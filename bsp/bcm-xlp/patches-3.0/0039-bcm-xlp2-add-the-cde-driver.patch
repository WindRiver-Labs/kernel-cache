From f83d9f2941cc34cc0b547d25d9632b66db545a3f Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 17:59:15 +0800
Subject: [PATCH 39/58] bcm-xlp2: add the cde driver

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/netlogic/nlm_cde/Makefile      |    6 +
 drivers/netlogic/nlm_cde/cdetest.c     |  246 +++++++
 drivers/netlogic/nlm_cde/nlm_cde.c     | 1170 ++++++++++++++++++++++++++++++++
 drivers/netlogic/nlm_cde/nlm_cde.h     |  100 +++
 drivers/netlogic/nlm_cde/nlm_cde_api.h |   67 ++
 5 files changed, 1589 insertions(+)

diff --git a/drivers/netlogic/nlm_cde/Makefile b/drivers/netlogic/nlm_cde/Makefile
new file mode 100644
index 0000000..bb1dc19
--- /dev/null
+++ b/drivers/netlogic/nlm_cde/Makefile
@@ -0,0 +1,6 @@
+EXTRA_CFLAGS += -DNLM_HAL_LINUX_KERNEL -Wno-undef
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/syslib/include
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/fmnlib
+EXTRA_CFLAGS += -Idrivers/netlogic/sae
+
+obj-$(CONFIG_XLP_CDE)	+= nlm_cde.o
diff --git a/drivers/netlogic/nlm_cde/cdetest.c b/drivers/netlogic/nlm_cde/cdetest.c
new file mode 100644
index 0000000..484350d
--- /dev/null
+++ b/drivers/netlogic/nlm_cde/cdetest.c
@@ -0,0 +1,246 @@
+/***********************************************************************
+Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_2#**********************************/
+/* Reference application for compression driver
+ * usage: mips64-nlm-linux-gcc  -g cdetest.c -o cdetest
+ *>../cdetest <inputfile>
+ */
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+
+static int sleep_usec = 100;
+static int LEN = 1024 * 16;
+static int dfd;
+struct nlm_cde_op
+{
+        unsigned int compression_type;
+        unsigned int sof;
+        unsigned int eof;
+};
+
+struct nlm_cde_op cde;
+
+void test()
+{
+        int i, ret, cd_fd;
+        unsigned char *buf;
+
+        for(i = 0; i < 10; i++)
+        {
+                ret = ioctl(dfd, i, (unsigned long)buf);
+	   	printf("ioctl %d bytes of data to devicee\n", ret);
+	        ret = read(dfd, buf, 10);
+	   	printf("read %d bytes of data to devicee\n", ret);
+	        ret = write(dfd, buf, 10);
+	   	printf("write %d bytes of data to devicee\n", ret);
+        }
+
+}
+
+static int cde_op(int op, char *buf, int len)
+{
+        int ret;
+
+        ret = ioctl(dfd, op, (unsigned long)&cde);
+
+	if (ret < 0) {
+		perror("can't ioctl");
+		return -1;
+	}
+
+	ret = write(dfd, buf, len);
+	if (ret < 0) {
+		perror("can't write to device");
+		return -1;
+	}
+	else {
+	   	printf("write %d bytes of data to devicee\n", ret);
+	}
+
+	return ret;
+}
+
+static int cde_result(char *buf, int len)
+{
+	int ret = 0;
+
+        while(ret == 0)
+        {
+                ret = read(dfd, buf, len);
+                if (ret < 0) {
+                        perror("can't read device");
+                        return -1;
+                }
+        }
+	printf("read %d bytes of data from devicee\n", ret);
+
+	return ret;
+}
+
+int main(int argc, char *argv[])
+{
+        char buf[LEN];
+	char buf1[LEN];
+        char buf2[LEN];
+	unsigned char *cde_mmap_mem = NULL;
+        int size = 0;
+
+	int tfd = open(argv[1], O_RDONLY);
+        int vfd = open("out.txt",O_WRONLY);
+        if (tfd < 0 || vfd < 0) {
+		perror("can't open test file");
+		return -1;
+	}
+
+        int data_len = read(tfd, buf, LEN);
+        if (data_len < 0) {
+		perror("can't read test file");
+		return -1;
+	}
+	else {
+	   	printf("read %d bytes of data from test file\n", data_len);
+	}
+
+	char *dev_name = "/dev/nlm_cde";
+	dfd = open(dev_name, O_RDWR);
+
+        if (dfd < 0) {
+		perror("can't open device");
+		return -1;
+	}
+//        test();
+  //      return 0;
+printf("\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n CDE TEST APPLICATION >>>>>>>>>>>>>>>>>\n");
+#if 1
+	size = ((1024 + 65) * 1024 ) *4;
+printf("\n size = %d\n", size);
+       cde_mmap_mem = mmap (0, size, PROT_READ | PROT_WRITE, MAP_SHARED, dfd, 0);
+       if(cde_mmap_mem)
+               strcpy(cde_mmap_mem, "HelloWorld\n");
+#endif
+
+        cde.compression_type = 1;
+        cde.sof = 1;
+        cde.eof = 1;
+
+	int ret = 0;
+        /*block_test();*/
+        if(0)
+        {
+        int i, num_blk = 2, data_len_ext, j = 0, def_len = 0;
+        data_len_ext = data_len /num_blk;
+        for(i = 0; i < num_blk; i++)
+        {
+                if (i ==0)
+                        cde.eof = 0;
+                if(i == (num_blk -1))
+                {
+                        cde.eof = 1;
+		        ret = cde_op(2, &buf[j], (data_len - (data_len_ext * i)));//deflate
+                }
+                else
+		        ret = cde_op(2, &buf[j], data_len_ext);//deflate
+	 	ret = cde_result(&buf1[def_len], LEN);
+                j += data_len_ext;
+                cde.sof = 0;
+                def_len += ret;
+        }
+        data_len = def_len;
+        data_len_ext = data_len /num_blk;
+        cde.sof = 1;
+        j = 0;
+        def_len = 0;
+        for(i = 0; i < num_blk; i++)
+        {
+                if (i ==0)
+                        cde.eof = 0;
+                if(i == (num_blk -1))
+                {
+                        cde.eof = 1;
+		        ret = cde_op(1, &buf1[j], (data_len - (data_len_ext * i)));//deflate
+                }
+                else
+		        ret = cde_op(1, &buf1[j], data_len_ext); //inflate
+	        if (ret < 0) break;
+
+	 	ret = cde_result(&buf2[def_len], LEN);
+	        if (ret < 0) break;
+                write(vfd, &buf2[def_len], ret);
+                j += data_len_ext;
+                cde.sof = 0;
+                def_len += ret;
+        }
+        return 0;
+        }
+
+	do
+        {
+		ret = cde_op(0xf0002, buf, data_len);//deflate
+	        //if (ret < 0) break;
+
+	        usleep(sleep_usec);
+
+	        char buf1[LEN];
+	 	ret = cde_result(buf1, LEN);
+	  //      if (ret < 0) break;
+
+	        usleep(sleep_usec);
+//                printf("read buf = %s ret = %d\n",buf1, ret );
+
+		ret = cde_op(0xf0001, buf1, ret); //inflate
+	        if (ret < 0) break;
+
+	        usleep(sleep_usec);
+
+	 	ret = cde_result(buf2, LEN);
+	        if (ret < 0) break;
+                write(vfd, buf2, ret);
+	}
+        while (0);
+
+	close(dfd);
+
+	if (ret <= 0) {
+	         printf("test aborted !\n");
+	         return -1;
+        }
+
+        if (ret != data_len) {
+	         printf("test failed: size mismatch !\n");
+	         return -1;
+        }
+
+        ret = memcmp(buf, buf2, data_len);
+        if (ret != 0) {
+	         printf("test failed: data mismatch !\n");
+	         return -1;
+        }
+
+	printf("test passed !\n");
+        return 0;
+}
+
+
diff --git a/drivers/netlogic/nlm_cde/nlm_cde.c b/drivers/netlogic/nlm_cde/nlm_cde.c
new file mode 100644
index 0000000..95d1588
--- /dev/null
+++ b/drivers/netlogic/nlm_cde/nlm_cde.c
@@ -0,0 +1,1170 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/errno.h>	/* for -EBUSY */
+#include <linux/ioport.h>	/* for request_region */
+#include <linux/delay.h>	/* for loops_per_jiffy */
+#include <linux/sched.h>
+#include <linux/ioctl.h>
+#include <asm/io.h>		/* for inb_p, outb_p, inb, outb, etc. */
+#include <asm/uaccess.h>	/* for get_user, etc. */
+#include <linux/init.h>		/* for __init, module_{init,exit} */
+#include <linux/poll.h>		/* for POLLIN, etc. */
+#include <nlm_msgring.h>
+#include <nlm_hal.h>
+#include <asm/mutex.h>
+
+#include <nlm_xlp.h>
+#include <nlm_hal_fmn.h>
+#include <nlm_hal_macros.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <nlm_hal_cde.h>
+#include <nlm_hal_fmn_dp.h>
+#include "nlm_cde.h"
+#include "nlm_cde_api.h"
+
+#define printf(a, b...) printk(KERN_ERR a, ##b)
+#define malloc(a) kmalloc(a, GFP_ATOMIC)
+#define free kfree
+
+#define L3_CACHELINE_SIZE 64
+#define L3_CACHELINE_MASK 0x3fULL
+#define VC_MODE_ROUND_ROBIN 1
+
+struct msgrng_msg {
+		__u64 msg0;
+		__u64 msg1;
+		__u64 msg2;
+		__u64 msg3;
+};
+
+static int xlp_cde_major;
+int xlp_cde_open(struct inode *, struct file *);
+int xlp_cde_release(struct inode *, struct file *);
+static long xlp_cde_ioctl(struct file *fptr, unsigned int type, unsigned long val);
+ssize_t xlp_cde_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
+ssize_t xlp_cde_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
+static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma);
+static unsigned char* cde_mem_start = NULL, *cde_mem_start_1, *cde_mem_start_2, *cde_mem_start_3, *cde_mem_start_4, *cde_mem_start_5, *cde_input_mem, *cde_output_mem, *cde_inf_input_mem, *cde_inf_output_mem, *cde_inf_mem_start;
+static unsigned int cde_mem_size, cde_mem_size_1, cde_mem_size_2, cde_mem_size_3, cde_mem_size_4, cde_mem_size_5;
+//static void test(void);
+
+int num_cde_engine;
+static cmp_data_t *cmp_data = NULL;
+
+struct nlm_cde_op
+{
+		unsigned int compression_type;
+		unsigned int sof;
+		unsigned int eof;
+};
+typedef struct free_page_structure {
+		char *data_array;
+} fr_page;
+
+volatile msg cmp_msg[MAX_NUM_MESSAGES]    __attribute__((aligned(32)));
+volatile fr_page page_array[MAX_NUM_PAGES]    __attribute__((aligned(32)));
+volatile char *(page_array_tmp_data_array[MAX_NUM_PAGES])__attribute__((aligned(32)));
+
+//#define CDE_DEBUG 1
+#ifdef CDE_DEBUG
+static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
+{
+	int k = 0;
+
+	//printk("\n %s", msg);
+	for(k = 0; k < len; k++)
+	{
+		printk(" %.2x",buf[k]);
+		if((k+1) % 16 == 0)
+		printk("\n");
+	}
+	printk("\n");
+}
+#endif
+
+static void *
+get_cache_aligned_mem(size_t size)
+{
+	void *addr, **tmp;
+	uint64_t loc;
+	addr = malloc(size + L3_CACHELINE_SIZE * 2);
+
+	if (addr == NULL) {
+		printk(KERN_ERR
+		"\n Malloc failed for cache aligned memory allocation");
+		return NULL;    //NLM_ERR_NO_MEM;
+	}
+	loc = (uint64_t) addr;
+	loc = (loc + L3_CACHELINE_SIZE - 1) & ~L3_CACHELINE_MASK;
+
+	tmp = (void **) loc;
+
+	*tmp = addr;
+
+	loc += L3_CACHELINE_SIZE;
+
+	addr = (void *) loc;
+
+	return addr;
+}
+
+static void
+free_cache_aligned_mem(void *addr)
+{
+	uint64_t loc;
+
+	loc = (uint64_t) addr;
+
+	loc -= 64;
+
+	addr = (void *) loc;
+
+	addr = (void *) *(uint64_t*) addr;
+
+	free(addr);
+}
+
+static int
+cde_get_fb_vc(void)
+{
+	int vc, cpu;
+
+	vc = RTN_BKT;
+	cpu = hard_smp_processor_id();
+	cpu = cpu * 4 + vc;
+	return cpu;
+}
+
+static const struct file_operations xlp_cde_fops = {
+	.owner = THIS_MODULE,
+	.open = xlp_cde_open,
+	.read = xlp_cde_read,
+	.write = xlp_cde_write,
+	.compat_ioctl = xlp_cde_ioctl,
+	.mmap = xlp_cde_mmap,
+	.release = xlp_cde_release,
+};
+
+
+static int config_cmp(void)
+{
+	int i;
+
+#ifdef CDE_DEBUG
+	printk("config_cmp \n");
+#endif
+	for(i = 0; i < num_cde_engine; i++)
+	{
+		unsigned int val;
+		if(is_nlm_xlp9xx())
+			val = nlm_hal_9xx_read_cde_reg(CMP_REG_CTRL_REG(i));
+		else
+			val = nlm_hal_read_cde_reg(CMP_REG_CTRL_REG(i));
+#ifdef CDE_DEBUG
+		printk("config_cmp i = %d cntrl_reg val = %x\n", i, val);
+#endif
+		if(is_nlm_xlp9xx())
+			val = nlm_hal_9xx_read_cde_reg(CMP_REG_SCRATCH_PAGE(i));
+		else
+			val = nlm_hal_read_cde_reg(CMP_REG_SCRATCH_PAGE(i));
+#ifdef CDE_DEBUG
+		printk("config_cmp i = %d scratch_reg val = %x\n", i, val);
+#endif
+		if(is_nlm_xlp9xx()){
+			nlm_hal_9xx_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | FD_CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
+			nlm_hal_9xx_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), ((SCRATCH_SIZE/64 << 17) | (16 << 9)));
+		}
+		else
+		{
+			nlm_hal_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | FD_CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
+			nlm_hal_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), ((SCRATCH_SIZE/64 << 17) | (16 << 9)));
+		}
+	}
+	return 0;
+}
+
+static int send_message_1(int stid, struct msgrng_msg *msg)
+{
+	int ret = 0;
+	unsigned long __attribute__ ((unused)) mflags;
+
+#ifdef CDE_DEBUG
+	printk("send_message = stid = 0x%x msg0 %llx\n",stid, msg->msg0);
+#endif
+	msgrng_access_enable(mflags);
+	nlm_hal_cde_send_request_1(stid, msg->msg0);
+	msgrng_access_disable(mflags);
+
+	return ret;
+}
+
+static int send_message_2(int stid, struct msgrng_msg *msg)
+{
+	int ret = 0;
+	unsigned long __attribute__ ((unused)) mflags;
+
+#ifdef CDE_DEBUG
+	printk("send_message = stid = 0x%x msg = %llx msg1 %llx\n",stid, msg->msg0, msg->msg1);
+#endif
+	msgrng_access_enable(mflags);
+	nlm_hal_cde_send_request_2(stid, msg->msg0, msg->msg1);
+	msgrng_access_disable(mflags);
+
+	return ret;
+}
+
+
+static int send_free_desc(void)
+{
+	int i;
+	int status = 0;
+	int stid;
+	struct msgrng_msg fd_msg;
+
+	// send free descriptors to cmp block
+	for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
+		if (!page_array[i].data_array)
+			page_array[i].data_array = get_cache_aligned_mem(FD_CMP_PAGE_SIZE);
+		if (!page_array[i].data_array)	{
+			printk("cacheline_aligned_kmalloc returmed error desc_num = %d\n", i);
+			return -1;
+		}
+
+		stid = nlm_hal_cde_make_fd_msg((uint64_t*)&fd_msg.msg0, (uint64_t)virt_to_phys(page_array[i].data_array));
+#ifdef CDE_DEBUG
+		printk("Free descriptor message [%0d] = 0x%016llx\n", i, fd_msg.msg0);
+#endif
+
+		if(is_nlm_xlp2xx())
+			status = send_message_1(MSGRNG_2XX_STNID_CMP1, &fd_msg);
+		else if(is_nlm_xlp9xx())	
+			status = send_message_1(MSGRNG_9XX_STNID_CMP1, &fd_msg);
+		else
+			status = send_message_1(MSGRNG_STNID_CMP1, &fd_msg);
+
+		if (status != 0) {
+			printk("[%s@%d]: Free descriptor (%d) didnt not reach cmpm status=%0d\n",
+					__FUNCTION__, __LINE__, i, status);
+			return -1;
+		}
+	}
+
+#ifdef CDE_DEBUG
+	printk("[%s@%d]: Sent %d free desc to comp engine\n",
+			__FUNCTION__, __LINE__, i);
+#endif
+
+	return 0;
+}
+
+
+int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of_file)
+{
+	int num_messages, num_desc, num_blk;
+	int i,j,k,stid;
+
+	int rtn_bkt;
+
+	int cur_blk = 0;
+	int cur_desc = 0;
+
+	int eof  = 0;
+	int sod  = 0;
+	int sob  = 0;
+	int eob  = 0;
+	int save = 0;
+	int restore = 0;
+
+	int desc_idx = 0;
+	int length = 0;
+	int start = 0;
+	int div;
+
+	/* Number of block and number of messages are always 1.
+	   User is expected to send one block at a time */
+	num_blk = num_desc = num_messages = 1;
+	div = num_blk * num_desc;
+
+	rtn_bkt = cde_get_fb_vc();
+	type = 1;
+	if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
+	{
+		printk("ERROR:src_size = %d if more than %d. No space to store\n", (int)cmp_data->src_size, (int)MAX_INPUT_BUFFER_SIZE);
+		return 0;
+	}
+	num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
+	for (i = 0; i < num_messages; i++) {
+		//create scratch page descriptor
+		cur_desc = 0;
+		restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
+		length = SCRATCH_SIZE ;
+		cmp_data->src_desc[desc_idx] =
+			cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch_inf)));
+#ifdef CDE_DEBUG
+		printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n",
+				cmp_data->scratch_inf, virt_to_phys(cmp_data->scratch_inf), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0]));
+#endif
+		cur_desc++;
+
+		for (j = 0; j < num_blk; j++) {
+			for (k = 0; k < num_desc; k++) {
+				eof = end_of_file;
+
+				sod = 1;//(start == 0);
+				sob = (k == 0);
+				eob = (k == num_desc-1);
+				save = ((eob == 1) & (end_of_file == 0)); //((eof == 0) & (eob == 1));
+				restore = 0; //restore only can be 1 on scratch descriptor
+				//save = 0;
+				length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+
+				cmp_data->src_desc[cur_desc] =
+					cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
+				//printk("data_desc_1 = %llx\n",cmp_data->src_desc[cur_desc]);
+
+#ifdef CDE_DEBUG
+				printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
+						__FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
+
+				printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
+						__FUNCTION__, __LINE__,
+						cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
+#endif
+
+				start = start + length;
+				cur_desc++;
+			}
+
+			cur_blk++;
+		}
+
+		//if (cpu_is_xlp9xx())
+		if (is_nlm_xlp9xx())
+		{	
+			stid = nlm_hal_9xxcde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, (uint64_t*)&cmp_msg[i].msg1, 0, cmp_data->op, rtn_bkt,
+					cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+			printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx  cmp_msg.msg1 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0, cmp_msg[i].msg1);
+#endif
+		}
+		else
+		{
+			stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
+					cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+			printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0);
+#endif
+		}
+		desc_idx = desc_idx + cur_desc;
+	}
+
+
+	//    if (is_nlm_xlp9xx())
+	//	num_messages = 2;
+	// returns the number of messages created
+	return (num_messages);
+}
+
+int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of_file)
+{
+	int num_messages, num_desc, num_blk;
+	int i,j,k,stid;
+
+	int rtn_bkt;
+
+	int cur_blk = 0;
+	int cur_desc = 0;
+
+	int eof  = 0;
+	int sod  = 0;
+	int sob  = 0;
+	int eob  = 0;
+	int save = 0;
+	int restore = 0;
+
+	int desc_idx = 0;
+	int length = 0;
+	int start = 0;
+	int div;
+
+	num_blk = num_desc = num_messages = 1;
+	div = num_blk * num_desc;
+
+	rtn_bkt = cde_get_fb_vc();
+
+	if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
+	{
+		printk("ERROR:src_size if more than %d. No space to store\n", MAX_INPUT_BUFFER_SIZE);
+		return 0;
+	}
+	num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
+	for (i = 0; i < num_messages; i++) {
+		//create scratch page descriptor
+		cur_desc = 0;
+		restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
+		length = SCRATCH_SIZE ;
+
+		cmp_data->src_desc[desc_idx] =
+			cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch)));
+
+#ifdef CDE_DEBUG
+		printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n",
+				cmp_data->scratch, virt_to_phys(cmp_data->scratch), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0]));
+#endif
+
+		cur_desc++;
+
+		for (j = 0; j < num_blk/num_messages; j++) {
+			for (k = 0; k < num_desc; k++) {
+				eof = end_of_file;
+
+				sod = 1;//(start == 0);
+				sob = (k == 0);
+				eob = (k == num_desc-1);
+				save = ((type == CDE_STATIC) & (eof == 0) & (eob == 1));
+				restore = 0; //restore only can be 1 on scratch descriptor
+
+				length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+				cmp_data->src_desc[cur_desc] =
+					cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
+
+				if (type == CDE_DYNAMIC) {//for dynamic duplicate desc and set type to 3
+					save = ( (eob == 1) & (eof == 0)) ;
+					cmp_data->src_desc[cur_desc+num_desc] = cpu_to_be64(nlm_hal_cde_make_data_desc ( eof, 3, 1/*sod*/, sob, save, 0, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
+#ifdef CDE_DEBUG
+					printf("cur_desc = %0d, i = %0d, j = %0d, k = %0d, src_desc[%0d] = 0x%016llx \n",
+							cur_desc, i, j, k, cur_desc+num_desc, (long long unsigned int)cmp_data->src_desc[cur_desc+num_desc]);
+#endif
+				}
+
+#ifdef CDE_DEBUG
+				printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
+						__FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
+
+				printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
+						__FUNCTION__, __LINE__,
+						cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
+#endif
+				start = start + length;
+				cur_desc++;
+			}
+
+			if (type == CDE_DYNAMIC) {//dynamic has 2x descriptors
+				cur_desc = cur_desc + num_desc;
+			}
+
+			cur_blk++;
+		}
+
+		//if (cpu_is_xlp9xx())
+		if (is_nlm_xlp9xx())
+		{
+			stid = nlm_hal_9xxcde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0,(uint64_t*)&cmp_msg[i].msg1, 0, cmp_data->op, rtn_bkt,
+					cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+			printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx cmp_msg.msg1 = 0x%016llx\n",
+					__FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0, cmp_msg[i].msg1);
+#endif
+		}
+		else
+		{
+			stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
+					cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+			printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n",
+					__FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0);
+#endif
+		}
+		desc_idx = desc_idx + cur_desc;
+	}
+
+	//if (is_nlm_xlp9xx())
+	//	num_messages = 2;
+	// returns the number of messages created
+	return (num_messages);
+}
+
+
+volatile uint64_t used_fd[NUM_FREE_DESCRIPTORS] __attribute__((aligned(32)));
+void return_free_descriptors(msg *msg_list, int msg_index)
+{
+	int i, j, k, status, num_desc;
+	msg return_msg, fd_msg;
+	uint64_t * temp_desc;
+	uint64_t dest_desc;
+	int used_fd_index = 0;
+
+
+	for (i = 0; i < msg_index; i++) {
+
+		memcpy ((void *) &return_msg, (void *)(msg_list+i), sizeof(msg));
+
+		if(is_nlm_xlp9xx())
+		{
+			used_fd[used_fd_index++] = ((uint64_t) return_msg.msg0 & 0xffffffffffUll);
+			num_desc = (return_msg.msg0>>40 & 0xffff);
+		}
+		else
+		{
+			used_fd[used_fd_index++] = ((uint64_t) return_msg.msg1 & 0xffffffffffUll);
+			num_desc = (return_msg.msg1>>40 & 0xffff);
+		}
+
+		if(is_nlm_xlp9xx())
+			temp_desc = (uint64_t *) phys_to_virt(return_msg.msg0 & 0xffffffffffUll);
+		else
+			temp_desc = (uint64_t *) phys_to_virt(return_msg.msg1 & 0xffffffffffUll);
+
+		for (j = 0; j< num_desc; j++) {
+			dest_desc = temp_desc[j];
+			used_fd[used_fd_index++] = ((uint64_t) dest_desc & 0xffffffffffUll);
+		}
+
+
+		if (used_fd_index > FD_BURST_SIZE) {
+			for (k = 0; k < used_fd_index; k++) {
+				fd_msg.msg0 = ((uint64_t) used_fd[k]);
+				if(is_nlm_xlp2xx())
+					status = send_message_1(MSGRNG_2XX_STNID_CMP1, &fd_msg);
+				else if(is_nlm_xlp9xx())
+					status = send_message_1(MSGRNG_9XX_STNID_CMP1, &fd_msg);
+				else
+					status = send_message_1(MSGRNG_STNID_CMP1, &fd_msg);
+				if (status != 0)
+					printk("Return free descriptor didnt not reach cmp! status=%0d\n", status);
+			}
+			used_fd_index = 0;
+		}
+	}
+}
+
+
+static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
+{
+	uint64_t i,j,num_bytes;
+	int offset = 0;
+	uint64_t *desc, dest_addr;
+	int num_desc = (payload >> 40) & 0x1fff;
+	char * tmp_ptr;
+	for (i = 0; i < num_desc; i++) {
+		desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
+		*desc = cpu_to_be64(*desc);
+		num_bytes = (*desc >> 40) & 0xffff;
+		dest_addr = *desc & 0xffffffffffUll;
+		tmp_ptr = (char *) phys_to_virt(dest_addr & 0xffffffffffUll);
+
+#if CDE_DEBUG
+		printk(" desc addr = %llx\n",desc);
+		printk("\n num_bytes = %d\n",num_bytes);
+		printk("\n num_desc = %d\n",num_desc);
+		printk("\n tmp_ptr = %llx\n",tmp_ptr);
+		dump_buffer(tmp_ptr, num_bytes, "output:");
+#endif
+		for (j = 0; j < num_bytes; j++) {
+			buffer[offset+j] = tmp_ptr[j]; //AGN: make it Memcpy, and need to check perf difference
+		}
+		offset = offset + num_bytes;
+	}
+	return offset;
+}
+
+/* Due compiler warning it is declraed globally */
+struct msgrng_msg msg_list_g[MAX_NUM_MESSAGES];
+		static void
+nlm_xlp_cde_msgring_handler(uint32_t vc, uint32_t src_id,
+				uint32_t size, uint32_t code,
+				uint64_t msg0, uint64_t msg1,
+				uint64_t msg2, uint64_t msg3, void *data)
+{
+	struct msgrng_msg *msg, temp_msg;
+	int last = 0;
+	int msg_index = 0;
+	int offset = cmp_data->target_size;
+
+#ifdef CDE_DEBUG
+	printk("nlm_xlp_cde_msgring_handler = vc = %d, src_id = %d size = %d code = %d msg0 = %llx, msg1 = %llx msg2 = %llx\n", vc, src_id, size, code, msg0, msg1, msg2);
+#endif
+
+	msg = (struct msgrng_msg *)&temp_msg;
+	msg->msg0 = msg0;
+	msg->msg1 = msg1;
+
+	last = ((msg->msg0 >> 63) & 0x1ULL);
+
+#ifdef CDE_DEBUG
+	printk("[%s@%d]: last = %d offset = %d target_size = %d\n", __FUNCTION__, __LINE__, last, offset, cmp_data->target_size);
+#endif
+
+	offset = cmp_data->target_size;
+	if (cpu_is_xlp9xx())
+		cmp_data->target_size += nlm_hal_cde_read_cmp_msg((char *) cmp_data->target + offset, msg->msg0);
+	else
+		cmp_data->target_size += nlm_hal_cde_read_cmp_msg((char *) cmp_data->target + offset, msg->msg1);
+
+#ifdef CDE_DEBUG
+	printk("cmp_data->target_size = %d\n",cmp_data->target_size);
+	dump_buffer((char *) (cmp_data->target + offset), cmp_data->target_size, "returned data:");
+#endif
+
+	memcpy((void *)&msg_list_g[msg_index++],(void *)msg, sizeof(struct msgrng_msg));
+
+	return_free_descriptors(msg_list_g, msg_index);
+#ifdef CDE_DEBUG
+	printk("[\n%s@%d]:end of phnx_msgring_comp_int_handler\n", __FUNCTION__, __LINE__);
+#endif
+}
+
+cmp_data_t* nlm_cde_init()
+{
+	cmp_data = (cmp_data_t *) kmalloc(sizeof(cmp_data_t), GFP_KERNEL);
+	if (!cmp_data)
+		return NULL;
+	memset(cmp_data, 0, sizeof(cmp_data_t));
+
+	cmp_data->src = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_INPUT_BUFFER_SIZE));
+	if (! cmp_data->src)	{
+		printk("kmalloc returns Error : cmp_data->src\n");
+		kfree(cmp_data);
+
+		return NULL;
+	}
+
+	cmp_data->target = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_BUFFER_SIZE));
+	if (! cmp_data->target)	{
+		printk("kmalloc returns Error : cmp_data->target\n");
+		kfree(cmp_data->src);
+		kfree(cmp_data);
+		return NULL;
+	}
+	cmp_data->src_desc = kmalloc(CMP_PAGE_SIZE , GFP_KERNEL);
+	if (! cmp_data->src_desc)	{
+		printk("kmalloc returns Error : cmp_data->src_desc\n");
+		kfree(cmp_data->src);
+		kfree(cmp_data->target);
+		kfree(cmp_data);
+		return NULL;
+	}
+	cmp_data->scratch = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
+	cmp_data->scratch_inf = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
+	if (! cmp_data->scratch || !cmp_data->scratch_inf)	{
+		printk("kmalloc returns Error : cmp_data->scratch\n");
+		kfree(cmp_data->src);
+		kfree(cmp_data->target);
+		kfree(cmp_data->src_desc);
+		kfree(cmp_data);
+		return NULL;
+	}
+
+	cde_mem_size_1 = cde_mem_size_3 = MAX_INPUT_BUFFER_SIZE;
+	cde_mem_size_2 = cde_mem_size_4 = MAX_BUFFER_SIZE;
+	cde_mem_size_5 = (sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int)) * 2;
+	cde_mem_size = cde_mem_size_5 + cde_mem_size_1 + cde_mem_size_2 + cde_mem_size_3 + cde_mem_size_4;
+
+	if(cde_mem_size_5 < PAGE_SIZE) cde_mem_size_5 = PAGE_SIZE;
+
+	cde_input_mem = cde_mem_start_1 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_1));
+	if(cde_mem_start_1 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_1);
+		return NULL;
+	}
+	cde_output_mem = cde_mem_start_2 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_2));
+	if(cde_mem_start_2 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_2);
+		return NULL;
+	}
+	cde_inf_input_mem = cde_mem_start_3 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_3));
+	if(cde_mem_start_3 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_3);
+		return NULL;
+	}
+	cde_inf_output_mem = cde_mem_start_4 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_4));
+	if(cde_mem_start_4 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_4);
+		return NULL;
+	}
+	cde_mem_start = cde_mem_start_5 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_5));
+	if(cde_mem_start_5 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_5);
+		return NULL;
+	}
+	cde_inf_mem_start = cde_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
+
+	memset(cmp_data->src, 0, MAX_INPUT_BUFFER_SIZE);
+	memset(cmp_data->target, 0, MAX_BUFFER_SIZE);
+
+	memset(cmp_data->src_desc, 0, CMP_PAGE_SIZE);
+	memset(cmp_data->scratch, 0, SCRATCH_SIZE);
+	memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
+
+	if (config_cmp() == -1)
+		return NULL;
+
+	if (send_free_desc() == -1)
+		return NULL;
+
+	return cmp_data;
+}
+
+int xlp_cde_open(struct inode *inode, struct file *filp)
+{
+#ifdef CDE_DEBUG
+	printk("xlp_cde_open \n");
+#endif
+
+		return 0;
+}
+
+
+void nlm_cde_cleanup(cmp_data_t *cmp_data)
+{
+	int i;
+	if (cmp_data->src)
+		free_pages ((ulong)cmp_data->src, get_order (MAX_INPUT_BUFFER_SIZE));
+	if (cmp_data->target)
+		free_pages ((ulong)cmp_data->target, get_order (MAX_BUFFER_SIZE));
+	if (cmp_data->src_desc)
+		kfree(cmp_data->src_desc);
+	if (cmp_data->scratch)
+		kfree(cmp_data->scratch);
+	if (cmp_data->scratch_inf)
+		kfree(cmp_data->scratch_inf);
+
+	free_pages((ulong)cde_mem_start_1, get_order(cde_mem_size_1));
+	free_pages((ulong)cde_mem_start_2, get_order(cde_mem_size_2));
+	free_pages((ulong)cde_mem_start_3, get_order(cde_mem_size_3));
+	free_pages((ulong)cde_mem_start_4, get_order(cde_mem_size_4));
+	free_pages((ulong)cde_mem_start_5, get_order(cde_mem_size_5));
+
+	cmp_data->src = NULL;
+	cmp_data->target = NULL;
+	cmp_data->src_desc = NULL;
+	cmp_data->scratch = NULL;
+	cmp_data->scratch_inf = NULL;
+
+	if (cmp_data)
+		kfree(cmp_data);
+
+	for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
+		if (page_array[i].data_array)	{
+			free_cache_aligned_mem((void*)page_array[i].data_array);
+			page_array[i].data_array = NULL;
+		}
+	}
+}
+
+
+static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma)
+{
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long size = 0;
+	int result = 0, result_t = 0;
+	unsigned long cde_pfn_addr = 0, vm_start = vma->vm_start;
+	if (cde_mem_size <= 0) return -ENXIO;
+
+	if (offset >= cde_mem_size) return -ESPIPE;
+
+	if (vma->vm_flags & VM_LOCKED) return -EPERM;
+
+	size = vma->vm_end - vma->vm_start;
+//	printk("\n %s size = %d cde_mem_size = %d", __FUNCTION__, size, cde_mem_size);
+	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
+	pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
+
+//	printk("\n %s  %d", __FUNCTION__, __LINE__);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_1 >> PAGE_SHIFT);
+	result = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_1,
+			vma->vm_page_prot);
+//	printk("\n %s  %d", __FUNCTION__, __LINE__);
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_1);
+
+	cde_pfn_addr = ((uint64_t)cde_mem_start_2 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_2,
+			vma->vm_page_prot);
+//	printk("\n %s  %d", __FUNCTION__, __LINE__);
+
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_2);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_3 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_3,
+			vma->vm_page_prot);
+//	printk("\n %s  %d", __FUNCTION__, __LINE__);
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_3);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_4 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_4,
+			vma->vm_page_prot);
+//	printk("\n %s  %d", __FUNCTION__, __LINE__);
+
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_4);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_5 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_5,
+			vma->vm_page_prot);
+//	printk("\n %s  %d", __FUNCTION__, __LINE__);
+	vma->vm_start = vm_start;
+	if (result) return -EAGAIN;
+
+	return 0;
+}
+
+int xlp_cde_release(struct inode *inode, struct file *filp)
+{
+	cmp_data->target_size = 0;
+	cmp_data->offset = 0;
+	memset(cmp_data->scratch, 0,  SCRATCH_SIZE);
+	memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
+	return 0;
+}
+
+unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, unsigned char *buf, unsigned int count)
+{
+	int size = 0;
+	if(cmp_data->target_size)
+	{
+		size = (count < cmp_data->target_size) ? count : cmp_data->target_size;
+
+		memcpy(buf, &cmp_data->target[cmp_data->offset], size);
+#ifdef CDE_DEBUG
+		printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->target_size, size);
+		dump_buffer(cmp_data->target, size, "Output:");
+#endif
+		cmp_data->offset += size;
+		cmp_data->target_size = cmp_data->target_size - size;
+		if(cmp_data->target_size == 0)
+			cmp_data->offset = 0;
+
+		return size;
+	}
+	else
+	{
+		cmp_data->offset = 0;
+		return 0;
+	}
+}
+
+ssize_t xlp_cde_read(struct file *filp, char __user *buf,
+				size_t count, loff_t *f_pos)
+{
+	unsigned char temp_buf[count+1];
+	int size;
+	size = nlm_cde_receive_response(cmp_data, (unsigned char*)temp_buf, count);
+	if(count >= size)
+	{
+		if (copy_to_user(buf, temp_buf, size)) {
+			printk("copy_to_user failed\n");
+			size = -EFAULT;
+		}
+	}
+	return size;
+}
+
+unsigned int nlm_cde_send_request(cmp_data_t *cmp_data, unsigned int op,
+		unsigned int type,
+		unsigned int sof,
+		unsigned int eof,
+		unsigned char *src_buf,
+		unsigned int size)
+{
+	int i;
+	int num_messages = 0;
+
+	memcpy(cmp_data->src, src_buf, size);
+	cmp_data->src_size = size;
+
+#ifdef CDE_DEBUG
+	printk("xlp_cde_write count = %d\n", size);
+	dump_buffer(cmp_data->src, cmp_data->src_size, "\nInput Buf:");
+	printk("write: cmp_data->compression_type = %d cmp_data->sof = %d, cmp_data->eof = %d\n",cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+#endif
+
+	if(cmp_data->op == 0/*CDE_INFLATE*/)
+		num_messages = create_inf_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+	else
+		num_messages = create_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+
+	// send message
+	for (i = 0; i < num_messages; i++) {
+
+		int status;
+		if(is_nlm_xlp2xx())
+			status =  send_message_1(MSGRNG_2XX_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+		else
+			if(is_nlm_xlp9xx())
+				status =  send_message_2(MSGRNG_9XX_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+			else
+				status =  send_message_1(MSGRNG_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+#ifdef CDE_DEBUG
+		printk("write: status = %x\n", status);
+#endif
+		if (status != 0) {
+			printk("Cmp Message didnt not reach cmp, status=%0d\n", status);
+		}
+	}
+
+	return size;
+}
+
+ssize_t xlp_cde_write(struct file *filp, const char __user *buf,
+		size_t count, loff_t *f_pos)
+{
+	unsigned char temp_buf[count+1];
+	if (copy_from_user(temp_buf, buf, count)) {
+		printk("copy from user failed \n");
+		return -EFAULT;
+	}
+
+	return nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)temp_buf, count);
+}
+
+
+static long xlp_cde_ioctl(struct file *filp,
+		unsigned int cmd, unsigned long arg)
+{
+	int err = 0, i = 0, sanity_test = 0;
+	struct nlm_cde_op *cde;
+	unsigned int input_size = 0, output_size = 0, size;
+	unsigned char *input_mem, *output_mem, *mem_start;
+
+#ifdef CDE_DEBUG
+	printk("xlp_cde_ioctl: cmd = %x\n", cmd);
+#endif
+	if(cmd &0xf0000)
+	{
+		cmd = cmd & 0xf;
+		sanity_test = 1;
+	}
+	switch(cmd) {
+
+		case CDE_INFLATE:
+			cmp_data->op = 0;
+			input_mem = cde_inf_input_mem;
+			output_mem = cde_inf_output_mem;
+			mem_start = cde_inf_mem_start;
+			break;
+
+		case CDE_DEFLATE:
+			cmp_data->op = 1;
+			input_mem = cde_input_mem;
+			output_mem = cde_output_mem;
+			mem_start = cde_mem_start;
+			break;
+		default:
+			printk("xlp_cde_ioctl: default\n");
+			return -ENOTTY;
+	}
+	cde = (struct nlm_cde_op*)mem_start;
+	input_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op));
+	output_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int));
+
+#ifdef CDE_DEBUG
+	printk("cde.compression_type = %d cde.sof = %d, cde.eof = %d\n",cde->compression_type, cde->sof, cde->eof);
+#endif
+	if(sanity_test)
+		cde = (struct nlmcde*)arg;
+
+	cmp_data->compression_type = cde->compression_type;
+	cmp_data->sof = cde->sof;
+	cmp_data->eof = cde->eof;
+#ifdef CDE_DEBUG
+	printk("cde.compression_type = %d cde.sof = %d, cde.eof = %d\n",cde->compression_type, cde->sof, cde->eof);
+#endif
+	if(!sanity_test)
+	{
+		size = nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)input_mem, input_size);
+#ifdef CDE_DEBUG
+		printk("#written %d byte of data\n", size);
+#endif
+		size = 0;
+		do{
+			size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
+			i++;
+		}while(size == 0 && i < 0xffffff);
+		*(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int)) = size;
+#ifdef CDE_DEBUG
+		printk("Read %d byte of data\n", size);
+		dump_buffer(cmp_data->scratch_inf, SCRATCH_SIZE, "Inf Scratch:");
+#endif
+	}
+
+	return err;
+}
+
+
+#if 0
+static unsigned strtonum(char c)
+{
+	if(c >= '0' && c <= '9')
+		return (c - '0');
+
+	if(c >= 'A' && c <= 'F')
+		return (c - 'A' + 10);
+
+	if(c >= 'a' && c <= 'f')
+		return (c - 'a' + 10);
+}
+static void test()
+{
+	int i = 0;
+	unsigned int input_size = 0, output_size = 0, size;
+	unsigned char *input_mem, *output_mem, *mem_start;
+
+	input_mem = cde_inf_input_mem;
+	output_mem = cde_inf_output_mem;
+	mem_start = cde_inf_mem_start;
+
+	input_size = sizeof(src_gz_data)/2;//200;
+	output_size = MAX_BUFFER_SIZE;
+	for(i = 0; i < (input_size*2); i=i+2)
+	{
+		input_mem[i/2] = (strtonum(src_gz_data[i]) << 4) | strtonum(src_gz_data[i+1]);
+	}
+	//dump_buffer(input_mem, input_size, "input:");
+	size = nlm_cde_send_request(cmp_data, 0, 1, 1, 1, (unsigned char*)input_mem, input_size);
+	printk("written %d byte of data\n", size);
+	size = 0;
+	do{
+		size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
+		i++;
+	}while(size == 0 && i < 0xffffff);
+	printk("Read %d byte of data\n", size);
+	//dump_buffer(output_mem, size, "output:");
+
+}
+#endif
+void xlp_cde_dev_initialize(void) 
+{
+	int i =0;
+	unsigned int ret;
+	int frequency = 0;
+	int __maybe_unused node = 0;
+
+	for(i = 0; i < num_cde_engine; i++)
+	{
+		if(is_nlm_xlp9xx())
+			ret = nlm_hal_9xx_read_cde_reg(CMP_REG_RESET_REG(i));
+		else	
+			ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
+#ifdef CDE_DEBUG
+		printk("reset_reg = ret = %x\n", ret);
+#endif
+		if(is_nlm_xlp9xx())
+			nlm_hal_9xx_write_cde_reg(CMP_REG_RESET_REG(i), 0x8);
+		else
+			nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x8);
+		do {
+			if(is_nlm_xlp9xx())
+				ret = nlm_hal_9xx_read_cde_reg(CMP_REG_RESET_REG(i));
+			else
+				ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
+#ifdef CDE_DEBUG
+			printk("reset_reg = ret = %x\n", ret);
+#endif
+			if (((ret >> 4) & 0x1) == 1)
+				break;
+		} while (1);
+
+		/* TBD: commented for time being as there is no entry in FDT for cde frequency*/
+		frequency = nlm_hal_get_fdt_freq(fdt, NLM_CDE);
+		//printk("\n CDE Frequency = %d\n",frequency);
+		//nlm_hal_set_cde_freq(node, frequency);
+
+		if(is_nlm_xlp9xx())
+		{
+			nlm_hal_9xx_write_cde_reg(CMP_REG_RESET_REG(i), 0x01);
+			nlm_hal_9xx_write_cde_reg(CMP_REG_RESET_REG(i), 0x00);
+		}
+		else
+		{
+			nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x01);
+			nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x00);
+		}
+	}
+	nlm_cde_init();
+}
+
+//static struct class *dev_class;
+static int __init xlp_cde_init(void)
+{
+	printk(KERN_ERR ",\n XLP CDE Initialization \n");
+
+	xlp_cde_major = register_chrdev(0, "NLM_XLP_CDE", &xlp_cde_fops);
+	if (xlp_cde_major < 0) {
+		printk(KERN_ERR "XLP_CDE - cannot register device\n");
+		return xlp_cde_major;
+	}
+	printk (KERN_ERR "XLP CDE MAJOR NUMBER %d\n", xlp_cde_major);
+#if 0
+	if(0){
+		dev_t dev = MKDEV(xlp_cde_major, 0);
+		dev_class = class_create(THIS_MODULE, "chardrv");
+		if(dev_class == NULL)
+			printk("\n Class creation failed\n");
+		if(device_create(dev_class, NULL, dev, NULL, "nlm_cde") == NULL)
+			printk("\n Device creation failed\n");
+	}
+#endif
+
+	if (register_xlp_msgring_handler
+			(XLP_MSG_HANDLE_CMP, nlm_xlp_cde_msgring_handler, NULL)) {
+		panic("can't register msgring handler for XLP_MSG_HANDLE_CMP");
+	}
+	printk("xlp_cde_init done\n\n");
+	if(is_nlm_xlp2xx())
+		num_cde_engine = NUM_CDE_ENGINE_XLP2XX;
+	else if (cpu_is_xlp9xx())
+		num_cde_engine = NUM_CDE_ENGINE_XLP9XX;
+	else
+		num_cde_engine = NUM_CDE_ENGINE;
+
+	xlp_cde_dev_initialize();
+
+	return 0;
+}
+
+static void __exit xlp_cde_cleanup(void)
+{
+	/*TEMP*/
+	nlm_cde_cleanup(cmp_data);
+	unregister_chrdev(xlp_cde_major, "NLM_XLP_CDE");
+}
+
+module_init(xlp_cde_init);
+module_exit(xlp_cde_cleanup);
+MODULE_DESCRIPTION("XLP Hardware CDE Support.");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
+MODULE_AUTHOR("Broadcom");
diff --git a/drivers/netlogic/nlm_cde/nlm_cde.h b/drivers/netlogic/nlm_cde/nlm_cde.h
new file mode 100644
index 0000000..a35a7b6
--- /dev/null
+++ b/drivers/netlogic/nlm_cde/nlm_cde.h
@@ -0,0 +1,100 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef _NLM_CDE_H_
+#define _NLM_CDE_H_
+
+#define NUM_VC 8
+#define NLM_CDE_VC_BASE 297
+#define NUM_CDE_ENGINE 4
+#define NUM_CDE_ENGINE_XLP2XX 	1
+#define NUM_CDE_ENGINE_XLP9XX 	3
+
+#define CDE_INFLATE 			1
+#define CDE_DEFLATE 			2
+
+#define CDE_NON      0
+#define CDE_STATIC   1
+#define CDE_DYNAMIC  2
+#define CDE_DYNAMIC2 3
+
+#define CMP_REG_SCRATCH_PAGE(i)  (0x47 + i * 0x10)
+#define CMP_REG_RESET_REG(i)     (0x4c + i * 0x10)
+#define CMP_REG_CTRL_REG(i)	(0x41 + (i * 0x10))
+
+#define MSGRNG_STNID_CMP0 XLP_STNID_CMP
+#define MSGRNG_STNID_CMP1 (XLP_STNID_CMP + 4)
+
+#define MSGRNG_9XX_STNID_CMP0 XLP_9XX_CMP_VC_BASE 
+#define MSGRNG_9XX_STNID_CMP1 (MSGRNG_9XX_STNID_CMP0 + 3)
+
+#define MSGRNG_2XX_STNID_CMP0 XLP_2XX_CDE_VC_BASE
+#define MSGRNG_2XX_STNID_CMP1 (XLP_2XX_CDE_VC_BASE + 1)
+
+#define RTN_BKT 3
+#define FD_BURST_SIZE 1
+#define NUM_FREE_DESCRIPTORS 256 //must be less or equal to MAX_NUM_PAGES
+#define MAX_NUM_PAGES 256
+#define MAX_BUFFER_SIZE (1024*2048)
+#define MAX_INPUT_BUFFER_SIZE (1024*64)
+#define CMP_PAGE_SIZE   (2*1024)
+#define FD_CMP_PAGE_SIZE   (32*1024)
+#define SCRATCH_SIZE    (8*1024)
+#define MAX_NUM_MESSAGES 100
+
+extern void *fdt;
+
+unsigned char src_gz_data[] = {"edc13101000000c2a0f54f6d085fa000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e03"};
+
+typedef struct cmp_data_structure {
+  char *src;    // source data
+  char *target; // inflated or deflated result
+  unsigned long long *src_desc;  // source descriptors
+  unsigned long long *scratch;    // scratch page
+  unsigned long long *scratch_inf;    // scratch page
+  unsigned long long src_size;    //size of source data
+  unsigned long long target_size; // size of result
+  unsigned long long num_desc;    // number of source descriptors including scratch desc
+  short op;                       // to deflate or inflate
+  unsigned int compression_type;
+  unsigned int sof;
+  unsigned int eof;
+  unsigned int offset;
+} cmp_data_t;
+
+typedef enum {
+	CDE_READ_DONE = 0,
+	CDE_WRITE_PENDING,
+	CDE_WRITE_DONE
+} nlm_cde_state;
+
+typedef struct msgrng_msg msg;
+
+#endif
+
diff --git a/drivers/netlogic/nlm_cde/nlm_cde_api.h b/drivers/netlogic/nlm_cde/nlm_cde_api.h
new file mode 100644
index 0000000..7467d7c
--- /dev/null
+++ b/drivers/netlogic/nlm_cde/nlm_cde_api.h
@@ -0,0 +1,67 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef _NLM_CDE_API_H_
+#define _NLM_CDE_API_H_
+
+/**
+ * @file_name nlm_cde_api.h
+ */
+
+/**
+ * @defgroup cde Compression/Decompression API
+ * @brief Description about the cde apis supported.
+ */
+
+
+#define NLM_ERR_BASE				0xEAE0000
+#define NLM_ERR_CDE_PARAM_NULL 			(NLM_ERR_BASE | 1)
+#define NLM_ERR_INVALID_PARAM 			(NLM_ERR_BASE | 2)
+#define NLM_ERR_NO_MEM 				(NLM_ERR_BASE | 3)
+#define NLM_ERR_UNSPECIFIED 			(NLM_ERR_BASE | 4)
+#define	NLM_ERR_SEND_TIMEOUT 			(NLM_ERR_BASE | 5)
+#define NLM_ERR_IN_PROGRESS 			(NLM_ERR_BASE | 6)
+
+#define NLM_ERR_FREEBACK_NOT_RECEIVED 		(NLM_ERR_BASE | 256)
+
+
+
+cmp_data_t* nlm_cde_init(void);
+unsigned int nlm_cde_send_request(cmp_data_t *cmp_data, unsigned int op,
+			unsigned int type, 
+			unsigned int sof, 
+			unsigned int eof, 
+			unsigned char *src_buf, 
+			unsigned int size);
+unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, 
+						unsigned char *buf, 
+						unsigned int count);
+void nlm_cde_cleanup(cmp_data_t *cmp_data);
+
+#endif
-- 
1.7.9.5

