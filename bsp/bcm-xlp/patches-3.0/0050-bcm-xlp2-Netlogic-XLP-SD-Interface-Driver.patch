From d149e3923c2f5bcb13ff8185b2459d97ba0f60b8 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 20:32:28 +0800
Subject: [PATCH 50/58] bcm-xlp2: Netlogic XLP SD Interface Driver

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/mmc/host/Kconfig     |   12 ++
 drivers/mmc/host/Makefile    |    1 +
 drivers/mmc/host/sdhci-xlp.c |  248 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 261 insertions(+)

diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 9ab8f8d..74cca4f 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -646,3 +646,15 @@ config MMC_REALTEK_PCI
 	help
 	  Say Y here to include driver code to support SD/MMC card interface
 	  of Realtek PCI-E card reader
+
+config MMC_SDHCI_XLP
+       tristate "Netlogic XLP SD Interface support"
+       depends on MMC_SDHCI && CPU_XLP && PCI
+       help
+         This option enables support for the SD Host Controller Interface
+         on Netlogic XLP MIPS SoC.
+
+         If you have a XLP platform with a MMC slots, say Y or M here.
+
+         If unsure, say N.
+
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index cd32280..29f41ea 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_MMC_SDHCI_PXAV2)	+= sdhci-pxav2.o
 obj-$(CONFIG_MMC_SDHCI_S3C)	+= sdhci-s3c.o
 obj-$(CONFIG_MMC_SDHCI_SIRF)   	+= sdhci-sirf.o
 obj-$(CONFIG_MMC_SDHCI_SPEAR)	+= sdhci-spear.o
+obj-$(CONFIG_MMC_SDHCI_XLP)	+= sdhci-xlp.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
diff --git a/drivers/mmc/host/sdhci-xlp.c b/drivers/mmc/host/sdhci-xlp.c
new file mode 100644
index 0000000..21644e0
--- /dev/null
+++ b/drivers/mmc/host/sdhci-xlp.c
@@ -0,0 +1,248 @@
+/*
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+#include "sdhci.h"
+
+#define XLP_SLOT_SIZE		0x100
+#define XLP_NUM_SD_SLOT		2
+#define XLP_MMC_CAP_REG_LOW	0x204
+
+struct sdhci_xlp_chip {
+	struct pci_dev		*pdev;
+	struct sdhci_host	*host[XLP_NUM_SD_SLOT];
+};
+
+/* Setting XLP device and Vendor IDs */
+static const struct pci_device_id xlp_pci_ids[] = {
+	{
+		.vendor         = PCI_VENDOR_NETLOGIC,
+		.device         = PCI_DEVICE_ID_NLM_MMC,
+		.subvendor      = PCI_ANY_ID,
+		.subdevice      = PCI_ANY_ID,
+	},
+	{
+		.vendor         = PCI_VENDOR_ID_BROADCOM,
+		.device         = PCI_DEVICE_ID_XLP9XX_MMC,
+		.subvendor      = PCI_ANY_ID,
+		.subdevice      = PCI_ANY_ID,
+	},
+};
+
+unsigned int xlp_get_max_clock(struct sdhci_host *sd_host)
+{
+	if (!cpu_is_xlp9xx())
+		return 0;
+#if 0
+	u32 val;
+
+	val = readl(sd_host->ioaddr, XLP_MMC_CAP_REG_LOW);
+	return ((val >> 7) & 0xff) << 20;
+#endif
+	return 133 << 20;  /* 133MHz */
+}
+static struct sdhci_ops xlp_sdhci_ops = {
+	.get_max_clock = xlp_get_max_clock,
+};
+
+static int sdhci_xlp_probe_slot(struct pci_dev *pdev,
+					struct sdhci_xlp_chip *chip, int sltno)
+{
+	struct sdhci_xlp_chip *chip_sd;
+	struct sdhci_host *sd_host;
+	int ret;
+
+	sd_host = sdhci_alloc_host(&pdev->dev, sizeof(struct sdhci_xlp_chip));
+	if (IS_ERR(sd_host)) {
+		dev_err(&pdev->dev, "sdhci_alloc_host() failed!\n");
+		return -ENODEV;
+	}
+
+	chip_sd = sdhci_priv(sd_host);
+	chip->host[sltno] = sd_host;
+	chip_sd->pdev = chip->pdev;
+
+	sd_host->hw_name = "xlp-mmc";
+	sd_host->ops = &xlp_sdhci_ops;
+	sd_host->irq = pdev->irq;
+
+	/*
+	 * The capabilites register reports block size as 3 for 4096,
+	 * force it to 2048
+	 */
+	sd_host->quirks = SDHCI_QUIRK_FORCE_BLK_SZ_2048;
+
+	ret = pci_request_region(pdev, sltno, mmc_hostname(sd_host->mmc));
+	if (ret) {
+		dev_err(&pdev->dev, "can't request region\n");
+		goto err1;
+	}
+
+	sd_host->ioaddr = devm_ioremap(&pdev->dev,
+					pci_resource_start(pdev, sltno),
+					pci_resource_len(pdev, sltno));
+	if (!sd_host->ioaddr) {
+		dev_err(&pdev->dev, "failed to remap registers\n");
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	/* Registering host */
+	ret = sdhci_add_host(sd_host);
+	if (ret) {
+		dev_err(&pdev->dev, "sdhci_add_host() failed\n");
+		goto err0;
+	}
+
+	return 0;
+
+err0:
+	pci_release_region(pdev, sltno);
+err1:
+	sdhci_free_host(sd_host);
+	return ret;
+}
+
+static int sdhci_xlp_probe(struct pci_dev *pdev,
+					const struct pci_device_id *id)
+{
+	struct sdhci_xlp_chip *chip;
+	struct resource res;
+	void __iomem *sys_addr;
+	int ret, slotno, node;
+
+	node = xlp_socdev_to_node(pdev);
+	chip = kzalloc(sizeof(struct sdhci_xlp_chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	ret = pci_enable_device(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "pci_enable_device() failed!\n");
+		kfree(chip);
+		return ret;
+	}
+
+	pdev->irq = nlm_irq_to_xirq(node, PIC_MMC_IRQ);
+	chip->pdev = pdev;
+	pci_set_drvdata(pdev, chip);
+
+	/*
+	 * Enable slots.
+	 * Get system control base, node set to zero.
+	 * TODO: node need to be taken care on multinode case.
+	 */
+	if (cpu_is_xlp9xx())
+		res.start = XLP9XX_SD_SLOT_BASE(node, 2);
+	else
+		res.start = XLP_SD_SLOT_BASE(node, 2);
+	sys_addr = devm_ioremap(&pdev->dev, res.start, 0x28);
+	if (!sys_addr) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	writel(0x1C, sys_addr);
+
+	/*
+	 * The XLP MMC/SD controller has two slots. The registers for the
+	 * slots are at fixed location in the PCIe ECFG space, and not
+	 * in any PCI BARs.
+	 */
+	for (slotno = 0; slotno < XLP_NUM_SD_SLOT; slotno++) {
+		pdev->resource[slotno].flags = IORESOURCE_MEM;
+		if (cpu_is_xlp9xx())
+			pdev->resource[slotno].start =
+				XLP9XX_SD_SLOT_BASE(node, slotno);
+		else
+			pdev->resource[slotno].start =
+				XLP_SD_SLOT_BASE(node, slotno);
+		pdev->resource[slotno].end = pdev->resource[slotno].start +
+						XLP_SLOT_SIZE - 1;
+
+		ret = sdhci_xlp_probe_slot(pdev, chip, slotno);
+		if (ret)
+			dev_err(&pdev->dev, "failed to probe slot%d\n", slotno);
+	}
+
+	return 0;
+
+err:
+	pci_disable_device(pdev);
+	kfree(chip);
+	return ret;
+}
+
+static void sdhci_xlp_remove(struct pci_dev *pdev)
+{
+	struct sdhci_xlp_chip *chip;
+	int slotno, dead;
+	u32 scratch;
+
+	chip = pci_get_drvdata(pdev);
+	if (chip) {
+		for (slotno = 0; slotno < XLP_NUM_SD_SLOT; slotno++) {
+			scratch = readl(chip->host[slotno]->ioaddr +
+					SDHCI_INT_STATUS);
+			if (scratch == (u32)-1)
+				dead = 1;
+
+			sdhci_remove_host(chip->host[slotno], dead);
+			pci_release_region(pdev, slotno);
+			sdhci_free_host(chip->host[slotno]);
+		}
+		pci_set_drvdata(pdev, NULL);
+	}
+	pci_disable_device(pdev);
+}
+
+static struct pci_driver sdhci_xlp_driver = {
+	.name		= "sdhci-xlp",
+	.id_table	= xlp_pci_ids,
+	.probe		= sdhci_xlp_probe,
+	.remove		= sdhci_xlp_remove,
+};
+
+module_pci_driver(sdhci_xlp_driver);
+
+MODULE_AUTHOR("Kamlakant Patel <kamlakant.patel@broadcom.com>");
+MODULE_DESCRIPTION("SDHCI Driver for Netlogic XLP");
+MODULE_LICENSE("GPL v2");
-- 
1.7.9.5

