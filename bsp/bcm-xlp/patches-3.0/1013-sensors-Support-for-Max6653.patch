From e57f1e87c2ef018e241b0725d94ea93c9174ba63 Mon Sep 17 00:00:00 2001
From: kopal <kopal@broadcom.com>
Date: Wed, 4 Dec 2013 17:02:42 +0530
Subject: [PATCH 013/163] sensors: Support for Max6653.

Signed-off-by: kopal <kopal@broadcom.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/hwmon/Kconfig   |    9 ++
 drivers/hwmon/Makefile  |    1 +
 drivers/hwmon/max6653.c |  333 +++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 343 insertions(+)

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index df064e8..8ecb78e 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -728,6 +728,15 @@ config SENSORS_LM90
 	  This driver can also be built as a module.  If so, the module
 	  will be called lm90.
 
+config SENSORS_MAX6653
+	tristate "max6653 sensor/fan driver"
+	depends on I2C
+	help
+	   If you say yes here you get support for max6653 sensor and fan.
+
+	   This driver can also be built as a module.  If so, the module
+           will be called max6653.
+
 config SENSORS_LM92
 	tristate "National Semiconductor LM92 and compatibles"
 	depends on I2C
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index d17d3e6..da382f1 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -88,6 +88,7 @@ obj-$(CONFIG_SENSORS_LM83)	+= lm83.o
 obj-$(CONFIG_SENSORS_LM85)	+= lm85.o
 obj-$(CONFIG_SENSORS_LM87)	+= lm87.o
 obj-$(CONFIG_SENSORS_LM90)	+= lm90.o
+obj-$(CONFIG_SENSORS_MAX6653)	+= max6653.o
 obj-$(CONFIG_SENSORS_LM92)	+= lm92.o
 obj-$(CONFIG_SENSORS_LM93)	+= lm93.o
 obj-$(CONFIG_SENSORS_LM95234)	+= lm95234.o
diff --git a/drivers/hwmon/max6653.c b/drivers/hwmon/max6653.c
new file mode 100644
index 0000000..551a1e4
--- /dev/null
+++ b/drivers/hwmon/max6653.c
@@ -0,0 +1,333 @@
+/*
+   max6653.c driver.
+
+   Based on lm90.c and
+      http://lists.lm-sensors.org/pipermail/lm-sensors/attachments/20040910/409a6435/attachment.bin
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+
+/*
+ * MAX 6653/6663/6664 registers
+ */
+
+#define MAX6653_REG_CFG1        0x00
+#define MAX6653_REG_CFG2        0x01
+#define MAX6653_REG_STAT1       0x02
+#define MAX6653_REG_STAT2       0x03
+#define MAX6653_REG_EXTTMP      0x06
+#define MAX6653_REG_LCLTMP      0x0A
+#define MAX6653_REG_REMTMP      0x0B
+#define MAX6653_REG_LCLTMP_OFF  0x0D
+#define MAX6653_REG_REMTMP_OFF  0x0E
+#define MAX6653_REG_LCLTMP_HI   0x14
+#define MAX6653_REG_LCLTMP_LO   0x15
+#define MAX6653_REG_LCLTMP_THRM 0x16
+#define MAX6653_REG_REMTMP_HI   0x18
+#define MAX6653_REG_REMTMP_LO   0x19
+#define MAX6653_REG_REMTMP_THRM 0x1A
+#define MAX6653_REG_LCLTMP_SD   0x1B
+#define MAX6653_REG_REMTMP_SD   0x1C
+#define MAX6653_REG_LCLTMP_RNG  0x24
+#define MAX6653_REG_REMTMP_RNG  0x25
+#define MAX6653_REG_DEVID       0x3D
+#define MAX6653_REG_MANID       0x3E
+#define MAX6653_REG_THRMREV     0x3F
+
+#define MAX6653_CFG1_MONITOR_ENABLE 0x01
+/*
+ * Config register 2 bits
+ */
+#define MAX6653_CFG2_RESET          0x80
+#define MAX6653_CFG2_RSVD           0x40
+#define MAX6653_CFG2_REM_TMP_ENABLE 0x20
+#define MAX6653_CFG2_LCL_TMP_ENABLE 0x10
+#define MAX6653_CFG2_INT_INPUT_FUNC 0x08
+#define MAX6653_CFG2_TACH_ENABLE    0x04
+#define MAX6653_CFG2_SMB_TO_ENABLE  0x02
+#define MAX6653_CFG2_PWM_OUT_ENABLE 0x01
+
+
+static int max6653_probe(struct i2c_client *client,
+                         const struct i2c_device_id *id);
+static int max6653_init_client(struct i2c_client *client);
+static struct max6653_data *max6653_update_device(struct device *dev);
+static int max6653_read(struct i2c_client *client, u8 reg);
+static int max6653_write(struct i2c_client *client, u8 reg, u8 value);
+static int max6653_remove(struct i2c_client *client);
+
+static const struct i2c_device_id max6653_id[] = {
+	{ "max6653", 1},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, max6653_id);
+
+static struct i2c_driver max6653_driver = {
+	.class	= I2C_CLASS_HWMON,
+	.driver = {
+		.name	= "max6653",
+	},
+	.probe	= max6653_probe,
+	.remove	= max6653_remove,
+	.id_table	= max6653_id,
+};
+
+struct max6653_data {
+	struct device *hwmon_dev;
+	struct mutex update_lock;
+	int nr_fans;
+	char valid; /* zero until following fields are valid */
+	unsigned long last_updated; /* in jiffies */
+
+	/* register values */
+	u8 config1;
+	u8 config2;
+	u8 extbits;
+	u8 temp1_input;
+	u8 temp2_input;
+	u8 temp1_min;
+	u8 temp1_max;
+	u8 temp2_min;
+	u8 temp2_max;
+	u8 temp1_crit;
+	u8 temp2_crit;
+	u8 alarm;
+};
+
+static ssize_t show_temp1_min(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	struct max6653_data *data = max6653_update_device(dev);
+	return sprintf(buf, "%d\n",(data->temp1_min)*1000);
+}
+
+static ssize_t show_temp2_min(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	struct max6653_data *data = max6653_update_device(dev);
+	return sprintf(buf, "%d\n",(data->temp2_min)*1000);
+}
+static ssize_t show_temp1_max(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	struct max6653_data *data = max6653_update_device(dev);
+	return sprintf(buf, "%d\n",(data->temp1_max)*1000);
+}
+static ssize_t show_temp2_max(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	struct max6653_data *data = max6653_update_device(dev);
+	return sprintf(buf, "%d\n",(data->temp2_max)*1000);
+}
+
+static ssize_t show_temp1_input(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	struct max6653_data *data = max6653_update_device(dev);
+	return sprintf(buf, "%d\n",(data->temp1_input)*1000);
+}
+
+static ssize_t show_temp2_input(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	struct max6653_data *data = max6653_update_device(dev);
+	return sprintf(buf, "%d\n",(data->temp2_input)*1000);
+}
+
+static ssize_t show_temp1_crit(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	struct max6653_data *data = max6653_update_device(dev);
+	return sprintf(buf, "%d\n",(data->temp1_crit)*1000);
+}
+
+static ssize_t show_temp2_crit(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	struct max6653_data *data = max6653_update_device(dev);
+	return sprintf(buf, "%d\n",(data->temp2_crit)*1000);
+}
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute
+                          *devattr, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct max6653_data *data = max6653_update_device(dev);
+	int bitnr = attr->index;
+
+	return sprintf(buf, "%d\n", (data->alarm >> bitnr) & 1);
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUSR|S_IRUGO, show_temp1_input, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp2_input, S_IRUSR|S_IRUGO, show_temp2_input, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp1_min, S_IWUSR | S_IRUGO, show_temp1_min, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp2_min, S_IWUSR | S_IRUGO, show_temp2_min, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp1_max, S_IWUSR | S_IRUGO, show_temp1_max, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp2_max, S_IWUSR | S_IRUGO, show_temp2_max, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp1_crit, S_IWUSR | S_IRUGO, show_temp1_crit, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp2_crit, S_IWUSR | S_IRUGO, show_temp2_crit, NULL, 0);
+/*ALARMS*/
+
+static SENSOR_DEVICE_ATTR(temp2_max_alarm, S_IRUGO, show_alarm, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp2_min_alarm, S_IRUGO, show_alarm, NULL, 3);
+static SENSOR_DEVICE_ATTR(temp2_crit_alarm, S_IRUGO, show_alarm, NULL, 4);
+static SENSOR_DEVICE_ATTR(temp2_fault, S_IRUGO, show_alarm, NULL, 5);
+static SENSOR_DEVICE_ATTR(temp1_max_alarm, S_IRUGO, show_alarm, NULL, 6);
+static SENSOR_DEVICE_ATTR(temp1_min_alarm, S_IRUGO, show_alarm, NULL, 7);
+
+static struct attribute *max6653_attrs[] = {
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp2_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_min.dev_attr.attr,
+	&sensor_dev_attr_temp2_min.dev_attr.attr,
+	&sensor_dev_attr_temp1_max.dev_attr.attr,
+	&sensor_dev_attr_temp2_max.dev_attr.attr,
+	&sensor_dev_attr_temp1_crit.dev_attr.attr,
+	&sensor_dev_attr_temp2_crit.dev_attr.attr,
+
+	&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp2_fault.dev_attr.attr,
+	&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,
+	NULL
+};
+
+
+static const struct attribute_group max6653_attr_grp = {
+	.attrs = max6653_attrs,
+};
+
+static int max6653_probe(struct i2c_client *client,
+                         const struct i2c_device_id *id)
+{
+	struct max6653_data *data;
+	int err;
+	struct device *dev = &client->dev;
+
+	data = devm_kzalloc(&client->dev, sizeof(struct max6653_data),
+				GFP_KERNEL);
+	if (!data) {
+		dev_err(&client->dev, "out of memory.\n");
+		return -ENOMEM;
+	}
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->update_lock);
+
+	/* Initialize the chipset */
+	err = max6653_init_client(client);
+	if (err)
+		return err;
+
+	/* Register sysfs hooks */
+	err = sysfs_create_group(&dev->kobj, &max6653_attr_grp);
+	if (err)
+		return err;
+
+	data->hwmon_dev = hwmon_device_register(dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		err = PTR_ERR(data->hwmon_dev);
+		goto exit_remove;
+	}
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&dev->kobj, &max6653_attr_grp);
+	return err;
+}
+
+static int max6653_init_client(struct i2c_client *client)
+{
+	u8 cfg2;
+
+	/* Reset the chip */
+	max6653_write(client, MAX6653_REG_CFG2, MAX6653_CFG2_RESET);
+
+	/*ebnable the temperature monitoring*/
+	max6653_write(client, MAX6653_REG_CFG1,MAX6653_CFG1_MONITOR_ENABLE);
+	cfg2=max6653_read(client, MAX6653_REG_CFG2);
+
+	max6653_write(client, MAX6653_REG_REMTMP_OFF,0x80);
+	return 0;
+}
+static int max6653_remove(struct i2c_client *client)
+{
+	struct max6653_data *data = i2c_get_clientdata(client);
+	struct device *dev = &client->dev;
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&dev->kobj, &max6653_attr_grp);
+
+	return 0;
+}
+
+static int max6653_read(struct i2c_client *client, u8 reg)
+{
+	return i2c_smbus_read_byte_data(client, reg);
+}
+
+static int max6653_write(struct i2c_client *client, u8 reg, u8 value)
+{
+	return i2c_smbus_write_byte_data(client, reg, value);
+}
+
+static struct max6653_data *max6653_update_device(struct device *dev)
+{
+	int i;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max6653_data *data = i2c_get_clientdata(client);
+
+	mutex_lock(&data->update_lock);
+
+	if (time_after(jiffies, data->last_updated + HZ) || !data->valid) {
+		data->config1 = max6653_read (client, MAX6653_REG_CFG1);
+		data->config2 = max6653_read (client, MAX6653_REG_CFG2);
+		data->extbits  = max6653_read (client, MAX6653_REG_EXTTMP);
+		data->temp1_input = max6653_read (client, MAX6653_REG_LCLTMP);
+		data->temp2_input = max6653_read (client, MAX6653_REG_REMTMP);
+		data->temp1_max = max6653_read (client, MAX6653_REG_LCLTMP_HI);
+		data->temp1_min = max6653_read (client, MAX6653_REG_LCLTMP_LO);
+		data->temp2_max = max6653_read (client, MAX6653_REG_REMTMP_HI);
+		data->temp2_min = max6653_read (client, MAX6653_REG_REMTMP_LO);
+		data->temp1_crit = max6653_read (client, MAX6653_REG_LCLTMP_THRM);
+		data->temp2_crit = max6653_read (client, MAX6653_REG_REMTMP_THRM);
+		data->alarm= max6653_read (client, MAX6653_REG_STAT1);
+
+		data->last_updated = jiffies;
+		data->valid = 1;
+	}
+
+	mutex_unlock(&data->update_lock);
+	return data;
+}
+
+module_i2c_driver(max6653_driver);
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("MAX6653 sensor driver");
+MODULE_LICENSE("GPL");
+
-- 
1.7.9.5

