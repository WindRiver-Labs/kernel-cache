From 869a1da06b35f5c51a12b4e63871922f8f4a0f5e Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 Mar 2014 15:55:43 +0800
Subject: [PATCH 4/4] bcm-xlp: use the unsleep raw spinlock in 8250 driver

replace the spin_lock/unlock with raw_spin_lock/unlock

otherwise we get the following message:

INIT: BUG: sleeping function called from invalid context at kernel/rtmutex.c:659
in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/0
Preemption disabled at:[<          (null)>]           (null)

CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.10.19-rt11-WR6.0.0.0_preempt-rt #39
Stack : 0000000000000000 000000000000004f 0000000000000000 0000000000000000
          0000000000000004 ffffffffc0c20000 0000000000000000 0000000000000000
          ffffffffc0f90000 0000000000000000 000000000000004f 0000000000000006
          ffffffffc0b2f970 ffffffffc02262b0 0000000000000000 0000000000000000
          0000000000000000 0000000000000000 ffffffffc0f70000 ffffffffc0f70000
          ffffffffc0a7f1d8 ffffffffc0c1d8f7 ffffffffc0f6ade8 ffffffffc0c1dd90
          0000000000000000 0000000000000000 c0000000a8fb0040 ffffffffc0c90000
          ffffffffc0b2f9f0 ffffffffc0b2f900 ffffffffc0b2fa18 ffffffffc0977f18
          ffffffffc0b2fa50 ffffffffc0227f48 ffffffffc0c1d9f0 ffffffffc0a7f1d8
          0000000000000000 ffffffffc01f9158 0000000000000000 0000000000000000
          ...
Call Trace:
[<ffffffffc01f9158>] show_stack+0xd8/0xf8
[<ffffffffc0977f18>] rt_spin_lock+0x38/0x98
[<ffffffffc065bd60>] serial8250_handle_irq.part.17+0x40/0x128
[<ffffffffc065aa30>] serial8250_interrupt+0x70/0x140
[<ffffffffc02b5c4c>] handle_irq_event_percpu+0xa4/0x328
[<ffffffffc02b5f54>] handle_irq_event+0x84/0xe0
[<ffffffffc02b9ecc>] handle_level_irq+0xe4/0x1a8
[<ffffffffc02b4fd4>] generic_handle_irq+0x54/0x88
[<ffffffffc0978c54>] do_IRQ+0x2c/0x40
[<ffffffffc01f3740>] ret_from_irq+0x0/0x4
[<ffffffffc01f39e0>] __r4k_wait+0x20/0x40
[<ffffffffc0279e98>] cpu_startup_entry+0x190/0x2e8
[<ffffffffc0c90af0>] start_kernel+0x4a8/0x4c8

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/tty/serial/8250/8250_core.c |   80 ++++++++++++++---------------
 drivers/tty/serial/of_serial.c      |    2 +-
 drivers/tty/serial/serial_core.c    |   96 +++++++++++++++++------------------
 drivers/tty/tty_buffer.c            |   28 +++++-----
 include/linux/serial_core.h         |    2 +-
 include/linux/tty.h                 |    2 +-
 6 files changed, 105 insertions(+), 105 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index 8953869..6e8ba63 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -134,7 +134,7 @@ static unsigned int probe_rsa_count;
 struct irq_info {
 	struct			hlist_node node;
 	int			irq;
-	spinlock_t		lock;	/* Protects list not the hash */
+	raw_spinlock_t		lock;	/* Protects list not the hash */
 	struct list_head	*head;
 };
 
@@ -613,9 +613,9 @@ static void enable_rsa(struct uart_8250_port *up)
 {
 	if (up->port.type == PORT_RSA) {
 		if (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {
-			spin_lock_irq(&up->port.lock);
+			raw_spin_lock_irq(&up->port.lock);
 			__enable_rsa(up);
-			spin_unlock_irq(&up->port.lock);
+			raw_spin_unlock_irq(&up->port.lock);
 		}
 		if (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)
 			serial_out(up, UART_RSA_FRR, 0);
@@ -635,7 +635,7 @@ static void disable_rsa(struct uart_8250_port *up)
 
 	if (up->port.type == PORT_RSA &&
 	    up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16) {
-		spin_lock_irq(&up->port.lock);
+		raw_spin_lock_irq(&up->port.lock);
 
 		mode = serial_in(up, UART_RSA_MSR);
 		result = !(mode & UART_RSA_MSR_FIFO);
@@ -648,7 +648,7 @@ static void disable_rsa(struct uart_8250_port *up)
 
 		if (result)
 			up->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;
-		spin_unlock_irq(&up->port.lock);
+		raw_spin_unlock_irq(&up->port.lock);
 	}
 }
 #endif /* CONFIG_SERIAL_8250_RSA */
@@ -1072,7 +1072,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 	 * We really do need global IRQs disabled here - we're going to
 	 * be frobbing the chips IRQ enable register to see if it exists.
 	 */
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 
 	up->capabilities = 0;
 	up->bugs = 0;
@@ -1111,7 +1111,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 			/*
 			 * We failed; there's nothing here
 			 */
-			spin_unlock_irqrestore(&port->lock, flags);
+			raw_spin_unlock_irqrestore(&port->lock, flags);
 			DEBUG_AUTOCONF("IER test failed (%02x, %02x) ",
 				       scratch2, scratch3);
 			goto out;
@@ -1135,7 +1135,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 		status1 = serial_in(up, UART_MSR) & 0xF0;
 		serial_out(up, UART_MCR, save_mcr);
 		if (status1 != 0x90) {
-			spin_unlock_irqrestore(&port->lock, flags);
+			raw_spin_unlock_irqrestore(&port->lock, flags);
 			DEBUG_AUTOCONF("LOOP test failed (%02x) ",
 				       status1);
 			goto out;
@@ -1215,7 +1215,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 		serial_out(up, UART_IER, 0);
 
 out_lock:
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 	if (up->capabilities != old_capabilities) {
 		printk(KERN_WARNING
 		       "ttyS%d: detected caps %08x should be %08x\n",
@@ -1429,9 +1429,9 @@ serial8250_rx_chars(struct uart_8250_port *up, unsigned char lsr)
 ignore_char:
 		lsr = serial_in(up, UART_LSR);
 	} while ((lsr & (UART_LSR_DR | UART_LSR_BI)) && (max_count-- > 0));
-	spin_unlock(&port->lock);
+	raw_spin_unlock(&port->lock);
 	tty_flip_buffer_push(&port->state->port);
-	spin_lock(&port->lock);
+	raw_spin_lock(&port->lock);
 	return lsr;
 }
 EXPORT_SYMBOL_GPL(serial8250_rx_chars);
@@ -1520,7 +1520,7 @@ int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 	if (iir & UART_IIR_NO_INT)
 		return 0;
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 
 	status = serial_port_in(port, UART_LSR);
 
@@ -1537,7 +1537,7 @@ int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 	if (status & UART_LSR_THRE)
 		serial8250_tx_chars(up);
 
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 	return 1;
 }
 EXPORT_SYMBOL_GPL(serial8250_handle_irq);
@@ -1596,7 +1596,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 
 	DEBUG_INTR("serial8250_interrupt(%d)...", irq);
 
-	spin_lock(&i->lock);
+	raw_spin_lock(&i->lock);
 
 	l = i->head;
 	do {
@@ -1622,7 +1622,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 		}
 	} while (l != end);
 
-	spin_unlock(&i->lock);
+	raw_spin_unlock(&i->lock);
 
 	DEBUG_INTR("end.\n");
 
@@ -1638,7 +1638,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
  */
 static void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)
 {
-	spin_lock_irq(&i->lock);
+	raw_spin_lock_irq(&i->lock);
 
 	if (!list_empty(i->head)) {
 		if (i->head == &up->list)
@@ -1648,7 +1648,7 @@ static void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)
 		BUG_ON(i->head != &up->list);
 		i->head = NULL;
 	}
-	spin_unlock_irq(&i->lock);
+	raw_spin_unlock_irq(&i->lock);
 	/* List empty so throw away the hash node */
 	if (i->head == NULL) {
 		hlist_del(&i->node);
@@ -1679,26 +1679,26 @@ static int serial_link_irq_chain(struct uart_8250_port *up)
 			mutex_unlock(&hash_mutex);
 			return -ENOMEM;
 		}
-		spin_lock_init(&i->lock);
+		raw_spin_lock_init(&i->lock);
 		i->irq = up->port.irq;
 		hlist_add_head(&i->node, h);
 	}
 	mutex_unlock(&hash_mutex);
 
-	spin_lock_irq(&i->lock);
+	raw_spin_lock_irq(&i->lock);
 
 	if (i->head) {
 		list_add(&up->list, i->head);
-		spin_unlock_irq(&i->lock);
+		raw_spin_unlock_irq(&i->lock);
 
 		ret = 0;
 	} else {
 		INIT_LIST_HEAD(&up->list);
 		i->head = &up->list;
-		spin_unlock_irq(&i->lock);
+		raw_spin_unlock_irq(&i->lock);
 		irq_flags |= up->port.irqflags;
 		ret = request_irq(up->port.irq, serial8250_interrupt,
-				  irq_flags, "serial", i);
+				  irq_flags | IRQF_NO_THREAD, "serial", i);
 		if (ret < 0)
 			serial_do_unlink(i, up);
 	}
@@ -1752,7 +1752,7 @@ static void serial8250_backup_timeout(unsigned long data)
 	unsigned int iir, ier = 0, lsr;
 	unsigned long flags;
 
-	spin_lock_irqsave(&up->port.lock, flags);
+	raw_spin_lock_irqsave(&up->port.lock, flags);
 
 	/*
 	 * Must disable interrupts or else we risk racing with the interrupt
@@ -1786,7 +1786,7 @@ static void serial8250_backup_timeout(unsigned long data)
 	if (up->port.irq)
 		serial_out(up, UART_IER, ier);
 
-	spin_unlock_irqrestore(&up->port.lock, flags);
+	raw_spin_unlock_irqrestore(&up->port.lock, flags);
 
 	/* Standard timer interval plus 0.2s to keep the port running */
 	mod_timer(&up->timer,
@@ -1800,10 +1800,10 @@ static unsigned int serial8250_tx_empty(struct uart_port *port)
 	unsigned long flags;
 	unsigned int lsr;
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	lsr = serial_port_in(port, UART_LSR);
 	up->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 
 	return (lsr & BOTH_EMPTY) == BOTH_EMPTY ? TIOCSER_TEMT : 0;
 }
@@ -1857,13 +1857,13 @@ static void serial8250_break_ctl(struct uart_port *port, int break_state)
 		container_of(port, struct uart_8250_port, port);
 	unsigned long flags;
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	if (break_state == -1)
 		up->lcr |= UART_LCR_SBC;
 	else
 		up->lcr &= ~UART_LCR_SBC;
 	serial_port_out(port, UART_LCR, up->lcr);
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 }
 
 /*
@@ -2052,7 +2052,7 @@ static int serial8250_startup(struct uart_port *port)
 		 * the interrupt is enabled.  Delays are necessary to
 		 * allow register changes to become visible.
 		 */
-		spin_lock_irqsave(&port->lock, flags);
+		raw_spin_lock_irqsave(&port->lock, flags);
 		if (up->port.irqflags & IRQF_SHARED)
 			disable_irq_nosync(port->irq);
 
@@ -2068,7 +2068,7 @@ static int serial8250_startup(struct uart_port *port)
 
 		if (port->irqflags & IRQF_SHARED)
 			enable_irq(port->irq);
-		spin_unlock_irqrestore(&port->lock, flags);
+		raw_spin_unlock_irqrestore(&port->lock, flags);
 
 		/*
 		 * If the interrupt is not reasserted, or we otherwise
@@ -2113,7 +2113,7 @@ static int serial8250_startup(struct uart_port *port)
 	 */
 	serial_port_out(port, UART_LCR, UART_LCR_WLEN8);
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	if (up->port.flags & UPF_FOURPORT) {
 		if (!up->port.irq)
 			up->port.mctrl |= TIOCM_OUT1;
@@ -2160,7 +2160,7 @@ static int serial8250_startup(struct uart_port *port)
 	}
 
 dont_test_tx_en:
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 
 	/*
 	 * Clear the interrupt registers again for luck, and clear the
@@ -2222,7 +2222,7 @@ static void serial8250_shutdown(struct uart_port *port)
 	if (up->dma)
 		serial8250_release_dma(up);
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	if (port->flags & UPF_FOURPORT) {
 		/* reset interrupts on the AST Fourport board */
 		inb((port->iobase & 0xfe0) | 0x1f);
@@ -2231,7 +2231,7 @@ static void serial8250_shutdown(struct uart_port *port)
 		port->mctrl &= ~TIOCM_OUT2;
 
 	serial8250_set_mctrl(port, port->mctrl);
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 
 	/*
 	 * Disable break condition and FIFOs
@@ -2360,7 +2360,7 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
 	 * Ok, we're now changing the port state.  Do it with
 	 * interrupts disabled.
 	 */
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 
 	/*
 	 * Update the per-port timeout.
@@ -2462,7 +2462,7 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
 		serial_port_out(port, UART_FCR, fcr);		/* set fcr */
 	}
 	serial8250_set_mctrl(port, port->mctrl);
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 	/* Don't rewrite B0 */
 	if (tty_termios_baud_rate(termios))
 		tty_termios_encode_baud_rate(termios, baud, baud);
@@ -2774,7 +2774,7 @@ static void __init serial8250_isa_init_ports(void)
 		struct uart_port *port = &up->port;
 
 		port->line = i;
-		spin_lock_init(&port->lock);
+		raw_spin_lock_init(&port->lock);
 
 		init_timer(&up->timer);
 		up->timer.function = serial8250_timeout;
@@ -2875,9 +2875,9 @@ serial8250_console_write(struct console *co, const char *s, unsigned int count)
 	touch_nmi_watchdog();
 
 	if (port->sysrq || oops_in_progress || in_kdb_printk())
-		locked = spin_trylock_irqsave(&port->lock, flags);
+		locked = raw_spin_trylock_irqsave(&port->lock, flags);
 	else
-		spin_lock_irqsave(&port->lock, flags);
+		raw_spin_lock_irqsave(&port->lock, flags);
 
 	/*
 	 *	First save the IER then disable the interrupts
@@ -2909,7 +2909,7 @@ serial8250_console_write(struct console *co, const char *s, unsigned int count)
 		serial8250_modem_status(up);
 
 	if (locked)
-		spin_unlock_irqrestore(&port->lock, flags);
+		raw_spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static int __init serial8250_console_setup(struct console *co, char *options)
diff --git a/drivers/tty/serial/of_serial.c b/drivers/tty/serial/of_serial.c
index 39c7ea4..d2b7ca1 100644
--- a/drivers/tty/serial/of_serial.c
+++ b/drivers/tty/serial/of_serial.c
@@ -87,7 +87,7 @@ static int of_platform_serial_setup(struct platform_device *ofdev,
 		goto out;
 	}
 
-	spin_lock_init(&port->lock);
+	raw_spin_lock_init(&port->lock);
 	port->mapbase = resource.start;
 
 	/* Check for shifted address mapping */
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 2598bba..ee42634 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -79,9 +79,9 @@ static void uart_stop(struct tty_struct *tty)
 	struct uart_port *port = state->uart_port;
 	unsigned long flags;
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	port->ops->stop_tx(port);
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static void __uart_start(struct tty_struct *tty)
@@ -100,9 +100,9 @@ static void uart_start(struct tty_struct *tty)
 	struct uart_port *port = state->uart_port;
 	unsigned long flags;
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	__uart_start(tty);
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static inline void
@@ -111,12 +111,12 @@ uart_update_mctrl(struct uart_port *port, unsigned int set, unsigned int clear)
 	unsigned long flags;
 	unsigned int old;
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	old = port->mctrl;
 	port->mctrl = (old & ~clear) | set;
 	if (old != port->mctrl)
 		port->ops->set_mctrl(port, port->mctrl);
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 }
 
 #define uart_set_mctrl(port, set)	uart_update_mctrl(port, set, 0)
@@ -172,10 +172,10 @@ static int uart_port_startup(struct tty_struct *tty, struct uart_state *state,
 		}
 
 		if (tty_port_cts_enabled(port)) {
-			spin_lock_irq(&uport->lock);
+			raw_spin_lock_irq(&uport->lock);
 			if (!(uport->ops->get_mctrl(uport) & TIOCM_CTS))
 				tty->hw_stopped = 1;
-			spin_unlock_irq(&uport->lock);
+			raw_spin_unlock_irq(&uport->lock);
 		}
 	}
 
@@ -465,13 +465,13 @@ static inline int __uart_put_char(struct uart_port *port,
 	if (!circ->buf)
 		return 0;
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	if (uart_circ_chars_free(circ) != 0) {
 		circ->buf[circ->head] = c;
 		circ->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);
 		ret = 1;
 	}
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 	return ret;
 }
 
@@ -511,7 +511,7 @@ static int uart_write(struct tty_struct *tty,
 	if (!circ->buf)
 		return 0;
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	while (1) {
 		c = CIRC_SPACE_TO_END(circ->head, circ->tail, UART_XMIT_SIZE);
 		if (count < c)
@@ -524,7 +524,7 @@ static int uart_write(struct tty_struct *tty,
 		count -= c;
 		ret += c;
 	}
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 
 	uart_start(tty);
 	return ret;
@@ -536,9 +536,9 @@ static int uart_write_room(struct tty_struct *tty)
 	unsigned long flags;
 	int ret;
 
-	spin_lock_irqsave(&state->uart_port->lock, flags);
+	raw_spin_lock_irqsave(&state->uart_port->lock, flags);
 	ret = uart_circ_chars_free(&state->xmit);
-	spin_unlock_irqrestore(&state->uart_port->lock, flags);
+	raw_spin_unlock_irqrestore(&state->uart_port->lock, flags);
 	return ret;
 }
 
@@ -548,9 +548,9 @@ static int uart_chars_in_buffer(struct tty_struct *tty)
 	unsigned long flags;
 	int ret;
 
-	spin_lock_irqsave(&state->uart_port->lock, flags);
+	raw_spin_lock_irqsave(&state->uart_port->lock, flags);
 	ret = uart_circ_chars_pending(&state->xmit);
-	spin_unlock_irqrestore(&state->uart_port->lock, flags);
+	raw_spin_unlock_irqrestore(&state->uart_port->lock, flags);
 	return ret;
 }
 
@@ -572,11 +572,11 @@ static void uart_flush_buffer(struct tty_struct *tty)
 	port = state->uart_port;
 	pr_debug("uart_flush_buffer(%d) called\n", tty->index);
 
-	spin_lock_irqsave(&port->lock, flags);
+	raw_spin_lock_irqsave(&port->lock, flags);
 	uart_circ_clear(&state->xmit);
 	if (port->ops->flush_buffer)
 		port->ops->flush_buffer(port);
-	spin_unlock_irqrestore(&port->lock, flags);
+	raw_spin_unlock_irqrestore(&port->lock, flags);
 	tty_wakeup(tty);
 }
 
@@ -595,9 +595,9 @@ static void uart_send_xchar(struct tty_struct *tty, char ch)
 	else {
 		port->x_char = ch;
 		if (ch) {
-			spin_lock_irqsave(&port->lock, flags);
+			raw_spin_lock_irqsave(&port->lock, flags);
 			port->ops->start_tx(port);
-			spin_unlock_irqrestore(&port->lock, flags);
+			raw_spin_unlock_irqrestore(&port->lock, flags);
 		}
 	}
 }
@@ -953,9 +953,9 @@ static int uart_tiocmget(struct tty_struct *tty)
 	mutex_lock(&port->mutex);
 	if (!(tty->flags & (1 << TTY_IO_ERROR))) {
 		result = uport->mctrl;
-		spin_lock_irq(&uport->lock);
+		raw_spin_lock_irq(&uport->lock);
 		result |= uport->ops->get_mctrl(uport);
-		spin_unlock_irq(&uport->lock);
+		raw_spin_unlock_irq(&uport->lock);
 	}
 	mutex_unlock(&port->mutex);
 
@@ -1059,20 +1059,20 @@ uart_wait_modem_status(struct uart_state *state, unsigned long arg)
 	/*
 	 * note the counters on entry
 	 */
-	spin_lock_irq(&uport->lock);
+	raw_spin_lock_irq(&uport->lock);
 	memcpy(&cprev, &uport->icount, sizeof(struct uart_icount));
 
 	/*
 	 * Force modem status interrupts on
 	 */
 	uport->ops->enable_ms(uport);
-	spin_unlock_irq(&uport->lock);
+	raw_spin_unlock_irq(&uport->lock);
 
 	add_wait_queue(&port->delta_msr_wait, &wait);
 	for (;;) {
-		spin_lock_irq(&uport->lock);
+		raw_spin_lock_irq(&uport->lock);
 		memcpy(&cnow, &uport->icount, sizeof(struct uart_icount));
-		spin_unlock_irq(&uport->lock);
+		raw_spin_unlock_irq(&uport->lock);
 
 		set_current_state(TASK_INTERRUPTIBLE);
 
@@ -1114,9 +1114,9 @@ static int uart_get_icount(struct tty_struct *tty,
 	struct uart_icount cnow;
 	struct uart_port *uport = state->uart_port;
 
-	spin_lock_irq(&uport->lock);
+	raw_spin_lock_irq(&uport->lock);
 	memcpy(&cnow, &uport->icount, sizeof(struct uart_icount));
-	spin_unlock_irq(&uport->lock);
+	raw_spin_unlock_irq(&uport->lock);
 
 	icount->cts         = cnow.cts;
 	icount->dsr         = cnow.dsr;
@@ -1284,19 +1284,19 @@ static void uart_set_termios(struct tty_struct *tty,
 
 	/* Handle turning off CRTSCTS */
 	if ((old_termios->c_cflag & CRTSCTS) && !(cflag & CRTSCTS)) {
-		spin_lock_irqsave(&uport->lock, flags);
+		raw_spin_lock_irqsave(&uport->lock, flags);
 		tty->hw_stopped = 0;
 		__uart_start(tty);
-		spin_unlock_irqrestore(&uport->lock, flags);
+		raw_spin_unlock_irqrestore(&uport->lock, flags);
 	}
 	/* Handle turning on CRTSCTS */
 	else if (!(old_termios->c_cflag & CRTSCTS) && (cflag & CRTSCTS)) {
-		spin_lock_irqsave(&uport->lock, flags);
+		raw_spin_lock_irqsave(&uport->lock, flags);
 		if (!(uport->ops->get_mctrl(uport) & TIOCM_CTS)) {
 			tty->hw_stopped = 1;
 			uport->ops->stop_tx(uport);
 		}
-		spin_unlock_irqrestore(&uport->lock, flags);
+		raw_spin_unlock_irqrestore(&uport->lock, flags);
 	}
 }
 
@@ -1330,9 +1330,9 @@ static void uart_close(struct tty_struct *tty, struct file *filp)
 	 */
 	if (port->flags & ASYNC_INITIALIZED) {
 		unsigned long flags;
-		spin_lock_irqsave(&uport->lock, flags);
+		raw_spin_lock_irqsave(&uport->lock, flags);
 		uport->ops->stop_rx(uport);
-		spin_unlock_irqrestore(&uport->lock, flags);
+		raw_spin_unlock_irqrestore(&uport->lock, flags);
 		/*
 		 * Before we drop DTR, make sure the UART transmitter
 		 * has completely drained; this is especially
@@ -1493,10 +1493,10 @@ static int uart_carrier_raised(struct tty_port *port)
 	struct uart_state *state = container_of(port, struct uart_state, port);
 	struct uart_port *uport = state->uart_port;
 	int mctrl;
-	spin_lock_irq(&uport->lock);
+	raw_spin_lock_irq(&uport->lock);
 	uport->ops->enable_ms(uport);
 	mctrl = uport->ops->get_mctrl(uport);
-	spin_unlock_irq(&uport->lock);
+	raw_spin_unlock_irq(&uport->lock);
 	if (mctrl & TIOCM_CAR)
 		return 1;
 	return 0;
@@ -1641,9 +1641,9 @@ static void uart_line_info(struct seq_file *m, struct uart_driver *drv, int i)
 		pm_state = state->pm_state;
 		if (pm_state != UART_PM_STATE_ON)
 			uart_change_pm(state, UART_PM_STATE_ON);
-		spin_lock_irq(&uport->lock);
+		raw_spin_lock_irq(&uport->lock);
 		status = uport->ops->get_mctrl(uport);
-		spin_unlock_irq(&uport->lock);
+		raw_spin_unlock_irq(&uport->lock);
 		if (pm_state != UART_PM_STATE_ON)
 			uart_change_pm(state, pm_state);
 		mutex_unlock(&port->mutex);
@@ -1831,7 +1831,7 @@ uart_set_options(struct uart_port *port, struct console *co,
 	 * Ensure that the serial console lock is initialised
 	 * early.
 	 */
-	spin_lock_init(&port->lock);
+	raw_spin_lock_init(&port->lock);
 	lockdep_set_class(&port->lock, &port_lock_key);
 
 	memset(&termios, 0, sizeof(struct ktermios));
@@ -1948,11 +1948,11 @@ int uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)
 			set_bit(ASYNCB_SUSPENDED, &port->flags);
 			clear_bit(ASYNCB_INITIALIZED, &port->flags);
 
-			spin_lock_irq(&uport->lock);
+			raw_spin_lock_irq(&uport->lock);
 			ops->stop_tx(uport);
 			ops->set_mctrl(uport, 0);
 			ops->stop_rx(uport);
-			spin_unlock_irq(&uport->lock);
+			raw_spin_unlock_irq(&uport->lock);
 		}
 
 		/*
@@ -2037,9 +2037,9 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 		int ret;
 
 		uart_change_pm(state, UART_PM_STATE_ON);
-		spin_lock_irq(&uport->lock);
+		raw_spin_lock_irq(&uport->lock);
 		ops->set_mctrl(uport, 0);
-		spin_unlock_irq(&uport->lock);
+		raw_spin_unlock_irq(&uport->lock);
 		if (console_suspend_enabled || !uart_console(uport)) {
 			/* Protected by port mutex for now */
 			struct tty_struct *tty = port->tty;
@@ -2047,10 +2047,10 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 			if (ret == 0) {
 				if (tty)
 					uart_change_speed(tty, state, NULL);
-				spin_lock_irq(&uport->lock);
+				raw_spin_lock_irq(&uport->lock);
 				ops->set_mctrl(uport, uport->mctrl);
 				ops->start_tx(uport);
-				spin_unlock_irq(&uport->lock);
+				raw_spin_unlock_irq(&uport->lock);
 				set_bit(ASYNCB_INITIALIZED, &port->flags);
 			} else {
 				/*
@@ -2143,9 +2143,9 @@ uart_configure_port(struct uart_driver *drv, struct uart_state *state,
 		 * keep the DTR setting that is set in uart_set_options()
 		 * We probably don't need a spinlock around this, but
 		 */
-		spin_lock_irqsave(&port->lock, flags);
+		raw_spin_lock_irqsave(&port->lock, flags);
 		port->ops->set_mctrl(port, port->mctrl & TIOCM_DTR);
-		spin_unlock_irqrestore(&port->lock, flags);
+		raw_spin_unlock_irqrestore(&port->lock, flags);
 
 		/*
 		 * If this driver supports console, and it hasn't been
@@ -2618,7 +2618,7 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)
 	 * initialised.
 	 */
 	if (!(uart_console(uport) && (uport->cons->flags & CON_ENABLED))) {
-		spin_lock_init(&uport->lock);
+		raw_spin_lock_init(&uport->lock);
 		lockdep_set_class(&uport->lock, &port_lock_key);
 	}
 
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index 94d3215..e8035ca 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -147,20 +147,20 @@ void tty_buffer_flush(struct tty_struct *tty)
 	struct tty_bufhead *buf = &port->buf;
 	unsigned long flags;
 
-	spin_lock_irqsave(&buf->lock, flags);
+	raw_spin_lock_irqsave(&buf->lock, flags);
 
 	/* If the data is being pushed to the tty layer then we can't
 	   process it here. Instead set a flag and the flush_to_ldisc
 	   path will process the flush request before it exits */
 	if (test_bit(TTYP_FLUSHING, &port->iflags)) {
 		set_bit(TTYP_FLUSHPENDING, &port->iflags);
-		spin_unlock_irqrestore(&buf->lock, flags);
+		raw_spin_unlock_irqrestore(&buf->lock, flags);
 		wait_event(tty->read_wait,
 				test_bit(TTYP_FLUSHPENDING, &port->iflags) == 0);
 		return;
 	} else
 		__tty_buffer_flush(port);
-	spin_unlock_irqrestore(&buf->lock, flags);
+	raw_spin_unlock_irqrestore(&buf->lock, flags);
 }
 
 /**
@@ -213,7 +213,7 @@ int tty_buffer_request_room(struct tty_port *port, size_t size)
 	struct tty_buffer *b, *n;
 	int left;
 	unsigned long flags;
-	spin_lock_irqsave(&buf->lock, flags);
+	raw_spin_lock_irqsave(&buf->lock, flags);
 	/* OPTIMISATION: We could keep a per tty "zero" sized buffer to
 	   remove this conditional if its worth it. This would be invisible
 	   to the callers */
@@ -235,7 +235,7 @@ int tty_buffer_request_room(struct tty_port *port, size_t size)
 		} else
 			size = left;
 	}
-	spin_unlock_irqrestore(&buf->lock, flags);
+	raw_spin_unlock_irqrestore(&buf->lock, flags);
 	return size;
 }
 EXPORT_SYMBOL_GPL(tty_buffer_request_room);
@@ -335,10 +335,10 @@ void tty_schedule_flip(struct tty_port *port)
 	unsigned long flags;
 	WARN_ON(port->low_latency);
 
-	spin_lock_irqsave(&buf->lock, flags);
+	raw_spin_lock_irqsave(&buf->lock, flags);
 	if (buf->tail != NULL)
 		buf->tail->commit = buf->tail->used;
-	spin_unlock_irqrestore(&buf->lock, flags);
+	raw_spin_unlock_irqrestore(&buf->lock, flags);
 	schedule_work(&buf->work);
 }
 EXPORT_SYMBOL(tty_schedule_flip);
@@ -432,7 +432,7 @@ static void flush_to_ldisc(struct work_struct *work)
 	if (disc == NULL)	/*  !TTY_LDISC */
 		return;
 
-	spin_lock_irqsave(&buf->lock, flags);
+	raw_spin_lock_irqsave(&buf->lock, flags);
 
 	if (!test_and_set_bit(TTYP_FLUSHING, &port->iflags)) {
 		struct tty_buffer *head;
@@ -456,10 +456,10 @@ static void flush_to_ldisc(struct work_struct *work)
 			char_buf = head->char_buf_ptr + head->read;
 			flag_buf = head->flag_buf_ptr + head->read;
 			head->read += count;
-			spin_unlock_irqrestore(&buf->lock, flags);
+			raw_spin_unlock_irqrestore(&buf->lock, flags);
 			disc->ops->receive_buf(tty, char_buf,
 							flag_buf, count);
-			spin_lock_irqsave(&buf->lock, flags);
+			raw_spin_lock_irqsave(&buf->lock, flags);
 			/* Ldisc or user is trying to flush the buffers.
 			   We may have a deferred request to flush the
 			   input buffer, if so pull the chain under the lock
@@ -474,7 +474,7 @@ static void flush_to_ldisc(struct work_struct *work)
 		clear_bit(TTYP_FLUSHING, &port->iflags);
 	}
 
-	spin_unlock_irqrestore(&buf->lock, flags);
+	raw_spin_unlock_irqrestore(&buf->lock, flags);
 
 	tty_ldisc_deref(disc);
 }
@@ -512,10 +512,10 @@ void tty_flip_buffer_push(struct tty_port *port)
 	struct tty_bufhead *buf = &port->buf;
 	unsigned long flags;
 
-	spin_lock_irqsave(&buf->lock, flags);
+	raw_spin_lock_irqsave(&buf->lock, flags);
 	if (buf->tail != NULL)
 		buf->tail->commit = buf->tail->used;
-	spin_unlock_irqrestore(&buf->lock, flags);
+	raw_spin_unlock_irqrestore(&buf->lock, flags);
 
 #ifndef CONFIG_PREEMPT_RT_FULL
 	if (port->low_latency)
@@ -543,7 +543,7 @@ void tty_buffer_init(struct tty_port *port)
 {
 	struct tty_bufhead *buf = &port->buf;
 
-	spin_lock_init(&buf->lock);
+	raw_spin_lock_init(&buf->lock);
 	buf->head = NULL;
 	buf->tail = NULL;
 	buf->free = NULL;
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 2ea3a99..6414962 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -115,7 +115,7 @@ struct uart_icount {
 typedef unsigned int __bitwise__ upf_t;
 
 struct uart_port {
-	spinlock_t		lock;			/* port lock */
+	raw_spinlock_t		lock;			/* port lock */
 	unsigned long		iobase;			/* in/out[bwl] */
 	unsigned char __iomem	*membase;		/* read/write[bwl] */
 	unsigned int		(*serial_in)(struct uart_port *, int);
diff --git a/include/linux/tty.h b/include/linux/tty.h
index 8780bd2..f28ce4d 100644
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -53,7 +53,7 @@ struct tty_buffer {
 
 struct tty_bufhead {
 	struct work_struct work;
-	spinlock_t lock;
+	raw_spinlock_t lock;
 	struct tty_buffer *head;	/* Queue head */
 	struct tty_buffer *tail;	/* Active buffer */
 	struct tty_buffer *free;	/* Free queue head */
-- 
1.7.9.5

