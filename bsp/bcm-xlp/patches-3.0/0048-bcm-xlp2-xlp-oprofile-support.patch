From aadf6c902d0919fca3e137f172bb410ac88be327 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 19:16:51 +0800
Subject: [PATCH 48/58] bcm-xlp2: xlp oprofile support

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/oprofile/Makefile          |    1 +
 arch/mips/oprofile/common.c          |    1 +
 arch/mips/oprofile/op_model_mipsxx.c |  105 ++++++++++++++++++++++++++--------
 3 files changed, 83 insertions(+), 24 deletions(-)

diff --git a/arch/mips/oprofile/Makefile b/arch/mips/oprofile/Makefile
index 9c0a678..cec4653 100644
--- a/arch/mips/oprofile/Makefile
+++ b/arch/mips/oprofile/Makefile
@@ -13,4 +13,5 @@ oprofile-$(CONFIG_CPU_MIPS64)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_R10000)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_SB1)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_XLR)		+= op_model_mipsxx.o
+oprofile-$(CONFIG_CPU_XLP)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_LOONGSON2)	+= op_model_loongson2.o
diff --git a/arch/mips/oprofile/common.c b/arch/mips/oprofile/common.c
index af763e8..16c2f8e 100644
--- a/arch/mips/oprofile/common.c
+++ b/arch/mips/oprofile/common.c
@@ -92,6 +92,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	case CPU_R12000:
 	case CPU_R14000:
 	case CPU_XLR:
+	case CPU_XLP:
 		lmodel = &op_model_mipsxx_ops;
 		break;
 
diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index e4b1140..cb44ccb 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -30,10 +30,14 @@
 #define M_PERFCTL_MORE			(1UL	  << 31)
 
 #define M_COUNTER_OVERFLOW		(1UL	  << 31)
+#define M_COUNTER_OVERFLOW_64		(1UL      << 63)
 
 /* Netlogic XLR specific, count events in all threads in a core */
 #define M_PERFCTL_COUNT_ALL_THREADS	(1UL	  << 13)
 
+/* BROADCOM XLP specific, count events in all threads in a core */
+#define M_XLP_PERFCTL_COUNT_ALL_THREADS	(1UL      << 25)
+
 static int (*save_perf_irq)(void);
 
 /*
@@ -136,11 +140,48 @@ __define_perf_accessors(perfctrl, 1, 3)
 __define_perf_accessors(perfctrl, 2, 0)
 __define_perf_accessors(perfctrl, 3, 1)
 
+#define r_c0_perfcntr0_64()	read_c0_perfcntr0_64()
+#define r_c0_perfcntr1_64()	read_c0_perfcntr1_64()
+#define r_c0_perfcntr2_64()	read_c0_perfcntr2_64()
+#define r_c0_perfcntr3_64()	read_c0_perfcntr3_64()
+
+#define w_c0_perfcntr0_64(n)	write_c0_perfcntr0_64(n)
+#define w_c0_perfcntr1_64(n)	write_c0_perfcntr1_64(n)
+#define w_c0_perfcntr2_64(n)	write_c0_perfcntr2_64(n)
+#define w_c0_perfcntr3_64(n)	write_c0_perfcntr3_64(n)
+
+#ifdef CONFIG_CPU_XLP
+#define cpu_has_64bit_perfcntr()	1
+#else
+#define cpu_has_64bit_perfcntr()	0
+#endif
+
+#define init_c0_perfcntr(n, reg)					\
+{									\
+	do {								\
+		if (cpu_has_64bit_perfcntr())				\
+			w_c0_perfcntr ## n ## _64(reg.counter64[n]);	\
+		else							\
+			w_c0_perfcntr ## n(reg.counter[n]);		\
+	} while (0);							\
+}
+
+#define setup_c0_perfcntr(n)						\
+{									\
+	do {								\
+		if (cpu_has_64bit_perfcntr())				\
+			w_c0_perfcntr ## n ## _64(reg.counter64[n]);	\
+		else							\
+			w_c0_perfcntr ## n(reg.counter[n]);		\
+	} while (0);							\
+}
+
 struct op_mips_model op_model_mipsxx_ops;
 
 static struct mipsxx_register_config {
 	unsigned int control[4];
 	unsigned int counter[4];
+	uint64_t     counter64[4];
 } reg;
 
 /* Compute all of the registers in preparation for enabling profiling.	*/
@@ -154,6 +195,7 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 	for (i = 0; i < counters; i++) {
 		reg.control[i] = 0;
 		reg.counter[i] = 0;
+		reg.counter64[i] = 0;
 
 		if (!ctr[i].enabled)
 			continue;
@@ -168,7 +210,12 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 			reg.control[i] |= M_PERFCTL_EXL;
 		if (current_cpu_type() == CPU_XLR)
 			reg.control[i] |= M_PERFCTL_COUNT_ALL_THREADS;
-		reg.counter[i] = 0x80000000 - ctr[i].count;
+		if (current_cpu_type() == CPU_XLP)
+			reg.control[i] |= M_XLP_PERFCTL_COUNT_ALL_THREADS;
+		if (cpu_has_64bit_perfcntr())
+			reg.counter64[i] = 0x8000000000000000 - ctr[i].count;
+		else
+			reg.counter[i] = 0x80000000 - ctr[i].count;
 	}
 }
 
@@ -184,16 +231,16 @@ static void mipsxx_cpu_setup(void *args)
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(0);
-		w_c0_perfcntr3(reg.counter[3]);
+		setup_c0_perfcntr(3);
 	case 3:
 		w_c0_perfctrl2(0);
-		w_c0_perfcntr2(reg.counter[2]);
+		setup_c0_perfcntr(2);
 	case 2:
 		w_c0_perfctrl1(0);
-		w_c0_perfcntr1(reg.counter[1]);
+		setup_c0_perfcntr(1);
 	case 1:
 		w_c0_perfctrl0(0);
-		w_c0_perfcntr0(reg.counter[0]);
+		setup_c0_perfcntr(0);
 	}
 }
 
@@ -241,8 +288,7 @@ static int mipsxx_perfcount_handler(void)
 {
 	unsigned int counters = op_model_mipsxx_ops.num_counters;
 	unsigned int control;
-	unsigned int counter;
-	int handled = IRQ_NONE;
+	int ovf,  handled = IRQ_NONE;
 
 	if (cpu_has_mips_r2 && !(read_c0_cause() & (1 << 26)))
 		return handled;
@@ -251,12 +297,16 @@ static int mipsxx_perfcount_handler(void)
 #define HANDLE_COUNTER(n)						\
 	case n + 1:							\
 		control = r_c0_perfctrl ## n();				\
-		counter = r_c0_perfcntr ## n();				\
-		if ((control & M_PERFCTL_INTERRUPT_ENABLE) &&		\
-		    (counter & M_COUNTER_OVERFLOW)) {			\
-			oprofile_add_sample(get_irq_regs(), n);		\
-			w_c0_perfcntr ## n(reg.counter[n]);		\
-			handled = IRQ_HANDLED;				\
+		if (control & M_PERFCTL_INTERRUPT_ENABLE) {		\
+			if (cpu_has_64bit_perfcntr())			\
+				ovf = (((r_c0_perfcntr ## n ## _64()) & M_COUNTER_OVERFLOW_64) >> 63);\
+			else						\
+				ovf = r_c0_perfcntr ## n() & M_COUNTER_OVERFLOW;\
+			if (ovf) {					\
+				oprofile_add_sample(get_irq_regs(), n);	\
+				setup_c0_perfcntr(n);			\
+				handled = IRQ_HANDLED;			\
+			}						\
 		}
 	HANDLE_COUNTER(3)
 	HANDLE_COUNTER(2)
@@ -330,7 +380,7 @@ static irqreturn_t mipsxx_perfcount_int(int irq, void *dev_id)
 
 static int __init mipsxx_init(void)
 {
-	int counters;
+	int counters, perfirq;
 
 	counters = n_counters();
 	if (counters == 0) {
@@ -405,18 +455,25 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/xlr";
 		break;
 
+	 case CPU_XLP:
+		op_model_mipsxx_ops.cpu_type = "mips/xlp";
+		break;
+
 	default:
 		printk(KERN_ERR "Profiling unsupported for this CPU\n");
 
 		return -ENODEV;
 	}
 
-	save_perf_irq = perf_irq;
-	perf_irq = mipsxx_perfcount_handler;
-
-	if ((cp0_perfcount_irq >= 0) && (cp0_compare_irq != cp0_perfcount_irq))
-		return request_irq(cp0_perfcount_irq, mipsxx_perfcount_int,
-			0, "Perfcounter", save_perf_irq);
+	if (cpu_has_mips_r2){
+		perfirq = MIPS_CPU_IRQ_BASE + cp0_perfcount_irq;
+		if (request_irq(perfirq, mipsxx_perfcount_int,
+				IRQF_PERCPU, "mips_oprofile", NULL))
+			printk(KERN_ERR "Unable to request IRQ%d for MIPS", perfirq);
+	} else {
+		save_perf_irq = perf_irq;
+		perf_irq = mipsxx_perfcount_handler;
+	}
 
 	return 0;
 }
@@ -425,13 +482,13 @@ static void mipsxx_exit(void)
 {
 	int counters = op_model_mipsxx_ops.num_counters;
 
-	if ((cp0_perfcount_irq >= 0) && (cp0_compare_irq != cp0_perfcount_irq))
-		free_irq(cp0_perfcount_irq, save_perf_irq);
-
 	counters = counters_per_cpu_to_total(counters);
 	on_each_cpu(reset_counters, (void *)(long)counters, 1);
 
-	perf_irq = save_perf_irq;
+	if(cpu_has_mips_r2)
+		free_irq(MIPS_CPU_IRQ_BASE + cp0_perfcount_irq, NULL);
+	else
+		perf_irq = save_perf_irq;
 }
 
 struct op_mips_model op_model_mipsxx_ops = {
-- 
1.7.9.5

