From 4c308ab5bd39c1f8fd3c1d2c541fa99130ad3da0 Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Fri, 21 Feb 2014 14:26:35 +0530
Subject: [PATCH 134/163] seclib:HALX support changes

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/netlogic/lib/seclib/cryptosoc_lib.c |  192 +++++++++++++++++++++-
 arch/mips/netlogic/lib/seclib/cryptosoc_lib.h |  132 ++++++++++++++-
 arch/mips/netlogic/lib/seclib/eccsoc_lib.h    |  122 +++++++++++++-
 arch/mips/netlogic/lib/seclib/rsasoc_lib.h    |  124 ++++++++++++++
 arch/mips/netlogic/lib/seclib/saesoc_defs.h   |   15 ++
 arch/mips/netlogic/lib/seclib/saesoc_lib.h    |  219 ++++++++++++++++++++++++-
 6 files changed, 799 insertions(+), 5 deletions(-)

diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
index 0bb5746..3536f3f 100644
--- a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
@@ -144,16 +144,28 @@
 */
 #include "cryptosoc_ctx.h"
 #include "saesoc_defs.h"
-#include "cryptosoc_lib_priv.h"
 
-int cryptosoc_ptype_gen;
+#ifndef __SECLIB_HALX
+#include "cryptosoc_lib_priv.h"
 static int cryptosoc_base_vc[CRYPTOSOC_TYPE_MAX];
 static int cryptosoc_lmt_vc[CRYPTOSOC_TYPE_MAX];
+#endif
+
+int cryptosoc_ptype_gen;
 #define relax() __asm__ __volatile__("sync": : :"memory")
 
+
+#ifndef __SECLIB_HALX
 cryptosoc__mem_alloc *cryptosoc_mem_alloc;
 cryptosoc__mem_free *cryptosoc_mem_free;
+#else
+static cryptosoc_req_qhdl_t cryptosoc_req_qhdl_base[CRYPTOSOC_TYPE_MAX];
+static cryptosoc_req_qhdl_t cryptosoc_req_qhdl_lmt[CRYPTOSOC_TYPE_MAX];
+crypto_mem_alloc_t *cryptosoc_mem_alloc;
+crypto_mem_free_t *cryptosoc_mem_free;
+#endif
 
+#ifndef __SECLIB_HALX
 /**
 * cryptosoc_lib_init - Initialize the sae/rsa/ecc soc library parameters 
 *  based on the processor type.
@@ -212,6 +224,69 @@ int cryptosoc_lib_init(struct cryptosoc_lib_params *params,
 
 	return CRYPTOSOC_OK;
 }
+#else
+/**
+* cryptosoc_lib_init - Initialize the sae/rsa/ecc soc library parameters 
+*  based on the processor type.
+* @params: Pointer to lib param structure(output) 
+* @mem_alloc: Function pointer to allocate physically contiguous memory
+*    This should return memory pointer in success.(input)
+* @mem_free: Function to free the memory.(input)
+* @arg: For future use
+*
+* This should be called once from every application which is intended 
+* to use this library. This function fills the params struct and returned
+* to the user. 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+int cryptosoc_lib_init(struct cryptosoc_lib_params *params, 
+		struct cryptosoc_lib_func *func,
+		void *arg)
+{
+	int i;
+
+	/* return error if callbacks are not provided */
+	if(!func->mem_alloc  || !func->mem_free) {
+			cryptosoc_err_print("%s:%d, Lib callbacks are not registered\n", 
+					__FUNCTION__, __LINE__);
+			return -CRYPTOSOC_EINVAL;
+	}
+	cryptosoc_mem_alloc = func->mem_alloc;
+	cryptosoc_mem_free	= func->mem_free;
+
+	memcpy(&cryptosoc_lib_f, func, sizeof(cryptosoc_lib_f));
+
+	params->saesoc_feature_set = 0;
+	params->saesoc_per_pkt_update_set = 0;
+
+	/* gen type should be filled by the priv init 
+	implementation specific init routine */
+	if(cryptosoc_lib_f.init && (cryptosoc_lib_f.init(params) < 0))
+		return  -CRYPTOSOC_EINVAL;
+
+	if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2) {
+		/* for griffin and associated versions */
+		params->saesoc_feature_set |= SAESOC_FF_GEN2_PTYPE;
+		params->saesoc_per_pkt_update_set |= 0;
+	} else { 
+		/* For eagle and associated versions */
+		//params->saesoc_feature_set = SAESOC_FF_GEN1_PTYPE | 
+		  //SAESOC_FF_3DES_KEY_SWAP_SUPPORT | SAESOC_FF_CIPHER_ZUC_SUPPORT;
+		params->saesoc_feature_set |= SAESOC_FF_GEN1_PTYPE;
+		/* TODO : If xlp 3xx add zuc support */
+		params->saesoc_per_pkt_update_set |= SAESOC_PER_PKT_UF_GEN1_PTYPE;
+	}
+
+	for(i = 0; i < CRYPTOSOC_TYPE_MAX; i++) {
+		if(cryptosoc_lib_f.get_req_qhdl)
+			cryptosoc_lib_f.get_req_qhdl(i, CRYPTOSOC_REQ_QHDL_PARALLEL,
+				&cryptosoc_req_qhdl_base[i], &cryptosoc_req_qhdl_lmt[i]);
+	}
+
+	return CRYPTOSOC_OK;
+}
+#endif
 
 /**
 * cryptosoc_lib_finish - Crypto library finish function 
@@ -220,9 +295,16 @@ int cryptosoc_lib_init(struct cryptosoc_lib_params *params,
 */
 int cryptosoc_lib_finish(struct cryptosoc_lib_params *params)
 {
+#ifndef __SECLIB_HALX
 	return cryptosoc_lib_priv_finish();
+#else
+	if(cryptosoc_lib_f.finish)
+		return (cryptosoc_lib_f.finish(params));
+	return CRYPTOSOC_OK;
+#endif
 }	
 
+#ifndef __SECLIB_HALX
 /**
 * cryptosoc_get_basevc_limitvc - Retrieve the SAE/RSA/ECC base vc and limit vc
 * @soc : Soc type, see enum cryptosoc_soc_type
@@ -296,6 +378,77 @@ int cryptosoc_get_highpri_channel_vcmask(enum cryptosoc_soc_type soc,
 	*vc_mask = 0x4; 
 	return CRYPTOSOC_OK;
 }
+#else
+/**
+* cryptosoc_get_req_qhandle - Get the request queue handle 
+* to send the operation request to the engine
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @type : Type, see cryptosoc_req_qhdl_type
+* @hdl : Pointer to the handle(output)
+*
+* Return : CRYPTOSOC_OK, CRYPTOSOC_EINVAL on error.
+*
+* Note: 
+* If the request returns error, application can 
+* call this api with some other type if it want to 
+* continue.
+*/
+int cryptosoc_get_req_qhandle(
+		enum cryptosoc_soc_type soc,
+		enum cryptosoc_req_qhdl_type type,
+		cryptosoc_req_qhdl_t *hdl)
+{
+	cryptosoc_req_qhdl_t base, lmt;
+	int rv = -CRYPTOSOC_EINVAL;
+	if(cryptosoc_lib_f.get_req_qhdl) {
+		rv = cryptosoc_lib_f.get_req_qhdl(soc, type, &base, &lmt);
+		*hdl = base;
+	}
+	return rv;
+}
+
+/**
+* cryptosoc_get_rsp_qhandle - Get the response queue handle 
+* to receive the response from the engine
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @type : Type, see cryptosoc_rsp_qhdl_type
+* @cpu : Cpu number, valid only if the type is PCPU.
+* @hdl : Pointer to the handle(output)
+*
+* Return : CRYPTOSOC_OK on success, CRYPTOSOC_EINVAL on error.
+* 
+*/
+int cryptosoc_get_rsp_qhandle(
+		enum cryptosoc_soc_type soc,
+		enum cryptosoc_rsp_qhdl_type type,
+		int cpu,
+		cryptosoc_rsp_qhdl_t *hdl)
+{
+	int rv = -CRYPTOSOC_EINVAL;
+	if(cryptosoc_lib_f.get_rsp_qhdl)
+		rv = cryptosoc_lib_f.get_rsp_qhdl(soc, type, cpu, hdl);
+	return rv;
+}
+
+/**
+* cryptosoc_get_fwd_qhandle - Get the forward queue handle 
+* to pass the response from the crypto engine to other
+* engines
+* @type : Type, see cryptosoc_rsp_qhdl_type
+* @hdl : Pointer to the handle(output)
+*
+* Return : CRYPTOSOC_OK on success, CRYPTOSOC_EINVAL on error.
+*/
+int cryptosoc_get_rsp_fwd_qhandle(
+		enum cryptosoc_rsp_fwd_qhdl_type type,
+		cryptosoc_rsp_fwd_qhdl_t *hdl)
+{
+	int rv = -CRYPTOSOC_EINVAL;
+	if(cryptosoc_lib_f.get_rsp_fwd_qhdl)
+		rv = cryptosoc_lib_f.get_rsp_fwd_qhdl(type, hdl);
+	return rv;
+}
+#endif
 
 /**
 * DOC: Crypto Sync/Async Context Implementation Details
@@ -604,11 +757,19 @@ int cryptosoc_new_context(
 		}
 		cpriv->max_pending_reqs = cparam->max_pending_reqs;
 
+#ifndef __SECLIB_HALX
 		if(crypto_ctxt_alloc(ctx) < 0) {
 			cryptosoc_err_print("%s, Error, Context creation failed\n",
 					__FUNCTION__); 
 			goto err_exit;
 		}
+#else
+	if(cryptosoc_lib_f.ctx_alloc && (cryptosoc_lib_f.ctx_alloc(ctx) < 0)) {
+			cryptosoc_err_print("%s, Error, Context creation failed\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+#endif
 
 		for(i = 0; i < cpriv->max_pending_reqs ; i++)
 			cpriv->free_req_index[i] = i;
@@ -630,11 +791,19 @@ int cryptosoc_new_context(
 		if(cparam->max_pending_reqs < CRYPTOSOC_MAX_PENDING_REQS_PER_CTX)
 			 cpriv->max_pending_reqs++;
 
+#ifndef __SECLIB_HALX
 		if(crypto_ctxt_alloc(ctx) < 0) {
 			cryptosoc_err_print("%s, Error, Context creation failed\n",
 					__FUNCTION__); 
 			goto err_exit;
 		}
+#else
+		if(cryptosoc_lib_f.ctx_alloc && (cryptosoc_lib_f.ctx_alloc(ctx) < 0)) {
+			cryptosoc_err_print("%s, Error, Context creation failed\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+#endif
 
 		cpriv->flags = cparam->flags;
 
@@ -713,8 +882,14 @@ int cryptosoc_close_ctx(struct cryptosoc_ctx *ctx)
 		cryptosoc_unlock(&cpriv->lock);
 	}
 	if(ctx->fd >= 0) {
+#ifndef __SECLIB_HALX
 		if((rv = crypto_ctxt_free(ctx)) < 0)
 			return rv;
+#else
+		if(cryptosoc_lib_f.ctx_free && 
+				((rv = cryptosoc_lib_f.ctx_free(ctx)) < 0))
+			return rv;
+#endif
 		if(close(ctx->fd) < 0)
 			return -CRYPTOSOC_EINVAL;
 	}
@@ -757,7 +932,11 @@ cont_rcv:
 	while(xlp_message_receive_2(rsp_vc, &src, &size, (unsigned int *)&code, 
 				&rx_msg0, &rx_msg1) != 0);
 
+#ifndef __SECLIB_HALX
 	if(!(src >= cryptosoc_base_vc[soc] && src <= cryptosoc_lmt_vc[soc])) {
+#else
+	if(!(src >= (int)cryptosoc_req_qhdl_base[soc] && src <= (int)cryptosoc_req_qhdl_lmt[soc])) {
+#endif
 		cryptosoc_err_print(
 				"Error : Msg recved from unknown src %d, continuing the loop\n", 
 				src);
@@ -828,7 +1007,12 @@ try_again:
 retry:
 	if(cpriv->flags & CRYPTOSOC_CTX_SYNC_SHRD_POLL_EN)
 		relax();
+#ifndef __SECLIB_HALX
 	else if((rv = crypto_ctxt_shrd_wait_for_response(fd)) < 0)
+#else
+	else if(cryptosoc_lib_f.wait_for_rsp && 
+			((rv = cryptosoc_lib_f.wait_for_rsp(fd)) < 0))
+#endif
 		return rv;
 		
 	/* if no change in the response generator id */
@@ -986,7 +1170,11 @@ int cryptosoc_process_request(int gen_type2,
 cont_rcv:
 		while(xlp_message_receive_2(rsp_vc, &src, &size, (unsigned int *)&code, 
 					(uint64_t *)&msg0, (uint64_t *)&msg1) != 0);
+#ifndef __SECLIB_HALX
 		if(!(src >= cryptosoc_base_vc[soc] && src <= cryptosoc_lmt_vc[soc])) {
+#else
+		if(!(src >= (int)cryptosoc_req_qhdl_base[soc] && src <= (int)cryptosoc_req_qhdl_lmt[soc])) {
+#endif
 			cryptosoc_err_print(
 			"Error : Msg recved from unknown src %d, continuing the loop\n", 
 					src);
diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
index 786dd6a..ff93621 100644
--- a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
@@ -156,6 +156,50 @@ enum cryptosoc_soc_type {
 };
 
 /**
+* enum cryptosoc_req_qhdl_type - Request Queue Handle type
+* @CRYPTOSOC_REQ_QHDL_SERIAL : The requests send to this queue will be
+* processed by the engine by first in first out order.
+* @CRYPTOSOC_REQ_QHDL_PARALLEL: The requests send to this queue will be
+* processed by the engine in parallel, so the response order
+* is not guaranteed.
+* @CRYPTOSOC_REQ_QHDL_SERIAL_HIGHPRI: Similar to serial mode,
+* but the request in this queue will be processed first 
+* before any requests from the normal serial queue.
+* @CRYPTOSOC_REQ_QHDL_PARALLEL_HIGHPRI: Similar to parallel mode,
+* but the request in this queue will be processed first 
+* before any requests from the normal parallel queue.
+*/
+enum cryptosoc_req_qhdl_type {
+	CRYPTOSOC_REQ_QHDL_SERIAL = 0,
+	CRYPTOSOC_REQ_QHDL_PARALLEL,
+	CRYPTOSOC_REQ_QHDL_SERIAL_HIGHPRI,
+	CRYPTOSOC_REQ_QHDL_PARALLEL_HIGHPRI,
+};
+
+/**
+* enum cryptosoc_rsp_qhdl_type - Response Queue Handle type
+* @CRYPTOSOC_RSP_QHDL_PCPU : The responses from the engine
+* will be delivered to a per cpu queue. The application should
+* set an affinity to this cpu to receive the responses.
+* @CRYPTOSOC_RSP_QHDL_GLOBAL: The responses from the engine
+* will be delivered to a global queue. This will work only
+* with the context apis. 
+*/
+enum cryptosoc_rsp_qhdl_type {
+	CRYPTOSOC_RSP_QHDL_PCPU = 0,
+	CRYPTOSOC_RSP_QHDL_GLOBAL,
+};
+
+/**
+* enum cryptosoc_rsp_fwd_qhdl_type - Response Queue Handle type
+* @CRYPTOSOC_RSP_FWD_QHDL_NAE : The responses from the sae engine is 
+* forwarded to the nae.
+*/
+enum cryptosoc_rsp_fwd_qhdl_type {
+	CRYPTOSOC_RSP_FWD_QHDL_NAE=0
+};
+
+/**
 * struct cryptosoc_lib_params - Crypto(sae,rsa,ecc) soc library params based on 
 *  the processor type
 * @saesoc_feature_set: Feature set variable and associated flags for SAE engine. 
@@ -168,6 +212,63 @@ struct cryptosoc_lib_params {
 	unsigned int saesoc_per_pkt_update_set ; 
 };
 
+typedef int cryptosoc_req_qhdl_t;
+typedef int cryptosoc_rsp_qhdl_t;
+typedef int cryptosoc_rsp_fwd_qhdl_t;
+typedef void *crypto_mem_alloc_t(size_t align, size_t size);
+typedef void crypto_mem_free_t(void *ptr);
+typedef int crypto_get_req_qhdl_t(
+		enum cryptosoc_soc_type soc,
+		enum cryptosoc_req_qhdl_type type,
+		cryptosoc_req_qhdl_t *base, cryptosoc_req_qhdl_t *lmt);
+typedef int crypto_get_rsp_qhdl_t(
+		enum cryptosoc_soc_type soc,
+		enum cryptosoc_rsp_qhdl_type type,
+		int cpu, cryptosoc_rsp_qhdl_t *hdl);
+typedef int crypto_get_rsp_fwd_qhdl_t(
+		enum cryptosoc_rsp_fwd_qhdl_type type,
+		cryptosoc_rsp_fwd_qhdl_t *hdl);
+
+
+/**
+* struct cryptosoc_lib_func - Crypto(sae,rsa,ecc) soc library functions which 
+*  has to be provided by the application/OS(callbacks).
+** @mem_alloc: Function pointer to allocate physically contiguous memory
+*    This should return memory pointer in success.(input)
+* @mem_free: Function to free the memory.(input)
+* @init: This will be called during cryptosoc_lib_init
+* @finish: This will be called during cryptosoc_lib_finish
+* @get_req_qhdl: This should fill the request handle for the given params 
+* @get_rsp_qhdl: This should fill the response handle for the given params 
+* @get_rsp_fwd_qhdl: This should fill the response forward 
+*    handle for the given params
+* @wait_for_rsp :This function should wait for response and returns only
+*  after receiving the message. Used only in Sync shared mode.
+* @ctx_alloc : Application/OS specific function which will be called during
+*  the cryptosoc_ctx_alloc
+* @ctx_free : Application/OS specific function which will be called during
+*  the cryptosoc_ctx_free
+*/
+
+struct cryptosoc_lib_func {
+	/* Application has to provide the below functions,
+	*  depending on the implementation */
+	void *(*mem_alloc)(size_t align, size_t size);
+	void (*mem_free)(void *ptr);
+	int (*init)(struct cryptosoc_lib_params *p);
+	int (*finish)(struct cryptosoc_lib_params *p);
+	int (*get_req_qhdl)( enum cryptosoc_soc_type soc,
+		enum cryptosoc_req_qhdl_type type,
+		cryptosoc_req_qhdl_t *base, cryptosoc_req_qhdl_t *lmt);
+	int (*get_rsp_qhdl)(enum cryptosoc_soc_type soc,
+		enum cryptosoc_rsp_qhdl_type type,
+		int cpu, cryptosoc_rsp_qhdl_t *hdl);
+	int (*get_rsp_fwd_qhdl)(enum cryptosoc_rsp_fwd_qhdl_type type,
+		cryptosoc_rsp_fwd_qhdl_t *hdl);
+	int (*wait_for_rsp)(int fd);
+	int (*ctx_alloc)(void *ctx);
+	int (*ctx_free)(void *ctx);
+};
 
 /**
 * struct saesoc_rsp_result - Crypto engine result 
@@ -221,17 +322,30 @@ static inline void cryptosoc_lock_init(cryptosoc_lock_t *lock)
 }
 
 
-
+#ifndef __SECLIB_HALX
 typedef void *cryptosoc__mem_alloc(size_t align, size_t size);
 typedef void cryptosoc__mem_free(void *ptr);
 
 extern cryptosoc__mem_alloc *cryptosoc_mem_alloc;
 extern cryptosoc__mem_free *cryptosoc_mem_free;
+#endif
+extern crypto_mem_alloc_t *cryptosoc_mem_alloc;
+extern crypto_mem_free_t *cryptosoc_mem_free;
+
+
 extern int cryptosoc_ptype_gen;
+
+#ifndef __SECLIB_HALX
 extern int cryptosoc_lib_init(struct cryptosoc_lib_params *params, 
 		void *(mem_alloc)(size_t align, size_t size),
 		void (mem_free)(void *ptr),
 		void *arg);
+#else
+extern int cryptosoc_lib_init(struct cryptosoc_lib_params *params, 
+		struct cryptosoc_lib_func *func,
+		void *arg);
+#endif
+#ifndef __SECLIB_HALX
 extern int cryptosoc_get_basevc_limitvc(enum cryptosoc_soc_type soc, 
 		int *base_vc, int *lmt_vc);
 extern int cryptosoc_get_single_channel_vcmask(enum cryptosoc_soc_type soc, 
@@ -240,6 +354,7 @@ extern int cryptosoc_get_multi_channel_vcmask(enum cryptosoc_soc_type soc,
 		unsigned int *vc_mask);
 int cryptosoc_get_highpri_channel_vcmask(enum cryptosoc_soc_type soc, 
 		unsigned int *vc_mask);
+#endif
 extern int cryptosoc_process_request(int gen_type2, 
 		enum cryptosoc_soc_type soc,
 		int req_vc, int fbvc, 
@@ -247,6 +362,21 @@ extern int cryptosoc_process_request(int gen_type2,
 		_uint64_t msg0, _uint64_t msg1, _uint64_t msg2,
 		_uint64_t *rx_msg);
 
+extern int cryptosoc_get_req_qhandle(
+		enum cryptosoc_soc_type soc,
+		enum cryptosoc_req_qhdl_type type,
+		cryptosoc_req_qhdl_t *hdl);
+extern int cryptosoc_get_rsp_qhandle(
+		enum cryptosoc_soc_type soc,
+		enum cryptosoc_rsp_qhdl_type type,
+		int cpu,
+		cryptosoc_rsp_qhdl_t *hdl);
+extern int cryptosoc_get_rsp_fwd_qhandle(
+		enum cryptosoc_rsp_fwd_qhdl_type type,
+		cryptosoc_rsp_fwd_qhdl_t *hdl);
+
+
+
 #if defined(__mips__)
 /* last bit set indication - from lsb to msb ,
 *  clz instruction looks for number of cleared bit from msb to lsb
diff --git a/arch/mips/netlogic/lib/seclib/eccsoc_lib.h b/arch/mips/netlogic/lib/seclib/eccsoc_lib.h
index e51dc7e..2c6fd93 100644
--- a/arch/mips/netlogic/lib/seclib/eccsoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/eccsoc_lib.h
@@ -342,6 +342,7 @@ struct eccsoc_request_desc {
 }___cryptosoc_cacheline_aligned;
 
 
+#ifndef __SECLIB_HALX
 /**
 * struct eccsoc_extra_req_send_params - RSA send request options
 * @send_all_requests : 1/0, Send all the requests present in the data descriptor
@@ -357,6 +358,23 @@ struct eccsoc_extra_req_send_params {
 	int num_reqs;
 	_uint64_t async_rsp_arg;
 };
+#else
+/**
+* struct eccsoc_req_send_params - RSA send request options
+* @send_all_requests : 1/0, Send all the requests present in the data descriptor
+* @sreq_num : Starting request number, Ignored 
+*    if the send_all_requests is true.
+* @num_reqs : Number of requests from sreq_num, Ignored 
+*    if the send_all_requests is true.
+*  @async_rsp_arg: User given callback argument, used in async mode only
+*/
+struct eccsoc_req_send_params {
+	int send_all_requests;
+	int sreq_num;
+	int num_reqs;
+	_uint64_t async_rsp_arg;
+};
+#endif
 
 
 static int eccsoc_max_req_args[] =  {
@@ -1412,7 +1430,7 @@ static inline void eccsoc_dump_request_data(
 }
 
 
-
+#ifndef __SECLIB_HALX
 /**
 * eccsoc_process_request - Send/Receive the descriptor info to/from 
 * the engine
@@ -1512,6 +1530,108 @@ static inline int eccsoc_process_request(
 	}
 	return rv;
 }
+#else
+/**
+* eccsoc_process_request - Send/Receive the descriptor info to/from 
+* the engine
+* @ctx : Pointer to the context(input). 
+* @req_desc : Pointer to the request descriptor(input)
+* @req_vc: Transmit vc id.
+* @rsp_vc: Freeback vc id. 
+* @code: Message send code.
+* @retry_count: How many times the send should be retried before
+* 	telling it is failed
+* @mparam: Extra parameters for the send request(input)
+*   Functions sends out all the requests if mparam==NULL
+* @sync_res: Engine result response if mode is sync(output). 
+* Rsp should be allocated for the number of requests that
+* are going to be sent out.
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*
+* Note: 
+* if ctx != null, it does the operation as per the ctx mode
+* If ctx == null &  rsp != null, function sends the message
+* and wait for the response. 
+* if ctx == null & rsp == null, the function just send the message
+*/
+static inline int eccsoc_process_request(
+		struct cryptosoc_ctx *ctx,
+		struct eccsoc_request_desc *req_desc, 
+		cryptosoc_req_qhdl_t req_qhdl,
+		cryptosoc_rsp_qhdl_t rsp_qhdl,
+		struct eccsoc_req_send_params *mparam,
+		struct eccsoc_rsp_result *sync_res)
+{
+
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int idx, gen_type2=0;
+	_uint64_t fmn_entry0, fmn_entry1, fmn_entry2 = 0ULL;
+	void *mem, *rmem;
+	int sreq_num, ereq_num;
+	int rv = -CRYPTOSOC_EINVAL;
+	int req_vc = (int)req_qhdl;
+	int rsp_vc = (int)rsp_qhdl;
+	int code=0, retry_count=16;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	if(mparam == NULL || mparam->send_all_requests) {
+		sreq_num = 0;
+		ereq_num = dpriv->num_reqs;
+	} else {
+		sreq_num = mparam->sreq_num - 1;
+		ereq_num = sreq_num  +  mparam->num_reqs;
+
+		if((sreq_num >= dpriv->num_reqs) || (ereq_num >  dpriv->num_reqs)) 
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	fmn_entry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+
+	for(idx = sreq_num; idx < ereq_num; idx++) {
+		mem = dpriv->req_info[idx].eng_inp;
+		rmem = dpriv->req_info[idx].eng_res;
+
+		if(dpriv->req_info[idx].op < 0)
+			return -CRYPTOSOC_EINVAL;
+
+		fmn_entry0 = eccsoc_gen1_form_fmn_entry0( 
+				dpriv->req_info[idx].flags & ECCSOC_SRC_L3_ALLOC ? 1 : 0, 
+				dpriv->req_info[idx].type, dpriv->req_info[idx].op, 
+				cryptosoc_virt_to_phys((unsigned long)mem));
+		fmn_entry1 = eccsoc_gen1_form_fmn_entry1( 
+				dpriv->req_info[idx].flags & ECCSOC_DST_CLOBBER ? 1: 0,
+				dpriv->req_info[idx].flags & ECCSOC_DST_L3_ALLOC ? 1 : 0,
+				rsp_vc, 
+				cryptosoc_virt_to_phys((unsigned long)rmem));
+
+		cryptosoc_dbg_print("ECC process req, req_num %d type %d func %d numreqs %d\n",
+			idx, dpriv->req_info[idx].type, dpriv->req_info[idx].op, dpriv->num_reqs);
+
+		if(!ctx) {
+			rv = cryptosoc_process_request(gen_type2, CRYPTOSOC_ECC, 
+					req_vc, rsp_vc, code, retry_count,
+					fmn_entry0, fmn_entry1, fmn_entry2,
+					sync_res ? &sync_res->result : NULL);
+		} else {
+			rv = cryptosoc_process_ctx_request(gen_type2, ctx, CRYPTOSOC_ECC,
+					req_vc, rsp_vc, code, retry_count, 
+					fmn_entry0, fmn_entry1, fmn_entry2, 
+					sync_res ? &sync_res->result : NULL, NULL);
+		}
+		if(sync_res)
+			sync_res++;
+		if(rv < 0)
+			break;
+
+	}
+	return rv;
+}
+#endif
 
 /**
 * eccsoc_result_valid - Check the whether the result from the engine is 
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_lib.h b/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
index a3f6ea1..f6898d7 100644
--- a/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
@@ -210,6 +210,7 @@ struct rsasoc_request_desc {
 	char data[0];
 }___cryptosoc_cacheline_aligned;
 
+#ifndef __SECLIB_HALX
 /**
 * struct rsasoc_extra_req_send_params - RSA send request options
 * @send_all_requests : 1/0, Send all the requests present in the data descriptor
@@ -225,6 +226,25 @@ struct rsasoc_extra_req_send_params {
 	int num_reqs;
 	_uint64_t async_rsp_arg;
 };
+#else
+/**
+* struct rsasoc_req_send_params - RSA send request options
+* @send_all_requests : 1/0, Send all the requests present in the data descriptor
+* @sreq_num : Starting request number, Ignored 
+*    if the send_all_requests is true.
+* @num_reqs : Number of request from sreq_num, Ignored 
+*    if the send_all_requests is true.
+*  @async_rsp_arg: User given callback argument, used in async mode only
+*/
+struct rsasoc_req_send_params {
+	int send_all_requests;
+	int sreq_num;
+	int num_reqs;
+	_uint64_t async_rsp_arg;
+};
+
+
+#endif
 
 static inline struct rsasoc_request_desc *rsasoc_create_new_desc(
 		struct rsasoc_request_desc *desc,
@@ -524,6 +544,7 @@ static inline void rsasoc_dump_request_data(
 }
 
 
+#ifndef __SECLIB_HALX
 /**
 * rsasoc_process_request - Send/Receive the descriptor info to/from 
 * the engine
@@ -623,7 +644,110 @@ static inline int rsasoc_process_request(
 	}
 	return rv;
 }
+#else
+/**
+* rsasoc_process_request - Send/Receive the descriptor info to/from 
+* the engine
+* @ctx : Pointer to the context(input). 
+* @req_desc : Pointer to the request descriptor(input)
+* @req_vc: Transmit vc id.
+* @rsp_vc: Freeback vc id. 
+* @code: Message send code.
+* @retry_count: How many times the send should be retried before
+* 	telling it is failed
+* @mparam: Extra parameters for the send request(input)
+*   Functions sends out all the requests if mparam==NULL
+* @sync_res: Engine result response if mode is sync(output)
+* Rsp should be allocated for the number of requests that
+* are going to be sent out
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*
+* Note: 
+* if ctx != null, it does the operation as per the ctx mode
+* If ctx == null &  rsp != null, function sends the message
+* and wait for the response. 
+* if ctx == null & rsp == null, the function just send the message
+*
+*/
+static inline int rsasoc_process_request(
+		struct cryptosoc_ctx *ctx,
+		struct rsasoc_request_desc *req_desc, 
+		cryptosoc_req_qhdl_t req_qhdl,
+		cryptosoc_rsp_qhdl_t rsp_qhdl,
+		struct rsasoc_req_send_params *mparam,
+		struct rsasoc_rsp_result *sync_res)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int idx, gen_type2 = 0;
+	_uint64_t fmn_entry0, fmn_entry1, fmn_entry2 = 0ULL;
+	void *mem, *rmem;
+	int sreq_num, ereq_num;
+	int rv = -CRYPTOSOC_EINVAL;
+	int req_vc = (int)req_qhdl;
+	int rsp_vc = (int)rsp_qhdl;
+	int code=0, retry_count=16;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	if(mparam == NULL || mparam->send_all_requests) {
+		sreq_num = 0;
+		ereq_num = dpriv->num_reqs;
+	} else {
+		sreq_num = mparam->sreq_num - 1;
+		ereq_num = sreq_num  +  mparam->num_reqs;
+
+		if((sreq_num >= dpriv->num_reqs) || (ereq_num >  dpriv->num_reqs)) 
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	fmn_entry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+
+	for(idx = sreq_num; idx < ereq_num; idx++) {
+		mem = dpriv->req_info[idx].eng_inp;
+		rmem = dpriv->req_info[idx].eng_res;
+
+		if(dpriv->req_info[idx].op < 0)
+			return -CRYPTOSOC_EINVAL;
+
+		fmn_entry0 = rsasoc_gen1_form_fmn_entry0(
+				dpriv->req_info[idx].flags & RSASOC_SRC_L3_ALLOC ? 1 : 0, 
+				dpriv->req_info[idx].type, dpriv->req_info[idx].op, 
+				cryptosoc_virt_to_phys((unsigned long)mem));
+
+		fmn_entry1 = rsasoc_gen1_form_fmn_entry1(
+				dpriv->req_info[idx].flags & RSASOC_DST_CLOBBER ? 1: 0,
+				dpriv->req_info[idx].flags & RSASOC_DST_L3_ALLOC ? 1 : 0,
+				rsp_vc, 
+				cryptosoc_virt_to_phys((unsigned long)rmem));
+
+		//rsasoc_dump_request_data(req_desc, 1);
+
+		if(!ctx) {
+			rv = cryptosoc_process_request(gen_type2, CRYPTOSOC_RSA, 
+					req_vc, rsp_vc, code, retry_count,
+					fmn_entry0, fmn_entry1, fmn_entry2,
+					sync_res ? &sync_res->result : NULL);
+		} else {
+			rv =  cryptosoc_process_ctx_request(gen_type2, ctx, CRYPTOSOC_RSA,
+					req_vc, rsp_vc, code, retry_count, 
+					fmn_entry0, fmn_entry1, fmn_entry2, 
+					sync_res ? &sync_res->result : NULL, NULL);
+		}
+		if(sync_res)
+			sync_res++;
+
+		if(rv < 0)
+			break;
+	}
+	return rv;
+}
+
 
+#endif
 /**
 * rsasoc_result_valid - Check the whether the result from the engine is 
 * valid or not
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_defs.h
index fc522aa..6a733e0 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_defs.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_defs.h
@@ -169,6 +169,7 @@ enum saesoc_iv_mode {
 	SAESOC_IV_FROM_PKT_DESC = 1
 };
 
+#ifndef __SECLIB_HALX
 /** 
  * enum saesoc_ddesc_reset_op - Possible types to reset the data descriptor
  *
@@ -181,6 +182,20 @@ enum saesoc_ddesc_reset_op {
 	SAESOC_DDESC_RESET_ALL_FRAGS = 1,
 	SAESOC_DDESC_RESET_FRAGIDX
 };
+#else
+/** 
+ * enum saesoc_reset_frags_op - Possible types to reset the data descriptor
+ *
+ * @SAESOC_RESET_ALL_FRAGS: Reset all the frags. Keep IV and other 
+ * 		msg informations.
+ * @SAESOC_RESET_FRAGIDX: Reset till the given fragments.
+ */
+
+enum saesoc_reset_frags_op {
+	SAESOC_RESET_ALL_FRAGS = 1,
+	SAESOC_RESET_FRAGIDX
+};
+#endif
 	
 /**
 * defines sess_init_flags : Session initialization flags 
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_lib.h b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
index 4c52827..99eed45 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
@@ -363,6 +363,7 @@ struct saesoc_data_desc {
 } ___cryptosoc_cacheline_aligned;
 
 
+#ifndef __SECLIB_HALX
 /**
 *  struct saesoc_extra_req_send_params:Extra parameters during request send 
 *  @arc4_load_state: Load the ARC4 state before the operation
@@ -372,7 +373,17 @@ struct saesoc_extra_req_send_params {
 	int arc4_load_state; /* 1 or 0 */
 	_uint64_t async_rsp_arg;
 };
-
+#else
+/**
+*  struct saesoc_req_send_params: Parameters during request send 
+*  @arc4_load_state: Load the ARC4 state before the operation
+*  @async_rsp_arg: User given callback argument, used in async mode only
+*/
+struct saesoc_req_send_params {
+	int arc4_load_state; /* 1 or 0 */
+	_uint64_t async_rsp_arg;
+};
+#endif
 
 
 /**
@@ -1202,6 +1213,7 @@ static inline int saesoc_get_frag_index(
 	return CRYPTOSOC_OK;
 }
 
+#ifndef __SECLIB_HALX
 /**
 * saesoc_reset_ddesc - Reset the data descriptor 
 * @ddesc: Pointer to the data descriptor(input)
@@ -1253,6 +1265,59 @@ static inline int saesoc_reset_ddesc(
 	return CRYPTOSOC_OK;
 };
 
+#else
+/**
+* saesoc_reset_ddesc - Reset the data descriptor 
+* @ddesc: Pointer to the data descriptor(input)
+* @op: Reset operation type
+* @src_idx: Source fragment index
+* @dst_idx: Destination fragment index
+*
+* Set the current source and destination descriptor index. 
+* This can be used to reset the current data descriptor memory. 
+* Also this can be used to abort the previous operation and re-use it 
+*
+* Note: 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_reset_ddesc(
+		struct saesoc_data_desc *ddesc,
+		enum saesoc_reset_frags_op op,
+		int src_idx,
+		int dst_idx )
+{
+	struct saesoc_ddesc_priv_data *dpriv;
+	struct saesoc_sdesc_priv_data *spriv;
+
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+	spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
+
+	if(op == SAESOC_RESET_ALL_FRAGS) {
+		/* set the starting free fragment index */
+		dpriv->lsrc_frag_idx = -1;
+		dpriv->ldst_frag_idx = -1;
+		dpriv->nfrag_idx = spriv->frag_idx;		
+		dpriv->ndesfb_descs = 0;
+	} else if(op == SAESOC_RESET_FRAGIDX) {
+		if((src_idx < dpriv->max_descs) && (dst_idx < dpriv->max_descs)) {
+			dpriv->lsrc_frag_idx = src_idx;
+			dpriv->ldst_frag_idx = dst_idx;
+			/* last descriptor is the maximum of this */
+			dpriv->nfrag_idx = src_idx > dst_idx ? src_idx : dst_idx;
+			dpriv->nfrag_idx++; /* it is the next availabe slot */
+		} else
+			return -CRYPTOSOC_EINVAL;
+	} else
+		return -CRYPTOSOC_EINVAL;
+
+	return CRYPTOSOC_OK;
+};
+
+#endif
 
 /**
 * saesoc_get_ddesc_cnt - Get the descriptor used count
@@ -1777,6 +1842,7 @@ static inline void saesoc_dump_desc_info(
 
 }
 
+#ifndef __SECLIB_HALX
 /**
 * saesoc_process_request - Send/Receive the descriptor info to/from
 * the engine
@@ -1924,6 +1990,157 @@ send_req:
 	}
 }
 
+#else
+/**
+* saesoc_process_request - Send/Receive the descriptor info to/from
+* the engine
+* @ctx : Pointer to the context(input). 
+* @ddesc:Pointer to the data descriptor(input)
+* @req_vc: Transmit vc id.
+* @rsp_vc: Freeback vc id. This should be the error freeback vc 
+* 	if designer freeback is enabled.
+* @code: Message send code.
+* @retry_count: How many times the send should be retried before
+* 	telling it is failed
+* @mparam: Extra parameters for the send request
+* @sync_res: Engine result response if mode is sync(output). 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EAGAIN, CRYPTOSOC_EINVAL
+*
+* Note: 
+* if ctx != null, it does the operation as per the ctx mode
+* If ctx == null &  rsp != null, function sends the message
+* and wait for the response. 
+* if ctx == null & rsp == null, the function just send the message
+*/
+
+static inline int saesoc_process_request(
+		struct cryptosoc_ctx *ctx,
+		struct saesoc_data_desc *ddesc,
+		cryptosoc_req_qhdl_t req_qhdl,
+		cryptosoc_rsp_qhdl_t rsp_qhdl,
+		struct saesoc_req_send_params *mparam,
+		struct saesoc_rsp_result *sync_res)
+{
+	struct saesoc_sdesc_priv_data *spriv;
+	struct saesoc_ddesc_priv_data *dpriv;
+	struct saesoc_session_desc    *sdesc;
+	int nddescs;
+	_uint64_t fmnentry0, fmnentry1, fmnentry2;
+	_uint64_t *rsp_msg_ptr = NULL;
+	int gen_type2 = 0;
+	int req_vc = (int)req_qhdl;
+	int rsp_vc = (int)rsp_qhdl;
+	int code=0, retry_count=16;
+
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		int nsdescs, ivdescs = 0;
+		gen_type2 = 1;
+
+		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+		sdesc = (struct saesoc_session_desc    *)dpriv->sdesc;
+		spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
+
+
+		nsdescs = spriv->ldesc;
+		nddescs = dpriv->nfrag_idx + dpriv->ndesfb_descs;
+		ivdescs = spriv->hash_iv_descs + spriv->cipher_iv_descs;
+
+		/* for gen2 the freeback entry should be copied to the last */
+		if((nddescs + 1) > dpriv->max_descs) {
+			cryptosoc_err_print(
+				"%s:%d, Error - Fragments overflow max %d cur %d \n", 
+				__FUNCTION__, __LINE__,  dpriv->max_descs, nddescs);
+			return -CRYPTOSOC_EINVAL;
+		}
+
+                /* Designer freeback is only enabled in asyn mode */
+                if (dpriv->ndesfb_descs == 0) {
+		    fmnentry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+		    ddesc->descs[nddescs] = fmnentry2;
+		    rsp_msg_ptr = &ddesc->descs[nddescs];
+	            nddescs++;
+                }
+
+		fmnentry0 = saesoc_gen2_form_fmn_entry0(rsp_vc, dpriv->ndesfb_descs, 
+			dpriv->ndesfb_descs == 0 ? 0:1, nsdescs, 
+			saesoc_get_cacheline_phys_addr(&sdesc->descs));
+
+		fmnentry1 = saesoc_gen2_form_fmn_entry1(
+			mparam != NULL ? mparam->arc4_load_state : 0, 
+			ivdescs, nddescs, 
+			saesoc_get_cacheline_phys_addr(&ddesc->descs));
+
+		/* Set the last frag bits */
+		if(dpriv->lsrc_frag_idx)
+			saesoc_gen2_set_last_frag(ddesc->descs[dpriv->lsrc_frag_idx]);
+		if(dpriv->ldst_frag_idx)
+			saesoc_gen2_set_last_frag(ddesc->descs[dpriv->ldst_frag_idx]);
+
+
+		//saesoc_dump_desc_info(sdesc, ddesc);
+		//saesoc_gen2_dump_fmnentry(fmnentry0, fmnentry1);
+		
+
+		goto send_req;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+	
+		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+		sdesc = (struct saesoc_session_desc    *)dpriv->sdesc;
+		spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
+		nddescs = dpriv->nfrag_idx + dpriv->ndesfb_descs;
+		nddescs = ((nddescs /2) -1) + ( nddescs & 0x01);
+
+
+		
+
+		fmnentry0 = saesoc_gen1_form_fmn_entry0(rsp_vc, dpriv->ndesfb_descs, 
+			dpriv->ndesfb_descs == 0 ? 0:1, spriv->cipher_key_len_in_dw, 
+			saesoc_get_cacheline_phys_addr(&sdesc->descs));
+
+		fmnentry1 = saesoc_gen1_form_fmn_entry1(
+				mparam != NULL ? mparam->arc4_load_state : 0, 
+				spriv->hash_key_len_in_dw, nddescs, 
+				saesoc_get_cacheline_phys_addr(&ddesc->descs[0]));
+
+		fmnentry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+
+		//saesoc_dump_desc_info(sdesc, ddesc);
+		//saesoc_gen1_dump_fmnentry(fmnentry0, fmnentry1);
+
+		goto send_req;
+
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+
+send_req:
+
+	if(!ctx) {
+		return cryptosoc_process_request(gen_type2, CRYPTOSOC_SAE, 
+				req_vc, rsp_vc, code, retry_count,
+				fmnentry0, fmnentry1, fmnentry2,
+				sync_res ? &sync_res->result : NULL);
+	} else {
+		return cryptosoc_process_ctx_request(gen_type2, ctx, CRYPTOSOC_SAE,
+				req_vc, rsp_vc, code, retry_count, 
+				fmnentry0, fmnentry1, fmnentry2, 
+				sync_res ? &sync_res->result : NULL,
+				rsp_msg_ptr);
+	}
+}
+
+#endif
+
 static inline int my_cpu_id(void)
 {
 	unsigned int pid = 0;
-- 
1.7.9.5

