From 60d89fb9305b874b82e2f49405d94ac3b73f6bec Mon Sep 17 00:00:00 2001
From: kopal <kopal@broadcom.com>
Date: Mon, 6 Jan 2014 16:15:33 +0530
Subject: [PATCH 082/163] smscufx: Fix impropoer pixel display.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/video/smscufx.c |   27 ++++++++++++++++++---------
 1 file changed, 18 insertions(+), 9 deletions(-)

diff --git a/drivers/video/smscufx.c b/drivers/video/smscufx.c
index b2b33fc..32e2589 100644
--- a/drivers/video/smscufx.c
+++ b/drivers/video/smscufx.c
@@ -63,7 +63,7 @@
 #define MAX_TRANSFER		(PAGE_SIZE*16 - BULK_SIZE)
 #define WRITES_IN_FLIGHT	(4)
 
-#define GET_URB_TIMEOUT		(HZ)
+#define GET_URB_TIMEOUT		(10*HZ)
 #define FREE_URB_TIMEOUT	(HZ*2)
 
 #define BPP			2
@@ -130,7 +130,7 @@ static struct usb_device_id id_table[] = {
 MODULE_DEVICE_TABLE(usb, id_table);
 
 /* module options */
-static bool console;   /* Optionally allow fbcon to consume first framebuffer */
+static bool console  = true;   /* Optionally allow fbcon to consume first framebuffer */
 static bool fb_defio = true;  /* Optionally enable fb_defio mmap support */
 
 /* ufx keeps a list of urbs for efficient bulk transfers */
@@ -183,7 +183,7 @@ static int ufx_reg_write(struct ufx_data *dev, u32 index, u32 data)
 	ret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
 		USB_VENDOR_REQUEST_WRITE_REGISTER,
 		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		00, index, buf, 4, USB_CTRL_SET_TIMEOUT);
+		00, index, buf, 4, USB_CTRL_SET_TIMEOUT * HZ);
 
 	kfree(buf);
 
@@ -261,7 +261,7 @@ static int ufx_blank(struct ufx_data *dev, bool wait)
 	if (!wait)
 		return 0;
 
-	for (i = 0; i < 250; i++) {
+	for (i = 0; i < 25000; i++) {
 		status = ufx_reg_read(dev, 0x2004, &dc_sts);
 		check_warn_return(status, "ufx_blank error reading 0x2004");
 
@@ -298,7 +298,7 @@ static int ufx_unblank(struct ufx_data *dev, bool wait)
 	if (!wait)
 		return 0;
 
-	for (i = 0; i < 250; i++) {
+	for (i = 0; i < 25000; i++) {
 		status = ufx_reg_read(dev, 0x2004, &dc_sts);
 		check_warn_return(status, "ufx_unblank error reading 0x2004");
 
@@ -335,7 +335,7 @@ static int ufx_disable(struct ufx_data *dev, bool wait)
 	if (!wait)
 		return 0;
 
-	for (i = 0; i < 250; i++) {
+	for (i = 0; i < 25000; i++) {
 		status = ufx_reg_read(dev, 0x2004, &dc_sts);
 		check_warn_return(status, "ufx_disable error reading 0x2004");
 
@@ -372,7 +372,7 @@ static int ufx_enable(struct ufx_data *dev, bool wait)
 	if (!wait)
 		return 0;
 
-	for (i = 0; i < 250; i++) {
+	for (i = 0; i < 25000; i++) {
 		status = ufx_reg_read(dev, 0x2004, &dc_sts);
 		check_warn_return(status, "ufx_enable error reading 0x2004");
 
@@ -844,8 +844,17 @@ static void ufx_raw_rect(struct ufx_data *dev, u16 *cmd, int x, int y,
 	for (line = 0; line < height; line++) {
 		const int line_offset = dev->info->fix.line_length * (y + line);
 		const int byte_offset = line_offset + (x * BPP);
-		memcpy(&cmd[(24 + (packed_line_len * line)) / 2],
-			(char *)dev->info->fix.smem_start + byte_offset, width * BPP);
+		const int cmd_base = (24 + (packed_line_len * line)) / 2;
+		const u16 *source = (u16 *)((char *)dev->info->fix.smem_start + byte_offset);
+                u16 *dest = (u16 *)(&cmd[cmd_base]);
+#ifdef __BIG_ENDIAN
+                int pixel;
+                for (pixel = 0; pixel < width; pixel++)
+                        dest[pixel] = cpu_to_le16(source[pixel]);
+#else /* __BIG_ENDIAN */
+		memcpy(dest, source, width * BPP);
+#endif /* __BIG_ENDIAN */
+		
 	}
 }
 
-- 
1.7.9.5

