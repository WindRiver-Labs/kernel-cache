From c629c426dda2fc34c6c8084fe411cee6287eb9b9 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 Mar 2014 15:55:01 +0800
Subject: [PATCH 3/4] bcm-xlp: use the unsleep raw spinlock in smsc911x driver

replace the spin_lock/unlock with raw_spin_lock/unlock

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/net/ethernet/smsc/smsc911x.c |   98 +++++++++++++++++-----------------
 drivers/net/ethernet/smsc/smsc911x.h |    2 +-
 2 files changed, 50 insertions(+), 50 deletions(-)

diff --git a/drivers/net/ethernet/smsc/smsc911x.c b/drivers/net/ethernet/smsc/smsc911x.c
index c4b7e07..08b7f9f 100644
--- a/drivers/net/ethernet/smsc/smsc911x.c
+++ b/drivers/net/ethernet/smsc/smsc911x.c
@@ -107,10 +107,10 @@ struct smsc911x_data {
 	/* This needs to be acquired before calling any of below:
 	 * smsc911x_mac_read(), smsc911x_mac_write()
 	 */
-	spinlock_t mac_lock;
+	raw_spinlock_t mac_lock;
 
 	/* spinlock to ensure register accesses are serialised */
-	spinlock_t dev_lock;
+	raw_spinlock_t dev_lock;
 
 	struct phy_device *phy_dev;
 	struct mii_bus *mii_bus;
@@ -188,9 +188,9 @@ static inline u32 smsc911x_reg_read(struct smsc911x_data *pdata, u32 reg)
 	u32 data;
 	unsigned long flags;
 
-	spin_lock_irqsave(&pdata->dev_lock, flags);
+	raw_spin_lock_irqsave(&pdata->dev_lock, flags);
 	data = pdata->ops->reg_read(pdata, reg);
-	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->dev_lock, flags);
 
 	return data;
 }
@@ -236,9 +236,9 @@ static inline void smsc911x_reg_write(struct smsc911x_data *pdata, u32 reg,
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&pdata->dev_lock, flags);
+	raw_spin_lock_irqsave(&pdata->dev_lock, flags);
 	pdata->ops->reg_write(pdata, reg, val);
-	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->dev_lock, flags);
 }
 
 /* Writes a packet to the TX_DATA_FIFO */
@@ -248,7 +248,7 @@ smsc911x_tx_writefifo(struct smsc911x_data *pdata, unsigned int *buf,
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&pdata->dev_lock, flags);
+	raw_spin_lock_irqsave(&pdata->dev_lock, flags);
 
 	if (pdata->config.flags & SMSC911X_SWAP_FIFO) {
 		while (wordcount--)
@@ -270,7 +270,7 @@ smsc911x_tx_writefifo(struct smsc911x_data *pdata, unsigned int *buf,
 
 	BUG();
 out:
-	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->dev_lock, flags);
 }
 
 /* Writes a packet to the TX_DATA_FIFO - shifted version */
@@ -280,7 +280,7 @@ smsc911x_tx_writefifo_shift(struct smsc911x_data *pdata, unsigned int *buf,
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&pdata->dev_lock, flags);
+	raw_spin_lock_irqsave(&pdata->dev_lock, flags);
 
 	if (pdata->config.flags & SMSC911X_SWAP_FIFO) {
 		while (wordcount--)
@@ -304,7 +304,7 @@ smsc911x_tx_writefifo_shift(struct smsc911x_data *pdata, unsigned int *buf,
 
 	BUG();
 out:
-	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->dev_lock, flags);
 }
 
 /* Reads a packet out of the RX_DATA_FIFO */
@@ -314,7 +314,7 @@ smsc911x_rx_readfifo(struct smsc911x_data *pdata, unsigned int *buf,
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&pdata->dev_lock, flags);
+	raw_spin_lock_irqsave(&pdata->dev_lock, flags);
 
 	if (pdata->config.flags & SMSC911X_SWAP_FIFO) {
 		while (wordcount--)
@@ -336,7 +336,7 @@ smsc911x_rx_readfifo(struct smsc911x_data *pdata, unsigned int *buf,
 
 	BUG();
 out:
-	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->dev_lock, flags);
 }
 
 /* Reads a packet out of the RX_DATA_FIFO - shifted version */
@@ -346,7 +346,7 @@ smsc911x_rx_readfifo_shift(struct smsc911x_data *pdata, unsigned int *buf,
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&pdata->dev_lock, flags);
+	raw_spin_lock_irqsave(&pdata->dev_lock, flags);
 
 	if (pdata->config.flags & SMSC911X_SWAP_FIFO) {
 		while (wordcount--)
@@ -370,7 +370,7 @@ smsc911x_rx_readfifo_shift(struct smsc911x_data *pdata, unsigned int *buf,
 
 	BUG();
 out:
-	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->dev_lock, flags);
 }
 
 /*
@@ -553,7 +553,7 @@ static int smsc911x_mii_read(struct mii_bus *bus, int phyaddr, int regidx)
 	unsigned int addr;
 	int i, reg;
 
-	spin_lock_irqsave(&pdata->mac_lock, flags);
+	raw_spin_lock_irqsave(&pdata->mac_lock, flags);
 
 	/* Confirm MII not busy */
 	if (unlikely(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {
@@ -577,7 +577,7 @@ static int smsc911x_mii_read(struct mii_bus *bus, int phyaddr, int regidx)
 	reg = -EIO;
 
 out:
-	spin_unlock_irqrestore(&pdata->mac_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->mac_lock, flags);
 	return reg;
 }
 
@@ -590,7 +590,7 @@ static int smsc911x_mii_write(struct mii_bus *bus, int phyaddr, int regidx,
 	unsigned int addr;
 	int i, reg;
 
-	spin_lock_irqsave(&pdata->mac_lock, flags);
+	raw_spin_lock_irqsave(&pdata->mac_lock, flags);
 
 	/* Confirm MII not busy */
 	if (unlikely(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {
@@ -618,7 +618,7 @@ static int smsc911x_mii_write(struct mii_bus *bus, int phyaddr, int regidx,
 	reg = -EIO;
 
 out:
-	spin_unlock_irqrestore(&pdata->mac_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->mac_lock, flags);
 	return reg;
 }
 
@@ -870,10 +870,10 @@ static int smsc911x_phy_loopbacktest(struct net_device *dev)
 			BMCR_LOOPBACK | BMCR_FULLDPLX);
 
 		/* Enable MAC tx/rx, FD */
-		spin_lock_irqsave(&pdata->mac_lock, flags);
+		raw_spin_lock_irqsave(&pdata->mac_lock, flags);
 		smsc911x_mac_write(pdata, MAC_CR, MAC_CR_FDPX_
 				   | MAC_CR_TXEN_ | MAC_CR_RXEN_);
-		spin_unlock_irqrestore(&pdata->mac_lock, flags);
+		raw_spin_unlock_irqrestore(&pdata->mac_lock, flags);
 
 		if (smsc911x_phy_check_loopbackpkt(pdata) == 0) {
 			result = 0;
@@ -882,17 +882,17 @@ static int smsc911x_phy_loopbacktest(struct net_device *dev)
 		pdata->resetcount++;
 
 		/* Disable MAC rx */
-		spin_lock_irqsave(&pdata->mac_lock, flags);
+		raw_spin_lock_irqsave(&pdata->mac_lock, flags);
 		smsc911x_mac_write(pdata, MAC_CR, 0);
-		spin_unlock_irqrestore(&pdata->mac_lock, flags);
+		raw_spin_unlock_irqrestore(&pdata->mac_lock, flags);
 
 		smsc911x_phy_reset(pdata);
 	}
 
 	/* Disable MAC */
-	spin_lock_irqsave(&pdata->mac_lock, flags);
+	raw_spin_lock_irqsave(&pdata->mac_lock, flags);
 	smsc911x_mac_write(pdata, MAC_CR, 0);
-	spin_unlock_irqrestore(&pdata->mac_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->mac_lock, flags);
 
 	/* Cancel PHY loopback mode */
 	smsc911x_mii_write(phy_dev->bus, phy_dev->addr, MII_BMCR, 0);
@@ -935,9 +935,9 @@ static void smsc911x_phy_update_flowcontrol(struct smsc911x_data *pdata)
 		afc |= 0xF;
 	}
 
-	spin_lock_irqsave(&pdata->mac_lock, flags);
+	raw_spin_lock_irqsave(&pdata->mac_lock, flags);
 	smsc911x_mac_write(pdata, FLOW, flow);
-	spin_unlock_irqrestore(&pdata->mac_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->mac_lock, flags);
 
 	smsc911x_reg_write(pdata, AFC_CFG, afc);
 }
@@ -955,7 +955,7 @@ static void smsc911x_phy_adjust_link(struct net_device *dev)
 		unsigned int mac_cr;
 		SMSC_TRACE(pdata, hw, "duplex state has changed");
 
-		spin_lock_irqsave(&pdata->mac_lock, flags);
+		raw_spin_lock_irqsave(&pdata->mac_lock, flags);
 		mac_cr = smsc911x_mac_read(pdata, MAC_CR);
 		if (phy_dev->duplex) {
 			SMSC_TRACE(pdata, hw,
@@ -967,7 +967,7 @@ static void smsc911x_phy_adjust_link(struct net_device *dev)
 			mac_cr &= ~MAC_CR_FDPX_;
 		}
 		smsc911x_mac_write(pdata, MAC_CR, mac_cr);
-		spin_unlock_irqrestore(&pdata->mac_lock, flags);
+		raw_spin_unlock_irqrestore(&pdata->mac_lock, flags);
 
 		smsc911x_phy_update_flowcontrol(pdata);
 		pdata->last_duplex = phy_dev->duplex;
@@ -1324,7 +1324,7 @@ static void smsc911x_rx_multicast_update_workaround(struct smsc911x_data *pdata)
 	 *
 	 * This is called from interrupt context */
 
-	spin_lock(&pdata->mac_lock);
+	raw_spin_lock(&pdata->mac_lock);
 
 	/* Check Rx has stopped */
 	if (smsc911x_mac_read(pdata, MAC_CR) & MAC_CR_RXEN_)
@@ -1340,7 +1340,7 @@ static void smsc911x_rx_multicast_update_workaround(struct smsc911x_data *pdata)
 
 	pdata->multicast_update_pending = 0;
 
-	spin_unlock(&pdata->mac_lock);
+	raw_spin_unlock(&pdata->mac_lock);
 }
 
 static int smsc911x_phy_disable_energy_detect(struct smsc911x_data *pdata)
@@ -1500,9 +1500,9 @@ static int smsc911x_open(struct net_device *dev)
 	smsc911x_reg_write(pdata, AFC_CFG, 0x006E3740);
 
 	/* Increase the legal frame size of VLAN tagged frames to 1522 bytes */
-	spin_lock_irq(&pdata->mac_lock);
+	raw_spin_lock_irq(&pdata->mac_lock);
 	smsc911x_mac_write(pdata, VLAN1, ETH_P_8021Q);
-	spin_unlock_irq(&pdata->mac_lock);
+	raw_spin_unlock_irq(&pdata->mac_lock);
 
 	/* Make sure EEPROM has finished loading before setting GPIO_CFG */
 	timeout = 50;
@@ -1519,9 +1519,9 @@ static int smsc911x_open(struct net_device *dev)
 
 	/* The soft reset above cleared the device's MAC address,
 	 * restore it from local copy (set in probe) */
-	spin_lock_irq(&pdata->mac_lock);
+	raw_spin_lock_irq(&pdata->mac_lock);
 	smsc911x_set_hw_mac_address(pdata, dev->dev_addr);
-	spin_unlock_irq(&pdata->mac_lock);
+	raw_spin_unlock_irq(&pdata->mac_lock);
 
 	/* Initialise irqs, but leave all sources disabled */
 	smsc911x_disable_irq_chip(dev);
@@ -1599,11 +1599,11 @@ static int smsc911x_open(struct net_device *dev)
 	temp |= (INT_EN_TDFA_EN_ | INT_EN_RSFL_EN_ | INT_EN_RXSTOP_INT_EN_);
 	smsc911x_reg_write(pdata, INT_EN, temp);
 
-	spin_lock_irq(&pdata->mac_lock);
+	raw_spin_lock_irq(&pdata->mac_lock);
 	temp = smsc911x_mac_read(pdata, MAC_CR);
 	temp |= (MAC_CR_TXEN_ | MAC_CR_RXEN_ | MAC_CR_HBDIS_);
 	smsc911x_mac_write(pdata, MAC_CR, temp);
-	spin_unlock_irq(&pdata->mac_lock);
+	raw_spin_unlock_irq(&pdata->mac_lock);
 
 	smsc911x_reg_write(pdata, TX_CFG, TX_CFG_TX_ON_);
 
@@ -1747,7 +1747,7 @@ static void smsc911x_set_multicast_list(struct net_device *dev)
 		pdata->hashlo = 0;
 	}
 
-	spin_lock_irqsave(&pdata->mac_lock, flags);
+	raw_spin_lock_irqsave(&pdata->mac_lock, flags);
 
 	if (pdata->generation <= 1) {
 		/* Older hardware revision - cannot change these flags while
@@ -1771,7 +1771,7 @@ static void smsc911x_set_multicast_list(struct net_device *dev)
 		smsc911x_rx_multicast_update(pdata);
 	}
 
-	spin_unlock_irqrestore(&pdata->mac_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->mac_lock, flags);
 }
 
 static irqreturn_t smsc911x_irqhandler(int irq, void *dev_id)
@@ -1862,9 +1862,9 @@ static int smsc911x_set_mac_address(struct net_device *dev, void *p)
 
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
 
-	spin_lock_irq(&pdata->mac_lock);
+	raw_spin_lock_irq(&pdata->mac_lock);
 	smsc911x_set_hw_mac_address(pdata, dev->dev_addr);
-	spin_unlock_irq(&pdata->mac_lock);
+	raw_spin_unlock_irq(&pdata->mac_lock);
 
 	netdev_info(dev, "MAC Address: %pM\n", dev->dev_addr);
 
@@ -1950,9 +1950,9 @@ smsc911x_ethtool_getregs(struct net_device *dev, struct ethtool_regs *regs,
 		data[j++] = smsc911x_reg_read(pdata, i);
 
 	for (i = MAC_CR; i <= WUCSR; i++) {
-		spin_lock_irqsave(&pdata->mac_lock, flags);
+		raw_spin_lock_irqsave(&pdata->mac_lock, flags);
 		data[j++] = smsc911x_mac_read(pdata, i);
-		spin_unlock_irqrestore(&pdata->mac_lock, flags);
+		raw_spin_unlock_irqrestore(&pdata->mac_lock, flags);
 	}
 
 	for (i = 0; i <= 31; i++)
@@ -2142,8 +2142,8 @@ static int smsc911x_init(struct net_device *dev)
 	SMSC_TRACE(pdata, probe, "IRQ: %d", dev->irq);
 	SMSC_TRACE(pdata, probe, "PHY will be autodetected.");
 
-	spin_lock_init(&pdata->dev_lock);
-	spin_lock_init(&pdata->mac_lock);
+	raw_spin_lock_init(&pdata->dev_lock);
+	raw_spin_lock_init(&pdata->mac_lock);
 
 	if (pdata->ioaddr == NULL) {
 		SMSC_WARN(pdata, probe, "pdata->ioaddr: 0x00000000");
@@ -2249,9 +2249,9 @@ static int smsc911x_init(struct net_device *dev)
 	 * is stored elsewhere and set by the bootloader.  This saves the
 	 * mac address before resetting the device */
 	if (pdata->config.flags & SMSC911X_SAVE_MAC_ADDRESS) {
-		spin_lock_irq(&pdata->mac_lock);
+		raw_spin_lock_irq(&pdata->mac_lock);
 		smsc911x_read_mac_address(dev);
-		spin_unlock_irq(&pdata->mac_lock);
+		raw_spin_unlock_irq(&pdata->mac_lock);
 	}
 
 	/* Reset the LAN911x */
@@ -2478,7 +2478,7 @@ static int smsc911x_drv_probe(struct platform_device *pdev)
 	xlp_smsc_gpio_setup();
 
 	retval = request_irq(dev->irq, smsc911x_irqhandler,
-			     irq_flags | IRQF_SHARED, dev->name, dev);
+			     irq_flags | IRQF_SHARED | IRQF_NO_THREAD, dev->name, dev);
 	if (retval) {
 		SMSC_WARN(pdata, probe,
 			  "Unable to claim requested irq: %d", dev->irq);
@@ -2500,7 +2500,7 @@ static int smsc911x_drv_probe(struct platform_device *pdev)
 		goto out_unregister_netdev_5;
 	}
 
-	spin_lock_irq(&pdata->mac_lock);
+	raw_spin_lock_irq(&pdata->mac_lock);
 
 	/* Check if mac address has been specified when bringing interface up */
 	if (is_valid_ether_addr(dev->dev_addr)) {
@@ -2529,7 +2529,7 @@ static int smsc911x_drv_probe(struct platform_device *pdev)
 		}
 	}
 
-	spin_unlock_irq(&pdata->mac_lock);
+	raw_spin_unlock_irq(&pdata->mac_lock);
 
 	netdev_info(dev, "MAC Address: %pM\n", dev->dev_addr);
 
diff --git a/drivers/net/ethernet/smsc/smsc911x.h b/drivers/net/ethernet/smsc/smsc911x.h
index 9ad5e5d..5729743 100644
--- a/drivers/net/ethernet/smsc/smsc911x.h
+++ b/drivers/net/ethernet/smsc/smsc911x.h
@@ -52,7 +52,7 @@
 
 #ifdef CONFIG_DEBUG_SPINLOCK
 #define SMSC_ASSERT_MAC_LOCK(pdata) \
-		WARN_ON(!spin_is_locked(&pdata->mac_lock))
+		WARN_ON(!raw_spin_is_locked(&pdata->mac_lock))
 #else
 #define SMSC_ASSERT_MAC_LOCK(pdata) do {} while (0)
 #endif				/* CONFIG_DEBUG_SPINLOCK */
-- 
1.7.9.5

