From 7b60789656e8e8a73710c4460d5ade2f6da84b16 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 18:37:01 +0800
Subject: [PATCH 47/58] bcm-xlp2: Broadcom XLP NMIProf support

NMIProf is a simple and accurate profiler for XLP cpus.

NMIProf uses NMI interrupts generated by the XLP PIC to get accurate
profiling information of a CPU.

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/netlogic/Kconfig               |   10 ++
 drivers/netlogic/nmiprof/Makefile      |    5 +
 drivers/netlogic/nmiprof/nmiprof-sys.c |  226 ++++++++++++++++++++++++++++
 drivers/netlogic/nmiprof/nmiprof.h     |  258 ++++++++++++++++++++++++++++++++
 drivers/netlogic/nmiprof/nmiprof_asm.S |   43 ++++++
 5 files changed, 542 insertions(+)

diff --git a/drivers/netlogic/Kconfig b/drivers/netlogic/Kconfig
index b7438e7..378e465 100644
--- a/drivers/netlogic/Kconfig
+++ b/drivers/netlogic/Kconfig
@@ -66,3 +66,13 @@ config XLP_PPM
         default y
 	help
           This driver supports Manage Packet Pool.
+
+config XLP_NMIPROF
+	tristate "XLP NMIProf support"
+        depends on NLM_XLP_BOARD
+        default n
+	help
+          NMIProf is a simple and accurate profiler for XLP cpus.
+
+          NMIProf uses NMI interrupts generated by the XLP PIC to get accurate profiling
+          information of a CPU.
diff --git a/drivers/netlogic/nmiprof/Makefile b/drivers/netlogic/nmiprof/Makefile
new file mode 100644
index 0000000..f1aca25
--- /dev/null
+++ b/drivers/netlogic/nmiprof/Makefile
@@ -0,0 +1,5 @@
+EXTRA_CFLAGS := -DCONFIG_XLP_FMN_SUPPORT -DNLM_HAL_LINUX_KERNEL
+
+obj-$(CONFIG_XLP_NMIPROF) 	+= nmiprof.o
+
+nmiprof-y := nmiprof_asm.o nmiprof-sys.o
diff --git a/drivers/netlogic/nmiprof/nmiprof-sys.c b/drivers/netlogic/nmiprof/nmiprof-sys.c
new file mode 100644
index 0000000..2a18df1
--- /dev/null
+++ b/drivers/netlogic/nmiprof/nmiprof-sys.c
@@ -0,0 +1,226 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/sysctl.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <asm/page.h>
+
+#include "nmiprof.h"
+
+static char nmiprofsave[1024];
+
+struct nlm_nmiprof_dev {
+	struct platform_device *dev;
+	struct bin_attribute bindata_attr;
+	struct bin_attribute binnmiprof_attr;
+	u64 *base;
+	int nlm_cpu;
+	int state;
+};
+
+struct nlm_nmiprof_dev *ndev;
+
+static ssize_t nlm_nmiprof_read(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+{
+	size_t log_size = bin_attr->size;
+
+	if ((pos) >= log_size)
+		return 0;
+	if ((pos) + size > log_size)
+		size = log_size - (pos/8);
+	memcpy((void __force *) buf,
+			(void __force *) ((char *)ndev->base + pos), size);
+	return size;
+}
+
+static ssize_t nlm_nmiprof_write(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+{
+	return 0;
+}
+
+static ssize_t nlm_nmiprofcontrol_read(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+{
+	int count = 0;
+	if (!pos)
+		count = scnprintf(buf, size, "%d\n", ndev->nlm_cpu);
+	return count;
+}
+
+static void nlm_config_cpu(void *data)
+{
+	write_c0_scratch(5, (u64 *)data);
+}
+
+static ssize_t nlm_nmiprofcontrol_write(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+{
+	u32 *write_asm;
+	int ret, use_cpu, hwcpu;
+	char *reset_data = (char *)CKSEG1ADDR(RESET_VEC_PHYS);
+	uint64_t xlp_pic_base = nlm_get_pic_regbase(0); /* Node 0 */
+
+	dev_dbg(&ndev->dev->dev, "Run nmiprof control on CPU %d\n", ndev->nlm_cpu);
+
+	/* Get cpu */
+	use_cpu = simple_strtol(buf, NULL, 0);
+	if (use_cpu >= NLM_NR_CPUS || use_cpu  < -1) {
+		dev_info(&ndev->dev->dev,
+			"Invalid CPU %d, valid values are 0-%d\n",
+							use_cpu, NLM_NR_CPUS);
+		return -EINVAL;
+	}
+
+	/* Stop the profiler */
+	if (use_cpu == -1) {
+		if (!ndev->state) {
+			dev_info(&ndev->dev->dev, "Not running on any cpu\n");
+			return -EINVAL;
+		}
+		nlm_pic_set_timer(xlp_pic_base, 6, ~0ULL, 0, 0);
+		memcpy(reset_data, nmiprofsave, nlm_nmiprof_end - nlm_nmiprof);
+		ndev->state = 0;
+		dev_info(&ndev->dev->dev, "Stopped tracing on cpu %d\n",
+								ndev->nlm_cpu);
+		ndev->nlm_cpu = NLM_NR_CPUS;
+		module_put(THIS_MODULE);
+		return size;
+	}
+
+	if (ndev->state) {
+		dev_info(&ndev->dev->dev, "Already running on cpu %d\n"
+			"To stop nmiprof: echo -1 > nmiprofcontrol\n",
+								ndev->nlm_cpu);
+		return -EINVAL;
+	}
+
+	ret = smp_call_function_single(use_cpu, nlm_config_cpu,
+			ndev->base, 1);
+	if (ret) {
+		dev_info(&ndev->dev->dev, "smp call function error\n");
+		return ret;
+	}
+
+	ndev->nlm_cpu = use_cpu;
+	hwcpu = cpu_logical_map(use_cpu);
+	dev_info(&ndev->dev->dev, "nmiprof: start tracing on cpu %d (hw %d)\n",
+							ndev->nlm_cpu, hwcpu);
+	memset(ndev->base, 0xa5, NMIPROF_LOG_SIZE);
+	memcpy(nmiprofsave, reset_data, nlm_nmiprof_end - nlm_nmiprof);
+	memcpy(reset_data, nlm_nmiprof, nlm_nmiprof_end - nlm_nmiprof);
+
+	write_asm = (u32 *) (reset_data + (&pic_entry - nlm_nmiprof));
+	*write_asm |= (xlp_pic_base & 0xffff0000) >> 16;
+	write_asm++;
+	*write_asm |= 0x400;
+	write_asm++;
+	*write_asm |= ((xlp_pic_base & 0xffff) + (PIC_STATUS << 2));
+	write_asm++;
+	*write_asm |= 0xa;
+	write_asm++;
+	*write_asm |= ((xlp_pic_base & 0xffff) + (PIC_INT_ACK << 2));
+
+	nlm_pic_set_timer(xlp_pic_base, 6, 509 * 1499ull, -3, hwcpu);
+	ndev->state = 1;
+	if (!try_module_get(THIS_MODULE))
+		pr_warn("%s:cannot get module\n", __func__);
+
+	return size;
+}
+
+static int __init nlm_init_sys(void)
+{
+	unsigned long err = 0;
+
+	ndev = kzalloc(sizeof(*ndev), GFP_KERNEL);
+	if (!ndev)
+		return ENOMEM;
+
+	ndev->nlm_cpu = NLM_NR_CPUS;
+
+	ndev->dev = platform_device_register_simple("nmiprof", -1, NULL, 0);
+	if (IS_ERR(ndev->dev)) {
+		pr_err("%s:platform_device_register_simple failed\n",
+								__func__);
+		err = EBUSY;
+		goto platform_err;
+	}
+	/* Allocate memory for dumping the statistic collected */
+	ndev->base = (u64 *) __get_free_pages(GFP_ATOMIC,
+			get_order(NMIPROF_LOG_SIZE));
+	if (!ndev->base) {
+		dev_err(&ndev->dev->dev, "Allocation of free pages failed\n");
+		err = ENOMEM;
+		goto page_err;
+	}
+
+	/* Setup the nmiprofdata entry,
+	 * which will be used for read/write */
+	ndev->bindata_attr.attr.name = "nmiprofdata";
+	ndev->bindata_attr.attr.mode = S_IRUSR | S_IWUSR;
+	ndev->bindata_attr.read = nlm_nmiprof_read;
+	ndev->bindata_attr.write = nlm_nmiprof_write;
+	ndev->bindata_attr.size = NMIPROF_LOG_SIZE;
+	ndev->bindata_attr.private = ndev;
+
+	/* Setup nmiprofcontrol entry to control
+	 * profiling start or stop */
+	ndev->binnmiprof_attr.attr.name = "nmiprofcontrol";
+	ndev->binnmiprof_attr.attr.mode = S_IRUSR | S_IWUSR;
+	ndev->binnmiprof_attr.read = nlm_nmiprofcontrol_read;
+	ndev->binnmiprof_attr.write = nlm_nmiprofcontrol_write;
+	ndev->binnmiprof_attr.size = 4;
+	ndev->binnmiprof_attr.private = ndev;
+
+	err = sysfs_create_bin_file(&ndev->dev->dev.kobj, &ndev->bindata_attr);
+	if (err) {
+		dev_err(&ndev->dev->dev, "can't create attribute file\n");
+		goto sys_err1;
+	}
+
+	err = sysfs_create_bin_file(&ndev->dev->dev.kobj, &ndev->binnmiprof_attr);
+	if (err) {
+		dev_err(&ndev->dev->dev, "can't create attribute file\n");
+		goto sys_err;
+	}
+	return 0;
+
+sys_err:
+	sysfs_remove_bin_file(&ndev->dev->dev.kobj, &ndev->bindata_attr);
+sys_err1:
+	if (ndev->base)
+		__free_pages((struct page *)ndev->base, get_order(NMIPROF_LOG_SIZE));
+page_err:
+	platform_device_unregister(ndev->dev);
+platform_err:
+	kfree(ndev);
+	return err;
+}
+
+static void __exit nlm_exit_sys(void)
+{
+	sysfs_remove_bin_file(&ndev->dev->dev.kobj, &ndev->binnmiprof_attr);
+	sysfs_remove_bin_file(&ndev->dev->dev.kobj, &ndev->bindata_attr);
+	platform_device_unregister(ndev->dev);
+	__free_pages((struct page *)ndev->base, get_order(NMIPROF_LOG_SIZE));
+	kfree(ndev);
+}
+
+module_init(nlm_init_sys);
+module_exit(nlm_exit_sys);
+
+MODULE_AUTHOR("Ganesan Ramalingam <ganesanr@broadcom.com>");
+MODULE_DESCRIPTION("XLP SoC NMIprof");
+MODULE_LICENSE("GPL");
diff --git a/drivers/netlogic/nmiprof/nmiprof.h b/drivers/netlogic/nmiprof/nmiprof.h
new file mode 100644
index 0000000..8bbd67e
--- /dev/null
+++ b/drivers/netlogic/nmiprof/nmiprof.h
@@ -0,0 +1,258 @@
+/*
+ * Copyright 2003-2011 NetLogic Microsystems, Inc. (NetLogic). All rights
+ * reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the NetLogic
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NETLOGIC ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* PIC Specific registers */
+#define PIC_CTRL                0x00
+
+/* PIC control register defines */
+#define PIC_CTRL_ITV		32 /* interrupt timeout value */
+#define PIC_CTRL_ICI		19 /* ICI interrupt timeout enable */
+#define PIC_CTRL_ITE		18 /* interrupt timeout enable */
+#define PIC_CTRL_STE		10 /* system timer interrupt enable */
+#define PIC_CTRL_WWR1		8  /* watchdog 1 wraparound count for reset */
+#define PIC_CTRL_WWR0		6  /* watchdog 0 wraparound count for reset */
+#define PIC_CTRL_WWN1		4  /* watchdog 1 wraparound count for NMI */
+#define PIC_CTRL_WWN0		2  /* watchdog 0 wraparound count for NMI */
+#define PIC_CTRL_WTE		0  /* watchdog timer enable */
+
+#define PIC_TIMER0_MAXVAL    0x34
+#define PIC_TIMER1_MAXVAL    0x36
+#define PIC_TIMER2_MAXVAL    0x38
+#define PIC_TIMER3_MAXVAL    0x3a
+#define PIC_TIMER4_MAXVAL    0x3c
+#define PIC_TIMER5_MAXVAL    0x3e
+#define PIC_TIMER6_MAXVAL    0x40
+#define PIC_TIMER7_MAXVAL    0x42
+#define PIC_TIMER_MAXVAL(i)  (PIC_TIMER0_MAXVAL + ((i) * 2))
+
+#define PIC_IRT0                0x74
+#define PIC_IRT(i)              (PIC_IRT0 + ((i) * 2))
+
+#define TIMER_CYCLES_MAXVAL	0xffffffffffffffffULL
+
+/*
+ *    IRT Map
+ */
+#define PIC_NUM_IRTS		160
+
+#define PIC_IRT_WD_0_INDEX	0
+#define PIC_IRT_WD_1_INDEX	1
+#define PIC_IRT_WD_NMI_0_INDEX	2
+#define PIC_IRT_WD_NMI_1_INDEX	3
+#define PIC_IRT_TIMER_0_INDEX	4
+#define PIC_IRT_TIMER_1_INDEX	5
+#define PIC_IRT_TIMER_2_INDEX	6
+#define PIC_IRT_TIMER_3_INDEX	7
+#define PIC_IRT_TIMER_4_INDEX	8
+#define PIC_IRT_TIMER_5_INDEX	9
+#define PIC_IRT_TIMER_6_INDEX	10
+#define PIC_IRT_TIMER_7_INDEX	11
+#define PIC_IRT_CLOCK_INDEX	PIC_IRT_TIMER_7_INDEX
+#define PIC_IRT_TIMER_INDEX(num)	((num) + PIC_IRT_TIMER_0_INDEX)
+
+#define PIC_STATUS              0x04
+#define PIC_INT_ACK             0x10
+
+#define XLP_DEFAULT_IO_BASE             0x18000000
+#define RESET_VEC_PHYS			0x1fc00000
+#define XLP_IO_PCI_HDRSZ		0x100
+#define XLP_IO_DEV(node, dev)           ((dev) + (node) * 8)
+#define XLP_IO_PCI_OFFSET(b, d, f)      (((b) << 20) | ((d) << 15) | ((f) << 12))
+
+#define XLP_HDR_OFFSET(node, bus, dev, fn) \
+                XLP_IO_PCI_OFFSET(bus, XLP_IO_DEV(node, dev), fn)
+
+/* On node 0 bus 1 */
+#define XLP9XX_HDR_OFFSET(n, d, f)      \
+                        XLP_IO_PCI_OFFSET(1, d, f)
+
+/* coherent inter chip */
+#define XLP_IO_PIC_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 0, 4)
+#define XLP9XX_IO_PIC_OFFSET(node)      XLP9XX_HDR_OFFSET(node, 2, 0)
+
+#define PIC_9XX_IRT0			0x1c0  /* this should be 0x200, FIXME */
+#define PIC_9XX_IRT(i)			(PIC_9XX_IRT0 + ((i) * 2))
+
+#define nlm_read_pci_reg(b, r)		nlm_read_reg(b, r)
+#define nlm_write_pci_reg(b, r, v)	nlm_write_reg(b, r, v)
+
+#define nlm_read_pic_reg(b, r)		nlm_read_reg64(b, r)
+#define nlm_write_pic_reg(b, r, v)	nlm_write_reg64(b, r, v)
+
+#define nlm_get_pic_pcibase(node)       nlm_pcicfg_base(cpu_is_xlp9xx() ? \
+		                XLP9XX_IO_PIC_OFFSET(node) : XLP_IO_PIC_OFFSET(node))
+
+#define nlm_get_pic_regbase(node) 	(nlm_get_pic_pcibase(node) + XLP_IO_PCI_HDRSZ)
+
+#define write_c0_scratch(sel, val)	__write_64bit_c0_register($22, sel, val)
+#define read_c0_scratch(sel)		__read_64bit_c0_register($22, sel)
+
+/* NMIprof log size 4MB*/
+#define NMIPROF_LOG_SIZE	0x400000
+#define NLM_NR_CPUS	(cpu_is_xlp9xx() ? 80 : 32)
+
+extern char nlm_nmiprof[], nlm_nmiprof_end[], pic_entry;
+extern uint64_t nlm_io_base;
+
+static inline int cpu_is_xlp9xx(void)
+{
+        int chip = read_c0_prid() & 0xff00;
+
+        return chip == PRID_IMP_NETLOGIC_XLP9XX;
+}
+
+static inline uint64_t nlm_pcicfg_base(uint32_t devoffset)
+{
+	return nlm_io_base + devoffset;
+}
+
+static inline uint64_t
+nlm_read_reg64(uint64_t base, uint32_t reg)
+{
+	uint64_t addr = base + (reg >> 1) * sizeof(uint64_t);
+	volatile uint64_t *ptr = (volatile uint64_t *)(long)addr;
+	uint64_t val;
+
+	if (sizeof(unsigned long) == 4) {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		__asm__ __volatile__(
+			".set	push"			"\n\t"
+			".set	mips64"			"\n\t"
+			"ld	%L0, %1"		"\n\t"
+			"dsra32	%M0, %L0, 0"		"\n\t"
+			"sll	%L0, %L0, 0"		"\n\t"
+			".set	pop"			"\n"
+			: "=r" (val)
+			: "m" (*ptr));
+		local_irq_restore(flags);
+	} else
+		val = *ptr;
+
+	return val;
+}
+
+static inline void
+nlm_write_reg64(uint64_t base, uint32_t reg, uint64_t val)
+{
+	uint64_t addr = base + (reg >> 1) * sizeof(uint64_t);
+	volatile uint64_t *ptr = (volatile uint64_t *)(long)addr;
+
+	if (sizeof(unsigned long) == 4) {
+		unsigned long flags;
+		uint64_t tmp;
+
+		local_irq_save(flags);
+		__asm__ __volatile__(
+			".set	push"			"\n\t"
+			".set	mips64"			"\n\t"
+			"dsll32	%L0, %L0, 0"		"\n\t"
+			"dsrl32	%L0, %L0, 0"		"\n\t"
+			"dsll32	%M0, %M0, 0"		"\n\t"
+			"or	%L0, %L0, %M0"		"\n\t"
+			"sd	%L0, %2"		"\n\t"
+			".set	pop"			"\n"
+			: "=r" (tmp)
+			: "0" (val), "m" (*ptr));
+		local_irq_restore(flags);
+	} else
+		*ptr = val;
+}
+
+/* IRT and h/w interrupt routines */
+
+static inline void
+nlm_9xx_pic_write_irt(uint64_t base, int irt_num, int en, int nmi,
+	int sch, int vec, int dt, int db, int cpu)
+{
+	uint64_t val;
+
+	val = (((uint64_t)en & 0x1) << 22) | ((nmi & 0x1) << 23) |
+			((0 /*mc*/) << 20) | ((vec & 0x3f) << 24) |
+			((dt & 0x1) << 21) | (0 /*ptr*/ << 16) |
+			(cpu & 0x3ff);
+
+	nlm_write_pic_reg(base, PIC_9XX_IRT(irt_num), val);
+}
+
+static inline void
+nlm_pic_write_irt(uint64_t base, int irt_num, int en,
+		int nmi, int sch, int vec, int dt, int db, int dte)
+{
+	uint64_t val;
+
+	val = (((uint64_t)en & 0x1) << 31) | ((nmi & 0x1) << 29) |
+			((sch & 0x1) << 28) | ((vec & 0x3f) << 20) |
+			((dt & 0x1) << 19) | ((db & 0x7) << 16) |
+			(dte & 0xffff);
+
+	nlm_write_pic_reg(base, PIC_IRT(irt_num), val);
+}
+
+static inline void
+nlm_pic_write_irt_direct(uint64_t base, int irt_num, int en, int nmi,
+	int sch, int vec, int cpu)
+{
+	if (cpu_is_xlp9xx())
+		nlm_9xx_pic_write_irt(base, irt_num, en, nmi, sch, vec,
+							1, 0, cpu);
+	else
+		nlm_pic_write_irt(base, irt_num, en, nmi, sch, vec, 1,
+			(cpu >> 4),		/* thread group */
+			1 << (cpu & 0xf));	/* thread mask */
+}
+
+static inline void
+nlm_pic_set_timer(uint64_t base, int timer, uint64_t value, int irq, int cpu)
+{
+	uint64_t pic_ctrl;
+	int en, nmi;
+
+	en = nmi = 0;
+	if (irq > 0)
+		en = 1;
+	else if (irq < 0) {
+		en = nmi = 1;
+		irq = -irq;
+	}
+	nlm_write_pic_reg(base, PIC_TIMER_MAXVAL(timer), value);
+	nlm_pic_write_irt_direct(base, PIC_IRT_TIMER_INDEX(timer),
+		en, nmi, 0, irq, cpu);
+
+	/* enable the timer */
+	pic_ctrl = nlm_read_pic_reg(base, PIC_CTRL);
+	pic_ctrl |= (1 << (PIC_CTRL_STE + timer));
+	nlm_write_pic_reg(base, PIC_CTRL, pic_ctrl);
+}
diff --git a/drivers/netlogic/nmiprof/nmiprof_asm.S b/drivers/netlogic/nmiprof/nmiprof_asm.S
new file mode 100644
index 0000000..6fb6876
--- /dev/null
+++ b/drivers/netlogic/nmiprof/nmiprof_asm.S
@@ -0,0 +1,43 @@
+#include <linux/init.h>
+
+#include <asm/asm.h>
+#include <asm/asm-offsets.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/stackframe.h>
+#include <asm/asmmacro.h>
+#include <asm/addrspace.h>
+
+	.set	noreorder
+	.set	mips64r2
+	.set	noat
+FEXPORT(nlm_nmiprof)
+	dmtc0	k0, CP0_DIAGNOSTIC, 6
+	dmtc0	k1, CP0_DIAGNOSTIC, 7
+	dmfc0	k0, CP0_DIAGNOSTIC, 5
+	dmfc0	k1, CP0_ERROREPC
+	sw	k1, 0(k0)
+	sw	ra, 4(k0)
+	/* Do over lap on single 4MB memory */
+	dextm	k1, k0, 22, 42
+	daddi	k0, 8
+	dinsm	k0, k1, 22, 42
+	dmtc0	k0, CP0_DIAGNOSTIC, 5
+	.global	pic_entry
+pic_entry:
+	lui	k0, 0
+	li	k1, 0
+	sd	k1, 0(k0)
+
+	li	k1, 0
+	sd	k1, 0(k0)
+
+	li	k1, 0x00480000	/* set ack mask */
+	mfc0	k0, CP0_STATUS	/* Read status */
+	xor	k0, k1		/* Ack */
+	mtc0	k0, CP0_STATUS	/* Write status */
+	dmfc0	k0, CP0_DIAGNOSTIC, 6
+	dmfc0	k1, CP0_DIAGNOSTIC, 7
+	eret
+	nop
+EXPORT(nlm_nmiprof_end)
-- 
1.7.9.5

