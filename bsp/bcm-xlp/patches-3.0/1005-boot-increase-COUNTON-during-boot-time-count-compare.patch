From c40b0f427c1230763e32bae9543deaf7e1e099cd Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Fri, 3 May 2013 14:52:56 -0700
Subject: [PATCH 005/163] boot: increase COUNTON during boot-time
 count/compare synchronization

  o During boot time, to synchronise count/compare register,
    for slave cpus, the following code sequence will be executed:

      ......
      mfc0  <reg>, CP0_COUNT
      addiu <reg>, <reg>, COUNTON
      mtc0  <reg>, CP0_COMPARE

    The default COUNTON is 100.
  o The idea is shortly after CP0_COMPARE is written, an interrupt should
    be generated.
  o This seems not true in certain cases. The reason is:
      "mfc0 <reg, CP0_COUNT" insn can be executed speculatively,
      while "mtc0 <reg>, CP0_COMPARE" can only be executed non-speculatively.
    For example, at cycle x, "mfc0 <reg>, CP0_COUNT" is executed.
    However, maybe due to some previous load (missed in the cache) to be finished,
    or due to in unmapped space, insn fetching for new cache line won't happen
    until all previous insns are retired,
    at cycle (x + 300), "mtc0 <reg>, CP0_COMPARE" gets executed.
    The time interrupt will not be generated in this case.
  o To fix the issue, increase COUNTON to 500.

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/kernel/sync-r4k.c |    6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/arch/mips/kernel/sync-r4k.c b/arch/mips/kernel/sync-r4k.c
index 1ff43d5..22232ff 100644
--- a/arch/mips/kernel/sync-r4k.c
+++ b/arch/mips/kernel/sync-r4k.c
@@ -25,7 +25,13 @@ static atomic_t __cpuinitdata count_count_start = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_count_stop = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_reference = ATOMIC_INIT(0);
 
+#ifdef CONFIG_CPU_XLP
+/* Increase COUNTON to ensure interrupt is triggered */
+#define COUNTON	500
+#else
 #define COUNTON 100
+#endif
+
 #define NR_LOOPS 5
 
 void __cpuinit synchronise_count_master(int cpu)
-- 
1.7.9.5

