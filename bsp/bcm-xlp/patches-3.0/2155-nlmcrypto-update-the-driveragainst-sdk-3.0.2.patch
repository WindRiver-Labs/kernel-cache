From c296970b08fcd4b888575e52e489c682dd7387b9 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Thu, 19 Jun 2014 11:17:54 +0800
Subject: [PATCH 155/160] nlmcrypto: update the driveragainst sdk 3.0.2

rebase the nlmcrypto to sdk 3.0.2

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Jack Tan <jiankemeng@gmail.com>
---
 drivers/netlogic/nlmcrypto/cryptodrv.c          |   29 +++++++++++++++++------
 drivers/netlogic/nlmcrypto/cryptosoc_lib_priv.h |    2 +-
 drivers/netlogic/nlmcrypto/init.c               |    8 +++----
 3 files changed, 27 insertions(+), 12 deletions(-)

diff --git a/drivers/netlogic/nlmcrypto/cryptodrv.c b/drivers/netlogic/nlmcrypto/cryptodrv.c
index bac9929..9fafc2d 100644
--- a/drivers/netlogic/nlmcrypto/cryptodrv.c
+++ b/drivers/netlogic/nlmcrypto/cryptodrv.c
@@ -25,7 +25,7 @@
 #include <nlm_hal_macros.h>
 #include <nlm_hal_xlp_dev.h>
 #include <nlm_xlp.h>
-#include "cryptosoc_ctx.h"
+#include  "cryptosoc_ctx.h"
 #include "cryptodev.h"
 
 //#define Message(x, args...) printk(x, ##args)
@@ -95,7 +95,7 @@ static inline struct cryptosoc_rsp *get_rsp_from_index(unsigned int index, int f
 	struct page *page;
 	int page_idx;
 	struct cryptosoc_rsp *rsp = NULL;
-	unsigned long flags;
+//	unsigned long flags;
 
 	page_idx = GET_PAGE_INDEX(index);
 
@@ -105,7 +105,8 @@ static inline struct cryptosoc_rsp *get_rsp_from_index(unsigned int index, int f
 	Message("%s in, index %d pidx %d page %lx\n", __FUNCTION__,
 			index, page_idx, (unsigned long)page_address(page_ptr[page_idx]));
 
-	raw_spin_lock_irqsave(&plock, flags);
+//	raw_spin_lock_irqsave(&plock, flags);
+	rcu_read_lock();
 	if((page = page_ptr[page_idx])) {
 		index = index % num_rsp_descs_per_page;
 		rsp = (struct cryptosoc_rsp *)((unsigned long)page_address(page) + 
@@ -114,7 +115,8 @@ static inline struct cryptosoc_rsp *get_rsp_from_index(unsigned int index, int f
 		if(from_intr) 
 			atomic_inc(&rsp->used_by_intr);
 	}
-	raw_spin_unlock_irqrestore(&plock, flags);
+	//raw_spin_unlock_irqrestore(&plock, flags);
+	rcu_read_unlock();
 	return rsp;
 }
 
@@ -326,6 +328,15 @@ check_again:
 	raw_spin_unlock_irqrestore(&plock, flags);
 
 	if(page) {
+		barrier();
+		/* interrupt handler does not take the lock. This rcu make sure the interrupt handler
+		*  does not use this page while the deletion is going on */
+		synchronize_rcu();
+recheck:
+		if(atomic_read(&rsp->used_by_intr)) {
+			schedule_timeout(1);
+			goto recheck;
+		}
 		free_pages((unsigned long)page_address(page), rsp_desc_page_order); 
 		DBG_NALLOCS_DEC(&nallocs);
 	}
@@ -444,10 +455,14 @@ static long crypto_driver_ioctl(struct file *filp, unsigned int cmd,
 		case NLM_CRYPTO_GET_CHIP_FEATURE:
 		{
 			uint32_t *ptr = (uint32_t *) arg;
-			int nlm_crypto_chip_features;
+			int chip_type = 1;
+
+			if(is_nlm_xlp9xx())
+				chip_type = 2;
+			else if(is_nlm_xlp2xx())
+				chip_type = 5; //both 0 and 2nd bit set
 
-			nlm_crypto_chip_features = nlm_hal_get_sae_chip_feature();
-			copy_to_user((ptr), &nlm_crypto_chip_features,sizeof(nlm_crypto_chip_features));
+			copy_to_user((ptr), &chip_type,sizeof(chip_type));
 
 			break;
 		}
diff --git a/drivers/netlogic/nlmcrypto/cryptosoc_lib_priv.h b/drivers/netlogic/nlmcrypto/cryptosoc_lib_priv.h
index 1bdfeda..35ff82d 100644
--- a/drivers/netlogic/nlmcrypto/cryptosoc_lib_priv.h
+++ b/drivers/netlogic/nlmcrypto/cryptosoc_lib_priv.h
@@ -72,7 +72,7 @@ cont_poll:
 extern int crypto_ctxt_alloc(struct cryptosoc_ctx *ctx);
 extern int crypto_ctxt_free(struct cryptosoc_ctx *ctx);
 extern int crypto_get_soc_vc_numbers(enum cryptosoc_soc_type soc, int *basevc, int *lmtvc);
-extern int cryptosoc_lib_priv_init(void);
+extern int cryptosoc_lib_priv_init(struct cryptosoc_lib_params *);
 extern int cryptosoc_lib_priv_finish(void);
 extern int crypto_get_rxvc_numbers(int *sae_rx_vc, int *sae_rx_sync_vc);
 
diff --git a/drivers/netlogic/nlmcrypto/init.c b/drivers/netlogic/nlmcrypto/init.c
index 4d79677..13c40a1 100644
--- a/drivers/netlogic/nlmcrypto/init.c
+++ b/drivers/netlogic/nlmcrypto/init.c
@@ -209,10 +209,10 @@ cont_recv:
 
 	printk("Downloading ucore data to rsa/ecc engine is done..\n");
 
-	/* configuring the internal scheduler by allocating all statations to all vcs 
-	*  TODO */
-	//nlm_hal_set_rsa_freq(p->node, p->freq);
-	//nlm_hal_set_rsa_engine_sel(p->node);
+	/* configuring the internal scheduler by allocating all statations to all vcs */
+        //nlm_hal_set_rsa_freq(p->node, p->freq);
+        nlm_hal_set_rsa_engine_sel(p->node);
+
 	if ((is_nlm_xlp9xx()) && rsa_data_fmt_is_ssl)
 		nlm_hal_set_rsa_data_mode(p->node, 0);
 
-- 
1.7.9.5

