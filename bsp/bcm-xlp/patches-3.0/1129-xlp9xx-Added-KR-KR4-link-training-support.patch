From d3b48d9067a98d1ae11fca13728ec79ac17cca4e Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Fri, 21 Feb 2014 16:42:19 +0530
Subject: [PATCH 129/163] xlp9xx: Added KR/KR4 link training support.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 .../netlogic/lib/netlib/include/netsoc_common.h    |    1 +
 .../netlogic/lib/netlib/include/netsoc_haliface.h  |    8 +-
 .../netlogic/lib/netlib/include/netsoc_libiface.h  |    8 +-
 arch/mips/netlogic/lib/netlib/include/netsoc_nae.h |   10 +-
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |    1 +
 arch/mips/netlogic/lib/netlib/src/netsoc_api.c     |   20 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_config.c  |    6 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     |   11 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     |    3 -
 arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c     |  202 ++++++++++++--------
 10 files changed, 174 insertions(+), 96 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index 18acc3e..4834559 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -429,6 +429,7 @@ static inline uint32_t get_msec_port_enable(uint32_t intf_type)
 	return 0;
 }
 
+
 static inline void update_default_config(int intf_type, uint32_t *config, uint32_t val)
 {
         uint32_t iface;
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index 04b01fd..e6de287 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -40,6 +40,7 @@
 #include "xlp2xx_netsoc.h"
 #include "xlp9xx_netsoc.h"
 #include "netsoc_common.h"
+#include "netsoc_libiface.h"
 #include "ext_phy.h"
 #include "nlm_hal_fmn.h"
 #include "xlp9xx_sys.h"
@@ -49,8 +50,8 @@ extern struct netsoc_info *current_netsoc;
 extern nae_t *xlp_nae[NLM_MAX_NODES][MAX_NAE_BLOCKS];
 extern poe_t *xlp_poe[NLM_MAX_NODES][MAX_NAE_BLOCKS];
 extern uint32_t nae_vfbid_tbl[NLM_MAX_NODES][MAX_NAE_BLOCKS][MAX_VFBID_ENTRIES];
-extern int __netsoc_parse_and_init(void *fdt, int dom_id);
-extern int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae);
+extern int __netsoc_parse_and_init(void *fdt, int dom_id, struct netsoc_lib_param* libparam);
+extern int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae, struct netsoc_lib_param* libparam);
 extern int fdt_parse_ucore_config(void *fdt, nae_t *nae);
 extern int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe);
 extern void update_netsoc_info(void);
@@ -94,7 +95,6 @@ extern void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask);
 extern void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode);
 extern void __netsoc_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phymode);
 extern void __netsoc_xlaui_pcs_init(nae_t *nae, uint32_t xlaui_cplx_mask, uint32_t phymode);
-extern void __netsoc_bkpl_ether_init(nae_t *nae);
 extern int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map);
 extern int register_marvell_phy(void);
 extern int register_broadcom_phy(void);
@@ -111,6 +111,8 @@ extern int __netsoc_config_nae_l4parser(nae_t *nae, l4_parser_config_t *l4_cfg,
 extern int __netsoc_alloc_poe_enq_storage(poe_t *poe);
 extern void __netsoc_enable_poe_stats(poe_t *poe);
 extern void __netsoc_print_poe_stats(poe_t *poe);
+extern void __netsoc_kr_init_an(nae_t *nae, int block);
+
 extern unsigned char pma2p0_mem_sgmii_4page [256];
 extern unsigned char pma2p0_mem_sgmii [256];
 
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
index a71b886..ead8e83 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
@@ -115,6 +115,7 @@ struct __netsoc_dev_stat{
 };
 typedef struct __netsoc_dev_stat dev_stat_t;
 
+
 struct netsoc_lib_param {
         void *(*malloc)(uint32_t size);
         void (*free)(void *buf);
@@ -130,6 +131,8 @@ struct netsoc_lib_param {
         void (*contig_free)(void *buf);
         uint64_t (*virt_to_phys)(void *);
         void *(*phys_to_virt)(uint64_t);
+	/*library params */
+	int kr_en;
 };
 
 static inline void *netsoc_api_contig_malloc(uint32_t align, uint32_t size)
@@ -519,8 +522,8 @@ static inline int is_netsoc_parser_enabled(nae_t *nae)
 }
 
 
-extern int init_netsoc(void *fdt, uint32_t dom_id);
-extern void brcm_netsoc_lib_init(struct netsoc_lib_param *libparam);
+extern int init_netsoc(void *fdt, uint32_t dom_id, struct netsoc_lib_param *libparam);
+extern int  brcm_netsoc_lib_init(struct netsoc_lib_param *libparam);
 extern uint32_t get_netsoc_features(void);
 extern int get_num_poe_pernode(void);
 extern poe_t *get_poe(uint32_t node, uint32_t poe_id);
@@ -584,4 +587,5 @@ extern int netsoc_print_nae_config(nae_t *);
 extern int netsoc_alloc_poe_enq_storage(poe_t *poe);
 extern void netsoc_enable_poe_stats(poe_t *poe);
 extern void netsoc_print_poe_stats(poe_t *poe);
+extern int netsoc_start_kr_an(nae_t *nae, int block);
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index c986d49..937deb7 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -252,7 +252,6 @@ static int __netsoc_pma2p0_cmd_poll_pend(uint64_t mac_base)
                 pma2p0_cmd = netsoc_read_mac_reg(mac_base, PMA2P0_CMD);
                 if( pma2p0_cmd & (1<<31)){
                         retries++;
-                        nlm_mdelay(1);
                         continue;
                 }else{
                         //nlm_print("PMA2P0 cmd pend clear\n");
@@ -1363,4 +1362,13 @@ static inline int __netsoc_disable_deepfifo(nae_t *nae, uint32_t context)
         return NETSOC_API_SUCCESS;
 }
 
+static inline int  __netsoc_validate_lib_param (struct netsoc_lib_param *param)
+{
+        if(!(is_nlm_xlp9xx()) && (param->kr_en)){
+                        return -1;
+        }else{
+                return 1;
+	}
+}
+
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index 44b0834..4c1273b 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -341,6 +341,7 @@ typedef struct nlm_hal_nae_port net_port_t;
 
 struct nlm_hal_nae_config {
 	struct nlm_hal_nae_config *sibling;
+	struct netsoc_info *current_soc;
 	uint64_t nae_base;
 	uint64_t mac_base;
 	uint64_t pcie_base;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index 2a0bb3b..12d101b 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -33,9 +33,10 @@
 #include "netsoc_libiface.h"
 #include "netsoc_nae.h"
 #include "netsoc_poe.h"
+#include "netsoc_common.h"
 #include <libfdt.h>
 
-void brcm_netsoc_lib_init(struct netsoc_lib_param *);
+int  brcm_netsoc_lib_init(struct netsoc_lib_param *);
 static int hallib_init_done = 0;
 
 void *(*netsoc_lib_malloc)(uint32_t size);
@@ -111,6 +112,11 @@ int netsoc_init_ext_phy(net_port_t *port)
 	return 0;
 }
 
+int netsoc_start_kr_an(nae_t* nae, int block)
+{
+	__netsoc_kr_init_an(nae, block);
+	return 0;
+}
 
 /**
 * @brief netsoc_reset_port: reset port
@@ -1685,7 +1691,7 @@ uint32_t get_netsoc_features(void)
 *
 */
 
-int init_netsoc(void *fdt, uint32_t dom_id)
+int init_netsoc(void *fdt, uint32_t dom_id, struct netsoc_lib_param *libparam)
 {
 	netsoc_api_print(NETSOC_APIDBG_DEFAULT, "%s dom %d", __func__, dom_id);
 	if (!hallib_init_done) {
@@ -1700,7 +1706,7 @@ int init_netsoc(void *fdt, uint32_t dom_id)
         }
 	
 	netsoc_api_print(NETSOC_APIDBG_TRACE, "calling __netsoc_parse_and_init\n");
-	return __netsoc_parse_and_init(fdt, dom_id);
+	return __netsoc_parse_and_init(fdt, dom_id, libparam);
 }
 
 
@@ -1713,7 +1719,7 @@ int init_netsoc(void *fdt, uint32_t dom_id)
 *
 */
 
-void brcm_netsoc_lib_init(struct netsoc_lib_param *libparam)	
+int  brcm_netsoc_lib_init(struct netsoc_lib_param *libparam)	
 {
 	uint32_t func, max_func;
 
@@ -1730,6 +1736,11 @@ void brcm_netsoc_lib_init(struct netsoc_lib_param *libparam)
 		netsoc_lib_virttophys = libparam->virt_to_phys;
 	}     
 
+	if(__netsoc_validate_lib_param(libparam)<0){
+		netsoc_api_print(NETSOC_APIDBG_ERROR," Invalid parameters to initilaize netlib\n");
+		return -1;	
+	}
+
 	update_netsoc_info();
 
 	max_func = sizeof(const_func_list) / sizeof(const_func_list[0]);
@@ -1737,6 +1748,7 @@ void brcm_netsoc_lib_init(struct netsoc_lib_param *libparam)
 		const_func_list[func]();
 	}
 	hallib_init_done = 1;
+	return 1;
 }
 
 #ifdef NLM_HAL_LINUX_KERNEL
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index bafd265..11d3265 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -501,6 +501,8 @@ static void __netsoc_update_nae_defaultconfig(nae_t *nae)
 	nae->hwparser.l3.status = 0;
 	nae->hwparser.l4.num_entries = current_netsoc->parser.max_l4_entries;
 	nae->hwparser.l4.status = 0;
+
+	nae->current_soc = current_netsoc;
 }
 
 static void __netsoc_update_poe_defaultconfig(poe_t *poe)
@@ -564,7 +566,7 @@ static int __netsoc_init(void)
 }
 
 
-int __netsoc_parse_and_init(void *fdt, int dom_id)
+int __netsoc_parse_and_init(void *fdt, int dom_id, struct netsoc_lib_param* libparam)
 {
 	int retval;
 #ifndef XLP_SIM
@@ -603,7 +605,7 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 			// Fill the default values 
 			__netsoc_update_nae_defaultconfig(nae);
 			// fdt_parse_netsoc_nae_config fills 'nae' structure with the configuration information to intialize NAE
-			retval = fdt_parse_netsoc_nae_config(fdt, dom_id, nae);
+			retval = fdt_parse_netsoc_nae_config(fdt, dom_id, nae, libparam);
 			if (retval) {
 				netsoc_api_print(NETSOC_APIDBG_ERROR,"%s: parse nae fdt failed\n",__func__);
 				return -1;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 5ad5b1d..a9f3916 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -916,7 +916,7 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
 
 //#define MACSEC_DEBUG 1
 
-static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
+static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg, struct netsoc_lib_param *libparam)
 {
         char nae_port_str[80];
         struct nae_complex_config cmplx_cfg;
@@ -1086,6 +1086,9 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                         nae_cfg->bkpl_cfg[block].message_page =cmplx_cfg.bkpl_cfg.message_page;
                         nae_cfg->bkpl_cfg[block].link_training_enable =cmplx_cfg.bkpl_cfg.link_training_enable;
                         nae_cfg->bkpl_cfg[block].read_rem_ability_registers =cmplx_cfg.bkpl_cfg.read_rem_ability_registers;
+			if(!nae_cfg->bkpl_cfg[block].kr_en && libparam->kr_en){
+				nae_cfg->bkpl_cfg[block].kr_en = libparam->kr_en;
+			}	
 		}
                 if(intf_type == XAUI_IF || intf_type == RXAUI_IF)
                 {
@@ -1529,7 +1532,7 @@ void nlm_hal_retrieve_nae_rx_cpu_mask(void *fdt, int dom_id, nae_t *nae)
 #endif
 }
 
-int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
+int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae, struct netsoc_lib_param *libparam)
 {
         if (is_nlm_xlp9xx()) {
 		if(!fdt_get_nae(fdt, nae))
@@ -1546,7 +1549,7 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 
 	if (dom_id < 0) {
 		nae->owned = 0;
-		fdt_parse_port_config(fdt, nae);
+		fdt_parse_port_config(fdt, nae, libparam);
 		return 0;
 	}
 
@@ -1572,7 +1575,7 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 
 	nlm_hal_retrieve_nae_rx_cpu_mask(fdt, dom_id, nae);
 
-	fdt_parse_port_config(fdt, nae);
+	fdt_parse_port_config(fdt, nae, libparam);
 	return 0;
 }
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 510af67..0e13978 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -4310,9 +4310,6 @@ int __netsoc_init_nae(nae_t *nae)
 
 		__netsoc_init_all_ports(nae);
 		
-		if(is_nlm_xlp9xx())
-			__netsoc_bkpl_ether_init(nae); /*do KR/KR4 lane configuration*/	
-
 		if (nae->freein_uniq_sz) {
 		        for (frin_q = 0; frin_q < __netsoc_get_max_frinqs(); frin_q++) {
                 		__netsoc_write_fifo_size(nae, frin_q, nae->frin_desc_size[frin_q]);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index e68a283..e277462 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -606,7 +606,7 @@ static void vsemi_configure_loopback(uint64_t mac_base)
 	}
 }
 
-void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed, int phy_mode, int kr_lpbk)
+void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed, int phy_mode, int kr_en)
 {
         uint32_t reg_addr, lane_no, max_lanes =4;  
         uint32_t pma2p0_cmd=0;
@@ -718,13 +718,13 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 	
 	if((phy_mode == PHYMODE_XLAUI) || (phy_mode == PHYMODE_XFI) || (phy_mode == PHYMODE_IL)){ 
 		for (lane_no=0; lane_no<max_lanes; lane_no++) {
-			if (kr_lpbk)
+			if (kr_en)
 				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x15, 0xdf);
 			else
 				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x15, 0xd9);
 					
 			__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x16, 0x07);
-			if (kr_lpbk)
+			if (kr_en)
 				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1c, 0x50);
 			else
 				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1c, 0xc0);
@@ -829,7 +829,7 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 
                 netsoc_write_mac_reg(mac_base, PMA2P0_CTL1, pma2p0_config);
 
-                xlp9xx_nae_write_pma2p0_mem(mac_base, block, speed, phymode, nae->bkpl_cfg[block].kr_lpbk);
+                xlp9xx_nae_write_pma2p0_mem(mac_base, block, speed, phymode, nae->bkpl_cfg[block].kr_en);
 #ifdef PMA2P0_DEBUG
 		__netsoc_display_pma2p0_indirect_reg(mac_base, block);	
 #endif
@@ -1604,14 +1604,14 @@ void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
 	}
 	__netsoc_write_kr_reg(base, lane_no, KXAN_ABILITY_1, rd_data);
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_1);
-	nlm_print("AN_ABILITY1:  lane:%d value is %x\n",  lane_no, rd_data);
+	//nlm_print("AN_ABILITY1:  lane:%d value is %x\n",  lane_no, rd_data);
 
 	//ability 2
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_2);
-	nlm_print("Data read from ability 2 is 0x%x\n", rd_data);
-	nlm_print("AN_ABILITY2: complex: %d: lane: %d value is %x\n",block, lane_no, rd_data);
+	//nlm_print("Data read from ability 2 is 0x%x\n", rd_data);
+	//nlm_print("AN_ABILITY2: complex: %d: lane: %d value is %x\n",block, lane_no, rd_data);
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
-	nlm_print("AN_STATUS: complex: %d lane :%d read value is %x\n",block, lane_no, rd_data);
+	//nlm_print("AN_STATUS: complex: %d lane :%d read value is %x\n",block, lane_no, rd_data);
 	__netsoc_write_kr_reg(base, lane_no, KXAN_MS_COUNT, 0xffff);
 
 	//Step2:
@@ -1642,7 +1642,7 @@ void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
 	//}
 	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
-	nlm_print(" AN_CONTROL:  lane:%d value is 0x%x\n",  lane_no, rd_data); 
+	//nlm_print(" AN_CONTROL:  lane:%d value is 0x%x\n",  lane_no, rd_data); 
 
 	//DEBUG: Read DME VSEMI register bit
 	//rd_data = read_vsemi_reg( lane_no, 0x28);
@@ -1675,16 +1675,16 @@ void __netsoc_perform_clause_173_base_page(nae_t *nae, uint32_t block, uint32_t
 		nlm_mdelay(10);
 		//if(count++ == 50) break; 
 	}
-	nlm_print(" AN_STATUS: complex: %d lane: %d Base page exchange completed value:0x%x\n",block, lane_no, rd_data);
+	//nlm_print(" AN_STATUS: complex: %d lane: %d Base page exchange completed value:0x%x\n",block, lane_no, rd_data);
 	//TODO:
 	//if(netior_config.read_rem_ability_registers == 1) {
 	//Read rem_ability registers:
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_0);
-	nlm_print("AN_REM_ABILITY0: value is 0x%x\n",rd_data);
+	//nlm_print("AN_REM_ABILITY0: value is 0x%x\n",rd_data);
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_1);
-	nlm_print("AN_REM_ABILITY1: value is 0x%x\n",rd_data);
+	//nlm_print("AN_REM_ABILITY1: value is 0x%x\n",rd_data);
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_2);
-	nlm_print("AN_REM_ABILITY2: value is 0x%x\n",rd_data);
+	//nlm_print("AN_REM_ABILITY2: value is 0x%x\n",rd_data);
 	//}
 
 	//If remote device does not have AN capability, AN process will be stuck at this stage,timeout to be implemented in this state to exit - MTIP spec
@@ -1954,7 +1954,7 @@ void send_maintap_update (nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t
 	main_tap_coeff = update; 
 	rd_data = (main_tap_coeff << 2); 
 	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-	nlm_print("send_maintap_update: SEND C(0) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+	//nlm_print("send_maintap_update: SEND C(0) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 
 	//Read LP status register
 	do {
@@ -1965,14 +1965,14 @@ void send_maintap_update (nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t
 			rd_data = (main_tap_coeff << 2); 
 			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
 			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
-			nlm_print("send_maintap_update: Set C(0) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+			//nlm_print("send_maintap_update: Set C(0) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 		} 
 	} while (main_tap_status == 0x0);
 	do {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
 		main_tap_status = ((rd_data & 0xC) >> 2);
 	} while(main_tap_status != 0x0);
-	nlm_print("send_maintap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
+	//nlm_print("send_maintap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
 }
 
 void send_pretap_update(nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update)
@@ -1984,29 +1984,25 @@ void send_pretap_update(nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t u
 	pre_tap_coeff = update; 
 	rd_data = pre_tap_coeff; 
 	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-	nlm_print("send_pretap_update: SEND C(-1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+	//nlm_print("send_pretap_update: SEND C(-1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 
 	//Read LP status register
 	do {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		nlm_print("send_pretap_update:  lane:%d Value of LP status register is 0x%x\n",  lane_no, rd_data);
+		//nlm_print("send_pretap_update:  lane:%d Value of LP status register is 0x%x\n",  lane_no, rd_data);
 		pre_tap_status = (rd_data & 0x3);
 		if((pre_tap_status == 0x3) || (pre_tap_status == 0x2) || (pre_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
 			pre_tap_coeff = 0x0; // hold 
 			rd_data = pre_tap_coeff; 
 			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-			nlm_print("send_pretap_update: Set C(-1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+		//	nlm_print("send_pretap_update: Set C(-1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 		}
 	} while (pre_tap_status == 0x0);
 	do {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-		if((rd_data & BIT(2)) != BIT(2)) {
-			__netsoc_bkpl_restart_link_training(nae, block, lane_no);
-		}
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
 		pre_tap_status = (rd_data & 0x3);
 	} while(pre_tap_status != 0x0);
-	nlm_print("send_pretap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
+	//nlm_print("send_pretap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
 }
 
 void send_posttap_update( nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update){
@@ -2017,26 +2013,26 @@ void send_posttap_update( nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t
 	post_tap_coeff = update; 
 	rd_data = (post_tap_coeff << 4); 
 	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-	nlm_print("send_posttap_update: SEND C(+1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+	//nlm_print("send_posttap_update: SEND C(+1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 
 	//Read LP status register
 	do {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		nlm_print("send_posttap_update:  lane:%d Value of LP status register is 0x%x \n",  lane_no, rd_data);
+		//nlm_print("send_posttap_update:  lane:%d Value of LP status register is 0x%x \n",  lane_no, rd_data);
 		post_tap_status = ((rd_data & 0x30) >> 4);
 		if((post_tap_status == 0x3) || (post_tap_status == 0x2) || (post_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
 			post_tap_coeff = 0x0; // hold 
 			rd_data = (post_tap_coeff << 4); 
 			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
 			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
-			nlm_print("send_posttap_update: Set C(+1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+		//	nlm_print("send_posttap_update: Set C(+1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 		} 
 	} while (post_tap_status == 0x0);
 	do {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
 		post_tap_status = ((rd_data & 0x30) >> 4);
 	} while(post_tap_status != 0x0);
-	nlm_print("send_posttap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
+	//nlm_print("send_posttap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
 }
 
 
@@ -2072,7 +2068,7 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
 	//txdrv_hlev = (rd_data & 0x7);        //21[2:0] 
 	txdrv_levn = ((rd_data >> 3) & 0x1F);//21[7:3]
-	//nlm_print("program_tx_driver:  lane:%d 21:0x%x\n",  lane_no, rd_data);
+	////nlm_print("program_tx_driver:  lane:%d 21:0x%x\n",  lane_no, rd_data);
 	rd_data =  __netsoc_read_pma2p0_reg(base, lane_no, 22);
 	txdrv_levnm1 = (rd_data & 0xF);       //22[3:0]
 	//txdrv_levnm2 = ((rd_data >> 4) & 0xF);//22[7:4] 
@@ -2095,13 +2091,13 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 		present_coeff_zero   = coeff27;
 		present_coeff_plus1  = coeff27_plus1;
 	}
-	nlm_print("program_tx_driver: lane:%d  present_coeff_minus1:%d present_coeff_zero:%d present_coeff_plus1:%d\n", lane_no,present_coeff_minus1, present_coeff_zero,present_coeff_plus1);
+	//nlm_print("program_tx_driver: lane:%d  present_coeff_minus1:%d present_coeff_zero:%d present_coeff_plus1:%d\n", lane_no,present_coeff_minus1, present_coeff_zero,present_coeff_plus1);
 
 
 	//Read LP coefficient update
 	do {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF); 
-		nlm_print("program_tx_driver:  lane:%d Value of LP coefficient update register is 0x%x --1\n", lane_no, rd_data);
+		//nlm_print("program_tx_driver:  lane:%d Value of LP coefficient update register is 0x%x --1\n", lane_no, rd_data);
 		//Get coeff updates
 		coeff_minus1_update = (rd_data & 0x3);
 		coeff_zero_update   = ((rd_data >> 2) & 0x3);
@@ -2175,7 +2171,7 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 			updated_status_zero = 0;
 			updated_status_plus1 = 0;
 		}
-		nlm_print("program_tx_driver:  lane:%d updated_coeff_minus1:%d updated_coeff_zero:%d updated_coeff_plus1:%d\n",  lane_no,updated_coeff_minus1,updated_coeff_zero,updated_coeff_plus1 );
+		//nlm_print("program_tx_driver:  lane:%d updated_coeff_minus1:%d updated_coeff_zero:%d updated_coeff_plus1:%d\n",  lane_no,updated_coeff_minus1,updated_coeff_zero,updated_coeff_plus1 );
 
 		mod_updated_coeff_minus1 =  mod(updated_coeff_minus1); 
 		mod_updated_coeff_zero   =  mod(updated_coeff_zero);
@@ -2221,7 +2217,7 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 		rd_data |= (updated_status_plus1 << 4);
 		__netsoc_write_kr_reg(base, lane_no, KR_LD_STAT, rd_data);
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
-		nlm_print("program_tx_driver :  lane:%d Value of LD status register is 0x%x\n", lane_no, rd_data);
+	//	nlm_print("program_tx_driver :  lane:%d Value of LD status register is 0x%x\n", lane_no, rd_data);
 
 		present_coeff_minus1 = updated_coeff_minus1;
 		present_coeff_zero   = updated_coeff_zero;
@@ -2237,13 +2233,13 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 		do {
 			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
 		} while (rd_data != 0x0);
-		nlm_print("program_tx_driver: lane:%d Value of LP coefficient update register is 0x%x -2\n", lane_no, rd_data);
+		//nlm_print("program_tx_driver: lane:%d Value of LP coefficient update register is 0x%x -2\n", lane_no, rd_data);
 		//Set LD Status to not updated
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
 		rd_data &= 0xFFC0 ; // set 5:0 to 0 (not updated) 
 		__netsoc_write_kr_reg(base , lane_no, KR_LD_STAT, rd_data);
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
-		nlm_print("program_tx_driver:  lane:%d Value of LD status register is 0x%x\n", lane_no, rd_data);
+		//nlm_print("program_tx_driver:  lane:%d Value of LD status register is 0x%x\n", lane_no, rd_data);
 
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
 
@@ -2306,19 +2302,19 @@ void __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lan
 	while((rd_data & BIT(1)) != BIT(1)) {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
 	}
-	nlm_print("link_device_training:  lane:%d PMD STATUS value:0x%x\n",  lane_no, rd_data);
+	//nlm_print("link_device_training:  lane:%d PMD STATUS value:0x%x\n",  lane_no, rd_data);
 
 	//program_tx_driver( lane_no);
 
 	//Read LP status
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-	nlm_print("link_device_training:  lane:%d Value of LP status register is 0x%x\n", lane_no, rd_data);
+	//nlm_print("link_device_training:  lane:%d Value of LP status register is 0x%x\n", lane_no, rd_data);
 	while ((rd_data & BIT(15)) == 0) {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF); 
 		if((rd_data & 0x3F)!= 0x0) __netsoc_bkpl_program_tx_driver(nae, block, lane_no);
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
 	}
-	nlm_print("link_device_training:  lane:%d Value of LP status register is 0x%x\n",  lane_no, rd_data);
+	//nlm_print("link_device_training:  lane:%d Value of LP status register is 0x%x\n",  lane_no, rd_data);
 
 
 	if(block==1) {
@@ -2326,12 +2322,12 @@ void __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lan
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
 		rd_data |= (0x1 << 0); // to push state machine into ( mr_trained ) remote training state
 		__netsoc_write_kr_reg(base,  lane_no, KR_PMD_STATUS, rd_data);
-		nlm_print("link_device_training:  lane:%d Pushed state machine into remote training state\n",  lane_no);
+		//nlm_print("link_device_training:  lane:%d Pushed state machine into remote training state\n",  lane_no);
 	}
 
 	//wait for lt_done
 	if(block==1) {
-		nlm_print("link_device_training:  lane:%d Waiting for signal_detection signal to go high - lt_done\n",  lane_no);
+		//nlm_print("link_device_training:  lane:%d Waiting for signal_detection signal to go high - lt_done\n",  lane_no);
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
 		while((rd_data & BIT(15)) == 0) { //signal detection - indicates training process is complete
 			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
@@ -2368,7 +2364,7 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 	//3 Record the figure of merit
 	//Assert Start and wait for done and then record figure of merit
 	eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-	nlm_print("link_partner_training:  lane:%d  Initial eye_value: 0x%x\n",  lane_no, eye_value);
+	//nlm_print("link_partner_training:  lane:%d  Initial eye_value: 0x%x\n",  lane_no, eye_value);
 	//nlm_print("link_partner_training:  lane:%d  Read initial rx equalization register values\n",  lane_no);
 	//read_vsemi_rxequalization_registers( lane_no);
 	//clear_netior_interrupts(inst_no);
@@ -2380,15 +2376,15 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 		send_maintap_update(nae, block, lane_no, 0x2); //decrement
 
 		updated_eye_value =__netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no); 
-		nlm_print("link_partner_training:  lane:%d  After step 4i updated_eye_value:0x%x\n",  lane_no, updated_eye_value);
+		//nlm_print("link_partner_training:  lane:%d  After step 4i updated_eye_value:0x%x\n",  lane_no, updated_eye_value);
 		//ii   Send INC(-1)
-		send_maintap_update(nae, block, lane_no, 0x1); //increment
+		send_pretap_update(nae, block, lane_no, 0x1); //increment
 
 		//iii  
 		//iv  
 		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);;
-		nlm_print("link_partner_training:  lane:%d  After step 4ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
-		nlm_print("link_partner_training:  lane:%d  updated_eye_value: 0x%x eye_value:0x%x\n",  lane_no, updated_eye_value, eye_value);
+		//nlm_print("link_partner_training:  lane:%d  After step 4ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+		//nlm_print("link_partner_training:  lane:%d  updated_eye_value: 0x%x eye_value:0x%x\n",  lane_no, updated_eye_value, eye_value);
 		//nlm_print("link_partner_training:  lane:%d  After step 4ii Read rx equalization register values\n", lane_no);
 		//read_vsemi_rxequalization_registers( lane_no);
 		count++;
@@ -2398,7 +2394,7 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 	send_pretap_update(nae, block, lane_no, 0x2); //decrement
 
 	updated_eye_value =  __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-	nlm_print("link_partner_training:  lane:%d  After step 4v updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+	//nlm_print("link_partner_training:  lane:%d  After step 4v updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
 	//nlm_print("link_partner_training:  lane:%d  After step 4v Read rx equalization register values\n", lane_no);
 	//read_vsemi_rxequalization_registers( lane_no);
 
@@ -2410,7 +2406,7 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 		eye_value = updated_eye_value;
 		send_maintap_update(nae, block, lane_no, 0x2); //decrement
 		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-		nlm_print("link_partner_training:  lane:%d  After step 5i updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+		//nlm_print("link_partner_training:  lane:%d  After step 5i updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
 		//nlm_print("link_partner_training:  lane:%d  After step 5i Read rx equalization register values\n",  lane_no);
 		//read_vsemi_rxequalization_registers( lane_no);
 
@@ -2420,17 +2416,17 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 		//iii  
 		//iv  
 		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-		nlm_print("link_partner_training:  lane:%d  After step 5ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+		//nlm_print("link_partner_training:  lane:%d  After step 5ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
 		//nlm_print("link_partner_training:  lane:%d  After step 5ii Read rx equalization register values\n",  lane_no);
 		//read_vsemi_rxequalization_registers( lane_no);
-		nlm_print("link_partner_training:  lane:%d  updated_eye_value: 0x%x eye_value:0x%x\n",  lane_no, updated_eye_value, eye_value);
+	//	nlm_print("link_partner_training:  lane:%d  updated_eye_value: 0x%x eye_value:0x%x\n",  lane_no, updated_eye_value, eye_value);
 		count++;
 	} while (updated_eye_value > eye_value);
 
 	//6  Send DEC C(+1)
 	send_posttap_update(nae, block, lane_no, 0x2); //decrement
 	updated_eye_value =  __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);  
-	nlm_print("link_partner_training:  lane:%d  After step 6: updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+	//nlm_print("link_partner_training:  lane:%d  After step 6: updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
 	//nlm_print("link_partner_training:  lane:%d  After step 6 Read rx equalization register values\n",  lane_no);
 	//read_vsemi_rxequalization_registers( lane_no);
 
@@ -2438,7 +2434,7 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 	send_maintap_update(nae, block, lane_no, 0x1); //increment
 
 	updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-	nlm_print("link_partner_training:  lane:%d  After step 7 updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+	//nlm_print("link_partner_training:  lane:%d  After step 7 updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
 	//nlm_print("link_partner_training:  lane:%d  After step 7 Read rx equalization register values\n",  lane_no);
 	//read_vsemi_rxequalization_registers( lane_no);
 
@@ -2448,15 +2444,15 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 	rd_data |= (0x1 << 15); // receiver ready
 	__netsoc_write_kr_reg(base,  lane_no, KR_LD_STAT, rd_data);
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
-	nlm_print("link_partner_training:  lane:%d Set receiver ready Value of LD status register is 0x%x\n", lane_no, rd_data);
+	//nlm_print("link_partner_training:  lane:%d Set receiver ready Value of LD status register is 0x%x\n", lane_no, rd_data);
 
 	if(block==0) {
 		//PMD status
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
 		rd_data |= (0x1 << 0); // to push state machine into ( mr_trained ) remote training state
 		__netsoc_write_kr_reg(base,  lane_no, KR_PMD_STATUS, rd_data);
-		nlm_print("link_partner_training:  lane:%d Pushed state machine into remote training state\n",  lane_no);
-		nlm_print("link_partner_training:  lane:%d Waiting for signal_detection signal to go high - lt_done\n", lane_no);
+	//	nlm_print("link_partner_training:  lane:%d Pushed state machine into remote training state\n",  lane_no);
+	//	nlm_print("link_partner_training:  lane:%d Waiting for signal_detection signal to go high - lt_done\n", lane_no);
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
 		while((rd_data & BIT(15)) == 0) { //signal detection - indicates training process is complete
 			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
@@ -2470,7 +2466,7 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 		while ((rd_data & BIT(15)) == 0) {
 			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
 		}
-		nlm_print("link_partner_training:  lane:%d Value of LP status register is 0x%x\n", lane_no, rd_data);
+		//nlm_print("link_partner_training:  lane:%d Value of LP status register is 0x%x\n", lane_no, rd_data);
 	}
 
 }
@@ -2551,45 +2547,95 @@ void __netsoc_xlaui_pcs_init(nae_t *nae, uint32_t xlaui_cplx_mask, uint32_t phym
 #endif
 }
 
-void __netsoc_bkpl_ether_init(nae_t *nae)
+void __netsoc_kr_init_an(nae_t *nae, int block)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
 
-	uint32_t block, lane_ctrl, max_kr_lanes=0;
+	uint32_t lane_ctrl, max_kr_lanes=4, lane_no;
 	uint32_t cplx_mask = nae->xlgmac_complex_map | nae->xfi_complex_map;
-
-	for( block = 0; block < 2; block++)
-        {
+#define NUM_LANES_PER_COMPLEX 4	
+	static volatile int lt_done_nae0_c0[NUM_LANES_PER_COMPLEX]; 
+	static volatile int lt_done_nae0_c1[NUM_LANES_PER_COMPLEX]; 
+	static volatile int lt_done_nae1_c0[NUM_LANES_PER_COMPLEX]; 
+	static volatile int lt_done_nae1_c1[NUM_LANES_PER_COMPLEX]; 
+
+	//for( block = 0; block < 2; block++)
+        //{
 		uint32_t phymode = get_phy_mode(nae, block); 
 		
 		if(!(phymode==XLAUI_IF || phymode==XFI_IF))
-		 	continue;
-		max_kr_lanes = (phymode==XFI_IF) ? 3:0; 
+		 	return;
+//		 	continue;
 		
-		if(!(nae->bkpl_cfg[block].kr_en))
-			continue;
+		//if(!(nae->bkpl_cfg[block].kr_en))
+		//	continue;
 
-                for( lane_ctrl = 0; lane_ctrl <= max_kr_lanes; lane_ctrl++){
-			__netsoc_clause_173_enable(nae, block, lane_ctrl);		
+                for( lane_ctrl = 0; lane_ctrl < max_kr_lanes; lane_ctrl++){
+			__netsoc_setup_bkpl_link_training(nae, block, lane_ctrl);		
 		}
 	
-	}
-	for( block = 0; block < 2; block++)
-        {
-		uint32_t phymode = get_phy_mode(nae, block); 
+	//}
+
+	//for( block = 0; block < 2; block++)
+        //{
+	//	uint32_t phymode = get_phy_mode(nae, block); 
 		
-		if(!(phymode==XLAUI_IF || phymode==XFI_IF))
-		 	continue;
-		max_kr_lanes = (phymode==XFI_IF) ? 3:0; 
+	//	if(!(phymode==XLAUI_IF || phymode==XFI_IF))
+	//	 	continue;
+	//	max_kr_lanes = (phymode==XFI_IF) ? 4:0; 
 		
-		if(!(nae->bkpl_cfg[block].kr_en))
-			continue;
+	//	if(!(nae->bkpl_cfg[block].kr_en))
+	//		continue;
 
-                for( lane_ctrl = 0; lane_ctrl <= max_kr_lanes; lane_ctrl++){
+                for( lane_ctrl = 0; lane_ctrl <=0; lane_ctrl++){
+			__netsoc_clause_173_enable(nae, block, lane_ctrl);		
+		}
+	
+	//}
+	//for( block = 0; block < 2; block++)
+        //{
+	//	uint32_t phymode = get_phy_mode(nae, block); 
+	
+	//	if(!(phymode==XLAUI_IF || phymode==XFI_IF))
+	//	 	continue;
+	//	max_kr_lanes = (phymode==XFI_IF) ? 4:0; 
+		
+	//	if(!(nae->bkpl_cfg[block].kr_en))
+	//		continue;
+
+                for( lane_ctrl = 0; lane_ctrl <= 0; lane_ctrl++){
 			__netsoc_perform_clause_173_base_page(nae, block, lane_ctrl);		
 		}
+                
+		for( lane_ctrl = 0; lane_ctrl < max_kr_lanes; lane_ctrl++){
+			__netsoc_bkpl_enable_link_training(nae, block, lane_ctrl);		
+		}
+		nlm_print("Done with enable link with block = 0x%x\n", block);
 	
-	}
+	//}
+		if (block==1){
+			for(lane_no=0; lane_no<4; lane_no++){
+        			if(lane_no != 0) while(lt_done_nae0_c0[lane_no -1] == 0) {}
+	        	         nlm_print(" Start Link Partner training on  complex:1 lane:%d\n",  lane_no);
+        	        	__netsoc_bkpl_link_partner_training(nae, 1, lane_no);
+	                	__netsoc_bkpl_link_device_training(nae, 1, lane_no);
+        	        	nlm_print(" Finished Link Device training on  complex:1 lane:%d\n",  lane_no);
+                		lt_done_nae0_c1[lane_no] = 1;
+			}
+		}
+		if (block==0){
+			for(lane_no=0; lane_no<4; lane_no++){
+        			if(lane_no != 0) while(lt_done_nae0_c1[lane_no -1] == 0) {}
+	        	         nlm_print(" Start Link Partner training on  complex:0 lane:%d\n",  lane_no);
+	                	__netsoc_bkpl_link_device_training(nae, 0, lane_no);
+        	        	__netsoc_bkpl_link_partner_training(nae, 0, lane_no);
+        	        	nlm_print(" Finished Link Device training on  complex:0 lane:%d\n",  lane_no);
+                		lt_done_nae0_c0[lane_no] = 1;
+			}
+		}
+
+
+#if 0
 	for( block = 0; block < 2; block++)
         {
 		uint32_t phymode = get_phy_mode(nae, block); 
@@ -2604,8 +2650,10 @@ void __netsoc_bkpl_ether_init(nae_t *nae)
 			//}
 		}
 	}
+endif
 
 #endif
+#endif
 	
 }
 
-- 
1.7.9.5

