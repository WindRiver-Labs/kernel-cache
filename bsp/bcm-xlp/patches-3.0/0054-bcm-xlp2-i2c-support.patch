From 9468652f091244443e4054f8d86895e9ac796ac5 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Mon, 17 Feb 2014 19:57:32 +0800
Subject: [PATCH 54/58] bcm-xlp2: i2c support

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/i2c/busses/Kconfig      |   11 +
 drivers/i2c/busses/Makefile     |    1 +
 drivers/i2c/busses/i2c-xlp9xx.c |  514 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 526 insertions(+)

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 4faf02b..c0b330e 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -755,6 +755,17 @@ config I2C_XLR
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-xlr.
 
+config I2C_XLP9XX
+	tristate "XLP9XX I2C support"
+	depends on CPU_XLP && I2C
+	default y
+	help
+	  This driver enables support for the on-chip I2C interface of
+	  the Broadcom XLP9xx MIPS processors.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-xlp9xx.
+
 config I2C_RCAR
 	tristate "Renesas R-Car I2C Controller"
 	depends on ARCH_SHMOBILE && I2C
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 8f4fc23..0e386a8 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -74,6 +74,7 @@ obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
 obj-$(CONFIG_I2C_OCTEON)	+= i2c-octeon.o
 obj-$(CONFIG_I2C_XILINX)	+= i2c-xiic.o
 obj-$(CONFIG_I2C_XLR)		+= i2c-xlr.o
+obj-$(CONFIG_I2C_XLP9XX)        += i2c-xlp9xx.o
 obj-$(CONFIG_I2C_RCAR)		+= i2c-rcar.o
 
 # External I2C/SMBus adapter drivers
diff --git a/drivers/i2c/busses/i2c-xlp9xx.c b/drivers/i2c/busses/i2c-xlp9xx.c
new file mode 100644
index 0000000..d9203d3
--- /dev/null
+++ b/drivers/i2c/busses/i2c-xlp9xx.c
@@ -0,0 +1,514 @@
+/*
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/of_i2c.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+
+//#define DEBUG
+#ifdef DEBUG
+#define i2c_dbg(fmt,args...)     printk (fmt,##args)
+#else
+#define i2c_dbg(fmt,args...)
+#endif
+
+enum processor_I2C
+{
+	I2C_DIVISOR     = 0x0,
+	I2C_CONTROL     = 0x1,
+	I2C_COMMAND     = 0x2,
+	I2C_STATUS      = 0x3,
+	I2C_MASTER_TX   = 0x4,
+	I2C_MASTER_RX   = 0x5,
+	I2C_MASTER_FCTL = 0x6,
+	I2C_SLAVE_TX    = 0x7,
+	I2C_SLAVE_RX    = 0x8,
+	I2C_SLAVE_FCTRL = 0x9,
+	I2C_I2CADDR     = 0xA,
+	I2C_CHIPADDR    = 0xB,
+	I2C_FIFO_COUNT  = 0xC,
+	I2C_INTEN       = 0xD,
+	I2C_INTST       = 0xE,
+	I2C_WAITCYCLE   = 0xF,
+	I2C_GENCALADDR  = 0x10
+};
+
+#define I2C_FIFO_SIZE       128
+#define I2C_CONTROL_RESET   (1<<8)
+#define I2C_CONTROL_EN      (1<<6)
+#define I2C_CONTROL_MASTER  (1<<4)
+#define I2C_CONTROL_FWRITE  0
+#define I2C_CONTROL_FREAD   (1<<1)
+
+#define I2C_COMMAND_START   (1<<7)
+#define I2C_COMMAND_STOP    (1<<6)
+#define I2C_COMMAND_READ    (1<<5)
+#define I2C_COMMAND_WRITE   (1<<4)
+#define I2C_COMMAND_NACK    (1<<3)
+
+#define I2C_I2CADDR_READ   1
+
+#define I2C_STATUS_BUSY    1
+
+#define I2C_MASTER_FCTL_RESET (1<<16)
+
+#define I2C_INTST_ALOST   (1<<11)  //arbitration lost
+#define I2C_INTST_RWDONE  (1<<12)  //read/write done
+#define I2C_INTST_ANACK   (1<<25)  //Nack for address
+#define I2C_INTST_WNACK   (1<<25)  //Nack for write
+
+
+#define I2C_TIMEOUT           10
+#define I2C_CONTROLLER_NUM    4
+
+static inline void xlp9xx_i2c_wreg(u32 __iomem *base, unsigned int reg, u32 val)
+{
+	__raw_writel(val, base + reg);
+}
+
+static inline u32 xlp9xx_i2c_rdreg(u32 __iomem *base, unsigned int reg)
+{
+	u32 val;
+	val = __raw_readl(base + reg);
+	return val;
+}
+
+struct xlp9xx_i2c_private {
+	struct platform_device *pdev;
+	struct i2c_adapter adap;
+	u32	clock_mhz;
+	u32 __iomem *iobase;
+};
+
+static int xlp9xx_i2c_wait_bus(struct xlp9xx_i2c_private *priv)
+{
+	static const int c_maxus = 1000;
+	u32 n=0;
+	u32 bus __attribute__((__unused__)) = priv->adap.nr;
+
+	while(( xlp9xx_i2c_rdreg(priv->iobase, I2C_STATUS) & I2C_STATUS_BUSY ) && n<c_maxus)
+	{
+		udelay(1);
+		n++;
+	}
+
+	if( n < c_maxus ) return 0;
+
+	i2c_dbg(" I2C Bus%d is busy: 0x%x\n", bus, xlp9xx_i2c_rdreg(priv->iobase, I2C_STATUS) );
+	return -EBUSY;
+}
+
+static int xlp9xx_i2c_tx(struct xlp9xx_i2c_private *priv,  u16 len,
+	u8 *data, u16 addr)
+{
+	int ret, off;
+	u32 rdata, n;
+	u32 bus __attribute__((__unused__)) = priv->adap.nr;
+	u32 wlen = 0;
+
+	off = data[0];
+
+	i2c_dbg("oc_i2c_tx: bus=%d, addr=0x%x, off=%#x, len=%d, data=0x%x\n",
+	        priv->adap.nr, addr, off, len, data[1] );
+
+	//wait for bus ideal
+	ret = xlp9xx_i2c_wait_bus( priv );
+	if( ret != 0) 
+		return -EBUSY;
+
+	//clear FIFO, set fifo opr to write slave
+	xlp9xx_i2c_wreg(priv->iobase, I2C_INTST, 0x3FFFFFF );  //clean int status
+	xlp9xx_i2c_wreg(priv->iobase, I2C_MASTER_FCTL, I2C_MASTER_FCTL_RESET );
+	rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_CONTROL ) & (~I2C_CONTROL_FREAD) & 0xFFFF;
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, rdata );
+	i2c_dbg("    I2C_CONTROL: 0x%x\n", xlp9xx_i2c_rdreg(priv->iobase, I2C_CONTROL ) );
+
+	//setup address
+	xlp9xx_i2c_wreg(priv->iobase, I2C_I2CADDR, (addr<<1) );
+	i2c_dbg("    I2C_I2CADDR: 0x%x\n", xlp9xx_i2c_rdreg(priv->iobase, I2C_I2CADDR) );
+
+	while( wlen<I2C_FIFO_SIZE && wlen < len)
+	{
+		xlp9xx_i2c_wreg(priv->iobase, I2C_MASTER_TX, *data++ );
+		wlen++;
+	}
+	rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_CONTROL ) | ((len) << 16);
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, rdata );
+
+	//issue command
+	xlp9xx_i2c_wreg(priv->iobase, I2C_COMMAND, I2C_COMMAND_START | I2C_COMMAND_STOP | I2C_COMMAND_WRITE );
+	i2c_dbg("    I2C_COMMAND: 0x%x\n", xlp9xx_i2c_rdreg(priv->iobase, I2C_COMMAND ) );
+
+	//check errors: 
+	for(n=0; n<I2C_TIMEOUT; n++)
+	{
+		rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_COMMAND ) & I2C_COMMAND_START;
+		if( rdata == 0 )
+			break;
+		udelay(100);
+	}
+
+	rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_INTST);
+	i2c_dbg("    I2C_INTST: 0x%x\n", xlp9xx_i2c_rdreg(priv->iobase, I2C_INTST ) );
+	if( ( rdata & I2C_INTST_ALOST) != 0 )
+	{
+		i2c_dbg("I2C bus%d lost arbitration, INT_STATUS=0x%x\n", bus, rdata );
+		goto Error_Recover;
+	}
+
+	if( rdata & (I2C_INTST_ANACK | I2C_INTST_WNACK) )
+	{
+		i2c_dbg("I2C bus%d receive Nack, Int_Status=0x%x\n", bus, rdata );
+		goto Error_Recover;
+	}
+
+	if( I2C_TIMEOUT <= n )
+	{
+		i2c_dbg("I2C bus%d send address time out\n", bus );
+		goto Error_Recover;
+	}
+
+	//fill in the data left with time out
+	while( wlen < len)
+	{
+		//wait for FIFO space available
+		for(n=0; n<I2C_TIMEOUT; n++)
+		{
+			rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_FIFO_COUNT) && 0xFF;
+			if( rdata < I2C_FIFO_SIZE )
+				break;
+			udelay(100);
+		}
+
+		if( I2C_TIMEOUT <= n )
+		{
+			i2c_dbg(" Bus%d write, wait FIFO time out!\n", bus );
+			goto Error_Recover;
+		}
+		
+		xlp9xx_i2c_wreg(priv->iobase, I2C_MASTER_TX, *data++ );
+		wlen++;
+	}
+
+	//wait for finish
+	for(n = 0; n < I2C_TIMEOUT ; n++)
+	{
+		rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_STATUS );
+		if( (rdata & I2C_STATUS_BUSY ) == 0 ) break;
+		udelay (100);
+	}
+
+	if( n <  I2C_TIMEOUT ){
+		return 0; //success
+	}
+	else
+	{
+		i2c_dbg ("%s:%d bus is busy: %#x\n", __func__,
+				__LINE__, rdata);
+	}
+
+Error_Recover:
+
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, I2C_CONTROL_RESET | I2C_CONTROL_EN | I2C_CONTROL_MASTER );
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, I2C_CONTROL_EN | I2C_CONTROL_MASTER );
+	xlp9xx_i2c_wreg(priv->iobase, I2C_COMMAND, I2C_COMMAND_STOP );
+
+	return -EIO;
+}
+
+static int xlp9xx_i2c_rx(struct xlp9xx_i2c_private *priv, u16 len, u8 *data, u16 addr)
+{
+	u32 ret, off;
+	u32 rdata, n;
+	u32 bus __attribute__((__unused__)) = priv->adap.nr;
+	int rlen;
+
+	off = data[0];
+	i2c_dbg("oc_i2c_rx: bus=%d, addr=0x%x, off=0x%x, len=%d\n",
+		     bus, addr, off, len );
+
+	//wait for bus ideal
+	ret = xlp9xx_i2c_wait_bus( priv );
+	if( ret != 0)
+		return -EIO;
+
+	//reset FIFO, write offset to slave
+	xlp9xx_i2c_wreg(priv->iobase, I2C_INTST, 0x3FFFFFF );  //clean int status
+
+	//reset FIFO, change to read mode
+	xlp9xx_i2c_wreg(priv->iobase, I2C_MASTER_FCTL, I2C_MASTER_FCTL_RESET );
+	rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_CONTROL ) | I2C_CONTROL_FREAD;
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, rdata );
+
+	//setup address, set length to read
+	xlp9xx_i2c_wreg(priv->iobase, I2C_I2CADDR, (addr<<1) | I2C_I2CADDR_READ );
+	rdata = (xlp9xx_i2c_rdreg(priv->iobase, I2C_CONTROL ) & 0xFFFF) | (len << 16) ;
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, rdata );
+
+	//issue out command
+	//need either STOP for first command, if NACK here. (required NACK in spec)
+	rdata = I2C_COMMAND_START | I2C_COMMAND_READ | I2C_COMMAND_STOP ; //I2C_COMMAND_NACK;
+	xlp9xx_i2c_wreg(priv->iobase, I2C_COMMAND, rdata );
+
+	//check errors: 
+	for(n=0; n<I2C_TIMEOUT; n++)
+	{
+		rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_COMMAND ) & I2C_COMMAND_START;
+		if( rdata == 0 ) 
+			break;
+		udelay(100);
+	}
+
+	rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_INTST);
+	i2c_dbg("    I2C_INTST: 0x%x\n", xlp9xx_i2c_rdreg(priv->iobase, I2C_INTST ) );
+	if( ( rdata & I2C_INTST_ALOST) != 0 )
+	{
+		i2c_dbg("I2C bus%d lost arbitration, INT_STATUS=0x%x\n", bus, rdata );
+		goto Error_Recover;
+	}
+
+	if( rdata & (I2C_INTST_ANACK | I2C_INTST_WNACK) )
+	{
+		i2c_dbg("I2C bus%d receive Nack, Int_Status=0x%x\n", bus, rdata );
+		goto Error_Recover;
+	}
+
+	if( I2C_TIMEOUT <= n )
+	{
+		i2c_dbg("I2C bus%d send address time out\n", bus );
+		goto Error_Recover;
+	}
+
+	//read FIFO
+	for(rlen=0; rlen<len; rlen++, data++ )
+	{
+		for(n=0; n<I2C_TIMEOUT; n++ )
+		{
+			rdata = xlp9xx_i2c_rdreg(priv->iobase, I2C_FIFO_COUNT) & 0xFF;
+			if( 0<rdata )
+				break;
+			udelay(100);
+		}
+		if( I2C_TIMEOUT <= n )
+		{
+			i2c_dbg("I2C bus%d wait Receive FIFO timeout\n", bus );
+			goto Error_Recover;
+		}
+
+		*data = xlp9xx_i2c_rdreg(priv->iobase, I2C_MASTER_RX );
+	}
+
+	return 0;
+
+Error_Recover:
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, I2C_CONTROL_RESET | I2C_CONTROL_EN | I2C_CONTROL_MASTER );
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, I2C_CONTROL_EN | I2C_CONTROL_MASTER );
+	xlp9xx_i2c_wreg(priv->iobase, I2C_COMMAND, I2C_COMMAND_STOP );
+
+	return -EIO;
+}
+
+static int xlp9xx_i2c_xfer(struct i2c_adapter *adap,
+	struct i2c_msg *msgs, int num)
+{
+	struct i2c_msg *msg;
+	int i;
+	int ret = 0;
+	struct xlp9xx_i2c_private *priv = i2c_get_adapdata(adap);
+
+	for (i = 0; ret == 0 && i < num; i++) {
+		msg = &msgs[i];
+		if (msg->flags & I2C_M_RD)
+			ret = xlp9xx_i2c_rx(priv, msg->len, &msg->buf[0],
+					msg->addr);
+		else
+			ret = xlp9xx_i2c_tx(priv, msg->len, &msg->buf[0],
+					msg->addr);
+	}
+
+	return (ret != 0) ? ret : num;
+}
+
+static u32 xlp9xx_func(struct i2c_adapter *adap)
+{
+	/* Emulate SMBUS over I2C */
+	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm xlp9xx_i2c_algo = {
+	.master_xfer	= xlp9xx_i2c_xfer,
+	.functionality	= xlp9xx_func,
+};
+
+static int xlp9xx_i2c_init (struct xlp9xx_i2c_private *priv)
+{
+	uint32_t div;
+
+	div = priv->clock_mhz;
+	div = (u64)div * 1000* 1000 / ( 5 * 400*1000) -1; //400K SCL
+	i2c_dbg(" ref clock: %d MHz, div=%d\n", 133, div );
+
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, I2C_CONTROL_RESET | I2C_CONTROL_EN | I2C_CONTROL_MASTER );
+	xlp9xx_i2c_wreg(priv->iobase, I2C_DIVISOR, div );
+	xlp9xx_i2c_wreg(priv->iobase, I2C_INTEN, 0 );  
+	i2c_dbg ("Initialized I2C Controller: %d.\n", priv->adap.nr );
+	xlp9xx_i2c_wreg(priv->iobase, I2C_CONTROL, I2C_CONTROL_EN | I2C_CONTROL_MASTER );
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int xlp9xx_i2c_of_probe(struct platform_device *pdev,
+				struct xlp9xx_i2c_private *priv)
+{
+	struct device_node *np = pdev->dev.of_node;
+	u32 val;
+
+	if (of_property_read_u32(np, "clock-frequency", &val)) {
+		dev_err(&pdev->dev,
+			"Missing required parameter 'clock-frequency'\n");
+		return -ENODEV;
+	}
+	priv->clock_mhz = val / (1000 * 1000);
+
+	return 0;
+}
+#else
+#define xlp9xx_i2c_of_probe(pdev,i2c) -ENODEV
+#endif
+
+
+static int xlp9xx_i2c_probe(struct platform_device *pdev)
+{
+	struct xlp9xx_i2c_private  *priv;
+	struct resource *res;
+	int ret = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->pdev = pdev;
+
+	if (!devm_request_mem_region(&pdev->dev, res->start,
+								 resource_size(res), pdev->name)) {
+		dev_err(&pdev->dev, "Memory region busy\n");
+		return -EBUSY;
+	}
+
+	priv->iobase = devm_ioremap_nocache(&pdev->dev, res->start,
+									   resource_size(res));
+	if (!priv->iobase) {
+		dev_err(&pdev->dev, "Unable to map registers\n");
+		return -EIO;
+	}
+
+	ret = xlp9xx_i2c_of_probe(pdev, priv);
+	if (ret)
+		return ret;
+
+	priv->adap.dev.parent = &pdev->dev;
+	priv->adap.owner	= THIS_MODULE;
+	priv->adap.algo_data	= priv;
+	priv->adap.algo		= &xlp9xx_i2c_algo;
+	priv->adap.class	= I2C_CLASS_HWMON;
+	priv->adap.dev.of_node = pdev->dev.of_node;
+
+	snprintf(priv->adap.name, sizeof(priv->adap.name), "xlp9xx-i2c");
+
+	i2c_set_adapdata(&priv->adap, priv);
+	ret = i2c_add_adapter(&priv->adap);
+	if (ret < 0) {
+		dev_err(&priv->adap.dev, "Failed to add i2c bus: %d.\n", pdev->id);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, priv);
+	dev_info(&priv->adap.dev, "Added I2C Bus: %d.\n", priv->adap.nr);
+
+	xlp9xx_i2c_init(priv);
+
+	of_i2c_register_devices(&priv->adap);
+
+	return 0;
+}
+
+static int xlp9xx_i2c_remove(struct platform_device *pdev)
+{
+	struct xlp9xx_i2c_private *priv;
+
+	priv = platform_get_drvdata(pdev);
+	i2c_del_adapter(&priv->adap);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct of_device_id xlp9xx_i2c_match[] = {
+	{ .compatible = "netlogic,xlp9xx-i2c", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, xlp9xx_i2c_match);
+
+
+static struct platform_driver xlp9xx_i2c_driver = {
+	.probe  = xlp9xx_i2c_probe,
+	.remove = xlp9xx_i2c_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "xlp9xx-i2c",
+		.of_match_table = xlp9xx_i2c_match,
+	},
+};
+
+module_platform_driver(xlp9xx_i2c_driver);
+
+MODULE_DESCRIPTION("xlp9xx SoC I2C Controller driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:xlp9xx-i2c");
-- 
1.7.9.5

