From 191d1c4da960eee99e5818f2a751154f3ff94f90 Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Sun, 16 Feb 2014 17:09:51 +0530
Subject: [PATCH 082/160] Revert "hw pgwalk"

This reverts commit ed2a5ee9b79287147f52c130502b17485faa0ded.

[Merging a better implementation in the next commit]
[add back defines cpucontrol.h needed for compiler]

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Jack Tan <jiankemeng@gmail.com>
---
 arch/mips/include/asm/mmu_context.h                |    8 --
 .../mips/include/asm/netlogic/xlp-hal/cpucontrol.h |   39 +-----
 arch/mips/include/asm/netlogic/xlp-hal/xlp.h       |    1 -
 arch/mips/netlogic/common/smp.c                    |    5 -
 arch/mips/netlogic/xlp/setup.c                     |  126 --------------------
 5 files changed, 1 insertion(+), 178 deletions(-)

diff --git a/arch/mips/include/asm/mmu_context.h b/arch/mips/include/asm/mmu_context.h
index 21cfb6e..516e6e9 100644
--- a/arch/mips/include/asm/mmu_context.h
+++ b/arch/mips/include/asm/mmu_context.h
@@ -24,12 +24,6 @@
 #endif /* SMTC */
 #include <asm-generic/mm_hooks.h>
 
-#ifdef CONIFG_CPU_XLP
-extern void setup_hwp_user_pgd(unsigned long pgd);
-#else
-#define setup_hwp_user_pgd(pdg)
-#endif
-
 #ifdef CONFIG_MIPS_PGD_C0_CONTEXT
 
 #define TLBMISS_HANDLER_SETUP_PGD(pgd)					\
@@ -202,7 +196,6 @@ static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	write_c0_entryhi(cpu_asid(cpu, next));
 #endif /* CONFIG_MIPS_MT_SMTC */
 	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
-	setup_hwp_user_pgd((unsigned long)next->pgd);
 
 	/*
 	 * Mark current->active_mm as not "active" anymore.
@@ -263,7 +256,6 @@ activate_mm(struct mm_struct *prev, struct mm_struct *next)
 	write_c0_entryhi(cpu_asid(cpu, next));
 #endif /* CONFIG_MIPS_MT_SMTC */
 	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
-	setup_hwp_user_pgd((unsigned long)next->pgd);
 
 	/* mark mmu ownership change */
 	cpumask_clear_cpu(cpu, mm_cpumask(prev));
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h b/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h
index 77a6d4d..12c0e92 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h
@@ -52,7 +52,7 @@
 #define ICU_CERR_LOG0		0x110
 #define ICU_CERR_LOG1		0x111
 #define ICU_CERR_LOG2		0x112
-
+ 
 #define LSU_DEFEATURE		0x304
 #define LSU_DEBUG_ADDR		0x305
 #define LSU_DEBUG_DATA0		0x306
@@ -102,41 +102,4 @@
 #define SCU_CERR_LOG1		0x811
 #define SCU_CERR_LOG2		0x812
 
-#ifndef __ASSEMBLY__
-
-/* Hardware Pagewalker related configuration parameters */
-#define USER_SEG 0
-#ifdef CONFIG_64BIT
-#define NR_ADDR_SEGMENTS 8  /* MUST be a power of 2 */
-#define MODULE_SEG 7
-#define VMALLOC_SEG 6
-#else /* CONFIG_32BIT */
-#define NR_ADDR_SEGMENTS 2 /* MUST be a power of 2 */
-#define VMALLOC_SEG 1
-#endif /* CONFIG_64BIT */
-
-enum {
-  //offset, width pair
-  PWFIELD_BD_O  = 32, PWFIELD_BD_W  = 6,
-  PWFIELD_GD_O  = 24, PWFIELD_GD_W  = 6,
-  PWFIELD_UD_O  = 18, PWFIELD_UD_W  = 6,
-  PWFIELD_MD_O  = 12, PWFIELD_MD_W  = 6,
-  PWFIELD_PT_O  =  6, PWFIELD_PT_W  = 6,
-  PWFIELD_PTE_O =  0, PWFIELD_PTE_W = 6,
-
-  PWSIZE_BD_O  = 32, PWSIZE_BD_W  = 6,
-  PWSIZE_PS_O  = 30, PWSIZE_PS_W  = 1,
-  PWSIZE_GD_O  = 24, PWSIZE_GD_W  = 6,
-  PWSIZE_UD_O  = 18, PWSIZE_UD_W  = 6,
-  PWSIZE_MD_O  = 12, PWSIZE_MD_W  = 6,
-  PWSIZE_PT_O  =  6, PWSIZE_PT_W  = 6,
-  PWSIZE_PTE_O =  0, PWSIZE_PTE_W = 6,
-
-  PWCTL_PW_EN_O = 31, PWCTL_PW_EN_W = 1,
-  PWCTL_PW_EN_HUGETLB = 6,
-  PWCTL_PW_HUGEVLD_PSN = 0,
-};
-
-#endif /* __ASSEMBLY__ */
-
 #endif /* __NLM_CPUCONTROL_H__ */
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
index 2447d6f..d17d71f 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
@@ -97,7 +97,6 @@ void xlp_wakeup_secondary_cpus(void);
 void xlp_mmu_init(void);
 void nlm_hal_init(void);
 int xlp_get_dram_map(int n, uint64_t *dram_map);
-void pgwalker_init(void);
 #ifdef CONFIG_NUMA
 void xlp_numa_init(void);
 #endif
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index e8694e2..72fda20 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -142,7 +142,6 @@ void nlm_early_init_secondary(int cpu)
 	change_c0_config(CONF_CM_CMASK, 0x3);
 #ifdef CONFIG_CPU_XLP
 	xlp_mmu_init();
-	pgwalker_init();
 #endif
 	write_c0_ebase(nlm_current_node()->ebase);
 }
@@ -164,10 +163,6 @@ void nlm_prepare_cpus(unsigned int max_cpus)
 {
 	/* declare we are SMT capable */
 	smp_num_siblings = nlm_threads_per_core;
-#ifdef CONFIG_CPU_XLP
-	/* hardware page walker configuration for boot cpu */
-	pgwalker_init();
-#endif
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index d8af64a..14d022f 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -33,23 +33,17 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/export.h>
 #include <linux/of_fdt.h>
 #include <linux/module.h>
 
 #include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/bootinfo.h>
-#include <asm/pgtable.h>
-#include <asm/asm-offsets.h>
 
 #include <asm/netlogic/haldefs.h>
 #include <asm/netlogic/common.h>
-#include <asm/netlogic/kvm_para.h>
-#include <asm/netlogic/mips-extns.h>
 #include <asm/netlogic/nlm_kexec.h>
 
-#include <asm/netlogic/xlp-hal/cpucontrol.h>
 #include <asm/netlogic/xlp-hal/iomap.h>
 #include <asm/netlogic/xlp-hal/xlp.h>
 #include <asm/netlogic/xlp-hal/sys.h>
@@ -63,15 +57,6 @@ int is_nlm_guest_os = 0;
 EXPORT_SYMBOL(is_nlm_guest_os);
 EXPORT_SYMBOL(nlm_io_base);
 
-DEFINE_PER_CPU(unsigned long [NR_ADDR_SEGMENTS], pgd_bases);
-static int enable_pgwalker = 0;
-static int __init enable_pgwalker_cmdline(char *str)
-{
-	enable_pgwalker = 1;
-	return 1;
-}
-__setup("enable_pgwalker", enable_pgwalker_cmdline);
-
 extern void (*cpu_wait)(void);
 
 static void nlm_linux_exit(void)
@@ -168,122 +153,11 @@ void __init prom_free_prom_memory(void)
 	/* Nothing yet */
 }
 
-void setup_hwp_user_pgd(unsigned long pgd)
-{
-	get_cpu_var(pgd_bases)[USER_SEG] = (unsigned long) pgd;
-	put_cpu_var(pgd_bases);
-}
-
-void pgwalker_init(void)
-{
-	int i = 0;
-	uint64_t pwbase_val = 0, pwfield_val = 0, pwsize_val = 0, bd_shift = 0;
-	uint32_t pwctl_val = 0;
-
-	if (enable_pgwalker == 0) {
-		/* If the kernel is root, also disable nested page table walk. */
-		if (cpu_is_xlp9xx() && is_nlm_guest_os == 0)
-			nlm_mtcr(MMU_SETUP, nlm_mfcr(MMU_SETUP) | ((0x1 << 5)));
-
-		return;
-	}
-
-	if (!cpu_is_xlpii()) {
-		printk("Hardware page walker is not supported for XLP8XX/XLP3XX\n");
-		return;
-	}
-#ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
-	else if (!cpu_is_xlp9xx()) {
-		printk("Hardware page walker is not supported for XLP2XX HugeTLB Page\n");
-		return;
-	}
-#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
-	else {
-		/* no mips default style hugepage is enabled,
-		 * hardware page walker does not work for it.
-		 */
-		printk("Hardware page walker is not supported for no mips default huge page\n");
-		return;
-	}
-#endif
-#endif
-
-	/* Initialize pgd bases to default values */
-	for (i = 0; i < NR_ADDR_SEGMENTS; i++) {
-		get_cpu_var(pgd_bases)[i] = (unsigned long)swapper_pg_dir;
-		put_cpu_var(pgd_bases);
-	}
-
-	pwbase_val = (uint64_t)(long)&(__get_cpu_var(pgd_bases)[0]);
-
-	/* enable page walker */
-	pwctl_val |= ((uint32_t)1) << PWCTL_PW_EN_O;
-
-#ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
-	pwctl_val |= ((uint32_t)1) << PWCTL_PW_EN_HUGETLB;
-	pwctl_val |= _PAGE_HUGE_SHIFT << PWCTL_PW_HUGEVLD_PSN;
-#endif
-
-	/* page table selector */
-	bd_shift = _PGDIR_SHIFT + ffs(_PTRS_PER_PGD) - 1;
-	pwfield_val |= bd_shift << PWFIELD_BD_O;
-	pwsize_val |= ((uint64_t)(ffs(NR_ADDR_SEGMENTS) - 1)) << PWSIZE_BD_O;
-
-	/* global directory */
-	pwfield_val |= ((uint64_t)(_PGDIR_SHIFT)) << PWFIELD_GD_O;
-	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PGD) - 1)) << PWSIZE_GD_O;
-
-	/* upper directory (was initialized to 0) */
-
-#ifndef __PAGETABLE_PMD_FOLDED
-	/* middle directory */
-	pwfield_val |= ((uint64_t)_PMD_SHIFT) << PWFIELD_MD_O;
-	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PMD) - 1)) << PWSIZE_MD_O;
-#endif
-	/* page table index */
-	pwfield_val |= ((uint64_t)PAGE_SHIFT) << PWFIELD_PT_O;
-	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PTE) - 1)) << PWSIZE_PT_O;
-
-#ifdef CONFIG_64BIT
-	pwsize_val |= ((uint64_t)1) << PWSIZE_PS_O;
-#else
-	/* PWSIZE_PS field was initialized to 0 */
-#endif
-
-	/* logical right rotate of PTE loaded from memory */
-	pwfield_val |= ((uint64_t)_PAGE_GLOBAL_SHIFT) << PWFIELD_PTE_O;
-	/* PWSIZE_PTE field was initialized to 0 (page table entry spacing) */
-
-	/* write registers*/
-	__write_64bit_c0_register($5, 5, pwbase_val);
-	__write_64bit_c0_register($5, 6, pwfield_val);
-	__write_64bit_c0_register($5, 7, pwsize_val);
-	__write_32bit_c0_register($6, 6, pwctl_val);
-
-	get_cpu_var(pgd_bases)[VMALLOC_SEG] = (unsigned long)swapper_pg_dir;
-#ifdef MODULE_START
-	__get_cpu_var(pgd_bases)[MODULE_SEG] = (unsigned long)swapper_pg_dir;
-#endif
-	put_cpu_var(pgd_bases);
-
-	printk("Initialized Page Walker on cpu@%d\n", hard_smp_processor_id());
-}
-
 void xlp_mmu_init(void)
 {
 	u32 conf4;
 
 	if (cpu_is_xlpii()) {
-		/* the extended TLB is always enabled, the large fixed TLB is enabled by default. */
-#if 0
-		/* disable large fixed TLB */
-		nlm_mtcr(MMU_SETUP, nlm_mfcr(MMU_SETUP) & (~(0x1 << 3)));
-#endif
-		/* turn off hardware page walker cache, workaround for xlp9xx */
-		if (cpu_is_xlp9xx()) {
-			nlm_mtcr(MMU_SETUP, nlm_mfcr(MMU_SETUP) | ((0x1 << 14)));
-		}
-
 		/* XLPII series has extended pagesize in config 4 */
 		conf4 = read_c0_config4() & ~0x1f00u;
 		write_c0_config4(conf4 | ((PAGE_SHIFT - 10) / 2 << 8));
-- 
1.7.9.5

