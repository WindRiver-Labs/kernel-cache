From 9e3152789d0c2d0d4d58f12c25abd35d223e7ab3 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 17:33:15 +0800
Subject: [PATCH 28/58] bcm-xlp2: add the syslib

Get from SDK_DIR/libraries/syslib

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/netlogic/lib/syslib/Makefile             |    9 +
 .../netlogic/lib/syslib/include/brcm_xlp_cpu.h     |   61 +
 arch/mips/netlogic/lib/syslib/include/byteorder.h  |   53 +
 .../lib/syslib/include/nlm_10ge_phy_nlp1042.h      |  772 ++++++++++
 arch/mips/netlogic/lib/syslib/include/nlm_eeprom.h |   81 ++
 .../netlogic/lib/syslib/include/nlm_evp_cpld.h     |   79 +
 arch/mips/netlogic/lib/syslib/include/nlm_hal.h    |  348 +++++
 .../mips/netlogic/lib/syslib/include/nlm_hal_cde.h |  141 ++
 .../netlogic/lib/syslib/include/nlm_hal_crypto.h   |  262 ++++
 .../mips/netlogic/lib/syslib/include/nlm_hal_kbp.h | 1037 +++++++++++++
 .../netlogic/lib/syslib/include/nlm_hal_macros.h   | 1334 +++++++++++++++++
 .../mips/netlogic/lib/syslib/include/nlm_hal_pic.h |  465 ++++++
 .../mips/netlogic/lib/syslib/include/nlm_hal_rsa.h |  962 ++++++++++++
 .../mips/netlogic/lib/syslib/include/nlm_hal_sys.h |  182 +++
 .../netlogic/lib/syslib/include/nlm_hal_xlp_dev.h  | 1524 ++++++++++++++++++++
 .../netlogic/lib/syslib/include/nlm_srio_xlp.h     |  660 +++++++++
 .../mips/netlogic/lib/syslib/include/nlm_uaccess.h |  214 +++
 arch/mips/netlogic/lib/syslib/include/nlm_xlp.h    |   39 +
 arch/mips/netlogic/lib/syslib/include/types.h      |   74 +
 arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h |  374 +++++
 arch/mips/netlogic/lib/syslib/src/brcm_xlp_cpu.c   |   92 ++
 arch/mips/netlogic/lib/syslib/src/nlm_eeprom.c     |  123 ++
 arch/mips/netlogic/lib/syslib/src/nlm_evp_cpld.c   |  248 ++++
 arch/mips/netlogic/lib/syslib/src/nlm_hal.c        | 1312 +++++++++++++++++
 .../netlogic/lib/syslib/src/nlm_hal_cpu_info.c     |  689 +++++++++
 arch/mips/netlogic/lib/syslib/src/nlm_hal_sys.c    | 1036 +++++++++++++
 26 files changed, 12171 insertions(+)

diff --git a/arch/mips/netlogic/lib/syslib/Makefile b/arch/mips/netlogic/lib/syslib/Makefile
new file mode 100644
index 0000000..1573be0
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/Makefile
@@ -0,0 +1,9 @@
+EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL -DNLM_CORTINA_SUPPORT -Wno-maybe-uninitialized
+EXTRA_CFLAGS += -Iarch/mips/netlogic/boot/
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/syslib/include
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/libfdt
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/libfdt/contrib
+
+obj-y += syslib.o
+syslib-objs := src/nlm_eeprom.o src/nlm_evp_cpld.o src/nlm_hal.o src/nlm_hal_cpu_info.o \
+	src/nlm_hal_sys.o
diff --git a/arch/mips/netlogic/lib/syslib/include/brcm_xlp_cpu.h b/arch/mips/netlogic/lib/syslib/include/brcm_xlp_cpu.h
new file mode 100644
index 0000000..674d1f2
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/brcm_xlp_cpu.h
@@ -0,0 +1,61 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _BRCM_XLP_CPU_H
+#define _BRCM_XLP_CPU_H
+
+#define DEFAULT_NODE_NUM	1
+#define NLM_MAX_NODES		4
+#define MAX_VC_PERTHREAD	4
+
+#ifndef NLM_NCPUS_PER_NODE 
+#define NLM_NCPUS_PER_NODE	32
+#endif
+
+#define XLP9XX_MAX_NODES		8
+#define XLP9XX_MAX_CPU_PER_NODE   	80
+
+#define XLP3XX_MAX_CPU_PER_NODE 	16
+#define XLP2XX_MAX_CPU_PER_NODE 	8
+
+#ifndef __ASSEMBLY__
+
+inline int brcm_get_max_cpu_num(void);
+inline int brcm_get_max_node_num(void);
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* #ifndef _BRCM_XLP_CPU_H */
diff --git a/arch/mips/netlogic/lib/syslib/include/byteorder.h b/arch/mips/netlogic/lib/syslib/include/byteorder.h
new file mode 100644
index 0000000..beb8eb3
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/byteorder.h
@@ -0,0 +1,53 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#ifndef _BYTEORDER_H
+#define _BYTEORDER_H
+
+#include <types.h>
+
+#ifdef __GNUC__
+
+#if !defined(__STRICT_ANSI__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#endif /* __GNUC__ */
+
+#if defined (__MIPSEB__)
+#  include <byteorder/big_endian.h>
+#elif defined (__MIPSEL__)
+#  include <byteorder/little_endian.h>
+#else
+#  error "MIPS, but neither __MIPSEB__, nor __MIPSEL__???"
+#endif
+
+#endif /* _BYTEORDER_H */
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_10ge_phy_nlp1042.h b/arch/mips/netlogic/lib/syslib/include/nlm_10ge_phy_nlp1042.h
new file mode 100644
index 0000000..6d92fa8
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_10ge_phy_nlp1042.h
@@ -0,0 +1,772 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+/* */
+/* v1p7 mwj 2011-05-12 */
+/*  add transpose (1.c20c.9) when RX_LOS asserted for LED link status */
+/* v1p8 pc  2011-05-24 update using margaret ocal_tx_losXposee_tgt_v1p8.uc */
+/*  add LC PLL lookup table to reliably run a wider temperature range */
+/* v1p9 mwj 2011-05-31 */
+/*  add lrcv/lrxmit reset and xaui squelch during RXLOS to ensure no LED */
+/*     when RXLOS = 1 and no incoming signal */
+/*  changed wait time after SRAM load to 300ms to ensure contvideal values */
+/*     are udpated */
+/* v1p9B mwj 2011-06-30 */
+/*  store temp to 1.eff0 */
+/*  increased wait time to 400ms in case customer MDIO is faster and */
+/*     reaches RCON faster */
+/* v1p10 mwj 2011-07-02 */
+/*  store temp to 1.ef2c to stay consistent with other firmware */
+/*  temp sense / contvideal LUT increased to 10 steps from 3 */
+/* v1p10B mwj 2011-07-05 */
+/*  optimized LUT values */
+
+/* MPS - Pete Moore, convert to .c functions for XLP SDK HAL */
+
+
+/* calico_C2 settings... */
+/* -------------------------------------------------- */
+/* NOTE, no reset (h/  nlm_nlp_phy_mod(pa,or x.0000.15) here */
+
+/* PART 1, nlp_init ---------------------------------- */
+uint16_t nlm_xaui_phy_read(int phyaddr, int devaddr, int regidx);
+void nlm_xaui_phy_write(int phyaddr, int devaddr, int regidx, uint16_t val);
+
+static inline void nlm_nlp_phy_mod(int pa, int da, uint16_t ra, int bh, int bl,
+	uint16_t val)
+{
+  uint16_t mask = 0xffff;
+  uint16_t tval;
+  int i;
+
+  for (i=bl; i<(bh+1); i++) {
+    mask &= ~(1 << i);
+  }
+
+  tval = nlm_xaui_phy_read(pa, da, ra);
+  /*nlm_print("Phymod read %x:%x:%x: 0x%02x\n", pa, da, ra, tval); */
+  tval &= mask;
+  tval |= (val << bl);
+  nlm_xaui_phy_write(pa, da, ra, tval);
+  /*nlm_print("Phymod Write %x:%x:%x: 0x%02x\n", pa, da, ra, tval); */
+}
+
+static inline void nlm_nlp1042_init(int pa)
+{
+  nlm_nlp_phy_mod(pa,1,0xca42,10,8, 0x1); 	/*  cmu_e2o_tx,vcocaplrsel */
+  nlm_nlp_phy_mod(pa,1,0xca44,15,12, 0x8); 	/*  cmu_e2o_tx,reg_vcotailsel */
+  nlm_nlp_phy_mod(pa,1,0xca44,9,5, 0x10); 	/*  cmu_e2o_tx,reg_contvideal */
+  nlm_nlp_phy_mod(pa,1,0xca46,8,8, 0x1); 	/*  cmu_e2o_tx,reg_cp_highv_en */
+  nlm_nlp_phy_mod(pa,1,0xca46,11,9 , 0x4); 	/*  cmu_e2o_tx,reg_cp_highvctl */
+  nlm_nlp_phy_mod(pa,1,0xcb0e,13,12, 0x1); 	/*  bt_237_236_ir25txcmu1 */
+  nlm_nlp_phy_mod(pa,1,0xca4c,5,0  , 0x2); 	/*  cmu_e2o_tx,antesten */
+  nlm_nlp_phy_mod(pa,1,0xca12,10,8 , 0x1); 	/*  cmu_o2e_lim,vcocaplrsel */
+  nlm_nlp_phy_mod(pa,1,0xca14,15,12, 0x8); 	/*  cmu_o2e_lim,reg_vcotailsel */
+  nlm_nlp_phy_mod(pa,1,0xca14,9,5  , 0x10); 	/*  cmu_o2e_lim,reg_contvideal */
+  nlm_nlp_phy_mod(pa,1,0xca16,8,8, 0x1); 	/*  cmu_o2e_lim,reg_cp_highv_en */
+  nlm_nlp_phy_mod(pa,1,0xca16,11,9 , 0x4); 	/*  cmu_o2e_lim,reg_cp_highvctl */
+  nlm_nlp_phy_mod(pa,1,0xcb06,13,12, 0x1); 	/*  bt_109_108_ir25rxfcmu1 */
+  nlm_nlp_phy_mod(pa,1,0xca1c,5,0  , 0x2); 	/*  cmu_o2e_lim,antesten */
+  nlm_nlp_phy_mod(pa,1,0xca42,13,11, 0x1); 	/*  cmu_e2o_tx,reg_bufcaplrsel */
+  nlm_nlp_phy_mod(pa,1,0xca43,14,12, 0x2); 	/*  cmu_e2o_tx,bufcmc */
+  nlm_nlp_phy_mod(pa,1,0xc246,9,7  , 0x3); 	/*  csbiasmuxsel */
+  nlm_nlp_phy_mod(pa,1,0xc242,2,0  , 0x0); 	/*  lkbiassel */
+  nlm_nlp_phy_mod(pa,1,0xc240,7,4  , 0x0); 	/*  ldbiassel */
+  nlm_nlp_phy_mod(pa,1,0xc240,13,11, 0x7); 	/*  cmbiassel */
+  nlm_nlp_phy_mod(pa,1,0xc242,15,13, 0x0); 	/*  cspredrvsel */
+  nlm_nlp_phy_mod(pa,1,0xc246,0,0, 0x0); 	/*  sfpmodeen */
+  nlm_nlp_phy_mod(pa,1,0xc246,1,1, 0x1); 	/*  krmodeen */
+  nlm_nlp_phy_mod(pa,1,0xc243,4,0, 0x1); 	/*  drvpre */
+  nlm_nlp_phy_mod(pa,1,0xc243,10,5, 0x3f); 	/*  drvmain */
+  nlm_nlp_phy_mod(pa,1,0xc243,15,11, 0x2); 	/*  drvpost */
+  nlm_nlp_phy_mod(pa,1,0xcb0b,1,0, 0x1); 	/*  bt_177_176_ic25drvbias0 */
+  nlm_nlp_phy_mod(pa,1,0xcb0b,5,4, 0x1); 	/*  bt_181_180_ir25drvbias0 */
+  nlm_nlp_phy_mod(pa,1,0xcb0b,9,8, 0x3); 	/*  bt_185_184_ir25drvbias2 */
+  nlm_nlp_phy_mod(pa,1,0xcb0b,11,10, 0x3); 	/*  bt_187_186_ir25drvbias3 */
+  nlm_nlp_phy_mod(pa,1,0xcb0b,13,12, 0x3); 	/*  bt_189_188_ir25drvbias4 */
+  nlm_nlp_phy_mod(pa,1,0xcb0b,15,14, 0x3); 	/*  bt_191_190_ir25drvbias5 */
+  nlm_nlp_phy_mod(pa,1,0xcc00,7,0, 0x0); 	/*  lsatxfi_o2e_rxrxfcdrqoffs */
+  nlm_nlp_phy_mod(pa,1,0xcc02,7,7, 0x1); 	/*  lsatxfi_o2e_rxrxfcdrwrpmltgl */
+  nlm_nlp_phy_mod(pa,1,0xcc02,7,7, 0x0); 	/*  lsatxfi_o2e_rxrxfcdrwrpmltgl */
+  nlm_nlp_phy_mod(pa,1,0xcc07,4,0, 0x17); 	/*  lsatxfi_o2e_rxrxfeqklp */
+  nlm_nlp_phy_mod(pa,1,0xcc08,5,0, 0x1f); 	/*  lsatxfi_o2e_rxrxfdfetap1 */
+  nlm_nlp_phy_mod(pa,1,0xcc08,11,6, 0x1f); 	/*  lsatxfi_o2e_rxrxfdfetap2 */
+  nlm_nlp_phy_mod(pa,1,0xcc09,5,0, 0x1f); 	/*  lsatxfi_o2e_rxrxfdfetap3 */
+  nlm_nlp_phy_mod(pa,1,0xcc09,11,6, 0x1f); 	/*  lsatxfi_o2e_rxrxfdfetap4 */
+  nlm_nlp_phy_mod(pa,1,0xcc07,8,5, 0x0); 	/*  lsatxfi_o2e_rxrxfeqmres */
+  nlm_nlp_phy_mod(pa,1,0xcc0e,0,0, 0x1); 	/*  lsatxfi_o2e_rxrxfdfetapstrobe */
+  nlm_nlp_phy_mod(pa,1,0xcc0e,1,1, 0x1); 	/*  lsatxfi_o2e_rxrxfdfeosdacstrobe */
+  nlm_nlp_phy_mod(pa,1,0xcc0e,2,2, 0x1); 	/*  lsatxfi_o2e_rxrxfeqosdacstrobe */
+  nlm_nlp_phy_mod(pa,1,0xcc0e,0,0, 0x0); 	/*  lsatxfi_o2e_rxrxfdfetapstrobe */
+  nlm_nlp_phy_mod(pa,1,0xcc0e,1,1, 0x0); 	/*  lsatxfi_o2e_rxrxfdfeosdacstrobe */
+  nlm_nlp_phy_mod(pa,1,0xcc0e,2,2, 0x0); 	/*  lsatxfi_o2e_rxrxfeqosdacstrobe */
+  nlm_nlp_phy_mod(pa,1,0xcc02,5,5, 0x1); 	/*  lsatxfi_o2e_rxrxfclk16inv */
+  nlm_nlp_phy_mod(pa,1,0xcc04,0,0, 0x1); 	/*  lsatxfi_o2e_rxrxfvgaovrden */
+  nlm_nlp_phy_mod(pa,1,0xcc04,8,1, 0x5a); 	/*  lsatxfi_o2e_rxrxfvgaovrd */
+  nlm_nlp_phy_mod(pa,1,0xcc11,5,3, 0x0); 	/*  lsatxfi_o2e_rxrxfdfetap1adj */
+  nlm_nlp_phy_mod(pa,1,0xcc11,8,6, 0x0); 	/*  lsatxfi_o2e_rxrxfdfetap2adj */
+  nlm_nlp_phy_mod(pa,1,0xcc11,11,9, 0x0); 	/*  lsatxfi_o2e_rxrxfdfetap3adj */
+  nlm_nlp_phy_mod(pa,1,0xcc11,14,12, 0x0); 	/*  lsatxfi_o2e_rxrxfdfetap4adj */
+  nlm_nlp_phy_mod(pa,1,0xcc11,2,0, 0x0); 	/*  lsatxfi_o2e_rxrxfdfemainadj */
+  nlm_nlp_phy_mod(pa,1,0xcb02,7,4, 0xf); 	/*  bt_039_036_ir50rxfeq1 */
+  nlm_nlp_phy_mod(pa,1,0xcb02,3,0, 0xf); 	/*  bt_035_032_ir50rxfeq0 */
+  nlm_nlp_phy_mod(pa,1,0xcb21,15,12, 0x1); 	/*  bt_543_540_ir50xtpll3 */
+  nlm_nlp_phy_mod(pa,1,0xca01,0,0, 0x1); 	/*  cmu_o2e_tx,cpdac_ovrd */
+  nlm_nlp_phy_mod(pa,1,0xca01,7,1, 0x8); 	/*  cmu_o2e_tx,ov_cpdac */
+  nlm_nlp_phy_mod(pa,1,0xcb1b,15,12, 0x1); 	/*  bt_447_444_ir50xrpll3 */
+  nlm_nlp_phy_mod(pa,1,0xca51,0,0, 0x1); 	/*  cmu_e2o_rx,cpdac_ovrd */
+  nlm_nlp_phy_mod(pa,1,0xca51,7,1, 0x8); 	/*  cmu_e2o_rx,ov_cpdac */
+  nlm_nlp_phy_mod(pa,1,0xc2c3,3,0, 0xf); 	/*  pwdpostb */
+  nlm_nlp_phy_mod(pa,1,0xc2ca,15,11, 0x8); 	/*  drvpost0 */
+  nlm_nlp_phy_mod(pa,1,0xc2d0,15,11, 0x8); 	/*  drvpost1 */
+  nlm_nlp_phy_mod(pa,1,0xc2d6,15,11, 0x8); 	/*  drvpost2 */
+  nlm_nlp_phy_mod(pa,1,0xc2dc,15,11, 0x8); 	/*  drvpost3 */
+  nlm_nlp_phy_mod(pa,1,0xc2f1,5,1, 0xa); 	/*  xreqklp0 */
+  nlm_nlp_phy_mod(pa,1,0xc2f1,8,6, 0x0); 	/*  xreqmlpf0 */
+  nlm_nlp_phy_mod(pa,1,0xc2f5,5,1, 0xa); 	/*  xreqklp1 */
+  nlm_nlp_phy_mod(pa,1,0xc2f5,8,6, 0x0); 	/*  xreqmlpf1 */
+  nlm_nlp_phy_mod(pa,1,0xc2f9,5,1, 0xa); 	/*  xreqklp2 */
+  nlm_nlp_phy_mod(pa,1,0xc2f9,8,6, 0x0); 	/*  xreqmlpf2 */
+  nlm_nlp_phy_mod(pa,1,0xc2fd,5,1, 0xa); 	/*  xreqklp3 */
+  nlm_nlp_phy_mod(pa,1,0xc2fd,8,6, 0x0); 	/*  xreqmlpf3 */
+  nlm_nlp_phy_mod(pa,1,0xc2e8,8,0, 0x100); 	/*  xrcdrqoffs0 */
+  nlm_nlp_phy_mod(pa,1,0xc2e9,8,0, 0x100); 	/*  xrcdrqoffs1 */
+  nlm_nlp_phy_mod(pa,1,0xc2ea,8,0, 0x100); 	/*  xrcdrqoffs2 */
+  nlm_nlp_phy_mod(pa,1,0xc2eb,8,0, 0x100); 	/*  xrcdrqoffs3 */
+  nlm_nlp_phy_mod(pa,1,0xc2e6,11,11, 0x1); 	/*  xrcdrwrpmltgl */
+  nlm_nlp_phy_mod(pa,1,0xc2e6,11,11, 0x0); 	/*  xrcdrwrpmltgl */
+  nlm_nlp_phy_mod(pa,1,0xc010,14,14, 0x1); 	/*  ber_los_mask */
+  nlm_nlp_phy_mod(pa,1,0xc017,13,13, 0x0);   /*  rx_pmainpcsfault_mask */
+  nlm_nlp_phy_mod(pa,1,0xc010,13,13, 0x1);   /*  los_opt_intlos_mask */
+  nlm_nlp_phy_mod(pa,1,0xcd40,3,0, 0x1);   /*  pdtrgmsk_10gbrx */
+  nlm_nlp_phy_mod(pa,1,0xc019,10,10, 0x1);   /*  sd_intlos_mask */
+  nlm_nlp_phy_mod(pa,1,0xff2a,15,0, 0x4a);
+
+/* PART 2, uc code  ---------------------------------- */
+
+/* cmdUC processing binary and source file... */
+/* cmdUC Writing binary into memory... */
+  nlm_nlp_phy_mod(pa,1,0xd008,0,0, 0x1);
+/* config uC */
+  nlm_udelay(100000); /* 100ms */
+  nlm_nlp_phy_mod(pa,1,0xd000,15,0, 0x5200);
+  nlm_udelay(100000); /* 100ms */
+/* writing binary into uC SRAM... */
+  nlm_nlp_phy_mod(pa,1,0xd800,15,0, 0x2fff);
+  nlm_nlp_phy_mod(pa,1,0xd801,15,0, 0x300f);
+  nlm_nlp_phy_mod(pa,1,0xd802,15,0, 0x2ff4);
+  nlm_nlp_phy_mod(pa,1,0xd803,15,0, 0x3ef4);
+  nlm_nlp_phy_mod(pa,1,0xd804,15,0, 0x20ae);
+  nlm_nlp_phy_mod(pa,1,0xd805,15,0, 0x301e);
+  nlm_nlp_phy_mod(pa,1,0xd806,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd807,15,0, 0x22c4);
+  nlm_nlp_phy_mod(pa,1,0xd808,15,0, 0x3ef4);
+  nlm_nlp_phy_mod(pa,1,0xd809,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd80a,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd80b,15,0, 0x220e);
+  nlm_nlp_phy_mod(pa,1,0xd80c,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd80d,15,0, 0x2124);
+  nlm_nlp_phy_mod(pa,1,0xd80e,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd80f,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd810,15,0, 0x23fe);
+  nlm_nlp_phy_mod(pa,1,0xd811,15,0, 0x3c1e);
+  nlm_nlp_phy_mod(pa,1,0xd812,15,0, 0x2214);
+  nlm_nlp_phy_mod(pa,1,0xd813,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd814,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd815,15,0, 0x20a4);
+  nlm_nlp_phy_mod(pa,1,0xd816,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd817,15,0, 0x2dfe);
+  nlm_nlp_phy_mod(pa,1,0xd818,15,0, 0x307e);
+  nlm_nlp_phy_mod(pa,1,0xd819,15,0, 0x6e24);
+  nlm_nlp_phy_mod(pa,1,0xd81a,15,0, 0x6e24);
+  nlm_nlp_phy_mod(pa,1,0xd81b,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd81c,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd81d,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd81e,15,0, 0x402e);
+  nlm_nlp_phy_mod(pa,1,0xd81f,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd820,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd821,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd822,15,0, 0x2014);
+  nlm_nlp_phy_mod(pa,1,0xd823,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd824,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd825,15,0, 0x6e8f);
+  nlm_nlp_phy_mod(pa,1,0xd826,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd827,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd828,15,0, 0x2044);
+  nlm_nlp_phy_mod(pa,1,0xd829,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd82a,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd82b,15,0, 0x6e8f);
+  nlm_nlp_phy_mod(pa,1,0xd82c,15,0, 0x201e);
+  nlm_nlp_phy_mod(pa,1,0xd82d,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd82e,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd82f,15,0, 0x20d4);
+  nlm_nlp_phy_mod(pa,1,0xd830,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd831,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd832,15,0, 0x6e8f);
+  nlm_nlp_phy_mod(pa,1,0xd833,15,0, 0x21fe);
+  nlm_nlp_phy_mod(pa,1,0xd834,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd835,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd836,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd837,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd838,15,0, 0x404e);
+  nlm_nlp_phy_mod(pa,1,0xd839,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd83a,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd83b,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd83c,15,0, 0x21f5);
+  nlm_nlp_phy_mod(pa,1,0xd83d,15,0, 0x3005);
+  nlm_nlp_phy_mod(pa,1,0xd83e,15,0, 0xb805);
+  nlm_nlp_phy_mod(pa,1,0xd83f,15,0, 0x8556);
+  nlm_nlp_phy_mod(pa,1,0xd840,15,0, 0x8557);
+  nlm_nlp_phy_mod(pa,1,0xd841,15,0, 0x8558);
+  nlm_nlp_phy_mod(pa,1,0xd842,15,0, 0x8559);
+  nlm_nlp_phy_mod(pa,1,0xd843,15,0, 0x855a);
+  nlm_nlp_phy_mod(pa,1,0xd844,15,0, 0x400d);
+  nlm_nlp_phy_mod(pa,1,0xd845,15,0, 0x6d8f);
+  nlm_nlp_phy_mod(pa,1,0xd846,15,0, 0x2032);
+  nlm_nlp_phy_mod(pa,1,0xd847,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd848,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd849,15,0, 0x2132);
+  nlm_nlp_phy_mod(pa,1,0xd84a,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd84b,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd84c,15,0, 0x21c2);
+  nlm_nlp_phy_mod(pa,1,0xd84d,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd84e,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd84f,15,0, 0x2302);
+  nlm_nlp_phy_mod(pa,1,0xd850,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd851,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd852,15,0, 0x23a2);
+  nlm_nlp_phy_mod(pa,1,0xd853,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd854,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd855,15,0, 0x24c2);
+  nlm_nlp_phy_mod(pa,1,0xd856,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd857,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd858,15,0, 0x2562);
+  nlm_nlp_phy_mod(pa,1,0xd859,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd85a,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd85b,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd85c,15,0, 0x4004);
+  nlm_nlp_phy_mod(pa,1,0xd85d,15,0, 0xb814);
+  nlm_nlp_phy_mod(pa,1,0xd85e,15,0, 0x5e43);
+  nlm_nlp_phy_mod(pa,1,0xd85f,15,0, 0x3d7);
+  nlm_nlp_phy_mod(pa,1,0xd860,15,0, 0x2032);
+  nlm_nlp_phy_mod(pa,1,0xd861,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd862,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd863,15,0, 0x200e);
+  nlm_nlp_phy_mod(pa,1,0xd864,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd865,15,0, 0x2);
+  nlm_nlp_phy_mod(pa,1,0xd866,15,0, 0xd01e);
+  nlm_nlp_phy_mod(pa,1,0xd867,15,0, 0x6e8f);
+  nlm_nlp_phy_mod(pa,1,0xd868,15,0, 0x20fe);
+  nlm_nlp_phy_mod(pa,1,0xd869,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd86a,15,0, 0xb80e);
+  nlm_nlp_phy_mod(pa,1,0xd86b,15,0, 0xd01d);
+  nlm_nlp_phy_mod(pa,1,0xd86c,15,0, 0x5de3);
+  nlm_nlp_phy_mod(pa,1,0xd86d,15,0, 0x249e);
+  nlm_nlp_phy_mod(pa,1,0xd86e,15,0, 0x301e);
+  nlm_nlp_phy_mod(pa,1,0xd86f,15,0, 0x135e);
+  nlm_nlp_phy_mod(pa,1,0xd870,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd871,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd872,15,0, 0x20d4);
+  nlm_nlp_phy_mod(pa,1,0xd873,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd874,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd875,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd876,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd877,15,0, 0x404e);
+  nlm_nlp_phy_mod(pa,1,0xd878,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd879,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd87a,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd87b,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd87c,15,0, 0x2044);
+  nlm_nlp_phy_mod(pa,1,0xd87d,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd87e,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd87f,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd880,15,0, 0x2014);
+  nlm_nlp_phy_mod(pa,1,0xd881,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd882,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd883,15,0, 0x200e);
+  nlm_nlp_phy_mod(pa,1,0xd884,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd885,15,0, 0x2124);
+  nlm_nlp_phy_mod(pa,1,0xd886,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd887,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd888,15,0, 0x2504);
+  nlm_nlp_phy_mod(pa,1,0xd889,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd88a,15,0, 0x4015);
+  nlm_nlp_phy_mod(pa,1,0xd88b,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd88c,15,0, 0x2514);
+  nlm_nlp_phy_mod(pa,1,0xd88d,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd88e,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd88f,15,0, 0xb145);
+  nlm_nlp_phy_mod(pa,1,0xd890,15,0, 0xb115);
+  nlm_nlp_phy_mod(pa,1,0xd891,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd892,15,0, 0x2bd2);
+  nlm_nlp_phy_mod(pa,1,0xd893,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd894,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd895,15,0, 0x678f);
+  nlm_nlp_phy_mod(pa,1,0xd896,15,0, 0x2514);
+  nlm_nlp_phy_mod(pa,1,0xd897,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd898,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd899,15,0, 0xb145);
+  nlm_nlp_phy_mod(pa,1,0xd89a,15,0, 0xb105);
+  nlm_nlp_phy_mod(pa,1,0xd89b,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd89c,15,0, 0x2bd2);
+  nlm_nlp_phy_mod(pa,1,0xd89d,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd89e,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd89f,15,0, 0x6f78);
+  nlm_nlp_phy_mod(pa,1,0xd8a0,15,0, 0xe78e);
+  nlm_nlp_phy_mod(pa,1,0xd8a1,15,0, 0x22c5);
+  nlm_nlp_phy_mod(pa,1,0xd8a2,15,0, 0x3ef5);
+  nlm_nlp_phy_mod(pa,1,0xd8a3,15,0, 0x6ec5);
+  nlm_nlp_phy_mod(pa,1,0xd8a4,15,0, 0x2084);
+  nlm_nlp_phy_mod(pa,1,0xd8a5,15,0, 0x3034);
+  nlm_nlp_phy_mod(pa,1,0xd8a6,15,0, 0x2005);
+  nlm_nlp_phy_mod(pa,1,0xd8a7,15,0, 0x3d75);
+  nlm_nlp_phy_mod(pa,1,0xd8a8,15,0, 0xc451);
+  nlm_nlp_phy_mod(pa,1,0xd8a9,15,0, 0x2f62);
+  nlm_nlp_phy_mod(pa,1,0xd8aa,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8ab,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8ac,15,0, 0x2444);
+  nlm_nlp_phy_mod(pa,1,0xd8ad,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd8ae,15,0, 0x2ed2);
+  nlm_nlp_phy_mod(pa,1,0xd8af,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8b0,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8b1,15,0, 0x2144);
+  nlm_nlp_phy_mod(pa,1,0xd8b2,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd8b3,15,0, 0x2ed2);
+  nlm_nlp_phy_mod(pa,1,0xd8b4,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8b5,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8b6,15,0, 0x2f02);
+  nlm_nlp_phy_mod(pa,1,0xd8b7,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8b8,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8b9,15,0, 0x28c2);
+  nlm_nlp_phy_mod(pa,1,0xd8ba,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8bb,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8bc,15,0, 0x0);
+  nlm_nlp_phy_mod(pa,1,0xd8bd,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd8be,15,0, 0x4007);
+  nlm_nlp_phy_mod(pa,1,0xd8bf,15,0, 0x2524);
+  nlm_nlp_phy_mod(pa,1,0xd8c0,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd8c1,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd8c2,15,0, 0x2005);
+  nlm_nlp_phy_mod(pa,1,0xd8c3,15,0, 0x9575);
+  nlm_nlp_phy_mod(pa,1,0xd8c4,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd8c5,15,0, 0x678f);
+  nlm_nlp_phy_mod(pa,1,0xd8c6,15,0, 0x2dd2);
+  nlm_nlp_phy_mod(pa,1,0xd8c7,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8c8,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8c9,15,0, 0x6f77);
+  nlm_nlp_phy_mod(pa,1,0xd8ca,15,0, 0x2514);
+  nlm_nlp_phy_mod(pa,1,0xd8cb,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd8cc,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd8cd,15,0, 0xbd05);
+  nlm_nlp_phy_mod(pa,1,0xd8ce,15,0, 0xbf45);
+  nlm_nlp_phy_mod(pa,1,0xd8cf,15,0, 0x2db2);
+  nlm_nlp_phy_mod(pa,1,0xd8d0,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8d1,15,0, 0x5553);
+  nlm_nlp_phy_mod(pa,1,0xd8d2,15,0, 0x1302);
+  nlm_nlp_phy_mod(pa,1,0xd8d3,15,0, 0x2006);
+  nlm_nlp_phy_mod(pa,1,0xd8d4,15,0, 0x3016);
+  nlm_nlp_phy_mod(pa,1,0xd8d5,15,0, 0x5763);
+  nlm_nlp_phy_mod(pa,1,0xd8d6,15,0, 0x13c2);
+  nlm_nlp_phy_mod(pa,1,0xd8d7,15,0, 0xd017);
+  nlm_nlp_phy_mod(pa,1,0xd8d8,15,0, 0x2bf2);
+  nlm_nlp_phy_mod(pa,1,0xd8d9,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8da,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8db,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd8dc,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8dd,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd8de,15,0, 0x2514);
+  nlm_nlp_phy_mod(pa,1,0xd8df,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd8e0,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd8e1,15,0, 0x4026);
+  nlm_nlp_phy_mod(pa,1,0xd8e2,15,0, 0x9655);
+  nlm_nlp_phy_mod(pa,1,0xd8e3,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd8e4,15,0, 0x648f);
+  nlm_nlp_phy_mod(pa,1,0xd8e5,15,0, 0x401d);
+  nlm_nlp_phy_mod(pa,1,0xd8e6,15,0, 0x2f22);
+  nlm_nlp_phy_mod(pa,1,0xd8e7,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8e8,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8e9,15,0, 0x6f74);
+  nlm_nlp_phy_mod(pa,1,0xd8ea,15,0, 0x2fd6);
+  nlm_nlp_phy_mod(pa,1,0xd8eb,15,0, 0x3ff6);
+  nlm_nlp_phy_mod(pa,1,0xd8ec,15,0, 0x8655);
+  nlm_nlp_phy_mod(pa,1,0xd8ed,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd8ee,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd8ef,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8f0,15,0, 0x22cd);
+  nlm_nlp_phy_mod(pa,1,0xd8f1,15,0, 0x301d);
+  nlm_nlp_phy_mod(pa,1,0xd8f2,15,0, 0x2108);
+  nlm_nlp_phy_mod(pa,1,0xd8f3,15,0, 0x3808);
+  nlm_nlp_phy_mod(pa,1,0xd8f4,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd8f5,15,0, 0x5dd3);
+  nlm_nlp_phy_mod(pa,1,0xd8f6,15,0, 0x2012);
+  nlm_nlp_phy_mod(pa,1,0xd8f7,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8f8,15,0, 0x1302);
+  nlm_nlp_phy_mod(pa,1,0xd8f9,15,0, 0x63a8);
+  nlm_nlp_phy_mod(pa,1,0xd8fa,15,0, 0x2b72);
+  nlm_nlp_phy_mod(pa,1,0xd8fb,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8fc,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8fd,15,0, 0xdffd);
+  nlm_nlp_phy_mod(pa,1,0xd8fe,15,0, 0x2f52);
+  nlm_nlp_phy_mod(pa,1,0xd8ff,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd900,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd901,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd902,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd903,15,0, 0x2214);
+  nlm_nlp_phy_mod(pa,1,0xd904,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd905,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd906,15,0, 0x2ef4);
+  nlm_nlp_phy_mod(pa,1,0xd907,15,0, 0x3ff4);
+  nlm_nlp_phy_mod(pa,1,0xd908,15,0, 0x8e4e);
+  nlm_nlp_phy_mod(pa,1,0xd909,15,0, 0x2214);
+  nlm_nlp_phy_mod(pa,1,0xd90a,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd90b,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd90c,15,0, 0x2104);
+  nlm_nlp_phy_mod(pa,1,0xd90d,15,0, 0x3004);
+  nlm_nlp_phy_mod(pa,1,0xd90e,15,0, 0x9e4e);
+  nlm_nlp_phy_mod(pa,1,0xd90f,15,0, 0x2214);
+  nlm_nlp_phy_mod(pa,1,0xd910,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd911,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd912,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd913,15,0, 0x2294);
+  nlm_nlp_phy_mod(pa,1,0xd914,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd915,15,0, 0x64db);
+  nlm_nlp_phy_mod(pa,1,0xd916,15,0, 0x8bbc);
+  nlm_nlp_phy_mod(pa,1,0xd917,15,0, 0xb84b);
+  nlm_nlp_phy_mod(pa,1,0xd918,15,0, 0x300c);
+  nlm_nlp_phy_mod(pa,1,0xd919,15,0, 0xdf0b);
+  nlm_nlp_phy_mod(pa,1,0xd91a,15,0, 0xdf0c);
+  nlm_nlp_phy_mod(pa,1,0xd91b,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd91c,15,0, 0xc5b5);
+  nlm_nlp_phy_mod(pa,1,0xd91d,15,0, 0xc6c6);
+  nlm_nlp_phy_mod(pa,1,0xd91e,15,0, 0x855e);
+  nlm_nlp_phy_mod(pa,1,0xd91f,15,0, 0xb84e);
+  nlm_nlp_phy_mod(pa,1,0xd920,15,0, 0x866c);
+  nlm_nlp_phy_mod(pa,1,0xd921,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd922,15,0, 0xb60c);
+  nlm_nlp_phy_mod(pa,1,0xd923,15,0, 0x9cee);
+  nlm_nlp_phy_mod(pa,1,0xd924,15,0, 0x20a4);
+  nlm_nlp_phy_mod(pa,1,0xd925,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd926,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd927,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd928,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd929,15,0, 0x202e);
+  nlm_nlp_phy_mod(pa,1,0xd92a,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd92b,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd92c,15,0, 0x200e);
+  nlm_nlp_phy_mod(pa,1,0xd92d,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd92e,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd92f,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd930,15,0, 0x22b4);
+  nlm_nlp_phy_mod(pa,1,0xd931,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd932,15,0, 0x64db);
+  nlm_nlp_phy_mod(pa,1,0xd933,15,0, 0x8bbc);
+  nlm_nlp_phy_mod(pa,1,0xd934,15,0, 0xb84b);
+  nlm_nlp_phy_mod(pa,1,0xd935,15,0, 0xb80c);
+  nlm_nlp_phy_mod(pa,1,0xd936,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd937,15,0, 0xdf0b);
+  nlm_nlp_phy_mod(pa,1,0xd938,15,0, 0xdf0c);
+  nlm_nlp_phy_mod(pa,1,0xd939,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd93a,15,0, 0xc7b7);
+  nlm_nlp_phy_mod(pa,1,0xd93b,15,0, 0xc8c8);
+  nlm_nlp_phy_mod(pa,1,0xd93c,15,0, 0x877e);
+  nlm_nlp_phy_mod(pa,1,0xd93d,15,0, 0xb84e);
+  nlm_nlp_phy_mod(pa,1,0xd93e,15,0, 0x888c);
+  nlm_nlp_phy_mod(pa,1,0xd93f,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd940,15,0, 0xb60c);
+  nlm_nlp_phy_mod(pa,1,0xd941,15,0, 0x9cee);
+  nlm_nlp_phy_mod(pa,1,0xd942,15,0, 0x20b4);
+  nlm_nlp_phy_mod(pa,1,0xd943,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd944,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd945,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd946,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd947,15,0, 0x402e);
+  nlm_nlp_phy_mod(pa,1,0xd948,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd949,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd94a,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd94b,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd94c,15,0, 0x22a4);
+  nlm_nlp_phy_mod(pa,1,0xd94d,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd94e,15,0, 0x64db);
+  nlm_nlp_phy_mod(pa,1,0xd94f,15,0, 0x8bbc);
+  nlm_nlp_phy_mod(pa,1,0xd950,15,0, 0xb84b);
+  nlm_nlp_phy_mod(pa,1,0xd951,15,0, 0xb80c);
+  nlm_nlp_phy_mod(pa,1,0xd952,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd953,15,0, 0xdf0b);
+  nlm_nlp_phy_mod(pa,1,0xd954,15,0, 0xdf0c);
+  nlm_nlp_phy_mod(pa,1,0xd955,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd956,15,0, 0xc9b9);
+  nlm_nlp_phy_mod(pa,1,0xd957,15,0, 0xcaca);
+  nlm_nlp_phy_mod(pa,1,0xd958,15,0, 0x899e);
+  nlm_nlp_phy_mod(pa,1,0xd959,15,0, 0xb84e);
+  nlm_nlp_phy_mod(pa,1,0xd95a,15,0, 0x8aac);
+  nlm_nlp_phy_mod(pa,1,0xd95b,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd95c,15,0, 0xb60c);
+  nlm_nlp_phy_mod(pa,1,0xd95d,15,0, 0x9cee);
+  nlm_nlp_phy_mod(pa,1,0xd95e,15,0, 0x20c4);
+  nlm_nlp_phy_mod(pa,1,0xd95f,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd960,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd961,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd962,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd963,15,0, 0x402e);
+  nlm_nlp_phy_mod(pa,1,0xd964,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd965,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd966,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd967,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd968,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd969,15,0, 0x20a4);
+  nlm_nlp_phy_mod(pa,1,0xd96a,15,0, 0x3004);
+  nlm_nlp_phy_mod(pa,1,0xd96b,15,0, 0x64d9);
+  nlm_nlp_phy_mod(pa,1,0xd96c,15,0, 0x899e);
+  nlm_nlp_phy_mod(pa,1,0xd96d,15,0, 0xbf0e);
+  nlm_nlp_phy_mod(pa,1,0xd96e,15,0, 0xbf4e);
+  nlm_nlp_phy_mod(pa,1,0xd96f,15,0, 0x4012);
+  nlm_nlp_phy_mod(pa,1,0xd970,15,0, 0x2f0e);
+  nlm_nlp_phy_mod(pa,1,0xd971,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd972,15,0, 0x2054);
+  nlm_nlp_phy_mod(pa,1,0xd973,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd974,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd975,15,0, 0x2064);
+  nlm_nlp_phy_mod(pa,1,0xd976,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd977,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd978,15,0, 0x8ee9);
+  nlm_nlp_phy_mod(pa,1,0xd979,15,0, 0xbe0e);
+  nlm_nlp_phy_mod(pa,1,0xd97a,15,0, 0xbf4e);
+  nlm_nlp_phy_mod(pa,1,0xd97b,15,0, 0x5e23);
+  nlm_nlp_phy_mod(pa,1,0xd97c,15,0, 0x382);
+  nlm_nlp_phy_mod(pa,1,0xd97d,15,0, 0x8);
+  nlm_nlp_phy_mod(pa,1,0xd97e,15,0, 0x401e);
+  nlm_nlp_phy_mod(pa,1,0xd97f,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd980,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd981,15,0, 0x280e);
+  nlm_nlp_phy_mod(pa,1,0xd982,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd983,15,0, 0x63ae);
+  nlm_nlp_phy_mod(pa,1,0xd984,15,0, 0x8);
+  nlm_nlp_phy_mod(pa,1,0xd985,15,0, 0x2fee);
+  nlm_nlp_phy_mod(pa,1,0xd986,15,0, 0x3ffe);
+  nlm_nlp_phy_mod(pa,1,0xd987,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd988,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd989,15,0, 0x280e);
+  nlm_nlp_phy_mod(pa,1,0xd98a,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd98b,15,0, 0x63ae);
+  nlm_nlp_phy_mod(pa,1,0xd98c,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd98d,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd98e,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd98f,15,0, 0x20a4);
+  nlm_nlp_phy_mod(pa,1,0xd990,15,0, 0x3004);
+  nlm_nlp_phy_mod(pa,1,0xd991,15,0, 0x64d9);
+  nlm_nlp_phy_mod(pa,1,0xd992,15,0, 0x899e);
+  nlm_nlp_phy_mod(pa,1,0xd993,15,0, 0xbf0e);
+  nlm_nlp_phy_mod(pa,1,0xd994,15,0, 0xbf4e);
+  nlm_nlp_phy_mod(pa,1,0xd995,15,0, 0x4012);
+  nlm_nlp_phy_mod(pa,1,0xd996,15,0, 0x5e23);
+  nlm_nlp_phy_mod(pa,1,0xd997,15,0, 0x3d2);
+  nlm_nlp_phy_mod(pa,1,0xd998,15,0, 0x1d);
+  nlm_nlp_phy_mod(pa,1,0xd999,15,0, 0x2f0e);
+  nlm_nlp_phy_mod(pa,1,0xd99a,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd99b,15,0, 0x2054);
+  nlm_nlp_phy_mod(pa,1,0xd99c,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd99d,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd99e,15,0, 0x2064);
+  nlm_nlp_phy_mod(pa,1,0xd99f,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd9a0,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9a1,15,0, 0x8ee9);
+  nlm_nlp_phy_mod(pa,1,0xd9a2,15,0, 0xbe0e);
+  nlm_nlp_phy_mod(pa,1,0xd9a3,15,0, 0xbf4e);
+  nlm_nlp_phy_mod(pa,1,0xd9a4,15,0, 0x5e23);
+  nlm_nlp_phy_mod(pa,1,0xd9a5,15,0, 0x382);
+  nlm_nlp_phy_mod(pa,1,0xd9a6,15,0, 0x9);
+  nlm_nlp_phy_mod(pa,1,0xd9a7,15,0, 0x2fee);
+  nlm_nlp_phy_mod(pa,1,0xd9a8,15,0, 0x3ffe);
+  nlm_nlp_phy_mod(pa,1,0xd9a9,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd9aa,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9ab,15,0, 0x280e);
+  nlm_nlp_phy_mod(pa,1,0xd9ac,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd9ad,15,0, 0x63ae);
+  nlm_nlp_phy_mod(pa,1,0xd9ae,15,0, 0x7);
+  nlm_nlp_phy_mod(pa,1,0xd9af,15,0, 0x401e);
+  nlm_nlp_phy_mod(pa,1,0xd9b0,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd9b1,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9b2,15,0, 0x280e);
+  nlm_nlp_phy_mod(pa,1,0xd9b3,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd9b4,15,0, 0x63ae);
+  nlm_nlp_phy_mod(pa,1,0xd9b5,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd9b6,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd9b7,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd9b8,15,0, 0x2844);
+  nlm_nlp_phy_mod(pa,1,0xd9b9,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9ba,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9bb,15,0, 0x2d62);
+  nlm_nlp_phy_mod(pa,1,0xd9bc,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd9bd,15,0, 0x1e52);
+  nlm_nlp_phy_mod(pa,1,0xd9be,15,0, 0x20c4);
+  nlm_nlp_phy_mod(pa,1,0xd9bf,15,0, 0x3c24);
+  nlm_nlp_phy_mod(pa,1,0xd9c0,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9c1,15,0, 0x2ff9);
+  nlm_nlp_phy_mod(pa,1,0xd9c2,15,0, 0x3fd9);
+  nlm_nlp_phy_mod(pa,1,0xd9c3,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd9c4,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9c5,15,0, 0x26c4);
+  nlm_nlp_phy_mod(pa,1,0xd9c6,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9c7,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9c8,15,0, 0x2ff9);
+  nlm_nlp_phy_mod(pa,1,0xd9c9,15,0, 0x3fa9);
+  nlm_nlp_phy_mod(pa,1,0xd9ca,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd9cb,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9cc,15,0, 0x2894);
+  nlm_nlp_phy_mod(pa,1,0xd9cd,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9ce,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9cf,15,0, 0x2f79);
+  nlm_nlp_phy_mod(pa,1,0xd9d0,15,0, 0x3ff9);
+  nlm_nlp_phy_mod(pa,1,0xd9d1,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd9d2,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9d3,15,0, 0x2eb2);
+  nlm_nlp_phy_mod(pa,1,0xd9d4,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd9d5,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd9d6,15,0, 0x2894);
+  nlm_nlp_phy_mod(pa,1,0xd9d7,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9d8,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9d9,15,0, 0x2089);
+  nlm_nlp_phy_mod(pa,1,0xd9da,15,0, 0x3009);
+  nlm_nlp_phy_mod(pa,1,0xd9db,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd9dc,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9dd,15,0, 0x26c4);
+  nlm_nlp_phy_mod(pa,1,0xd9de,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9df,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9e0,15,0, 0x2009);
+  nlm_nlp_phy_mod(pa,1,0xd9e1,15,0, 0x3059);
+  nlm_nlp_phy_mod(pa,1,0xd9e2,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd9e3,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9e4,15,0, 0x20c4);
+  nlm_nlp_phy_mod(pa,1,0xd9e5,15,0, 0x3c24);
+  nlm_nlp_phy_mod(pa,1,0xd9e6,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9e7,15,0, 0x2009);
+  nlm_nlp_phy_mod(pa,1,0xd9e8,15,0, 0x3029);
+  nlm_nlp_phy_mod(pa,1,0xd9e9,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd9ea,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9eb,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd9ec,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd9ed,15,0, 0x64d6);
+  nlm_nlp_phy_mod(pa,1,0xd9ee,15,0, 0x21f7);
+  nlm_nlp_phy_mod(pa,1,0xd9ef,15,0, 0x3fc7);
+  nlm_nlp_phy_mod(pa,1,0xd9f0,15,0, 0x8676);
+  nlm_nlp_phy_mod(pa,1,0xd9f1,15,0, 0xb505);
+  nlm_nlp_phy_mod(pa,1,0xd9f2,15,0, 0x9566);
+  nlm_nlp_phy_mod(pa,1,0xd9f3,15,0, 0x66c4);
+  nlm_nlp_phy_mod(pa,1,0xd9f4,15,0, 0xb545);
+  nlm_nlp_phy_mod(pa,1,0xd9f5,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd9f6,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd9f7,15,0, 0x6138);
+  nlm_nlp_phy_mod(pa,1,0xd9f8,15,0, 0x5883);
+  nlm_nlp_phy_mod(pa,1,0xd9f9,15,0, 0x2062);
+  nlm_nlp_phy_mod(pa,1,0xd9fa,15,0, 0x3032);
+  nlm_nlp_phy_mod(pa,1,0xd9fb,15,0, 0x1302);
+  nlm_nlp_phy_mod(pa,1,0xd9fc,15,0, 0x2ff7);
+  nlm_nlp_phy_mod(pa,1,0xd9fd,15,0, 0x3007);
+  nlm_nlp_phy_mod(pa,1,0xd9fe,15,0, 0x8786);
+  nlm_nlp_phy_mod(pa,1,0xd9ff,15,0, 0xb887);
+  nlm_nlp_phy_mod(pa,1,0xda00,15,0, 0x8785);
+  nlm_nlp_phy_mod(pa,1,0xda01,15,0, 0xb8c5);
+  nlm_nlp_phy_mod(pa,1,0xda02,15,0, 0x5e63);
+  nlm_nlp_phy_mod(pa,1,0xda03,15,0, 0x2f72);
+  nlm_nlp_phy_mod(pa,1,0xda04,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xda05,15,0, 0x13c2);
+  nlm_nlp_phy_mod(pa,1,0xda06,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xda07,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xda08,15,0, 0xc82);
+  nlm_nlp_phy_mod(pa,1,0xda09,15,0, 0xd87);
+  nlm_nlp_phy_mod(pa,1,0xda0a,15,0, 0xe8d);
+  nlm_nlp_phy_mod(pa,1,0xda0b,15,0, 0x1092);
+  nlm_nlp_phy_mod(pa,1,0xda0c,15,0, 0x1198);
+  nlm_nlp_phy_mod(pa,1,0xda0d,15,0, 0x129d);
+  nlm_nlp_phy_mod(pa,1,0xda0e,15,0, 0x14a3);
+  nlm_nlp_phy_mod(pa,1,0xda0f,15,0, 0x16a8);
+  nlm_nlp_phy_mod(pa,1,0xda10,15,0, 0x17ae);
+  nlm_nlp_phy_mod(pa,1,0xda11,15,0, 0x18b4);
+  nlm_nlp_phy_mod(pa,1,0xda12,15,0, 0x0);
+  nlm_nlp_phy_mod(pa,1,0xda13,15,0, 0x0);
+
+/* done with uC binary */
+/* cmdUC verifying binary... */
+  nlm_nlp_phy_mod(pa,1,0xd080,15,0, 0x100);
+  nlm_nlp_phy_mod(pa,1,0xd092,15,0, 0x0);
+  nlm_udelay(400000);  /* wait for uC to settle offset calibration */
+
+#if 0 /* Sequence from SDK */
+  nlm_nlp_phy_mod(pa,1,0xc088,3,0  , 0x0);
+  nlm_nlp_phy_mod(pa,1,0xc012,3,0  , 0x0);
+  nlm_nlp_phy_mod(pa,1,0xc012,7,4  , 0x0);
+  nlm_nlp_phy_mod(pa,1,0xc017,13,13  , 0x0);
+  nlm_nlp_phy_mod(pa,1,0xcd40,3,0  , 0x1);
+  nlm_nlp_phy_mod(pa,1,0xc0f0,15,0  , 0x0102);
+  nlm_nlp_phy_mod(pa,1,0xc0f1,15,0  , 0x0056);
+  nlm_nlp_phy_mod(pa,1,0xc20d,1,1  , 0x1);
+  nlm_udelay(200000);  /* sleep 200ms */
+
+#else /* Sequence from Support */
+  nlm_nlp_phy_mod(pa,1,0xcc08,5,0  , 0x6); 	/*  lsatxfi_o2e_rxrxfdfetap1 */
+  nlm_nlp_phy_mod(pa,1,0xcc08,11,6 , 0x23); 	/*  lsatxfi_o2e_rxrxfdfetap2 */
+  nlm_nlp_phy_mod(pa,1,0xcc09,5,0  , 0x28); 	/*  lsatxfi_o2e_rxrxfdfetap3 */
+  nlm_nlp_phy_mod(pa,1,0xcc09,11,6 , 0x2d); 	/*  lsatxfi_o2e_rxrxfdfetap4 */
+  nlm_nlp_phy_mod(pa,1,0xcc0e,0,0, 0x1); 	/*  lsatxfi_o2e_rxrxfdfetapstrobe */
+  nlm_nlp_phy_mod(pa,1,0xcc0e,0,0, 0x0); 	/*  lsatxfi_o2e_rxrxfdfetapstrobe */
+/* end of s_eepromLoad */
+
+/* PART 3, speed mode -------------------------------- */
+
+/* Evaluating, 'xaui_init ' */
+  nlm_nlp_phy_mod(pa,1,0xc2e1,3,0, 0xf);   /*  mci_lpbk_glue */
+  nlm_nlp_phy_mod(pa,1,0xc088,3,0, 0x0);   /*  espeed_mode */
+  nlm_nlp_phy_mod(pa,1,0xc012,3,0, 0x0);   /*  cfg_pwrdnxr */
+  nlm_nlp_phy_mod(pa,1,0xc012,7,4, 0x0);   /*  cfg_pwrdnxt */
+  nlm_nlp_phy_mod(pa,1,0xc0f0,15,0, 0x010a);/*  revision */
+  nlm_nlp_phy_mod(pa,1,0xc0f1,15,0, 0x0056);/*  clk mode */
+  nlm_nlp_phy_mod(pa,1,0xc20d,1,1, 0x1);   /*  rConStart */
+  nlm_udelay(200000);  /* sleep 200ms */
+#endif
+
+  /* Add setting the GPIO config for our LEDs */
+
+  /* GPIO port2 gpioobcfg */
+  nlm_nlp_phy_mod(pa,1,0xc112,15,0, 0x33ff);
+
+  /* GPIO port2 gpioobcfg */
+  nlm_nlp_phy_mod(pa,1,0xc113,15,0, 0xb3ff);
+
+  /* GPIO Ctrl port2 and port3 to probe mode */
+  /*nlm_nlp_phy_mod(pa,1,0xc108,15,0, 0x8800); */
+  /* GPIO Ctrl port2 and port3 to traffic indication mode */
+  nlm_nlp_phy_mod(pa,1,0xc108,15,0, 0xdd00);
+}
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_eeprom.h b/arch/mips/netlogic/lib/syslib/include/nlm_eeprom.h
new file mode 100644
index 0000000..5983eb5
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_eeprom.h
@@ -0,0 +1,81 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _NLM_EEPROM_H
+#define _NLH_EEPROM_H
+
+#include "nlm_hal.h"
+/* MACID i2c memory definitions
+ */
+#define MAGIC_OFF   		0x00
+#define MAGIC_LEN   		0x02
+#define MAC_MAGIC_BYTE0 	0xAA
+#define MAC_MAGIC_BYTE1 	0x55
+#define MAC_OFF     		0x02
+#define MAC_LEN     		0x06
+
+#define NAME_OFF     		0x10
+#define NAME_LEN     		0x08
+#define REV_OFF     		0x18
+#define REV_LEN     		0x03
+#define SN_OFF      		0x1B
+#define SN_LEN      		0x04
+#define UPD_OFF     		0x1F
+#define UPD_LEN     		0x02
+
+
+struct eeprom_data{
+	unsigned char magic_bytes0[MAGIC_LEN];
+	unsigned char mac_addr0[MAC_LEN];
+	unsigned char magic_bytes1[MAGIC_LEN];
+	unsigned char mac_addr1[MAC_LEN];
+	unsigned char name[NAME_LEN];
+	unsigned char revision[REV_LEN];
+	unsigned char srnum[SN_LEN];
+	unsigned char upd[UPD_LEN];
+
+	unsigned char i2c_dev_addr;
+	void *priv;
+
+	void(*eeprom_i2c_read_bytes)(unsigned char dev_addr, unsigned int addr, int alen, unsigned char * buf, int len);
+	void(*eeprom_i2c_write_bytes)(unsigned char dev_addr, unsigned int addr, int alen, unsigned char * buf, int len);
+};
+
+extern int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+extern int  eeprom_set_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+extern int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+extern int  eeprom_dump(struct eeprom_data *nlm_eeprom, unsigned char *mac, int offset, int len);
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_evp_cpld.h b/arch/mips/netlogic/lib/syslib/include/nlm_evp_cpld.h
new file mode 100644
index 0000000..64f235b
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_evp_cpld.h
@@ -0,0 +1,79 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef __NLM_CPLD_H__
+#define __NLM_CPLD_H__
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#endif
+#include "nlm_hal.h"
+
+#define CORTINA_ILK1_BASE	0x17100000
+#define CORTINA_ILK2_BASE	0x17200000
+#define NLM_GBU_FREQ_DEFAULT	133
+#define NLM_GBU_FREQ_ILK	16
+	
+#define NLM_XLP_MAX_CS  7
+
+typedef struct {
+        uint32_t        base;
+        uint32_t        size;
+        uint32_t        swap;
+        uint32_t        devparam;
+}nlm_xlp_nor_t;
+
+#define SWAB16(x)       ((uint16_t)((((uint16_t)x & (uint16_t)0x00FFU) << 8) |  \
+                        (((uint16_t)x & (uint16_t)0xFF00U) >> 8)))
+
+#define SIZE_16MB       (0x1000000)
+#define SIZE_1MB        (0x100000)
+
+#define DC_ILK          0
+#define DC_HIGIG        0
+#define DC_SGMII        1
+#define DC_XAUI         2
+#define DC_NOT_PRSNT    3
+#define DC_RXAUI        6 /*not support by CPLD : Defined for software using only */
+#define DC_XFI		7
+#define DC_XLAUI	8 
+
+#define DC_TYPE(val,slot)       ((val >> (slot * 2)) & 0x3)
+#define EVP_VER(val)            (val & 0x8)
+
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
new file mode 100644
index 0000000..adb6092
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
@@ -0,0 +1,348 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _NLM_HAL_H_
+#define _NLM_HAL_H_
+
+#if !defined(NLM_HAL_LINUX_KERNEL) && !defined(NLM_HAL_UBOOT)
+#include "types.h"
+#endif
+
+
+#include "nlm_hal_macros.h"
+#include "nlm_hal_xlp_dev.h"
+//#include "nlm_nae.h"
+#ifndef __ASSEMBLY__
+
+#include "nlm_hal_sys.h"
+
+struct nlm_node_config
+{
+        int valid;
+        int num_nodes;  // Number of nodes
+        void *nae_cfg[NLM_MAX_NODES];      // NAE configuration
+        struct fmn_cfg *fmn_cfg[NLM_MAX_NODES];
+};
+
+
+enum freq_config {
+        NLM_DEFAULT     = 0,
+        NLM_NAE,
+        NLM_RSA,
+        NLM_SAE,
+        NLM_DTRE,
+        NLM_CDE,
+};
+
+struct nlm_netl_proc_info{
+	unsigned int proc_id;
+	unsigned int chipid;		/*example: xlp832=>0x8084, xlp316=>0x3044, xlp208=>0x2024 etc */
+	unsigned int revision;
+	unsigned int efuse_config[8];
+	char cpu_info_str[32];
+};
+
+struct nlm_hal_mii_info{
+       uint32_t speed;
+       uint32_t duplex;
+       int link_stat;
+       int phyaddr;
+};
+/**
+* @brief Used by function ::get_phy_info and various internal PHY manufacturer-specific functions.
+* @ingroup hal
+*/
+struct nlm_hal_ext_phy{
+        char name[16];
+        uint32_t phy_idfer;
+        uint32_t ext_mdio_bus;
+        int inf;
+        int phy_addr;
+	int (*phy_get_status)(struct nlm_hal_ext_phy* ext_phy, struct nlm_hal_mii_info *mii_info, int node);
+        void (*start_phy_an)(struct nlm_hal_ext_phy* ext_phy, int node);
+        void (*ext_phy_init)(struct nlm_hal_ext_phy* ext_phy, int node);
+        /*(void) (*dump_regs)(void); */
+};
+extern void nlm_hal_init(void);
+
+extern unsigned long long nlm_hal_cpu_freq(void);
+extern int naecfg_hack;
+
+extern int nlm_hal_is_xlp_a0(void);
+extern int nlm_hal_is_xlp_le(void);
+extern void nlm_hal_xlp_pcie_rc_init(void);
+
+extern void nlm_hal_cpld_init(int node);
+/* #define SKIP_INTERFACE_TYPE_FROMCPLD 1 */
+extern int nlm_get_interface_type(int node, int slot);
+extern int is_ilk_card_onslot(int);
+extern int is_xlp_evp1(void);
+extern int is_xlp_evp2(void);
+extern int nlm_xlp_boardver(void);
+extern int nlm_xlp_cpldver(void);
+extern void sgmii_scan_phys(int node);
+
+#ifndef NLM_HAL_LINUX_KERNEL
+extern void enable_cpus(unsigned int node, unsigned long thread_bitmask, unsigned long park_func);
+#endif /* #ifndef NLM_HAL_LINUX_KERNEL */
+
+#ifdef NLM_HAL_XLOADER
+#define nlm_hal_read_16bit_reg(base, index)	(uint16_t)(nlh_read_cfg_reg16(base + (index << 1)))
+#define nlm_hal_write_16bit_reg(base, index, val)	(nlh_write_cfg_reg16(base +  (index << 1) , val))
+#define nlm_hal_read_32bit_reg(base, index)	(uint32_t)(nlh_read_cfg_reg32(base + (index << 2)))
+#define nlm_hal_write_32bit_reg(base, index, val)	(nlh_write_cfg_reg32(base +  (index << 2) , val))
+#define nlm_hal_read_64bit_reg(base, index) (uint64_t)(nlh_read_cfg_reg64(base + (index << 3)))
+#define nlm_hal_write_64bit_reg(base, index, val) 	(nlh_write_cfg_reg64(base +  (index << 3) , val))
+
+#else
+
+extern uint16_t nlm_hal_read_16bit_reg(uint64_t base, uint32_t index);
+extern void nlm_hal_write_16bit_reg(uint64_t base, uint32_t index, uint16_t val);
+extern uint32_t nlm_hal_read_32bit_reg(uint64_t base, int index);
+extern void nlm_hal_write_32bit_reg(uint64_t base, int index, uint32_t val);
+extern uint64_t nlm_hal_read_64bit_reg(uint64_t base, int index);
+extern void nlm_hal_write_64bit_reg(uint64_t base, int index, uint64_t val);
+
+#endif /*NLM_HAL_XLOADER*/
+
+extern void nlm_hal_cpld_write_16(int cs, uint16_t val, uint16_t reg);
+extern uint16_t nlm_hal_cpld_read_16(int cs, uint16_t reg);
+
+extern uint32_t efuse_cfg0(void);
+extern uint32_t efuse_cfg1(void);
+extern uint32_t efuse_cfg6(void);
+extern uint32_t get_proc_id(void);
+
+extern void nlm_hal_set_rsa_cge(int node, int enable);
+extern void nlm_hal_set_sae_engine_sel(int node);
+extern void nlm_hal_set_rsa_engine_sel(int node);
+extern void nlm_hal_set_sae_freq(int node, int freq);
+extern int  nlm_hal_get_sae_chip_feature(void);
+extern void nlm_hal_set_rsa_freq(int node, int freq);
+extern void nlm_hal_set_dtre_freq(int node, int freq);
+extern void nlm_hal_set_cde_freq(int node, int freq);
+extern void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit);
+extern void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit);
+extern void nlm_hal_set_rsa_data_mode(int node, int bigend_fmt);
+
+#define nlh_read_dev_reg(dev, index) nlm_hal_read_32bit_reg(nlm_hal_get_dev_base(dev), index)
+#define nlh_write_dev_reg(dev, index, val) nlm_hal_write_32bit_reg(nlm_hal_get_dev_base(dev), index, val)
+
+extern uint64_t nlm_hal_get_dev_base(int node, int bus, int dev, int func);
+
+extern int nlm_hal_get_cpuinfo(struct nlm_netl_proc_info *);
+
+extern int is_nlm_xlp208(void);
+extern int is_nlm_xlp108(void);
+extern int is_nlm_xlp204(void);
+extern int is_nlm_xlp104(void);
+extern int is_nlm_xlp202(void);
+extern int is_nlm_xlp201(void);
+extern int is_nlm_xlp101(void);
+
+extern uint32_t get_dom_owner_mask(void *fdt, int dom_id, char *module);
+
+struct nlm_sae_init_param {
+	int node;
+	int freq;
+};
+
+struct nlm_rsa_init_param {
+	int node;
+	int freq;
+};
+
+extern int nlm_hal_is_ref_clk_133MHz(void);
+#define XLP_PIT_TICK_RATE      nlm_hal_get_ref_clk_freq()
+
+extern int nlm_hal_get_fdt_freq(void *fdt, int type);
+/*
+TODO :
+  1. support Debug flags
+  2. XLP support ?
+ */
+
+static inline uint32_t get_xlp3xx_epid(void)
+{
+        uint32_t cfg0, epid;
+
+        cfg0=efuse_cfg0();
+        epid = (uint8_t)(( cfg0>>4 )  & 0xf);
+        return epid;
+}
+
+#ifndef DEFAULT_CPU_IO_BASE
+#define DEFAULT_CPU_IO_BASE 0xffffffffb8000000ULL
+#endif
+#define HDR_OFFSET 0x100
+#define BDF2OFFSET(bus, dev, func)  (((bus) << 20) | ((dev) << 15) | ((func) << 12))
+#define XLP_XKPHYS_UNCACHED       0x9000000000000000ULL
+
+#define BRIDGE BDF2OFFSET(0, 0, 0)
+
+#if defined(NLM_HAL_LINUX_KERNEL) || defined(NLM_HAL_UBOOT)
+inline static u32 xlp9xx_get_node_id(void)
+{
+        u32 node = 0;
+        __asm__ __volatile__(          \
+                " .set    push         \n" \
+                " .set    noreorder    \n" \
+                "   mfc0  %0, $15, 1   \n" \
+                "   srl   %0, 7        \n" \
+                "   and   %0, 7        \n" \
+                " .set pop             \n" \
+                : "=r" (node):: );
+
+        return node;
+}
+#else
+inline static u32 xlp9xx_get_node_id(void)
+{
+	u32 cpuid = nlm_uaccess_hard_cpuid();
+	return ((cpuid >> 7) & 0x7);
+}
+#endif
+
+//node<0: use current cpu nodeid
+#if defined(NLM_HAL_LINUX_KERNEL) || defined(NLM_HAL_UBOOT)
+inline static volatile u32* xlp9xx_cpu_io_mmio(int node, u32 offset)
+{
+	volatile u32 * pcmu = NULL;
+	uint32_t busno;
+        if(node <0 )
+		node = xlp9xx_get_node_id();
+
+        pcmu = (volatile u32*)(DEFAULT_CPU_IO_BASE + ( (node&0x7) << 12) );
+        if( offset == BRIDGE ) return pcmu + 0x40;
+
+        busno = (pcmu[6] >> 8 ) & 0xFF;  //get secondary bus number
+
+        return (volatile u32 *)(DEFAULT_CPU_IO_BASE + (busno<<20) + (offset) + HDR_OFFSET);
+}
+#else
+inline static volatile u32* xlp9xx_cpu_io_mmio(int node, u32 offset)
+{
+	volatile u32 * pcmu = NULL;
+	uint32_t busno, val;
+	if(node <0 )
+		node = xlp9xx_get_node_id();
+
+	pcmu = (volatile u32*)((DEFAULT_CPU_IO_BASE + ( (node&0x7) << 12)) & 0x1fffffff);
+	if( offset == BRIDGE ) return pcmu + 0x40;
+
+	val = nlm_hal_read_32bit_reg((uint64_t)pcmu, 6);
+	busno = (val >> 8 ) & 0xFF;  //get secondary bus number
+
+	return (volatile u32 *)((DEFAULT_CPU_IO_BASE + (busno<<20) +
+                              (offset) + HDR_OFFSET) & 0x1fffffff);
+}
+#endif
+
+//get device's mem bar0/1 and convert to 64bits uncached virtual memory
+#if defined(NLM_HAL_LINUX_KERNEL) || defined(NLM_HAL_UBOOT)
+inline static volatile u32* xlp9xx_cpu_mem_base(u32 node, u32 offset)
+{
+	uint64_t phy;
+	volatile u32* mmio = xlp9xx_cpu_io_mmio(node, offset);
+
+	mmio -= HDR_OFFSET/sizeof(u32);
+	phy = mmio[4] ;
+
+	if( phy&1 )
+		phy &= ~((u64)3);       //io bar
+	else{
+		//64bits physical address
+		if( ((phy>>1) & 3) == 2 )  phy |= (u64)mmio[5] << 32;
+		phy &= ~((u64)0x7F);
+	}
+
+	phy &= 0xFFFFFFFFFFULL; //40 bits phy addr
+	return (volatile u32*)(phy);
+}
+#else
+inline static volatile u32* xlp9xx_cpu_mem_base(u32 node, u32 offset)
+{
+	uint64_t phy,phy1;
+	volatile u32* mmio = xlp9xx_cpu_io_mmio(node, offset);
+
+	mmio -= HDR_OFFSET/sizeof(u32);
+	phy = (uint64_t)nlm_hal_read_32bit_reg((uint64_t)mmio, 4);
+	phy1 = (uint64_t)nlm_hal_read_32bit_reg((uint64_t)mmio, 5);
+
+	if( phy&1 )
+		phy &= ~((u64)3);	//io bar
+	else{
+		//64bits physical address
+		if( ((phy>>1) & 3) == 2 )  phy |= (u64)phy1 << 32;
+		phy &= ~((u64)0x7F);
+	}
+
+	phy &= 0xFFFFFFFFFFULL; //40 bits phy addr
+	return (volatile u32*)(phy);
+}
+#endif
+
+
+static inline uint64_t __get_nae_soc_phys_base(int node, int nae_id)
+{
+	if(is_nlm_xlp9xx()){
+		if(nae_id==0)
+			return (uint64_t)xlp9xx_cpu_mem_base(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE0));
+		else
+			return (uint64_t)xlp9xx_cpu_mem_base(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE1));
+	}else{
+		if(nae_id)
+			return 0;
+		else{
+			uint64_t mask = ~0xf;
+			uint64_t pcie_cfg = 0x18000000 + XLP_PCIE_DEV_BASE(node, XLP_NAE);
+			return (mask & nlm_hal_read_32bit_reg(pcie_cfg,PCI_MEM_BAR_0));
+		}
+	}
+}
+
+static inline int bitcount(unsigned int n)
+{
+	register unsigned int tmp;
+
+	tmp = n - ((n >> 1) & 033333333333)
+	      - ((n >> 2) & 011111111111);
+	return ((tmp + (tmp >> 3)) & 030707070707) % 63;
+}
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* #ifndef _NLM_HAL_H_ */
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_cde.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_cde.h
new file mode 100644
index 0000000..cfe9b94
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_cde.h
@@ -0,0 +1,141 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef _NLM_HAL_CDE_H_
+#define _NLM_HAL_CDE_H_
+
+#include "nlm_hal.h"
+
+#define nlm_hal_9xx_write_cde_reg(reg, val) nlm_hal_write_32bit_reg \
+					(nlm_hal_get_dev_base \
+					(XLP_CDE_NODE, XLP_CDE_BUS_9XX, XLP_CDE_DEVICE, XLP_CDE_FUNC), \
+					 (reg), (val))
+#define nlm_hal_9xx_read_cde_reg(reg) nlm_hal_read_32bit_reg( \
+					nlm_hal_get_dev_base \
+					(XLP_CDE_NODE, XLP_CDE_BUS_9XX, XLP_CDE_DEVICE, XLP_CDE_FUNC), \
+					 (reg))
+
+#define nlm_hal_write_cde_reg(reg, val) nlm_hal_write_32bit_reg \
+					(nlm_hal_get_dev_base \
+					(XLP_CDE_NODE, XLP_CDE_BUS, XLP_CDE_DEVICE, XLP_CDE_FUNC), \
+					 (reg), (val))
+#define nlm_hal_read_cde_reg(reg) nlm_hal_read_32bit_reg( \
+					nlm_hal_get_dev_base \
+					(XLP_CDE_NODE, XLP_CDE_BUS, XLP_CDE_DEVICE, XLP_CDE_FUNC), \
+					 (reg))
+
+static __inline__ int nlm_hal_cde_make_fd_msg(uint64_t *msg0, uint64_t free_addr)
+{
+  int stid = XLP_STNID_CMP;
+
+  *msg0 = ( ((uint64_t)free_addr & 0xffffffffffULL)
+                );
+  return stid;
+}
+
+static __inline__ int nlm_hal_cde_make_cmp_msg(uint64_t *msg0, int readp, int op, int rtn_bkt,
+				   int length, uint64_t src_addr)
+{
+  int stid = XLP_STNID_CMP;
+  
+  *msg0 = ( ((uint64_t) readp <<63) |
+		((uint64_t) op << 62)  | 
+                ((uint64_t) rtn_bkt << 50) |
+                ((uint64_t) length << 40) |
+                ((uint64_t) src_addr & 0xffffffffffULL)
+                );
+  return stid;
+}
+
+
+static __inline__ uint64_t nlm_hal_cde_make_data_desc(int eof, int type, int sod, int sob, int save,
+					 int restore, int eob, int length, uint64_t src_addr)
+{
+  uint64_t src_desc = 0;
+  src_desc = (  ((uint64_t) eof << 63) | 
+                ((uint64_t) type << 61) |
+                ((uint64_t) sod << 60) |
+                ((uint64_t) sob << 59) |
+                ((uint64_t) save << 58) |
+                ((uint64_t) restore << 57) |
+                ((uint64_t) eob << 56) |
+                ((uint64_t) length << 40) |
+                ((uint64_t) src_addr & 0xffffffffffULL)
+                );
+  return src_desc;
+}
+static __inline__ int nlm_hal_9xxcde_make_cmp_msg(uint64_t *msg0, uint64_t *msg1, int readp, int op, int rtn_bkt,
+				   int length, uint64_t src_addr)
+{
+  int stid = XLP_STNID_CMP;
+  *msg0 = ( ((
+                ((uint64_t) readp <<63) |
+                ((uint64_t) op << 62)  | 
+                ((uint64_t) length << 40) |
+                ((uint64_t) src_addr & 0xffffffffffULL))
+                /*&0xc003ffffffffffff*/) );
+  *msg1 = ( ((
+                ((uint64_t) rtn_bkt << 50) |
+                ((uint64_t) 0x3ffffffffffff))
+                /*&0x7fffffffffffffff*/));
+  return stid;
+}
+
+
+/* Return error when parameter are invalid */
+static __inline__ int nlm_hal_cde_send_request_1(uint32_t dst_vc, uint64_t entry0)
+{
+	return nlm_hal_send_msg1(dst_vc, 0, entry0);
+
+}
+
+/* Return error when parameter are invalid */
+static __inline__ int nlm_hal_cde_send_request_2(uint32_t dst_vc, uint64_t entry0, uint64_t entry1)
+{
+	return nlm_hal_send_msg2(dst_vc, 0, entry0, entry1);
+
+}
+
+static __inline__ void nlm_hal_cde_receive_response(uint32_t rx_vc, uint64_t *entry0, uint64_t *entry1)
+{
+        uint32_t size = 0, code = 0, src = 0;
+/*        uint64_t entry0 = 0, entry1 = 0; */
+
+        nlm_hal_recv_msg2(rx_vc, &src, &size, &code, entry0, entry1);
+}
+#endif				/*#ifndef _NLM_HAL_CDE_H_ */
+
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_crypto.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_crypto.h
new file mode 100644
index 0000000..7a96261
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_crypto.h
@@ -0,0 +1,262 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef _NLM_HAL_CRYPTO_H_
+#define _NLM_HAL_CRYPTO_H_
+
+#define shift_lower_bits(x, bitshift, numofbits) ((unsigned long long)(x) << (bitshift))
+
+#define shift_lower_bits_mask(x, bitshift, numofbits) (((unsigned long long)(x) & ((1ULL << (numofbits)) - 1)) << (bitshift))
+
+/**
+* @file_name nlm_hal_crypto.c
+*/
+
+/**
+* @defgroup crypto  Crypto HAL apis
+* @brief Description about the crypto HAL level apis for RSA/ECC and SAE engines
+*/
+
+/**
+* @brief Generate crypto rsa/ecc fmn message entry 0
+* @ingroup crypto
+* - l3alloc: 1 casuses source data to transit through l3 cache
+* - type: ecc prime/ecc bin/ me/ micorcode load
+* - func: point mul/add etc
+* - srcaddr : source address
+*/
+static inline unsigned long long nlm_crypto_form_rsa_ecc_fmn_entry0(unsigned int l3alloc, unsigned int type, 
+		unsigned int func, unsigned long long srcaddr)
+{
+	return shift_lower_bits(l3alloc, 61, 1) | 
+		shift_lower_bits(type, 46, 7) |
+		shift_lower_bits(func, 40, 6) |
+		shift_lower_bits(srcaddr, 0, 40);
+}
+
+/**
+* @brief Generate crypto rsa/ecc fmn message entry 1
+* @ingroup crypto
+* - dstclobber: 1 causes data to be written as 64byte cacheline
+* - l3alloc: 1 caused data written to the dram is also copied to l3 cache
+* - fbvc: freeback message vc
+* - dstaddr : destination address
+*/
+static inline unsigned long long nlm_crypto_form_rsa_ecc_fmn_entry1(unsigned int dstclobber, unsigned int l3alloc, 
+		unsigned int fbvc, unsigned long long dstaddr)
+{
+	return shift_lower_bits(dstclobber, 62, 1) |
+		shift_lower_bits(l3alloc, 61, 1) |
+		shift_lower_bits(fbvc, 40, 12) |
+		shift_lower_bits(dstaddr, 0, 40);
+}
+
+/**
+* @brief Generate crypto control descriptor
+* @ingroup crypto
+* - hmac : 1 for hash with hmac 
+* - hashalg: see hash_alg enums
+* - hashmode: see hash_mode enums
+* - cipherhalg: see  cipher_alg enums
+* - ciphermode: see  cipher_mode enums
+* - arc4_cipherkeylen : length of arc4 cipher key, 0 is interpreted as 32 
+* - arc4_keyinit : 
+* - cfbmask : cipher text for feedback, 
+*           0(1 bit), 1(2 bits), 2(4 bits), 3(8 bits), 4(16bits), 5(32 bits), 6(64 bits), 7(128 bits)
+*/
+static inline unsigned long long nlm_crypto_form_pkt_ctrl_desc(unsigned int hmac, 
+		unsigned int hashalg,  unsigned int hashmode,
+		unsigned int cipheralg, unsigned int ciphermode,
+		unsigned int arc4_cipherkeylen, unsigned int arc4_keyinit, unsigned int cfbmask)
+{
+	return shift_lower_bits(hmac, 61, 1) | 
+		shift_lower_bits(hashalg, 52, 8) | 
+		shift_lower_bits(hashmode, 43, 8) | 
+		shift_lower_bits(cipheralg, 34, 8) | 
+		shift_lower_bits(ciphermode, 25, 8) | 
+		shift_lower_bits(arc4_cipherkeylen, 18, 5) | 
+		shift_lower_bits(arc4_keyinit, 17, 1) | 
+		shift_lower_bits(cfbmask, 0, 3);
+}
+/**
+* @brief Generate crypto packet descriptor 0
+* @ingroup crypto
+* - tls : 1(tls enabled) 0(tls disabled)
+* - hash_source : 1(encrypted data is sent to the auth engine) 0(plain data is sent to the auth engine)
+* - hashout_l3alloc : 1(auth output is transited through l3 cache)
+* - encrypt : 1(for encrypt) 0(for decrypt)
+* - ivlen : iv length in bytes
+* - hashdst_addr : hash out physical address, byte aligned
+*/
+static inline unsigned long long nlm_crypto_form_pkt_desc0(unsigned int tls, unsigned int hash_source, 
+		unsigned int hashout_l3alloc,
+		unsigned int encrypt, unsigned int ivlen, unsigned long long hashdst_addr)
+{
+	return (shift_lower_bits(tls, 63, 1) |
+		shift_lower_bits(hash_source, 62, 1) |
+		shift_lower_bits(hashout_l3alloc, 60, 1) |
+		shift_lower_bits(encrypt, 59, 1) |
+		shift_lower_bits_mask((ivlen - 1), 41, 16) |
+		shift_lower_bits(hashdst_addr, 0, 40));
+}
+
+/**
+* @brief Generate crypto packet descriptor 1
+* @ingroup crypto
+* - cipherlen : cipher length in bytes
+* - hashlen : hash length in bytes
+*/
+static inline unsigned long long nlm_crypto_form_pkt_desc1(unsigned int cipherlen, unsigned int hashlen)
+{
+	return shift_lower_bits_mask((cipherlen - 1), 32, 32)
+		| shift_lower_bits_mask((hashlen - 1), 0, 32);
+}	
+
+/**
+* @brief Generate crypto packet descriptor 2
+* @ingroup crypto
+* - ivoff : iv offset, offset from start of src data addr
+* - ciperbit_cnt : number of valid bits in the last input byte to the cipher, 0(8 bits), 1(1 bit)..7(7 bits)
+* - cipheroff : cipher offset, offset from start of src data addr
+* - hashbit_cnt : number of valid bits in the last input byte to the auth, 0(8 bits), 1(1 bit)..7(7 bits)
+* - hashclobber : 1(hash output will be written as multiples of cachelines, no read modify write)
+* - hashoff : hash offset, offset from start of src data addr
+*/
+
+static inline unsigned long long nlm_crypto_form_pkt_desc2(unsigned int ivoff, unsigned int cipherbit_cnt, 
+		unsigned int cipheroff, 
+		unsigned int hashbit_cnt, unsigned int hashclobber, unsigned int hashoff)
+{
+	return shift_lower_bits(ivoff , 45, 16)
+		| shift_lower_bits(cipherbit_cnt, 42, 3) 
+		| shift_lower_bits(cipheroff, 22, 16)
+		| shift_lower_bits(hashbit_cnt, 19, 3)
+		| shift_lower_bits(hashclobber, 18, 1)
+		| shift_lower_bits(hashoff, 0, 16);
+}
+
+/**
+* @brief Generate crypto packet descriptor 3
+* @ingroup crypto
+* - designer_vc : designer freeback fmn destination id
+* - taglen : length in bits of the tag generated by the auth engine
+*          md5(128 bits), sha1(160), sha224(224), sha384(384), sha512(512), Kasumi(32), snow3g(32), gcm(128)
+* - hmacpad : 1 if hmac padding is already done 
+*/
+static  inline unsigned long long nlm_crypto_form_pkt_desc3(unsigned int designer_vc, unsigned int taglen, 
+	unsigned int arc4_state_save_l3, unsigned int arc4_save_state, unsigned int hmacpad)
+{
+	return shift_lower_bits(designer_vc, 48, 16)
+		| shift_lower_bits(taglen, 11, 16)
+		| shift_lower_bits(arc4_state_save_l3, 8, 1)
+		| shift_lower_bits(arc4_save_state, 6, 1)
+		| shift_lower_bits(hmacpad, 5, 1);
+}
+
+/**
+* @brief Generate crypto packet descriptor 4
+* @ingroup crypto
+* - srcfraglen : length of the source fragment(header + data + tail) in bytes
+* - srcfragaddr : physical address of the srouce fragment
+*/
+static inline unsigned long long nlm_crypto_form_pkt_desc4(unsigned int srcfraglen, unsigned long long srcfragaddr )
+{
+	return shift_lower_bits_mask((srcfraglen - 1), 48, 16)
+		| shift_lower_bits(srcfragaddr, 0, 40);
+}
+
+/**
+* @brief Generate crypto packet descriptor 5
+* @ingroup crypto
+* - dstfraglen : length of the dst fragment(header + data + tail) in bytes
+* - chipherout_l3alloc : 1(cipher output is transited through l3 cache)
+* - cipherclobber : 1(cipher output will be written as multiples of cachelines, no read modify write)
+* - chiperdst_addr : physical address of the cipher destination address
+*/
+static inline unsigned long long nlm_crypto_form_pkt_desc5(unsigned int dstfraglen, unsigned int cipherout_l3alloc, 
+	       unsigned int cipherclobber, unsigned long long cipherdst_addr)
+
+{
+	return shift_lower_bits_mask((dstfraglen - 1), 48, 16)
+		| shift_lower_bits(cipherout_l3alloc, 46, 1) 
+		| shift_lower_bits(cipherclobber, 41, 1)
+		| shift_lower_bits(cipherdst_addr, 0, 40);
+}
+
+/**
+  * @brief Generate crypto packet fmn message entry 0
+  * @ingroup crypto
+  * - freeback_vc: freeback response destination address
+  * - designer_fblen : Designer freeback length, 1 - 4
+  * - designerdesc_valid : designer desc valid or not
+  * - cipher_keylen : cipher key length in bytes
+  * - ctrldesc_addr : physicall address of the control descriptor
+  */
+static inline unsigned long long  nlm_crypto_form_pkt_fmn_entry0(unsigned int freeback_vc, unsigned int designer_fblen,
+		unsigned int designerdesc_valid, unsigned int cipher_keylen, unsigned long long cntldesc_addr)
+{
+	return shift_lower_bits(freeback_vc, 48, 16)
+		| shift_lower_bits_mask(designer_fblen - 1, 46, 2)
+		| shift_lower_bits(designerdesc_valid, 45, 1)
+		| shift_lower_bits_mask(((cipher_keylen + 7) >> 3), 40, 5)
+		| shift_lower_bits(cntldesc_addr >> 6, 0, 34);
+}
+
+/**
+  * @brief Generate crypto packet fmn message entry 1
+  * @ingroup crypto
+  * - arc4load_state : 1 if load state required 0 otherwise
+  * - hash_keylen : hash key length in bytes
+  * - pktdesc_size : packet descriptor size in bytes
+  * - pktdesc_addr : physicall address of the packet descriptor
+  */
+static inline unsigned long long nlm_crypto_form_pkt_fmn_entry1(unsigned int arc4load_state, unsigned int hash_keylen,
+		unsigned int pktdesc_size, unsigned long long pktdesc_addr)
+{
+	return shift_lower_bits(arc4load_state, 63, 1)
+		| shift_lower_bits_mask(((hash_keylen + 7) >> 3), 56, 5)
+		| shift_lower_bits_mask(((pktdesc_size >> 4) - 1), 43, 12)
+		| shift_lower_bits(pktdesc_addr >> 6, 0, 34);
+}
+
+enum chip_specific_features { 
+	INIT_DONE = 0x1,
+	ZUC = 0x2, 
+	DES3_KEY_SWAP = 0x4
+};
+
+#endif	
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_kbp.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_kbp.h
new file mode 100644
index 0000000..75c5362
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_kbp.h
@@ -0,0 +1,1037 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef _NLM_HAL_KBP_H_
+#define _NLM_HAL_KBP_H_
+#include "nlm_hal_nae.h"
+#include "nlm_hal_xlp_dev.h"
+
+#define KBP_CTL                   0x40
+#define KBP_INT                   0x41
+#define KBP_ERR_CNT               0x42
+#define LA_MEM_USAGE              0x43
+#define KBP_INT_MASK              0x44
+#define KBP_REQ_ID                0x45
+#define KBP_REQ_INDEX             0x46
+#define TO_LEV2_LOW               0x47
+#define TO_LEV2_HIGH              0x48
+#define TO_HDR                    0x49
+#define TO_DR0_LOW                0x4A
+#define TO_DR0_HIGH               0x4B
+#define TO_DR1_LOW                0x4C
+#define TO_DR1_HIGH               0x4D
+#define IODI_TIMEOUT              0x4E
+#define KBP_PKT_CNT_CTL           0x4F
+#define KBP_PKT_TX_CNT            0x50
+#define KBP_PKT_RX_CNT            0x51
+#define KBP_RSP_ERROR_PAR         0x52
+#define KBP_REQ_TEST_HEAD         0x53
+#define KBP_RSP_TEST_HEAD         0x54
+#define LA_INT                    0x55
+#define LA_INT_MASK               0x56
+#define LA_RX_DIAGWORD            0x57
+#define LA_RX_SYNC                0x58
+#define LA_ERROR1                 0x59
+#define LA_ERROR2                 0x5A
+#define LA_TX_ENABLE              0x5B
+#define LA_TX_EN                  0x01
+#define LA_BAD_LANE               0x5C
+#define LA_TX_STAT                0x5D
+#define LA_TX_RLIM                0x5E
+#define LA_SETUP                  0x5F
+#define LA_LEN                    0x60
+#define SER_CTL                   0x61
+#define SER_REG0                  0x62
+#define SER_REGALL                0x63
+#define IO_CONFIG_SWAP_DIS        0x64
+#define STATE_RST                 0x65
+#define PKT_ERR_LO                0x66
+#define PKT_ERR_HI                0x67
+#define RD_EX_BASE                0x68
+#define RD_EX_LIMIT               0x69
+#define TX_SERR_MSG_0             0x6A
+#define TX_SERR_MSG_1             0x6B
+#define TX_SERR_MSG_2             0x6C
+#define TX_SERR_MSG_3             0x6D
+#define TX_MERR_MSG_0             0x6E
+#define TX_MERR_MSG_1             0x6F
+#define TX_MERR_MSG_2             0x70
+#define TX_MERR_MSG_3             0x71
+#define RX_ERR_MSG_0              0x72
+#define RX_ERR_MSG_1              0x73
+#define RX_ERR_MSG_2              0x74
+#define RX_ERR_MSG_3              0x75
+#define IODI_SLAVE_RD_ERR_MSG_0   0x76
+#define IODI_SLAVE_RD_ERR_MSG_1   0x77
+#define IODI_SLAVE_RD_ERR_MSG_2   0x78
+#define IODI_SLAVE_RD_ERR_MSG_3   0x79
+#define IODI_SLAVE_RD_ERR_MSG_4   0x7A
+#define IODI_SLAVE_RD_ERR_MSG_5   0x7B
+#define IODI_SLAVE_RD_ERR_MSG_6   0x7C
+#define IODI_SLAVE_RD_ERR_MSG_7   0x7D
+
+#define XLP_PCIE_KBP_DEV   1 /* pcie device number */
+#define KBP_START_LANE     2 /* func number     */
+
+#define DEFAULT_CPLD_MEM_BAR   0x170000
+
+/*KBP PCS common config (CSM) register */
+
+#define KBP_RX_LANE_0_15_EN             0x8100
+#define KBP_RX_LANE_16_23_EN            0x8101
+#define KBP_TX_LANE_0_11_EN             0x8102
+#define KBP_CRX_LANE_0_11_EN            0x8103
+#define KBP_CTX_LANE_0_15_EN            0x8104
+#define KBP_CTX_LANE_16_23_EN           0x8105
+#define KBP_RX_FRM_LEN                  0x8106
+#define KBP_TX_FRM_LEN                  0x8107
+#define KBP_LANE_SWAP                   0x8108
+#define KBP_RX_FIFO_THRD                0x8109
+#define KBP_TX_FIFO_THRD                0x810A
+#define KBP_TX_BUR_SHORT                0x810B
+#define KBP_RX_TX_EN                    0x810C
+#define KBP_TX_SER_0_11_SQCH            0x8117
+#define KBP_CTX_SER_0_15_SQCH           0x8118
+#define KBP_CTX_SER_16_23_SQCH          0x8119
+#define KBP_RXTX_CLK_SEL                0x811A
+#define KBP_SER_SW_RST                  0x811B
+#define KBP_GL_SW_RST                   0x811C
+#define KBP_SPEED_SEL                   0x811D
+#define KBP_COM_STATUS                  0x8180
+#define KBP_GEN_STATUS0                 0x8181
+#define KBP_GEN_STATUS1                 0x8182
+#define KBP_GEN_STATUS2                 0x8183
+#define KBP_GEN_STATUS3                 0x8184
+
+#define KBP_PCS_RX_STAT                 0x8300
+#define KBP_PCS_RX_WD_ALGN_STAT         0x8301
+#define KBP_PCS_RX_WD_ERR               0x8302
+#define KBP_PCS_RX_BLK_ERR              0x8303
+#define KBP_PCS_RX_FRM_ERR              0x8304
+#define KBP_PCS_RX_DSC_SYNC_ERR         0x8305
+#define KBP_PCS_RX_DSC_SGL_ERR          0x8306
+#define KBP_PCS_RX_FIFO_ERR             0x8307
+#define KBP_PCS_RX_CRC32_ERR            0x8308
+
+#ifndef __ASSEMBLY_
+#define MDIO_STATUS_RETRIES             20000
+
+#define EXT_XG_MDIO_CTRL_RST_POS        30
+#define EXT_XG_MDIO_CTRL_SMP_POS        20
+
+#define MAKE_MDIO_CTRL(x1, x2, x3, x4, x5, x6, x7, x8, x9)     (\
+          (x1 << EXT_XG_MDIO_CTRL_OP_POS)        \
+        | (x2 << EXT_XG_MDIO_CTRL_PHYADDR_POS)   \
+        | (x3 << EXT_XG_MDIO_CTRL_DEVTYPE_POS)   \
+        | (x4 << EXT_XG_MDIO_CTRL_TA_POS)        \
+        | (x5 << EXT_XG_MDIO_CTRL_MIIM_POS)      \
+        | (x6 << EXT_XG_MDIO_CTRL_LOAD_POS)      \
+        | (x7 << EXT_XG_MDIO_CTRL_SMP_POS)       \
+        | (x8 << EXT_XG_MDIO_CTRL_XDIV_POS)      \
+        | (x9 << EXT_XG_MDIO_CTRL_RST_POS)       )
+
+enum KBP_MDIO_DEV {
+    MDIO_DEV_CSM = 1,
+    MDIO_DEV_RX_0_3 = 2,
+    MDIO_DEV_RX_4_7 = 3,
+    MDIO_DEV_RX_8_11 = 4,
+    MDIO_DEV_RX_12_15 = 5,
+    MDIO_DEV_RX_16_19 = 6,
+    MDIO_DEV_RX_20_23 = 7,
+    MDIO_DEV_CRX_0_3 = 8,
+    MDIO_DEV_CRX_4_7 = 9,
+    MDIO_DEV_CRX_8_11 = 10,
+    MDIO_DEV_TX_0_3 = 11,
+    MDIO_DEV_TX_4_7 = 12,
+    MDIO_DEV_TX_8_11 = 13,
+    MDIO_DEV_CTX_0_3 = 14,
+    MDIO_DEV_CTX_4_7 = 15,
+    MDIO_DEV_CTX_8_11 = 16,
+    MDIO_DEV_CTX_12_15 = 17,
+    MDIO_DEV_CTX_16_19 = 18,
+    MDIO_DEV_CTX_20_23 = 19,
+    MDIO_DEV_RX_BCAST = 30,
+    MDIO_DEV_TX_BCAST = 31,
+};
+
+
+/**waste cpu clock cycle to achieve delay in time
+ @param x - number of 64-bit add operation to perform
+ @return None
+ */
+__inline__ void KBP_DELAY( uint64_t x ){
+    volatile uint64_t i = 0;
+    volatile uint64_t j = 0;
+    for( i = 0; i < x ; i++ ){
+        j++;
+    } /* end for */
+} /* end KBP_DELAY */
+
+__inline__ void WAIT_MDIO_BSY_CLEAR( uint32_t node ){
+    volatile uint64_t i = 0;
+    for( i = 0; i < MDIO_STATUS_RETRIES ; i++ ){
+        if( ( nlm_hal_read_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_RD_STAT ) & EXT_XG_MDIO_STAT_MBSY ) == 0 )
+            break;
+        /* end if */
+    } /* end for */
+} /* end WAIT_MDIO_BSY_CLEAR; */
+
+/**read from ILA register on XLP
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param func - function number of register in PCIe space. usually 0x2
+ @param reg_addr - register address
+ @return 32-bit register data
+ */
+__inline__ uint32_t nlm_hal_ila_reg_read( uint32_t node, uint32_t func, uint32_t reg_addr ){
+    volatile uint64_t mmio = nlm_hal_get_dev_base( node, 0, XLP_PCIE_KBP_DEV, func );
+    return nlm_hal_read_32bit_reg( mmio, reg_addr );
+} /* end nlm_hal_ila_reg_read */
+
+/**write to ILA register on XLP
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param func - function number of register in PCIe space. usually 0x2
+ @param reg_addr - register address
+ @param reg_data - register data
+ @return None
+ */
+__inline__ void nlm_hal_ila_reg_write( uint32_t node, uint32_t func, uint32_t reg_addr, uint32_t reg_data ){
+    volatile uint64_t mmio = nlm_hal_get_dev_base( node, 0, XLP_PCIE_KBP_DEV, func );
+    nlm_hal_write_32bit_reg( mmio, reg_addr, reg_data );
+} /* end nlm_hal_ila_reg_write */
+
+/**read from 8-bit SerDes register for ILA
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param lane - SerDes lane index
+ @param reg_addr - register address
+ @return 8-bit register data
+ */
+static __inline__ uint8_t nlm_hal_ila_serdes_reg_read( uint32_t node, uint32_t lane, uint8_t reg_addr ){
+    uint32_t serdes_select = 0x1 << lane;
+    uint32_t serdes_reg_data_wr = 0x00;
+
+    serdes_reg_data_wr = ( serdes_select << 16 ) | ( (uint32_t)reg_addr << 8 ) | 0x00;
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, SER_REG0, serdes_reg_data_wr );
+    return nlm_hal_ila_reg_read( node, KBP_START_LANE, SER_REGALL );
+
+} /* end nlm_hal_ila_serdes_reg_read */
+
+/**write to 8-bit SerDes register for ILA
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param lane - SerDes lane index
+ @param reg_addr - register address
+ @param reg_data - register data
+ @return None
+ */
+static __inline__ void nlm_hal_ila_serdes_reg_write( uint32_t node, uint32_t lane, uint8_t reg_addr, uint8_t reg_data ){
+    uint32_t serdes_select = 0x1 << lane;
+    uint32_t serdes_reg_data_wr = 0x00;
+
+    serdes_reg_data_wr = ( serdes_select << 16 ) | ( (uint32_t)reg_addr << 8 ) | (uint32_t)reg_data;
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, SER_REG0, serdes_reg_data_wr );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, SER_REGALL, serdes_reg_data_wr );
+
+} /* end nlm_hal_ila_serdes_reg_write */
+
+/**perform read on list of address-data pair of 8-bit SerDes registers for given number of SerDes lanes starting from lane 0 for ILA
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param number_of_lanes - number of lanes to write register
+ @param number_of_addr - number of register address per SerDes lane
+ @param reg_addr - array of list of register address
+ @param reg_data - array to store read data
+ @return None
+ * e.x. nlm_hal_ila_serdes_lanes_reg_read( 0, 4, 2, [0x64, 0x65], [0, 0, 0, 0, 0, 0, 0, 0] );
+ *      read SerDes register 0x64 and 0x65 for SerDes lane 0, 1, 2 and 3
+ *      reg_data = [ 0x64 data of lane 0, 0x64 data of lane 1, 0x64 data of lane 2, 0x64 data of lane 3,
+ *                   0x65 data of lane 0, 0x65 data of lane 1, 0x65 data of lane 2, 0x65 data of lane 3 ]
+ */
+static __inline__ void nlm_hal_ila_serdes_lanes_reg_read( uint32_t node, uint32_t number_of_lanes, uint32_t number_of_addr, uint8_t* reg_addr, uint8_t* reg_data ){
+    uint32_t serdes_counter = 0x00;
+    uint32_t reg_counter = 0x00;
+
+    for( reg_counter = 0x0; reg_counter < number_of_addr ; reg_counter++ ){
+        for( serdes_counter = 0; serdes_counter < number_of_lanes ; serdes_counter++ ){
+            reg_data[reg_counter * number_of_lanes + serdes_counter] = nlm_hal_ila_serdes_reg_read( node, serdes_counter, reg_addr[reg_counter] );
+        } /* end for */
+    } /* end for */
+
+} /* end nlm_hal_ila_serdes_lanes_reg_read */
+
+/**perform write on list of address-data pair of 8-bit SerDes registers for given number of SerDes lanes starting from lane 0 for ILA
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param number_of_lanes - number of lanes to write register
+ @param number_of_addr - number of register address per SerDes lane
+ @param reg_addr - array of list of register address
+ @param reg_data - array of list of register data
+ @return None
+ * e.x. nlm_hal_ila_serdes_lanes_reg_write( 0, 4, 2, [0x23,0x64], [0xBE,0xEF] )
+ *      SerDes lane 0 register 0x23 data becomes 0xBE
+ *      SerDes lane 0 register 0x64 data becomes 0xEF
+ *      SerDes lane 1 register 0x23 data becomes 0xBE
+ *      SerDes lane 1 register 0x64 data becomes 0xEF
+ *      SerDes lane 2 register 0x23 data becomes 0xBE
+ *      SerDes lane 2 register 0x64 data becomes 0xEF
+ *      SerDes lane 3 register 0x23 data becomes 0xBE
+ *      SerDes lane 3 register 0x64 data becomes 0xEF
+ */
+static __inline__ void nlm_hal_ila_serdes_lanes_reg_write( uint32_t node, uint32_t number_of_lanes, uint32_t number_of_addr, uint8_t* reg_addr, uint8_t* reg_data ){
+    uint32_t serdes_counter = 0x00;
+    uint32_t reg_counter = 0x00;
+
+    for( reg_counter = 0x0; reg_counter < number_of_addr ; reg_counter++ ){
+        for( serdes_counter = 0; serdes_counter < number_of_lanes ; serdes_counter++ ){
+            nlm_hal_ila_serdes_reg_write( node, serdes_counter, reg_addr[reg_counter], reg_data[reg_counter * number_of_lanes + serdes_counter] );
+        } /* end for */
+    } /* end for */
+
+} /* end nlm_hal_ila_serdes_lanes_reg_write */
+
+#ifndef CONFIG_N511
+/**read from 16-bit cpld chip-select 0x2 registers on EVP board for KBP
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param reg_addr - register address
+ @return 16-bit register data
+ */
+uint16_t nlm_hal_kbp_cpld_reg_read( uint32_t node, uint16_t addr ){
+    volatile uint64_t mmio = nlm_hal_get_dev_base( node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NOR );
+    volatile uint64_t cpld_base = nlm_hal_read_32bit_reg( mmio, 0x42 );
+    volatile uint16_t data = 0;
+
+    if( cpld_base != DEFAULT_CPLD_MEM_BAR )
+        nlm_hal_write_32bit_reg( mmio, 0x42, DEFAULT_CPLD_MEM_BAR );
+    /* end if */
+
+    data = nlm_hal_read_16bit_reg( ( cpld_base << 8 ), ( addr >> 1 ) );
+
+    /* NetOS and HELinux needs byte swap */
+#if defined(NLM_HAL_NETOS) | defined(NLM_HAL_LINUX_USER)
+    data = ( data << 8 ) | ( data >> 8 );
+#endif
+
+    return data;
+
+} /* end nlm_hal_kbp_cpld_reg_read */
+
+/**write to 16-bit cpld chip-select 0x2 registers on EVP board for KBP
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param reg_addr - register address
+ @param data - register data
+ @return None
+ */
+void nlm_hal_kbp_cpld_reg_write( uint32_t node, uint16_t addr, uint16_t data ){
+    volatile uint64_t mmio = nlm_hal_get_dev_base( node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NOR );
+    volatile uint64_t cpld_base = nlm_hal_read_32bit_reg( mmio, 0x42 );
+
+    if( cpld_base != DEFAULT_CPLD_MEM_BAR )
+        nlm_hal_write_32bit_reg( mmio, 0x42, DEFAULT_CPLD_MEM_BAR );
+    /* end if */
+
+    /* NetOS and HELinux needs byte swap */
+#if defined(NLM_HAL_NETOS) | defined(NLM_HAL_LINUX_USER)
+    data = ( data << 8 ) | ( data >> 8 );
+#endif
+
+    nlm_hal_write_16bit_reg( ( cpld_base << 8 ), ( addr >> 1 ), data );
+} /* end nlm_hal_kbp_cpld_reg_write */
+
+/**reset KBP MDIO interface
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @return None
+ */
+static __inline__ void nlm_hal_kbp_mdio_reset( uint32_t node ){
+    uint32_t reg_data;
+
+    reg_data = nlm_hal_read_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL ); /*0x25*/
+    reg_data = 0x04000000;
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, reg_data );
+    reg_data = nlm_hal_read_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL );
+
+} /* end nlm_hal_kbp_mdio_reset */
+
+/**read from KBP MDIO register
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param regaddr - register address
+ @param dev_id - MDIO device id
+ @return register data
+ */
+static __inline__ uint32_t nlm_hal_kbp_mdio_read( uint32_t node, uint32_t regaddr, uint32_t dev_id ){
+
+    uint32_t data = 0;
+    volatile uint32_t status;
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL_DATA, regaddr );
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    /* now the address has been written in indirectly*/
+    /* Now get the load bit to be 0 ( bit 19) */
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(3, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(3, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    /* get the load bit to be 0 ( bit 19) */
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    status = nlm_hal_read_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_RD_STAT ); /* 0x27*/
+    return ( status & 0xFFFF );
+} /* end nlm_hal_kbp_mdio_read */
+
+/**write to KBP MDIO register
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param regaddr - register address
+ @param indirect_data - register data
+ @param dev_id - MDIO device id
+ @return None
+ */
+static __inline__ void nlm_hal_kbp_mdio_write( uint32_t node, uint32_t regaddr, uint32_t indirect_data, uint32_t dev_id ){
+    uint32_t data = 0;
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL_DATA, regaddr );
+    /*0x26*/
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+    /*0x25*/
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    /* now the address has been written in indirectly */
+    /* next write in the data , but before that get the load bit to be 0 ( bit 19)*/
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL_DATA, indirect_data );
+
+    /* for write bits[3:2] is 01 */
+    data = MAKE_MDIO_CTRL(1, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(1, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    /* next write in the data , but before that get the load bit to be 0 ( bit 19) */
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+} /* end nlm_hal_kbp_mdio_write */
+
+#else
+#define RST_CTL_0       0x8
+
+#define MI_BSL          0x1d
+#define MI_CSR          0x20
+#define MI_MCTL         0x21
+#define MI_AD0          0x22
+#define MI_AD1          0x23
+#define MI_DEVREG_AD    0x24
+#define MI_PRTPHY_AD    0x25
+
+static void n511_cpld_wr(int offset, char data)
+{
+  volatile static char *n511_cpld_base;
+  n511_cpld_base = (char *)0xffffffffb7000000ULL;
+  n511_cpld_base[offset] = data;
+}
+
+static char n511_cpld_rd(int offset)
+{
+  volatile static char *n511_cpld_base;
+  n511_cpld_base = (char *)0xffffffffb7000000ULL;
+  return n511_cpld_base[offset];
+}
+
+/* N511 CPLD MDIO operations */
+/* #define MI_BSL          0x1d */
+/*      7       6       5       4       3       2       1       0 */
+/*      res     res     res     res     Sel3    Sel2    Sel1    Sel0 */
+/* Select Map */
+/*  000 = NL11000 */
+/*  001 = NLP1042 XPHY 0 / 1 */
+/*  010 = NLP1042 XPHY 2 / 3 */
+/*  011 = Mgmt Phy0 */
+/*  100 = Mgmt Phy1 */
+/*  101-111 Reserved */
+inline void n511_cpld_mdio_bus_sel(char bus)
+{
+  n511_cpld_wr(MI_BSL, bus);
+}
+
+/* #define MI_MCTL         0x21 */
+/*      7       6       5       4       3       2       1       0 */
+/*      C22     res     Clk1    Clk0    obe     mdc     mdio_0  mdio_1 */
+/* Clk Map */
+/*  00 = Manual (bit bang) */
+/*  01 = 50 Mhz / 32 */
+/*  10 = 50 Mhz / 16 */
+/*  11 = 50 Mhz / 8 */
+inline void n511_cpld_mdio_set_clk(char clock)
+{
+  n511_cpld_wr(MI_MCTL, (clock<<4));
+}
+
+
+static __inline__ void mdio_reset(void)
+{
+  return;
+}
+
+/* #define MI_AD0          0x22 */
+/* #define MI_AD1          0x23 */
+/* #define MI_DEVREG_AD    0x24 */
+/* #define MI_PRTPHY_AD    0x25 */
+static __inline__ void mdio_write(int regidx, int val, int devaddr)
+{
+  int i;
+  uint8_t clock = 2;
+  char bus = 0;
+  char phyaddr = 1;
+
+  n511_cpld_mdio_set_clk(clock);
+  n511_cpld_mdio_bus_sel(bus);
+
+  /* Address Cycle */
+  n511_cpld_wr(MI_AD1, (uint8_t)(regidx>>8));
+  n511_cpld_wr(MI_AD0, (uint8_t)(regidx & 0xff));
+  n511_cpld_wr(MI_DEVREG_AD, devaddr);
+  n511_cpld_wr(MI_PRTPHY_AD, phyaddr);
+  /* 00 Mgmt Interface Address */
+  /* Write start bit only */
+  n511_cpld_wr(MI_CSR, 1);
+  /* Wait for start bit to auto-clear */
+  i = 0;
+  while (n511_cpld_rd(MI_CSR) & 0x1) {
+    nlm_udelay(100);
+    if (i++ > 10000) {
+      printf("N511 CPLD MDIO timeout on Address cycle\n");
+      return;
+    }
+  }
+
+  /* Data Cycle */
+  /* Write data regs */
+  n511_cpld_wr(MI_AD1, (uint8_t)(val>>8));
+  n511_cpld_wr(MI_AD0, (uint8_t)(val & 0xff));
+
+  /* 01 Mgmt Interface Write */
+  /* Write op 1 and start bit */
+  n511_cpld_wr(MI_CSR, (1 << 4) | 0x1);
+  /* Wait for start bit to auto-clear */
+  i = 0;
+  while (n511_cpld_rd(MI_CSR) & 0x1) {
+    nlm_udelay(100);
+    if (i++ > 10000) {
+      printf("N511 CPLD MDIO timeout on Write cycle\n");
+      return;
+    }
+  }
+  return;
+}
+
+static __inline__ int mdio_read(int regidx, int devaddr)
+{
+  int i;
+  uint8_t clock = 2;
+  uint16_t rdval;
+  char bus = 0;
+  char phyaddr = 1;
+
+  n511_cpld_mdio_set_clk(clock);
+  n511_cpld_mdio_bus_sel(bus);
+
+  /* Address Cycle */
+  n511_cpld_wr(MI_AD1, (uint8_t)(regidx>>8));
+  n511_cpld_wr(MI_AD0, (uint8_t)(regidx & 0xff));
+  n511_cpld_wr(MI_DEVREG_AD, devaddr);
+  n511_cpld_wr(MI_PRTPHY_AD, phyaddr);
+  /* 00 Mgmt Interface Address */
+  /* Write start bit only */
+  n511_cpld_wr(MI_CSR, 1);
+  /* Wait for start bit to auto-clear */
+  i = 0;
+  while (n511_cpld_rd(MI_CSR) & 0x1) {
+    nlm_udelay(100);
+    if (i++ > 10000) {
+      printf("N511 CPLD MDIO timeout on Address cycle\n");
+      return 0xffff;
+    }
+  }
+
+  /* Data Cycle */
+  /* 11 Mgmt Interface Read */
+  /* Write op 3 and start bit */
+  n511_cpld_wr(MI_CSR, (3 << 4) | 0x1);
+  /* Wait for start bit to auto-clear */
+  i = 0;
+  while (n511_cpld_rd(MI_CSR) & 0x1) {
+    nlm_udelay(100);
+    if (i++ > 10000) {
+      printf("N511 CPLD MDIO timeout on Read cycle\n");
+      return 0xffff;
+    }
+  }
+  rdval = (n511_cpld_rd(MI_AD1) << 8) | (n511_cpld_rd(MI_AD0));
+  return rdval;
+}
+#endif
+/**perform KBP System-ON Reset Sequence
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param number_of_lane - number of SerDes lane to use
+ @param serdes_speed_in_gbps - SerDes lane speed
+ @param tx_metaframe_length - tx meta frame
+ @param rx_metaframe_length - rx meta frame
+ @return None
+ * meta frame is for synchronization
+ */
+static __inline__ void nlm_hal_kbp_system_on_reset( uint32_t node, uint32_t number_of_lane, uint32_t serdes_speed_in_gbps, uint16_t tx_metaframe_length, uint16_t rx_metaframe_length ){
+    volatile uint16_t cpld_data = 0;
+
+    nlm_print( "Perform KBP System-ON Reset Sequence...\n" );
+#ifdef CONFIG_N511
+    uint8_t t8;
+
+    nlm_print( "N511 CPLD reading RST_CTL_0\n");
+    t8 = n511_cpld_rd(RST_CTL_0);
+    nlm_print( "N511 CPLD read RST_CTL_0 0x%x\n", t8);
+    t8 |= 0x08;
+    n511_cpld_wr(RST_CTL_0, t8);
+
+    KBP_DELAY(50000);
+
+    t8 &= ~0x08;
+    n511_cpld_wr(RST_CTL_0, t8);
+
+    KBP_DELAY(50000);
+
+    nlm_print( "N511 CPLD KBP Reset complete\n" );
+#else /* CONFIG_N511 */
+    /* 1. Ensure SRST_L & CRST_L are de-asserted (held high) before assert (pull low) SRST_L & CRST_L */
+    cpld_data = nlm_hal_kbp_cpld_reg_read( node, 0x02 );
+    /* de-assert SRST and CRST */
+    cpld_data |= 0x0104;
+    nlm_hal_kbp_cpld_reg_write( node, 0x02, cpld_data );
+    /* wait for a while */
+    KBP_DELAY( 50000 );
+
+    cpld_data = nlm_hal_kbp_cpld_reg_read( node, 0x02 );
+    /* assert low SRST and CRST */
+    cpld_data &= 0xFEFB;
+    nlm_hal_kbp_cpld_reg_write( node, 0x02, cpld_data );
+
+    /* 2. Wait for 3.0us and de-assert SRST_L */
+    /* wait for some long time to ensure sufficient wait time even when CPU runs at 1.6 GHz */
+    KBP_DELAY( 50000 );
+
+    cpld_data = nlm_hal_kbp_cpld_reg_read( node, 0x02 );
+    /* de-assert SRST */
+    cpld_data |= 0x0004;
+    nlm_hal_kbp_cpld_reg_write( node, 0x02, cpld_data );
+#endif
+    /* 3. If MDIO-based device configuration is required, follow the steps as outlined in Section 6.7 */
+    uint16_t reg_data = 0;
+
+    /*    Device Configuration using MDIO */
+    nlm_hal_kbp_mdio_reset( node );
+
+    /*    1. Squelch the Transmit SerDes using "TX_SerDes_11_0_squelch", "CTX_SerDes_15_0_squelch", and "CTX_SerDes_23_16_squelch" registers. See Table 18 on page 39 */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_TX_SER_0_11_SQCH, 0x0FFF, MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_CTX_SER_0_15_SQCH, 0xFFFF, MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_CTX_SER_16_23_SQCH, 0x00FF, MDIO_DEV_CSM );
+
+    /*    2. Disable RX and TX PCS using "Global RX / TX Enable" register. See Table 18 on page 39 */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_RX_TX_EN, 0x0000, MDIO_DEV_CSM );
+
+    /*    3. Reset SerDes-Initialization state machine, Core PLL and Core Logic by writing 16'h7 to "Global SW Reset" register. See Table 18 on page 39 */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_GL_SW_RST, 0x0007, MDIO_DEV_CSM );
+
+    /*    4. Configure MDIO registers */
+    KBP_DELAY( 100 );
+
+    if( serdes_speed_in_gbps == 6 ){
+        reg_data = nlm_hal_kbp_mdio_read( node, KBP_SPEED_SEL, MDIO_DEV_CSM );
+        reg_data = ( reg_data & 0xFF88 ) | 0x44;
+        nlm_hal_kbp_mdio_write( node, KBP_SPEED_SEL, reg_data, MDIO_DEV_CSM );
+    }else{
+        reg_data = nlm_hal_kbp_mdio_read( node, KBP_SPEED_SEL, MDIO_DEV_CSM );
+        reg_data = ( reg_data & 0xFF88 ) | 0x00;
+        nlm_hal_kbp_mdio_write( node, KBP_SPEED_SEL, reg_data, MDIO_DEV_CSM );
+        /* workaround for NL11000 RA01 KBP running 3.125 Gbps */
+        uint16_t counter = 0;
+        for( counter = 0; counter < 4 ; counter++ ){
+            nlm_hal_kbp_mdio_write( node, 0x120, 0x0043, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x130, 0x0043, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x140, 0x0043, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x150, 0x0043, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x120, 0x0041, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x130, 0x0041, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x140, 0x0041, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x150, 0x0041, MDIO_DEV_RX_BCAST );
+        } /* end for */
+/*        // workaround for NL11000 RA12 KBP running 3.125 Gbps */
+/*        nlm_hal_kbp_mdio_write( node, 0x0100, 0x0100, MDIO_DEV_RX_BCAST ); */
+/*        nlm_hal_kbp_mdio_write( node, 0x0101, 0x0100, MDIO_DEV_RX_BCAST ); */
+/*        nlm_hal_kbp_mdio_write( node, 0x0102, 0x0100, MDIO_DEV_RX_BCAST ); */
+/*        nlm_hal_kbp_mdio_write( node, 0x0103, 0x0100, MDIO_DEV_RX_BCAST ); */
+/*        nlm_hal_kbp_mdio_write( node, 0x0160, 0x0080, MDIO_DEV_RX_BCAST ); */
+/*        nlm_hal_kbp_mdio_write( node, 0x0160, 0x0000, MDIO_DEV_RX_BCAST ); */
+    } /* end if & else */
+
+    /* workaround for NL11000 RA01 KBP START */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, 0x0502, 0x0F68, MDIO_DEV_RX_BCAST );
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, 0x0502, 0x0F68, MDIO_DEV_TX_BCAST );
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, 0x8121, 0x7C53, MDIO_DEV_CSM );
+    /* workaround for NL11000 RA01 KBP END */
+
+    KBP_DELAY( 100 );
+    /* TX Metaframe length */
+    nlm_hal_kbp_mdio_write( node, KBP_TX_FRM_LEN, tx_metaframe_length, MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    /* RX Metaframe length */
+    nlm_hal_kbp_mdio_write( node, KBP_RX_FRM_LEN, rx_metaframe_length, MDIO_DEV_CSM );
+
+    /*    5. Deassert Core PLL and Core Logic reset, and trigger the SerDes-Initialization state machine by writing 16'h0 to "Global SW Reset" register. See Table 18 on page 39 */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_GL_SW_RST, 0x0000, MDIO_DEV_CSM );
+
+    /*    6. Poll for assertion of bit[3], SerDes Reset Sequence Done, in the "General Purpose Status Register 3". See Table 19 on page 45 */nlm_print( "    Polling for SerDes Reset Sequence Done...\n" );
+    KBP_DELAY( 100 );
+    do{
+        reg_data = nlm_hal_kbp_mdio_read( node, KBP_GEN_STATUS2, MDIO_DEV_CSM );
+        reg_data = ( reg_data >> 3 ) & 0b1;
+    }while( reg_data == 0 ); /* end do & while */
+    nlm_print( "    SerDes Reset Sequence is Done\n" );
+
+    /*    7. Enable RX and TX PCS using Global RX/TX Enable register. See Table 18 on page 39.*/
+    if( number_of_lane <= 16 ){
+        KBP_DELAY( 100 );
+        nlm_hal_kbp_mdio_write( node, KBP_RX_LANE_0_15_EN, ( 0x1 << number_of_lane ) - 1, MDIO_DEV_CSM );
+        KBP_DELAY( 100 );
+        nlm_hal_kbp_mdio_write( node, KBP_RX_LANE_16_23_EN, 0x0000, MDIO_DEV_CSM );
+    }else if( number_of_lane > 16 && number_of_lane <= 24 ){
+        KBP_DELAY( 100 );
+        nlm_hal_kbp_mdio_write( node, KBP_RX_LANE_0_15_EN, 0xFFFF, MDIO_DEV_CSM );
+        KBP_DELAY( 100 );
+        nlm_hal_kbp_mdio_write( node, KBP_RX_LANE_16_23_EN, ( 0x1 << ( number_of_lane - 16 ) ) - 1, MDIO_DEV_CSM );
+    }else{
+        nlm_print( "    ERROR!!!!!!!!!!!!! KBP Doesn't support %u SerDes lanes for requests!!!!!!!!!!!!!\n", number_of_lane );
+    } /* end if & else */
+
+    KBP_DELAY( 100 );
+    if( number_of_lane <= 12 ){
+        nlm_hal_kbp_mdio_write( node, KBP_TX_LANE_0_11_EN, ( 0x1 << number_of_lane ) - 1, MDIO_DEV_CSM );
+    }else{
+        nlm_print( "    ERROR!!!!!!!!!!!!! KBP Doesn't support %u SerDes lanes for responses!!!!!!!!!!!!!\n", number_of_lane );
+    } /* end if & else */
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_RX_TX_EN, 0x0003, MDIO_DEV_CSM ); /* Global Enable for Tx & Rx PCS*/
+
+    /*    8. Disable squelch for the Transmit SerDes using TX_SerDes_11_0_squelch CTX_SerDes_15_0_squelch and CTX_SerDes_23_16_squelch registers. See Table 18 on page 39.*/
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_TX_SER_0_11_SQCH, 0x0FFF - ( ( 0x1 << number_of_lane ) - 1 ), MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_CTX_SER_0_15_SQCH, 0xFFFF, MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_CTX_SER_16_23_SQCH, 0x00FF, MDIO_DEV_CSM );
+
+    /*    9. Read the General Purpose Status Register 3, 0x8184 to release assertion of GIO_L that may happen due to errors on the lanes during initialization.*/
+    nlm_hal_kbp_mdio_read( node, KBP_GEN_STATUS3, MDIO_DEV_CSM );
+
+    /* 4. Wait for 2.5ms and de-assert CRST_L */
+    KBP_DELAY( 5000000 );
+
+#ifdef CONFIG_N511
+    t8 = n511_cpld_rd(RST_CTL_0);
+    t8 |= 0x04;
+    n511_cpld_wr(RST_CTL_0, t8);
+
+    KBP_DELAY(40000);
+
+    t8 &= ~0x04;
+    n511_cpld_wr(RST_CTL_0, t8);
+
+    KBP_DELAY(40000);
+#else
+    cpld_data = nlm_hal_kbp_cpld_reg_read( node, 0x02 );
+    /* de-assert CRST */
+    cpld_data |= 0x0104;
+    nlm_hal_kbp_cpld_reg_write( node, 0x02, cpld_data );
+#endif
+    /* 5. Interlaken Look-Aside framing and synchronization.
+     *       Idle control words will be sent on the response port with XOFF until synchronization is complete.
+     *       It is expected that only idle control words are sent on the RX port until XON is provided on the TX port.*/
+    KBP_DELAY( 5000000 );
+
+    /* 6. Assert then de-assert reset Rx satellete sticky register */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_SER_SW_RST, 0x0040, MDIO_DEV_CSM );
+
+    KBP_DELAY( 2500000 );
+
+    nlm_hal_kbp_mdio_write( node, KBP_SER_SW_RST, 0x0000, MDIO_DEV_CSM );
+
+    nlm_print( "KBP System-ON Reset Sequence is Done\n" );
+
+} /* end nlm_hal_kbp_system_on_reset */
+
+/**perform ILA Reset Sequence
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param number_of_lane - number of SerDes lane to use
+ @param serdes_speed_in_gbps - SerDes lane speed
+ @param tx_metaframe_length - tx meta frame
+ @param rx_metaframe_length - rx meta frame
+ @return None
+ * meta frame is for synchronization
+ */
+static __inline__ void nlm_hal_ila_reset( uint32_t node, uint32_t number_of_lane, uint32_t serdes_speed_in_gbps, uint16_t tx_metaframe_length, uint16_t rx_metaframe_length ){
+    uint32_t reg_data = 0;
+
+    nlm_print( "Perform ILA Reset Sequence...\n" );
+
+    if( serdes_speed_in_gbps == 6 ){
+        /* do nothing */
+    }else{
+        /* Configure SerDes to run at 3.125 Gbps */
+        uint8_t addr = 0x04;
+        uint8_t data[MAX_NUMBER_OF_SERDES_LANE] = { 0x0 };
+
+        memset( data, 0x30, MAX_NUMBER_OF_SERDES_LANE );
+        nlm_hal_ila_serdes_lanes_reg_write( node, number_of_lane, 1, &addr, data );
+
+        /* Writing to reg05 to change M value to 2 */
+        addr = 0x05;
+        memset( data, 0x33, MAX_NUMBER_OF_SERDES_LANE );
+        nlm_hal_ila_serdes_lanes_reg_write( node, number_of_lane, 1, &addr, data );
+    } /* end if */
+
+    /* Assert active low PLL reset */
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, KBP_CTL );
+    reg_data &= 0xFFFFF7FF;
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_CTL, reg_data );
+
+    KBP_DELAY( 1000 );
+
+    /* De-assert active low PLL reset */
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, KBP_CTL );
+    reg_data |= 0x00000800;
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_CTL, reg_data );
+
+    /* Mask all interrupts */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_INT_MASK, 0x3FF );
+
+    /* Configure number of active lanes by writing index of last active lane */
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, LA_BAD_LANE );
+    reg_data &= 0xFFFFFF0F;
+    reg_data &= 0xFF0FFFFF;
+    if( number_of_lane == 2 ){
+        /* TX lane */
+        reg_data &= 0xFFFFFFF7;
+        reg_data |= ( 0x1 ) << 7;
+        reg_data |= ( 0x2 ) << 4;
+        reg_data |= ( 0x2 ) << 0;
+        /* RX lane */
+        reg_data &= 0xFFF7FFFF;
+        reg_data |= ( 0x1 ) << 23;
+        reg_data |= ( 0x2 ) << 20;
+        reg_data |= ( 0x2 ) << 16;
+    }else if( number_of_lane >= 3 && number_of_lane <= 8 ){
+        /* TX lane */
+        reg_data |= ( 0x0 ) << 7;
+        reg_data |= ( number_of_lane - 1 ) << 4;
+        /* RX lane */
+        reg_data |= ( 0x0 ) << 24;
+        reg_data |= ( number_of_lane - 1 ) << 20;
+    }else{
+        nlm_print( "    ERROR!!!!!!!!!!!!! ILA Doesn't support %u SerDes lanes!!!!!!!!!!!!!\n", number_of_lane );
+    } /* end if & else if & else */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_BAD_LANE, reg_data );
+
+    /* set timeout time tick */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_REQ_ID, 0x00000400 );
+
+    /* set metaframe */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_LEN, ( ( rx_metaframe_length - 1 ) << 16 ) | ( tx_metaframe_length - 1 ) );
+
+    /* set LSB position of Context Buffer ID to [17], so the valid Context Buffer ID length is 12-bit in an ILA request at descriptor0 bit [28:17] */
+    /* set Zero Pad Length of Context Buffer ID to [0] */
+    /* these 12 bits correspond to context buffer address [13:2] at KBP because ILA automatically masks out LSBs to zeros when sending request to KBP */
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, KBP_CTL );
+    reg_data = ( reg_data & 0xFFFFFFF0 ) | 0x1;
+    reg_data = ( reg_data & 0xFFFE0FFF ) | ( 0x11 << 12 );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_CTL, reg_data );
+
+    /* Enable packet counter and counter interrupts */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_PKT_CNT_CTL, 0xC000C000 );
+
+    /* wait until PCS lanes are ready */
+    nlm_print( "    Polling for PCS Lanes ready...\n" );
+    do{
+        KBP_DELAY( 10000 );
+        reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, SER_CTL );
+        reg_data &= 0xFF;
+    }while( reg_data != 0xFF ); /* end do & while */
+    nlm_print( "    All PCS Lanes are ready\n" );
+
+    /* Reset RX SerDes clocks, TX SerDes, RX SerDes and TX */
+    KBP_DELAY( 10000 );
+    reg_data = ( 0xFF << 24 ) | ( 0x1 << 22 ) | ( 0x1 << 21 ) | ( 0x1 << 20 );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_RX_SYNC, reg_data );
+
+    /* Wait for all RX lanes to be aligned/de-skewed */
+    nlm_print( "    Polling for Word Boundary and Scrambler Lock...\n" );
+    nlm_print( "        If Word Boundary and Scrambler Lock does not come up, check Meta Frame, Enabled Number of Lanes and SerDes Speed setting\n" );
+    do{
+        reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, LA_RX_SYNC );
+        reg_data = ( reg_data >> 18 ) & 0b1;
+    }while( reg_data != 1 ); /* end do & while */
+    nlm_print( "    Word Boundary and Scrambler are Locked\n" );
+
+    /* Enable TX */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_TX_ENABLE, 0x1 );
+
+    /* Enable capture of 3'bxxx except 3'b000 in pick1 counter and 3'bx1x in pick0 counter on error status bits [31:29] of KBP responses */
+    reg_data = ( 0xFE << 16 ) | ( 0xCC << 8 );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_RSP_ERROR_PAR, reg_data );
+
+    /* Set TX short burst length to 16 bytes */
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, LA_SETUP );
+    reg_data &= 0xFFFFF8FF;
+    reg_data |= ( 0x1 << 8 );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_SETUP, reg_data );
+
+    /* Change LA MEM Usage Register Threshold */
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, LA_MEM_USAGE );
+    reg_data &= 0xFFFFFF00;
+    if( is_nlm_xlp8xx_ax() ){
+        reg_data |= 0x3A;
+    }else if( is_nlm_xlp8xx_bx() ){
+        reg_data |= 0xFF;
+    } /* end if & else if */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_MEM_USAGE, reg_data );
+
+    /* Set up counters to capture errors flagged at bit [31:29] in KBP response packets control word */
+    /* 0xFE : increase counter when [31:29] = one of {3'b111, 3'b110, 3'b101, 3'b100, 3'b011, 3'b010, 3'b001} */
+    /* 0xCC : increase counter when [31:29] = one of {3'b111, 3'b110, 3'b011, 3'b010} */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_RSP_ERROR_PAR, 0x00FECC00 );
+
+    /* Set Tick Scale for timeout when waiting for response from KBP */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_REQ_ID, 0x00000400 );
+
+    /* check for KBP link status */
+    nlm_print( "    Checking for KBP status on [RX PCS Ready], [Core Init Done], [SerDes Reset Sequence Done] after ILA Reset\n" );
+    reg_data = nlm_hal_kbp_mdio_read( node, KBP_GEN_STATUS2, MDIO_DEV_CSM );
+    if( ( reg_data & 0xE ) == 0xE ){
+        nlm_print( "    KBP is ready after ILA Reset\n" );
+    }else{
+        nlm_print( "    ERROR!!!!!!!!!!!!! KBP is not ready after ILA Reset!!!!!!!!!!!!!\n" );
+        nlm_print( "ILA Reset Sequence is NOT Done\n" );
+        return;
+    } /* end if & else */
+
+    /* clear interrupts after initialization */
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_INT, 0xFFFFFFFF );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_INT, 0xFFFFFFFF );
+
+    nlm_print( "ILA Reset Sequence is Done\n" );
+
+} /* end nlm_hal_ila_reset */
+
+#endif /*__ASSEMBLY_*/
+#endif /* _NLM_HAL_KBP_H_ */
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h
new file mode 100644
index 0000000..13c4239
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h
@@ -0,0 +1,1334 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _NLM_HAL_MACROS_H
+#define _NLM_HAL_MACROS_H
+
+#ifndef __ASSEMBLY__
+extern unsigned long xlp_io_base;
+extern unsigned long xlp_fmn_base[];
+extern unsigned long xlp_nae_base[];
+extern unsigned long xlp_mac_base[];
+extern unsigned long xlp_poe_base_pcie[];
+extern unsigned long xlp_poe_base_pcim[];
+extern unsigned long xlp_sys_base[];
+
+extern int nlm_chip_is_xlp3xx;
+extern unsigned long xlp_regex_base_pcie;
+extern unsigned long xlp_regex_base_pcim;
+
+
+#ifndef is_nlm_xlp8xx
+extern int is_nlm_xlp(unsigned int chipid, unsigned int rev, unsigned int ext);
+
+#define XLP_REVISION_ANY 0xFF
+#define is_nlm_xlp8xx()      (is_nlm_xlp(0x8000, XLP_REVISION_ANY, 0) || is_nlm_xlp(0x4000, XLP_REVISION_ANY, 0))
+#endif /* is_nlm_xlp8xx */
+
+#endif /* #ifndef __ASSEMBLY__ */
+
+
+#if defined(NLM_HAL_LINUX_USER) /* Linux User mode */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#define nlm_print printf
+#define nlm_malloc malloc
+#define nlm_free  free
+#if (_MIPS_SIM == _MIPS_SIM_ABI32) || (_MIPS_SIM == _MIPS_SIM_NABI32) || \
+    (_MIPS_SZLONG == 32)
+#define KSEG0     0x80000000UL
+#define KSEG1     0xA0000000UL
+#define KSEG2     0xC0000000UL
+#define KSEG3     0xE0000000UL
+#define KSEG0_PHY_BOUNDARY 0x10000000UL    /* 256 MB */
+#else
+#define KSEG0     (0xffffffff80000000ULL)
+#define KSEG1     (0xffffffffA0000000ULL)
+#define KSEG2     (0xffffffffC0000000ULL)
+#define KSEG3     (0xffffffffE0000000ULL)
+#define KSEG0_PHY_BOUNDARY 0x10000000ULL    /* 256 MB */
+#endif
+
+
+/* Adding a new macro for mdelay.  */
+#define nlm_udelay(n) 	usleep(n)
+#define nlm_mdelay(n) 	usleep(n * 1000) 
+				        
+
+#elif defined(NLM_HAL_LINUX_KERNEL) /* Linux Kenrel mode */
+
+#include <asm/mipsregs.h>
+#ifndef __ASSEMBLY__
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+#include <linux/slab.h>
+#include <asm/atomic.h>
+#endif
+
+#define nlm_print printk
+#define nlm_malloc(size) kmalloc((size), GFP_KERNEL)
+#define nlm_free  kfree
+
+static inline unsigned long nlm_spill_alloc(int node, uint64_t size)
+{
+        struct page *pg;
+        pg = alloc_pages_exact_node(node, GFP_KERNEL, get_order(size));
+	if (pg == NULL) {
+		nlm_print("Spill Mem allocation on node %d failed \n", node);
+		return 0;
+	}
+        return page_to_phys(pg);
+}
+
+#if (_MIPS_SIM == _MIPS_SIM_ABI32) || (_MIPS_SIM == _MIPS_SIM_NABI32) || \
+    (_MIPS_SZLONG == 32)
+#ifndef KSEG0
+#define KSEG0     0x80000000UL
+#endif
+#ifndef KSEG1
+#define KSEG1     0xA0000000UL
+#endif
+#ifndef KSEG2
+#define KSEG2     0xC0000000UL
+#endif
+#ifndef KSEG3
+#define KSEG3     0xE0000000UL
+#endif
+#define KSEG0_PHY_BOUNDARY 0x10000000UL    /* 256 MB */
+#else
+#define KSEG0     (0xffffffff80000000ULL)
+#define KSEG1     (0xffffffffA0000000ULL)
+#define KSEG2     (0xffffffffC0000000ULL)
+#define KSEG3     (0xffffffffE0000000ULL)
+#define KSEG0_PHY_BOUNDARY 0x10000000ULL    /* 256 MB */
+#endif
+#define nlm_mdelay(n) mdelay(n)
+
+#define nlm_udelay(n)	udelay(n)
+#define nlm_mdelay(n)  	mdelay(n)
+
+#endif /* __ASSEMBLY__ */
+
+#elif defined(NLM_HAL_NETOS) /* Netos */
+
+#ifndef __ASSEMBLY__
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+
+#define nlm_print printf
+#define nlm_malloc malloc
+#define nlm_free  free
+#define nlm_udelay(x)	_netos_delay(x) /* Temporary implementation for netos-hyperex */
+#define nlm_mdelay(n) 	nlm_udelay(n * 1000)
+static __inline__ void _netos_delay(unsigned int x)
+{
+        unsigned long int i;
+
+        /* compilers beyond gcc 4.0 will remove off tight loops
+         * when optimization is enabled. This asm call is
+         * supposedly the standard way to work around this.
+         */
+        for (i = 0; i<(1000 * x) ; i++)
+                __asm__ __volatile__ ("");
+}
+#endif /* __ASSEMBLY__ */
+
+#if (_MIPS_SIM == _MIPS_SIM_ABI32) || (_MIPS_SIM == _MIPS_SIM_NABI32) || \
+    (_MIPS_SZLONG == 32)
+#define KSEG0     0x80000000
+#define KSEG1     0xA0000000
+#define KSEG2     0xC0000000
+#define KSEG3     0xE0000000
+#define KSEG0_PHY_BOUNDARY 0x10000000    /* 256 MB */
+#else
+#define KSEG0     (0xffffffff80000000)
+#define KSEG1     (0xffffffffA0000000)
+#define KSEG2     (0xffffffffC0000000)
+#define KSEG3     (0xffffffffE0000000)
+#define KSEG0_PHY_BOUNDARY 0x10000000    /* 256 MB */
+#endif
+
+#elif defined(NLM_HAL_UBOOT) /* u-boot */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+
+#define nlm_print printf
+#define nlm_malloc malloc
+#define nlm_free  free
+#define nlm_udelay(n)	udelay(n)
+#define nlm_mdelay(n) 	udelay(n * 1000)
+
+#if (_MIPS_SIM == _MIPS_SIM_ABI32) || (_MIPS_SIM == _MIPS_SIM_NABI32) || \
+    (_MIPS_SZLONG == 32)
+#define KSEG0     0x80000000UL
+#define KSEG1     0xA0000000UL
+#define KSEG2     0xC0000000UL
+#define KSEG3     0xE0000000UL
+#define KSEG0_PHY_BOUNDARY 0x10000000UL    /* 256 MB */
+#else
+#define KSEG0     (0xffffffff80000000ULL)
+#define KSEG1     (0xffffffffA0000000ULL)
+#define KSEG2     (0xffffffffC0000000ULL)
+#define KSEG3     (0xffffffffE0000000ULL)
+#define KSEG0_PHY_BOUNDARY 0x10000000ULL    /* 256 MB */
+#endif
+
+#elif defined(NLM_HAL_XLOADER) /* x-loader */
+#include <common.h>
+#define KSEG0     0x80000000UL
+#define KSEG1     0xA0000000UL
+#define KSEG2     0xC0000000UL
+#define KSEG3     0xE0000000UL
+#define KSEG0_PHY_BOUNDARY 0x10000000UL    /* 256 MB */
+
+#elif defined(NLM_HAL_NETLBOOT) /* netlboot */
+#include <printk.h>
+
+#define nlm_print printk
+#define nlm_malloc malloc
+#define nlm_free  free
+#define nlm_udelay(n)	udelay(n)
+#define nlm_mdelay(n) 	mdelay(n)
+
+#else
+#error "Unsupported platform for NL HAL"
+#endif	/* NLM_HAL_LINUX_USER */
+
+#define CCA_UNCACHED  2
+#define CCA_CACHED    3
+
+#define CRC_POLY_REG_0_SEL 0
+#define CRC_POLY_REG_1_SEL 1
+#define CRC_POLY_REG_2_SEL 2
+#define CRC_POLY_REG_3_SEL 3
+
+#define CRC_ENDIAN_BIT 5
+#define CRC_FLIPBITS_BIT 4
+#define CRC_DESTINATION_BIT 6
+
+#define CRC_32_INIT_VALUE 0xffffffff
+#define CRC_16_INIT_VALUE 0
+
+/*
+ * Memory segments (64bit kernel mode addresses)
+ */
+/* XLP_MERGE_TODO */
+#define NLH_XKUSEG			0x0000000000000000
+#define NLH_XKSSEG			0x4000000000000000
+#ifdef CONFIG_64BIT
+#define NLH_XKPHYS                      0x8000000000000000
+#else
+#define NLH_XKPHYS			0x8000000000000000ULL
+#endif
+#define NLH_XKPHYS_UNCACHED             0x9000000000000000ULL
+#define NLH_XKSEG			0xc000000000000000
+#define NLH_CKSEG0			0xffffffff80000000
+#define NLH_CKSEG1			0xffffffffa0000000
+#define NLH_CKSSEG			0xffffffffc0000000
+#define NLH_CKSEG3			0xffffffffe0000000
+
+#define SET_MIPS64 .set mips64r2
+#define NLM_HAL_THREAD_SIZE (8 << 10)
+
+/* For hal internal debug */
+#define nlm_hal_dbg_msg(fmt, args...) nlm_print(fmt, ##args)
+
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#ifndef __ASSEMBLY__
+#define XLP_BIT_MASK_W(size) ((1 << (size)) - 1)
+#define XLP_BIT_MASK_DW(size) (((unsigned long long) 1 << size) - 1)
+
+#define enable_KX(flags)       \
+ __asm__ __volatile__ (        \
+        ".set push\n"          \
+        ".set noat\n"          \
+        ".set noreorder\n"     \
+        "mfc0 %0, $12\n\t"     \
+        "ori $1, %0, 0x81\n\t" \
+        "xori $1, 1\n\t"       \
+        "mtc0 $1, $12\n"       \
+        ".set pop\n"           \
+        : "=r"(flags) );
+
+#define disable_KX(flags)   \
+ __asm__ __volatile__ (     \
+        ".set push\n"       \
+        "mtc0 %0, $12\n"    \
+        ".set pop\n"        \
+        : : "r"(flags) )
+
+#ifdef CONFIG_64BIT
+static __inline__ uint8_t lb_40bit_phys(uint64_t phys, int cca)
+{
+        uint8_t value = 0;
+
+        __asm__ __volatile__(".set push\n"
+                             ".set noreorder\n"
+                             ".set mips64\n"
+                             "dli   $8, " STR(NLH_XKPHYS) "\n"
+                             "or    $8, $8, %2\n"
+                             "daddu $8, $8, %1\n"
+                             "lb    %0, 0($8) \n" 
+			     ".set pop\n":"=r"(value)
+                             :"r"(phys & 0xffffffffffULL),
+                             "r"((uint64_t) cca << 59)
+                             :"$8");
+
+        return value;
+}
+
+static __inline__ uint16_t lh_40bit_phys(uint64_t phys, int cca)
+{
+	uint16_t value = 0;
+
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "lhu    %0, 0($8) \n"
+			     ".set pop\n"
+			     :"=r"(value)
+			     :"r"(phys & 0xfffffffffeULL),"r"((uint64_t) cca << 59)
+			     :"$8");
+
+	return value;
+}
+
+static __inline__ uint64_t lw_40bit_phys(uint64_t phys, int cca)
+{
+	uint64_t value = 0;
+
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "lw    %0, 0($8) \n"
+			     ".set pop\n"
+			     :"=r"(value)
+			     :"r"(phys & 0xfffffffffcULL),"r"((uint64_t) cca << 59)
+			     :"$8");
+
+	return value;
+}
+static __inline__ uint64_t ld_40bit_phys(uint64_t phys, int cca)
+{
+	uint64_t value = 0;
+
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "ld    %0, 0($8) \n"
+			     ".set pop\n"
+			     :"=r"(value)
+			     :"r"(phys & 0xfffffffff8ULL),"r"((uint64_t) cca << 59)
+			     :"$8");
+
+	return value;
+}
+#else
+
+static __inline__ uint8_t lb_40bit_phys(uint64_t phys, int cca)
+{
+        uint8_t value = 0;
+        uint32_t low, high;
+        uint64_t cca64 = ((uint64_t)cca << 59);
+        unsigned long flags;
+
+        phys &= 0xffffffffffULL;
+        phys |= (NLH_XKPHYS | cca64);
+        low = (uint32_t) phys & 0xffffffff;
+        high = (uint32_t) (phys >> 32);
+
+        enable_KX(flags);
+
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %2, 0\n"
+                        "dsll32 %1, 0\n"
+                        "dsrl32 %1, 0\n"
+                        "or $1, $1, %1\n"
+                        "lb %0, 0($1) \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :"=r"(value)
+                        :"r"(low), "r"(high)
+                        :"$1");
+
+        disable_KX(flags);
+
+        return value;
+}
+
+static __inline__ uint16_t lh_40bit_phys(uint64_t phys, int cca)
+{
+        uint16_t value = 0;
+        uint32_t low, high;
+        uint64_t cca64 = ((uint64_t)cca << 59);
+        unsigned long flags;
+
+        phys &= 0xfffffffffeULL;
+        phys |= (NLH_XKPHYS | cca64);
+        low = (uint32_t) phys & 0xffffffff;
+        high = (uint32_t) (phys >> 32);
+
+        enable_KX(flags);
+
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %2, 0\n"
+                        "dsll32 %1, 0\n"
+                        "dsrl32 %1, 0\n"
+                        "or $1, $1, %1\n"
+                        "lhu %0, 0($1) \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :"=r"(value)
+                        :"r"(low), "r"(high)
+                        :"$1");
+
+        disable_KX(flags);
+
+        return value;
+}
+
+static __inline__ uint32_t lw_40bit_phys(uint64_t phys, int cca)
+{
+        uint32_t value = 0;
+        uint32_t low, high;
+        uint64_t cca64 = ((uint64_t)cca << 59);
+        unsigned long flags;
+
+        phys &= 0xfffffffffcULL;
+        phys |= (NLH_XKPHYS | cca64);
+        low = (uint32_t) phys & 0xffffffff;
+        high = (uint32_t) (phys >> 32);
+
+        enable_KX(flags);
+
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %2, 0\n"
+                        "dsll32 %1, 0\n"
+                        "dsrl32 %1, 0\n"
+                        "or $1, $1, %1\n"
+                        "lw %0, 0($1) \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :"=r"(value)
+                        :"r"(low), "r"(high)
+                        :"$1");
+
+        disable_KX(flags);
+
+        return value;
+}
+
+static __inline__ uint64_t ld_40bit_phys(uint64_t phys, int cca)
+{
+        uint32_t lsw, msw, high, low;
+        uint64_t cca64 = ((uint64_t)cca << 59);
+        unsigned long flags;
+
+        phys &= 0xfffffffff8ULL;
+        phys |= (NLH_XKPHYS | cca64);
+        low  = (uint32_t) phys & 0xffffffff;
+        high = (uint32_t) (phys >> 32);
+
+        enable_KX(flags);
+
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %3, 0\n"
+                        "dsll32 %2, 0    \n"
+                        "dsrl32 %2, 0    \n"
+                        "or $1, $1, %2   \n"
+                        "ld $1, 0($1)    \n"
+                        "dsrl32 %1, $1 ,0\n"
+                        "dsll32 $1, $1 ,0\n"
+                        "dsrl32 %0, $1 ,0\n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :"=r"(lsw), "=r"(msw)
+                        :"r"(low),  "r"(high)
+                        :"$1");
+
+        disable_KX(flags);
+        return (((unsigned long long)msw << 32) | lsw);
+}
+
+#endif /* #ifdef CONFIG_64BIT */
+
+static __inline__ uint8_t lb_40bit_phys_uncached(uint64_t phys)
+{
+        return lb_40bit_phys(phys, CCA_UNCACHED);
+}
+
+static __inline__  uint8_t lb_40bit_phys_cached(uint64_t phys)
+{
+        return lb_40bit_phys(phys, CCA_CACHED);
+}
+
+static __inline__ uint16_t lh_40bit_phys_uncached(uint64_t phys)
+{
+        return lh_40bit_phys(phys, CCA_UNCACHED);
+}
+
+static __inline__  uint16_t lh_40bit_phys_cached(uint64_t phys)
+{
+        return lh_40bit_phys(phys, CCA_CACHED);
+}
+
+static __inline__ uint32_t lw_40bit_phys_uncached(uint64_t phys)
+{
+	return lw_40bit_phys(phys, CCA_UNCACHED);
+}
+static __inline__ uint32_t lw_40bit_phys_cached(uint64_t phys)
+{
+	return lw_40bit_phys(phys, CCA_CACHED);
+}
+static __inline__ uint64_t ld_40bit_phys_uncached(uint64_t phys)
+{
+	return ld_40bit_phys(phys, CCA_UNCACHED);
+}
+static __inline__ uint64_t ld_40bit_phys_cached(uint64_t phys)
+{
+	return ld_40bit_phys(phys, CCA_CACHED);
+}
+
+#ifdef CONFIG_64BIT
+static __inline__ void sb_40bit_phys(uint64_t phys, int cca, uint8_t value)
+{
+  __asm__ __volatile__(".set push\n"
+                       ".set noreorder\n"
+                       ".set mips64\n"
+                       "dli   $8, "STR(NLH_XKPHYS)"\n"
+                       "or    $8, $8, %2\n"
+                       "daddu $8, $8, %1\n"
+                       "sb    %0, 0($8) \n"
+                       ".set pop\n"
+                       :
+                       : "r"(value), "r"(phys & 0xffffffffffULL), "r"((uint64_t)cca << 59)
+                       : "$8"
+          );
+}
+static __inline__ void sh_40bit_phys(uint64_t phys, int cca, uint32_t value)
+{
+  __asm__ __volatile__(".set push\n"
+                       ".set noreorder\n"
+                       ".set mips64\n"
+                       "dli   $8, "STR(NLH_XKPHYS)"\n"
+                       "or    $8, $8, %2\n"
+                       "daddu $8, $8, %1\n"
+                       "sh    %0, 0($8) \n"
+                       ".set pop\n"
+                       :
+                       : "r"(value), "r"(phys & 0xfffffffffeULL), "r"((uint64_t)cca << 59)
+                       : "$8"
+	  );
+}
+static __inline__ void sw_40bit_phys(uint64_t phys, int cca, uint32_t value)
+{
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "sw    %0, 0($8) \n"
+			     ".set pop\n"
+			     :
+			     :"r"(value), "r"(phys & 0xfffffffffcULL), "r"((uint64_t) cca << 59)
+			     :"$8"
+		);
+}
+static __inline__ void sd_40bit_phys(uint64_t phys, int cca, uint64_t value)
+{
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "sd    %0, 0($8) \n"
+			     ".set pop\n"
+			     :
+			     :"r"(value), "r"(phys & 0xfffffffff8ULL), "r"((uint64_t) cca << 59)
+			     :"$8"
+		);
+}
+
+#else
+
+static __inline__ void sb_40bit_phys(uint64_t phys, int cca, uint8_t value)
+{
+        uint32_t low, high;
+        uint64_t cca64 = ((uint64_t)cca << 59);
+        unsigned long flags;
+
+        phys &= 0xffffffffffULL;
+        phys |= (NLH_XKPHYS | cca64);
+        low = (uint32_t) phys & 0xffffffff;
+        high = (uint32_t) (phys >> 32);
+
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %2, 0\n"
+                        "dsll32 %1, 0\n"
+                        "dsrl32 %1, 0\n"
+                        "or $1, $1, %1\n"
+                        "sb %0, 0($1) \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :
+                        :"r"(value), "r"(low), "r"(high)
+                        :"$1");
+        disable_KX(flags);
+}
+
+static __inline__ void sh_40bit_phys(uint64_t phys, int cca, uint16_t value)
+{
+        uint32_t low, high;
+        uint64_t cca64 = ((uint64_t)cca << 59);
+        unsigned long flags;
+
+        phys &= 0xfffffffffeULL;
+        phys |= (NLH_XKPHYS | cca64);
+        low = (uint32_t) phys & 0xffffffff;
+        high = (uint32_t) (phys >> 32);
+
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %2, 0\n"
+                        "dsll32 %1, 0\n"
+                        "dsrl32 %1, 0\n"
+                        "or $1, $1, %1\n"
+                        "sh %0, 0($1) \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :
+                        :"r"(value), "r"(low), "r"(high)
+                        :"$1");
+        disable_KX(flags);
+}
+
+static __inline__ void sw_40bit_phys(uint64_t phys, int cca, uint32_t value)
+{
+        uint32_t low, high;
+        uint64_t cca64 = ((uint64_t)cca << 59);
+        unsigned long flags;
+
+        phys &= 0xfffffffffcULL;
+        phys |= (NLH_XKPHYS | cca64);
+        low = (uint32_t) phys & 0xffffffff;
+        high = (uint32_t) (phys >> 32);
+
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %2, 0\n"
+                        "dsll32 %1, 0\n"
+                        "dsrl32 %1, 0\n"
+                        "or $1, $1, %1\n"
+                        "sw %0, 0($1) \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :
+                        :"r"(value), "r"(low), "r"(high)
+                        :"$1");
+        disable_KX(flags);
+}
+
+static __inline__ void sd_40bit_phys(uint64_t phys, int cca, uint64_t value)
+{
+        uint32_t lsw, msw, high, low;
+        uint64_t cca64 = ((uint64_t)cca << 59);
+        unsigned long flags;
+        phys &= 0xfffffffff8ULL;
+        phys |= (NLH_XKPHYS | cca64);
+        low  = (uint32_t) phys & 0xffffffff;
+        high = (uint32_t) (phys >> 32);
+        lsw  = (uint32_t) value  & 0xffffffff;
+        msw  = (uint32_t)(value >>32);
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %3, 0\n"
+                        "dsll32 %2, 0    \n"
+                        "dsrl32 %2, 0    \n"
+                        "or $1, $1, %2   \n"
+                        "dsll32 $8, %1, 0\n"
+                        "dsll32 %0, 0   \n"
+                        "dsrl32 %0, 0   \n"
+                        "or $8, $8, %0   \n"
+                        "sd $8, 0($1)    \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :
+                        : "r"(lsw), "r"(msw), "r"(low), "r"(high)
+                        :"$1", "$8");
+        disable_KX(flags);
+}
+
+#endif /* #ifdef CONFIG_64BIT */
+
+static __inline__ void sb_40bit_phys_uncached(uint64_t phys, uint8_t value)
+{
+      sb_40bit_phys(phys, CCA_UNCACHED, value);
+}
+static __inline__ void sb_40bit_phys_cached(uint64_t phys, uint8_t value)
+{
+      sb_40bit_phys(phys, CCA_CACHED, value);
+}
+
+static __inline__ void sh_40bit_phys_uncached(uint64_t phys, uint16_t value)
+{
+      sh_40bit_phys(phys, CCA_UNCACHED, value);
+}
+static __inline__ void sh_40bit_phys_cached(uint64_t phys, uint16_t value)
+{
+      sh_40bit_phys(phys, CCA_CACHED, value);
+}
+
+static __inline__ void sw_40bit_phys_uncached(uint64_t phys, uint32_t value)
+{
+	sw_40bit_phys(phys, CCA_UNCACHED, value);
+}
+static __inline__ void sw_40bit_phys_cached(uint64_t phys, uint32_t value)
+{
+	sw_40bit_phys(phys, CCA_CACHED, value);
+}
+static __inline__ void sd_40bit_phys_uncached(uint64_t phys, uint64_t value)
+{
+	sd_40bit_phys(phys, CCA_UNCACHED, value);
+}
+static __inline__ void sd_40bit_phys_cached(uint64_t phys, uint64_t value)
+{
+	sd_40bit_phys(phys, CCA_CACHED, value);
+}
+
+        
+#define enable_ELPA()           \
+ __asm__ __volatile__ (         \
+        ".set push\n"           \
+        ".set noat\n"           \
+        ".set noreorder\n"      \
+        "mfc0 $8, $5, 1\n"      \
+        "li $9, 0x20000000\n"   \
+        "or $8, $8, $9\n"       \
+        "mtc0 $8, $5, 1\n"      \
+        ".set pop\n"            \
+        :  :  :"$8", "$9")                      
+
+
+/*
+ *  COP2 Reg access macros
+ */
+#define _read_32bit_cp2_register(source)                        \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define _write_32bit_cp2_register(register,value)               \
+        __asm__ __volatile__(                                   \
+        "mtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+        : : "r" (value));
+
+#define _read_32bit_cp2_register_sel(source, sel)               \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips32\n\t"                                       \
+        "mfc2\t%0,"STR(source)", %1\n\t"                        \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define _write_32bit_cp2_register_sel(reg, value, sel)          \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips32\n\t"                                       \
+        "mtc2\t%0,"STR(reg)", %1\n\t"                           \
+	".set\tpop"						\
+        : : "r" (value), "i" (sel) );
+
+#ifndef _ABI64
+
+#define _read_64bit_cp2_register_sel(source, sel)                        \
+({                                                                      \
+        unsigned int high, low;                                         \
+                                                                        \
+                __asm__ __volatile__(                                   \
+                        ".set\tmips64\n\t"                              \
+                        "dmfc2\t$8, "STR(source)","STR(sel)"\n\t"       \
+                        "dsrl32\t%0, $8, 0\n\t"                         \
+                        "dsll32\t$8, $8, 0\n\t"                         \
+                        "dsrl32\t%1, $8, 0\n\t"                         \
+                        ".set\tmips0"                                   \
+                        : "=r" (high), "=r"(low): "i"(sel) : "$8");     \
+        ( (((unsigned long long)high)<<32) | low);                      \
+})
+
+#define _write_64bit_cp2_register_sel(source, val, sel)                 \
+do {                                                                    \
+     unsigned int high = val>>32;                                       \
+     unsigned int low  = val & 0xffffffff;                              \
+                __asm__ __volatile__(                                   \
+                        ".set\tmips64\n\t"                              \
+                        "dsll32 $8, %1, 0\n"                            \
+                        "dsll32 $9, %0, 0\n"                            \
+                        "dsrl32 $8, $8, 0\n"                            \
+                        "or     $8, $8, $9\n"                           \
+                        "dmtc2\t$8, "STR(source)", %2\n\t"              \
+                        ".set\tmips0"                                   \
+                        : : "r" (high), "r" (low), "i"(sel): "$8", "$9");               \
+} while (0)
+
+#define _read_64bit_cp2_register(source) \
+	_read_64bit_cp2_register_sel(source, 0)
+#define _write_64bit_cp2_register(source, val) \
+	_write_64bit_cp2_register_sel(source, val, 0)
+
+#else /* _ABI64 */
+
+#define _read_64bit_cp2_register(source)                        \
+({ unsigned long long __res;                                    \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        ".set\tmips64\n\t"                                      \
+        "dmfc2\t%0,"STR(source)"\n\t"                           \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define _write_64bit_cp2_register(register,value)               \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "dmtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+	".set\tpop"						\
+        : : "r" (value));
+
+#define _read_64bit_cp2_register_sel(source, sel)               \
+({ unsigned long long __res;                                    \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips64\n\t"                                       \
+        "dmfc2\t%0,"STR(source)", %1\n\t"                       \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define _write_64bit_cp2_register_sel(reg, value, sel)          \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips64\n\t"                                       \
+        "dmtc2\t%0,"STR(reg)", %1\n\t"                          \
+	".set\tpop"						\
+        : : "r" (value), "i" (sel) );
+
+#endif /* _ABI64 */
+
+typedef enum crc_type {
+	NLM_CRC_32 = 0,
+	NLM_CRC_16 = 16,
+	NLM_CRC_7 = 25
+} crc_type_t;
+
+#define REG_STR(x) "$" #x
+
+#undef USE_64BIT_CRC
+#if defined(NLM_HAL_LINUX_KERNEL)
+#define USE_64BIT_CRC
+#else
+#if _MIPS_SIM != _MIPS_SIM_ABI32 && !defined(ABI_32)
+#define USE_64BIT_CRC
+#endif
+#endif /* NLM_HAL_LINUX_KERNEL */
+
+#ifdef USE_64BIT_CRC
+typedef uint64_t u_data;
+#else
+typedef uint32_t u_data;
+#endif
+
+#define INIT_CRC_POLY(poly_reg, poly_type, crc_poly) \
+({                                                            \
+    asm volatile (                                            \
+        ".set push\n"                                         \
+        ".set noat\n"                                         \
+	"dmtur %0, " REG_STR(poly_reg) "\n"                   \
+	"ehb\n"                                               \
+        ".set pop\n"                                          \
+	: : [poly] "r"((crc_poly << poly_type) & 0x00000000ffffffff)  \
+    );                                                        \
+})
+
+#ifdef USE_64BIT_CRC
+static __inline__ unsigned int
+nlm_crc32_generic(uint64_t data, unsigned int flags_len, unsigned int crc)
+{
+	unsigned int ret;
+	asm volatile (
+		".set push\n"
+		".set noreorder\n"
+		"addiu $9, %[flags_len], 0\n"
+		"dcrc   %[result], %[input], $9\n"
+		".set pop\n"
+		: [result] "=r"(ret)
+		: [input] "r"(data), [flags_len] "r"(flags_len), "0"(crc)
+		: "$9"
+	);
+	return ret;
+}
+#else
+static __inline__ unsigned int
+nlm_crc32_generic(unsigned int data, unsigned int flags_len, unsigned int crc)
+{
+	unsigned int ret;
+	asm volatile (
+		".set push\n"
+		".set noreorder\n"
+		"addiu $9, %[flags_len], 0\n"
+		"crc   %[result], %[input], $9\n"
+		".set pop\n"
+		: [result] "=r"(ret)
+		: [input] "r"(data), [flags_len] "r"(flags_len), "0"(crc)
+		: "$9"
+	);
+	return ret;
+}
+#endif
+
+static __inline__ uint32_t
+bit_flip(uint32_t t)
+{
+	unsigned int ret = 0, x = t;
+
+    asm volatile (
+	    ".set push\n"
+	    ".set mips32\n"
+	    ".set noreorder\n"
+	    "addiu   %[ret], $0, 0\n"
+	 "1: addiu   $9, $0, 32\n"
+	    "clz     $8, %[val]\n"
+	    "beq     $8, $9, 3f\n"
+
+	    /* set the bit in the correct location of result */
+	    "addiu   $9, $0, 1\n"
+	    "sllv    $9, $9, $8\n"
+	    "or      %[ret], %[ret], $9\n"
+
+	    /* reset the bit in the data */
+	    "addiu   $9, $0, 31\n"
+	    "subu    $9, $9, $8\n"
+	    "addiu   $8, $0, 1\n"
+	    "sllv    $9, $8, $9\n"
+	    "xor     %[val], %[val], $9\n"
+	    "b       1b\n"
+	    ".set pop\n"
+	    "3: nop\n"
+	    : [ret] "=&r"(ret) : [val] "r"(x)
+	    :"$8", "$9"
+	    );
+    return ret;
+}
+
+static __inline__ unsigned int
+nlm_crc32_word(int crc_reg, u_data data, unsigned int len,
+	   unsigned int crc_init)
+{
+	/* flip bit */
+	unsigned int flags_len = (1 << CRC_FLIPBITS_BIT) | (1 << CRC_DESTINATION_BIT);
+
+	/* set length and CRC poly reg */
+	flags_len |= ((len & 0x7) |
+		      ((crc_reg & 0x3) << 8));
+
+	return nlm_crc32_generic(data, flags_len, crc_init);
+}
+
+static __inline__ uint32_t
+nlm_crc16_ibm(int crc_reg, u_data data, unsigned int len,
+	  unsigned short crc_init)
+{
+	/* flip bit */
+	unsigned int flags_len = (1 << CRC_FLIPBITS_BIT) | (1 << CRC_DESTINATION_BIT);
+
+	/* set length and CRC poly reg */
+	flags_len |= ((len & 0x7) |
+		      ((crc_reg & 0x3) << 8));
+
+	return  nlm_crc32_generic(data, flags_len, crc_init);
+}
+
+static __inline__ uint32_t
+nlm_crc7_word(int crc_reg, u_data data, unsigned int len, unsigned short crc_init)
+{
+	/* flip bit */
+	unsigned int flags_len = (1 << CRC_FLIPBITS_BIT) | (1 << CRC_DESTINATION_BIT);
+
+	/* set length and CRC poly reg */
+	flags_len |= ((len & 0x7) |
+		      ((crc_reg & 0x3) << 8));
+
+	return  nlm_crc32_generic(data, flags_len, crc_init);
+}
+
+/**
+ * This macro loops on a string of data.  It is kept this way to
+ * adjust to endianess and use of 64bit instruction, so that each
+ * CRC function does not require ifdef.
+ */
+#ifdef USE_64BIT_CRC
+#define LOOP_ON_DATA(c, init, b, len, f) \
+({                                                                           \
+        uint64_t data;                                                       \
+	uint32_t i, rem = len, __ret = init, l;                              \
+	for(i = 0; rem > 0;) {                                               \
+                data = ((uint64_t *)buf)[i];                                 \
+      	        i += 1;                                                      \
+	        if(rem >= 8) {                                               \
+		        rem -= 8;                                            \
+		        l = 7;                                               \
+		} else if (rem == 7) {                                       \
+			rem -= 7;                                            \
+			l = 6;                                               \
+		} else if (rem == 6) {                                       \
+			rem -= 6;                                            \
+			l = 5;                                               \
+		} else if (rem == 5) {                                       \
+			rem -= 5;                                            \
+			l = 4;                                               \
+		} else if (rem == 4) {                                       \
+			rem -= 4;                                            \
+			l = 3;                                               \
+		} else if (rem == 3) {                                       \
+			rem -= 3;                                            \
+			l = 2;                                               \
+		} else if (rem == 2) {                                       \
+			rem -= 2;                                            \
+			l = 1;                                               \
+		} else if (rem == 1) {                                       \
+			rem -= 1;                                            \
+			l = 0;                                               \
+		}                                                            \
+		__ret = f(crc_reg, data, l, __ret);                          \
+	}                                                                    \
+        __ret;                                                               \
+})
+#else
+#define LOOP_ON_DATA(c, init, b, len, f) \
+({                                                                           \
+        uint32_t data;                                                       \
+	uint32_t i, rem = len, __ret = init, l;                              \
+	for(i = 0; rem > 0;) {                                               \
+		data = ((uint32_t *)buf)[i];                                 \
+                i += 1;                                                      \
+		if(rem >= 4) {                                               \
+			rem -= 4;                                            \
+			l = 3;                                               \
+		} else if (rem == 3) {                                       \
+			rem -= 3;                                            \
+			l = 2;                                               \
+		} else if (rem == 2) {                                       \
+			rem -= 2;                                            \
+			l = 1;                                               \
+		} else if (rem == 1) {                                       \
+			rem -= 1;                                            \
+			l = 0;                                               \
+		}                                                            \
+		__ret = f(crc_reg, data, l, __ret);                          \
+	}                                                                    \
+        __ret;                                                               \
+})
+#endif
+
+static __inline__ uint32_t
+nlm_crc32(int crc_reg, const unsigned char *buf, unsigned int len, unsigned int crc)
+{
+	return LOOP_ON_DATA(crc_reg, crc,
+			    buf, len, nlm_crc32_word) ^ 0xffffffff;
+}
+
+static __inline__ uint16_t
+nlm_crc16(int crc_reg, const unsigned char *buf, unsigned int len, unsigned short crc)
+{
+	return (uint16_t)(LOOP_ON_DATA(crc_reg, crc,
+				       buf, len, nlm_crc16_ibm) & 0xffff);
+}
+
+static __inline__ unsigned char
+nlm_crc7(int crc_reg, const unsigned char *buf, unsigned int len, unsigned char crc)
+{
+	return (unsigned char)(LOOP_ON_DATA(crc_reg, crc, buf,
+					    len, nlm_crc7_word) & 0x7f);
+}
+#if 0
+static __inline__ int num_ones(unsigned long mask)
+{
+	int  nones;
+
+	for (nones = 0; mask; mask >>= 1) {
+		if (mask & 0x1)
+			++nones;
+	}
+
+	return nones;
+}
+#endif
+static __inline__ void write_32bit_cfg_reg(uint32_t *base, unsigned int offset, uint32_t value)
+{
+  base[offset] = value;
+}
+static __inline__ uint32_t read_32bit_cfg_reg(uint32_t *base, unsigned int offset)
+{
+  return ((base)[offset]);
+}
+static __inline__ void write_64bit_cfg_reg(uint64_t *base, unsigned int offset, uint64_t value)
+{
+  base[offset] = value;
+}
+static __inline__ uint64_t read_64bit_cfg_reg(uint64_t *base, unsigned int offset)
+{
+  return ((base)[offset]);
+}
+
+static __inline__ uint32_t xlp_get_field_w(uint32_t word, int lsb, int size)
+{
+	return ((word >> lsb) & XLP_BIT_MASK_W(size));
+}
+static __inline__ uint64_t xlp_get_field_dw(uint64_t dword, int lsb, int size)
+{
+	return ((dword >> lsb) & XLP_BIT_MASK_DW(size));
+}
+
+
+#if !defined(NLM_HAL_LINUX_USER)
+static __inline__ int nlm_read_prid(void)
+{
+        int res = 0;
+
+        asm volatile(         \
+                ".set push\n"           \
+                ".set noat\n"           \
+                ".set noreorder\n"      \
+                "mfc0 %0, $15, 0\n"      \
+                ".set pop\n"            \
+                : "=r" (res));
+
+        return res;
+}
+
+#else
+#define nlm_read_prid 			nlm_uaccess_processor_id
+#endif
+
+static __inline__ uint32_t nlm_read_ebase(void)
+{
+        uint32_t res = 0;
+
+        asm volatile(         \
+                ".set push\n"           \
+                ".set noat\n"           \
+                ".set noreorder\n"      \
+                "mfc0 %0, $15, 1\n"      \
+                ".set pop\n"            \
+                : "=r" (res));
+
+        return res;
+}
+
+
+/* Linux User Mode */
+#if defined(NLM_HAL_LINUX_USER)
+#include <nlm_uaccess.h>
+#define nlh_read_cfg_reg16(addr)       nlm_uaccess_mem_read16((NLH_XKPHYS_UNCACHED | (addr)))
+#define nlh_write_cfg_reg16(addr, val) nlm_uaccess_mem_write16((NLH_XKPHYS_UNCACHED | (addr)), (val))
+#define nlh_read_cfg_reg32(addr)       nlm_uaccess_mem_read32((NLH_XKPHYS_UNCACHED | (addr)))
+#define nlh_write_cfg_reg32(addr, val) nlm_uaccess_mem_write32((NLH_XKPHYS_UNCACHED | (addr)), (val))
+#define nlh_read_cfg_reg64(addr)       nlm_uaccess_mem_read64((NLH_XKPHYS_UNCACHED | (addr)))
+#define nlh_write_cfg_reg64(addr, val) nlm_uaccess_mem_write64((NLH_XKPHYS_UNCACHED | (addr)), (val))
+
+/* For Accessing Regex Registers in PCI Memory space */
+#define WRITE_REGX_CFG_REG_PCIM(reg, val)       nlh_write_cfg_reg32((xlp_regex_base_pcim + reg), (val))
+#define READ_REGX_CFG_REG_PCIM(reg)             nlh_read_cfg_reg32((xlp_regex_base_pcim + reg))
+
+#define nlh_send_msg4(dst, code, data0, data1, data2, data3) \
+  nlm_uaccess_msgsnd_4(code, dst, data0, data1, data2, data3)
+
+#define nlh_send_msg3(dst, code, data0, data1, data2) \
+  nlm_uaccess_msgsnd_3(code, dst, data0, data1, data2)
+
+#define nlh_send_msg2(dst, code, data0, data1) \
+  nlm_uaccess_msgsnd_2(code, dst, data0, data1)
+
+#define nlh_send_msg1(dst, code, data0) \
+  nlm_uaccess_msgsnd_1(code, dst, data0)
+
+/* Returns 1 on failure and 0 on success */
+#define nlh_recv_msg2(dst, src, size, code, data0, data1)	\
+  nlm_uaccess_msgrcv_2(dst, src, size, code, data0, data1)
+
+#define nlh_recv_msg1(dst, src, size, code, data0)	\
+  nlm_uaccess_msgrcv_1(dst, src, size, code, data0)
+
+/* NETOS and Linux Kernel Mdoe */
+#elif defined(NLM_HAL_NETOS) || defined(NLM_HAL_LINUX_KERNEL) \
+	|| defined(NLM_HAL_UBOOT) || defined(NLM_HAL_NETLBOOT) || defined(NLM_HAL_XLOADER)
+
+#define nlh_read_cfg_reg16(addr)       lh_40bit_phys_uncached(addr)
+#define nlh_write_cfg_reg16(addr, val) sh_40bit_phys_uncached(addr, val)
+#define nlh_read_cfg_reg32(addr)       lw_40bit_phys_uncached(addr)
+#define nlh_write_cfg_reg32(addr, val) sw_40bit_phys_uncached(addr, val)
+#define nlh_read_cfg_reg64(addr)       ld_40bit_phys_uncached(addr)
+#define nlh_write_cfg_reg64(addr, val) sd_40bit_phys_uncached(addr, val)
+
+
+#define nlh_send_msg4(dst, code, data0, data1, data2, data3) \
+  xlp_message_send_4(dst, code, data0, data1, data2, data3)
+
+#define nlh_send_msg3(dst, code, data0, data1, data2) \
+  xlp_message_send_3(dst, code, data0, data1, data2)
+
+#define nlh_send_msg2(dst, code, data0, data1) \
+  xlp_message_send_2(dst, code, data0, data1)
+
+#define nlh_send_msg1(dst, code, data0) \
+  xlp_message_send_1(dst, code, data0)
+
+#define nlh_recv_msg2(dst, src, size, code, data0, data1) \
+  xlp_message_receive_2(dst, src, size, code, data0, data1)
+
+#define nlh_recv_msg1(dst, src, size, code, data0) \
+  xlp_message_receive_1(dst, src, size, code, data0)
+
+#else
+#error "Unsupported platform for NL HAL"
+
+#endif
+
+#if !defined(NLM_HAL_LINUX_USER)
+static __inline__ uint32_t nlm_hard_cpuid(void)
+{
+	return nlm_read_ebase() & 0x3ff;
+}
+#else
+#define nlm_hard_cpuid			nlm_uaccess_hard_cpuid
+#endif
+
+static __inline__ uint32_t nlm_node_id(void)
+{
+	if (is_nlm_xlp8xx())
+		return (nlm_hard_cpuid() >> 5) & 0x3;
+	return 0;
+}
+
+static __inline__ uint32_t nlm_cpu_id(void)
+{
+	return nlm_hard_cpuid() & 0x1f;
+}
+
+#else  /* __ASSEMBLY__ */
+
+#if (_MIPS_SIM == _MIPS_SIM_ABI32) || (_MIPS_SIM == _MIPS_SIM_NABI32) || \
+    (_MIPS_SZLONG == 32)
+#define LW lw
+#define LA la
+#define SW sw
+#else
+#define LW ld
+#define LA dla
+#define SW sd
+#endif
+
+
+#endif /* __ASSEMBLY__ */
+
+
+#endif /* #ifndef _NLM_HAL_MACROS_H */
+
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_pic.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_pic.h
new file mode 100644
index 0000000..0a722f8
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_pic.h
@@ -0,0 +1,465 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef _NLM_HAL_PIC_H
+#define _NLM_HAL_PIC_H
+
+#include "nlm_hal.h"
+
+#define TIMER_CYCLES_MAXVAL        0xffffffffffffffffULL
+
+/*
+ *    IRT Map
+ */
+#define PIC_NUM_IRTS               160
+
+#define PIC_IRT_WD_0_INDEX         0
+#define PIC_IRT_WD_1_INDEX         1
+#define PIC_IRT_WD_NMI_0_INDEX     2
+#define PIC_IRT_WD_NMI_1_INDEX     3
+#define PIC_IRT_TIMER_0_INDEX      4
+#define PIC_IRT_TIMER_1_INDEX      5
+#define PIC_IRT_TIMER_2_INDEX      6
+#define PIC_IRT_TIMER_3_INDEX      7
+#define PIC_IRT_TIMER_4_INDEX      8
+#define PIC_IRT_TIMER_5_INDEX      9
+#define PIC_IRT_TIMER_6_INDEX      10
+#define PIC_IRT_TIMER_7_INDEX      11
+#define PIC_IRT_CLOCK_INDEX        PIC_IRT_TIMER_7_INDEX
+
+#define PIC_NUM_MSG_Q_IRTS         32
+#define PIC_IRT_MSG_Q0_INDEX       12
+#define PIC_IRT_MSG_Q_INDEX(qid)   ((qid) + PIC_IRT_MSG_Q0_INDEX) /* 12 - 43 */
+
+#define PIC_IRT_MSG_0_INDEX        44
+#define PIC_IRT_MSG_1_INDEX        45
+
+#define PIC_NUM_PCIE_MSIX_IRTS     32
+#define PIC_IRT_PCIE_MSIX_0_INDEX  46
+#define PIC_IRT_PCIE_MSIX_INDEX(num) ((num) + PIC_IRT_PCIE_MSIX_0_INDEX) /* 46 - 77 */
+
+#define PIC_NUM_PCIE_LINK_IRTS     4
+#define PIC_IRT_PCIE_LINK_0_INDEX  78
+#define PIC_IRT_PCIE_LINK_INDEX(num) ((num) + PIC_IRT_PCIE_LINK_0_INDEX) /* 78 - 81 */
+
+#define PIC_NUM_NA_IRTS            32
+#define PIC_IRT_NA_0_INDEX         82
+#define PIC_IRT_NA_INDEX(num)      ((num) + PIC_IRT_NA_0_INDEX) /* 82 - 113 */
+
+#define PIC_IRT_POE_INDEX          114
+
+#define PIC_NUM_USB_IRTS           6
+#define PIC_IRT_USB_0_INDEX        115
+#define PIC_IRT_USB_INDEX(num) ((num) + PIC_IRT_USB_0_INDEX) /* 115 - 120 */
+
+#define PIC_IRT_GDX_INDEX          121
+#define PIC_IRT_SEC_INDEX          122
+#define PIC_IRT_RSA_INDEX          123
+
+#define PIC_NUM_COMP_IRTS          4
+#define PIC_IRT_COMP_0_INDEX       124
+#define PIC_IRT_COMP_INDEX(num)    ((num) + PIC_IRT_COMP_0_INDEX) /* 124 - 127 */
+
+#define PIC_IRT_ICC_0_INDEX        129 /* ICC - Inter Chip Coherency */
+#define PIC_IRT_ICC_1_INDEX        130
+#define PIC_IRT_ICC_2_INDEX        131
+#define PIC_IRT_CAM_INDEX          132
+#define PIC_IRT_UART_0_INDEX       133
+#define PIC_IRT_UART_1_INDEX       134
+#define PIC_IRT_I2C_0_INDEX        135
+#define PIC_IRT_I2C_1_INDEX        136
+#define PIC_IRT_SYS_0              137
+#define PIC_IRT_SYS_1              138
+#define PIC_IRT_JTAG_INDEX         139
+#define PIC_IRT_PIC                140
+
+#define PIC_NUM_GPIO_IRTS          4
+#define PIC_IRT_GPIO_0_INDEX       146
+#define PIC_IRT_GPIO_INDEX(num)    ((num) + PIC_IRT_GPIO_0_INDEX) /* 146 - 149 */
+
+#define PIC_IRT_NOR                150
+#define PIC_IRT_NAND               151
+#define PIC_IRT_SPI                152
+#define PIC_IRT_MMC                153
+#define PIC_IRT_NBU                154
+#define PIC_IRT_TCU                155
+#define PIC_IRT_GCU                156 /* GBC - Global Coherency */
+#define PIC_IRT_DMC_0_INDEX        157
+#define PIC_IRT_DMC_1_INDEX        158
+#define PIC_IRT_TCB                159
+
+/*
+ *     Register Offsets
+ */
+#define PIC_CTRL             0x00
+#define PIC_BYTESWAP         0x01
+#define PIC_STATUS           0x02
+#define PIC_INT_TIMEOUT      0x03
+#define PIC_ICI0_INT_TIMEOUT 0x04
+#define PIC_ICI1_INT_TIMEOUT 0x05
+#define PIC_ICI2_INT_TIMEOUT 0x06
+#define PIC_IPI_CTL          0x07
+#define PIC_INT_ACK          0x08
+#define PIC_INT_PENDING0     0x09
+#define PIC_INT_PENDING1     0x0a
+#define PIC_INT_PENDING2     0x0b
+
+#define PIC_WD0_MAX_VAL      0x0c
+#define PIC_WD0_COUNT        0x0d
+#define PIC_WD0_MASK_0       0x0e
+#define PIC_WD0_MASK_1       0x0f
+#define PIC_WD0_HEARBEATCMD  0x10
+#define PIC_WD0_HEARBEAT_0   0x11
+#define PIC_WD0_HEARBEAT_1   0x12
+
+#define PIC_WD_MAX_VAL(id)    (PIC_WD0_MAX_VAL + ((id) ? 7 : 0))
+#define PIC_WD_COUNT(id)      (PIC_WD0_COUNT + ((id) ? 7 : 0))
+#define PIC_WD_MASK_0(id)     (PIC_WD0_MASK_0 + ((id) ? 7 : 0))
+#define PIC_WD_MASK_1(id)     (PIC_WD0_MASK_1 + ((id) ? 7 : 0))
+#define PIC_WD_HEARBEAT_0(id) (PIC_WD0_HEARTBEAT_0 + ((id) ? 7 : 0))
+#define PIC_WD_HEARBEAT_1(id) (PIC_WD0_HEARTBEAT_1 + ((id) ? 7 : 0))
+
+#define PIC_SYS_TIMER_0_MAX_VAL   0x1a
+#define PIC_SYS_TIMER_MAX_VAL(id) (PIC_SYS_TIMER_0_MAX_VAL + (id))
+
+#define PIC_SYS_TIMER_0_COUNTER   0x22
+#define PIC_SYS_TIMER_COUNTER(id) (PIC_SYS_TIMER_0_COUNTER + (id))
+
+#define PIC_TIMER_0_MAXVAL   PIC_SYS_TIMER_0_MAX_VAL
+#define PIC_TIMER_0_COUNTER  PIC_SYS_TIMER_0_COUNTER
+#define PIC_TIMER_7_MAXVAL   PIC_SYS_TIMER_MAX_VAL(7)
+#define PIC_TIMER_7_COUNTER  PIC_SYS_TIMER_COUNTER(7)
+#define PIC_TIMER_6_MAXVAL   PIC_SYS_TIMER_MAX_VAL(6)
+#define PIC_TIMER_6_COUNTER  PIC_SYS_TIMER_COUNTER(6)
+
+#define PIC_INT_THR_ENABLE_0_N01   0x2a
+#define PIC_INT_THR_ENABLE_0_N23   0x2b
+#define PIC_INT_THR_ENABLE_N01(id) (PIC_INT_THR_ENABLE_0_N01 + ((id) * 2))
+#define PIC_INT_THR_ENABLE_N23(id) (PIC_INT_THR_ENABLE_0_N23 + ((id) * 2))
+
+#define PIC_IRT_0   0x3a
+#define PIC_IRT(id) (PIC_IRT_0 + (id))
+
+#define PIC_IRT_WD_0        PIC_IRT(PIC_IRT_WD0_INDEX)
+#define PIC_IRT_WD_1        PIC_IRT(PIC_IRT_WD1_INDEX)
+#define PIC_IRT_TIMER_0     PIC_IRT(PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_TIMER_1     PIC_IRT(PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_TIMER_2     PIC_IRT(PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_TIMER_3     PIC_IRT(PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_TIMER_4     PIC_IRT(PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_TIMER_5     PIC_IRT(PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_TIMER_6     PIC_IRT(PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_TIMER_7     PIC_IRT(PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_CLOCK       PIC_IRT_TIMER_7
+#define PIC_IRT_UART_0      PIC_IRT(PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_UART_1      PIC_IRT(PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_I2C_0       PIC_IRT(PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_I2C_1       PIC_IRT(PIC_IRT_I2C_1_INDEX)
+
+#define PIC_CLOCK_TIMER     7
+#define PIC_IRQ_BASE        8
+
+#define ASM_XLP_IO_PIC_OFFSET        0xffffffffb8004100 /* TODO: This will change in to function */
+#define C_XLP_IO_PIC_OFFSET        0xffffffffb8004100ULL /* TODO: This will change in to function */
+
+#ifndef __ASSEMBLY__
+enum {
+	WD0 = 0,
+	WD1 = 1
+};
+extern int irt_irq_table[PIC_NUM_IRTS][4];
+extern int find_irt_from_irq(int irq_num);
+extern int nlm_hal_request_shared_irq(int irt);
+extern void nlm_hal_unrequest_shared_irq(int irt);
+
+static __inline__ int nlm_hal_irt_to_irq(int irt_num)
+{
+	if(irt_num < 0 || irt_num > PIC_NUM_IRTS)
+		return -1;
+
+	return irt_irq_table[irt_num][0];
+}
+
+static __inline__ int nlm_hal_irq_to_irt(int irq_num)
+{
+	int irt = find_irt_from_irq(irq_num);
+	return irt;
+}
+
+static __inline__ int nlm_hal_is_shared_irt(int irt_num)
+{
+	return irt_irq_table[irt_num][1];
+}
+
+#define PIC_IRT_FIRST_IRQ        (PIC_IRQ_BASE)
+#define PIC_WD_0_IRQ             nlm_hal_irt_to_irq(PIC_IRT_WD_0_INDEX)
+#define PIC_WD_1_IRQ             nlm_hal_irt_to_irq(PIC_IRT_WD_1_INDEX)
+#define PIC_TIMER_0_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_0_INDEX)
+#define PIC_TIMER_1_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_1_INDEX)
+#define PIC_TIMER_2_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_2_INDEX)
+#define PIC_TIMER_3_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_3_INDEX)
+#define PIC_TIMER_4_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_4_INDEX)
+#define PIC_TIMER_5_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_5_INDEX)
+#define PIC_TIMER_6_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_6_INDEX)
+#define PIC_TIMER_7_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_7_INDEX)
+#define PIC_CLOCK_IRQ            (PIC_TIMER_7_IRQ)
+#define PIC_UART_0_IRQ           17
+#define PIC_UART_1_IRQ           18
+#define PIC_I2C_0_IRQ            nlm_hal_irt_to_irq(PIC_IRT_I2C_0_INDEX)
+#define PIC_I2C_1_IRQ            nlm_hal_irt_to_irq(PIC_IRT_I2C_1_INDEX)
+#define PIC_GPIO_IRQ(num)        nlm_hal_irt_to_irq(PIC_IRT_GPIO_INDEX(num))
+#define PIC_IRT_LAST_IRQ_        (PIC_IRQ_BASE + PIC_NUM_IRTS - 1)
+#define PIC_IRT_LAST_IRQ()       PIC_IRT_LAST_IRQ_
+
+/*
+ *   Misc
+ */
+#define IRT_VALID       	1
+#define LOCAL_SCHEDULING    1
+#define GLOBAL_SCHEDULING   0
+#define PIC_IRQ_IS_IRT(irq) ((irq >= PIC_IRT_FIRST_IRQ) && (irq <= PIC_IRT_LAST_IRQ_))
+#define PIC_IRQ_IS_EDGE_TRIGGERED(irq) 0 /* XLP interrupts are level triggered */
+
+/*
+ *
+ */
+
+#define NODE_OFFSET(node) ((node) << 18)
+#define CPU_TO_NODE(cpu) ((cpu) >> 5)
+
+static __inline__ int nlm_hal_cpu_id(void)
+{
+	int cpu;
+
+	__asm__ __volatile__ (
+		".set push\n"
+		".set noreorder\n"
+		".set mips32\n"
+		"mfc0 %0, $15, 1\n"
+		"andi %0, %0, 0x3ff\n"
+		".set pop\n"
+		: "=r"(cpu)
+		);
+
+	return cpu;
+}
+
+#define XLP_IO_PIC_OFFSET        C_XLP_IO_PIC_OFFSET
+
+typedef volatile unsigned long long pic_reg_t;
+
+static __inline__ pic_reg_t* nlm_hal_pic_offset(void)
+{
+	uint32_t cpu = nlm_hal_cpu_id();
+
+	return ( (pic_reg_t *) (unsigned long) (XLP_IO_PIC_OFFSET + NODE_OFFSET( CPU_TO_NODE(cpu) )) );
+}
+
+#ifdef CONFIG_64BIT
+
+static __inline__ void nlm_hal_write_pic_reg(pic_reg_t *base, unsigned int offset, unsigned long long value)
+{
+	base[offset] = value;
+}
+static __inline__ unsigned long long nlm_hal_read_pic_reg(pic_reg_t *base, unsigned int offset)
+{
+	return ((base)[offset]);
+}
+
+#else
+
+static __inline__ void nlm_hal_write_pic_reg(pic_reg_t *base, unsigned int offset, unsigned long long value)
+{
+        uint32_t lsw, msw;
+        uint64_t val;
+        uint32_t ls, ms;
+        unsigned long flags;
+
+        lsw = (uint32_t)  (unsigned long long) (base+offset);
+        msw = (uint32_t) 0xffffffffUL;
+        val = (uint64_t)value;
+
+        ls = (uint32_t) (val & 0xffffffff);
+        ms = (uint32_t) (val >> 32);
+
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %2, 0\n"
+                        "dsll32 %1, 0\n"
+                        "dsrl32 %1, 0\n"
+                        "or $1, $1, %1\n"
+                        "dsll32 $8, %4, 0\n"
+                        "dsll32 %3, 0\n"
+                        "dsrl32 %3, 0\n"
+                        "or $8, $8, %3\n"
+                        "sd $8, 0($1) \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :
+                        :"r"(val), "r"(lsw), "r"(msw), "r"(ls), "r"(ms)
+                        :"$1", "$8");
+        disable_KX(flags);
+}
+
+static __inline__ unsigned long long nlm_hal_read_pic_reg(pic_reg_t *base, unsigned int offset)
+{
+        uint32_t lsw, msw;
+        uint64_t value = 0;
+        uint32_t lo, hi;
+        unsigned long flags;
+
+        lsw = (uint32_t) (unsigned long long) (base+offset);
+        msw = (uint32_t) 0xffffffffUL;
+
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %3, 0\n"
+                        "dsll32 %2, 0\n"
+                        "dsrl32 %2, 0\n"
+                        "or $1, $1, %2\n"
+                        "ld $8, 0($1) \n"
+                        "dsrl32 %1, $8, 0\n"
+                        "dsll32 $8, $8, 0\n"
+                        "dsrl32 %0, $8, 0\n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :"=r"(lo), "=r"(hi)
+                        :"r"(lsw), "r"(msw)
+                        :"$1", "$8");
+
+        disable_KX(flags);
+        value = hi;
+        value = (uint64_t) ((value<<32) | lo);
+        return (value);
+}
+
+#endif /* #ifdef CONFIG_64BIT */
+static __inline__ void nlm_hal_pic_send_ipi(int nmi, int vec, int node, int cpu)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	unsigned long long ipi = (nmi << 31) | (vec << 20) | (node << 17) | (1 << (cpu & 0xf));
+	if (cpu > 15) {
+		ipi |= 0x10000; /* Setting bit 16 to select cpus 16-31 */
+	}
+
+	nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, ipi);
+}
+
+static __inline__ unsigned long long nlm_hal_pic_read_control(void)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	return nlm_hal_read_pic_reg(mmio, PIC_CTRL);
+}
+
+static __inline__ void nlm_hal_pic_write_control(unsigned long long control)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_CTRL, control);
+}
+
+static __inline__ void nlm_hal_pic_update_control(unsigned long long control)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_CTRL, (control | nlm_hal_read_pic_reg(mmio, PIC_CTRL)));
+}
+
+static __inline__ void nlm_hal_ack_pic(int irt_num)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_INT_ACK, irt_num);
+
+	/* Ack the Status register for Watchdog & System timers */
+	if (irt_num < 12) {
+		nlm_hal_write_pic_reg(mmio, PIC_STATUS, (1 << irt_num));
+	}
+}
+
+static __inline__ unsigned long long nlm_hal_pic_read_irt(int irt_num)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	return nlm_hal_read_pic_reg(mmio, PIC_IRT(irt_num));
+}
+
+static __inline__ void nlm_hal_pic_write_irt(int irt_num, int en, int nmi, int sch, int vec, int dt, int db, int dte)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	unsigned long long val = (((en & 0x1) << 31) | ((nmi & 0x1) << 29) | ((sch & 0x1) << 28) |
+				  ((vec & 0x3f) << 20) | ((dt & 0x1 ) << 19) | ((db & 0x7) << 16) |
+				  (dte & 0xffff));
+
+	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt_num), val);
+}
+
+#define CPUIDBITS01(X) ((X) & 0x3)
+#define CPUIDBIT2(X) ((X >> 2) & 0x1)
+
+static __inline__ void nlm_hal_pic_write_irt_direct(int irt_num, int en, int nmi, int sch, int vec, int cpu)
+{
+	nlm_hal_pic_write_irt(irt_num, en, nmi, sch, vec, 1, CPUIDBIT2(cpu), CPUIDBITS01(cpu));
+	/* Does not support multi node support yet */
+}
+
+static __inline__ unsigned long long nlm_hal_pic_read_timer(int timer)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	return nlm_hal_read_pic_reg(mmio, PIC_SYS_TIMER_COUNTER(timer));
+}
+
+static __inline__ void nlm_hal_pic_write_timer(int timer, pic_reg_t value)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_SYS_TIMER_COUNTER(timer), value);
+}
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _NLM_HAL_PIC_H */
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_rsa.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_rsa.h
new file mode 100644
index 0000000..d3bc8e4
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_rsa.h
@@ -0,0 +1,962 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _NLM_HAL_RSA_H
+#define _NLM_HAL_RSA_H
+static uint64_t  nlm_rsa_ucode_data [] = {
+0x0000000000000000ULL,
+0x00000000503840ecULL,
+0x00000001903800ecULL,
+0x00000002c03820ecULL,
+0x0000003760000044ULL,
+0x0000000000000014ULL,
+0x000000071000000cULL,
+0x00000007d000010cULL,
+0x0000001b80000c0cULL,
+0x00000000e03fc0ecULL,
+0x00000001103fc1ecULL,
+0x00000001403f42ecULL,
+0x00000001403fc4ecULL,
+0x0000003760000044ULL,
+0x000000001800003cULL,
+0x0000000d8000030cULL,
+0x0000000630000044ULL,
+0x000000002800003cULL,
+0x0000000ef000030cULL,
+0x0000000630000044ULL,
+0x00000000503fc23cULL,
+0x00000000a03fc33cULL,
+0x00000001403fc43cULL,
+0x00000010c000030cULL,
+0x0000000630000044ULL,
+0x0000000000000014ULL,
+0x000000071000000cULL,
+0x0000001c1000070cULL,
+0x0000002500000d0cULL,
+0x00000027c0000e0cULL,
+0x0000002d60000f0cULL,
+0x00000002603f00ecULL,
+0x00000002603f82ecULL,
+0x00000002803f83ecULL,
+0x00000002803f04ecULL,
+0x00000002a03f06ecULL,
+0x00000002a03f88ecULL,
+0x0000003760000044ULL,
+0x000000086000010cULL,
+0x00000003f0000044ULL,
+0x00000008d000010cULL,
+0x00000004b0000044ULL,
+0x00000008d000010cULL,
+0x0000000570000044ULL,
+0x000000000000001cULL,
+0x000000076000000cULL,
+0x0000001c1000070cULL,
+0x0000002690000d0cULL,
+0x0000002990000e0cULL,
+0x0000002e10000f0cULL,
+0x00000003903f20ecULL,
+0x00000003903fa2ecULL,
+0x00000003b03fa3ecULL,
+0x00000003b03f24ecULL,
+0x00000003d03f26ecULL,
+0x00000003d03fa8ecULL,
+0x0000003760000044ULL,
+0x000000096000010cULL,
+0x00000003f0000044ULL,
+0x0000000a0000010cULL,
+0x00000004b0000044ULL,
+0x0000000a0000010cULL,
+0x0000000570000044ULL,
+0x000000000800003cULL,
+0x0000000af000020cULL,
+0x0000000bc000030cULL,
+0x000000129000040cULL,
+0x000000178000050cULL,
+0x000000191000060cULL,
+0x0000001ff000080cULL,
+0x000000205000090cULL,
+0x00000022c0000a0cULL,
+0x00000020b0000b0cULL,
+0x0000001ac0000c0cULL,
+0x0000000680000044ULL,
+0x000000001000003cULL,
+0x0000000b5000020cULL,
+0x0000000c5000030cULL,
+0x000000137000040cULL,
+0x00000017e000050cULL,
+0x000000197000060cULL,
+0x000000200000080cULL,
+0x000000206000090cULL,
+0x0000002340000a0cULL,
+0x0000002110000b0cULL,
+0x0000001b10000c0cULL,
+0x0000000680000044ULL,
+0x000000001800003cULL,
+0x0000000b5000020cULL,
+0x0000000d8000030cULL,
+0x000000154000040cULL,
+0x000000187000050cULL,
+0x0000001a0000060cULL,
+0x000000202000080cULL,
+0x000000208000090cULL,
+0x0000002410000a0cULL,
+0x00000021c0000b0cULL,
+0x0000001b80000c0cULL,
+0x0000000680000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x0000002ed01f80e4ULL,
+0x00000030101f81e4ULL,
+0x0000003760000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x00000030d01f00e4ULL,
+0x00000030d01f82e4ULL,
+0x00000034801f83e4ULL,
+0x00000035401e04e4ULL,
+0x00000037101f88e4ULL,
+0x00000035401f89e4ULL,
+0x0000003760000044ULL,
+0x0000000000000074ULL,
+0x0000000f0000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x0000000000000074ULL,
+0x0000000c000000a4ULL,
+0x0000000004004071ULL,
+0x0000000b0000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x0000000000000000ULL,
+0x0000000004000802ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000081000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x000000089000006cULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000091000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x0000000990000064ULL,
+0x000000004a8b0021ULL,
+0x0000000000898611ULL,
+0x0000000c000000a4ULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x0000000a40000064ULL,
+0x0000000088800021ULL,
+0x0000000880800423ULL,
+0x00000000001004a1ULL,
+0x0000000c000000a4ULL,
+0x00000002c88b0061ULL,
+0x0000000a808b0463ULL,
+0x00000000000000c4ULL,
+0x00000000058f0011ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000004d8f0021ULL,
+0x0000000b10000044ULL,
+0x00000007058f0013ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000034c0f0021ULL,
+0x0000000b058f0423ULL,
+0x0000000b70000044ULL,
+0x0000000000180001ULL,
+0x000000000b600031ULL,
+0x00000008000000a4ULL,
+0x0000000004800041ULL,
+0x00000008000000a4ULL,
+0x0000000007c03f41ULL,
+0x00000000440ac491ULL,
+0x00000004000000a4ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c3430431ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000117982861ULL,
+0x0000000088a03631ULL,
+0x00000002c3430c31ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000347cb2861ULL,
+0x000000034c09f691ULL,
+0x00000003040a8491ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000283430431ULL,
+0x000000080000009cULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000104202861ULL,
+0x0000000117d82861ULL,
+0x0000000088a02f31ULL,
+0x00000002c0833c31ULL,
+0x0000002283430c3bULL,
+0x0000000000000000ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x0000000307cb2861ULL,
+0x000000034c09ef91ULL,
+0x000000030409bc91ULL,
+0x00000003040a8491ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000283430531ULL,
+0x0000000a00038007ULL,
+0x0000000000000000ULL,
+0x000000012c002b41ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000000b8a02b31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c33c31ULL,
+0x0000000004900041ULL,
+0x0000002e83430d3bULL,
+0x0000000200038000ULL,
+0x0000000000000000ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000280830531ULL,
+0x0000001e80830433ULL,
+0x0000000283430431ULL,
+0x0000000b2c03ab67ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000002b8a3ab31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c32831ULL,
+0x0000000004900041ULL,
+0x0000000280832931ULL,
+0x0000001e80832833ULL,
+0x0000002e83430c3bULL,
+0x000000032c03ab61ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000000140001ULL,
+0x0000004000140001ULL,
+0x000000000b600061ULL,
+0x000000400b600061ULL,
+0x00000004000000a4ULL,
+0x0000000004800041ULL,
+0x0000004004800041ULL,
+0x00000004000000a4ULL,
+0x0000000007c03f41ULL,
+0x0000004007c03f41ULL,
+0x00000000440ac591ULL,
+0x00000040440ac591ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010140001ULL,
+0x0000004010140001ULL,
+0x0000000088e00061ULL,
+0x0000004088e00061ULL,
+0x00000002c3430561ULL,
+0x00000042c3430561ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000117f42961ULL,
+0x0000004117f42961ULL,
+0x0000000088e03f61ULL,
+0x0000004088e03f61ULL,
+0x00000002c3430d61ULL,
+0x00000042c3430d61ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000347eb2961ULL,
+0x0000004347eb2961ULL,
+0x000000034c7dff91ULL,
+0x000000434c7dff91ULL,
+0x00000003040a0591ULL,
+0x00000043040a0591ULL,
+0x00000000000000c4ULL,
+0x0000000010140001ULL,
+0x0000004010140001ULL,
+0x0000000088e00061ULL,
+0x0000004088e00061ULL,
+0x00000002c0c30561ULL,
+0x00000042c0c30561ULL,
+0x0000000004900041ULL,
+0x0000004004900041ULL,
+0x0000000283430561ULL,
+0x0000004283430561ULL,
+0x0000000b2c43ab47ULL,
+0x000000432c43ab41ULL,
+0x0000000344602961ULL,
+0x0000004344602961ULL,
+0x0000000317d72961ULL,
+0x0000004317d72961ULL,
+0x00000002b8e3ab61ULL,
+0x00000042b8e3ab61ULL,
+0x00000002c0c32961ULL,
+0x00000042c0c32961ULL,
+0x0000000004900041ULL,
+0x0000004004900041ULL,
+0x0000000283430d61ULL,
+0x0000007683430d6bULL,
+0x000000032c43ab41ULL,
+0x000000432c43ab41ULL,
+0x00000003446b2961ULL,
+0x00000043446b2961ULL,
+0x0000000307cb2961ULL,
+0x0000004307cb2961ULL,
+0x000000037c7de791ULL,
+0x000000437c7de791ULL,
+0x0000000304499d91ULL,
+0x0000004304499d91ULL,
+0x00000003040a0591ULL,
+0x00000043040a059dULL,
+0x0000000048840011ULL,
+0x00000000028b3691ULL,
+0x000000000e09c691ULL,
+0x000000000c09c691ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000212ab3691ULL,
+0x0000000080800411ULL,
+0x0000000002cb3691ULL,
+0x000000034c29ef91ULL,
+0x0000000006098491ULL,
+0x000000034c09ef91ULL,
+0x0000000004098491ULL,
+0x00000000000000c4ULL,
+0x00000000e8840011ULL,
+0x0000000210ab3a91ULL,
+0x0000000880800415ULL,
+0x00000006128b3699ULL,
+0x000000034c29eb91ULL,
+0x0000000f0409a893ULL,
+0x0000000026098891ULL,
+0x000000034c09eb91ULL,
+0x0000000f0409a893ULL,
+0x000000000409849dULL,
+0x0000000048841011ULL,
+0x00000000068b7691ULL,
+0x000000000e099611ULL,
+0x000000000c098611ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000216ab7691ULL,
+0x0000000080801411ULL,
+0x0000000006cb3691ULL,
+0x000000034c29af11ULL,
+0x0000000006099411ULL,
+0x000000034c09af11ULL,
+0x0000000004098411ULL,
+0x00000000000000c4ULL,
+0x00000000e8840011ULL,
+0x0000000214ab7a91ULL,
+0x0000000c80800415ULL,
+0x00000006168b3699ULL,
+0x0000000080801411ULL,
+0x00000002168b3691ULL,
+0x000000034c29ab11ULL,
+0x0000000f0409a813ULL,
+0x0000000026099811ULL,
+0x000000034c09ab11ULL,
+0x0000000f0409a813ULL,
+0x000000000409841dULL,
+0x0000000c000000d4ULL,
+0x0000000000000000ULL,
+0x000000004a801011ULL,
+0x000000000e004691ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000200098001ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000c00800415ULL,
+0x0000000584003699ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000a00098003ULL,
+0x000000000009800dULL,
+0x000000200000302aULL,
+0x00000000000e0012ULL,
+0x0000000000100211ULL,
+0x0000000002000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000ccULL,
+0x0000000006000302ULL,
+0x00000002810b0011ULL,
+0x0000000a808b0013ULL,
+0x0000000002010002ULL,
+0x00000006108b0093ULL,
+0x0000000002800002ULL,
+0x00000007040b0013ULL,
+0x0000000006800002ULL,
+0x00000007040b0013ULL,
+0x0000000003000002ULL,
+0x0000000000090101ULL,
+0x0000000200098001ULL,
+0x0000000a000b0003ULL,
+0x0000000007000302ULL,
+0x0000000400890015ULL,
+0x0000000784098019ULL,
+0x0000000007800002ULL,
+0x0000000000090001ULL,
+0x0000000000098101ULL,
+0x0000001dd000006cULL,
+0x000000280300060aULL,
+0x0000000000000000ULL,
+0x0000000000000e02ULL,
+0x0000000001000011ULL,
+0x00000010000000a4ULL,
+0x0000001dc0000064ULL,
+0x0000000000000f02ULL,
+0x0000000001000011ULL,
+0x0000000002000602ULL,
+0x0000000680890013ULL,
+0x0000000002806002ULL,
+0x0000000004000011ULL,
+0x000000031489f691ULL,
+0x0000000804000415ULL,
+0x000000071489b699ULL,
+0x0000000006000e02ULL,
+0x0000000680890013ULL,
+0x0000000006800e02ULL,
+0x0000000680898013ULL,
+0x0000002c0300540aULL,
+0x0000000007800012ULL,
+0x00000000000b8000ULL,
+0x000000000700cd42ULL,
+0x0000000000800011ULL,
+0x000000029489f691ULL,
+0x0000000800800415ULL,
+0x000000069489b699ULL,
+0x000000200000e02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000001dc0000064ULL,
+0x000000240000c02aULL,
+0x0000000002000012ULL,
+0x0000000600090003ULL,
+0x00000000000000c4ULL,
+0x000000001680409dULL,
+0x0000000014804091ULL,
+0x000000001680049dULL,
+0x0000000014804091ULL,
+0x0000000014800491ULL,
+0x000000001680049dULL,
+0x000000001680419dULL,
+0x0000000014804191ULL,
+0x000000001680049dULL,
+0x0000000014804191ULL,
+0x0000000014800491ULL,
+0x000000001680049dULL,
+0x0000000000800011ULL,
+0x00000000068b5691ULL,
+0x0000000004098611ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x0000000296cb569dULL,
+0x0000000000800011ULL,
+0x0000000294ab7691ULL,
+0x0000000000801411ULL,
+0x00000000068b3691ULL,
+0x000000034409af11ULL,
+0x0000000004098411ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x00000002948b7691ULL,
+0x0000000000801411ULL,
+0x0000000296cb369dULL,
+0x0000000000800011ULL,
+0x0000000294ab7691ULL,
+0x0000000000800411ULL,
+0x00000002948b3691ULL,
+0x0000000000801411ULL,
+0x00000000068b3a91ULL,
+0x000000034409ab11ULL,
+0x000000030409a411ULL,
+0x0000000004098411ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x00000002948b7691ULL,
+0x0000000000800411ULL,
+0x00000002948b3691ULL,
+0x0000000000801411ULL,
+0x0000000296cb369dULL,
+0x0000000001000011ULL,
+0x0000000006098611ULL,
+0x0000000000000000ULL,
+0x0000000007000e02ULL,
+0x0000000000888061ULL,
+0x0000000003000602ULL,
+0x0000000000888061ULL,
+0x00000000000984edULL,
+0x0000000001000011ULL,
+0x0000000b8409b615ULL,
+0x0000000400800419ULL,
+0x000000000609b611ULL,
+0x0000000007000e02ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8000ULL,
+0x0000000003000602ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8001ULL,
+0x00000000000985edULL,
+0x0000000001000011ULL,
+0x0000000b8409b615ULL,
+0x0000000400800419ULL,
+0x000000000609b611ULL,
+0x0000000007000e02ULL,
+0x0000000080800061ULL,
+0x00000002808b0461ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8000ULL,
+0x0000000003000602ULL,
+0x0000000080800061ULL,
+0x00000002808b0461ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8001ULL,
+0x00000000000985edULL,
+0x0000000002800002ULL,
+0x000000500220220aULL,
+0x000000140606550aULL,
+0x000000140606c50aULL,
+0x0000000002a01202ULL,
+0x000000500680100aULL,
+0x000000140286550aULL,
+0x000000000300d502ULL,
+0x000000500220340aULL,
+0x000000140306660aULL,
+0x000000140686c40aULL,
+0x000000140206660aULL,
+0x000000000600dd02ULL,
+0x000000500720550aULL,
+0x0000001806064c0aULL,
+0x000000180306c60aULL,
+0x0000000002001102ULL,
+0x000000500020c50aULL,
+0x000000000600e402ULL,
+0x000000500220440aULL,
+0x000000140606cc0aULL,
+0x000000000320d602ULL,
+0x000000500100e50aULL,
+0x000000180086c60aULL,
+0x00000000000000c4ULL,
+0x0000000002000002ULL,
+0x0000005002a0210aULL,
+0x000000140280540aULL,
+0x0000000003005502ULL,
+0x000000500620200aULL,
+0x000000140680c50aULL,
+0x0000000002004402ULL,
+0x0000005003a0cc0aULL,
+0x0000000002a03702ULL,
+0x000000500700c50aULL,
+0x000000140280650aULL,
+0x000000140280e50aULL,
+0x000000000000c502ULL,
+0x000000500120c70aULL,
+0x000000000200c402ULL,
+0x0000005000a0d50aULL,
+0x0000000000000000ULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x0000000006009202ULL,
+0x000000500220a10aULL,
+0x0000001806064c0aULL,
+0x0000000002808202ULL,
+0x0000005006a0a00aULL,
+0x000000180706d50aULL,
+0x000000000320cc02ULL,
+0x000000500280ee0aULL,
+0x0000000006a0d502ULL,
+0x000000500780a20aULL,
+0x000000140386dd0aULL,
+0x000000000300f602ULL,
+0x0000005002a0e50aULL,
+0x000000180306560aULL,
+0x0000000000000000ULL,
+0x000000180306760aULL,
+0x0000001806866d0aULL,
+0x000000000380f502ULL,
+0x0000005007a0450aULL,
+0x000000300281070aULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002bc000006cULL,
+0x000000000600dc02ULL,
+0x000000500020e60aULL,
+0x000000180086fc0aULL,
+0x000000140107170aULL,
+0x00000000000000c4ULL,
+0x000000000200a102ULL,
+0x000000500620920aULL,
+0x000000140600c40aULL,
+0x000000000200a002ULL,
+0x0000005006a0820aULL,
+0x000000140680d40aULL,
+0x000000140200dc0aULL,
+0x000000000700a202ULL,
+0x0000005002a0dd0aULL,
+0x000000000300c402ULL,
+0x0000005003a0350aULL,
+0x0000000000000000ULL,
+0x000000140300670aULL,
+0x000000000380d502ULL,
+0x0000005007a0e60aULL,
+0x0000000000000000ULL,
+0x0000001407807f0aULL,
+0x000000000380d102ULL,
+0x000000500320c00aULL,
+0x0000000000000000ULL,
+0x000000140380760aULL,
+0x0000000003007502ULL,
+0x0000005002a0d50aULL,
+0x000000000200f402ULL,
+0x0000005003a0e50aULL,
+0x000000300281070aULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002bc000006cULL,
+0x000000000000df02ULL,
+0x0000005000a0a60aULL,
+0x000000140101170aULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x000000300281020aULL,
+0x0000003006810a0aULL,
+0x0000003006010c0aULL,
+0x000000200000202aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002d1000006cULL,
+0x000000200000a02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002d5000006cULL,
+0x000000200000c02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002cd0000064ULL,
+0x00000034000000d4ULL,
+0x00000000000000c4ULL,
+0x0000000001000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x000000140001180aULL,
+0x000000140081190aULL,
+0x0000001401011a0aULL,
+0x00000000000000c4ULL,
+0x00000000000000c4ULL,
+0x0000000001810302ULL,
+0x0000005005a10b0aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140206340aULL,
+0x000000180606cb0aULL,
+0x0000000002000402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x0000000002801002ULL,
+0x0000005005a10b0aULL,
+0x000000140286b50aULL,
+0x000000140186300aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140606c50aULL,
+0x0000000002003402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x0000000004000002ULL,
+0x00000006808b0013ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x0000002ff000005cULL,
+0x0000002f4000004cULL,
+0x00000002000b0101ULL,
+0x0000000a000b0003ULL,
+0x0000003760000044ULL,
+0x0000000000000034ULL,
+0x0000000c0000000aULL,
+0x0000002ff0000054ULL,
+0x0000000c0000800aULL,
+0x0000002fb000004cULL,
+0x0000003640000044ULL,
+0x0000000c0000800aULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x0000003640000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0180430eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x0000000001010002ULL,
+0x00000006108b0093ULL,
+0x0000000005010002ULL,
+0x00000006108b0093ULL,
+0x0000000000000000ULL,
+0x00000032e01f80e4ULL,
+0x00000034401f81e4ULL,
+0x00000034601f82e4ULL,
+0x0000000c0181020aULL,
+0x0000000c0181030aULL,
+0x0000001c000000d4ULL,
+0x0000000000004002ULL,
+0x0000005000a0410aULL,
+0x0000000001004202ULL,
+0x000000500021000aULL,
+0x0000000000810102ULL,
+0x000000500121020aULL,
+0x000000200000202aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000000000000002ULL,
+0x0000000600098003ULL,
+0x0000000000810002ULL,
+0x0000000610898093ULL,
+0x0000003760000044ULL,
+0x0000000004000002ULL,
+0x00000006808b0013ULL,
+0x0000000004800102ULL,
+0x00000006808b0013ULL,
+0x0000000005000202ULL,
+0x00000006808b0013ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x000000342000005cULL,
+0x000000334000004cULL,
+0x0000001000000084ULL,
+0x00000006000b0009ULL,
+0x00000002000b0101ULL,
+0x0000002000000084ULL,
+0x00000006000b0009ULL,
+0x0000003760000044ULL,
+0x0000000000000034ULL,
+0x00000034000000d4ULL,
+0x0000003420000054ULL,
+0x00000038000000d4ULL,
+0x00000033e000004cULL,
+0x00000031d0000044ULL,
+0x00000038000000d4ULL,
+0x00000031d0000044ULL,
+0x00000034000000d4ULL,
+0x00000031d0000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x0000000005840002ULL,
+0x00000007040b0013ULL,
+0x0000003c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000200000402aULL,
+0x0000000000000012ULL,
+0x00000000000b0001ULL,
+0x0000000000098101ULL,
+0x0000003760000044ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0000400eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000036c01f87e4ULL,
+0x00000036401f89e4ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0400480eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000036a01f86e4ULL,
+0x000000080180000aULL,
+0x00000036601f84e4ULL,
+0x00000036801f85e4ULL,
+0x000000300001000aULL,
+0x0000003760000044ULL,
+0x000000140006800aULL,
+0x0000003640000044ULL,
+0x000000180006800aULL,
+0x0000003640000044ULL,
+0x0000000c0000800aULL,
+0x0000003640000044ULL,
+0x0000000c0181080aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x0000000c0000400aULL,
+0x0000003640000044ULL,
+0x0000000c0181000aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000140001140aULL,
+0x0000003640000044ULL,
+0x0000000c000000a4ULL,
+0x0000000000000044ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+};
+
+#endif				/*#ifndef _NLM_HAL_RSA_H_ */
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_sys.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_sys.h
new file mode 100644
index 0000000..65c0edc
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_sys.h
@@ -0,0 +1,182 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _NLH_SYS_H
+#define _NLH_SYS_H
+#if !defined(__KERNEL__) && !defined(NLM_HAL_UBOOT)
+#include <stdint.h>
+#endif
+
+#define COUNT_OF(x) ((sizeof(x)/sizeof(0[x])) / ((size_t)(!(sizeof(x) % sizeof(0[x])))))
+
+/* TODO: XLP9xx support for different REFCLKs. */
+/* 133.333 MHz Reference Clock */
+#define REF_CLK_NUM_400 400000000ULL
+#define REF_CLK_NUM_200 200000000ULL
+#define REF_CLK_NUM_125 125000000ULL
+#define REF_CLK_NUM_100 100000000ULL
+#define REF_CLK_DEN  3
+#define REF_CLK_DEN3 3
+#define REF_CLK_DEN1 1
+
+/* 1 MHz resolution for frequency setting */
+#define FREQ_RESOLUTION 1000000ULL
+
+/* System Clock Reg: Device:6, Func:5
+ * 0x56 Clock Disable Control
+ * 0x57 Clock Reset Control
+ * 0x58 Clock Bypass Control
+ * 0x59 Clock Divider Increment Control
+ * 0x5A clock Divider Decrement Control
+ */
+typedef enum soc_dfs_device {
+	DFS_DEVICE_NAE_2X = 0,
+	DFS_DEVICE_SAE    = 1,
+	DFS_DEVICE_RSA    = 2,
+	DFS_DEVICE_DTRE   = 3,
+	DFS_DEVICE_CMP    = 4, /*xlp8xx only*/
+	DFS_DEVICE_KBP    = 5, /*xlp8xx only*/
+	DFS_DEVICE_DMC    = 6,
+	DFS_DEVICE_NAND   = 7,
+	DFS_DEVICE_MMC    = 8,
+	DFS_DEVICE_NOR    = 9,
+	DFS_DEVICE_CORE   = 10, /*0xA*/
+	DFS_DEVICE_REGEX_SLOW    = 11, /*xlp3xx only 0xB*/
+	DFS_DEVICE_REGEX_FAST    = 12, /*xlp3xx only 0xC*/
+	DFS_DEVICE_SATA          = 13, /*xlp3xx only 0xD*/
+
+	XLP2XX_CLKDEVICE_NAE	= 0x10,
+	XLP2XX_CLKDEVICE_SAE	= 0x11,
+	XLP2XX_CLKDEVICE_RSA	= 0x12,
+	XLP2XX_CLKDEVICE_GDX	= 0x13,
+	XLP2XX_CLKDEVICE_CMP	= 0x14,
+	XLP2XX_CLKDEVICE_NAND	= 0x15,
+	XLP2XX_CLKDEVICE_MMC	= 0x16,
+	XLP2XX_CLKDEVICE_GBU	= 0x17,
+	XLP2XX_CLKDEVICE_RGXF	= 0x18,
+	XLP2XX_CLKDEVICE_RGXS	= 0x19,
+	XLP2XX_CLKDEVICE_USB	= 0x1a,
+	XLP2XX_CLKDEVICE_PIC	= 0x1b,
+	XLP2XX_CLKDEVICE_NULL	= 0x1c,
+
+	INVALID_DFS_DEVICE = 0xFF
+} soc_device_id_t;
+
+typedef struct xlp2xx_soc_freq_t {
+        uint32_t nae;
+        uint32_t sae;
+        uint32_t rsa;
+        uint32_t gdx;
+        uint32_t cmp;
+        uint32_t nand;
+        uint32_t mmc;
+        uint32_t gbu;
+        uint32_t rgxf;
+        uint32_t rgxs;
+        uint32_t usb;
+        uint32_t pic;
+} xlp2xx_soc_freq_s;
+
+extern xlp2xx_soc_freq_s xlp2xx_freq_tbl[2];
+extern const char* nlm_hal_xlp2xx_get_dev_name(soc_device_id_t dev);
+
+typedef soc_device_id_t xlp2xx_clkdev_t;
+
+#ifdef NLM_HAL_LINUX_KERNEL 
+#define NLM_HAL_DO_DIV(n, base)   if(base) { do_div((n), (base)); }
+#else
+#define NLM_HAL_DO_DIV(n, base)   if(base) { ((n) /= (base)); }
+#endif 
+
+/*XLP2XX soc dev*/
+typedef enum xlp2xx_pll_type {
+	CORE0_PLL = 0,
+	CORE1_PLL = 1,
+	SYS_PLL   = 2,
+	DMC_PLL   = 3,
+	DEV0_PLL  = 4,
+	DEV1_PLL  = 5,
+	DEV2_PLL  = 6
+} xlp2xx_pll_type_t;
+
+
+typedef enum xlp2xx_clkdev_sel{
+	SEL_REF_CLK	=0x0,
+	SEL_DEV0PLL	=0x1,
+	SEL_DEV1PLL	=0x2,
+	SEL_DEV2PLL	=0x3
+} xlp2xx_clkdev_sel_t;
+
+typedef enum xlp2xx_clkdev_div{
+	DIV_BYPASS	=0x0,
+	DIV_DIV2	=0x1,
+	DIV_DIV4	=0x2,
+	DIV_DIV8	=0x3
+} xlp2xx_clkdev_div_t;
+
+extern uint8_t nlm_hal_get_soc_clock_state(int node, soc_device_id_t device);
+extern void nlm_hal_soc_clock_enable(int node, soc_device_id_t device);
+extern void nlm_hal_soc_clock_disable(int node, soc_device_id_t device);
+extern void nlm_hal_soc_clock_reset(int node, soc_device_id_t device);
+
+extern uint64_t nlm_hal_get_soc_freq(int node, soc_device_id_t device);
+extern uint64_t nlm_hal_set_soc_freq(int node, soc_device_id_t device, uint64_t freq);
+extern uint64_t nlm_hal_get_core_freq(int node, uint8_t core);
+extern uint64_t nlm_hal_set_core_freq(int node, uint8_t core, uint64_t freq);
+extern unsigned long long nlm_hal_cpu_freq(void);
+extern int nlm_hal_is_ref_clk_133MHz(void);
+extern uint64_t nlm_hal_get_ref_clk_freq(void);
+
+#define XLP_LOW_FREQ_SEL  0
+#define XLP_HIGH_FREQ_SEL 1
+extern void nlm_hal_adjust_soc_freqs(int node, int freq_sel);
+
+
+/*xlp2xx based APIs*/
+extern uint64_t xlp2xx_get_ref_clk(int node, uint64_t* ref_clk_num, uint32_t* ref_clk_den);
+extern uint64_t nlm_hal_xlp2xx_set_clkdev_frq(int node, soc_device_id_t dev_type, uint64_t frq);
+extern uint64_t nlm_hal_xlp2xx_get_clkdev_frq(int node, soc_device_id_t dev_type);
+
+#define NLM_HALT_IF(cond) while(cond) { \
+                nlm_print("ERROR: %s\n", __FUNCTION__); \
+                nlm_mdelay(10000); \
+        }
+
+#define NLM_HALT_IF_XLPII() NLM_HALT_IF(is_nlm_xlp2xx())
+#define XLP_DISABLE 1
+#define XLP_ENABLE  0
+
+
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
new file mode 100644
index 0000000..9015c18
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
@@ -0,0 +1,1524 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef NLM_HAL_XLP_DEV_H
+#define NLM_HAL_XLP_DEV_H
+
+#include <brcm_xlp_cpu.h>
+
+#define XLP_CACHELINE_SIZE	64
+/*
+ * This File has all the XLP Device specific Defines
+ */
+#define XLP_PCIE_CFG_SIZE 0x1000 /* 4K */
+#define XLP_PCIE_DEV_BLK_SIZE 0x8000 /* 4k per function  and 8 function in a dev block */
+#define XLP_PCIE_BUS_BLK_SIZE (256 * XLP_PCIE_DEV_BLK_SIZE)
+
+/*XLP8XX/4XX B0 and A2 supported apis*/
+#define CHIP_PROCESSOR_ID_XLP_8XX    0
+#define CHIP_PROCESSOR_ID_XLP_8_4_XX 0x10
+#define CHIP_PROCESSOR_ID_XLP_3XX    0x11
+#define CHIP_PROCESSOR_ID_XLP_2XX    0x12
+#define CHIP_PROCESSOR_ID_XLP_9XX    0x15
+
+/*XLP 8XX  A0,A1,A2 chip support*/
+#define CHIP_PROCESSOR_ID_XLP_832   CHIP_PROCESSOR_ID_XLP_8_4_XX
+#define CHIP_PROCESSOR_ID_XLP_816   0x14
+#define CHIP_PROCESSOR_ID_XLP_432   0x90
+#define CHIP_PROCESSOR_ID_XLP_416   0x94
+#define CHIP_PROCESSOR_ID_XLP_408   0x95
+#define CHIP_PROCESSOR_ID_XLP_208   0xB5
+#define CHIP_PROCESSOR_ID_XLP_204   0xB7
+#define CHIP_PROCESSOR_ID_XLP_104   0xF7
+
+/*Software Revision Number        XLP8XX  XLP3XX */
+#define XLP_REVISION_A0  0x00 /*    0        0   */
+#define XLP_REVISION_A1  0x01 /*    1        1   */
+#define XLP_REVISION_A2  0x02 /*    2            */
+#define XLP_REVISION_B0  0x03 /*    3        2   */
+#define XLP_REVISION_B1  0x04 /*    4        3   */
+
+#define XLP_REVISION_AX  0xAF
+#define XLP_REVISION_BX  0xBF
+#define XLP_REVISION_INV 0xFE
+#ifndef XLP_REVISION_ANY
+#define XLP_REVISION_ANY 0xFF
+#endif
+
+/*XLP 3XX EXTPID type */
+/*xlp3xx Base
+ *--------
+ *xlp316 : 4x4 16 threads
+ *xlp308   2x4  8 threads
+ *xlp304   1x4  4 threads
+ *xlp208a  2x4  8 trheads
+ *xlp108a  2x4  8 trheads
+ *xlp204a  1x4  4 trheads
+ *xlp104a  1x4  4 trheads
+ *xlp202a  2x1  2 trheads
+ *xlp201a  1x1  1 trheads
+ *xlp101a  1x1  1 trheads
+ */
+#define CPU_EXTPID_XLP_3XX_NONE  0x00
+#define CPU_EXTPID_XLP_3XX_BASE  0x00
+
+#define CPU_EXTPID_XLP_3XX_L    0x01
+#define CPU_EXTPID_XLP_3XX_LP   0x02
+#define CPU_EXTPID_XLP_3XX_LP2  0x03
+
+#define CPU_EXTPID_XLP_208a     0x06
+#define CPU_EXTPID_XLP_108a     0x07
+#define CPU_EXTPID_XLP_204a     0x05
+#define CPU_EXTPID_XLP_104a     0x04
+#define CPU_EXTPID_XLP_202a     0x08
+#define CPU_EXTPID_XLP_201a     0x09
+#define CPU_EXTPID_XLP_101a     0x0A
+
+#define CPU_EXTPID_XLP_3XX_MAX   0x0F
+
+#define CPU_EXTPID_XLP_3XX_INV   0xFE  	 /* invalid */
+#define CPU_EXTPID_XLP_3XX_ANY   0xFF	 /* Any 3XX */
+
+#ifndef __ASSEMBLY__
+#ifndef __XLP_CHIPID_MACROS__
+#define __XLP_CHIPID_MACROS__
+
+extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
+
+/* 16 bits Software CPU ID Encoding rule:
+ * [15:12]: xlp family: 2, 3, 8, 9
+ * [11:04]: num of cores
+ * [ 3: 0]: num of threads per core
+ */
+
+#ifndef is_nlm_xlp8xx
+#define is_nlm_xlp8xx()      ( is_nlm_xlp(0x8000, XLP_REVISION_ANY, 0) || is_nlm_xlp(0x4000, XLP_REVISION_ANY, 0))
+#endif /* is_nlm_xlp8xx */
+
+#define is_nlm_xlp8xx_ax()   ( is_nlm_xlp(0x8000, XLP_REVISION_AX,  0) || is_nlm_xlp(0x4000, XLP_REVISION_AX, 0))
+#define is_nlm_xlp8xx_b0()   ( is_nlm_xlp(0x8000, XLP_REVISION_B0,  0) || is_nlm_xlp(0x4000, XLP_REVISION_B0, 0))
+#define is_nlm_xlp8xx_b1()   ( is_nlm_xlp(0x8000, XLP_REVISION_B1,  0) || is_nlm_xlp(0x4000, XLP_REVISION_B1, 0))
+#define is_nlm_xlp8xx_bx()   ( is_nlm_xlp(0x8000, XLP_REVISION_BX,  0) || is_nlm_xlp(0x4000, XLP_REVISION_BX, 0))
+#define is_nlm_xlp832_ax()   ( is_nlm_xlp(0x8084, XLP_REVISION_AX,  0))
+
+#define is_nlm_xlp8xx_832() is_nlm_xlp(0x8084, XLP_REVISION_ANY, 0)
+#define is_nlm_xlp8xx_824() is_nlm_xlp(0x8064, XLP_REVISION_ANY, 0)
+#define is_nlm_xlp8xx_816() is_nlm_xlp(0x8044, XLP_REVISION_ANY, 0)
+
+#define is_nlm_xlp8xx_432() is_nlm_xlp(0x4084, XLP_REVISION_ANY, 0)
+#define is_nlm_xlp8xx_424() is_nlm_xlp(0x4064, XLP_REVISION_ANY, 0)
+#define is_nlm_xlp8xx_416() is_nlm_xlp(0x4044, XLP_REVISION_ANY, 0)
+#define is_nlm_xlp8xx_408() is_nlm_xlp(0x8024, XLP_REVISION_ANY, 0)
+
+#define is_nlm_xlp3xx_B(rev)      ( is_nlm_xlp(0x3000, rev, CPU_EXTPID_XLP_3XX_BASE))
+#define is_nlm_xlp316_B(rev)      ( is_nlm_xlp(0x3044, rev, CPU_EXTPID_XLP_3XX_BASE))
+#define is_nlm_xlp312_B(rev)      ( is_nlm_xlp(0x3034, rev, CPU_EXTPID_XLP_3XX_BASE))
+#define is_nlm_xlp308_B(rev)      ( is_nlm_xlp(0x3024, rev, CPU_EXTPID_XLP_3XX_BASE))
+#define is_nlm_xlp304_B(rev)      ( is_nlm_xlp(0x3014, rev, CPU_EXTPID_XLP_3XX_BASE))
+
+#define is_nlm_xlp3xx_L(rev)      ( is_nlm_xlp(0x3000, rev, CPU_EXTPID_XLP_3XX_L))
+#define is_nlm_xlp316_L(rev)      ( is_nlm_xlp(0x3044, rev, CPU_EXTPID_XLP_3XX_L))
+#define is_nlm_xlp312_L(rev)      ( is_nlm_xlp(0x3034, rev, CPU_EXTPID_XLP_3XX_L))
+#define is_nlm_xlp308_L(rev)      ( is_nlm_xlp(0x3024, rev, CPU_EXTPID_XLP_3XX_L))
+#define is_nlm_xlp304_L(rev)      ( is_nlm_xlp(0x3014, rev, CPU_EXTPID_XLP_3XX_L))
+
+#define is_nlm_xlp3xx_LP(rev)      ( is_nlm_xlp(0x3000, rev, CPU_EXTPID_XLP_3XX_LP))
+#define is_nlm_xlp316_LP(rev)      ( is_nlm_xlp(0x3044, rev, CPU_EXTPID_XLP_3XX_LP))
+#define is_nlm_xlp312_LP(rev)      ( is_nlm_xlp(0x3034, rev, CPU_EXTPID_XLP_3XX_LP))
+#define is_nlm_xlp308_LP(rev)      ( is_nlm_xlp(0x3024, rev, CPU_EXTPID_XLP_3XX_LP))
+#define is_nlm_xlp304_LP(rev)      ( is_nlm_xlp(0x3014, rev, CPU_EXTPID_XLP_3XX_LP))
+
+#define is_nlm_xlp3xx_LP2(rev)      ( is_nlm_xlp(0x3000, rev, CPU_EXTPID_XLP_3XX_LP2))
+#define is_nlm_xlp316_LP2(rev)      ( is_nlm_xlp(0x3044, rev, CPU_EXTPID_XLP_3XX_LP2))
+#define is_nlm_xlp312_LP2(rev)      ( is_nlm_xlp(0x3034, rev, CPU_EXTPID_XLP_3XX_LP2))
+#define is_nlm_xlp308_LP2(rev)      ( is_nlm_xlp(0x3024, rev, CPU_EXTPID_XLP_3XX_LP2))
+#define is_nlm_xlp304_LP2(rev)      ( is_nlm_xlp(0x3014, rev, CPU_EXTPID_XLP_3XX_LP2))
+
+#define is_nlm_xlp316_rev(rev)  (is_nlm_xlp316_B(rev) || is_nlm_xlp316_L(rev) || is_nlm_xlp316_LP(rev) || is_nlm_xlp316_LP2(rev))
+#define is_nlm_xlp312_rev(rev)  (is_nlm_xlp312_B(rev) || is_nlm_xlp312_L(rev) || is_nlm_xlp312_LP(rev) || is_nlm_xlp312_LP2(rev))
+#define is_nlm_xlp308_rev(rev)  (is_nlm_xlp308_B(rev) || is_nlm_xlp308_L(rev) || is_nlm_xlp308_LP(rev) || is_nlm_xlp308_LP2(rev))
+#define is_nlm_xlp304_rev(rev)  (is_nlm_xlp304_B(rev) || is_nlm_xlp304_L(rev) || is_nlm_xlp304_LP(rev) || is_nlm_xlp304_LP2(rev))
+
+#define is_nlm_xlp316() is_nlm_xlp316_rev(XLP_REVISION_ANY)
+#define is_nlm_xlp312() is_nlm_xlp312_rev(XLP_REVISION_ANY)
+#define is_nlm_xlp308() is_nlm_xlp308_rev(XLP_REVISION_ANY)
+#define is_nlm_xlp304() is_nlm_xlp304_rev(XLP_REVISION_ANY)
+
+#define is_nlm_xlp3xx_rev(rev) (is_nlm_xlp(0x3000, rev, CPU_EXTPID_XLP_3XX_ANY))
+#define is_nlm_xlp3xx()	     is_nlm_xlp3xx_rev(XLP_REVISION_ANY)
+#define is_nlm_xlp3xx_ax()   is_nlm_xlp3xx_rev(XLP_REVISION_AX)
+#define is_nlm_xlp3xx_bx()   is_nlm_xlp3xx_rev(XLP_REVISION_BX)
+#define is_nlm_xlp3xx_b0()   is_nlm_xlp3xx_rev(XLP_REVISION_B0)
+
+#define is_nlm_xlp3xx_208a()      ( is_nlm_xlp(0x3024, XLP_REVISION_ANY, CPU_EXTPID_XLP_208a))
+#define is_nlm_xlp3xx_108a()      ( is_nlm_xlp(0x3024, XLP_REVISION_ANY, CPU_EXTPID_XLP_108a))
+
+#define is_nlm_xlp3xx_204a()      ( is_nlm_xlp(0x3014, XLP_REVISION_ANY, CPU_EXTPID_XLP_204a))
+#define is_nlm_xlp3xx_104a()      ( is_nlm_xlp(0x3014, XLP_REVISION_ANY, CPU_EXTPID_XLP_104a))
+
+#define is_nlm_xlp3xx_202a()      ( is_nlm_xlp(0x3021, XLP_REVISION_ANY, CPU_EXTPID_XLP_202a))
+#define is_nlm_xlp3xx_201a()      ( is_nlm_xlp(0x3011, XLP_REVISION_ANY, CPU_EXTPID_XLP_201a))
+#define is_nlm_xlp3xx_101a()      ( is_nlm_xlp(0x3011, XLP_REVISION_ANY, CPU_EXTPID_XLP_101a))
+
+#define is_nlm_xlp3xx_lite()  (is_nlm_xlp3xx() && (!is_nlm_xlp3xx_B(XLP_REVISION_ANY)) )
+
+#define is_nlm_xlp2xx()	    is_nlm_xlp(0x2000, XLP_REVISION_ANY,  0)
+#define is_nlm_xlp9xx()	    is_nlm_xlp(0x9000, XLP_REVISION_ANY,  0)
+
+#endif /*__XLP_CHIPID_MACROS__ */
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ *    FMN
+ */
+#define XLP_STN_RX_QSIZE 256
+
+#define XLP_STNID_CPU0          0x00
+#define XLP_STNID_CPU1          0x10
+#define XLP_STNID_CPU2          0x20
+#define XLP_STNID_CPU3          0x30
+#define XLP_STNID_CPU4          0x40
+#define XLP_STNID_CPU5          0x50
+#define XLP_STNID_CPU6          0x60
+#define XLP_STNID_CPU7          0x70
+#define XLP_STNID_PCIE0         0x100
+#define XLP_STNID_PCIE1         0x102
+#define XLP_STNID_PCIE2         0x104
+#define XLP_STNID_PCIE3         0x106
+#define XLP_STNID_GDX           0x108
+#define XLP_STNID_RSA_ECC       0x110
+#define XLP_STNID_CRYPTO        0x119
+#define XLP_STNID_CMP           0x129
+#define XLP_STNID_POE           0x180
+#define XLP_STNID_NAE_TX        0x1DC
+#define XLP_STNID_NAE_RX        0x3E8
+#define XLP_STNID_INVALID       0x400
+#define XLP_MAX_TX_STNS         20
+
+#define XLP_PCIE0_VC_BASE       256
+#define XLP_PCIE0_VC_LIMIT      257
+#define XLP_PCIE1_VC_BASE       258
+#define XLP_PCIE1_VC_LIMIT      259
+#define XLP_PCIE2_VC_BASE       260
+#define XLP_PCIE2_VC_LIMIT      261
+#define XLP_PCIE3_VC_BASE       262
+#define XLP_PCIE3_VC_LIMIT      263
+#define XLP_GDX_VC_BASE         264
+#define XLP_GDX_VC_LIMIT        267
+#define XLP_RSA_ECC_VC_BASE     272
+#define XLP_RSA_ECC_VC_LIMIT    280
+#define XLP_CRYPTO_VC_BASE      281
+#define XLP_CRYPTO_VC_LIMIT     296
+#define XLP_CMP_VC_BASE         297
+#define XLP_CMP_VC_LIMIT        304
+#define XLP_POE_VC_BASE         384
+#define XLP_POE_VC_LIMIT        391
+#define XLP_NET_TX_VC_BASE      476
+#define XLP_NET_TX_VC_LIMIT     999
+#define XLP_NET_RX_VC_BASE      1000
+#define XLP_NET_RX_VC_LIMIT     1019
+#define XLP_NET_VC_BASE         XLP_NET_TX_VC_BASE
+#define XLP_NET_VC_LIMIT        1023
+
+#define XLP_POPQ_VC_BASE	128
+#define XLP_POPQ_VC_LIMIT	255
+
+#define XLP_CPU0_VC_BASE	0
+#define XLP_CPU0_VC_LIMIT       15
+#define XLP_CPU1_VC_LIMIT       31
+#define XLP_CPU2_VC_LIMIT       47
+#define XLP_CPU3_VC_LIMIT       63
+#define XLP_CPU4_VC_LIMIT       79
+#define XLP_CPU5_VC_LIMIT       95
+#define XLP_CPU6_VC_LIMIT       111
+#define XLP_CPU7_VC_LIMIT       127
+
+/* XLP_3XX */
+
+#define XLP_3XX_MAX_NAE_UCORES	8
+
+#define XLP_3XX_REGEX_VC_BASE       268
+#define XLP_3XX_REGEX_VC_LIMIT      271
+
+#define XLP_3XX_RSA_ECC_VC_BASE     272
+#define XLP_3XX_RSA_ECC_VC_LIMIT    275
+
+#define XLP_3XX_CRYPTO_VC_BASE      276
+#define XLP_3XX_CRYPTO_VC_LIMIT     279
+
+#define XLP_3XX_SRIO_VC_BASE        280
+#define XLP_3XX_SRIO_VC_LIMIT       288
+#define XLP_3XX_B0_SRIO_VC_LIMIT    289
+
+
+#define XLP_3XX_POE_VC_BASE         384
+#define XLP_3XX_POE_VC_LIMIT        391
+#define XLP_3XX_NET_TX_VC_BASE      432
+#define XLP_3XX_NET_TX_VC_LIMIT     495
+#define XLP_3XX_NET_RX_VC_BASE      496
+#define XLP_3XX_NET_RX_VC_LIMIT     503 /* 511 */
+#define XLP_3XX_NET_VC_BASE	      XLP_3XX_NET_TX_VC_BASE
+#define XLP_3XX_NET_VC_LIMIT        511
+
+#define XLP_INVALID_STATION		0xFFFF	
+#define XLP_3XX_INVALID_STATION		XLP_INVALID_STATION
+
+/* XLP2XX */
+#define XLP_2XX_CDE_VC_BASE         266
+#define XLP_2XX_CDE_VC_LIMIT        267
+
+#define XLP_2XX_REGEX_VC_BASE       268
+#define XLP_2XX_REGEX_VC_LIMIT      271
+
+#define XLP_2XX_RSA_ECC_VC_BASE     272
+#define XLP_2XX_RSA_ECC_VC_LIMIT    272
+
+#define XLP_2XX_CRYPTO_VC_BASE      276
+#define XLP_2XX_CRYPTO_VC_LIMIT     276
+
+#define XLP_2XX_POE_VC_BASE         384
+#define XLP_2XX_POE_VC_LIMIT        391
+#define XLP_2XX_NET_TX_VC_BASE      432
+#define XLP_2XX_NET_TX_VC_LIMIT     495
+#define XLP_2XX_NET_RX_VC_BASE      496
+#define XLP_2XX_NET_RX_VC_LIMIT     503 /* 511 */
+#define XLP_2XX_NET_VC_BASE	    XLP_2XX_NET_TX_VC_BASE
+#define XLP_2XX_NET_VC_LIMIT        511
+
+#define XLP_2XX_INVALID_STATION		XLP_INVALID_STATION
+
+// XLP9XX
+
+#define XLP_STNID_CPU8          0x80
+#define XLP_STNID_CPU9          0x90
+#define XLP_STNID_CPU10         0xA0
+#define XLP_STNID_CPU11         0xB0
+#define XLP_STNID_CPU12         0xC0
+#define XLP_STNID_CPU13         0xD0
+#define XLP_STNID_CPU14         0xE0
+#define XLP_STNID_CPU15         0xF0
+#define XLP_STNID_CPU16         0x100
+#define XLP_STNID_CPU17         0x110
+#define XLP_STNID_CPU18         0x120
+#define XLP_STNID_CPU19         0x130
+
+#define XLP_CPU8_VC_LIMIT       0x8F
+#define XLP_CPU9_VC_LIMIT       0x9F
+#define XLP_CPU10_VC_LIMIT      0xAF
+#define XLP_CPU11_VC_LIMIT      0xBF
+#define XLP_CPU12_VC_LIMIT      0xCF
+#define XLP_CPU13_VC_LIMIT      0xDF
+#define XLP_CPU14_VC_LIMIT      0xEF
+#define XLP_CPU15_VC_LIMIT      0xFF
+#define XLP_CPU16_VC_LIMIT      0x10F
+#define XLP_CPU17_VC_LIMIT      0x11F
+#define XLP_CPU18_VC_LIMIT      0x12F
+#define XLP_CPU19_VC_LIMIT      0x13F
+
+#define XLP_9XX_PCIE0_VC_BASE	0x180
+#define XLP_9XX_PCIE0_VC_LIMIT	0x181
+#define XLP_9XX_PCIE1_VC_BASE	0x182
+#define XLP_9XX_PCIE1_VC_LIMIT	0x183
+#define XLP_9XX_PCIE2_VC_BASE	0x184
+#define XLP_9XX_PCIE2_VC_LIMIT	0x185
+#define XLP_9XX_PCIE3_VC_BASE	0x186
+#define XLP_9XX_PCIE3_VC_LIMIT	0x187
+
+#define XLP_9XX_GDX0_VC_BASE	0x188
+#define XLP_9XX_GDX0_VC_LIMIT	0x189
+#define XLP_9XX_GDX1_VC_BASE	0x18A
+#define XLP_9XX_GDX1_VC_LIMIT	0x18B
+#define XLP_9XX_CMP_VC_BASE	0x190
+#define XLP_9XX_CMP_VC_LIMIT	0x196
+#define XLP_9XX_LZS_VC_BASE	0x19C
+#define XLP_9XX_LZS_VC_LIMIT	0x1A2
+#define XLP_9XX_SEC_VC_BASE	0x1A8
+#define XLP_9XX_SEC_VC_LIMIT	0x1AF
+#define XLP_9XX_RSA_VC_BASE	0x1C0
+#define XLP_9XX_RSA_VC_LIMIT	0x1C3
+#define XLP_9XX_RGX_VC_BASE	0x1CC
+#define XLP_9XX_RGX_VC_LIMIT	0x1CF
+#define XLP_9XX_KBP_VC_BASE	0x1DC
+#define XLP_9XX_KBP_VC_LIMIT	0x1DF
+
+#define XLP_9XX_POE0_VC_BASE	0x200
+#define XLP_9XX_POE0_VC_LIMIT	0x207
+#define XLP_9XX_NET0_VC_BASE	0x208
+#define XLP_9XX_NET0_VC_LIMIT	0x257
+#define XLP_9XX_POE1_VC_BASE	0x280
+#define XLP_9XX_POE1_VC_LIMIT	0x287
+#define XLP_9XX_NET1_VC_BASE	0x288
+#define XLP_9XX_NET1_VC_LIMIT	0x2D7
+#define XLP_9XX_ALE_VC_BASE	0x2DA
+#define XLP_9XX_ALE_VC_LIMIT	0x2DB
+
+#define XLP_9XX_POPQ_VC_BASE	0x300
+#define XLP_9XX_POPQ_VC_LIMIT	0x3FF
+
+#define XLP_9XX_INVALID_STATION		0x2FF
+
+#define XLP_9XX_NET0_TX_VC_BASE      520
+#define XLP_9XX_NET0_TX_VC_LIMIT     583
+#define XLP_9XX_NET0_RX_VC_BASE      584
+#define XLP_9XX_NET0_RX_VC_LIMIT     599
+
+#define XLP_9XX_NET1_TX_VC_BASE      648
+#define XLP_9XX_NET1_TX_VC_LIMIT     711
+#define XLP_9XX_NET1_RX_VC_BASE      712
+#define XLP_9XX_NET1_RX_VC_LIMIT     727
+
+#define XLP9XX_NAE0_DEVICE               3
+#define XLP9XX_NAE0_FUNC                 0
+
+#define XLP9XX_NAE1_DEVICE              3
+#define XLP9XX_NAE1_FUNC                3
+
+#define XLP9XX_POE0_DEVICE               3
+#define XLP9XX_POE0_FUNC                 1
+
+#define XLP9XX_POE1_DEVICE              3
+#define XLP9XX_POE1_FUNC                4 
+
+#define XLP9XX_ALE_DEVICE               3
+#define XLP9XX_ALE_FUNC                 5 
+
+/*Sw Code */
+#define XLP_CODE_MAC		0
+#define XLP_CODE_SEC		1
+#define XLP_CODE_BOOT_WAKEUP	200
+
+/*Cop2 Regs */
+#define XLP_TX_BUF_REG		$0
+#define XLP_RX_BUF_REG		$1
+#define XLP_MSG_TXSTATUS_REG	$2
+#define XLP_MSG_RXSTATUS_REG	$3
+#define XLP_MSG_STATUS1_REG	$4
+#define XLP_MSG_CONFIG_REG	$5
+#define XLP_MSG_CONFIG1_REG	$6
+#define XLP_MSG_ECC_STATUS     $7
+#define XLP_MSG_INT_REG		$8
+#define XLP_MSG_Q_CNT_STATUS   $9
+
+/*sys register offset in pcie config space*/
+#define XLP_PCIE_NODE0_SYSOFFSET        0x35000
+#define XLP_PCIE_NODE1_SYSOFFSET        0x75000
+#define XLP_PCIE_NODE2_SYSOFFSET        0xB5000
+#define XLP_PCIE_NODE3_SYSOFFSET        0xF5000
+
+/* DTR related */
+#define XLP_DTR_NODE                    0x0
+#define XLP_DTR_BUS                     0x0
+#define XLP_DTR_DEVICE                  0x5
+#define XLP_DTR_FUNC                    0x0
+#define XLP_DTR_MASTER_CONTROL_REG      0x40
+#define XLP_DTR_CHANNEL_CONTROL_REG_0   0x48
+#define XLP_DTR_CHANNEL_CONTROL_REG_1   0x49
+#define XLP_DTR_CHANNEL_CONTROL_REG_2   0x4A
+#define XLP_DTR_CHANNEL_CONTROL_REG_3   0x4B
+
+/* Crypto related */
+#define XLP_CRYPTO_NODE                 0x0
+#define XLP_CRYPTO_BUS                  0x0
+#define XLP_CRYPTO_DEVICE               0x5
+#define XLP_CRYPTO_FUNC                 0x1
+
+/*RSA related */
+#define XLP_RSA_NODE                    0x0
+#define XLP_RSA_BUS                     0x0
+#define XLP_RSA_DEVICE                  0x5
+#define XLP_RSA_FUNC                    0x2
+
+/*CDE related */
+#define XLP_CDE_NODE                    0x0
+#define XLP_CDE_BUS                     0x0
+#define XLP_CDE_BUS_9XX                 0x1
+#define XLP_CDE_DEVICE                  0x5
+#define XLP_CDE_FUNC                    0x3
+
+/* XLP Storm Regex related */
+#define XLP_3XX_REGEX_NODE		0x0
+#define XLP_3XX_REGEX_BUS		0x0
+#define XLP_3XX_REGEX_DEVICE		0x5
+#define XLP_3XX_REGEX_FUNC		0x5
+
+#define XLP_IO_DEVICE			0x0
+#define XLP_IO_FUNC	                0x0
+
+#define XLP_FMN_DEVICE			0x4
+#define XLP_FMN_FUNC			0x0
+
+#define XLP_NAE_DEVICE			0x3
+#define XLP_NAE_FUNC			0x0
+
+#define XLP_POE_DEVICE			0x3
+#define XLP_POE_FUNC			0x1
+
+#define XLP_SAE_DEVICE			0x5
+#define XLP_SAE_FUNC			0x1
+
+#define XLP_RSA_DEVICE			0x5
+#define XLP_RSA_FUNC			0x2
+
+#define XLP_SYS_DEVICE			0x6
+#define XLP_SYS_FUNC			0x5
+
+#define XLP9XX_SYS_BUS			0x1
+#define XLP9XX_SYS_DEVICE		0x6
+#define XLP9XX_SYS_FUNC			0x0
+
+#define XLP_MAXDEV_PERNODE		8
+
+#define XLP9XX_SAE_RSA_BUS_NUM		(1<<20)
+#define XLP9XX_PCIE_DEV_BASE(SOC)		(((SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
+#define XLP_PCIE_DEV_BASE(node, SOC)                ((((node * XLP_MAXDEV_PERNODE) + SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
+
+#define XLP_NA_REG_BLOCK_SIZE       0x2000 /* 8KB */
+#define PCI_MEM_BAR_0               0x0004
+#define MAX_NUMBER_OF_SERDES_LANE   0x8
+
+
+
+#ifndef __ASSEMBLY__
+/* Device Id: Bus[8:6], Dev[5:3], func[2:0] */
+
+enum sae_cfg_regs {
+  SECCONENGSL0 = 0x41,
+  SECCONENGSL1 = 0x42,
+  SECCONENGSL2 = 0x43,
+  SECCONENGSL3 = 0x44,
+  SECCONENGSL4 = 0x45,
+  SECCONENGSL5 = 0x46,
+  SECCONENGSL6 = 0x47,
+  SECCONENGSL7 = 0x48,
+  SECCONENGSL8 = 0x49,
+  SECEMSGCTLLO = 0x82,
+  SECEMSGCTLL1 = 0x83,
+};
+
+enum NLH_DEV_ID {
+  NLH_BRIDGE = 0,
+  NLH_PIC    = 4,
+  NLH_NAE    = 0x18,
+  NLH_POE    = 0x19,
+  NLH_FMN    = 0x20,
+  NLH_GDX    = 0x28,
+  NLH_SEC    = 0x29,
+  NLH_RSA    = 0x2a,
+  NLH_COMP   = 0x2b,
+  NLH_UART0  = 0x30,
+  NLH_UART1  = 0x31,
+  NLH_SYS    = 0x35,
+};
+
+enum XLP_MSG_HANDLES  {
+	/* cpus */
+        XLP_MSG_HANDLE_CPU0,
+        XLP_MSG_HANDLE_CPU1,
+        XLP_MSG_HANDLE_CPU2,
+        XLP_MSG_HANDLE_CPU3,
+        XLP_MSG_HANDLE_CPU4,
+        XLP_MSG_HANDLE_CPU5,
+        XLP_MSG_HANDLE_CPU6,
+        XLP_MSG_HANDLE_CPU7,
+        XLP_MSG_HANDLE_CPU8,
+        XLP_MSG_HANDLE_CPU9,
+        XLP_MSG_HANDLE_CPU10,
+        XLP_MSG_HANDLE_CPU11,
+        XLP_MSG_HANDLE_CPU12,
+        XLP_MSG_HANDLE_CPU13,
+        XLP_MSG_HANDLE_CPU14,
+        XLP_MSG_HANDLE_CPU15,
+        XLP_MSG_HANDLE_CPU16,
+        XLP_MSG_HANDLE_CPU17,
+        XLP_MSG_HANDLE_CPU18,
+        XLP_MSG_HANDLE_CPU19,
+
+	/* io */
+        XLP_MSG_HANDLE_PCIE0,
+        XLP_MSG_HANDLE_PCIE1,
+        XLP_MSG_HANDLE_PCIE2,
+        XLP_MSG_HANDLE_PCIE3,
+	XLP_MSG_HANDLE_DTRE,
+        XLP_MSG_HANDLE_GDX,
+        XLP_MSG_HANDLE_GDX_0 = XLP_MSG_HANDLE_GDX,
+        XLP_MSG_HANDLE_GDX_1,
+        XLP_MSG_HANDLE_REGX,
+        XLP_MSG_HANDLE_RSA_ECC,
+        XLP_MSG_HANDLE_CRYPTO,
+        XLP_MSG_HANDLE_SRIO,
+        XLP_MSG_HANDLE_CMP,
+        XLP_MSG_HANDLE_LZS,
+        XLP_MSG_HANDLE_KBP,
+
+	/* net and popq */
+        XLP_MSG_HANDLE_POE,
+        XLP_MSG_HANDLE_POE_0 = XLP_MSG_HANDLE_POE,
+        XLP_MSG_HANDLE_NAE_0,
+        XLP_MSG_HANDLE_POE_1,
+        XLP_MSG_HANDLE_NAE_1,
+        XLP_MSG_HANDLE_ALE,
+        XLP_MSG_HANDLE_POPQ,
+
+        XLP_MSG_HANDLE_INVALID,
+        XLP_MSG_HANDLE_MAX,
+};
+
+typedef struct {
+        unsigned int base_vc;
+        unsigned int vc_limit;
+}nlm_fmn_config_t;
+
+#define SYS_REG_BASE	(( KSEG1 + 0x18000000 + XLP_PCIE_NODE0_SYSOFFSET) & 0x1fffffff )
+#define SYS_REG_INDEX(x)   ( 0x40 + (x))
+
+/* System Management PCIe config registers */
+enum sys_cfg_regs {
+    CHIP_RESET              = 0x00,
+    POWER_ON_RESET_CFG      = 0x01,
+    EFUSE_DEVICE_CFG0       = 0x02,
+    EFUSE_DEVICE_CFG1       = 0x03,
+    EFUSE_DEVICE_CFG2       = 0x04,
+    EFUSE_DEVICE_CFG3       = 0x05,
+    EFUSE_DEVICE_CFG4       = 0x06,
+    EFUSE_DEVICE_CFG5       = 0x07,
+    EFUSE_DEVICE_CFG6       = 0x08,
+    EFUSE_DEVICE_CFG7       = 0x09,
+    PLL_CTRL                = 0x0a,
+    CPU_RESET               = 0x0b,
+    CPU_THREAD_EN           = 0x0c,
+    CPU_NONCOHERENT_MODE    = 0x0d,
+    CORE_DFS_DIS_CTRL       = 0x0e,
+    CORE_DFS_RST_CTRL       = 0x0f,
+    CORE_DFS_BYP_CTRL       = 0x10,
+    CORE_DFS_PHA_CTRL       = 0x11,
+    CORE_DFS_DIV_INC_CTRL   = 0x12,
+    CORE_DFS_DIV_DEC_CTRL   = 0x13,
+    CORE_DFS_DIV_VALUE      = 0x14,
+    SYS_RESET               = 0x15,
+    SYS_DFS_DIS_CTRL        = 0x16,
+    SYS_DFS_RST_CTRL        = 0x17,
+    SYS_DFS_BYP_CTRL        = 0x18,
+    SYS_DFS_DIV_INC_CTRL    = 0x19,
+    SYS_DFS_DIV_DEC_CTRL    = 0x1a,
+    SYS_DFS_DIV_VALUE0      = 0x1b,
+    SYS_DFS_DIV_VALUE1      = 0x1c,
+    CPU_SENSE_AMP_DLY       = 0x1d,
+    SOC_SENSE_AMP_DLY       = 0x1e,
+    SYS_CTRL0               = 0x1f,
+    SYS_CTRL1               = 0x20,
+    TIMEOUT_BSI             = 0x21,
+    BYTE_SWAP               = 0x22,
+    VRM_VID                 = 0x23,
+    SYS_PWR_RAM_CMD         = 0x24,
+    SYS_PWR_RAM_ADDR        = 0x25,
+    SYS_PWR_RAM_DATA0       = 0x26,
+    SYS_PWR_RAM_DATA1       = 0x27,
+    SYS_PWR_RAM_DATA2       = 0x28,
+    SYS_PWR_UCODE           = 0x29,
+    CPU0_PWR_STATUS         = 0x2a,
+    CPU1_PWR_STATUS         = 0x2b,
+    CPU2_PWR_STATUS         = 0x2c,
+    CPU3_PWR_STATUS         = 0x2d,
+    CPU4_PWR_STATUS         = 0x2e,
+    CPU5_PWR_STATUS         = 0x2f,
+    CPU6_PWR_STATUS         = 0x30,
+    CPU7_PWR_STATUS         = 0x31,
+    SYS_STATUS              = 0x32,
+    SYS_INT_POL             = 0x33,
+    SYS_INT_TYPE            = 0x34,
+    SYS_INT_STATUS          = 0x35,
+    SYS_INT_EN0             = 0x36,
+    SYS_INT_EN1             = 0x37,
+
+    /* Added XLP3XX or XLP8XX.Bx Registers: from 0x38 to 0x8a*/
+    PLL_DFS_DIS_CTRL        = 0x38,
+    PLL_DFS_RST_CTRL        = 0x39,
+    PLL_DFS_BYP_CTRL        = 0x3a,
+    PLL_DFS_DIV_INC_CTRL    = 0x3b,
+    PLL_DFS_DIV_DEC_CTRL    = 0x3c,
+    PLL_DFS_DIV_VALUE       = 0x3d,
+    SYS_DISABLE             = 0x3e,
+    SYS_UCO_S_ECC           = 0x3f,
+    SYS_UCO_M_ECC           = 0x40,
+    SYS_UCO_ADDR            = 0x41,
+    SYS_UCO_INST            = 0x42,
+
+    MEM_BIST0               = 0x43,
+    MEM_BIST1               = 0x44,
+    MEM_BIST2               = 0x45,
+    MEM_BIST3               = 0x46,
+    MEM_BIST4               = 0x47,
+    MEM_BIST5               = 0x48,
+    MEM_BIST6               = 0x49,
+    MEM_BIST7               = 0x4a,
+    MEM_BIST8               = 0x4b,
+    MEM_BIST9               = 0x4c,
+    MEM_BIST10              = 0x4d,
+    MEM_BIST11              = 0x4e,
+    MEM_BIST12              = 0x4f,
+    MEM_STAT0               = 0x50,
+    MEM_STAT1               = 0x51,
+
+    SYS_SCRATCH0            = 0x52,
+    SYS_SCRATCH1            = 0x53,
+    SYS_SCRATCH2            = 0x54,
+    SYS_SCRATCH3	    = 0x55,
+
+    SYS_COUNTER             = 0x56,
+    SYS_CTRLSECUREBOOT      = 0x57,
+    SYS_SECUREKEY           = 0x60,
+    SYS_EFUSECTRL           = 0x80,
+    SYS_EFUSECMD            = 0x81,
+    SYS_EFUSECMDKEY         = 0x82,
+    SYS_EFUSESTAT           = 0x8a
+};
+
+
+#define XLP2XX_CHIPRESET_REG                           0x0
+#define XLP2XX_POWERONRESETCFG_REG                     0x1
+#define XLP2XX_EFUSEDEVICECFG0_REG                     0x2
+#define XLP2XX_EFUSEDEVICECFG1_REG                     0x3
+#define XLP2XX_EFUSEDEVICECFG2_REG                     0x4
+#define XLP2XX_EFUSEDEVICECFG3_REG                     0x5
+#define XLP2XX_EFUSEDEVICECFG4_REG                     0x6
+#define XLP2XX_EFUSEDEVICECFG5_REG                     0x7
+#define XLP2XX_EFUSEDEVICECFG6_REG                     0x8
+#define XLP2XX_EFUSEDEVICECFG7_REG                     0x9
+#define XLP2XX_PLLCTRL_REG                             0xa
+#define XLP2XX_CPURESET_REG                            0xb
+#define XLP2XX_CPUTHREADEN_REG                         0xc
+#define XLP2XX_CPUNONCOHERENTMODE_REG                  0xd
+#define XLP2XX_TCUDISABLE_REG                          0xe
+#define XLP2XX_CPUSTOP_REG                             0xf
+#define XLP2XX_CPUPSWCTRL_REG                          0x10
+#define XLP2XX_CPUPWRDOWN_REG                          0x11
+#define XLP2XX_CPUMEMCLR_REG                           0x12
+#define XLP2XX_SYSDISABLE_REG                          0x14
+#define XLP2XX_SYSRESET_REG                            0x15
+#define XLP2XX_CPUPSWISO_REG                           0x16
+#define XLP2XX_CPUPSWSET_REG                           0x17
+#define XLP2XX_CPUPSWRESET_REG                         0x18
+#define XLP2XX_CPUPSWCLKEN_REG                         0x19
+#define XLP2XX_CPUPSWIN_REG                            0x1a
+#define XLP2XX_CPUPSWSRAMOFF_REG                       0x1b
+#define XLP2XX_CPUPSWSRAMCLKEN_REG                     0x1c
+#define XLP2XX_CPUSENSEAMPDLY_REG                      0x1d
+#define XLP2XX_SOCSENSEAMPDLY_REG                      0x1e
+#define XLP2XX_SYSCTRL0_REG                            0x1f
+#define XLP2XX_SYSCTRL1_REG                            0x20
+#define XLP2XX_TIMEOUTBSI_REG                          0x21
+#define XLP2XX_BYTESWAP_REG                            0x22
+#define XLP2XX_SYSVRMVID_REG                           0x23
+#define XLP2XX_SYSPWRRAMCMD_REG                        0x24
+#define XLP2XX_SYSPWRRAMADDR_REG                       0x25
+#define XLP2XX_SYSPWRRAMDATA0_REG                      0x26
+#define XLP2XX_SYSPWRRAMDATA1_REG                      0x27
+#define XLP2XX_SYSPWRRAMDATA2_REG                      0x28
+#define XLP2XX_SYSPWRUCODE_REG                         0x29
+#define XLP2XX_SYSPWRSTATUS0_REG                       0x2a
+#define XLP2XX_SYSPWRSTATUS1_REG                       0x2b
+#define XLP2XX_SYSSTATUS_REG                           0x32
+#define XLP2XX_SYSINTPOL_REG                           0x33
+#define XLP2XX_SYSINTTYPE_REG                          0x34
+#define XLP2XX_SYSINTSTATUS_REG                        0x35
+#define XLP2XX_SYSINTENABLE0_REG                       0x36
+#define XLP2XX_SYSINTENABLE1_REG                       0x37
+#define XLP2XX_CPUSTOPPIC_REG                          0x38
+#define XLP2XX_CPUSTOPNBU_REG                          0x39
+#define XLP2XX_CPUSTOPMSG_REG                          0x3a
+#define XLP2XX_CPUPSWDATAOUT_REG                       0x3b
+#define XLP2XX_CPUPWRSTATUS_REG                        0x3c
+#define XLP2XX_CPUMEMCLRDONE_REG                       0x3d
+#define XLP2XX_SYSUCOSECC_REG                          0x3f
+#define XLP2XX_SYSUCOMECC_REG                          0x40
+#define XLP2XX_SYSUCOADDR_REG                          0x41
+#define XLP2XX_SYSUCOINST_REG                          0x42
+#define XLP2XX_SYSMEMBISTGO0_REG                       0x43
+#define XLP2XX_SYSMEMBISTGO1_REG                       0x44
+#define XLP2XX_SYSMEMBISTGO2_REG                       0x45
+#define XLP2XX_SYSMEMBISTGO3_REG                       0x46
+#define XLP2XX_SYSMEMBISTGO4_REG                       0x47
+#define XLP2XX_SYSMEMBISTGO5_REG                       0x48
+#define XLP2XX_SYSMEMBISTGO6_REG                       0x49
+#define XLP2XX_SYSMEMBISTGO7_REG                       0x4a
+#define XLP2XX_SYSMEMBISTGO8_REG                       0x4b
+#define XLP2XX_SYSMEMBISTGO9_REG                       0x4c
+#define XLP2XX_SYSMEMBISTGO10_REG                      0x4d
+#define XLP2XX_SYSMEMBISTGO11_REG                      0x4e
+#define XLP2XX_SYSMEMBISTGO12_REG                      0x4f
+#define XLP2XX_SYSMEMSTAT0_REG                         0x54
+#define XLP2XX_SYSMEMSTAT1_REG                         0x55
+#define XLP2XX_SYSSCRATCH0_REG                         0x58
+#define XLP2XX_SYSSCRATCH1_REG                         0x59
+#define XLP2XX_SYSSCRATCH2_REG                         0x5a
+#define XLP2XX_SYSSCRATCH3_REG                         0x5b
+#define XLP2XX_SYSCOUNTER_REG                          0x5c
+#define XLP2XX_SYSCTRLSECUREBOOT_REG                   0x5d
+#define XLP2XX_SYSSECUREKEY_REG                        0xc0
+#define XLP2XX_SYSEFUSECTRL_REG                        0x140
+#define XLP2XX_SYSEFUSECMD_REG                         0x141
+#define XLP2XX_SYSEFUSECMDDATA_REG                     0x142
+#define XLP2XX_SYSEFUSESTAT_REG                        0x14a
+#define XLP2XX_SYSTHERMCTRL_REG                        0x14b
+#define XLP2XX_CPUTHERMPWRDOWN_REG                     0x14c
+#define XLP2XX_SYSTHERMPWRDOWN_REG                     0x14d
+#define XLP2XX_CPUTHERMEN_REG                          0x14e
+#define XLP2XX_SYSTHERMEN_REG                          0x14f
+#define XLP2XX_THERMTHRESH0_REG                        0x150
+#define XLP2XX_THERMTHRESH1_REG                        0x151
+#define XLP2XX_THERMTHRESH2_REG                        0x152
+#define XLP2XX_THERMTHRESH3_REG                        0x153
+#define XLP2XX_CPUTHERMINTSTATUSHIGH0_REG              0x154
+#define XLP2XX_CPUTHERMINTSTATUSLOW0_REG               0x155
+#define XLP2XX_SYSTHERMINTSTATUSHIGH0_REG              0x156
+#define XLP2XX_SYSTHERMINTSTATUSLOW0_REG               0x157
+#define XLP2XX_CPUTHERMINTSTATUSHIGH1_REG              0x158
+#define XLP2XX_CPUTHERMINTSTATUSLOW1_REG               0x159
+#define XLP2XX_SYSTHERMINTSTATUSHIGH1_REG              0x15a
+#define XLP2XX_SYSTHERMINTSTATUSLOW1_REG               0x15b
+#define XLP2XX_CPUTHERMINTSTATUSHIGH2_REG              0x15c
+#define XLP2XX_CPUTHERMINTSTATUSLOW2_REG               0x15d
+#define XLP2XX_SYSTHERMINTSTATUSHIGH2_REG              0x15e
+#define XLP2XX_SYSTHERMINTSTATUSLOW2_REG               0x15f
+#define XLP2XX_CPUTHERMINTSTATUSHIGH3_REG              0x160
+#define XLP2XX_CPUTHERMINTSTATUSLOW3_REG               0x161
+#define XLP2XX_SYSTHERMINTSTATUSHIGH3_REG              0x162
+#define XLP2XX_SYSTHERMINTSTATUSLOW3_REG               0x163
+#define XLP2XX_CPUTHERMINTENHIGH0_REG                  0x164
+#define XLP2XX_CPUTHERMINTENLOW0_REG                   0x165
+#define XLP2XX_SYSTHERMINTENHIGH0_REG                  0x166
+#define XLP2XX_SYSTHERMINTENLOW0_REG                   0x167
+#define XLP2XX_CPUTHERMINTENHIGH1_REG                  0x168
+#define XLP2XX_CPUTHERMINTENLOW1_REG                   0x169
+#define XLP2XX_SYSTHERMINTENHIGH1_REG                  0x16a
+#define XLP2XX_SYSTHERMINTENLOW1_REG                   0x16b
+#define XLP2XX_CPUTHERMINTENHIGH2_REG                  0x16c
+#define XLP2XX_CPUTHERMINTENLOW2_REG                   0x16d
+#define XLP2XX_SYSTHERMINTENHIGH2_REG                  0x16e
+#define XLP2XX_SYSTHERMINTENLOW2_REG                   0x16f
+#define XLP2XX_CPUTHERMINTENHIGH3_REG                  0x170
+#define XLP2XX_CPUTHERMINTENLOW3_REG                   0x171
+#define XLP2XX_SYSTHERMINTENHIGH3_REG                  0x172
+#define XLP2XX_SYSTHERMINTENLOW3_REG                   0x173
+#define XLP2XX_CPUTHERMCOUNT_REG                       0x174
+#define XLP2XX_SYSTHERMCOUNT_REG                       0x194
+#define XLP2XX_THERMCOUNT_REG                          0x19c
+
+#define XLP2XX_SYSCPUPLLCTRL0_REG                      0x1c0
+#define XLP2XX_SYSCPUPLLCTRL1_REG                      0x1c1
+#define XLP2XX_SYSCPUPLLCTRL2_REG                      0x1c2
+#define XLP2XX_SYSCPUPLLCTRL3_REG                      0x1c3
+
+#define XLP2XX_SYSCPU1PLLCTRL0_REG                      0x1c4
+#define XLP2XX_SYSCPU1PLLCTRL1_REG                      0x1c5
+#define XLP2XX_SYSCPU1PLLCTRL2_REG                      0x1c6
+#define XLP2XX_SYSCPU1PLLCTRL3_REG                      0x1c7
+
+#define XLP2XX_SYSSYSPLLCTRL0_REG                      0x240
+#define XLP2XX_SYSSYSPLLCTRL1_REG                      0x241
+#define XLP2XX_SYSSYSPLLCTRL2_REG                      0x242
+#define XLP2XX_SYSSYSPLLCTRL3_REG                      0x243
+#define XLP2XX_SYSDMCPLLCTRL0_REG                      0x244
+#define XLP2XX_SYSDMCPLLCTRL1_REG                      0x245
+#define XLP2XX_SYSDMCPLLCTRL2_REG                      0x246
+#define XLP2XX_SYSDMCPLLCTRL3_REG                      0x247
+
+#define XLP2XX_SYSDEVPLLCTRL0_REG                      0x248
+#define XLP2XX_SYSDEVPLLCTRL1_REG                      0x249
+#define XLP2XX_SYSDEVPLLCTRL2_REG                      0x24a
+#define XLP2XX_SYSDEVPLLCTRL3_REG                      0x24b
+
+#define XLP2XX_SYSDEV1PLLCTRL0_REG                      0x24c
+#define XLP2XX_SYSDEV1PLLCTRL1_REG                      0x24d
+#define XLP2XX_SYSDEV1PLLCTRL2_REG                      0x24e
+#define XLP2XX_SYSDEV1PLLCTRL3_REG                      0x24f
+
+#define XLP2XX_SYSDEV2PLLCTRL0_REG                      0x250
+#define XLP2XX_SYSDEV2PLLCTRL1_REG                      0x251
+#define XLP2XX_SYSDEV2PLLCTRL2_REG                      0x252
+#define XLP2XX_SYSDEV2PLLCTRL3_REG                      0x253
+
+#define XLP2XX_SYSCPUPLLCHGCTRL_REG                    0x288
+#define XLP2XX_SYSSYSPLLCHGCTRL_REG                    0x289
+#define XLP2XX_SYSCLKDEVDIS_REG                        0x28a
+#define XLP2XX_SYSCLKDEVSEL_REG                        0x28b
+#define XLP2XX_SYSCLKDEVDIV_REG                        0x28c
+#define XLP2XX_SYSCLKDEVCHG_REG                        0x28d
+#define XLP2XX_SYSCLKDEVSELREG_REG                     0x28e
+#define XLP2XX_SYSCLKDEVDIVREG_REG                     0x28f
+#define XLP2XX_SYSCPUPLLLOCK_REG                       0x29f
+#define XLP2XX_SYSSYSPLLLOCK_REG                       0x2a0
+#define XLP2XX_SYSPLLMEMCMD_REG                        0x2a1
+#define XLP2XX_SYSCPUPLLMEMREQ_REG                     0x2a2
+#define XLP2XX_SYSSYSPLLMEMREQ_REG                     0x2a3
+#define XLP2XX_SYSPLLMEMSTAT_REG                       0x2a4
+
+#define XLP2XX_RTC_REG_SECONDS_REG                         0x300
+#define XLP2XX_RTC_REG_MINUTES_REG                         0x301
+#define XLP2XX_RTC_REG_CENTURY_HOURS_REG                   0x302
+#define XLP2XX_RTC_REG_DAY_REG                             0x303
+#define XLP2XX_RTC_REG_DATE_REG                            0x304
+#define XLP2XX_RTC_REG_MONTH_REG                           0x305
+#define XLP2XX_RTC_REG_YEAR_REG                            0x306
+#define XLP2XX_RTC_REG_CONTROL_REG                         0x307
+#define XLP2XX_RTC_REG_STATUS_REG                          0x308
+#define XLP2XX_RTC_REG_FLAG_REG                            0x309
+#define XLP2XX_RTC_REG_CLOCK_PERIOD_REG                    0x30a
+#define XLP2XX_RTC_REG_LOCK_REG                            0x30b
+#define XLP2XX_RTC_REG_VOLT_REG                            0x30c
+#define XLP2XX_RTC_REG_TEST_REG                            0x30f
+
+/*  Reference Clock Select 00:66; 01:100; 10:125; 11:133 */
+#define XLP2XX_SYS_PWRON_RCS(x) (((x)>>18) & 0x3)
+#define XLP2XX_SYS_NAND_BOOT(x) ( ((x) & 0x1f) == 6)
+
+enum xlp2xx_sys_cfg_regs {
+	XLP2XX_RESET			= 0,
+	XLP2XX_POWER_ON_RESET_CFG	= 1,
+    	XLP2XX_EFUSE_DEVICE_CFG0	= 2,
+    	XLP2XX_EFUSE_DEVICE_CFG1        = 3,
+	XLP2XX_EFUSE_DEVICE_CFG2       	= 4,
+	XLP2XX_EFUSE_DEVICE_CFG3       	= 5,
+	XLP2XX_EFUSE_DEVICE_CFG4       	= 6,
+	XLP2XX_EFUSE_DEVICE_CFG5       	= 7,
+	XLP2XX_EFUSE_DEVICE_CFG6       	= 8,
+	XLP2XX_EFUSE_DEVICE_CFG7       	= 9,
+	XLP2XX_SYS_PLL_CTRL             = 10,
+
+	XLP2XX_CPU_RESET                            = 0xb,
+	XLP2XX_CPU_THREAD_EN                        = 0xc,
+	XLP2XX_CPUNONCOHERENTMODE                 = 0xd,
+	XLP2XX_TCU_DISABLE                         = 0xe,
+	XLP2XX_CPU_STOP                            = 0xf,
+	XLP2XX_CPU_PSWCTRL                         = 0x10,
+	XLP2XX_CPU_PWRDOWN                         = 0x11,
+	XLP2XX_CPU_MEMCLR                          = 0x12,
+
+	XLP2XX_SYSDISABLE                         = 0x14,
+	XLP2XX_SYSRESET                           = 0x15,
+	XLP2XX_CPUPSWISO                          = 0x16,
+	XLP2XX_CPUPSWSET                          = 0x17,
+	XLP2XX_CPUPSWRESET                        = 0x18,
+	XLP2XX_CPUPSWCLKEN                        = 0x19,
+	XLP2XX_CPUPSWIN                           = 0x1a,
+	XLP2XX_CPUPSWSRAMOFF                      = 0x1b,
+	XLP2XX_CPUPSWSRAMCLKEN                    = 0x1c,
+	XLP2XX_CPUSENSEAMPDLY                     = 0x1d,
+	XLP2XX_SOCSENSEAMPDLY                     = 0x1e,
+	XLP2XX_SYSCTRL0                           = 0x1f,
+	XLP2XX_SYSCTRL1                           = 0x20,
+	XLP2XX_TIMEOUTBSI                         = 0x21,
+	XLP2XX_BYTESWAP                           = 0x22,
+	XLP2XX_SYSVRMVID                          = 0x23,
+	XLP2XX_SYSPWRRAMCMD                       = 0x24,
+	XLP2XX_SYSPWRRAMADDR                      = 0x25,
+	XLP2XX_SYSPWRRAMDATA0                     = 0x26,
+	XLP2XX_SYSPWRRAMDATA1                     = 0x27,
+	XLP2XX_SYSPWRRAMDATA2                     = 0x28,
+	XLP2XX_SYSPWRUCODE                        = 0x29,
+	XLP2XX_SYSPWRSTATUS0                      = 0x2a,
+	XLP2XX_SYSPWRSTATUS1                      = 0x2b,
+	XLP2XX_SYSSTATUS                          = 0x32,
+	XLP2XX_SYSINTPOL                          = 0x33,
+	XLP2XX_SYSINTTYPE                         = 0x34,
+	XLP2XX_SYSINTSTATUS                       = 0x35,
+	XLP2XX_SYSINTENABLE0                      = 0x36,
+	XLP2XX_SYSINTENABLE1                      = 0x37,
+	XLP2XX_CPUSTOPPIC                         = 0x38,
+	XLP2XX_CPUSTOPNBU                         = 0x39,
+	XLP2XX_CPUSTOPMSG                         = 0x3a,
+	XLP2XX_CPUPSWDATAOUT                      = 0x3b,
+	XLP2XX_CPUPWRSTATUS                       = 0x3c,
+	XLP2XX_CPUMEMCLRDONE                      = 0x3d,
+	XLP2XX_SYSUCOSECC                         = 0x3f,
+	XLP2XX_SYSUCOMECC                         = 0x40,
+	XLP2XX_SYSUCOADDR                         = 0x41,
+	XLP2XX_SYSUCOINST                         = 0x42,
+	XLP2XX_SYSMEMBISTGO0                      = 0x43,
+	XLP2XX_SYSMEMBISTGO1                      = 0x44,
+	XLP2XX_SYSMEMBISTGO2                      = 0x45,
+	XLP2XX_SYSMEMBISTGO3                      = 0x46,
+	XLP2XX_SYSMEMBISTGO4                      = 0x47,
+	XLP2XX_SYSMEMBISTGO5                      = 0x48,
+	XLP2XX_SYSMEMBISTGO6                      = 0x49,
+	XLP2XX_SYSMEMBISTGO7                      = 0x4a,
+	XLP2XX_SYSMEMBISTGO8                      = 0x4b,
+	XLP2XX_SYSMEMBISTGO9                      = 0x4c,
+	XLP2XX_SYSMEMBISTGO10                     = 0x4d,
+	XLP2XX_SYSMEMBISTGO11                     = 0x4e,
+	XLP2XX_SYSMEMBISTGO12                     = 0x4f,
+	XLP2XX_SYSMEMSTAT0                        = 0x54,
+	XLP2XX_SYSMEMSTAT1                        = 0x55,
+	XLP2XX_SYSSCRATCH0                        = 0x58,
+	XLP2XX_SYSSCRATCH1                        = 0x59,
+	XLP2XX_SYSSCRATCH2                        = 0x5a,
+	XLP2XX_SYSSCRATCH3                        = 0x5b,
+	XLP2XX_SYSCOUNTER                         = 0x5c,
+	XLP2XX_SYSCTRLSECUREBOOT                  = 0x5d,
+	XLP2XX_SYSSECUREKEY                       = 0xc0,
+	XLP2XX_SYSEFUSECTRL                       = 0x140,
+	XLP2XX_SYSEFUSECMD                        = 0x141,
+	XLP2XX_SYSEFUSECMDDATA                    = 0x142,
+	XLP2XX_SYSEFUSESTAT                       = 0x14a,
+	XLP2XX_SYSTHERMCTRL                       = 0x14b,
+	XLP2XX_CPUTHERMPWRDOWN                    = 0x14c,
+	XLP2XX_SYSTHERMPWRDOWN                    = 0x14d,
+	XLP2XX_CPUTHERMEN                         = 0x14e,
+	XLP2XX_SYSTHERMEN                         = 0x14f,
+	XLP2XX_THERMTHRESH0                       = 0x150,
+	XLP2XX_THERMTHRESH1                       = 0x151,
+	XLP2XX_THERMTHRESH2                       = 0x152,
+	XLP2XX_THERMTHRESH3                       = 0x153,
+	XLP2XX_CPUTHERMINTSTATUSHIGH0             = 0x154,
+	XLP2XX_CPUTHERMINTSTATUSLOW0              = 0x155,
+	XLP2XX_SYSTHERMINTSTATUSHIGH0             = 0x156,
+	XLP2XX_SYSTHERMINTSTATUSLOW0              = 0x157,
+	XLP2XX_CPUTHERMINTSTATUSHIGH1             = 0x158,
+	XLP2XX_CPUTHERMINTSTATUSLOW1              = 0x159,
+	XLP2XX_SYSTHERMINTSTATUSHIGH1             = 0x15a,
+	XLP2XX_SYSTHERMINTSTATUSLOW1              = 0x15b,
+	XLP2XX_CPUTHERMINTSTATUSHIGH2             = 0x15c,
+	XLP2XX_CPUTHERMINTSTATUSLOW2              = 0x15d,
+	XLP2XX_SYSTHERMINTSTATUSHIGH2             = 0x15e,
+	XLP2XX_SYSTHERMINTSTATUSLOW2              = 0x15f,
+	XLP2XX_CPUTHERMINTSTATUSHIGH3             = 0x160,
+	XLP2XX_CPUTHERMINTSTATUSLOW3              = 0x161,
+	XLP2XX_SYSTHERMINTSTATUSHIGH3             = 0x162,
+	XLP2XX_SYSTHERMINTSTATUSLOW3              = 0x163,
+	XLP2XX_CPUTHERMINTENHIGH0                 = 0x164,
+	XLP2XX_CPUTHERMINTENLOW0                  = 0x165,
+	XLP2XX_SYSTHERMINTENHIGH0                 = 0x166,
+	XLP2XX_SYSTHERMINTENLOW0                  = 0x167,
+	XLP2XX_CPUTHERMINTENHIGH1                 = 0x168,
+	XLP2XX_CPUTHERMINTENLOW1                  = 0x169,
+	XLP2XX_SYSTHERMINTENHIGH1                 = 0x16a,
+	XLP2XX_SYSTHERMINTENLOW1                  = 0x16b,
+	XLP2XX_CPUTHERMINTENHIGH2                 = 0x16c,
+	XLP2XX_CPUTHERMINTENLOW2                  = 0x16d,
+	XLP2XX_SYSTHERMINTENHIGH2                 = 0x16e,
+	XLP2XX_SYSTHERMINTENLOW2                  = 0x16f,
+	XLP2XX_CPUTHERMINTENHIGH3                 = 0x170,
+	XLP2XX_CPUTHERMINTENLOW3                  = 0x171,
+	XLP2XX_SYSTHERMINTENHIGH3                 = 0x172,
+	XLP2XX_SYSTHERMINTENLOW3                  = 0x173,
+	XLP2XX_CPUTHERMCOUNT                      = 0x174,
+	XLP2XX_SYSTHERMCOUNT                      = 0x194,
+	XLP2XX_THERMCOUNT                         = 0x19c,
+
+	XLP2XX_CORE0_PLL_CTRL0		= 0x1c0,
+	XLP2XX_CORE0_PLL_CTRL1		= 0x1c1,
+	XLP2XX_CORE0_PLL_CTRL2		= 0x1c2,
+	XLP2XX_CORE0_PLL_CTRL3		= 0x1c3,
+
+	XLP2XX_CORE1_PLL_CTRL0		= 0x1c4,
+	XLP2XX_CORE1_PLL_CTRL1		= 0x1c5,
+	XLP2XX_CORE1_PLL_CTRL2		= 0x1c6,
+	XLP2XX_CORE1_PLL_CTRL3		= 0x1c7,
+
+	XLP2XX_SYS_PLL_CTRL0		= 0x240,
+	XLP2XX_SYS_PLL_CTRL1		= 0x241,
+	XLP2XX_SYS_PLL_CTRL2		= 0x242,
+	XLP2XX_SYS_PLL_CTRL3		= 0x243,
+	XLP2XX_DMC_PLL_CTRL0		= 0x244,
+	XLP2XX_DMC_PLL_CTRL1		= 0x245,
+	XLP2XX_DMC_PLL_CTRL2		= 0x246,
+	XLP2XX_DMC_PLL_CTRL3		= 0x247,
+
+	XLP2XX_DEV0_PLL_CTRL0		= 0x248,
+	XLP2XX_DEV0_PLL_CTRL1		= 0x249,
+	XLP2XX_DEV0_PLL_CTRL2		= 0x24a,
+	XLP2XX_DEV0_PLL_CTRL3		= 0x24b,
+	XLP2XX_DEV1_PLL_CTRL0		= 0x24c,
+	XLP2XX_DEV1_PLL_CTRL1		= 0x24d,
+	XLP2XX_DEV1_PLL_CTRL2		= 0x24e,
+	XLP2XX_DEV1_PLL_CTRL3		= 0x24f,
+	XLP2XX_DEV2_PLL_CTRL0		= 0x250,
+	XLP2XX_DEV2_PLL_CTRL1		= 0x251,
+	XLP2XX_DEV2_PLL_CTRL2		= 0x252,
+	XLP2XX_DEV2_PLL_CTRL3		= 0x253,
+
+	XLP2XX_CPU_PLL_CHG_CTRL		= 0x288,
+	XLP2XX_SYS_PLL_CHG_CTRL		= 0x289,
+	XLP2XX_SYS_CLK_DEV_DIS		= 0x28a,
+	XLP2XX_SYS_CLK_DEV_SEL		= 0x28b,
+	XLP2XX_SYS_CLK_DEV_DIV		= 0x28c,
+	XLP2XX_SYS_CLK_DEV_CHG		= 0x28d,
+	XLP2XX_SYS_CLK_DEV_SEL_REG	= 0x28e,
+	XLP2XX_SYS_CLK_DEV_DIV_REG	= 0x28f,
+	XLP2XX_SYS_CPU_PLL_LOCK   	= 0x29f,
+	XLP2XX_SYS_SYS_PLL_LOCK 	= 0x2a0,
+	XLP2XX_SYS_PLL_MEM_CMD    	= 0x2a1,
+	XLP2XX_SYS_CPU_PLL_MEM_REQ	= 0x2a2,
+	XLP2XX_SYS_SYS_PLL_MEM_REQ	= 0x2a3,
+	XLP2XX_SYS_PLL_MEM_STAT		= 0x2a4,
+
+	XLP2XX_RTC_REG_SECONDS          = 0x300,
+	XLP2XX_RTC_REG_MINUTES          = 0x301,
+	XLP2XX_RTC_REG_CENTURY_HOURS    = 0x302,
+	XLP2XX_RTC_REG_DAY              = 0x303,
+	XLP2XX_RTC_REG_DATE             = 0x304,
+	XLP2XX_RTC_REG_MONTH            = 0x305,
+	XLP2XX_RTC_REG_YEAR             = 0x306,
+	XLP2XX_RTC_REG_CONTROL          = 0x307,
+	XLP2XX_RTC_REG_STATUS           = 0x308,
+	XLP2XX_RTC_REG_FLAG             = 0x309,
+	XLP2XX_RTC_REG_CLOCK_PERIOD     = 0x30a,
+	XLP2XX_RTC_REG_LOCK             = 0x30b,
+	XLP2XX_RTC_REG_VOLT             = 0x30c,
+	XLP2XX_RTC_REG_TEST             = 0x30f,
+};
+
+/* EFUSE Config2 Reg */
+#define XLP2XX_RSA_BLOCK_INDEX		0
+#define XLP2XX_REGX_BLOCK_INDEX		11
+
+/* EFUSE Config1 Reg */
+#define XLP2XX_CMP_BLOCK_INDEX		9
+#define XLP2XX_CRYPTO_BLOCK_INDEX	14
+
+/*1588-PTP CLOCK selection*/
+#define NET_SYS_CLK 		0
+#define INT_SYNCE_CLK		1
+#define GPIO_1588_CLK		2
+#define SGMII_REF_CLK		3
+
+#define nlm_hal_read_sys_reg(node, index) \
+        nlm_hal_read_32bit_reg((xlp_sys_base[node] + 0x100), (index))
+
+#define nlm_hal_write_sys_reg(node, index, val) \
+        nlm_hal_write_32bit_reg((xlp_sys_base[node] + 0x100), (index), (val))
+
+#define nlm_hal_read_rsa_reg(node, reg) \
+        nlm_hal_read_32bit_reg((xlp_rsa_base[node]), (reg))
+
+#define nlm_hal_write_rsa_reg(node, reg, val) \
+        nlm_hal_write_32bit_reg ((xlp_rsa_base[node]), (reg), (val))
+
+#define nlm_hal_read_sae_reg(node, reg) \
+        nlm_hal_read_32bit_reg((xlp_sae_base[node]), (reg))
+
+#define nlm_hal_write_sae_reg(node, reg, val) \
+        nlm_hal_write_32bit_reg ((xlp_sae_base[node]), (reg), (val))
+
+/* SPI */
+#define XLP_SPI_CONFIG			0x40
+    #define XLP_SPI_CPHA		0x01
+    #define XLP_SPI_CPOL		0x02
+    #define XLP_SPI_MODE_MASK		0x03
+    #define XLP_SPI_CS_POL_HI		0x04
+    #define XLP_SPI_TXMISO_EN		0x08
+    #define XLP_SPI_TXMOSI_EN		0x10
+    #define XLP_SPI_RXMISO_EN		0x20
+    #define XLP_SPI_SB_EN		0x40
+    #define XLP_SPI_SBPOL		0x80
+    #define XLP_SPI_LSBF_EN		0x0400
+    #define XLP_SPI_RXCAP_EV		0x0800
+#define XLP_SPI_FDIV			0x41
+#define XLP_SPI_CMD			0x42
+    #define XLP_SPI_CMD_MASK		0xF
+    #define XLP_SPI_CMD_IDLE            0x0000
+    #define XLP_SPI_CMD_TX              0x0001
+    #define XLP_SPI_CMD_RX              0x0002
+    #define XLP_SPI_CMD_TXRX            0x0003
+    #define XLP_SPI_CMD_CONT		0x10
+    #define XLP_SPI_XFR_BITCNT_POS	16
+
+#define XLP_SPI_STATUS			0x43
+    #define XLP_SPI_XFR_PENDING		0x01
+    #define XLP_SPI_XFR_DONE		0x02
+    #define XLP_SPI_TX_OV_TH		0x04
+    #define XLP_SPI_RX_OV_TH		0x08
+    #define XLP_SPI_TX_UF		0x10
+    #define XLP_SPI_TX_OF		0x20
+#define XLP_SPI_INTEN			0x44
+    #define XLP_SPI_INT_XFR_DONE	0x01
+    #define XLP_SPI_INT_TX_THRESH	0x02
+    #define XLP_SPI_INT_RX_THRESH	0x04
+    #define XLP_SPI_INT_TX_UF		0x08
+    #define XLP_SPI_INT_RX_OF		0x10
+
+#define XLP_SPI_FIFO_THRESH		0x45
+    #define XLP_SPI_TXFIFO_THRESH_POS	4
+    #define XLP_SPI_RXFIFO_THRESH_POS	0
+
+#define XLP_SPI_FIFO_WCNT		0x46
+    #define XLP_SPI_TXFIFO_WCNT_POS	4
+    #define XLP_SPI_RXFIFO_WCNT_POS	0
+#define XLP_SPI_TXDATA_FIFO		0x47
+#define XLP_SPI_RXDATA_FIFO		0x48
+
+#define XLP_SPI_SYSCTRL			0x80
+    #define XLP_SPI_SYS_RESET		0x01
+    #define XLP_SPI_SYS_CLKDIS		0x0010
+    #define XLP_SPI_SYS_PMEN		0x0100
+
+/* I2C */
+#define XLP_PRESCALE0                   0x0 
+#define XLP_PRESCALE1                   0x1 
+#define XLP_I2C_CONTROL                 0x2 
+        #define XLP_I2C_CTRL_EN         0x80
+        #define XLP_I2C_CTRL_IEN        0x40
+#define XLP_I2C_DATA                    0x3              
+#define XLP_I2C_COMMAND                 0x4 
+        #define XLP_I2C_CMD_START       0x90
+        #define XLP_I2C_CMD_STOP        0x40
+        #define XLP_I2C_CMD_READ        0x20
+        #define XLP_I2C_CMD_WRITE       0x10
+        #define XLP_I2C_CMD_RDACK       0x20
+        #define XLP_I2C_CMD_RDNACK      0x28
+        #define XLP_I2C_CMD_IACK        0x01 
+#define XLP_I2C_STATUS                  0x4       
+        #define XLP_I2C_STATUS_NACK     0x80     
+        #define XLP_I2C_STATUS_BUSY     0x40
+        #define XLP_I2C_STATUS_AL       0x20    
+        #define XLP_I2C_STATUS_TIP      0x02   
+        #define XLP_I2C_STATUS_IF       0x01 
+#define XLP_WRITE_BIT                   0x00
+#define XLP_READ_BIT                    0x01
+
+#define XLP_USB_PCIE_MBAR		0x4
+#define XLP_USB_PCIE_MBAR1		0x5
+
+#define XLP_USB_PCI0			0x40
+#define XLP_USB_CTL0            	0x41
+    #define USBCONTROLLERRESET  	0x01
+    #define USBEHCI64BITEN		0x02
+    #define USBOHCISTARTCLK		0x04
+
+#define XLP_USB_CTL1            	0x42
+#define XLP_USB_CTL2            	0x43
+#define XLP_USB_CTL3            	0x44
+#define XLP_USB_CTL4            	0x45
+#define XLP_USB_CTL5            	0x46
+#define XLP_USB_CTL6            	0x47
+#define XLP_USB_CTL7            	0x48
+
+#define XLP_USB_BYTESWAP    		0x49
+
+#define XLP_USB_PHY0            	0x4A
+#define XLP_USB_PHY1            	0x4B
+#define XLP_USB_PHY2            	0x4C
+    #define USBPHYRESET         	0x01
+    #define USBVBUSDETECT		0x02
+    #define USBREFCLK_12MHZ		0x00
+    #define USBREFCLK_24MHZ     	0x04
+    #define USBREFCLK_48MHZ     	0x08
+    #define USBPHYPORTRESET0    	0x10
+    #define USBPHYPORTRESET1    	0x20
+
+#define XLP_USB_STATUS0         	0x4D
+#define XLP_USB_INT_STATUS0     	0x4E
+#define XLP_USB_INT_EN          	0x4F
+    #define USB_PHY_INTERRUPT_EN    	0x01
+    #define USB_OHCI_INTERRUPT_EN   	0x02
+    #define USB_OHCI_INTERRUPT1_EN  	0x04
+    #define USB_OHCI_INTERRUPT12_EN 	0x08
+    #define USB_CTRL_INTERRUPT_EN   	0x10
+
+
+#define XLP_USB3_CTL			0x100
+#define XLP_USB3_INT			0x102
+#define XLP_USB3_INT_MASK		0x103
+#define XLP2XX_USB_PHY_TEST		0x106
+#define XLP2XX_USB_PHY_LOS_LEV		0x109
+#define XLP2XX_USB_PHY_PLL_MULT		0x10a
+#define XLP2XX_USB_REF_CLK		0x10c
+
+
+#ifndef NLM_HAL_LINUX_KERNEL		/* This is not applicable in Linux */
+#define XLP_NOR_IRQ			20
+#define XLP_NAND_IRQ			21
+#define XLP_SPI_IRQ			22
+#define XLP_MMC_IRQ	                23
+#define XLP_USB_EHCI_IRQ                24
+#define XLP_USB_OHCI_IRQ                25
+#define XLP_USB_IRT0			115
+#define XLP_NOR_IRT			150
+#define XLP_NAND_IRT			151
+#define XLP_SPI_IRT			152
+#define XLP_MMC_IRT			153
+#endif
+
+#define XLP_PCIE_SPI_NOR_FLASH_DEV	7
+#define XLP_PCIE_SPI_NOR		0
+#define XLP_PCIE_SPI_NAND		1
+#define XLP_PCIE_SPI_CTRL		2
+#define XLP_PCIE_SPI_SD			3
+
+#define XLP_PCIE_GIO_DEV		6
+#define XLP_PCIE_USB_DEV		2
+#define XLP_PCIE_USB3_DEV		4
+#define XLP_PCIE_USB_FUNC_0		0
+#define XLP_PCIE_USB_FUNC_1		1
+#define XLP_PCIE_USB_FUNC_2		2
+#define XLP_PCIE_USB_FUNC_3		3
+#define XLP_PCIE_USB_FUNC_4		4
+#define XLP_PCIE_USB_FUNC_5		5
+
+
+#define XLP_GIO_UART0_FUNC		0
+#define XLP_GIO_UART1_FUNC		1
+#define XLP_GIO_I2C0_FUNC		2
+#define XLP_GIO_I2C1_FUNC		3
+#define XLP_GIO_GPIO_FUNC		4
+
+#define XLP_GPIO_OUTPUT_EN0		0x40	/* GPIO 31:0    */
+#define XLP_GPIO_OUTPUT_EN1		0x41	/* GPIO 40:32   */
+#define XLP_GPIO_OUTPUT0		0x42	/* outpin 31:0  */
+#define XLP_GPIO_OUTPUT1		0x43	/* outpin 40:32 */
+#define XLP_GPIO_INPUT0			0x44	/* input 31:0   */
+#define XLP_GPIO_INPUT1			0x45	/* input 40:32  */
+#define XLP_GPIO_INTEN00		0x46	/* irt 146 31:0  */
+#define XLP_GPIO_INTEN01		0x47	/* irt 146 40:32  */
+#define XLP_GPIO_INTEN10		0x48	/* irt 147 31:0  */
+#define XLP_GPIO_INTEN11		0x49	/* irt 147 40:32  */
+#define XLP_GPIO_INTEN20		0x4A	/* irt 148 31:0  */
+#define XLP_GPIO_INTEN21		0x4B	/* irt 148 40:32  */
+#define XLP_GPIO_INTEN30		0x4C	/* irt 149 31:0  */
+#define XLP_GPIO_INTEN31		0x4D	/* irt 149 40:32  */
+#define XLP_GPIO_INT_POLAR0		0x5E	/* int polarity	31:0   */
+#define XLP_GPIO_INT_POLAR1		0x5F	/* int polarity	40:32  */
+#define XLP_GPIO_INT_TYPE0		0x60	/* int level type 31:0   */
+#define XLP_GPIO_INT_TYPE1		0x61	/* int level type 40:32  */
+#define XLP_GPIO_INT_STAT0		0x62	/* int status 31:0   */
+#define XLP_GPIO_INT_STAT1		0x63	/* int status 40:32  */
+#define XLP_8XX_GPIO_INT_POLAR0		0x4E	/* int polarity	31:0   */
+#define XLP_8XX_GPIO_INT_POLAR1		0x4F	/* int polarity	40:32  */
+#define XLP_8XX_GPIO_INT_TYPE0		0x50	/* int level type 31:0   */
+#define XLP_8XX_GPIO_INT_TYPE1		0x51	/* int level type 40:32  */
+#define XLP_8XX_GPIO_INT_STAT0		0x52	/* int status 31:0   */
+#define XLP_8XX_GPIO_INT_STAT1		0x53	/* int status 40:32  */
+#define XLP_GPIO_INT0_IRT       	146
+#define XLP_GPIO_INT1_IRT       	147
+#define XLP_GPIO_INT2_IRT       	148
+#define XLP_GPIO_INT3_IRT       	149
+
+/* NOR Flash memory interface */
+
+#define NLM_NOR_BUS_NUM        0
+#define NLM_NOR_DEV_NUM        7
+#define NLM_NOR_FUN_NUM        0
+
+#define NLM_NOR_CFG_BASE        ( 0x18000000 | (NLM_NOR_DEV_NUM << 15) | (NLM_NOR_FUN_NUM << 12))
+
+#define XLP_NOR_CS_BASE         0x40
+#define XLP_NOR_CS_LIMIT        0x48
+#define XLP_NOR_DEVPARAM        0x50
+#define XLP_NOR_DEV_TIME0       0x58
+#define XLP_NOR_DEV_TIME1       0x59
+
+
+#define NAE_CLK_DIV		0x1
+#define SAE_CLK_DIV		0x2
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#define DFS_OUTPUT(DR, DF, DV)  ((400/((DR+1) * 3)) * (DF+1) * 2)/(DV+1)
+#else
+#define DFS_OUTPUT(DR, DF, DV)  ((133.33/(DR+1)) * (DF+1) * 2)/(DV+1)
+#endif
+
+#endif /*__ASSEMBLY__*/
+
+/* SATA related */
+
+/* SATA CONTROLLER PORT REGISTERS */
+#define SataCLB           0x00
+#define SataCLBU          0x04
+#define SataFB            0x08
+#define SataFBU           0x0c
+#define SataIS            0x10
+#define SataIE            0x14
+#define SataCMD           0x18
+#define SataTFD           0x20
+#define SataSIG           0x24
+#define SataSSTS          0x28
+#define SataSCTL          0x2c
+#define SataSERR          0x30
+#define SataSACT          0x34
+#define SataCI            0x38
+#define SataSNTF          0x3c
+#define SataFBS           0x40
+#define SataDMACR         0x70
+#define SataPHYCR         0x78
+#define SataPHYSTS        0x7c
+
+#define ECFG_BASE               0xffffffffb8000000ULL
+#define SATA_DEV_NUM            3
+#define SATA_FUNC_NUM           2
+#define XLP_IO_SATA_BASE        (ECFG_BASE | (SATA_DEV_NUM << 15) | (SATA_FUNC_NUM << 12))
+
+/* #define XLP_MEM_SATA_BASE       0xd0042000 */
+/* #define wr_sata_mem_reg(offset, val)            sw_40bit_phys_uncached(((uint64_t)XLP_MEM_SATA_BASE) + (offset), val) */
+/* #define rd_sata_mem_reg(offset)                 lw_40bit_phys_uncached(((uint64_t)XLP_MEM_SATA_BASE) + (offset)) */
+
+#define wr_sata_glue_reg(offset, val)           write_32bit_cfg_reg((uint32_t *)(XLP_IO_SATA_BASE + 0x900), (offset >> 2), val)
+#define rd_sata_glue_reg(offset)                read_32bit_cfg_reg((uint32_t *)(XLP_IO_SATA_BASE + 0x900), (offset >> 2))
+
+#define set_sata_glue_reg(offset, bit)          wr_sata_glue_reg(offset, (rd_sata_glue_reg(offset) | bit))
+#define clear_sata_glue_reg(offset, bit)        wr_sata_glue_reg(offset, (rd_sata_glue_reg(offset) & ~bit))
+
+#define XLP_HAL_SATA_CTL                0x00    /*  */
+#define XLP_HAL_SATA_STATUS             0x04    /* SATA Status register */
+#define XLP_HAL_SATA_INT                0x08    /* SATA Interrupt Register */
+#define XLP_HAL_SATA_INT_MASK           0x0c    /* SATA Interrupt Mask Register */
+#define XLP_HAL_SATA_CR_REG_TIMER       0x10    /* PHY Conrol Timer Register */
+#define XLP_HAL_SATA_CORE_ID            0x14    /* SATA Core ID Register */
+#define XLP_HAL_SATA_AXI_SLAVE_OPT1     0x18    /* SATA AXI Slave Options Register */
+#define XLP_HAL_SATA_PHY_LOS_LEV        0x1c    /* SATA PHY LOS Level Register  */
+#define XLP_HAL_SATA_PHY_MULTI          0x20    /* SATA PHY Multiplier Register          */
+#define XLP_HAL_SATA_PHY_CLK_SEL        0x24    /* SATA PHY Clock Select Register */
+#define XLP_HAL_SATA_PHY_AMP1_GEN1      0x28    /* SATA PHY Transmit Amplitude Register 1    */
+#define XLP_HAL_SATA_PHY_AMP1_GEN2      0x2c    /* SATA PHY Transmit Amplitude Register 2    */
+#define XLP_HAL_SATA_PHY_AMP1_GEN3      0x30    /* SATA PHY Transmit Amplitude Register 3    */
+#define XLP_HAL_SATA_PHY_PRE1           0x34    /* SATA PHY Transmit Preemphasis Register 1 */
+#define XLP_HAL_SATA_PHY_PRE2           0x38    /* SATA PHY Transmit Preemphasis Register 2 */
+#define XLP_HAL_SATA_PHY_PRE3           0x3c    /* SATA PHY Transmit Preemphasis Register 3 */
+#define XLP_HAL_SATA_SPDMODE            0x40    /* SATA Speed Mode Register */
+#define XLP_HAL_SATA_REFCLK             0x44    /* SATA Reference Clock Control Register */
+#define XLP_HAL_SATA_BYTE_SWAP_DIS	0x74    /* SATA byte swap disable */
+
+/* SATA_CTL Bits */
+#define SATA_RST_N      (1 << 0)
+#define PHY0_RESET_N    (1 << 16)
+#define PHY1_RESET_N    (1 << 17)
+#define PHY2_RESET_N    (1 << 18)
+#define PHY3_RESET_N    (1 << 19)
+#define M_CSYSREQ       (1 << 2)
+#define S_CSYSREQ       (1 << 3)
+
+/* SATA_STATUS Bits */
+#define P0_PHY_READY (1 << 4)
+#define P1_PHY_READY (1 << 5)
+#define P2_PHY_READY (1 << 6)
+#define P3_PHY_READY (1 << 7)
+
+/* SATA CONTROLLER GENERIC HOST REGISTERS */
+#define SATA_CAP                0x00
+#define SATA_GHC                0x04
+#define SATA_IS                 0x08
+#define SATA_PI                 0x0c
+#define SATA_AHCI               0x10
+#define SATA_CCC_CTL            0x14
+#define SATA_CCC_PORTS          0x18
+#define SATA_CAP2               0x24
+#define SATA_BISTAFR            0xa0
+#define SATA_BISTCR             0xa4
+#define SATA_BISTFCTR           0xa8
+#define SATA_BISTSR             0xac
+#define SATA_OOBR               0xbc
+#define SATA_TIMER1MS           0xe0
+#define Reserved5               0x0
+#define SATA_GPARAM1R           0xe8
+#define SATA_GPARAM2R           0xec
+#define SATA_PPARAMR            0xf0
+#define SATA_TESTR              0xf4
+#define SATA_VERSIONR           0xf8
+#define SATA_IDR                0xfc
+
+#define HBAReset (1 << 0)
+
+
+/* XLP BIU_NUMBER
+ * Used by 6.5.0x54.SYSDISABLE & 6.5.0x55.SYS_RESET
+ */
+#define XLP2XX_IO_NUM_OF_BIUS                16
+/* sbb0 */
+#define XLP2XX_IO_PIC_BIU_NUMBER             0
+#define XLP2XX_IO_PCIE0_BIU_NUMBER           1
+#define XLP2XX_IO_PCIE1_BIU_NUMBER           2
+#define XLP2XX_IO_PCIE2_BIU_NUMBER           3
+#define XLP2XX_IO_PCIE3_BIU_NUMBER           4
+#define XLP2XX_IO_USB_BIU_NUMBER             5
+#define XLP2XX_IO_GDX_BIU_NUMBER             6
+#define XLP2XX_IO_CMP_BIU_NUMBER             7
+#define XLP2XX_IO_SEC_BIU_NUMBER             8
+#define XLP2XX_IO_RSA_BIU_NUMBER             9
+/* sbb1 */
+#define XLP2XX_IO_GIO_BIU_NUMBER             10
+#define XLP2XX_IO_GBU_BIU_NUMBER             11
+#define XLP2XX_IO_NET_BIU_NUMBER             12
+#define XLP2XX_IO_MSG_BIU_NUMBER             13
+#define XLP2XX_IO_POE_BIU_NUMBER             14
+#define XLP2XX_IO_REGX_BIU_NUMBER            15
+
+
+#define XLP3XX_IO_NUM_OF_BIUS                17
+/* sbb0 */
+#define XLP3XX_IO_PIC_BIU_NUMBER             0
+#define XLP3XX_IO_PCIE0_BIU_NUMBER           1
+#define XLP3XX_IO_PCIE1_BIU_NUMBER           2
+#define XLP3XX_IO_PCIE2_BIU_NUMBER           3
+#define XLP3XX_IO_PCIE3_BIU_NUMBER           4
+#define XLP3XX_IO_USB_BIU_NUMBER             5
+#define XLP3XX_IO_POE_BIU_NUMBER             7
+#define XLP3XX_IO_SATA_BIU_NUMBER            10
+#define XLP3XX_IO_SRIO_BIU_NUMBER            15
+#define XLP3XX_IO_REGX_BIU_NUMBER            16
+/* sbb1 */
+#define XLP3XX_IO_GIO_BIU_NUMBER             8
+#define XLP3XX_IO_GBU_BIU_NUMBER             9
+#define XLP3XX_IO_NET_BIU_NUMBER             6
+#define XLP3XX_IO_MSG_BIU_NUMBER             11
+#define XLP3XX_IO_GDX_BIU_NUMBER             12
+#define XLP3XX_IO_SEC_BIU_NUMBER             13
+#define XLP3XX_IO_RSA_BIU_NUMBER             14
+
+
+#define XLP8XX_IO_NUM_OF_BIUS                18
+/* sbb0 */
+#define XLP8XX_IO_ICI0_BIU_NUMBER            0
+#define XLP8XX_IO_ICI1_BIU_NUMBER            1
+#define XLP8XX_IO_ICI2_BIU_NUMBER            2
+#define XLP8XX_IO_PIC_BIU_NUMBER             3
+#define XLP8XX_IO_PCIE0_BIU_NUMBER           4
+#define XLP8XX_IO_PCIE1_BIU_NUMBER           5
+#define XLP8XX_IO_PCIE2_BIU_NUMBER           6
+#define XLP8XX_IO_PCIE3_BIU_NUMBER           7
+#define XLP8XX_IO_USB_BIU_NUMBER             8
+#define XLP8XX_IO_NET_BIU_NUMBER             9
+#define XLP8XX_IO_POE_BIU_NUMBER             10
+#define XLP8XX_IO_GIO_BIU_NUMBER             16
+#define XLP8XX_IO_GBU_BIU_NUMBER             17
+/* sbb1 */
+#define XLP8XX_IO_MSG_BIU_NUMBER             11
+#define XLP8XX_IO_GDX_BIU_NUMBER             12
+#define XLP8XX_IO_SEC_BIU_NUMBER             13
+#define XLP8XX_IO_RSA_BIU_NUMBER             14
+#define XLP8XX_IO_CMP_BIU_NUMBER             15
+
+#endif /* #ifndef NLM_HAL_XLP_DEV_H */
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_srio_xlp.h b/arch/mips/netlogic/lib/syslib/include/nlm_srio_xlp.h
new file mode 100644
index 0000000..881a15f
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_srio_xlp.h
@@ -0,0 +1,660 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef __NLM_SRIO_XLP_H__
+#define __NLM_SRIO_XLP_H__
+
+/* SRIO Block configuration */
+#define SRIO_MODE_4x1
+#define SRIO_BUF_SIZE		4096
+
+#define SRIO_BAUD_1250M		1	/*Mode4 1.25G */
+#define SRIO_BAUD_2500M		2	/*Mode3 25.G */
+#define SRIO_BAUD_3125M		3	/*Mode2 3.125G */
+#define SRIO_BAUD_5000M		4	/*Mode1 5G */
+#define SRIO_BAUD_6250M		5	/*Mode0 6.25G */
+#define SRIO_PORT_BAUD_RATE	SRIO_BAUD_6250M	
+
+#define MAX_DOORBELL_XLP3XX_AX	16
+#define MAX_MSGDESTINATION	256
+#define MAX_SWITCH_ENTRY	32
+#define MAX_MBOX		4
+
+#define NLM_SRIO_TT		0	/* 8 bit devid by default */
+#define NLM_SRIODEV_MASK        0xFFFF 
+
+#define PATH_MODE_SEL_VAL_0	0
+#define PATH_MODE_SEL_VAL_4	4
+
+#ifdef SRIO_MODE_1x4
+#define PATH_MODE_SEL_VAL	0
+#define NLM_MAX_SRIO_PORTS	1
+#elif defined(SRIO_MODE_4x1)
+#define PATH_MODE_SEL_VAL       4
+#define NLM_MAX_SRIO_PORTS      4
+#endif
+
+/*SRIO MODE */
+#define SRIO_MODE_x1		1
+#define SRIO_MODE_x4		2
+
+/* FTYPE */
+#define FTYPE_REQUEST		2  /* NREAD, ATMOIC		 */
+   #define TRANS_NREAD	  	4
+   #define TRANS_ATOMIC_INC  	12
+   #define TRANS_ATOMIC_DEC	13
+   #define TRANS_ATOMIC_SET  	14
+   #define TRANS_ATOMIC_CLR	15		
+
+#define FTYPE_WRITE		5  /* NWRITE, NWRITE_R, ATOMIC */
+   #define TRANS_NWRITE		4
+   #define TRANS_NWRITE_R	5
+   #define TRANS_ATOMIC_SWP	12
+   #define TRANS_ATOMIC_CMPSWP	13
+   #define TRANS_ATOMIC_TSTSWP  14	
+
+#define FTYPE_SWRITE		6  /* SWRITE */
+
+#define FTYPE_MAINTENANCE	8  /* MAINTENANCE */
+   #define TRANS_MREAD		0
+   #define TRANS_MWRITE		1
+   #define TRANS_MREAD_RESP	2
+   #define TRANS_MWRITE_RESP	3
+   #define TRANS_PWRITE		4
+
+#define FTYPE_DOORBELL		10 /* Doorbell */
+
+#define FTYPE_MESSAGE		11 /* Data message */
+
+#define FTYPE_RESPONSE		13 /* Response */
+
+/* SRIO VC */
+#define XLP_SRIO_TXVC_BASE	280
+#define XLP_SRIO_ADDRQ_VC	288
+
+#define NLM_SRIO_BUS_NUM 	0
+#define NLM_SRIO_DEV_NUM 	5
+#define NLM_SRIO_FUN_NUM 	4 
+
+#define NLM_SRIO_CFG_BASE	 ( 0x18000000 | (NLM_SRIO_DEV_NUM << 15) | (NLM_SRIO_FUN_NUM << 12))   
+/* SriComplex Configuration Register */
+
+#define SRICOMCONFIG    	0x40
+   #define WR_BLOCK_DISABLE   	0x00000001
+   #define DEV_ECC_DISABLE	0x00000002
+   #define BIU_TOUT_ENABLE      0x00000004
+   #define RESP_TOUT_ENABLE     0x00000008
+   #define SRICOMCONFIG_RSVD1   4
+   #define DBELL_INDX_START_POS 13  /* 16:13   */
+   #define IPCLK_GATING_DIS0    0x00020000 
+   #define IPCLK_GATING_DIS1	0x00040000
+   #define IPCLK_GATING_DIS2	0x00080000
+   #define IPCLK_GATING_DIS3	0x00100000
+   #define PAYLOAD_INDESC	0x00200000
+   #define SRICOMCONFIG_RSVD2   22  /* 25:22  */
+   #define SRI_EACTRL           0x04000000   
+   #define IP_RESET	        0x08000000 
+   #define REG_RESET	        0x10000000
+   #define PLL_RESET	        0x20000000 
+   #define SRICOMCONFIG_RSVD3   30  /* 31:30 */
+
+   #define DBELLINDEX_MASK	0xFFFE1FFF
+   #define MAX_DBELL_OFFSET_XLP3XX_AX	12
+	
+
+/* SRIOIP Control Register */
+#define SRIOIPCTRL              0x41
+   #define PORT0_RSTREQ		0x00000001
+   #define PORT1_RSTREQ		0x00000002
+   #define PORT2_RSTREQ         0x00000004        
+   #define PORT3_RSTREQ         0x00000008        
+   #define PORT0_READY		0x00000010
+   #define PORT1_READY          0x00000020                
+   #define PORT2_READY          0x00000040                
+   #define PORT3_READY          0x00000080                
+   #define PORT0_LOOPBACK	0x00000100
+   #define PORT1_LOOPBACK       0x00000200                
+   #define PORT2_LOOPBACK       0x00000400                
+   #define PORT3_LOOPBACK       0x00000800                
+   #define PORT0_ENUM		0x00001000
+   #define PORT1_ENUM           0x00002000
+   #define PORT2_ENUM           0x00004000
+   #define PORT3_ENUM           0x00008000
+   #define LANE0_TXMODE		0x00010000
+   #define LANE1_TXMODE         0x00020000
+   #define LANE2_TXMODE         0x00040000
+   #define LANE3_TXMODE         0x00080000
+   #define BOOT_COMPLETE	0x00100000
+   #define SRIO_SWPORT_POS	21 /*28:21 */
+   #define PORT_WR_REQ		0x20000000
+   #define SRIOIPCTRL_RSVD	30 /*31:30 */
+		
+/* SRIOIP Configuration Register */
+#define SRIOIPCONFIG            0x42
+   #define PORT0_PWRDWN		0x00000001
+   #define PORT1_PWRDWN		0x00000002
+   #define PORT2_PWRDWN		0x00000004
+   #define PORT3_PWRDWN		0x00000008
+   #define SRIO_PATHID_POS	4  /*8:4 */
+   #define PATH_MODE_SEL_POS	9  /*11:9 */
+   #define PATH_BAUD_RATE_POS	12 /*16:12 */
+   #define PORT0_BAUD_RATE_POS	17 /*19:17 */
+   #define PORT1_BAUD_RATE_POS	20 /*22:20 */
+   #define PORT2_BAUD_RATE_POS	23 /*25:23 */
+   #define PORT3_BAUD_RATE_POS	26 /*28:26 */
+   #define PORT_GEN_CTRL_POS	29 /*31:29  */
+
+/* SRIOIP Configuration Status Register */
+#define SRIOIPSTATUS		0x43
+   #define PORT0_PWRDWN_STS	0x00000001
+   #define PORT1_PWRDWN_STS	0x00000002
+   #define PORT2_PWRDWN_STS	0x00000004
+   #define PORT3_PWRDWN_STS	0x00000008
+   #define PATH_MODE_SEL_STS_POS	4  /*6:4 */
+   #define LANE0_BAUD_RATE_STS_POS	7  /*10:7 */
+   #define LANE1_BAUD_RATE_STS_POS	11 /*14:11 */
+   #define LANE2_BAUD_RATE_STS_POS 	15 /*18:15 */
+   #define LANE3_BAUD_RATE_STS_POS	19 /*22:19 */
+   #define SRIO_HOST_END_STS	0x00800000
+   #define SRIO_HOST_EN_STS	0x01000000
+   #define SRIO_MASTER_EN_STS	0x02000000
+   #define SRIO_DEV_DISC_STS	0x04000000
+   #define SRIOIPSTATUS_RSVD	27 /*31:27 */
+ 	
+/* SRIOIP Base Device ID Register */
+#define SRIOBASEDEVID           0x44
+   #define SRIO_BASE_DEVID_POS		0 /*23:0 */
+   #define SRIOBASEDEVID_RSVD		24 /*31:24 */
+   #define SRIO_8BIT_DEVID_POS		16	
+
+/* SRIOIP Base Device ID Status Register */
+#define  SRIOBASEDEVID_STATUS	0x45
+   #define SRIOBASEDEVID_STAT_POS	0 /*23:0 */
+   #define SRIOBASEDEVIDS_RSVD 		24 /*31:24  */
+
+/* SRIOIP Device ID Register */
+#define SRIODEVICEID            0x46
+
+/* SRIOIP Device INFO Register */
+#define SRIODEVICEINFO          0x47
+
+/* SRIOIP Port Write Data Register */
+#define SRIOPORTWDATA           0x48
+
+/*SRIO PHY Reg Read/Write Control Register (Indirect Access) */
+#define PHYRDWRCTRL             0x49
+   #define PHY_REGLANE		0
+   #define PHY_REGADDR		4
+
+/* SRIO PHY Reg Read/Write Access Register (Indirect Access) */
+#define PHYRDWRACCS            	0x4A
+
+/* Biu Timeout Value Register */
+#define BIU_TIMEOUT_VAL		0x4B
+
+/*Response Packet Timeout Value Register */
+#define RESP_TIMEOUT_VAL	0x4C
+
+/* Message Destination ID for Port */
+/* Total of 4 ports */
+#define MSG_DESTID		0x4D
+   #define MSG_DESTID_PORT_POS		0 /*11:0 */
+   #define MSG_DESTID_CODE_POS  	12 /* 19:12 */
+
+/* Message Destination ID for Doorbell Distribution Table  */
+/* Total of 16 entries */
+#define DOORBELL_DESTID_XLP3XX_AX	0x51
+
+/* Destination ID for Data Message Lookup Byte Offset */
+#define DATAMSGBYTE     	0x61 /*Lookup Byte Offset; 0-255 */
+
+/* Destination ID for Data Message Lookup Enable */
+/* Total of 4 entries - 32x4=128 bits */
+#define DATAMSGEN0               0x62
+#define DATAMSGEN1               0x63
+#define DATAMSGEN2               0x64
+#define DATAMSGEN3               0x65
+
+/* Destination ID for Data Message Distribution Table */
+/* Total of 256 entries */
+#define DATAMSG_DESTID		0x66
+
+/* Switch CAM Table */
+/* Total of 32 entries */
+#define SWITCH_ENTRY		0x166
+   #define SWITCH_ENTRY_KEY	0
+   #define SWITCH_RES_PORT	16
+   #define SWITCH_RES_CPU	18
+   #define SWITCH_RES_DROP	19
+
+/* Switch Default */
+#define SWITCHDEFAULT           0x186
+   #define SWITCH_DEF_PORT	0
+   #define SWITCH_DEF_CPU	2
+   #define SWITCH_DEF_DROP	3
+
+/* Direct IO Operation Table */
+/* Totll of 32 entries */
+#define DIRECTIO_CMD		0x187
+   #define DIRIO_CMD_DESTID	0
+   #define DIRIO_CMD_PORT	16
+   #define DIRIO_CMD_TT		18
+   #define DIRIO_CMD_CRC	19
+   #define DIRIO_CMD_CRF	20
+   #define DIRIO_CMD_PRIO	21
+   #define DIRIO_CMD_HOP	23
+
+/* Diret IO Response Table */
+/* Total of 32 entires */
+#define DIRECTIO_RESP   	0x1a7
+
+/* Diret IO Ctrl */
+#define DIRECTIO_CTRL		0x1c7
+
+/* Byte Swap Register */
+#define BYTE_SWAP 		0x1ca
+
+/* Alloc Base Register */
+#define ALLOC_BASE		0x1cb
+
+/* Alloc Limit Register */
+#define ALLOC_LIMIT		0x1cc
+
+/* Read Exclusive Base Register */
+#define RDEXC_BASE		0x1cd
+
+/* Read Exclusive Limit Register */
+#define RDEXC_LIMIT		0x1ce
+
+/* Sri Error Source 0 Register */
+#define SRIERR_SRC0		0x1cf
+   #define BIU_TIMEOUT		0
+   #define DMA_RDERR		8
+   #define INMSG_ERR		16
+   #define OUTMSG_S_ERR		25
+   #define OUTMSG_M_ERR		26
+   #define SRIGEN_EXCP		27
+
+/* Sri Error Source 1 Register */
+#define SRIERR_SRC1 		0x1d0
+
+/* Sri Error Interrupt Enable 0 Register */
+#define SRIERRINT_EN0    	0x1d1
+
+/* Sri Error Interrupt Enable 1 Register */
+#define SRIERRINT_EN1 		0x1d2
+
+/* FMB Egress SECC Info Register */
+#define SRI_SECCINF        	0x1d3
+
+/* FMB Egress MECC Info Register */
+#define SRI_MECCINF		0x1d4
+
+/* Sri Response Timeout Info 0 Register */
+#define SRI_RSPTMINF0		0x1d5
+
+#define SRI_RSPTMINF1           0x1d6
+#define SRI_RSPTMINF2           0x1d7
+
+#define SRI_RSPTMINF3           0x1d8
+
+
+/*RIO Specific registers */
+#define RIO_SRC_OP		0x18
+#define RIO_PORTMAINT_HDR	0x100
+#define RIO_LNKTOUT_CSR		0x120
+#define RIO_RESPTOUT_CSR	0x124
+#define RIO_PORTGEN_CSR 	0x13c
+
+#define RIO_PORT0CTRL2_CSR      0x154
+#define RIO_PORT1CTRL2_CSR      0x174
+#define RIO_PORT2CTRL2_CSR      0x194
+#define RIO_PORT3CTRL2_CSR      0x1b4
+
+#define RIO_PORT0CTRL_CSR	0x15c	
+#define RIO_PORT1CTRL_CSR       0x17c               
+#define RIO_PORT2CTRL_CSR       0x19c               
+#define RIO_PORT3CTRL_CSR       0x1bc               
+
+/*/ SBB */
+
+#define DIRIO_RESP_MASK		0xF
+/* dirio 40 bit phys addr */
+#define DIRIO_PHYS_ADDR		0
+#define DIRIO_PHYS_THRD		32
+#define DIRIO_PHYS_OP		37
+#define DIRIO_PHYS_SRIO		39
+
+/* dirio opcode */
+#define DIRIO_OP_NREAD		0
+#define DIRIO_OP_MREAD		3
+
+#define DIRIO_OP_NWRITE		0
+#define DIRIO_OP_NWRITE_R	1
+#define DIRIO_OP_MWRITE		2
+#define DIRIO_OP_PWRITE		3
+
+
+#define SRIO_DIRIO_CMD(dst, port, tt, crc, crf, prio, hop) \
+	((hop << DIRIO_CMD_HOP)  | (prio << DIRIO_CMD_PRIO) | \
+	 (crf << DIRIO_CMD_CRF) | (crc << DIRIO_CMD_CRC) | \
+	 (tt << DIRIO_CMD_TT) | (port << DIRIO_CMD_PORT) | dst)
+
+	
+#define SRIO_DIRIO_40BITPHYS(addr, cpu, opcode) \
+	(uint64_t)((1ULL << DIRIO_PHYS_SRIO) | ((uint64_t)opcode << DIRIO_PHYS_OP) | ((uint64_t)cpu << DIRIO_PHYS_THRD) | addr)
+
+#define DIRECTIO_CMD_OFF	(DIRECTIO_CMD + getpid())
+#define DIRECTIO_RESP_OFF	(DIRECTIO_RESP + getpid())
+
+#define nlm_read_srio_devreg(index) nlm_hal_read_32bit_reg((uint64_t)NLM_SRIO_CFG_BASE, index)
+#define nlm_write_srio_devreg(index, val) nlm_hal_write_32bit_reg((uint64_t)NLM_SRIO_CFG_BASE, index, val)
+
+#if 0
+#define nlm_read_srio_reg8(offset)	lb_40bit_phys_uncached(((uint64_t)xlp_srio_base) + (offset))	
+#define nlm_read_srio_reg16(offset)  	lh_40bit_phys_uncached(((uint64_t)xlp_srio_base) + (offset))
+#define nlm_read_srio_reg64(offset)     ld_40bit_phys_uncached(((uint64_t)xlp_srio_base) + (offset))
+#endif
+
+#define nlm_read_srio_reg32(offset) 	lw_40bit_phys_uncached((uint64_t)xlp_srio_base + offset)
+#define nlm_read_srio_reg(index)	nlm_read_srio_reg32((index<<2))
+
+
+#if 0
+#define nlm_write_srio_reg8(offset, val)	sb_40bit_phys_uncached(((uint64_t)xlp_srio_base) + (offset), val)	
+#define nlm_write_srio_reg16(offset, val)	sh_40bit_phys_uncached(((uint64_t)xlp_srio_base) + (offset), val)	
+#define nlm_write_srio_reg64(offset, val)       sd_40bit_phys_uncached(((uint64_t)xlp_srio_base) + (offset), val)  
+#endif
+
+#define nlm_write_srio_reg32(offset, val)	sw_40bit_phys_uncached((uint64_t)xlp_srio_base + offset, val)	
+#define nlm_write_srio_reg(index, val)	nlm_write_srio_reg32((index<<2), val)
+
+
+/* FMN */
+
+/* xlp3xx-Ax */
+#define IS_FREEBACK(desc)		((desc >> 63) & 0x01ULL)
+#define IS_DMA_ERR(desc)		((desc >> 62) & 0x01ULL)	
+#define SRIO_PORT(desc)			((desc >> 59) & 0x03ULL)	
+#define SRIO_FTYPE(desc) 		((desc >> 48) & 0x0FULL)
+#define SRIO_DEST_ID(desc)		((desc >> 32) & 0xFFFFULL)
+#define SRIO_SRC_ID(desc)		((desc >> 16) & 0xFFFFULL)
+#define SRIO_TRANS_TYPE(desc)		((desc >> 12) & 0x0FULL)
+#define SRIO_RESP_STATUS(desc)		((desc >> 8) & 0x0FULL)	
+#define SRIO_PAYLOAD_LENGTH_XLP3XX_AX(desc)	((desc >> 48) & 0xFFFFULL)
+#define SRIO_PAYLOAD_ADDR(desc)		(desc & 0xFFFFFFFFFFULL)   
+#define SRIO_DBELL_INFO(desc)		((desc >> 48) & 0xFFFFULL)
+#define SRIO_MBOX(desc)			((desc >> 4) & 0x3)
+
+#define SRIO_FREEBACK			(1ULL << 58)
+#define SRIO_FMB_NO_DMA			(1ULL << 63)
+#define SRIO_MIN_SEGMENT_SIZE		8
+#define SRIO_MAX_SEGMENT_SIZE		256
+
+#define XLP_SRIO_FMBRX_DESC0(port, ftype, dest_dev, msg_dest_id, pri)  \
+	(uint64_t)(((uint64_t)port<<59) | ((uint64_t)pri<<54) | ((uint64_t)NLM_SRIO_TT << 52) | ((uint64_t)ftype << 48) | \
+	((uint64_t)(dest_dev & NLM_SRIODEV_MASK) << 32) | (msg_dest_id << 16))
+
+
+/* 
+ * Support for XLP3xx-B0, XLP1xx , XLP2xx
+ * Defined the register and descriptor format which is different from XLP3XX_AX
+ */
+
+#define SRIO_MAX_P2DS		128
+
+#define IS_LINK_RESP_TOUT(desc) ((desc >> 61) & 0x01ULL)
+#define SRIO_COS(desc)		((desc >> 8) & 0xffULL)
+#define SRIO_STREAM_ID(desc)	(desc & 0xffffULL)
+#define SRIO_LENGTH_ERROR(desc) ((desc >> 16) & 0x01ULL)
+
+#define MAX_DOORBELL		32
+#define MAX_DBELL_OFFSET	11
+
+/* Register offsets */
+    /*comconfig register changes  */
+#define SRICOMCONFIG_RXDMSG_TIMER_EN	0x00000010
+#define SRICOMCONFIG_TXDMSG_TIMER_EN	0x00000040
+
+#define DOORBELL_DESTID		0x1F0
+
+#define SRIO_DATAMSG_SIZE	0x1D9
+
+#define SRIO_SUPPRESS_CTRL      0x1E8
+#define TYPE2_SUPRS_EN          0x0001
+#define TYPE5_NORESP_SUPRS_EN   0x0002
+#define TYPE5_RESP_SUPRS_EN     0x0004
+#define TYPE6_SUPRS_EN          0x0008
+#define TYPE9_SUPRS_EN          0x0010
+#define TYPE10_SUPRS_EN         0x0020
+#define TYPE11_SUPRS_EN         0x0040
+
+#define RXEDMESG_TIMEOUT	0x210		
+#define TXEDMESG_TIMEOUT	0x212
+
+#define FLUSHADDRQ             0x278
+
+#define MAX_PACKET_LEN			4096
+#define MAX_P2PDMSG_PACKET_LEN		1024
+#define SRIO_PAYLOAD_LENGTH(desc)       ((desc >> 47) & 0x1FFFFULL)
+#define ADDR_MASK_40BIT			0xffffffffffULL
+/*------------------------------------------------------------------- 
+ * Message 1
+ *
+ * ---------------------------------------------------------------------*/
+
+/* NREAD, NWRITE, NWRITE_R, SWRITE */
+#define SRIO_P2P		(0x8000000000000000ULL)
+#define SRIO_P2D_LAST		(0x4000000000000000ULL)
+#define SRIO_INJECT_CRC		(0x2000000000000000ULL)
+#define SRIO_SEND_FREEBACK	(0x0400000000000000ULL)
+#define SRIO_SEND_RESP		(0x0200000000000000ULL)
+#define SRIO_NODMA_RESP		(0x0000000080000000ULL)
+
+#define	SRIO_P2P_POS		63	/* P2P or P2D desc */
+#define SRIO_P2D_LAST_POS	62	/* Last P2D desc  */
+#define SRIO_TT_POS		52	/* Transport type */
+#define SRIO_FTYPE_POS		48	/* Format type */
+#define SRIO_DESTID_POS		32	/* Destination device ID */
+#define SRIO_MSG_DESTID_POS	16	/* Message destination ID */
+#define SRIO_TRANS_POS		12	/* Transaction type */
+#define SRIO_SIZE_POS		0	/* Transfer byte size */
+
+#define SRIO_SWRITE_SIZE_POS	3	/* SWRITE transfer byte size */
+
+#define SRIO_MAINT_SIZE_POS	0
+
+#define SRIO_STREAM_COS_POS	8
+
+#define SRIO_DBELL_INFO_POS	0
+
+#define SRIO_DMSG_LTR_POS	6
+#define SRIO_DMSG_MBOX_POS	4
+#define SRIO_DMSG_XMBOX_POS	0
+
+
+#define SRIO_TT_MASK		(0x03ULL)
+#define SRIO_FTYPE_MASK		(0x0fULL)
+#define SRIO_DESTID_MASK	(0xffffULL)
+#define SRIO_MSG_DESTID_MASK	(0x0fffULL)
+#define SRIO_TRANS_MASK		(0x0fULL)
+#define SRIO_SIZE_MASK		(0x0fffULL)
+
+#define SRIO_SWRITE_SIZE_MASK	(0x1ffULL)
+
+#define SRIO_MAINT_SIZE_MASK	(0xfULL)
+
+#define SRIO_DBELL_INFO_MASK	(0xffffULL)
+
+#define SRIO_P2P_MESSAGE	0x8000000000000000ULL
+#define SRIO_DATA_MESSAGE_P2P	0x2000000000000000ULL
+#define SRIO_DATA_MESSAGE_POS	61
+#define SRIO_SINGLE_SEGMENT_POS	60
+		
+#define SRIO_DONT_SEND_RESP	0ULL
+#define SRIO_DONT_SEND_FREEBACK	0ULL
+#define SRIO_P2D_NOT_LAST	0ULL
+
+/*-------------------------------------------------------------------
+ * Message 2: NREAD/NWRITE/NWRITE_R
+ *  	63..40 Rsvd
+ *	39..0 Address
+ * Message 2: Maintenance
+ * 	63..32 Rsvd
+ *	31..24	hop count
+ *	23..2	configuration offset
+ *----------------------------------------------------------------*/
+#define SRIO_PACKET_ADDR_MASK	ADDR_MASK_40BIT
+
+#define SRIO_HOP_COUNT_POS	24
+#define SRIO_CONFIG_OFF_POS	2
+
+#define SRIO_STREAM_SIZE_POS	48
+#define SRIO_STREAM_ID_POS	0
+#define SRIO_STREAM_SIZE_MASK	0xffffULL
+#define SRIO_STREAM_ID_MASK	0xffffULL
+
+
+#define SRIO_DMSG_SIZE_POS	52
+#define SRIO_DMSG_LEN_POS	48
+
+#define SRIO_DATAMSG_TIMEOUT	0x20000ULL
+
+#define SRIO_P2P_NP2DS_POS	42
+#define SRIO_P2P_P2DADDR_POS	6
+#define SRIO_P2D_ADDR_MASK	0xFFFFFFFFC0ULL
+
+/*-------------------------------------------------------------------
+ * Message 3 : NREAD
+ *  	63..41	Rsvd
+ *	40	cache alloc
+ *	39..0	Base address to store response
+ * Message 3 : NWRITE/NWRITE_R
+ *  	63..42	Rsvd / dword[63..42]
+ *	41	Read exclusive / dword[41]
+ *	40	Cache alloc  / dword[40]
+ *	39..0	payload base address / dword[39..0]
+ *--------------------------------------------------------------------*/
+
+#define SRIO_READ_EXCL		41
+#define SRIO_CACHE_ALLOC_POS	40
+#define SRIO_PLOAD_ADDR_MASK	ADDR_MASK_40BIT
+
+
+static __inline__ uint64_t xlp_nread_fmbrx_desc0(uint64_t p2dlast, uint64_t resp, uint32_t dest_dev, uint32_t  msg_dest_id, uint32_t size) 
+{
+	return ((uint64_t)( ((uint64_t) p2dlast) | ((uint64_t) resp) | ((uint64_t) NLM_SRIO_TT << SRIO_TT_POS) |
+			    ((uint64_t)	FTYPE_REQUEST << SRIO_FTYPE_POS) | ((uint64_t) dest_dev << SRIO_DESTID_POS) |
+			    ((uint64_t) msg_dest_id << SRIO_MSG_DESTID_POS) |
+			    ((uint64_t) TRANS_NREAD << SRIO_TRANS_POS) | ((uint64_t) (size & SRIO_SIZE_MASK))	
+        		  ));
+}
+
+static __inline__ uint64_t xlp_nwrite_fmbrx_desc0(uint64_t p2dlast, uint64_t freeback, uint32_t dest_dev, uint32_t  msg_dest_id, uint32_t size) 
+{
+	return ((uint64_t)( ((uint64_t) p2dlast) | ((uint64_t) freeback) | ((uint64_t) NLM_SRIO_TT << SRIO_TT_POS) |
+			    ((uint64_t)	FTYPE_WRITE << SRIO_FTYPE_POS) | ((uint64_t) dest_dev << SRIO_DESTID_POS) |
+			    ((uint64_t) msg_dest_id << SRIO_MSG_DESTID_POS) |
+			    ((uint64_t) TRANS_NWRITE << SRIO_TRANS_POS) | ((uint64_t) (size & SRIO_SIZE_MASK))
+        		  ));
+}
+
+
+static __inline__ uint64_t xlp_nwriter_fmbrx_desc0(uint64_t p2dlast, uint64_t resp, uint32_t dest_dev, uint32_t  msg_dest_id, uint32_t size) 
+{
+	return ((uint64_t)( ((uint64_t) p2dlast) | ((uint64_t) resp) | ((uint64_t) NLM_SRIO_TT << SRIO_TT_POS) |
+			    ((uint64_t)	FTYPE_WRITE << SRIO_FTYPE_POS) | ((uint64_t) dest_dev << SRIO_DESTID_POS) |
+			    ((uint64_t) msg_dest_id << SRIO_MSG_DESTID_POS) |
+			    ((uint64_t) TRANS_NWRITE_R << SRIO_TRANS_POS) | ((uint64_t)(size & SRIO_SIZE_MASK))	
+        		  ));
+}
+
+static __inline__ uint64_t xlp_swrite_fmbrx_desc0(uint64_t p2dlast, uint64_t freeback, uint32_t dest_dev, uint32_t  msg_dest_id, uint32_t size) 
+{
+	return ((uint64_t)( ((uint64_t) p2dlast) | ((uint64_t) freeback) | ((uint64_t) NLM_SRIO_TT << SRIO_TT_POS) |
+			    ((uint64_t)	FTYPE_SWRITE << SRIO_FTYPE_POS) | ((uint64_t) dest_dev << SRIO_DESTID_POS) |
+			    ((uint64_t) msg_dest_id << SRIO_MSG_DESTID_POS) |
+			    ((uint64_t) (size & SRIO_SIZE_MASK))	
+        		  ));
+}
+
+static __inline__ uint64_t xlp_dbell_fmbrx_desc0(uint64_t p2dlast, uint64_t resp, uint32_t dest_dev, uint32_t  msg_dest_id, uint16_t info) 
+{
+	return ((uint64_t)( ((uint64_t) p2dlast) | ((uint64_t) resp) | ((uint64_t) NLM_SRIO_TT << SRIO_TT_POS) |
+			    ((uint64_t)	FTYPE_DOORBELL << SRIO_FTYPE_POS) | ((uint64_t) dest_dev << SRIO_DESTID_POS) |
+			    ((uint64_t) msg_dest_id << SRIO_MSG_DESTID_POS) |
+			    ((uint64_t) (info & SRIO_DBELL_INFO_MASK))	
+        		  ));
+}
+
+static __inline__ uint64_t xlp_dmesg_fmbrx_desc0(uint64_t p2dlast, uint64_t resp, uint32_t dest_dev, uint32_t  msg_dest_id, uint32_t mbox) 
+{
+	return ((uint64_t)( ((uint64_t) p2dlast) | ((uint64_t) resp) | ((uint64_t) NLM_SRIO_TT << SRIO_TT_POS) |
+			    ((uint64_t)	FTYPE_MESSAGE << SRIO_FTYPE_POS) | ((uint64_t) dest_dev << SRIO_DESTID_POS) |
+			    ((uint64_t) msg_dest_id << SRIO_MSG_DESTID_POS) |
+			    ((uint64_t) (mbox << SRIO_DMSG_MBOX_POS))	
+        		  ));
+}
+
+static __inline__ uint64_t xlp_dmesg_fmbrx_desc1(uint32_t size, uint32_t msglen, uint64_t paddr)
+{
+	return ((uint64_t)( ((uint64_t) (size & 0xFFF) << SRIO_DMSG_SIZE_POS) |
+		     	    ((uint64_t) ((msglen - 1) / SRIO_MAX_SEGMENT_SIZE) << SRIO_DMSG_LEN_POS) |
+			    ((uint64_t) (paddr & SRIO_PACKET_ADDR_MASK))
+			  ));
+}
+
+static __inline__ uint64_t xlp_p2p_dmesg_fmbrx_desc0(uint32_t ssegment, uint32_t dest_id, uint32_t mbox)
+{
+	return ((uint64_t)( ((uint64_t) SRIO_P2P_MESSAGE) | ((uint64_t) SRIO_DATA_MESSAGE_P2P) |
+			    ((uint64_t) NLM_SRIO_TT << SRIO_TT_POS) | ((uint64_t) ssegment << SRIO_SINGLE_SEGMENT_POS) |
+			    ((uint64_t) dest_id << SRIO_DESTID_POS) | ((uint64_t) mbox << SRIO_DMSG_MBOX_POS)
+			  ));
+}
+
+static __inline__ uint64_t xlp_p2p_fmbrx_desc0(void)
+{
+	return ((uint64_t)( ((uint64_t) SRIO_P2P_MESSAGE) | ((uint64_t) NLM_SRIO_TT << SRIO_TT_POS) ));
+}
+
+static __inline__ uint64_t xlp_p2p_fmbrx_desc1(uint32_t np2ds, uint64_t p2dlist)
+{
+	return ((uint64_t)( ((uint64_t) (np2ds & 0x7fULL) << SRIO_P2P_NP2DS_POS) |
+			    ((uint64_t) (p2dlist & SRIO_P2D_ADDR_MASK))
+			  ));	
+}
+
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_uaccess.h b/arch/mips/netlogic/lib/syslib/include/nlm_uaccess.h
new file mode 100644
index 0000000..f157bd0
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_uaccess.h
@@ -0,0 +1,214 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#ifndef _NLM_UACCESS_H
+#define _NLM_UACCESS_H
+
+#include <stdint.h>
+#include <string.h>
+
+#ifndef THREAD_SIZE
+#define THREAD_SIZE (2048 * sizeof(long))
+#endif
+
+static inline unsigned int nlm_uaccess_processor_id(void) 
+{
+	unsigned int val;
+	__asm__ volatile(
+			"syscall 11\n" 
+			"move %0, $8\n"    /* val = t0 */
+			:"=r"(val)
+			:
+			:"$8");
+
+	return val;
+}
+
+static inline unsigned int nlm_uaccess_hard_cpuid(void) 
+{
+	unsigned int val;
+	__asm__ volatile(
+			"syscall 14\n" 
+			"move %0, $8\n"    /* val = t0 */
+			:"=r"(val)
+			:
+			:"$8");
+
+	return val;
+}
+
+static __inline__ uint16_t nlm_uaccess_mem_read16(uint64_t phys)
+{
+        uint32_t lsb, msb;
+        uint16_t value;
+
+        lsb = phys & (0xffffffffULL);
+        msb = phys >> 32;
+
+        __asm__ volatile(
+                ".set push\n"
+                ".set arch=xlp\n"
+                ".set noreorder\n"
+                "move $8, %2\n"
+                "move $9, %1\n"
+                "syscall 25 \n"
+                "move %0, $10\n"
+                ".set pop\n"
+                :"=r"(value)
+                :"r"(lsb),"r"(msb)
+                :"$8", "$9", "$10"
+        );
+        return value;
+}
+
+static __inline__ void nlm_uaccess_mem_write16(uint64_t phys, uint16_t value)
+{
+        uint32_t lsb, msb;
+
+        lsb = phys & (0xffffffffULL);
+        msb = phys >> 32;
+
+        __asm__ volatile(
+                ".set push\n"
+                ".set arch=xlp\n"
+                ".set noreorder\n"
+                "move $8, %1\n"
+                "move $9, %0\n"
+                "move $10, %2\n"
+                "syscall 26 \n"
+                ".set pop\n"
+                :
+                :"r"(lsb),"r"(msb), "r"(value)
+                :"$8", "$9", "$10"
+        );
+        return;
+}
+
+static __inline__ uint32_t nlm_uaccess_mem_read32(uint64_t phys)
+{
+	uint32_t lsb, msb;
+	uint32_t value;
+
+	lsb = phys & (0xffffffffULL);
+	msb = phys >> 32;
+
+	__asm__ volatile(
+		".set push\n"
+		".set arch=xlp\n"
+		".set noreorder\n"
+		"move $8, %2\n"
+		"move $9, %1\n"
+		"syscall 21 \n"
+		"move %0, $10\n"
+		".set pop\n"
+		:"=r"(value)
+		:"r"(lsb),"r"(msb)
+		:"$8", "$9", "$10"
+	);
+	return value;
+}
+
+static __inline__ void nlm_uaccess_mem_write32(uint64_t phys, uint32_t value)
+{
+	uint32_t lsb, msb;
+
+	lsb = phys & (0xffffffffULL);
+	msb = phys >> 32;
+
+	__asm__ volatile(
+		".set push\n"
+		".set arch=xlp\n"
+		".set noreorder\n"
+		"move $8, %1\n"
+		"move $9, %0\n"
+		"move $10, %2\n"
+		"syscall 22 \n"
+		".set pop\n"
+		:
+		:"r"(lsb),"r"(msb), "r"(value)
+		:"$8", "$9", "$10"
+	);
+	return;
+}
+
+static __inline__ uint64_t nlm_uaccess_mem_read64(uint64_t phys)
+{
+	uint32_t lsb, msb;
+	uint64_t value;
+	uint64_t lsb_val, msb_val;
+
+	lsb = phys & (0xffffffffULL);
+	msb = phys >> 32;
+
+	__asm__ volatile(
+		".set push\n"
+		".set arch=xlp\n"
+		".set noreorder\n"
+		"move $8, %3\n"
+		"move $9, %2\n"
+		"syscall 19 \n"
+		"move %0, $11\n"
+		"move %1, $10\n"
+		".set pop\n"
+		:"=r"(lsb_val), "=r"(msb_val)
+		:"r"(lsb),"r"(msb)
+		:"$8", "$9", "$10", "$11"
+	);
+	value = ((uint64_t)msb_val << 32) | ((uint64_t)lsb_val);
+	return value;
+}
+
+
+static __inline__ void nlm_uaccess_mem_write64(uint64_t phys, uint64_t value)
+{
+	uint32_t lsb, msb;
+	uint32_t lsb_val, msb_val;
+
+	lsb = phys & (0xffffffffULL);
+	msb = phys >> 32;
+	lsb_val = value & (0xffffffffULL);
+	msb_val = value >> 32;
+	__asm__ volatile(
+		".set push\n"
+		".set arch=xlp\n"
+		".set noreorder\n"
+		"move $8, %1\n"
+		"move $9, %0\n"
+		"move $10, %3\n"
+		"move $11, %2\n"
+		"syscall 20 \n"
+		".set pop\n"
+		:
+		:"r"(lsb),"r"(msb), "r"(lsb_val), "r"(msb_val)
+		:"$8", "$9", "$10", "$11"
+	);
+	return;
+}
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_xlp.h b/arch/mips/netlogic/lib/syslib/include/nlm_xlp.h
new file mode 100644
index 0000000..0e99b40
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_xlp.h
@@ -0,0 +1,39 @@
+#ifndef _HAL_XLP_
+#define _HAL_XLP_
+static inline int hard_smp_processor_id(void)
+{
+	int id;
+
+	asm volatile ("mfc0 %0, $15, 1" : "=r"(id));
+	return id & 0x3ff;
+}
+
+extern cpumask_t phys_cpu_present_map;
+#define NLM_MAX_CPU_NODE        4
+#define NLM_MAX_DRAM_REGION     8
+#define NLM_MAX_CPU_PER_NODE    32
+#define NLM_MAX_THREADS_PER_CPU 4
+#define NLM_MAX_VC_PER_THREAD   4
+
+#define NLM_MAX_CPU_NODE_9XX		8
+#define NUM_CPUMASK_WORDS_9XX		2
+#define NLM_MAX_CPU_PER_NODE_9XX	80
+#define NLM_MAX_VC_PER_THREAD_9XX	4
+#define NLM_MAX_COREPAIR_PER_NODE_9XX	10
+#define NLM_MAX_VC_MASK_9XX		0x1ff	/* 0x1ff for 320 vc in xlp9xx per node*/
+
+typedef struct _big_mask_9xx {
+	uint64_t map[NLM_MAX_CPU_NODE_9XX][NUM_CPUMASK_WORDS_9XX];
+} big_mask_t;
+
+#ifdef CONFIG_64BIT
+#define DEFAULT_NETLOGIC_IO_BASE 0xffffffffb8000000ULL
+#else
+#define DEFAULT_NETLOGIC_IO_BASE 0xb8000000
+#endif
+
+/* hack for on_chip.c */
+#define XLP_IRQ_MSGRING_RVEC	5
+typedef struct { volatile int value; } nlm_common_atomic_t;
+
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/include/types.h b/arch/mips/netlogic/lib/syslib/include/types.h
new file mode 100644
index 0000000..bd81814
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/types.h
@@ -0,0 +1,74 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#ifndef _TYPES_H
+#define _TYPES_H
+
+#ifndef __ASSEMBLY__
+
+#include <sys/types.h>
+#include <stdint.h>
+
+enum {FALSE = 0, TRUE = 1};
+
+#if __LONG_MAX__ > 2147483647 || !defined(__GNUC__)
+typedef unsigned long __kernel_size_t;
+#else
+typedef unsigned int __kernel_size_t;
+#endif
+
+typedef unsigned char __u8, u8;
+//typedef signed char   int8_t;
+
+//typedef __int16_t   int16_t;
+//typedef __int32_t   int32_t;
+//typedef __int64_t   int64_t;
+
+//typedef __uint16_t  __u16, u16;
+//typedef __uint32_t  __u32, u32;
+//typedef __uint64_t  __u64, u64;
+
+#if (_MIPS_SIM == _MIPS_SIM_ABI32) || (_MIPS_SIM == _MIPS_SIM_NABI32) || \
+    (_MIPS_SZLONG == 32)
+typedef __uint32_t __uintptr_t;
+typedef __int32_t __intptr_t;
+#else
+typedef unsigned long int __uintptr_t;
+typedef long int __intptr_t;
+#endif
+
+typedef __const char *c_caddr_t;    /* core address, pointer to const */
+typedef __volatile char *v_caddr_t; /* core address, pointer to volatile */
+
+typedef volatile uint32_t phoenix_reg_t;
+
+#endif
+
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
new file mode 100644
index 0000000..92dbcae
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
@@ -0,0 +1,374 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef __XLP9XX_SYS_H__
+#define __XLP9XX_SYS_H__
+
+#include "nlm_hal.h"
+
+#ifndef __ASSEMBLY__
+enum processor_sys
+{
+        SYS_POWERONRESETCFG    = 0x0,
+        SYS_CHIPRESET          = 0x1,
+        SYS_CPURESET           = 0x2,
+        SYS_CPUNONCOHERENTMODE = 0x3,
+        SYS_CPUTHREADEN0       = 0x4,
+        SYS_CPUTHREADEN1       = 0x5,
+        SYS_SYSDISCFG0         = 0x25,
+        SYS_SYSDISCFG1         = 0x26,
+        SYS_SYSDISCFG2         = 0x27,
+        SYS_SYSDISCFG3         = 0x28,
+        SYS_SYSDISCFG4         = 0x29,
+        SYS_SYSDISCFG5         = 0x2a,
+        SYS_SYSDISCFG6         = 0x2b,
+        SYS_SYSDISCFG7         = 0x2c,
+        SYS_SYSDEVICEDIS       = 0x34,
+        SYS_SYSDEVICERESET     = 0x3c,
+        SYS_SYSRESETCFG        = 0x3d,
+        SYS_BYTESWAP           = 0x45,
+        SYS_SYSCTRL            = 0x46,
+        SYS_TIMEOUTBSI         = 0x47,
+        SYS_BISTRESET          = 0x48,
+        SYS_SYSCFG             = 0x49,
+        SYS_SYSHOTPLUGWAITOUT  = 0x4a,
+        SYS_SYSHOTPLUGWAITIN   = 0x4b,
+        SYS_SYSHOTPLUGDONE     = 0x4c,
+        SYS_SYSSCRATCH         = 0x69,
+        SYS_SYSCOUNTER         = 0x71,
+        SYS_SYSSTATUS          = 0x91,
+        SYS_SYSINTSTATUS       = 0x92,
+        SYS_SYSINTENABLE0      = 0x93,
+        SYS_SYSINTENABLE1      = 0x94,
+        SYS_MONITORCTRL        = 0x9c,
+        SYS_CPUMONITOR         = 0xa4,
+        SYS_DDRMONITOR         = 0x1a4,
+        SYS_SOCMONITOR         = 0x1ac,
+        SYS_MEMBISTGO          = 0x1c0,
+        SYS_MEMSTAT            = 0x200
+};
+
+//Device -6 , function - 2
+enum dev_sys {
+        PLL_CLKCTRL             = 0x41,
+        CLK_CHOPCTRL            = 0x45,
+        CPU_CLKCHOPEN           = 0x46,
+        SOC_CLKCHOPEN           = 0x47,
+        CPU_PLLCTRL_0_0         = 0x140,
+        CPU_PLLCTRL_1_0         = 0x141,
+        CPU_PLLCTRL_2_0         = 0x142,
+        CPU_PLLCTRL_3_0         = 0x143,
+
+        SYS_PLLCTRL_0           = 0x184,
+        SYS_PLLCTRL_1           = 0x185,
+        SYS_PLLCTRL_2           = 0x186,
+        SYS_PLLCTRL_3           = 0x187,
+
+        DEV_PLLCTRL_0           = 0x188,
+        DEV_PLLCTRL_1           = 0x189,
+        DEV_PLLCTRL_2           = 0x18a,
+        DEV_PLLCTRL_3           = 0x18b,
+
+        CPU_PLLCHG_CTRL         = 0x1c8,
+        SYS_PLLCHG_CTRL         = 0x1c9,
+        CLK_DEVDIS              = 0x1ca,
+        CLK_DEVSEL              = 0x1cb,
+        CLK_DEVDIV              = 0x1cd,
+        CLK_DEVCHG              = 0x1cf,
+
+	CLK_DEVSEL_STAT		= 0x1e4,
+	CLK_DEVDIV_STAT		= 0x1e6,
+};
+
+enum dev_clk{
+        XLP9XX_CLKDEV_PIC = 0,
+        XLP9XX_CLKDEV_GDX = 1,
+        XLP9XX_CLKDEV_CMP = 2,
+        XLP9XX_CLKDEV_REGXF = 3,
+        XLP9XX_CLKDEV_REGXS = 4,
+        XLP9XX_CLKDEV_SEC = 5,
+        XLP9XX_CLKDEV_RSA = 6,
+        XLP9XX_CLKDEV_NET = 7,
+        XLP9XX_CLKDEV_SATA = 8,
+        XLP9XX_CLKDEV_KBP = 9,
+        XLP9XX_CLKDEV_USB = 10,
+        XLP9XX_CLKDEV_GIO = 11,
+        XLP9XX_CLKDEV_GBU = 12,
+        XLP9XX_CLKDEV_MMC = 13,
+        XLP9XX_CLKDEV_NAND = 14,
+        XLP9XX_CLKDEV_LZS = 15,
+};
+
+#endif //__ASSEMBLY__
+
+#define SYS_BUS		1
+#define SYS_DEV		6
+#define SYS_FUNC_CLKDEV	2
+
+#define SYS_CLKDEV_BASE(node)   (0x18000000 + (SYS_BUS << 20) + (((node * XLP_MAXDEV_PERNODE) + SYS_DEV) << 15) + (SYS_FUNC_CLKDEV << 12))
+
+#define syssoc_write_reg(base, reg, val)	nlm_hal_write_32bit_reg(base, reg, val)
+#define syssoc_read_reg(base, reg)		nlm_hal_read_32bit_reg(base, reg)
+
+/* 
+    Following are the selections for clock source selector
+    0 - 133 MHz (Ref clock)
+    1 - 500 MHz (Dev 0 PLL clock)
+    2 - 667 MHz (Dev 1 PLL clock)
+    3 - 767 MHz (Dev 2 PLL clock)
+
+    Following are the selections for clock divide selector
+    0 - divide by 1
+    1 - divide by 2
+    2 - divide by 4
+    3 - divide by 8
+*/
+
+static inline uint64_t get_nae_frequency(int node) 
+{
+    uint32_t sel, div, pll_out, dev_shift = XLP9XX_CLKDEV_NET * 2;
+    uint32_t clk_freq;
+    uint64_t sys_base = SYS_CLKDEV_BASE(node); 
+
+    sel = (syssoc_read_reg(sys_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+    div = (syssoc_read_reg(sys_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+
+    switch (sel) {
+        case 0: pll_out = 133; break;
+        case 1: pll_out = 500; break;
+        case 2: pll_out = 667; break;
+        case 3: pll_out = 767; break;
+    }
+
+    switch (div) {
+        case 0: clk_freq = pll_out; break;
+        case 1: clk_freq = pll_out/2; break;
+        case 2: clk_freq = pll_out/4; break;
+        case 3: clk_freq = pll_out/8; break;
+    }
+
+    nlm_print("sel:%d div:%d NET_FREQUENCY :%d MHz\n", sel, div, clk_freq);
+    return (uint64_t) (clk_freq * 1000000);
+}
+
+
+static inline int set_nae_frequency(int node, uint64_t freq)
+{
+    int sel, div, dev_shift, i;
+    const uint64_t mhz = 1000000;
+    int dev_freq = freq / mhz;
+    uint32_t val, dev_id = XLP9XX_CLKDEV_NET;
+    uint64_t sys_base = SYS_CLKDEV_BASE(node);
+
+    nlm_print("NAE frequency %lld MHz\n",get_nae_frequency(node) / mhz);
+		
+    if (freq == get_nae_frequency(node))
+	return 0;	
+    switch (dev_freq) {
+        case 133: sel = 0; div = 0; break;
+        case 66:  sel = 0; div = 1; break;
+        case 33:  sel = 0; div = 2; break;
+        case 17:  sel = 0; div = 3; break;
+        case 500: sel = 1; div = 0; break;
+        case 250: sel = 1; div = 1; break;
+        case 125: sel = 1; div = 2; break;
+        case 63:  sel = 1; div = 3; break;
+        case 667: sel = 2; div = 0; break;
+        case 333: sel = 2; div = 1; break;
+        case 167: sel = 2; div = 2; break;
+        case 83:  sel = 2; div = 3; break;
+        case 767: sel = 3; div = 0; break;
+        case 383: sel = 3; div = 1; break;
+        case 192: sel = 3; div = 2; break;
+        case 96:  sel = 3; div = 3; break;
+        default: // Set it to 333 MHz
+            nlm_print("Can't set freq to given MHz. Setting NAE Freq to 667 MHz instead.\n");
+            sel = 2; div = 0;
+        break;
+    }
+
+    dev_shift = dev_id * 2;	
+    // Write the div and select register	
+    val = ((sel & 0x3) << dev_shift);
+    syssoc_write_reg(sys_base, CLK_DEVSEL, val);
+	
+    val = ((div & 0x3) << dev_shift);  
+    syssoc_write_reg(sys_base, CLK_DEVDIV, val);
+	
+    // Poll Change register
+    syssoc_write_reg(sys_base, CLK_DEVCHG, 0x1 << dev_id);
+
+    i=0;
+    while (i++ < 10) {
+      val = syssoc_read_reg(sys_base, CLK_DEVCHG);
+
+      if ((i==10) || ((val & (1 << dev_id)) == 0)) {
+          // Check the status
+	  val = (syssoc_read_reg(sys_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+          if (val != sel) {
+              nlm_print("NET CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVSEL_STAT), sel, val);
+          }
+          val = (syssoc_read_reg(sys_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+          if (val != div) {
+              nlm_print("NET CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVDIV_STAT), div, val);
+          }
+          break;
+      }
+    }
+
+    nlm_print("NAE frequency changed to %lld MHz\n",get_nae_frequency(node) / mhz);
+    return 0;
+}
+
+static inline uint64_t get_crypto_block_frequency(int node, int dev_id)
+{
+    uint32_t sel, div, pll_out, dev_shift;
+    uint32_t clk_freq;
+    uint64_t sys_base = SYS_CLKDEV_BASE(node);
+
+    if (dev_id == XLP9XX_CLKDEV_SEC) 
+        dev_shift = XLP9XX_CLKDEV_SEC * 2;
+    else 
+        dev_shift = XLP9XX_CLKDEV_RSA * 2;
+
+    sel = (syssoc_read_reg(sys_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+    div = (syssoc_read_reg(sys_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+
+    switch (sel) {
+        case 0: pll_out = 133; break;
+        case 1: pll_out = 500; break;
+        case 2: pll_out = 667; break;
+        case 3: pll_out = 767; break;
+    }
+
+    switch (div) {
+        case 0: clk_freq = pll_out; break;
+        case 1: clk_freq = pll_out/2; break;
+        case 2: clk_freq = pll_out/4; break;
+        case 3: clk_freq = pll_out/8; break;
+    }
+
+    nlm_print("sel:%d div:%d %s_FREQUENCY :%d MHz\n", sel, div, 
+               dev_id == XLP9XX_CLKDEV_SEC? "SAE":"RSA", clk_freq);
+    return (uint64_t) (clk_freq * 1000000);
+}
+
+static inline int set_crypto_block_frequency(int node, int dev_id, uint64_t freq)
+{
+    int sel, div, dev_shift, i;
+    const uint64_t mhz = 1000000;
+    int dev_freq = freq / mhz;
+    uint32_t val;
+    uint64_t sys_base = SYS_CLKDEV_BASE(node);
+    char* block_name;
+
+    if (dev_id == XLP9XX_CLKDEV_SEC)
+        block_name = "SAE";
+    else
+        block_name = "RSA";
+
+    nlm_print("%s frequency %lld MHz\n", block_name,  
+              get_crypto_block_frequency(node, dev_id) / mhz);
+
+    if (freq == get_crypto_block_frequency(node, dev_id))
+        return 0;
+    switch (dev_freq) {
+        case 133: sel = 0; div = 0; break;
+        case 500: sel = 1; div = 0; break;
+        case 250: sel = 1; div = 1; break;
+        case 125: sel = 1; div = 2; break;
+        case 667: sel = 2; div = 0; break;
+        case 767: sel = 3; div = 0; break;
+        default: // Set it to 333 MHz
+            nlm_print("Can't set freq to given MHz. Setting Freq to 667 MHz instead.\n");
+            sel = 2; div = 0;
+        break;
+    }
+    dev_shift = dev_id * 2;
+    // Write the div and select register
+    val = ((sel & 0x3) << dev_shift);
+    syssoc_write_reg(sys_base, CLK_DEVSEL, val);
+
+    val = ((div & 0x3) << dev_shift);
+    syssoc_write_reg(sys_base, CLK_DEVDIV, val);
+
+    // Poll Change register
+    syssoc_write_reg(sys_base, CLK_DEVCHG, 0x1 << dev_id);
+
+    i=0;
+    while (i++ < 10) {
+      val = syssoc_read_reg(sys_base, CLK_DEVCHG);
+
+      if ((i==10) || ((val & (1 << dev_id)) == 0)) {
+          // Check the status
+          val = (syssoc_read_reg(sys_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+          if (val != sel) {
+              nlm_print(" %s CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n",
+                          block_name, syssoc_read_reg(sys_base, CLK_DEVSEL_STAT), sel, val);
+          }
+          val = (syssoc_read_reg(sys_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+          if (val != div) {
+              nlm_print("%s CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n",
+                         block_name, syssoc_read_reg(sys_base, CLK_DEVDIV_STAT), div, val);
+          }
+          break;
+      }
+    }
+
+    nlm_print("%s frequency changed to %lld MHz\n",block_name, 
+              get_crypto_block_frequency(node, dev_id) / mhz);
+    return 0;
+}
+
+
+static inline int set_soc_frequency(int node, int dev_id, uint64_t freq)
+{
+
+	switch(dev_id) {
+		case XLP9XX_CLKDEV_NET:
+			set_nae_frequency(node, freq);
+			break;
+                case XLP9XX_CLKDEV_SEC:
+		case XLP9XX_CLKDEV_RSA:
+                        set_crypto_block_frequency(node, dev_id, freq);
+                        break;
+		default:
+			nlm_print("%s error\n",__func__);
+			break;
+	}
+        return 0;
+}
+
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/src/brcm_xlp_cpu.c b/arch/mips/netlogic/lib/syslib/src/brcm_xlp_cpu.c
new file mode 100644
index 0000000..c023ad2
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/src/brcm_xlp_cpu.c
@@ -0,0 +1,92 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#include <brcm_xlp_cpu.h>
+#include <nlm_hal_xlp_dev.h>
+
+/**
+ * @brief brcm_get_max_cpu_num - return the total number of cpus on a chip
+ *
+ * @param [in]	- none
+ *
+ * @return
+ * 	  - total number of cpus on a chip
+ *
+ * @see brcm_get_relative_cpu_num
+ **/
+
+inline int brcm_get_max_cpu_num(void)
+{
+	int max_cpu = 0;
+
+	if (is_nlm_xlp9xx()) {
+		max_cpu = XLP9XX_MAX_CPU_PER_NODE;
+	} else if (is_nlm_xlp8xx()) {
+		max_cpu = NLM_NCPUS_PER_NODE;
+	} else if (is_nlm_xlp3xx()) {
+		max_cpu = XLP3XX_MAX_CPU_PER_NODE;
+	} else if (is_nlm_xlp2xx()) {
+		max_cpu = XLP2XX_MAX_CPU_PER_NODE;
+	} else {
+		max_cpu = NLM_NCPUS_PER_NODE;
+	}
+	return max_cpu;
+}
+
+/**
+ * @brief brcm_get_max_node_num - return the total number of nodes
+ *
+ * @param [in]	- none
+ *
+ * @return
+ * 	  - total number of nodes on a chip
+ *
+ * @see brcm_get_node_num
+ **/
+
+inline int brcm_get_max_node_num(void)
+{
+	int max_node = 0;
+	
+	if (is_nlm_xlp9xx()) {
+		max_node = XLP9XX_MAX_NODES;
+	} else if (is_nlm_xlp8xx()) {
+		max_node = NLM_MAX_NODES;
+	} else {
+		max_node = DEFAULT_NODE_NUM;
+	}
+	return max_node;
+}
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_eeprom.c b/arch/mips/netlogic/lib/syslib/src/nlm_eeprom.c
new file mode 100644
index 0000000..6e71f41
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_eeprom.c
@@ -0,0 +1,123 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#endif
+#include "nlm_eeprom.h"
+
+
+int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
+{
+	unsigned char *eeprom_mac;
+	unsigned int offset;
+	unsigned char dev_addr;
+
+	if(nlm_eeprom==NULL){
+		return -1;
+	}
+
+	dev_addr = nlm_eeprom->i2c_dev_addr;
+	eeprom_mac = interface?(nlm_eeprom->mac_addr1):(nlm_eeprom->mac_addr0);
+
+	offset= (unsigned int) (interface?(unsigned long)(((struct eeprom_data*)0)->mac_addr1):(unsigned long)(((struct eeprom_data*)0)->mac_addr0));
+	nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0, eeprom_mac, MAC_LEN);
+	memcpy(mac, eeprom_mac, MAC_LEN);
+	return 0;
+}
+
+int  eeprom_set_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
+{
+	unsigned char *eeprom_mac;
+	unsigned char dev_addr,i;
+	unsigned int offset;
+	if(nlm_eeprom==NULL){
+		return -1;
+	}
+	dev_addr = nlm_eeprom->i2c_dev_addr;
+
+	eeprom_mac = interface?(nlm_eeprom->mac_addr1):(nlm_eeprom->mac_addr0);
+	for(i=0;i<6;i++){
+                eeprom_mac[i]= mac[i];
+        }
+	offset= (unsigned int)(interface?(unsigned long)(((struct eeprom_data*)0)->mac_addr1):(unsigned long)(((struct eeprom_data*)0)->mac_addr0));
+	nlm_eeprom->eeprom_i2c_write_bytes(dev_addr, offset,0, eeprom_mac, MAC_LEN);
+	return 0;
+}
+int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
+{
+        unsigned char *eeprom_mac;
+        unsigned int offset;
+        unsigned char dev_addr;
+
+        if(nlm_eeprom==NULL){
+                return -1;
+        }
+
+        dev_addr = nlm_eeprom->i2c_dev_addr;
+        eeprom_mac = interface?(nlm_eeprom->magic_bytes1):(nlm_eeprom->magic_bytes0);
+
+        offset= (unsigned int)(interface?(unsigned long)(((struct eeprom_data*)0)->magic_bytes1):(unsigned long)(((struct eeprom_data*)0)->magic_bytes0));
+        nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0, eeprom_mac, MAGIC_LEN);
+        memcpy(mac, eeprom_mac, MAGIC_LEN);
+        return 0;
+}
+int  eeprom_dump(struct eeprom_data *nlm_eeprom, unsigned char *mac, int offset, int len)
+{
+
+        unsigned char dev_addr;
+
+        if(nlm_eeprom==NULL){
+                return -1;
+        }
+
+        dev_addr   = nlm_eeprom->i2c_dev_addr;
+
+        nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0,mac,len);
+        return 0;
+}
+
+
+#ifdef NLM_HAL_LINUX_KERNEL
+/*Add  API here if any API  from above is needed*/
+EXPORT_SYMBOL(eeprom_get_mac_addr);
+EXPORT_SYMBOL(eeprom_set_mac_addr);
+EXPORT_SYMBOL(eeprom_get_magic_bytes);
+EXPORT_SYMBOL(eeprom_dump);
+#endif
+
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_evp_cpld.c b/arch/mips/netlogic/lib/syslib/src/nlm_evp_cpld.c
new file mode 100644
index 0000000..26a6877
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_evp_cpld.c
@@ -0,0 +1,248 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#else
+#include <byteorder.h>
+#endif
+#include "nlm_evp_cpld.h"
+#include "nlm_hal_sys.h"
+
+
+static nlm_xlp_nor_t xlp_nor_dev[8] = {
+{ 0x16000000, SIZE_16MB, 0, 0x2e00 },
+{ 0xffffffff, 0, 0, 0 },
+{ 0x17000000, SIZE_1MB , 1, 0x2C00 },
+{ 0x17200000, SIZE_1MB , 0, 0x2C00 },
+{ 0x17300000, SIZE_1MB , 0, 0x2f84 },
+{ 0xffffffff, 0, 0, 0 },
+{ 0xffffffff, 0, 0, 0 },
+{ 0xffffffff, 0, 0, 0 },
+};
+
+static inline uint32_t nlm_hal_nor_read(uint32_t reg)
+{
+        return nlm_hal_read_32bit_reg(NLM_NOR_CFG_BASE, reg);
+}
+
+static inline void nlm_hal_nor_write(uint32_t reg, uint32_t val)
+{
+        nlm_hal_write_32bit_reg(NLM_NOR_CFG_BASE, reg, val);
+}
+
+uint16_t nlm_hal_cpld_read_16(int cs, uint16_t reg)
+{
+#ifndef CONFIG_N511
+        uint16_t val;
+	if ((cs == 3) || (cs ==4))
+	        nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , 0x2f84);
+	
+	val = nlm_hal_read_16bit_reg(xlp_nor_dev[cs].base, reg);
+        return (xlp_nor_dev[cs].swap ? le16_to_cpu(val): be16_to_cpu(val));
+#else
+	return 0;
+#endif
+}
+
+void nlm_hal_cpld_write_16(int cs, uint16_t val, uint16_t reg)
+{
+#ifndef CONFIG_N511
+        uint16_t data = xlp_nor_dev[cs].swap ? cpu_to_le16(val): cpu_to_be16(val);
+	if ((cs == 3) || (cs ==4))
+	        nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , 0x2d84);
+
+        nlm_hal_write_16bit_reg(xlp_nor_dev[cs].base, reg, data);
+#else
+#endif
+}
+
+int nlm_xlp_boardver(void)
+{
+	uint16_t data = nlm_hal_cpld_read_16(2, 5);
+	return ((EVP_VER(data) >> 3) + 1);
+}
+
+int nlm_xlp_cpldver(void)
+{
+	return nlm_hal_cpld_read_16(2, 0);
+}
+
+int is_xlp_evp1(void)
+{
+#ifndef CONFIG_N511
+        uint16_t data = nlm_hal_cpld_read_16(2, 5);
+
+        if (EVP_VER(data) == 0)
+                return 1;
+        else
+#endif
+                return 0;
+}
+
+int is_xlp_evp2(void)
+{
+#ifndef CONFIG_N511
+        uint16_t data = nlm_hal_cpld_read_16(2, 5);
+
+        if (EVP_VER(data))
+                return 1;
+        else
+#endif
+                return 0;
+}
+
+int is_ilk_card_onslot(int slot)
+{
+	uint16_t data = nlm_hal_cpld_read_16(2, 6);
+
+	slot >>= 1;
+
+	if (DC_TYPE(data, slot) == DC_ILK) 
+		return 1;
+	else
+		return 0;
+}
+
+#if defined(NLM_HAL_LINUX_USER) || defined(NLM_HAL_LINUX_KERNEL)
+/* cop0 hwren register should be set */
+static inline int my_cpu_id(void)
+{
+	unsigned int cpu = 0;
+
+	__asm__ volatile (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"rdhwr %0, $0\n"
+			".set pop\n"
+			: "=r" (cpu)
+			:);
+
+	return cpu;
+}
+#endif
+
+int nlm_get_interface_type(int node, int slot)
+{
+	uint16_t data;
+       
+	/* there is no cpld in the existing multi node board for node 1-3 */
+#if defined(NLM_HAL_LINUX_USER) || defined(NLM_HAL_LINUX_KERNEL)
+	if(my_cpu_id() >= 32)
+		return DC_NOT_PRSNT;
+#endif
+	
+	data = nlm_hal_cpld_read_16(2, 6);
+	nlm_print("Slot present status 0x%x\n", (data & 0xFF));
+        if (slot == 4)
+                return DC_SGMII;
+
+        if (nlm_xlp_cpldver() == 0)
+                return DC_NOT_PRSNT;
+
+#ifdef SKIP_INTERFACE_TYPE_FROMCPLD
+	return DC_NOT_PRSNT;
+#else
+	if (slot == 2)
+		slot >>= 1;
+	else if (slot == 1)
+		slot <<= 1;
+	return DC_TYPE(data, slot);
+#endif
+}
+
+int xlp_cpld_init(uint32_t cs)
+{
+	unsigned long base = xlp_nor_dev[cs].base;
+	unsigned long limit = base + xlp_nor_dev[cs].size - 1;
+
+	if (cs > NLM_XLP_MAX_CS)
+		return -1;
+
+	nlm_hal_nor_write(XLP_NOR_CS_BASE + cs , (base >> 8));
+	nlm_hal_nor_write(XLP_NOR_CS_LIMIT + cs , (limit >> 8));
+
+	nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , xlp_nor_dev[cs].devparam); 
+
+	nlm_hal_nor_write(XLP_NOR_DEV_TIME0 + (cs * 2), 0x4F646EC2 );
+	nlm_hal_nor_write(XLP_NOR_DEV_TIME1 + (cs * 2), 0x8CF3);
+
+	return 0;
+}
+
+void set_gbu_frequency(int node, int frequency)
+{
+	const uint64_t mhz = 1000000;
+	uint64_t set_freq;
+	if(is_nlm_xlp2xx()) {
+		set_freq = nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_GBU, frequency * mhz);
+	}
+	else {
+		set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_NOR, frequency * mhz);
+	}
+	NLM_HAL_DO_DIV(set_freq,mhz);
+	nlm_print("GBU Frequency set to %lluMHz\n", set_freq);
+}
+
+void nlm_hal_cpld_init(int node)
+{
+#if !defined(XLP_SIM) || defined(NLM_BOARD)
+	int i;
+#if defined(NLM_CORTINA_SUPPORT)
+	set_gbu_frequency(node, NLM_GBU_FREQ_ILK);
+#else
+	set_gbu_frequency(node, NLM_GBU_FREQ_DEFAULT);
+#endif
+	for(i=2; i<5; i++)
+        	xlp_cpld_init(i);
+#endif
+}
+
+#ifdef NLM_HAL_LINUX_KERNEL
+EXPORT_SYMBOL(nlm_hal_cpld_init);
+EXPORT_SYMBOL(nlm_get_interface_type);
+EXPORT_SYMBOL(is_xlp_evp1);
+EXPORT_SYMBOL(is_xlp_evp2);
+EXPORT_SYMBOL(nlm_xlp_boardver);
+EXPORT_SYMBOL(is_ilk_card_onslot);
+EXPORT_SYMBOL(nlm_xlp_cpldver);
+EXPORT_SYMBOL(nlm_hal_cpld_read_16);
+EXPORT_SYMBOL(nlm_hal_cpld_write_16);
+#endif
+
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
new file mode 100644
index 0000000..43cfbc5
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -0,0 +1,1312 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+
+/**
+* @defgroup hal Hardware Abstraction Layer APIs
+* @brief This section describes the generic and miscellaneous HAL APIs. <br>
+*
+* <b>Source:</b> libraries/hal/nlm_hal.c <br>
+* @ingroup hal_overview
+*/
+
+/**
+* @defgroup hal_nae NAE Hardware Abstraction Layer APIs
+* @brief This section describes the NAE(Network Acceleration Engine) HAL APIs.<br>
+*
+* <b>Source:</b> libraries/hal/nlm_hal.c <br>
+* <b>Header:</b> hyperexec/srcs/drivers/hal/nlm_hal.h
+*/
+
+/**
+* @defgroup hal_sae SAE Hardware Abstraction Layer APIs
+* @brief This section describes the SAE(Security Acceleration Engine) HAL APIs <br>
+*
+* <b>Source:</b> libraries/hal/nlm_hal.c <br>
+* <b>Header:</b> hyperexec/srcs/drivers/hal/nlm_hal_sae.h
+*/
+
+#include "nlm_hal.h"
+#include "nlm_hal_crypto.h"
+#include "nlm_hal_xlp_dev.h"
+#include "nlm_hal_sys.h"
+#include "libfdt.h"
+#include "fdt_helper.h"
+#include "xlp9xx_sys.h"
+
+/* These addresses are computed by the nlm_hal_init() */
+unsigned long xlp_io_base;
+unsigned long xlp_fmn_base[NLM_MAX_NODES];
+unsigned long xlp_nae_base[NLM_MAX_NODES];
+unsigned long xlp_sae_base[NLM_MAX_NODES];
+unsigned long xlp_rsa_base[NLM_MAX_NODES];
+unsigned long xlp_mac_base[NLM_MAX_NODES];
+unsigned long xlp_poe_base_pcie[NLM_MAX_NODES];
+unsigned long xlp_poe_base_pcim[NLM_MAX_NODES];
+unsigned long xlp_sys_base[NLM_MAX_NODES];
+unsigned long xlp_regex_base_pcie;
+unsigned long xlp_regex_base_pcim;
+
+struct nlm_node_config  nlm_node_cfg;
+
+
+static __inline__ unsigned int power_on_reset_cfg(void)
+{
+	return nlh_read_cfg_reg32(0x18035104);
+}
+
+#define PCIE_CONTROL_0 0x240
+
+/**
+* @brief nlm_hal_xlp_pcie_rc_init function is used to initialize the XLP PCIE controllers configured in RC mode.
+*
+* @return
+*  - Returns no value.
+*
+* @ingroup hal
+*
+*/
+__inline__ void nlm_hal_xlp_pcie_rc_init(void)
+{
+	int num_pcie = 4; /* Number of PCIe controllers */
+	unsigned long base = 0x18000000;
+	int dev = 1;
+	int pcie = 0;
+
+	unsigned int pciemode = (power_on_reset_cfg() >> 19) & 0xf;
+
+	for (pcie = 0; pcie < num_pcie; pcie++) {
+		unsigned long addr;
+		unsigned int val;
+
+		if (!(pciemode & (1 << pcie)))
+			continue;
+
+		addr = base + (dev << 15) + (pcie << 12);
+
+		val = nlm_hal_read_32bit_reg(addr, PCIE_CONTROL_0);
+		val |= (1 << 21); /* BAR mask enable */
+		nlm_hal_write_32bit_reg(addr, PCIE_CONTROL_0, val);
+
+		nlm_hal_write_32bit_reg(addr, PCI_MEM_BAR_0, 0x0);
+	}
+}
+
+/* PCI Enumeration */
+__inline__ void nlm_hal_enumerate_pci(void)
+{
+}
+
+#ifndef NLM_HAL_XLOADER
+/* Basic Reg access
+ */
+
+/**
+* @brief nlm_hal_read_16bit_reg function is used to read 16-bit registers (e.g. CPLD)
+*
+* @param [in] base Physical address where the register space starts
+* @param [in] index Register Index
+*
+* @return
+*  - 16bit register value
+*
+* @sa nlm_hal_write_16bit_reg, nlm_hal_read_32bit_reg, nlm_hal_write_32bit_reg, nlm_hal_read_64bit_reg, nlm_hal_write_64bit_reg??
+* @ingroup hal
+*
+*/
+__inline__ uint16_t nlm_hal_read_16bit_reg(uint64_t base, uint32_t index){
+    return nlh_read_cfg_reg16(base + (index << 1));
+}
+/**
+* @brief nlm_hal_write_16bit_reg function is used to write 16-bit registers (e.g. CPLD)
+*
+* @param [in] base Physical address where the register space starts
+* @param [in] index Register Index
+* @param [in] val Register value
+*
+* @return
+*  - none
+*
+* @sa nlm_hal_read_16bit_reg, nlm_hal_read_32bit_reg, nlm_hal_write_32bit_reg, nlm_hal_read_64bit_reg, nlm_hal_write_64bit_reg??
+* @ingroup hal
+*
+*/
+__inline__ void nlm_hal_write_16bit_reg(uint64_t base, uint32_t index, uint16_t val){
+    nlh_write_cfg_reg16(base +  (index << 1) , val);
+}
+
+/**
+* @brief nlm_hal_read_32bit_reg function is used to read 32bit registers
+*
+* @param [in] base Physical address where the register space starts
+* @param [in] index Register Index
+*
+* @return
+*  - 32bit register value
+*
+* @sa nlm_hal_write_32bit_reg, nlm_hal_read_64bit_reg, nlm_hal_write_64bit_reg
+* @ingroup hal
+*
+*/
+__inline__ uint32_t nlm_hal_read_32bit_reg(uint64_t base, int index)
+{
+	return nlh_read_cfg_reg32(base + (index << 2));
+}
+
+/**
+* @brief nlm_hal_write_32bit_reg function is used to write 32bit registers
+*
+* @param [in] base Physical address where the register space starts
+* @param [in] index Register Index
+* @param [in] val Register value
+*
+* @return
+*  - none
+*
+* @sa nlm_hal_read_32bit_reg, nlm_hal_read_64bit_reg, nlm_hal_write_64bit_reg
+* @ingroup hal
+*
+*/
+__inline__ void nlm_hal_write_32bit_reg(uint64_t base, int index, uint32_t val)
+{
+	nlh_write_cfg_reg32(base +  (index << 2) , val);
+}
+
+/**
+* @brief nlm_hal_read_64bit_reg function is used to read 64bit registers
+*
+* @param [in] base Physical address where the register space starts
+* @param [in] index Register Index
+*
+* @return
+*  - 64bit register value
+*
+* @sa nlm_hal_write_32bit_reg, nlm_hal_read_32bit_reg, nlm_hal_write_64bit_reg
+* @ingroup hal
+*
+*/
+__inline__ uint64_t nlm_hal_read_64bit_reg(uint64_t base, int index)
+{
+	return nlh_read_cfg_reg64(base + (index << 3));
+}
+/**
+* @brief nlm_hal_read_64bit_reg function is used to write 64bit registers
+*
+* @param [in] base Physical address where the register space starts
+* @param [in] index Register Index
+* @param [in] val Register value
+*
+* @return
+*  - none
+*
+* @sa nlm_hal_write_32bit_reg, nlm_hal_read_32bit_reg, nlm_hal_read_64bit_reg
+* @ingroup hal
+*
+*/
+__inline__ void nlm_hal_write_64bit_reg(uint64_t base, int index, uint64_t val)
+{
+	nlh_write_cfg_reg64(base +  (index << 3) , val);
+}
+#endif /*NLM_HAL_XLOADER*/
+/*
+ *    Generic Devices
+ */
+/**
+* @brief nlm_hal_get_dev_base function is used to get device base address
+*
+* @param [in] node Node ID
+* @param [in] bus Bus ID
+* @param [in] dev Device ID
+* @param [in] func Function ID
+*
+* @return
+*  - Physical address of the base address for a given (node, bus, device, function) combination
+*
+* @ingroup hal
+*
+*/
+__inline__ uint64_t nlm_hal_get_dev_base(int node, int bus, int dev, int func)
+{
+	uint64_t base = xlp_io_base & 0x1fffffff;
+
+	return (uint64_t)  (base +
+			    (bus << 20) +
+			    (dev << 15) +
+			    (node*8 << 15) +
+			    (func << 12));
+}
+
+__inline__ int nlm_hal_is_xlp_a0(void)
+{
+	/* XXX: read register to determine stepping */
+	return 1;
+}
+
+__inline__ int nlm_hal_is_xlp_le(void)
+{
+	unsigned int pwronrst = power_on_reset_cfg();
+	int little_endian = ((pwronrst & (1 << 5)) == 0);
+	return little_endian;
+}
+
+/*
+ * @brief nlm_hal_get_fdt_freq function is used to read the frequency specified in the fdt file.
+ *
+ * @param [in]  pointer to the fdt file
+ * @param [in]  block for whych we need the frequency.
+ *
+ * @return
+ * actual frequency on success & "-1" if the frency is not specified in fdt file.
+ *
+ * @ingroup hal
+ *
+ **/
+int nlm_hal_get_fdt_freq(void *fdt, int type)
+{
+	int freq;
+	int ret = 250;  /* Set the default frequency to 250 */
+	char path_str[50];
+
+	sprintf(path_str,"/frequency-config");
+
+	switch(type)
+	{
+	case NLM_NAE:
+		if(copy_fdt_prop(fdt, path_str, "nae", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("nae frequency is %d\n", ret);
+#endif
+		break;
+	case NLM_RSA:
+		if(copy_fdt_prop(fdt, path_str, "rsa", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("rsa frequency is %d\n", ret);
+#endif
+		break;
+	case NLM_SAE:
+		if(copy_fdt_prop(fdt, path_str, "sae", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("sae frequency is %d\n", ret);
+#endif
+		break;
+	case NLM_DTRE:
+		if(copy_fdt_prop(fdt, path_str, "dtre", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("sae frequency is %d\n", ret);
+#endif
+		break;
+	case NLM_CDE:
+		if(copy_fdt_prop(fdt, path_str, "cde", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("sae frequency is %d\n", ret);
+#endif
+		break;
+	default:
+		{
+			nlm_print("Frequency not specified in the FDT file for type:%d", type);
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
+/* Main initialization */
+/**
+* @brief nlm_hal_init function is used to Initialize HAL
+*
+* @return
+*  - Returns no value.
+*
+* @note
+*    This function must be the first to be called before any other HAL API's
+*
+* @ingroup hal
+*
+*/
+
+__inline__ void nlm_hal_init(void)
+{
+	unsigned long long mask = ~0xf;
+	int node = 0;
+#if !defined(NLM_HAL_LINUX_USER)
+	unsigned int flags = 0;
+	enable_KX(flags);
+#endif
+	nlm_hal_enumerate_pci();
+
+	nlm_node_cfg.valid = 1;
+	nlm_node_cfg.num_nodes = 1;
+
+ 	for(node = 0; node < NLM_MAX_NODES; node++)
+	{
+		//nlm_node_cfg.nae_cfg[node] = NULL;
+		nlm_node_cfg.nae_cfg[node] = NULL;
+		nlm_node_cfg.fmn_cfg[node] = NULL;
+
+		xlp_io_base = KSEG1 + 0x18000000;
+
+        	/* PCI enumeration of supported devices*/
+
+		if (is_nlm_xlp9xx()) {
+			xlp_mac_base[node] = (uint64_t)xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE(XLP_NAE));
+			xlp_fmn_base[node] = (uint64_t)xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE(XLP_FMN));
+			xlp_nae_base[node] = xlp_mac_base[node] + 0xe000;
+
+			xlp_poe_base_pcim[node] = (uint64_t)xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE(XLP_POE));
+			xlp_poe_base_pcie[node] = (xlp_io_base | XLP9XX_PCIE_DEV_BASE(XLP_POE)) & 0x1fffffff; /* For now . Will be fixed soon.*/
+			xlp_sys_base[node] = (xlp_io_base | (XLP9XX_SYS_BUS << 20) | XLP9XX_PCIE_DEV_BASE(XLP9XX_SYS)) & 0x1fffffff; /*For now . Will be fixed soon.*/
+
+			xlp_sae_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_SAE)) & 0x1fffffff; /*For now . Will be fixed soon.*/
+			xlp_rsa_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
+		} else
+		{
+			xlp_fmn_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_PCIE_DEV_BASE(node, XLP_FMN)), PCI_MEM_BAR_0);
+
+			xlp_mac_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_PCIE_DEV_BASE(node, XLP_NAE)), PCI_MEM_BAR_0); //0x18018000
+			xlp_nae_base[node] = xlp_mac_base[node] + 0xe000;
+
+			xlp_poe_base_pcie[node] = (xlp_io_base | XLP_PCIE_DEV_BASE(node, XLP_POE)) & 0x1fffffff; /* For now . Will be fixed soon.*/
+
+			xlp_poe_base_pcim[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_PCIE_DEV_BASE(node, XLP_POE)), PCI_MEM_BAR_0);	//0x18019000
+
+			xlp_sys_base[node] = (xlp_io_base | XLP_PCIE_DEV_BASE(node, XLP_SYS)) & 0x1fffffff; /*For now . Will be fixed soon.*/
+			xlp_sae_base[node] = (xlp_io_base | XLP_PCIE_DEV_BASE(node, XLP_SAE)) & 0x1fffffff; /* For now . Will be fixed soon.*/
+			xlp_rsa_base[node] = (xlp_io_base | XLP_PCIE_DEV_BASE(node, XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
+
+		}
+
+	}
+	if(!is_nlm_xlp9xx()){
+		if ( is_nlm_xlp3xx() || is_nlm_xlp2xx() ) {
+			xlp_regex_base_pcie = (xlp_io_base | (XLP_PCIE_DEV_BASE(0, XLP_3XX_REGEX))) & 0x1fffffff;
+			xlp_regex_base_pcim = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_PCIE_DEV_BASE(0, XLP_3XX_REGEX)), PCI_MEM_BAR_0);
+
+#ifdef DEBUG
+			nlm_print("xlp3xx/2xx Regex (netl7) vendor_device id:%#x\n"
+					"xlp_regex_base_pcim:%#lx\n"
+					"xlp_regex_base_pcie:%#lx\n",
+					nlm_hal_read_32bit_reg(xlp_regex_base_pcie, 0),
+					xlp_regex_base_pcim, xlp_regex_base_pcie);
+#endif
+		}
+	}
+
+
+#if !defined(NLM_HAL_UBOOT)
+#ifndef CONFIG_N511
+	nlm_hal_cpld_init(0);
+#endif
+#endif
+
+#if !defined(NLM_HAL_LINUX_USER) && (_MIPS_SZLONG == 64)
+	disable_KX(flags);
+#endif
+}
+
+
+/*
+ * Naming convention: NLM_HAL_XXX for external API
+ *                    NLH_XXX for internal naming of NL HAL
+ */
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/module.h>
+
+EXPORT_SYMBOL(xlp_io_base);
+EXPORT_SYMBOL(xlp_fmn_base);
+EXPORT_SYMBOL(xlp_nae_base);
+EXPORT_SYMBOL(xlp_mac_base);
+EXPORT_SYMBOL(xlp_sys_base);
+EXPORT_SYMBOL(xlp_sae_base);
+EXPORT_SYMBOL(xlp_rsa_base);
+EXPORT_SYMBOL(xlp_poe_base_pcie);
+EXPORT_SYMBOL(xlp_poe_base_pcim);
+
+EXPORT_SYMBOL(nlm_hal_init);
+EXPORT_SYMBOL(nlm_hal_read_32bit_reg);
+EXPORT_SYMBOL(nlm_hal_write_32bit_reg);
+#else
+#include "nlm_hal_pic.h"
+/*
+   This is to map 160 irt entry to 64 interrupt vector
+   Each row has three elements
+   irq		shared     number of sharing
+   irq:  assigned irq number used in linux
+   shared:  0: this irq not shared,  1: this irq is shared
+   number of sharing:  if shared = 1,  this variable indicate number of irt line to shared the same irq
+   if shared = 0,  this should be 0.
+*/
+#define SHARED_IRQ	1
+#define NOT_SHARED	0
+
+int irt_irq_table[160][4]= {
+        {9,     1,      2,      0},     /*PICIRT_WD_0_INDEX         0	*/
+        {9,     1,      2,      0},     /*PICIRT_WD_1_INDEX         1	*/
+        {19,    1,      2,      0},     /*PICIRT_WD_NMI_0_INDEX     2	*/
+        {19,    1,      2,      0},     /*PICIRT_WD_NMI_1_INDEX     3	*/
+        {10,    1,      8,      0},     /*PICIRT_TIMER_0_INDEX      4	*/
+        {10,    1,      8,      0},     /*PICIRT_TIMER_1_INDEX      5	*/
+        {10,    1,      8,      0},     /*PICIRT_TIMER_2_INDEX      6	*/
+        {10,    1,      8,      0},     /*PICIRT_TIMER_3_INDEX      7	*/
+        {10,    1,      8,      0},     /*PICIRT_TIMER_4_INDEX      8	*/
+        {10,    1,      8,      0},     /*PICIRT_TIMER_5_INDEX      9	*/
+        {10,    1,      8,      0},     /*PICIRT_TIMER_6_INDEX      10	*/
+        {10,    1,      8,      0},     /*PICIRT_TIMER_7_INDEX      11	*/
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(0),    12	*/
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(1),    13  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(2),    14  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(3),    15  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(4),    16  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(5),    17  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(6),    18  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(7),    19  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(8),    20  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(9),    21  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(10),   22  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(11),   23  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(12),   24  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(13),   25  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(14),   26  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(15),   27  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(16),   28  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(17),   29  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(18),   30  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(19),   31  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(20),   32  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(21),   33  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(22),   34  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(23),   35  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(24),   36  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(25),   37  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(26),   38  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(27),   39  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(28),   40  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(29),   41  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(30),   42  */
+        {59,    1,      32,     0},     /*PICIRT_MSG_Q_INDEX(31),   43  */
+        {49,    0,      0,      0},     /*PICIRT_MSG_0_INDEX,       44	*/
+        {48,    0,      0,      0},     /*PICIRT_MSG_1_INDEX,       45	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(0) 46  */
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(1) 47  */
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(2) 48	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(3) 49	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(4) 50	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(5) 51	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(6) 52	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(7) 53	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(8) 54	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(9) 55	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(10)56 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(11)57 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(12)58	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(13)59 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(14)60 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(15)61 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(16)62 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(17)63	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(18)64 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(19)65 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(20)66 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(21)67 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(22)68 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(23)69 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(24)70 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(25)71 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(26)72 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(27)73 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(28)74 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(29)75 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(30)76 	*/
+        {46,    1,      32,     0},     /*PICIRT_PCIE_MSIX_INDEX(31)77 	*/
+        {44,    0,      0,      0},     /*PICIRT_PCIE_LINK_INDEX(0) 78	*/
+        {43,    0,      0,      0},     /*PICIRT_PCIE_LINK_INDEX(1) 79	*/
+        {42,    0,      0,      0},     /*PICIRT_PCIE_LINK_INDEX(2) 80	*/
+        {41,    0,      0,      0},     /*PICIRT_PCIE_LINK_INDEX(3) 81	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(0)        82	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(1)        83	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(2)        84	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(3)        85	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(4)        86	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(5)        87	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(6)        88	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(7)        89	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(8)        90	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(9)        91	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(10)       92	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(11)       93	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(12)       94	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(13)       95	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(14)       96	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(15)       97	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(16)       98	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(17)       99	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(18)       100	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(19)       101	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(20)       102 */
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(21)       103	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(22)       104	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(23)       105	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(24)       106	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(25)       107	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(26)       108	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(27)       109	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(28)       110	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(29)       111	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(30)       112	*/
+        {58,    1,      32,     0},     /*PICIRT_NA_INDEX(31)       113	*/
+        {60,    0,      0,      0},     /*PICIRT_POE_INDEX          114	*/
+        {24,    1,      6,      0},     /*PICIRT_USB_INDEX(0)       115	*/
+        {25,    1,      6,      0},     /*PICIRT_USB_INDEX(1)       116	*/
+        {25,    1,      6,      0},     /*PICIRT_USB_INDEX(2)       117	*/
+        {24,    1,      6,      0},     /*PICIRT_USB_INDEX(3)       118	*/
+        {25,    1,      6,      0},     /*PICIRT_USB_INDEX(4)       119	*/
+        {25,    1,      6,      0},     /*PICIRT_USB_INDEX(5)       120	*/
+        {61,    0,      0,      0},     /*PICIRT_GDX_INDEX          121 */
+        {63,    0,      0,      0},     /*PICIRT_SEC_INDEX          122 */
+        {62,    0,      0,      0},     /*PICIRT_RSA_INDEX          123 */
+        {39,    1,      4,      0},     /*PICIRT_COMP_INDEX(0)      124 */
+        {39,    1,      4,      0},     /*PICIRT_COMP_INDEX(1)      125 */
+        {39,    1,      4,      0},     /*PICIRT_COMP_INDEX(2)      126 */
+        {39,    1,      4,      0},     /*PICIRT_COMP_INDEX(3)      127 */
+        {0,     0,      0,      0},     /*                          128 */
+        {37,    1,      3,      0},     /*PICIRT_ICC_0_INDEX        129  ICC - Inter Chip Coherency*/
+        {37,    1,      3,      0},     /*PICIRT_ICC_1_INDEX        130 */
+        {37,    1,      3,      0},     /*PICIRT_ICC_2_INDEX        131 */
+        {36,    0,      0,      0},     /*PICIRT_CAM_INDEX          132 */
+        {17,    0,      0,      0},     /*PICIRT_UART_0_INDEX       133 */
+        {18,    0,      0,      0},     /*PICIRT_UART_1_INDEX       134 */
+        {11,    1,      2,      0},     /*PICIRT_I2C_0_INDEX        135	*/
+        {11,    1,      2,      0},     /*PICIRT_I2C_1_INDEX        136	*/
+        {12,    1,      2,      0},     /*PICIRT_SYS_0              137	*/
+        {12,    1,      2,      0},     /*PICIRT_SYS_1              138	*/
+        {55,    0,      0,      0},     /*PICIRT_JTAG_INDEX         139	*/
+        {50,    0,      0,      0},     /*PICIRT_PIC                140	*/
+        {0,     0,      0,      0},     /*Reserved                  141	*/
+        {0,     0,      0,      0},     /*Reserved                  142	*/
+        {0,     0,      0,      0},     /*Reserved                  143 */
+        {0,     0,      0,      0},     /*Reserved        	    144	*/
+        {0,     0,      0,      0},     /*Reserved        	    145	*/
+        {13,    0,      0,      0},     /*PICIRT_GPIO_INDEX(0)      146	*/
+        {14,    0,      0,      0},     /*PICIRT_GPIO_INDEX(1)      147	*/
+        {15,    0,      0,      0},     /*PICIRT_GPIO_INDEX(2)      148	*/
+        {16,    0,      0,      0},     /*PICIRT_GPIO_INDEX(3)      149	*/
+        {20,    0,      0,      0},     /*PICIRT_NOR                150	*/
+        {21,    0,      0,      0},     /*PICIRT_NAND               151	*/
+        {22,    0,      0,      0},     /*PICIRT_SPI                152	*/
+        {23,    0,      0,      0},     /*PICIRT_MMC                153	*/
+        {54,    0,      0,      0},     /*PICIRT_NBU		    154	*/
+        {53,    0,      0,      0},     /*PICIRT_TCU                155	*/
+        {52,    0,      0,      0},     /*PICIRT_GCU                156	*/
+        {36,    1,      2,      0},     /*DDR3 DMC                  157 */
+        {36,    1,      2,      0},     /*DDR3 DMC		    158 */
+        {57,    0,      0,      0},     /*Trace Buffer	TCB	    159 */
+};
+
+
+/*
+  short find_irt_from_irq( int irq)
+
+  find irt number from irq
+  irq: input irq number,
+  return:  irt number,  if it is -1, indicate can't find irt line for irq number.
+*/
+int find_irt_from_irq( int irq)
+{
+        unsigned long long irt_pending0, irt_pending1, irt_pending2;
+        int base_irt, num_shared = 0, i,j;
+        uint64_t val;
+        uint64_t shared_mask;
+
+        if(irq <0 || irq >63)
+        {
+                return -1;
+        }
+        if(irq < 8)
+                return irq;
+
+        /*from base irt_irq_table, find base irt number, for shared irq, need figure out which is the*/
+        for ( i = 0; i < PIC_NUM_IRTS; i++)
+        {
+                if(irq == irt_irq_table[i][0])
+                {
+                        /* unshared irq*/
+                        if(irt_irq_table[i][1] == NOT_SHARED)
+                        {
+                                /* this is irt number we needed;*/
+                                return  i;
+                        }
+                        else if(irt_irq_table[i][1] == SHARED_IRQ)
+                        {
+                                /*if shared bit is 1,  this irq is shared by a number of irt line*/
+                                num_shared = irt_irq_table[i][2];
+                                break;
+                        }
+                }
+
+        }
+        base_irt = i;
+        if(num_shared == NOT_SHARED || base_irt == 160)
+                return -1;
+        /* for shared irq, need figure out which irt line produce this irq*/
+        /* we can determine it by look at the interrupt pending register*/
+
+        /*first scan col 4 of enabled field to see whether any IRT is enabled,*/
+        /*it could be just first time to register*/
+        for(j = 0; j < num_shared; j++)
+        {
+		shared_mask = (1ULL << num_shared) - 1;
+                if( irt_irq_table[base_irt][0] != irt_irq_table[base_irt + j][0])
+                        continue;
+
+                if(irt_irq_table[base_irt + j][3] == 1)
+                {
+                        val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(base_irt + j));
+                        if(!(val & (1 << 31)))
+                        {
+                                /*this irt entry not enable yet*/
+                                return base_irt + j;
+
+                        }
+                        else
+                        {
+                                /*check pending register*/
+                                if(base_irt+j < 64)
+                                {
+                                        irt_pending0 = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_INT_PENDING0);
+                                        shared_mask  = shared_mask << base_irt;
+                                        irt_pending0 = irt_pending0 & shared_mask;
+                                        if(irt_pending0 & (1ULL << (base_irt + j)))
+                                                return (j + base_irt);
+                                }
+                                else if(base_irt + j >= 64 && base_irt + j < 128)
+                                {
+                                        irt_pending1 = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_INT_PENDING1);
+                                        shared_mask  = shared_mask << (base_irt - 64);
+                                        irt_pending1 = irt_pending1 & shared_mask;
+                                        if(irt_pending1 & (1ULL << (base_irt + j - 64)))
+                                                return (j + base_irt);
+
+                                }
+                                else if(base_irt+j > 128)
+                                {
+                                        irt_pending2 = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_INT_PENDING2);
+                                        shared_mask  = shared_mask << (base_irt - 128);
+                                        irt_pending2 = irt_pending2 & shared_mask;
+                                        if(irt_pending2 & (1ULL << (base_irt + j - 128)))
+                                                return (j + base_irt);
+                                }
+                        }
+                }
+        }
+
+        /*if we get here, means penging register is not set for all */
+        for(j = 0; j < num_shared ; j++)
+        {
+
+                if(irt_irq_table[base_irt+j][3] == 1)
+                        return (base_irt+j);
+        }
+        return -1;
+}
+
+
+int nlm_hal_request_shared_irq(int irt)
+{
+        uint64_t  val;
+
+        if(irt < 0 || irt > PIC_NUM_IRTS)
+                return -1;
+        irt_irq_table[irt][3] = 1;
+        val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt));
+        /* clear DB and DTE field */
+        val &= ~(0x3f << 20);
+        val |= (irt_irq_table[irt][0] << 20 | 1 << 31 | 1 << 28);
+        nlm_hal_write_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt),val);
+
+
+        return irt_irq_table[irt][0];
+}
+void nlm_hal_unrequest_shared_irq(int irt)
+{
+        if(irt < 0 || irt > PIC_NUM_IRTS)
+                return;
+        if(irt_irq_table[irt][3] == 1)
+                irt_irq_table[irt][3] = 0;
+        return;
+}
+
+
+unsigned long tlb_size_to_page_size(unsigned long size)
+{
+	if (size <= (4*1024)) return 4*1024;
+	if (size <= (16*1024)) return 16*1024;
+	if (size <= (64*1024)) return 64*1024;
+	if (size <= (256*1024)) return 256*1024;
+	if (size <= (1024*1024)) return 1024*1024;
+	if (size <= (4*1024*1024)) return 4*1024*1024;
+	if (size <= (16*1024*1024)) return 16*1024*1024;
+	if (size <= (64*1024*1024)) return 64*1024*1024;
+
+	return 256*1024*1024;
+}
+
+unsigned long tlb_size_to_mask(unsigned long size)
+{
+	if (size <= (4*1024)) return 0x0 << 13;
+	if (size <= (16*1024)) return 0x03 << 13;
+	if (size <= (64*1024)) return 0x0f << 13;
+	if (size <= (256*1024)) return 0x3f << 13;
+	if (size <= (1024*1024)) return 0xff << 13;
+	if (size <= (4*1024*1024)) return 0x3ff << 13;
+	if (size <= (16*1024*1024)) return 0xfff << 13;
+	if (size <= (64*1024*1024)) return 0x3fff << 13;
+
+	return 0xffff << 13;
+}
+#endif
+
+
+/* CDE SUPPORT
+ */
+/**
+* @brief nlm_hal_set_cde_freq function sets the frequency of the CDE block.
+*
+* @param [in] node Node number
+* @param [in] freq Frequency to set in MHz
+*
+* @return
+* 	- none
+*
+* @ingroup hal
+*
+*/
+void nlm_hal_set_cde_freq(int node, int freq)
+{
+	const uint64_t mhz = 1000000;
+	nlm_print("-- CDE Frequency set to %d\n", freq);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_CMP, freq * mhz);
+	}
+	else {
+		uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_CMP, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("CDE Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
+}
+
+/* DTRE SUPPORT
+ */
+/**
+* @brief nlm_hal_set_dtre_freq function sets the frequency of the DTR block.
+*
+* @param [in] node Node number
+* @param [in] freq Frequency to set in MHz
+*
+* @return
+* 	- none
+*
+* @ingroup hal
+*
+*/
+void nlm_hal_set_dtre_freq(int node, int freq)
+{
+	const uint64_t mhz = 1000000;
+	uint64_t set_freq;
+
+	nlm_print("-- DTRE Frequency set to to %d\n", freq);
+
+	if (is_nlm_xlp2xx()) {
+		set_freq = nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_GDX, freq*mhz);
+	}
+	else {
+		set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_DTRE, freq * mhz);
+	}
+
+	NLM_HAL_DO_DIV(set_freq, mhz);
+	nlm_print("DTRE Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+
+	/* This is only for experimetal reasons.
+	 * It will cleaned very soon.
+	 */
+#ifdef EXPERIMENTAL
+	/* TODO: xlp9xx
+	   check the device ID for DTRE1 - (DFS_DEVICE_DTRE1)
+	 */
+	/* for xlp9xx, set the frequency for the additional engine DTRE1 also */
+	if (is_nlm_xlp9xx()) {
+		uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_DTRE1, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("DTRE Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
+#endif
+
+}
+
+/* xlp9xx
+    1. check B/D/F values for both engines
+   */
+static void nlm_hal_dtr_9xx_init(void *fdt)
+{
+
+	uint64_t base0 = nlm_hal_get_dev_base (XLP_DTR_NODE, 1, XLP_DTR_DEVICE, XLP_DTR_FUNC);
+	uint64_t base1 = nlm_hal_get_dev_base (XLP_DTR_NODE, 1, XLP_DTR_DEVICE, 6);
+
+	/* xlp9xx has two DTRE engines.  We need to initialize both */
+
+	/* for engine DTRE0 */
+
+	/* Enable Master Control register */
+	nlm_hal_write_32bit_reg (base0, XLP_DTR_MASTER_CONTROL_REG, 0x1);
+	/* Channel control registers */
+	nlm_hal_write_32bit_reg (base0, XLP_DTR_CHANNEL_CONTROL_REG_0, 0x3fe);
+	nlm_hal_write_32bit_reg (base0, XLP_DTR_CHANNEL_CONTROL_REG_1, 0x3fe);
+
+#ifdef DEBUG
+	nlm_print ("Base Register 0x%llx\n", (unsigned long long)base0);
+	nlm_print ("Master control 0x%x\n", nlm_hal_read_32bit_reg (base0, XLP_DTR_MASTER_CONTROL_REG));
+	nlm_print ("Channel control0 0x%x\n", nlm_hal_read_32bit_reg (base0, XLP_DTR_CHANNEL_CONTROL_REG_0));
+	nlm_print ("Channel control1 0x%x\n", nlm_hal_read_32bit_reg (base0, XLP_DTR_CHANNEL_CONTROL_REG_1));
+#endif
+
+	/* for engine DTRE1 */
+
+	/* Enable Master Control register */
+	nlm_hal_write_32bit_reg (base1, XLP_DTR_MASTER_CONTROL_REG, 0x1);
+	/* Channel control registers */
+	nlm_hal_write_32bit_reg (base1, XLP_DTR_CHANNEL_CONTROL_REG_0, 0x3fe);
+	nlm_hal_write_32bit_reg (base1, XLP_DTR_CHANNEL_CONTROL_REG_1, 0x3fe);
+
+#ifdef DEBUG
+	nlm_print ("Base Register 0x%llx\n", (unsigned long long)base1);
+	nlm_print ("Master control 0x%x\n", nlm_hal_read_32bit_reg (base1, XLP_DTR_MASTER_CONTROL_REG));
+	nlm_print ("Channel control0 0x%x\n", nlm_hal_read_32bit_reg (base1, XLP_DTR_CHANNEL_CONTROL_REG_0));
+	nlm_print ("Channel control1 0x%x\n", nlm_hal_read_32bit_reg (base1, XLP_DTR_CHANNEL_CONTROL_REG_1));
+#endif
+
+}
+
+/**
+* @brief nlm_hal_dtr_init function is used to enable DTR block on XLP.
+*
+* @return : none
+*
+* @ingroup hal
+*
+*/
+void nlm_hal_dtr_init(void *fdt)
+{
+    uint64_t base = nlm_hal_get_dev_base (XLP_DTR_NODE, XLP_DTR_BUS, XLP_DTR_DEVICE, XLP_DTR_FUNC);
+    int frequency = 0, node = 0;
+
+    if (is_nlm_xlp9xx())
+    {
+	    nlm_hal_dtr_9xx_init(fdt);
+	    return;
+    }
+
+    /* Enable Master Control register */
+    nlm_hal_write_32bit_reg (base, XLP_DTR_MASTER_CONTROL_REG, 0x1);
+    /* Channel control registers */
+    nlm_hal_write_32bit_reg (base, XLP_DTR_CHANNEL_CONTROL_REG_0, 0x3fe);
+    nlm_hal_write_32bit_reg (base, XLP_DTR_CHANNEL_CONTROL_REG_1, 0x3fe);
+    nlm_hal_write_32bit_reg (base, XLP_DTR_CHANNEL_CONTROL_REG_2, 0x3fe);
+    nlm_hal_write_32bit_reg (base, XLP_DTR_CHANNEL_CONTROL_REG_3, 0x3fe);
+
+    frequency = nlm_hal_get_fdt_freq(fdt, NLM_DTRE);
+    if (frequency) {
+	    nlm_hal_set_dtre_freq(node, frequency);
+    }
+
+#ifdef DEBUG
+    nlm_print ("Base Register 0x%llx\n", (unsigned long long)base);
+    nlm_print ("Master control 0x%x\n", nlm_hal_read_32bit_reg (base, XLP_DTR_MASTER_CONTROL_REG));
+    nlm_print ("Channel control0 0x%x\n", nlm_hal_read_32bit_reg (base, XLP_DTR_CHANNEL_CONTROL_REG_0));
+    nlm_print ("Channel control1 0x%x\n", nlm_hal_read_32bit_reg (base, XLP_DTR_CHANNEL_CONTROL_REG_1));
+    nlm_print ("Channel control2 0x%x\n", nlm_hal_read_32bit_reg (base, XLP_DTR_CHANNEL_CONTROL_REG_2));
+    nlm_print ("Channel control3 0x%x\n", nlm_hal_read_32bit_reg (base, XLP_DTR_CHANNEL_CONTROL_REG_3));
+#endif
+}
+
+/* SAE SUPPORT
+ */
+/**
+* @brief nlm_hal_set_sae_freq function sets the frequency of the SAE block.
+*
+* @param [in] node Node number
+* @param [in] freq Frequency to set in MHz
+*
+* @return
+* 	- none
+*
+* @ingroup hal_sae
+*
+*/
+void nlm_hal_set_sae_freq(int node, int freq)
+{
+	const uint64_t mhz = 1000000;
+	nlm_print("-- SAE Frequency set to %d\n", freq);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_SAE, freq * mhz);
+	} else if (is_nlm_xlp9xx()) {
+            set_soc_frequency(node, XLP9XX_CLKDEV_SEC, freq * mhz);
+        } else {
+		uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_SAE, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("SAE Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
+}
+
+
+int nlm_hal_get_sae_chip_feature(void )
+{
+	int chip_features;
+	if( is_nlm_xlp2xx())
+		chip_features = (INIT_DONE | ZUC | DES3_KEY_SWAP);
+	else
+		chip_features = INIT_DONE;
+	return chip_features;
+}
+
+void nlm_hal_set_rsa_freq(int node, int freq)
+{
+	const uint64_t mhz = 1000000;
+	nlm_print("--RSA Frequency set to %d\n", freq);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_RSA, freq * mhz);
+	} if (is_nlm_xlp9xx()) {
+            set_soc_frequency(node, XLP9XX_CLKDEV_RSA, freq*mhz);
+        } else {
+		uint64_t set_freq = nlm_hal_set_soc_freq(0, DFS_DEVICE_RSA, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("RSA Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
+}
+
+void  nlm_hal_sata_firmware_init(void)
+{
+	volatile uint32_t readdata, i;
+
+	nlm_print(" Started AHCI Firmware Initialization.\n");
+
+	nlm_mdelay(1000);
+
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_CTL);
+
+	nlm_print ("Reseting PHYs.\n");
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, SATA_RST_N);
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, PHY3_RESET_N);
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, PHY2_RESET_N);
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, PHY1_RESET_N);
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, PHY0_RESET_N);
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_CTL);
+	nlm_mdelay(10);
+
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, SATA_RST_N);
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, PHY3_RESET_N);
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, PHY2_RESET_N);
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, PHY1_RESET_N);
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, PHY0_RESET_N);
+
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_CTL);
+	wr_sata_glue_reg(XLP_HAL_SATA_CTL, readdata);
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_CTL);
+
+	nlm_print ("Waiting for PHYs to come up.\n");
+
+	i=0;
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_STATUS);
+	while ( ((readdata & 0x00F0) != 0x00F0) && (i < 30))
+	{
+		readdata = rd_sata_glue_reg(XLP_HAL_SATA_STATUS);
+		nlm_mdelay(10);
+		i++;
+	}
+
+	if (readdata  & P0_PHY_READY) nlm_print(" PHY0 is up.\n");
+	else nlm_print(" PHY0 is down.\n");
+	if (readdata  & P1_PHY_READY) nlm_print(" PHY1 is up.\n");
+	else nlm_print(" PHY1 is down.\n");
+	if (readdata  & P2_PHY_READY) nlm_print(" PHY2 is up.\n");
+	else nlm_print(" PHY2 is down.\n");
+	if (readdata  & P3_PHY_READY) nlm_print(" PHY3 is up.\n");
+	else nlm_print(" PHY3 is down.\n");
+
+	nlm_print(" AHCI Firmware Init  Done.\n");
+}
+
+void nlm_hal_sata_intr_setup(void)
+{
+	uint32_t val;
+
+	/* clear pending interrupts and then enable them */
+	val = rd_sata_glue_reg(XLP_HAL_SATA_INT);
+	nlm_mdelay(10);
+	wr_sata_glue_reg(XLP_HAL_SATA_INT, val);
+	nlm_mdelay(10);
+
+	val = rd_sata_glue_reg(XLP_HAL_SATA_INT_MASK);
+	nlm_mdelay(10);
+#if 1
+	wr_sata_glue_reg(XLP_HAL_SATA_INT_MASK, 0x1);
+#else
+	wr_sata_glue_reg(XLP_HAL_SATA_INT_MASK, val & 0x1BFF3);
+#endif
+}
+
+void nlm_hal_sata_intr_ack(void)
+{
+	uint32_t val = 0;
+
+	val = rd_sata_glue_reg(XLP_HAL_SATA_INT);
+	wr_sata_glue_reg(XLP_HAL_SATA_INT, val & 0x1BFF3);
+}
+
+void nlm_hal_sata_init(void)
+{
+	nlm_hal_sata_firmware_init();
+}
+
+uint32_t get_dom_owner_mask(void *fdt, int dom_id, char *module)
+{
+	char dom_node_str[32];
+	unsigned int *pval;
+	int nodeoffset;
+	int plen;
+	uint32_t flag;
+
+	sprintf(dom_node_str, "/doms/dom@%d/owner-config", dom_id);
+	nodeoffset = fdt_path_offset(fdt, dom_node_str);
+
+	if (nodeoffset >= 0)
+	{
+		pval = ((unsigned int *)fdt_getprop(fdt, nodeoffset, module, &plen));
+		if (pval != NULL) {
+			flag = fdt32_to_cpu(*(unsigned int *)pval);
+			//nlm_print("owner flag for %s is %#x.\n", module, flag);
+		}
+		else {
+			flag = 0;
+			// nlm_print("ERROR: pval is NULL.\n");
+		}
+	}
+	else
+	{
+		flag = 0;
+		// nlm_print("ERROR: unable to find nodeoffset.\n");
+	}
+
+	return flag;
+}
+
+
+void nlm_hal_set_rsa_cge(int node, int enable)
+{
+#define NLM_RSA_CFG_REG 0x40
+	uint32_t d32 = nlm_hal_read_rsa_reg(node, NLM_RSA_CFG_REG);
+	if(enable)
+		d32 |= 1<<9;
+	else
+		d32 &= ~(1<<9);
+	nlm_hal_write_rsa_reg(node, NLM_RSA_CFG_REG, d32);
+}
+
+
+
+void nlm_hal_set_rsa_data_mode(int node, int bigend_fmt)
+{
+	unsigned long rsa_base = xlp_rsa_base[node];
+	uint64_t d64 = nlm_hal_read_64bit_reg(rsa_base, 0x20);
+	//nlm_print("%s %d in, %llx\n", __FUNCTION__, __LINE__, d64);
+	if(!bigend_fmt)
+		d64 |= (1ULL<<20);
+	else
+		d64 &= ~(1ULL<<20);
+	nlm_hal_write_64bit_reg(rsa_base, 0x20, d64);
+	d64 = nlm_hal_read_64bit_reg(rsa_base, 0x20);
+	//nlm_print("%s %d out, %llx\n", __FUNCTION__, __LINE__, d64);
+}
+
+#define NLM_SAE_ENGINE_SELECT_REG_0 0x41
+void nlm_hal_set_sae_engine_sel(int node)
+{
+	int i, n;
+	unsigned int val;
+
+	if(is_nlm_xlp2xx()) {
+		return;
+	}
+	if (is_nlm_xlp9xx())  {
+                /* SAE selection is fully mapped by default.*/
+                return;
+	} else if(is_nlm_xlp3xx()) {
+		n = 1;
+		val =  0x00FFFFFF;
+	} else {
+		n = 8;
+		val =  0x00FFFFFF;
+	}
+	for (i = 0; i < n; i++) {
+		nlm_hal_write_sae_reg(node, NLM_SAE_ENGINE_SELECT_REG_0 + i, val);
+	}
+}
+
+#define NLM_RSA_ENGINE_SELECT_REG_0 0x41
+void nlm_hal_set_rsa_engine_sel(int node)
+{
+	int i, n;
+	unsigned int val;
+	if(is_nlm_xlp2xx()) {
+		return;
+	}
+
+	if (is_nlm_xlp9xx())  {
+            /* XLP9XX configure RSA engine selection as default value */
+            return;
+	} else if(is_nlm_xlp3xx()) {
+		n = 1;
+		val = 0xffff;
+	} else {
+		n = 3;
+		val = 0x7ffffff;
+	}
+	for (i = 0; i < n; i++) {
+		nlm_hal_write_rsa_reg(node, NLM_RSA_ENGINE_SELECT_REG_0 + i, val);
+	}
+}
+
+void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit)
+{
+
+	if (is_nlm_xlp9xx())  {
+		*vcbase = XLP_9XX_SEC_VC_BASE;
+		*vclimit = XLP_9XX_SEC_VC_LIMIT;
+	} else if(is_nlm_xlp3xx()) {
+		*vcbase = XLP_3XX_CRYPTO_VC_BASE;
+		*vclimit = XLP_3XX_CRYPTO_VC_LIMIT;
+	} else if(is_nlm_xlp2xx()) {
+		*vcbase = XLP_2XX_CRYPTO_VC_BASE;
+		*vclimit = XLP_2XX_CRYPTO_VC_LIMIT;
+	} else {
+		*vcbase = XLP_CRYPTO_VC_BASE;
+		*vclimit = XLP_CRYPTO_VC_LIMIT;
+	}
+}
+
+void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit)
+{
+	if (is_nlm_xlp9xx())  {
+		*vcbase = XLP_9XX_RSA_VC_BASE;
+		*vclimit = XLP_9XX_RSA_VC_LIMIT;
+	} else if(is_nlm_xlp3xx()) {
+		*vcbase  = XLP_3XX_RSA_ECC_VC_BASE;
+		*vclimit = XLP_3XX_RSA_ECC_VC_LIMIT;
+	} else if(is_nlm_xlp2xx()) {
+		*vcbase  = XLP_2XX_RSA_ECC_VC_BASE;
+		*vclimit = XLP_2XX_RSA_ECC_VC_LIMIT;
+	} else {
+		*vcbase = XLP_RSA_ECC_VC_BASE;
+		*vclimit = XLP_RSA_ECC_VC_LIMIT;
+
+	}
+}
+
+#define NLM_SAE_HASH_MUTE_MASK_REG_0 0x28
+void nlm_hal_config_hash_mute_mask(int node, int index, unsigned long long val[4])
+{
+	int reg = NLM_SAE_HASH_MUTE_MASK_REG_0 + index * 4;
+	int i;
+
+	if (!is_nlm_xlp9xx()) 
+		return;
+
+	for(i = 0; i < 4; i++) {
+		reg += i;
+		nlm_hal_write_64bit_reg ((xlp_sae_base[node]), (reg), (val[i]));
+	}
+	nlm_print("Configured mutemask for index %d \n", index);
+	nlm_print(" %016llx %016llx %016llx %016llx\n", val[0], val[1], val[2], val[3]);
+}
+
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/module.h>
+EXPORT_SYMBOL(nlm_hal_is_xlp_a0);
+EXPORT_SYMBOL(nlm_hal_is_xlp_le);
+EXPORT_SYMBOL(nlm_hal_get_dev_base);
+EXPORT_SYMBOL(nlm_hal_set_sae_freq);
+EXPORT_SYMBOL(nlm_hal_get_sae_chip_feature);
+EXPORT_SYMBOL(nlm_hal_set_rsa_freq);
+EXPORT_SYMBOL(nlm_hal_set_dtre_freq);
+EXPORT_SYMBOL(nlm_hal_set_cde_freq);
+EXPORT_SYMBOL(nlm_hal_get_crypto_vc_nums);
+EXPORT_SYMBOL(nlm_hal_set_sae_engine_sel);
+EXPORT_SYMBOL(nlm_hal_set_rsa_engine_sel);
+EXPORT_SYMBOL(nlm_hal_get_rsa_vc_nums);
+EXPORT_SYMBOL(nlm_hal_config_hash_mute_mask);
+
+EXPORT_SYMBOL(nlm_node_cfg);
+
+EXPORT_SYMBOL(get_dom_owner_mask);
+EXPORT_SYMBOL(nlm_hal_sata_init);
+EXPORT_SYMBOL(nlm_hal_sata_intr_setup);
+EXPORT_SYMBOL(nlm_hal_sata_intr_ack);
+EXPORT_SYMBOL(nlm_hal_get_fdt_freq);
+EXPORT_SYMBOL(nlm_hal_dtr_init);
+EXPORT_SYMBOL(nlm_hal_set_rsa_data_mode);
+
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal_cpu_info.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal_cpu_info.c
new file mode 100644
index 0000000..f068177
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal_cpu_info.c
@@ -0,0 +1,689 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#include "nlm_hal.h"
+#include "nlm_hal_macros.h"
+#include "nlm_hal_xlp_dev.h"
+
+/* local defines */
+#define XLP8XX_REVISION_A0  0x00
+#define XLP8XX_REVISION_A1  0x01
+#define XLP8XX_REVISION_A2  0x02
+#define XLP8XX_REVISION_B0  0x03
+#define XLP8XX_REVISION_B1  0x04
+
+#define XLP3XX_REVISION_A0  0x00
+#define XLP3XX_REVISION_A1  0x01
+#define XLP3XX_REVISION_B0  0x02
+#define XLP3XX_REVISION_B1  0x03
+
+extern void *memset(void *s, int c, size_t n);
+
+__inline__ uint32_t efuse_cfg0(void)
+{
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG0)));
+}
+
+__inline__ uint32_t efuse_cfg1(void)
+{
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG1)));
+}
+
+__inline__ uint32_t efuse_cfg2(void)
+{
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG2)));
+}
+
+__inline__ uint32_t efuse_cfg3(void)
+{
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG3)));
+}
+
+__inline__ uint32_t efuse_cfg6(void)
+{
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG6)));
+}
+
+
+static __inline__ int nlm_xlp2xx_has_cmp(void)
+{
+    unsigned int cfg1 = efuse_cfg1();
+    return !(cfg1 & (1 << XLP2XX_CMP_BLOCK_INDEX));
+}
+
+static __inline__ int nlm_xlp2xx_has_crypto(void)
+{
+    unsigned int cfg1 = efuse_cfg1();
+    return !(cfg1 & (1 << XLP2XX_CRYPTO_BLOCK_INDEX));
+}
+
+static __inline__ int nlm_xlp2xx_has_rsa(void)
+{
+    unsigned int cfg2 = efuse_cfg2();
+    return !(cfg2 & (1 << XLP2XX_RSA_BLOCK_INDEX));
+}
+
+static __inline__ int nlm_xlp2xx_has_regx(void)
+{
+    unsigned int cfg2 = efuse_cfg2();
+    return !(cfg2 & (1 << XLP2XX_REGX_BLOCK_INDEX));
+}
+
+__inline uint32_t get_proc_id(void)
+{
+	unsigned int prid = nlm_read_prid();
+	prid = (prid >> 8) & 0xff;
+	if (!prid) { /*May be its Non fused part.*/
+#ifdef  CONFIG_NETL3XX
+		prid = CHIP_PROCESSOR_ID_XLP_3XX;
+#elif  defined (CONFIG_NETL2XX)
+		prid = CHIP_PROCESSOR_ID_XLP_2XX;
+#else
+		prid = CHIP_PROCESSOR_ID_XLP_8_4_XX;
+#endif
+	}
+	return prid;
+}
+
+static __inline__ int get_nlm_xlp9xx_rev(void)
+{
+	return nlm_read_prid() & 0xff;
+}
+
+static __inline__ int get_nlm_xlp8xx_rev(void)
+{
+	return nlm_read_prid() & 0xff;
+}
+
+static __inline__ int get_nlm_xlp3xx_rev(void)
+{
+	int hw_rev = nlm_read_prid() & 0xff;
+	int sw_rev;
+	if(hw_rev>=XLP3XX_REVISION_B0)
+		sw_rev = hw_rev + 1;
+	else
+		sw_rev = hw_rev;
+	return sw_rev;
+}
+
+static __inline__ int get_nlm_xlp2xx_rev(void)
+{
+	return nlm_read_prid() & 0xff;
+}
+
+/***************************************************************************************
+* match the chip revision with 'rev'
+ * rev:  revision number
+		single match: XLP_REVISION_A0 etc
+		multi-match:  XLP_REVISION_AX/_BX/_XX
+****************************************************************************************/
+static __inline__ int is_nlm_xlp8xx_rev_xx(uint32_t rev)
+{
+	int sw_rev=get_nlm_xlp8xx_rev();
+	uint32_t rev_b0 = XLP_REVISION_B0;
+	if( rev==sw_rev)        return 1;
+	if( rev==XLP_REVISION_AX && sw_rev<rev_b0)	return 1;
+	if( rev==XLP_REVISION_BX && (rev_b0<=sw_rev))  	return 1;
+	if( rev==XLP_REVISION_ANY)			return 1;
+	return 0;
+}
+
+/***************************************************************************************
+* match the chip revision with 'rev'
+ * rev:  revision number
+		single match: XLP_REVISION_A0 etc
+		multi-match:  XLP_REVISION_AX/_BX/_XX
+****************************************************************************************/
+static __inline__ int is_nlm_xlp3xx_rev_xx(uint32_t rev)
+{
+	int sw_rev=get_nlm_xlp3xx_rev();
+	uint32_t rev_b0 = XLP_REVISION_B0;
+	if( rev==sw_rev)	return 1;
+	if( rev==XLP_REVISION_AX && sw_rev<rev_b0)	return 1;
+	if( rev==XLP_REVISION_BX && (rev_b0<=sw_rev))  	return 1;
+	if( rev==XLP_REVISION_ANY)			return 1;
+
+	return 0;
+}
+
+
+static __inline__ int is_nlm_xlp2xx_rev_xx(uint32_t rev)
+{
+	int sw_rev=get_nlm_xlp2xx_rev();
+	uint32_t rev_b0 = XLP_REVISION_B0;
+	if( rev==sw_rev)	return 1;
+	if( rev==XLP_REVISION_AX && sw_rev<rev_b0)	return 1;
+	if( rev==XLP_REVISION_BX && (rev_b0<=sw_rev))  	return 1;
+	if( rev==XLP_REVISION_ANY)			return 1;
+
+	return 0;
+}
+
+/***************************************************************************************
+match legacy eagle Ax: xlp832, xlp816, xlp432, xlp416, xlp408, xlp208, xlp204, xlp104
+chipid: 832, 816, 432, 416, 408, 208, 204, 104; match any of the chip in eagle Ax
+rev:    revision
+***************************************************************************************/
+static inline int is_xlp8xx_legacy(int chipid, uint32_t rev)
+{
+	uint32_t pid=get_proc_id();
+	uint32_t sw_rev = get_nlm_xlp8xx_rev();
+
+	if( rev==XLP_REVISION_ANY )	rev=XLP_REVISION_AX;
+	if( sw_rev!=rev && rev!=XLP_REVISION_AX )	return 0;
+	if( XLP_REVISION_B0<=sw_rev ) return 0;
+	if(	(( (chipid==0x8084) || (chipid==0x8000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_832)) ||
+		(( (chipid==0x8044) || (chipid==0x8000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_816)) ||
+		(( (chipid==0x4084) || (chipid==0x4000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_432)) ||
+		(( (chipid==0x4044) || (chipid==0x4000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_416)) ||
+		(( (chipid==0x4024) || (chipid==0x4000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_408)) )
+		return 1;
+
+    return 0;
+}
+
+/*
+ * match xlp8xx
+ * num_cpu: 32-xlp832, 24-xlp824, 16-xlp816, 0 any cpu number is valid match
+ * rev:  chip revision,
+ */
+#define CPU_NUM_ANY  0 /* any cpu number will be matched */
+static inline int is_xlp8xx(uint8_t num_cpu, uint32_t rev)
+{
+	uint32_t pid, core_mask, cfg1;
+	int ret, hw_cpu_num;
+
+	ret=is_nlm_xlp8xx_rev_xx(rev);
+	if(ret!=1)	return 0;
+
+	pid=get_proc_id();
+
+	if( pid == CHIP_PROCESSOR_ID_XLP_8_4_XX)
+	{
+		core_mask = efuse_cfg0() & 0xff;
+		cfg1 = efuse_cfg1() & 0x7;
+
+		hw_cpu_num=(8-bitcount(core_mask))<<2;
+		if( ((hw_cpu_num==num_cpu)||(num_cpu==CPU_NUM_ANY)) && cfg1!=0x7 )	return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * match xlp4xx
+ * num_cpu: 32-xlp832, 24-xlp824, 16-xlp816, 0xff any cpu number is valid match
+ * rev:  chip revision,
+ */
+static inline int is_xlp4xx(uint8_t num_cpu, uint32_t rev)
+{
+	uint32_t pid, core_mask, cfg1;
+	int ret, hw_cpu_num;
+
+	ret=is_nlm_xlp8xx_rev_xx(rev);
+	if(ret!=1)  return 0;
+
+	pid=get_proc_id();
+
+	if( pid == CHIP_PROCESSOR_ID_XLP_8_4_XX )
+	{
+		core_mask = efuse_cfg0() & 0xff;
+		cfg1 = efuse_cfg1() & 0x7;
+
+		hw_cpu_num=(8-bitcount(core_mask))<<2;
+		if( ((hw_cpu_num==num_cpu)||(num_cpu==CPU_NUM_ANY)) && cfg1==0x7 )	return 1;
+	}
+
+    return 0;
+}
+
+/*
+ * match xlp3xx
+ * num_cpu: 16-xlp316,  8-xlp308, 4-xlp304;  0xff any cpu number is valid match
+ * rev:  chip revision,
+ * type: CPU_EXTPID_XLP_3XX_NONE, CPU_EXTPID_XLP_3XX_L, CPU_EXTPID_XLP_3XX_LP, CPU_EXTPID_XLP_3XX_LP2
+ * xlp316 : 4x4 threads
+ * xlp308   2x4 threads
+ * xlp304   1x4 threads
+ * xlp208a  2x4 trheads
+ * xlp108a  2x4 trheads
+ * xlp204a  1x4 trheads
+ * xlp104a  1x4 trheads
+ * xlp202a  2x1 trheads
+ * xlp201a  1x1 trheads
+ * xlp101a  1x1 trheads
+ */
+static inline int xlp3xx_get_num_of_threads_per_core(uint32_t core_mask, uint32_t epid)
+{
+	int nthreads=1;
+	switch(epid) {
+		case CPU_EXTPID_XLP_3XX_BASE :
+		case CPU_EXTPID_XLP_3XX_L    :
+		case CPU_EXTPID_XLP_3XX_LP   :
+		case CPU_EXTPID_XLP_3XX_LP2  :
+		case CPU_EXTPID_XLP_208a     :
+		case CPU_EXTPID_XLP_108a     :
+		case CPU_EXTPID_XLP_204a     :
+		case CPU_EXTPID_XLP_104a     : nthreads = 4; break;
+		case CPU_EXTPID_XLP_202a     :
+		case CPU_EXTPID_XLP_201a     :
+		case CPU_EXTPID_XLP_101a     : nthreads = 1; break;
+		default: break;
+	};
+	return nthreads;
+}
+
+static inline int xlp3xx_get_num_of_cores(uint32_t core_mask, uint32_t epid)
+{
+	int ncores=1;
+	switch(epid) {
+		case CPU_EXTPID_XLP_3XX_BASE :
+		case CPU_EXTPID_XLP_3XX_L    :
+		case CPU_EXTPID_XLP_3XX_LP   :
+		case CPU_EXTPID_XLP_3XX_LP2  :
+		case CPU_EXTPID_XLP_208a     :
+		case CPU_EXTPID_XLP_108a     :
+		case CPU_EXTPID_XLP_204a     :
+		case CPU_EXTPID_XLP_104a     :
+		{
+ 			ncores = 4-bitcount(core_mask);
+			break;
+		}
+		case CPU_EXTPID_XLP_202a     : ncores = 2; break;
+		case CPU_EXTPID_XLP_201a     :
+		case CPU_EXTPID_XLP_101a     : ncores = 1; break;
+		default: break;
+	};
+	return ncores;
+}
+
+static inline int is_xlp3xx(uint8_t num_cores, uint8_t num_threads, uint32_t rev, uint32_t exttype)
+{
+	uint32_t pid, cfg0, core_mask;
+	uint8_t epid;
+	int ret, ncores, nthreads;
+
+	ret=is_nlm_xlp3xx_rev_xx(rev);
+	if(ret!=1)  return 0;
+
+	pid=get_proc_id();
+	if( pid == CHIP_PROCESSOR_ID_XLP_3XX )
+	{
+		cfg0=efuse_cfg0();
+		core_mask = cfg0  & 0xf;
+		epid = (uint8_t)(( cfg0>>4 )  & 0xf);
+
+		if( exttype ==CPU_EXTPID_XLP_3XX_ANY)
+			return 1;
+		else if (exttype == epid ) {
+			ncores=xlp3xx_get_num_of_cores(core_mask, epid);
+			nthreads=xlp3xx_get_num_of_threads_per_core(core_mask, epid);
+			if ((num_cores*num_threads) == CPU_NUM_ANY) return 1;
+  			else if ((ncores == num_cores) && (nthreads == num_threads)) return 1;
+		}
+	}
+
+    return 0;
+}
+
+/*
+ * match xlp2xx
+ * num_cpu: 8-xlp208, 4-xlp204;  0xff any cpu number is valid match
+ * rev:  chip revision,
+ */
+static inline int is_xlp2xx(uint8_t num_cores, uint8_t num_threads, uint32_t rev)
+{
+	uint32_t pid, cfg0, core_mask;
+	int ret, ncores, nthreads;
+	int xlp2xx_threads_tbl[4] = { 4, 2, 2, 1 };
+
+	ret=is_nlm_xlp2xx_rev_xx(rev);
+	if(ret!=1)  return 0;
+
+	pid=get_proc_id();
+	if(pid == CHIP_PROCESSOR_ID_XLP_2XX)
+	{
+		cfg0=efuse_cfg0();
+		core_mask = cfg0  & 0x3;
+		nthreads = xlp2xx_threads_tbl[(cfg0 >> 28) & 0x3];
+		ncores   = (2-bitcount(core_mask));
+		if ((num_cores*num_threads) == CPU_NUM_ANY) return 1;
+		else if ((ncores == num_cores) && (nthreads == num_threads)) return 1;
+	}
+	return 0;
+}
+
+static inline int is_xlp9xx(uint8_t num_cpus, uint32_t rev)
+{
+	uint32_t pid;
+	pid = get_proc_id();
+	if (pid == CHIP_PROCESSOR_ID_XLP_9XX)
+		return 1;
+	return 0;
+
+}
+
+/*
+ * match xlpxx
+ * chipid: 832, 316, 308, 208, etc, 800: any in 8xx group, 0 for all xlp group
+ * rev:    XLP_REVISION_A0, XLP_REVISION_A0 etc, or XLP_REVISION_AX (a0,a1,a2) XLP_REVISION_ANY(both: ax,bx)
+ * exttype: current only for 3xx:
+ *  CPU_EXTPID_XLP_3XX_BASE  0x00
+ *  CPU_EXTPID_XLP_3XX_L    0x01
+ *  CPU_EXTPID_XLP_3XX_LP   0x02
+ *  CPU_EXTPID_XLP_3XX_LP2  0x03
+ *  CPU_EXTPID_XLP_208a     0x06
+ *  CPU_EXTPID_XLP_108a     0x07
+ *  CPU_EXTPID_XLP_204a     0x05
+ *  CPU_EXTPID_XLP_104a     0x04
+ *  CPU_EXTPID_XLP_202a     0x08
+ *  CPU_EXTPID_XLP_201a     0x09
+ *  CPU_EXTPID_XLP_101a     0x0A
+ */
+int is_nlm_xlp(unsigned int chipid, unsigned int rev, unsigned int exttype)
+{
+	uint32_t group=(chipid>>12) & 0xF;
+	uint32_t num_cores=(chipid>>4) & 0xFF;
+	uint32_t num_threads_per_core=chipid & 0xF;
+	uint8_t num_cpu=num_cores*num_threads_per_core;
+	int b_rc=0;
+
+	if (group == 9)
+	{
+		b_rc = is_xlp9xx(num_cpu, rev);
+		if( b_rc == 1 )	return 1;
+	}
+
+	if ( group==8 )
+	{
+		b_rc=is_xlp8xx(num_cpu, rev);
+		if( b_rc==1 )	return 1;
+	}
+
+	if ( group==4 )
+	{
+		b_rc=is_xlp4xx(num_cpu, rev);
+		if( b_rc==1 )	return 1;
+	}
+
+	if ( group==3 )
+	{
+		b_rc=is_xlp3xx(num_cores, num_threads_per_core, rev, exttype);
+		return b_rc;
+	}
+
+	if ( group==2 )
+	{
+		b_rc=is_xlp2xx(num_cores, num_threads_per_core, rev);
+		return b_rc;
+	}
+
+	/* for legacy chips: */
+	if( rev<=XLP_REVISION_A2 || rev==XLP_REVISION_AX || rev==XLP_REVISION_ANY )
+		b_rc=is_xlp8xx_legacy(chipid, rev);
+
+	return b_rc;
+}
+
+
+static int  nlm_hal_get_chipid(void)
+{
+	int xlp2xx_threads_tbl[4] = { 4, 2, 2, 1 };
+	int chipid=-1, ncores, nthreads;
+	unsigned int cfg0, cfg1;
+	uint32_t pid=get_proc_id();
+
+	cfg0 =  efuse_cfg0() ;
+	cfg1 =  efuse_cfg1() ;
+
+	/* eagle 4xx 8xx BX, unfused chip treat as 8xx */
+	if(pid==0 || pid==CHIP_PROCESSOR_ID_XLP_8_4_XX)
+	{
+		ncores=(8-bitcount(cfg0&0xFF));
+		nthreads = 4;
+		chipid = (cfg1&7)==7 ? 0x4000 : 0x8000;
+		chipid+= ((ncores<<4) + nthreads);
+		return chipid;
+	}
+	if(pid==CHIP_PROCESSOR_ID_XLP_3XX)
+	{
+		ncores=(4-bitcount(cfg0&0xF));
+		nthreads = 4;
+		chipid = (0x3000 + (ncores<<4) + nthreads);
+		return chipid;
+	}
+	if (pid == CHIP_PROCESSOR_ID_XLP_2XX)
+	{
+		ncores=(2-bitcount(cfg0&0x3));
+		nthreads = xlp2xx_threads_tbl[(cfg0 >> 28) & 0x3];
+		chipid = (0x2000 + (ncores<<4) + nthreads);
+		return chipid;
+	}
+	if (pid == CHIP_PROCESSOR_ID_XLP_9XX)
+	{
+		chipid = 0x9100;
+		return chipid;
+	}
+
+	/* eagle 8xx AX */
+	switch(pid)
+	{
+	case CHIP_PROCESSOR_ID_XLP_832 :    chipid=0x8084;   break;
+	case CHIP_PROCESSOR_ID_XLP_816 :    chipid=0x8044;   break;
+	case CHIP_PROCESSOR_ID_XLP_432 :    chipid=0x4084;   break;
+	case CHIP_PROCESSOR_ID_XLP_416 :    chipid=0x4044;   break;
+	case CHIP_PROCESSOR_ID_XLP_408 :    chipid=0x4024;   break;
+	default: break;
+	}
+
+	return chipid;
+}
+
+static const char*  nlm_hal_get_chipid_str(void)
+{
+	if(is_nlm_xlp8xx_832()) return "XLP832";
+	if(is_nlm_xlp8xx_824()) return "XLP824";
+	if(is_nlm_xlp8xx_816()) return "XLP816";
+
+	if(is_nlm_xlp8xx_432()) return "XLP432";
+	if(is_nlm_xlp8xx_424()) return "XLP424";
+	if(is_nlm_xlp8xx_416()) return "XLP416";
+
+	if(is_nlm_xlp316()) return "XLP316";
+	if(is_nlm_xlp312()) return "XLP312";
+	if(is_nlm_xlp308()) return "XLP308";
+	if(is_nlm_xlp304()) return "XLP304";
+
+	if(is_nlm_xlp3xx_208a()) return "XLP3XX_208a";
+	if(is_nlm_xlp3xx_108a()) return "XLP3XX_108a";
+
+	if(is_nlm_xlp3xx_204a()) return "XLP3XX_204a";
+	if(is_nlm_xlp3xx_104a()) return "XLP3XX_104a";
+
+	if(is_nlm_xlp3xx_202a()) return "XLP3XX_202a";
+	if(is_nlm_xlp3xx_201a()) return "XLP3XX_201a";
+	if(is_nlm_xlp3xx_101a()) return "XLP3XX_101a";
+
+	if(is_nlm_xlp208()) return "XLP208";
+	if(is_nlm_xlp108()) return "XLP108";
+
+	if(is_nlm_xlp204()) return "XLP204";
+	if(is_nlm_xlp104()) return "XLP104";
+
+	if(is_nlm_xlp202()) return "XLP202";
+	if(is_nlm_xlp201()) return "XLP201";
+	if(is_nlm_xlp101()) return "XLP101";
+
+	if(is_nlm_xlp9xx()) return "XLP9XX";
+
+	return "XLP???";
+}
+
+int  nlm_hal_get_cpuinfo(struct nlm_netl_proc_info* cpu_info)
+{
+	const static char c_typename[][8]={"\0", "Lite", "Lite+", "Lite+2", "Unknown"};
+	unsigned int sw_rev, chipid, type, i;
+	uint32_t cfg0, pid;
+	const char* chipid_str;
+
+	pid=get_proc_id();
+	chipid=nlm_hal_get_chipid();
+
+	memset(cpu_info, 0, sizeof(struct nlm_netl_proc_info));
+	cpu_info->proc_id=pid;
+	cpu_info->chipid=chipid;
+
+	for(i=0; i<8; i++) {
+		cpu_info->efuse_config[i] =
+			nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG0+i)));
+	}
+	chipid_str = nlm_hal_get_chipid_str();
+
+	if (pid == CHIP_PROCESSOR_ID_XLP_9XX ) {
+		sw_rev = get_nlm_xlp9xx_rev();
+		cpu_info->revision= sw_rev;
+		sprintf(cpu_info->cpu_info_str, "%s Rev %c%1d",
+			chipid_str,(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
+	}
+	else if( pid == CHIP_PROCESSOR_ID_XLP_2XX )
+	{
+		sw_rev = get_nlm_xlp2xx_rev();
+		cpu_info->revision= sw_rev;
+		sprintf(cpu_info->cpu_info_str, "%s Rev %c%1d",
+			chipid_str,(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
+	}
+	else if( pid != CHIP_PROCESSOR_ID_XLP_3XX )
+	{
+		sw_rev = get_nlm_xlp8xx_rev();
+		cpu_info->revision= sw_rev;
+		sprintf(cpu_info->cpu_info_str, "%s Rev %c%1d",
+			chipid_str,(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
+	}
+	else
+	{
+		sw_rev = get_nlm_xlp3xx_rev();
+		cpu_info->revision = sw_rev;
+		cfg0 =  efuse_cfg0();
+		type= (cfg0>>4) & 0xF;
+		if(CPU_EXTPID_XLP_3XX_LP2<type) type=CPU_EXTPID_XLP_3XX_LP2+1;
+		sprintf(cpu_info->cpu_info_str, "%s%s Rev %c%1d", chipid_str, c_typename[type],
+			(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
+	}
+
+	return 0;
+}
+
+int is_nlm_xlp208(void)
+{
+	return ( is_nlm_xlp(0x2024, XLP_REVISION_ANY, 0)
+			&& (nlm_xlp2xx_has_cmp())
+			&& (nlm_xlp2xx_has_crypto())
+			&& (nlm_xlp2xx_has_rsa())
+			&& (nlm_xlp2xx_has_regx()) );
+}
+
+int is_nlm_xlp108(void)
+{
+	return ( is_nlm_xlp(0x2024, XLP_REVISION_ANY, 0)
+			&& (!nlm_xlp2xx_has_cmp())
+			&& (nlm_xlp2xx_has_crypto())
+			&& (nlm_xlp2xx_has_rsa())
+			&& (nlm_xlp2xx_has_regx()) );
+}
+
+int is_nlm_xlp204(void)
+{
+	return ( is_nlm_xlp(0x2014, XLP_REVISION_ANY, 0)
+				&& (nlm_xlp2xx_has_cmp())
+				&& (nlm_xlp2xx_has_crypto())
+				&& (nlm_xlp2xx_has_rsa())
+				&& (nlm_xlp2xx_has_regx()) );
+}
+
+int is_nlm_xlp104(void)
+{
+	return ( is_nlm_xlp(0x2014, XLP_REVISION_ANY, 0)
+				&& (!nlm_xlp2xx_has_cmp())
+				&& (nlm_xlp2xx_has_crypto())
+				&& (nlm_xlp2xx_has_rsa())
+				&& (nlm_xlp2xx_has_regx()) );
+}
+
+int is_nlm_xlp202(void)
+{
+	return ( is_nlm_xlp(0x2021, XLP_REVISION_ANY, 0)
+				&& (!nlm_xlp2xx_has_cmp())
+				&& (!nlm_xlp2xx_has_crypto())
+				&& (!nlm_xlp2xx_has_rsa())
+				&& (!nlm_xlp2xx_has_regx()) );
+}
+
+int is_nlm_xlp201(void)
+{
+	return ( is_nlm_xlp(0x2011, XLP_REVISION_ANY, 0)
+				&& (!nlm_xlp2xx_has_cmp())
+				&& (!nlm_xlp2xx_has_crypto())
+				&& (!nlm_xlp2xx_has_rsa())
+				&& (nlm_xlp2xx_has_regx()) );
+}
+
+int is_nlm_xlp101(void)
+{
+	return ( is_nlm_xlp(0x2011, XLP_REVISION_ANY, 0) \
+				&& (!nlm_xlp2xx_has_cmp()) \
+				&& (!nlm_xlp2xx_has_crypto()) \
+				&& (!nlm_xlp2xx_has_rsa()) \
+				&& (!nlm_xlp2xx_has_regx()) );
+}
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/module.h>
+/*Add  API here if any API  from above is needed*/
+EXPORT_SYMBOL(efuse_cfg0);
+EXPORT_SYMBOL(efuse_cfg1);
+EXPORT_SYMBOL(efuse_cfg6);
+EXPORT_SYMBOL(get_proc_id);
+EXPORT_SYMBOL(is_nlm_xlp);
+EXPORT_SYMBOL(nlm_hal_get_cpuinfo);
+EXPORT_SYMBOL(is_nlm_xlp208);
+EXPORT_SYMBOL(is_nlm_xlp108);
+EXPORT_SYMBOL(is_nlm_xlp204);
+EXPORT_SYMBOL(is_nlm_xlp104);
+EXPORT_SYMBOL(is_nlm_xlp202);
+EXPORT_SYMBOL(is_nlm_xlp201);
+EXPORT_SYMBOL(is_nlm_xlp101);
+#endif
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal_sys.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal_sys.c
new file mode 100644
index 0000000..a4c15c8
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal_sys.c
@@ -0,0 +1,1036 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#if !defined(__KERNEL__) && !defined(NLM_HAL_UBOOT)
+#include <stddef.h>
+#endif
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <asm/div64.h>
+#endif
+#include "nlm_hal.h"
+#include "nlm_hal_sys.h"
+#include "nlm_hal_xlp_dev.h"
+
+uint64_t nlm_hal_xlp2xx_get_pllfreq_dyn(int node, uint8_t pll_type);
+uint64_t nlm_hal_xlp2xx_set_pllfreq_dyn(int node, uint8_t pll_type, uint64_t freq);
+uint64_t nlm_hal_xlp2xx_get_pll_out_frq(int node, uint8_t pll_type);
+
+/**
+ * Calculate the DFS divider value for the specified reference clock
+ * and target output frequency.
+ * @param [in] reference the reference clock frequency, in Hz.
+ * @param [in] target the target output frequency, in Hz.
+ * @returns the divider that produces the target frequency
+ * (if the target frequency is within FREQ_RESOLUTION of the actual output).
+ * Otherwise, it will round up to the nearest divider (rounding down to the
+ * the lower output frequency).
+ */
+static uint8_t fuzzy_divider(uint64_t reference, uint64_t target)
+{
+	uint64_t divider = reference;
+	uint64_t freq = reference;
+	uint64_t delta;
+	uint8_t result;
+	NLM_HAL_DO_DIV(divider, target);
+	NLM_HAL_DO_DIV(freq, divider);
+	delta = freq - target;
+	result = (uint8_t)divider;
+	return (delta <= FREQ_RESOLUTION)? result : (result + 1);
+}
+
+
+/**
+ * @returns the numerator for the reference clock frequency.
+ */
+static inline uint64_t ref_clk_num(void)
+{
+	return  (nlm_hal_is_ref_clk_133MHz()) ? REF_CLK_NUM_400 : REF_CLK_NUM_200;
+}
+
+/**
+ * @returns the denominator for the reference clock frequency.
+ */
+static inline uint64_t ref_clk_den(void)
+{
+	return REF_CLK_DEN;
+}
+/**
+ * @returns the current reference clock frequency, in Hz.
+ */
+uint64_t nlm_hal_get_ref_clk_freq(void)
+{
+        uint64_t ref_freq;
+        uint64_t clk_num;
+        uint32_t clk_den;
+
+	if(is_nlm_xlp2xx()) {
+		ref_freq = xlp2xx_get_ref_clk(0, &clk_num, &clk_den);
+	} else {
+		ref_freq = ref_clk_num() / ref_clk_den();
+	}
+	return ref_freq;
+}
+
+/**
+ * Mapping of DFS indices to actual DFS divider values.
+ */
+static uint8_t DFS[] = {1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 15};
+
+/**
+ * @returns the maximum DFS divider value.
+ */
+static inline uint8_t max_dfs_val(void)
+{
+	return DFS[COUNT_OF(DFS) - 1];
+}
+/**
+ * @returns the minimum DFS divider value.
+ */
+static inline uint8_t min_dfs_val(void)
+{
+	return DFS[0];
+}
+
+/**
+ * Get the output frequency for the PLL, based on the
+ * R-divider, F-divider, and PLL DFS divider.
+ * @param [in] divr R-divider for the PLL.
+ * @param [in] divf F-divider for the PLL.
+ * @param [in] pll_dfs PLL DFS divider.
+ * @return PLL frequency, in Hz.
+ */
+static inline uint64_t pll_freq(uint8_t divr, uint8_t divf, uint8_t pll_dfs)
+{
+	uint64_t num = ref_clk_num() * (divf + 1) * 4 / 2;
+	uint64_t den = ref_clk_den() * (divr + 1) * (pll_dfs + 1);
+	NLM_HALT_IF_XLPII();
+	NLM_HAL_DO_DIV(num, den);
+	return num;
+}
+
+/**
+ * Get the DFS index for the DFS value (to be used with the stepping functions).
+ * The DFS value is rounded up (producing the lower output frequency) if
+ * the exact DFS value does not exist.
+  @param [in] dfs DFS divider value.
+ * @return the DFS index greater than or equal to the specified DFS divider value.
+ */
+static inline int8_t closest_dfs_index(uint8_t dfs)
+{
+	int i;
+	NLM_HALT_IF_XLPII();
+	if (dfs > max_dfs_val())
+		return COUNT_OF(DFS)-1;
+
+	for (i = (COUNT_OF(DFS) - 2); i >= 0; i--) {
+		if ((DFS[i+1] >= dfs) && (dfs > DFS[i]))
+			return i+1;
+	}
+
+	return 0;
+}
+
+/**
+ * Determine whether the Core PLL DFS is bypassed.
+ * In XLP8xx-4xx A-stepping, the Core PLL DFS does not exist.
+ * @returns 0 if the Core PLL is not bypassed.
+ * @returns 1 if the Core PLL is bypassed, or if the Core PLL does not exist.
+ */
+static inline uint8_t is_core_pll_dfs_bypassed(int node)
+{
+	NLM_HALT_IF_XLPII();
+	/* no Core PLL DFS on XLP8XX/4XX A-stepping */
+	if (is_nlm_xlp8xx_ax())
+		return 1;
+	return nlm_hal_read_sys_reg(node, PLL_DFS_BYP_CTRL) & 0x1;
+}
+
+/**
+ * Determine whether the SoC PLL DFS is bypassed.
+ * In XLP8xx-4xx A-stepping, the SoC PLL DFS does not exist.
+ * @returns 0 if the SoC PLL is not bypassed.
+ * @returns 1 if the SoC PLL is bypassed, or if the SoC PLL does not exist.
+ */
+static inline uint8_t is_soc_pll_dfs_bypassed(int node)
+{
+	NLM_HALT_IF_XLPII();
+	/* no Core PLL DFS on XLP8XX/4XX A-stepping */
+	if (is_nlm_xlp8xx_ax())
+		return 1;
+	return (nlm_hal_read_sys_reg(node, PLL_DFS_BYP_CTRL) >> 1) & 0x1;
+}
+
+/**
+ * @return the Core PLL DFS divider value, if the chip family supports it.
+ * @return 0 if the Core PLL DFS is not implemented.
+ */
+static inline uint64_t core_pll_dfs_val(int node)
+{
+	NLM_HALT_IF_XLPII();
+	/* no Core PLL DFS on XLP8XX/4XX A-stepping */
+	if (is_nlm_xlp8xx_ax())
+		return 0;
+	if (is_core_pll_dfs_bypassed(node))
+		return 0;
+	return nlm_hal_read_sys_reg(node, PLL_DFS_DIV_VALUE) & 0xf;
+}
+
+/**
+ * @return the SoC PLL DFS divider value, if the chip family supports it.
+ * @return 0 if the SoC PLL DFS is not implemented.
+ */
+static inline uint64_t soc_pll_dfs_val(int node)
+{
+	NLM_HALT_IF_XLPII();
+	/* no SoC PLL DFS on XLP8XX/4XX A-stepping */
+	if (is_nlm_xlp8xx_ax())
+		return 0;
+	if (is_soc_pll_dfs_bypassed(node))
+		return 0;
+	return (nlm_hal_read_sys_reg(node, PLL_DFS_DIV_VALUE) >> 4) & 0xf;
+}
+
+/**
+ * Get the Core PLL frequency post PLL DFS.
+ */
+static inline uint64_t core_pll_freq(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, POWER_ON_RESET_CFG);
+	uint8_t divr = (reg >> 8)  & 0x3;
+	uint8_t divf = (reg >> 10) & 0x7f;
+	NLM_HALT_IF_XLPII();
+	return pll_freq(divr, divf, core_pll_dfs_val(node));
+}
+
+/**
+ * Get the SoC PLL frequency post PLL DFS.
+ */
+static inline uint64_t soc_pll_freq(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, PLL_CTRL);
+	uint8_t divf = (reg >> 3) & 0x7F;
+	uint8_t divr = (reg >> 1) & 0x3;
+	NLM_HALT_IF_XLPII();
+	return pll_freq(divr, divf, soc_pll_dfs_val(node));
+}
+
+/**
+ * Get the DDR PLL frequency.
+ */
+static inline uint64_t ddr_pll_freq(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, PLL_CTRL);
+	uint8_t divf = (reg >> 19) & 0x7F;
+	uint8_t divr = (reg >> 17) & 0x3;
+	NLM_HALT_IF_XLPII();
+	return pll_freq(divr, divf, 0);
+}
+
+/**
+ * Get the DFS divider value for the specified SoC device.
+ * @param [in] device the SoC device.
+ */
+static inline uint64_t soc_dfs_val(int node, soc_device_id_t device)
+{
+	uint8_t device_index = device;
+	NLM_HALT_IF_XLPII();
+	if (device_index >= 8)
+	{
+		device_index -= 8;
+		return (nlm_hal_read_sys_reg(node, SYS_DFS_DIV_VALUE1) >> (device_index * 4)) & 0xF;
+	}
+	return (nlm_hal_read_sys_reg(node, SYS_DFS_DIV_VALUE0) >> (device_index * 4)) & 0xF;
+}
+
+/**
+ * Get the DFS divider value for the specified Core.
+ * @param [in] core CPU core index.
+ */
+static inline uint64_t core_dfs_val(int node, uint8_t core)
+{
+	NLM_HALT_IF_XLPII();
+	return (nlm_hal_read_sys_reg(node, CORE_DFS_DIV_VALUE) >> (core * 4)) & 0xF; 
+}
+
+/**
+ * Determine whether the SoC device's DFS is bypassed.
+ * @param [in] device the SoC device.
+ * @returns 1 if the SoC device's DFS is bypassed.
+ * @returns 0 if the SoC device's DFS is not bypassed.
+ */
+static inline uint8_t is_soc_dfs_bypassed(int node, soc_device_id_t device)
+{
+	uint8_t device_index = device;
+	NLM_HALT_IF_XLPII();
+	return (nlm_hal_read_sys_reg(node, SYS_DFS_BYP_CTRL) >> device_index) & 1;
+}
+
+/**
+ * Enable/disable the DFS bypass for the specified SoC device.
+ * @param [in] device the SoC device.
+ * @param [in] bypass 1: bypass the DFS. 0: do not bypass DFS.
+ */
+static inline void set_soc_dfs_bypass(int node, soc_device_id_t device, uint8_t bypass)
+{
+	uint8_t device_index = device;
+	uint32_t val;
+	NLM_HALT_IF_XLPII();
+	val = nlm_hal_read_sys_reg(node, SYS_DFS_BYP_CTRL) & ~(1 << device_index);
+	nlm_hal_write_sys_reg(node, SYS_DFS_BYP_CTRL, val | ((bypass? 0x1 : 0x0) << device_index));
+}
+
+/**
+ * Determine whether the CPU core's DFS is bypassed.
+ * @param [in] core CPU core index.
+ * @returns 1 if the CPU core's DFS is bypassed.
+ * @returns 0 if the CPU core's DFS is not bypassed.
+ */
+static inline uint8_t is_core_dfs_bypassed(int node, uint8_t core)
+{
+	NLM_HALT_IF_XLPII();
+	return (nlm_hal_read_sys_reg(node, CORE_DFS_BYP_CTRL) >> core) & 1;
+}
+
+/**
+ * Enable/disable the DFS bypass for the specified CPU core.
+ * @param [in] core CPU core index.
+ * @param [in] bypass 1: bypass the DFS. 0: do not bypass DFS.
+ */
+static inline void set_core_dfs_bypass(int node, uint8_t core, uint8_t bypass)
+{
+	uint32_t val;
+	NLM_HALT_IF_XLPII();
+	val = nlm_hal_read_sys_reg(node, CORE_DFS_BYP_CTRL) & ~(1 << core);
+	nlm_hal_write_sys_reg(node, CORE_DFS_BYP_CTRL, val | ((bypass? 0x1 : 0x0) << core));
+}
+
+/**
+ * Get the operating frequency for the specified CPU core.
+ * @param [in] device the SoC device.
+ * @returns The SoC device operating frequency, in Hz.
+ */
+uint64_t nlm_hal_get_soc_freq(int node, soc_device_id_t device)
+{
+	uint64_t freq, den;
+
+	if(is_nlm_xlp2xx()) {
+		freq = nlm_hal_xlp2xx_get_clkdev_frq(node, device);
+		return freq;
+	}
+
+	switch (device) {
+		case DFS_DEVICE_NAND:
+		case DFS_DEVICE_NOR:
+		case DFS_DEVICE_MMC:
+			/* NOR, NAND and MMC devices are derived from the freq clock. */
+			freq = nlm_hal_get_ref_clk_freq();
+			break;
+		case DFS_DEVICE_DMC:
+			freq = ddr_pll_freq(node);
+			break;
+		case DFS_DEVICE_CORE:
+			/* The Core DFS is derived from the Core PLL */
+			freq = core_pll_freq(node);
+			break;
+		default:
+			freq = soc_pll_freq(node);
+			break;
+	}
+
+	den = soc_dfs_val(node, device) + 1;
+	if (!is_soc_dfs_bypassed(node, device)) {
+		NLM_HAL_DO_DIV(freq, den);
+	}
+	return freq;
+}
+
+/**
+ * Step the DFS of the specified SoC device to the target DFS index.
+ * @param [in] device the SoC device.
+ * @param [in] dfs_index DFS index (**not** the DFS value).
+ */
+static void step_soc_dfs(int node, soc_device_id_t device, uint8_t dfs_index)
+{
+	uint8_t device_index;
+	uint8_t cur;
+	int8_t delta, i;
+
+	NLM_HALT_IF_XLPII();
+	device_index = device;
+	cur = closest_dfs_index(soc_dfs_val(node, device));
+	delta = cur - dfs_index;
+
+	if (delta >= 0) {
+		/* positive delta, decrement dfs */
+		for (i=0; i < delta; i++)
+			nlm_hal_write_sys_reg(node, SYS_DFS_DIV_DEC_CTRL, 1 << device_index);
+	} else {
+		/* negative delta, increment dfs */
+		for (i=0; i > delta; i--)
+			nlm_hal_write_sys_reg(node, SYS_DFS_DIV_INC_CTRL, 1 << device_index);
+	}
+}
+
+/**
+ * Set the operating frequency for the specified SoC device.
+ * This is achieved only by stepping the SoC device DFS.
+ * @param [in] device the SoC device.
+ * @param [in] freq target SoC device frequency, in Hz.
+ * @returns the new SoC device operating frequency, in Hz.
+ */
+uint64_t nlm_hal_set_soc_freq(int node, soc_device_id_t device, uint64_t freq)
+{
+	uint64_t reference;
+	uint8_t  target;
+
+	if(is_nlm_xlp2xx()) {
+		return nlm_hal_xlp2xx_set_clkdev_frq(node, device, freq);
+	}
+	switch (device) {
+		case DFS_DEVICE_NAND:
+		case DFS_DEVICE_NOR:
+		case DFS_DEVICE_MMC:
+			/* NOR, NAND and MMC devices are derived from the reference clock. */
+			reference = nlm_hal_get_ref_clk_freq();
+			break;
+		case DFS_DEVICE_DMC:
+			reference = ddr_pll_freq(node);
+			break;
+		case DFS_DEVICE_CORE:
+			/* The Core DFS is derived from the Core PLL */
+			reference = core_pll_freq(node);
+			break;
+		default:
+			reference = soc_pll_freq(node);
+			break;
+	}
+
+	target = closest_dfs_index(fuzzy_divider(reference, freq) - 1);
+	if (freq >= (reference - FREQ_RESOLUTION)) {
+		/* bypass DFS if freq is reference freq */
+		set_soc_dfs_bypass(node, device, 1);
+	} else {
+		/* otherwise, step dfs and clear bypass */
+		step_soc_dfs(node, device, target);
+		set_soc_dfs_bypass(node, device, 0);
+	}
+
+	return nlm_hal_get_soc_freq(node, device);
+}
+
+/**
+ * Get the operating frequency for the specified CPU core.
+ * @param [in] core CPU core index.
+ * @returns The CPU core operating frequency, in Hz.
+ */
+uint64_t nlm_hal_get_core_freq(int node, uint8_t core)
+{
+	if(is_nlm_xlp2xx()) {
+		return nlm_hal_xlp2xx_get_pllfreq_dyn(node, core);
+	}
+	else {
+		uint64_t den, reference = core_pll_freq(node);
+		den = core_dfs_val(node, core) + 1;
+		if (!is_core_dfs_bypassed(node, core))
+		    NLM_HAL_DO_DIV(reference, den);
+		return reference;
+	}
+}
+
+/**
+ * Step the DFS of the specified CPU core to the target DFS index.
+ * @param [in] core CPU core index.
+ * @param [in] dfs_index DFS index (**not** the DFS value).
+ */
+static void step_core_dfs(int node, uint8_t core, uint8_t dfs_index)
+{
+	uint8_t cur;
+	int8_t delta;
+	int i;
+
+	NLM_HALT_IF_XLPII();
+	cur = closest_dfs_index(core_dfs_val(node, core));
+	delta = cur - dfs_index;
+
+	if (delta >= 0) {
+		/* positive delta, decrement dfs */
+		for (i=0; i < delta; i++)
+			nlm_hal_write_sys_reg(node, CORE_DFS_DIV_DEC_CTRL, 1 << core);
+	} else {
+		/* negative delta, increment dfs */
+		for (i=0; i > delta; i--)
+			nlm_hal_write_sys_reg(node, CORE_DFS_DIV_INC_CTRL, 1 << core);
+	}
+}
+
+/**
+ * Set the operating frequency for the specified CPU core.
+ * This is achieved only by stepping the Core DFS.
+ * @param [in] core CPU core index.
+ * @param [in] freq target CPU core frequency, in Hz.
+ * @returns the new CPU core operating frequency, in Hz.
+ */
+uint64_t nlm_hal_set_core_freq(int node, uint8_t core, uint64_t freq)
+{
+	if(is_nlm_xlp2xx()) {
+		return nlm_hal_xlp2xx_set_pllfreq_dyn(node, core, freq);
+	}
+	else {
+		uint64_t reference = core_pll_freq(node);
+		uint8_t target = closest_dfs_index(fuzzy_divider(reference, freq) - 1);
+
+		if (freq >= (reference - FREQ_RESOLUTION)) {
+			/* bypass DFS if freq is reference freq */
+			set_core_dfs_bypass(node, core, 1);
+		} else {
+			/* otherwise, step dfs and clear bypass */
+			step_core_dfs(node, core, target);
+			set_core_dfs_bypass(node, core, 0);
+		}
+		return nlm_hal_get_core_freq(node, core);
+	}
+}
+
+/**
+ * Get the operating frequency for the current core.
+ * @returns The core operating frequency (in Hz).
+ */
+unsigned long long nlm_hal_cpu_freq(void)  
+{
+	uint8_t core = (nlm_cpu_id() >> 2) & 0x7;
+	return nlm_hal_get_core_freq(nlm_node_id(), core);
+}
+
+uint32_t nlm_hal_get_biu_mask_by_soc_device_id(soc_device_id_t device)
+{
+	int biu_mask=0;
+	switch(device) {
+        case XLP2XX_CLKDEVICE_NAE    : biu_mask =
+		 (1<<XLP2XX_IO_NET_BIU_NUMBER)|(1<<XLP2XX_IO_MSG_BIU_NUMBER)|(1<<XLP2XX_IO_POE_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_SAE    : biu_mask = (1<<XLP2XX_IO_SEC_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_RSA    : biu_mask = (1<<XLP2XX_IO_RSA_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_GDX    : biu_mask = (1<<XLP2XX_IO_GDX_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_CMP    : biu_mask = (1<<XLP2XX_IO_CMP_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_NAND   : biu_mask = (1<<XLP2XX_IO_GBU_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_MMC    : biu_mask = (1<<XLP2XX_IO_GBU_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_GBU    : biu_mask = (1<<XLP2XX_IO_GBU_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_RGXF   : biu_mask = (1<<XLP2XX_IO_REGX_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_RGXS   : biu_mask = (1<<XLP2XX_IO_REGX_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_USB    : biu_mask = (1<<XLP2XX_IO_USB_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_PIC    : biu_mask = (1<<XLP2XX_IO_PIC_BIU_NUMBER); break;
+		default: break;
+	}
+	return biu_mask;
+}
+
+uint8_t nlm_hal_get_soc_clock_state(int node, soc_device_id_t device)
+{
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		return (nlm_hal_read_sys_reg(node, XLP2XX_SYSDISABLE) & biu_mask) ?  XLP_DISABLE : XLP_ENABLE;
+	} else {
+		return (nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL) >> device);
+	}
+}
+
+void nlm_hal_soc_clock_enable(int node, soc_device_id_t device)
+{
+	uint32_t d32;
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		biu_mask = (nlm_hal_read_sys_reg(node, XLP2XX_SYSDISABLE) & ~biu_mask);
+		nlm_hal_write_sys_reg(node, XLP2XX_SYSDISABLE, biu_mask);
+	} else {
+		d32 = nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL);
+		d32 &= ~(1<<device);
+		nlm_hal_write_sys_reg(node, SYS_DFS_DIS_CTRL, d32);
+	}
+}
+
+void nlm_hal_soc_clock_disable(int node, soc_device_id_t device)
+{
+	uint32_t d32;
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		biu_mask |= nlm_hal_read_sys_reg(node, XLP2XX_SYSDISABLE);
+		nlm_hal_write_sys_reg(node, XLP2XX_SYSDISABLE, biu_mask);
+	} else {
+		d32 = nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL);
+		d32 |= (1<<device);
+		nlm_hal_write_sys_reg(node, SYS_DFS_DIS_CTRL, d32);
+	}
+}
+
+void nlm_hal_soc_clock_reset(int node, soc_device_id_t device)
+{
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		nlm_hal_write_sys_reg(node, XLP2XX_SYSRESET, biu_mask);
+	} else {
+		nlm_hal_write_sys_reg(node, SYS_DFS_RST_CTRL, 1 << device);
+	}
+}
+
+/*
+ * XLP 2XX Clock Management
+ */
+/*  Reference Clock Select 00:66; 01:100; 10:125; 11:133 */
+#define SYS_PWRON_RCS(x) (((x)>>18) & 0x3)
+
+#define SYS_PWRON_PLF(x) (((x)>>17) & 0x1)
+
+static int xlp2xx_get_plf(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, XLP2XX_POWER_ON_RESET_CFG);
+	int plf = SYS_PWRON_PLF(reg);
+	return plf;
+}
+
+static int xlp2xx_get_rcs(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, XLP2XX_POWER_ON_RESET_CFG);
+	int rcs = SYS_PWRON_RCS(reg);
+	return rcs;
+}
+
+static void nlm_hal_xlp2xx_dev_pll_cfg(int node, soc_device_id_t dev_type, int dev_pll_sel, int div)
+{
+	int dev_idx = dev_type - XLP2XX_CLKDEVICE_NAE;
+	uint32_t rsel, rdiv, rchg;
+	NLM_HALT_IF(dev_idx<0);
+	rsel = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL_REG) & (~(3<<(dev_idx*2)));
+	rdiv = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV_REG) & (~(3<<(dev_idx*2)));
+	nlm_hal_write_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL, rsel | ((dev_pll_sel&3) << (dev_idx*2)));
+	nlm_hal_write_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV, rdiv | ((div&3)<<(dev_idx*2)));
+	rsel = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL_REG);
+	rdiv = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV_REG);
+	rchg = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_CHG);
+	nlm_hal_write_sys_reg(node, XLP2XX_SYS_CLK_DEV_CHG, rchg|(1<<dev_idx));
+	while((nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_CHG) & (1<<dev_idx)));
+	return;
+}
+
+/*
+ * SYS_CLK_DEV_SEL
+ *  00  400MHz
+ *  01  Dev0 PLL
+ *  10  Dev1 PLL
+ *  11  Dev2 PLL
+ */
+static inline xlp2xx_clkdev_sel_t xlp2xx_get_clk_dev_sel(int node, soc_device_id_t dev_type)
+{
+	int dev_idx = dev_type - XLP2XX_CLKDEVICE_NAE;
+	NLM_HALT_IF(dev_idx<0);
+	return ( nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL_REG) >> (dev_idx*2) ) & 0x3 ;
+}	
+
+/*
+ * SYS_CLK_DEV_DIV
+ * 00  1
+ * 01  2
+ * 10  4
+ * 11  8
+ */
+static inline uint8_t xlp2xx_get_clkdev_div(int node, soc_device_id_t dev_type)
+{
+	int dev_idx = dev_type - XLP2XX_CLKDEVICE_NAE;
+	NLM_HALT_IF(dev_idx<0);
+	return  1<< (( nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV_REG) >> (dev_idx*2) ) & 0x3);
+}	
+
+uint64_t nlm_hal_xlp2xx_get_pllfreq_dyn(int node, uint8_t pll_type)
+{
+        uint32_t pll_mult = 0; /* [5:0] */
+        uint64_t ref_clk_num;
+	uint32_t ref_clk_den;
+        uint32_t reg_ctrl;
+	int plf = xlp2xx_get_plf(node)+1;
+        switch(pll_type)
+        {
+                case CORE0_PLL:
+                case CORE1_PLL:
+                        reg_ctrl = XLP2XX_CORE0_PLL_CTRL1+pll_type*4;
+                break;
+                case SYS_PLL:
+                case DMC_PLL:
+                case DEV0_PLL:
+                case DEV1_PLL:
+                case DEV2_PLL:
+                        reg_ctrl = XLP2XX_SYS_PLL_CTRL1+(pll_type-SYS_PLL)*4;
+                break;
+                default:
+                        nlm_print("Unknown PLL type:%d\n", pll_type);
+                        return 0;
+        }
+        pll_mult = nlm_hal_read_sys_reg(node, reg_ctrl) & (0x3f);
+        ref_clk_num =  (REF_CLK_NUM_100 * pll_mult);
+        ref_clk_den = REF_CLK_DEN;
+        NLM_HAL_DO_DIV(ref_clk_num, ref_clk_den);
+        ref_clk_num +=  REF_CLK_NUM_400;
+
+        if(pll_type != DMC_PLL) {
+		NLM_HAL_DO_DIV(ref_clk_num, plf);
+	}
+
+        return ref_clk_num;
+}
+
+uint64_t nlm_hal_xlp2xx_set_pllfreq_dyn(int node, uint8_t pll_type, uint64_t freq)
+{
+        /*Target PLL output frequency; 400 MHz + (33.333 MHz x [5:0]).*/
+	uint32_t pll_mult = 0; /* [5:0] */
+	uint64_t clk_base_freq_num = 100*1000000;
+	uint32_t clk_base_freq_den = 3;
+	uint32_t reg_ctrl,reg_chg,chg_mask;
+	int plf = xlp2xx_get_plf(node)+1;
+
+	if(pll_type!=DMC_PLL)
+		freq*=plf;
+
+	if(freq<400*1000000){
+	        nlm_print("Freq for PLL cant be less than 400 Mhz\n");
+	        return 0;
+	}
+	freq = clk_base_freq_den * (freq - 400*1000000);
+	NLM_HAL_DO_DIV(freq, clk_base_freq_num);
+	pll_mult = freq;
+        switch(pll_type)
+        {
+                case CORE0_PLL:
+                case CORE1_PLL:
+                        reg_ctrl = XLP2XX_CORE0_PLL_CTRL1+pll_type*4;
+                        reg_chg  = XLP2XX_CPU_PLL_CHG_CTRL;
+                        chg_mask = 1<<(pll_type-CORE0_PLL);
+                break;
+                case SYS_PLL:
+                case DMC_PLL:
+                case DEV0_PLL:
+                case DEV1_PLL:
+                case DEV2_PLL:
+                        reg_ctrl = XLP2XX_SYS_PLL_CTRL1+(pll_type-SYS_PLL)*4;
+                        reg_chg  = XLP2XX_SYS_PLL_CHG_CTRL;
+                        chg_mask = 1<<(pll_type-SYS_PLL);
+                break;
+                default:
+                        nlm_print("Unknown PLL type:%d\n", pll_type);
+                        return 0;
+        }
+
+        nlm_hal_write_sys_reg(node, reg_ctrl, pll_mult);
+        nlm_hal_write_sys_reg(node, reg_chg,  chg_mask);
+        while(nlm_hal_read_sys_reg(node, reg_chg) & chg_mask);
+
+	/*freq = nlm_hal_xlp2xx_get_pll_out_frq(node, pll_type); */
+	/*nlm_print("pll out freq:%dMHz\n", (uint32_t)freq/1000000); */
+
+	freq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, pll_type);
+	return freq;
+}
+
+uint64_t xlp2xx_get_ref_clk(int node, uint64_t* ref_clk_num, uint32_t* ref_clk_den)
+{
+	uint64_t frq_num;
+	uint32_t frq_den;
+	uint32_t rcs = xlp2xx_get_rcs(node);
+	switch(rcs) {
+		case 0x0:
+			frq_num = REF_CLK_NUM_200;
+			frq_den = REF_CLK_DEN3;
+		break;	
+		case 0x1:
+			frq_num = REF_CLK_NUM_100;
+			frq_den = REF_CLK_DEN1;
+		break;	
+		case 0x2:
+			frq_num = REF_CLK_NUM_125;
+			frq_den = REF_CLK_DEN1;
+		break;	
+		case 0x3:
+		default:
+			frq_num = REF_CLK_NUM_400;
+			frq_den = REF_CLK_DEN3;
+		break;	
+	}
+	*ref_clk_num = frq_num;
+	*ref_clk_den = frq_den;
+	NLM_HAL_DO_DIV(frq_num, frq_den);
+	return frq_num;	
+}
+
+/* freq_out = ( ref_freq/2 * (6 + ctrl2[7:0]) + ctrl2[20:8]/2^13 ) / ((2^ctrl0[7:5]) * Table(ctrl0[26:24]))
+ * Table.ctrl0[26:24]
+ * ------------------
+ *  0: 1
+ *  1: 2
+ *  3: 4
+ *  7: 8
+ *  6: 16
+ */
+uint64_t nlm_hal_xlp2xx_get_pll_out_frq(int node, uint8_t pll_type)
+{
+	uint32_t vco_po_div, pll_post_div, mdiv;
+	uint64_t ref_frq_num, pll_out_freq_num, two13, fdiv;
+	uint32_t ref_frq_den, pll_out_freq_den;
+        uint32_t reg_ctrl0, reg_ctrl2;
+        uint32_t ctrl0, ctrl2;
+	
+        switch(pll_type)
+        {
+                case CORE0_PLL:
+                case CORE1_PLL:
+                        reg_ctrl0 = XLP2XX_CORE0_PLL_CTRL0+pll_type*4;
+                        reg_ctrl2 = XLP2XX_CORE0_PLL_CTRL2+pll_type*4;
+                break;
+                case SYS_PLL:
+                case DMC_PLL:
+                case DEV0_PLL:
+                case DEV1_PLL:
+                case DEV2_PLL:
+                        reg_ctrl0 = XLP2XX_SYS_PLL_CTRL0+(pll_type-SYS_PLL)*4;
+                        reg_ctrl2 = XLP2XX_SYS_PLL_CTRL2+(pll_type-SYS_PLL)*4;
+                break;
+                default:
+                        nlm_print("Unknown PLL type:%d\n", pll_type);
+                        return 0;
+        }
+
+	xlp2xx_get_ref_clk(node, &ref_frq_num, &ref_frq_den);
+	ctrl0 = nlm_hal_read_sys_reg(node, reg_ctrl0);
+	ctrl2 = nlm_hal_read_sys_reg(node, reg_ctrl2);
+
+	vco_po_div = (ctrl0>>5) & 0x7;
+	pll_post_div = (ctrl0>>24) & 0x7;
+	mdiv = ctrl2 & 0xff;
+	fdiv = (ctrl2>>8) & 0xfff;
+
+	switch(pll_post_div) {
+	    case 1: pll_post_div=2; break;
+	    case 3: pll_post_div=4; break;
+	    case 7: pll_post_div=8; break;
+	    case 6: pll_post_div=16; break;
+	    case 0:
+	    default: 
+		    pll_post_div=1;
+		    break;
+	}
+
+	two13 = 1<<13;
+	NLM_HAL_DO_DIV(fdiv, two13);
+	pll_out_freq_num = ((ref_frq_num>>1) * (6 + mdiv) ) + fdiv;
+	pll_out_freq_den = (1<<vco_po_div) * pll_post_div * ref_frq_den;
+
+	if(pll_out_freq_den>0) {
+		NLM_HAL_DO_DIV(pll_out_freq_num, pll_out_freq_den);
+	}
+	return pll_out_freq_num;
+}
+
+uint64_t nlm_hal_xlp2xx_get_clkdev_frq(int node, soc_device_id_t dev_type)
+{
+	uint64_t frq = 0, ref_clk_num;
+	uint32_t ref_clk_den;
+	uint8_t div = xlp2xx_get_clkdev_div(node, dev_type);
+	xlp2xx_clkdev_sel_t pll_sel = xlp2xx_get_clk_dev_sel(node, dev_type);
+
+	switch(pll_sel)
+	{
+		case SEL_REF_CLK:
+			frq = xlp2xx_get_ref_clk(node, &ref_clk_num, &ref_clk_den);
+		break;
+		case SEL_DEV0PLL:
+			frq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, DEV0_PLL);
+		break;
+		case SEL_DEV1PLL:
+			frq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, DEV1_PLL);
+		break;
+		case SEL_DEV2PLL:
+			frq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, DEV2_PLL);
+		break;
+		default:
+		break;
+	}
+	NLM_HAL_DO_DIV(frq, div);
+	return frq;
+}
+
+uint64_t nlm_hal_xlp2xx_set_clkdev_frq(int node, soc_device_id_t dev_type, uint64_t new_frq)
+{
+	uint64_t frq;
+	uint8_t new_div, div;
+	xlp2xx_clkdev_sel_t pll_sel;
+
+	pll_sel = xlp2xx_get_clk_dev_sel(node, dev_type);
+	div = xlp2xx_get_clkdev_div(node, dev_type);
+	frq = nlm_hal_xlp2xx_get_clkdev_frq(node, dev_type);
+
+	/* new_frq*new_div=frq*div
+	 *  new_div = frq*div/new_frq;
+	 */
+	new_div = fuzzy_divider(frq*div, new_frq);
+	switch (new_div)
+	{
+		case 1:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_BYPASS);
+		break;
+		case 2:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV2);
+		break;
+		case 4:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV4);
+		break;
+		case 8:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV8);
+		break;
+		default:
+		break;
+	}
+	frq = nlm_hal_xlp2xx_get_clkdev_frq(node, dev_type);
+	return frq;
+}
+
+/**
+ * @returns true if reference clock is 133MHz
+ */
+int nlm_hal_is_ref_clk_133MHz(void)
+{
+	if(is_nlm_xlp2xx())
+		return 3 == xlp2xx_get_rcs(0);
+	else {
+		uint32_t reg = nlm_hal_read_sys_reg(0, POWER_ON_RESET_CFG);
+		uint8_t divr = (reg >> 8) & 0x3;
+		return  (divr==3);
+	}
+}
+
+const char* nlm_hal_xlp2xx_get_dev_name(soc_device_id_t dev) {
+	static char* name[] = {
+	"NAE",
+	"SAE",
+	"RSA",
+	"GDX",
+	"CMP",
+	"NAND",
+	"MMC",
+	"GBU",
+	"RGXF",
+	"RGXS",
+	"USB",
+	"PIC",
+	"NULL"
+	};
+	if(! ((dev>=XLP2XX_CLKDEVICE_NAE)&&(dev<=XLP2XX_CLKDEVICE_PIC)))
+	{
+		dev = XLP2XX_CLKDEVICE_NULL;
+	}
+	return name[dev-XLP2XX_CLKDEVICE_NAE];
+}
+
+
+xlp2xx_soc_freq_s xlp2xx_tbl_freq[2] = {
+	/* slow freq for low voltage*/
+      { .nae = 250,
+	.sae = 250,
+	.rsa = 250,
+	.gdx = 333,
+	.cmp = 333,
+	.nand = 133,
+	.mmc = 133,
+	.gbu = 133,
+	.rgxf = 250,
+	.rgxs = 200,
+	.usb = 167,
+	.pic = 200 },
+	/* high freq */
+      { .nae = 500,
+	.sae = 500,
+	.rsa = 500,
+	.gdx = 667,
+	.cmp = 667,
+	.nand = 133,
+	.mmc = 133,
+	.gbu = 133,
+	.rgxf = 500,
+	.rgxs = 450,
+	.usb = 167,
+	.pic = 400 },
+};
+
+void nlm_hal_adjust_soc_freqs(int node, int freq_sel)
+{
+	if(is_nlm_xlp2xx()) {
+	xlp2xx_soc_freq_s* freq;
+	freq = &xlp2xx_tbl_freq[freq_sel&0x1];
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_NAE, freq->nae*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_SAE, freq->sae*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_RSA, freq->rsa*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_GDX, freq->gdx*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_CMP, freq->cmp*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_NAND, freq->nand*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_MMC, freq->mmc*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_GBU, freq->gbu*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_RGXF, freq->rgxf*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_RGXS, freq->rgxs*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_USB, freq->usb*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_PIC, freq->pic*1000000);
+	}
+}
+
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/module.h>
+EXPORT_SYMBOL(nlm_hal_get_soc_clock_state);
+EXPORT_SYMBOL(nlm_hal_soc_clock_enable);
+EXPORT_SYMBOL(nlm_hal_soc_clock_disable);
+EXPORT_SYMBOL(nlm_hal_soc_clock_reset);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_set_clkdev_frq);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_get_clkdev_frq);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_get_pll_out_frq);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_get_dev_name);
+EXPORT_SYMBOL(nlm_hal_get_soc_freq);
+EXPORT_SYMBOL(nlm_hal_set_soc_freq);
+EXPORT_SYMBOL(nlm_hal_get_core_freq);
+EXPORT_SYMBOL(nlm_hal_set_core_freq);
+EXPORT_SYMBOL(nlm_hal_cpu_freq);
+EXPORT_SYMBOL(nlm_hal_is_ref_clk_133MHz);
+EXPORT_SYMBOL(nlm_hal_get_ref_clk_freq);
+EXPORT_SYMBOL(nlm_hal_adjust_soc_freqs);
+
+#endif
-- 
1.7.9.5

