From 21273eb62a72e51183a281b7091a24c8f44aec20 Mon Sep 17 00:00:00 2001
From: reshmic <reshmic@broadcom.com>
Date: Wed, 28 Nov 2012 09:59:01 +0530
Subject: [PATCH 734/761] bcm_xlp: SAE: crypto: Adding chip feature support

     nlm_crypto_fill_pkt_ctrl now takes one more argument enc/dec and does the
     3des key swap.
     Added ioctl call to get chip feature for openssl

Based on Broadcom SDK 2.3.

Signed-off-by: reshmic <reshmic@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/crypto/sae/cryptoapi.c |   10 +++++-----
 drivers/crypto/sae/cryptodev.h |   17 +----------------
 drivers/crypto/sae/nlmcrypto.h |   41 +++++++++++++++++++++++++++++-----------
 3 files changed, 36 insertions(+), 32 deletions(-)

diff --git a/drivers/crypto/sae/cryptoapi.c b/drivers/crypto/sae/cryptoapi.c
index 0ee7144..3f023e2 100644
--- a/drivers/crypto/sae/cryptoapi.c
+++ b/drivers/crypto/sae/cryptoapi.c
@@ -128,21 +128,21 @@ static inline int crypto_async_pop_msg(struct nlm_crypto_ctx *ctx, void **ctrl,
 * This should be called only once from every application.
 *
 * @return 
-*  - On sucess,  returns NLM_CRYPTO_OK. 
-*  - On failure, returns NLM_CRYPTO_ERROR.
+*  - On sucess,  returns nlm_crypto_init_params. 
+*  - On failure, returns NULL.
 *	  
 * @ingroup crypto
 */
-int nlm_crypto_lib_init(void)
+struct nlm_crypto_init_params *  nlm_crypto_lib_init(void)
 {
 	int rv;
 
 	if((rv = crypto_app_lib_init(&iparam)) < 0)
-		return rv;
+		return NULL;
 	
 	crypto_sync_lock = (cryptolock_t *)iparam.pcpu_sync_lock_ptr;
 
-	return NLM_CRYPTO_OK;
+	return &iparam;
 }
 
 /**
diff --git a/drivers/crypto/sae/cryptodev.h b/drivers/crypto/sae/cryptodev.h
index 7f18397..763ce5f 100644
--- a/drivers/crypto/sae/cryptodev.h
+++ b/drivers/crypto/sae/cryptodev.h
@@ -39,6 +39,7 @@
 #define NLM_CRYPTO_GET_RX_VC_NUMS 		_IOWR(NLM_CRYPTO_IOC, 3, unsigned int *)
 #define NLM_CRYPTO_GET_COMMON_SHM_ADDR_SZ 	_IOWR(NLM_CRYPTO_IOC, 4, unsigned long long *)
 #define NLM_CRYPTO_GET_SAE_VC_NUMS		_IOWR(NLM_CRYPTO_IOC, 5, unsigned int *)
+#define NLM_CRYPTO_GET_CHIP_FEATURE		_IOWR(NLM_CRYPTO_IOC, 6, unsigned int *)
 
 
 #ifndef XLP_CACHELINE_SIZE
@@ -117,22 +118,6 @@ struct nlm_crypto_ctx {
 };
 
 
-
-
-
-/* This should be provided by the application/os/hyperexec */
-struct nlm_crypto_init_params 
-{
-	int sae_rx_vc; /* async vc */
-	int sae_rx_sync_vc;
-	int sae_crypto_vc_base;
-	int sae_crypto_vc_limit;
-	int sae_rsa_vc_base;
-	int sae_rsa_vc_limit;
-	int pad[2];
-	unsigned long pcpu_sync_lock_ptr; /* if multiple threads per cpu is enabled */
-};
-
 extern int crypto_app_lib_init(struct nlm_crypto_init_params *);
 extern int crypto_app_lib_finish(void);
 
diff --git a/drivers/crypto/sae/nlmcrypto.h b/drivers/crypto/sae/nlmcrypto.h
index 3c204db..8d71aca 100755
--- a/drivers/crypto/sae/nlmcrypto.h
+++ b/drivers/crypto/sae/nlmcrypto.h
@@ -73,12 +73,9 @@ enum nlm_crypto_mode { NLM_CRYPTO_MODE_ASYNC = 1, NLM_CRYPTO_MODE_SYNC_EXLVC, NL
 /* seglen is 16 bits */
 #define NLM_CRYPTO_MAX_SEG_LEN (64 * 1024) 
 
-enum chip_specific_features { 
-	ZUC = 0x1, 
-	DES3_KEY_SWAP = 0x2
-};
-extern int chip_feature ;
-#define CHIP_SUPPORTS(a) ( chip_feature & a )  
+extern int nlm_crypto_chip_features;
+#define CHIP_SUPPORTS(a) ( nlm_crypto_chip_features & a )  
+
 
 #ifndef NLM_HAL_LINUX_KERNEL
 #define nlm_err_print(fmt, args...)  { \
@@ -398,6 +395,19 @@ struct nlm_crypto_pkt_seg_desc {
 	unsigned long long dst;
 };
 
+/* This should be provided by the application/os/hyperexec */
+struct nlm_crypto_init_params 
+{
+	int sae_rx_vc; /* async vc */
+	int sae_rx_sync_vc;
+	int sae_crypto_vc_base;
+	int sae_crypto_vc_limit;
+	int sae_rsa_vc_base;
+	int sae_rsa_vc_limit;
+	int sae_chip_features; 
+	int pad;
+	unsigned long pcpu_sync_lock_ptr; /* if multiple threads per cpu is enabled */
+};
 static inline int nlm_crypto_getnibble(unsigned char a) 
 { 
 	if (a >= 'a' && a <= 'f')
@@ -478,9 +488,12 @@ static inline int nlm_crypto_fill_pkt_ctrl(struct nlm_crypto_pkt_ctrl *ctrl,
 		enum nlm_cipher_algo cipheralg, enum nlm_cipher_mode ciphermode,
 		unsigned int keys_instr,
 		unsigned char *cipherkey, unsigned int cipherkeylen, 
-		unsigned char *hashkey,   unsigned int hashkeylen)
+		unsigned char *hashkey,   unsigned int hashkeylen, int enc)
 {
 	int taglen;
+
+	if( !CHIP_SUPPORTS(INIT_DONE))
+		return -1;
 	ctrl->desc0 = ccpu_to_be64(nlm_crypto_form_pkt_ctrl_desc(hmac, hashalg, hashmode, 
 			cipheralg, ciphermode, 0, 0, 0));
 	memset((char *)ctrl->key, 0, sizeof(ctrl->key));
@@ -489,6 +502,15 @@ static inline int nlm_crypto_fill_pkt_ctrl(struct nlm_crypto_pkt_ctrl *ctrl,
 			nlm_crypto_hex2bin((unsigned char *)ctrl->key, cipherkey, cipherkeylen);
 		else
 			memcpy((unsigned char *)ctrl->key, cipherkey, cipherkeylen);
+		
+		if ( (cipheralg == NLM_CIPHER_3DES) && (enc == 0 ) && (!CHIP_SUPPORTS(DES3_KEY_SWAP))) 
+		{
+			unsigned long long  * key = (unsigned long long  *)cipherkey;
+
+			ctrl->key[0] = key[2];
+			ctrl->key[1] = key[1];
+			ctrl->key[2] = key[0];
+		}
 	}
 	if(hashkey) {
 		if(keys_instr)
@@ -958,10 +980,7 @@ static inline void nlm_crypto_modify_cipher_clobber_l3_alloc(struct nlm_crypto_p
 #define SAE_ERROR(etype, msg0, msg1) (etype == 1 ? CRYPTO_ERROR(msg1) : RSA_ERROR(msg0))
 
 #define NLM_MAX_NODES           4
-
-extern unsigned long xlp_rsa_base;
-extern unsigned long xlp_sae_base[NLM_MAX_NODES];
-int nlm_crypto_lib_init(void);
+struct nlm_crypto_init_params *  nlm_crypto_lib_init(void);
 int nlm_crypto_lib_finish(void);
 nlm_crypto_ctx_t *nlm_crypto_open_sync_session(int sync_mode, int cpu, void *arg);
 nlm_crypto_ctx_t *nlm_crypto_open_async_session(int max_outstanding_reqs, 
-- 
1.7.10.4

