From ea39fd7064a3bfda02f4921fc04b67145923bd7f Mon Sep 17 00:00:00 2001
From: Om Narasimhan <onarasimhan@netlogicmicro.com>
Date: Tue, 7 Jun 2011 19:04:24 -0700
Subject: [PATCH 319/761] CPU frequency scaling outline

This patch enables XLP cpu frequency scaling using DFS. The driver handles only
XLP

Prints logical processor ids. This handles printing out cpu numbers (logical
numbers which are not discontiguous). Due to integer arithmetic and clock
approximation, frequency comparison won't yield exact matches.  Added code in
/proc/cpuinfo to print both logical and physical ids.

This commit provides the base framework for cpufrequency scaling. This commit
does not change the frequency per se, for you require userspace tools or a
default `ondemand` cpu governor for that. As such, these changes are transparent
to the user.

This commit replaces some include files with that of xloader.

As a note, this feature is not compiled as a part of standard configuration. As
such this commit is incomplete -- this is functional but not complete. The timer
interfacing and Schedululer interfacing has to be worked on and currently
broken before it can be enabled in the config.

Incorporated YongHong's comments.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                                  |    8 +-
 arch/mips/include/asm/mach-netlogic/xlp-mmu.h      |    3 +-
 arch/mips/include/asm/netlogic/xlp8xx/cpu.h        |  156 +++++++++++++++
 .../asm/netlogic/xlp8xx/cpu_control_macros.h       |   25 +++
 arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h    |  205 +++++++++++++++++++
 arch/mips/include/asm/smp.h                        |    6 +-
 arch/mips/kernel/proc.c                            |   14 +-
 arch/mips/netlogic/xlp/Makefile                    |    1 +
 arch/mips/netlogic/xlp/cpu_control.c               |  107 +++++++++-
 arch/mips/netlogic/xlp/cpu_control_asm.S           |    6 +-
 arch/mips/netlogic/xlp/cpu_control_macros.h        |  157 ---------------
 arch/mips/netlogic/xlp/smp.c                       |   26 +--
 arch/mips/netlogic/xlp/xlp-cpufreq.c               |  207 ++++++++++++++++++++
 13 files changed, 739 insertions(+), 182 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/xlp8xx/cpu.h
 create mode 100644 arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
 create mode 100644 arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h
 delete mode 100644 arch/mips/netlogic/xlp/cpu_control_macros.h
 create mode 100644 arch/mips/netlogic/xlp/xlp-cpufreq.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 46b05b6..6872c48 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -2644,7 +2644,6 @@ config BINFMT_ELF32
 endmenu
 
 menu "Power management options"
-
 config ARCH_HIBERNATION_POSSIBLE
 	def_bool y
 	depends on SYS_SUPPORTS_HOTPLUG_CPU || !SMP
@@ -2655,6 +2654,13 @@ config ARCH_SUSPEND_POSSIBLE
 
 source "kernel/power/Kconfig"
 
+config XLP_CPUFREQ
+	bool "XLP Cpu frequency scaling support"
+	depends on NLM_XLP
+	help
+		Enable Cpu frequency scaling on Netlogic XLP series of processors.
+	source "drivers/cpufreq/Kconfig"
+
 endmenu
 
 source "arch/mips/kernel/cpufreq/Kconfig"
diff --git a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
index 259fe18..48293d7 100644
--- a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
+++ b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
@@ -3,6 +3,7 @@
 
 #include <linux/percpu.h>
 #include <asm/mipsregs.h>
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 
 /* 
  * These numbers correspond to Cop0 Config6 reg 
@@ -82,8 +83,6 @@ static inline void nlm_unlock_l1(uint32_t core)
 
 #define NLM_XLP_L1_MAXWAY       2
 #define NLM_XLP_L1_MAXINDX      128
-#define LSU_DEBUG_DATA0         0x306
-#define LSU_DEBUG_ADDR          0x305
 
 static inline void nlm_flush_l1_dcache_line(uint32_t line)
 {
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/cpu.h b/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
new file mode 100644
index 0000000..e2bf0d3
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+ * reserved. Redistribution and use in source and binary forms, with 
+ * or without modification, are permitted provided that the following 
+ * conditions are met:
+ *
+ *	1. 	Redistributions of source code must retain the above copyright
+ *		notice, this list of conditions and the following disclaimer.
+ *
+ *	2. 	Redistributions in binary form must reproduce the above copyright
+ *		notice, this list of conditions and the following disclaimer in
+ *		the documentation and/or other materials provided with the
+ *		distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * --------------------------------#NETL_2#--------------------------------
+ */
+/* XLP CPU specific */
+
+#ifndef __XLP_CPU_H_
+#define __XLP_CPU_H_
+
+/* so that these need not 
+ * be included explicitly 
+
+#include "xlp_bridge.h"
+#include "xlp_i2c.h"
+#include "xlp_spi.h"
+#include "xlp_sys.h"
+#include "xlp_ddr.h"
+#include "xlp_gbu.h"
+#include "xlp_nand.h"
+#include "xlp_ici.h"
+ */
+
+#define CHIP_PID_XLP					0x00
+#define MAX_NODES						0x04
+
+/* CPU Internal Blocks specific to XLP .
+ * These are accessed using the mfcr/mtcr
+ * instructions. Blocks [0-5] are same for
+ * XLR and XLP
+ */
+#define CPU_BLOCKID_MAP					0x0a
+/* Offsets of interest from the 'MAP' Block */
+#define BLKID_MAP_THREADMODE			0x00 
+#define BLKID_MAP_EXT_EBASE_ENABLE		0x04 
+#define BLKID_MAP_CCDI_CONFIG			0x08
+#define BLKID_MAP_THRD0_CCDI_STATUS		0x0c	
+#define BLKID_MAP_THRD1_CCDI_STATUS		0x10
+#define BLKID_MAP_THRD2_CCDI_STATUS		0x14	
+#define BLKID_MAP_THRD3_CCDI_STATUS		0x18
+#define BLKID_MAP_THRD0_DEBUG_MODE		0x1c
+#define BLKID_MAP_THRD1_DEBUG_MODE		0x20
+#define BLKID_MAP_THRD2_DEBUG_MODE		0x24
+#define BLKID_MAP_THRD3_DEBUG_MODE		0x28
+#define BLKID_MAP_MISC_STATE			0x60
+#define BLKID_MAP_DEBUG_READ_CTL		0x64
+#define BLKID_MAP_DEBUG_READ_REG0		0x68
+#define BLKID_MAP_DEBUG_READ_REG1		0x6c
+
+#define CPU_BLOCKID_SCH				7
+#define CPU_BLOCKID_SCU				8
+#define CPU_BLOCKID_FPU				9
+
+/* ----------------------------------
+ *   XLP RESET Physical Address Map
+ * ----------------------------------
+ * PCI ECFG : 0x18000000 - 0x1bffffff 
+ * PCI CFG  : 0x1c000000 - 0x1cffffff 
+ * FLASH    : 0x1fc00000 - 0x1fffffff 
+ * ----------------------------------
+ */
+
+/* The DEFAULT_XLP_IO_BASE value is what is
+ * programmed in the NBU's (NorthBridge Unit) 
+ * ECFG_BAR register. The NBU itself is 
+ * accessible as [BDF:0,0,0].
+ */
+#ifdef __ASSEMBLY__
+#define DEFAULT_XLP_IO_BASE		0xffffffffb8000000ULL
+#define DEFAULT_XLP_IO_BASE_VIRT	0xb8000000	/* IO_BASE for Assembly macros */
+#else
+#define DEFAULT_XLP_IO_BASE		0xffffffffb8000000ULL
+#define DEFAULT_XLP_IO_BASE_VIRT	DEFAULT_XLP_IO_BASE
+#define DEFAULT_XLP_IO_BASE_PHYS	0x18000000
+#endif
+
+#ifdef NLM_HAL_LINUX_KERNEL		/* Hal requires phy add :-) */
+#define DEFAULT_CPU_IO_BASE		DEFAULT_XLP_IO_BASE_PHYS
+#else
+#define DEFAULT_CPU_IO_BASE		DEFAULT_XLP_IO_BASE_VIRT
+#endif
+
+#define CPU_IO_SIZE			(64<<20)/* Size of the ECFG Space */
+#define HDR_OFFSET			0x100 /* Skip 256 bytes of cfg. hdrs */
+
+#define NETL_VENDOR_ID			0x184e
+#define ICI_DEVICE_ID			0x1002
+
+/* The On-Chip functional blocks for XLP */
+
+/* ------------------------------------------------------------------------*/
+/* Accesses Based on Enhanced Configuration Mechanism					   */
+/* ------------------------------------------------------------------------*/
+/* Interface			|	Bus    |	Dev	|   Func   */
+/* ------------------------------------------------------------------------*/
+#define BRIDGE			(0x00<<20) | (0x00<<15) | (0x00<<12)
+#define ICI0			(0x00<<20) | (0x00<<15) | (0x01<<12)
+#define ICI1			(0x00<<20) | (0x00<<15) | (0x02<<12)
+#define ICI2			(0x00<<20) | (0x00<<15) | (0x03<<12)
+#define	PIC			(0x00<<20) | (0x00<<15) | (0x04<<12)
+#define UART0			(0x00<<20) | (0x06<<15) | (0x00<<12)
+#define UART1			(0x00<<20) | (0x06<<15) | (0x01<<12)
+#define I2C0			(0x00<<20) | (0x06<<15) | (0x02<<12)
+#define I2C1			(0x00<<20) | (0x06<<15) | (0x03<<12)
+#define	GPIO			(0x00<<20) | (0x06<<15) | (0x04<<12)
+#define SYS			(0x00<<20) | (0x06<<15) | (0x05<<12)
+#define	JTAG			(0x00<<20) | (0x06<<15) | (0x06<<12)
+#define	NOR			(0x00<<20) | (0x07<<15) | (0x00<<12)
+#define	NAND			(0x00<<20) | (0x07<<15) | (0x01<<12)
+#define	SPI			(0x00<<20) | (0x07<<15) | (0x02<<12)
+#define	MMC			(0x00<<20) | (0x07<<15) | (0x03<<12)
+/* same as NOR ? */
+#define GBU			(0x00<<20) | (0x07<<15) | (0x00<<12)
+/* ------------------------------------------------------------------------*/
+
+#define CPU_MMIO_OFFSET(y,x)	(DEFAULT_CPU_IO_BASE + (x) + \
+				HDR_OFFSET + (y<<18))
+
+#define DMC_MMIO_OFFSET(y,x)	(DEFAULT_CPU_IO_BASE + (0x200*x) \
+				HDR_OFFSET + (y<<18) + (BRIDGE) + 0x300)
+
+#ifndef __ASSEMBLY__
+#define cpu_io_mmio(node,offset)	((__u32 *)(DEFAULT_CPU_IO_BASE + \
+					(node<<18) + (offset) + HDR_OFFSET))
+
+#define dmc_io_mmio(node,offset)\
+	((__u32 *)(DEFAULT_CPU_IO_BASE + \
+	(node<<18) + (0x200*offset) + (BRIDGE) + 0x300 + HDR_OFFSET))
+
+#define ici_io_mmio(node,link)\
+	((__u32 *)(DEFAULT_CPU_IO_BASE + (ICI0) + \
+	(node<<18) + HDR_OFFSET + (link << 12) ) )
+#endif	/* __ASSEMBLY__ */
+#endif	/* __XLP_CPU_H_ */
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
new file mode 100644
index 0000000..24ec6f9
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
@@ -0,0 +1,25 @@
+#ifndef __CPUCONTROL_MACROS_H__
+#define __CPUCONTROL_MACROS_H__
+#include <asm/netlogic/xlp8xx/cpu.h>
+#include <asm/netlogic/xlp8xx/xlp_sys.h>
+#define CP0_EBASE	$15
+#define NMI_BASE    	0xffffffffbfc00000UL
+#define NMI_BASE_ASM   	0xbfc00000
+
+#define LSU_DEFEATURE 0x304
+#define LSU_DEBUG_ADDR  0x305
+#define LSU_DEBUG_DATA0	0x306
+#define MMU_SETUP 0x400
+#define SCHED_DEFEATURE 0x700
+
+#ifndef __ASSEMBLY__
+#define	 XLP_THREADS_PER_CORE	4
+#define  XLP_CORES_PER_NODE	7
+u32 get_cpu_freq(int);
+void enable_cpus(unsigned int, unsigned int);
+u32 get_core_dfs(int);
+u32 change_cpu_freq(int, int);
+#define get_cpu_freq_masked(cpu_num, mask)\
+	(get_cpu_freq(cpu_num) & (mask))
+#endif	// __ASSEMBLY__
+#endif /* __CPUCONTROL_MACROS_H__ */
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h b/arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h
new file mode 100644
index 0000000..43ab668
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+ * reserved. Redistribution and use in source and binary forms, with 
+ * or without modification, are permitted provided that the following 
+ * conditions are met:
+ *
+ *	1. 	Redistributions of source code must retain the above copyright
+ *		notice, this list of conditions and the following disclaimer.
+ *
+ *	2. 	Redistributions in binary form must reproduce the above copyright
+ *		notice, this list of conditions and the following disclaimer in
+ *		the documentation and/or other materials provided with the
+ *		distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * --------------------------------#NETL_2#--------------------------------
+ */
+#ifndef __XLP_SYS_H__
+#define __XLP_SYS_H__
+
+#define SYS_CHIPRESET_REG  0
+#define SYS_POWERONRESETCFG_REG  1
+#define SYS_EFUSEDEVICECFG0_REG  2
+#define SYS_EFUSEDEVICECFG1_REG  3
+#define SYS_EFUSEDEVICECFG2_REG  4
+#define SYS_EFUSEDEVICECFG3_REG  5
+#define SYS_EFUSEDEVICECFG4_REG  6
+#define SYS_EFUSEDEVICECFG5_REG  7
+#define SYS_EFUSEDEVICECFG6_REG  8
+#define SYS_EFUSEDEVICECFG7_REG  9
+#define SYS_PLLCTRL_REG  10
+#define SYS_CPURESET_REG  11
+#define SYS_CPUTHREADEN_REG  12
+#define SYS_CPUNONCOHERENTMODE_REG  13
+#define SYS_COREDFSDISCTRL_REG  14
+#define SYS_COREDFSRSTCTRL_REG  15
+#define SYS_COREDFSBYPCTRL_REG  16
+#define SYS_COREDFSPHACTRL_REG  17
+#define SYS_COREDFSDIVINCCTRL_REG  18
+#define SYS_COREDFSDIVDECCTRL_REG  19
+#define SYS_COREDFSDIVCTRL_REG  20
+#define SYS_SYSRESET_REG  21
+#define SYS_SYSDFSDISCTRL_REG  22
+#define SYS_SYSDFSRSTCTRL_REG  23
+#define SYS_SYSDFSBYPCTRL_REG  24
+#define SYS_SYSDFSDIVINCCTRL_REG  25
+#define SYS_SYSDFSDIVDECCTRL_REG  26
+#define SYS_SYSDFSDIVCTRL0_REG  27
+#define SYS_SYSDFSDIVCTRL1_REG  28
+#define SYS_CPUSENSEAMPDLY_REG  29
+#define SYS_SOCSENSEAMPDLY_REG  30
+#define SYS_SYSCTRL0_REG  31
+#define SYS_SYSCTRL1_REG  32
+#define SYS_TIMEOUTBSI_REG  33
+#define SYS_BYTESWAP_REG  34
+#define SYS_SYSVRMVID_REG  35
+#define SYS_SYSPWRRAMCMD_REG  36
+#define SYS_SYSPWRRAMADDR_REG  37
+#define SYS_SYSPWRRAMDATA0_REG  38
+#define SYS_SYSPWRRAMDATA1_REG  39
+#define SYS_SYSPWRRAMDATA2_REG  40
+#define SYS_SYSPWRUCODE_REG  41
+#define SYS_SYSPWRSTATUS0_REG  42
+#define SYS_SYSPWRSTATUS1_REG  43
+#define SYS_SYSPWRSTATUS2_REG  44
+#define SYS_SYSPWRSTATUS3_REG  45
+#define SYS_SYSPWRSTATUS4_REG  46
+#define SYS_SYSPWRSTATUS5_REG  47
+#define SYS_SYSPWRSTATUS6_REG  48
+#define SYS_SYSPWRSTATUS7_REG  49
+#define SYS_SYSSTATUS_REG  50
+#define SYS_SYSINTPOL_REG  51
+#define SYS_SYSINTTYPE_REG  52
+#define SYS_SYSINTSTATUS_REG  53
+#define SYS_SYSINTENABLE0_REG  54
+#define SYS_SYSINTENABLE1_REG  55
+#define SYS_SYSUCOSECC_REG  56
+#define SYS_SYSUCOMECC_REG  57
+#define SYS_SYSUCOADDR_REG  58
+#define SYS_SYSUCOINST_REG  59
+#define SYS_SYSMEMBISTGO0_REG  60
+#define SYS_SYSMEMBISTGO1_REG  61
+#define SYS_SYSMEMBISTGO2_REG  62
+#define SYS_SYSMEMBISTGO3_REG  63
+#define SYS_SYSMEMBISTGO4_REG  64
+#define SYS_SYSMEMBISTGO5_REG  65
+#define SYS_SYSMEMBISTGO6_REG  66
+#define SYS_SYSMEMBISTGO7_REG  67
+#define SYS_SYSMEMBISTGO8_REG  68
+#define SYS_SYSSCRATCH0_REG  69
+#define SYS_SYSSCRATCH1_REG  70
+#define SYS_SYSSCRATCH2_REG  71
+#define SYS_SYSSCRATCH3_REG  72
+
+#define SYS_PWRON_DIVF(x) ( (x >> 10) & 0x7f)
+#define SYS_PWRON_DIVR(x) ( (x >> 8) & 0x3)
+#define SYS_CORE_DFS(x,y) ( (x >> (y*4) ) & 0xf)
+
+#define SYS_DMC_DISABLE_MASK 0x40
+#define SYS_DMC_PLL_RESET(x) (x << 16)
+#define SYS_DMC_PLL_DIVR(x) (x << 17)
+#define SYS_DMC_PLL_DIVF(x) (x << 19)
+#define SYS_DMC_DIV(x) ( (x >> 24) & 0xf)
+#define SYS_DMC_PLL_RMW_MASK 0xffff
+
+#define RD_DMC_PLL_DIVR(x) ( (x >> 17) & 0x3)
+#define RD_DMC_PLL_DIVF(x) ( (x >> 19) & 0x7f)
+
+#define SYS_DMC_DIV_DEC_MASK 0x40
+#define SYS_DMC_DIV_INC_MASK 0x40
+
+#ifndef __ASSEMBLY__
+enum processor_sys
+{
+	SYS_CHIPRESET = 0,
+	SYS_POWERONRESETCFG = 1,
+	SYS_EFUSEDEVICECFG0 = 2,
+	SYS_EFUSEDEVICECFG1 = 3,
+	SYS_EFUSEDEVICECFG2 = 4,
+	SYS_EFUSEDEVICECFG3 = 5,
+	SYS_EFUSEDEVICECFG4 = 6,
+	SYS_EFUSEDEVICECFG5 = 7,
+	SYS_EFUSEDEVICECFG6 = 8,
+	SYS_EFUSEDEVICECFG7 = 9,
+	SYS_PLLCTRL = 10,
+	SYS_CPURESET = 11,
+	SYS_CPUTHREADEN = 12,
+	SYS_CPUNONCOHERENTMODE = 13,
+	SYS_COREDFSDISCTRL = 14,
+	SYS_COREDFSRSTCTRL = 15,
+	SYS_COREDFSBYPCTRL = 16,
+	SYS_COREDFSPHACTRL = 17,
+	SYS_COREDFSDIVINCCTRL = 18,
+	SYS_COREDFSDIVDECCTRL = 19,
+	SYS_COREDFSDIVCTRL = 20,
+	SYS_SYSRESET = 21,
+	SYS_SYSDFSDISCTRL = 22,
+	SYS_SYSDFSRSTCTRL = 23,
+	SYS_SYSDFSBYPCTRL = 24,
+	SYS_SYSDFSDIVINCCTRL = 25,
+	SYS_SYSDFSDIVDECCTRL = 26,
+	SYS_SYSDFSDIVCTRL0 = 27,
+	SYS_SYSDFSDIVCTRL1 = 28,
+	SYS_CPUSENSEAMPDLY = 29,
+	SYS_SOCSENSEAMPDLY = 30,
+	SYS_SYSCTRL0 = 31,
+	SYS_SYSCTRL1 = 32,
+	SYS_TIMEOUTBSI = 33,
+	SYS_BYTESWAP = 34,
+	SYS_SYSVRMVID = 35,
+	SYS_SYSPWRRAMCMD = 36,
+	SYS_SYSPWRRAMADDR = 37,
+	SYS_SYSPWRRAMDATA0 = 38,
+	SYS_SYSPWRRAMDATA1 = 39,
+	SYS_SYSPWRRAMDATA2 = 40,
+	SYS_SYSPWRUCODE = 41,
+	SYS_SYSPWRSTATUS0 = 42,
+	SYS_SYSPWRSTATUS1 = 43,
+	SYS_SYSPWRSTATUS2 = 44,
+	SYS_SYSPWRSTATUS3 = 45,
+	SYS_SYSPWRSTATUS4 = 46,
+	SYS_SYSPWRSTATUS5 = 47,
+	SYS_SYSPWRSTATUS6 = 48,
+	SYS_SYSPWRSTATUS7 = 49,
+	SYS_SYSSTATUS = 50,
+	SYS_SYSINTPOL = 51,
+	SYS_SYSINTTYPE = 52,
+	SYS_SYSINTSTATUS = 53,
+	SYS_SYSINTENABLE0 = 54,
+	SYS_SYSINTENABLE1 = 55,
+	SYS_SYSUCOSECC = 56,
+	SYS_SYSUCOMECC = 57,
+	SYS_SYSUCOADDR = 58,
+	SYS_SYSUCOINST = 59,
+	SYS_SYSMEMBISTGO0 = 60,
+	SYS_SYSMEMBISTGO1 = 61,
+	SYS_SYSMEMBISTGO2 = 62,
+	SYS_SYSMEMBISTGO3 = 63,
+	SYS_SYSMEMBISTGO4 = 64,
+	SYS_SYSMEMBISTGO5 = 65,
+	SYS_SYSMEMBISTGO6 = 66,
+	SYS_SYSMEMBISTGO7 = 67,
+	SYS_SYSMEMBISTGO8 = 68,
+	SYS_SYSMEMBISTGO9 = 69,
+	SYS_SYSMEMBISTGO10 = 70,
+	SYS_SYSMEMBISTGO11 = 71,
+	SYS_SYSMEMBISTGO12 = 72,
+	SYS_SYSSCRATCH0 = 73,
+	SYS_SYSSCRATCH1 = 74,
+	SYS_SYSSCRATCH2 = 75,
+	SYS_SYSSCRATCH3 = 76
+};
+#endif
+
+#endif /* __XLP_SYS_H__ */
diff --git a/arch/mips/include/asm/smp.h b/arch/mips/include/asm/smp.h
index ed318ce..25eeb28 100644
--- a/arch/mips/include/asm/smp.h
+++ b/arch/mips/include/asm/smp.h
@@ -35,8 +35,10 @@ extern cpumask_t cpu_sibling_map[];
 
 #define raw_smp_processor_id() (current_thread_info()->cpu)
 
-/* Map from cpu id to sequential logical cpu number.  This will only
-   not be idempotent when cpus failed to come on-line.  */
+/* Map from cpu id to sequential logical cpu number.  This will
+   not be idempotent when cpus failed to come on-line as well as
+   when you have holes in the online cpu mask
+   if you use FDT, `onlinemask' */
 extern int __cpu_number_map[NR_CPUS];
 #define cpu_number_map(cpu)  __cpu_number_map[cpu]
 
diff --git a/arch/mips/kernel/proc.c b/arch/mips/kernel/proc.c
index 4ff3e2b..ce010ae 100644
--- a/arch/mips/kernel/proc.c
+++ b/arch/mips/kernel/proc.c
@@ -13,6 +13,9 @@
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
 #include <asm/mips_machine.h>
+#ifdef CONFIG_NLM_XLP
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
+#endif
 
 unsigned int vced_count, vcei_count;
 
@@ -39,13 +42,20 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 				   mips_get_machine_name());
 	}
 
+#ifdef CONFIG_NLM_XLP
+	seq_printf(m, "processor\t\t: %ld\n", (long)cpu_number_map(n));
+	/* x86 has physical id in /proc, does not hurt to include this */
+	seq_printf(m, "physical id\t\t: %ld\n", n);
+#else
 	seq_printf(m, "processor\t\t: %ld\n", n);
+#endif
 #ifdef CONFIG_NLM_COMMON
 	/* workaround for compiler warning */
 	version = fp_vers = 0;
 
-	seq_printf(m, "cpu model\t\t: %s %s\n", __cpu_name[n],
-		   (cpu_data[n].options & MIPS_CPU_FPU ? "  FPU " : "") );
+	seq_printf(m, "cpu model\t\t: %s %s @%dMHz\n", __cpu_name[n],
+		   (cpu_data[n].options & MIPS_CPU_FPU ? "  FPU " : ""),
+		   get_cpu_freq(n));
 #else
 	sprintf(fmt, "cpu model\t\t: %%s V%%d.%%d%s\n",
 	        cpu_data[n].options & MIPS_CPU_FPU ? "  FPU V%d.%d" : "");
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index c3f3a2f..9449750 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_SMP)       	+= smp.o
 
 obj-$(CONFIG_KGDB)      += nmi.o
 obj-$(CONFIG_NLM_XLP) += cop2.o
+obj-$(CONFIG_XLP_CPUFREQ) += xlp-cpufreq.o
 
 ifeq ($(CONFIG_XEN),y)
 obj-y += xenbootinfo.o
diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index d56fa1b..529d793 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -39,14 +39,13 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/interrupt.h>
 #include <asm/atomic.h>
 #include <asm/cacheflush.h>
-
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/hal/nlm_hal.h>
 
-#include "cpu_control_macros.h"
-
 #define XLP_ECFG_BASE           0x18000000
 #define XLP_SYS_DEV_BASE        0x35000
+#define PLL_REF_CLK_PS		7500
 
 /* temporary storage space for
  * stack pointers
@@ -127,6 +126,15 @@ static void enable_cores(unsigned int node, unsigned int cores_bitmap)
 	}
 }
 
+static inline int num_ones(unsigned long mask)
+{
+	int ret = 0;
+
+	if (!mask) return 0;
+	while ((mask &= (mask - 1))) ret++;
+	return (ret + 1);
+}
+
 int threads_to_enable = 0;
 /*
  * This function is called once for each node. However, it is executed
@@ -193,3 +201,96 @@ void enable_cpus(unsigned int node, unsigned int node_cpumask)
 
 	return;
 }
+
+EXPORT_SYMBOL(enable_cpus);
+/* Return period in femto-seconds.(1e-15 s)
+ */
+static u32 get_pll_period(int divf,int divr) {
+
+	u32 vco_fs;		/* vco in femto-seconds */
+	u32 pll_period_fs;	/* pll output in femto-seconds */
+
+	if (divr == 2) {
+		printk (KERN_ERR "Error! Illegal divr value %d!\n", divr);
+		return 0;
+	}
+	if ((divf < 11) || (divf > 91)) {
+		printk (KERN_ERR "Error! Illegal divf value %d!\n", divf);
+		return 0;
+	}
+
+	vco_fs = (((PLL_REF_CLK_PS * 1000) * (divr+1))/(4 * (divf+1)));
+	pll_period_fs  = vco_fs * 2; /* pll output is divided by 2 */
+
+	return pll_period_fs;
+}
+
+/* Return frequency in KHz
+ */
+static u32 get_pll_freq(int divf,int divr)
+{
+	uint64_t khz_freq;
+	uint64_t khz_mult = (1000ULL * 1000ULL * 1000ULL * 1000ULL); /* 1e12 */
+	u32 pll_period_fs = get_pll_period(divf,divr);
+
+	khz_freq   = khz_mult/((uint64_t) pll_period_fs);
+
+	return (u32) khz_freq;
+}
+
+/* Return frequency in KHz
+ */
+u32 get_cpu_freq(int cpu_num)
+{
+	volatile u32* mmio;
+	u32 pwron_rst_reg;
+	u32 core_dfs, divf, divr, dfs, core;
+	mmio = (volatile u32 *) cpu_io_mmio(cpu_num/32,SYS);
+
+	pwron_rst_reg = nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_POWERONRESETCFG);
+	core_dfs      = nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_COREDFSDIVCTRL);
+	core          = cpu_num >> 2;
+
+	divf = SYS_PWRON_DIVF(pwron_rst_reg);
+	divr = SYS_PWRON_DIVR(pwron_rst_reg);
+	dfs  = SYS_CORE_DFS(core_dfs,core);
+
+	return (get_pll_freq(divf,divr)/(dfs + 1));
+}
+
+EXPORT_SYMBOL(get_cpu_freq);
+
+u32 get_core_dfs(int cpu_num)
+{
+	u32 core_dfs, dfs;
+	volatile u32 *mmio;
+
+	mmio = (volatile u32 *) cpu_io_mmio(cpu_num/32,SYS);
+	core_dfs = nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_COREDFSDIVCTRL);
+	dfs  = SYS_CORE_DFS(core_dfs, (cpu_num >> 2));
+	return dfs;
+}
+
+EXPORT_SYMBOL(get_core_dfs);
+
+/*
+ * @cpu_num : # of the cpu
+ * @dec	: whether to decrement frequency
+ * NOTE: If frequency to be decremented, multiplier should be incremented
+ */
+u32 change_cpu_freq(int cpu_num, int dec)
+{
+	volatile u32 *mmio;
+	u32 val;
+	/* INC freq --> DEC multiplier */
+	u32 reg = (dec == 1) ? SYS_COREDFSDIVINCCTRL: SYS_COREDFSDIVDECCTRL;
+
+	mmio = (volatile u32 *) cpu_io_mmio(cpu_num/32,SYS);
+	val = (0x1 << (cpu_num >> 2));
+	nlm_hal_write_32bit_reg((uint64_t)mmio, reg, val);
+	//printk("NLM: %#x\n", nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_COREDFSDIVCTRL));
+	return 0;
+}
+
+EXPORT_SYMBOL(change_cpu_freq);
+
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index 949b3f1..4d9a0a7 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -6,7 +6,7 @@
 #include <asm/asmmacro.h>
 
 #include <asm/mach-netlogic/kernel-entry-init.h>
-#include "cpu_control_macros.h"
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 
 	.macro  prog_c0_status set clr
 	.set 	push
@@ -130,11 +130,11 @@ EXPORT(reset_entry)
 	li      t1, 0x1
 	sll     t0, t1, t0
 	nor     t0, t0, zero
-	dla     t2, CPU_MMIO_OFFSET(SYS)
+	dla     t2, CPU_MMIO_OFFSET(0, SYS)
 	add	t2, t2, t3  #get node based SYS offset
 	lw      t1, (SYS_CPUNONCOHERENTMODE_REG << 2)(t2)
 	and     t1, t1, t0
-	sw      t1, (SYS_CPUNONCOHERENTMODE_REG << 2)(t2)
+	sw      t1, (SYS_CPUNONCOHERENTMODE_REG<< 2)(t2)
 
 	/* read back to ensure complete */
 	lw      t1, (SYS_CPUNONCOHERENTMODE_REG << 2)(t2)
diff --git a/arch/mips/netlogic/xlp/cpu_control_macros.h b/arch/mips/netlogic/xlp/cpu_control_macros.h
deleted file mode 100644
index c66017e..0000000
--- a/arch/mips/netlogic/xlp/cpu_control_macros.h
+++ /dev/null
@@ -1,157 +0,0 @@
-#ifndef __CPUCONTROL_MACROS_H__
-#define __CPUCONTROL_MACROS_H__
-
-#define CP0_EBASE	$15
-#define CHIP_PID_XLP    0x00
-#define NMI_BASE    	0xffffffffbfc00000UL
-#define NMI_BASE_ASM   	0xbfc00000
-
-/* CPU Internal Blocks specific to XLP .
- * These are accessed using the mfcr/mtcr
- * instructions. Blocks [0-5] are same for
- * XLR and XLP
- */
-#define CPU_BLOCKID_MAP                         0x0a
-/* Offsets of interest from the 'MAP' Block */
-#define BLKID_MAP_THREADMODE                    0x00 
-#define BLKID_MAP_EXT_EBASE_ENABLE              0x04 
-#define BLKID_MAP_CCDI_CONFIG                   0x08
-#define BLKID_MAP_THRD0_CCDI_STATUS             0x0c    
-#define BLKID_MAP_THRD1_CCDI_STATUS             0x10
-#define BLKID_MAP_THRD2_CCDI_STATUS             0x14    
-#define BLKID_MAP_THRD3_CCDI_STATUS             0x18
-#define BLKID_MAP_THRD0_DEBUG_MODE              0x1c
-#define BLKID_MAP_THRD1_DEBUG_MODE              0x20
-#define BLKID_MAP_THRD2_DEBUG_MODE              0x24
-#define BLKID_MAP_THRD3_DEBUG_MODE              0x28
-#define BLKID_MAP_MISC_STATE                    0x60
-#define BLKID_MAP_DEBUG_READ_CTL                0x64
-#define BLKID_MAP_DEBUG_READ_REG0               0x68
-#define BLKID_MAP_DEBUG_READ_REG1               0x6c
-
-#define CPU_BLOCKID_SCH                         7
-#define CPU_BLOCKID_SCU                         8
-#define CPU_BLOCKID_FPU                         9
-
-#define LSU_DEFEATURE 0x304
-#define LSU_DEBUG_ADDR  0x305
-#define LSU_DEBUG_DATA0	0x306
-#define MMU_SETUP 0x400
-#define SCHED_DEFEATURE 0x700
-
-/* ----------------------------------
- *   XLP RESET Physical Address Map
- * ----------------------------------
- * PCI ECFG : 0x18000000 - 0x1bffffff 
- * PCI CFG  : 0x1c000000 - 0x1cffffff 
- * FLASH    : 0x1fc00000 - 0x1fffffff 
- * ----------------------------------
- */
-
-/* 
- * The DEFAULT_XLP_IO_BASE value is what is
- * programmed in the NBU's (NorthBridge Unit) 
- * ECFG_BAR register. The NBU itself is 
- * accessible as [BDF:0,0,0].
- */
-#define DEFAULT_XLP_IO_BASE       0xffffffffb8000000ULL
-#define DEFAULT_XLP_IO_BASE_VIRT  0xffffffffb8000000      /* IO_BASE for Assembly macros */
-#define DEFAULT_CPU_IO_BASE       DEFAULT_XLP_IO_BASE
-#define DEFAULT_CPU_IO_BASE_VIRT  DEFAULT_XLP_IO_BASE_VIRT
-#define CPU_IO_SIZE               (64<<20)        /* Size of the ECFG Space      */
-#define HDR_OFFSET                0x100           /* Skip 256 bytes of cfg. hdrs */
-
-/* The On-Chip functional blocks for XLP */
-
-/* --------------------------------------------------------------*/
-/* Accesses Based on Enhanced Configuration Mechanism            */
-/* --------------------------------------------------------------*/
-/* Interface | Bus          | Dev       |  Func                  */
-/* --------------------------------------------------------------*/
-#define        BRIDGE        (0x00<<20) | (0x00<<15) | (0x00<<12)
-#define        PIC           (0x00<<20) | (0x00<<15) | (0x04<<12)
-#define        CMS           (0x00<<20) | (0x04<<15) | (0x00<<12)
-#define        UART0         (0x00<<20) | (0x06<<15) | (0x00<<12)
-#define        UART1         (0x00<<20) | (0x06<<15) | (0x01<<12)
-#define        I2C0          (0x00<<20) | (0x06<<15) | (0x02<<12)
-#define        I2C1          (0x00<<20) | (0x06<<15) | (0x03<<12)
-#define        GPIO          (0x00<<20) | (0x06<<15) | (0x04<<12)
-#define        SYS           (0x00<<20) | (0x06<<15) | (0x05<<12)
-#define        JTAG          (0x00<<20) | (0x06<<15) | (0x06<<12)
-#define        NOR           (0x00<<20) | (0x07<<15) | (0x00<<12)
-#define        NAND          (0x00<<20) | (0x07<<15) | (0x01<<12)
-#define        SPI           (0x00<<20) | (0x07<<15) | (0x02<<12)
-#define        MMC           (0x00<<20) | (0x07<<15) | (0x03<<12)
-
-#define CPU_MMIO_OFFSET(x) (DEFAULT_CPU_IO_BASE_VIRT + (x) + HDR_OFFSET)
-
-
-#define SYS_CHIPRST_REG                 0
-#define SYS_PWRONRSTCFG0_REG            1
-#define SYS_EFUSEDEV_CFG0_REG           2
-#define SYS_EFUSEDEV_CFG1_REG           3
-#define SYS_EFUSEDEV_CFG2_REG           4
-#define SYS_EFUSEDEV_CFG3_REG           5
-#define SYS_EFUSEDEV_CFG4_REG           6
-#define SYS_EFUSEDEV_CFG5_REG           7
-#define SYS_EFUSEDEV_CFG6_REG           8
-#define SYS_EFUSEDEV_CFG7_REG           9 
-#define SYS_PLLCTRL_REG                 10
-#define SYS_CPURST_REG                  11
-#define SYS_CPUTHREADEN_REG             12
-#define SYS_CPUNONCOHERENTMODE_REG      13
-#define SYS_COREDFSDISCTRL_REG          14
-#define SYS_COREDFSRSTCTRL_REG          15
-#define SYS_COREDFSBYPCTRL_REG          16
-#define SYS_COREDFSPHACTRL_REG          17
-#define SYS_COREDFSDIVCTRL_REG          18
-#define SYS_SYSRST_REG                  19
-#define SYS_SYSDFSDISCTRL_REG           20
-#define SYS_SYSDFSRSTCTRL_REG           21
-#define SYS_SYSDFSBYPCTRL_REG           22
-#define SYS_SYSDFSDIVCTRL_REG           23
-#define SYS_DMCDFSCTRL_REG              24
-
-#ifndef __ASSEMBLY__
-
-static inline int num_ones(unsigned long mask)
-{
-	int  nones;
-	for (nones = 0; mask; mask >>= 1) {
-		if (mask & 0x1)
-			++nones;
-	}
-	return nones;
-}
-
-enum processor_sys
-{
-	SYS_CHIPRST                     = 0,
-	SYS_PWRONRSTCFG0                = 1,
-	SYS_EFUSEDEV_CFG0               = 2,
-	SYS_EFUSEDEV_CFG1               = 3,
-	SYS_EFUSEDEV_CFG2               = 4,
-	SYS_EFUSEDEV_CFG3               = 5,
-	SYS_EFUSEDEV_CFG4               = 6,
-	SYS_EFUSEDEV_CFG5               = 7,
-	SYS_EFUSEDEV_CFG6               = 8,
-	SYS_EFUSEDEV_CFG7               = 9, 
-	SYS_PLLCTRL                     = 10,
-	SYS_CPURST                      = 11,
-	SYS_CPUTHREADEN                 = 12,
-	SYS_CPUNONCOHERENTMODE          = 13,
-	SYS_COREDFSDISCTRL              = 14,
-	SYS_COREDFSRSTCTRL              = 15,
-	SYS_COREDFSBYPCTRL              = 16,
-	SYS_COREDFSPHACTRL              = 17,
-	SYS_COREDFSDIVCTRL              = 18,
-	SYS_SYSRST                      = 19,
-	SYS_SYSDFSDISCTRL               = 20,
-	SYS_SYSDFSRSTCTRL               = 21,
-	SYS_SYSDFSBYPCTRL               = 22,
-	SYS_SYSDFSDIVCTRL               = 23,
-	SYS_DMCDFSCTRL                  = 24
-};
-
-#endif
-#endif /* __CPUCONTROL_MACROS_H__ */
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index e6f802b..7b831d5 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -39,6 +39,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/interrupt.h>
 #include <asm/netlogic/xlp_hal_pic.h>
+#include <linux/module.h>
 
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
@@ -48,7 +49,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <asm/mach-netlogic/mmu.h>
 
-#include "cpu_control_macros.h"
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 
 struct smp_boot_info smp_boot;
 EXPORT_SYMBOL(smp_boot);
@@ -107,9 +108,8 @@ static void __cpuinit nlm_init_secondary(void)
 {
     /* Time init for this cpu is done in mips_clockevent_init() */
     nlm_smp_irq_init();
-
     enable_msgconfig_int();
-
+#ifdef CONFIG_NLM_XLP_A0_WORKAROUNDS
     /* Workaround for XLP A0 Multi-Node bug */
     {
 	    int cpu = hard_smp_processor_id();
@@ -119,7 +119,7 @@ static void __cpuinit nlm_init_secondary(void)
 		    nlm_common_timer_setup();
 	    }
     }
-
+#endif
     /* Enable vc interupts for this thread*/
     nlm_enable_vc_intr();
 }
@@ -162,14 +162,16 @@ void __init nlm_smp_setup(void)
 
 	/* Initialize maps */
 	for (i = 0; i < NR_CPUS; i++) {
-		__cpu_number_map[i] = 0;
-		__cpu_logical_map[i] = boot_cpu;
+		__cpu_number_map[i] = NR_CPUS + 1; /* Set to invalid value */
+		__cpu_logical_map[i] = NR_CPUS + 1; /* Set to invalid value */
 	}
 
 	/* Setup map for master cpu */
 	__cpu_number_map[boot_cpu] = 0;
 	__cpu_logical_map[0] = boot_cpu;
 	num_cpus = 1;
+	cpumask_clear(&cpu_possible_map);
+	cpumask_clear(&cpu_present_map);
 	cpu_set(0, cpu_possible_map);
 
 	/* Setup map for other cpus */
@@ -178,19 +180,16 @@ void __init nlm_smp_setup(void)
 		if (i == boot_cpu) continue;
 
 		if (cpumask_test_cpu(i, &fdt_cpumask)) {
-
 			__cpu_number_map[i] = num_cpus;
 			__cpu_logical_map[num_cpus] = i;
-			cpu_set(num_cpus, cpu_possible_map);
-
+			cpu_data[i].core = (int) (i/XLP_THREADS_PER_CORE);
 			num_cpus++;
 		}
 	}
 
-	cpu_present_map = cpu_possible_map;
-
+	cpumask_copy(&cpu_present_map, &fdt_cpumask);
+	cpumask_copy(&cpu_possible_map, &cpu_present_map);
 	cpumask_scnprintf(buf, CPUMASK_BUF, &fdt_cpumask);
-	printk("FDT CPU map %s\n", buf);
 	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_possible_map);
 	printk("Possible/Present CPU map %s\n", buf);
 
@@ -223,6 +222,9 @@ static inline void config_mmu(void)
 	);
 }
 
+/*
+ * this function requires cpu_present_map
+ */
 int wakeup_secondary_cpus(void)
 {
 	cpumask_t mask32;
diff --git a/arch/mips/netlogic/xlp/xlp-cpufreq.c b/arch/mips/netlogic/xlp/xlp-cpufreq.c
new file mode 100644
index 0000000..393cc27
--- /dev/null
+++ b/arch/mips/netlogic/xlp/xlp-cpufreq.c
@@ -0,0 +1,207 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/regulator/consumer.h>
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
+#include <asm/netlogic/cpumask.h>
+
+#define XLP_CPU_PER_NODE	4
+
+static spinlock_t freq_lock = SPIN_LOCK_UNLOCKED;
+static struct cpumask xlp_affected_cpus[NR_CPUS];
+/* The following are the possible devisors
+ * The first value need not be 2 always. Read Reset value from
+ * CORE_DFS_DIV_VALUE PRM 34.9.7.20
+ *
+ * This array contains frequency multipliers:
+ * Say, initial frequency is 1.2GHz and core_dfs reads 1,
+ * that means 1.2 GHz is the max (== 1.2 / ((core_dfs + 1)/2)).
+ * Then a range of 1.2GHz through 1.2/(15+1)/2 == 150MHz is available for
+ * scaling.
+ * Scaling range is limited to core_dfs@startup through xlp_divs[XLP_DIVS]
+ */
+#define XLP_DIVS 11
+#define XLP_FREQ_MASK	(0xfffffff0)
+static int xlp_divs[XLP_DIVS] = {1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 15};
+static struct cpufreq_frequency_table xlp_freq_table[XLP_DIVS + 1];
+
+static int xlp_cpufreq_verify_speed(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, xlp_freq_table);
+}
+
+static void setup_affected_cpus(struct cpumask map)
+{
+	/* Find out the number of cores. Read SYS, reg 0x42 bits 0-7,
+	 * PRM 34.9.7.3 */
+	u32 idx;
+	struct cpumask thr;
+	unsigned long flags;
+
+	cpumask_clear(&thr);
+	cpumask_set_cpu(0, &thr);
+	cpumask_set_cpu(1, &thr);
+	cpumask_set_cpu(2, &thr);
+	cpumask_set_cpu(3, &thr);
+
+	spin_lock_irqsave(&freq_lock, flags);
+	for (idx = 0; idx < NR_CPUS; idx++) {
+		cpumask_and(&xlp_affected_cpus[idx], &thr, &map);
+		if (((idx + 1) % XLP_THREADS_PER_CORE) == 0) {
+			cpumask_shift_left(&thr, &thr, XLP_THREADS_PER_CORE);
+		}
+	}
+	spin_unlock_irqrestore(&freq_lock, flags);
+	return;
+}
+
+#define XLP_CPU0	0
+__init static int build_cpufreq_table(struct cpufreq_frequency_table *t)
+{
+	unsigned long freq;
+	u32 divfs = get_core_dfs(XLP_CPU0);
+	int i, div_start = -1, j;
+
+	freq = get_cpu_freq_masked(XLP_CPU0, XLP_FREQ_MASK);	// In KHz
+	divfs = (divfs >> ((XLP_CPU0 & 0x1f) >> 2)) & 0xf;
+	for (i = 0; i < XLP_DIVS; i++) {
+		if (xlp_divs[i] == divfs){
+			div_start = i;
+			break;
+		}
+	}
+	if (div_start == -1) {
+		return -EFAULT;
+	}
+	for (i = 0, j = div_start; j < XLP_DIVS; i++, j++) {
+		xlp_freq_table[i].index = j;
+		xlp_freq_table[i].frequency = (int)(freq * 2 / (xlp_divs[j] + 1));
+	}
+	xlp_freq_table[i].frequency = CPUFREQ_TABLE_END;
+	xlp_freq_table[i].index = 0;
+	return 0;
+}
+
+static unsigned int xlp_cpufreq_get_speed(unsigned int cpu)
+{
+	return get_cpu_freq_masked(cpu, XLP_FREQ_MASK);
+}
+
+static int xlp_freq_set(struct cpufreq_frequency_table *from,
+		struct cpufreq_frequency_table *to, int cpu, int dec)
+{
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&freq_lock, flags);
+	for (i = from->index; i != to->index; ){
+			change_cpu_freq(cpu, dec);
+			/* To decrement frequency, INC index */
+			i = (dec == 1) ? (i + 1) : (i - 1);
+	}
+	spin_unlock_irqrestore(&freq_lock, flags);
+	return 0;
+}
+static int xlp_cpufreq_set_target(struct cpufreq_policy *policy,
+				      unsigned int target_freq,
+				      unsigned int relation)
+{
+	int ret;
+	unsigned int i = 0, tmp = 0, cpu;
+	struct cpufreq_freqs freq;
+	u32 cur_freq;
+	u32 start, end;
+
+	if (!policy) {
+		return -1;
+	}
+	if (target_freq < policy->min) {
+		target_freq = policy->min;
+	}
+	if (target_freq > policy->max) {
+		target_freq = policy->max;
+	}
+
+	ret = cpufreq_frequency_table_target(policy, xlp_freq_table,
+						target_freq, relation, &i);
+	if (ret < 0) {
+		fdebug("Cannot find a target frequency\n");
+		return ret;
+	}
+	start = policy->cpu & (~(XLP_CPU_PER_NODE - 1));
+	end = start + XLP_CPU_PER_NODE;
+	cur_freq = get_cpu_freq_masked(start, XLP_FREQ_MASK);
+	ret = cpufreq_frequency_table_target(policy, xlp_freq_table,
+					     cur_freq, relation, &tmp);
+	if (ret < 0) {
+		fdebug("Cannot find a source frequency\n");
+		return ret;
+	}
+	freq.old = xlp_freq_table[tmp].frequency;
+	freq.new = xlp_freq_table[i].frequency;
+	freq.cpu = policy->cpu;
+	freq.flags = 0;
+	if (freq.old == freq.new) {
+		return 0;
+	}
+	cpufreq_notify_transition(&freq, CPUFREQ_PRECHANGE);
+	ret = xlp_freq_set(&xlp_freq_table[tmp], &xlp_freq_table[i],
+			policy->cpu, (freq.old > freq.new));
+	cpufreq_notify_transition(&freq, CPUFREQ_POSTCHANGE);
+	if (ret != 0) {
+		fdebug("Setting cpufrequency failed\n");
+		return -EFAULT;
+	}
+	return 0;
+}
+
+__init static int xlp_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+	int ret;
+	unsigned long flags;
+
+	policy->cur = get_cpu_freq_masked(XLP_CPU0, XLP_FREQ_MASK);
+	if (xlp_freq_table == NULL) {
+		pr_err("cpufreq: No frequency information for this CPU\n");
+		return -ENODEV;
+	}
+	/* Pick a conservative guess in ns: */
+	policy->cpuinfo.transition_latency = 2 * 1000 * 1000;
+	spin_lock_irqsave(&freq_lock, flags);
+	cpumask_copy(policy->cpus, &xlp_affected_cpus[policy->cpu]);
+	spin_unlock_irqrestore(&freq_lock, flags);
+	ret = cpufreq_frequency_table_cpuinfo(policy, xlp_freq_table);
+	if (ret != 0) {
+		pr_err("cpufreq: Failed to configure frequency table: %d\n", ret);
+	}
+	return ret;
+}
+
+__exit static int xlp_cpufreq_driver_exit(struct cpufreq_policy *policy)
+{
+	return 0;
+}
+
+static struct cpufreq_driver xlp_cpufreq_driver = {
+	.owner		= THIS_MODULE,
+	.flags          = 0,
+	.verify		= xlp_cpufreq_verify_speed,
+	.target		= xlp_cpufreq_set_target,
+	.get		= xlp_cpufreq_get_speed,
+	.init		= xlp_cpufreq_driver_init,
+	.exit		= xlp_cpufreq_driver_exit,
+	.name		= "xlp-cpufreq",
+};
+
+static int __init xlp_cpufreq_init(void)
+{
+	setup_affected_cpus(cpu_present_map);
+	if (build_cpufreq_table(xlp_freq_table) < 0) {
+		return -EFAULT;
+	}
+	return cpufreq_register_driver(&xlp_cpufreq_driver);
+}
+module_init(xlp_cpufreq_init);
-- 
1.7.10.4

