From df72111b9e30ebd9eaad70981024253055101b93 Mon Sep 17 00:00:00 2001
From: Yongjun Zhang <yzhang@netlogicmicro.com>
Date: Thu, 7 Jul 2011 16:56:24 -0700
Subject: [PATCH 337/762] initial linux kernel change for xlp2xx pagewalker.

Based on Broadcom SDK 2.3.

Signed-off-by: Yongjun Zhang <yzhang@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/pgwalker.h |   23 +++++
 arch/mips/include/asm/mipsregs.h               |   15 +++
 arch/mips/netlogic/xlp/mmu.c                   |  124 +++++++++++++++++++++---
 arch/mips/netlogic/xlp/setup.c                 |   22 +++--
 4 files changed, 162 insertions(+), 22 deletions(-)

diff --git a/arch/mips/include/asm/mach-netlogic/pgwalker.h b/arch/mips/include/asm/mach-netlogic/pgwalker.h
index 855f900..29c5659 100644
--- a/arch/mips/include/asm/mach-netlogic/pgwalker.h
+++ b/arch/mips/include/asm/mach-netlogic/pgwalker.h
@@ -32,4 +32,27 @@ enum {
 
 extern void dump_pgwalker_config(void);
 
+/* pagewalker control register field offset and width */
+enum {
+  //offset, width pair
+  PWFIELD_BD_O  = 32, PWFIELD_BD_W  = 6,
+  PWFIELD_GD_O  = 24, PWFIELD_GD_W  = 6,
+  PWFIELD_UD_O  = 18, PWFIELD_UD_W  = 6,
+  PWFIELD_MD_O  = 12, PWFIELD_MD_W  = 6,
+  PWFIELD_PT_O  =  6, PWFIELD_PT_W  = 6,
+  PWFIELD_PTE_O =  0, PWFIELD_PTE_W = 6,
+
+  PWSIZE_BD_O  = 32, PWSIZE_BD_W  = 6,
+  PWSIZE_PS_O  = 30, PWSIZE_PS_W  = 1,
+  PWSIZE_GD_O  = 24, PWSIZE_GD_W  = 6,
+  PWSIZE_UD_O  = 18, PWSIZE_UD_W  = 6,
+  PWSIZE_MD_O  = 12, PWSIZE_MD_W  = 6,
+  PWSIZE_PT_O  =  6, PWSIZE_PT_W  = 6,
+  PWSIZE_PTE_O =  0, PWSIZE_PTE_W = 6,
+
+  PWCTL_PW_EN_O = 31, PWCTL_PW_EN_W = 1,
+
+  CFG4_FTLBPAGESIZE_O = 8, CFG4_FTLBPAGESIZE_W = 5
+};
+
 #endif
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index eca8b63..aadcea5 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -1175,6 +1175,21 @@ do {									\
 #define write_c0_brcm_sleepcount(val)	__write_32bit_c0_register($22, 7, val)
 
 /*
+ * xlp2xx pagewalker PW registers
+ */
+#define read_c0_pwbase()	__read_64bit_c0_register($5, 5)
+#define write_c0_pwbase(val)	__write_64bit_c0_register($5, 5, val)
+
+#define read_c0_pwfield()	__read_64bit_c0_register($5, 6)
+#define write_c0_pwfield(val)	__write_64bit_c0_register($5, 6, val)
+
+#define read_c0_pwsize()	__read_64bit_c0_register($5, 7)
+#define write_c0_pwsize(val)	__write_64bit_c0_register($5, 7, val)
+
+#define read_c0_pwctl()	__read_32bit_c0_register($6, 6)
+#define write_c0_pwctl(val)	__write_32bit_c0_register($6, 6, val)
+
+/*
  * Macros to access the floating point coprocessor control registers
  */
 #define read_32bit_cp1_register(source)                         \
diff --git a/arch/mips/netlogic/xlp/mmu.c b/arch/mips/netlogic/xlp/mmu.c
index dd7a002..f49de00 100644
--- a/arch/mips/netlogic/xlp/mmu.c
+++ b/arch/mips/netlogic/xlp/mmu.c
@@ -30,6 +30,7 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/netlogic/xlp.h>
+#include <asm/netlogic/hal/nlm_hal.h>
 
 #define READ_INHIBIT (1 << 31)
 #define EXEC_INHIBIT (1 << 30)
@@ -86,15 +87,15 @@ static void pgwalker_init(void)
 		put_cpu_var(pgd_bases);
 	}
 
-	/* 
+	/*
 	 * hardware page levels information:
-	 * 
+	 *
 	 * [15:8] no of top-most bits of vaddr used to form
 	 *        an index into the pgdirs table
 	 * [ 7:4] shift amount by which pfn (page frame number)
 	 *        needs to be left shifted for populating the
 	 *        entrylo0 and entrylo1 registers
-	 * [ 3:0] page table levels used. 32-bit kernels use 
+	 * [ 3:0] page table levels used. 32-bit kernels use
 	 *        pgd and pte levels, while 64-bits kernels
 	 *        use pgd, pmd, and pte
 	 */
@@ -117,7 +118,7 @@ static void pgwalker_init(void)
 	 * MIPS Linux currently does not use 4-level page tables
 	 * and hence it is not necessary to fill in pud information
 	 *
-	 * So, just fill in the PMD shift and mask information 
+	 * So, just fill in the PMD shift and mask information
 	 */
 	pgw_register_write_w(PGW_PMD_SHIFT, _PMD_SHIFT - _PMD_T_LOG2);
 	pgw_register_write_w(PGW_PMD_MASK, (_PTRS_PER_PMD - 1) << _PMD_T_LOG2);
@@ -144,10 +145,85 @@ static void pgwalker_init(void)
 	printk("Initialized Page Walker on cpu@%d\n", hard_smp_processor_id());
 }
 
+static void pgwalker_init_xlp2xx(void)
+{
+	int i = 0;
+	uint64_t pwbase_val = 0, pwfield_val = 0, pwsize_val = 0, bd_shift = 0;
+	uint32_t pwctl_val = 0;
+
+	if (!(tlb_config & ENABLE_PGWALKER)) {
+		/* disable pagewalker (PWCTL_PW_EN field was initialized to 0) */
+		write_c0_pwctl(pwctl_val);
+		return;
+	}
+
+	/* Initialize pgd_bases to default values */
+	for(i = 0; i < NR_ADDR_SEGMENTS; i++) {
+		get_cpu_var(pgd_bases)[i] = (unsigned long)swapper_pg_dir;
+		put_cpu_var(pgd_bases);
+	}
+	pwbase_val = (uint64_t)&(__get_cpu_var(pgd_bases)[0]);
+
+	/* enable page walker */
+	pwctl_val |= ((uint32_t)1) << PWCTL_PW_EN_O;
+
+	/* page table selector */
+	bd_shift = _PGDIR_SHIFT + ffs(_PTRS_PER_PGD) - 1;
+	pwfield_val |= bd_shift << PWFIELD_BD_O; /* corresponds to old HPW_NUM_PAGE_LVL[15:8] */
+	pwsize_val |= ((uint64_t)(ffs(NR_ADDR_SEGMENTS) - 1)) << PWSIZE_BD_O;
+
+	/* global directory */
+	pwfield_val |= ((uint64_t)(_PGDIR_SHIFT)) << PWFIELD_GD_O;
+	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PGD) - 1)) << PWSIZE_GD_O;
+
+	/* upper directory (was initialized to 0) */
+
+#ifdef CONFIG_64BIT
+	/* middle directory */
+	pwfield_val |= ((uint64_t)_PMD_SHIFT) << PWFIELD_MD_O;
+	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PMD) - 1)) << PWSIZE_MD_O;
+
+#endif
+	/* page table index */
+	pwfield_val |= ((uint64_t)PAGE_SHIFT) << PWFIELD_PT_O;
+	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PTE) - 1)) << PWSIZE_PT_O;
+
+#ifdef CONFIG_64BIT
+	pwsize_val |= ((uint64_t)1) << PWSIZE_PS_O;
+#else
+	/* PWSIZE_PS field was initialized to 0 */
+#endif
+
+	/* logical right rotate of PTE loaded from memory */
+	pwfield_val |= ((uint64_t)ENTRYLO_PFN_SHIFT) << PWFIELD_PTE_O;
+
+	/* PWSIZE_PTE field was initialized to 0 (page table entry spacing) */
+
+	/* write registers*/
+	write_c0_pwbase(pwbase_val);
+	write_c0_pwfield(pwfield_val);
+	write_c0_pwsize(pwsize_val);
+	write_c0_pwctl(pwctl_val);
+
+	get_cpu_var(pgd_bases)[VMALLOC_SEG] = (unsigned long)swapper_pg_dir;
+
+#ifdef MODULE_START
+	__get_cpu_var(pgd_bases)[MODULE_SEG] = (unsigned long)swapper_pg_dir;
+#endif
+
+	put_cpu_var(pgd_bases);
+
+	dump_pgwalker_config();
+	printk("Initialized Page Walker on cpu@%d\n", hard_smp_processor_id());
+}
+
 void dump_pgwalker_config(void)
 {
 #ifdef DEBUG
 	int i = 0;
+	uint64_t pwbase_val = 0, pwfield_val = 0, pwsize_val = 0;
+	uint32_t pwctl_val = 0;
+        int is_soc_xlp2xx = (get_proc_id() == CHIP_PROCESSOR_ID_XLP_2XX);
 
 	pgw_print_w(PGW_MMU_INFO);
 	pgw_print_w(PGW_PGD_SHIFT);
@@ -163,7 +239,16 @@ void dump_pgwalker_config(void)
 	for(i = 0; i < NR_ADDR_SEGMENTS; i++) {
 		printk("pgd_bases[%d] = 0x%lx\n", i, __get_cpu_var(pgd_bases)[i]);
 	}
-
+	if (is_soc_xlp2xx) {
+		pwbase_val = read_c0_pwbase();
+		pwfield_val = read_c0_pwfield();
+		pwsize_val = read_c0_pwsize();
+		pwctl_val = read_c0_pwctl();
+		printk("read pwbase: = %llx\n", pwbase_val);
+		printk("read pwfield: = %llx\n", pwfield_val);
+		printk("read pwsize: = %llx\n", pwsize_val);
+		printk("read pwctl: = %x\n", pwctl_val);
+	}
 #endif
 }
 
@@ -176,11 +261,11 @@ static void pgwalker_workaround_setup(void)
 	chip_id = (prid >> 8) & 0xff;
 	rev_id  = prid & 0xff;
 
-	/* Disable hardware page walker for XLP A0/1/2 chips (832-408), 
+	/* Disable hardware page walker for XLP A0/1/2 chips (832-408),
 	 * Revision A0/A1/A2 chips.
 	 */
-	if (chip_id == CHIP_PROCESSOR_ID_XLP_8XX || chip_id == CHIP_PROCESSOR_ID_XLP_832 
-	|| chip_id == CHIP_PROCESSOR_ID_XLP_816 || chip_id == CHIP_PROCESSOR_ID_XLP_432 
+	if (chip_id == CHIP_PROCESSOR_ID_XLP_8XX || chip_id == CHIP_PROCESSOR_ID_XLP_832
+	|| chip_id == CHIP_PROCESSOR_ID_XLP_816 || chip_id == CHIP_PROCESSOR_ID_XLP_432
 	|| chip_id == CHIP_PROCESSOR_ID_XLP_416 || chip_id == CHIP_PROCESSOR_ID_XLP_408) {
 		if (rev_id == XLP_REVISION_A0 || rev_id == XLP_REVISION_A1
 			|| rev_id == XLP_REVISION_A2)
@@ -193,27 +278,38 @@ static void pgwalker_workaround_setup(void) {}
 
 void mmu_init(void)
 {
+	uint32_t config4_val = 0;
+	int is_soc_xlp2xx = (get_proc_id() == CHIP_PROCESSOR_ID_XLP_2XX);
 
 	/* For XLP832 A0-A2 chips, the page walker needs to be shutdown to
 	 * prevent potential errors.
 	 */
 	pgwalker_workaround_setup();
 
-	/* 
+	/*
 	 * Read back TLB entries after configuration
 	 */
 	current_cpu_data.tlbsize = (read_c0_config6() >> 16 ) & 0xffff;
 
-	/* 
-	 * shift right half the number of 1s in 
+	/*
+	 * shift right half the number of 1s in
 	 * the pagemask and populate that value
 	 */
 	write_c0_config7(PM_DEFAULT_MASK >> (13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
+
 #ifdef DEBUG
 	printk(KERN_INFO "( %s ): write_c0_config7 = %d\n", __FUNCTION__,
 		   read_c0_config7());
 #endif
 
+	if (is_soc_xlp2xx) {
+		/* set config4 to use 64KB page */
+		config4_val = read_c0_config4();
+		config4_val &= ~(((uint32_t)0x1f) << CFG4_FTLBPAGESIZE_O); /*clear 5-bit width field*/
+		config4_val |= ((uint32_t)0x3) << CFG4_FTLBPAGESIZE_O; /* 64KB page */
+		write_c0_config4(config4_val);
+	}
+
 #ifdef CONFIG_EXEC_INHIBIT
 	pagegrain_write(pagegrain_read() | EXEC_INHIBIT);
 #endif
@@ -222,7 +318,11 @@ void mmu_init(void)
 	pagegrain_write(pagegrain_read() | READ_INHIBIT);
 #endif
 
-	pgwalker_init();
+	if (is_soc_xlp2xx) {
+		pgwalker_init_xlp2xx();
+	} else {
+		pgwalker_init();
+	}
 	tlbstats_init();
 	entrylo0_mask_init();
 
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 69499e2..4301a74 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -436,7 +436,7 @@ static int fdt_process(void)
 	uint32_t  i, na, ns, regs[MAX_PROP_LEN / 4], entries, cpu_cells;
 	uint32_t node_vc_mask[NLM_MAX_CPU_NODE] = {0};
 	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
-	unsigned char buf[30];	
+	unsigned char buf[30];
 	int j, id=0, k, tmp;
 	uint32_t onlinemask[MAX_CPUMASK_CELLS];
  	uint32_t linux_loader_mask[MAX_CPUMASK_CELLS] = {0};
@@ -546,7 +546,7 @@ static int fdt_process(void)
 	printk("FDT Cmdline: %s\n", arcs_cmdline);
 
 
-	/* 
+	/*
 	 * extract CPU online mask for domain 0 (linux)
 	 */
 	for (i = 0; i < MAX_CPUMASK_CELLS; i++)
@@ -582,7 +582,7 @@ static int fdt_process(void)
 			int j = 0;
 
 			for (j = 0; j < 32; j++) {
-				if ((onlinemask[i] & (1 << j)) == 0) 
+				if ((onlinemask[i] & (1 << j)) == 0)
 					continue;
 				cpumask_set_cpu((i * 32 + j), &fdt_cpumask);
 			}
@@ -626,12 +626,12 @@ static int fdt_process(void)
 			int j = 0;
 
 			for (j = 0; j < 32; j++) {
-				if ((linux_loader_mask[i] & (1 << j)) == 0) 
+				if ((linux_loader_mask[i] & (1 << j)) == 0)
 					continue;
 				cpumask_set_cpu((i * 32 + j), &fdt_loadermask);
 			}
 		}
-		
+
 		entries = (getprop(node, "memory", regs, sizeof(regs))) / sizeof(regs[0]);
 		if (!entries || (entries % (na+ns))){
 			printk("Invalid Memory Map Specified!\n");
@@ -708,8 +708,6 @@ static int get_xlp_proc_name(void)
 	//printk("efuse_cfg0 =0x%x \n", efuse_cfg0());
         //printk("efuse_cfg1 =0x%x \n", efuse_cfg1());
 
-
-	
 	switch (processor_id) {
 		case CHIP_PROCESSOR_ID_XLP_8XX:		/*defulet set to XLP8XX */
 		case CHIP_PROCESSOR_ID_XLP_8_4_XX:
@@ -739,9 +737,9 @@ static int get_xlp_proc_name(void)
 					printk("No category found in XLP 8XX/4XX. Default to XLP832\n");
 					strcpy(cpu_model_info, "XLP832");
 				return 0;
-						
+
 			}
-		break;   
+		break;
 		/*Backward compatibility for XLP8XX/XLP4XX A0/A1/A2*/
 		case CHIP_PROCESSOR_ID_XLP_816:
 			strcpy(cpu_model_info, "XLP816");
@@ -773,8 +771,12 @@ static int get_xlp_proc_name(void)
 				break;
 
 			}
-		
+
+		break;
+		case CHIP_PROCESSOR_ID_XLP_2XX:
+			strcpy(cpu_model_info, "XLP2XX");
 		break;
+
 		case CHIP_PROCESSOR_ID_XLP_208:
 			strcpy(cpu_model_info, "XLP208");
 		break;
-- 
1.7.0.4

