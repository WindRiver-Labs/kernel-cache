From a6541445d59004c7747da6b46b5dda664469cb7d Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Fri, 2 Jul 2010 11:55:09 -0700
Subject: [PATCH 090/762] fix debug and warning message

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/irq.c |   89 +++++++++++++++++++++---------------------
 1 files changed, 45 insertions(+), 44 deletions(-)

diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 0a637b7..5e43a70 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -63,7 +63,7 @@ extern void *ht_config_base;
 extern int link0, link1;
 struct pic_tmask pic_tmask[PIC_NUM_IRTS];
 
-__u64 nlm_common_irq_mask;
+__u64 nlm_xlp_irq_mask;
 spinlock_t nlm_common_pic_lock = SPIN_LOCK_UNLOCKED;
 
 void dump_irt_entry(short no)
@@ -100,7 +100,6 @@ static unsigned int pic_startup(unsigned int irq)
 		printk("can't find irt for irq: %d\n",irq);
 		return -1;
 	}
- 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq, irt); 
 
 	spin_lock_irqsave(&nlm_common_pic_lock, flags);
 
@@ -108,10 +107,8 @@ static unsigned int pic_startup(unsigned int irq)
 	 * Assume, that doesn't happen?
 	 */
 	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
-	/* netlogic_write_reg(mmio, PIC_IRT_1_BASE + irq_to_irt(irq), reg | (1<<31)); */
 	/* By default all the interrupts are initialized as level senstive - fix for the PCMCIA flash */
 	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), reg|(1 << 28)|(1 << 31));
-	printk("[%s] Writing IRT reg %ld with IRQ %d\n", __FUNCTION__,irt, irq);
 
 	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
 
@@ -126,7 +123,7 @@ static void pic_unmask(unsigned int irq)
 	unsigned long irt;
 
 	if(irq < 8) {
-		return 0;
+		return;
 	}
 	irt = find_irt_from_irq(irq);
 	if(irt == -1)
@@ -135,14 +132,12 @@ static void pic_unmask(unsigned int irq)
 		return;
 	}
 
- 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
 	spin_lock_irqsave(&nlm_common_pic_lock, flags);
 
 	/* What happens if this irq was previously not ack'ed? 
 	 * Assume, that doesn't happen?
 	 */
 	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
-	/* netlogic_write_reg(mmio, PIC_IRT_1_BASE + irq_to_irt(irq), reg | (1<<31)); */
 	/* By default all the interrupts are initialized as level senstive - fix for the PCMCIA flash */
 	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), reg | (1 << 28) | (1 << 31));
 
@@ -153,13 +148,13 @@ static void pic_unmask(unsigned int irq)
 
 static void pic_ack(unsigned int irq)
 {
-	unsigned long flags, i;
+	unsigned long flags;
 	unsigned long irt;
-	uint64_t val,eirr;
+	/*uint64_t val;*/
 
 
 	if(irq < 8) {
-		return 0;
+		return;
 	}
 	irt = find_irt_from_irq(irq);
 	if(irt == -1)
@@ -167,20 +162,28 @@ static void pic_ack(unsigned int irq)
 		printk("can't find irt for irq: %d\n",irq);
 		return;
 	}
+	/*
 	if(irq!=7 && irq != 17 && irq != 18)
  	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
+	*/
 	/* If edge triggered IRQ, ack it immediately, else when the device
 	 * interrupt condition is cleared, we may lose interrupts 
 	 */
 	if (PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
 		spin_lock_irqsave(&nlm_common_pic_lock, flags);
+		/*
 		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
-	if(irq!=7 && irq != 17 && irq != 18)
+		if(irq!=7 && irq != 17 && irq != 18)
 		printk("[%s] pending1 :%lx\n", __func__,val);
+		*/
+
 		nlm_hal_ack_pic(irt);
+		/*
 		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
-	if(irq!=7 && irq != 17 && irq != 18)
+		
+		if(irq!=7 && irq != 17 && irq != 18)
 		printk("[%s] pending1 :%lx\n", __func__,val);
+		*/
 		spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
 	}
 }
@@ -189,10 +192,10 @@ static void pic_end(unsigned int irq)
 {
 	unsigned long flags;
 	unsigned long irt;
-	uint64_t val;
+	/*uint64_t val;*/
 
 	if(irq < 8) {
-		return 0;
+		return;
 	}
 	irt = find_irt_from_irq(irq);
 	if(irt == -1)
@@ -200,19 +203,24 @@ static void pic_end(unsigned int irq)
 		printk("can't find irt for irq: %d\n",irq);
 		return;
 	}
+	/*
 	if(irq!=7 && irq != 17 && irq != 18)
- 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
-
+ 		printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
+	*/
 	/* If level triggered, ack it after the device condition is cleared */
 	if (!PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
 		spin_lock_irqsave(&nlm_common_pic_lock, flags);
+		/*
 		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
-	if(irq!=7 && irq != 17 && irq != 18)
+		if(irq!=7 && irq != 17 && irq != 18)
 		printk("[%s] pending1 :%lx\n", __func__,val);
+		*/
 		nlm_hal_ack_pic(irt);
+		/*
 		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
-	if(irq!=7 && irq != 17 && irq != 18)
-		printk("[%s] pending1 :%lx\n", __func__,val);
+		if(irq!=7 && irq != 17 && irq != 18)
+			printk("[%s] pending1 :%lx\n", __func__,val);
+		*/
 		spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
 	}
 }
@@ -225,7 +233,7 @@ static void pic_shutdown(unsigned int irq)
 	unsigned long irt;
 
 	if(irq < 8) {
-		return 0;
+		return;
 	}
 	irt = find_irt_from_irq(irq);
 	if(irt == -1)
@@ -234,9 +242,6 @@ static void pic_shutdown(unsigned int irq)
 		return;
 	}
 
-	//dbg_msg("IN irq=%d\n", irq);
- 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
-
 	spin_lock_irqsave(&nlm_common_pic_lock, flags);
 
 	/* What happens if this irq is currently pending an ack? 
@@ -244,7 +249,6 @@ static void pic_shutdown(unsigned int irq)
 	 */
 	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
 	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), (reg & ~(1 << 31)));
-	printk("[%s] disable IRT %ld with IRQ %d\n", __FUNCTION__,PIC_IRT(irt), irq);
 
 	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
 }
@@ -264,6 +268,7 @@ static int pic_set_affinity(unsigned int irq, const struct cpumask *mask)
 		if(cpumask_test_cpu(cpu, mask))
 		{
 			nlm_hal_set_irq_to_cpu(irq, cpu);
+		//	printk("[%s]: IN irq=%d cpu %d\n", __func__, irq , cpu); 
 		}
 	}
 //	nlm_hal_pic_send_ipi(int nmi, int vec, int node, int cpu);
@@ -333,7 +338,6 @@ static irqreturn_t nlm_common_rsvd_irq_handler(int irq, void *dev_id)
 struct irqaction nlm_common_rsvd_action = {
 	.handler = nlm_common_rsvd_irq_handler,
 	.flags = 0,
-	//.mask = 0,
 	.name = "nlm_common_rsvd_action",
 	.dev_id = 0,
 	.next = 0
@@ -350,7 +354,7 @@ void __init init_nlm_common_irqs(void)
 #ifdef CONFIG_REMOTE_DEBUG
 	irq_desc[IRQ_REMOTE_DEBUG].chip = &nlm_common_rsvd_pic;
 	irq_desc[IRQ_REMOTE_DEBUG].action = nlm_common_rsvd_action;
-	nlm_common_irq_mask |= (1ULL << IRQ_REMOTE_DEBUG);
+	nlm_xlp_irq_mask |= (1ULL << IRQ_REMOTE_DEBUG);
 #endif
 
 #ifdef CONFIG_SMP
@@ -364,33 +368,33 @@ void __init init_nlm_common_irqs(void)
 	/* PR: New IPI added here for netrx balancing */
 	irq_desc[IRQ_IPI_NETRX].chip = &nlm_common_rsvd_pic;
 	irq_desc[IRQ_IPI_NETRX].action = &nlm_common_rsvd_action;
-	nlm_common_irq_mask |= (1ULL << IRQ_IPI_NETRX);
+	nlm_xlp_irq_mask |= (1ULL << IRQ_IPI_NETRX);
 #endif				/* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
 
-	nlm_common_irq_mask |=
+	nlm_xlp_irq_mask |=
 	    ((1ULL << IRQ_IPI_SMP_FUNCTION) | (1ULL << IRQ_IPI_SMP_RESCHEDULE));
 #endif
 
 	/* msgring interrupt */
 	irq_desc[IRQ_MSGRING].chip = &nlm_common_rsvd_pic;
 	irq_desc[IRQ_MSGRING].action = &nlm_common_rsvd_action;
-	nlm_common_irq_mask |= (1ULL << IRQ_MSGRING);
+	nlm_xlp_irq_mask |= (1ULL << IRQ_MSGRING);
 
 	/* unmask all PIC related interrupts. If no handler is installed by the 
 	 * drivers, it'll just ack the interrupt and return 
 	 */
 	for (i = PIC_IRT_FIRST_IRQ; i <= PIC_IRT_LAST_IRQ(); i++)
-		nlm_common_irq_mask |= (1ULL << i);
+		nlm_xlp_irq_mask |= (1ULL << i);
 
 #ifdef CONFIG_OPROFILE
-	nlm_common_irq_mask |= (1ULL << IRQ_IPI_OPROFILE);
+	nlm_xlp_irq_mask |= (1ULL << IRQ_IPI_OPROFILE);
 #endif
 
 #ifdef CONFIG_KGDB
-	nlm_common_irq_mask |= (1ULL << IRQ_IPI_SMP_KGDB);
+	nlm_xlp_irq_mask |= (1ULL << IRQ_IPI_SMP_KGDB);
 #endif
 
-	nlm_common_irq_mask |= (1ULL << IRQ_TIMER);
+	nlm_xlp_irq_mask |= (1ULL << IRQ_TIMER);
 }
 
 #ifdef CONFIG_KGDB
@@ -414,7 +418,6 @@ void do_nlm_common_IRQ(unsigned int irq, struct pt_regs *regs)
 		return;
 	}
 #endif
-
 	if (irq == IRQ_MSGRING) nlm_xlp_msgring_int_handler(irq, regs);
 
 #ifdef CONFIG_KGDB
@@ -432,8 +435,9 @@ void do_nlm_common_IRQ(unsigned int irq, struct pt_regs *regs)
 
 void __cpuinit nlm_smp_irq_init(void)
 {
+	printk("[%s]\n",__FUNCTION__);
 	/* set interrupt mask for non-zero cpus */
-	write_64bit_cp0_eimr(nlm_common_irq_mask | (1 << IRQ_TIMER));
+	write_64bit_cp0_eimr(nlm_xlp_irq_mask | (1 << IRQ_TIMER));
 }
 
 /* 
@@ -503,7 +507,7 @@ int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)
 	}
 	write_msi_msg(irq, &msg);
 	irq_desc[irq].chip = &nlm_common_pic_msi;
-	nlm_common_irq_mask |= (1ULL << irq);
+	nlm_xlp_irq_mask |= (1ULL << irq);
 	return irq;
 }
 #endif
@@ -536,9 +540,8 @@ void __init arch_init_irq(void)
 	/* Initialize the irq descriptors */
 	init_nlm_common_irqs();
 
-	write_64bit_cp0_eimr(nlm_common_irq_mask);
-
-//	dumpall_irt_entry();
+	write_64bit_cp0_eimr(nlm_xlp_irq_mask);
+	//dumpall_irt_entry();
 }
 
 asmlinkage void plat_irq_dispatch(void)
@@ -565,18 +568,16 @@ asmlinkage void plat_irq_dispatch(void)
 		return;
 	}
 	/*ack eirr */
-	if(i == 58)
+	if(i == 58 || i == 6)
 	{
-		printk("[%s] ack cp0_eirr:%lx %d\n",__func__,eirr, i);
+//		printk("[%s] ack cp0_eirr:%lx %d\n",__func__,eirr, i);
 	}
 	write_64bit_cp0_eirr(1ULL << i);
 	eirr = read_64bit_cp0_eirr() & read_64bit_cp0_eimr();
 	if(i == 58)
 	{
-		printk("[%s] ack cp0_eirr:%lx %d\n",__func__,eirr, i);
+		printk("[%s] ack cp0_eirr:%llx %d\n",__func__,eirr, i);
 	}
 	do_nlm_common_IRQ(i, pt_regs);
 	return;
 }
-
-
-- 
1.7.0.4

