From 59e082a0c844fe23efce7f5ad3f8a87477601a03 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Wed, 12 Nov 2014 11:00:21 +0800
Subject: [PATCH] Revert "bcm-xlp: use the unsleep raw spinlock in mmc driver"

mmc can work in irq thread, forcely making them
work in interrupt context will introduce bug like below:

[ 47.030000] BUG: sleeping function called from invalid context at kernel/rtmutex.c:797
[ 47.030000] in_atomic(): 1, irqs_disabled(): 1, pid: 486, name: mmcqd/0
[ 47.030000] Preemption disabled at:[< (null)>] (null)

[ 47.030000] CPU: 42 PID: 486 Comm: mmcqd/0 Tainted: G W 3.10.55-ltsi-rt55-WR6.0.0.0_preempt-rt #1
[ 47.030000] Stack : 0000000000000000 000000000000005f 0000000000000000 0000000000000000
0000000000000004 ffffffffc0ce0000 0000000000000000 0000000000000000
ffffffffc1040000 000000000000002a 000000000000005f 0000000000000006
c0000000b1edfa38 ffffffffc02a1e10 0000000000000000 0000000000000000
0000000000000000 0000000000000000 ffffffffc1020000 ffffffffc1020000
ffffffffc0b2f080 ffffffffc0cd5a57 ffffffffc101cf88 c0000000bba84868
00000000000001e6 000000000000002a 0000000000000001 ffffffffc02d0000
c0000000b1edfab8 c0000000b1edf9c8 c0000000b1edfae0 ffffffffc0a248b8
c0000000b1edfb18 ffffffffc02a3a98 c0000000bba844c0 ffffffffc0b2f080
000000000000002a ffffffffc0274ca0 0000000000000000 0000000000000000
...
[ 47.030000] Call Trace:
[ 47.030000] [<ffffffffc0274ca0>] show_stack+0xd8/0xf8
[ 47.030000] [<ffffffffc0a248b8>] rt_spin_lock+0x38/0x98
[ 47.030000] [<ffffffffc0854264>] sdhci_request+0x74/0x308
[ 47.030000] [<ffffffffc083bd3c>] mmc_start_req+0x36c/0x448
[ 47.030000] [<ffffffffc084e8d0>] mmc_blk_issue_rw_rq+0xd8/0xaf8
[ 47.030000] [<ffffffffc084f504>] mmc_blk_issue_rq+0x214/0x558
[ 47.030000] [<ffffffffc08500f8>] mmc_queue_thread+0xd8/0x1b0
[ 47.030000] [<ffffffffc02cfb5c>] kthread+0xbc/0xc8
[ 47.030000] [<ffffffffc026f26c>] ret_from_kernel_thread+0x14/0x1c

Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
---
 drivers/mmc/core/core.c   |   50 ++++++++++++------------
 drivers/mmc/core/host.c   |    2 +-
 drivers/mmc/host/sdhci.c  |   90 ++++++++++++++++++++++----------------------
 include/linux/mmc/host.h  |    2 +-
 include/linux/mmc/sdhci.h |    2 +-
 5 files changed, 73 insertions(+), 73 deletions(-)

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1ccfb72..bf18b6b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -891,15 +891,15 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 	might_sleep();
 
 	add_wait_queue(&host->wq, &wait);
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	while (1) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		stop = abort ? atomic_read(abort) : 0;
 		if (stop || !host->claimed || host->claimer == current)
 			break;
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 		schedule();
-		raw_spin_lock_irqsave(&host->lock, flags);
+		spin_lock_irqsave(&host->lock, flags);
 	}
 	set_current_state(TASK_RUNNING);
 	if (!stop) {
@@ -908,7 +908,7 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 		host->claim_cnt += 1;
 	} else
 		wake_up(&host->wq);
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
 	if (host->ops->enable && !stop && host->claim_cnt == 1)
 		host->ops->enable(host);
@@ -928,14 +928,14 @@ int mmc_try_claim_host(struct mmc_host *host)
 	int claimed_host = 0;
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	if (!host->claimed || host->claimer == current) {
 		host->claimed = 1;
 		host->claimer = current;
 		host->claim_cnt += 1;
 		claimed_host = 1;
 	}
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 	if (host->ops->enable && claimed_host && host->claim_cnt == 1)
 		host->ops->enable(host);
 	return claimed_host;
@@ -958,14 +958,14 @@ void mmc_release_host(struct mmc_host *host)
 	if (host->ops->disable && host->claim_cnt == 1)
 		host->ops->disable(host);
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	if (--host->claim_cnt) {
 		/* Release for nested claim */
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 	} else {
 		host->claimed = 0;
 		host->claimer = NULL;
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 		wake_up(&host->wq);
 	}
 }
@@ -1657,9 +1657,9 @@ static inline void mmc_bus_get(struct mmc_host *host)
 {
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	host->bus_refs++;
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 /*
@@ -1670,11 +1670,11 @@ static inline void mmc_bus_put(struct mmc_host *host)
 {
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	host->bus_refs--;
 	if ((host->bus_refs == 0) && host->bus_ops)
 		__mmc_release_bus(host);
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 /*
@@ -1690,7 +1690,7 @@ void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 
 	WARN_ON(!host->claimed);
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	BUG_ON(host->bus_ops);
 	BUG_ON(host->bus_refs);
@@ -1699,7 +1699,7 @@ void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 	host->bus_refs = 1;
 	host->bus_dead = 0;
 
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 /*
@@ -1714,11 +1714,11 @@ void mmc_detach_bus(struct mmc_host *host)
 	WARN_ON(!host->claimed);
 	WARN_ON(!host->bus_ops);
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	host->bus_dead = 1;
 
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 
 	mmc_bus_put(host);
 }
@@ -1737,9 +1737,9 @@ void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	WARN_ON(host->removed);
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 	host->detect_change = 1;
 	mmc_schedule_delayed_work(&host->detect, delay);
@@ -2512,9 +2512,9 @@ void mmc_stop_host(struct mmc_host *host)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	host->removed = 1;
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
 	host->rescan_disable = 1;
@@ -2694,9 +2694,9 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
-		raw_spin_lock_irqsave(&host->lock, flags);
+		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 1;
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 		cancel_delayed_work_sync(&host->detect);
 
 		if (!host->bus_ops)
@@ -2721,9 +2721,9 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	case PM_POST_HIBERNATION:
 	case PM_POST_RESTORE:
 
-		raw_spin_lock_irqsave(&host->lock, flags);
+		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 0;
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 		mmc_detect_change(host, 0);
 
 	}
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 15f34f9..49bc403 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -479,7 +479,7 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	mutex_init(&host->slot.lock);
 	host->slot.cd_irq = -EINVAL;
 
-	raw_spin_lock_init(&host->lock);
+	spin_lock_init(&host->lock);
 	init_waitqueue_head(&host->wq);
 	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
 #ifdef CONFIG_PM
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 833701c..e95b5ba 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -306,7 +306,7 @@ static void sdhci_led_control(struct led_classdev *led,
 	struct sdhci_host *host = container_of(led, struct sdhci_host, led);
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	if (host->runtime_suspended)
 		goto out;
@@ -316,7 +316,7 @@ static void sdhci_led_control(struct led_classdev *led,
 	else
 		sdhci_activate_led(host);
 out:
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 #endif
 
@@ -1353,7 +1353,7 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 
 	sdhci_runtime_pm_get(host);
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	WARN_ON(host->mrq != NULL);
 
@@ -1411,9 +1411,9 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 					mmc->card->type == MMC_TYPE_MMC ?
 					MMC_SEND_TUNING_BLOCK_HS200 :
 					MMC_SEND_TUNING_BLOCK;
-				raw_spin_unlock_irqrestore(&host->lock, flags);
+				spin_unlock_irqrestore(&host->lock, flags);
 				sdhci_execute_tuning(mmc, tuning_opcode);
-				raw_spin_lock_irqsave(&host->lock, flags);
+				spin_lock_irqsave(&host->lock, flags);
 
 				/* Restore original mmc_request structure */
 				host->mrq = mrq;
@@ -1427,7 +1427,7 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	}
 
 	mmiowb();
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
@@ -1436,10 +1436,10 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 	int vdd_bit = -1;
 	u8 ctrl;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	if (host->flags & SDHCI_DEVICE_DEAD) {
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 		if (host->vmmc && ios->power_mode == MMC_POWER_OFF)
 			mmc_regulator_set_ocr(host->mmc, host->vmmc, 0);
 		return;
@@ -1466,9 +1466,9 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 		vdd_bit = sdhci_set_power(host, ios->vdd);
 
 	if (host->vmmc && vdd_bit != -1) {
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 		mmc_regulator_set_ocr(host->mmc, host->vmmc, vdd_bit);
-		raw_spin_lock_irqsave(&host->lock, flags);
+		spin_lock_irqsave(&host->lock, flags);
 	}
 
 	if (host->ops->platform_send_init_74_clocks)
@@ -1605,7 +1605,7 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 		sdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
 
 	mmiowb();
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
@@ -1653,7 +1653,7 @@ static int sdhci_check_ro(struct sdhci_host *host)
 	unsigned long flags;
 	int is_readonly;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	if (host->flags & SDHCI_DEVICE_DEAD)
 		is_readonly = 0;
@@ -1663,7 +1663,7 @@ static int sdhci_check_ro(struct sdhci_host *host)
 		is_readonly = !(sdhci_readl(host, SDHCI_PRESENT_STATE)
 				& SDHCI_WRITE_PROTECT);
 
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 
 	/* This quirk needs to be replaced by a callback-function later */
 	return host->quirks & SDHCI_QUIRK_INVERTED_WRITE_PROTECT ?
@@ -1736,9 +1736,9 @@ static void sdhci_enable_sdio_irq(struct mmc_host *mmc, int enable)
 	struct sdhci_host *host = mmc_priv(mmc);
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	sdhci_enable_sdio_irq_nolock(host, enable);
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static int sdhci_do_start_signal_voltage_switch(struct sdhci_host *host,
@@ -1869,7 +1869,7 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 
 	sdhci_runtime_pm_get(host);
 	disable_irq(host->irq);
-	raw_spin_lock(&host->lock);
+	spin_lock(&host->lock);
 
 	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 
@@ -1889,7 +1889,7 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 	    requires_tuning_nonuhs)
 		ctrl |= SDHCI_CTRL_EXEC_TUNING;
 	else {
-		raw_spin_unlock(&host->lock);
+		spin_unlock(&host->lock);
 		enable_irq(host->irq);
 		sdhci_runtime_pm_put(host);
 		return 0;
@@ -1962,7 +1962,7 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 		host->cmd = NULL;
 		host->mrq = NULL;
 
-		raw_spin_unlock(&host->lock);
+		spin_unlock(&host->lock);
 		enable_irq(host->irq);
 
 		/* Wait for Buffer Read Ready interrupt */
@@ -1970,7 +1970,7 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 					(host->tuning_done == 1),
 					msecs_to_jiffies(50));
 		disable_irq(host->irq);
-		raw_spin_lock(&host->lock);
+		spin_lock(&host->lock);
 
 		if (!host->tuning_done) {
 			pr_info(DRIVER_NAME ": Timeout waiting for "
@@ -2044,7 +2044,7 @@ out:
 		err = 0;
 
 	sdhci_clear_set_irqs(host, SDHCI_INT_DATA_AVAIL, ier);
-	raw_spin_unlock(&host->lock);
+	spin_unlock(&host->lock);
 	enable_irq(host->irq);
 	sdhci_runtime_pm_put(host);
 
@@ -2086,7 +2086,7 @@ static void sdhci_card_event(struct mmc_host *mmc)
 	if (host->ops->card_event)
 		host->ops->card_event(host);
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	/* Check host->mrq first in case we are runtime suspended */
 	if (host->mrq && !sdhci_do_get_cd(host)) {
@@ -2102,7 +2102,7 @@ static void sdhci_card_event(struct mmc_host *mmc)
 		tasklet_schedule(&host->finish_tasklet);
 	}
 
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static const struct mmc_host_ops sdhci_ops = {
@@ -2141,14 +2141,14 @@ static void sdhci_tasklet_finish(unsigned long param)
 
 	host = (struct sdhci_host*)param;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
         /*
          * If this tasklet gets rescheduled while running, it will
          * be run again afterwards but without any active request.
          */
 	if (!host->mrq) {
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 		return;
 	}
 
@@ -2186,7 +2186,7 @@ static void sdhci_tasklet_finish(unsigned long param)
 #endif
 
 	mmiowb();
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 
 #ifdef CONFIG_CPU_XLP
 	mutex_unlock(&sdhci_cmd_inprogress);
@@ -2203,7 +2203,7 @@ static void sdhci_timeout_timer(unsigned long data)
 
 	host = (struct sdhci_host*)data;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	if (host->mrq) {
 		pr_err("%s: Timeout waiting for hardware "
@@ -2224,7 +2224,7 @@ static void sdhci_timeout_timer(unsigned long data)
 	}
 
 	mmiowb();
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static void sdhci_tuning_timer(unsigned long data)
@@ -2234,11 +2234,11 @@ static void sdhci_tuning_timer(unsigned long data)
 
 	host = (struct sdhci_host *)data;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	host->flags |= SDHCI_NEEDS_RETUNING;
 
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 /*****************************************************************************\
@@ -2433,10 +2433,10 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 	u32 intmask, unexpected = 0;
 	int cardint = 0, max_loops = 16;
 
-	raw_spin_lock(&host->lock);
+	spin_lock(&host->lock);
 
 	if (host->runtime_suspended) {
-		raw_spin_unlock(&host->lock);
+		spin_unlock(&host->lock);
 		return IRQ_NONE;
 	}
 
@@ -2516,7 +2516,7 @@ again:
 	if (intmask && --max_loops)
 		goto again;
 out:
-	raw_spin_unlock(&host->lock);
+	spin_unlock(&host->lock);
 
 	if (unexpected) {
 		pr_err("%s: Unexpected interrupt 0x%08x.\n",
@@ -2616,7 +2616,7 @@ int sdhci_resume_host(struct sdhci_host *host)
 	}
 
 	if (!device_may_wakeup(mmc_dev(host->mmc))) {
-		ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED | IRQF_NO_THREAD,
+		ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
 				  mmc_hostname(host->mmc), host);
 		if (ret)
 			return ret;
@@ -2693,15 +2693,15 @@ int sdhci_runtime_suspend_host(struct sdhci_host *host)
 		host->flags &= ~SDHCI_NEEDS_RETUNING;
 	}
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 
 	synchronize_irq(host->irq);
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 	host->runtime_suspended = true;
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 
 	return ret;
 }
@@ -2727,16 +2727,16 @@ int sdhci_runtime_resume_host(struct sdhci_host *host)
 	sdhci_do_start_signal_voltage_switch(host, &host->mmc->ios);
 	if ((host_flags & SDHCI_PV_ENABLED) &&
 		!(host->quirks2 & SDHCI_QUIRK2_PRESET_VALUE_BROKEN)) {
-		raw_spin_lock_irqsave(&host->lock, flags);
+		spin_lock_irqsave(&host->lock, flags);
 		sdhci_enable_preset_value(host, true);
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 	}
 
 	/* Set the re-tuning expiration flag */
 	if (host->flags & SDHCI_USING_RETUNING_TIMER)
 		host->flags |= SDHCI_NEEDS_RETUNING;
 
-	raw_spin_lock_irqsave(&host->lock, flags);
+	spin_lock_irqsave(&host->lock, flags);
 
 	host->runtime_suspended = false;
 
@@ -2747,7 +2747,7 @@ int sdhci_runtime_resume_host(struct sdhci_host *host)
 	/* Enable Card Detection */
 	sdhci_enable_card_detection(host);
 
-	raw_spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock_irqrestore(&host->lock, flags);
 
 	return ret;
 }
@@ -3164,7 +3164,7 @@ int sdhci_add_host(struct sdhci_host *host)
 		return -ENODEV;
 	}
 
-	raw_spin_lock_init(&host->lock);
+	spin_lock_init(&host->lock);
 
 	/*
 	 * Maximum number of segments. Depends on if the hardware
@@ -3241,7 +3241,7 @@ int sdhci_add_host(struct sdhci_host *host)
 
 	sdhci_init(host, 0);
 
-	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED | IRQF_NO_THREAD,
+	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
 		mmc_hostname(mmc), host);
 	if (ret) {
 		pr_err("%s: Failed to request IRQ %d: %d\n",
@@ -3302,7 +3302,7 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 	unsigned long flags;
 
 	if (dead) {
-		raw_spin_lock_irqsave(&host->lock, flags);
+		spin_lock_irqsave(&host->lock, flags);
 
 		host->flags |= SDHCI_DEVICE_DEAD;
 
@@ -3314,7 +3314,7 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 			tasklet_schedule(&host->finish_tasklet);
 		}
 
-		raw_spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock_irqrestore(&host->lock, flags);
 	}
 
 	sdhci_disable_card_detection(host);
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0a2c64a..3b0c33a 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -306,7 +306,7 @@ struct mmc_host {
 	unsigned int		max_discard_to;	/* max. discard timeout in ms */
 
 	/* private data */
-	raw_spinlock_t		lock;		/* lock for claim and bus ops */
+	spinlock_t		lock;		/* lock for claim and bus ops */
 
 	struct mmc_ios		ios;		/* current io bus settings */
 	u32			ocr;		/* the current OCR setting */
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 8e61c12..40de6bf 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -116,7 +116,7 @@ struct sdhci_host {
 	char led_name[32];
 #endif
 
-	raw_spinlock_t lock;	/* Mutex */
+	spinlock_t lock;	/* Mutex */
 
 	int flags;		/* Host attributes */
 #define SDHCI_USE_SDMA		(1<<0)	/* Host is SDMA capable */
-- 
1.7.5.4

