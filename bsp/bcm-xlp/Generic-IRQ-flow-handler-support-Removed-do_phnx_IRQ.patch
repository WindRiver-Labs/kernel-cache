From b2a8888a7cf54245d07a39f73892f57aea0c58aa Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Tue, 29 Jun 2010 15:53:08 +0530
Subject: [PATCH 102/761] Generic IRQ flow handler support Removed
 do_phnx_IRQ() - not required anymore

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                |    2 +-
 arch/mips/netlogic/Kconfig       |    1 +
 arch/mips/netlogic/common/smp.c  |   53 +++++++++++++++++
 arch/mips/netlogic/xlr/irq.c     |  121 ++++++++++++++++++--------------------
 arch/mips/netlogic/xlr/on_chip.c |    5 +-
 arch/mips/netlogic/xlr/setup.c   |    5 +-
 6 files changed, 116 insertions(+), 71 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 7b57533..b223f5f 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -952,7 +952,7 @@ config SCHED_OMIT_FRAME_POINTER
 
 config GENERIC_HARDIRQS_NO__DO_IRQ
 # XLP_MERGE_TODO
-	default  n if NLM_PTR || NLM_XLP_SIM
+	default  n if NLM_XLP_SIM
 	def_bool y
 
 #
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index ec5771d..837212d 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -2,6 +2,7 @@ config NLM_COMMON
 	bool 
 
 config NLM_XLR
+	select GENERIC_HARDIRQS_NO__DO_IRQ
 	bool
 
 config NLM_XLP
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index d5f9ba5..593afc3 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -138,6 +138,59 @@ unsigned long nlm_next_sp;
 extern void skb_transfer_finish(void);
 #endif				/* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
 
+#ifdef CONFIG_SMP
+/* IRQ_IPI_SMP_FUNCTION Handler */
+void nlm_smp_function_ipi_handler(unsigned int irq, struct irq_desc *desc)
+{
+	nlm_common_ipi_stats[smp_processor_id()]++;
+	save_epc(&nlm_common_ipi_epc[smp_processor_id()]);
+#ifdef IPI_PRINTK_DEBUG
+	printk("[%s]: cpu_%d processing ipi_%d [->%u]\n", __FUNCTION__,
+			smp_processor_id(), irq,
+			ipi_3_counter_rx[smp_processor_id()]++);
+#endif
+	++ipi_3_counter_rx[smp_processor_id()];
+	smp_call_function_interrupt();
+	nlm_common_ipi_stats[smp_processor_id()]--;
+}
+
+/* IRQ_IPI_SMP_RESCHEDULE  handler */
+void nlm_smp_resched_ipi_handler(unsigned int irq, struct irq_desc *desc)
+{
+	nlm_common_ipi_stats[smp_processor_id()]++;
+	save_epc(&nlm_common_ipi_epc[smp_processor_id()]);
+
+#ifdef IPI_PRINTK_DEBUG
+	printk("[%s]: cpu_%d processing ipi_%d\n", __FUNCTION__,
+			smp_processor_id(), irq);
+#endif
+	/* Announce that we are for reschduling */
+	set_need_resched();
+	nlm_common_ipi_stats[smp_processor_id()]--;
+}
+
+#ifdef CONFIG_PHOENIX_IP_FLOW_AFFINITY
+/* nlm_ip_flow_ipi_handler HANDLER */
+void nlm_ip_flow_ipi_handler(unsigned int irq, struct irq_desc *desc)
+{
+	nlm_common_ipi_stats[smp_processor_id()]++;
+	save_epc(&nlm_common_ipi_epc[smp_processor_id()]);
+
+	/* do_IRQ called irq_enter() before calling this desc->handler */
+	skb_transfer_finish();
+	nlm_common_ipi_stats[smp_processor_id()]--;
+
+}
+#endif /* CONFIG_PHOENIX_IP_FLOW_AFFINITY */
+#endif
+
+void nlm_msgring_int_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct pt_regs *pt_regs = current_thread_info()->regs;
+
+	nlm_common_msgring_int_handler(irq, pt_regs);
+}
+
 void nlm_common_ipi_handler(int irq, struct pt_regs *regs)
 {
 	nlm_common_ipi_stats[smp_processor_id()]++;
diff --git a/arch/mips/netlogic/xlr/irq.c b/arch/mips/netlogic/xlr/irq.c
index dbf7d01..7bddaa0 100644
--- a/arch/mips/netlogic/xlr/irq.c
+++ b/arch/mips/netlogic/xlr/irq.c
@@ -231,15 +231,10 @@ static void pic_ack(unsigned int irq)
 		}
 	}
 
-	/* If edge triggered IRQ, ack it immediately, else when the device
-	 * interrupt condition is cleared, we may lose interrupts 
-	 */
-	if (PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
-		spin_lock_irqsave(&phnx_pic_lock, flags);
-		netlogic_write_reg(mmio, PIC_INT_ACK,
-				  (1 << (irq - PIC_IRQ_BASE)));
-		spin_unlock_irqrestore(&phnx_pic_lock, flags);
-	}
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+	netlogic_write_reg(mmio, PIC_INT_ACK,
+			(1 << (irq - PIC_IRQ_BASE)));
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
 }
 
 static void pic_end(unsigned int irq)
@@ -306,7 +301,7 @@ static int pic_set_affinity(unsigned int irq, const struct cpumask *mask)
 	return 0;
 }
 
-static struct irq_chip phnx_pic = {
+static struct irq_chip xlr_pic = {
 	.name = "Phoenix-PIC",
 	.unmask = pic_unmask,
 	.mask = pic_shutdown,
@@ -364,51 +359,84 @@ static irqreturn_t phnx_rsvd_irq_handler(int irq, void *dev_id)
   return IRQ_NONE;
 }
 
-struct irqaction phnx_rsvd_action = {
+struct irqaction xlr_rsvd_action = {
 	.handler = phnx_rsvd_irq_handler,
 	.flags = 0,
 	//.mask = 0,
-	.name = "phnx_rsvd_action",
+	.name = "xlr_rsvd_action",
 	.dev_id = 0,
 	.next = 0
 };
 
+#ifdef CONFIG_KGDB
+extern irqreturn_t xlr_kgdb_ipi_handler(int irq, struct pt_regs *regs);
+void nlm_kgdb_handler(int irq, struct irq_desc *desc)
+{
+	irqreturn_t ret;
+	struct pt_regs *pt_regs = current_thread_info()->regs;
+
+	ret = xlr_kgdb_ipi_handler(irq, pt_regs);
+}
+#endif
+
+#ifdef CONFIG_OPROFILE
+extern void nlm_common_oprofile_int_handler(int irq, void *dev_id,
+					 struct pt_regs *regs);
+
+void nlm_oprofile_ipi_handler(int irq, struct irq_desc *desc)
+{
+	struct pt_regs *pt_regs = current_thread_info()->regs;
+
+	nlm_common_oprofile_int_handler(irq, NULL, pt_regs);
+}
+#endif
+
+extern void nlm_smp_function_ipi_handler(unsigned int irq, 
+					struct irq_desc *desc);
+extern void nlm_smp_resched_ipi_handler(unsigned int irq, 
+					struct irq_desc *desc);
+extern void nlm_ip_flow_ipi_handler(unsigned int irq, 
+						struct irq_desc *desc);
+extern void nlm_msgring_int_handler(unsigned int irq, struct irq_desc *desc);
+
 void __init init_xlr_irqs(void)
 {
 	int i;
 
+	/* Make all IRQs as level triggered by default */
 	for (i = 0; i < NR_IRQS; i++) {
-		set_irq_chip(i, &phnx_pic);
+		set_irq_chip(i, &xlr_pic);
+		set_irq_handler(i, handle_level_irq);
 	}
 
-#ifdef CONFIG_REMOTE_DEBUG
-	irq_desc[IRQ_REMOTE_DEBUG].chip = &phnx_rsvd_pic;
-	irq_desc[IRQ_REMOTE_DEBUG].action = phnx_rsvd_action;
-	phnx_irq_mask |= (1ULL << IRQ_REMOTE_DEBUG);
-#endif
 
 #ifdef CONFIG_SMP
 	irq_desc[IRQ_IPI_SMP_FUNCTION].chip = &phnx_rsvd_pic;
-	irq_desc[IRQ_IPI_SMP_FUNCTION].action = &phnx_rsvd_action;
+	irq_desc[IRQ_IPI_SMP_FUNCTION].action = &xlr_rsvd_action;
+	set_irq_handler(IRQ_IPI_SMP_FUNCTION, nlm_smp_function_ipi_handler);
 
 	irq_desc[IRQ_IPI_SMP_RESCHEDULE].chip = &phnx_rsvd_pic;
-	irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &phnx_rsvd_action;
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &xlr_rsvd_action;
+	set_irq_handler(IRQ_IPI_SMP_RESCHEDULE, nlm_smp_resched_ipi_handler);
+
+	phnx_irq_mask |=
+	    ((1ULL << IRQ_IPI_SMP_FUNCTION) | (1ULL << IRQ_IPI_SMP_RESCHEDULE));
 
 #ifdef CONFIG_PHOENIX_IP_FLOW_AFFINITY
 	/* PR: New IPI added here for netrx balancing */
 	irq_desc[IRQ_IPI_NETRX].chip = &phnx_rsvd_pic;
-	irq_desc[IRQ_IPI_NETRX].action = &phnx_rsvd_action;
+	irq_desc[IRQ_IPI_NETRX].action = &xlr_rsvd_action;
 	phnx_irq_mask |= (1ULL << IRQ_IPI_NETRX);
+	set_irq_handler(IRQ_IPI_NETRX, nlm_ip_flow_ipi_handler);
 #endif				/* CONFIG_PHOENIX_IP_FLOW_AFFINITY */
 
-	phnx_irq_mask |=
-	    ((1ULL << IRQ_IPI_SMP_FUNCTION) | (1ULL << IRQ_IPI_SMP_RESCHEDULE));
 #endif
 
 	/* msgring interrupt */
 	irq_desc[IRQ_MSGRING].chip = &phnx_rsvd_pic;
-	irq_desc[IRQ_MSGRING].action = &phnx_rsvd_action;
+	irq_desc[IRQ_MSGRING].action = &xlr_rsvd_action;
 	phnx_irq_mask |= (1ULL << IRQ_MSGRING);
+	set_irq_handler(IRQ_MSGRING, nlm_msgring_int_handler);
 
 	/* unmask all PIC related interrupts. If no handler is installed by the 
 	 * drivers, it'll just ack the interrupt and return 
@@ -418,55 +446,17 @@ void __init init_xlr_irqs(void)
 
 #ifdef CONFIG_OPROFILE
 	phnx_irq_mask |= (1ULL << IRQ_IPI_OPROFILE);
+	set_irq_handler(IRQ_IPI_OPROFILE, nlm_oprofile_ipi_handler);
 #endif
 
 #ifdef CONFIG_KGDB
 	phnx_irq_mask |= (1ULL << IRQ_IPI_SMP_KGDB);
+	set_irq_handler(IRQ_IPI_SMP_KGDB, nlm_kgdb_handler);
 #endif
 
 	phnx_irq_mask |= (1ULL << IRQ_TIMER);
 }
 
-#ifdef CONFIG_KGDB
-extern irqreturn_t xlr_kgdb_ipi_handler(int irq, struct pt_regs *regs);
-#endif
-#ifdef CONFIG_OPROFILE
-extern void xlr_oprofile_int_handler(int irq, void *dev_id,
-					 struct pt_regs *regs);
-#endif
-void do_phnx_IRQ(unsigned int irq, struct pt_regs *regs)
-{
-#ifdef CONFIG_SMP
-
-#ifdef CONFIG_PHOENIX_IP_FLOW_AFFINITY
-	if (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE
-	    || irq == IRQ_IPI_NETRX) {
-#else
-	if (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE) {
-#endif				/* CONFIG_PHOENIX_IP_FLOW_AFFINITY */
-		nlm_common_ipi_handler(irq, regs);
-		return;
-	}
-#endif
-
-	if (irq == IRQ_MSGRING) nlm_common_msgring_int_handler(irq, regs);
-
-#ifdef CONFIG_KGDB
-	else if (irq == IRQ_IPI_SMP_KGDB) {
-#if 0
-	  xlr_kgdb_ipi_handler(irq, regs);
-#endif
-  }
-#endif
-#ifdef CONFIG_OPROFILE
-	else if (irq == IRQ_IPI_OPROFILE) {
-		if (xlr_thr_id() != 0)
-			xlr_oprofile_int_handler(irq, NULL, regs);
-	}
-#endif
-  else do_IRQ(irq);
-}
-
 void __cpuinit nlm_smp_irq_init(void)
 {
 	/* Set up kseg0 to be cachable coherent */
@@ -638,7 +628,8 @@ asmlinkage void plat_irq_dispatch(void)
 	}
 	/*ack eirr */
 	write_64bit_cp0_eirr(1ULL << i);
-	do_phnx_IRQ(i, pt_regs);
+
+	do_IRQ(i);
 	return;
 }
 
diff --git a/arch/mips/netlogic/xlr/on_chip.c b/arch/mips/netlogic/xlr/on_chip.c
index 505ae9b..f254556 100644
--- a/arch/mips/netlogic/xlr/on_chip.c
+++ b/arch/mips/netlogic/xlr/on_chip.c
@@ -548,7 +548,6 @@ void nlm_common_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 		nlm_cpu_stat_update_msgring_pic_int();
 	}
 
-	irq_enter();
 
 	//dbg_msg("IN irq=%d\n", irq);
 
@@ -566,8 +565,6 @@ void nlm_common_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 
 	//dbg_msg("OUT irq=%d\n", irq);
 
-	/* Call the msg callback */
-	irq_exit();
 }
 
 static void enable_msgring_int(void *info)
@@ -601,7 +598,9 @@ static void msgring_bkp_timer(unsigned long data)
 	unsigned long flags;
 	struct timer_list *timer = (struct timer_list *)data;
 	local_irq_save(flags);
+	irq_enter();
 	nlm_common_msgring_int_handler(-1,NULL);
+	irq_exit();
 	local_irq_restore(flags);
 	mod_timer(timer, timer->expires+2);
 }
diff --git a/arch/mips/netlogic/xlr/setup.c b/arch/mips/netlogic/xlr/setup.c
index 49bd899..a7529c4 100644
--- a/arch/mips/netlogic/xlr/setup.c
+++ b/arch/mips/netlogic/xlr/setup.c
@@ -177,6 +177,7 @@ void *nlm_common_psb_shm = 0;
 unsigned long nlm_common_psb_shm_size = 0;
 static int dyna_exc_index=0;
 extern unsigned long _text[];
+extern void config_net_init(void);
 
 #ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
 unsigned long nlm_asid_mask = 0x3f;
@@ -1625,9 +1626,9 @@ rest_prom_int:
 
 	if (hybrid_str != NULL)
 		xlr_hybrid_setup(hybrid_str);
-/*
+
 	config_net_init();
-*/
+
 	board_nmi_handler_setup = nlm_nmi_setup;
 
 	on_chip_init();
-- 
1.7.10.4

