From 48233e42ee56a310ed8042d5040d6882a0082460 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Tue, 23 Apr 2013 16:51:53 +0800
Subject: [PATCH 468/761] bcm_xlp: add FDT support

Add FDT support.
Based on SDK version 2.3-preview.

Based on Broadcom SDK 2.3.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                                 |    1 -
 arch/mips/Makefile                                |    4 +-
 arch/mips/boot/dts/xlp_evp.dts                    |   56 +-
 arch/mips/include/asm/bootinfo.h                  |   15 +-
 arch/mips/include/asm/netlogic/gpio.h             |    3 +-
 arch/mips/include/asm/netlogic/hal/fdt_helper.h   |   91 ++
 arch/mips/include/asm/netlogic/hal/nlm_eeprom.h   |   81 ++
 arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h |   77 ++
 arch/mips/include/asm/netlogic/mips-exts.h        |    5 +
 arch/mips/include/asm/pgtable-64.h                |   44 +-
 arch/mips/kernel/cevt-r4k.c                       |    1 -
 arch/mips/mm/cerr-nlm.c                           |    1 -
 arch/mips/mm/tlbex.c                              |    1 +
 arch/mips/netlogic/common/Makefile                |    6 +-
 arch/mips/netlogic/common/fdt_helper.c            |  172 ++++
 arch/mips/netlogic/common/nlm_eeprom.c            |  125 +++
 arch/mips/netlogic/common/nlm_evp_cpld.c          |  247 +++++
 arch/mips/netlogic/common/nlm_hal.c               |  753 +++++++++++++-
 arch/mips/netlogic/common/nlm_hal_cpu_info.c      |  532 ++++++++++
 arch/mips/netlogic/common/nlm_hal_fmn_config.c    | 1144 +++++++++++++++++++++
 arch/mips/netlogic/common/nlm_hal_mdio.c          | 1038 +++++++++++++++++++
 arch/mips/netlogic/common/nlm_hal_sys.c           | 1036 +++++++++++++++++++
 arch/mips/netlogic/xlp/bootinfo.c                 |    2 +
 arch/mips/netlogic/xlp/cpu_control.c              |    1 +
 arch/mips/netlogic/xlp/irq.c                      |   12 +-
 arch/mips/netlogic/xlp/nmi.S                      |    5 +-
 arch/mips/netlogic/xlp/on_chip.c                  |   28 +-
 arch/mips/netlogic/xlp/platform.c                 |    2 +
 arch/mips/netlogic/xlp/setup.c                    |  841 +++++----------
 arch/mips/netlogic/xlp/smp.c                      |   10 +-
 arch/mips/netlogic/xlp/xlp_gpio.c                 |    6 +
 drivers/i2c/i2c-core.c                            |  816 +++++++++------
 include/linux/cpumask.h                           |    6 +
 include/linux/serial_core.h                       |  174 ++--
 kernel/time/clockevents.c                         |    2 +
 35 files changed, 6257 insertions(+), 1081 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/hal/fdt_helper.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_eeprom.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h
 create mode 100644 arch/mips/netlogic/common/fdt_helper.c
 create mode 100644 arch/mips/netlogic/common/nlm_eeprom.c
 create mode 100644 arch/mips/netlogic/common/nlm_evp_cpld.c
 create mode 100644 arch/mips/netlogic/common/nlm_hal_cpu_info.c
 create mode 100644 arch/mips/netlogic/common/nlm_hal_fmn_config.c
 create mode 100644 arch/mips/netlogic/common/nlm_hal_mdio.c
 create mode 100644 arch/mips/netlogic/common/nlm_hal_sys.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index a64f672..5597425 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -896,7 +896,6 @@ config NLM_XLP_BOARD
 	select ZONE_DMA if 64BIT
 	select SYNC_R4K
 	select SYS_HAS_EARLY_PRINTK
-	select USE_OF
 	help
 	  This board is based on Netlogic XLP Processor.
 	  Say Y here if you have a XLP based board.
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index ca16e5c..1fb9f97 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -212,8 +212,10 @@ include $(srctree)/arch/mips/Kbuild.platforms
 # NETLOGIC XLP Soc, Simulator and boards
 #
 core-$(CONFIG_NLM_XLP) 		+= arch/mips/netlogic/boot/
-cflags-$(CONFIG_NLM_XLP)	+= -DXLP -I$(srctree)/arch/mips/include/asm/netlogic/hal
+cflags-$(CONFIG_NLM_XLP)	+= -I$(srctree)/arch/mips/include/asm/netlogic/hal
 cflags-$(CONFIG_NLM_XLP)	+= -I$(srctree)/arch/mips/netlogic/boot
+cflags-$(CONFIG_NLM_COMMON)    	+= -DXLP -I$(srctree)/arch/mips/include/asm/mach-netlogic
+cflags-$(CONFIG_NLM_COMMON)    	+= -I$(srctree)/arch/mips/include/asm/netlogic
 load-$(CONFIG_NLM_XLP_EVP_BOARD) += $(CONFIG_NLM_COMMON_LOAD_ADDRESS)
 load-$(CONFIG_NLM_XLP_BOARD) += $(CONFIG_NLM_COMMON_LOAD_ADDRESS)
 
diff --git a/arch/mips/boot/dts/xlp_evp.dts b/arch/mips/boot/dts/xlp_evp.dts
index ef04549..a89b05f 100644
--- a/arch/mips/boot/dts/xlp_evp.dts
+++ b/arch/mips/boot/dts/xlp_evp.dts
@@ -1,19 +1,16 @@
-/*
- * XLP8XX Device Tree Source for EVP boards
- */
-
 /dts-v1/;
+
 / {
-	model = "netlogic,XLP-EVP";
-	compatible = "netlogic,xlp";
-	#address-cells = <2>;
-	#size-cells = <2>;
-
-	memory {
-		device_type = "memory";
-		reg =  <0 0x00100000 0 0x0FF00000	// 255M at 1M
-			0 0x20000000 0 0xa0000000	// 2560M at 512M
-			0 0xe0000000 3 0x00000000>;	// 12288M at 3584M
+	model = "MIPS,XLP8XX";
+	compatible = "NETL,XLP8XX_A0";
+	#address-cells = <0x1>;
+	#size-cells = <0x1>;
+
+	hypervisor {
+		hypervisor-name = "Xen";
+		alloc_dom0_memory = <0x0>;
+		bootargs = "ncores=8 dom0_loadaddr=0x72000000 dom0_size=0x1c000000 dom0_cpumask=0xffffffff -- ";
+		domain_heap = <0x80000000 0x20000000>;
 	};
 
 	doms {
@@ -43,6 +40,10 @@
 				sharedcfg = <0x1f000000>;
 			};
 
+			memory {
+				reg = <0x1000000 0xb000000 0x20000000 0xa0000000>;
+			};
+
 			fmn {
 				node_0_vc_mask = <0xbbbbbbbb 0xbbbbbbbb 0xbbbbbbbb 0xbbbbbbbb>;
 				node_1_vc_mask = <0xbbbbbbbb 0xbbbbbbbb 0xbbbbbbbb 0xbbbbbbbb>;
@@ -54,7 +55,7 @@
 			};
 
 			nae {
-				freein-fifo-mask = <0xffff 0x0 0x0 0x0>;
+				freein-fifo-mask = <0x3ffff 0x0 0x0 0x0>;
 				vfbtbl-sw-offset = <0x0 0x0 0x0 0x0>;
 				vfbtbl-sw-nentries = <0x20 0x20 0x20 0x20>;
 				vfbtbl-hw-offset = <0x20 0x20 0x20 0x20>;
@@ -71,7 +72,10 @@
 	};
 
 	chosen {
-		bootargs = "ramdisk=204800 rd_start=0xffffffff88000000 rd_size=0x01000000 root=/dev/ram rw console=ttyS0,115200";
+/*
+		bootargs = "ramdisk=204800 rd_start=0xffffffff88000000 rd_size=0x01000000 root=/dev/ram rw console=ttyS0,115200 mem=2048m@8192m";
+*/
+		bootargs = "root=/dev/nfs rw nfsroot=192.168.0.1:/rootfs,nfsvers=3 ip=192.168.0.2:192.168.0.1:192.168.0.1:255.255.254.0:xlp:eth2:off console=ttyS0,115200  mem=2048m@8192m";
 	};
 
 	firmware-download {
@@ -142,9 +146,11 @@
 			ucore {
 
 				src@1 {
-					num-opcodes = <0x25c>;
+					num-opcodes = <0x240>;
+					path = "/home/yjin-local/bcm-sdk/sdk-base/sysconfig/nae/ucore/linux-ucore.c";
+					timestamp = "Tue Apr  9 11:08:25 2013\n";
 					mask = <0xffff>;
-					opcodes = <0x3c1c0010 0x279cf808 0x3c020010 0x2442f808 0x3c030010 0x2463f808 0xac400000 0x43082b 0x1420fffd 0x24420004 0x3c1d0010 0x27bdf9c0 0x27a50020 0x27a60028 0xaca00000 0xacc00000 0xc000029 0x2021 0x1000ffff 0x0 0x3c020000 0x8c4209a4 0x27bdffe0 0x2403ffff 0xafbf001c 0xafb10018 0x10430009 0xafb00014 0x3c100000 0x261009a4 0x2411ffff 0x40f809 0x2610fffc 0x8e020000 0x1451fffc 0x0 0x8fbf001c 0x8fb10018 0x8fb00014 0x3e00008 0x27bd0020 0x27bdfe78 0xafa00000 0xafa00004 0xafa00008 0xafa0000c 0xafa00010 0xafa00014 0xafa00018 0xafa0001c 0xafa00020 0xafa00024 0xafa00028 0xafa0002c 0x8fa3002c 0xafbf0184 0x2c620048 0xafbe0180 0xafb7017c 0xafb60178 0xafb50174 0xafb40170 0xafb3016c 0xafb20168 0xafb10164 0xafb00160 0x10400012 0x27a50034 0x3c040001 0x34848000 0x8fb0002c 0x8fae002c 0x107880 0xe6880 0x1a46021 0x8d8b0000 0xaf5021 0xad4b0000 0x8fa9002c 0x25280001 0xafa8002c 0x8fa7002c 0x2ce60048 0x14c0fff2 0x0 0x8fb10040 0x24050002 0x122501b9 0x3c13000f 0x8fa30040 0x24020001 0x1062010f 0x3669fe50 0x8fa70040 0x24060003 0x10e6000d 0x8fbf0184 0x1021 0x8fbe0180 0x8fb7017c 0x8fb60178 0x8fb50174 0x8fb40170 0x8fb3016c 0x8fb20168 0x8fb10164 0x8fb00160 0x3e00008 0x27bd0188 0x3c020001 0x3c0ddead 0x3443bffc 0x8000077 0x35a2beef 0xafa0002c 0x8fac002c 0x2d8b0064 0x156000f1 0x0 0x8c640000 0x1482fff9 0x3c08dead 0x3c02000f 0x3c1e0001 0x3c172aaa 0x3453fe4c 0x3452fe50 0x3451fe54 0x3444fe00 0x3443fe04 0x3446fe08 0x3445fe0c 0x3510beff 0x345ffe01 0x3459fe02 0x3458fe03 0x344ffe05 0x344efe06 0x344dfe07 0x344cfe09 0x350bbeef 0x37cac000 0x80000b3 0x36e9aaab 0x10e000d4 0x0 0x27d4000c 0x14a080 0x3b4b821 0x8ee70034 0x24170800 0x107a006 0x12d70007 0x3294001f 0x27de0012 0x1eb880 0x3b73821 0x8cf60034 0x116f006 0x33d4001f 0x8fa70158 0x8fbe015c 0x1074006 0x3117001f 0x1eb200 0x2f63821 0x74080 0x115f021 0x33d50fff 0x15ba00 0x36e70001 0x34088030 0xad070000 0x3c160178 0x144380 0x36de0018 0x11ea825 0x34088000 0xad150000 0x34088004 0x8d1e0000 0x8e750000 0x15bc02 0xafb70028 0x8e560000 0x164402 0xafa80004 0x8e340000 0x328700ff 0xafa70018 0x8c950000 0xafb50020 0x8c770000 0xafb70024 0x8cd60000 0xafb60010 0x8fa80018 0xaca80000 0x93f40000 0x93270000 0x90960000 0x7ac00 0x14ba00 0x3d04021 0x2f5a021 0x931e0000 0x296b821 0x91f60000 0x91d40000 0x1e3e00 0x90750000 0x2e7b821 0x16f200 0x91a70000 0x14b400 0x3d6a021 0x295f021 0x7ae00 0x3454fe0a 0x91870000 0x3d5b021 0x92950000 0x3454fe0b 0x90de0000 0x92940000 0x73a00 0x15ac00 0xf5a821 0xafa70158 0x14a600 0x2be3821 0xf4a821 0x2c8b021 0x2a84021 0x8f702 0x83900 0x3c7a025 0x2f5a823 0x2b4a826 0x15be82 0x15f180 0x2d53823 0x2fea025 0x287a026 0x1164021 0x14f200 0x14b602 0x2a8a821 0x2de3825 0x1144023 0xe84026 0x8bc02 0x8b400 0x2f6f025 0x2a83823 0x295a021 0x3c7a826 0x15bb42 0x15b4c0 0x1143821 0x2f6f025 0x295a023 0x3d4a026 0x2a7a821 0xf44023 0x14bf02 0x14b100 0x3447fe0f 0x2f6f025 0x90f60000 0x3c84026 0xafb60158 0x345efe0e 0x93d60000 0x8fa70158 0x3457fe0d 0x92f70000 0x90be0000 0x73e00 0x16b400 0xf6b021 0xafa70158 0x295a021 0x2de3821 0x17f200 0xfeb021 0x14bc82 0x14f380 0x2d53821 0x1144026 0x2feb025 0x1164023 0x8bd42 0x8f2c0 0x2feb025 0x107a826 0x2b6a823 0x1539c2 0x15f640 0x2b4a026 0xfeb025 0x296f023 0x1ebc02 0x1e3c00 0x2e7b025 0x3c84026 0x1164023 0x8bf02 0x83900 0x115a826 0x2e7b025 0x2b63823 0x7b482 0x7bb80 0x2d7a825 0xfea026 0x295f023 0x3c83826 0x1eba02 0xf7b023 0x32d40fff 0xafb4001c 0x8fbe001c 0xac7e0000 0xac8b0000 0x8fb5001c 0x154080 0x10a3821 0x8cf70000 0x32f6001f 0xafb60030 0x8fb60028 0x8fb70004 0x8fa70030 0xe90018 0x7f7c3 0xa010 0x29ef023 0x1e4040 0x1ea8c0 0x2a8a023 0xf44023 0x27c70006 0x7a880 0x8a080 0x2884021 0x3b5a021 0x8e870034 0x8fb50048 0xafa70158 0xafb5015c 0x8fb50038 0x8fb40044 0x1680ff2e 0x2ae705dd 0x800009b 0x27de000c 0x8000093 0x27d40012 0x8faa002c 0x25490001 0x8000073 0xafa9002c 0x3c059e37 0x3c042aaa 0x34a379b9 0x3662fe4c 0x3485aaab 0x3667fe54 0x24060006 0x366cfe00 0x366bfe04 0x366afe08 0x240d0800 0x8000197 0x3c040178 0x2b3905dd 0x13200095 0x0 0x27ee000c 0xeb080 0x3b6a821 0x8eb40034 0x1149806 0x130d0007 0x326e001f 0x27ff0012 0x1f7080 0x3aef021 0x8fd70034 0x117c006 0x330e001f 0x111b006 0xfa200 0x32d5001f 0x2b49821 0x13c880 0x3309021 0x325f0fff 0x1f7a00 0x35f10001 0x34088030 0xad110000 0xe4380 0x1048025 0x34088000 0xad100000 0x34088004 0x8d0e0000 0x8c550000 0x15a402 0xafb40028 0x8c530000 0x139202 0x3251000f 0xafb10000 0x8d300000 0x107c02 0xafaf0004 0x8cee0000 0x31c800ff 0xafa80018 0x8fbf0000 0x1ff080 0x3c24021 0x8d19000c 0x19c302 0x3317000f 0xafb70008 0x8d16000c 0x32d5003f 0xafb5000c 0x8fb40018 0x1286004b 0x0 0x8d930000 0xafb30020 0x8d720000 0xafb20024 0x8d4f0000 0xafaf0010 0x8fb10020 0x8fae0024 0x8fa80010 0x223c021 0x1c3c821 0x3088023 0x219f023 0x8fb42 0x3df7826 0x328b823 0x2efa823 0xfb200 0x2d57026 0x10fa023 0x28e9023 0xe9b42 0x272b826 0x1ee8823 0x2378023 0x17c302 0x310a026 0x1d7f823 0x3f4c823 0x14f400 0x3d98826 0x2f4b023 0x2d14023 0x11a942 0x2a8f826 0x2919823 0x27f7823 0x1f90c2 0x24ff026 0x23f8023 0x21e7023 0x1ec280 0x30eb826 0x3fec823 0x337b023 0x17abc2 0x2b6a026 0xafb4001c 0x8fb3001c 0x3272001f 0xafb20030 0x8fb80028 0x8fb90004 0x8fb00030 0x2050018 0x10ffc3 0x9010 0x25ff823 0x27f70006 0x1f78c0 0x1f7040 0x17b080 0x1ee8823 0x3b6a821 0x2114023 0x8eb10034 0x8faf0048 0x8fb00038 0x8fb40044 0x8f080 0x1680ff7e 0x3c84021 0x8000183 0x27ff000c 0x8fb7000c 0x32f60010 0x12c0ffb3 0x0 0x8fbf0008 0x8fae0000 0x8fb90004 0x1dff021 0x1ec080 0x1719ffac 0x0 0x8d110004 0x118402 0xafb00014 0x8faf0014 0x31e8001f 0x80001e6 0xafa80030 0x800017c 0x27ee0012 0x3c122aaa 0x3666fe4c 0x3665fe50 0x3664fe61 0x3643aaab 0x24070800 0x8000238 0x3c020178 0x299205dd 0x1240003f 0x0 0x25a9000c 0x9b080 0x3b6a821 0x8eb40034 0x1149806 0x11670007 0x3269001f 0x25ad0012 0xdf080 0x3bec821 0x8f380034 0x118b806 0x32e9001f 0x10a9006 0x3250001f 0xf8a00 0x2117821 0xf6880 0x1ae6021 0x318b0fff 0xb7200 0x35ca0001 0x34088030 0xad0a0000 0x94380 0x102f825 0x34088000 0xad1f0000 0x34088004 0x8d090000 0x8cd10000 0x118402 0xafb00028 0x8caf0000 0xf6c02 0xafad0004 0x908c0000 0x318b001f 0xafab0030 0x8fab0028 0x8fac0004 0x8fbe0030 0x3c30018 0x1e57c3 0x7010 0x1ca6823 0x25b70006 0xd4040 0xd48c0 0x17b080 0x128f823 0x3b6a821 0x8eaa0034 0x3dfc023 0x8faf0048 0x8fae0038 0x8fb40044 0x18c880 0x1680ffc2 0x3384021 0x8000224 0x25ad000c 0x800021d 0x25a90012>;
+					opcodes = <0x3c1c0010 0x279cf808 0x3c020010 0x2442f808 0x3c030010 0x2463f808 0xac400000 0x43082b 0x1420fffd 0x24420004 0x3c1d0010 0x27bdf9c0 0x27a50020 0x27a60028 0xaca00000 0xacc00000 0xc000029 0x2021 0x1000ffff 0x0 0x3c020000 0x8c420934 0x27bdffe0 0x2403ffff 0xafbf001c 0xafb10018 0x10430009 0xafb00014 0x3c100000 0x26100934 0x2411ffff 0x40f809 0x2610fffc 0x8e020000 0x1451fffc 0x0 0x8fbf001c 0x8fb10018 0x8fb00014 0x3e00008 0x27bd0020 0x27bdfea8 0xafa00030 0xafa0002c 0xafa00028 0xafa00024 0xafa00020 0xafa0001c 0xafa00018 0xafa00014 0xafa00010 0xafa0000c 0xafa00008 0xafa00004 0x8fa30004 0x2c620048 0x10400012 0x3c040001 0x34848000 0x8fb80004 0x8fad0004 0x187080 0xd6080 0x1845821 0x8d6a0000 0x27af0034 0x1ee4821 0xad2a0000 0x8fa80004 0x25070001 0xafa70004 0x8fa60004 0x2cc50048 0x14a0fff1 0x0 0x8fa20040 0x30590002 0x13200050 0x3c020010 0x3c1f2aaa 0x37e3aaab 0x24060800 0x3c050178 0x3c040170 0x34088004 0x8d070000 0x8c4ffe4c 0xf3c02 0xafa70008 0x8c4dfe50 0xd7402 0xafae002c 0x904cfe61 0x318b001f 0xafab0000 0x8fab0008 0x8fac002c 0x8fb80000 0x3030018 0x184fc3 0x4010 0x1094023 0x85040 0x8f8c0 0x250d0006 0x3eac823 0xd7080 0x3193823 0x3ae4821 0x8d2a0034 0x77880 0x8fb90048 0x1e73821 0xeaf806 0x33ef001f 0x19c200 0x8fae0038 0x1f86821 0x8faa0044 0xd4880 0x1140001d 0x12e4821 0x299805dd 0x13000020 0x0 0x250a000c 0xa6080 0x3ac5021 0x8d5f0034 0xffc806 0x11660007 0x332a001f 0x25080012 0x86880 0x3ad7021 0x8dcb0034 0xeb4006 0x310a001f 0x31390fff 0x19c200 0x370f0001 0x34088030 0xad0f0000 0x8fa70040 0x30e90008 0x11200006 0xa5380 0x34088000 0x8000054 0xad040000 0x8000085 0x2508000c 0x145f825 0x34088000 0x8000054 0xad1f0000 0x800007e 0x250a0012 0x8fa40040 0x30830001 0x146000e2 0x3c020010 0x8fa60040 0x30c50004 0x10a00198 0x3c02dead 0x3c030002 0x80000ae 0x3442beef 0xafa00004 0x8fa70004 0x2ce90064 0x1520017f 0x0 0x8c6fbffc 0x15e2fff9 0x3c0d0001 0x3c03dead 0x3463beff 0x3c192aaa 0x3c1f0178 0x3c080170 0x3c020010 0x2466fff0 0x35a5c000 0x3724aaab 0x240a0800 0x27e90018 0x25070018 0x34088004 0x8d0c0000 0x8c59fe4c 0x194402 0xafa80008 0x8c58fe50 0x185c02 0xafab002c 0x8c4ffe54 0x31ed00ff 0xafad0018 0x8c4efe00 0xafae0010 0x8c5ffe04 0xafbf000c 0x8c59fe08 0xafb90020 0x9058fe01 0x904bfe02 0x186a00 0xb7c00 0x8fa80018 0x904bfe05 0x1aff821 0x904efe00 0x904ffe06 0x9059fe03 0xac48fe0c 0x3eec021 0x1834021 0x905ffe04 0x196600 0xb7200 0xf6c00 0x1cdc821 0x30cc021 0x904cfe07 0x33f7821 0x904efe09 0x905ffe0a 0xc5e00 0x1eb6821 0xe6200 0x904bfe08 0x904efe0b 0x1fcc00 0x1997821 0x1ebc821 0xefe00 0x33f6021 0x188c821 0x195f02 0x197900 0x30cf823 0x16f7025 0x3ee7826 0x1a86821 0xfc180 0xf4682 0x1af6023 0x1185825 0x16cc026 0x32df821 0x18ce02 0x186a00 0x3f84023 0x32d7025 0x1c8c826 0x1ff6021 0x197c02 0x19fc00 0x30cc021 0x1ff5825 0x1996023 0x16cf826 0x1f4342 0x1f6cc0 0x10d7025 0x31f7823 0x1cf7826 0x904dfe0f 0x904efe0e 0x338c821 0xf5f02 0xf6100 0x16cc025 0x3f9f821 0x904cfe0c 0x32f4023 0xe5c00 0xdce00 0x904dfe0d 0x1ff7821 0x3084026 0x32bc021 0x30cc821 0xd7200 0xf6482 0xfc380 0x32e5821 0x1986825 0x10fc826 0x32dc823 0x17ff821 0x197542 0x195ac0 0x1cb4025 0x33f6026 0x1886023 0xcc1c2 0xcfe40 0x31f6825 0x18f5826 0x16d5823 0xb7402 0xb4400 0x1c87825 0x179c026 0x30fc023 0x18ff02 0x18c900 0x30c4026 0x3f96825 0x10d7023 0xe7c82 0xe6380 0x1cbc826 0x1ecf825 0x33f6823 0x1b84026 0xd7202 0x10e5823 0x316f0fff 0xafaf0014 0x8fac0014 0xac4cfe04 0xac46fe00 0x8fbf0014 0x1fc880 0x325c021 0x8f0d0000 0x31ae001f 0xafae0000 0x8fad0008 0x8fae002c 0x8fb90000 0x3240018 0x1947c3 0x5810 0x1685823 0xb6040 0xb78c0 0x1ecf823 0x256f0006 0xf6080 0x33f4023 0x3acf821 0x8ff90034 0x8c080 0x8faf0048 0x3084021 0x119c006 0x330c001f 0xfca00 0x1997821 0x8fbf0038 0x8fac0044 0xfc080 0x118000cf 0x31f7821 0x29cc05dd 0x118000d2 0x0 0x256c000c 0xcc880 0x3b9c021 0x8f0e0034 0x10ef806 0x11aa0007 0x33ec001f 0x256b0012 0xbf880 0x3bf6021 0x8d8b0034 0x10b6806 0x31ac001f 0x31f90fff 0x19c200 0x370e0001 0x34088030 0xad0e0000 0x8fa80040 0x310f0008 0x11e000b8 0xc5b80 0x34088000 0x80000bd 0xad070000 0x3c089e37 0x3c0c2aaa 0x2446fe4c 0x24050006 0x250379b9 0x3584aaab 0x240a0800 0x3c090178 0x3c070170 0x34088004 0x8d0b0000 0x8c4cfe4c 0xcfc02 0xafbf0008 0x8c59fe4c 0x19c202 0x330f000f 0xafaf0030 0x8c4dfe50 0xd7402 0xafae002c 0x8c4bfe54 0x316800ff 0xafa80018 0x8fac0030 0xcf880 0x3e64021 0x8d19000c 0x19c302 0x330f000f 0xafaf0028 0x8d0d000c 0x31ae003f 0xafae0024 0x8fab0018 0x11650071 0x0 0x8c4ffe00 0xafaf0010 0x8c4cfe04 0xafac000c 0x8c48fe08 0xafa80020 0x8fae0010 0x8fab000c 0x8fa80020 0x1c3f821 0x1637821 0x3e86823 0x1afc823 0x8c342 0x338c826 0x1e86023 0x1995823 0x197200 0x1cb7026 0x119f823 0x3eec023 0xe6b42 0x1b8c026 0x32e7823 0x1f84023 0x186302 0x1886026 0x1d85823 0x16cc823 0xcfc00 0x3f9c826 0x30c6823 0x1b97023 0x197942 0x1ee7026 0x1994023 0x10ef823 0xe58c2 0x17f6026 0x32ec023 0x30c7823 0xc6a80 0x1af5826 0x1cc4023 0x10bf823 0xbcbc2 0x33fc026 0xafb80014 0x8fad0014 0x31af001f 0xafaf0000 0x8fad0008 0x8fae002c 0x8fbf0000 0x3e40018 0x1f47c3 0x5810 0x1685823 0xbc840 0xb60c0 0x1997823 0x256c0006 0xcc880 0x3ef4023 0x3b9f821 0x8fef0034 0x8c080 0x8fac0048 0x3084021 0x10fc006 0x3319001f 0xc7a00 0x32f6021 0x8fbf0038 0x8fb90044 0xcc080 0x1320001d 0x31f7821 0x29ce05dd 0x11c00032 0x0 0x256c000c 0xc6080 0x3acc821 0x8f3f0034 0x11fc006 0x11aa0007 0x330c001f 0x256b0012 0xbc080 0x3b87021 0x8dcb0034 0x10b6806 0x31ac001f 0x31ed0fff 0xdca00 0x373f0001 0x34088030 0xad1f0000 0x8fa80040 0x310f0008 0x11e00006 0xc5b80 0x34088000 0x800018c 0xad070000 0x8000201 0x256b000c 0x1696025 0x34088000 0x800018c 0xad0c0000 0x8fae0024 0x31cb0010 0x1160ff8d 0x0 0x8fb90028 0x8fbf0030 0x8faf002c 0x3f9c021 0x186880 0x15afff86 0x0 0x8d0e0004 0xe5c02 0xafab001c 0x8fac001c 0x3188001f 0x80001db 0xafa80000 0x80001fa 0x256c0012 0x8fb80004 0x270e0001 0xafae0004 0x8fa40004 0x2c8a0064 0x1140fe7c 0x0 0x800022c 0x0 0x8000172 0x256b000c 0x1696825 0x34088000 0x80000bd 0xad0d0000 0x800016b 0x256c0012 0x1021 0x3e00008 0x27bd0158>;
 				};
 			};
 
@@ -152,6 +158,7 @@
 				freein-fifo-spill-mem-range = <0x0 0x0 0x0 0x200000>;
 				freein-fifo-onchip-num-descs = <0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38>;
 				freein-fifo-spill-num-descs = <0x4b0>;
+				port-fifo-en = <0x1>;
 			};
 
 			vfbid-config {
@@ -442,9 +449,11 @@
 			ucore {
 
 				src@1 {
-					num-opcodes = <0x25c>;
+					num-opcodes = <0x240>;
+					path = "/home/yjin-local/bcm-sdk/sdk-base/sysconfig/nae/ucore/linux-ucore.c";
+					timestamp = "Tue Apr  9 11:08:25 2013\n";
 					mask = <0xffff>;
-					opcodes = <0x3c1c0010 0x279cf808 0x3c020010 0x2442f808 0x3c030010 0x2463f808 0xac400000 0x43082b 0x1420fffd 0x24420004 0x3c1d0010 0x27bdf9c0 0x27a50020 0x27a60028 0xaca00000 0xacc00000 0xc000029 0x2021 0x1000ffff 0x0 0x3c020000 0x8c4209a4 0x27bdffe0 0x2403ffff 0xafbf001c 0xafb10018 0x10430009 0xafb00014 0x3c100000 0x261009a4 0x2411ffff 0x40f809 0x2610fffc 0x8e020000 0x1451fffc 0x0 0x8fbf001c 0x8fb10018 0x8fb00014 0x3e00008 0x27bd0020 0x27bdfe78 0xafa00000 0xafa00004 0xafa00008 0xafa0000c 0xafa00010 0xafa00014 0xafa00018 0xafa0001c 0xafa00020 0xafa00024 0xafa00028 0xafa0002c 0x8fa3002c 0xafbf0184 0x2c620048 0xafbe0180 0xafb7017c 0xafb60178 0xafb50174 0xafb40170 0xafb3016c 0xafb20168 0xafb10164 0xafb00160 0x10400012 0x27a50034 0x3c040001 0x34848000 0x8fb0002c 0x8fae002c 0x107880 0xe6880 0x1a46021 0x8d8b0000 0xaf5021 0xad4b0000 0x8fa9002c 0x25280001 0xafa8002c 0x8fa7002c 0x2ce60048 0x14c0fff2 0x0 0x8fb10040 0x24050002 0x122501b9 0x3c13000f 0x8fa30040 0x24020001 0x1062010f 0x3669fe50 0x8fa70040 0x24060003 0x10e6000d 0x8fbf0184 0x1021 0x8fbe0180 0x8fb7017c 0x8fb60178 0x8fb50174 0x8fb40170 0x8fb3016c 0x8fb20168 0x8fb10164 0x8fb00160 0x3e00008 0x27bd0188 0x3c020001 0x3c0ddead 0x3443bffc 0x8000077 0x35a2beef 0xafa0002c 0x8fac002c 0x2d8b0064 0x156000f1 0x0 0x8c640000 0x1482fff9 0x3c08dead 0x3c02000f 0x3c1e0001 0x3c172aaa 0x3453fe4c 0x3452fe50 0x3451fe54 0x3444fe00 0x3443fe04 0x3446fe08 0x3445fe0c 0x3510beff 0x345ffe01 0x3459fe02 0x3458fe03 0x344ffe05 0x344efe06 0x344dfe07 0x344cfe09 0x350bbeef 0x37cac000 0x80000b3 0x36e9aaab 0x10e000d4 0x0 0x27d4000c 0x14a080 0x3b4b821 0x8ee70034 0x24170800 0x107a006 0x12d70007 0x3294001f 0x27de0012 0x1eb880 0x3b73821 0x8cf60034 0x116f006 0x33d4001f 0x8fa70158 0x8fbe015c 0x1074006 0x3117001f 0x1eb200 0x2f63821 0x74080 0x115f021 0x33d50fff 0x15ba00 0x36e70001 0x34088030 0xad070000 0x3c160178 0x144380 0x36de0018 0x11ea825 0x34088000 0xad150000 0x34088004 0x8d1e0000 0x8e750000 0x15bc02 0xafb70028 0x8e560000 0x164402 0xafa80004 0x8e340000 0x328700ff 0xafa70018 0x8c950000 0xafb50020 0x8c770000 0xafb70024 0x8cd60000 0xafb60010 0x8fa80018 0xaca80000 0x93f40000 0x93270000 0x90960000 0x7ac00 0x14ba00 0x3d04021 0x2f5a021 0x931e0000 0x296b821 0x91f60000 0x91d40000 0x1e3e00 0x90750000 0x2e7b821 0x16f200 0x91a70000 0x14b400 0x3d6a021 0x295f021 0x7ae00 0x3454fe0a 0x91870000 0x3d5b021 0x92950000 0x3454fe0b 0x90de0000 0x92940000 0x73a00 0x15ac00 0xf5a821 0xafa70158 0x14a600 0x2be3821 0xf4a821 0x2c8b021 0x2a84021 0x8f702 0x83900 0x3c7a025 0x2f5a823 0x2b4a826 0x15be82 0x15f180 0x2d53823 0x2fea025 0x287a026 0x1164021 0x14f200 0x14b602 0x2a8a821 0x2de3825 0x1144023 0xe84026 0x8bc02 0x8b400 0x2f6f025 0x2a83823 0x295a021 0x3c7a826 0x15bb42 0x15b4c0 0x1143821 0x2f6f025 0x295a023 0x3d4a026 0x2a7a821 0xf44023 0x14bf02 0x14b100 0x3447fe0f 0x2f6f025 0x90f60000 0x3c84026 0xafb60158 0x345efe0e 0x93d60000 0x8fa70158 0x3457fe0d 0x92f70000 0x90be0000 0x73e00 0x16b400 0xf6b021 0xafa70158 0x295a021 0x2de3821 0x17f200 0xfeb021 0x14bc82 0x14f380 0x2d53821 0x1144026 0x2feb025 0x1164023 0x8bd42 0x8f2c0 0x2feb025 0x107a826 0x2b6a823 0x1539c2 0x15f640 0x2b4a026 0xfeb025 0x296f023 0x1ebc02 0x1e3c00 0x2e7b025 0x3c84026 0x1164023 0x8bf02 0x83900 0x115a826 0x2e7b025 0x2b63823 0x7b482 0x7bb80 0x2d7a825 0xfea026 0x295f023 0x3c83826 0x1eba02 0xf7b023 0x32d40fff 0xafb4001c 0x8fbe001c 0xac7e0000 0xac8b0000 0x8fb5001c 0x154080 0x10a3821 0x8cf70000 0x32f6001f 0xafb60030 0x8fb60028 0x8fb70004 0x8fa70030 0xe90018 0x7f7c3 0xa010 0x29ef023 0x1e4040 0x1ea8c0 0x2a8a023 0xf44023 0x27c70006 0x7a880 0x8a080 0x2884021 0x3b5a021 0x8e870034 0x8fb50048 0xafa70158 0xafb5015c 0x8fb50038 0x8fb40044 0x1680ff2e 0x2ae705dd 0x800009b 0x27de000c 0x8000093 0x27d40012 0x8faa002c 0x25490001 0x8000073 0xafa9002c 0x3c059e37 0x3c042aaa 0x34a379b9 0x3662fe4c 0x3485aaab 0x3667fe54 0x24060006 0x366cfe00 0x366bfe04 0x366afe08 0x240d0800 0x8000197 0x3c040178 0x2b3905dd 0x13200095 0x0 0x27ee000c 0xeb080 0x3b6a821 0x8eb40034 0x1149806 0x130d0007 0x326e001f 0x27ff0012 0x1f7080 0x3aef021 0x8fd70034 0x117c006 0x330e001f 0x111b006 0xfa200 0x32d5001f 0x2b49821 0x13c880 0x3309021 0x325f0fff 0x1f7a00 0x35f10001 0x34088030 0xad110000 0xe4380 0x1048025 0x34088000 0xad100000 0x34088004 0x8d0e0000 0x8c550000 0x15a402 0xafb40028 0x8c530000 0x139202 0x3251000f 0xafb10000 0x8d300000 0x107c02 0xafaf0004 0x8cee0000 0x31c800ff 0xafa80018 0x8fbf0000 0x1ff080 0x3c24021 0x8d19000c 0x19c302 0x3317000f 0xafb70008 0x8d16000c 0x32d5003f 0xafb5000c 0x8fb40018 0x1286004b 0x0 0x8d930000 0xafb30020 0x8d720000 0xafb20024 0x8d4f0000 0xafaf0010 0x8fb10020 0x8fae0024 0x8fa80010 0x223c021 0x1c3c821 0x3088023 0x219f023 0x8fb42 0x3df7826 0x328b823 0x2efa823 0xfb200 0x2d57026 0x10fa023 0x28e9023 0xe9b42 0x272b826 0x1ee8823 0x2378023 0x17c302 0x310a026 0x1d7f823 0x3f4c823 0x14f400 0x3d98826 0x2f4b023 0x2d14023 0x11a942 0x2a8f826 0x2919823 0x27f7823 0x1f90c2 0x24ff026 0x23f8023 0x21e7023 0x1ec280 0x30eb826 0x3fec823 0x337b023 0x17abc2 0x2b6a026 0xafb4001c 0x8fb3001c 0x3272001f 0xafb20030 0x8fb80028 0x8fb90004 0x8fb00030 0x2050018 0x10ffc3 0x9010 0x25ff823 0x27f70006 0x1f78c0 0x1f7040 0x17b080 0x1ee8823 0x3b6a821 0x2114023 0x8eb10034 0x8faf0048 0x8fb00038 0x8fb40044 0x8f080 0x1680ff7e 0x3c84021 0x8000183 0x27ff000c 0x8fb7000c 0x32f60010 0x12c0ffb3 0x0 0x8fbf0008 0x8fae0000 0x8fb90004 0x1dff021 0x1ec080 0x1719ffac 0x0 0x8d110004 0x118402 0xafb00014 0x8faf0014 0x31e8001f 0x80001e6 0xafa80030 0x800017c 0x27ee0012 0x3c122aaa 0x3666fe4c 0x3665fe50 0x3664fe61 0x3643aaab 0x24070800 0x8000238 0x3c020178 0x299205dd 0x1240003f 0x0 0x25a9000c 0x9b080 0x3b6a821 0x8eb40034 0x1149806 0x11670007 0x3269001f 0x25ad0012 0xdf080 0x3bec821 0x8f380034 0x118b806 0x32e9001f 0x10a9006 0x3250001f 0xf8a00 0x2117821 0xf6880 0x1ae6021 0x318b0fff 0xb7200 0x35ca0001 0x34088030 0xad0a0000 0x94380 0x102f825 0x34088000 0xad1f0000 0x34088004 0x8d090000 0x8cd10000 0x118402 0xafb00028 0x8caf0000 0xf6c02 0xafad0004 0x908c0000 0x318b001f 0xafab0030 0x8fab0028 0x8fac0004 0x8fbe0030 0x3c30018 0x1e57c3 0x7010 0x1ca6823 0x25b70006 0xd4040 0xd48c0 0x17b080 0x128f823 0x3b6a821 0x8eaa0034 0x3dfc023 0x8faf0048 0x8fae0038 0x8fb40044 0x18c880 0x1680ffc2 0x3384021 0x8000224 0x25ad000c 0x800021d 0x25a90012>;
+					opcodes = <0x3c1c0010 0x279cf808 0x3c020010 0x2442f808 0x3c030010 0x2463f808 0xac400000 0x43082b 0x1420fffd 0x24420004 0x3c1d0010 0x27bdf9c0 0x27a50020 0x27a60028 0xaca00000 0xacc00000 0xc000029 0x2021 0x1000ffff 0x0 0x3c020000 0x8c420934 0x27bdffe0 0x2403ffff 0xafbf001c 0xafb10018 0x10430009 0xafb00014 0x3c100000 0x26100934 0x2411ffff 0x40f809 0x2610fffc 0x8e020000 0x1451fffc 0x0 0x8fbf001c 0x8fb10018 0x8fb00014 0x3e00008 0x27bd0020 0x27bdfea8 0xafa00030 0xafa0002c 0xafa00028 0xafa00024 0xafa00020 0xafa0001c 0xafa00018 0xafa00014 0xafa00010 0xafa0000c 0xafa00008 0xafa00004 0x8fa30004 0x2c620048 0x10400012 0x3c040001 0x34848000 0x8fb80004 0x8fad0004 0x187080 0xd6080 0x1845821 0x8d6a0000 0x27af0034 0x1ee4821 0xad2a0000 0x8fa80004 0x25070001 0xafa70004 0x8fa60004 0x2cc50048 0x14a0fff1 0x0 0x8fa20040 0x30590002 0x13200050 0x3c020010 0x3c1f2aaa 0x37e3aaab 0x24060800 0x3c050178 0x3c040170 0x34088004 0x8d070000 0x8c4ffe4c 0xf3c02 0xafa70008 0x8c4dfe50 0xd7402 0xafae002c 0x904cfe61 0x318b001f 0xafab0000 0x8fab0008 0x8fac002c 0x8fb80000 0x3030018 0x184fc3 0x4010 0x1094023 0x85040 0x8f8c0 0x250d0006 0x3eac823 0xd7080 0x3193823 0x3ae4821 0x8d2a0034 0x77880 0x8fb90048 0x1e73821 0xeaf806 0x33ef001f 0x19c200 0x8fae0038 0x1f86821 0x8faa0044 0xd4880 0x1140001d 0x12e4821 0x299805dd 0x13000020 0x0 0x250a000c 0xa6080 0x3ac5021 0x8d5f0034 0xffc806 0x11660007 0x332a001f 0x25080012 0x86880 0x3ad7021 0x8dcb0034 0xeb4006 0x310a001f 0x31390fff 0x19c200 0x370f0001 0x34088030 0xad0f0000 0x8fa70040 0x30e90008 0x11200006 0xa5380 0x34088000 0x8000054 0xad040000 0x8000085 0x2508000c 0x145f825 0x34088000 0x8000054 0xad1f0000 0x800007e 0x250a0012 0x8fa40040 0x30830001 0x146000e2 0x3c020010 0x8fa60040 0x30c50004 0x10a00198 0x3c02dead 0x3c030002 0x80000ae 0x3442beef 0xafa00004 0x8fa70004 0x2ce90064 0x1520017f 0x0 0x8c6fbffc 0x15e2fff9 0x3c0d0001 0x3c03dead 0x3463beff 0x3c192aaa 0x3c1f0178 0x3c080170 0x3c020010 0x2466fff0 0x35a5c000 0x3724aaab 0x240a0800 0x27e90018 0x25070018 0x34088004 0x8d0c0000 0x8c59fe4c 0x194402 0xafa80008 0x8c58fe50 0x185c02 0xafab002c 0x8c4ffe54 0x31ed00ff 0xafad0018 0x8c4efe00 0xafae0010 0x8c5ffe04 0xafbf000c 0x8c59fe08 0xafb90020 0x9058fe01 0x904bfe02 0x186a00 0xb7c00 0x8fa80018 0x904bfe05 0x1aff821 0x904efe00 0x904ffe06 0x9059fe03 0xac48fe0c 0x3eec021 0x1834021 0x905ffe04 0x196600 0xb7200 0xf6c00 0x1cdc821 0x30cc021 0x904cfe07 0x33f7821 0x904efe09 0x905ffe0a 0xc5e00 0x1eb6821 0xe6200 0x904bfe08 0x904efe0b 0x1fcc00 0x1997821 0x1ebc821 0xefe00 0x33f6021 0x188c821 0x195f02 0x197900 0x30cf823 0x16f7025 0x3ee7826 0x1a86821 0xfc180 0xf4682 0x1af6023 0x1185825 0x16cc026 0x32df821 0x18ce02 0x186a00 0x3f84023 0x32d7025 0x1c8c826 0x1ff6021 0x197c02 0x19fc00 0x30cc021 0x1ff5825 0x1996023 0x16cf826 0x1f4342 0x1f6cc0 0x10d7025 0x31f7823 0x1cf7826 0x904dfe0f 0x904efe0e 0x338c821 0xf5f02 0xf6100 0x16cc025 0x3f9f821 0x904cfe0c 0x32f4023 0xe5c00 0xdce00 0x904dfe0d 0x1ff7821 0x3084026 0x32bc021 0x30cc821 0xd7200 0xf6482 0xfc380 0x32e5821 0x1986825 0x10fc826 0x32dc823 0x17ff821 0x197542 0x195ac0 0x1cb4025 0x33f6026 0x1886023 0xcc1c2 0xcfe40 0x31f6825 0x18f5826 0x16d5823 0xb7402 0xb4400 0x1c87825 0x179c026 0x30fc023 0x18ff02 0x18c900 0x30c4026 0x3f96825 0x10d7023 0xe7c82 0xe6380 0x1cbc826 0x1ecf825 0x33f6823 0x1b84026 0xd7202 0x10e5823 0x316f0fff 0xafaf0014 0x8fac0014 0xac4cfe04 0xac46fe00 0x8fbf0014 0x1fc880 0x325c021 0x8f0d0000 0x31ae001f 0xafae0000 0x8fad0008 0x8fae002c 0x8fb90000 0x3240018 0x1947c3 0x5810 0x1685823 0xb6040 0xb78c0 0x1ecf823 0x256f0006 0xf6080 0x33f4023 0x3acf821 0x8ff90034 0x8c080 0x8faf0048 0x3084021 0x119c006 0x330c001f 0xfca00 0x1997821 0x8fbf0038 0x8fac0044 0xfc080 0x118000cf 0x31f7821 0x29cc05dd 0x118000d2 0x0 0x256c000c 0xcc880 0x3b9c021 0x8f0e0034 0x10ef806 0x11aa0007 0x33ec001f 0x256b0012 0xbf880 0x3bf6021 0x8d8b0034 0x10b6806 0x31ac001f 0x31f90fff 0x19c200 0x370e0001 0x34088030 0xad0e0000 0x8fa80040 0x310f0008 0x11e000b8 0xc5b80 0x34088000 0x80000bd 0xad070000 0x3c089e37 0x3c0c2aaa 0x2446fe4c 0x24050006 0x250379b9 0x3584aaab 0x240a0800 0x3c090178 0x3c070170 0x34088004 0x8d0b0000 0x8c4cfe4c 0xcfc02 0xafbf0008 0x8c59fe4c 0x19c202 0x330f000f 0xafaf0030 0x8c4dfe50 0xd7402 0xafae002c 0x8c4bfe54 0x316800ff 0xafa80018 0x8fac0030 0xcf880 0x3e64021 0x8d19000c 0x19c302 0x330f000f 0xafaf0028 0x8d0d000c 0x31ae003f 0xafae0024 0x8fab0018 0x11650071 0x0 0x8c4ffe00 0xafaf0010 0x8c4cfe04 0xafac000c 0x8c48fe08 0xafa80020 0x8fae0010 0x8fab000c 0x8fa80020 0x1c3f821 0x1637821 0x3e86823 0x1afc823 0x8c342 0x338c826 0x1e86023 0x1995823 0x197200 0x1cb7026 0x119f823 0x3eec023 0xe6b42 0x1b8c026 0x32e7823 0x1f84023 0x186302 0x1886026 0x1d85823 0x16cc823 0xcfc00 0x3f9c826 0x30c6823 0x1b97023 0x197942 0x1ee7026 0x1994023 0x10ef823 0xe58c2 0x17f6026 0x32ec023 0x30c7823 0xc6a80 0x1af5826 0x1cc4023 0x10bf823 0xbcbc2 0x33fc026 0xafb80014 0x8fad0014 0x31af001f 0xafaf0000 0x8fad0008 0x8fae002c 0x8fbf0000 0x3e40018 0x1f47c3 0x5810 0x1685823 0xbc840 0xb60c0 0x1997823 0x256c0006 0xcc880 0x3ef4023 0x3b9f821 0x8fef0034 0x8c080 0x8fac0048 0x3084021 0x10fc006 0x3319001f 0xc7a00 0x32f6021 0x8fbf0038 0x8fb90044 0xcc080 0x1320001d 0x31f7821 0x29ce05dd 0x11c00032 0x0 0x256c000c 0xc6080 0x3acc821 0x8f3f0034 0x11fc006 0x11aa0007 0x330c001f 0x256b0012 0xbc080 0x3b87021 0x8dcb0034 0x10b6806 0x31ac001f 0x31ed0fff 0xdca00 0x373f0001 0x34088030 0xad1f0000 0x8fa80040 0x310f0008 0x11e00006 0xc5b80 0x34088000 0x800018c 0xad070000 0x8000201 0x256b000c 0x1696025 0x34088000 0x800018c 0xad0c0000 0x8fae0024 0x31cb0010 0x1160ff8d 0x0 0x8fb90028 0x8fbf0030 0x8faf002c 0x3f9c021 0x186880 0x15afff86 0x0 0x8d0e0004 0xe5c02 0xafab001c 0x8fac001c 0x3188001f 0x80001db 0xafa80000 0x80001fa 0x256c0012 0x8fb80004 0x270e0001 0xafae0004 0x8fa40004 0x2c8a0064 0x1140fe7c 0x0 0x800022c 0x0 0x8000172 0x256b000c 0x1696825 0x34088000 0x80000bd 0xad0d0000 0x800016b 0x256c0012 0x1021 0x3e00008 0x27bd0158>;
 				};
 			};
 
@@ -452,6 +461,7 @@
 				freein-fifo-spill-mem-range = <0x0 0x0 0x0 0x200000>;
 				freein-fifo-onchip-num-descs = <0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38 0x38>;
 				freein-fifo-spill-num-descs = <0x4b0>;
+				port-fifo-en = <0x1>;
 			};
 
 			vfbid-config {
@@ -717,9 +727,9 @@
 	};
 
 	frequency-config {
-		nae = <0xfa>;
-		sae = <0xfa>;
-		rsa = <0xfa>;
+		nae = <0x1f4>;
+		sae = <0x1f4>;
+		rsa = <0x1f4>;
 		dtre = <0xfa>;
 		cde = <0xfa>;
 	};
diff --git a/arch/mips/include/asm/bootinfo.h b/arch/mips/include/asm/bootinfo.h
index 84e411b..581a416 100644
--- a/arch/mips/include/asm/bootinfo.h
+++ b/arch/mips/include/asm/bootinfo.h
@@ -94,6 +94,7 @@ extern unsigned long mips_machtype;
 #define BOOT_MEM_RAM		1
 #define BOOT_MEM_ROM_DATA	2
 #define BOOT_MEM_RESERVED	3
+#define BOOT_MEM_INIT_RAM	4
 
 /*
  * A memory map that's built upon what was determined
@@ -121,7 +122,7 @@ extern void free_init_pages(const char *what,
 /*
  * Initial kernel command line, usually setup by prom_init()
  */
-extern char arcs_cmdline[CL_SIZE];
+extern char arcs_cmdline[COMMAND_LINE_SIZE];
 
 /*
  * Registers a0, a1, a3 and a4 as passed to the kernel entry by firmware
@@ -133,4 +134,16 @@ extern unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
  */
 extern void plat_mem_setup(void);
 
+#ifdef CONFIG_SWIOTLB
+/*
+ * Optional platform hook to call swiotlb_setup().
+ */
+extern void plat_swiotlb_setup(void);
+
+#else
+
+static inline void plat_swiotlb_setup(void) {}
+
+#endif /* CONFIG_SWIOTLB */
+
 #endif /* _ASM_BOOTINFO_H */
diff --git a/arch/mips/include/asm/netlogic/gpio.h b/arch/mips/include/asm/netlogic/gpio.h
index 33dce08..b507852 100644
--- a/arch/mips/include/asm/netlogic/gpio.h
+++ b/arch/mips/include/asm/netlogic/gpio.h
@@ -74,6 +74,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define gpio_get_value __gpio_get_value
 #define gpio_set_value __gpio_set_value
 #define gpio_cansleep __gpio_cansleep
-#define gpio_to_irq(gpio) NULL
+//#define gpio_to_irq(gpio) NULL
+extern int gpio_to_irq(unsigned gpio);
 #endif
 #endif
diff --git a/arch/mips/include/asm/netlogic/hal/fdt_helper.h b/arch/mips/include/asm/netlogic/hal/fdt_helper.h
new file mode 100644
index 0000000..b25a02b
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/fdt_helper.h
@@ -0,0 +1,91 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#if !defined(__KERNEL__) && !defined(NLM_HAL_NETLBOOT)
+#include <stdint.h>
+#endif
+
+/**
+ * open_fdt - get pointer to fdt blob for given file descriptor
+ * @fd: file descriptor for dtb
+ *
+ * returns:
+ * 	pointer to fdt blob, on success
+ * 	NULL, on error
+ */
+extern void *open_fdt(int fd);
+
+
+enum prop_type {
+	PROP_STR = 0,
+	PROP_CELL
+};
+
+/**
+ * copy_fdt_prop - copies value of given path and property
+ * @fdt: pointer to fdt blob
+ * @path: path of node to find
+ * @prop: property to find
+ * @type: type of property
+ * @buf: pointer to buffer (copy destination)
+ * @len: size of buffer (copy destination)
+ *
+ * returns:
+ * 	bytes copied to buffer, on success
+ * 	-FDT_ERR_BADPATH, given path does not begin with '/' or is invalid
+ * 	-FDT_ERR_NOTFOUND, node does not exist or does not have named property
+ * 	-FDT_ERR_BADMAGIC,
+ * 	-FDT_ERR_BADVERSION,
+ * 	-FDT_ERR_BADSTATE,
+ * 	-FDT_ERR_BADSTRUCTURE,
+ * 	-FDT_ERR_TRUNCATED, standard meanings
+ */
+extern int copy_fdt_prop(void *fdt, const char *path, const char *prop,
+	enum prop_type type, void *buf, int len);
+
+static inline int copy_fprop_str(void *fdt,
+	const char *path, const char *prop, char *buf, int buflen) {
+	return copy_fdt_prop(fdt, path, prop, PROP_STR, (void *)buf, buflen);
+}
+
+static inline int copy_fprop_cell(void *fdt,
+	const char *path, const char *prop, uint32_t *cells, int numcells) {
+	int len = copy_fdt_prop(fdt, path, prop, PROP_CELL,
+	                        (void *)cells, numcells * sizeof(uint32_t));
+	return len / sizeof(uint32_t);
+}
+
+/**
+ * set_fdt_helper_print - switch for print output from helper functions
+ * @val: zero = off, non-zero = on
+ *
+ * returns:
+ * 	previous setting
+ */
+extern int set_fdt_helper_print(int val);
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h b/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h
new file mode 100644
index 0000000..5983eb5
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h
@@ -0,0 +1,81 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _NLM_EEPROM_H
+#define _NLH_EEPROM_H
+
+#include "nlm_hal.h"
+/* MACID i2c memory definitions
+ */
+#define MAGIC_OFF   		0x00
+#define MAGIC_LEN   		0x02
+#define MAC_MAGIC_BYTE0 	0xAA
+#define MAC_MAGIC_BYTE1 	0x55
+#define MAC_OFF     		0x02
+#define MAC_LEN     		0x06
+
+#define NAME_OFF     		0x10
+#define NAME_LEN     		0x08
+#define REV_OFF     		0x18
+#define REV_LEN     		0x03
+#define SN_OFF      		0x1B
+#define SN_LEN      		0x04
+#define UPD_OFF     		0x1F
+#define UPD_LEN     		0x02
+
+
+struct eeprom_data{
+	unsigned char magic_bytes0[MAGIC_LEN];
+	unsigned char mac_addr0[MAC_LEN];
+	unsigned char magic_bytes1[MAGIC_LEN];
+	unsigned char mac_addr1[MAC_LEN];
+	unsigned char name[NAME_LEN];
+	unsigned char revision[REV_LEN];
+	unsigned char srnum[SN_LEN];
+	unsigned char upd[UPD_LEN];
+
+	unsigned char i2c_dev_addr;
+	void *priv;
+
+	void(*eeprom_i2c_read_bytes)(unsigned char dev_addr, unsigned int addr, int alen, unsigned char * buf, int len);
+	void(*eeprom_i2c_write_bytes)(unsigned char dev_addr, unsigned int addr, int alen, unsigned char * buf, int len);
+};
+
+extern int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+extern int  eeprom_set_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+extern int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+extern int  eeprom_dump(struct eeprom_data *nlm_eeprom, unsigned char *mac, int offset, int len);
+#endif
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h b/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h
new file mode 100644
index 0000000..d9bf075
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h
@@ -0,0 +1,77 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef __NLM_CPLD_H__
+#define __NLM_CPLD_H__
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#else
+#include "nlm_hal.h"
+#endif
+
+#define CORTINA_ILK1_BASE	0x17100000
+#define CORTINA_ILK2_BASE       0x17200000
+	
+#define NLM_XLP_MAX_CS  7
+
+typedef struct {
+        uint32_t        base;
+        uint32_t        size;
+        uint32_t        swap;
+        uint32_t        devparam;
+}nlm_xlp_nor_t;
+
+#define SWAB16(x)       ((uint16_t)((((uint16_t)x & (uint16_t)0x00FFU) << 8) |  \
+                        (((uint16_t)x & (uint16_t)0xFF00U) >> 8)))
+
+#define SIZE_16MB       (0x1000000)
+#define SIZE_1MB        (0x100000)
+
+#define DC_ILK          0
+#define DC_HIGIG        0
+#define DC_SGMII        1
+#define DC_XAUI         2
+#define DC_NOT_PRSNT    3
+#define DC_RXAUI        6 /*not support by CPLD : Defined for software using only */
+
+#define DC_TYPE(val,slot)       ((val >> (slot * 2)) & 0x3)
+#define EVP_VER(val)            (val & 0x8)
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/mips-exts.h b/arch/mips/include/asm/netlogic/mips-exts.h
index c704324..b8c3087 100644
--- a/arch/mips/include/asm/netlogic/mips-exts.h
+++ b/arch/mips/include/asm/netlogic/mips-exts.h
@@ -268,6 +268,11 @@ static __inline__ int hard_smp_processor_id(void)
 	return cpu;
 }
 
+static __inline__ int netlogic_node_id(void)
+{
+	return hard_smp_processor_id() >> 5;	
+}
+
 static __inline__ int netlogic_cpu_id(void)
 {
 	return hard_smp_processor_id() >> 2;
diff --git a/arch/mips/include/asm/pgtable-64.h b/arch/mips/include/asm/pgtable-64.h
index da7e26d..f8fc0e2 100644
--- a/arch/mips/include/asm/pgtable-64.h
+++ b/arch/mips/include/asm/pgtable-64.h
@@ -45,13 +45,20 @@
  * fault address - VMALLOC_START.
  */
 
+
+/* PGDIR_SHIFT determines what a third-level page table entry can map */
+#ifdef __PAGETABLE_PMD_FOLDED
+#define PGDIR_SHIFT	(PAGE_SHIFT + PAGE_SHIFT + PTE_ORDER - 3)
+#else
+
 /* PMD_SHIFT determines the size of the area a second-level page table can map */
 #define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT + PTE_ORDER - 3))
 #define PMD_SIZE	(1UL << PMD_SHIFT)
 #define PMD_MASK	(~(PMD_SIZE-1))
 
-/* PGDIR_SHIFT determines what a third-level page table entry can map */
+
 #define PGDIR_SHIFT	(PMD_SHIFT + (PAGE_SHIFT + PMD_ORDER - 3))
+#endif
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
@@ -109,13 +116,15 @@
 #endif
 
 #define PTRS_PER_PGD	((PAGE_SIZE << PGD_ORDER) / sizeof(pgd_t))
+#ifndef __PAGETABLE_PMD_FOLDED
 #define PTRS_PER_PMD	((PAGE_SIZE << PMD_ORDER) / sizeof(pmd_t))
+#endif
 #define PTRS_PER_PTE	((PAGE_SIZE << PTE_ORDER) / sizeof(pte_t))
 
-#if PGDIR_SIZE >= TASK_SIZE
+#if PGDIR_SIZE >= TASK_SIZE64
 #define USER_PTRS_PER_PGD       (1)
 #else
-#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
+#define USER_PTRS_PER_PGD	(TASK_SIZE64 / PGDIR_SIZE)
 #endif
 #define FIRST_USER_ADDRESS	0UL
 
@@ -123,7 +132,12 @@
 extern unsigned long __vmalloc_start;
 #define VMALLOC_START		__vmalloc_start
 #else
-#define VMALLOC_START		MAP_BASE
+/*
+ * TLB refill handlers also map the vmalloc area into xuseg.  Avoid
+ * the first couple of pages so NULL pointer dereferences will still
+ * reliably trap.
+ */
+#define VMALLOC_START		(MAP_BASE + (2 * PAGE_SIZE))
 #endif
 
 #define VMALLOC_END	\
@@ -147,15 +161,30 @@ extern unsigned long __vmalloc_start;
 
 #define pte_ERROR(e) \
 	printk("%s:%d: bad pte %016lx.\n", __FILE__, __LINE__, pte_val(e))
+#ifndef __PAGETABLE_PMD_FOLDED
 #define pmd_ERROR(e) \
 	printk("%s:%d: bad pmd %016lx.\n", __FILE__, __LINE__, pmd_val(e))
+#endif
 #define pgd_ERROR(e) \
 	printk("%s:%d: bad pgd %016lx.\n", __FILE__, __LINE__, pgd_val(e))
 
 extern pte_t invalid_pte_table[PTRS_PER_PTE];
 extern pte_t empty_bad_page_table[PTRS_PER_PTE];
+
+
+#ifndef __PAGETABLE_PMD_FOLDED
+/*
+ * For 3-level pagetables we defines these ourselves, for 2-level the
+ * definitions are supplied by <asm-generic/pgtable-nopmd.h>.
+ */
+typedef struct { unsigned long pmd; } pmd_t;
+#define pmd_val(x)	((x).pmd)
+#define __pmd(x)	((pmd_t) { (x) } )
+
+
 extern pmd_t invalid_pmd_table[PTRS_PER_PMD];
 extern pmd_t empty_bad_pmd_table[PTRS_PER_PMD];
+#endif
 
 /*
  * Empty pgd/pmd entries point to the invalid_pte_table.
@@ -176,6 +205,7 @@ static inline void pmd_clear(pmd_t *pmdp)
 {
 	pmd_val(*pmdp) = ((unsigned long) invalid_pte_table);
 }
+#ifndef __PAGETABLE_PMD_FOLDED
 
 /*
  * Empty pud entries point to the invalid_pmd_table.
@@ -199,6 +229,7 @@ static inline void pud_clear(pud_t *pudp)
 {
 	pud_val(*pudp) = ((unsigned long) invalid_pmd_table);
 }
+#endif
 
 #define pte_page(x)		pfn_to_page(pte_pfn(x))
 
@@ -227,6 +258,7 @@ static inline void pud_clear(pud_t *pudp)
 /* to find an entry in a page-table-directory */
 #define pgd_offset(mm, addr)	((mm)->pgd + pgd_index(addr))
 
+#ifndef __PAGETABLE_PMD_FOLDED
 static inline unsigned long pud_page_vaddr(pud_t pud)
 {
 	return pud_val(pud);
@@ -239,6 +271,7 @@ static inline pmd_t *pmd_offset(pud_t * pud, unsigned long address)
 {
 	return (pmd_t *) pud_page_vaddr(*pud) + pmd_index(address);
 }
+#endif
 
 /* Find an entry in the third-level page table.. */
 #define __pte_offset(address)						\
@@ -249,10 +282,7 @@ static inline pmd_t *pmd_offset(pud_t * pud, unsigned long address)
 	((pte_t *) pmd_page_vaddr(*(dir)) + __pte_offset(address))
 #define pte_offset_map(dir, address)					\
 	((pte_t *)page_address(pmd_page(*(dir))) + __pte_offset(address))
-#define pte_offset_map_nested(dir, address)				\
-	((pte_t *)page_address(pmd_page(*(dir))) + __pte_offset(address))
 #define pte_unmap(pte) ((void)(pte))
-#define pte_unmap_nested(pte) ((void)(pte))
 
 /*
  * Initialize a new pgd / pmd table with invalid pointers.
diff --git a/arch/mips/kernel/cevt-r4k.c b/arch/mips/kernel/cevt-r4k.c
index b7698ac..51095dd9 100644
--- a/arch/mips/kernel/cevt-r4k.c
+++ b/arch/mips/kernel/cevt-r4k.c
@@ -164,7 +164,6 @@ int c0_compare_int_usable(void)
 
 int __cpuinit r4k_clockevent_init(void)
 {
-	uint64_t mips_freq = mips_hpt_frequency;
 	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *cd;
 	unsigned int irq;
diff --git a/arch/mips/mm/cerr-nlm.c b/arch/mips/mm/cerr-nlm.c
index 5ac938c..6903d77 100644
--- a/arch/mips/mm/cerr-nlm.c
+++ b/arch/mips/mm/cerr-nlm.c
@@ -24,7 +24,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 *****************************#NETL_2#********************************/
 
 #include <linux/smp.h>
-#include <asm/system.h>
 
 #include <asm/netlogic/iomap.h>
 #include <asm/netlogic/hal/nlm_hal.h>
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index 1d5e3da..076ed1b 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -33,6 +33,7 @@
 #include <asm/war.h>
 #include <asm/uasm.h>
 
+extern unsigned long ebase;
 /*
  * TLB load/store/modify handlers.
  *
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index 54bd989..021cb97 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -6,8 +6,10 @@ obj-$(CONFIG_NLM_XLR)			+= msgring.o
 obj-$(CONFIG_NLM_XLR)			+= msgring_xls.o
 obj-$(CONFIG_NLM_XLR)			+= msgring_shared.o
 
-obj-$(CONFIG_NLM_XLP)			+= nlm_hal_fmn_config.o nlm_evp_cpld.o
-obj-$(CONFIG_NLM_XLP)			+= nlm_hal.o nlm_hal_nae.o fdt_helper.o
+obj-$(CONFIG_NLM_XLP)			+= nlm_hal_sys.o nlm_evp_cpld.o nlm_hal_cpu_info.o
+obj-$(CONFIG_NLM_XLP)			+= nlm_hal.o nlm_eeprom.o fdt_helper.o
+obj-$(CONFIG_NLM_XLP)		+= nlm_hal_mdio.o
+obj-$(CONFIG_NLM_XLP)		+= nlm_hal_fmn_config.o
 
 ifeq ($(CONFIG_NLM_CORTINA_SUPPORT),y)
 obj-y					+= cortina_cs34x7/nlm_cortina_cs34x7.o cortina_cs34x7/nlm_cortina_cs34x7_p1.o cortina_cs34x7/nlm_cortina_cs34x7_p2.o \
diff --git a/arch/mips/netlogic/common/fdt_helper.c b/arch/mips/netlogic/common/fdt_helper.c
new file mode 100644
index 0000000..310ca7f
--- /dev/null
+++ b/arch/mips/netlogic/common/fdt_helper.c
@@ -0,0 +1,172 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#if defined(__KERNEL__)
+#if !defined(NLM_HAL_UBOOT)
+#include <linux/kernel.h>
+#endif
+#else
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#if !defined(NLM_HAL_NETLBOOT) && !defined(NLM_HAL_NETOS)
+#include <sys/mman.h>
+#endif
+#endif
+
+#include "libfdt.h"
+#include "fdt_helper.h"
+
+static int fdt_helper_print  = 1;
+
+extern int printf(const char *format, ...);
+#if !defined(__KERNEL__)
+#define fdtprint(x...) do {   \
+	if (fdt_helper_print) \
+		printf(x);    \
+} while (0)
+#elif defined(NLM_HAL_UBOOT)
+#define fdtprint(x...) do {   \
+	if (fdt_helper_print) \
+		printf(x);    \
+} while (0)
+#else
+#define fdtprint(x...) do {   \
+	if (fdt_helper_print) \
+		printk(x);    \
+} while (0)
+#endif
+
+int set_fdt_helper_print(int val)
+{
+	int old_val = fdt_helper_print;
+	fdt_helper_print = val;
+	return old_val;
+}
+
+#if !defined(__KERNEL__) && !defined(NLM_HAL_NETOS) && !defined(NLM_HAL_NETLBOOT)
+void *open_fdt(int fd)
+{
+	struct stat st;
+	if (fstat(fd, &st) < 0) {
+		perror("fstat");
+		return NULL;
+	}
+
+	void *fdt;
+	fdt = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (fdt == MAP_FAILED) {
+		perror("mmap");
+		return NULL;
+	}
+	return fdt;
+}
+#else
+void *open_fdt(int fd) { return NULL; }
+#endif
+
+static void print_fdt_prop(const char *path, const char *prop,
+	enum prop_type type, const void *buf, int len)
+{
+#if 0
+	fdtprint("FDT: parsed %s.%s: ", path, prop);
+	if (type == PROP_CELL) {
+		const uint32_t *dst = (const uint32_t *)buf;
+		int cells = len / sizeof(uint32_t);
+		int i;
+
+		fdtprint("cells=%d val=", cells);
+		for (i = 0; i < cells; i++) {
+			fdtprint("0x%x(%d),", dst[i], dst[i]);
+		}
+	}
+	else {
+		fdtprint("len=%d val=%s", len, (const char *)buf);
+	}
+	fdtprint("\n");
+#endif
+}
+
+int copy_fdt_prop(void *fdt, const char *path, const char *prop,
+	enum prop_type type, void *buf, int len)
+{
+	int nodeoffset;
+	const void *pval;
+	int plen;
+	int copylen;
+
+	if (len <= 0)  {
+		fdtprint("Warning: Len is 0 while copying %s/%s\n", path, prop);
+		return -1;
+	}
+
+	nodeoffset = fdt_path_offset(fdt, path);
+	if (nodeoffset < 0) {
+#if 0
+		fdtprint("%s: Failed to parse path %s\n",
+		         fdt_strerror(nodeoffset), path);
+#endif
+		return nodeoffset;
+	}
+
+	pval = fdt_getprop(fdt, nodeoffset, prop, &plen);
+	if (pval == NULL) {
+#if 0
+		fdtprint("%s: Failed to parse property %s\n",
+		         fdt_strerror(plen), prop);
+#endif
+		return plen;
+	}
+
+	if (plen > len) {
+		fdtprint("WARNING: buf of %d is insufficient to store %d (%s/%s)\n",
+		         len, plen, path, prop);
+		copylen = len;
+	}
+	else {
+		copylen = plen;
+	}
+
+	if (type == PROP_CELL) {
+		const uint32_t *src = (const uint32_t *)pval;
+		uint32_t *dst = (uint32_t *)buf;
+		int i;
+		for (i = 0; i < copylen / sizeof(uint32_t); i++) {
+			dst[i] = fdt32_to_cpu(src[i]);
+		}
+	}
+	else {
+		memcpy(buf, pval, copylen);
+	}
+
+ 	print_fdt_prop(path, prop, type, buf, copylen); 
+
+	return copylen;
+}
diff --git a/arch/mips/netlogic/common/nlm_eeprom.c b/arch/mips/netlogic/common/nlm_eeprom.c
new file mode 100644
index 0000000..3381c04
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_eeprom.c
@@ -0,0 +1,125 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/netlogic/hal/nlm_eeprom.h>
+#else
+#include "nlm_eeprom.h"
+#endif
+
+
+int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
+{
+	unsigned char *eeprom_mac;
+	unsigned int offset;
+	unsigned char dev_addr;
+
+	if(nlm_eeprom==NULL){
+		return -1;
+	}
+
+	dev_addr = nlm_eeprom->i2c_dev_addr;
+	eeprom_mac = interface?(nlm_eeprom->mac_addr1):(nlm_eeprom->mac_addr0);
+
+	offset= (unsigned int) (interface?(unsigned long)(((struct eeprom_data*)0)->mac_addr1):(unsigned long)(((struct eeprom_data*)0)->mac_addr0));
+	nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0, eeprom_mac, MAC_LEN);
+	memcpy(mac, eeprom_mac, MAC_LEN);
+	return 0;
+}
+
+int  eeprom_set_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
+{
+	unsigned char *eeprom_mac;
+	unsigned char dev_addr,i;
+	unsigned int offset;
+	if(nlm_eeprom==NULL){
+		return -1;
+	}
+	dev_addr = nlm_eeprom->i2c_dev_addr;
+
+	eeprom_mac = interface?(nlm_eeprom->mac_addr1):(nlm_eeprom->mac_addr0);
+	for(i=0;i<6;i++){
+                eeprom_mac[i]= mac[i];
+        }
+	offset= (unsigned int)(interface?(unsigned long)(((struct eeprom_data*)0)->mac_addr1):(unsigned long)(((struct eeprom_data*)0)->mac_addr0));
+	nlm_eeprom->eeprom_i2c_write_bytes(dev_addr, offset,0, eeprom_mac, MAC_LEN);
+	return 0;
+}
+int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
+{
+        unsigned char *eeprom_mac;
+        unsigned int offset;
+        unsigned char dev_addr;
+
+        if(nlm_eeprom==NULL){
+                return -1;
+        }
+
+        dev_addr = nlm_eeprom->i2c_dev_addr;
+        eeprom_mac = interface?(nlm_eeprom->magic_bytes1):(nlm_eeprom->magic_bytes0);
+
+        offset= (unsigned int)(interface?(unsigned long)(((struct eeprom_data*)0)->magic_bytes1):(unsigned long)(((struct eeprom_data*)0)->magic_bytes0));
+        nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0, eeprom_mac, MAGIC_LEN);
+        memcpy(mac, eeprom_mac, MAGIC_LEN);
+        return 0;
+}
+int  eeprom_dump(struct eeprom_data *nlm_eeprom, unsigned char *mac, int offset, int len)
+{
+
+        unsigned char dev_addr;
+
+        if(nlm_eeprom==NULL){
+                return -1;
+        }
+
+        dev_addr   = nlm_eeprom->i2c_dev_addr;
+
+        nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0,mac,len);
+        return 0;
+}
+
+
+#ifdef NLM_HAL_LINUX_KERNEL
+/*Add  API here if any API  from above is needed*/
+EXPORT_SYMBOL(eeprom_get_mac_addr);
+EXPORT_SYMBOL(eeprom_set_mac_addr);
+EXPORT_SYMBOL(eeprom_get_magic_bytes);
+EXPORT_SYMBOL(eeprom_dump);
+#endif
+
diff --git a/arch/mips/netlogic/common/nlm_evp_cpld.c b/arch/mips/netlogic/common/nlm_evp_cpld.c
new file mode 100644
index 0000000..5329b4f
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_evp_cpld.c
@@ -0,0 +1,247 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/netlogic/hal/nlm_evp_cpld.h>
+#include <asm/netlogic/hal/nlm_hal_sys.h>
+#else
+#include <byteorder.h>
+#include "nlm_evp_cpld.h"
+#include "nlm_hal_sys.h"
+#endif
+
+
+static nlm_xlp_nor_t xlp_nor_dev[8] = {
+{ 0x16000000, SIZE_16MB, 0, 0x2e00 },
+{ 0xffffffff, 0, 0, 0 },
+{ 0x17000000, SIZE_1MB , 1, 0x2C00 },
+{ 0x17200000, SIZE_1MB , 0, 0x2C00 },
+{ 0x17300000, SIZE_1MB , 0, 0x2f84 },
+{ 0xffffffff, 0, 0, 0 },
+{ 0xffffffff, 0, 0, 0 },
+{ 0xffffffff, 0, 0, 0 },
+};
+
+static inline uint32_t nlm_hal_nor_read(uint32_t reg)
+{
+        return nlm_hal_read_32bit_reg(NLM_NOR_CFG_BASE, reg);
+}
+
+static inline void nlm_hal_nor_write(uint32_t reg, uint32_t val)
+{
+        nlm_hal_write_32bit_reg(NLM_NOR_CFG_BASE, reg, val);
+}
+
+uint16_t nlm_hal_cpld_read_16(int cs, uint16_t reg)
+{
+#ifndef CONFIG_N511
+        uint16_t val;
+	if ((cs == 3) || (cs ==4))
+	        nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , 0x2f84);
+	
+	val = nlm_hal_read_16bit_reg(xlp_nor_dev[cs].base, reg);
+        return (xlp_nor_dev[cs].swap ? le16_to_cpu(val): be16_to_cpu(val));
+#else
+	return 0;
+#endif
+}
+
+void nlm_hal_cpld_write_16(int cs, uint16_t val, uint16_t reg)
+{
+#ifndef CONFIG_N511
+        uint16_t data = xlp_nor_dev[cs].swap ? cpu_to_le16(val): cpu_to_be16(val);
+	if ((cs == 3) || (cs ==4))
+	        nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , 0x2d84);
+
+        nlm_hal_write_16bit_reg(xlp_nor_dev[cs].base, reg, data);
+#else
+#endif
+}
+
+int nlm_xlp_boardver(void)
+{
+	uint16_t data = nlm_hal_cpld_read_16(2, 5);
+	return ((EVP_VER(data) >> 3) + 1);
+}
+
+int nlm_xlp_cpldver(void)
+{
+	return nlm_hal_cpld_read_16(2, 0);
+}
+
+int is_xlp_evp1(void)
+{
+#ifndef CONFIG_N511
+        uint16_t data = nlm_hal_cpld_read_16(2, 5);
+
+        if (EVP_VER(data) == 0)
+                return 1;
+        else
+#endif
+                return 0;
+}
+
+int is_xlp_evp2(void)
+{
+#ifndef CONFIG_N511
+        uint16_t data = nlm_hal_cpld_read_16(2, 5);
+
+        if (EVP_VER(data))
+                return 1;
+        else
+#endif
+                return 0;
+}
+
+int is_ilk_card_onslot(int slot)
+{
+	uint16_t data = nlm_hal_cpld_read_16(2, 6);
+
+	slot >>= 1;
+
+	if (DC_TYPE(data, slot) == DC_ILK) 
+		return 1;
+	else
+		return 0;
+}
+
+#if defined(NLM_HAL_LINUX_USER) || defined(NLM_HAL_LINUX_KERNEL)
+/* cop0 hwren register should be set */
+static inline int my_cpu_id(void)
+{
+	unsigned int cpu = 0;
+
+	__asm__ volatile (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"rdhwr %0, $0\n"
+			".set pop\n"
+			: "=r" (cpu)
+			:);
+
+	return cpu;
+}
+#endif
+
+int nlm_get_interface_type(int node, int slot)
+{
+	uint16_t data;
+       
+	/* there is no cpld in the existing multi node board for node 1-3 */
+#if defined(NLM_HAL_LINUX_USER) || defined(NLM_HAL_LINUX_KERNEL)
+	if(my_cpu_id() >= 32)
+		return DC_NOT_PRSNT;
+#endif
+	
+	data = nlm_hal_cpld_read_16(2, 6);
+	nlm_print("Slot present status 0x%x\n", (data & 0xFF));
+        if (slot == 4)
+                return DC_SGMII;
+
+        if (nlm_xlp_cpldver() == 0)
+                return DC_NOT_PRSNT;
+
+#ifdef SKIP_INTERFACE_TYPE_FROMCPLD
+	return DC_NOT_PRSNT;
+#else
+	if (slot == 2)
+		slot >>= 1;
+	else if (slot == 1)
+		slot <<= 1;
+	return DC_TYPE(data, slot);
+#endif
+}
+
+int xlp_cpld_init(uint32_t cs)
+{
+	unsigned long base = xlp_nor_dev[cs].base;
+	unsigned long limit = base + xlp_nor_dev[cs].size - 1;
+
+	if (cs > NLM_XLP_MAX_CS)
+		return -1;
+
+	nlm_hal_nor_write(XLP_NOR_CS_BASE + cs , (base >> 8));
+	nlm_hal_nor_write(XLP_NOR_CS_LIMIT + cs , (limit >> 8));
+
+	nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , xlp_nor_dev[cs].devparam); 
+
+	nlm_hal_nor_write(XLP_NOR_DEV_TIME0 + (cs * 2), 0x4F646EC2 );
+	nlm_hal_nor_write(XLP_NOR_DEV_TIME1 + (cs * 2), 0x8CF3);
+
+	return 0;
+}
+
+void set_gbu_frequency(int node, int frequency)
+{
+	const uint64_t mhz = 1000000;
+	nlm_print("GBU Frequency set to %d\n", frequency);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_GBU, frequency * mhz);
+	}
+	else {
+		uint64_t set_freq;
+		set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_NOR, frequency * mhz);
+		NLM_HAL_DO_DIV(set_freq,mhz);
+		nlm_print("GBU Frequency set to %lluMHz\n", set_freq);
+	}
+}
+
+void nlm_hal_cpld_init(int node)
+{
+#if !defined(XLP_SIM) || defined(NLM_BOARD)
+	int i;
+	set_gbu_frequency(node, 16);
+	for(i=2; i<5; i++)
+        	xlp_cpld_init(i);
+#endif
+}
+
+#ifdef NLM_HAL_LINUX_KERNEL
+EXPORT_SYMBOL(nlm_hal_cpld_init);
+EXPORT_SYMBOL(nlm_get_interface_type);
+EXPORT_SYMBOL(is_xlp_evp1);
+EXPORT_SYMBOL(is_xlp_evp2);
+EXPORT_SYMBOL(nlm_xlp_boardver);
+EXPORT_SYMBOL(is_ilk_card_onslot);
+EXPORT_SYMBOL(nlm_xlp_cpldver);
+EXPORT_SYMBOL(nlm_hal_cpld_read_16);
+EXPORT_SYMBOL(nlm_hal_cpld_write_16);
+#endif
+
diff --git a/arch/mips/netlogic/common/nlm_hal.c b/arch/mips/netlogic/common/nlm_hal.c
index a4037ee..a5ee0af 100644
--- a/arch/mips/netlogic/common/nlm_hal.c
+++ b/arch/mips/netlogic/common/nlm_hal.c
@@ -94,7 +94,7 @@
 #include "nlm_hal_xlp_dev.h"
 #include "nlm_hal_sys.h"
 #include "libfdt.h"
-//#include "fdt_helper.h"
+#include "fdt_helper.h"
 
 /* These addresses are computed by the nlm_hal_init() */
 unsigned long xlp_io_base;
@@ -134,14 +134,13 @@ void nlm_hal_config_sgmii_if(int node, int inf);
 struct nlm_hal_ext_phy * get_phy_info(int inf);
 #define MAX_PHYS 18
 /*PHYs */
-struct nlm_hal_ext_phy  known_ext_phys[] = {
+static struct nlm_hal_ext_phy  known_ext_phys[] = {
 		{"mvs103656", 0xc97, 0, 0, 0, mvl_get_phy_status, mvl_start_an, mvl_init_phy},
 		{"bcm5461s", 0x60c1, 0, 0, 0, bcm_get_phy_status, bcm_start_an, bcm_init_phy},
 		{"bcm5482", 0xbcb2, 0, 0, 0, xmc_get_phy_status, xmc_start_an, xmc_init_phy},
 		{"bcm5416", 0x5e74, 0, 0, 0, bcm_get_phy_status, bcm_start_an, bcm_init_phy},
 		{"", 0, 0, 0, 0, NULL, NULL, NULL}
 };
-
 static struct nlm_hal_ext_phy regs_ext_phys[MAX_PHYS];
 
 static __inline__ unsigned int power_on_reset_cfg(void)
@@ -152,24 +151,6 @@ static __inline__ unsigned int power_on_reset_cfg(void)
 #define PCI_MEM_BAR_0 0x4
 #define PCIE_CONTROL_0 0x240
 
-#include <asm/netlogic/haldefs.h>
-#include <asm/netlogic/xlp-hal/iomap.h>
-#include <asm/netlogic/xlp-hal/xlp.h>
-#include <asm/netlogic/xlp-hal/pic.h>
-#include <asm/netlogic/xlp-hal/sys.h>
-
-/* These addresses are computed by the nlm_hal_init() */
-uint64_t nlm_io_base;
-uint64_t nlm_sys_base;
-uint64_t nlm_pic_base;
-
-/* Main initialization */
-void nlm_hal_init(void)
-{
-	nlm_io_base = CKSEG1ADDR(XLP_DEFAULT_IO_BASE);
-	nlm_sys_base = nlm_get_sys_regbase(0);	/* node 0 */
-	nlm_pic_base = nlm_get_pic_regbase(0);	/* node 0 */
-}
 /**
 * @brief nlm_hal_xlp_pcie_rc_init function is used to initialize the XLP PCIE controllers configured in RC mode.
 *
@@ -481,17 +462,6 @@ __inline__ int nlm_hal_is_xlp_le(void)
 	return little_endian;
 }
 
-enum prop_type {
-        PROP_STR = 0,
-        PROP_CELL
-};
-
-int copy_fdt_prop(void *fdt, const char *path, const char *prop,
-			enum prop_type type, void *buf, int len)
-{
-	return 0;
-}
-
 /*
  * @brief nlm_hal_get_fdt_freq function is used to read the frequency specified in the fdt file.
  *
@@ -573,6 +543,79 @@ int nlm_hal_get_fdt_freq(void *fdt, int type)
 	return ret;
 }
 
+/* Main initialization */
+/**
+* @brief nlm_hal_init function is used to Initialize HAL
+*
+* @return
+*  - Returns no value.
+*
+* @note
+*    This function must be the first to be called before any other HAL API's
+*
+* @ingroup hal
+*
+*/
+
+__inline__ void nlm_hal_init(void)
+{
+	unsigned long long mask = ~0xf;
+	int node = 0;
+#if !defined(NLM_HAL_LINUX_USER)
+	unsigned int flags = 0;
+	enable_KX(flags);
+#endif
+	nlm_hal_enumerate_pci();
+
+	nlm_node_cfg.valid = 1;
+	nlm_node_cfg.num_nodes = 1;
+
+ 	for(node = 0; node < NLM_MAX_NODES; node++)
+	{
+		/*nlm_node_cfg.nae_cfg[node] = NULL; */
+		nlm_node_cfg.nae_cfg[node] = NULL;
+		nlm_node_cfg.fmn_cfg[node] = NULL;
+
+		xlp_io_base = KSEG1 + 0x18000000;
+
+        	/* PCI enumeration of supported devices*/
+		xlp_fmn_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_FMN)), PCI_MEM_BAR_0);
+
+		xlp_mac_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_NAE)), PCI_MEM_BAR_0); /*0x18018000 */
+		/*printf("Node:%d NAE_MAC_Base:%lX\n", node, xlp_mac_base[node]); */
+		xlp_nae_base[node] = xlp_mac_base[node] + 0xe000;
+
+		xlp_poe_base_pcim[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_POE)), PCI_MEM_BAR_0);	/*0x18019000 */
+		xlp_poe_base_pcie[node] = (xlp_io_base | XLP_CFG_BASE(node, XLP_POE)) & 0x1fffffff; /* For now . Will be fixed soon.*/
+
+		xlp_sys_base[node] = (xlp_io_base | XLP_CFG_BASE(node, XLP_SYS)) & 0x1fffffff; /*For now . Will be fixed soon.*/
+		xlp_sae_base[node] = (xlp_io_base | XLP_CFG_BASE(node, XLP_SAE)) & 0x1fffffff; /* For now . Will be fixed soon.*/
+	}
+
+        xlp_rsa_base = (xlp_io_base | XLP_CFG_BASE(0, XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
+
+	if ( is_nlm_xlp3xx() || is_nlm_xlp2xx() ) {
+		xlp_regex_base_pcie = (xlp_io_base | (XLP_CFG_BASE(0, XLP_3XX_REGEX))) & 0x1fffffff;
+	        xlp_regex_base_pcim = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(0, XLP_3XX_REGEX)), PCI_MEM_BAR_0);
+		nlm_print("xlp3xx/2xx Regex (netl7) vendor_device id:%#x\n"
+			"xlp_regex_base_pcim:%#lx\n"
+			"xlp_regex_base_pcie:%#lx\n",
+			nlm_hal_read_32bit_reg(xlp_regex_base_pcie, 0),
+			xlp_regex_base_pcim, xlp_regex_base_pcie);
+       	}
+
+#if !defined(NLM_HAL_UBOOT)
+#ifndef CONFIG_N511
+        	nlm_hal_cpld_init(0);
+#endif
+#endif
+
+#if !defined(NLM_HAL_LINUX_USER) && (_MIPS_SZLONG == 64)
+	disable_KX(flags);
+#endif
+}
+
+
 /*
  * Naming convention: NLM_HAL_XXX for external API
  *                    NLH_XXX for internal naming of NL HAL
@@ -600,7 +643,6 @@ EXPORT_SYMBOL(nlm_hal_send_msg2);
 EXPORT_SYMBOL(nlm_hal_recv_msg2);
 EXPORT_SYMBOL(nlm_hal_send_msg3);
 EXPORT_SYMBOL(nlm_hal_send_msg4);
-int irt_irq_table[32][4];
 #else
 #include "nlm_hal_pic.h"
 /*
@@ -944,6 +986,28 @@ unsigned long tlb_size_to_mask(unsigned long size)
 #ifdef PHY_DEBUG
 static void dump_phy_regs(int node, int inf)
 {
+	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
+	int j = 0;
+	for(;j<nae_cfg->num_ports;j++){
+		if(nae_cfg->ports[j].hw_port_id == inf)
+			break;
+	}
+
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22, 0x0);
+	nlm_print("Page0 Control Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 0));
+	nlm_print("Page0 Status Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 1));
+        nlm_print("Page0 ExtStatus Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 17));
+
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22, 0x2);
+	nlm_print("Page %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22));
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22, 0x2);
+
+        nlm_print("Page2 Control Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 0));
+        nlm_print("Page2 media Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 10));
+	nlm_print("Page2 Reg26 (Bypass) %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 26));
+	nlm_print("Page2 SGMII sync %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 17));
+
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22, 0x0);
 }
 #endif
 
@@ -989,7 +1053,7 @@ static void xmc_phy_status(struct nlm_hal_ext_phy *phy, int node)
 
 }
 #else
-void xmc_phy_status(struct nlm_hal_ext_phy *phy, int node) {;}
+static void xmc_phy_status(struct nlm_hal_ext_phy *phy, int node) {;}
 #endif
 
 /**
@@ -1006,6 +1070,68 @@ void xmc_phy_status(struct nlm_hal_ext_phy *phy, int node) {;}
 */
 static void xmc_init_phy(struct nlm_hal_ext_phy *phy, int node)
 {
+	int i, aux_status;
+	int bus = phy->ext_mdio_bus;
+	int phyaddr = phy->phy_addr;
+	int int_inf = phy->inf;
+	int status=0;
+
+	nlm_print("XMC_INIT_PHY \n ");
+
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x04, 0x01); /* selector field */
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0); /* disable XLP AN */
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x8000); /* soft reset */
+
+	/* XMC board has INTFSEL[1:0] = 01 which selects fiber and power down modes*/
+
+	/* setup for SGMII-Copper mode */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+	status = 0x7c00 | (2 << 1); /* SGMII mode, copper registers */
+	/*nlm_print("writing phyaddr %d reg 0x1c =0x%x \n", phyaddr, status); */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)));
+
+	/* Turn off Signal Detect Enable on 1000BASE-X side */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (0x5c00 | (1<<15)));
+
+	/* power up copper side*/
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
+	status &= ~(1<<11);
+	/*nlm_print("writing phyaddr %d reg 0 =0x%x \n", phyaddr, status); */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x00, status); /* Normal Operation */
+	nlm_mdelay(100);
+
+	/* setup LED control */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x8801); /* spare control 1, enable link led mode */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0xB4E5); /* LED Selector 1, LED3 off, LED1 SLAVE (LINK) */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0xB83E); /* LED Selector 2, LED2 ACTIVITY, LED4 off */
+
+	/*switch to 1000Base-X registers mode*/
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)| (0x1)));
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, 0x100 ); /*Disable AN and power up SGMII side*/
+	nlm_mdelay(100);
+
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, status | (1<<12) ); /*Enable AN on SGMMII side of PHY*/
+
+#if 1
+	/* wait up to 5 seconds for AN to complete on copper side */
+	i=0;
+	do {
+		nlm_mdelay(100);
+		aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
+		if (aux_status & 0x8000)
+			break;
+
+		i++;
+	}while(i<50);
+	xmc_phy_status(phy, node);
+#endif
+
+	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<12)); /* Enable XLP AN */
 	return;
 }
 
@@ -1023,6 +1149,35 @@ static void xmc_init_phy(struct nlm_hal_ext_phy *phy, int node)
 */
 static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node)
 {
+	int bus = phy->ext_mdio_bus;
+	int phyaddr = phy->phy_addr;
+	int int_inf = phy->inf;
+	int status=0;
+	nlm_print("BCM_INIT_PHY \n ");
+
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x04, 0x01); /* selector field */
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0); /* disable XLP AN */
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x8000); /* soft reset */
+
+#if 0
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf,  0x1c, 0x7800);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf,  0x1c, (status | (1<<15)| (0x1)));
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf,  0x1c, 0x7800);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C);
+#endif
+
+	/*switch to 1000Base-X registers mode*/
+	/*refer mode control register in broadcom datasheet*/
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)| (0x1)));
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, 0x100 ); /*Disable AN*/
+
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, status | (1<<12) ); /*Enable AN on SGMMII side of PHY*/
+	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<12)); /* Enable XLP AN */
 	return;
 }
 
@@ -1040,6 +1195,27 @@ static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node)
 */
 static void mvl_init_phy(struct nlm_hal_ext_phy *phy, int node)
 {
+	int bus = phy->ext_mdio_bus;
+	int phyaddr = phy->phy_addr;
+	int int_inf = phy->inf;
+
+	/* device initialization */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0x02);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 16, 0x0288);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0x8000);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x00, 0x8000);
+
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0x02); /* page 2 */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 26, 0x8000); /* AN bypass enable */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0, 0); /* Disable MAC side AN */
+
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0x00); /* page 0 */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0, 0xb000); /* Enable AN, Soft reset */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0, 0x9140); /* Enable AN, Soft reset */
+
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x04, 0x01); /* selector field */
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x4000); /* disable XLP AN */
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x8000); /* soft reset */
 }
 
 /**
@@ -1066,6 +1242,42 @@ void nlm_hal_ext_phy_an(int node, int inf)
 
 void nlm_hal_restart_an(int node, int inf)
 {
+	static int link_status[XLP_MAX_PORTS];
+	struct nlm_hal_ext_phy *phy=NULL;
+	int i = 0, int_inf, status, phyaddr, bus;
+
+	while(regs_ext_phys[i].inf != -1)
+	{
+		phy = get_phy_info(regs_ext_phys[i].inf);
+		if(!phy)
+	               	return;
+		if((phy->phy_idfer == 0x60c1 || phy->phy_idfer == 0xbcb2))/* only for broadcom phys*/
+		{
+			int_inf = phy->inf;
+			phyaddr = phy->phy_addr;
+			bus = phy->ext_mdio_bus;
+
+			status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
+			if(!(status & (1<<2)))
+			{
+				link_status[int_inf] = 1;
+
+				nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C, 0x7800);
+				status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C);
+
+				status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
+				status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+				nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
+
+			}
+			else if(link_status[int_inf])
+			{
+				link_status[int_inf] = 0;
+				nlm_hal_ext_phy_an(0, i);
+			}
+		}
+		i++;
+	}
 }
 /**
 * @brief xmc_start_an function enables auto-negotiation on XMC board external BROADCOM PHY.
@@ -1081,6 +1293,33 @@ void nlm_hal_restart_an(int node, int inf)
 */
 static void xmc_start_an(struct nlm_hal_ext_phy *phy, int node)
 {
+	int status, count;
+	int phyaddr = phy->phy_addr;
+	int bus = phy->ext_mdio_bus;
+	int int_inf = phy->inf;
+
+	nlm_print("Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", phy->inf,  bus, phyaddr);
+
+	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
+	/*Wait for XLP<->SGMII-PHY AN to be OK*/
+	count=0;
+        do {
+		nlm_mdelay(100);
+		count++;
+		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
+		if(status & (1<<5)){ /* check for autonegotiation to be completed */
+			nlm_print("Autonegotiation is OK with PHY-SGMII =0x%x \n", int_inf);
+			xmc_phy_status(phy, node);
+			/*nlm_print("%s: exit\n", __func__); */
+			return;
+		}
+		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+		nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
+        }while(count<100);
+
+	nlm_print("Autonegotiation is NOT OK for PHY-SGMII inf=0x%x int_inf =0x%x\n", phyaddr, int_inf);
+	xmc_phy_status(phy, node);
 	return;
 }
 
@@ -1098,6 +1337,65 @@ static void xmc_start_an(struct nlm_hal_ext_phy *phy, int node)
 */
 static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
 {
+	int status, count;
+	int phyaddr;
+	int bus;
+	int int_inf = phy->inf;
+
+	phyaddr = phy->phy_addr;
+        bus = phy->ext_mdio_bus;
+	/*switch to Copper registers mode*/
+	/*refer mode control register in broadcom datasheet*/
+	/*nlm_print("Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", phy->inf,  bus, phyaddr); */
+#if 0
+	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
+	status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
+	status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x0);
+	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x0, status|(1<<9));
+	count=0;
+        do {
+		nlm_mdelay(100);
+		count++;
+		status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
+		if(status & (1<<5)){ /* check for autonegotiation to be completed */
+			nlm_print("Autonegotiation is OK for phyaddr=0x%x \n", phyaddr);
+			break;
+		}
+		status = -1;
+        }while(count<50);
+
+	if(status<0){
+		nlm_print("Autonegotiation is NOT OK for phyaddr=0x%x \n", phyaddr);
+		return;
+	}
+#endif
+
+
+	/*switch to 1000Base-X registers mode*/
+	/*nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00); */
+	/*status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C); */
+	/*nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)| (0x1))); */
+	/*status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0); */
+	/*nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, status|(1<<9)); Restart AN on SGMMII side of PHY*/
+	/*nlm_mdelay(1000); */
+	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
+	/*Wait for XLP<->SGMII-PHY AN to be OK*/
+	count=0;
+        do {
+		nlm_mdelay(100);
+		count++;
+		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
+		if(status & (1<<5)){ /* check for autonegotiation to be completed */
+	/*		nlm_print("Autonegotiation is OK with PHY-SGMII =0x%x \n", int_inf); */
+			return;
+		}
+		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+		nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
+        }while(count<100);
+
+	/*nlm_print("Autonegotiation is NOT OK for PHY-SGMII inf=0x%x int_inf =0x%x\n", phyaddr, int_inf); */
 	return;
 }
 
@@ -1115,6 +1413,52 @@ static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
 */
 static void mvl_start_an(struct nlm_hal_ext_phy *phy, int node)
 {
+        uint32_t i=0;
+        volatile uint16_t val, status, extstatus;
+#ifdef PHY_DEBUG
+        uint16_t speed, duplex = 0;
+#endif
+	int phyaddr = phy->phy_addr;
+	int bus = phy->ext_mdio_bus;
+
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0);
+        val = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0);
+        val |= 0x1200;
+        nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0, val);
+
+#ifdef PHY_DEBUG
+	nlm_print("Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", phy->inf,  bus, phyaddr);
+#endif
+	i=0;
+        do {
+                status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 1);
+                extstatus = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 17);
+		if (((status & 0x0024) == 0x0024) && (extstatus & 0x0400)) {
+			nlm_print("bus:%d phy:%d Autonegotiation ok:%X %X i:%d\n", bus, phyaddr, status, extstatus, i);
+			break;
+		}
+		nlm_mdelay(1);
+		i++;
+        }while(i<5000);
+        if(i==5000) nlm_print(" bus:%d phy:%d auto negotiation timeout!\n", bus, phyaddr);
+
+#ifdef PHY_DEBUG
+        switch(speed) {
+                case SPEED_10M:
+                        nlm_print("physpeed 10 Mbps\t");
+                        break;
+                case SPEED_100M:
+                        nlm_print("physpeed 100 Mbps\t");
+                        break;
+                case SPEED_1000M:
+                        nlm_print("physpeed 1000 Mbps\t");
+                        break;
+                default:
+                        nlm_print("unknown speed !!! \t");
+        }
+        ((duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
+	/*dump_phy_regs(inf); */
+#endif
 }
 
 int nlm_hal_status_ext_phy(int node, int inf, struct nlm_hal_mii_info* mii_info)
@@ -1143,7 +1487,102 @@ int nlm_hal_status_ext_phy(int node, int inf, struct nlm_hal_mii_info* mii_info)
 */
 static int xmc_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node)
 {
-	return 0;
+	int aux_status=0;
+	int status=0;
+	int phyaddr = phy->phy_addr;
+	int bus = phy->ext_mdio_bus;
+	mii_info->phyaddr=phyaddr;
+	/*int int_inf = phy->inf; */
+
+
+	/*switch to Copper registers mode*/
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
+
+#if 0
+	/* start auto-negotiation on copper side */
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
+	status |= (1 << 9);
+	nlm_print("writing phyaddr %d reg 0 =0x%x \n", phyaddr, status);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x00, status );
+#endif
+
+#if 0
+	/* wait up to 5 seconds for AN to complete on copper side*/
+	i=0;
+	do {
+		nlm_mdelay(100);
+		aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
+		if (aux_status & 0x8000)
+			break;
+
+		i++;
+	}while(i<50);
+#endif
+	/* check the status */
+	aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
+	switch ((aux_status>>8) & 0x7){
+		case 0x7:
+			mii_info->speed = SPEED_1000M;
+			mii_info->duplex = 1;
+		break;
+
+		case 0x6:
+			mii_info->speed = SPEED_1000M;
+			mii_info->duplex = 0;
+		break;
+
+		case 0x5:
+			mii_info->speed = SPEED_100M;
+			mii_info->duplex = 1;
+		break;
+
+		case 0x3:
+			mii_info->speed = SPEED_100M;
+			mii_info->duplex = 0;
+		break;
+
+		case 0x2:
+			mii_info->speed = SPEED_10M;
+			mii_info->duplex = 1;
+		break;
+
+		case 0x1:
+			mii_info->speed = SPEED_10M;
+			mii_info->duplex = 0;
+		break;
+
+		default:
+			nlm_print("Unknown operating speed, auxstatus = 0x%04x\n", aux_status);
+		break;
+	}
+
+//#ifdef PHY_DEBUG
+	if(mii_info->speed==SPEED_1000M)
+		nlm_print("Configured with Speed  1000M");
+	if(mii_info->speed==SPEED_100M)
+		nlm_print("Configured with Speed 100M");
+	if(mii_info->speed==SPEED_10M)
+		nlm_print("Configured with Speed 10M");
+
+	((mii_info->duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
+//#endif
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
+	if(status & (1<<2)){
+		mii_info->link_stat = LINK_UP;
+		nlm_print("Link is up : %x\n", status);
+		xmc_phy_status(phy, node);
+		/*nlm_print("%s: exit\n", __func__); */
+		return 1;
+	}else{
+		mii_info->link_stat = LINK_DOWN;
+		nlm_print("Link is down : %x\n", status);
+		xmc_phy_status(phy, node);
+		/*nlm_print("%s: exit\n", __func__); */
+		return 0;
+	}
 }
 
 /**
@@ -1162,7 +1601,76 @@ static int xmc_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_in
 */
 static int bcm_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node)
 {
-	return 0;
+	int aux_status=0;
+	int status=0;
+	int phyaddr = phy->phy_addr;
+	int bus = phy->ext_mdio_bus;
+	mii_info->phyaddr=phyaddr;
+	/*int int_inf = phy->inf; */
+
+	bcm_start_an(phy, node);
+
+	/*switch to Copper registers mode*/
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
+	aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
+	switch ((aux_status>>8) & 0x7){
+		case 0x7:
+			mii_info->speed = SPEED_1000M;
+			mii_info->duplex = 1;
+		break;
+
+		case 0x6:
+			mii_info->speed = SPEED_1000M;
+			mii_info->duplex = 0;
+		break;
+
+		case 0x5:
+			mii_info->speed = SPEED_100M;
+			mii_info->duplex = 1;
+		break;
+
+		case 0x3:
+			mii_info->speed = SPEED_100M;
+			mii_info->duplex = 0;
+		break;
+
+		case 0x2:
+			mii_info->speed = SPEED_10M;
+			mii_info->duplex = 1;
+		break;
+
+		case 0x1:
+			mii_info->speed = SPEED_10M;
+			mii_info->duplex = 0;
+		break;
+
+		default:
+			nlm_print("Unknown operating speed\n");
+		break;
+	}
+
+//#ifdef PHY_DEBUG
+	if(mii_info->speed==SPEED_1000M)
+		nlm_print("Configured with Speed  1000M");
+	if(mii_info->speed==SPEED_100M)
+		nlm_print("Configured with Speed 100M");
+	if(mii_info->speed==SPEED_10M)
+		nlm_print("Configured with Speed 10M");
+
+	((mii_info->duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
+//#endif
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
+	if(status & (1<<2)){
+		mii_info->link_stat = LINK_UP;
+		nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, status);
+		return 1;
+	}else{
+		mii_info->link_stat = LINK_DOWN;
+		nlm_print("bus:%d phy:%d Link is down : %x\n", bus, phyaddr, status);
+		return 0;
+	}
 }
 
 /**
@@ -1181,7 +1689,27 @@ static int bcm_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_in
 */
 static int mvl_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node)
 {
+	uint16_t extstatus;
+	int phyaddr = phy->phy_addr;
+	int bus = phy->ext_mdio_bus;
+
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0);
+        extstatus = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 17);
+	mii_info->speed = (extstatus >> 14) & 0x3;
+        mii_info->duplex =  (extstatus >> 13) & 0x1;
+        mii_info->phyaddr=phyaddr;
+
+	if (extstatus & 0x0400) {
+		mii_info->link_stat = LINK_UP;
+		nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, extstatus);
+		return 1;
+	}
+	else {
+		mii_info->link_stat = LINK_DOWN;
+		nlm_print("bus:%d phy:%d Link is down : %x\n",bus, phyaddr, extstatus);
 		return 0;
+	}
+
 }
 
 /**
@@ -1282,6 +1810,65 @@ void register_phy(int node, int inf, int* hw_portid)
 */
 void sgmii_scan_phys(int node)
 {
+	int phyid, inf;
+	int j;
+	int reg_idx=0;
+
+	/*init regs_ext_phys data*/
+	for (j=0; j<MAX_PHYS; j++){
+		regs_ext_phys[j].phy_get_status =  NULL;
+		regs_ext_phys[j].start_phy_an =  NULL;
+		regs_ext_phys[j].ext_phy_init =  NULL;
+		regs_ext_phys[j].phy_addr = 0xff;
+		regs_ext_phys[j].inf = -1;
+	}
+	/* scan all PHYs available on both ext MDIOs */
+	/* check with phys IDs against registered phys */
+
+	/*BUS1*/
+	if(!(is_nlm_xlp3xx() || is_nlm_xlp2xx())){ /*Only one mdio controller*/
+		nlm_print("Scanning MDIO external BUS1----\n");
+		for(inf=0; inf<31; inf++){
+			phyid = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, 1, BLOCK_7, LANE_CFG, inf, 3);
+			for(j=0; j < sizeof(known_ext_phys)/ sizeof(struct nlm_hal_ext_phy); j++){
+				if(phyid == known_ext_phys[j].phy_idfer){
+					regs_ext_phys[reg_idx].ext_mdio_bus = 1;
+					regs_ext_phys[reg_idx].phy_get_status =  known_ext_phys[j].phy_get_status;
+					regs_ext_phys[reg_idx].start_phy_an =  known_ext_phys[j].start_phy_an;
+					regs_ext_phys[reg_idx].ext_phy_init =  known_ext_phys[j].ext_phy_init;
+					regs_ext_phys[reg_idx].phy_addr = inf;
+					regs_ext_phys[reg_idx].inf = -1;
+					regs_ext_phys[reg_idx].phy_idfer = known_ext_phys[j].phy_idfer;
+					/*nlm_print("Found port with 1st bus and phy_addr =0x%x phy-idfer =0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid); */
+					reg_idx++;
+				}
+			}
+
+		}
+	}
+	nlm_print("Scanning MDIO external BUS0----\n");
+	/*BUS0*/
+	for(inf=0; inf<31; inf++){
+		phyid = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, inf, 3);
+		for(j=0; j < sizeof(known_ext_phys)/ sizeof(struct nlm_hal_ext_phy); j++){
+			if(phyid == known_ext_phys[j].phy_idfer){
+
+				regs_ext_phys[reg_idx].ext_mdio_bus = 0;
+				regs_ext_phys[reg_idx].phy_get_status =  known_ext_phys[j].phy_get_status;
+				regs_ext_phys[reg_idx].start_phy_an =  known_ext_phys[j].start_phy_an;
+				regs_ext_phys[reg_idx].ext_phy_init =  known_ext_phys[j].ext_phy_init;
+				regs_ext_phys[reg_idx].phy_addr = inf;
+				regs_ext_phys[reg_idx].inf = -1;
+				regs_ext_phys[reg_idx].phy_idfer = known_ext_phys[j].phy_idfer;
+				/*nlm_print("Found port with 0th bus and phy_addr =0x%x phy-idfer=0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid); */
+				reg_idx++;
+			}
+		}
+
+	}
+
+	reg_num_phys =  reg_idx;
+	nlm_print("Total PHYs found = %d\n", reg_idx);
 }
 
 /* CDE SUPPORT
@@ -1300,6 +1887,16 @@ void sgmii_scan_phys(int node)
 */
 void nlm_hal_set_cde_freq(int node, int freq)
 {
+	const uint64_t mhz = 1000000;
+	nlm_print("-- CDE Frequency set to %d\n", freq);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_CMP, freq * mhz);
+	}
+	else {
+		uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_CMP, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("CDE Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
 }
 
 /* DTRE SUPPORT
@@ -1318,6 +1915,16 @@ void nlm_hal_set_cde_freq(int node, int freq)
 */
 void nlm_hal_set_dtre_freq(int node, int freq)
 {
+	const uint64_t mhz = 1000000;
+	nlm_print("-- DTRE Frequency set to %d\n", freq);
+	if(is_nlm_xlp2xx()) {
+		nlm_print("ERROR: DTRE block unavailable for xlp2xx\n");
+	}
+	else {
+		uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_DTRE, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("DTRE Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
 }
 
 /**
@@ -1370,18 +1977,41 @@ void nlm_hal_dtr_init(void *fdt)
 */
 void nlm_hal_set_sae_freq(int node, int freq)
 {
+	const uint64_t mhz = 1000000;
+	nlm_print("-- SAE Frequency set to %d\n", freq);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_SAE, freq * mhz);
+	}
+	else {
+		uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_SAE, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("SAE Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
 }
 
 
 int nlm_hal_get_chip_feature(void )
 {
 	int chip_features;
-	chip_features = INIT_DONE;
+	if( is_nlm_xlp2xx())
+		chip_features = (INIT_DONE | ZUC | DES3_KEY_SWAP);
+	else
+		chip_features = INIT_DONE;
 	return chip_features;
 }
 
 void nlm_hal_set_rsa_freq(int node, int freq)
 {
+	const uint64_t mhz = 1000000;
+	nlm_print("--RSA Frequency set to %d\n", freq);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_RSA, freq * mhz);
+	}
+	else {
+		uint64_t set_freq = nlm_hal_set_soc_freq(0, DFS_DEVICE_RSA, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("RSA Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
 }
 
 
@@ -1517,19 +2147,68 @@ void nlm_hal_set_rsa_cge(int node, int enable)
 #define NLM_SAE_ENGINE_SELECT_REG_0 0x41
 void nlm_hal_set_sae_engine_sel(int node)
 {
+	int i, n;
+	if(is_nlm_xlp2xx()) {
+		return;
+	}
+	if(is_nlm_xlp3xx())
+		n = 1;
+	else
+		n = 8;
+
+	for (i = 0; i < n; i++) {
+		nlm_hal_write_sae_reg(node, NLM_SAE_ENGINE_SELECT_REG_0 + i, 0x00FFFFFF);
+	}
 }
 
 #define NLM_RSA_ENGINE_SELECT_REG_0 0x41
 void nlm_hal_set_rsa_engine_sel(void)
 {
+	int i, n;
+	unsigned int val;
+	if(is_nlm_xlp2xx()) {
+		return;
+	}
+	if(is_nlm_xlp3xx()) {
+		n = 1;
+		val = 0xffff;
+	} else {
+		n = 3;
+		val = 0x7ffffff;
+	}
+	for (i = 0; i < n; i++) {
+		nlm_hal_write_rsa_reg(NLM_RSA_ENGINE_SELECT_REG_0 + i, val);
+	}
 }
 
 void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit)
 {
+
+	if(is_nlm_xlp3xx()) {
+		*vcbase = XLP_3XX_CRYPTO_VC_BASE;
+		*vclimit = XLP_3XX_CRYPTO_VC_LIMIT;
+	} else if(is_nlm_xlp2xx()) {
+		*vcbase = XLP_2XX_CRYPTO_VC_BASE;
+		*vclimit = XLP_2XX_CRYPTO_VC_LIMIT;
+	} else {
+		*vcbase = XLP_CRYPTO_VC_BASE;
+		*vclimit = XLP_CRYPTO_VC_LIMIT;
+	}
 }
 
 void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit)
 {
+	if(is_nlm_xlp3xx()) {
+		*vcbase  = XLP_3XX_RSA_ECC_VC_BASE;
+		*vclimit = XLP_3XX_RSA_ECC_VC_LIMIT;
+	} else if(is_nlm_xlp2xx()) {
+		*vcbase  = XLP_2XX_RSA_ECC_VC_BASE;
+		*vclimit = XLP_2XX_RSA_ECC_VC_LIMIT;
+	} else {
+		*vcbase = XLP_RSA_ECC_VC_BASE;
+		*vclimit = XLP_RSA_ECC_VC_LIMIT;
+
+	}
 }
 
 #ifdef NLM_HAL_LINUX_KERNEL
diff --git a/arch/mips/netlogic/common/nlm_hal_cpu_info.c b/arch/mips/netlogic/common/nlm_hal_cpu_info.c
new file mode 100644
index 0000000..246c50a
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_hal_cpu_info.c
@@ -0,0 +1,532 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#include "nlm_hal.h"
+#include "nlm_hal_macros.h"
+#include "nlm_hal_xlp_dev.h"
+
+/* local defines */
+#define XLP8XX_REVISION_A0  0x00
+#define XLP8XX_REVISION_A1  0x01
+#define XLP8XX_REVISION_A2  0x02
+#define XLP8XX_REVISION_B0  0x03
+#define XLP8XX_REVISION_B1  0x04
+
+#define XLP3XX_REVISION_A0  0x00
+#define XLP3XX_REVISION_A1  0x01
+#define XLP3XX_REVISION_B0  0x02
+#define XLP3XX_REVISION_B1  0x03
+
+extern void *memset(void *s, int c, size_t n);
+static inline int bitcount(unsigned int n)                          
+{
+  register unsigned int tmp;
+    
+  tmp = n - ((n >> 1) & 033333333333)
+            - ((n >> 2) & 011111111111);
+  return ((tmp + (tmp >> 3)) & 030707070707) % 63;
+}
+
+
+__inline__ uint32_t efuse_cfg0(void)
+{
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG0)));
+
+}
+
+ __inline__ uint32_t efuse_cfg1(void)
+{
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG1)));
+}
+
+__inline__ uint32_t efuse_cfg6(void)
+{
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG6)));
+}
+
+
+__inline uint32_t get_proc_id(void)
+{
+	unsigned int prid = nlm_read_prid();
+	prid = (prid >> 8) & 0xff;
+	if (!prid) { /*May be its Non fused part.*/
+#ifdef  CONFIG_NETL3XX
+		prid = CHIP_PROCESSOR_ID_XLP_3XX;
+#elif  defined (CONFIG_NETL2XX)
+		prid = CHIP_PROCESSOR_ID_XLP_2XX;
+#else
+		prid = CHIP_PROCESSOR_ID_XLP_8_4_XX;
+#endif
+	}
+	return prid;
+}
+
+__inline__ int get_nlm_xlp8xx_rev(void)
+{
+	return nlm_read_prid() & 0xff;
+}
+
+__inline__ int get_nlm_xlp3xx_rev(void)
+{
+	int hw_rev = nlm_read_prid() & 0xff;
+	int sw_rev;
+	if(hw_rev>=XLP3XX_REVISION_B0)
+		sw_rev = hw_rev + 1;
+	else
+		sw_rev = hw_rev;
+	return sw_rev;
+}
+
+__inline__ int get_nlm_xlp2xx_rev(void)
+{
+	return nlm_read_prid() & 0xff;
+}
+
+/***************************************************************************************
+* match the chip revision with 'rev'
+ * rev:  revision number
+		single match: XLP_REVISION_A0 etc
+		multi-match:  XLP_REVISION_AX/_BX/_XX
+****************************************************************************************/
+__inline__ int is_nlm_xlp8xx_rev_xx(uint32_t rev)
+{
+	int sw_rev=get_nlm_xlp8xx_rev();
+	uint32_t rev_b0 = XLP_REVISION_B0;
+	if( rev==sw_rev)        return 1;
+	if( rev==XLP_REVISION_AX && sw_rev<rev_b0)	return 1;
+	if( rev==XLP_REVISION_BX && (rev_b0<=sw_rev))  	return 1;
+	if( rev==XLP_REVISION_ANY)			return 1;
+	return 0;
+}
+
+/***************************************************************************************
+* match the chip revision with 'rev'
+ * rev:  revision number
+		single match: XLP_REVISION_A0 etc
+		multi-match:  XLP_REVISION_AX/_BX/_XX
+****************************************************************************************/
+__inline__ int is_nlm_xlp3xx_rev_xx(uint32_t rev)
+{
+	int sw_rev=get_nlm_xlp3xx_rev();
+	uint32_t rev_b0 = XLP_REVISION_B0;
+	if( rev==sw_rev)	return 1;
+	if( rev==XLP_REVISION_AX && sw_rev<rev_b0)	return 1;
+	if( rev==XLP_REVISION_BX && (rev_b0<=sw_rev))  	return 1;
+	if( rev==XLP_REVISION_ANY)			return 1;
+
+	return 0;
+}
+
+
+__inline__ int is_nlm_xlp2xx_rev_xx(uint32_t rev)
+{
+	int sw_rev=get_nlm_xlp2xx_rev();
+	uint32_t rev_b0 = XLP_REVISION_B0;
+	if( rev==sw_rev)	return 1;
+	if( rev==XLP_REVISION_AX && sw_rev<rev_b0)	return 1;
+	if( rev==XLP_REVISION_BX && (rev_b0<=sw_rev))  	return 1;
+	if( rev==XLP_REVISION_ANY)			return 1;
+
+	return 0;
+}
+
+/***************************************************************************************
+match legacy eagle Ax: xlp832, xlp816, xlp432, xlp416, xlp408, xlp208, xlp204, xlp104
+chipid: 832, 816, 432, 416, 408, 208, 204, 104; match any of the chip in eagle Ax
+rev:    revision
+***************************************************************************************/
+inline int is_xlp8xx_legacy(int chipid, uint32_t rev)
+{
+	uint32_t pid=get_proc_id();
+	uint32_t sw_rev = get_nlm_xlp8xx_rev();
+
+	if( rev==XLP_REVISION_ANY )	rev=XLP_REVISION_AX;
+	if( sw_rev!=rev && rev!=XLP_REVISION_AX )	return 0;
+	if( XLP_REVISION_B0<=sw_rev ) return 0;
+	if(	(( (chipid==0x8084) || (chipid==0x8000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_832)) ||
+		(( (chipid==0x8044) || (chipid==0x8000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_816)) ||
+		(( (chipid==0x4084) || (chipid==0x4000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_432)) ||
+		(( (chipid==0x4044) || (chipid==0x4000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_416)) ||
+		(( (chipid==0x4024) || (chipid==0x4000) ) &&  (pid==CHIP_PROCESSOR_ID_XLP_408)) )
+		return 1;
+
+    return 0;
+}
+
+/*
+ * match xlp8xx
+ * num_cpu: 32-xlp832, 24-xlp824, 16-xlp816, 0 any cpu number is valid match
+ * rev:  chip revision,
+ */
+#define CPU_NUM_ANY  0 /* any cpu number will be matched */
+inline int is_xlp8xx(uint8_t num_cpu, uint32_t rev)
+{
+	uint32_t pid, core_mask, cfg1;
+	int ret, hw_cpu_num;
+
+	ret=is_nlm_xlp8xx_rev_xx(rev);
+	if(ret!=1)	return 0;
+
+	pid=get_proc_id();
+
+	if( pid == CHIP_PROCESSOR_ID_XLP_8_4_XX)
+	{
+		core_mask = efuse_cfg0() & 0xff;
+		cfg1 = efuse_cfg1() & 0x7;
+
+		hw_cpu_num=(8-bitcount(core_mask))<<2;
+		if( ((hw_cpu_num==num_cpu)||(num_cpu==CPU_NUM_ANY)) && cfg1!=0x7 )	return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * match xlp4xx
+ * num_cpu: 32-xlp832, 24-xlp824, 16-xlp816, 0xff any cpu number is valid match
+ * rev:  chip revision,
+ */
+inline int is_xlp4xx(uint8_t num_cpu, uint32_t rev)
+{
+	uint32_t pid, core_mask, cfg1;
+	int ret, hw_cpu_num;
+
+	ret=is_nlm_xlp8xx_rev_xx(rev);
+	if(ret!=1)  return 0;
+
+	pid=get_proc_id();
+
+	if( pid == CHIP_PROCESSOR_ID_XLP_8_4_XX )
+	{
+		core_mask = efuse_cfg0() & 0xff;
+		cfg1 = efuse_cfg1() & 0x7;
+
+		hw_cpu_num=(8-bitcount(core_mask))<<2;
+		if( ((hw_cpu_num==num_cpu)||(num_cpu==CPU_NUM_ANY)) && cfg1==0x7 )	return 1;
+	}
+
+    return 0;
+}
+
+/*
+ * match xlp3xx
+ * num_cpu: 16-xlp316,  8-xlp308, 4-xlp304;  0xff any cpu number is valid match
+ * rev:  chip revision,
+ * type: CPU_EXTPID_XLP_3XX_NONE, CPU_EXTPID_XLP_3XX_L, CPU_EXTPID_XLP_3XX_LP, CPU_EXTPID_XLP_3XX_LP2
+ * xlp316 : 4x4 threads
+ * xlp308   2x4 threads
+ * xlp304   1x4 threads
+ * xlp208a  2x4 trheads
+ * xlp108a  2x4 trheads
+ * xlp204a  1x4 trheads
+ * xlp104a  1x4 trheads
+ * xlp202a  2x1 trheads
+ * xlp201a  1x1 trheads
+ * xlp101a  1x1 trheads
+ */
+#define CPU_EXTPID_XLP_3XX_NONE  0x00
+#define CPU_EXTPID_XLP_3XX_BASE  0x00
+
+#define CPU_EXTPID_XLP_3XX_L    0x01
+#define CPU_EXTPID_XLP_3XX_LP   0x02
+#define CPU_EXTPID_XLP_3XX_LP2  0x03
+#define CPU_EXTPID_XLP_208a     0x06
+#define CPU_EXTPID_XLP_108a     0x07
+#define CPU_EXTPID_XLP_204a     0x05
+#define CPU_EXTPID_XLP_104a     0x04
+#define CPU_EXTPID_XLP_202a     0x08
+#define CPU_EXTPID_XLP_201a     0x09
+#define CPU_EXTPID_XLP_101a     0x0A
+
+inline int xlp3xx_get_num_of_threads_per_core(uint32_t core_mask, uint32_t epid)
+{
+	int nthreads=1;
+	switch(epid) {
+		case CPU_EXTPID_XLP_3XX_BASE :
+		case CPU_EXTPID_XLP_3XX_L    :
+		case CPU_EXTPID_XLP_3XX_LP   :
+		case CPU_EXTPID_XLP_3XX_LP2  :
+		case CPU_EXTPID_XLP_208a     :
+		case CPU_EXTPID_XLP_108a     :
+		case CPU_EXTPID_XLP_204a     :
+		case CPU_EXTPID_XLP_104a     : nthreads = 4; break;
+		case CPU_EXTPID_XLP_202a     :
+		case CPU_EXTPID_XLP_201a     :
+		case CPU_EXTPID_XLP_101a     : nthreads = 1; break;
+		default: break;
+	};
+	return nthreads;
+}
+
+inline int xlp3xx_get_num_of_cores(uint32_t core_mask, uint32_t epid)
+{
+	int ncores=1;
+	switch(epid) {
+		case CPU_EXTPID_XLP_3XX_BASE :
+		case CPU_EXTPID_XLP_3XX_L    :
+		case CPU_EXTPID_XLP_3XX_LP   :
+		case CPU_EXTPID_XLP_3XX_LP2  :
+		case CPU_EXTPID_XLP_208a     :
+		case CPU_EXTPID_XLP_108a     :
+		case CPU_EXTPID_XLP_204a     :
+		case CPU_EXTPID_XLP_104a     :
+		{
+ 			ncores = 4-bitcount(core_mask);
+			break;
+		}
+		case CPU_EXTPID_XLP_202a     : ncores = 2; break;
+		case CPU_EXTPID_XLP_201a     :
+		case CPU_EXTPID_XLP_101a     : ncores = 1; break;
+		default: break;
+	};
+	return ncores;
+}
+
+inline int is_xlp3xx(uint8_t num_cores, uint8_t num_threads, uint32_t rev, uint32_t exttype)
+{
+	uint32_t pid, cfg0, core_mask;
+	uint8_t epid;
+	int ret, ncores, nthreads;
+
+	ret=is_nlm_xlp3xx_rev_xx(rev);
+	if(ret!=1)  return 0;
+
+	pid=get_proc_id();
+	if( pid == CHIP_PROCESSOR_ID_XLP_3XX )
+	{
+		cfg0=efuse_cfg0();
+		core_mask = cfg0  & 0xf;
+		epid = (uint8_t)(( cfg0>>4 )  & 0xf);
+
+		if( exttype ==CPU_EXTPID_XLP_3XX_ANY)
+			return 1;
+		else if (exttype == epid ) {
+			ncores=xlp3xx_get_num_of_cores(core_mask, epid);
+			nthreads=xlp3xx_get_num_of_threads_per_core(core_mask, epid);
+			if ((num_cores*num_threads) == CPU_NUM_ANY) return 1;
+  			else if ((ncores == num_cores) && (nthreads == num_threads)) return 1;
+		}
+	}
+
+    return 0;
+}
+
+/*
+ * match xlp2xx
+ * num_cpu: 8-xlp208, 4-xlp204;  0xff any cpu number is valid match
+ * rev:  chip revision,
+ */
+inline int is_xlp2xx(uint8_t num_cores, uint8_t num_threads, uint32_t rev)
+{
+	uint32_t pid, cfg0, core_mask;
+	int ret, ncores, nthreads;
+	int xlp2xx_threads_tbl[4] = { 4, 2, 2, 1 };
+
+	ret=is_nlm_xlp2xx_rev_xx(rev);
+	if(ret!=1)  return 0;
+
+	pid=get_proc_id();
+	if(pid == CHIP_PROCESSOR_ID_XLP_2XX)
+	{
+		cfg0=efuse_cfg0();
+		core_mask = cfg0  & 0x3;
+		nthreads = xlp2xx_threads_tbl[(cfg0 >> 28) & 0x3];
+		ncores   = (2-bitcount(core_mask));
+		if ((num_cores*num_threads) == CPU_NUM_ANY) return 1;
+		else if ((ncores == num_cores) && (nthreads == num_threads)) return 1;
+	}
+	return 0;
+}
+
+/*
+ * match xlpxx
+ * chipid: 832, 316, 308, 208, etc, 800: any in 8xx group, 0 for all xlp group
+ * rev:    XLP_REVISION_A0, XLP_REVISION_A0 etc, or XLP_REVISION_AX (a0,a1,a2) XLP_REVISION_ANY(both: ax,bx)
+ * exttype: current only for 3xx:
+ *  CPU_EXTPID_XLP_3XX_BASE  0x00
+ *  CPU_EXTPID_XLP_3XX_L    0x01
+ *  CPU_EXTPID_XLP_3XX_LP   0x02
+ *  CPU_EXTPID_XLP_3XX_LP2  0x03
+ *  CPU_EXTPID_XLP_208a     0x06
+ *  CPU_EXTPID_XLP_108a     0x07
+ *  CPU_EXTPID_XLP_204a     0x05
+ *  CPU_EXTPID_XLP_104a     0x04
+ *  CPU_EXTPID_XLP_202a     0x08
+ *  CPU_EXTPID_XLP_201a     0x09
+ *  CPU_EXTPID_XLP_101a     0x0A
+ */
+int is_nlm_xlp(unsigned int chipid, unsigned int rev, unsigned int exttype)
+{
+	uint32_t group=(chipid>>12) & 0xF;
+	uint32_t num_cores=(chipid>>4) & 0xFF;
+	uint32_t num_threads_per_core=chipid & 0xF;
+	uint8_t num_cpu=num_cores*num_threads_per_core;
+	int b_rc=0;
+
+	if ( group==8 )
+	{
+		b_rc=is_xlp8xx(num_cpu, rev);
+		if( b_rc==1 )	return 1;
+	}
+
+	if ( group==4 )
+	{
+		b_rc=is_xlp4xx(num_cpu, rev);
+		if( b_rc==1 )	return 1;
+	}
+
+	if ( group==3 )
+	{
+		b_rc=is_xlp3xx(num_cores, num_threads_per_core, rev, exttype);
+		return b_rc;
+	}
+
+	if ( group==2 )
+	{
+		b_rc=is_xlp2xx(num_cores, num_threads_per_core, rev);
+		return b_rc;
+	}
+
+	/* for legacy chips: */
+	if( rev<=XLP_REVISION_A2 || rev==XLP_REVISION_AX || rev==XLP_REVISION_ANY )
+		b_rc=is_xlp8xx_legacy(chipid, rev);
+
+	return b_rc;
+}
+
+
+int  nlm_hal_get_chipid(void)
+{
+	int xlp2xx_threads_tbl[4] = { 4, 2, 2, 1 };
+	int chipid=-1, ncores, nthreads;
+	unsigned int cfg0, cfg1;
+	uint32_t pid=get_proc_id();
+
+	cfg0 =  efuse_cfg0() ;
+	cfg1 =  efuse_cfg1() ;
+
+	/* eagle 4xx 8xx BX, unfused chip treat as 8xx */
+	if(pid==0 || pid==CHIP_PROCESSOR_ID_XLP_8_4_XX)
+	{
+		ncores=(8-bitcount(cfg0&0xFF));
+		nthreads = 4;
+		chipid = (cfg1&7)==7 ? 0x4000 : 0x8000;
+		chipid+= ((ncores<<4) + nthreads);
+		return chipid;
+	}
+	if(pid==CHIP_PROCESSOR_ID_XLP_3XX)
+	{
+		ncores=(4-bitcount(cfg0&0xF));
+		nthreads = 4;
+		chipid = (0x3000 + (ncores<<4) + nthreads);
+		return chipid;
+	}
+	if (pid == CHIP_PROCESSOR_ID_XLP_2XX)
+	{
+		ncores=(2-bitcount(cfg0&0x3));
+		nthreads = xlp2xx_threads_tbl[(cfg0 >> 28) & 0x3];
+		chipid = (0x2000 + (ncores<<4) + nthreads);
+		return chipid;
+	}
+	/* eagle 8xx AX */
+	switch(pid)
+	{
+	case CHIP_PROCESSOR_ID_XLP_832 :    chipid=0x8084;   break;
+	case CHIP_PROCESSOR_ID_XLP_816 :    chipid=0x8044;   break;
+	case CHIP_PROCESSOR_ID_XLP_432 :    chipid=0x4084;   break;
+	case CHIP_PROCESSOR_ID_XLP_416 :    chipid=0x4044;   break;
+	case CHIP_PROCESSOR_ID_XLP_408 :    chipid=0x4024;   break;
+	default: break;
+	}
+
+	return chipid;
+}
+
+int  nlm_hal_get_cpuinfo(struct nlm_netl_proc_info* cpu_info)
+{
+	const static char c_typename[][8]={"\0", "Lite", "Lite+", "Lite+2", "Unknown"};
+	unsigned int sw_rev, chipid, type;
+	uint32_t cfg0, pid;
+
+	pid=get_proc_id();
+	chipid=nlm_hal_get_chipid();
+
+	memset(cpu_info, 0, sizeof(struct nlm_netl_proc_info));
+	cpu_info->proc_id=pid;
+	cpu_info->chipid=chipid;
+
+	if( pid == CHIP_PROCESSOR_ID_XLP_2XX )
+	{
+		sw_rev = get_nlm_xlp2xx_rev();
+		cpu_info->revision= sw_rev;
+		sprintf(cpu_info->cpu_info_str, "XLP%4X Rev %c%1d",
+			chipid,(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
+	}
+	else if( pid != CHIP_PROCESSOR_ID_XLP_3XX )
+	{
+		sw_rev = get_nlm_xlp8xx_rev();
+		cpu_info->revision= sw_rev;
+		sprintf(cpu_info->cpu_info_str, "XLP%4X Rev %c%1d",
+			chipid,(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
+	}
+	else
+	{
+		sw_rev = get_nlm_xlp3xx_rev();
+		cpu_info->revision = sw_rev;
+		cfg0 =  efuse_cfg0();
+		type= (cfg0>>4) & 0xF;
+		if(CPU_EXTPID_XLP_3XX_LP2<type) type=CPU_EXTPID_XLP_3XX_LP2+1;
+		sprintf(cpu_info->cpu_info_str, "XLP%4X%s Rev %c%1d", chipid, c_typename[type],
+			(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
+	}
+
+	return 0;
+}
+
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/module.h>
+/*Add  API here if any API  from above is needed*/
+EXPORT_SYMBOL(efuse_cfg0);
+EXPORT_SYMBOL(efuse_cfg1);
+EXPORT_SYMBOL(efuse_cfg6);
+EXPORT_SYMBOL(get_proc_id);
+EXPORT_SYMBOL(is_nlm_xlp);
+EXPORT_SYMBOL(nlm_hal_get_cpuinfo);
+#endif
+
+
diff --git a/arch/mips/netlogic/common/nlm_hal_fmn_config.c b/arch/mips/netlogic/common/nlm_hal_fmn_config.c
new file mode 100644
index 0000000..6e7cffb
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_hal_fmn_config.c
@@ -0,0 +1,1144 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
+#else
+#include "nlm_hal_fmn.h"
+#endif
+#include "libfdt.h"
+#include "fdt_helper.h"
+#include "nlm_hal_sys.h"
+
+#define CPU		1
+#define PCIE	2
+#define GDX		3
+#define CMP		4
+#define CRYPTO	5
+#define POE		6
+#define NAE		7
+#define RSA		8
+
+#define INT_EN 			0x0800000000000000ULL
+#define OUTQ_EN			0x8000000000000000ULL
+#define SPILL_EN 		0x4000000000000000ULL
+#define LOW40MASK       	0x000000ffffffffffULL
+#define UP46MASK        	0xfffffffffffc0000ULL
+#define UP52MASK        	0xfffffffffffff000ULL
+#define LOW18MASK       	0x000000000003ffffULL
+#define LOW4KMASK       	0x00000000000003ffULL
+#define OUTQ_SIZE		32
+#define NUM_SGMII_PORT		18
+#define MAX_TXVC		524
+#define FMN_OUTQ		1024
+#define NUM_CORES		8
+#define NUM_CPU_VC		128
+#define NUM_CPU_POPQ		256
+#define NUM_THREADS		4
+#define NUM_VC_PER_THREAD	4
+
+
+nlm_fmn_config_t xlp3xx_fmn_config[] = {
+[XLP_MSG_HANDLE_CPU0] = {XLP_STNID_CPU0, XLP_CPU0_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU1] = {XLP_STNID_CPU1, XLP_CPU1_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU2] = {XLP_STNID_CPU2, XLP_CPU2_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU3] = {XLP_STNID_CPU3, XLP_CPU3_VC_LIMIT},
+
+[XLP_MSG_HANDLE_CPU4] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU5] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU6] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU7] = {XLP_3XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_PCIE0] = {XLP_PCIE0_VC_BASE, XLP_PCIE0_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE1] = {XLP_PCIE1_VC_BASE, XLP_PCIE1_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE2] = {XLP_PCIE2_VC_BASE, XLP_PCIE2_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE3] = {XLP_PCIE3_VC_BASE, XLP_PCIE3_VC_LIMIT},
+
+[XLP_MSG_HANDLE_DTRE] = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+
+[XLP_MSG_HANDLE_GDX]  = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+[XLP_MSG_HANDLE_REGX] = {XLP_3XX_REGEX_VC_BASE, XLP_3XX_REGEX_VC_LIMIT},
+[XLP_MSG_HANDLE_RSA_ECC] = {XLP_3XX_RSA_ECC_VC_BASE, XLP_3XX_RSA_ECC_VC_LIMIT},
+[XLP_MSG_HANDLE_CRYPTO] = {XLP_3XX_CRYPTO_VC_BASE, XLP_3XX_CRYPTO_VC_LIMIT},
+
+[XLP_MSG_HANDLE_SRIO] = {XLP_3XX_SRIO_VC_BASE, XLP_3XX_SRIO_VC_LIMIT},
+
+[XLP_MSG_HANDLE_CMP] = {XLP_3XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_POE] = {XLP_3XX_POE_VC_BASE, XLP_3XX_POE_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_0] = {XLP_3XX_NET_TX_VC_BASE, XLP_3XX_NET_TX_VC_LIMIT},
+
+[XLP_MSG_HANDLE_INVALID] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_MAX] = {XLP_3XX_INVALID_STATION, 0},
+};
+
+nlm_fmn_config_t xlp2xx_fmn_config[] = {
+[XLP_MSG_HANDLE_CPU0] = {XLP_STNID_CPU0, XLP_CPU0_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU1] = {XLP_STNID_CPU1, XLP_CPU1_VC_LIMIT},
+
+[XLP_MSG_HANDLE_CPU2] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU3] = {XLP_2XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_CPU4] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU5] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU6] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU7] = {XLP_2XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_PCIE0] = {XLP_PCIE0_VC_BASE, XLP_PCIE0_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE1] = {XLP_PCIE1_VC_BASE, XLP_PCIE1_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE2] = {XLP_PCIE2_VC_BASE, XLP_PCIE2_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE3] = {XLP_PCIE3_VC_BASE, XLP_PCIE3_VC_LIMIT},
+
+[XLP_MSG_HANDLE_DTRE] = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+
+[XLP_MSG_HANDLE_GDX]  = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+[XLP_MSG_HANDLE_REGX] = {XLP_2XX_REGEX_VC_BASE, XLP_2XX_REGEX_VC_LIMIT},
+[XLP_MSG_HANDLE_RSA_ECC] = {XLP_2XX_RSA_ECC_VC_BASE, XLP_2XX_RSA_ECC_VC_LIMIT},
+[XLP_MSG_HANDLE_CRYPTO] = {XLP_2XX_CRYPTO_VC_BASE, XLP_2XX_CRYPTO_VC_LIMIT},
+
+[XLP_MSG_HANDLE_SRIO] = {XLP_2XX_INVALID_STATION,0},
+
+[XLP_MSG_HANDLE_CMP] = {XLP_2XX_CDE_VC_BASE, XLP_2XX_CDE_VC_BASE},
+
+[XLP_MSG_HANDLE_POE] = {XLP_2XX_POE_VC_BASE, XLP_2XX_POE_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_0] = {XLP_2XX_NET_TX_VC_BASE, XLP_2XX_NET_VC_LIMIT},
+
+[XLP_MSG_HANDLE_INVALID] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_MAX] = {XLP_2XX_INVALID_STATION, 0},
+};
+extern struct nlm_node_config nlm_node_cfg;
+
+/*#define FMN_DEBUG 1 */
+
+static unsigned int fmn_cfg_value[XLP_NET_VC_LIMIT + 1];
+static unsigned int fmn_default_credits = XLP_FMN_DEFAULT_CREDITS;
+static unsigned int fmn_default_qsize = XLP_FMN_DEFAULT_QUEUE_SIZE;
+static unsigned long long fmn_spill_mem_addr = XLP_FMNQ_SPILL_DEFAULT_MEM_ADDR;
+static unsigned long long fmn_spill_mem_size = XLP_FMNQ_SPILL_DEFAULT_MEM_SIZE;
+
+
+static struct fmn_qsize_credit_config fmn_qsize_credit_cfg[XLP_MSG_BLK_MAX] = {
+	[XLP_MSG_BLK_CPU] =     { "cpu",    XLP_CPU0_VC_BASE,      XLP_CPU7_VC_LIMIT,      8, 1 },
+	[XLP_MSG_BLK_POPQ] =    { "popq",   XLP_POPQ_VC_BASE,      XLP_POPQ_VC_LIMIT,      0, 1 },
+        [XLP_MSG_BLK_PCIE0] =    { "pcie0",   XLP_PCIE0_VC_BASE,     XLP_PCIE0_VC_LIMIT,     1, 1 },
+        [XLP_MSG_BLK_PCIE1] =    { "pcie1",   XLP_PCIE1_VC_BASE,     XLP_PCIE1_VC_LIMIT,     1, 1 },
+        [XLP_MSG_BLK_PCIE2] =    { "pcie2",   XLP_PCIE2_VC_BASE,     XLP_PCIE2_VC_LIMIT,     1, 1 },
+        [XLP_MSG_BLK_PCIE3] =    { "pcie3",   XLP_PCIE3_VC_BASE,     XLP_PCIE3_VC_LIMIT,     1, 1 },
+	[XLP_MSG_BLK_GDX]  =    { "gdx",    XLP_GDX_VC_BASE,       XLP_GDX_VC_LIMIT,       1, 1 },
+	[XLP_MSG_BLK_RSA_ECC] = { "rsa",    XLP_RSA_ECC_VC_BASE,   XLP_RSA_ECC_VC_LIMIT,   1, 1 },
+	[XLP_MSG_BLK_CRYPTO] =  { "crypto", XLP_CRYPTO_VC_BASE,    XLP_CRYPTO_VC_LIMIT,    1, 1 },
+	[XLP_MSG_BLK_CMP] =     { "cmp",    XLP_CMP_VC_BASE,       XLP_CMP_VC_LIMIT,       1, 1 },
+	[XLP_MSG_BLK_POE] =     { "poe",    XLP_POE_VC_BASE,       XLP_POE_VC_LIMIT,       1, 1 },
+	[XLP_MSG_BLK_NAE] =     { "nae",    XLP_NET_VC_BASE,       XLP_NET_VC_LIMIT,       1, 1 },
+	[XLP_MSG_BLK_REGX] =    { "regx",   XLP_3XX_REGEX_VC_BASE, XLP_3XX_REGEX_VC_LIMIT, 1, 1 },
+	[XLP_MSG_BLK_SRIO] =    { "srio",   XLP_3XX_SRIO_VC_BASE,  XLP_3XX_SRIO_VC_LIMIT,  1, 1 },
+};
+
+int station_exist_in_2xx(int qid)
+{
+	int hndl;
+	nlm_fmn_config_t *fmn_config = &xlp2xx_fmn_config[0];
+	for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
+		if((qid >= fmn_config[hndl].base_vc) && (qid <= fmn_config[hndl].vc_limit))
+			return 1;
+
+	}
+	/* check for popq. 
+	TODO : We should add this also in to the array 
+	 */
+	if(qid >= 128 && qid <= 159)
+		return 1;
+
+	return 0;
+}
+
+/* called based on the chip type */
+static void fmn_modify_qsize_credit_config(int node, int blk, int ntxstns, int b_stid, int e_stid)
+{
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	if(ntxstns >= 0)
+		fmn_q_config[blk].n_txstns = ntxstns;
+	if(b_stid >= 0)
+		fmn_q_config[blk].b_stid = b_stid;
+	if(e_stid >= 0)
+		fmn_q_config[blk].e_stid = e_stid;
+}
+
+static void fmn_invalidate_blocks(int node, int blk)
+{
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	fmn_q_config[blk].valid = 0;
+}
+
+
+static void fmn_invalidate_block_on_allnodes(int block)
+{
+	int node;
+
+	for(node=0; node < nlm_node_cfg.num_nodes; node++)
+		fmn_invalidate_blocks(node, block); 
+}
+
+static void update_fmn_config(void)
+{
+	uint32_t pid, epid, config;
+
+	pid = get_proc_id();
+
+	switch(pid) {
+                case CHIP_PROCESSOR_ID_XLP_8_4_XX:
+			fmn_invalidate_block_on_allnodes(XLP_MSG_BLK_REGX);
+			fmn_invalidate_block_on_allnodes(XLP_MSG_BLK_SRIO);
+                        break;
+		case CHIP_PROCESSOR_ID_XLP_3XX:
+			xlp3xx_fmn_config[XLP_MSG_HANDLE_CMP].base_vc = XLP_INVALID_STATION;
+			fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_CMP);
+			epid = get_xlp3xx_epid();
+			switch(epid) {
+				case CPU_EXTPID_XLP_202a:
+				case CPU_EXTPID_XLP_201a:
+				case CPU_EXTPID_XLP_101a:
+					xlp3xx_fmn_config[XLP_MSG_HANDLE_RSA_ECC].base_vc = XLP_INVALID_STATION;
+					xlp3xx_fmn_config[XLP_MSG_HANDLE_CRYPTO].base_vc = XLP_INVALID_STATION;
+					xlp3xx_fmn_config[XLP_MSG_HANDLE_SRIO].base_vc = XLP_INVALID_STATION;
+					xlp3xx_fmn_config[XLP_MSG_HANDLE_REGX].base_vc = XLP_INVALID_STATION;
+
+					fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_RSA_ECC);
+					fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_CRYPTO);
+					fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_SRIO);
+					fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_REGX);
+					break;
+			}
+			break;
+		case CHIP_PROCESSOR_ID_XLP_2XX:
+			xlp2xx_fmn_config[XLP_MSG_HANDLE_SRIO].base_vc =  XLP_INVALID_STATION;
+			fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_SRIO);
+			
+			config = nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG2)));
+			nlm_print("XLP2xx Efuse config 2 0x%x\n",config);
+
+			if (config & (1 << XLP2XX_RSA_BLOCK_INDEX)) {
+				xlp2xx_fmn_config[XLP_MSG_HANDLE_RSA_ECC].base_vc = XLP_INVALID_STATION;
+				fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_RSA_ECC);
+			}
+
+			if (config & (1 << XLP2XX_REGX_BLOCK_INDEX)) {
+				xlp2xx_fmn_config[XLP_MSG_HANDLE_REGX].base_vc = XLP_INVALID_STATION;
+				fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_REGX);
+			}
+
+			config = nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG1)));
+			nlm_print("XLP2xx Efuse config 1 0x%x\n",config);
+
+			if (config & (1 << XLP2XX_CMP_BLOCK_INDEX)) {
+				xlp2xx_fmn_config[XLP_MSG_HANDLE_CMP].base_vc = XLP_INVALID_STATION;
+				fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_CMP);
+			}
+
+			if (config & (1 << XLP2XX_CRYPTO_BLOCK_INDEX)) {
+				xlp2xx_fmn_config[XLP_MSG_HANDLE_CRYPTO].base_vc = XLP_INVALID_STATION;
+				fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_CRYPTO);
+			}
+			break;
+	}
+}
+
+#if 0
+static void fmn_qsize_credit_cfg_extract(void *fdt)
+{
+	char path[128];
+	const void *pval;
+	int s_stn = 0, d_stn = 0, nodeoffset, plen, len = 0;
+	unsigned int qsize = XLP_FMN_DEFAULT_QUEUE_SIZE;
+	unsigned int credits = XLP_FMN_DEFAULT_CREDITS;
+
+	/* initialize with the default values, given the config file */
+	if(fdt) {
+		strcpy(path, "/fmn-config");
+		nodeoffset = fdt_path_offset(fdt, path);
+		if(nodeoffset >= 0)  {
+			pval = fdt_getprop(fdt, nodeoffset, "default-queue-size", &plen);
+			if(pval != NULL) {
+				qsize = fdt32_to_cpu(*(unsigned int *)pval);
+				fmn_default_qsize = qsize;
+			}
+			pval = fdt_getprop(fdt, nodeoffset, "default-credits", &plen);
+			if(pval != NULL) {
+				credits = fdt32_to_cpu(*(unsigned int *)pval);
+				fmn_default_credits = credits;
+			}
+		}
+
+		strcpy(path, "/extra-mem-config");
+		nodeoffset = fdt_path_offset(fdt, path);
+		if(nodeoffset >= 0)  {
+			pval = fdt_getprop(fdt, nodeoffset, "fmn-spill-mem-range", &plen);
+			if(pval != NULL) {
+				fmn_spill_mem_addr = fdt64_to_cpu(*(unsigned long long *)pval);
+				fmn_spill_mem_size = fdt64_to_cpu(*((unsigned long long *)pval + 1));
+			}
+		}
+	}
+
+	nlm_print("FMN Default queuesize %d credtis %d\n", qsize, credits);
+	nlm_print("FMN Spill mem addr %lx mem size %lx\n", 
+					(long)fmn_spill_mem_addr, (long)fmn_spill_mem_size);
+
+	/* credits from this source station(s_stn) to the destination station(d_stn) */
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		fmn_qsize_credit_cfg[s_stn].q_size = qsize;
+		for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++)
+			fmn_qsize_credit_cfg[s_stn].credits[d_stn] = credits;
+	}
+
+	if(!fdt)
+		return;
+	
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		len = sprintf(&path[0], "%s", "/fmn-config/");
+		sprintf(&path[len], "%s", fmn_qsize_credit_cfg[s_stn].q_name);
+		nodeoffset = fdt_path_offset(fdt, path);
+		if(nodeoffset < 0) 
+			continue;
+
+		/* get queue size for this station */
+		pval = fdt_getprop(fdt, nodeoffset, "queue-size", &plen);
+		if(pval != NULL) {
+			qsize = fdt32_to_cpu(*(unsigned int *)pval);
+			fmn_qsize_credit_cfg[s_stn].q_size = qsize;
+		}
+
+		/* get credits from this station to other stations */
+		for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+			pval = fdt_getprop(fdt, nodeoffset, fmn_qsize_credit_cfg[d_stn].q_name, &plen);
+			if (pval != NULL) {
+				credits = fdt32_to_cpu(*(unsigned int *)pval);
+				fmn_qsize_credit_cfg[s_stn].credits[d_stn] = credits;
+				/*nlm_print(" dst stn name %s credits %d\n", 
+						fmn_qsize_credit_cfg[d_stn].q_name, credits);*/
+			}
+		}
+	}
+	
+#ifdef FMN_DEBUG
+	/* dump the table */
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		len = 0;
+		nlm_print("name %s bstid %d estid %d ntxstns %d qsize %d\n",
+				fmn_qsize_credit_cfg[s_stn].q_name, fmn_qsize_credit_cfg[s_stn].b_stid,
+				fmn_qsize_credit_cfg[s_stn].e_stid, fmn_qsize_credit_cfg[s_stn].n_txstns,
+				fmn_qsize_credit_cfg[s_stn].q_size);
+		nlm_print("  credits ");
+		for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++)
+			nlm_print("<%s:%d> ",   fmn_qsize_credit_cfg[d_stn].q_name,
+					 fmn_qsize_credit_cfg[s_stn].credits[d_stn]);
+		nlm_print("\n");
+	}
+#endif
+}
+#endif
+
+static void fmn_update_credit(int node, int b_stid, int dst_node)
+{
+	unsigned int *credits = NULL;
+	int s_stn, d_stn, sid;
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	/* configure with the default */
+	for(sid = 0; sid <= XLP_NET_VC_LIMIT; sid++)
+		fmn_cfg_value[sid] = nlm_node_cfg.fmn_cfg[node]->fmn_default_credits;
+
+	/* Get credit config from the given source station to different destination station */
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		if(!fmn_q_config[s_stn].valid)
+			continue;
+		if(b_stid >=  fmn_q_config[s_stn].b_stid && 
+				b_stid <= fmn_q_config[s_stn].e_stid) {
+			credits = fmn_q_config[s_stn].credits[dst_node];
+			break;
+		}
+	}
+	if(credits == NULL) {
+		nlm_print("ERROR in Credit config: Station id not found, configuring default credit\n");
+		return;
+	}
+
+	for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+/*		nlm_print("update credit s_stn %d d_stn %d credits %d\n",s_stn, d_stn, credits[d_stn]); */
+		if(!fmn_q_config[d_stn].valid)
+			continue;
+		for(sid = fmn_q_config[d_stn].b_stid; sid <= fmn_q_config[d_stn].e_stid; sid++)
+			fmn_cfg_value[sid] = credits[d_stn];
+	}
+
+	return;
+}
+
+static int fmn_update_qsize(int node)
+{
+	int sid, s_stn;
+	unsigned long long qsize;
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	
+	/* qsize cannot be more than 256KB and it should be aligned to 4K */
+	if((fmn_default_qsize % FMN_Q_PAGE_SIZE) != 0)
+		fmn_default_qsize = (fmn_default_qsize + FMN_Q_PAGE_SIZE - 1) & (~(FMN_Q_PAGE_SIZE - 1));
+
+	if(fmn_default_qsize > FMN_MAX_Q_SIZE) {
+		nlm_print("ERROR: Default FMN Q size exceeds the limit\n");
+		return -1;
+	}
+	
+	for(sid = 0; sid <= XLP_NET_VC_LIMIT; sid++)
+		fmn_cfg_value[sid] = fmn_default_qsize;
+
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		if(!fmn_q_config[s_stn].valid)
+			continue;
+		for(sid = fmn_q_config[s_stn].b_stid; sid <= fmn_q_config[s_stn].e_stid; sid++) {
+			qsize = fmn_q_config[s_stn].q_size;
+			if(qsize > FMN_MAX_Q_SIZE) {
+				nlm_print("ERROR: FMN Q size for stn %d exceeds the limit\n", s_stn);
+				return -1;
+			}
+			if((qsize % FMN_Q_PAGE_SIZE) != 0)
+				qsize = (qsize + FMN_Q_PAGE_SIZE - 1) & (~(FMN_Q_PAGE_SIZE - 1));
+			fmn_cfg_value[sid] = qsize;
+		}
+	}
+	return 0;
+}
+
+
+static void fmn_validate_credit(int node, int max_nodes)
+{
+	unsigned int credits, qsize;
+	unsigned int s_stn, d_stn, src_node;
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	
+	/* credits from all the source stations to this station */
+	for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+		if(!fmn_q_config[d_stn].valid)
+			continue;
+		qsize = fmn_q_config[d_stn].q_size;
+		credits = 0;
+	        for(src_node = 0; src_node < max_nodes; src_node++) {
+  		    for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++)  {
+		 	if(!fmn_q_config[s_stn].valid)
+				continue;
+			credits += (fmn_q_config[s_stn].credits[src_node][d_stn] * fmn_q_config[s_stn].n_txstns);
+                    }
+		}
+
+#ifdef FMN_DEBUG
+		nlm_print("Credits check dst stn %s, reqd %d cfgrd %d\n", 
+					fmn_q_config[d_stn].q_name, (credits * 12), qsize);
+#endif
+
+		/* considering single entry message only */
+		if((credits * 12) >= qsize) 
+			nlm_print("WARN ... Credits overflow.. dst stn %s, reqd %d cfgd %d\n", 
+					fmn_q_config[d_stn].q_name, (credits * 12), qsize);
+	}
+}
+
+/* 1024-bit bitmask as 16 64-bit longs.
+ * '1' => station @ that bit position
+ * is disabled.
+ */
+unsigned long long stids[16];
+
+/*********************************************************************
+ * nlm_hal_enable_vc_intr
+ *
+ * In xlp, there are 4 VC per cpu. Each vc can be configured to generate
+ * an interrupt when message receive event happens.
+ ********************************************************************/
+void nlm_hal_enable_vc_intr(int node, int vc)
+{
+	uint64_t val = 0;
+	val = nlm_hal_read_outq_config(node, vc);
+	val &= ~((0x7ULL<<56) | (0x3ULL<<54) | (0x7ULL<<51) | (0x3ULL<<49));
+	val |=  (0ULL<<56)|(0x2ULL<<54)|(0x0ULL<<51)|(0x1ULL<<49);
+	nlm_hal_write_outq_config(node, vc, val);
+}
+
+/*********************************************************************
+ * nlm_hal_disable_vc_intr
+*********************************************************************/
+void nlm_hal_disable_vc_intr(int node, int vc)
+{
+	uint64_t val = 0;
+	val = nlm_hal_read_outq_config(node, vc);
+	val = val & ~((0x3ULL<<54) | (0x3ULL<<49));
+	nlm_hal_write_outq_config(node, vc, val);
+}
+
+/*********************************************************************
+ * nlm_hal_set_fmn_interrupt
+ *
+ * setup cp2 msgconfig register for fmn interrup vector as 6
+ *
+ ********************************************************************/
+void nlm_hal_set_fmn_interrupt(int irq)
+{
+	uint32_t val;
+	/* Need write interrupt vector to cp2 msgconfig register */
+
+	val =  _read_32bit_cp2_register(XLP_MSG_CONFIG_REG);
+	val &= ~(0x1f << 16);
+	val |= (irq << 16);
+	_write_32bit_cp2_register(XLP_MSG_CONFIG_REG, val);
+
+}
+
+static __inline__ void nlm_hal_write_credit(int node, uint64_t src, uint64_t dst, uint64_t credits)
+{
+	uint64_t regaddr = nlh_qid_to_virt_addr(node, XLP_CREDIT_CONFIG_REG, 0); 
+	uint64_t value = (((src) & 0x3ff) | (((dst) & 0xfff) << 12) | (((credits) & 0xffff) << 24));
+
+	nlh_write_cfg_reg64(regaddr, value);
+}
+
+/* Clear a particular bit within the
+ * 1024 bitmaks array stids.
+ * Note: not a generic routine.
+ */
+static void clearbit(int bitnum) {
+
+	int index = bitnum / 64;
+	stids[index] &= ~(1ULL << (bitnum % 64));
+}
+
+void enable_interface(int interface, short value) {
+
+	switch (interface) {
+		case CPU: {
+				int i;
+				for (i=0; i<8; i++) {
+					if ((value  & (1 << i)) == 0)
+						clearbit(i << 4);
+				}
+			} break;
+		case PCIE: {
+				int i;
+				for (i=0; i<4; i++) {
+					if ((value  & (1 << i)) == 0)
+						clearbit(XLP_STNID_PCIE0 + (i << 1));		
+				}
+			} break;
+		case GDX: {
+				if (value == 0)
+					clearbit(XLP_STNID_GDX);		
+			} break;
+		case CMP: {
+				int i;
+#ifndef NLM_XLP_3XX
+				for (i=0; i<4; i++) {
+					if ((value  & (1 << i)) == 0)
+						clearbit(XLP_STNID_CMP + i);		
+				}
+#endif
+			} break;
+		case CRYPTO: {
+				int i;
+				for (i=0; i<12; i++) {
+					if ((value  & (1 << i)) == 0)
+						clearbit(XLP_STNID_CRYPTO + i);		
+				}
+			} break;
+		case POE: {
+				if (value == 0)
+					clearbit(XLP_STNID_POE);		
+			} break;
+		case NAE: {
+				if (value == 0)
+					clearbit(XLP_STNID_NAE_TX);		
+			} break;
+		case RSA: {
+				int i;
+				for (i=0; i<9; i++) {
+					if ((value  & (1 << i)) == 0)
+						clearbit(XLP_STNID_RSA_ECC + i);		
+				}
+			} break;
+		default:
+			nlm_print("Error! Configuring Credits for Unknown Interface.\n");
+			break;
+	}
+}
+	
+/* Based on the (un)set bits from the EFUSE CFG Regs,
+ * create a bitmask representing 0-1023 station IDs
+ * which can then be used to check whether to send
+ * credits to or not. This is a one-time operation.
+ */
+void stids_toskip(int node) {
+
+	int i;
+
+        if(is_nlm_xlp2xx()) {
+		nlm_print("xlp2xx: please update %s\n", __FUNCTION__);
+		return;
+	}
+
+	for (i=0; i<16; i++)
+		stids[i] = ~0ULL;	/* init to all disabled */
+	
+	enable_interface(CPU,     nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG0) & 0xff);
+	enable_interface(PCIE,   (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 3) & 0xf);
+	enable_interface(GDX,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 8) & 0x1);
+	enable_interface(CMP,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 9) & 0xf);
+	enable_interface(CRYPTO, (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 14) & 0xfff);
+	enable_interface(POE,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 27) & 0x1);
+	enable_interface(NAE,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 28) & 0x1);
+	enable_interface(RSA,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG2)) & 0x1ff);
+}
+
+static void nlm_hal_write_fmn_credit(int node, int max_nodes) 
+{
+	int src, qid, hndl = 0, dst_node;
+	nlm_fmn_config_t *fmn_config = NULL;
+	volatile int index;
+	uint32_t credits, cfgrd;
+
+        if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
+		nlm_print(" XLP3XX/XLP2XX FMN configuration \n");
+		if(is_nlm_xlp316()){
+			nlm_print(" XLP316 FMN configuration \n");
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 4, XLP_CPU0_VC_BASE, XLP_CPU3_VC_LIMIT);
+		}
+		else if(is_nlm_xlp312()){
+			nlm_print(" XLP312 FMN configuration \n");
+			fmn_config = &xlp3xx_fmn_config[0];
+			fmn_config += XLP_MSG_HANDLE_CPU3;
+			for(hndl = 0; hndl<1; hndl++){
+				fmn_config->base_vc = XLP_3XX_INVALID_STATION,
+				fmn_config->vc_limit =0;
+				fmn_config++;
+			}
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 3, XLP_CPU0_VC_BASE, XLP_CPU2_VC_LIMIT);
+		}
+		else if(is_nlm_xlp308() || is_nlm_xlp208()){
+			nlm_print(" XLP308/208 FMN configuration \n");
+			fmn_config = (is_nlm_xlp308())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
+			fmn_config += XLP_MSG_HANDLE_CPU2;
+			for(hndl = 0; hndl<2; hndl++){
+				fmn_config->base_vc = XLP_3XX_INVALID_STATION,
+				fmn_config->vc_limit =0;
+				fmn_config++;
+			}
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 2, XLP_CPU0_VC_BASE, XLP_CPU1_VC_LIMIT);
+
+		}
+		else if(is_nlm_xlp304() || is_nlm_xlp204()){
+			nlm_print(" XLP304/204 FMN configuration \n");
+			fmn_config = (is_nlm_xlp304())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
+			fmn_config += XLP_MSG_HANDLE_CPU1;
+			for(hndl = 0; hndl<3; hndl++){
+				fmn_config->base_vc = XLP_3XX_INVALID_STATION,
+				fmn_config->vc_limit =0;
+				fmn_config++;
+			}
+
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 1, XLP_CPU0_VC_BASE, XLP_CPU0_VC_LIMIT);
+		}
+		else {
+		}
+
+		if (is_nlm_xlp3xx()) {
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_3XX_RSA_ECC_VC_BASE, XLP_3XX_RSA_ECC_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_3XX_CRYPTO_VC_BASE, XLP_3XX_CRYPTO_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_3XX_NET_VC_BASE, XLP_3XX_NET_VC_LIMIT);
+		}
+		else if (is_nlm_xlp2xx()) {
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_2XX_RSA_ECC_VC_BASE, XLP_2XX_RSA_ECC_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_2XX_CRYPTO_VC_BASE, XLP_2XX_CRYPTO_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_2XX_NET_VC_BASE, XLP_2XX_NET_VC_LIMIT);
+		}
+			
+		if (is_nlm_xlp3xx_ax() == 0)
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_SRIO, 1, XLP_3XX_SRIO_VC_BASE, XLP_3XX_B0_SRIO_VC_LIMIT);
+
+		fmn_config = (is_nlm_xlp3xx())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
+                for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
+                        if (fmn_config->base_vc != XLP_INVALID_STATION) {
+				fmn_update_credit(node, fmn_config->base_vc, node);		
+				credits = 0;
+                                for (qid = 0; qid <= XLP_3XX_NET_VC_LIMIT; qid++) {
+#ifdef FMN_DEBUG
+					if(credits != fmn_cfg_value[qid]) {
+						nlm_print("base %d qid %d credits %d\n", 
+							fmn_config->base_vc, qid, fmn_cfg_value[qid]);
+					}
+#endif
+					cfgrd = credits = fmn_cfg_value[qid];
+					if ((fmn_config->base_vc >= XLP_STNID_CPU0) && (fmn_config->base_vc <= XLP_STNID_CPU7))
+						cfgrd = credits - 1;
+
+	                                nlm_hal_write_credit(node, fmn_config->base_vc, qid, cfgrd);	
+                                }
+                        }
+                        fmn_config++;
+                }
+        }
+	else {
+	/* this populates the global array 'stids' 
+	 * with a '1' representing a disabled station ID.
+	 */
+		stids_toskip(node);
+
+		for (src = 0; src <= XLP_STNID_NAE_TX; src++) {
+			/* check if bitposition src == 1 in 
+			 * the dst_skip_bitmask. if so, continue
+			 */
+			index = src / 64;
+
+			if ((stids[index] >> (src % 64)) & 0x1) {
+				continue;
+			}
+
+			/* only enabled stations will reach here
+			 */
+
+			for(dst_node = 0 ;dst_node < max_nodes; dst_node++) {
+				fmn_update_credit(node, src, dst_node);
+				credits = 0;
+				for (qid = 0; qid < 1024; qid++) {
+#ifdef FMN_DEBUG
+					if(credits != fmn_cfg_value[qid]) {
+						nlm_print("src%d@%d node %d qid %d credits %d\n", 
+							src, node, dst_node, qid, fmn_cfg_value[qid]);
+					}
+#endif
+					cfgrd = credits = fmn_cfg_value[qid];
+					if ((src >= XLP_STNID_CPU0) && (src <= XLP_STNID_CPU7))
+						cfgrd = credits - 1;
+
+					nlm_hal_write_credit(node, src, ((dst_node << 10) | qid), cfgrd);	
+				}
+			}
+		}
+	}
+
+	/* Validae the credit config */
+	fmn_validate_credit(node, max_nodes);
+}
+/*********************************************************************
+ * nlm_hal_fmn_init
+ *
+ * setup 1024 outq, set credit from cpu to io,  io to io, and io to
+ * cpu
+ ********************************************************************/
+#if defined(NLM_HAL_UBOOT) || defined(NLM_HAL_NETLBOOT) || defined(NLM_HAL_NETOS)
+
+#define OUT_Q_INIT	0
+
+#else
+
+#define OUT_Q_INIT	((0x2ULL<<54) | (0x1ULL<<49))
+
+#endif
+/*********************************************************************
+ * nlm_hal_setup_outq
+ *
+ * In xlp, there is 1024 receive message queues for fmn network. The
+ * queue, allocated to cpu and high speed IO device, identified by
+ * their vc number. When A send B a FMN message, receive VC is dest
+ * number A need addressing. This function is to config each queue with
+ * initial defaule value
+ *
+ * Total spill size for each Q is 16KB
+ * This allows for 1024 q entries with 16B of entry size
+ * This assumes credits across all sending agents to this queue is < 1024
+ ********************************************************************/
+int nlm_hal_setup_outq(int node, int max_nodes)
+{
+	uint32_t qid, max_qs = 0;
+	uint64_t val;
+
+	uint64_t spill_base = nlm_node_cfg.fmn_cfg[node]->fmn_spill_base; /*fmn_spill_mem_addr; */
+	uint32_t spill_size = nlm_node_cfg.fmn_cfg[node]->fmn_spill_size;
+	uint64_t q_spill_start_page = 0, q_spill_pages;
+
+	const uint32_t ram_base = 0;
+	uint32_t q_ram_base = 0;
+	uint32_t q_ram_start_page = 0;
+	const int q_ram_pages = 1;
+	const uint32_t q_ram_page_entries = 32; /* entries, not bytes */
+	int cnt =0;
+
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
+		max_qs = XLP_3XX_NET_VC_LIMIT;
+	}
+	else {
+		max_qs = XLP_NET_VC_LIMIT;
+	}
+
+        nlm_node_cfg.fmn_cfg[node]->spill_base_cur = spill_base;
+        nlm_node_cfg.fmn_cfg[node]->q_ram_base = nlm_node_cfg.fmn_cfg[node]->q_ram_base_cur = q_ram_base;
+        nlm_node_cfg.fmn_cfg[node]->q_ram_page_perq = 1;
+
+	if(fmn_update_qsize(node) < 0)
+		return -1;
+
+	for( qid = 0; qid <= max_qs; qid++ )
+	{
+		/* Enable all output queues and spill on all queues.
+		   Disable spill for u-boot as the spill memory will be enabled by the os 
+		   loading time with the specified address */
+#if defined(NLM_HAL_UBOOT) || defined(NLM_HAL_NETLBOOT)
+		val = OUTQ_EN;
+#else
+		val = OUTQ_EN;
+		if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) 
+			val |= SPILL_EN;
+#endif
+
+		/* Enable interrupts for cpu Queues */
+		if ( (qid >= 0) && (qid < 128))
+			val |= OUT_Q_INIT ;
+
+			/*val |= INT_EN|(0ULL<<56)|(0x2ULL<<54)|(0x0ULL<<51)|(0x1ULL<<49); */
+
+		/***************************************************************
+		 * Configuration of on-chip RAM area
+		 **************************************************************
+		 */
+		/* As 2xx has only 8k onchip memory skip all the invalid stations */
+		if(is_nlm_xlp2xx()) {
+			if(!station_exist_in_2xx(qid))
+				continue;
+			q_ram_base = ram_base + (cnt * q_ram_pages * q_ram_page_entries);
+			cnt++;
+		} else 
+			q_ram_base = ram_base + (qid * q_ram_pages * q_ram_page_entries);
+
+		val |= ( ((q_ram_base >> 10) & 0x1f) << 10); /* [14:10] of q_ram_base */
+
+		q_ram_start_page = (q_ram_base >> 5) & 0x1f; /* [9:5] of q_ram_base */
+		val |= (q_ram_start_page << 0);
+		val |= ( (q_ram_start_page + q_ram_pages - 1) << 5) ;
+
+		if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) {
+
+			/***************************************************************
+			 * Configuration of spill area
+			 **************************************************************
+			 */
+			/* pages in 4K units */
+			q_spill_pages = fmn_cfg_value[qid] / (FMN_Q_PAGE_SIZE);
+		
+			/* if spill_start + qsize crosses 256MB boundary, configuration will be wrong as 
+			 only 17-12 bits only considered for spill last */
+			if(((spill_base & (FMN_MAX_Q_SIZE - 1)) +  fmn_cfg_value[qid]) > FMN_MAX_Q_SIZE)
+				spill_base = (spill_base + FMN_MAX_Q_SIZE - 1) & (~(FMN_MAX_Q_SIZE - 1));
+		
+			val |= ( ((spill_base >> 18) & 0x3fffff) << 27); /* [39:18] of q_spill_base */
+
+			q_spill_start_page = (spill_base >> 12) & 0x3f; /* [17:12] of q_spill_base */
+			val |= (q_spill_start_page << 15);
+			val |= ( (q_spill_start_page + q_spill_pages - 1) << 21);
+
+#ifdef FMN_DEBUG
+		nlm_print("Fmn q config %d sqbase %lx sqsize %d sqpages %d\n", 
+				qid, (long)spill_base, fmn_cfg_value[qid], (int)q_spill_pages);
+#endif
+		
+			spill_base +=  fmn_cfg_value[qid];
+		}
+		
+		/* Write to the configuration register */
+		nlm_hal_write_outq_config(node, qid, val);
+	}
+
+        nlm_node_cfg.fmn_cfg[node]->spill_base_cur = spill_base;
+        nlm_node_cfg.fmn_cfg[node]->q_ram_base_cur = q_ram_base;
+ 
+        nlm_print("spill_base_cur 0x%llx qram_base_cur 0x%llx \n",(unsigned long long)spill_base,(unsigned long long) q_ram_base);
+
+/*	if((spill_base - fmn_spill_mem_addr) > fmn_spill_mem_size) { */
+	if ((spill_base - nlm_node_cfg.fmn_cfg[node]->fmn_spill_base) > spill_size) {
+		nlm_print("ERROR:  FMN Q total size exceeds the limit\n");
+		return -1;
+	}
+	return 0;
+}
+
+int parse_queue_config(void *fdt, int max_nodes)
+{
+        int node = 0, src_node, s_stn, d_stn;
+        char fmn_cfg_str[80];
+        char prop_str[10];
+        int plen, nodeoffset;
+        uint32_t *pval;
+	struct fmn_qsize_credit_config *fmn_q_config;
+	uint32_t credits, qsize;
+
+        for(node = 0 ;  node < max_nodes; node++) {
+                fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+                for(d_stn=0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+
+                        sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s", node, fmn_q_config[d_stn].q_name);
+                        nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+                        if(nodeoffset < 0)
+                                continue;
+	                /* get queue size for this station */
+        	        pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "queue-size", &plen);
+                	if(pval != NULL) {
+                        	qsize = fdt32_to_cpu(*(unsigned int *)pval);
+	                        fmn_q_config[d_stn].q_size = qsize;
+        	        }
+
+                        sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s/credits-from", node, fmn_q_config[d_stn].q_name);
+                        nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+                        if(nodeoffset < 0)
+                                continue;
+
+                	/* get credits from this station to other stations */
+
+                        for(src_node = 0; src_node < max_nodes; src_node++) {
+                                sprintf(prop_str, "node-%d", src_node);
+                                pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, prop_str, &plen);
+                                if(pval != NULL) {
+                                        if ((plen / sizeof(uint32_t)) != XLP_MSG_BLK_MAX) {
+                                                nlm_print("Invalid credit configuration in fdt \n");
+                                                while(1); 
+                                        }
+                                        for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+                                                credits = fdt32_to_cpu(*(unsigned int *)(pval + s_stn));
+						if (credits != 0)
+							nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn] = credits;
+#ifdef FMN_DEBUG
+                                                nlm_print("node %d station %s has %d credits to %d:Q %s\n", src_node, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].q_name, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn], node, fmn_q_config[d_stn].q_name);
+#endif
+                                        }
+
+                                }
+                        }
+                }
+        }
+	return 0;
+}
+
+
+int parse_fdt_fmn_config(void *fdt)
+{
+	char fmn_cfg_str[50];
+	int nodeoffset = 0, plen, max_nodes = 1, node = 0;
+  	uint32_t *pval;
+	struct fmn_cfg *fmn_config;
+#if !defined(NLM_HAL_UBOOT) && !defined(NLM_HAL_NETLBOOT)
+	uint64_t spill_base = 0ULL;
+#endif
+	uint32_t qsize, credits, src_node, s_stn, d_stn;
+
+	sprintf(fmn_cfg_str,"/soc/nodes");
+	nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+        if(nodeoffset >= 0) {
+		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "num-nodes", &plen);
+		if(pval != NULL) {
+			max_nodes = fdt32_to_cpu(*(unsigned int *)pval);
+		}
+	}
+
+	nlm_print("Number of nodes %d \n",max_nodes);
+
+	nlm_node_cfg.num_nodes = max_nodes;
+	
+	for(node = 0; node < max_nodes; node++) {
+		nlm_node_cfg.fmn_cfg[node] = nlm_malloc(sizeof(struct fmn_cfg));
+		if (nlm_node_cfg.fmn_cfg[node] == NULL) {
+			nlm_print("nlm_malloc failed for node %d\n", node);
+			return -1;
+		}
+		memset(nlm_node_cfg.fmn_cfg[node], 0, sizeof(struct fmn_cfg));
+		nlm_node_cfg.fmn_cfg[node]->fmn_default_credits = fmn_default_credits/max_nodes;
+		nlm_node_cfg.fmn_cfg[node]->fmn_default_qsize = fmn_default_qsize;
+		if (node == 0) {
+			nlm_node_cfg.fmn_cfg[node]->fmn_spill_base = fmn_spill_mem_addr;
+			nlm_node_cfg.fmn_cfg[node]->fmn_spill_size = fmn_spill_mem_size;
+		}
+		else {
+			nlm_node_cfg.fmn_cfg[node]->fmn_spill_base = 0ULL;
+			nlm_node_cfg.fmn_cfg[node]->fmn_spill_size = 0ULL;
+		}
+		
+		sprintf(fmn_cfg_str,"/soc/fmn@node-%d",node);
+                nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+                if(nodeoffset < 0) {
+                        nlm_print("No 'fmn@node-%d' param in dtb \n",node);
+			nlm_print("node %d default qsize %d credits %d\n",node, nlm_node_cfg.fmn_cfg[node]->fmn_default_qsize, nlm_node_cfg.fmn_cfg[node]->fmn_default_credits);
+	                memcpy(nlm_node_cfg.fmn_cfg[node]->fmn_q_config, fmn_qsize_credit_cfg, sizeof(fmn_qsize_credit_cfg));
+                        continue;
+                }
+
+#if !defined(NLM_HAL_UBOOT) && !defined(NLM_HAL_NETLBOOT)
+		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "fmn-spill-mem-size", &plen);
+                if(pval != NULL) {
+                        nlm_node_cfg.fmn_cfg[node]->fmn_spill_size = fdt64_to_cpu(*(unsigned long long *)pval) ;
+		}
+
+		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "fmn-spill-mem-base", &plen);
+		if(pval != NULL) {
+			spill_base = fdt64_to_cpu(*(unsigned long long *)pval);
+			if (spill_base != 0ULL) {
+				nlm_node_cfg.fmn_cfg[node]->fmn_spill_base = spill_base;
+			}
+		}
+#ifdef NLM_HAL_LINUX_KERNEL
+		if ((pval == NULL) || (spill_base == 0ULL)){
+			spill_base = nlm_spill_alloc(node, (nlm_node_cfg.fmn_cfg[node]->fmn_spill_size));
+			if (spill_base == 0ULL) {
+				nlm_print("Node %d FMN spill_mem alloc failed \n", node);
+				nlm_node_cfg.fmn_cfg[node]->fmn_spill_size = 0;
+			}
+			else
+				nlm_node_cfg.fmn_cfg[node]->fmn_spill_base = spill_base;
+		}
+#endif
+#endif
+		nlm_print("spillsize 0x%llx @ 0x%016llx \n", (unsigned long long)nlm_node_cfg.fmn_cfg[node]->fmn_spill_size,(unsigned long long)nlm_node_cfg.fmn_cfg[node]->fmn_spill_base);
+
+
+                pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "default-queue-size", &plen);
+                if (pval != NULL) {
+                        qsize = fdt32_to_cpu(*(unsigned int *)pval);
+                        nlm_node_cfg.fmn_cfg[node]->fmn_default_qsize = qsize;
+                }
+
+                pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "default-credits", &plen);
+                if (pval != NULL) {
+                        credits = fdt32_to_cpu(*(unsigned int *)pval);
+                        nlm_node_cfg.fmn_cfg[node]->fmn_default_credits = credits / max_nodes;
+                }
+
+		nlm_print("node %d default qsize %d credits %d\n",node, nlm_node_cfg.fmn_cfg[node]->fmn_default_qsize, nlm_node_cfg.fmn_cfg[node]->fmn_default_credits);
+                memcpy(nlm_node_cfg.fmn_cfg[node]->fmn_q_config, fmn_qsize_credit_cfg, sizeof(fmn_qsize_credit_cfg));
+	}
+
+        for(node=0; node < max_nodes; node++) {
+                fmn_config = nlm_node_cfg.fmn_cfg[node];
+                for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+                        fmn_config->fmn_q_config[d_stn].q_size = fmn_config->fmn_default_qsize;
+                        for(src_node=0; src_node < max_nodes; src_node++) {
+                                for(s_stn=0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+                                        fmn_config->fmn_q_config[d_stn].credits[src_node][s_stn] = fmn_config->fmn_default_credits;
+#ifdef FMN_DEBUG
+                                        nlm_print("%d:%s Q, credits given to node %d stn %s : %d\n", node, fmn_config->fmn_q_config[d_stn].q_name, src_node, fmn_config->fmn_q_config[s_stn].q_name, fmn_config->fmn_q_config[d_stn].credits[src_node][s_stn]);
+#endif
+                                }
+                        }
+                }
+        }
+
+	parse_queue_config(fdt, max_nodes);
+
+	return max_nodes;
+}
+
+int get_dom_fmn_node_ownership(void *fdt, int dom_id)
+{
+	uint32_t owner_mask;
+
+	owner_mask = get_dom_owner_mask(fdt, dom_id, "fmn");
+
+	return owner_mask;
+}
+
+/**
+* @brief nlm_hal_fmn_init function Initializes FMN (outpu Queues and Credit registers)
+*
+* @param [in]  spill_base    :Physical address where the spill base starts
+* @param [in]  size          :Size of the spill/fill region in bytes
+* @param [in]  credits       :Number of credits from any src to any dst. 
+*
+* @return
+*  - Returns no value.
+*
+* @note
+*    1. This funysconfig/dts/fmn-temp.dtstion must be the first to be called before any FMN HAL API's.
+* @n
+*    2. This function is typically called twice (once from U-boot and once from OS). This is due to
+*       Netlogic's SDK convention that only 1 cpu is running while in U-boot and potentially more than 
+*       one cpu running while in OS and also the requirement that Credit configuration can only
+*       happen after the cpu is out of reset.
+* @n
+*    3. The credits between any source and any destination is chosen to be same for simplification.
+* 
+* @ingroup hal_fmn
+*
+*/
+void nlm_hal_fmn_init(void *fdt, int node)
+{
+	int max_nodes;
+
+	nlm_print("*** Firmware Configuration of FMN ***\n");
+
+	max_nodes = parse_fdt_fmn_config(fdt);
+
+	update_fmn_config();
+
+	if (max_nodes < 0) {
+		nlm_print("FMN Configuration failed\n");
+		while(1);
+	}
+
+	if(!is_nlm_xlp2xx()) {
+		nlm_hal_soc_clock_enable(node, DFS_DEVICE_RSA);
+	}
+
+	/*fmn_qsize_credit_cfg_extract(fdt); */
+	/* verify out_q config 
+	 */
+	if(nlm_hal_setup_outq(node, max_nodes) < 0)
+		while(1);
+	nlm_hal_write_fmn_credit(node, max_nodes);
+}
+
+#ifdef NLM_HAL_LINUX_KERNEL 
+#include <linux/types.h>
+#include <linux/module.h>
+EXPORT_SYMBOL(nlm_hal_disable_vc_intr);
+EXPORT_SYMBOL(nlm_hal_enable_vc_intr);
+EXPORT_SYMBOL(nlm_hal_fmn_init);
+#endif
diff --git a/arch/mips/netlogic/common/nlm_hal_mdio.c b/arch/mips/netlogic/common/nlm_hal_mdio.c
new file mode 100644
index 0000000..8f13655
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_hal_mdio.c
@@ -0,0 +1,1038 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/netdevice.h>
+#endif
+#include "nlm_hal_fmn.h"
+#include "nlm_hal_nae.h"
+#include "nlm_hal_sys.h"
+#include "libfdt.h"
+#include "fdt_helper.h"
+#include "nlm_evp_cpld.h"
+
+
+void nae_ext_mdio_wait(int n)
+{
+	volatile int s=0, i,j;
+	unsigned long long freq = nlm_hal_cpu_freq();
+	freq >>= 17;
+	if ( is_nlm_xlp3xx_ax() || is_nlm_xlp8xx_ax() || is_nlm_xlp8xx_b0() )
+	   return;
+	for(j=0; j<n; j++)
+	for(i=0; i<freq; i++) s++;
+	return;
+}
+
+/*
+ * MDIO CLK = NAE Freq/(26*8*2)/64
+ * MDIO CLK = 250MHz/(26*4*2)/64  when addDiv=7 & div=2 ==> 18.75KHz
+ *------------------------------
+ * EXT_G0_MDIO_CTRL[4:2]
+ *------------------------------
+ *  0 1
+ *  1 1
+ *  2 2
+ *  3 3
+ *  4 4
+ *  5 6
+ *  6 9
+ *  7 26
+ *------------------------------
+ * EXT_G0_MDIO_CTRL[1:0]
+ * 0 1
+ * 1 2
+ * 2 4
+ * 3 8
+ *------------------------------
+ */
+/*0x1E: 0001 11,10  addDiv=7, div=2 ==> 18.75KHz if nae.ref=250Mhz */
+/*0x10: 0001 00,00  addDiv=4, div=0 ==> 0.5Mhz if nae.ref=250MHz */
+/*0x11: 0001 00,01  addDiv=4, div=1 ==> 0.5Mhz if nae.ref=500MHz */
+static uint32_t nae_get_EXT_G_MDIO_DIV(void)
+{
+	/*
+	 * MDIO CLK = 250MHz/(4*1*2)/64  when addDiv=4 & div=0 ==> 0.5MHz
+	 * MDIO CLK = 500MHz/(4*1*2)/64  when addDiv=4 & div=0 ==> 1.0MHz
+	 * XLP8XX_B1_EXT_G_MDIO_DIV:= b100,00 = 0x10
+	 */
+	return (
+	       is_nlm_xlp3xx_ax() ||
+	       is_nlm_xlp8xx_ax() ||
+	       is_nlm_xlp8xx_b0() ) ?  EXT_G_MDIO_DIV : EXT_G_MDIO_DIV_WITH_HW_DIV64_11;
+}
+
+/* INT_MDIO_CTRL, block7, 0x799
+ * EXT_XG_MDIO_CTRL, block7, 0x7A5,0x7A9
+ * 29:28: MCDiv Master Clock Divider
+ * 0 1
+ * 1 2
+ * 2 4
+ * 3 8
+ * 27:21: XDiv Clock Divisor
+ *   M(mdc) = F(mstclk)/(2*(XDiv+1))
+ *    500MHz/4 = 125MHz
+ *    125MHz/(2*(0x7F+1)) = 0.5MHz
+ *
+ *    250MHz/4 = 62.5MHz
+ *    62.5MHz/(2*(0x7F+1)) = 0.24MHz
+ */
+
+static uint32_t nae_get_EXT_XG_MDIO_DIV(void)
+{
+	return ((0x7F << EXT_XG_MDIO_CTRL_XDIV_POS) | (2 << EXT_XG_MDIO_CTRL_MCDIV_POS));
+}
+
+/* INT_MDIO_CTRL, block7, 0x799
+ * EXT_XG_MDIO_CTRL, block7, 0x7A5,0x7A9
+ * 29:28: MCDiv Master Clock Divider
+ * 0 1
+ * 1 2
+ * 2 4
+ * 3 8
+ * 27:21: XDiv Clock Divisor
+ *   M(mdc) = F(mstclk)/(2*(XDiv+1))
+ *    500MHz/4 = 125MHz
+ *    125MHz/(2*(0x7F+1)) = 0.5MHz
+ *
+ *    250MHz/4 = 62.5MHz
+ *    62.5MHz/(2*(0x7F+1)) = 0.24MHz
+ */
+static uint32_t nae_get_INT_MDIO_DIV(void)
+{
+	return ((0x7F << INT_MDIO_CTRL_XDIV_POS) | (2 << INT_MDIO_CTRL_MCDIV_POS));
+}
+
+#define PHY_STATUS_RETRIES 20000
+
+#define NUM_EGRESS_PORTS 18
+#define TX_IF_BURST_MAX  2048
+#define DRR_QUANTA       2048
+#define SP_EN            0
+#define SP_NUM           0
+
+
+
+#define WAIT_XGMAC_MDIO_BSY_CLEAR(node)  \
+	for (i = 0; i < PHY_STATUS_RETRIES; i++) {	\
+		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG,	\
+			EXT_XG0_MDIO_RD_STAT + bus * 4 ) & EXT_XG_MDIO_STAT_MBSY) == 0)	\
+                        break;							\
+        }
+
+#define WAIT_XGMAC_IMDIO_BSY_CLEAR(node)   \
+	for (i = 0; i < PHY_STATUS_RETRIES; i++) { \
+		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, \
+			INT_MDIO_RD_STAT) & INT_MDIO_STAT_MBSY) == 0)        \
+                        break;                                                  \
+        }
+
+
+/*
+ *      MDIO Support
+ */
+/* Internal MDIO READ/WRITE Routines
+ */
+/**
+* @brief nae_int_gmac_mdio_read function is used to read an SGMII PCS register.
+* 
+* @param [in] node Node number
+* @param [in] bus Internal MDIO bus number
+* @param [in] phyaddr Internal PHY's address
+* @param [in] regidx MDIO register index
+*
+* @return
+* 	- value of MDIO register
+* 
+* @ingroup hal_nae
+*
+*/
+static int nae_int_gmac_mdio_read(int node, int bus, int phyaddr, int regidx)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4);
+
+	if (mdio_ld_cmd & INT_MDIO_CTRL_CMD_LOAD) {
+		nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+				       (mdio_ld_cmd & ~INT_MDIO_CTRL_CMD_LOAD));
+	}
+
+	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+			       INT_MDIO_CTRL_SMP
+			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
+			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
+			       | (2 << INT_MDIO_CTRL_OP_POS)
+			       | (1 << INT_MDIO_CTRL_ST_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
+			       | (2 << INT_MDIO_CTRL_TA_POS)
+			       | (2 << INT_MDIO_CTRL_MIIM_POS)
+			       | (0 << INT_MDIO_CTRL_LOAD_POS)
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
+
+	/* Toggle Load Cmd Bit */
+	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+			       INT_MDIO_CTRL_SMP
+			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
+			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
+			       | (2 << INT_MDIO_CTRL_OP_POS)
+			       | (1 << INT_MDIO_CTRL_ST_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
+			       | (2 << INT_MDIO_CTRL_TA_POS)
+			       | (2 << INT_MDIO_CTRL_MIIM_POS)
+			       | (1 << INT_MDIO_CTRL_LOAD_POS) /* */
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
+
+	/* poll master busy bit until it is not busy
+	 */
+	while(nlm_hal_read_mac_reg(node, block, intf_type,
+				    INT_MDIO_RD_STAT + bus * 4) & INT_MDIO_STAT_MBSY);
+
+	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+			       INT_MDIO_CTRL_SMP
+			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
+			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
+			       | (2 << INT_MDIO_CTRL_OP_POS)
+			       | (1 << INT_MDIO_CTRL_ST_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
+			       | (2 << INT_MDIO_CTRL_TA_POS)
+			       | (2 << INT_MDIO_CTRL_MIIM_POS)
+			       | (0 << INT_MDIO_CTRL_LOAD_POS)
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
+
+	/* Read the data back
+	 */
+	return nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_RD_STAT + bus * 4);
+}
+
+/* Internal MDIO WRITE Routines
+ */
+/**
+* @brief nae_int_gmac_mdio_write function is used to write an SGMII PCS register.
+*
+* @param [in] node Node number
+* @param [in] bus Internal MDIO bus number
+* @param [in] phyaddr Internal PHY's address
+* @param [in] regidx MDIO register index
+* @param [in] val Value to write
+*
+* @return
+* 	- 0 on success
+* 
+* @ingroup hal_nae
+*
+*/
+static int nae_int_gmac_mdio_write(int node, int bus, int phyaddr, int regidx, uint16_t val)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4);
+
+	if (mdio_ld_cmd & INT_MDIO_CTRL_CMD_LOAD) {
+		nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+				       (mdio_ld_cmd & ~INT_MDIO_CTRL_CMD_LOAD));
+	}
+
+	/* load data into ctrl data reg
+	 */
+	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL_DATA + bus * 4, val);
+
+	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+			       INT_MDIO_CTRL_SMP
+			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
+			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
+			       | (1 << INT_MDIO_CTRL_OP_POS)
+			       | (1 << INT_MDIO_CTRL_ST_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
+			       | (2 << INT_MDIO_CTRL_TA_POS)
+			       | (1 << INT_MDIO_CTRL_MIIM_POS)
+			       | (0 << INT_MDIO_CTRL_LOAD_POS)
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
+
+	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+			       INT_MDIO_CTRL_SMP
+			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
+			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
+			       | (1 << INT_MDIO_CTRL_OP_POS)
+			       | (1 << INT_MDIO_CTRL_ST_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
+			       | (2 << INT_MDIO_CTRL_TA_POS)
+			       | (1 << INT_MDIO_CTRL_MIIM_POS)
+			       | (1 << INT_MDIO_CTRL_LOAD_POS)
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
+
+	/* poll master busy bit until it is not busy
+	 */
+	while(nlm_hal_read_mac_reg(node, block, intf_type,
+				    INT_MDIO_RD_STAT + bus * 4) & INT_MDIO_STAT_MBSY);
+
+	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+			       INT_MDIO_CTRL_SMP
+			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
+			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
+			       | (1 << INT_MDIO_CTRL_OP_POS)
+			       | (1 << INT_MDIO_CTRL_ST_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
+			       | (2 << INT_MDIO_CTRL_TA_POS)
+			       | (1 << INT_MDIO_CTRL_MIIM_POS)
+			       | (0 << INT_MDIO_CTRL_LOAD_POS)
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
+
+	return 0;
+}
+
+/**
+* @brief internal_nae_gmac_mdio_reset function is used to reset an internal MDIO controller.
+*
+* @param [in] node Node number
+* @param [in] bus Internal MDIO bus number
+*
+* @return
+* 	- 0 on success
+* 
+* @ingroup hal_nae
+*
+*/
+static int internal_nae_gmac_mdio_reset(int node, int bus)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+			       INT_MDIO_CTRL_RST | INT_MDIO_CTRL_SMP |
+			       (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS) 	|
+			       (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
+
+	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
+				INT_MDIO_CTRL_SMP | /* supress pre-amble */
+			       (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS) 	|
+			       (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
+	return 0;
+}
+
+/**********************************************************************
+ *  nae_gmac_mdio_read - Read sgmii phy register
+ *
+ *  Input parameters:
+ *         bus          - bus number, nae has two external gmac bus: 0 and 1
+ *         phyaddr      - PHY's address
+ *         regidx       - index of register to read
+ *
+ *  Return value:
+ *         value read (16 bits), or 0xffffffff if an error occurred.
+ ********************************************************************* */
+/**
+* @brief nae_gmac_mdio_read function is used to read an SGMII PHY register.
+*
+* @param [in] node Node number
+* @param [in] bus External MDIO bus number
+* @param [in] phyaddr External PHY's address
+* @param [in] regidx PHY register index to read
+*
+* @return
+*	- value read (16 bits), or 0xffffffff if an error occurred.
+* 
+* @ingroup hal_nae
+*
+*/
+static int nae_gmac_mdio_read(int node, int bus, int phyaddr, int regidx)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4);
+
+	if (mdio_ld_cmd & EXT_G_MDIO_CMD_LCD) {
+		nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
+				       (mdio_ld_cmd & ~EXT_G_MDIO_CMD_LCD));
+		while(nlm_hal_read_mac_reg(node, block, intf_type,
+					    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
+	}
+
+	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
+			       EXT_G_MDIO_CMD_SP
+			       | (phyaddr << EXT_G_MDIO_PHYADDR_POS)
+			       | (regidx << EXT_G_MDIO_REGADDR_POS)
+			       | (0<<18) | nae_get_EXT_G_MDIO_DIV());
+
+	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
+			       EXT_G_MDIO_CMD_SP
+			       | (phyaddr << EXT_G_MDIO_PHYADDR_POS)
+			       | (regidx << EXT_G_MDIO_REGADDR_POS)
+			       | (1<<18) | nae_get_EXT_G_MDIO_DIV());
+
+	nae_ext_mdio_wait(1);
+
+	while(nlm_hal_read_mac_reg(node, block, intf_type,
+				    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
+
+	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
+			       EXT_G_MDIO_CMD_SP
+			       | (phyaddr << EXT_G_MDIO_PHYADDR_POS)
+			       | (regidx << EXT_G_MDIO_REGADDR_POS)
+			       | (0<<18) | nae_get_EXT_G_MDIO_DIV());
+
+	/* Read the data back */
+	return nlm_hal_read_mac_reg(node, block, intf_type, EXT_G0_MDIO_RD_STAT + bus * 4);
+}
+
+/**********************************************************************
+ *  nae_gmac_mdio_write -Write sgmac mii PHY register.
+ *
+ *  Input parameters:
+ *         bus          - bus number, nae has two external gmac bus: 0 and 1
+ *         phyaddr      - PHY to use
+ *         regidx       - register within the PHY
+ *         val          - data to write to register
+ *
+ *  Return value:
+ *         0 - success
+ ********************************************************************* */
+/**
+* @brief nae_gmac_mdio_write function is used to write an SGMII PHY register.
+*
+* @param [in] node Node number
+* @param [in] bus External MDIO bus number
+* @param [in] phyaddr External PHY's address
+* @param [in] regidx PHY register index to read
+* @param [in] val Value to write
+*
+* @return
+* 	- 0 on success
+* 
+* @ingroup hal_nae
+*
+*/
+static int nae_gmac_mdio_write(int node, int bus, int phyaddr, int regidx, uint16_t val)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4);
+
+	if (mdio_ld_cmd & EXT_G_MDIO_CMD_LCD) {
+		nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
+				       (mdio_ld_cmd & ~EXT_G_MDIO_CMD_LCD));
+		while(nlm_hal_read_mac_reg(node, block, intf_type,
+					    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
+	}
+
+	/* load data into ctrl data reg
+	 */
+	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL_DATA + bus * 4, val);
+
+	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
+			       EXT_G_MDIO_CMD_SP 	|
+			       (phyaddr << EXT_G_MDIO_PHYADDR_POS) 	|
+			       (regidx << EXT_G_MDIO_REGADDR_POS)	|
+			       (0<<18) | nae_get_EXT_G_MDIO_DIV());
+
+	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
+			       EXT_G_MDIO_CMD_LCD | EXT_G_MDIO_CMD_SP 	|
+			       (phyaddr << EXT_G_MDIO_PHYADDR_POS) 	|
+			       (regidx << EXT_G_MDIO_REGADDR_POS)	|
+			       (0<<18) | nae_get_EXT_G_MDIO_DIV());
+
+	nae_ext_mdio_wait(1);
+
+	while(nlm_hal_read_mac_reg(node, block, intf_type,
+				    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
+
+	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
+			       EXT_G_MDIO_CMD_SP 	|
+			       (phyaddr << EXT_G_MDIO_PHYADDR_POS) 	|
+			       (regidx << EXT_G_MDIO_REGADDR_POS)	|
+			       (0<<18) | nae_get_EXT_G_MDIO_DIV());
+
+	return 0;
+}
+
+/**********************************************************************
+ *  external_nae_gmac_mdio_reset -Reset sgmii mdio module.
+ *
+ *  Input parameters:
+ *         bus - bus number, nae has two external gmac bus: 0 and 1
+ *
+ *  Return value:
+ *        0 - success
+ ********************************************************************* */
+/**
+* @brief external_nae_gmac_mdio_reset function is used to reset an external MDIO controller.
+*
+* @param [in] node Node number
+* @param [in] bus External MDIO bus number
+*
+* @return
+* 	- 0 on success
+* 
+* @ingroup hal_nae
+*
+*/
+static int external_nae_gmac_mdio_reset(int node, int bus)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+	/*printf("INTF:%d EXT Gx MDIO DIV:%d\n", intf_type, nae_get_EXT_G_MDIO_DIV()); */
+	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
+			       EXT_G_MDIO_MMRST | nae_get_EXT_G_MDIO_DIV());
+	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
+			       nae_get_EXT_G_MDIO_DIV());
+	return 0;
+}
+
+/**********************************************************************
+ *  external_nae_xgmac_mdio_reset -Reset sgmii mdio module.
+ *
+ *  Input parameters:
+ *         bus - bus number, nae has two external gmac bus: 0 and 1
+ *
+ *  Return value:
+ *        0 - success
+ ********************************************************************* */
+/**
+* @brief external_nae_xgmac_mdio_reset function is used to reset an external MDIO controller.
+*
+* @param [in] node Node number
+* @param [in] bus External MDIO bus number
+*
+* @return
+* 	- 0 on success
+*
+* @ingroup hal_nae
+*
+*/
+static int external_nae_xgmac_mdio_reset(int node, int bus)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
+				 nae_get_EXT_XG_MDIO_DIV()
+                                | EXT_XG_MDIO_CTRL_RST );
+
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
+				 nae_get_EXT_XG_MDIO_DIV()
+                                );
+	return 0;
+}
+
+static int nlm_hal_xgmac_imdio_addr(int node, int phyaddr, int regidx)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+        int32_t i;
+        /* internal xgmac pcs is always 5 */
+        /* phyadd 0x13,0x14, 0x15, 0x16 */
+        int dev_addr = 5;
+
+        /* load  XGMC_MDIO_CTRL_DATA register with addr */
+        nlm_hal_write_mac_reg( node, block, intf_type,
+                                INT_MDIO_CTRL_DATA, regidx);
+
+        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | INT_MDIO_CTRL_CMD_LOAD
+                                | MDIO_MIIM_CMD_10G_MMD << INT_MDIO_CTRL_MIIM_POS
+                                | INT_MDIO_CTRL_TA << INT_MDIO_CTRL_TA_POS
+                                | MDIO_CTRL_OP_INDIRECT_ADDR << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
+
+
+        /* poll master busy bit until it is not busy */
+        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
+
+        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | MDIO_MIIM_CMD_IDLE << INT_MDIO_CTRL_MIIM_POS
+                                | 0x0 << INT_MDIO_CTRL_TA_POS
+                                | MDIO_CTRL_OP_INDIRECT_ADDR << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
+
+
+        /* poll master busy bit until it is not busy */
+        WAIT_XGMAC_IMDIO_BSY_CLEAR(node)
+        return 0;
+}
+
+static int nlm_hal_xgmac_imdio_write(int node, int phyaddr, int regidx, uint16_t val)
+{
+
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+        int32_t  i;
+        /* internal xgmac pcs is always 5 */
+        /* phyadd 0x13,0x14, 0x15, 0x16 */
+        int dev_addr = 5;
+
+         /* first is indirect address cycle */
+        nlm_hal_xgmac_imdio_addr(node, phyaddr, regidx);
+
+        nlm_hal_write_mac_reg( node, block , intf_type,
+                                INT_MDIO_CTRL_DATA, val);
+
+        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | INT_MDIO_CTRL_CMD_LOAD
+                                | MDIO_MIIM_CMD_10G_MMD << INT_MDIO_CTRL_MIIM_POS
+                                | INT_MDIO_CTRL_TA << INT_MDIO_CTRL_TA_POS
+                                | MDIO_CTRL_OP_WRITE_10G_MMD << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
+
+        /* poll master busy bit until it is not busy */
+        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
+
+        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | MDIO_MIIM_CMD_IDLE << INT_MDIO_CTRL_MIIM_POS
+                                | 0x0 << INT_MDIO_CTRL_TA_POS
+                                | 0 << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
+
+
+        /* poll master busy bit until it is not busy */
+        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
+        return 0;
+
+}
+static int nlm_hal_xgmac_imdio_read(int node, int phyaddr, int regidx)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+        int32_t  i;
+        int rdval;
+        /* internal xgmac pcs is always 5 */
+        /* phyadd 0x13,0x14, 0x15, 0x16 */
+        int dev_addr = 5;
+
+         /* first is indirect address cycle */
+        nlm_hal_xgmac_imdio_addr(node, phyaddr, regidx);
+
+        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | INT_MDIO_CTRL_CMD_LOAD
+                                | MDIO_MIIM_CMD_10G_MMD << INT_MDIO_CTRL_MIIM_POS
+                                | INT_MDIO_CTRL_TA << INT_MDIO_CTRL_TA_POS
+                                | MDIO_CTRL_OP_READ_10G_MMD << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
+
+        /* poll master busy bit until it is not busy */
+        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
+
+        rdval =  nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_RD_STAT) & 0xFFFF;
+
+        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | MDIO_MIIM_CMD_IDLE << INT_MDIO_CTRL_MIIM_POS
+                                | 0x0 << INT_MDIO_CTRL_TA_POS
+                                | 0 << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
+
+
+        /* poll master busy bit until it is not busy */
+        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
+
+        return rdval;
+
+}
+
+/**
+* @brief nlm_hal_mdio_read function is used to read a register through MDIO.
+*
+* @param [in] node Node number
+* @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
+* @param [in] bus MDIO bus number
+* @param [in] [To be deleted] block NAE Register Memory Map Block
+* @param [in] [To be deleted] LANE_CFG (only valid for block 7)
+* @param [in] phyaddr PHY's address: devType=Bit[12:8]; phyAddr:=Bit[4:0]
+* @param [in] regidx PHY register index to read
+*
+* @return
+*	- value read (16 bits), or 0xffffffff if an error occurred.
+*	- -1: Invalid type
+* 
+* @ingroup hal_nae
+*
+*/
+int nlm_hal_mdio_wr(int node, int type, int bus, int phyaddr, int regidx, uint16_t val);
+int nlm_hal_mdio_rd(int node, int type, int bus, int phyaddr, int regidx);
+
+int nlm_hal_mdio_rd(int node, int type, int bus, int phyaddr, int regidx)
+{
+	if (type == NLM_HAL_INT_MDIO) {
+		/* INT_MDIO_CTRL: 0x799 */
+		return nae_int_gmac_mdio_read(node, bus, phyaddr&0x1F, regidx);
+	} else if (type == NLM_HAL_INT_MDIO_C45) {
+		/* INT_MDIO_CTRL: 0x799 */
+		return nlm_hal_xgmac_imdio_read(node, phyaddr&0x1F, regidx);
+	} else if (type == NLM_HAL_EXT_MDIO) {
+	        /* 1GE MDIO EXT_G<0,1> : bus0:0x79D, bus1:0x7A1*/
+		return nae_gmac_mdio_read(node, bus, phyaddr&0x1F, regidx);
+	} else if (type == NLM_HAL_EXT_MDIO_C45) {
+	        /* 10GE MDIO EXT_XG<0,1> : bus0:0x7A5, bus1:0x7A9*/
+		return nlm_hal_xgmac_mdio_read(node, bus,
+						(phyaddr&0x1F), (phyaddr>>8)&0x1F, regidx);
+	} else {
+		nlm_print("NAE_ERROR: Invalid type for MDIO read !!\n");
+		return -1;
+	}
+}
+int nlm_hal_mdio_read(int node, int type, int bus, int block, int intf_type,
+		      int phyaddr, int regidx)
+{
+	return nlm_hal_mdio_rd(node, type, bus, phyaddr, regidx);
+}
+
+/**
+* @brief nlm_hal_mdio_write function is used to write a register through MDIO.
+*
+* @param [in] node Node number
+* @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
+* @param [in] bus MDIO bus number
+* @param [in] [To be deleted] block NAE Register Memory Map Block
+* @param [in] [To be deleted] LANE_CFG (only valid for block 7)
+* @param [in] phyaddr PHY's address: devType=Bit[12:8]; phyAddr:=Bit[4:0]
+* @param [in] regidx PHY register index to read
+* @param [in] val Value to write
+*
+* @return
+*	- 0 on success
+*	- -1: Invalid type
+* 
+* @ingroup hal_nae
+*
+*/
+int nlm_hal_mdio_wr(int node, int type, int bus, int phyaddr, int regidx, uint16_t val)
+{
+	if (type == NLM_HAL_INT_MDIO) {
+		/* INT_MDIO_CTRL: 0x799 */
+		return nae_int_gmac_mdio_write(node, bus, phyaddr&0x1F, regidx, val);
+	} else if (type == NLM_HAL_INT_MDIO_C45) {
+		/* INT_MDIO_CTRL: 0x799 */
+		return nlm_hal_xgmac_imdio_write(node, phyaddr&0x1F, regidx, val);
+	} else if (type == NLM_HAL_EXT_MDIO) {
+	        /* 1GE MDIO EXT_G<0,1> : bus0:0x79D, bus1:0x7A1*/
+		return nae_gmac_mdio_write(node, bus, phyaddr&0x1F, regidx, val);
+	} else if (type == NLM_HAL_EXT_MDIO_C45) {
+	        /* 10GE MDIO EXT_XG<0,1> : bus0:0x7A5, bus1:0x7A9*/
+		return nlm_hal_xgmac_mdio_write(node, bus,
+						(phyaddr&0x1F), (phyaddr>>8)&0x1F, regidx, val);
+	} else {
+		nlm_print("NAE_ERROR: Invalid type for MDIO write !!\n");
+		return -1;
+	}
+}
+int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type,
+		       int phyaddr, int regidx, uint16_t val)
+{
+	return nlm_hal_mdio_wr(node, type, bus, phyaddr, regidx, val);
+}
+
+/**
+* @brief nlm_hal_mdio_reset function is used to reset an MDIO controller.
+*
+* @param [in] node Node number
+* @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
+* @param [in] bus MDIO bus number
+*
+* @return
+*	- 0 on success
+*	- -1: Invalid type
+* 
+* @ingroup hal_nae
+*
+*/
+int nlm_hal_mdio_reset(int node, int type, int bus)
+{
+	if ((type == NLM_HAL_INT_MDIO) || (type == NLM_HAL_INT_MDIO_C45)) {
+		return internal_nae_gmac_mdio_reset(node, bus);
+	} else if (type == NLM_HAL_EXT_MDIO) {
+		return external_nae_gmac_mdio_reset(node, bus);
+	} else if (type == NLM_HAL_EXT_MDIO_C45) {
+		return external_nae_xgmac_mdio_reset(node, bus);
+	} else {
+		nlm_print("NAE_ERROR: Invalid type for MDIO reset !!\n");
+		return -1;
+	}
+}
+
+
+
+
+/**
+* @brief nlm_hal_init_poe_ext_storage function is used to initialize the POE memory spaces for message and FreeBuffer storage.
+*
+* @param [in] node Node number
+* @param [in] fbp_base_phys Physical address of the start of FreeBuffer storage in DRAM
+* @param [in] fbp_base_virt Virtual address of the start of FreeBuffer storage in DRAM
+* @param [in] msg_base_phys Physical address of the start of message storage in DRAM
+* @param [in] msg_base_virt Virtual address of the start of message storage in DRAM
+*
+* @return
+* 	- none
+* 
+* @ingroup hal_nae
+*
+*/
+void nlm_hal_init_poe_ext_storage(int node,
+				  uint64_t fbp_base_phys,
+				  uint64_t fbp_base_virt,
+				  uint64_t msg_base_phys,
+	                          uint64_t msg_base_virt)
+{
+	uint32_t addr, num_messages;
+	uint64_t ldata, a, mdata;
+	uint64_t *vaddr_fbp, *vaddr_msg;
+	int i;
+	uint32_t mbase_hi, mbase_lo, fbp_hi, fbp_lo, fbp_sp_init;
+	mbase_hi = (msg_base_phys >> 32) & 0xffffffff;
+	mbase_lo = msg_base_phys & 0xffffffff;
+	fbp_hi = (fbp_base_phys >> 32) & 0xffffffff;
+	fbp_lo = fbp_base_phys & 0xffffffff;
+
+	/* POE External Message Storage (upto 58K) */
+
+	nlm_print("POE ext msg storage: \n");
+	nlm_print("msg base: 0x%x%x\n", mbase_hi, mbase_lo);
+	nlm_print("fbp base: 0x%x%x\n", fbp_hi, fbp_lo);
+
+	/* Free Buffer Pool config */
+	nlm_print (" POE Free Buffer Pool config ...\n");
+
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
+		a = (uint64_t)XLP3XX_EXT_FBP_START_ADDR;
+		num_messages = XLP3XX_MAX_POE_EXT_MSG_STORAGE;
+		fbp_sp_init = XLP3XX_POE_FBP_SP_INIT;
+	}
+	else {
+		a = (uint64_t)EXT_FBP_START_ADDR;
+		num_messages = MAX_POE_EXT_MSG_STORAGE;
+		fbp_sp_init = POE_FBP_SP_INIT;
+	}
+
+	vaddr_fbp = (uint64_t *)(uintptr_t) fbp_base_virt;
+	vaddr_msg = (uint64_t *)(uintptr_t) msg_base_virt;
+	mdata = 0ULL;
+
+	/* initialize free buffer pool with 16-bit storage indexes */
+	for (i = 0; i < (num_messages / 4); i++) {
+		ldata = ((a+3) << 48) | ((a+2) << 32) | ((a+1) << 16) | a;
+		*vaddr_fbp = ldata;
+		vaddr_fbp++;
+		a += 4;
+	}
+
+	/* initialize storage memory area with zero */
+	for (i = 0; i < (num_messages * 8); i++) {
+		*vaddr_msg = mdata;
+		vaddr_msg++;
+	}
+
+	/* Configuring Message base pointer */
+	addr = MSG_STORAGE_BASE_ADR_L;
+	nlm_print ("POE Configuring Message base pointer ...\n");
+	nlm_hal_write_poe_pcie_reg(node, addr, mbase_lo);
+	addr++;
+	nlm_hal_write_poe_pcie_reg(node, addr, mbase_hi);
+
+	/* Configuring FBP base pointer */
+	addr = FBP_BASE_ADR_L;
+	nlm_print ("POE Configuring FBP base pointer ...\n");
+	nlm_hal_write_poe_pcie_reg(node, addr, fbp_lo);
+	addr++;
+	nlm_hal_write_poe_pcie_reg(node, addr, fbp_hi);
+
+	/* Configuring FBP SP */
+	addr = POE_FBP_SP;
+	nlm_print ("POE Configuring FBP stack pointer ...\n");
+	nlm_hal_write_poe_pcie_reg(node, addr, fbp_sp_init);
+}
+
+
+/*
+ *  Interface support
+ */
+
+#define PHY_STATUS_RETRIES 20000
+
+#define WAIT_XGMAC_MDIO_BSY_CLEAR(node)  \
+	for (i = 0; i < PHY_STATUS_RETRIES; i++) {	\
+		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG,	\
+			EXT_XG0_MDIO_RD_STAT + bus * 4 ) & EXT_XG_MDIO_STAT_MBSY) == 0)	\
+                        break;							\
+        }
+
+#define WAIT_XGMAC_IMDIO_BSY_CLEAR(node)   \
+	for (i = 0; i < PHY_STATUS_RETRIES; i++) { \
+		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, \
+			INT_MDIO_RD_STAT) & INT_MDIO_STAT_MBSY) == 0)        \
+                        break;                                                  \
+        }
+
+/*
+ *                   XAUI Support
+ *
+ */
+int nlm_hal_xgmac_mdio_write(int node, int bus,
+	int phyaddr, int dev_addr, int regidx, uint16_t val)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+        int32_t  i;
+	uint32_t ctrl =   (phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS)
+			| (dev_addr << EXT_XG_MDIO_CTRL_REG_POS)
+			| (regidx << EXT_XG_MDIO_CTRL_OP_POS)
+			/* load = 0 */
+			| nae_get_EXT_XG_MDIO_DIV()
+			| (EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS)
+			| (MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS);
+
+	/*nlm_print("xw: bus:%d phy:%d d:%d %x.%x=%x\n", bus, phyaddr, dev_addr, ctrl, regidx, val); */
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL_DATA + (bus * 4), val);
+
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4, ctrl);
+        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
+
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4, ctrl|EXT_XG_MDIO_CTRL_CMD_LOAD);
+        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
+
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4, ctrl);
+        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
+
+        return 0;
+}
+
+int nlm_hal_xgmac_mdio_read(int node, int bus, int phyaddr, int dev_addr, int regidx)
+{
+	int rdval;
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_INDIRECT_ADDR, regidx);
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_READ_10G_MMD, regidx);
+        rdval =  nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_RD_STAT + (bus * 4)) & 0xFFFF;
+        return rdval;
+}
+
+int nlm_hal_c45_mdio_indirect_write_external(int node, int bus,
+	int phyaddr, int dev_addr, uint32_t reg_addr, uint32_t write_data)
+{
+	write_data &= 0xFFFF;
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_INDIRECT_ADDR, reg_addr);
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_WRITE_10G_MMD, write_data);
+	/*nlm_print("C45 MDIO w phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, write_data); */
+	return 0;
+}
+
+int nlm_hal_c45_mdio_indirect_read_external (int node, int bus,
+	int phyaddr, int dev_addr, uint32_t reg_addr)
+{
+	int rdval = nlm_hal_xgmac_mdio_read(node, bus, phyaddr, dev_addr, reg_addr);
+	/*nlm_print("C45 MDIO r phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, rdval); */
+	return rdval;
+}
+
+
+#ifdef CONFIG_N511
+
+/* call for phy/ports 0 - 3 */
+void nlm_xaui_phy_write(int phyaddr, int devaddr, int regidx, uint16_t val)
+{
+  int bus = 0;
+  if ((phyaddr >= 0x13) && (phyaddr <= 0x16)) {
+    nlm_hal_xgmac_imdio_write(0, phyaddr, regidx, val);
+    return;
+  } else if (phyaddr > 1) {
+    bus = 1;
+  }
+  nlm_hal_c45_mdio_indirect_write_external(0, bus, phyaddr, devaddr, regidx, val);
+  return;
+}
+
+uint16_t nlm_xaui_phy_read(int phyaddr, int devaddr, int regidx)
+{
+  int bus = 0;
+  uint16_t val = 0;
+
+  if ((phyaddr >= 0x13) && (phyaddr <= 0x16)) {
+    val = nlm_hal_xgmac_imdio_read(0, phyaddr, regidx);
+    nlm_print("nlm_xaui_phy_read PCS phy with internal mdio = 0x%x\n", val);
+    return val;
+  } else if (phyaddr > 1) {
+    bus = 1;
+  }
+  val = nlm_hal_c45_mdio_indirect_read_external (0, bus, phyaddr, devaddr, regidx);
+  return val;
+}
+
+#include "nlm_10ge_phy_nlp1042.h"
+
+/* MPS add, scan 10ge Phys */
+void nlm_xaui_phy_scan(void)
+{
+  int bus, phyaddr, devid;
+  nlm_print("nlm_xaui_phy_scan, xlp_mac_base = 0x%llux\n", (unsigned long long)xlp_mac_base);
+  bus=0;
+  for (phyaddr=0; phyaddr<2; phyaddr++) {
+    devid = nlm_hal_xgmac_mdio_read(0, bus, phyaddr, 1, 0xC205);
+    nlm_print("\t%d:%x: 0x%02x\n", bus, phyaddr, devid);
+    nlm_nlp1042_init(phyaddr);
+  }
+  bus=1;
+  for (phyaddr=2; phyaddr<4; phyaddr++) {
+    devid = nlm_hal_xgmac_mdio_read(0, bus, phyaddr, 1, 0xC205);
+    nlm_print("\t%d:%x: 0x%02x\n", bus, phyaddr, devid);
+    nlm_nlp1042_init(phyaddr);
+  }
+}
+
+#endif /* CONFIG_N511 */
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/module.h>
+EXPORT_SYMBOL(nlm_hal_mdio_reset);
+EXPORT_SYMBOL(nlm_hal_mdio_read);
+EXPORT_SYMBOL(nlm_hal_mdio_write);
+EXPORT_SYMBOL(nlm_hal_mdio_rd);
+EXPORT_SYMBOL(nlm_hal_mdio_wr);
+EXPORT_SYMBOL(nlm_hal_c45_mdio_indirect_read_external);
+EXPORT_SYMBOL(nlm_hal_c45_mdio_indirect_write_external);
+#endif
diff --git a/arch/mips/netlogic/common/nlm_hal_sys.c b/arch/mips/netlogic/common/nlm_hal_sys.c
new file mode 100644
index 0000000..a4c15c8
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_hal_sys.c
@@ -0,0 +1,1036 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#if !defined(__KERNEL__) && !defined(NLM_HAL_UBOOT)
+#include <stddef.h>
+#endif
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <asm/div64.h>
+#endif
+#include "nlm_hal.h"
+#include "nlm_hal_sys.h"
+#include "nlm_hal_xlp_dev.h"
+
+uint64_t nlm_hal_xlp2xx_get_pllfreq_dyn(int node, uint8_t pll_type);
+uint64_t nlm_hal_xlp2xx_set_pllfreq_dyn(int node, uint8_t pll_type, uint64_t freq);
+uint64_t nlm_hal_xlp2xx_get_pll_out_frq(int node, uint8_t pll_type);
+
+/**
+ * Calculate the DFS divider value for the specified reference clock
+ * and target output frequency.
+ * @param [in] reference the reference clock frequency, in Hz.
+ * @param [in] target the target output frequency, in Hz.
+ * @returns the divider that produces the target frequency
+ * (if the target frequency is within FREQ_RESOLUTION of the actual output).
+ * Otherwise, it will round up to the nearest divider (rounding down to the
+ * the lower output frequency).
+ */
+static uint8_t fuzzy_divider(uint64_t reference, uint64_t target)
+{
+	uint64_t divider = reference;
+	uint64_t freq = reference;
+	uint64_t delta;
+	uint8_t result;
+	NLM_HAL_DO_DIV(divider, target);
+	NLM_HAL_DO_DIV(freq, divider);
+	delta = freq - target;
+	result = (uint8_t)divider;
+	return (delta <= FREQ_RESOLUTION)? result : (result + 1);
+}
+
+
+/**
+ * @returns the numerator for the reference clock frequency.
+ */
+static inline uint64_t ref_clk_num(void)
+{
+	return  (nlm_hal_is_ref_clk_133MHz()) ? REF_CLK_NUM_400 : REF_CLK_NUM_200;
+}
+
+/**
+ * @returns the denominator for the reference clock frequency.
+ */
+static inline uint64_t ref_clk_den(void)
+{
+	return REF_CLK_DEN;
+}
+/**
+ * @returns the current reference clock frequency, in Hz.
+ */
+uint64_t nlm_hal_get_ref_clk_freq(void)
+{
+        uint64_t ref_freq;
+        uint64_t clk_num;
+        uint32_t clk_den;
+
+	if(is_nlm_xlp2xx()) {
+		ref_freq = xlp2xx_get_ref_clk(0, &clk_num, &clk_den);
+	} else {
+		ref_freq = ref_clk_num() / ref_clk_den();
+	}
+	return ref_freq;
+}
+
+/**
+ * Mapping of DFS indices to actual DFS divider values.
+ */
+static uint8_t DFS[] = {1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 15};
+
+/**
+ * @returns the maximum DFS divider value.
+ */
+static inline uint8_t max_dfs_val(void)
+{
+	return DFS[COUNT_OF(DFS) - 1];
+}
+/**
+ * @returns the minimum DFS divider value.
+ */
+static inline uint8_t min_dfs_val(void)
+{
+	return DFS[0];
+}
+
+/**
+ * Get the output frequency for the PLL, based on the
+ * R-divider, F-divider, and PLL DFS divider.
+ * @param [in] divr R-divider for the PLL.
+ * @param [in] divf F-divider for the PLL.
+ * @param [in] pll_dfs PLL DFS divider.
+ * @return PLL frequency, in Hz.
+ */
+static inline uint64_t pll_freq(uint8_t divr, uint8_t divf, uint8_t pll_dfs)
+{
+	uint64_t num = ref_clk_num() * (divf + 1) * 4 / 2;
+	uint64_t den = ref_clk_den() * (divr + 1) * (pll_dfs + 1);
+	NLM_HALT_IF_XLPII();
+	NLM_HAL_DO_DIV(num, den);
+	return num;
+}
+
+/**
+ * Get the DFS index for the DFS value (to be used with the stepping functions).
+ * The DFS value is rounded up (producing the lower output frequency) if
+ * the exact DFS value does not exist.
+  @param [in] dfs DFS divider value.
+ * @return the DFS index greater than or equal to the specified DFS divider value.
+ */
+static inline int8_t closest_dfs_index(uint8_t dfs)
+{
+	int i;
+	NLM_HALT_IF_XLPII();
+	if (dfs > max_dfs_val())
+		return COUNT_OF(DFS)-1;
+
+	for (i = (COUNT_OF(DFS) - 2); i >= 0; i--) {
+		if ((DFS[i+1] >= dfs) && (dfs > DFS[i]))
+			return i+1;
+	}
+
+	return 0;
+}
+
+/**
+ * Determine whether the Core PLL DFS is bypassed.
+ * In XLP8xx-4xx A-stepping, the Core PLL DFS does not exist.
+ * @returns 0 if the Core PLL is not bypassed.
+ * @returns 1 if the Core PLL is bypassed, or if the Core PLL does not exist.
+ */
+static inline uint8_t is_core_pll_dfs_bypassed(int node)
+{
+	NLM_HALT_IF_XLPII();
+	/* no Core PLL DFS on XLP8XX/4XX A-stepping */
+	if (is_nlm_xlp8xx_ax())
+		return 1;
+	return nlm_hal_read_sys_reg(node, PLL_DFS_BYP_CTRL) & 0x1;
+}
+
+/**
+ * Determine whether the SoC PLL DFS is bypassed.
+ * In XLP8xx-4xx A-stepping, the SoC PLL DFS does not exist.
+ * @returns 0 if the SoC PLL is not bypassed.
+ * @returns 1 if the SoC PLL is bypassed, or if the SoC PLL does not exist.
+ */
+static inline uint8_t is_soc_pll_dfs_bypassed(int node)
+{
+	NLM_HALT_IF_XLPII();
+	/* no Core PLL DFS on XLP8XX/4XX A-stepping */
+	if (is_nlm_xlp8xx_ax())
+		return 1;
+	return (nlm_hal_read_sys_reg(node, PLL_DFS_BYP_CTRL) >> 1) & 0x1;
+}
+
+/**
+ * @return the Core PLL DFS divider value, if the chip family supports it.
+ * @return 0 if the Core PLL DFS is not implemented.
+ */
+static inline uint64_t core_pll_dfs_val(int node)
+{
+	NLM_HALT_IF_XLPII();
+	/* no Core PLL DFS on XLP8XX/4XX A-stepping */
+	if (is_nlm_xlp8xx_ax())
+		return 0;
+	if (is_core_pll_dfs_bypassed(node))
+		return 0;
+	return nlm_hal_read_sys_reg(node, PLL_DFS_DIV_VALUE) & 0xf;
+}
+
+/**
+ * @return the SoC PLL DFS divider value, if the chip family supports it.
+ * @return 0 if the SoC PLL DFS is not implemented.
+ */
+static inline uint64_t soc_pll_dfs_val(int node)
+{
+	NLM_HALT_IF_XLPII();
+	/* no SoC PLL DFS on XLP8XX/4XX A-stepping */
+	if (is_nlm_xlp8xx_ax())
+		return 0;
+	if (is_soc_pll_dfs_bypassed(node))
+		return 0;
+	return (nlm_hal_read_sys_reg(node, PLL_DFS_DIV_VALUE) >> 4) & 0xf;
+}
+
+/**
+ * Get the Core PLL frequency post PLL DFS.
+ */
+static inline uint64_t core_pll_freq(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, POWER_ON_RESET_CFG);
+	uint8_t divr = (reg >> 8)  & 0x3;
+	uint8_t divf = (reg >> 10) & 0x7f;
+	NLM_HALT_IF_XLPII();
+	return pll_freq(divr, divf, core_pll_dfs_val(node));
+}
+
+/**
+ * Get the SoC PLL frequency post PLL DFS.
+ */
+static inline uint64_t soc_pll_freq(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, PLL_CTRL);
+	uint8_t divf = (reg >> 3) & 0x7F;
+	uint8_t divr = (reg >> 1) & 0x3;
+	NLM_HALT_IF_XLPII();
+	return pll_freq(divr, divf, soc_pll_dfs_val(node));
+}
+
+/**
+ * Get the DDR PLL frequency.
+ */
+static inline uint64_t ddr_pll_freq(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, PLL_CTRL);
+	uint8_t divf = (reg >> 19) & 0x7F;
+	uint8_t divr = (reg >> 17) & 0x3;
+	NLM_HALT_IF_XLPII();
+	return pll_freq(divr, divf, 0);
+}
+
+/**
+ * Get the DFS divider value for the specified SoC device.
+ * @param [in] device the SoC device.
+ */
+static inline uint64_t soc_dfs_val(int node, soc_device_id_t device)
+{
+	uint8_t device_index = device;
+	NLM_HALT_IF_XLPII();
+	if (device_index >= 8)
+	{
+		device_index -= 8;
+		return (nlm_hal_read_sys_reg(node, SYS_DFS_DIV_VALUE1) >> (device_index * 4)) & 0xF;
+	}
+	return (nlm_hal_read_sys_reg(node, SYS_DFS_DIV_VALUE0) >> (device_index * 4)) & 0xF;
+}
+
+/**
+ * Get the DFS divider value for the specified Core.
+ * @param [in] core CPU core index.
+ */
+static inline uint64_t core_dfs_val(int node, uint8_t core)
+{
+	NLM_HALT_IF_XLPII();
+	return (nlm_hal_read_sys_reg(node, CORE_DFS_DIV_VALUE) >> (core * 4)) & 0xF; 
+}
+
+/**
+ * Determine whether the SoC device's DFS is bypassed.
+ * @param [in] device the SoC device.
+ * @returns 1 if the SoC device's DFS is bypassed.
+ * @returns 0 if the SoC device's DFS is not bypassed.
+ */
+static inline uint8_t is_soc_dfs_bypassed(int node, soc_device_id_t device)
+{
+	uint8_t device_index = device;
+	NLM_HALT_IF_XLPII();
+	return (nlm_hal_read_sys_reg(node, SYS_DFS_BYP_CTRL) >> device_index) & 1;
+}
+
+/**
+ * Enable/disable the DFS bypass for the specified SoC device.
+ * @param [in] device the SoC device.
+ * @param [in] bypass 1: bypass the DFS. 0: do not bypass DFS.
+ */
+static inline void set_soc_dfs_bypass(int node, soc_device_id_t device, uint8_t bypass)
+{
+	uint8_t device_index = device;
+	uint32_t val;
+	NLM_HALT_IF_XLPII();
+	val = nlm_hal_read_sys_reg(node, SYS_DFS_BYP_CTRL) & ~(1 << device_index);
+	nlm_hal_write_sys_reg(node, SYS_DFS_BYP_CTRL, val | ((bypass? 0x1 : 0x0) << device_index));
+}
+
+/**
+ * Determine whether the CPU core's DFS is bypassed.
+ * @param [in] core CPU core index.
+ * @returns 1 if the CPU core's DFS is bypassed.
+ * @returns 0 if the CPU core's DFS is not bypassed.
+ */
+static inline uint8_t is_core_dfs_bypassed(int node, uint8_t core)
+{
+	NLM_HALT_IF_XLPII();
+	return (nlm_hal_read_sys_reg(node, CORE_DFS_BYP_CTRL) >> core) & 1;
+}
+
+/**
+ * Enable/disable the DFS bypass for the specified CPU core.
+ * @param [in] core CPU core index.
+ * @param [in] bypass 1: bypass the DFS. 0: do not bypass DFS.
+ */
+static inline void set_core_dfs_bypass(int node, uint8_t core, uint8_t bypass)
+{
+	uint32_t val;
+	NLM_HALT_IF_XLPII();
+	val = nlm_hal_read_sys_reg(node, CORE_DFS_BYP_CTRL) & ~(1 << core);
+	nlm_hal_write_sys_reg(node, CORE_DFS_BYP_CTRL, val | ((bypass? 0x1 : 0x0) << core));
+}
+
+/**
+ * Get the operating frequency for the specified CPU core.
+ * @param [in] device the SoC device.
+ * @returns The SoC device operating frequency, in Hz.
+ */
+uint64_t nlm_hal_get_soc_freq(int node, soc_device_id_t device)
+{
+	uint64_t freq, den;
+
+	if(is_nlm_xlp2xx()) {
+		freq = nlm_hal_xlp2xx_get_clkdev_frq(node, device);
+		return freq;
+	}
+
+	switch (device) {
+		case DFS_DEVICE_NAND:
+		case DFS_DEVICE_NOR:
+		case DFS_DEVICE_MMC:
+			/* NOR, NAND and MMC devices are derived from the freq clock. */
+			freq = nlm_hal_get_ref_clk_freq();
+			break;
+		case DFS_DEVICE_DMC:
+			freq = ddr_pll_freq(node);
+			break;
+		case DFS_DEVICE_CORE:
+			/* The Core DFS is derived from the Core PLL */
+			freq = core_pll_freq(node);
+			break;
+		default:
+			freq = soc_pll_freq(node);
+			break;
+	}
+
+	den = soc_dfs_val(node, device) + 1;
+	if (!is_soc_dfs_bypassed(node, device)) {
+		NLM_HAL_DO_DIV(freq, den);
+	}
+	return freq;
+}
+
+/**
+ * Step the DFS of the specified SoC device to the target DFS index.
+ * @param [in] device the SoC device.
+ * @param [in] dfs_index DFS index (**not** the DFS value).
+ */
+static void step_soc_dfs(int node, soc_device_id_t device, uint8_t dfs_index)
+{
+	uint8_t device_index;
+	uint8_t cur;
+	int8_t delta, i;
+
+	NLM_HALT_IF_XLPII();
+	device_index = device;
+	cur = closest_dfs_index(soc_dfs_val(node, device));
+	delta = cur - dfs_index;
+
+	if (delta >= 0) {
+		/* positive delta, decrement dfs */
+		for (i=0; i < delta; i++)
+			nlm_hal_write_sys_reg(node, SYS_DFS_DIV_DEC_CTRL, 1 << device_index);
+	} else {
+		/* negative delta, increment dfs */
+		for (i=0; i > delta; i--)
+			nlm_hal_write_sys_reg(node, SYS_DFS_DIV_INC_CTRL, 1 << device_index);
+	}
+}
+
+/**
+ * Set the operating frequency for the specified SoC device.
+ * This is achieved only by stepping the SoC device DFS.
+ * @param [in] device the SoC device.
+ * @param [in] freq target SoC device frequency, in Hz.
+ * @returns the new SoC device operating frequency, in Hz.
+ */
+uint64_t nlm_hal_set_soc_freq(int node, soc_device_id_t device, uint64_t freq)
+{
+	uint64_t reference;
+	uint8_t  target;
+
+	if(is_nlm_xlp2xx()) {
+		return nlm_hal_xlp2xx_set_clkdev_frq(node, device, freq);
+	}
+	switch (device) {
+		case DFS_DEVICE_NAND:
+		case DFS_DEVICE_NOR:
+		case DFS_DEVICE_MMC:
+			/* NOR, NAND and MMC devices are derived from the reference clock. */
+			reference = nlm_hal_get_ref_clk_freq();
+			break;
+		case DFS_DEVICE_DMC:
+			reference = ddr_pll_freq(node);
+			break;
+		case DFS_DEVICE_CORE:
+			/* The Core DFS is derived from the Core PLL */
+			reference = core_pll_freq(node);
+			break;
+		default:
+			reference = soc_pll_freq(node);
+			break;
+	}
+
+	target = closest_dfs_index(fuzzy_divider(reference, freq) - 1);
+	if (freq >= (reference - FREQ_RESOLUTION)) {
+		/* bypass DFS if freq is reference freq */
+		set_soc_dfs_bypass(node, device, 1);
+	} else {
+		/* otherwise, step dfs and clear bypass */
+		step_soc_dfs(node, device, target);
+		set_soc_dfs_bypass(node, device, 0);
+	}
+
+	return nlm_hal_get_soc_freq(node, device);
+}
+
+/**
+ * Get the operating frequency for the specified CPU core.
+ * @param [in] core CPU core index.
+ * @returns The CPU core operating frequency, in Hz.
+ */
+uint64_t nlm_hal_get_core_freq(int node, uint8_t core)
+{
+	if(is_nlm_xlp2xx()) {
+		return nlm_hal_xlp2xx_get_pllfreq_dyn(node, core);
+	}
+	else {
+		uint64_t den, reference = core_pll_freq(node);
+		den = core_dfs_val(node, core) + 1;
+		if (!is_core_dfs_bypassed(node, core))
+		    NLM_HAL_DO_DIV(reference, den);
+		return reference;
+	}
+}
+
+/**
+ * Step the DFS of the specified CPU core to the target DFS index.
+ * @param [in] core CPU core index.
+ * @param [in] dfs_index DFS index (**not** the DFS value).
+ */
+static void step_core_dfs(int node, uint8_t core, uint8_t dfs_index)
+{
+	uint8_t cur;
+	int8_t delta;
+	int i;
+
+	NLM_HALT_IF_XLPII();
+	cur = closest_dfs_index(core_dfs_val(node, core));
+	delta = cur - dfs_index;
+
+	if (delta >= 0) {
+		/* positive delta, decrement dfs */
+		for (i=0; i < delta; i++)
+			nlm_hal_write_sys_reg(node, CORE_DFS_DIV_DEC_CTRL, 1 << core);
+	} else {
+		/* negative delta, increment dfs */
+		for (i=0; i > delta; i--)
+			nlm_hal_write_sys_reg(node, CORE_DFS_DIV_INC_CTRL, 1 << core);
+	}
+}
+
+/**
+ * Set the operating frequency for the specified CPU core.
+ * This is achieved only by stepping the Core DFS.
+ * @param [in] core CPU core index.
+ * @param [in] freq target CPU core frequency, in Hz.
+ * @returns the new CPU core operating frequency, in Hz.
+ */
+uint64_t nlm_hal_set_core_freq(int node, uint8_t core, uint64_t freq)
+{
+	if(is_nlm_xlp2xx()) {
+		return nlm_hal_xlp2xx_set_pllfreq_dyn(node, core, freq);
+	}
+	else {
+		uint64_t reference = core_pll_freq(node);
+		uint8_t target = closest_dfs_index(fuzzy_divider(reference, freq) - 1);
+
+		if (freq >= (reference - FREQ_RESOLUTION)) {
+			/* bypass DFS if freq is reference freq */
+			set_core_dfs_bypass(node, core, 1);
+		} else {
+			/* otherwise, step dfs and clear bypass */
+			step_core_dfs(node, core, target);
+			set_core_dfs_bypass(node, core, 0);
+		}
+		return nlm_hal_get_core_freq(node, core);
+	}
+}
+
+/**
+ * Get the operating frequency for the current core.
+ * @returns The core operating frequency (in Hz).
+ */
+unsigned long long nlm_hal_cpu_freq(void)  
+{
+	uint8_t core = (nlm_cpu_id() >> 2) & 0x7;
+	return nlm_hal_get_core_freq(nlm_node_id(), core);
+}
+
+uint32_t nlm_hal_get_biu_mask_by_soc_device_id(soc_device_id_t device)
+{
+	int biu_mask=0;
+	switch(device) {
+        case XLP2XX_CLKDEVICE_NAE    : biu_mask =
+		 (1<<XLP2XX_IO_NET_BIU_NUMBER)|(1<<XLP2XX_IO_MSG_BIU_NUMBER)|(1<<XLP2XX_IO_POE_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_SAE    : biu_mask = (1<<XLP2XX_IO_SEC_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_RSA    : biu_mask = (1<<XLP2XX_IO_RSA_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_GDX    : biu_mask = (1<<XLP2XX_IO_GDX_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_CMP    : biu_mask = (1<<XLP2XX_IO_CMP_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_NAND   : biu_mask = (1<<XLP2XX_IO_GBU_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_MMC    : biu_mask = (1<<XLP2XX_IO_GBU_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_GBU    : biu_mask = (1<<XLP2XX_IO_GBU_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_RGXF   : biu_mask = (1<<XLP2XX_IO_REGX_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_RGXS   : biu_mask = (1<<XLP2XX_IO_REGX_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_USB    : biu_mask = (1<<XLP2XX_IO_USB_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_PIC    : biu_mask = (1<<XLP2XX_IO_PIC_BIU_NUMBER); break;
+		default: break;
+	}
+	return biu_mask;
+}
+
+uint8_t nlm_hal_get_soc_clock_state(int node, soc_device_id_t device)
+{
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		return (nlm_hal_read_sys_reg(node, XLP2XX_SYSDISABLE) & biu_mask) ?  XLP_DISABLE : XLP_ENABLE;
+	} else {
+		return (nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL) >> device);
+	}
+}
+
+void nlm_hal_soc_clock_enable(int node, soc_device_id_t device)
+{
+	uint32_t d32;
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		biu_mask = (nlm_hal_read_sys_reg(node, XLP2XX_SYSDISABLE) & ~biu_mask);
+		nlm_hal_write_sys_reg(node, XLP2XX_SYSDISABLE, biu_mask);
+	} else {
+		d32 = nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL);
+		d32 &= ~(1<<device);
+		nlm_hal_write_sys_reg(node, SYS_DFS_DIS_CTRL, d32);
+	}
+}
+
+void nlm_hal_soc_clock_disable(int node, soc_device_id_t device)
+{
+	uint32_t d32;
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		biu_mask |= nlm_hal_read_sys_reg(node, XLP2XX_SYSDISABLE);
+		nlm_hal_write_sys_reg(node, XLP2XX_SYSDISABLE, biu_mask);
+	} else {
+		d32 = nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL);
+		d32 |= (1<<device);
+		nlm_hal_write_sys_reg(node, SYS_DFS_DIS_CTRL, d32);
+	}
+}
+
+void nlm_hal_soc_clock_reset(int node, soc_device_id_t device)
+{
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		nlm_hal_write_sys_reg(node, XLP2XX_SYSRESET, biu_mask);
+	} else {
+		nlm_hal_write_sys_reg(node, SYS_DFS_RST_CTRL, 1 << device);
+	}
+}
+
+/*
+ * XLP 2XX Clock Management
+ */
+/*  Reference Clock Select 00:66; 01:100; 10:125; 11:133 */
+#define SYS_PWRON_RCS(x) (((x)>>18) & 0x3)
+
+#define SYS_PWRON_PLF(x) (((x)>>17) & 0x1)
+
+static int xlp2xx_get_plf(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, XLP2XX_POWER_ON_RESET_CFG);
+	int plf = SYS_PWRON_PLF(reg);
+	return plf;
+}
+
+static int xlp2xx_get_rcs(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, XLP2XX_POWER_ON_RESET_CFG);
+	int rcs = SYS_PWRON_RCS(reg);
+	return rcs;
+}
+
+static void nlm_hal_xlp2xx_dev_pll_cfg(int node, soc_device_id_t dev_type, int dev_pll_sel, int div)
+{
+	int dev_idx = dev_type - XLP2XX_CLKDEVICE_NAE;
+	uint32_t rsel, rdiv, rchg;
+	NLM_HALT_IF(dev_idx<0);
+	rsel = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL_REG) & (~(3<<(dev_idx*2)));
+	rdiv = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV_REG) & (~(3<<(dev_idx*2)));
+	nlm_hal_write_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL, rsel | ((dev_pll_sel&3) << (dev_idx*2)));
+	nlm_hal_write_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV, rdiv | ((div&3)<<(dev_idx*2)));
+	rsel = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL_REG);
+	rdiv = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV_REG);
+	rchg = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_CHG);
+	nlm_hal_write_sys_reg(node, XLP2XX_SYS_CLK_DEV_CHG, rchg|(1<<dev_idx));
+	while((nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_CHG) & (1<<dev_idx)));
+	return;
+}
+
+/*
+ * SYS_CLK_DEV_SEL
+ *  00  400MHz
+ *  01  Dev0 PLL
+ *  10  Dev1 PLL
+ *  11  Dev2 PLL
+ */
+static inline xlp2xx_clkdev_sel_t xlp2xx_get_clk_dev_sel(int node, soc_device_id_t dev_type)
+{
+	int dev_idx = dev_type - XLP2XX_CLKDEVICE_NAE;
+	NLM_HALT_IF(dev_idx<0);
+	return ( nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL_REG) >> (dev_idx*2) ) & 0x3 ;
+}	
+
+/*
+ * SYS_CLK_DEV_DIV
+ * 00  1
+ * 01  2
+ * 10  4
+ * 11  8
+ */
+static inline uint8_t xlp2xx_get_clkdev_div(int node, soc_device_id_t dev_type)
+{
+	int dev_idx = dev_type - XLP2XX_CLKDEVICE_NAE;
+	NLM_HALT_IF(dev_idx<0);
+	return  1<< (( nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV_REG) >> (dev_idx*2) ) & 0x3);
+}	
+
+uint64_t nlm_hal_xlp2xx_get_pllfreq_dyn(int node, uint8_t pll_type)
+{
+        uint32_t pll_mult = 0; /* [5:0] */
+        uint64_t ref_clk_num;
+	uint32_t ref_clk_den;
+        uint32_t reg_ctrl;
+	int plf = xlp2xx_get_plf(node)+1;
+        switch(pll_type)
+        {
+                case CORE0_PLL:
+                case CORE1_PLL:
+                        reg_ctrl = XLP2XX_CORE0_PLL_CTRL1+pll_type*4;
+                break;
+                case SYS_PLL:
+                case DMC_PLL:
+                case DEV0_PLL:
+                case DEV1_PLL:
+                case DEV2_PLL:
+                        reg_ctrl = XLP2XX_SYS_PLL_CTRL1+(pll_type-SYS_PLL)*4;
+                break;
+                default:
+                        nlm_print("Unknown PLL type:%d\n", pll_type);
+                        return 0;
+        }
+        pll_mult = nlm_hal_read_sys_reg(node, reg_ctrl) & (0x3f);
+        ref_clk_num =  (REF_CLK_NUM_100 * pll_mult);
+        ref_clk_den = REF_CLK_DEN;
+        NLM_HAL_DO_DIV(ref_clk_num, ref_clk_den);
+        ref_clk_num +=  REF_CLK_NUM_400;
+
+        if(pll_type != DMC_PLL) {
+		NLM_HAL_DO_DIV(ref_clk_num, plf);
+	}
+
+        return ref_clk_num;
+}
+
+uint64_t nlm_hal_xlp2xx_set_pllfreq_dyn(int node, uint8_t pll_type, uint64_t freq)
+{
+        /*Target PLL output frequency; 400 MHz + (33.333 MHz x [5:0]).*/
+	uint32_t pll_mult = 0; /* [5:0] */
+	uint64_t clk_base_freq_num = 100*1000000;
+	uint32_t clk_base_freq_den = 3;
+	uint32_t reg_ctrl,reg_chg,chg_mask;
+	int plf = xlp2xx_get_plf(node)+1;
+
+	if(pll_type!=DMC_PLL)
+		freq*=plf;
+
+	if(freq<400*1000000){
+	        nlm_print("Freq for PLL cant be less than 400 Mhz\n");
+	        return 0;
+	}
+	freq = clk_base_freq_den * (freq - 400*1000000);
+	NLM_HAL_DO_DIV(freq, clk_base_freq_num);
+	pll_mult = freq;
+        switch(pll_type)
+        {
+                case CORE0_PLL:
+                case CORE1_PLL:
+                        reg_ctrl = XLP2XX_CORE0_PLL_CTRL1+pll_type*4;
+                        reg_chg  = XLP2XX_CPU_PLL_CHG_CTRL;
+                        chg_mask = 1<<(pll_type-CORE0_PLL);
+                break;
+                case SYS_PLL:
+                case DMC_PLL:
+                case DEV0_PLL:
+                case DEV1_PLL:
+                case DEV2_PLL:
+                        reg_ctrl = XLP2XX_SYS_PLL_CTRL1+(pll_type-SYS_PLL)*4;
+                        reg_chg  = XLP2XX_SYS_PLL_CHG_CTRL;
+                        chg_mask = 1<<(pll_type-SYS_PLL);
+                break;
+                default:
+                        nlm_print("Unknown PLL type:%d\n", pll_type);
+                        return 0;
+        }
+
+        nlm_hal_write_sys_reg(node, reg_ctrl, pll_mult);
+        nlm_hal_write_sys_reg(node, reg_chg,  chg_mask);
+        while(nlm_hal_read_sys_reg(node, reg_chg) & chg_mask);
+
+	/*freq = nlm_hal_xlp2xx_get_pll_out_frq(node, pll_type); */
+	/*nlm_print("pll out freq:%dMHz\n", (uint32_t)freq/1000000); */
+
+	freq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, pll_type);
+	return freq;
+}
+
+uint64_t xlp2xx_get_ref_clk(int node, uint64_t* ref_clk_num, uint32_t* ref_clk_den)
+{
+	uint64_t frq_num;
+	uint32_t frq_den;
+	uint32_t rcs = xlp2xx_get_rcs(node);
+	switch(rcs) {
+		case 0x0:
+			frq_num = REF_CLK_NUM_200;
+			frq_den = REF_CLK_DEN3;
+		break;	
+		case 0x1:
+			frq_num = REF_CLK_NUM_100;
+			frq_den = REF_CLK_DEN1;
+		break;	
+		case 0x2:
+			frq_num = REF_CLK_NUM_125;
+			frq_den = REF_CLK_DEN1;
+		break;	
+		case 0x3:
+		default:
+			frq_num = REF_CLK_NUM_400;
+			frq_den = REF_CLK_DEN3;
+		break;	
+	}
+	*ref_clk_num = frq_num;
+	*ref_clk_den = frq_den;
+	NLM_HAL_DO_DIV(frq_num, frq_den);
+	return frq_num;	
+}
+
+/* freq_out = ( ref_freq/2 * (6 + ctrl2[7:0]) + ctrl2[20:8]/2^13 ) / ((2^ctrl0[7:5]) * Table(ctrl0[26:24]))
+ * Table.ctrl0[26:24]
+ * ------------------
+ *  0: 1
+ *  1: 2
+ *  3: 4
+ *  7: 8
+ *  6: 16
+ */
+uint64_t nlm_hal_xlp2xx_get_pll_out_frq(int node, uint8_t pll_type)
+{
+	uint32_t vco_po_div, pll_post_div, mdiv;
+	uint64_t ref_frq_num, pll_out_freq_num, two13, fdiv;
+	uint32_t ref_frq_den, pll_out_freq_den;
+        uint32_t reg_ctrl0, reg_ctrl2;
+        uint32_t ctrl0, ctrl2;
+	
+        switch(pll_type)
+        {
+                case CORE0_PLL:
+                case CORE1_PLL:
+                        reg_ctrl0 = XLP2XX_CORE0_PLL_CTRL0+pll_type*4;
+                        reg_ctrl2 = XLP2XX_CORE0_PLL_CTRL2+pll_type*4;
+                break;
+                case SYS_PLL:
+                case DMC_PLL:
+                case DEV0_PLL:
+                case DEV1_PLL:
+                case DEV2_PLL:
+                        reg_ctrl0 = XLP2XX_SYS_PLL_CTRL0+(pll_type-SYS_PLL)*4;
+                        reg_ctrl2 = XLP2XX_SYS_PLL_CTRL2+(pll_type-SYS_PLL)*4;
+                break;
+                default:
+                        nlm_print("Unknown PLL type:%d\n", pll_type);
+                        return 0;
+        }
+
+	xlp2xx_get_ref_clk(node, &ref_frq_num, &ref_frq_den);
+	ctrl0 = nlm_hal_read_sys_reg(node, reg_ctrl0);
+	ctrl2 = nlm_hal_read_sys_reg(node, reg_ctrl2);
+
+	vco_po_div = (ctrl0>>5) & 0x7;
+	pll_post_div = (ctrl0>>24) & 0x7;
+	mdiv = ctrl2 & 0xff;
+	fdiv = (ctrl2>>8) & 0xfff;
+
+	switch(pll_post_div) {
+	    case 1: pll_post_div=2; break;
+	    case 3: pll_post_div=4; break;
+	    case 7: pll_post_div=8; break;
+	    case 6: pll_post_div=16; break;
+	    case 0:
+	    default: 
+		    pll_post_div=1;
+		    break;
+	}
+
+	two13 = 1<<13;
+	NLM_HAL_DO_DIV(fdiv, two13);
+	pll_out_freq_num = ((ref_frq_num>>1) * (6 + mdiv) ) + fdiv;
+	pll_out_freq_den = (1<<vco_po_div) * pll_post_div * ref_frq_den;
+
+	if(pll_out_freq_den>0) {
+		NLM_HAL_DO_DIV(pll_out_freq_num, pll_out_freq_den);
+	}
+	return pll_out_freq_num;
+}
+
+uint64_t nlm_hal_xlp2xx_get_clkdev_frq(int node, soc_device_id_t dev_type)
+{
+	uint64_t frq = 0, ref_clk_num;
+	uint32_t ref_clk_den;
+	uint8_t div = xlp2xx_get_clkdev_div(node, dev_type);
+	xlp2xx_clkdev_sel_t pll_sel = xlp2xx_get_clk_dev_sel(node, dev_type);
+
+	switch(pll_sel)
+	{
+		case SEL_REF_CLK:
+			frq = xlp2xx_get_ref_clk(node, &ref_clk_num, &ref_clk_den);
+		break;
+		case SEL_DEV0PLL:
+			frq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, DEV0_PLL);
+		break;
+		case SEL_DEV1PLL:
+			frq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, DEV1_PLL);
+		break;
+		case SEL_DEV2PLL:
+			frq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, DEV2_PLL);
+		break;
+		default:
+		break;
+	}
+	NLM_HAL_DO_DIV(frq, div);
+	return frq;
+}
+
+uint64_t nlm_hal_xlp2xx_set_clkdev_frq(int node, soc_device_id_t dev_type, uint64_t new_frq)
+{
+	uint64_t frq;
+	uint8_t new_div, div;
+	xlp2xx_clkdev_sel_t pll_sel;
+
+	pll_sel = xlp2xx_get_clk_dev_sel(node, dev_type);
+	div = xlp2xx_get_clkdev_div(node, dev_type);
+	frq = nlm_hal_xlp2xx_get_clkdev_frq(node, dev_type);
+
+	/* new_frq*new_div=frq*div
+	 *  new_div = frq*div/new_frq;
+	 */
+	new_div = fuzzy_divider(frq*div, new_frq);
+	switch (new_div)
+	{
+		case 1:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_BYPASS);
+		break;
+		case 2:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV2);
+		break;
+		case 4:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV4);
+		break;
+		case 8:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV8);
+		break;
+		default:
+		break;
+	}
+	frq = nlm_hal_xlp2xx_get_clkdev_frq(node, dev_type);
+	return frq;
+}
+
+/**
+ * @returns true if reference clock is 133MHz
+ */
+int nlm_hal_is_ref_clk_133MHz(void)
+{
+	if(is_nlm_xlp2xx())
+		return 3 == xlp2xx_get_rcs(0);
+	else {
+		uint32_t reg = nlm_hal_read_sys_reg(0, POWER_ON_RESET_CFG);
+		uint8_t divr = (reg >> 8) & 0x3;
+		return  (divr==3);
+	}
+}
+
+const char* nlm_hal_xlp2xx_get_dev_name(soc_device_id_t dev) {
+	static char* name[] = {
+	"NAE",
+	"SAE",
+	"RSA",
+	"GDX",
+	"CMP",
+	"NAND",
+	"MMC",
+	"GBU",
+	"RGXF",
+	"RGXS",
+	"USB",
+	"PIC",
+	"NULL"
+	};
+	if(! ((dev>=XLP2XX_CLKDEVICE_NAE)&&(dev<=XLP2XX_CLKDEVICE_PIC)))
+	{
+		dev = XLP2XX_CLKDEVICE_NULL;
+	}
+	return name[dev-XLP2XX_CLKDEVICE_NAE];
+}
+
+
+xlp2xx_soc_freq_s xlp2xx_tbl_freq[2] = {
+	/* slow freq for low voltage*/
+      { .nae = 250,
+	.sae = 250,
+	.rsa = 250,
+	.gdx = 333,
+	.cmp = 333,
+	.nand = 133,
+	.mmc = 133,
+	.gbu = 133,
+	.rgxf = 250,
+	.rgxs = 200,
+	.usb = 167,
+	.pic = 200 },
+	/* high freq */
+      { .nae = 500,
+	.sae = 500,
+	.rsa = 500,
+	.gdx = 667,
+	.cmp = 667,
+	.nand = 133,
+	.mmc = 133,
+	.gbu = 133,
+	.rgxf = 500,
+	.rgxs = 450,
+	.usb = 167,
+	.pic = 400 },
+};
+
+void nlm_hal_adjust_soc_freqs(int node, int freq_sel)
+{
+	if(is_nlm_xlp2xx()) {
+	xlp2xx_soc_freq_s* freq;
+	freq = &xlp2xx_tbl_freq[freq_sel&0x1];
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_NAE, freq->nae*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_SAE, freq->sae*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_RSA, freq->rsa*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_GDX, freq->gdx*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_CMP, freq->cmp*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_NAND, freq->nand*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_MMC, freq->mmc*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_GBU, freq->gbu*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_RGXF, freq->rgxf*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_RGXS, freq->rgxs*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_USB, freq->usb*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_PIC, freq->pic*1000000);
+	}
+}
+
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/module.h>
+EXPORT_SYMBOL(nlm_hal_get_soc_clock_state);
+EXPORT_SYMBOL(nlm_hal_soc_clock_enable);
+EXPORT_SYMBOL(nlm_hal_soc_clock_disable);
+EXPORT_SYMBOL(nlm_hal_soc_clock_reset);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_set_clkdev_frq);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_get_clkdev_frq);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_get_pll_out_frq);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_get_dev_name);
+EXPORT_SYMBOL(nlm_hal_get_soc_freq);
+EXPORT_SYMBOL(nlm_hal_set_soc_freq);
+EXPORT_SYMBOL(nlm_hal_get_core_freq);
+EXPORT_SYMBOL(nlm_hal_set_core_freq);
+EXPORT_SYMBOL(nlm_hal_cpu_freq);
+EXPORT_SYMBOL(nlm_hal_is_ref_clk_133MHz);
+EXPORT_SYMBOL(nlm_hal_get_ref_clk_freq);
+EXPORT_SYMBOL(nlm_hal_adjust_soc_freqs);
+
+#endif
diff --git a/arch/mips/netlogic/xlp/bootinfo.c b/arch/mips/netlogic/xlp/bootinfo.c
index 673d86c..42a100c 100644
--- a/arch/mips/netlogic/xlp/bootinfo.c
+++ b/arch/mips/netlogic/xlp/bootinfo.c
@@ -5,6 +5,8 @@
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/bootinfo.h>
 
+struct psb_info prom_info_copy; /* Bootloader prom_info is saved here */
+
 static int is_valid_prominfo(struct psb_info *info)
 {
 	if (!prom_info) 
diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index 9d44587..1561c19 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -28,6 +28,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/bootmem.h>
 #include <linux/init.h>
 #include <linux/pm.h>
+#include <linux/export.h>
 
 #include <asm/asm.h>
 #include <asm/irq.h>
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index d9392207..8d7b74a 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -32,9 +32,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/slab.h>
 #include <linux/pci.h>
 #include <linux/msi.h>
+#include <linux/export.h>
 #include <asm/errno.h>
 #include <asm/signal.h>
-#include <asm/system.h>
 #include <asm/ptrace.h>
 #include <asm/kgdb.h>
 #include <asm/mipsregs.h>
@@ -597,7 +597,7 @@ static void xlp_pic_unmask(struct irq_data *d)
  * When an interrupt is started, we force it to be enabled only in cpu0, it can
  * be changed later by calling nlm_irq_set_affinity()
  */
-static unsigned int nlm_irq_startup(struct irq_data *d)
+static void nlm_irq_startup(struct irq_data *d)
 {
 	__label__ __failure;
 	unsigned int irq = d->irq;
@@ -610,9 +610,9 @@ static unsigned int nlm_irq_startup(struct irq_data *d)
 	cpumask_clear(&m);
 	cpumask_set_cpu(0, &m);
 	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
-		return 0;
+		return;
 	} else if(irq >= XLP_IRQ_MAX) {
-		return 0;
+		return;
 	}
 	n = xlp_closest_match_cpumask(&m);
 	spin_lock_irqsave(&xlp_pic_lock, flags);
@@ -648,7 +648,7 @@ static unsigned int nlm_irq_startup(struct irq_data *d)
 	}
 __failure:
 	spin_unlock_irqrestore(&xlp_pic_lock, flags);
-	return ret;
+	return;
 }
 
 /*
@@ -1199,7 +1199,7 @@ asmlinkage void plat_irq_dispatch(void)
 	volatile u64 eimr;
 	volatile u64 bitmap;
 	struct pt_regs *pt_regs = current_thread_info()->regs;
-	int rvec = 0, idx = 0, base_irq, irq, fn;
+	int rvec = 0, idx = 0, base_irq, irq, fn __maybe_unused;
 	unsigned long flags;
 
 	eirr = read_64bit_cp0_eirr();
diff --git a/arch/mips/netlogic/xlp/nmi.S b/arch/mips/netlogic/xlp/nmi.S
index 61006eb..e539a12 100644
--- a/arch/mips/netlogic/xlp/nmi.S
+++ b/arch/mips/netlogic/xlp/nmi.S
@@ -38,6 +38,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/interrupt.h>
 
+#define XLP_IRQ_IPI_SMP_KGDB_RVEC	9
 
 NESTED(nlm_except_vec_nmi, 0, sp)
 	.set push
@@ -83,7 +84,7 @@ NESTED(nlm_nmi_kgdb_handler, PT_SIZE,  sp)
 	CLI
 	TRACE_IRQS_OFF
 
-	li	a0, IRQ_IPI_SMP_KGDB
+	li	a0, XLP_IRQ_IPI_SMP_KGDB_RVEC
 	move	a1, sp
 	/* jal	do_nlm_common_IRQ */
 	/* nop */
@@ -109,4 +110,4 @@ NESTED(nlm_nmi_kgdb_handler, PT_SIZE,  sp)
 
 	.set pop
 END(nlm_nmi_kgdb_handler)
-#endif
\ No newline at end of file
+#endif
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 47b140a..6ecf165 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -414,30 +414,6 @@ int unregister_xlp_msgring_handler(int major, void *dev_id)
 
 EXPORT_SYMBOL(unregister_xlp_msgring_handler);
 
-#include <asm/netlogic/cpumask.h>
-void nlm_nmi_cpus(unsigned int mask)
-{
-	uint32_t cpumask = cpumask_to_uint32(&cpu_present_map); /* doesn't handle non-n0 nodes */
-	uint32_t cpumask_lo;
-	uint32_t cpumask_hi;
-	const int nmi = 1;
-
-	pic_reg_t *mmio = nlm_hal_pic_offset();
-
-	cpumask = cpumask & mask;
-
-	cpumask_hi = cpumask >> 16;;
-	cpumask_lo = cpumask & 0xffff;
-
-	/* Send IRQ_MSGRING vector in an IPI to all cpus but the current one */
-	if (cpumask_lo)
-		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (nmi << 31) | cpumask_lo );
-
-	if (cpumask_hi)
-		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (nmi << 31) | (1 << 16) | (cpumask_hi));
-}
-
-
 /*********************************************************************
  * enable_msgconfig_int 
  *
@@ -655,9 +631,9 @@ void nlm_enable_vc_intr(void)
 		if(nlm_cpu_vc_mask[cpu] & (1<<i)){
 			vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
 			/*enable interrupts*/
-			nlm_hal_enable_vc_intr(vc_index);
+			nlm_hal_enable_vc_intr(0, vc_index);
 		}else{
-			nlm_hal_disable_vc_intr(vc_index);
+			nlm_hal_disable_vc_intr(0, vc_index);
 		}
 	}
 }
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index c19e09d..b9ff86a 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -106,6 +106,7 @@ static void xlp_init_uart(int port_id)
         xlp_uart_port[port_id].serial_out    = xlp_uart_out;
 }
 
+#ifdef CONFIG_USB
 static void xlp_usb_hw_start(int ctrl_no)
 {
 	int val;
@@ -128,6 +129,7 @@ static void xlp_usb_hw_start(int ctrl_no)
 
 	return;
 }
+#endif
 
 struct dev2drv dev2drv_table[MAX_DEV2DRV] = {
 	{XLP_DEVID_UART, "serial8250",	11,	0,	PLAT_DRV},
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 81870c7..c6ed88e 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -1,69 +1,63 @@
-/* **********************************************************************
- * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+/*
+ * Copyright 2003-2011 NetLogic Microsystems, Inc. (NetLogic). All rights
  * reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the NetLogic
+ * license below:
+ *
  * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
  * 1. Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in
- * the documentation and/or other materials provided with the
- * distribution.
- * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NETLOGIC ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- * ****************************#NETL_2#*******************************
- */
-
-/*
- * Setup code for Netlogic's XLP-based boards
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <linux/spinlock.h>
-#include <linux/mm.h>
-#include <linux/bootmem.h>
-#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/serial_8250.h>
 #include <linux/pm.h>
+#include <linux/bootmem.h>
 
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <asm/bootinfo.h>
-#include <asm/addrspace.h>
 #include <asm/reboot.h>
 #include <asm/time.h>
-#include <linux/interrupt.h>
-#include <asm/atomic.h>
-#include <asm/cacheflush.h>
-
-#include <asm/mipsregs.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/iomap.h>
-#include <asm/netlogic/debug.h>
+#include <asm/bootinfo.h>
+
 #include <asm/netlogic/xlp.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/nlm_pcix_gen_dev.h>
-#include <asm/netlogic/memory-exclusion.h>
-#include <linux/serial.h>
-#include <linux/serial_core.h>
-#include <linux/module.h>
-#include <linux/proc_fs.h>
-#include <asm/mach-netlogic/mmu.h>
-#include <asm/netlogic/bootinfo.h>
+
+#include <linux/of_fdt.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/common.h>
+
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+
 #include <asm/netlogic/cpumask.h>
-#include <asm/netlogic/hal/nlm_hal_macros.h>
-#include <asm/netlogic/xlp_hal_pic.h>
 #include <asm/netlogic/phnx_loader.h>
 #include "../boot/ops.h"
-#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
+#include <asm/netlogic/hal/nlm_hal.h>
 /* Certain macros for this file
  */
 
@@ -102,7 +96,7 @@ int xlp_loader_support = 0;
 #ifdef CONFIG_NUMA
 int hcpu_to_lcpu[NR_CPUS];
 #endif
-
+unsigned int xlp_napi_vc_mask = 0;
 struct proc_dir_entry *nlm_root_proc;
 EXPORT_SYMBOL(nlm_root_proc);
 
@@ -112,7 +106,7 @@ char cpu_model_info[MAX_CPU_REV_LEN] = {'X','L','P'};
 
 static unsigned int xlp_uart_portid = 0;
 
-static char prop_buf[MAX_PROP_LEN];
+char prop_buf[MAX_PROP_LEN];
 
 void *nlm_common_psb_shm = 0;
 unsigned long nlm_common_psb_shm_size = 0;
@@ -123,11 +117,6 @@ struct nlm_node_mem_info node_mem_info[NLM_MAX_CPU_NODE];
 static int nlm_nodes=1;
 #endif
 
-#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
-unsigned long nlm_asid_mask = 0x3f;
-unsigned int nlm_shtlb = 1; /* by default shared TLB is enabled */
-#endif
-
 const char *DEFAULT_CONSOLE_BOOT_PARAMS = "boot_noi2c mem=255m@1m mem=512m@512m console=ttyS0,115200 ";
 const char *DEFAULT_INITRD_BOOT_PARAMS = "rdinit=/sbin/init ";
 
@@ -135,12 +124,18 @@ const char *DEFAULT_INITRD_BOOT_PARAMS = "rdinit=/sbin/init ";
 atomic_t cpus_rebooted = ATOMIC_INIT(0);
 #endif
 
+void parse_cmdline(void);
 unsigned long long nlm_common_tlb_stats[NR_CPUS] __cacheline_aligned;
-spinlock_t atomic_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(atomic_lock);
 
 int hwemul = 0;
 EXPORT_SYMBOL(hwemul);
 
+/* A flag to indicate whether certain xlp8xx/832/816/432/416/408/208/204/104 a0/a1 workaround
+ * is needed or not.
+ */
+int xlp8xx_a01_workaround_needed = 0;
+
 /* Struct for temp. allocation
  * of sp/gp for secondary CPUs
  */
@@ -151,267 +146,88 @@ struct xlp_stack_pages xlp_stack_pages_temp
 __attribute__((__section__(".data.init_task"),
 	       __aligned__(THREAD_SIZE)));
 
-struct boot_mem_map boot_physaddr_info = {
-	.nr_map = 5,
-	.map = {
-		[0] = {
-			.addr = 0ULL,
-			.size = 0x14000000ULL,
-			.type = BOOT_MEM_RAM
-		},
-		[1] = {
-			.addr = 0x14000000ULL,
-			.size = 0x09000000ULL,
-			.type = BOOT_MEM_RESERVED
-		},
-		[2] = {
-			.addr = 0x1D000000ULL,
-			.size = 0xA3000000ULL,
-			.type = BOOT_MEM_RAM
-		},
-		[3] = {
-			.addr = 0xC0000000ULL,
-			.size = 0x20000000ULL,
-			.type = BOOT_MEM_RESERVED
-		},
-		[4] = {
-			.addr = 0xE0000000ULL,
-			.size = 0x20000000ULL,
-			.type = BOOT_MEM_RAM
-		},
-	}
-};
-
-int nlm_common_get_pgprot(unsigned long address)
-{
-	int i = 0;
-
-	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
-		__u64 start = 0, end = 0;
-		long type = 0;
-
-		start = boot_physaddr_info.map[i].addr;
-		end = start + boot_physaddr_info.map[i].size;
-		type = boot_physaddr_info.map[i].type;
-
-		if (address >= start && address < end) {
-			/* Uncached */
-			if (type == BOOT_MEM_RESERVED) return 1;
-			/* cached */
-			if (type == BOOT_MEM_RAM) return 0;
-		}
-	}
-
-	/* uncached */
-	return 1;
-}
-
-int valid_mmap_nlm_common_addr_range(unsigned long pfn)
-{
-	int i;
-	__u64 end=0;
-
-	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
-		end = boot_physaddr_info.map[i].addr + boot_physaddr_info.map[i].size;
-		end = end >> PAGE_SHIFT;
-		if (pfn <= (unsigned long)end)
-			return 1;
-	}
-	return 0;
-}
-
-const char *get_system_type(void)
-{
-	return "Netlogic XLP SoC";
-}
+extern void prom_pre_boot_secondary_cpus(void *);
+
+
+/* used for command line parsing */
+uint32_t nlm_common_loader_kseg_start, nlm_common_loader_kseg_size;
+uint32_t nlm_common_loader_mask;
+/* Size of the shared memory b/w Linux userapp and rmios apps */
+uint32_t nlm_common_app_sh_mem_sz;
+unsigned long  nlm_common_app_shmem_start;
+
+/* xls chip family variables */
+int chip_is_xls6xx = 0;
+int chip_is_xls4xx = 0;
+int chip_is_xls2xx = 0;
+int chip_is_xls1xx = 0;
+int chip_is_xls = 0;
+int chip_is_xls_b0 = 0;
+int chip_is_xls6xx_b0 = 0;
+int chip_is_xls4xx_b0 = 0;
+EXPORT_SYMBOL(chip_is_xls6xx);
+EXPORT_SYMBOL(chip_is_xls4xx);
+EXPORT_SYMBOL(chip_is_xls2xx);
+EXPORT_SYMBOL(chip_is_xls1xx);
+EXPORT_SYMBOL(chip_is_xls);
+EXPORT_SYMBOL(chip_is_xls_b0);
+EXPORT_SYMBOL(chip_is_xls6xx_b0);
+EXPORT_SYMBOL(chip_is_xls4xx_b0);
+
+__u32 xlr_board_major_version = 0;
+__u32 xlr_board_minor_version = 0;
+
+int xlr_hybrid;
+int xlr_loader_support=0;
+int xlr_loader_sharedcore=0;
+int xlr_loader_own_gmac=0;
+int xlr_loader_own_dma=0;
+
+uint32_t xlr_linux_cpu_mask;
+int xlr_console_pci_con_dev = 0;
+int xlr_console_pci_con_baud = 0;
+int xlr_boot_over_nfs = 0;
 
-static void ptr_linux_exit(void)
-{
-	// trigger a chip reset
-	 nlm_hal_write_sys_reg(CHIP_RESET, 1);
-	 for ( ; ; )
-		  cpu_wait();
-}
+unsigned long long nlm_common_tlb_stats[NR_CPUS] __cacheline_aligned;
 
-void __init bus_error_init(void)
-{
-}
+/* default to uniprocessor */
+uint32_t nlm_coremask = 1, nlm_cpumask  = 1;
+int  nlm_threads_per_core = 1;
+extern u32 __dtb_start[];
 
-#ifdef CONFIG_NLM_XLP
-void prom_reconfigure_thr_resources(void) {}
-#else
 void prom_reconfigure_thr_resources(void)
 {
-	unsigned int mmu_setup = 0;
-	int i = 0, num_threads = 0, dis_contig = 0;
-	int value = 0;
-	int cpu = 0;
-
-	/* Configure thread resources only if it is thread_0 of that core */
-	if (netlogic_thr_id() != 0) return;
-
-#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
-	uint32_t map;
-
-	/* netlogic kernel configures this
-	 */
-	if (nlm_shtlb && (nlm_asid_mask == 0x3f)) {
-
-		uint32_t online_map = smp_node.onlinemask[0];    /* from fdt */
-
-		/* Global TLB will work only if all
-		 * the enabled cores have all their
-		 * threads owned by Linux.
-		 */
-		map = online_map;
-		for (i = 0; i < NR_CPUS; i += 4) {
-			if ((map & 0xf) && ((map & 0xf) != 0xf)) {
-				nlm_asid_mask = 0xff;
-				nlm_shtlb = 0;
-				printk("Disabling Shared TLB mode\n");
-				break;
-			}
-			map >>= 4;
-		}
-		if ((nlm_asid_mask == 0x3f) && (netlogic_thr_id() == 0)) {
-			mmu_setup = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_MMU, 0);
-			mmu_setup = mmu_setup | 0x1;
-			write_32bit_nlm_ctrl_reg(CPU_BLOCKID_MMU, 0, mmu_setup);
-
-			printk("CPU %d: Enabled Shared TLB mode \n",
-					netlogic_cpu_id());
-			return;
-		}
-	}
-	return;
-#endif /* CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID */
-
-	/* cpu has to be thread@0 */
-	cpu = hard_smp_processor_id();
-
-	for (i = 0; i < 4; i++) {
-
-		if (!cpumask_test_cpu(cpu + i, &fdt_cpumask)) continue;
-
-		if (i != num_threads)	dis_contig = 1;
-
-		num_threads++;
-	}
-
-	switch(num_threads) {
-	case 1: value = 0x00; break;
-	case 2: value = 0x02; break;
-	default:
-		value = 0x03; break;
-	}
-
-	if (dis_contig)	value = 0x3;
-
-	mmu_setup = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_MMU, 0);
-	mmu_setup = mmu_setup & ~0x06;
-	mmu_setup |= (value << 1);
-	write_32bit_nlm_ctrl_reg(CPU_BLOCKID_MMU, 0, mmu_setup);
 }
-#endif
 
-unsigned int __cpuinit get_c0_compare_int(void)
+int nlm_common_get_pgprot(unsigned long address)
 {
-    return XLP_IRQ_TIMER;
+	return 0;
 }
 
-/* TODO: Get this from FDT */
 void plat_time_init(void)
 {
-	extern void nlm_common_timer_setup(void);
-	mips_hpt_frequency = (unsigned int) get_cpu_freq(XLP_CPU0);
-	printk("mips_hpt_frequency = %u\n", mips_hpt_frequency);
-	nlm_common_timer_setup();
 }
 
-void __init plat_mem_setup(void)
-{
-	extern int panic_timeout;
-
-	panic_timeout 	 = 5;
-	_machine_restart = (void (*)(char *))ptr_linux_exit;
-	_machine_halt    = ptr_linux_exit;
-	pm_power_off 	 = ptr_linux_exit;
-	return;
-}
-
-struct nlm_common_name_value_struct {
-	char *name;
-	uint32_t *val;
-};
-
-static void prom_add_memory(uint64_t start, uint64_t size) __attribute__((unused));
-static void prom_add_memory(uint64_t start, uint64_t size)
+int valid_mmap_nlm_common_addr_range(unsigned long pfn)
 {
-	__u64 pref_backup = 512;
-
-	add_memory_region(
-			start, size - pref_backup, /* CHECK! */
-			BOOT_MEM_RAM);
-	return;
+	return 0;
 }
 
-
-void __init nlm_nmi_setup (void)
+static void nlm_linux_exit(void)
 {
-	void *base;
-	extern char nlm_except_vec_nmi;
-
-	printk("Setting up NMI Handler \n");
-	base = (void *)(unsigned long)0xffffffffbfc00000ULL;
-	memcpy(base, &nlm_except_vec_nmi, 0x80);
+	nlm_hal_write_sys_reg(netlogic_node_id(), CHIP_RESET, 1);
+	for ( ; ; )
+		cpu_wait();
 }
 
-/* setup early serial port driver */
-#ifdef CONFIG_SERIAL_8250
-#define UART_CLK 133333333
-
-static void nlm_early_serial_setup(int uart_id)
+void __init plat_mem_setup(void)
 {
-	struct uart_port s;
-	extern int __init early_serial_setup(struct uart_port *port);
-
-	memset(&s, 0, sizeof(s));
-	s.flags = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
-	s.iotype = UPIO_NLM;
-	s.regshift = 2; /* registers are 4 bytes wide */
-	/* hardware int 4 - the serial int, is CPU int 6
-	 but poll for now */
-	s.uartclk = UART_CLK;
-	switch(uart_id){
-		default:
-		case 0:
-			s.irq = XLP_UART_IRQ(0);
-			s.membase = (unsigned char __iomem *)
-			(DEFAULT_NETLOGIC_IO_BASE + NETLOGIC_IO_UART_0_OFFSET);
-			s.mapbase = (DEFAULT_NETLOGIC_IO_BASE +
-					NETLOGIC_IO_UART_0_OFFSET);
-			s.line = 0;
-			break;
-		case 1:
-			s.irq =  XLP_UART_IRQ(1);
-			s.membase = (unsigned char __iomem *)
-			(DEFAULT_NETLOGIC_IO_BASE + NETLOGIC_IO_UART_1_OFFSET);
-			s.mapbase = (DEFAULT_NETLOGIC_IO_BASE +
-					NETLOGIC_IO_UART_1_OFFSET);
-			s.line = 1;
-			break;
-	}
-	s.serial_in	= xlp_uart_in;
-	s.serial_out	= xlp_uart_out;
-	if (early_serial_setup(&s) != 0) {
-		printk(KERN_ERR "Serial setup failed!\n");
-	}
+	panic_timeout	= 5;
+	_machine_restart = (void (*)(char *))nlm_linux_exit;
+	_machine_halt	= nlm_linux_exit;
+	pm_power_off	= nlm_linux_exit;
 }
-#else
-static void nlm_early_serial_setup(int uart_id) {}
-#endif /* CONFIG_SERIAL_8250 */
 
-extern struct plat_smp_ops nlm_smp_ops;
 struct loader_mem_info loader_mem_map[MAX_NUM_LOADER_MEM_BLK];
 
 #define MAX_CPUMASK_CELLS 4
@@ -429,33 +245,70 @@ int nlm_get_fdt_app_param(const char *param, void *data, int size)
 }
 EXPORT_SYMBOL(nlm_get_fdt_app_param);
 
+int nae_rx_vc = -1, nae_fb_vc = -1;
 int sae_rx_vc = -1, sae_rx_sync_vc = -1;
-static void parse_fdt_sae_vc_config()
+int ipsec_async_vc = -1, ipsec_sync_vc = -1;
+static void parse_fdt_sae_vc_config(void)
 {
 	void *node;
+	void * valid_node;
+	int i;
+	int num_nodes = 1;
+	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
 	node = finddevice("/doms/dom@0/cpu");
 	if(node) {
-		if (getprop(node, "sae-rx-vc", &sae_rx_vc, 4) > 0) 
+		if (getprop(node, "nae-rx-vc", &nae_rx_vc, 4) > 0)
+                        nae_rx_vc = fdt32_to_cpu(nae_rx_vc);
+
+		if (getprop(node, "nae-fb-vc", &nae_fb_vc, 4) > 0)
+                        nae_fb_vc = fdt32_to_cpu(nae_fb_vc);
+
+		if (getprop(node, "sae-rx-vc", &sae_rx_vc, 4) > 0)
 			sae_rx_vc = fdt32_to_cpu(sae_rx_vc);
-		
+
 		if (getprop(node, "sae-rx-sync-vc", &sae_rx_sync_vc, 4) > 0)
 			sae_rx_sync_vc = fdt32_to_cpu(sae_rx_sync_vc);
+
+		if (getprop(node, "ipsec-async-vc", &ipsec_async_vc, 4) > 0)
+			ipsec_async_vc = fdt32_to_cpu(ipsec_async_vc);
+
+		if (getprop(node, "ipsec-sync-vc", &ipsec_sync_vc, 4) > 0)
+			ipsec_sync_vc = fdt32_to_cpu(ipsec_sync_vc);
+
+		valid_node  = finddevice("/soc/nodes");
+
+		if (getprop(valid_node, "num-nodes", &num_nodes, 4) > 0 )
+			num_nodes = fdt32_to_cpu(num_nodes);
+
+		for(i =0 ; i < num_nodes*NLM_MAX_CPU_PER_NODE; i++) {
+			if(nlm_cpu_vc_mask[i] & (1 << ipsec_sync_vc)) {
+				ipsec_sync_vc = -1;
+			}
+
+		}
 	}
+
 	return;
 }
+EXPORT_SYMBOL(nae_rx_vc);
+EXPORT_SYMBOL(nae_fb_vc);
 EXPORT_SYMBOL(sae_rx_vc);
 EXPORT_SYMBOL(sae_rx_sync_vc);
+EXPORT_SYMBOL(ipsec_async_vc);
+EXPORT_SYMBOL(ipsec_sync_vc);
 
-
-static int fdt_process(void)
+static int __init fdt_process(void)
 {
+	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
+
 	int  domain=0;
 	char domstr[32] = "";
 	uint32_t  i, na, ns, regs[MAX_PROP_LEN / 4], entries, cpu_cells;
+#ifdef CONFIG_XLP_FMN_SUPPORT
 	uint32_t node_vc_mask[NLM_MAX_CPU_NODE] = {0};
-	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
 	unsigned char buf[30];
 	int j, id=0, k, tmp;
+#endif
 	uint32_t onlinemask[MAX_CPUMASK_CELLS];
  	uint32_t linux_loader_mask[MAX_CPUMASK_CELLS] = {0};
 
@@ -606,6 +459,13 @@ static int fdt_process(void)
 			}
 		}
 
+		if(getprop(node, "napi-vc-mask", &xlp_napi_vc_mask, sizeof(uint32_t)) < 0){
+			xlp_napi_vc_mask = 0x0;
+		}else{
+			xlp_napi_vc_mask = fdt32_to_cpu(xlp_napi_vc_mask);
+		}
+		printk("xlp_napi_vc_mask %#x\n", xlp_napi_vc_mask);
+
 		cpumask_scnprintf(buf, CPUMASK_BUF, &fdt_cpumask);
 		printk("fdt_cpumask: %s\n", buf);
 	}
@@ -671,6 +531,7 @@ noloadermask:
 		printk("fdt_loadermask: %s\n", buf);
 	}
 
+#ifdef CONFIG_XLP_FMN_SUPPORT
 	node = finddevice("/doms/dom@0/fmn");
 	if (node) {
 		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
@@ -705,6 +566,7 @@ noloadermask:
 			}
 		}
 	}
+#endif
 
 	sprintf(domstr, "/doms/dom@%d/uart", domain);
 	node = finddevice(domstr);
@@ -712,300 +574,57 @@ noloadermask:
 		if (getprop(node, "id", &xlp_uart_portid, sizeof(xlp_uart_portid)) < 0)
 			return -1;
 	}
-	/* Parse the sae async/sync vcs for linux userspace model , 
-	   remove the sync vc from the int handler of linux */
+	/* Parse the sae async/sync vcs for linux userspace model */
 	parse_fdt_sae_vc_config();
-	if(sae_rx_sync_vc >= 0) {
-		for (i = 0; i < NLM_MAX_CPU_NODE * NLM_MAX_CPU_PER_NODE ; i++) {
-			if(nlm_cpu_vc_mask[i] & (1 << sae_rx_sync_vc)) {
-				nlm_cpu_vc_mask[i] = nlm_cpu_vc_mask[i] & (~(1 << sae_rx_sync_vc));
-			}
-		}
-	}
 
 	return 0;
 }
 
-
-static int get_xlp_proc_name(void)
-{
-	unsigned int processor_id = get_proc_id();
-	unsigned int cfg0 =  efuse_cfg0();
-	unsigned int cfg1 =  efuse_cfg1();
-	//printk("efuse_cfg6 =0x%x \n", get_proc_id());
-	//printk("efuse_cfg0 =0x%x \n", efuse_cfg0());
-        //printk("efuse_cfg1 =0x%x \n", efuse_cfg1());
-
-	switch (processor_id) {
-		case CHIP_PROCESSOR_ID_XLP_8XX:		/*defulet set to XLP8XX */
-		case CHIP_PROCESSOR_ID_XLP_8_4_XX:
-			switch((cfg0 & EFUSE_CFG0_MASK) | (cfg1<<EFUSE_CFG1_SHIFT)) {
-				case XLP_832:
-					strcpy(cpu_model_info, "XLP832");
-				break;
-				case XLP_824:
-					strcpy(cpu_model_info, "XLP824");
-				break;
-				case XLP_816:
-					strcpy(cpu_model_info, "XLP816");
-				break;
-				case XLP_432:
-					strcpy(cpu_model_info, "XLP432");
-				break;
-				case XLP_424:
-					strcpy(cpu_model_info, "XLP424");
-				break;
-				case XLP_416:
-					strcpy(cpu_model_info, "XLP416");
-				break;
-				case XLP_408:
-					strcpy(cpu_model_info, "XLP408");
-				break;
-				default:
-					printk("No category found in XLP 8XX/4XX. Default to XLP832\n");
-					strcpy(cpu_model_info, "XLP832");
-				return 0;
-
-			}
-		break;
-		/*Backward compatibility for XLP8XX/XLP4XX A0/A1/A2*/
-		case CHIP_PROCESSOR_ID_XLP_816:
-			strcpy(cpu_model_info, "XLP816");
-		break;
-		case CHIP_PROCESSOR_ID_XLP_432:
-			strcpy(cpu_model_info, "XLP432");
-		break;
-		case CHIP_PROCESSOR_ID_XLP_416:
-			strcpy(cpu_model_info, "XLP416");
-		break;
-		case CHIP_PROCESSOR_ID_XLP_408:
-			strcpy(cpu_model_info, "XLP408");
-		break;
-		/*XLP3XX series*/
-		case CHIP_PROCESSOR_ID_XLP_3XX:
-			strcpy(cpu_model_info, "XLP3");
-			switch (cfg0 & 0xf){
-				case CPU_XLP_316:
-					strcat(cpu_model_info, "16");
-				break;
-				case CPU_XLP_308:
-					strcat(cpu_model_info, "08");
-				break;
-				case CPU_XLP_304:
-					strcat(cpu_model_info, "04");
-				break;
-				default:
-					strcat(cpu_model_info, "??");
-				break;
-
-			}
-
-		break;
-		case CHIP_PROCESSOR_ID_XLP_2XX:
-			strcpy(cpu_model_info, "XLP2XX");
-		break;
-
-		case CHIP_PROCESSOR_ID_XLP_208:
-			strcpy(cpu_model_info, "XLP208");
-		break;
-		case CHIP_PROCESSOR_ID_XLP_204:
-			strcpy(cpu_model_info, "XLP204");
-		break;
-		case CHIP_PROCESSOR_ID_XLP_104:
-			strcpy(cpu_model_info, "XLP104");
-		break;
-		default:
-			strcpy(cpu_model_info, "XLP???");
-		return -1;
-	}
-
-	return 0;
-}
-
-static int get_xlp_revision(void)
-{
-	int revision = read_c0_prid() & 0xff;
-
-	switch (revision) {
-	case XLP_REVISION_A0:
-		strcpy(cpu_model_info + PROCESSOR_ID_MAX_LEN, " Rev A0");
-		break;
-	case XLP_REVISION_A1:
-		strcpy(cpu_model_info + PROCESSOR_ID_MAX_LEN, " Rev A1");
-		break;
-	case XLP_REVISION_A2:
-		strcpy(cpu_model_info + PROCESSOR_ID_MAX_LEN, " Rev A2");
-		break;
-	case XLP_REVISION_B0:
-		strcpy(cpu_model_info + PROCESSOR_ID_MAX_LEN, " Rev B0");
-		break;
-	default:
-		strcpy(cpu_model_info + PROCESSOR_ID_MAX_LEN, " Rev ??");
-		return -1;
-	}
-
-	return revision;
-}
-
-char* get_cpu_info(void)
-{
-	get_xlp_proc_name();
-	get_xlp_revision();
-
-	return cpu_model_info;
-}
-
-#ifdef CONFIG_XEN
-extern void xen_init(void);
+#ifdef CONFIG_MAPPED_KERNEL
+#define secondary_cpus_bootup_func \
+	((unsigned long)prom_pre_boot_secondary_cpus - \
+	 (unsigned long)LOADADDR + (unsigned long)PHYSADDR)
 #else
-static void xen_init(void) {}
+#define secondary_cpus_bootup_func prom_pre_boot_secondary_cpus
 #endif
 
-#ifdef CONFIG_NUMA
-static void sort_mem_info(struct nlm_node_mem_info *info, unsigned long *spfn,
-	unsigned long *epfn)
+const char *get_system_type(void)
 {
-	struct nlm_node_mem_frag *list = info->mem;
-	int i,j;
-
-	uint64_t start_pfn = 0;
-	uint64_t end_pfn = 0;
-
-	*spfn = *epfn = 0;
-	if(info->frags == 0)
-		return;
-
-	for(i=0; i < info->frags; i++) {
-		for (j = i; j < info->frags; j++) {
-			if (list[i].start_pfn > list[j].start_pfn) {
-				start_pfn = list[i].start_pfn;
-				end_pfn = list[i].end_pfn;
-				list[i].start_pfn = list[j].start_pfn;
-				list[i].end_pfn = list[j].end_pfn;
-				list[j].start_pfn = start_pfn;
-				list[j].end_pfn = end_pfn;
-			}
-		}
-	}
-	*spfn = list[0].start_pfn;
-	*epfn = list[info->frags-1].end_pfn;
+	return "Netlogic XLP Series";
 }
 
-void __init prom_meminit(void)
+void __init prom_free_prom_memory(void)
 {
-	int node=0;
-	unsigned long start_pfn, end_pfn;
-	struct nlm_mem_info *minfo;
-
-	/* sort the node_mem_map */
-	for(node=0; node < nlm_nodes; node++) {
-        	sort_mem_info(&node_mem_info[node], &start_pfn, &end_pfn);
-        	minfo = NODE_MEM_DATA(node);
-        	minfo->low_pfn = start_pfn;
-        	minfo->high_pfn = end_pfn;
-	}
+	/* Nothing yet */
 }
 
-extern struct nlm_node_data __node_data_holder[];
-void __init build_node_cpu_map(void)
+void xlp_mmu_init(void)
 {
-	int cpu, node,i;
-
-	/* kernel expects all node_data to initialized
- 	 * If a node has its own memory, we will overwrite this pointer
- 	 */
-	for(node=0; node < MAX_NUMNODES; node++) {
-		__node_data[node] = &__node_data_holder[node];
-	}
+	/* enable extended TLB and Large Fixed TLB */
+	write_c0_config6(read_c0_config6() | 0x24);
 
-	i=0;
-	for_each_cpu(cpu, &fdt_cpumask) {
-		node = hardcpu_to_node(cpu);
-		hcpu_to_lcpu[cpu] = i;
-		if(!node_online(node)) {
-			node_set_online(num_online_nodes());
-		}
-		i++;
-	}
-	printk("Number of online nodes = %d\n", num_online_nodes());
+	/* set page mask of Fixed TLB in config7 */
+	write_c0_config7(PM_DEFAULT_MASK >>
+		(13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
 }
-#endif
 
 void __init prom_init(void)
 {
-#ifdef CONFIG_NLM_ENABLE_COP2
-	unsigned int c0status;
-#endif
-	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
 	fdt_process();
+    	parse_cmdline();
 
-#ifdef CONFIG_NUMA
-	build_node_cpu_map();
-#endif
+	xlp_mmu_init();
+	nlm_hal_init();
 
-	xen_init();
 
 	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
-
-#ifdef CONFIG_NLM_ENABLE_COP2
-	// workaround. trap_init enables cop2. But this function gets called before trap_init
-	c0status = read_c0_status() | ST0_CU2;
-	write_c0_status(c0status);
-#endif
-	cpumask_clear(&smp_boot.online_map);
-	cpumask_set_cpu(hard_smp_processor_id(), &smp_boot.online_map);
-
-	board_nmi_handler_setup = nlm_nmi_setup;
-
-	on_chip_init();
-
-	prom_reconfigure_thr_resources();
-
-	/* setup early serial port driver */
-	nlm_early_serial_setup(xlp_uart_portid);
+#ifdef CONFIG_SMP
+	/* update TLB size after waking up threads */
+	current_cpu_data.tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
 
 	register_smp_ops(&nlm_smp_ops);
-
-	wakeup_secondary_cpus();
-}
-
-void prom_free_prom_memory(void)
-{
-	/* nothing to free */
-}
-
-#ifndef KSEG0
-#define KSEG0 0xffffffff80000000ULL
 #endif
-
-#define RING_BUFFER_BASE (511 << 20)
-#define RING_BUFFER_SIZE (8 << 10)
-static void outbyte_ring_buffer(char c)
-{
-	unsigned long base = RING_BUFFER_BASE + (hard_smp_processor_id() * RING_BUFFER_SIZE);
-	char *buf = (char *)KSEG0 + base;
-	static int idx = 0;
-
-	buf[idx] = c;
-	idx = (idx + 1) % (RING_BUFFER_SIZE);
-}
-
-void nlm_early_printk(const char *fmt, ...)
-{
-	char buf[256];
-	va_list args;
-	int r;
-	char *str = buf;
-
-	va_start(args, fmt);
-	r = vsnprintf(buf, 256, fmt, args);
-	va_end(args);
-
-	while (*str) {
-		outbyte_ring_buffer(*str);
-		str++;
-	}
 }
 
 #ifdef CONFIG_EARLY_PRINTK
@@ -1034,12 +653,90 @@ void prom_putchar(char c)
 }
 #endif
 
-static int __init nlm_proc_setup(void)
+#ifdef CONFIG_BLK_DEV_INITRD
+extern unsigned long initrd_start, initrd_end;
+
+static int __init initrd_setup(char *str)
 {
-	nlm_root_proc = proc_mkdir("netlogic", 0);
-	if (!nlm_root_proc)
-		return -ENOMEM;
+	char rdarg[64];
+	int idx;
+	char *tmp, *endptr;
+	unsigned long initrd_size;
+
+	/* Make a copy of the initrd argument so we can smash it up here */
+	for (idx = 0; idx < sizeof(rdarg)-1; idx++) {
+		if (!str[idx] || (str[idx] == ' ')) break;
+		rdarg[idx] = str[idx];
+	}
+
+	rdarg[idx] = 0;
+	str = rdarg;
 
+	/*
+	*Initrd location comes in the form "<hex size of ramdisk in bytes>@<location in memory>"
+	*  e.g. initrd=size@physaddr.
+	*/
+	for (tmp = str; *tmp != '@'; tmp++) {
+	       if (!*tmp) {
+			goto fail;
+		}
+	}
+	*tmp = 0;
+	tmp++;
+	if (!*tmp) {
+		goto fail;
+	}
+	initrd_size = simple_strtoul(str, &endptr, 16);
+	if (*endptr) {
+		 *(tmp-1) = '@';
+		 goto fail;
+	}
+	*(tmp-1) = '@';
+	initrd_start = simple_strtoul(tmp, &endptr, 16);
+
+
+#if defined(CONFIG_32BIT) && defined (CONFIG_MAPPED_KERNEL)
+	initrd_start = CKSEG2ADDR(initrd_start);
+#else
+	initrd_start = CKSEG1ADDR(initrd_start);
+#endif
+
+	if (*endptr) {
+		goto fail;
+	}
+	initrd_end = initrd_start + initrd_size;
 	return 0;
+	fail:
+	printk("Bad initrd argument.  Disabling initrd\n");
+	initrd_start = 0;
+	initrd_end = 0;
+	return -1;
+}
+#endif
+
+/*
+ * Init routine which accepts the variables from u-boot
+ */
+void  __init parse_cmdline(void)
+{
+	char *ptr;
+	/* Need to find out early whether we've got an initrd.  So scan
+	the list looking now */
+	for (ptr = arcs_cmdline; *ptr; ptr++) {
+		while (*ptr == ' ') {
+			ptr++;
+		}
+		if (!strncmp(ptr, "initrd=", 7)) {
+#ifdef CONFIG_BLK_DEV_INITRD
+			initrd_setup(ptr+7);
+#else
+			printk("initrd is disabled in Kernel\n");
+#endif
+			break;
+		} else {
+			while (*ptr && (*ptr != ' ')) {
+				ptr++;
+			}
+		}
+	}
 }
-rootfs_initcall(nlm_proc_setup);
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 7cfebfa..ad70f94 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -133,9 +133,13 @@ void nlm_cpus_done(void)
 {
 }
 
-/* Boot all other cpus in the system, initialize them, and
-   bring them into the boot fn */
-void __cpuinit nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
+/*
+ * init/main.c : smp_init ==> cpu_up ==> _cpu_up => __cpu_up (arch/mips/kernel/
+ * smp.c) ==> mp_ops->boot_secondary
+ * The cpu argument is the bit number from cpu_present_mask (for_each_online_cpu
+ * ) => physical cpu id, not logical
+ */
+void __cpuinit nlm_boot_secondary(int cpu, struct task_struct *idle)
 {
 	unsigned long gp = (unsigned long)task_thread_info(idle);
 	unsigned long sp = (unsigned long)__KSTK_TOS(idle);
diff --git a/arch/mips/netlogic/xlp/xlp_gpio.c b/arch/mips/netlogic/xlp/xlp_gpio.c
index b8bba19..a106c49 100644
--- a/arch/mips/netlogic/xlp/xlp_gpio.c
+++ b/arch/mips/netlogic/xlp/xlp_gpio.c
@@ -236,4 +236,10 @@ static int __init xlp_gpiolib_init(void)
         return 0;
 }
 
+int gpio_to_irq(unsigned gpio)
+{
+	return -1;
+}
+EXPORT_SYMBOL_GPL(gpio_to_irq);
+
 arch_initcall(xlp_gpiolib_init);
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index 3bf7b0a..feb7dc3 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -14,13 +14,16 @@
 
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+    MA 02110-1301 USA.							     */
 /* ------------------------------------------------------------------------- */
 
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi>.
    All SMBus-related things are written by Frodo Looijaard <frodol@dds.nl>
    SMBus 2.0 support by Mark Studebaker <mdsxyz123@yahoo.com> and
-   Jean Delvare <khali@linux-fr.org> */
+   Jean Delvare <khali@linux-fr.org>
+   Mux support by Rodolfo Giometti <giometti@enneenne.com> and
+   Michael Lawnick <michael.lawnick.ext@nsn.com> */
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -30,24 +33,24 @@
 #include <linux/init.h>
 #include <linux/idr.h>
 #include <linux/mutex.h>
+#include <linux/of_device.h>
 #include <linux/completion.h>
 #include <linux/hardirq.h>
 #include <linux/irqflags.h>
 #include <linux/rwsem.h>
+#include <linux/pm_runtime.h>
 #include <asm/uaccess.h>
 
 #include "i2c-core.h"
 
 
-/* core_lock protects i2c_adapter_idr, userspace_devices, and guarantees
+/* core_lock protects i2c_adapter_idr, and guarantees
    that device detection, deletion of detected devices, and attach_adapter
    and detach_adapter calls are serialized */
 static DEFINE_MUTEX(core_lock);
 static DEFINE_IDR(i2c_adapter_idr);
-static LIST_HEAD(userspace_devices);
 
 static struct device_type i2c_client_type;
-static int i2c_check_addr(struct i2c_adapter *adapter, int addr);
 static int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver);
 
 /* ------------------------------------------------------------------------- */
@@ -71,6 +74,10 @@ static int i2c_device_match(struct device *dev, struct device_driver *drv)
 	if (!client)
 		return 0;
 
+	/* Attempt an OF style match */
+	if (of_driver_match_device(dev, drv))
+		return 1;
+
 	driver = to_i2c_driver(drv);
 	/* match on an id table if there is one */
 	if (driver->id_table)
@@ -116,8 +123,10 @@ static int i2c_device_probe(struct device *dev)
 	dev_dbg(dev, "probe\n");
 
 	status = driver->probe(client, i2c_match_id(driver->id_table, client));
-	if (status)
+	if (status) {
 		client->driver = NULL;
+		i2c_set_clientdata(client, NULL);
+	}
 	return status;
 }
 
@@ -138,8 +147,10 @@ static int i2c_device_remove(struct device *dev)
 		dev->driver = NULL;
 		status = 0;
 	}
-	if (status == 0)
+	if (status == 0) {
 		client->driver = NULL;
+		i2c_set_clientdata(client, NULL);
+	}
 	return status;
 }
 
@@ -155,7 +166,8 @@ static void i2c_device_shutdown(struct device *dev)
 		driver->shutdown(client);
 }
 
-static int i2c_device_suspend(struct device *dev, pm_message_t mesg)
+#ifdef CONFIG_PM_SLEEP
+static int i2c_legacy_suspend(struct device *dev, pm_message_t mesg)
 {
 	struct i2c_client *client = i2c_verify_client(dev);
 	struct i2c_driver *driver;
@@ -168,7 +180,7 @@ static int i2c_device_suspend(struct device *dev, pm_message_t mesg)
 	return driver->suspend(client, mesg);
 }
 
-static int i2c_device_resume(struct device *dev)
+static int i2c_legacy_resume(struct device *dev)
 {
 	struct i2c_client *client = i2c_verify_client(dev);
 	struct i2c_driver *driver;
@@ -181,6 +193,74 @@ static int i2c_device_resume(struct device *dev)
 	return driver->resume(client);
 }
 
+static int i2c_device_pm_suspend(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_suspend(dev);
+	else
+		return i2c_legacy_suspend(dev, PMSG_SUSPEND);
+}
+
+static int i2c_device_pm_resume(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_resume(dev);
+	else
+		return i2c_legacy_resume(dev);
+}
+
+static int i2c_device_pm_freeze(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_freeze(dev);
+	else
+		return i2c_legacy_suspend(dev, PMSG_FREEZE);
+}
+
+static int i2c_device_pm_thaw(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_thaw(dev);
+	else
+		return i2c_legacy_resume(dev);
+}
+
+static int i2c_device_pm_poweroff(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_poweroff(dev);
+	else
+		return i2c_legacy_suspend(dev, PMSG_HIBERNATE);
+}
+
+static int i2c_device_pm_restore(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_restore(dev);
+	else
+		return i2c_legacy_resume(dev);
+}
+#else /* !CONFIG_PM_SLEEP */
+#define i2c_device_pm_suspend	NULL
+#define i2c_device_pm_resume	NULL
+#define i2c_device_pm_freeze	NULL
+#define i2c_device_pm_thaw	NULL
+#define i2c_device_pm_poweroff	NULL
+#define i2c_device_pm_restore	NULL
+#endif /* !CONFIG_PM_SLEEP */
+
 static void i2c_client_dev_release(struct device *dev)
 {
 	kfree(to_i2c_client(dev));
@@ -219,14 +299,27 @@ static const struct attribute_group *i2c_dev_attr_groups[] = {
 	NULL
 };
 
+static const struct dev_pm_ops i2c_device_pm_ops = {
+	.suspend = i2c_device_pm_suspend,
+	.resume = i2c_device_pm_resume,
+	.freeze = i2c_device_pm_freeze,
+	.thaw = i2c_device_pm_thaw,
+	.poweroff = i2c_device_pm_poweroff,
+	.restore = i2c_device_pm_restore,
+	SET_RUNTIME_PM_OPS(
+		pm_generic_runtime_suspend,
+		pm_generic_runtime_resume,
+		pm_generic_runtime_idle
+	)
+};
+
 struct bus_type i2c_bus_type = {
 	.name		= "i2c",
 	.match		= i2c_device_match,
 	.probe		= i2c_device_probe,
 	.remove		= i2c_device_remove,
 	.shutdown	= i2c_device_shutdown,
-	.suspend	= i2c_device_suspend,
-	.resume		= i2c_device_resume,
+	.pm		= &i2c_device_pm_ops,
 };
 EXPORT_SYMBOL_GPL(i2c_bus_type);
 
@@ -255,6 +348,141 @@ struct i2c_client *i2c_verify_client(struct device *dev)
 EXPORT_SYMBOL(i2c_verify_client);
 
 
+/* This is a permissive address validity check, I2C address map constraints
+ * are purposely not enforced, except for the general call address. */
+static int i2c_check_client_addr_validity(const struct i2c_client *client)
+{
+	if (client->flags & I2C_CLIENT_TEN) {
+		/* 10-bit address, all values are valid */
+		if (client->addr > 0x3ff)
+			return -EINVAL;
+	} else {
+		/* 7-bit address, reject the general call address */
+		if (client->addr == 0x00 || client->addr > 0x7f)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+/* And this is a strict address validity check, used when probing. If a
+ * device uses a reserved address, then it shouldn't be probed. 7-bit
+ * addressing is assumed, 10-bit address devices are rare and should be
+ * explicitly enumerated. */
+static int i2c_check_addr_validity(unsigned short addr)
+{
+	/*
+	 * Reserved addresses per I2C specification:
+	 *  0x00       General call address / START byte
+	 *  0x01       CBUS address
+	 *  0x02       Reserved for different bus format
+	 *  0x03       Reserved for future purposes
+	 *  0x04-0x07  Hs-mode master code
+	 *  0x78-0x7b  10-bit slave addressing
+	 *  0x7c-0x7f  Reserved for future purposes
+	 */
+	if (addr < 0x08 || addr > 0x77)
+		return -EINVAL;
+	return 0;
+}
+
+static int __i2c_check_addr_busy(struct device *dev, void *addrp)
+{
+	struct i2c_client	*client = i2c_verify_client(dev);
+	int			addr = *(int *)addrp;
+
+	if (client && client->addr == addr)
+		return -EBUSY;
+	return 0;
+}
+
+/* walk up mux tree */
+static int i2c_check_mux_parents(struct i2c_adapter *adapter, int addr)
+{
+	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);
+	int result;
+
+	result = device_for_each_child(&adapter->dev, &addr,
+					__i2c_check_addr_busy);
+
+	if (!result && parent)
+		result = i2c_check_mux_parents(parent, addr);
+
+	return result;
+}
+
+/* recurse down mux tree */
+static int i2c_check_mux_children(struct device *dev, void *addrp)
+{
+	int result;
+
+	if (dev->type == &i2c_adapter_type)
+		result = device_for_each_child(dev, addrp,
+						i2c_check_mux_children);
+	else
+		result = __i2c_check_addr_busy(dev, addrp);
+
+	return result;
+}
+
+static int i2c_check_addr_busy(struct i2c_adapter *adapter, int addr)
+{
+	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);
+	int result = 0;
+
+	if (parent)
+		result = i2c_check_mux_parents(parent, addr);
+
+	if (!result)
+		result = device_for_each_child(&adapter->dev, &addr,
+						i2c_check_mux_children);
+
+	return result;
+}
+
+/**
+ * i2c_lock_adapter - Get exclusive access to an I2C bus segment
+ * @adapter: Target I2C bus segment
+ */
+void i2c_lock_adapter(struct i2c_adapter *adapter)
+{
+	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);
+
+	if (parent)
+		i2c_lock_adapter(parent);
+	else
+		rt_mutex_lock(&adapter->bus_lock);
+}
+EXPORT_SYMBOL_GPL(i2c_lock_adapter);
+
+/**
+ * i2c_trylock_adapter - Try to get exclusive access to an I2C bus segment
+ * @adapter: Target I2C bus segment
+ */
+static int i2c_trylock_adapter(struct i2c_adapter *adapter)
+{
+	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);
+
+	if (parent)
+		return i2c_trylock_adapter(parent);
+	else
+		return rt_mutex_trylock(&adapter->bus_lock);
+}
+
+/**
+ * i2c_unlock_adapter - Release exclusive access to an I2C bus segment
+ * @adapter: Target I2C bus segment
+ */
+void i2c_unlock_adapter(struct i2c_adapter *adapter)
+{
+	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);
+
+	if (parent)
+		i2c_unlock_adapter(parent);
+	else
+		rt_mutex_unlock(&adapter->bus_lock);
+}
+EXPORT_SYMBOL_GPL(i2c_unlock_adapter);
+
 /**
  * i2c_new_device - instantiate an i2c device
  * @adap: the adapter managing the device
@@ -294,17 +522,28 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 
 	strlcpy(client->name, info->type, sizeof(client->name));
 
+	/* Check for address validity */
+	status = i2c_check_client_addr_validity(client);
+	if (status) {
+		dev_err(&adap->dev, "Invalid %d-bit I2C address 0x%02hx\n",
+			client->flags & I2C_CLIENT_TEN ? 10 : 7, client->addr);
+		goto out_err_silent;
+	}
+
 	/* Check for address business */
-	status = i2c_check_addr(adap, client->addr);
+	status = i2c_check_addr_busy(adap, client->addr);
 	if (status)
 		goto out_err;
 
 	client->dev.parent = &client->adapter->dev;
 	client->dev.bus = &i2c_bus_type;
 	client->dev.type = &i2c_client_type;
+	client->dev.of_node = info->of_node;
 
+	/* For 10-bit clients, add an arbitrary offset to avoid collisions */
 	dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
-		     client->addr);
+		     client->addr | ((client->flags & I2C_CLIENT_TEN)
+				     ? 0xa000 : 0));
 	status = device_register(&client->dev);
 	if (status)
 		goto out_err;
@@ -317,6 +556,7 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 out_err:
 	dev_err(&adap->dev, "Failed to register i2c client %s at 0x%02x "
 		"(%d)\n", client->name, client->addr, status);
+out_err_silent:
 	kfree(client);
 	return NULL;
 }
@@ -416,8 +656,6 @@ i2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,
 	char *blank, end;
 	int res;
 
-	dev_warn(dev, "The new_device interface is still experimental "
-		 "and may change in a near future\n");
 	memset(&info, 0, sizeof(struct i2c_board_info));
 
 	blank = strchr(buf, ' ');
@@ -442,20 +680,14 @@ i2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
-	if (info.addr < 0x03 || info.addr > 0x77) {
-		dev_err(dev, "%s: Invalid I2C address 0x%hx\n", "new_device",
-			info.addr);
-		return -EINVAL;
-	}
-
 	client = i2c_new_device(adap, &info);
 	if (!client)
-		return -EEXIST;
+		return -EINVAL;
 
 	/* Keep track of the added device */
-	mutex_lock(&core_lock);
-	list_add_tail(&client->detected, &userspace_devices);
-	mutex_unlock(&core_lock);
+	mutex_lock(&adap->userspace_clients_lock);
+	list_add_tail(&client->detected, &adap->userspace_clients);
+	mutex_unlock(&adap->userspace_clients_lock);
 	dev_info(dev, "%s: Instantiated device %s at 0x%02hx\n", "new_device",
 		 info.type, info.addr);
 
@@ -494,9 +726,10 @@ i2c_sysfs_delete_device(struct device *dev, struct device_attribute *attr,
 
 	/* Make sure the device was added through sysfs */
 	res = -ENOENT;
-	mutex_lock(&core_lock);
-	list_for_each_entry_safe(client, next, &userspace_devices, detected) {
-		if (client->addr == addr && client->adapter == adap) {
+	mutex_lock(&adap->userspace_clients_lock);
+	list_for_each_entry_safe(client, next, &adap->userspace_clients,
+				 detected) {
+		if (client->addr == addr) {
 			dev_info(dev, "%s: Deleting device %s at 0x%02hx\n",
 				 "delete_device", client->name, client->addr);
 
@@ -506,7 +739,7 @@ i2c_sysfs_delete_device(struct device *dev, struct device_attribute *attr,
 			break;
 		}
 	}
-	mutex_unlock(&core_lock);
+	mutex_unlock(&adap->userspace_clients_lock);
 
 	if (res < 0)
 		dev_err(dev, "%s: Can't find device in list\n",
@@ -533,10 +766,11 @@ static const struct attribute_group *i2c_adapter_attr_groups[] = {
 	NULL
 };
 
-static struct device_type i2c_adapter_type = {
+struct device_type i2c_adapter_type = {
 	.groups		= i2c_adapter_attr_groups,
 	.release	= i2c_adapter_dev_release,
 };
+EXPORT_SYMBOL_GPL(i2c_adapter_type);
 
 #ifdef CONFIG_I2C_COMPAT
 static struct class_compat *i2c_adapter_compat_class;
@@ -558,25 +792,32 @@ static void i2c_scan_static_board_info(struct i2c_adapter *adapter)
 	up_read(&__i2c_board_lock);
 }
 
-static int i2c_do_add_adapter(struct device_driver *d, void *data)
+static int i2c_do_add_adapter(struct i2c_driver *driver,
+			      struct i2c_adapter *adap)
 {
-	struct i2c_driver *driver = to_i2c_driver(d);
-	struct i2c_adapter *adap = data;
-
 	/* Detect supported devices on that bus, and instantiate them */
 	i2c_detect(adap, driver);
 
 	/* Let legacy drivers scan this bus for matching devices */
 	if (driver->attach_adapter) {
+		dev_warn(&adap->dev, "%s: attach_adapter method is deprecated\n",
+			 driver->driver.name);
+		dev_warn(&adap->dev, "Please use another way to instantiate "
+			 "your i2c_client\n");
 		/* We ignore the return code; if it fails, too bad */
 		driver->attach_adapter(adap);
 	}
 	return 0;
 }
 
+static int __process_new_adapter(struct device_driver *d, void *data)
+{
+	return i2c_do_add_adapter(to_i2c_driver(d), data);
+}
+
 static int i2c_register_adapter(struct i2c_adapter *adap)
 {
-	int res = 0, dummy;
+	int res = 0;
 
 	/* Can't register until after driver model init */
 	if (unlikely(WARN_ON(!i2c_bus_type.p))) {
@@ -584,7 +825,21 @@ static int i2c_register_adapter(struct i2c_adapter *adap)
 		goto out_list;
 	}
 
-	mutex_init(&adap->bus_lock);
+	/* Sanity checks */
+	if (unlikely(adap->name[0] == '\0')) {
+		pr_err("i2c-core: Attempt to register an adapter with "
+		       "no name!\n");
+		return -EINVAL;
+	}
+	if (unlikely(!adap->algo)) {
+		pr_err("i2c-core: Attempt to register adapter '%s' with "
+		       "no algo!\n", adap->name);
+		return -EINVAL;
+	}
+
+	rt_mutex_init(&adap->bus_lock);
+	mutex_init(&adap->userspace_clients_lock);
+	INIT_LIST_HEAD(&adap->userspace_clients);
 
 	/* Set default timeout to 1 second if not already set */
 	if (adap->timeout == 0)
@@ -613,8 +868,7 @@ static int i2c_register_adapter(struct i2c_adapter *adap)
 
 	/* Notify drivers */
 	mutex_lock(&core_lock);
-	dummy = bus_for_each_drv(&i2c_bus_type, NULL, adap,
-				 i2c_do_add_adapter);
+	bus_for_each_drv(&i2c_bus_type, NULL, adap, __process_new_adapter);
 	mutex_unlock(&core_lock);
 
 	return 0;
@@ -674,6 +928,9 @@ EXPORT_SYMBOL(i2c_add_adapter);
  * or otherwise built in to the system's mainboard, and where i2c_board_info
  * is used to properly configure I2C devices.
  *
+ * If the requested bus number is set to -1, then this function will behave
+ * identically to i2c_add_adapter, and will dynamically assign a bus number.
+ *
  * If no devices have pre-been declared for this bus, then be sure to
  * register the adapter before any dynamically allocated ones.  Otherwise
  * the required bus ID may not be available.
@@ -689,6 +946,8 @@ int i2c_add_numbered_adapter(struct i2c_adapter *adap)
 	int	id;
 	int	status;
 
+	if (adap->nr == -1) /* -1 means dynamically assign bus id */
+		return i2c_add_adapter(adap);
 	if (adap->nr & ~MAX_ID_MASK)
 		return -EINVAL;
 
@@ -715,10 +974,9 @@ retry:
 }
 EXPORT_SYMBOL_GPL(i2c_add_numbered_adapter);
 
-static int i2c_do_del_adapter(struct device_driver *d, void *data)
+static int i2c_do_del_adapter(struct i2c_driver *driver,
+			      struct i2c_adapter *adapter)
 {
-	struct i2c_driver *driver = to_i2c_driver(d);
-	struct i2c_adapter *adapter = data;
 	struct i2c_client *client, *_n;
 	int res;
 
@@ -735,6 +993,8 @@ static int i2c_do_del_adapter(struct device_driver *d, void *data)
 
 	if (!driver->detach_adapter)
 		return 0;
+	dev_warn(&adapter->dev, "%s: detach_adapter method is deprecated\n",
+		 driver->driver.name);
 	res = driver->detach_adapter(adapter);
 	if (res)
 		dev_err(&adapter->dev, "detach_adapter failed (%d) "
@@ -745,11 +1005,24 @@ static int i2c_do_del_adapter(struct device_driver *d, void *data)
 static int __unregister_client(struct device *dev, void *dummy)
 {
 	struct i2c_client *client = i2c_verify_client(dev);
+	if (client && strcmp(client->name, "dummy"))
+		i2c_unregister_device(client);
+	return 0;
+}
+
+static int __unregister_dummy(struct device *dev, void *dummy)
+{
+	struct i2c_client *client = i2c_verify_client(dev);
 	if (client)
 		i2c_unregister_device(client);
 	return 0;
 }
 
+static int __process_removed_adapter(struct device_driver *d, void *data)
+{
+	return i2c_do_del_adapter(to_i2c_driver(d), data);
+}
+
 /**
  * i2c_del_adapter - unregister I2C adapter
  * @adap: the adapter being unregistered
@@ -777,24 +1050,29 @@ int i2c_del_adapter(struct i2c_adapter *adap)
 	/* Tell drivers about this removal */
 	mutex_lock(&core_lock);
 	res = bus_for_each_drv(&i2c_bus_type, NULL, adap,
-			       i2c_do_del_adapter);
+			       __process_removed_adapter);
 	mutex_unlock(&core_lock);
 	if (res)
 		return res;
 
 	/* Remove devices instantiated from sysfs */
-	list_for_each_entry_safe(client, next, &userspace_devices, detected) {
-		if (client->adapter == adap) {
-			dev_dbg(&adap->dev, "Removing %s at 0x%x\n",
-				client->name, client->addr);
-			list_del(&client->detected);
-			i2c_unregister_device(client);
-		}
+	mutex_lock(&adap->userspace_clients_lock);
+	list_for_each_entry_safe(client, next, &adap->userspace_clients,
+				 detected) {
+		dev_dbg(&adap->dev, "Removing %s at 0x%x\n", client->name,
+			client->addr);
+		list_del(&client->detected);
+		i2c_unregister_device(client);
 	}
+	mutex_unlock(&adap->userspace_clients_lock);
 
 	/* Detach any active clients. This can't fail, thus we do not
-	   checking the returned value. */
+	 * check the returned value. This is a two-pass process, because
+	 * we can't remove the dummy devices during the first pass: they
+	 * could have been instantiated by real devices wishing to clean
+	 * them up properly, so we give them a chance to do that first. */
 	res = device_for_each_child(&adap->dev, NULL, __unregister_client);
+	res = device_for_each_child(&adap->dev, NULL, __unregister_dummy);
 
 #ifdef CONFIG_I2C_COMPAT
 	class_compat_remove_link(i2c_adapter_compat_class, &adap->dev,
@@ -827,22 +1105,23 @@ EXPORT_SYMBOL(i2c_del_adapter);
 
 /* ------------------------------------------------------------------------- */
 
-static int __attach_adapter(struct device *dev, void *data)
+int i2c_for_each_dev(void *data, int (*fn)(struct device *, void *))
 {
-	struct i2c_adapter *adapter;
-	struct i2c_driver *driver = data;
-
-	if (dev->type != &i2c_adapter_type)
-		return 0;
-	adapter = to_i2c_adapter(dev);
+	int res;
 
-	i2c_detect(adapter, driver);
+	mutex_lock(&core_lock);
+	res = bus_for_each_dev(&i2c_bus_type, NULL, data, fn);
+	mutex_unlock(&core_lock);
 
-	/* Legacy drivers scan i2c busses directly */
-	if (driver->attach_adapter)
-		driver->attach_adapter(adapter);
+	return res;
+}
+EXPORT_SYMBOL_GPL(i2c_for_each_dev);
 
-	return 0;
+static int __process_new_driver(struct device *dev, void *data)
+{
+	if (dev->type != &i2c_adapter_type)
+		return 0;
+	return i2c_do_add_adapter(data, to_i2c_adapter(dev));
 }
 
 /*
@@ -869,45 +1148,29 @@ int i2c_register_driver(struct module *owner, struct i2c_driver *driver)
 	if (res)
 		return res;
 
+	/* Drivers should switch to dev_pm_ops instead. */
+	if (driver->suspend)
+		pr_warn("i2c-core: driver [%s] using legacy suspend method\n",
+			driver->driver.name);
+	if (driver->resume)
+		pr_warn("i2c-core: driver [%s] using legacy resume method\n",
+			driver->driver.name);
+
 	pr_debug("i2c-core: driver [%s] registered\n", driver->driver.name);
 
 	INIT_LIST_HEAD(&driver->clients);
 	/* Walk the adapters that are already present */
-	mutex_lock(&core_lock);
-	bus_for_each_dev(&i2c_bus_type, NULL, driver, __attach_adapter);
-	mutex_unlock(&core_lock);
+	i2c_for_each_dev(driver, __process_new_driver);
 
 	return 0;
 }
 EXPORT_SYMBOL(i2c_register_driver);
 
-static int __detach_adapter(struct device *dev, void *data)
+static int __process_removed_driver(struct device *dev, void *data)
 {
-	struct i2c_adapter *adapter;
-	struct i2c_driver *driver = data;
-	struct i2c_client *client, *_n;
-
 	if (dev->type != &i2c_adapter_type)
 		return 0;
-	adapter = to_i2c_adapter(dev);
-
-	/* Remove the devices we created ourselves as the result of hardware
-	 * probing (using a driver's detect method) */
-	list_for_each_entry_safe(client, _n, &driver->clients, detected) {
-		dev_dbg(&adapter->dev, "Removing %s at 0x%x\n",
-			client->name, client->addr);
-		list_del(&client->detected);
-		i2c_unregister_device(client);
-	}
-
-	if (driver->detach_adapter) {
-		if (driver->detach_adapter(adapter))
-			dev_err(&adapter->dev,
-				"detach_adapter failed for driver [%s]\n",
-				driver->driver.name);
-	}
-
-	return 0;
+	return i2c_do_del_adapter(data, to_i2c_adapter(dev));
 }
 
 /**
@@ -917,9 +1180,7 @@ static int __detach_adapter(struct device *dev, void *data)
  */
 void i2c_del_driver(struct i2c_driver *driver)
 {
-	mutex_lock(&core_lock);
-	bus_for_each_dev(&i2c_bus_type, NULL, driver, __detach_adapter);
-	mutex_unlock(&core_lock);
+	i2c_for_each_dev(driver, __process_removed_driver);
 
 	driver_unregister(&driver->driver);
 	pr_debug("i2c-core: driver [%s] unregistered\n", driver->driver.name);
@@ -928,21 +1189,6 @@ EXPORT_SYMBOL(i2c_del_driver);
 
 /* ------------------------------------------------------------------------- */
 
-static int __i2c_check_addr(struct device *dev, void *addrp)
-{
-	struct i2c_client	*client = i2c_verify_client(dev);
-	int			addr = *(int *)addrp;
-
-	if (client && client->addr == addr)
-		return -EBUSY;
-	return 0;
-}
-
-static int i2c_check_addr(struct i2c_adapter *adapter, int addr)
-{
-	return device_for_each_child(&adapter->dev, &addr, __i2c_check_addr);
-}
-
 /**
  * i2c_use_client - increments the reference count of the i2c client structure
  * @client: the client being referenced
@@ -1093,12 +1339,12 @@ int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 #endif
 
 		if (in_atomic() || irqs_disabled()) {
-			ret = mutex_trylock(&adap->bus_lock);
+			ret = i2c_trylock_adapter(adap);
 			if (!ret)
 				/* I2C activity is ongoing. */
 				return -EAGAIN;
 		} else {
-			mutex_lock_nested(&adap->bus_lock, adap->level);
+			i2c_lock_adapter(adap);
 		}
 
 		/* Retry automatically on arbitration loss */
@@ -1110,7 +1356,7 @@ int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 			if (time_after(jiffies, orig_jiffies + adap->timeout))
 				break;
 		}
-		mutex_unlock(&adap->bus_lock);
+		i2c_unlock_adapter(adap);
 
 		return ret;
 	} else {
@@ -1124,14 +1370,14 @@ EXPORT_SYMBOL(i2c_transfer);
  * i2c_master_send - issue a single I2C message in master transmit mode
  * @client: Handle to slave device
  * @buf: Data that will be written to the slave
- * @count: How many bytes to write
+ * @count: How many bytes to write, must be less than 64k since msg.len is u16
  *
  * Returns negative errno, or else the number of bytes written.
  */
-int i2c_master_send(struct i2c_client *client,const char *buf ,int count)
+int i2c_master_send(const struct i2c_client *client, const char *buf, int count)
 {
 	int ret;
-	struct i2c_adapter *adap=client->adapter;
+	struct i2c_adapter *adap = client->adapter;
 	struct i2c_msg msg;
 
 	msg.addr = client->addr;
@@ -1141,8 +1387,10 @@ int i2c_master_send(struct i2c_client *client,const char *buf ,int count)
 
 	ret = i2c_transfer(adap, &msg, 1);
 
-	/* If everything went ok (i.e. 1 msg transmitted), return #bytes
-	   transmitted, else error code. */
+	/*
+	 * If everything went ok (i.e. 1 msg transmitted), return #bytes
+	 * transmitted, else error code.
+	 */
 	return (ret == 1) ? count : ret;
 }
 EXPORT_SYMBOL(i2c_master_send);
@@ -1151,13 +1399,13 @@ EXPORT_SYMBOL(i2c_master_send);
  * i2c_master_recv - issue a single I2C message in master receive mode
  * @client: Handle to slave device
  * @buf: Where to store data read from slave
- * @count: How many bytes to read
+ * @count: How many bytes to read, must be less than 64k since msg.len is u16
  *
  * Returns negative errno, or else the number of bytes read.
  */
-int i2c_master_recv(struct i2c_client *client, char *buf ,int count)
+int i2c_master_recv(const struct i2c_client *client, char *buf, int count)
 {
-	struct i2c_adapter *adap=client->adapter;
+	struct i2c_adapter *adap = client->adapter;
 	struct i2c_msg msg;
 	int ret;
 
@@ -1169,8 +1417,10 @@ int i2c_master_recv(struct i2c_client *client, char *buf ,int count)
 
 	ret = i2c_transfer(adap, &msg, 1);
 
-	/* If everything went ok (i.e. 1 msg transmitted), return #bytes
-	   transmitted, else error code. */
+	/*
+	 * If everything went ok (i.e. 1 msg received), return #bytes received,
+	 * else error code.
+	 */
 	return (ret == 1) ? count : ret;
 }
 EXPORT_SYMBOL(i2c_master_recv);
@@ -1181,7 +1431,46 @@ EXPORT_SYMBOL(i2c_master_recv);
  * ----------------------------------------------------
  */
 
-static int i2c_detect_address(struct i2c_client *temp_client, int kind,
+/*
+ * Legacy default probe function, mostly relevant for SMBus. The default
+ * probe method is a quick write, but it is known to corrupt the 24RF08
+ * EEPROMs due to a state machine bug, and could also irreversibly
+ * write-protect some EEPROMs, so for address ranges 0x30-0x37 and 0x50-0x5f,
+ * we use a short byte read instead. Also, some bus drivers don't implement
+ * quick write, so we fallback to a byte read in that case too.
+ * On x86, there is another special case for FSC hardware monitoring chips,
+ * which want regular byte reads (address 0x73.) Fortunately, these are the
+ * only known chips using this I2C address on PC hardware.
+ * Returns 1 if probe succeeded, 0 if not.
+ */
+static int i2c_default_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	int err;
+	union i2c_smbus_data dummy;
+
+#ifdef CONFIG_X86
+	if (addr == 0x73 && (adap->class & I2C_CLASS_HWMON)
+	 && i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE_DATA))
+		err = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,
+				     I2C_SMBUS_BYTE_DATA, &dummy);
+	else
+#endif
+	if (!((addr & ~0x07) == 0x30 || (addr & ~0x0f) == 0x50)
+	 && i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK))
+		err = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_WRITE, 0,
+				     I2C_SMBUS_QUICK, NULL);
+	else if (i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE))
+		err = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,
+				     I2C_SMBUS_BYTE, &dummy);
+	else {
+		dev_warn(&adap->dev, "No suitable probing method supported\n");
+		err = -EOPNOTSUPP;
+	}
+
+	return err >= 0;
+}
+
+static int i2c_detect_address(struct i2c_client *temp_client,
 			      struct i2c_driver *driver)
 {
 	struct i2c_board_info info;
@@ -1190,32 +1479,25 @@ static int i2c_detect_address(struct i2c_client *temp_client, int kind,
 	int err;
 
 	/* Make sure the address is valid */
-	if (addr < 0x03 || addr > 0x77) {
+	err = i2c_check_addr_validity(addr);
+	if (err) {
 		dev_warn(&adapter->dev, "Invalid probe address 0x%02x\n",
 			 addr);
-		return -EINVAL;
+		return err;
 	}
 
 	/* Skip if already in use */
-	if (i2c_check_addr(adapter, addr))
+	if (i2c_check_addr_busy(adapter, addr))
 		return 0;
 
-	/* Make sure there is something at this address, unless forced */
-	if (kind < 0) {
-		if (i2c_smbus_xfer(adapter, addr, 0, 0, 0,
-				   I2C_SMBUS_QUICK, NULL) < 0)
-			return 0;
-
-		/* prevent 24RF08 corruption */
-		if ((addr & ~0x0f) == 0x50)
-			i2c_smbus_xfer(adapter, addr, 0, 0, 0,
-				       I2C_SMBUS_QUICK, NULL);
-	}
+	/* Make sure there is something at this address */
+	if (!i2c_default_probe(adapter, addr))
+		return 0;
 
 	/* Finally call the custom detection function */
 	memset(&info, 0, sizeof(struct i2c_board_info));
 	info.addr = addr;
-	err = driver->detect(temp_client, kind, &info);
+	err = driver->detect(temp_client, &info);
 	if (err) {
 		/* -ENODEV is returned if the detection fails. We catch it
 		   here as this isn't an error. */
@@ -1245,13 +1527,17 @@ static int i2c_detect_address(struct i2c_client *temp_client, int kind,
 
 static int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver)
 {
-	const struct i2c_client_address_data *address_data;
+	const unsigned short *address_list;
 	struct i2c_client *temp_client;
 	int i, err = 0;
 	int adap_id = i2c_adapter_id(adapter);
 
-	address_data = driver->address_data;
-	if (!driver->detect || !address_data)
+	address_list = driver->address_list;
+	if (!driver->detect || !address_list)
+		return 0;
+
+	/* Stop here if the classes do not match */
+	if (!(adapter->class & driver->class))
 		return 0;
 
 	/* Set up a temporary client to help detect callback */
@@ -1260,150 +1546,55 @@ static int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver)
 		return -ENOMEM;
 	temp_client->adapter = adapter;
 
-	/* Force entries are done first, and are not affected by ignore
-	   entries */
-	if (address_data->forces) {
-		const unsigned short * const *forces = address_data->forces;
-		int kind;
-
-		for (kind = 0; forces[kind]; kind++) {
-			for (i = 0; forces[kind][i] != I2C_CLIENT_END;
-			     i += 2) {
-				if (forces[kind][i] == adap_id
-				 || forces[kind][i] == ANY_I2C_BUS) {
-					dev_dbg(&adapter->dev, "found force "
-						"parameter for adapter %d, "
-						"addr 0x%02x, kind %d\n",
-						adap_id, forces[kind][i + 1],
-						kind);
-					temp_client->addr = forces[kind][i + 1];
-					err = i2c_detect_address(temp_client,
-						kind, driver);
-					if (err)
-						goto exit_free;
-				}
-			}
-		}
-	}
-
-	/* Stop here if the classes do not match */
-	if (!(adapter->class & driver->class))
-		goto exit_free;
-
-	/* Stop here if we can't use SMBUS_QUICK */
-	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_QUICK)) {
-		if (address_data->probe[0] == I2C_CLIENT_END
-		 && address_data->normal_i2c[0] == I2C_CLIENT_END)
-			goto exit_free;
-
-		dev_warn(&adapter->dev, "SMBus Quick command not supported, "
-			 "can't probe for chips\n");
-		err = -EOPNOTSUPP;
-		goto exit_free;
-	}
-
-	/* Probe entries are done second, and are not affected by ignore
-	   entries either */
-	for (i = 0; address_data->probe[i] != I2C_CLIENT_END; i += 2) {
-		if (address_data->probe[i] == adap_id
-		 || address_data->probe[i] == ANY_I2C_BUS) {
-			dev_dbg(&adapter->dev, "found probe parameter for "
-				"adapter %d, addr 0x%02x\n", adap_id,
-				address_data->probe[i + 1]);
-			temp_client->addr = address_data->probe[i + 1];
-			err = i2c_detect_address(temp_client, -1, driver);
-			if (err)
-				goto exit_free;
-		}
-	}
-
-	/* Normal entries are done last, unless shadowed by an ignore entry */
-	for (i = 0; address_data->normal_i2c[i] != I2C_CLIENT_END; i += 1) {
-		int j, ignore;
-
-		ignore = 0;
-		for (j = 0; address_data->ignore[j] != I2C_CLIENT_END;
-		     j += 2) {
-			if ((address_data->ignore[j] == adap_id ||
-			     address_data->ignore[j] == ANY_I2C_BUS)
-			 && address_data->ignore[j + 1]
-			    == address_data->normal_i2c[i]) {
-				dev_dbg(&adapter->dev, "found ignore "
-					"parameter for adapter %d, "
-					"addr 0x%02x\n", adap_id,
-					address_data->ignore[j + 1]);
-				ignore = 1;
-				break;
-			}
-		}
-		if (ignore)
-			continue;
-
+	for (i = 0; address_list[i] != I2C_CLIENT_END; i += 1) {
 		dev_dbg(&adapter->dev, "found normal entry for adapter %d, "
-			"addr 0x%02x\n", adap_id,
-			address_data->normal_i2c[i]);
-		temp_client->addr = address_data->normal_i2c[i];
-		err = i2c_detect_address(temp_client, -1, driver);
-		if (err)
-			goto exit_free;
+			"addr 0x%02x\n", adap_id, address_list[i]);
+		temp_client->addr = address_list[i];
+		err = i2c_detect_address(temp_client, driver);
+		if (unlikely(err))
+			break;
 	}
 
- exit_free:
 	kfree(temp_client);
 	return err;
 }
 
+int i2c_probe_func_quick_read(struct i2c_adapter *adap, unsigned short addr)
+{
+	return i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,
+			      I2C_SMBUS_QUICK, NULL) >= 0;
+}
+EXPORT_SYMBOL_GPL(i2c_probe_func_quick_read);
+
 struct i2c_client *
 i2c_new_probed_device(struct i2c_adapter *adap,
 		      struct i2c_board_info *info,
-		      unsigned short const *addr_list)
+		      unsigned short const *addr_list,
+		      int (*probe)(struct i2c_adapter *, unsigned short addr))
 {
 	int i;
 
-	/* Stop here if the bus doesn't support probing */
-	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE)) {
-		dev_err(&adap->dev, "Probing not supported\n");
-		return NULL;
-	}
+	if (!probe)
+		probe = i2c_default_probe;
 
 	for (i = 0; addr_list[i] != I2C_CLIENT_END; i++) {
 		/* Check address validity */
-		if (addr_list[i] < 0x03 || addr_list[i] > 0x77) {
+		if (i2c_check_addr_validity(addr_list[i]) < 0) {
 			dev_warn(&adap->dev, "Invalid 7-bit address "
 				 "0x%02x\n", addr_list[i]);
 			continue;
 		}
 
 		/* Check address availability */
-		if (i2c_check_addr(adap, addr_list[i])) {
+		if (i2c_check_addr_busy(adap, addr_list[i])) {
 			dev_dbg(&adap->dev, "Address 0x%02x already in "
 				"use, not probing\n", addr_list[i]);
 			continue;
 		}
 
-		/* Test address responsiveness
-		   The default probe method is a quick write, but it is known
-		   to corrupt the 24RF08 EEPROMs due to a state machine bug,
-		   and could also irreversibly write-protect some EEPROMs, so
-		   for address ranges 0x30-0x37 and 0x50-0x5f, we use a byte
-		   read instead. Also, some bus drivers don't implement
-		   quick write, so we fallback to a byte read it that case
-		   too. */
-		if ((addr_list[i] & ~0x07) == 0x30
-		 || (addr_list[i] & ~0x0f) == 0x50
-		 || !i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK)) {
-			union i2c_smbus_data data;
-
-			if (i2c_smbus_xfer(adap, addr_list[i], 0,
-					   I2C_SMBUS_READ, 0,
-					   I2C_SMBUS_BYTE, &data) >= 0)
-				break;
-		} else {
-			if (i2c_smbus_xfer(adap, addr_list[i], 0,
-					   I2C_SMBUS_WRITE, 0,
-					   I2C_SMBUS_QUICK, NULL) >= 0)
-				break;
-		}
+		/* Test address responsiveness */
+		if (probe(adap, addr_list[i]))
+			break;
 	}
 
 	if (addr_list[i] == I2C_CLIENT_END) {
@@ -1416,12 +1607,12 @@ i2c_new_probed_device(struct i2c_adapter *adap,
 }
 EXPORT_SYMBOL_GPL(i2c_new_probed_device);
 
-struct i2c_adapter* i2c_get_adapter(int id)
+struct i2c_adapter *i2c_get_adapter(int nr)
 {
 	struct i2c_adapter *adapter;
 
 	mutex_lock(&core_lock);
-	adapter = idr_find(&i2c_adapter_idr, id);
+	adapter = idr_find(&i2c_adapter_idr, nr);
 	if (adapter && !try_module_get(adapter->owner))
 		adapter = NULL;
 
@@ -1443,7 +1634,7 @@ static u8 crc8(u16 data)
 {
 	int i;
 
-	for(i = 0; i < 8; i++) {
+	for (i = 0; i < 8; i++) {
 		if (data & 0x8000)
 			data = data ^ POLY;
 		data = data << 1;
@@ -1456,7 +1647,7 @@ static u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)
 {
 	int i;
 
-	for(i = 0; i < count; i++)
+	for (i = 0; i < count; i++)
 		crc = crc8((crc ^ p[i]) << 8);
 	return crc;
 }
@@ -1504,7 +1695,7 @@ static int i2c_smbus_check_pec(u8 cpec, struct i2c_msg *msg)
  * This executes the SMBus "receive byte" protocol, returning negative errno
  * else the byte received from the device.
  */
-s32 i2c_smbus_read_byte(struct i2c_client *client)
+s32 i2c_smbus_read_byte(const struct i2c_client *client)
 {
 	union i2c_smbus_data data;
 	int status;
@@ -1524,9 +1715,9 @@ EXPORT_SYMBOL(i2c_smbus_read_byte);
  * This executes the SMBus "send byte" protocol, returning negative errno
  * else zero on success.
  */
-s32 i2c_smbus_write_byte(struct i2c_client *client, u8 value)
+s32 i2c_smbus_write_byte(const struct i2c_client *client, u8 value)
 {
-	return i2c_smbus_xfer(client->adapter,client->addr,client->flags,
+	return i2c_smbus_xfer(client->adapter, client->addr, client->flags,
 	                      I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);
 }
 EXPORT_SYMBOL(i2c_smbus_write_byte);
@@ -1539,7 +1730,7 @@ EXPORT_SYMBOL(i2c_smbus_write_byte);
  * This executes the SMBus "read byte" protocol, returning negative errno
  * else a data byte received from the device.
  */
-s32 i2c_smbus_read_byte_data(struct i2c_client *client, u8 command)
+s32 i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command)
 {
 	union i2c_smbus_data data;
 	int status;
@@ -1560,13 +1751,14 @@ EXPORT_SYMBOL(i2c_smbus_read_byte_data);
  * This executes the SMBus "write byte" protocol, returning negative errno
  * else zero on success.
  */
-s32 i2c_smbus_write_byte_data(struct i2c_client *client, u8 command, u8 value)
+s32 i2c_smbus_write_byte_data(const struct i2c_client *client, u8 command,
+			      u8 value)
 {
 	union i2c_smbus_data data;
 	data.byte = value;
-	return i2c_smbus_xfer(client->adapter,client->addr,client->flags,
-	                      I2C_SMBUS_WRITE,command,
-	                      I2C_SMBUS_BYTE_DATA,&data);
+	return i2c_smbus_xfer(client->adapter, client->addr, client->flags,
+			      I2C_SMBUS_WRITE, command,
+			      I2C_SMBUS_BYTE_DATA, &data);
 }
 EXPORT_SYMBOL(i2c_smbus_write_byte_data);
 
@@ -1578,7 +1770,7 @@ EXPORT_SYMBOL(i2c_smbus_write_byte_data);
  * This executes the SMBus "read word" protocol, returning negative errno
  * else a 16-bit unsigned "word" received from the device.
  */
-s32 i2c_smbus_read_word_data(struct i2c_client *client, u8 command)
+s32 i2c_smbus_read_word_data(const struct i2c_client *client, u8 command)
 {
 	union i2c_smbus_data data;
 	int status;
@@ -1599,13 +1791,14 @@ EXPORT_SYMBOL(i2c_smbus_read_word_data);
  * This executes the SMBus "write word" protocol, returning negative errno
  * else zero on success.
  */
-s32 i2c_smbus_write_word_data(struct i2c_client *client, u8 command, u16 value)
+s32 i2c_smbus_write_word_data(const struct i2c_client *client, u8 command,
+			      u16 value)
 {
 	union i2c_smbus_data data;
 	data.word = value;
-	return i2c_smbus_xfer(client->adapter,client->addr,client->flags,
-	                      I2C_SMBUS_WRITE,command,
-	                      I2C_SMBUS_WORD_DATA,&data);
+	return i2c_smbus_xfer(client->adapter, client->addr, client->flags,
+			      I2C_SMBUS_WRITE, command,
+			      I2C_SMBUS_WORD_DATA, &data);
 }
 EXPORT_SYMBOL(i2c_smbus_write_word_data);
 
@@ -1618,7 +1811,8 @@ EXPORT_SYMBOL(i2c_smbus_write_word_data);
  * This executes the SMBus "process call" protocol, returning negative errno
  * else a 16-bit unsigned "word" received from the device.
  */
-s32 i2c_smbus_process_call(struct i2c_client *client, u8 command, u16 value)
+s32 i2c_smbus_process_call(const struct i2c_client *client, u8 command,
+			   u16 value)
 {
 	union i2c_smbus_data data;
 	int status;
@@ -1646,7 +1840,7 @@ EXPORT_SYMBOL(i2c_smbus_process_call);
  * support this; its emulation through I2C messaging relies on a specific
  * mechanism (I2C_M_RECV_LEN) which may not be implemented.
  */
-s32 i2c_smbus_read_block_data(struct i2c_client *client, u8 command,
+s32 i2c_smbus_read_block_data(const struct i2c_client *client, u8 command,
 			      u8 *values)
 {
 	union i2c_smbus_data data;
@@ -1673,7 +1867,7 @@ EXPORT_SYMBOL(i2c_smbus_read_block_data);
  * This executes the SMBus "block write" protocol, returning negative errno
  * else zero on success.
  */
-s32 i2c_smbus_write_block_data(struct i2c_client *client, u8 command,
+s32 i2c_smbus_write_block_data(const struct i2c_client *client, u8 command,
 			       u8 length, const u8 *values)
 {
 	union i2c_smbus_data data;
@@ -1682,14 +1876,14 @@ s32 i2c_smbus_write_block_data(struct i2c_client *client, u8 command,
 		length = I2C_SMBUS_BLOCK_MAX;
 	data.block[0] = length;
 	memcpy(&data.block[1], values, length);
-	return i2c_smbus_xfer(client->adapter,client->addr,client->flags,
-			      I2C_SMBUS_WRITE,command,
-			      I2C_SMBUS_BLOCK_DATA,&data);
+	return i2c_smbus_xfer(client->adapter, client->addr, client->flags,
+			      I2C_SMBUS_WRITE, command,
+			      I2C_SMBUS_BLOCK_DATA, &data);
 }
 EXPORT_SYMBOL(i2c_smbus_write_block_data);
 
 /* Returns the number of read bytes */
-s32 i2c_smbus_read_i2c_block_data(struct i2c_client *client, u8 command,
+s32 i2c_smbus_read_i2c_block_data(const struct i2c_client *client, u8 command,
 				  u8 length, u8 *values)
 {
 	union i2c_smbus_data data;
@@ -1709,7 +1903,7 @@ s32 i2c_smbus_read_i2c_block_data(struct i2c_client *client, u8 command,
 }
 EXPORT_SYMBOL(i2c_smbus_read_i2c_block_data);
 
-s32 i2c_smbus_write_i2c_block_data(struct i2c_client *client, u8 command,
+s32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client, u8 command,
 				   u8 length, const u8 *values)
 {
 	union i2c_smbus_data data;
@@ -1726,10 +1920,10 @@ EXPORT_SYMBOL(i2c_smbus_write_i2c_block_data);
 
 /* Simulate a SMBus command using the i2c protocol
    No checking of parameters is done!  */
-static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,
-                                   unsigned short flags,
-                                   char read_write, u8 command, int size,
-                                   union i2c_smbus_data * data)
+static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
+				   unsigned short flags,
+				   char read_write, u8 command, int size,
+				   union i2c_smbus_data *data)
 {
 	/* So we need to generate a series of msgs. In the case of writing, we
 	  need to use only one message; when reading, we need two. We initialize
@@ -1737,7 +1931,7 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,
 	  simpler. */
 	unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];
 	unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];
-	int num = read_write == I2C_SMBUS_READ?2:1;
+	int num = read_write == I2C_SMBUS_READ ? 2 : 1;
 	struct i2c_msg msg[2] = { { addr, flags, 1, msgbuf0 },
 	                          { addr, flags | I2C_M_RD, 0, msgbuf1 }
 	                        };
@@ -1746,7 +1940,7 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,
 	int status;
 
 	msgbuf0[0] = command;
-	switch(size) {
+	switch (size) {
 	case I2C_SMBUS_QUICK:
 		msg[0].len = 0;
 		/* Special case: The read/write field is used as data */
@@ -1773,7 +1967,7 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,
 		if (read_write == I2C_SMBUS_READ)
 			msg[1].len = 2;
 		else {
-			msg[0].len=3;
+			msg[0].len = 3;
 			msgbuf0[1] = data->word & 0xff;
 			msgbuf0[2] = data->word >> 8;
 		}
@@ -1866,26 +2060,26 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,
 	}
 
 	if (read_write == I2C_SMBUS_READ)
-		switch(size) {
-			case I2C_SMBUS_BYTE:
-				data->byte = msgbuf0[0];
-				break;
-			case I2C_SMBUS_BYTE_DATA:
-				data->byte = msgbuf1[0];
-				break;
-			case I2C_SMBUS_WORD_DATA:
-			case I2C_SMBUS_PROC_CALL:
-				data->word = msgbuf1[0] | (msgbuf1[1] << 8);
-				break;
-			case I2C_SMBUS_I2C_BLOCK_DATA:
-				for (i = 0; i < data->block[0]; i++)
-					data->block[i+1] = msgbuf1[i];
-				break;
-			case I2C_SMBUS_BLOCK_DATA:
-			case I2C_SMBUS_BLOCK_PROC_CALL:
-				for (i = 0; i < msgbuf1[0] + 1; i++)
-					data->block[i] = msgbuf1[i];
-				break;
+		switch (size) {
+		case I2C_SMBUS_BYTE:
+			data->byte = msgbuf0[0];
+			break;
+		case I2C_SMBUS_BYTE_DATA:
+			data->byte = msgbuf1[0];
+			break;
+		case I2C_SMBUS_WORD_DATA:
+		case I2C_SMBUS_PROC_CALL:
+			data->word = msgbuf1[0] | (msgbuf1[1] << 8);
+			break;
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			for (i = 0; i < data->block[0]; i++)
+				data->block[i+1] = msgbuf1[i];
+			break;
+		case I2C_SMBUS_BLOCK_DATA:
+		case I2C_SMBUS_BLOCK_PROC_CALL:
+			for (i = 0; i < msgbuf1[0] + 1; i++)
+				data->block[i] = msgbuf1[i];
+			break;
 		}
 	return 0;
 }
@@ -1914,7 +2108,7 @@ s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,
 	flags &= I2C_M_TEN | I2C_CLIENT_PEC;
 
 	if (adapter->algo->smbus_xfer) {
-		mutex_lock(&adapter->bus_lock);
+		i2c_lock_adapter(adapter);
 
 		/* Retry automatically on arbitration loss */
 		orig_jiffies = jiffies;
@@ -1928,9 +2122,9 @@ s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,
 				       orig_jiffies + adapter->timeout))
 				break;
 		}
-		mutex_unlock(&adapter->bus_lock);
+		i2c_unlock_adapter(adapter);
 	} else
-		res = i2c_smbus_xfer_emulated(adapter,addr,flags,read_write,
+		res = i2c_smbus_xfer_emulated(adapter, addr, flags, read_write,
 					      command, protocol, data);
 
 	return res;
diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h
index a2c819d..1ffdb98 100644
--- a/include/linux/cpumask.h
+++ b/include/linux/cpumask.h
@@ -764,6 +764,12 @@ static inline const struct cpumask *get_cpu_mask(unsigned int cpu)
  *
  */
 #ifndef CONFIG_DISABLE_OBSOLETE_CPUMASK_FUNCTIONS
+/* These strip const, as traditionally they weren't const. */
+#define cpu_possible_map	(*(cpumask_t *)cpu_possible_mask)
+#define cpu_online_map		(*(cpumask_t *)cpu_online_mask)
+#define cpu_present_map		(*(cpumask_t *)cpu_present_mask)
+#define cpu_active_map		(*(cpumask_t *)cpu_active_mask)
+
 #define cpumask_of_cpu(cpu) (*get_cpu_mask(cpu))
 
 #define CPU_MASK_LAST_WORD BITMAP_LAST_WORD_MASK(NR_CPUS)
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d16d300..3b7e2b6 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -44,7 +44,10 @@
 #define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
 #define PORT_OCTEON	17	/* Cavium OCTEON internal UART */
 #define PORT_AR7	18	/* Texas Instruments AR7 internal UART */
-#define PORT_MAX_8250	18	/* max port ID */
+#define PORT_U6_16550A	19	/* ST-Ericsson U6xxx internal UART */
+#define PORT_TEGRA	20	/* NVIDIA Tegra internal UART */
+#define PORT_XR17D15X	21	/* Exar XR17D15x UART */
+#define PORT_MAX_8250	21	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
@@ -94,7 +97,7 @@
 /* PPC CPM type number */
 #define PORT_CPM        58
 
-/* MPC52xx type numbers */
+/* MPC52xx (and MPC512x) type numbers */
 #define PORT_MPC52xx	59
 
 /* IBM icom */
@@ -179,6 +182,37 @@
 /* BCM63xx family SoCs */
 #define PORT_BCM63XX	89
 
+/* Aeroflex Gaisler GRLIB APBUART */
+#define PORT_APBUART    90
+
+/* Altera UARTs */
+#define PORT_ALTERA_JTAGUART	91
+#define PORT_ALTERA_UART	92
+
+/* SH-SCI */
+#define PORT_SCIFB	93
+
+/* MAX3107 */
+#define PORT_MAX3107	94
+
+/* High Speed UART for Medfield */
+#define PORT_MFD	95
+
+/* TI OMAP-UART */
+#define PORT_OMAP	96
+
+/* VIA VT8500 SoC */
+#define PORT_VT8500	97
+
+/* Xilinx PSS UART */
+#define PORT_XUARTPS	98
+
+/* Atheros AR933X SoC */
+#define PORT_AR933X	99
+
+/* Energy Micro efm32 SoC */
+#define PORT_EFMUART   100
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
@@ -189,6 +223,7 @@
 #include <linux/tty.h>
 #include <linux/mutex.h>
 #include <linux/sysrq.h>
+#include <linux/pps_kernel.h>
 
 struct uart_port;
 struct serial_struct;
@@ -213,7 +248,7 @@ struct uart_ops {
 	void		(*flush_buffer)(struct uart_port *);
 	void		(*set_termios)(struct uart_port *, struct ktermios *new,
 				       struct ktermios *old);
-	void		(*set_ldisc)(struct uart_port *);
+	void		(*set_ldisc)(struct uart_port *, int new);
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
@@ -243,6 +278,7 @@ struct uart_ops {
 #endif
 };
 
+#define NO_POLL_CHAR		0x00ff0000
 #define UART_CONFIG_TYPE	(1 << 0)
 #define UART_CONFIG_IRQ		(1 << 1)
 
@@ -268,6 +304,13 @@ struct uart_port {
 	unsigned char __iomem	*membase;		/* read/write[bwl] */
 	unsigned int		(*serial_in)(struct uart_port *, int);
 	void			(*serial_out)(struct uart_port *, int, int);
+	void			(*set_termios)(struct uart_port *,
+				               struct ktermios *new,
+				               struct ktermios *old);
+	int			(*handle_irq)(struct uart_port *);
+	void			(*pm)(struct uart_port *, unsigned int state,
+				      unsigned int old);
+	void			(*handle_break)(struct uart_port *);
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */
@@ -283,9 +326,7 @@ struct uart_port {
 #define UPIO_MEM32		(3)
 #define UPIO_AU			(4)			/* Au1x00 type IO */
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
-#define UPIO_DWAPB		(6)			/* DesignWare APB UART */
-#define UPIO_RM9000		(7)			/* RM9000 type IO */
-#define UPIO_DWAPB32		(8)			/* DesignWare APB UART (32 bit accesses) */
+#define UPIO_RM9000		(6)			/* RM9000 type IO */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */
@@ -316,6 +357,8 @@ struct uart_port {
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
+#define UPF_EXAR_EFR		((__force upf_t) (1 << 25))
+#define UPF_BUG_THRE		((__force upf_t) (1 << 26))
 /* The exact UART type is known and should not be probed.  */
 #define UPF_FIXED_TYPE		((__force upf_t) (1 << 27))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
@@ -336,10 +379,24 @@ struct uart_port {
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
+	unsigned char		irq_wake;
 	unsigned char		unused[2];
 	void			*private_data;		/* generic platform data pointer */
+#ifdef CONFIG_CONSOLE_POLL
+	int		(*poll_rx_cb)(u8);
+#endif
 };
 
+static inline int serial_port_in(struct uart_port *up, int offset)
+{
+	return up->serial_in(up, offset);
+}
+
+static inline void serial_port_out(struct uart_port *up, int offset, int value)
+{
+	up->serial_out(up, offset, value);
+}
+
 /*
  * This is the state information which is persistent across opens.
  */
@@ -349,7 +406,6 @@ struct uart_state {
 	int			pm_state;
 	struct circ_buf		xmit;
 
-	struct tasklet_struct	tlet;
 	struct uart_port	*uart_port;
 };
 
@@ -391,6 +447,14 @@ unsigned int uart_get_baud_rate(struct uart_port *port, struct ktermios *termios
 				unsigned int max);
 unsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);
 
+/* Base timer interval for polling */
+static inline int uart_poll_timeout(struct uart_port *port)
+{
+	int timeout = port->timeout;
+
+	return timeout > 6 ? (timeout / 2 - 2) : 1;
+}
+
 /*
  * Console helpers.
  */
@@ -440,23 +504,31 @@ static inline int uart_tx_stopped(struct uart_port *port)
 /*
  * The following are helper functions for the low level drivers.
  */
+
+extern void uart_handle_dcd_change(struct uart_port *uport,
+		unsigned int status);
+extern void uart_handle_cts_change(struct uart_port *uport,
+		unsigned int status);
+
+extern void uart_insert_char(struct uart_port *port, unsigned int status,
+		 unsigned int overrun, unsigned int ch, unsigned int flag);
+
+#ifdef SUPPORT_SYSRQ
 static inline int
 uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 {
-#ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch, port->state->port.tty);
+			handle_sysrq(ch);
 			port->sysrq = 0;
 			return 1;
 		}
 		port->sysrq = 0;
 	}
-#endif
 	return 0;
 }
-#ifndef SUPPORT_SYSRQ
-#define uart_handle_sysrq_char(port,ch) uart_handle_sysrq_char(port, 0)
+#else
+#define uart_handle_sysrq_char(port,ch) ({ (void)port; 0; })
 #endif
 
 /*
@@ -465,6 +537,10 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 static inline int uart_handle_break(struct uart_port *port)
 {
 	struct uart_state *state = port->state;
+
+	if (port->handle_break)
+		port->handle_break(port);
+
 #ifdef SUPPORT_SYSRQ
 	if (port->cons && port->cons->index == port->line) {
 		if (!port->sysrq) {
@@ -479,80 +555,6 @@ static inline int uart_handle_break(struct uart_port *port)
 	return 0;
 }
 
-/**
- *	uart_handle_dcd_change - handle a change of carrier detect state
- *	@uport: uart_port structure for the open port
- *	@status: new carrier detect status, nonzero if active
- */
-static inline void
-uart_handle_dcd_change(struct uart_port *uport, unsigned int status)
-{
-	struct uart_state *state = uport->state;
-	struct tty_port *port = &state->port;
-
-	uport->icount.dcd++;
-
-#ifdef CONFIG_HARD_PPS
-	if ((uport->flags & UPF_HARDPPS_CD) && status)
-		hardpps();
-#endif
-
-	if (port->flags & ASYNC_CHECK_CD) {
-		if (status)
-			wake_up_interruptible(&port->open_wait);
-		else if (port->tty)
-			tty_hangup(port->tty);
-	}
-}
-
-/**
- *	uart_handle_cts_change - handle a change of clear-to-send state
- *	@uport: uart_port structure for the open port
- *	@status: new clear to send status, nonzero if active
- */
-static inline void
-uart_handle_cts_change(struct uart_port *uport, unsigned int status)
-{
-	struct tty_port *port = &uport->state->port;
-	struct tty_struct *tty = port->tty;
-
-	uport->icount.cts++;
-
-	if (port->flags & ASYNC_CTS_FLOW) {
-		if (tty->hw_stopped) {
-			if (status) {
-				tty->hw_stopped = 0;
-				uport->ops->start_tx(uport);
-				uart_write_wakeup(uport);
-			}
-		} else {
-			if (!status) {
-				tty->hw_stopped = 1;
-				uport->ops->stop_tx(uport);
-			}
-		}
-	}
-}
-
-#include <linux/tty_flip.h>
-
-static inline void
-uart_insert_char(struct uart_port *port, unsigned int status,
-		 unsigned int overrun, unsigned int ch, unsigned int flag)
-{
-	struct tty_struct *tty = port->state->port.tty;
-
-	if ((status & port->ignore_status_mask & ~overrun) == 0)
-		tty_insert_flip_char(tty, ch, flag);
-
-	/*
-	 * Overrun is special.  Since it's reported immediately,
-	 * it doesn't affect the current character.
-	 */
-	if (status & ~port->ignore_status_mask & overrun)
-		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
-}
-
 /*
  *	UART_ENABLE_MS - determine if port should enable modem status irqs
  */
diff --git a/kernel/time/clockevents.c b/kernel/time/clockevents.c
index fddbaa8..7e1ce01 100644
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@ -18,6 +18,8 @@
 #include <linux/notifier.h>
 #include <linux/smp.h>
 
+#include "tick-internal.h"
+
 /* The registered clock event devices */
 static LIST_HEAD(clockevent_devices);
 static LIST_HEAD(clockevents_released);
-- 
1.7.10.4

