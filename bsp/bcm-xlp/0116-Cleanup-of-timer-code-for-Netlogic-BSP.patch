From 8cee3fba0156367a1aaf365ba67bb3adde418a26 Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Fri, 9 Jul 2010 19:28:31 +0530
Subject: [PATCH 116/762] Cleanup of timer code for Netlogic BSP

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/kernel/sync-r4k.c |   26 --------------------------
 include/linux/mm.h          |    5 -----
 2 files changed, 0 insertions(+), 31 deletions(-)

diff --git a/arch/mips/kernel/sync-r4k.c b/arch/mips/kernel/sync-r4k.c
index debc309..99f913c 100644
--- a/arch/mips/kernel/sync-r4k.c
+++ b/arch/mips/kernel/sync-r4k.c
@@ -13,9 +13,6 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irqflags.h>
-#ifdef CONFIG_NLM_COMMON
-#include <linux/smp.h>
-#endif
 #include <linux/cpumask.h>
 
 #include <asm/r4k-timer.h>
@@ -31,10 +28,6 @@ static atomic_t __cpuinitdata count_reference = ATOMIC_INIT(0);
 #define COUNTON	100
 #define NR_LOOPS 5
 
-#ifdef CONFIG_NLM_COMMON
-unsigned int count_after_sync[NR_CPUS];
-#endif
-
 void __cpuinit synchronise_count_master(void)
 {
 	int i;
@@ -90,16 +83,8 @@ void __cpuinit synchronise_count_master(void)
 		/*
 		 * Everyone initialises count in the last loop:
 		 */
-#ifdef CONFIG_NLM_COMMON
-		if (i == NR_LOOPS-1) {
-			write_c0_count(initcount);
-			count_after_sync[0] = read_c0_count();
-			smp_wmb();
-		}
-#else
 		if (i == NR_LOOPS-1)
 			write_c0_count(initcount);
-#endif
 
 		/*
 		 * Wait for all slaves to leave the synchronization point:
@@ -129,9 +114,6 @@ void __cpuinit synchronise_count_slave(void)
 	unsigned long flags;
 	unsigned int initcount;
 	int ncpus;
-#ifdef CONFIG_NLM_COMMON
-	int cpu = smp_processor_id();
-#endif
 
 #ifdef CONFIG_MIPS_MT_SMTC
 	/*
@@ -163,16 +145,8 @@ void __cpuinit synchronise_count_slave(void)
 		/*
 		 * Everyone initialises count in the last loop:
 		 */
-#ifdef CONFIG_NLM_COMMON
-		if (i == NR_LOOPS-1) {
-			write_c0_count(initcount);
-			count_after_sync[cpu] = read_c0_count();
-			smp_wmb();
-		}
-#else
 		if (i == NR_LOOPS-1)
 			write_c0_count(initcount);
-#endif
 
 		atomic_inc(&count_count_stop);
 		while (atomic_read(&count_count_stop) != ncpus)
diff --git a/include/linux/mm.h b/include/linux/mm.h
index ca09ca6..441a564 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1421,13 +1421,8 @@ int write_one_page(struct page *page, int wait);
 void task_dirty_inc(struct task_struct *tsk);
 
 /* readahead.c */
-#ifndef CONFIG_NLM_NAS
 #define VM_MAX_READAHEAD	128	/* kbytes */
 #define VM_MIN_READAHEAD	16	/* kbytes (includes current page) */
-#else
-#define VM_MAX_READAHEAD	1024	/* kbytes */
-#define VM_MIN_READAHEAD	32	/* kbytes (includes current page) */
-#endif
 
 int force_page_cache_readahead(struct address_space *mapping, struct file *filp,
 			pgoff_t offset, unsigned long nr_to_read);
-- 
1.7.0.4

