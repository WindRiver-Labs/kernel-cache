From cb3218e2e92ea6428a493c02ea1897557a35a130 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 22 Apr 2013 17:27:53 +0800
Subject: [PATCH 554/761] XLP base port: xlp2xx support

o fix disable/enable pgwalker since the register to access is different
o hook out with external visible flags to enable/disable fixed TLB
o support variable fixed tlb page size
o use XLP8xx style PTE format by default
o	boot the 2nd core and compute frequency correctly

Based on Broadcom SDK 2.3.

Signed-off-by: Jayanthi A <jayanthi.annadurai@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/pgwalker.h |    1 +
 arch/mips/include/asm/mach-netlogic/xlp-mmu.h  |   30 ++++++--
 arch/mips/include/asm/netlogic/xlp.h           |    1 +
 arch/mips/kernel/setup.c                       |   10 +++
 arch/mips/netlogic/xlp/cpu_control.c           |   30 ++++++--
 arch/mips/netlogic/xlp/cpu_control_asm.S       |    8 +-
 arch/mips/netlogic/xlp/mmu.c                   |   96 ++++++++++--------------
 7 files changed, 101 insertions(+), 75 deletions(-)

diff --git a/arch/mips/include/asm/mach-netlogic/pgwalker.h b/arch/mips/include/asm/mach-netlogic/pgwalker.h
index 29c5659..326a350 100644
--- a/arch/mips/include/asm/mach-netlogic/pgwalker.h
+++ b/arch/mips/include/asm/mach-netlogic/pgwalker.h
@@ -6,6 +6,7 @@
 #define PGW_REGS_BLOCK 4
 
 enum {
+	PGW_MMU_SETUP = 0x0,
 	PGW_MMU_INFO = 0x10,
 	PGW_PGD_BASES,
 	PGW_PGD_SHIFT,
diff --git a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
index 48293d7..d08de67 100644
--- a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
+++ b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
@@ -4,6 +4,7 @@
 #include <linux/percpu.h>
 #include <asm/mipsregs.h>
 #include <asm/netlogic/xlp8xx/cpu_control_macros.h>
+#include <asm/mach-netlogic/pgwalker.h>
 
 /* 
  * These numbers correspond to Cop0 Config6 reg 
@@ -24,6 +25,7 @@
 #define VMALLOC_SEG 1
 #endif /* CONFIG_64BIT */
 
+extern int is_cpu_core_xlp_ii;
 extern DEFINE_PER_CPU(unsigned long [NR_ADDR_SEGMENTS], pgd_bases);
 
 extern uint32_t nlm_l1_lock[NR_CPUS/4];
@@ -139,11 +141,27 @@ static __inline__ void pipeline_flush(void)
 }
 
 #define disable_pgwalker(flags)						\
-	({ flags = read_c0_config6();					\
-		pipeline_flush(); write_c0_config6(read_c0_config6() & ~ENABLE_PGWALKER); pipeline_flush();})
-
-#define enable_pgwalker(flags)						\
-	({ write_c0_config6(read_c0_config6() | (flags & ENABLE_PGWALKER)); })
-
+	({                                                              \
+           if (!is_cpu_core_xlp_ii) {					\
+		flags = read_c0_config6();                              \
+		pipeline_flush();                                       \
+		write_c0_config6(flags & ~ENABLE_PGWALKER);             \
+		pipeline_flush();                                       \
+ 	   }else {                                                      \
+	   flags = read_c0_pwctl();                                     \
+                pipeline_flush();                                       \
+                write_c0_pwctl(flags & ~(1 <<  PWCTL_PW_EN_O));         \
+                pipeline_flush();                                       \
+	   }                                                            \
+	})
+
+#define enable_pgwalker(flags)                                                	  	\
+        ({                                                                     		\
+            if (!is_cpu_core_xlp_ii) {                                         		\
+                write_c0_config6(read_c0_config6() | (flags | ENABLE_PGWALKER));	\
+            } else {                                                            	\
+                write_c0_pwctl(read_c0_pwctl() | (flags & (1 << PWCTL_PW_EN_O)));       \
+            }                                                 		                \
+        })
 
 #endif
diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index be9f411..7d26297 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -84,4 +84,5 @@ extern cpumask_t phys_cpu_present_map;
 
 extern char cpu_model_info[MAX_CPU_REV_LEN];
 extern char* get_cpu_info(void);
+extern int is_cpu_core_xlp_ii;
 #endif /*_ASM_XLP_H */ 
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index a9029bf..d3dfcbd 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -44,6 +44,7 @@ the header of the original work apply to this derived work.
 #ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/debug.h>
 #include <asm/mach-netlogic/mmu.h>
+#include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
 #endif /* CONFIG_NLM_XLP */
 
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
@@ -70,6 +71,12 @@ unsigned long mips_machtype __read_mostly = MACH_UNKNOWN;
 
 EXPORT_SYMBOL(mips_machtype);
 
+/* A flag to indicate the the cpu core is XLP-II.
+   A variable is used since later on it is used in macros.
+ */
+int is_cpu_core_xlp_ii = 0;
+
+
 struct boot_mem_map boot_mem_map;
 
 static char __initdata command_line[COMMAND_LINE_SIZE];
@@ -646,6 +653,9 @@ static void __init resource_init(void)
 
 void __init setup_arch(char **cmdline_p)
 {
+        /* the variable later on will be used in macros as well */
+        is_cpu_core_xlp_ii = is_nlm_xlp2xx();
+
 	cpu_probe();
 	prom_init();
 
diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index bba5f5e..3f95734 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -101,6 +101,9 @@ static inline void config_lsu(void)
 			"lui     %2, 0x4080\n"
 			"or      %1, %1, %2\n"
 			"mtcr    %1, %0\n"
+			"li      %0, "STR(SCHED_DEFEATURE)"\n"
+                        "lui     %1, 0x0100\n"
+                        "mtcr    %1, %0\n"
 			".set pop\n"
 			: "=r" (tmp0), "=r" (tmp1), "=r" (tmp2)
 		);
@@ -125,6 +128,12 @@ static void enable_cores(unsigned int node, unsigned int cores_bitmap)
 
 		if ( (cbitmap & core) == 0) continue;
 
+                if (!is_cpu_core_xlp_ii) {
+                        /* Enable CPU clock: only needed for xlp8xx/xlp3xx */
+                        value = nlm_hal_read_32bit_reg(sys_mmio,0x4E) & ~core;
+                        nlm_hal_write_32bit_reg(sys_mmio, 0x4E, value);
+                }
+
 		/* Enable CPU clock
 		 */
 		value = nlm_hal_read_32bit_reg(sys_mmio,0x4E) & ~core;
@@ -264,16 +273,21 @@ u32 get_cpu_freq(int cpu_num)
 	mmio = (volatile u32 *) cpu_io_mmio(cpu_num/32,SYS);
 
 	pwron_rst_reg = nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_POWERONRESETCFG);
-	core_dfs      = nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_COREDFSDIVCTRL);
-	core          = cpu_num >> 2;
+        if (!is_cpu_core_xlp_ii) {
+                core_dfs      = nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_COREDFSDIVCTRL);
+                core          = cpu_num >> 2;
 
-	divf = SYS_PWRON_DIVF(pwron_rst_reg);
-	divr = SYS_PWRON_DIVR(pwron_rst_reg);
-	ext_div = SYS_PWRON_EXTDIV(pwron_rst_reg) + 1;
-	dfs  = SYS_CORE_DFS(core_dfs,core) + 1;
+                divf = SYS_PWRON_DIVF(pwron_rst_reg);
+                divr = SYS_PWRON_DIVR(pwron_rst_reg);
+                ext_div = SYS_PWRON_EXTDIV(pwron_rst_reg) + 1;
+                dfs  = SYS_CORE_DFS(core_dfs,core) + 1;
 
-	pll_freq = get_pll_freq(divf,divr);
-	do_div( pll_freq, ((uint64_t)(ext_div * dfs)));
+                pll_freq = get_pll_freq(divf,divr);
+                do_div( pll_freq, ((uint64_t)(ext_div * dfs)));
+	}
+	else {
+		pll_freq = (400 + 33 * (pwron_rst_reg >> 26)) * 1024 * 1024ULL;
+	}
 	return ((u32) pll_freq);
 }
 
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index e1a31ae..5c01250 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -85,6 +85,10 @@
 	.set noreorder
 	li      t0, LSU_DEFEATURE
 
+        li      t0, SCHED_DEFEATURE
+        lui     t1, 0x0100 # Experimental: Disable BRU accepting ALU ops
+        mtcr    t1, t0
+
 	mfcr    t1, t0
 	lui     t2, 0x4080  # Enable Unaligned Access, L2HPE
 	or      t1, t1, t2
@@ -99,10 +103,6 @@
 	and	t1, t1, t2
 	mtcr    t1, t0
 
-	li      t0, SCHED_DEFEATURE
-	lui     t1, 0x0100 # Experimental: Disable BRU accepting ALU ops
-	mtcr    t1, t0
-
 10:
 
 	.set pop
diff --git a/arch/mips/netlogic/xlp/mmu.c b/arch/mips/netlogic/xlp/mmu.c
index a7bb028..73dfe17 100644
--- a/arch/mips/netlogic/xlp/mmu.c
+++ b/arch/mips/netlogic/xlp/mmu.c
@@ -37,7 +37,7 @@
 
 #define _PMD_T_LOG2 3
 
-static int __initdata tlb_config = (ENABLE_ETLB | ENABLE_128_TLB | ENABLE_PGWALKER);
+static int __cpuinitdata tlb_config = (ENABLE_ETLB | ENABLE_128_TLB | ENABLE_PGWALKER);
 
 int __init disable_etlb(char *str)
 {
@@ -74,14 +74,7 @@ static int pgtable_levels = PGD | PMD | PTE;
 static int pgtable_levels = PGD | PTE;
 #endif
 
-static int is_hwpw_mips_compliant(uint32_t proc_id)
-{
-	return  (proc_id == CHIP_PROCESSOR_ID_XLP_2XX) ||
-		(proc_id == CHIP_PROCESSOR_ID_XLP_1XX) ||
-		(proc_id == CHIP_PROCESSOR_ID_XLP_9XX);
-}
-
-static void pgwalker_init(void)
+static void __cpuinit pgwalker_init(void)
 {
 	unsigned int value;
 	int i = 0;
@@ -230,23 +223,27 @@ void dump_pgwalker_config(void)
 	int i = 0;
 	uint64_t pwbase_val = 0, pwfield_val = 0, pwsize_val = 0;
 	uint32_t pwctl_val = 0;
-	int hwpw_mips_compliant = is_hwpw_mips_compliant(get_proc_id());
-
-	pgw_print_w(PGW_MMU_INFO);
-	pgw_print_w(PGW_PGD_SHIFT);
-	pgw_print_w(PGW_PGD_MASK);
-	pgw_print_w(PGW_PMD_SHIFT);
-	pgw_print_w(PGW_PMD_MASK);
-	pgw_print_w(PGW_PTE_SHIFT);
-	pgw_print_w(PGW_PTE_MASK);
-	pgw_print_w(PGW_PUD_SHIFT);
-	pgw_print_w(PGW_PUD_MASK);
+
+	if (!is_cpu_core_xlp_ii) {
+		pgw_print_w(PGW_MMU_INFO);
+		pgw_print_w(PGW_PGD_SHIFT);
+		pgw_print_w(PGW_PGD_MASK);
+		pgw_print_w(PGW_PMD_SHIFT);
+		pgw_print_w(PGW_PMD_MASK);
+		pgw_print_w(PGW_PTE_SHIFT);
+		pgw_print_w(PGW_PTE_MASK);
+		pgw_print_w(PGW_PUD_SHIFT);
+		pgw_print_w(PGW_PUD_MASK);
+	}
+	else {
+		pgw_print_w(PGW_MMU_SETUP);
+	}
 
 	printk("swapper_pg_dir = %lx\n", (unsigned long)swapper_pg_dir);
 	for(i = 0; i < NR_ADDR_SEGMENTS; i++) {
 		printk("pgd_bases[%d] = 0x%lx\n", i, __get_cpu_var(pgd_bases)[i]);
 	}
-	if (hwpw_mips_compliant) {
+	if (is_cpu_core_xlp_ii) {
 		pwbase_val = read_c0_pwbase();
 		pwfield_val = read_c0_pwfield();
 		pwsize_val = read_c0_pwsize();
@@ -262,56 +259,42 @@ void dump_pgwalker_config(void)
 #ifdef CONFIG_NLM_XLP
 static void pgwalker_workaround_setup(void)
 {
-	uint32_t prid, chip_id, rev_id;
-
-	prid = read_c0_prid();
-	chip_id = (prid >> 8) & 0xff;
-	rev_id  = prid & 0xff;
-
-	/* Disable hardware page walker for XLP A0/1/2 chips (832-408),
-	 * Revision A0/A1/A2 chips.
-	 */
-	if (chip_id == CHIP_PROCESSOR_ID_XLP_8XX || chip_id == CHIP_PROCESSOR_ID_XLP_832
-	|| chip_id == CHIP_PROCESSOR_ID_XLP_816 || chip_id == CHIP_PROCESSOR_ID_XLP_432
-	|| chip_id == CHIP_PROCESSOR_ID_XLP_416 || chip_id == CHIP_PROCESSOR_ID_XLP_408) {
-		if (rev_id == XLP_REVISION_A0 || rev_id == XLP_REVISION_A1
-			|| rev_id == XLP_REVISION_A2)
-			tlb_config &= ~ENABLE_PGWALKER;
-	}
+        /* Disable hardware page walker for XLP A0/1/2, revision A0/A1/A2 chips. */
+        if (is_nlm_xlp8xx_ax())
+                tlb_config &= ~ENABLE_PGWALKER;
 }
 #else
 static void pgwalker_workaround_setup(void) {}
 #endif
 
-void mmu_init(void)
+void __cpuinit mmu_init(void)
 {
 	uint32_t config4_val = 0;
-	uint32_t proc_id = get_proc_id();
-	int hwpw_mips_compliant = is_hwpw_mips_compliant(proc_id);
 
 	/* For XLP832 A0-A2 chips, the page walker needs to be shutdown to
 	 * prevent potential errors.
 	 */
 	pgwalker_workaround_setup();
 
-	/*
-	 * shift right half the number of 1s in
-	 * the pagemask and populate that value
-	 */
-	write_c0_config7(PM_DEFAULT_MASK >> (13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
-
-#ifdef DEBUG
-	printk(KERN_INFO "( %s ): write_c0_config7 = %d\n", __FUNCTION__,
-		   read_c0_config7());
-#endif
-
-	if (hwpw_mips_compliant) {
+	if (is_cpu_core_xlp_ii) {
 		/* set config4 to use 64KB page */
 		config4_val = read_c0_config4();
 		config4_val &= ~(((uint32_t)0x1f) << CFG4_FTLBPAGESIZE_O); /*clear 5-bit width field*/
-		config4_val |= ((uint32_t)0x3) << CFG4_FTLBPAGESIZE_O; /* 64KB page */
+		config4_val |= ((PAGE_SHIFT - 10) >> 1) << CFG4_FTLBPAGESIZE_O;
 		write_c0_config4(config4_val);
 	}
+        else {
+                /*
+                * shift right half the number of 1s in
+                * the pagemask and populate that value
+                */
+                write_c0_config7(PM_DEFAULT_MASK >> (13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
+
+#ifdef DEBUG
+                printk(KERN_INFO "( %s ): write_c0_config7 = %d\n", __FUNCTION__,
+                        read_c0_config7());
+#endif
+        }
 
 #ifdef CONFIG_EXEC_INHIBIT
 	pagegrain_write(pagegrain_read() | EXEC_INHIBIT);
@@ -321,17 +304,16 @@ void mmu_init(void)
 	pagegrain_write(pagegrain_read() | READ_INHIBIT);
 #endif
 
-	if (hwpw_mips_compliant) {
+	if (is_cpu_core_xlp_ii) {
 		pgwalker_init_mips_compliant();
 	} else {
 		pgwalker_init();
+		/* Intialize after pgwalker and others are configured! */
+	        write_c0_config6(read_c0_config6() | tlb_config);
 	}
 	tlbstats_init();
 	entrylo0_mask_init();
 
-	/* Intialize after pgwalker and others are configured! */
-	write_c0_config6(read_c0_config6() | tlb_config);
-
 	/*
 	 * Read back TLB entries after configuration
 	 */
-- 
1.7.10.4

