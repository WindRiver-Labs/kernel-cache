From 36907e88f46ae325ed57df6c6351f418bc103707 Mon Sep 17 00:00:00 2001
From: Krishnamurthy Vasanthrao Daulatabad <krishnad@broadcom.com>
Date: Fri, 21 Sep 2012 04:23:58 -0700
Subject: [PATCH 729/762] bcm_xlp: SAE: crypto: Adding new APIs

	nlmcrypto_msg.h - api to do stateless do op
	nlmcrypto.h - api to modify packet descriptor elements
              	    - api to add designer freeback descriptor
Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy Vasanthrao Daulatabad <krishnad@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/crypto/sae/cryptoapi.c     |   21 ++++-
 drivers/crypto/sae/cryptodev.h     |   10 --
 drivers/crypto/sae/nlmcrypto.h     |  196 +++++++++++++++++++++++++++++++++++-
 drivers/crypto/sae/nlmcrypto_msg.h |  142 ++++++++++++++++++++++++++
 4 files changed, 356 insertions(+), 13 deletions(-)
 mode change 100644 => 100755 drivers/crypto/sae/nlmcrypto.h
 create mode 100755 drivers/crypto/sae/nlmcrypto_msg.h

diff --git a/drivers/crypto/sae/cryptoapi.c b/drivers/crypto/sae/cryptoapi.c
index 19457bf..91ca386 100644
--- a/drivers/crypto/sae/cryptoapi.c
+++ b/drivers/crypto/sae/cryptoapi.c
@@ -847,6 +847,7 @@ int nlm_crypto_aync_callback(enum nlm_crypto_op_type_t type, unsigned long long
 	void *ctrl, *param, *arg;
 	int instance;
 	struct nlm_crypto_ctx *ctx;
+	int tmp = 0;
 	int (*func)(nlm_crypto_ctx_t *, void *, void *, void *);
 
 	if(type == NLM_CRYPTO_PKT) {
@@ -865,6 +866,23 @@ int nlm_crypto_aync_callback(enum nlm_crypto_op_type_t type, unsigned long long
 
 	func = (void *)ctx->async_callback;
 
+	ctx->req[instance].msg[1] = NULL;
+
+	crypto_lock((cryptolock_t *)&ctx->lock);
+	tmp = (ctx->mhead + 1) % ctx->max_msgs;
+	if(instance ==  tmp) {
+		/* look for already read instances */
+		while(!fifo_empty(ctx->mtail, ctx->mhead)) {
+			if(!ctx->req[tmp].msg[1]) {
+				ctx->mhead = (ctx->mhead + 1) % ctx->max_msgs;
+				tmp = (ctx->mhead + 1) % ctx->max_msgs;
+				ctx->rsp_pend--;
+			} else
+				break;
+		}
+	}
+	crypto_unlock((cryptolock_t *)&ctx->lock);
+
 	if(func)
 		return func(ctx, ctrl, param, arg);
 
@@ -942,7 +960,8 @@ struct nlm_crypto_pkt_param *nlm_crypto_pkt_param_alloc(nlm_crypto_ctx_t *ctxt,
 	void *ptr;
 	int alignment, size;
 
-	size = sizeof(struct nlm_crypto_pkt_param) + (16 * nsegs);
+	/* 32 for designer descriptor */
+	size = sizeof(struct nlm_crypto_pkt_param) + (16 * nsegs) + 32;
 	/* As the default memory allocator allocates only 128K of physically contiguous memory, 
 	 play with the alignment to get the cont memory
 	 */
diff --git a/drivers/crypto/sae/cryptodev.h b/drivers/crypto/sae/cryptodev.h
index fe32a34..7f18397 100644
--- a/drivers/crypto/sae/cryptodev.h
+++ b/drivers/crypto/sae/cryptodev.h
@@ -45,16 +45,6 @@
 #define XLP_CACHELINE_SIZE 64
 #endif 
 
-/* type value start and end */
-#define NLM_CRYPTO_ECCPRIME_TYPE_SVALUE 	0x0
-#define NLM_CRYPTO_ECCPRIME_TYPE_EVALUE 	0x8
-
-#define NLM_CRYPTO_ECCBIN_TYPE_SVALUE 		0x20
-#define NLM_CRYPTO_ECCBIN_TYPE_EVALUE 		0x28
-
-#define NLM_CRYPTO_RSA_TYPE_SVALUE 		0x40
-#define NLM_CRYPTO_RSA_TYPE_EVALUE 		0x44
-
 /* In async when max_msgs > 1, the message send id is specified in 52nd bit onwards
  int the msg2 
  0-31(32 bits) - session id
diff --git a/drivers/crypto/sae/nlmcrypto.h b/drivers/crypto/sae/nlmcrypto.h
old mode 100644
new mode 100755
index 2c395b8..fcee9c3
--- a/drivers/crypto/sae/nlmcrypto.h
+++ b/drivers/crypto/sae/nlmcrypto.h
@@ -108,6 +108,16 @@ enum nlm_crypto_mode { NLM_CRYPTO_MODE_ASYNC = 1, NLM_CRYPTO_MODE_SYNC_EXLVC, NL
 #define ccpu_to_be64(x) (x)
 #endif
 
+/* type value start and end */
+#define NLM_CRYPTO_ECCPRIME_TYPE_SVALUE 	0x0
+#define NLM_CRYPTO_ECCPRIME_TYPE_EVALUE 	0x8
+
+#define NLM_CRYPTO_ECCBIN_TYPE_SVALUE 		0x20
+#define NLM_CRYPTO_ECCBIN_TYPE_EVALUE 		0x28
+
+#define NLM_CRYPTO_RSA_TYPE_SVALUE 		0x40
+#define NLM_CRYPTO_RSA_TYPE_EVALUE 		0x44
+
 
 enum nlm_crypto_op_type_t { NLM_CRYPTO_RSA, NLM_CRYPTO_ECC, NLM_CRYPTO_PKT };
 
@@ -346,7 +356,7 @@ enum nlm_hash_mode {
 	NLM_HASH_MODE_MAX = 0xA,
 }; 
 
-#define MAX_KEY_LEN_IN_DW 20
+#define MAX_KEY_LEN_IN_DW 58
 /**
 * @brief crypto control descriptor, should be cache aligned
 * @ingroup crypto
@@ -586,7 +596,6 @@ static inline unsigned int nlm_crypto_fill_src_seg(struct nlm_crypto_pkt_param *
 			sval, 0x0ULL) + s_seg);
 
 }
-
 /**
 * @brief Top level function for generating packet desc5 from cipher destination segments
 * @ingroup crypto
@@ -735,6 +744,189 @@ static inline int crypto_get_lbc64(unsigned long long x)
 	return 64 - x;
 }
 
+/**
+* @brief Top level function for modifying the packet cipherlen, hashlen and hashdstaddr in desc0 and desc1
+* @ingroup crypto
+* - param : pointer to the param structure
+* - cipherlen : cipher length in bytes
+* - hashlen : hash length in bytes
+* - hashdstaddr : hash destination physical address
+*/
+static inline void nlm_crypto_modify_cipher_auth_pkt_param(struct nlm_crypto_pkt_param *param,
+		int cipherlen, int hashlen, unsigned char * hashdstaddr)
+{
+	unsigned long long  desc;
+	param->desc1 = ccpu_to_be64(nlm_crypto_form_pkt_desc1(cipherlen, hashlen));
+	desc =  ccpu_to_be64(param->desc0) & 0xFFFFFE0000000000ULL;
+	param->desc0 = ccpu_to_be64((shift_lower_bits(crypto_virt_to_phys(hashdstaddr), 0, 40)|desc));
+
+}
+
+/**
+* @brief Top level function for modifying the packet cipherlen in desc1
+* @ingroup crypto
+* - param : pointer to the param structure
+* - cipherlen : cipher length in bytes
+*/
+static inline void nlm_crypto_modify_cipher_pkt_param(struct nlm_crypto_pkt_param *param, int cipherlen)
+{
+	unsigned long long  desc;
+	desc = ccpu_to_be64(param->desc1) & 0x00000000ffffffffULL;
+	param->desc1 = ccpu_to_be64((shift_lower_bits_mask((cipherlen - 1), 32, 32) | desc) );
+
+
+}
+
+/**
+* @brief Top level function for modifying the packet hashlen and hashdstaddr in desc0 and desc1
+* @ingroup crypto
+* - param : pointer to the param structure
+* - hashlen : hash length in bytes
+* - hashdstaddr : hash destination physical address
+*/
+static inline void nlm_crypto_modify_auth_pkt_param(struct nlm_crypto_pkt_param *param, int hashlen, unsigned char * hashdstaddr)
+{
+	unsigned long long  desc;
+	desc =  ccpu_to_be64(param->desc0) & 0xffffff0000000000ULL;
+	param->desc0 = ccpu_to_be64((shift_lower_bits(crypto_virt_to_phys(hashdstaddr), 0, 40)|desc));
+	desc = ccpu_to_be64(param->desc1) & 0xffffffff00000000ULL;
+	param->desc1 = ccpu_to_be64( (shift_lower_bits_mask((hashlen - 1), 0, 32) | desc) );
+
+}
+
+/**
+* @brief Top level function for adding designer descriptor at the end of src/dst fragments 
+* @ingroup crypto
+* - param : pointer to the param structure
+* - des_fb_start : designer feedback start segment  
+* - des_index : designer feedback index
+* - des_desc : designer feedback to be filled at the index specified by des_index
+*/
+static inline void nlm_crypto_fill_desfback_pkt_param(struct nlm_crypto_pkt_param *param, int des_fb_start, int des_index,unsigned long long des_desc)
+{
+
+	unsigned long long *seg = &param->segment[des_fb_start][0];
+	seg[des_index] = ccpu_to_be64(des_desc);
+	
+}
+
+
+/**
+* @brief Top level function for modifying cfb_mask in the control descriptor 
+* @ingroup crypto
+* - ctrl : pointer to control structure
+* - cfb_mask : cfb mask needed by the cfb_mode
+*/
+static inline void nlm_crypto_modify_cfbmask(struct nlm_crypto_pkt_ctrl *ctrl,int cfb_mask )
+{
+	unsigned long long desc =  ccpu_to_be64(ctrl->desc0);
+
+	desc = desc & 0xFFFFFFFFFFFFFFF8ULL;
+	desc = desc | shift_lower_bits(cfb_mask, 0, 3);
+	ctrl->desc0 = ccpu_to_be64(desc);
+}
+
+
+/**
+* @brief Top level function for modifying cipherbit_cnt, hashbit_cnt in the packet descriptor 
+* @ingroup crypto
+* - param : pointer to the param structure
+* - cipherbit_cnt : number of bits valid in the last cipher byte 
+* - hashbit_cnt: number of bits valid in the last hash byte
+*/
+static inline void nlm_crypto_modify_cipher_auth_bitcnt(struct nlm_crypto_pkt_param *param, int cipherbit_cnt, int hashbit_cnt)
+{
+	unsigned long long desc =  ccpu_to_be64(param->desc2); 
+	desc = desc & 0xFFFEE3FFFFC7FFFFULL;
+	desc = desc | shift_lower_bits(cipherbit_cnt, 42, 3) | shift_lower_bits(hashbit_cnt, 19, 3);
+	param->desc2 = ccpu_to_be64(desc);
+
+}
+
+
+/**
+* @brief Top level function for modifying for  packet descriptor for arc4 cipher
+* @ingroup crypto
+* - param : pointer to the param structure
+* - arc4_cipherkeylen : length of the arc4 cipher key
+* - arc4_keyinit : set to initialize the key for the first time
+* - arc4_state_save_l3 : sbox state is saved and transits through the L3 cache  
+* - arc4_save_state :  sbox state is saved 
+*/
+static inline void nlm_crypto_modify_arc4_cipher(struct nlm_crypto_pkt_ctrl *ctrl, struct nlm_crypto_pkt_param *param, 
+			int arc4_cipherkeylen, int arc4_keyinit, int arc4_state_save_l3, int arc4_save_state )
+{
+	unsigned long long desc =  ccpu_to_be64(ctrl->desc0);
+
+	desc = desc & 0xFFFFFFFFFF81FFFFULL;
+	desc = desc | shift_lower_bits(arc4_cipherkeylen, 18, 5) | shift_lower_bits(arc4_keyinit, 17, 1);
+	ctrl->desc0 = ccpu_to_be64(desc); 
+
+	desc =  ccpu_to_be64(param->desc3);
+	desc = desc & 0xFFFFFFFFFFFFFEBFULL;
+	desc = desc | shift_lower_bits(arc4_state_save_l3, 8, 1) | shift_lower_bits(arc4_save_state, 6, 1);
+	param->desc3 = ccpu_to_be64(desc);
+	
+}
+
+/**
+* @brief Top level function for modifying tls protocol enable 
+* @ingroup crypto
+* - param : pointer to the param structure
+* - tls : 1: enable 
+*/
+static inline void nlm_crypto_modify_tls_proto(struct nlm_crypto_pkt_param *param, int tls )
+{
+	unsigned long long desc =  ccpu_to_be64(param->desc0);
+	desc = (desc & 0x7FFFFFFFFFFFFFFFULL) | shift_lower_bits(tls, 63, 1);
+	param->desc0 = ccpu_to_be64(desc);
+}
+
+/**
+* @brief Top level function for modifying l3 alloc and clobber for auth 
+* @ingroup crypto
+* - param : pointer to the param structure
+* - hashout_l3alloc : 1,tag, when written out, is transited through the L3 cache
+* - hashclobber : output is written out as multiples of cache
+*                 lines. No read-modify-write is done.
+*/
+static inline void nlm_crypto_modify_auth_clobber_l3_alloc(struct nlm_crypto_pkt_param *param,
+	int hashout_l3alloc, int hashclobber )
+{
+	unsigned long long desc =  ccpu_to_be64(param->desc0);
+	desc = ( desc & 0xEFFFFFFFFFFFFFFF ) | shift_lower_bits(hashout_l3alloc, 60, 1);
+	param->desc0 = ccpu_to_be64(desc);
+	
+	desc = ccpu_to_be64(param->desc2);
+	desc = (desc & 0xFFFFFFFFFFFBFFFFULL ) | shift_lower_bits(hashclobber, 18, 1);;
+	param->desc2 = ccpu_to_be64(desc );
+}
+
+/**
+* @brief Top level function for modifying l3 alloc and clobber for cipher  
+* @ingroup crypto
+* - param : pointer to the param structure
+* - nsegs : Number of packet segments, not considered for rsa
+* - cipherout_l3alloc : output is saved, it transits through the L3 cache.
+* - cipherclobber : 1,output is written out as multiples of cache lines. No
+*                   read-modify-write is done. 
+*/
+static inline void nlm_crypto_modify_cipher_clobber_l3_alloc(struct nlm_crypto_pkt_param *param, int nsegs, int cipherout_l3alloc, int cipherclobber)
+{
+
+	int i;
+	unsigned long long desc;
+	for(i =0; i < nsegs; i++) {	
+		desc = ccpu_to_be64(param->segment[i][1]);	
+		desc = (desc & 0xFFFFBDFFFFFFFFFFULL ) | ( shift_lower_bits(cipherout_l3alloc, 46, 1) |
+					shift_lower_bits(cipherclobber, 41, 1));
+
+		param->segment[i][1] = ccpu_to_be64(desc ); 
+	}
+
+}
+
+
 #ifndef XLP_CACHELINE_SIZE
 #define XLP_CACHELINE_SIZE 64
 #endif 
diff --git a/drivers/crypto/sae/nlmcrypto_msg.h b/drivers/crypto/sae/nlmcrypto_msg.h
new file mode 100755
index 0000000..fa63df7
--- /dev/null
+++ b/drivers/crypto/sae/nlmcrypto_msg.h
@@ -0,0 +1,142 @@
+/*********************************************************************
+
+  Copyright 2003-2010 Netlogic Microsystem, Inc. ("Netlogic"). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#NLM_2#**********************************/
+#ifndef _NLM_CRYPTO_MSG_H
+#define _NLM_CRYPTO_MSG_H
+
+#ifndef NLM_CRYPTO_EXCL_IFC
+#include "nlmcrypto_ifc.h"
+#include "nlm_hal_fmn.h" 
+
+#define xtract_bits(x, bitpos, numofbits) ((x) >> (bitpos) & ((1ULL << (numofbits)) - 1))
+
+
+/**
+* @brief Top level function for sending the crypto messages to the security engine. 
+* @ingroup crypto
+* - ctrl : Pointer to the control structure
+* - param : pointer to the param structure
+* - nsegs : Number of packet segments, not considered for rsa
+* - dstvc : destination VC
+* - fbvc : regular feedback VC, in case designer enabled it is the error VC
+* - designer_fb_vc: designer feedback vc
+* - designer_fb_len : number of designer feedback messages
+* - arc4load_state : 1 if load state required 0 otherwise 
+* - arg : fmn entry 2 Software scratch pad
+*/
+static inline int nlm_crypto_pkt_msgsend(struct nlm_crypto_pkt_ctrl *ctrl, struct nlm_crypto_pkt_param *param, 
+		int data_nsegs, int dstvc, int fbvc, int designer_fb_vc,int designer_fb_len, int arc4load_state, unsigned long long arg)
+{
+	int pktdescsize;
+	int designerdesc_valid = designer_fb_len?1:0;
+	uint64_t msg0, msg1;
+	uint64_t desc;
+
+	data_nsegs = data_nsegs +  (( designer_fb_len +1 )/2);
+	pktdescsize = 32 + data_nsegs * 16;
+
+	desc =  ccpu_to_be64(param->desc3) & 0x0000ffffffffffffULL;
+	param->desc3 = ccpu_to_be64((shift_lower_bits(designer_fb_vc, 48, 16)|desc));
+	
+	nlm_dbg_print("Do op cdesc %016llx pdesc %016llx %016llx %016llx %016llx\n",
+			ctrl->desc0, param->desc0, param->desc1, param->desc2,param->desc3);
+	nlm_dbg_print("Do op pseg %016llx %016llx\n", pktparam->segment[0][0],
+			param->segment[0][1]);
+	msg0 = nlm_crypto_form_pkt_fmn_entry0(fbvc, designer_fb_len, designerdesc_valid, ctrl->cipherkeylen, 
+			crypto_virt_to_phys(ctrl));
+	msg1 = nlm_crypto_form_pkt_fmn_entry1(arc4load_state, ctrl->hashkeylen, pktdescsize, 
+			crypto_virt_to_phys(param));
+	while( nlm_hal_send_msg3(dstvc,0,msg0,msg1,arg) != 0);
+
+	return 0;
+
+}
+
+/**
+* @brief Top level function for sending the rsa messages to the rsa engine. 
+* @ingroup crypto
+* - ctrl : Pointer to the control structure
+* - param : pointer to the param structure
+* - dstvc : destination VC
+* - fbvc : feedback VC
+* - arg : fmn entry 2 Software scratch pad
+*/
+static inline int nlm_crypto_rsa_msgsend(struct nlm_crypto_rsa_ctrl *ctrl, struct nlm_crypto_rsa_param *param, int dstvc, int fbvc,unsigned long long arg)
+{
+	int blksz_nbits = ctrl->blksz_nbits; 
+	int bitset;
+	struct nlm_crypto_rsa_result *rsar = param->result;
+	uint64_t msg0, msg1;
+	int op = ctrl->op;
+	int type;
+	/* rsa starts from 512 bits, 9 is hardcoded */
+	bitset = crypto_get_lbs(blksz_nbits) - 1;
+	type = bitset - 9 + NLM_CRYPTO_RSA_TYPE_SVALUE;
+	if(type > NLM_CRYPTO_RSA_TYPE_EVALUE || ((blksz_nbits - (1 << bitset)) > 0))
+		return NLM_CRYPTO_ERROR;
+
+	msg0 = nlm_crypto_form_rsa_ecc_fmn_entry0(1, type, op, crypto_virt_to_phys(param->modexp.x));
+	msg1 = nlm_crypto_form_rsa_ecc_fmn_entry1(0, 1, fbvc, crypto_virt_to_phys(rsar->r));
+	while( nlm_hal_send_msg3(dstvc,0,msg0,msg1,arg) != 0);
+	return 0;
+
+}
+
+/**
+* @brief Top level function for sending the ecc messages to the rsa/ecc engine. 
+* @ingroup crypto
+* - ctrl : Pointer to the control structure
+* - param : pointer to the param structure
+* - dstvc : destination VC
+* - fbvc : feedback VC
+* - arg : fmn entry 2 Software scratch pad
+*/
+static inline int nlm_crypto_ecc_msgsend(struct nlm_crypto_ecc_ctrl *ctrl, struct nlm_crypto_ecc_param *param, int dstvc, int fbvc, unsigned long long arg)
+{
+	int blksz_nbits = ctrl->blksz_nbits; 
+	int prime = ctrl->prime;
+	uint64_t msg0, msg1;
+	int op = ctrl->op;
+	int type;
+	/* ecc starts from 64 bits*/
+	if(prime)
+		type =  (blksz_nbits / 64) - 1 + NLM_CRYPTO_ECCPRIME_TYPE_SVALUE;
+	else
+		type =  (blksz_nbits / 64) - 1 + NLM_CRYPTO_ECCBIN_TYPE_SVALUE;
+	if((blksz_nbits % 64) != 0) 
+		return NLM_CRYPTO_ERROR;
+
+	msg0 = nlm_crypto_form_rsa_ecc_fmn_entry0(1, type, op, crypto_virt_to_phys(param->pmul.x));
+	msg1 = nlm_crypto_form_rsa_ecc_fmn_entry1(0, 1, fbvc, crypto_virt_to_phys(param->result->fres.r));
+	while( nlm_hal_send_msg3(dstvc,0,msg0,msg1,arg) != 0);
+	return 0;
+
+}
+#endif
+#endif
-- 
1.7.0.4

