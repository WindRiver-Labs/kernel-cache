From 49db3b0ff8a568ad07097d7d92f6293f7e513fa2 Mon Sep 17 00:00:00 2001
From: Anurag <anuragn@rmicorp.com>
Date: Mon, 12 Dec 2011 13:43:12 +0530
Subject: [PATCH 489/761] Adding support for SD card detection
 insertion/removal

Based on Broadcom SDK 2.3.

Signed-off-by: Anurag <anuragn@rmicorp.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mmc/host/xlpmmc.c |   78 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 74 insertions(+), 4 deletions(-)

diff --git a/drivers/mmc/host/xlpmmc.c b/drivers/mmc/host/xlpmmc.c
index 28a61bc..529bd47 100644
--- a/drivers/mmc/host/xlpmmc.c
+++ b/drivers/mmc/host/xlpmmc.c
@@ -40,6 +40,9 @@
 #include <linux/delay.h>
 
 #include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <hal/nlm_hal_xlp_dev.h>
 
 #include "xlpmmc.h"
 
@@ -56,6 +59,7 @@ struct xlpmmc_host {
 	u32 power_mode;
 	spinlock_t		irq_lock; /* Prevent races with irq handler */
 	int status;
+        int present;
 
 	struct {
 		int len;
@@ -88,7 +92,22 @@ struct xlpmmc_host {
 #define HOST_S_CMD	0x0002
 #define HOST_S_DATA	0x0003
 
-#define PCIE_HDR_OFFSET                0x100
+#define PCIE_HDR_OFFSET 0x100
+#define GPIO_MMC_DETECT 29
+
+__inline__ int32_t gpio_regread(int node, int regidx) 
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, XLP_GIO_GPIO_FUNC);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void gpio_regwrite(int node, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, XLP_GIO_GPIO_FUNC);
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
 
 /* Low-level write-routines*/
 static inline void hc_wr32(void *iobase, int offset, u32 data, int slot) {
@@ -148,8 +167,9 @@ static void xlpmmc_set_power(struct xlpmmc_host *host, int state)
 
 static int xlpmmc_card_inserted(struct mmc_host *mmc)
 {
-	//struct xlpmmc_host *host = mmc_priv(mmc);
-	return 1;
+        struct xlpmmc_host *host = mmc_priv(mmc);
+        host->present = !gpio_get_value(GPIO_MMC_DETECT);
+        return host->present;
 }
 
 static int xlpmmc_card_readonly(struct mmc_host *mmc)
@@ -157,6 +177,31 @@ static int xlpmmc_card_readonly(struct mmc_host *mmc)
 	//struct xlpmmc_host *host = mmc_priv(mmc);
 	return -ENOSYS;
 }
+static irqreturn_t xlpmmc_det_irq(int irq, void *dev_id)
+{
+        struct xlpmmc_host *host = (struct xlpmmc_host *) dev_id;
+        int present = !gpio_get_value(GPIO_MMC_DETECT); 
+#ifdef XLP_MMC_DEBUG
+        printk("Entered xlpmmc_det_irq\n");
+#endif
+        /*
+        * we expect this irq on both insert and remove,
+        * and use a short delay to debounce.
+        */
+        gpio_regwrite(0, XLP_GPIO_INT_STAT0, gpio_regread(0, XLP_GPIO_INT_STAT0) & 0x20000000);
+        if(present)
+                gpio_regwrite(0, XLP_GPIO_INT_POLAR0, gpio_regread(0, XLP_GPIO_INT_POLAR0) & 0xDFFFFFFF);
+        else
+                gpio_regwrite(0, XLP_GPIO_INT_POLAR0, gpio_regread(0, XLP_GPIO_INT_POLAR0) | 0x20000000);
+
+        if (present != host->present) {
+                host->present = present;
+                pr_debug("%s: card %s\n", mmc_hostname(host->mmc),
+                        present ? "insert" : "remove");
+                mmc_detect_change(host->mmc, msecs_to_jiffies(100));
+        }
+        return IRQ_HANDLED;
+}
 
 static void xlpmmc_finish_request(struct xlpmmc_host *host)
 {
@@ -756,6 +801,23 @@ static int __devinit xlpmmc_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "cannot grab IRQ\n");
 		goto out3;
 	}
+        
+        gpio_regwrite(0, XLP_GPIO_INTEN00,   gpio_regread(0, XLP_GPIO_INTEN00) | 0x20000000);
+        gpio_regwrite(0, XLP_GPIO_INT_POLAR0, gpio_regread(0, XLP_GPIO_INT_POLAR0) | 0x20000000);
+        gpio_regwrite(0, XLP_GPIO_INT_TYPE0, gpio_regread(0, XLP_GPIO_INT_TYPE0) | 0x20000000);
+        
+        ret = request_irq(xlp_irt_to_irq(XLP_GPIO_INT0_IRT), xlpmmc_det_irq,
+                IRQF_SHARED, "mmc-gpio", host);
+        if (ret) {
+                dev_warn(&pdev->dev, "request MMC detect irq failed\n");
+                free_irq(xlp_irt_to_irq(XLP_GPIO_INT0_IRT), host);
+        }
+                                                                   
+        if (gpio_is_valid(GPIO_MMC_DETECT)) {
+               if (gpio_request(GPIO_MMC_DETECT, "mmc_detect")) {
+                pr_debug("no detect pin available\n");
+               }
+        }
 
 	mmc->ops = &xlpmmc_ops;
 
@@ -797,7 +859,11 @@ out6:
 	/*Disable the host if init fails*/
 	mmc_remove_host(host->mmc);
 	xlpmmc_set_power(host, 0);
-
+        
+        if (gpio_is_valid(GPIO_MMC_DETECT)) {
+                gpio_free(GPIO_MMC_DETECT);
+        }
+	free_irq(xlp_irt_to_irq(XLP_GPIO_INT0_IRT), host);
 	free_irq(host->irq, host);
 out3:
 	iounmap((void *)host->base);
@@ -818,7 +884,11 @@ static int __devexit xlpmmc_remove(struct platform_device *pdev)
 		mmc_remove_host(host->mmc);
 		
 		xlpmmc_set_power(host, 0);
+                if (gpio_is_valid(GPIO_MMC_DETECT)) {
+                        gpio_free(GPIO_MMC_DETECT);
+                }
 		
+		free_irq(xlp_irt_to_irq(XLP_GPIO_INT0_IRT), host);
 		free_irq(host->irq, host);
 		iounmap((void *)host->base);
 		release_resource(host->ioarea);
-- 
1.7.10.4

