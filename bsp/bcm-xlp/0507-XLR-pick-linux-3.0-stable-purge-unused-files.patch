From 529c30b6d279d9340cf48d3e1d84decaeeb83d5a Mon Sep 17 00:00:00 2001
From: Zi Shen Lim <zlim@netlogicmicro.com>
Date: Mon, 9 Jan 2012 18:46:38 -0800
Subject: [PATCH 507/762] XLR: pick linux-3.0-stable, purge unused files

Based on Broadcom SDK 2.3.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlr/board.c      |  218 ----------
 arch/mips/netlogic/xlr/config_net.c |  532 -----------------------
 arch/mips/netlogic/xlr/mmu.c        |    7 -
 arch/mips/netlogic/xlr/nmi.S        |  105 -----
 arch/mips/netlogic/xlr/on_chip.c    |  786 -----------------------------------
 arch/mips/netlogic/xlr/time.c       |  259 ++----------
 6 files changed, 43 insertions(+), 1864 deletions(-)
 delete mode 100644 arch/mips/netlogic/xlr/board.c
 delete mode 100644 arch/mips/netlogic/xlr/config_net.c
 delete mode 100644 arch/mips/netlogic/xlr/mmu.c
 delete mode 100644 arch/mips/netlogic/xlr/nmi.S
 delete mode 100644 arch/mips/netlogic/xlr/on_chip.c

diff --git a/arch/mips/netlogic/xlr/board.c b/arch/mips/netlogic/xlr/board.c
deleted file mode 100644
index b45fad2..0000000
--- a/arch/mips/netlogic/xlr/board.c
+++ /dev/null
@@ -1,218 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-/*
- * Board dependent code for Netlogic's XLR-based boards
- */
-
-#include <linux/spinlock.h>
-#include <linux/mm.h>
-#include <linux/bootmem.h>
-#include <linux/init.h>
-#include <linux/pm.h>
-
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <asm/bootinfo.h>
-#include <asm/addrspace.h>
-#include <asm/reboot.h>
-#include <asm/time.h>
-#include <linux/interrupt.h>
-#include <asm/atomic.h>
-#include <asm/cacheflush.h>
-
-#include <asm/netlogic/sim.h>
-#include <asm/mipsregs.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/iomap.h>
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/xlr_user_mac.h>
-#include <asm/netlogic/msgring.h>
-
-#include <asm/netlogic/nlm_pcix_gen_dev.h>
-#include <asm/netlogic/bootinfo.h>
-#include <asm/netlogic/memory-exclusion.h>
-
-#include <linux/serial.h>
-#include <linux/serial_core.h>
-#include <linux/module.h>
-#include <linux/proc_fs.h>
-#include <asm/mach-netlogic/mmu.h>
-#include <asm/netlogic/i2c-algo-palm.h>
-#include <asm/netlogic/xlr_board.h>
-
-
-#define EEPROM_MAJOR_OFFSET 0x18
-#define EEPROM_MINOR_OFFSET 0x19
-#define EEPROM_ETH_MAC_OFFSET 0x20
-#define GPIO_RESET_CFG 			21
-
-int wait_i2c_idle(nlm_reg_t *mmio)
-{
-	int i;
-	nlm_reg_t regVal;
-
-	i=0x1000;
-	regVal = netlogic_read_reg(mmio, I2C_PALM_STATUS) & 0x0001;
-	while (regVal && i--) {
-		regVal = netlogic_read_reg(mmio, I2C_PALM_STATUS) & 0x0001;
-	}
-	if(i == 0) {
-		printk("Bus not idle\n");
-		return -1;
-	}
-	return 0;
-}
-
-
-static uint32_t xls_get_cpu_clk(uint32_t cfg)
-{
-	int adivq, adivf;
-	int ref = 6667;
-	int res;
-
-	/* REF/2 * DIVF / DIVQ = PLLOUT */
-	adivf = (cfg & 0xff) + 1;
-	adivq = (cfg >> 8) & 0x7 ;
-	adivq = (1 << adivq); /* adivq = 2 ^ divq */
-
-	/* multiply adivf by 1000 so that we get
-	 * better result with integer division.
-	 * Also divide the final result with 100 (from ref
-	 * earlier) and the 1000 we multiplied with adivf
-	 */
-	res = ((ref / 2) * (adivf*1000/adivq))/(100*1000);
-	printk("Determined CPU frequency = %dMhz\n", res);
-	return (uint32_t)res;
-}
-
-void get_cpu_clock(xlr_board_info_t *board)
-{
-	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_GPIO_OFFSET);
-	uint32_t freq=0, cfg;
-
-	cfg = netlogic_read_reg(mmio, GPIO_RESET_CFG);
-
-	if(is_xls()) {
-		freq = xls_get_cpu_clk(cfg);
-	} else {
-
-		freq = (((((cfg >> 2) & 0x7f) + 1) * 16667)/1000);
-
-		if (cfg & 0x200)
-			freq = freq >> 1;
-	}
-	if(!freq) {
-		printk("Unable to determine CPU frequency from CFGREG [0x%x]\n", cfg);
-		board->cpu_freq = 1000 * 1000 * 1000;
-	} else {
-		board->cpu_freq = freq * 1000 * 1000;
-	}
-	
-}
-
-int  read_board_info(xlr_board_info_t *board) 
-{
-	uint8_t ebuf[48];
-	int len;
-	volatile uint32_t regVal, i, tmp;
-	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_I2C_1_OFFSET);
-
-	/* if this is not read from FDT */
-	if(board->cpu_freq == 0)
-		get_cpu_clock(board);
-
-	/* Read other board dependent stuff */
-	/* EEPROM on Netlogic XLR/XLS boards are on BUS 1 */
-	/* read first 40 bytes of the EEPROM */
-	
-	len = 40;
-
-	for(tmp=0; tmp < len; tmp++) {
-
-		if(wait_i2c_idle(mmio) != 0)
-			return -1;
-
-		/* EEPROM is at address 0x50 on bus 1 */
-		netlogic_write_reg(mmio, I2C_PALM_DEVADDR, 0x50);
-		netlogic_write_reg(mmio, I2C_PALM_ADDR, tmp);
-		netlogic_write_reg(mmio, I2C_PALM_CFG,     0xf8);
-		netlogic_write_reg(mmio, I2C_PALM_BYTECNT, 0);
-		netlogic_write_reg(mmio, I2C_PALM_STARTXFR,0x2);
-
-
-		if(wait_i2c_idle(mmio) != 0)
-			return -1;
-
-		regVal = netlogic_read_reg(mmio, I2C_PALM_STATUS);
-		if (regVal & 0x0008) {
-			printk("start read: ACKERR. Aborting...\n");
-			return -1;
-		}
-
-
-		netlogic_write_reg(mmio, I2C_PALM_DEVADDR, 0x50);
-		netlogic_write_reg(mmio, I2C_PALM_CFG,     0xfa);
-		netlogic_write_reg(mmio, I2C_PALM_BYTECNT, 0);
-		netlogic_write_reg(mmio, I2C_PALM_STARTXFR,0x1);
-
-
-		if(wait_i2c_idle(mmio) != 0)
-			return -1;
-
-		regVal = netlogic_read_reg(mmio, I2C_PALM_STATUS);
-		if (regVal & 0x0008) {
-			printk("start read: ACKERR. Aborting...\n");
-			return -1;
-		}
-		i = 0;
-		while(1) {
-			regVal = netlogic_read_reg(mmio, I2C_PALM_STATUS);
-			if (regVal & 0x4) {
-				ebuf[tmp] = (__u8)netlogic_read_reg(mmio,
-						I2C_PALM_DATAIN);
-				break;
-
-			}
-			i++;
-			if (i >= 1000000) {
-				printk("* read Timed OUT byte %d.\n", tmp);
-				return -1;
-			}
-		}
-	}
-	
-	if(board->major == 0) 
-		board->major = ebuf[EEPROM_MAJOR_OFFSET] - '0';
-	if(board->minor == 0) 
-	board->minor = ebuf[EEPROM_MINOR_OFFSET] - '0';
-
-	if(*((uint32_t *)board->mac_addr) == 0) {
-		for(i=0; i < 6; i++) 
-			board->mac_addr[i] = ebuf[EEPROM_ETH_MAC_OFFSET + i];
-	}
-	return 0;
-
-}
diff --git a/arch/mips/netlogic/xlr/config_net.c b/arch/mips/netlogic/xlr/config_net.c
deleted file mode 100644
index 8dfc0d8..0000000
--- a/arch/mips/netlogic/xlr/config_net.c
+++ /dev/null
@@ -1,532 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-/*
- * Setup code for Netlogic's XLR-based boards
- */
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/socket.h>
-#include <linux/errno.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/config_net.h>
-#include <asm/netlogic/xlr_mac.h>
-#include <asm/netlogic/gpio.h>
-
-struct net_device_cfg xlr_net_dev_cfg;
-extern unsigned long netlogic_io_base;
-/*
-extern uint32_t dev_tree_en;
-extern void nlm_dev_config_net(void);
-*/
-static uint32_t gmac_offsets[] = { NETLOGIC_IO_GMAC_0_OFFSET, NETLOGIC_IO_GMAC_1_OFFSET, 
-			NETLOGIC_IO_GMAC_2_OFFSET, NETLOGIC_IO_GMAC_3_OFFSET,
-			NETLOGIC_IO_GMAC_4_OFFSET, NETLOGIC_IO_GMAC_5_OFFSET,
-			NETLOGIC_IO_GMAC_6_OFFSET, NETLOGIC_IO_GMAC_7_OFFSET };
-
-#if !defined(XLP_SIM)
-static uint32_t gmac_irqs[] = { PIC_GMAC_0_IRQ, PIC_GMAC_1_IRQ, 
-			PIC_GMAC_2_IRQ, PIC_GMAC_3_IRQ,
-			PIC_GMAC_4_IRQ, PIC_GMAC_5_IRQ,
-			PIC_GMAC_6_IRQ, PIC_GMAC_7_IRQ };
-
-static uint32_t xgmac_offsets[] = { NETLOGIC_IO_XGMAC_0_OFFSET, NETLOGIC_IO_XGMAC_1_OFFSET };
-static uint32_t spi4_offsets[] = { NETLOGIC_IO_SPI4_0_OFFSET, NETLOGIC_IO_SPI4_1_OFFSET };
-static uint32_t xgs_irqs[] = { PIC_XGS_0_IRQ, PIC_XGS_1_IRQ };
-#endif /* XLP_SIM */
-
-#define MAX_NUM_DESC		512
-#define NLM_BASE(x) (netlogic_io_base + x)
-
-/*
-   This functions returns:
-   True (1): if block is in XAUI mode
-   False(0): if block is in GMAC mode
-*/
-
-int xlsb0_in_xaui(int block)
-{
-    unsigned int gpio_xaui = 0;
-    nlm_reg_t *gpio_mmio =
-                    (unsigned int *)(netlogic_io_base + NETLOGIC_IO_GPIO_OFFSET);
-    if (xlr_board_atx_xi() || xlr_board_atx_xii()) {
-        gpio_xaui = ((netlogic_read_reg(gpio_mmio,21) >> 24) & 0x3);
-        switch(gpio_xaui){
-            case 0x1:
-                return block==0?1:0;
-            case 0x2:
-                 return block==1?1:0;
-            case 0x3:
-                 return 1;
-            default:
-                return 0;
-        }
-    }
-    return 0;
-}
-
-static int sgmii_daughter_card_present(int block)
-{
-	unsigned long cpld_base = (unsigned long)(NETLOGIC_CPLD_OFFSET);
-	unsigned char *mmio = (unsigned char*)cpld_base;
-	unsigned char value = mmio[0x0d];
-	value = value & 0x03;
-
-	switch (block)
-	{
-		case 0:
-			if ((value == 0x0) || (value == 0x1))
-				return 1;
-			break;
-		case 1:
-			if ((value == 0x0) || (value == 0x2))
-				return 1;
-			break;
-		default:
-			return 0;
-	}
-	return 0;
-}
-
-/* This arrray is indexed with the processor id 8bits */
-char nlm_chip_gmac_count[256];
-void init_gmac_ports(void)
-{
-	int processor_id;
-
-    processor_id = ((read_c0_prid() & 0xff00) >> 8);
-
-    /* Currently handle for XLS B0 parts... */
-    switch(processor_id) {
-        case CHIP_PROCESSOR_ID_XLS_616_B0:
-        case CHIP_PROCESSOR_ID_XLS_608_B0:
-        case CHIP_PROCESSOR_ID_XLS_416_B0:
-        case CHIP_PROCESSOR_ID_XLS_412_B0:
-        case CHIP_PROCESSOR_ID_XLS_408_B0:
-        case CHIP_PROCESSOR_ID_XLS_404_B0:
-            nlm_chip_gmac_count[processor_id] = 8;
-            break;
-
-        default:
-            break;
-    }
-}
-int xlr_is_mac_active(int instance, int type, int *mode)
-{
-    uint32_t *gpio_base = (uint32_t *)(DEFAULT_NETLOGIC_IO_BASE +
-                                    NETLOGIC_IO_GPIO_OFFSET);    
-	int processor_id;
-    int xaui_board = 0;
-
-
-    if(xlr_board_atx_xi() || xlr_board_atx_xii())
-        xaui_board = 1;
-
-	*mode = PHY_MODE_RGMII;
-
-	/* On XLS xgmac is not available */
-	if (is_xls()) {
-		if(type == TYPE_XGMAC || type == TYPE_SPI4)
-                return 0;
-
-		processor_id = ((read_c0_prid() & 0xff00) >> 8);
-
-		*mode = PHY_MODE_SGMII;
-
-		if(instance == 0) {
-			/* Lite board does not have rgmii ifc */
-			if(xlr_board_atx_viii())
-				*mode = PHY_MODE_SGMII;
-			/* atx-xi/xii boards: SGMII mode for gmac 0 only if 
-			   daughter card for gmac block-0 is present.
-			   */
-			else if((xlr_board_atx_xi() || xlr_board_atx_xii()) &&
-					(!sgmii_daughter_card_present(0)))
-				*mode = PHY_MODE_RGMII;
-			else
-				*mode = PHY_MODE_RGMII | PHY_MODE_SELECTABLE;
-		}
-
-		if(is_xls_b0() && xaui_board){
-			if(instance < 4){
-                /* If port is not in XAUI mode, this board does not have SGMII.
-                   Only port 0 is in RGMII mode
-                   */
-				if(xlsb0_in_xaui(0)) {
-                    *mode = PHY_MODE_XAUI; /* else mode is set above */
-                    printk("Port %d is in XAUI mode\n", instance);
-                    if(instance == 0)
-                        return 1;
-                    else
-                        return 0;
-                } else
-				{
-					/* return TRUE if (instance == 0) OR
-					   if daughter card for block0 is 
-					   present 
-					 */
-					if ((instance == 0) || 
-						sgmii_daughter_card_present(0))
-						return 1;
-					else
-						return 0;
-				}
-			}
-			else if(instance < 8){
-                /* If port is not in XAUI mode, this board does not have SGMII*/
-				if(xlsb0_in_xaui(1)) {
-                    *mode = PHY_MODE_XAUI;
-                    printk("Port %d is in XAUI mode\n", instance);
-                    if(instance == 4)
-                        return 1;
-                    else
-                        return 0;
-                } else 
-				{
-					/* return TRUE only if daughter card 
-					   for block 1 is present */
-					if (sgmii_daughter_card_present(1))
-						return 1;
-					else
-						return 0;
-				}
-			}else
-				return 0;
-		}
-
-		/* all XLS parts have gmac0, gmac1 */
-		if (instance < 2)
-				return 1;
-
-		if (processor_id <= CHIP_PROCESSOR_ID_XLS_104) {
-			/* all XLS parts with processor_id <=104, have gmac3 */
-			if (instance < 3) 	
-				return 1;
-		}
-		if (processor_id <= CHIP_PROCESSOR_ID_XLS_204) {
-			/* all XLS parts with processor_id <=204, have gmac4 */
-			if (instance < 4) 	
-				return 1;
-		}
-
-		if ((processor_id >= CHIP_PROCESSOR_ID_XLS_608) &&
-		    (processor_id < CHIP_PROCESSOR_ID_XLS_208)) {
-			if (instance < 6) 
-				return 1;
-
-			if(((gpio_base[NETLOGIC_GPIO_FUSE_BANK_REG] & (1<<28)) == 0)  &&
-    	            ((gpio_base[NETLOGIC_GPIO_FUSE_BANK_REG] & (1<<29)) ==  0)){
-				/*Below bits are set when ports are disabled.
-				28 - GMAC7
-				29 - GMAC6
-				30 - GMAC5
-				31 - GMAC4
-				*/
-				/*We found an XLS-408 with 8 gmacs*/
-				if (instance < 8) 
-					return 1;
-			}
-		}
-		if (processor_id == CHIP_PROCESSOR_ID_XLS_608) {
-			if (instance == 6 || instance == 7) 
-				return 1;
-		}
-
-        if(nlm_chip_gmac_count[processor_id] &&
-                (instance < nlm_chip_gmac_count[processor_id]))
-            return 1;
-
-		/* should never come here */
-		return 0;
-	}
-	
-	if (type == TYPE_GMAC) {
-		/* On XLR gmac4 to gmac7 are unavailable */
-		if(instance >= 4)
-			return 0;
-
-		/* On ATX-II, gmac 0 and gmac 1 are not available */
-		if (xlr_board_atx_ii() && !xlr_board_atx_ii_b()) {
-			if(instance < 2)
-				return 0;
-		}
-
-		/* On ATX-IV-B and ATX-V, gmac 3 is not available */
-		if ((xlr_board_atx_v() || xlr_board_atx_iv_b())) {
-			if(instance > 2)
-				return 0;
-		}
-
-		return 1;
-
-	} else if(type == TYPE_XGMAC) {
-		/* On ATX-II and ATX IIB 2 xgmac is  available */
-		if (xlr_board_atx_ii() || xlr_board_atx_ii_b())
-			return 1;
-		return 0;
-
-	}  else if(type == TYPE_SPI4) {
-		if(xlr_board_atx_i())
-			return 1;
-		return 0;
-	}
-	
-	return 0;
-}
-
-int xlr_get_phy_info(int instance, int mode, unsigned long *mii_addr, 
-					unsigned long *pcs_addr, unsigned long *serdes_addr)
-{
-	uint32_t phy_addr;
-
-	*pcs_addr = 0x0;
-	*serdes_addr = 0x0;
-	*mii_addr = NLM_BASE(gmac_offsets[0]);
-
-	if(is_xls()) {
-		if(instance < NETLOGIC_GMAC_PORTS_PER_CTRL) {
-			*pcs_addr = NLM_BASE(gmac_offsets[0]);
-		} else  {
-			*pcs_addr = NLM_BASE(gmac_offsets[NETLOGIC_GMAC_PORTS_PER_CTRL]);
-		}
-		*serdes_addr = NLM_BASE(gmac_offsets[0]);
-
-		if(mode & PHY_MODE_RGMII) {
-			phy_addr = 0 + instance;
-			/*only atx-vi has rgmii-0 linked to sgmii-4 offset*/
-			if(xlr_board_atx_vi())
-				*mii_addr = NLM_BASE(gmac_offsets[NETLOGIC_GMAC_PORTS_PER_CTRL]);		
-		} else
-			phy_addr = 0x10 + instance;
-
-		/* boards 11 / 12 may have SGMII ports due to daughter
-		   cards.  In this case, the phy for block-0 is same as 
-		   gmac[0], but phy for block-1 is taken from gmac[4].
-		   Hence, update phy values if gmac instance >= 4.
-		   */
-		if ((xlr_board_atx_xi() || xlr_board_atx_xii()) &&
-				(instance >= NETLOGIC_GMAC_PORTS_PER_CTRL))
-		{
-			*mii_addr = NLM_BASE(gmac_offsets[NETLOGIC_GMAC_PORTS_PER_CTRL]);
-			phy_addr -= NETLOGIC_GMAC_PORTS_PER_CTRL;
-		}
-	} else {
-		if (xlr_board_atx_ii() && !xlr_board_atx_ii_b()) {
-			if(instance < 2)
-					phy_addr =  0;
-			phy_addr = instance - 2;
-		}
-		phy_addr = 0 + instance;
-	}
-	return phy_addr;
-}
-
-void config_net_init(void)
-{
-#if !defined(XLP_SIM)
-	struct net_device_cfg *net_dev = &xlr_net_dev_cfg;
-	int i, mode, gmac_pblock = 0;
-	int num_desc = MAX_NUM_DESC;
-
-    init_gmac_ports();
-	for(i = 0; i < NETLOGIC_MAX_GMACS; i++)  {
-		/* general config for gmac */
-		net_dev->gmac_port[i].instance = i;
-		net_dev->gmac_port[i].irqno = gmac_irqs[i];
-		net_dev->gmac_port[i].config_pde = 1;
-		/* chip specific config for gmac */
-		if(xlr_is_mac_active(i, TYPE_GMAC, &mode) == 1) {
-			net_dev->gmac_port[i].mmio_addr = NLM_BASE(gmac_offsets[i]);
-			net_dev->gmac_port[i].cfg_flag 	= PORT_OWN_LINUX;
-			
-			if(xlr_board_atx_vii() && i==4)
-				/*atx-vii board workaround for mdio-1*/
-				net_dev->gmac_port[i].cfg_flag 	= PORT_OWN_LINUX & ~(NLM_INT_ATTACH);
-
-			if(i >= gmac_pblock) {
-				net_dev->gmac_port[i].num_desc = num_desc;
-				if(is_xls()) {
-					if(i < NETLOGIC_GMAC_PORTS_PER_CTRL) {
-						net_dev->gmac_port[i].bucket = &xls_bucket_sizes.bucket[MSGRNG_STNID_GMAC0];
-						net_dev->gmac_port[i].credit = &xls_cc_table_gmac0;
-					} else {
-						net_dev->gmac_port[i].bucket = &xls_bucket_sizes.bucket[MSGRNG_STNID_GMAC1];
-						net_dev->gmac_port[i].credit = &xls_cc_table_gmac1;
-					}
-				} else {
-					net_dev->gmac_port[i].bucket = &bucket_sizes.bucket[MSGRNG_STNID_GMAC];
-					net_dev->gmac_port[i].credit = &cc_table_gmac;
-				}
-				gmac_pblock += NETLOGIC_GMAC_PORTS_PER_CTRL;
-			}
- 
-			net_dev->gmac_port[i].phy_mode = mode;
-
-			net_dev->gmac_port[i].phy_addr = xlr_get_phy_info(i, 
-				net_dev->gmac_port[i].phy_mode, 
-				&net_dev->gmac_port[i].mii_addr, 
-				&net_dev->gmac_port[i].pcs_addr, 
-				&net_dev->gmac_port[i].serdes_addr);
-			
-		}
-	}
-
-	/* general config for xgmac */
-	for(i = 0; i < NETLOGIC_MAX_XGMACS; i++)  {
-		net_dev->xgs_port[i].instance = i;
-		net_dev->xgs_port[i].irqno = xgs_irqs[i];
-		net_dev->xgs_port[i].config_pde = 1;
-
-		if(xlr_is_mac_active(i, TYPE_XGMAC, &mode) == 1) {
-			net_dev->xgs_port[i].mmio_addr = NLM_BASE(xgmac_offsets[i]);
-			net_dev->xgs_port[i].cfg_flag 	= PORT_OWN_LINUX;
-			net_dev->xgs_port[i].num_desc = num_desc;
-			net_dev->xgs_type[i] = TYPE_XGMAC;
-
-		} else 	if(xlr_is_mac_active(i, TYPE_SPI4, &mode) == 1) {
-			net_dev->xgs_port[i].mmio_addr = NLM_BASE(spi4_offsets[i]);
-			net_dev->xgs_port[i].cfg_flag 	= PORT_OWN_LINUX;
-			net_dev->xgs_port[i].num_desc = num_desc;
-			net_dev->xgs_type[i] = TYPE_SPI4;
-		}
-		/* as descriptors are discontinues we need to pass the 
-           full list */
-		net_dev->xgs_port[i].bucket = &bucket_sizes.bucket[0];
-		if(i == 0)
-			net_dev->xgs_port[i].credit = &cc_table_xgs_0;
-		else
-			net_dev->xgs_port[i].credit = &cc_table_xgs_1;
-	}
-
-	/* Modify the basic configurations with the options 
-			supported in Linux */
-	/* usermac support */
-	if(xlr_hybrid_user_mac()) {
-		for(i = 0; i < NETLOGIC_MAX_GMACS; i++)  {
-			if(net_dev->gmac_port[i].mmio_addr == 0)
-				continue;
-			net_dev->gmac_port[i].cfg_flag     = NLM_PORT_INIT;
-		}
-	}
-	if(xlr_hybrid_user_mac() || xlr_hybrid_user_mac_xgmac()) {
-		for(i = 0; i < NETLOGIC_MAX_XGMACS; i++)  {
-			if(net_dev->xgs_port[i].mmio_addr == 0)
-				continue;
-			net_dev->xgs_port[i].cfg_flag = NLM_PORT_INIT;
-		}
-	}
-
-	if(xlr_hybrid_rmios_ipsec()) {
-		/* port should be enabled by rmios apps
-          after configuring the descriptors */
-		for(i = 0; i < NETLOGIC_MAX_GMACS; i++)  {
-			if(net_dev->gmac_port[i].mmio_addr == 0)
-				continue;
-		//	net_dev->gmac_port[i].cfg_flag     = NLM_PORT_INIT | NLM_PORT_ATTACH;
-			net_dev->gmac_port[i].cfg_flag     = NLM_PORT_ATTACH;
-		}
-		for(i = 0; i < NETLOGIC_MAX_XGMACS; i++)  {
-			net_dev->xgs_port[i].cfg_flag     = 0;
-		}
-	}
-
-	if(xlr_hybrid_rmios_tcpip_stack()) {
-		/* port should be enabled by rmios apps
-          after configuring the descriptors */
-		for(i = 0; i < NETLOGIC_MAX_GMACS; i++)  {
-			if(net_dev->gmac_port[i].mmio_addr == 0)
-				continue;
-			net_dev->gmac_port[i].cfg_flag     = NLM_PORT_ATTACH;
-		}
-		for(i = 0; i < NETLOGIC_MAX_XGMACS; i++)  {
-			net_dev->xgs_port[i].cfg_flag     = 0;
-		}
-	}
-
-	/* dev_tree_en */
-/*
-	if(dev_tree_en) {
-		nlm_dev_config_net();
-	}
-*/
-
-	return;
-#endif /* XLP_SIM */
-}
-
-static int __init xlr_mac_desc_setup(char *str)
-{
-	int desc = simple_strtoul(str, 0, 10);
-	struct net_device_cfg *net_dev = &xlr_net_dev_cfg;
-	int i;
-
-	printk("[%s]: str = \"%s\", desc=%d\n", __FUNCTION__, str, desc);
-	if(desc == 0)
-		return 1;
-
-	for(i = 0; i < NETLOGIC_MAX_GMACS; i++) {
-		if(net_dev->gmac_port[i].num_desc != 0)
-			net_dev->gmac_port[i].num_desc = desc;
-	}
-
-	for(i = 0; i < NETLOGIC_MAX_XGMACS; i++)  {
-		if(net_dev->xgs_port[i].num_desc != 0)
-			net_dev->xgs_port[i].num_desc = desc;
-	}
-
-	return 1;
-}
-
-__setup("xlr_mac_desc=", xlr_mac_desc_setup);
-
-static int __init xls_gmac0_sgmii_setup(char *str)
-{
-	struct net_device_cfg *net_dev = &xlr_net_dev_cfg;
-	
-	if (is_xls()) {
-		if(net_dev->gmac_port[0].phy_mode & PHY_MODE_SELECTABLE) {
-			net_dev->gmac_port[0].phy_mode = 
-				(net_dev->gmac_port[0].phy_mode & PHY_MODE_SELECTABLE) | PHY_MODE_SGMII;
-			net_dev->gmac_port[0].phy_addr = xlr_get_phy_info(0, 
-				net_dev->gmac_port[0].phy_mode, 
-				&net_dev->gmac_port[0].mii_addr, 
-				&net_dev->gmac_port[0].pcs_addr, 
-				&net_dev->gmac_port[0].serdes_addr);
-
-			printk("[%s]: *********************************************\n", __FUNCTION__);
-			printk("[%s]: Enabling SGMII mode for gmac0\n", __FUNCTION__);
-			printk("[%s]: *********************************************\n", __FUNCTION__);
-		}
-	}
-
-	return 1;
-}
-__setup("xls_gmac0_sgmii=", xls_gmac0_sgmii_setup);
-
-
diff --git a/arch/mips/netlogic/xlr/mmu.c b/arch/mips/netlogic/xlr/mmu.c
deleted file mode 100644
index 41d9f4e..0000000
--- a/arch/mips/netlogic/xlr/mmu.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <asm/mach-netlogic/mmu.h>
-
-void mmu_init(void)
-{
-	tlbstats_init();
-	entrylo0_mask_init();
-}
diff --git a/arch/mips/netlogic/xlr/nmi.S b/arch/mips/netlogic/xlr/nmi.S
deleted file mode 100644
index 26d2fa7..0000000
--- a/arch/mips/netlogic/xlr/nmi.S
+++ /dev/null
@@ -1,105 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (�~@~\Netlogic�~@~]). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/init.h>
-
-#include <asm/asm.h>
-#include <asm/asmmacro.h>
-#include <asm/cacheops.h>
-#include <asm/irqflags.h>
-#include <asm/regdef.h>
-#include <asm/fpregdef.h>
-#include <asm/mipsregs.h>
-#include <asm/stackframe.h>
-#include <asm/war.h>
-#include <asm/page.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/interrupt.h>
-
-
-NESTED(nlm_except_vec_nmi, 0, sp)
-	.set push
-	.set noat
-	.set mips64
-	.set noreorder
-	MTC0	k0, OS_KGDB_SCRATCH_REG6
-	nop
-	nop
-	PTR_LA	k0, nlm_nmi_handler
-	jr       k0
-	nop
-	.set pop
-END(nlm_except_vec_nmi)
-
-
-	/* This nmi handler is currently only for taking oprofile samples
-	   on non-zero cpus
-	   */
-NESTED(nlm_nmi_handler, PT_SIZE,  sp)
-	.set	push
-	.set	noat
-	.set noreorder
-	.set 	mips64
-
-	/* Save K0 and K1 first */
-	/* K0 is already saved in nlm_except_vec_nmi */
-	MTC0	k1, OS_KGDB_SCRATCH_REG7
-	
-	/* Clear the  NMI and BEV bits */
-	MFC0	k0, CP0_STATUS
-	li 	k1, 0xffb7ffff
-	and	k0, k0, k1
-	MTC0	k0, CP0_STATUS
-
-	SAVE_ALL
-	CLI
-	TRACE_IRQS_OFF
-
-	li	a0, IRQ_IPI_SMP_KGDB
-	move	a1, sp
-	/* jal	do_nlm_common_IRQ */
-	/* nop */
-	jal	nlm_kgdb_call_nmi_hook
-	nop
-
-	RESTORE_ALL
-
-	/*
-	MFC0 	k0, $15, 1
-	andi	k0, 0x1f
-	sll	k0, 2
-	la	k1, nlm_cpus_in_nmi
- 	PTR_ADDU	k1, k0
-	sw	zero, 0(k1)
-	*/
-
-	MFC0	k0, OS_KGDB_SCRATCH_REG6
-	MFC0	k1, OS_KGDB_SCRATCH_REG7
-	
-	.set mips3
-	eret
-
-	.set pop
-END(nlm_nmi_handler)
diff --git a/arch/mips/netlogic/xlr/on_chip.c b/arch/mips/netlogic/xlr/on_chip.c
deleted file mode 100644
index 35cb87a..0000000
--- a/arch/mips/netlogic/xlr/on_chip.c
+++ /dev/null
@@ -1,786 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are peNLMtted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/module.h>
-#include <linux/timer.h>
-
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/iomap.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/xlr_user_mac.h>
-#include <asm/netlogic/sim.h>
-
-#ifdef CONFIG_NLM_XLP
-#include <asm/netlogic/hal/nlm_hal.h>
-#include <asm/netlogic/hal/nlm_hal_pic.h>
-#endif
-
-unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
-EXPORT_SYMBOL(netlogic_io_base);
-int msgring_timer_irq;
-
-#define MSGRNG_CC_INIT_CPU_DEST(conf, dest,cpu) \
-do { \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][0], 0 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][1], 1 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][2], 2 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][3], 3 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][4], 4 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][5], 5 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][6], 6 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][7], 7 ); \
-} while(0)
-
-/* Initialized CC for cpu 0 to send to all buckets at 0-7 cpus */
-#define MSGRNG_CC_INIT_CPU(conf, cpu) \
-do { \
-  MSGRNG_CC_INIT_CPU_DEST(conf,0,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,1,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,2,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,3,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,4,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,5,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,6,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,7,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,8,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,9,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,10,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,11,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,12,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,13,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,14,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,15,cpu); \
-} while (0)
-
-#define MSGRNG_BUCKETSIZE_INIT_CPU(conf, base) \
-do { \
-  msgrng_write_bucksize(0, conf##bucket_sizes.bucket[base+0]);         \
-  msgrng_write_bucksize(1, conf##bucket_sizes.bucket[base+1]);         \
-  msgrng_write_bucksize(2, conf##bucket_sizes.bucket[base+2]);  \
-  msgrng_write_bucksize(3, conf##bucket_sizes.bucket[base+3]);  \
-  msgrng_write_bucksize(4, conf##bucket_sizes.bucket[base+4]);  \
-  msgrng_write_bucksize(5, conf##bucket_sizes.bucket[base+5]);  \
-  msgrng_write_bucksize(6, conf##bucket_sizes.bucket[base+6]);  \
-  msgrng_write_bucksize(7, conf##bucket_sizes.bucket[base+7]);  \
-} while(0)
-
-#define XLR_MSG_TBL
-#define XLS_MSG_TBL  xls_
-#define SHARED_XLR_MSG_TBL shared_
-
-#define X_MSGRNG_BUCKETSIZE_INIT_CPU(x,y) MSGRNG_BUCKETSIZE_INIT_CPU(x,y)
-
-__u32  pop_bucket_mask[NR_CORES];
-__u32  pop_bucket_start[NR_CORES];
-__u32  pop_bucket_end[NR_CORES];
-__u32 cpu_to_bktmask[NR_CPUS];
-__u32 cpu_to_frstid[NR_CPUS];
-
-uint32_t hard_cpu_online_map = 0;
-uint32_t msgring_global_thread_mask = 0;
-
-/* make this a read/write spinlock */
-spinlock_t msgrng_lock;
-static nlm_common_atomic_t msgring_registered;
-
-int msgring_int_type;
-int msgring_int_en;
-int msgring_watermark_count;
-static __u32 msgring_thread_mask;
-
-extern int nlm_dev_own_bucket_list_get(int *start, int *end, int *mask);
-extern struct irq_chip nlm_common_rsvd_pic;
-extern struct irqaction nlm_common_rsvd_action;
-
-#ifdef CONFIG_PHOENIX_MSGRING_NAPI
-extern int nlm_msgring_napi;
-extern int xlr_napi_ready;
-extern void xlr_napi_rx_schedule(void);
-#endif				/* CONFIG_PHOENIX_MSGRING_NAPI */
-
-struct tx_stn tx_stns[MAX_TX_STNS];
-
-int rxstn_to_txstn_map[128] = {
-	[0 ... 7] = TX_STN_CPU_0,
-	[8 ... 15] = TX_STN_CPU_1,
-	[16 ... 23] = TX_STN_CPU_2,
-	[24 ... 31] = TX_STN_CPU_3,
-	[32 ... 39] = TX_STN_CPU_4,
-	[40 ... 47] = TX_STN_CPU_5,
-	[48 ... 55] = TX_STN_CPU_6,
-	[56 ... 63] = TX_STN_CPU_7,
-	[64 ... 95] = TX_STN_INVALID,
-	[96 ... 103] = TX_STN_GMAC,
-	[104 ... 107] = TX_STN_DMA,
-	[108 ... 111] = TX_STN_INVALID,
-	[112 ... 113] = TX_STN_XGS_0,
-	[114 ... 115] = TX_STN_XGS_1,
-	[116 ... 119] = TX_STN_INVALID,
-	[120 ... 127] = TX_STN_SEC
-};
-
-int xls_rxstn_to_txstn_map[128] = {
-        [0 ... 7] = TX_STN_CPU_0,
-        [8 ... 15] = TX_STN_CPU_1,
-	[16 ... 23] = TX_STN_CPU_2,
-	[24 ... 31] = TX_STN_CPU_3,
-        [32 ... 80] = TX_STN_INVALID,
-	[80 ... 87] = TX_STN_GMAC1,
-	[96 ... 103] = TX_STN_GMAC0,
-	[104 ... 107] = TX_STN_DMA,
-	[108 ... 111] = TX_STN_CMP,
-	[112 ... 115] = TX_STN_INVALID,
-	[116 ... 119] = TX_STN_PCIE,
-	[120 ... 121] = TX_STN_SEC,
-	[122 ... 127] = TX_STN_INVALID,
-};
-
-void dummy_handler(int bucket, int size, int code, int tx_stid,
-		   struct msgrng_msg *msg, void *dev_id)
-{
-	printk("[%s]: No Handler for message from stn_id=%d, bucket=%d, "
-	       "size=%d, msg0=%llx, dropping message\n",
-	       __FUNCTION__, tx_stid, bucket, size,
-	       (unsigned long long)msg->msg0);
-}
-
-struct tx_stn_handler tx_stn_handler_map[128] = {
-	[0 ... 127] = {dummy_handler, NULL},
-};
-
-void nlm_common_msgring_cpu_init(void)
-{
-	int id;
-	unsigned long flags;
-	int shared_msgring = 0;
-
-	id = cpu_logical_map(get_cpu());
-
-	msgring_int_en = 1;
-
-	if (xlr_hybrid_user_mac() || xlr_hybrid_user_mac_xgmac()) {
-		/* msgring interrupt should be disabled */
-		msgring_int_type = 0x0;
-
-		pop_bucket_start[id >> 2] = 0;
-		pop_bucket_end[id >> 2] = 4;
-		pop_bucket_mask[id >> 2] = 0xf;
-	} else {
-		/* all the stations are owned by linux */
-		pop_bucket_start[id >> 2] = 0;
-		pop_bucket_end[id >> 2] = 8;
-		pop_bucket_mask[id >> 2] = 0xff;
-	}
-
-	/* if not thead 0 */
-	if ((id & 0x03) != 0) {
-		put_cpu();
-		return;
-	}
-
-	prom_dbg_msg("Initializing message ring for cpu_%d\n", id);
-
-	msgrng_flags_save(flags);
-
-	/* Message Stations are shared among all threads in a cpu core
-	 * Assume, thread 0 on all cores are always active when more than
-	 * 1 thread is active in a core
-	 */
-	if (is_xls()) {
-		if (id == 0) {
-			X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL, 0);
-			MSGRNG_CC_INIT_CPU(XLS_MSG_TBL, 0);
-		} else if (id == 4) {
-			X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL, 8);
-			MSGRNG_CC_INIT_CPU(XLS_MSG_TBL, 1);
-		} else if (id == 8) {
-			X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL, 16);
-			MSGRNG_CC_INIT_CPU(XLS_MSG_TBL, 2);
-		} else if (id == 12) {
-			X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL, 24);
-			MSGRNG_CC_INIT_CPU(XLS_MSG_TBL, 3);
-		}
-	} else {
-		if (shared_msgring) {
-			if (id == 0) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     0);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 0);
-			} else if (id == 4) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     8);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 1);
-			} else if (id == 8) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     16);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 2);
-			} else if (id == 12) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     24);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 3);
-			} else if (id == 16) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     32);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 4);
-			} else if (id == 20) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     40);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 5);
-			} else if (id == 24) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     48);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 6);
-			} else if (id == 28) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     56);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 7);
-			}
-		} else {
-			if (id == 0) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 0);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 0);
-			} else if (id == 4) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 8);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 1);
-			} else if (id == 8) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 16);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 2);
-			} else if (id == 12) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 24);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 3);
-			} else if (id == 16) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 32);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 4);
-			} else if (id == 20) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 40);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 5);
-			} else if (id == 24) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 48);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 6);
-			} else if (id == 28) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 56);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 7);
-			}
-		}
-	}
-	msgrng_flags_restore(flags);
-	put_cpu();
-}
-
-void nlm_common_msgring_config(void)
-{
-
-#ifdef CONFIG_PHOENIX_MSGRING_NAPI
-	/* If we use NAPI then we enable queue non-empty interrupt */
-	msgring_int_type = nlm_msgring_napi ? 0x01 : 0x02;
-#else
-	msgring_int_type = 0x02;
-#endif				/* CONFIG_PHOENIX_MSGRING_NAPI */
-
-	msgring_watermark_count = 1;
-	msgring_thread_mask = 0x0f;
-
-/* 	printk("[%s]: int_type = 0x%x, pop_num_buckets=%d, pop_bucket_mask=%x" */
-/* 	       "watermark_count=%d, thread_mask=%x\n", __FUNCTION__, */
-/* 	       msgring_int_type, msgring_pop_num_buckets, msgring_pop_bucket_mask, */
-/* 	       msgring_watermark_count, msgring_thread_mask); */
-}
-
-void nlm_common_derive_cpu_to_bkt_map(void)
-{
-	int cpus_per_core[NR_CORES];
-	int stns_per_core[NR_CORES];
-	int num_cpus, cpus, cpu_off, from, i;
-	int bucket_mask[NR_CPUS_PER_CORE];
-	int fr_bucket[NR_CPUS_PER_CORE];
-	int core, bkt_idx, bkt_mask;
-
-#define GET_NEXT_SET_BIT_U8(val, rv) { \
-    if(val < ( 1 << rv)) \
-        rv = 0; \
-    for(i = rv; val != 0 && i <= 7; i++) { \
-        if(val & (1 << i)) { \
-            rv = i; \
-            break; \
-        } \
-    }  \
-    if( i >= 8) \
-        rv = 0; \
-}
-
-	memset(cpus_per_core, 0, sizeof(cpus_per_core));
-	memset(stns_per_core, 0, sizeof(stns_per_core));
-
-	for (i = 0; i < NR_CPUS; i++) {
-		if (!(hard_cpu_online_map & (1 << i)))
-			continue;
-		core = i / NR_CPUS_PER_CORE;
-		cpus_per_core[core]++;
-	}
-	for (core = 0; core < NR_CORES; core++) {
-		for (i = 0; i < NR_STNS_PER_CORE; i++) {
-			if (!(pop_bucket_mask[core] & (1 << i)))
-				continue;
-			stns_per_core[core]++;
-		}
-	}
-
-	for (core = 0; core < NR_CORES; core++) {
-		int filled_all = 0;
-		int rv = 0;
-		uint8_t fr_bucket_map = 0;
-		memset(bucket_mask, 0, sizeof(bucket_mask));
-		memset(fr_bucket, 0xff, sizeof(fr_bucket));
-
-        num_cpus = cpus_per_core[core];
-        if(num_cpus == 0)
-            continue;
-        for(cpus = 0, bkt_idx = 0, bkt_mask = pop_bucket_mask[core];
-                bkt_mask; bkt_mask = bkt_mask >> 1, bkt_idx++) {
-            if(!(bkt_mask & 0x01))
-                continue;
-            bucket_mask[cpus] |=  (1 << bkt_idx);
-			
-			if(((int)fr_bucket[cpus] != -1) && (fr_bucket[cpus] < NR_CPUS_PER_CORE))
-                fr_bucket_map &= (~(1 << fr_bucket[cpus]));
-            fr_bucket_map |= (1 << bkt_idx);
-			fr_bucket[cpus] = bkt_idx;
-
-			if((cpus + 1) == num_cpus)
-            	filled_all = 1;
-
-            cpus = (cpus + 1) % num_cpus;
-        }
-
-        /* fill the non filled cpus */
-		if(filled_all == 0) {
-	        for(from = 0; cpus < num_cpus; cpus++, from++) {
-    	        bucket_mask[cpus] = bucket_mask[from];
-       	 	}
-		}
-        cpu_off = core * NR_CPUS_PER_CORE;
-        for(from = 0, cpus = cpu_off;
-                cpus < cpu_off + NR_CPUS_PER_CORE; cpus++) {
-            if(!(hard_cpu_online_map & (1 << cpus)))
-                continue;
-            cpu_to_bktmask[cpus] = bucket_mask[from];
-			GET_NEXT_SET_BIT_U8(fr_bucket_map, rv);
-            cpu_to_frstid[cpus] = rv + (core * NR_STNS_PER_CORE);
-            from++;
-			rv++;
-        }
-    }
-#if 0
-	for (i = 0; i < NR_CPUS; i++)
-		printk("%d: bktmask=0x%x frstid=%d\n",
-		       i, cpu_to_bktmask[i], cpu_to_frstid[i]);
-#endif
-
-	return;
-}
-
-static int __init xlr_msgring_watermark_setup(char *str)
-{
-	if (*str == '=')
-		str++;
-
-	msgring_watermark_count = (int)simple_strtoul(str, NULL, 10);
-
-	return 1;
-}
-
-static int __init xlr_msgring_thread_mask_setup(char *str)
-{
-	if (*str == '=')
-		str++;
-
-	msgring_thread_mask = simple_strtoul(str, NULL, 16);
-	msgring_thread_mask &= 0x0f;
-
-	return 1;
-}
-
-static int __init xlr_complete_msgring_thread_mask_setup(char *str)
-{
-	if (*str == '=')
-		str++;
-	msgring_global_thread_mask = simple_strtoul(str, NULL, 16);
-	msgring_global_thread_mask &= 0xffffffff;
-	return 1;
-}
-
-__setup("xlr_msgring_watermark=", xlr_msgring_watermark_setup);
-__setup("xlr_msgring_thread_mask=", xlr_msgring_thread_mask_setup);
-__setup("xlr_complete_msgring_thread_mask=",
-	xlr_complete_msgring_thread_mask_setup);
-
-extern void nlm_cpu_stat_update_msgring_int(void);
-extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
-extern void nlm_cpu_stat_update_msgring_pic_int(void);
-
-void msgring_process_rx_msgs(int start_bucket, int end_bucket,
-			     __u32 pop_bucket_mask)
-{
-	unsigned int bucket_empty_bm = 0;
-	int bucket = 0;
-	int size = 0, code = 0, rx_stid = 0;
-	struct msgrng_msg msg;
-	struct tx_stn_handler *handler = 0;
-	unsigned int status = 0;
-
-#ifdef CONFIG_PHOENIX_MSGRING_NAPI
-	if (xlr_napi_ready && in_irq()) {
-		xlr_napi_rx_schedule();
-		return;
-	}
-#endif				/* CONFIG_PHOENIX_MSGRING_NAPI */
-
-	/* First Drain all the high priority messages */
-	for (;;) {
-
-		bucket_empty_bm =
-		    (msgrng_read_status() >> 24) & pop_bucket_mask;
-
-		/* all buckets empty, break */
-		if (bucket_empty_bm == pop_bucket_mask)
-			break;
-
-		for (bucket = start_bucket; bucket < end_bucket; bucket++) {
-
-			if ((bucket_empty_bm & (1 << bucket)) ||	/* empty */
-			    !((1 << bucket) & pop_bucket_mask))	/* not in mask */
-				continue;
-
-			status =
-			    message_receive(bucket, &size, &code, &rx_stid,
-					    &msg);
-			if (status)
-				continue;
-
-			handler = &tx_stn_handler_map[rx_stid];
-			/* Handler is always present. If not actual, atleast 
-			 * dummy_handler
-			 */
-			(handler->action) (bucket, size, code, rx_stid, &msg,
-					   handler->dev_id);
-		}
-	}
-}
-
-#if !defined(CONFIG_NLMCOMMON_MAC) && !defined(CONFIG_NLM_XLP)
-//__u64 xlr_cp2_exceptions[32];
-//struct user_mac_kernal_data user_mac_krnl_data;
-//struct xlr_user_mac_config xlr_user_mac;
-void nlm_cpu_stat_update_msgring_int(void) { }
-void nlm_cpu_stat_update_msgring_cycles(__u32 cycles) { }
-void nlm_cpu_stat_update_msgring_pic_int(void) { }
-#endif /* CONFIG_PHOENIX_MAC */
-
-__u32 msgrng_msg_cycles = 0;
-void nlm_xlr_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
-{
-	unsigned long mflags;
-	int core;
-	__u32 cycles = 0;
-
-	if (irq == IRQ_MSGRING) {
-		/* normal message ring interrupt */
-		xlr_inc_counter(MSGRNG_INT);
-		nlm_cpu_stat_update_msgring_int();
-	} else {
-		nlm_cpu_stat_update_msgring_pic_int();
-	}
-
-
-	//dbg_msg("IN irq=%d\n", irq);
-
-	/* TODO: not necessary to disable preemption */
-	msgrng_flags_save(mflags);
-
-	cycles = read_c0_count();
-
-	core = cpu_logical_map(smp_processor_id()) >> 2;
-	msgring_process_rx_msgs(pop_bucket_start[core], pop_bucket_end[core], pop_bucket_mask[core]);
-
-	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
-
-	msgrng_flags_restore(mflags);
-
-	//dbg_msg("OUT irq=%d\n", irq);
-
-}
-
-static void enable_msgring_int(void *info)
-{
-	unsigned long flags = 0, mflags = 0;
-	unsigned int th_mask;
-	unsigned int core;
-	msgrng_access_save(&msgrng_lock, flags, mflags);
-
-	core = hard_smp_processor_id() & ~(0x3);
-	th_mask = (msgring_global_thread_mask >> core) & 0x0f;
-
-#if 0
-	printk
-	    ("[%s:%d] cpu_%d cpu_online_map=0x%04x msgring_global_mask=0x%08x "
-	     "th_mask=0x%02x intype=%d wm=%d\n", __FUNCTION__, __LINE__,
-	     hard_smp_processor_id(), hard_cpu_online_map,
-	     msgring_global_thread_mask, th_mask, msgring_int_type,
-	     msgring_watermark_count);
-#endif
-
-	/* enable the message ring interrupts */
-	msgrng_write_config((msgring_watermark_count << 24) |
-			    (IRQ_MSGRING << 16)
-			    | (th_mask << 8) | msgring_int_type);
-	msgrng_access_restore(&msgrng_lock, flags, mflags);
-}
-
-static void msgring_bkp_timer(unsigned long data)
-{
-	unsigned long flags;
-	struct timer_list *timer = (struct timer_list *)data;
-	local_irq_save(flags);
-	irq_enter();
-	nlm_xlr_msgring_int_handler(-1,NULL);
-	irq_exit();
-	local_irq_restore(flags);
-	mod_timer(timer, timer->expires+2);
-}
-
-static void enable_msgring_timer(void *data)
-{
-	struct timer_list *timer;
-	timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
-	setup_timer(timer, msgring_bkp_timer, (unsigned long)timer);
-	timer->expires = jiffies + 2;
-	add_timer(timer);
-}
-
-extern spinlock_t nlm_common_pic_lock;
-int register_msgring_handler(int major,
-			     void (*action) (int, int, int, int,
-					     struct msgrng_msg *, void *),
-			     void *dev_id)
-{
-	struct tx_stn_handler *handler = 0;
-	int ret = 1;
-	int i,j,tx_stid;
-	unsigned long flags = 0;
-	cpumask_t timer_cpu_mask;
-
-	if (major >= MAX_TX_STNS || action == NULL) {
-		printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
-		       "MAX_TX_STN=%d action=%p",
-		       __FUNCTION__, __LINE__, major, MAX_TX_STNS, action);
-		return ret;
-	}
-
-	/* Check if the message station is valid, if not return error */
-	spin_lock_irqsave(&msgrng_lock, flags);
-
-	for (i = 0; i < 128; i++) {
-		if (is_xls())
-			tx_stid = xls_rxstn_to_txstn_map[i];
-		else
-			tx_stid = rxstn_to_txstn_map[i];
-		if (tx_stid == major) {
-			tx_stn_handler_map[i].action = action;
-			tx_stn_handler_map[i].dev_id = dev_id;
-		}
-	}
-
-	handler = &tx_stns[major].handler;
-
-	// dbg_msg("major=%d, action=%p, dev_id=%p\n", major, action, dev_id);
-	handler->action = action;
-	handler->dev_id = dev_id;
-
-	ret = 0;
-	spin_unlock_irqrestore(&msgrng_lock, flags);
-
-	if (!ret && nlm_common_test_and_set(&msgring_registered)) {
-		int i=0;
-
-		hard_cpu_online_map = 0;
-		for (i = 0; i < NR_CPUS; i++) {
-			if (cpu_isset(i, cpu_online_map))
-				hard_cpu_online_map |=
-				    (1 << cpu_logical_map(i));
-		}
-
-		/* derive the cpu to bucket map */
-		nlm_common_derive_cpu_to_bkt_map();
-
-
-		/* Configure PIC to deliver msgring interrupt for timeouts */
-		if (msgring_global_thread_mask == 0) {
-			for (i = 0; i < NR_CORES; i++) {
-				msgring_global_thread_mask |=
-				    (msgring_thread_mask << (i << 2));
-			}
-		}
-
-		msgring_global_thread_mask &= hard_cpu_online_map;
-
-		/* configure the msgring interrupt on all cpus */
-		if (msgring_int_en)
-			on_each_cpu(enable_msgring_int, 0, 1);
-
-/* 		printk("[%s]: cpu_online_map = %lx, hard_cpu_online_map=%x, " */
-/* 		       "msgring_global_thread_mask=%x\n", */
-/* 		       __FUNCTION__,  */
-/* 		       (unsigned long)cpu_online_map,  */
-/* 		       hard_cpu_online_map,  */
-/* 		       msgring_global_thread_mask); */
-
-		/* Schedule a messagering backup timer at every 2 jiffies on one 
-		   therad per core 
-		 */
-
-		cpus_clear(timer_cpu_mask);
-		for(i = 0; i < NR_CORES; i++) {
-			int core_mask;			
-			int phys_id, logical_id;
-			if(hard_cpu_online_map & (0xf<<(i*NR_CPUS_PER_CORE))){
-				core_mask = (hard_cpu_online_map>>(i*NR_CPUS_PER_CORE)) & 0xf;
-				for(j=0; j<NR_CPUS_PER_CORE; j++){
-					if(core_mask & (1<<j))
-						break;
-				}
-				phys_id = (i*NR_CPUS_PER_CORE) + j;
-				logical_id = cpu_number_map(phys_id);
-				cpu_set(logical_id, timer_cpu_mask);
-			}
-		}
-		preempt_disable();
-		smp_call_function_many(&timer_cpu_mask, enable_msgring_timer, NULL, 1);
-		preempt_enable();
-		if(cpu_isset(cpu_number_map(hard_smp_processor_id()),timer_cpu_mask))
-			enable_msgring_timer(NULL);
-	}
-
-	return ret;
-}
-
-EXPORT_SYMBOL(register_msgring_handler);
-
-static void pic_init(void)
-{
-	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
-	int i = 0;
-	int level;
-	uint32_t thread_mask = (1 << hard_smp_processor_id());
-
-	for (i = 0; i < PIC_NUM_IRTS; i++) {
-
-		level = PIC_IRQ_IS_EDGE_TRIGGERED(i);
-
-		/* Bind all PIC irqs to boot cpu */
-		netlogic_write_reg(mmio, PIC_IRT_0_BASE + i, thread_mask);
-
-		/* Use local scheduling and high polarity for all IRTs
-		 * Invalidate all IRTs, by default
-		 */
-		netlogic_write_reg(mmio, PIC_IRT_1_BASE + i,
-				  (level << 30) | (1 << 6) | (PIC_IRQ_BASE +
-							      i));
-	}
-}
-
-atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
-
-static void nlm_usb_init (void)
-{
-	nlm_reg_t * gpio_mmio = netlogic_io_mmio(NETLOGIC_IO_GPIO_OFFSET);
-	nlm_reg_t * usb_mmio  = netlogic_io_mmio(NETLOGIC_IO_USB_1_OFFSET);
-
-   /* The NLM-Specific USB Block */
-   netlogic_write_reg(usb_mmio, 49, 0x10000000); //Clear Rogue Phy INTs
-   netlogic_write_reg(usb_mmio, 50, 0x1f000000);
-
-	if (is_xls1xx()) {
-		/* Enabling only 1 USB Port */
-		if (xlr_board_atx_viii()) {
-			/* LTE board has usb port #1 */
-			netlogic_write_reg(usb_mmio,  1, 0x05000500);
-		}
-		else {
-			/* enable usb port #0 */
-			netlogic_write_reg(usb_mmio,  1, 0x03000500);
-		}
-	}
-	else {
-   	netlogic_write_reg(usb_mmio,  1, 0x07000500);
-	}
-
-   {
-      volatile unsigned int value = gpio_mmio[21];
-      if ((value >> 22) & 0x01) {
-         printk("Detected USB Host mode..\n");
-         netlogic_write_reg(usb_mmio,  0, 0x02000000);
-      }
-      else {
-         printk("Detected USB Device mode..\n");
-         netlogic_write_reg(usb_mmio,  0, 0x01000000);
-      }
-   }
-}
-
-void on_chip_init(void)
-{
-	int i = 0, j = 0;
-
-	cpu_logical_map(0)  = hard_smp_processor_id();
-
-	/* Set netlogic_io_base to the run time value */
-	spin_lock_init(&msgrng_lock);
-
-	msgring_registered.value = 0;
-
-#if defined(CONFIG_NLM_XLP)
-	nlm_hal_init();
-#endif
-
-	nlm_common_msgring_config();
-
-	pic_init(); 
-
-	nlm_common_msgring_cpu_init();
-
-
-
-	for (i = 0; i < NR_CPUS; i++)
-		for (j = 0; j < NLM_MAX_COUNTERS; j++)
-			atomic_set(&nlm_common_counters[i][j], 0);
-
-	if (is_xls())
-		nlm_usb_init();
-}
diff --git a/arch/mips/netlogic/xlr/time.c b/arch/mips/netlogic/xlr/time.c
index 8660b6c..0d81b26 100644
--- a/arch/mips/netlogic/xlr/time.c
+++ b/arch/mips/netlogic/xlr/time.c
@@ -1,224 +1,51 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are peNLMtted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*
+ * Copyright 2003-2011 NetLogic Microsystems, Inc. (NetLogic). All rights
+ * reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the NetLogic
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NETLOGIC ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
 
-#include <linux/interrupt.h>
-#include <linux/sched.h>
-#include <linux/spinlock.h>
-
-#include <asm/irq.h>
-#include <asm/ptrace.h>
-#include <asm/addrspace.h>
 #include <asm/time.h>
-#include <asm/cpu.h>
-#include <asm/cpu-features.h>
-#include <asm/perfctr.h>
-#include <linux/oprofile.h>
-
-#include <linux/proc_fs.h>
-
-extern spinlock_t phnx_pic_lock;
-
-#if defined(CONFIG_PERFCTR) && defined(CONFIG_OPROFILE)
-#error "Cannot enable both VPERF and OProfile at the same time"
-#endif
-
-#ifndef CONFIG_NLMCOMMON_MAC
-void nlm_common_user_mac_update_time(void)
-{
-}
-void nlm_common_user_mac_update_ktime(void)
-{
-}
-#else
-extern void nlm_common_user_mac_update_time(void);
-extern void nlm_common_user_mac_update_ktime(void);
-#endif
- 
-extern struct irq_chip phnx_rsvd_pic;
-extern struct irqaction phnx_rsvd_action;
-
-void save_epc(unsigned long *epc)
-{
-	__asm__ __volatile__(".set push\n"
-			     ".set noreorder\n"
-			     "mfc0 %0, $14\n" ".set pop\n":"=r"(*epc));
-}
-
-#ifdef CONFIG_OPROFILE
-extern void xlr_oprofile_int_handler(int irq, void *dev_id,
-					 struct pt_regs *regs);
-#endif
-void xlr_timer_interrupt(struct pt_regs *regs, int irq)
-{
-	int cpu = smp_processor_id();
-
-#ifdef CONFIG_NLM_WATCHDOG
-        nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
-
-	/* ack the watchdog */
-	netlogic_write_reg(mmio, 0x0c, 1 << cpu_logical_map(cpu));
-#endif
-
-#if defined (CONFIG_OPROFILE) || defined (CONFIG_PERFCTR_INTERRUPT_SUPPORT)
-    int cntr0, cntr1;
-    uint32_t ctrl0, ctrl1;
-	int    perfctr_overflow = 0;
-#endif
-
-	if (irq != IRQ_TIMER) {
-		printk("[%s]:cpu_%d: bad timer irq = %x\n", __FUNCTION__, cpu, irq);
-		BUG();
-	}
-
-#if defined (CONFIG_PERFCTR_INTERRUPT_SUPPORT) || defined (CONFIG_OPROFILE)
-    ctrl0 = __read_32bit_c0_register($25, 0);
-    ctrl1 = __read_32bit_c0_register($25, 2);
-    cntr0 = __read_32bit_c0_register($25, 1);
-    cntr1 = __read_32bit_c0_register($25, 3);
-
-    /* if interrupts are enabled for perf events, check if any counter has
-       overflowed. Then we know for sure that this is a perf event
-       */
-    if((ctrl0 & 0x10) || (ctrl1 & 0x10))
-            if((cntr0 < 0) || (cntr1 < 0))
-                perfctr_overflow = 1;
-    if(perfctr_overflow == 0)
-#endif
-    {
-        do_IRQ(irq);
-
-        if (cpu == 0) {
-            nlm_common_user_mac_update_time();
-	    nlm_common_user_mac_update_ktime();
-        }
-    }
-
-#if defined (CONFIG_PERFCTR_INTERRUPT_SUPPORT) || defined (CONFIG_OPROFILE)
-	if (perfctr_overflow) {
-#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-		(*perfctr_ihandler) (instruction_pointer(regs));
-#endif
-    }
-#ifdef CONFIG_OPROFILE
-	if (perfctr_overflow) {
-		if(netlogic_thr_id() == 0) {
-			nlm_common_oprofile_int_handler (irq, NULL, regs);
-		}
-    }
-#endif
-#endif
-
-}
-
-/* PIC clock at 66Mhz takes more than 60 secs to come to 0 from max. So 32bit 
-   counter is sufficient
-   */
-#define PIC_FREE_RUNNING_TIMER_MAX_VAL 0xffffffff
-cycle_t xlr_hpt_read(void)
-{
-	uint32_t counter = 0;
-	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
-	counter = netlogic_read_reg(mmio, PIC_TIMER_6_COUNTER_0);
-	return (cycle_t)(PIC_FREE_RUNNING_TIMER_MAX_VAL - counter);
-}
-EXPORT_SYMBOL(xlr_hpt_read);
+#include <asm/netlogic/interrupt.h>
+#include <asm/netlogic/psb-bootinfo.h>
 
-int read_current_timer(unsigned long *timer_val)
+unsigned int __cpuinit get_c0_compare_int(void)
 {
-	*timer_val = xlr_hpt_read();
-	return 0;
+	return IRQ_TIMER;
 }
 
-void nlm_common_timer_setup(void)
+void __init plat_time_init(void)
 {
-        nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
-        unsigned long flags = 0;
-
-        spin_lock_irqsave(&phnx_pic_lock, flags);
-
-        /* Use PIC Timer 6 as a free running counter */
-        netlogic_write_reg(mmio, PIC_TIMER_6_MAXVAL_0, 0xffffffff);
-        netlogic_write_reg(mmio, PIC_TIMER_6_MAXVAL_1, 0xffffffff);
-        /* we Don't need interrupts */
-        netlogic_write_reg(mmio, PIC_IRT_0_TIMER_6, 0);
-        netlogic_write_reg(mmio, PIC_IRT_1_TIMER_6,
-                          (1 << 31) | (0 << 30) | (1 << 6) | (PIC_TIMER_6_IRQ));
-        pic_update_control(1 << (8 + 6));
-
-        spin_unlock_irqrestore(&phnx_pic_lock, flags);
-
-        //do_gettimeoffset = xlr_gettimeoffset;
-
+	mips_hpt_frequency = nlm_prom_info.cpu_frequency;
+	pr_info("MIPS counter frequency [%ld]\n",
+		(unsigned long)mips_hpt_frequency);
 }
-
-static int nlm_timer_proc_read(char *page, char **start, off_t off, int count,
-			       int *eof, void *data)
-{
-	int len = 0;
-
-	preempt_disable();
-	len += sprintf(page + len, "cpu = %d, eimr = 0x%016llx, status = 0x%x\n", 
-				   smp_processor_id(), 
-                   (unsigned long long)read_64bit_cp0_eimr(), read_c0_status());
-	preempt_enable();
-	*eof = 1;
-
-	return len;
-}
-
-extern struct proc_dir_entry *nlm_root_proc;
-struct proc_dir_entry *main_entry;
-struct proc_dir_entry *sub_entry;
-
-static int init_pic_timer_procfs(void)
-{
-	main_entry = proc_mkdir("nlm_timer", nlm_root_proc);
-	if (!main_entry) {
-		printk(KERN_ERR "unable to create /proc/nlm_timer\n");
-		return -ENOMEM;
-	}
-
-	sub_entry = create_proc_entry("debug", 0644, main_entry);
-
-	if (!sub_entry) {
-		remove_proc_entry("nlm_timer", nlm_root_proc);
-		return -ENOMEM;
-	}
-
-	sub_entry->read_proc = nlm_timer_proc_read;
-
-	printk("created NLM_timer proc fs entry\n");
-
-	return 0;
-}
-
-static void exit_pic_timer_procfs(void)
-{
-	remove_proc_entry("debug", main_entry);
-	remove_proc_entry("nlm_timer", nlm_root_proc);
-}
-
-module_init(init_pic_timer_procfs);
-module_exit(exit_pic_timer_procfs);
-- 
1.7.0.4

