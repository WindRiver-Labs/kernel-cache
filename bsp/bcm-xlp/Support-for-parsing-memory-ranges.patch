From 083ae854985dd67e197091bbdc93c21fbaf077b0 Mon Sep 17 00:00:00 2001
From: Nebu Philips <nphilips@jakarta.razamicroelectronics.com>
Date: Tue, 25 May 2010 13:31:45 -0700
Subject: [PATCH 035/761] Support for parsing memory ranges

Add sample DTS file for XLP

Based on Broadcom SDK 2.3.

Signed-off-by: Nebu Philips <nphilips@jakarta.razamicroelectronics.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/boot/dts/xlp.dts |  307 +++++++++++++++++++++++++++++++++++
 arch/mips/netlogic/xlp/setup.c      |   76 ++++++---
 2 files changed, 364 insertions(+), 19 deletions(-)
 create mode 100644 arch/mips/netlogic/boot/dts/xlp.dts

diff --git a/arch/mips/netlogic/boot/dts/xlp.dts b/arch/mips/netlogic/boot/dts/xlp.dts
new file mode 100644
index 0000000..883338c
--- /dev/null
+++ b/arch/mips/netlogic/boot/dts/xlp.dts
@@ -0,0 +1,307 @@
+/* XLP8XX Device Tree Source 
+ */
+
+/dts-v1/;
+/ {
+	model = "MIPS,XLP8XX";
+	compatible = "NETL,XLP8XX_A0";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	doms {
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		dom@0 {
+			device_type = "domain";
+			cpu {
+				onlinemask = <0xff>;
+			};
+			uart {
+				id = <0>;
+			};
+			memory {
+				reg = <0x00100000 0x0FF00000	// 255M at 1M
+					   0x20000000 0x20000000>;  // 512M at 512M
+			};
+			pic {
+			};
+		};
+		dom@1 {
+			device_type = "domain";
+			cpu {
+				onlinemask = <0xffff0000>;
+			};
+			uart {
+				id = <1>;
+			};
+			memory {
+			};
+		};
+		dom@2 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@3 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@4 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@5 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@6 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@7 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@8 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@9 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@10 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@11 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@12 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@13 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@14 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@15 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@16 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@17 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@18 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@19 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@20 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@21 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@23 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@24 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@25 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@26 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@27 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@28 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@29 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@30 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+		dom@31 {
+			device_type = "domain";
+			cpu {
+			};
+			uart {
+			};
+			memory {
+			};
+		};
+	};
+
+	chosen {
+		bootargs = "xlp_noi2c console=ttyS0,115200 rdinit=/sbin/init";
+	};
+};
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index f32a465..ea3a1e9 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -120,7 +120,7 @@ extern void *fdt_init(void *blob);
 extern void *simple_alloc_init(char *base, unsigned long heap_size,
 		unsigned long granularity, unsigned long max_allocs);
 
-int onlinemask = 0x1;
+unsigned int onlinemask = 0x1;
 
 /* Struct for temp. allocation
  * of sp/gp for secondary CPUs 
@@ -570,46 +570,84 @@ extern struct plat_smp_ops nlm_smp_ops;
 
 static int fdt_process(void) 
 {
+	int  domain=0;
+	char domstr[32] = "";
+	int  i, na, ns, regs[4], entries;
+
 	/* If booted using FDT and U-Boot, all
 	 * we get is a pointer to an FDT Blob
 	 */
 	void *blob = (void *)fw_arg0;
 	void *node;
 
-	/* We try to create a region starting
-	 * from (_end + 64K) of size 8MB for
-	 * the FDT structures. The 64K is the
-	 * current page size for XEN
+	/* Create a region starting from
+	 * (_end + 64K) of size 8MB for
+	 * the FDT structures. The 64K is
+	 * the current page size for XEN
 	 */
 	simple_alloc_init((char *)((unsigned long)(&_end)+0x10000),
 			(8<<20), 32, 128);
 
-	/* Create a local copy of the FDT */
+	/* Create a local copy of the FDT 
+	 */
 	fdt = fdt_init(blob);
 
-	/* Grab the bitmask of CPUs to 
-	 * bring online, from the FDT
+	/* extract cmdline params
 	 */
-	node = finddevice("/cpus");
+	node = finddevice("/chosen");
 	if (node) {
-		if (getprop(node, "onlinemask", &onlinemask, 
-					sizeof(onlinemask)) < 0)
+		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
 			return -1;
+		strcat(arcs_cmdline, prop_buf);
+	}
+	
+	/* extract memory ranges,
+	 * add to command line
+	 */
+	node = finddevice("/doms/dom@0");
+	if (node) {
+		if (getprop(node, "#address-cells", &na, sizeof(na)) < 0)
+			na = 1;
+		if (na < 1 || na > 2)
+			printk("Can't cope with #address-cells == %d.\n\r", na);
+		if (getprop(node, "#size-cells", &ns, sizeof(ns)) < 0)
+			ns = 1;
+		if (ns < 1 || ns > 2)
+			printk("Can't cope with #size-cells == %d.\n\r", ns);
 	}
-	if (!onlinemask) 
-		onlinemask = 0x1;
 
-	/* extract bootloader-passed
-	 * cmdline params
+	node = finddevice("/doms/dom@0/memory");
+	if (node) {
+		entries = (getprop(node, "reg", regs, sizeof(regs))) / sizeof(regs[0]);
+		if (!entries || (entries % (na+ns)))
+			printk("Invalid Memory Map Specified!\n");
+		
+		for (i=0; i<entries; i+=2) {
+			sprintf(domstr, " mem=%dm@%dm ", 
+					(regs[i+1]>>20), (regs[i]>>20));
+			strcat(arcs_cmdline, domstr);
+			memset((void *)&domstr, '\0', sizeof(domstr));
+		}
+	}
+		
+	printk("FDT Cmdline: %s\n", arcs_cmdline);
+
+	/* extract CPU online mask for 
+	 * domain 0 (linux)
 	 */
-	node = finddevice("/chosen");
+	sprintf(domstr, "/doms/dom@%d/cpu", domain);
+
+	node = finddevice(domstr);
 	if (node) {
-		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
+		if (getprop(node, "onlinemask", &onlinemask, 
+					sizeof(onlinemask)) < 0) 
 			return -1;
-		printk("Firmware Cmdline: %s\n", prop_buf);
-		strcat(arcs_cmdline, prop_buf);
 	}
 
+	if (!onlinemask) 
+		/* something went wrong ? */
+		onlinemask = 0x1;
+
 	return 0;
 }
 
-- 
1.7.10.4

