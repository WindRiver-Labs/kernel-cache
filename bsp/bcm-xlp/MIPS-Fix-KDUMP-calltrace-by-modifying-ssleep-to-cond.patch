From ced5d2fe2222d9a6364c6b4d7ea8522ba95bd672 Mon Sep 17 00:00:00 2001
From: Tian Le <le.tian@windriver.com>
Date: Fri, 25 Feb 2011 16:31:24 -0400
Subject: [PATCH 10/11] MIPS: Fix KDUMP calltrace by modifying ssleep to
 conditional ssleep

The calltrace is caused by bash thread scheduling in atomic context.
the preempt disable comes from the handling of the sysrq-c
(triggered by "echo c > /proc/sysrq-trigger") in __handle_sysrq(),
where it takes a spinlock before calling the sysrq handler. The handler
in turn calls die(), which, on MIPS, for some reason, sleeps for 5
seconds before calling panic(). A valid solution for this
would be to put the ssleep() call in die() within two checks.

Signed-off-by: Tian Le <le.tian@windriver.com>
Signed-off-by: Guojian Zhou <guojian.zhou@windriver.com>
---
 arch/mips/kernel/traps.c |   13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 7970392..7d77cf3 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -392,6 +392,10 @@ static int regs_to_trapnr(struct pt_regs *regs)
 
 static DEFINE_RAW_SPINLOCK(die_lock);
 
+#ifdef CONFIG_KEXEC
+extern struct kimage *kexec_crash_image;
+#endif
+
 void __noreturn die(const char *str, struct pt_regs *regs)
 {
 	static int die_counter;
@@ -426,8 +430,15 @@ void __noreturn die(const char *str, struct pt_regs *regs)
 		panic("Fatal exception in interrupt");
 
 	if (panic_on_oops) {
+		int do_sleep = 1;
 		printk(KERN_EMERG "Fatal exception: panic in 5 seconds");
-		ssleep(5);
+
+#ifdef CONFIG_KEXEC
+		if (kexec_crash_image)
+			do_sleep = 0;
+#endif
+		if (do_sleep)
+			ssleep(5);
 		panic("Fatal exception");
 	}
 
-- 
1.7.10.4

