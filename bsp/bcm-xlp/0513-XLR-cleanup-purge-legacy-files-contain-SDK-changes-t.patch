From 7d3e89d28896362de12bc9144dff14b440c06843 Mon Sep 17 00:00:00 2001
From: Zi Shen Lim <zlim@netlogicmicro.com>
Date: Tue, 10 Jan 2012 19:13:57 -0800
Subject: [PATCH 513/763] XLR: cleanup, purge legacy files, contain SDK changes to XLP

Based on Broadcom SDK 2.3.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                                  |   13 +-
 arch/mips/include/asm/addrspace.h                  |    2 +-
 arch/mips/include/asm/bitops.h                     |    4 +-
 arch/mips/include/asm/cacheflush.h                 |    2 +-
 arch/mips/include/asm/cpu-features.h               |    2 +
 arch/mips/include/asm/dma.h                        |    2 +-
 arch/mips/include/asm/mach-netlogic/ioremap.h      |    6 +-
 .../include/asm/mach-netlogic/kernel-entry-init.h  |    6 +
 arch/mips/include/asm/mach-netlogic/mmu.h          |   11 -
 arch/mips/include/asm/mach-netlogic/pci-dma.h      |    8 -
 arch/mips/include/asm/mach-netlogic/spaces.h       |   20 -
 arch/mips/include/asm/mipsregs.h                   |   12 -
 arch/mips/include/asm/mmu_context.h                |   15 +-
 arch/mips/include/asm/module.h                     |    2 -
 arch/mips/include/asm/netlogic/atx_cpld.h          |   59 -
 arch/mips/include/asm/netlogic/bootinfo.h          |    6 +-
 arch/mips/include/asm/netlogic/config_net.h        |  113 -
 arch/mips/include/asm/netlogic/cpumask.h           |    3 +
 arch/mips/include/asm/netlogic/debug.h             |    3 +
 arch/mips/include/asm/netlogic/devices.h           |   41 -
 arch/mips/include/asm/netlogic/global_shmem.h      |   47 -
 arch/mips/include/asm/netlogic/gpio.h              |   47 +-
 arch/mips/include/asm/netlogic/i2c-algo-palm.h     |   53 -
 arch/mips/include/asm/netlogic/i2c.h               |   33 -
 arch/mips/include/asm/netlogic/io.h                |    3 +
 arch/mips/include/asm/netlogic/iomap.h             |    3 +
 arch/mips/include/asm/netlogic/linux_crf.h         |   74 -
 arch/mips/include/asm/netlogic/memory-exclusion.h  |   38 -
 arch/mips/include/asm/netlogic/mips-exts.h         |   33 +-
 arch/mips/include/asm/netlogic/msidef.h            |    3 +
 arch/mips/include/asm/netlogic/nlm_common_cde.h    |  170 -
 .../asm/netlogic/nlm_common_rmios_debugger.h       |   48 -
 arch/mips/include/asm/netlogic/nlm_common_sec.h    |  767 ---
 .../include/asm/netlogic/nlm_common_shim_drv.h     |  505 --
 arch/mips/include/asm/netlogic/nlm_common_tb.h     |   92 -
 arch/mips/include/asm/netlogic/nlm_common_uart.h   |   47 -
 arch/mips/include/asm/netlogic/nlm_dma.h           |    3 +
 arch/mips/include/asm/netlogic/nlm_fs.h            |    3 +
 arch/mips/include/asm/netlogic/nlm_pcix_gen_dev.h  |  119 -
 arch/mips/include/asm/netlogic/nlm_pcix_gen_host.h |  125 -
 arch/mips/include/asm/netlogic/nlm_rw_lock.h       |    3 +
 arch/mips/include/asm/netlogic/nlm_srio.h          |  338 --
 arch/mips/include/asm/netlogic/pci.h               |   33 -
 arch/mips/include/asm/netlogic/perf_ctr.h          |   67 -
 arch/mips/include/asm/netlogic/phnx_loader.h       |    3 +
 arch/mips/include/asm/netlogic/pic.h               |    3 +
 arch/mips/include/asm/netlogic/proc.h              |    3 +
 arch/mips/include/asm/netlogic/sim.h               |  449 --
 arch/mips/include/asm/netlogic/utils.h             |   83 -
 arch/mips/include/asm/netlogic/xgmac_mdio.h        |  114 -
 arch/mips/include/asm/netlogic/xlp.h               |    3 +
 arch/mips/include/asm/netlogic/xlp8xx/cpu.h        |    3 +
 .../asm/netlogic/xlp8xx/cpu_control_macros.h       |    3 +
 arch/mips/include/asm/netlogic/xlp_hal_pic.h       |    3 +
 arch/mips/include/asm/netlogic/xlp_irq.h           |    8 +-
 arch/mips/include/asm/netlogic/xlp_usb.h           |    3 +
 arch/mips/include/asm/netlogic/xlr_board.h         |   42 -
 arch/mips/include/asm/netlogic/xlr_mac.h           | 1158 -----
 arch/mips/include/asm/netlogic/xlr_pcix_boot.h     |   37 -
 arch/mips/include/asm/netlogic/xlr_rmik.h          |   77 -
 arch/mips/include/asm/netlogic/xlr_user_mac.h      |   56 -
 arch/mips/include/asm/netlogic/xlr_virt_uart.h     |   63 -
 arch/mips/include/asm/page.h                       |    6 +-
 arch/mips/include/asm/pci.h                        |    2 -
 arch/mips/include/asm/perfctr.h                    |  237 -
 arch/mips/include/asm/pgtable-bits.h               |    2 +-
 arch/mips/include/asm/processor.h                  |    4 +
 arch/mips/include/asm/smp.h                        |    2 +-
 arch/mips/include/asm/timex.h                      |    4 +-
 arch/mips/include/asm/xlr_macros.h                 |  117 -
 arch/mips/kernel/Makefile                          |    3 -
 arch/mips/kernel/asm-offsets.c                     |   15 +-
 arch/mips/kernel/binfmt_elfo32.c                   |   38 +-
 arch/mips/kernel/cpu-probe.c                       |   64 +-
 arch/mips/kernel/genex.S                           |    7 +-
 arch/mips/kernel/head.S                            |   44 +-
 arch/mips/kernel/kgdb.c                            |   10 +-
 arch/mips/kernel/nlm_fs_handler.S                  |    7 +-
 arch/mips/kernel/proc.c                            |    2 +-
 arch/mips/kernel/ptrace.c                          |    6 +-
 arch/mips/kernel/r4k_switch.S                      |    4 +
 arch/mips/kernel/rio.c                             |   49 -
 arch/mips/kernel/scall32-o32.S                     |    4 +-
 arch/mips/kernel/scall64-n32.S                     |    2 +-
 arch/mips/kernel/scall64-o32.S                     |    4 +-
 arch/mips/kernel/setup.c                           |   15 +-
 arch/mips/kernel/smp.c                             |   14 +-
 arch/mips/kernel/traps.c                           |   38 +-
 arch/mips/kernel/unaligned.c                       |   10 +-
 arch/mips/kernel/vmlinux.lds.S                     |   17 +-
 arch/mips/lib/delay.c                              |   16 +-
 arch/mips/mm/c-phoenix.c                           |   16 -
 arch/mips/mm/cache.c                               |    3 +-
 arch/mips/mm/cex-gen.S                             |    2 +-
 arch/mips/mm/tlb-r4k.c                             |   57 +-
 arch/mips/mm/tlbex.c                               |   34 +-
 arch/mips/netlogic/Kconfig                         |  146 +-
 arch/mips/netlogic/common/Makefile                 |    9 +-
 arch/mips/netlogic/common/cpu_proc.c               |   17 -
 arch/mips/netlogic/common/dma.c                    |  602 ---
 arch/mips/netlogic/common/platform.c               |  109 -
 arch/mips/netlogic/common/smp.c                    |   35 -
 arch/mips/netlogic/common/srio.c                   | 2225 --------
 arch/mips/netlogic/xlp/cpu_control_asm.S           |    2 +
 arch/mips/netlogic/xlp/on_chip.c                   |   10 -
 arch/mips/netlogic/xlp/smp.c                       |    3 +-
 arch/mips/netlogic/xlp/time.c                      |   65 +-
 arch/mips/oprofile/Makefile                        |    1 -
 arch/mips/pci/Makefile                             |    1 -
 arch/mips/pci/pci-xlp.c                            |   84 -
 arch/mips/xen/Kconfig                              |    2 +-
 drivers/char/Kconfig                               |   19 -
 drivers/char/Makefile                              |   14 +-
 drivers/char/hw_random/Kconfig                     |    5 -
 drivers/char/hw_random/Makefile                    |    1 -
 drivers/char/hw_random/xlr-rng.c                   |   85 -
 drivers/char/nlm_common_dummy_uart.c               |  288 --
 drivers/char/nlm_common_loader.c                   |  625 ---
 drivers/char/nlm_common_msgring_debugger.c         |   86 -
 drivers/char/nlm_common_rmios_debugger.c           |  327 --
 drivers/char/nlm_common_tb.c                       |  320 --
 drivers/char/nlm_common_uart.c                     |  684 ---
 drivers/char/nlm_pcix_gen_dev.c                    |  277 -
 drivers/char/nlm_pcix_gen_host.c                   |  513 --
 drivers/char/nlm_xlr_cde.c                         |  822 ---
 drivers/char/nlm_xlr_msgring.c                     |  732 ---
 drivers/char/random.c                              |   34 -
 drivers/char/xlr_pcix_console_dev.c                |  459 --
 drivers/char/xlr_pcix_console_host.c               |  476 --
 drivers/char/xlr_virtual_uart.c                    |  384 --
 drivers/crypto/Kconfig                             |   11 -
 drivers/crypto/netlogic/Makefile                   |    2 -
 drivers/crypto/netlogic/ecc_ucode_data.h           |  364 --
 drivers/crypto/netlogic/nlm_auth.c                 |  459 --
 drivers/crypto/netlogic/nlm_enc.c                  |  822 ---
 drivers/crypto/netlogic/nlm_state_info.h           |  115 -
 drivers/crypto/netlogic/nlmsec.c                   | 2401 ---------
 drivers/i2c/algos/Kconfig                          |    9 -
 drivers/i2c/algos/Makefile                         |    1 -
 drivers/i2c/algos/i2c-algo-palm.c                  |  328 --
 drivers/i2c/busses/Kconfig                         |   11 -
 drivers/i2c/busses/Makefile                        |    1 -
 drivers/i2c/busses/i2c-bk3220.c                    |  154 -
 drivers/ide/Kconfig                                |    5 -
 drivers/ide/ide-dma-sff.c                          |   32 -
 drivers/ide/ide-io-std.c                           |   45 -
 drivers/ide/pdc202xx_new.c                         |   58 -
 drivers/mtd/maps/Kconfig                           |    6 -
 drivers/mtd/maps/Makefile                          |    1 -
 drivers/mtd/maps/xlr-flash.c                       |  100 -
 drivers/mtd/nand/xls_nand.c                        |  281 -
 drivers/mtd/nand/xls_nand.h                        |   41 -
 drivers/net/Kconfig                                |   15 -
 drivers/net/Makefile                               |    4 -
 drivers/net/kgdboe.c                               |  216 -
 drivers/net/nlm_ptp1588/Makefile                   |    8 -
 drivers/net/nlm_ptp1588/ptp_common.h               |   35 -
 drivers/net/nlm_ptp1588/ptp_main.c                 |  358 --
 drivers/net/nlm_ptp1588/ptp_mod.h                  |   33 -
 drivers/net/nlm_rionet.c                           |  615 ---
 drivers/net/nlm_spi4/Makefile                      |    9 -
 drivers/net/nlm_spi4/meigsii_reg.h                 |  459 --
 drivers/net/nlm_spi4/nlm_spi4.c                    |  859 ----
 drivers/net/nlm_spi4/nlm_spi4.h                    |  227 -
 drivers/net/nlm_spi4/nlm_spi4_config.h             |  136 -
 drivers/net/nlm_spi4/nlm_vits_driver.c             |  277 -
 drivers/net/nlm_spi4/nlm_vits_driver.h             |   47 -
 drivers/net/nlm_spi4/nlm_vits_eth.c                | 1221 -----
 drivers/net/nlm_spi4/nlm_vits_eth.h                |  149 -
 drivers/net/nlm_spi4/nlm_vits_wrapper.c            |   98 -
 drivers/net/nlm_spi4/nlm_vits_wrapper.h            |   41 -
 drivers/net/nlm_spi4/os_layer.c                    |   92 -
 drivers/net/nlm_spi4/os_layer.h                    |   46 -
 drivers/net/nlm_spi4/vitesse_common.h              |  279 -
 drivers/net/nlm_spi4/vitesse_highlevel.c           | 5363 --------------------
 drivers/net/nlm_spi4/vitesse_highlevel.h           | 1384 -----
 drivers/net/nlm_spi4/vitesse_io.c                  |  229 -
 drivers/net/nlm_spi4/vitesse_io.h                  |   77 -
 drivers/net/nlm_spi4/vitesse_phy_ctrl.c            |  440 --
 drivers/net/nlm_spi4/vitesse_phy_ctrl.h            |  292 --
 drivers/net/nlm_vnet.c                             |  653 ---
 drivers/net/nlm_vnet.h                             |   90 -
 drivers/net/xlr_ip_over_pci_dev.c                  |  610 ---
 drivers/net/xlr_ip_over_pci_host.c                 |  703 ---
 drivers/net/xlr_mac.c                              | 4557 -----------------
 drivers/net/xlr_pcix_boot.c                        |  330 --
 drivers/net/xlr_rmik.c                             |  693 ---
 drivers/net/xlr_user_mac.c                         | 1196 -----
 drivers/pci/Makefile                               |    1 -
 drivers/pci/probe.c                                |   32 -
 drivers/pci/proc.c                                 |    2 +-
 drivers/perfctr/Kconfig                            |   64 -
 drivers/perfctr/Makefile                           |   25 -
 drivers/perfctr/compat.h                           |   47 -
 drivers/perfctr/cpumask.h                          |   90 -
 drivers/perfctr/dummy-syscalls.c                   |   69 -
 drivers/perfctr/init.c                             |  194 -
 drivers/perfctr/mips.c                             |  834 ---
 drivers/perfctr/mips.h                             |   44 -
 drivers/perfctr/mips_tests.c                       |  217 -
 drivers/perfctr/mips_tests.h                       |   20 -
 drivers/perfctr/pmc.h                              |   34 -
 drivers/perfctr/version.h                          |    9 -
 drivers/perfctr/virtual.c                          | 1356 -----
 drivers/perfctr/virtual.h                          |   21 -
 drivers/rapidio/switches/Makefile                  |    3 -
 drivers/rapidio/switches/tsi578.c                  |   71 -
 drivers/usb/core/usb.c                             |   21 -
 drivers/usb/host/ehci-hcd.c                        |   25 -
 drivers/usb/host/ehci-xls.c                        |  161 -
 drivers/usb/host/ohci-hcd.c                        |   32 -
 drivers/usb/host/ohci-xls.c                        |  151 -
 drivers/watchdog/Kconfig                           |    8 -
 drivers/watchdog/Makefile                          |    1 -
 drivers/watchdog/phoenix_wdt.c                     |  301 --
 fs/dcookies.c                                      |   45 -
 include/linux/crypto.h                             |    7 -
 include/linux/libata.h                             |    2 +-
 include/linux/linkage.h                            |    6 +-
 include/linux/nlm_common_tb.h                      |  167 -
 include/linux/perfctr.h                            |  198 -
 include/linux/skbuff.h                             |   12 +-
 include/linux/syscalls.h                           |   11 -
 include/user/netlogic/nlm_common_msgring.h         |   51 -
 include/user/netlogic/xlr_mmap.h                   |   38 -
 include/user/netlogic/xlr_user_mac.h               |  133 -
 kernel/pid.c                                       |   20 +-
 kernel/ptrace.c                                    |    3 +-
 kernel/sys_ni.c                                    |    1 -
 net/core/dev.c                                     |    7 -
 net/core/skbuff.c                                  |    2 +-
 net/ipv4/netfilter/ip_queue.c                      |   94 -
 232 files changed, 382 insertions(+), 46748 deletions(-)
 delete mode 100644 arch/mips/include/asm/mach-netlogic/pci-dma.h
 delete mode 100644 arch/mips/include/asm/mach-netlogic/spaces.h
 delete mode 100644 arch/mips/include/asm/netlogic/atx_cpld.h
 delete mode 100644 arch/mips/include/asm/netlogic/config_net.h
 delete mode 100644 arch/mips/include/asm/netlogic/devices.h
 delete mode 100644 arch/mips/include/asm/netlogic/global_shmem.h
 delete mode 100644 arch/mips/include/asm/netlogic/i2c-algo-palm.h
 delete mode 100644 arch/mips/include/asm/netlogic/i2c.h
 delete mode 100644 arch/mips/include/asm/netlogic/linux_crf.h
 delete mode 100644 arch/mips/include/asm/netlogic/memory-exclusion.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_common_cde.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_common_rmios_debugger.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_common_sec.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_common_shim_drv.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_common_tb.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_common_uart.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_pcix_gen_dev.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_pcix_gen_host.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_srio.h
 delete mode 100644 arch/mips/include/asm/netlogic/pci.h
 delete mode 100644 arch/mips/include/asm/netlogic/perf_ctr.h
 delete mode 100644 arch/mips/include/asm/netlogic/sim.h
 delete mode 100644 arch/mips/include/asm/netlogic/utils.h
 delete mode 100644 arch/mips/include/asm/netlogic/xgmac_mdio.h
 delete mode 100644 arch/mips/include/asm/netlogic/xlr_board.h
 delete mode 100644 arch/mips/include/asm/netlogic/xlr_mac.h
 delete mode 100644 arch/mips/include/asm/netlogic/xlr_pcix_boot.h
 delete mode 100644 arch/mips/include/asm/netlogic/xlr_rmik.h
 delete mode 100644 arch/mips/include/asm/netlogic/xlr_user_mac.h
 delete mode 100644 arch/mips/include/asm/netlogic/xlr_virt_uart.h
 delete mode 100644 arch/mips/include/asm/perfctr.h
 delete mode 100644 arch/mips/include/asm/xlr_macros.h
 delete mode 100644 arch/mips/kernel/rio.c
 delete mode 100644 arch/mips/netlogic/common/dma.c
 delete mode 100644 arch/mips/netlogic/common/platform.c
 delete mode 100644 arch/mips/netlogic/common/srio.c
 delete mode 100644 drivers/char/hw_random/xlr-rng.c
 delete mode 100644 drivers/char/nlm_common_dummy_uart.c
 delete mode 100644 drivers/char/nlm_common_loader.c
 delete mode 100644 drivers/char/nlm_common_msgring_debugger.c
 delete mode 100644 drivers/char/nlm_common_rmios_debugger.c
 delete mode 100644 drivers/char/nlm_common_tb.c
 delete mode 100644 drivers/char/nlm_common_uart.c
 delete mode 100644 drivers/char/nlm_pcix_gen_dev.c
 delete mode 100644 drivers/char/nlm_pcix_gen_host.c
 delete mode 100644 drivers/char/nlm_xlr_cde.c
 delete mode 100644 drivers/char/nlm_xlr_msgring.c
 delete mode 100644 drivers/char/xlr_pcix_console_dev.c
 delete mode 100644 drivers/char/xlr_pcix_console_host.c
 delete mode 100644 drivers/char/xlr_virtual_uart.c
 delete mode 100644 drivers/crypto/netlogic/Makefile
 delete mode 100644 drivers/crypto/netlogic/ecc_ucode_data.h
 delete mode 100644 drivers/crypto/netlogic/nlm_auth.c
 delete mode 100644 drivers/crypto/netlogic/nlm_enc.c
 delete mode 100644 drivers/crypto/netlogic/nlm_state_info.h
 delete mode 100644 drivers/crypto/netlogic/nlmsec.c
 delete mode 100644 drivers/i2c/algos/i2c-algo-palm.c
 delete mode 100644 drivers/i2c/busses/i2c-bk3220.c
 delete mode 100644 drivers/mtd/maps/xlr-flash.c
 delete mode 100644 drivers/mtd/nand/xls_nand.c
 delete mode 100644 drivers/mtd/nand/xls_nand.h
 delete mode 100644 drivers/net/kgdboe.c
 delete mode 100644 drivers/net/nlm_ptp1588/Makefile
 delete mode 100644 drivers/net/nlm_ptp1588/ptp_common.h
 delete mode 100644 drivers/net/nlm_ptp1588/ptp_main.c
 delete mode 100644 drivers/net/nlm_ptp1588/ptp_mod.h
 delete mode 100644 drivers/net/nlm_rionet.c
 delete mode 100644 drivers/net/nlm_spi4/Makefile
 delete mode 100644 drivers/net/nlm_spi4/meigsii_reg.h
 delete mode 100644 drivers/net/nlm_spi4/nlm_spi4.c
 delete mode 100644 drivers/net/nlm_spi4/nlm_spi4.h
 delete mode 100644 drivers/net/nlm_spi4/nlm_spi4_config.h
 delete mode 100644 drivers/net/nlm_spi4/nlm_vits_driver.c
 delete mode 100644 drivers/net/nlm_spi4/nlm_vits_driver.h
 delete mode 100644 drivers/net/nlm_spi4/nlm_vits_eth.c
 delete mode 100644 drivers/net/nlm_spi4/nlm_vits_eth.h
 delete mode 100644 drivers/net/nlm_spi4/nlm_vits_wrapper.c
 delete mode 100644 drivers/net/nlm_spi4/nlm_vits_wrapper.h
 delete mode 100644 drivers/net/nlm_spi4/os_layer.c
 delete mode 100644 drivers/net/nlm_spi4/os_layer.h
 delete mode 100644 drivers/net/nlm_spi4/vitesse_common.h
 delete mode 100644 drivers/net/nlm_spi4/vitesse_highlevel.c
 delete mode 100644 drivers/net/nlm_spi4/vitesse_highlevel.h
 delete mode 100644 drivers/net/nlm_spi4/vitesse_io.c
 delete mode 100644 drivers/net/nlm_spi4/vitesse_io.h
 delete mode 100644 drivers/net/nlm_spi4/vitesse_phy_ctrl.c
 delete mode 100644 drivers/net/nlm_spi4/vitesse_phy_ctrl.h
 delete mode 100644 drivers/net/nlm_vnet.c
 delete mode 100644 drivers/net/nlm_vnet.h
 delete mode 100644 drivers/net/xlr_ip_over_pci_dev.c
 delete mode 100644 drivers/net/xlr_ip_over_pci_host.c
 delete mode 100644 drivers/net/xlr_mac.c
 delete mode 100644 drivers/net/xlr_pcix_boot.c
 delete mode 100644 drivers/net/xlr_rmik.c
 delete mode 100644 drivers/net/xlr_user_mac.c
 delete mode 100644 drivers/perfctr/Kconfig
 delete mode 100644 drivers/perfctr/Makefile
 delete mode 100644 drivers/perfctr/compat.h
 delete mode 100644 drivers/perfctr/cpumask.h
 delete mode 100644 drivers/perfctr/dummy-syscalls.c
 delete mode 100644 drivers/perfctr/init.c
 delete mode 100644 drivers/perfctr/mips.c
 delete mode 100644 drivers/perfctr/mips.h
 delete mode 100644 drivers/perfctr/mips_tests.c
 delete mode 100644 drivers/perfctr/mips_tests.h
 delete mode 100644 drivers/perfctr/pmc.h
 delete mode 100644 drivers/perfctr/version.h
 delete mode 100644 drivers/perfctr/virtual.c
 delete mode 100644 drivers/perfctr/virtual.h
 delete mode 100644 drivers/rapidio/switches/tsi578.c
 delete mode 100644 drivers/usb/host/ehci-xls.c
 delete mode 100644 drivers/usb/host/ohci-xls.c
 delete mode 100644 drivers/watchdog/phoenix_wdt.c
 delete mode 100644 include/linux/nlm_common_tb.h
 delete mode 100644 include/linux/perfctr.h
 delete mode 100644 include/user/netlogic/nlm_common_msgring.h
 delete mode 100644 include/user/netlogic/xlr_mmap.h
 delete mode 100644 include/user/netlogic/xlr_user_mac.h

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 5597425..57fe079 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -761,7 +761,7 @@ config NLM_XLP_SIM
 	depends on EXPERIMENTAL
 	select SMP
 	select BOOT_ELF32
-	select NLM_COMMON
+	select NLMCOMMON
 	select NLM_XLP
 	select SYS_HAS_CPU_XLP
 	select SYS_SUPPORTS_SMP
@@ -789,7 +789,7 @@ config NLM_XLP_EVP_BOARD
         depends on EXPERIMENTAL
         select SMP
         select BOOT_ELF32
-        select NLM_COMMON
+	select NLMCOMMON
         select NLM_XLP
         select SYS_HAS_CPU_XLP
         select SYS_SUPPORTS_SMP
@@ -902,15 +902,6 @@ config NLM_XLP_BOARD
 
 endchoice
 
-config RAPIDIO
-	bool "RapidIO support"
-	depends on NLM_XLR
-	help
-	  If you say Y here, the kernel will include drivers and
-	  infrastructure code to support RapidIO interconnect devices.
-
-source "drivers/rapidio/Kconfig"
-
 source "arch/mips/alchemy/Kconfig"
 source "arch/mips/ath79/Kconfig"
 source "arch/mips/bcm47xx/Kconfig"
diff --git a/arch/mips/include/asm/addrspace.h b/arch/mips/include/asm/addrspace.h
index 7cf85bd..6b97876 100644
--- a/arch/mips/include/asm/addrspace.h
+++ b/arch/mips/include/asm/addrspace.h
@@ -134,7 +134,7 @@
  * the region, 3 bits for the CCA mode.  This leaves 59 bits of which the
  * R8000 implements most with its 48-bit physical address space.
  */
-#if defined(CONFIG_CPU_XLR) || defined(CONFIG_CPU_XLP)
+#if defined(CONFIG_CPU_XLP)
 #define TO_PHYS_MASK	_CONST64_(0x000000ffffffffff)	/* 2^^40 - 1 */
 #else
 #define TO_PHYS_MASK	_CONST64_(0x07ffffffffffffff)	/* 2^^59 - 1 */
diff --git a/arch/mips/include/asm/bitops.h b/arch/mips/include/asm/bitops.h
index 9efca72..bf8be97 100644
--- a/arch/mips/include/asm/bitops.h
+++ b/arch/mips/include/asm/bitops.h
@@ -615,7 +615,7 @@ static inline unsigned long __ffs(unsigned long word)
 static inline int fls(int x)
 {
 	int r;
-#if defined(CONFIG_CPU_XLR) || defined(CONFIG_CPU_XLP)
+#if defined(CONFIG_CPU_XLP)
 	__asm__("       .set push                       \n"
 		"       .set mips32                     \n"
 		"       clz %0, %1                      \n"
@@ -656,7 +656,7 @@ static inline int fls(int x)
 	return r;
 }
 
-#if defined(CONFIG_64BIT) && (defined(CONFIG_CPU_XLR) || defined(CONFIG_CPU_XLP))
+#if defined(CONFIG_64BIT) && defined(CONFIG_CPU_XLP)
 static __always_inline int fls64(__u64 word)
 {
 	__asm__("       .set push               \n"
diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h
index 662a599..0fd7b59 100644
--- a/arch/mips/include/asm/cacheflush.h
+++ b/arch/mips/include/asm/cacheflush.h
@@ -49,7 +49,7 @@ extern void __flush_dcache_page(struct page *page);
 #define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 1
 static inline void flush_dcache_page(struct page *page)
 {
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	extern void nlm_common_flush_dcache_page(struct page *page);
 	nlm_common_flush_dcache_page(page);
 #else
diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 8f44734..701347c 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -41,9 +41,11 @@
 #ifndef cpu_has_octeon_cache
 #define cpu_has_octeon_cache	0
 #endif
+#ifdef CONFIG_NLM_XLP
 #ifndef cpu_has_nlm_cache
 #define cpu_has_nlm_cache  (cpu_data[0].options & MIPS_CPU_NLM_CACHE)
 #endif
+#endif
 #ifndef cpu_has_fpu
 #define cpu_has_fpu		(current_cpu_data.options & MIPS_CPU_FPU)
 #define raw_cpu_has_fpu		(raw_current_cpu_data.options & MIPS_CPU_FPU)
diff --git a/arch/mips/include/asm/dma.h b/arch/mips/include/asm/dma.h
index 976a5f8..4289d2c 100644
--- a/arch/mips/include/asm/dma.h
+++ b/arch/mips/include/asm/dma.h
@@ -87,7 +87,7 @@
 /* don't care; ISA bus master won't work, ISA slave DMA supports 32bit addr */
 #define MAX_DMA_ADDRESS		PAGE_OFFSET
 #else
-#if defined(CONFIG_NLM_COMMON) && defined(CONFIG_64BIT)
+#if defined(CONFIG_NLM_XLP) && defined(CONFIG_64BIT)
 #define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x80000000)
 #else
 #define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x01000000)
diff --git a/arch/mips/include/asm/mach-netlogic/ioremap.h b/arch/mips/include/asm/mach-netlogic/ioremap.h
index d98eb20..215919a 100644
--- a/arch/mips/include/asm/mach-netlogic/ioremap.h
+++ b/arch/mips/include/asm/mach-netlogic/ioremap.h
@@ -11,13 +11,13 @@
 
 #include <linux/types.h>
 
+#ifdef CONFIG_NLM_XLP
 #define ARCH_HAS_VALID_PHYS_ADDR_RANGE
 
-#define NETLOGIC_UNCACHED_START 0x10000000UL
-#define NETLOGIC_UNCACHED_END 0x20000000UL
-
 extern inline int valid_phys_addr_range(unsigned long addr, size_t count);
 extern inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+#endif
+
 /*
  * Allow physical addresses to be fixed up to help peripherals located
  * outside the low 32-bit range -- generic pass-through version.
diff --git a/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h b/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h
index ea24e3f..786f70a 100644
--- a/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h
+++ b/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h
@@ -1,6 +1,10 @@
 #ifndef __ASM_MACH_NLM_KERNEL_ENTRY_H
 #define __ASM_MACH_NLM_KERNEL_ENTRY_H
 
+#include <asm/mach-generic/kernel-entry-init.h>
+
+#ifdef CONFIG_NLM_XLP
+
 /* XLP_MERGE_TODO */
 #if !defined(CKSSEG)
 #define CKSSEG			0xffffffffc0000000
@@ -55,4 +59,6 @@ mapped_space:
 #endif
 	.endm
 
+#endif /* CONFIG_NLM_XLP */
+
 #endif /* __ASM_MACH_NLM_KERNEL_ENTRY_H */
diff --git a/arch/mips/include/asm/mach-netlogic/mmu.h b/arch/mips/include/asm/mach-netlogic/mmu.h
index c866b59..ec69f2c 100644
--- a/arch/mips/include/asm/mach-netlogic/mmu.h
+++ b/arch/mips/include/asm/mach-netlogic/mmu.h
@@ -49,13 +49,7 @@ static inline void nlm_update_tlb_stats(void *arg)
 }
 
 #define tlbstats_init() nlm_write_os_scratch_2(0ULL)
-
-#ifdef CONFIG_HUGETLBFS
-#define entrylo0_mask_init() \
-nlm_write_os_scratch_3(~(((1ULL << HUGETLB_PAGE_ORDER) - 1) << ENTRYLO_PFN_SHIFT))
-#else
 #define entrylo0_mask_init()
-#endif
 
 extern void setup_mapped_kernel_tlbs(int index, int secondary_cpu);
 extern unsigned long recalculate_max_low_pfn(unsigned long max_low_pfn);
@@ -64,10 +58,5 @@ extern unsigned long recalculate_max_low_pfn(unsigned long max_low_pfn);
 extern void __init nlm_numa_bootmem_init(unsigned long);
 #endif
 
-#ifndef CONFIG_NLM_XLP
-#define disable_pgwalker(flags) (void)flags
-#define enable_pgwalker(flags) (void) flags
-#endif
-
 #endif /* __ASSEMBLY__ */
 #endif
diff --git a/arch/mips/include/asm/mach-netlogic/pci-dma.h b/arch/mips/include/asm/mach-netlogic/pci-dma.h
deleted file mode 100644
index c3480f7..0000000
--- a/arch/mips/include/asm/mach-netlogic/pci-dma.h
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef __ASM_MACH_NLM_PCI_DMA_H
-#define __ASM_MACH_NLM_PCI_DMA_H
-
-#ifdef CONFIG_NLM_XLR
-#define HAVE_ARCH_PCI_SET_DMA_MASK 1
-#endif
-
-#endif  /* __ASM_MACH_NLM_PCI_DMA_H */
diff --git a/arch/mips/include/asm/mach-netlogic/spaces.h b/arch/mips/include/asm/mach-netlogic/spaces.h
deleted file mode 100644
index c94d919..0000000
--- a/arch/mips/include/asm/mach-netlogic/spaces.h
+++ /dev/null
@@ -1,20 +0,0 @@
-#ifndef __NLM_SPACES_H__
-#define __NLM_SPACES_H__
-
-#ifndef __ASSEMBLY__
-#ifdef CONFIG_NLM_VMIPS
-extern unsigned long nlm_vmips_phys_offset;
-#define PHYS_OFFSET nlm_vmips_phys_offset
-
-extern unsigned long long nlm_vmips_highmem_start;
-#define        HIGHMEM_START   (nlm_vmips_highmem_start)
-
-#define PAGE_OFFSET (CAC_BASE)
-
-#endif
-#endif
-
-#include <asm/mach-generic/spaces.h>
-
-
-#endif
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index aadcea5..76af30d 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -24,7 +24,6 @@ the header of the original work apply to this derived work.
 #include <linux/linkage.h>
 #include <asm/hazards.h>
 #include <asm/war.h>
-#include <asm/netlogic/mips-exts.h>
 
 /*
  * The following macros are especially useful for __asm__
@@ -892,18 +891,7 @@ do {									\
 #define write_c0_count3(val)	__write_32bit_c0_register($9, 7, val)
 
 #define read_c0_entryhi()	__read_ulong_c0_register($10, 0)
-#if defined(CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID)
-extern unsigned int nlm_shtlb;
-#define write_c0_entryhi(val)   \
-	if(nlm_shtlb) \
-		__write_ulong_c0_register($10, 0, (((val) & ~0xc0)|(netlogic_thr_id()<<6))); \
-	else \
-		__write_ulong_c0_register($10, 0, val);
-#elif defined(CONFIG_NLMCOMMON_GLOBAL_TLB_GLOBAL_ASID)
-#define write_c0_entryhi(val)   __write_ulong_c0_register($10, 0, (((val) & ~0xc0)|(netlogic_thr_id()<<6)))
-#else
 #define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, val)
-#endif
 
 #define read_c0_compare()	__read_32bit_c0_register($11, 0)
 #define write_c0_compare(val)	__write_32bit_c0_register($11, 0, val)
diff --git a/arch/mips/include/asm/mmu_context.h b/arch/mips/include/asm/mmu_context.h
index 7730a79..dd52b6d 100644
--- a/arch/mips/include/asm/mmu_context.h
+++ b/arch/mips/include/asm/mmu_context.h
@@ -24,13 +24,13 @@
 #endif /* SMTC */
 #include <asm-generic/mm_hooks.h>
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/debug.h>
 #include <asm/mach-netlogic/mmu.h>
-#endif
-
-#ifndef CONFIG_NLM_XLP
+#else
+#define disable_pgwalker(flags)	(void)flags
+#define enable_pgwalker(flags)	(void)flags
 static inline void setup_user_pgd(pgd_t *pgd) { }
 #endif
 
@@ -97,15 +97,8 @@ extern unsigned long smtc_asid_mask;
 /* End SMTC/34K debug hack */
 #else /* FIXME: not correct for R6000 */
 
-#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
-#define ASID_INC    0x1
-extern unsigned long nlm_asid_mask;
-#define ASID_MASK   nlm_asid_mask
-#else
-
 #define ASID_INC	0x1
 #define ASID_MASK	0xff
-#endif
 
 #endif
 
diff --git a/arch/mips/include/asm/module.h b/arch/mips/include/asm/module.h
index 8cd6e69..7683a87 100644
--- a/arch/mips/include/asm/module.h
+++ b/arch/mips/include/asm/module.h
@@ -124,8 +124,6 @@ search_module_dbetables(unsigned long addr)
 #define MODULE_PROC_FAMILY "RM9000 "
 #elif defined CONFIG_CPU_SB1
 #define MODULE_PROC_FAMILY "SB1 "
-#elif defined CONFIG_CPU_XLR
-#define MODULE_PROC_FAMILY "XLR "
 #elif defined CONFIG_CPU_XLP
 #define MODULE_PROC_FAMILY "XLP "
 #elif defined CONFIG_CPU_LOONGSON2
diff --git a/arch/mips/include/asm/netlogic/atx_cpld.h b/arch/mips/include/asm/netlogic/atx_cpld.h
deleted file mode 100644
index 7be6898..0000000
--- a/arch/mips/include/asm/netlogic/atx_cpld.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_ATX_CPLD_H
-#define _ASM_NLM_ATX_CPLD_H
-
-/*
-	 * bit_0 : xgs0 phy reset
-	 * bit_1 : xgs1 phy reset
-	 * bit_2 : HT reset
-	 * bit_3 : RTC reset
-	 * bit_4 : gmac phy soft reset
-	 * bit_5 : gmac phy hard reset
-	 * bit_6 : board reset
-	 * bit_7 : reserved
-*/
-#define ATX_CPLD_RESET_1   2
-
-/*
- *  bit_0_2 : reserved
- *  bit_3 : turn off xpak_0 tx
- *  bit_4 : turn off xpak_1 tx
- *  bit_5 : HT stop (active low)
- *  bit_6 : flash program enable
- *  bit_7 : compact flash io mode
- */
-#define ATX_CPLD_MISC_CTRL 8
-
-/*
- * bit_0 : reset tcam 
- * bit_1 : reset xpak_0 module
- * bit_2 : reset xpak_1 module
- * bit_3_7 : reserved
- */
-#define ATX_CPLD_RESET_2   9
-
-#endif /* _ASM_NLM_ATX_CPLD_H */
diff --git a/arch/mips/include/asm/netlogic/bootinfo.h b/arch/mips/include/asm/netlogic/bootinfo.h
index 3486087..2b0535b 100644
--- a/arch/mips/include/asm/netlogic/bootinfo.h
+++ b/arch/mips/include/asm/netlogic/bootinfo.h
@@ -1,6 +1,10 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef _ASM_NETLOGIC_BOOTINFO_H
 #define _ASM_NETLOGIC_BOOTINFO_H
 
+#ifdef CONFIG_NLM_XLP
 #define LOADER_UBOOT   1
 #define LOADER_OTHER   2
 
@@ -21,8 +25,6 @@ struct boot_mem_map_exclude_region {
 };
 extern void copy_mem_map(struct boot_mem_map *, struct nlm_boot_mem_map *);
 
-
-#ifdef CONFIG_NLM_XLP
 extern struct psb_info *prom_info;
 extern struct psb_info prom_info_copy;
 extern struct boot_mem_map boot_physaddr_info;
diff --git a/arch/mips/include/asm/netlogic/config_net.h b/arch/mips/include/asm/netlogic/config_net.h
deleted file mode 100644
index d0058ad..0000000
--- a/arch/mips/include/asm/netlogic/config_net.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_NET_H
-#define _ASM_NLM_NET_H
-
-#include <asm/netlogic/msgring.h>
-
-#define NETLOGIC_MAX_GMACS 8
-#define NETLOGIC_MAX_XGMACS 2
-#define NETLOGIC_MAX_XAUIS 2
-
-#define NETLOGIC_GMAC_PORTS_PER_CTRL 4
-
-#define NETLOGIC_MAX_MACS (NETLOGIC_MAX_GMACS + NETLOGIC_MAX_XGMACS)
-
-enum config_flags { NLM_PORT_INIT = 1, 
-					NLM_PORT_ATTACH = 2, 
-					NLM_INT_ATTACH = 4, 
-					NLM_MSGRNG_OWN = 8, 
-					NLM_PORT_EN = 0x10 };
-
-#define PORT_OWN_LINUX  ( NLM_PORT_INIT | NLM_PORT_ATTACH | NLM_INT_ATTACH | NLM_MSGRNG_OWN | NLM_PORT_EN )
-
-/* 	PORT_INIT  : GMAC/XGMAC IP initialization will be done. 
-	Port will be disabled after the initialization. 
-	Glue logic(spill, packet descriptors will not be initialized 
-
-	PORT_ATTACH : Eth interface will be attached to Linux 
-
-	INT_ATTACH : GMAC/XGMAC MDIO interrupt will be attached to Linux
-
-	MSGRNG_OWN : Glue logic(spill, packet descriptors will be initialized by linux
-
-	PORT_EN : Option to enable the port
-*/
-
-
-struct port_cfg {
-	/* port number */
-	int instance;
-
-	/* See enum config_flags */
-	uint32_t cfg_flag;
-
-	/* Interrupt Request number */
-	int irqno; 
-
-	/* number of descriptors configured */
-	int num_desc; 
-
-	/* pointer to the bucket config */
-	bucket_t *bucket;
-
-	/* pointer to the credit config */
-	struct stn_cc *credit;
-
-	/* driver should configure the pde */
-	int config_pde;
-
-	unsigned long mmio_addr; /* config address */
-	uint32_t phy_addr; /* phy id */
-	int phy_mode; /* sgmii or rgmii */
-	unsigned long mii_addr; /* mdio addr */
-	unsigned long pcs_addr; /* only for sgmii ports */
-	unsigned long serdes_addr; /* only for sgmii ports */
-};
-
-struct net_device_cfg {
-	struct port_cfg gmac_port[NETLOGIC_MAX_GMACS];
-	int xgs_type[NETLOGIC_MAX_XGMACS];
-	struct port_cfg xgs_port[NETLOGIC_MAX_XGMACS];
-};
-
-
-enum net_types { TYPE_GMAC = 0, TYPE_XGMAC, TYPE_SPI4, MAX_NET_TYPES };
-enum phy_modes { PHY_MODE_SGMII	= 1, PHY_MODE_RGMII = 2, 
-    PHY_MODE_SELECTABLE = 4, PHY_MODE_XAUI=8};
-
-extern int xlr_get_phy_info(int instance, int mode, unsigned long *mii_addr, 
-					unsigned long *pcs_addr, unsigned long *serdes_addr);
-
-#define PORT_INIT(x) (x & NLM_PORT_INIT)
-#define PORT_ATTACH(x) (x & NLM_PORT_ATTACH)
-#define PORT_INT_ATTACH(x) (x & NLM_INT_ATTACH)
-#define MSGRNG_OWN(x) (x & NLM_MSGRNG_OWN)
-#define PORT_EN(x) (x & NLM_PORT_EN)
-
-#endif
-
-
diff --git a/arch/mips/include/asm/netlogic/cpumask.h b/arch/mips/include/asm/netlogic/cpumask.h
index b72ae27..a64b35c 100644
--- a/arch/mips/include/asm/netlogic/cpumask.h
+++ b/arch/mips/include/asm/netlogic/cpumask.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef _ASM_NETLOGIC_CPUMASK_H
 #define _ASM_NETLOGIC_CPUMASK_H
 
diff --git a/arch/mips/include/asm/netlogic/debug.h b/arch/mips/include/asm/netlogic/debug.h
index 20b6d78..086a2b6 100644
--- a/arch/mips/include/asm/netlogic/debug.h
+++ b/arch/mips/include/asm/netlogic/debug.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/devices.h b/arch/mips/include/asm/netlogic/devices.h
deleted file mode 100644
index 555ddc6..0000000
--- a/arch/mips/include/asm/netlogic/devices.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_DEVICES_H
-#define _ASM_NLM_DEVICES_H
-
-#define XLR_VIRT_UART_MAJOR       239
-#define XLR_TB_MAJOR              240
-#define XLR_USER_MAC_MAJOR        241
-#define XLR_CRYPTO_MAJOR          242
-
-#define BTLBDEV_MAJOR             243
-
-#define XLR_MSGRING_SHM_MAJOR     244
-#define XLR_APP_LOADER_MAJOR      245
-#define XLR_CONSOLE_OVER_PCI_MAJOR	  246
-#define XLR_DEBUGGER_MAJOR              247
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/global_shmem.h b/arch/mips/include/asm/netlogic/global_shmem.h
deleted file mode 100644
index 2295698..0000000
--- a/arch/mips/include/asm/netlogic/global_shmem.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*********************************************************************
- This product is the confidential property of NetLogic Microsystems Inc.
- (“NetLogic”), is provided under a non-disclosure agreement, and is 
- protected under applicable copyright, patent, and trade secret laws.
- Unauthorized use, reproduction, distribution or other dissemination
- without the prior written authorization from NetLogic is
- strictly prohibited.
-
- NETLOGIC DISCLAIMS ALL WARRANTIES OF ANY NATURE, EXPRESS OR IMPLIED,
- INCLUDING, WITHOUT LIMITATION, THE WARRANTIES OF FITNESS FOR A PARTICULAR
- PURPOSE, MERCHANTABILITY AND/OR NON-INFRINGEMENT OF THIRD PARTY RIGHTS.
- NETLOGIC ASSUMES NO LIABILITY FOR ANY ERROR OR OMISSIONS IN THIS PRODUCT,
- OR FOR THE USE OF THIS PRODUCT. IN NO EVENT SHALL NETLOGIC BE LIABLE TO ANY
- OTHER PARTY FOR ANY SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL
- DAMAGES, WHETHER BASED ON BREACH OF CONTRACT, TORT, PRODUCT LIABILITY,
- INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR OTHERWISE. NETLOGIC
- RESERVES THE RIGHT TO MAKE CHANGES TO, OR DISCONTINUE, ITS PRODUCTS AT ANY
- TIME.
-
- Distribution of the product herein does not convey a license or any other
- right in any patent, trademark, or other intellectual property of NetLogic.
-
-Use of the product shall serve as acceptance of these terms and conditions.
-If you do not accept these terms, you should return or destroy the product
-and any other accompanying information immediately.
-
-Copyright, 2002-2010, NetLogic Microsystems, Inc. All rights reserved.
-
-*******************************NETL_3********************************/
-#ifndef __GLOBAL_SHMEM_H_
-#define __GLOBAL_SHMEM_H_
-
-
-/* Apps should check this size and then use boot1_info->global_shmem_addr */
-#define GLOBAL_SHMEM_SIZE       0x1000
-
-
-/* Apps should use the boot1_info->global_shmem_addr + the offsets defined
-   here.
- */
-#define BRIDGE_WKAROUND_AREA_OFFSET	0
-#define BRIDGE_WKAROUND_AREA_SIZE	32
-
-
-
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/gpio.h b/arch/mips/include/asm/netlogic/gpio.h
index b507852..d6b7202 100644
--- a/arch/mips/include/asm/netlogic/gpio.h
+++ b/arch/mips/include/asm/netlogic/gpio.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
@@ -26,50 +29,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef _ASM_NLM_GPIO_H
 #define _ASM_NLM_GPIO_H
 
-#include <asm/netlogic/iomap.h>
-
-#define NETLOGIC_GPIO_INT_EN_REG 0
-#define NETLOGIC_GPIO_INPUT_INVERSION_REG 1
-#define NETLOGIC_GPIO_IO_DIR_REG 2
-#define NETLOGIC_GPIO_IO_DATA_WR_REG 3
-#define NETLOGIC_GPIO_IO_DATA_RD_REG 4
-
-#define NETLOGIC_GPIO_SWRESET_REG 8
-
-#define NETLOGIC_GPIO_DRAM1_CNTRL_REG 9
-#define NETLOGIC_GPIO_DRAM1_RATIO_REG 10
-#define NETLOGIC_GPIO_DRAM1_RESET_REG 11
-#define NETLOGIC_GPIO_DRAM1_STATUS_REG 12
-
-#define NETLOGIC_GPIO_DRAM2_CNTRL_REG 13
-#define NETLOGIC_GPIO_DRAM2_RATIO_REG 14
-#define NETLOGIC_GPIO_DRAM2_RESET_REG 15
-#define NETLOGIC_GPIO_DRAM2_STATUS_REG 16
-
-#define NETLOGIC_GPIO_PWRON_RESET_CFG_REG 21
-
-#define NETLOGIC_GPIO_BIST_ALL_GO_STATUS_REG 24
-#define NETLOGIC_GPIO_BIST_CPU_GO_STATUS_REG 25
-#define NETLOGIC_GPIO_BIST_DEV_GO_STATUS_REG 26
-
-#define NETLOGIC_GPIO_FUSE_BANK_REG 35
-
-#define NETLOGIC_GPIO_CPU_RESET_REG 40
-
-#define NETLOGIC_GPIO_RNG_REG 43
-
-#define NETLOGIC_PWRON_RESET_PCMCIA_BOOT 17
-
-#define NETLOGIC_GPIO_LED_BITMAP 0x1700000
-#define NETLOGIC_GPIO_LED_0_SHIFT 20
-#define NETLOGIC_GPIO_LED_1_SHIFT 24
-
-#define NETLOGIC_GPIO_LED_OUTPUT_CODE_RESET 0x01
-#define NETLOGIC_GPIO_LED_OUTPUT_CODE_HARD_RESET 0x02
-#define NETLOGIC_GPIO_LED_OUTPUT_CODE_SOFT_RESET 0x03
-#define NETLOGIC_GPIO_LED_OUTPUT_CODE_MAIN 0x04
-
 #ifdef CONFIG_NLM_XLP
+#include <asm/netlogic/iomap.h>
 #include <asm-generic/gpio.h>
 #define gpio_get_value __gpio_get_value
 #define gpio_set_value __gpio_set_value
diff --git a/arch/mips/include/asm/netlogic/i2c-algo-palm.h b/arch/mips/include/asm/netlogic/i2c-algo-palm.h
deleted file mode 100644
index 7fafa4a..0000000
--- a/arch/mips/include/asm/netlogic/i2c-algo-palm.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-/*
- *  i2c-algo-palm.c i2c driver algorithms for the BK3220 I2C Host 
- *  adapter on the RMI Phoenix System.
- *  Derived from the PCA-ISA I2C-Algo/Bus files.
- */
-
-#ifndef I2C_PALM_H
-#define I2C_PALM_H 			1
-
-#define I2C_PALM_CFG			0x00 
-#define I2C_PALM_CLKDIV			0x01 
-#define I2C_PALM_DEVADDR		0x02 
-#define I2C_PALM_ADDR			0x03
-#define I2C_PALM_DATAOUT		0x04 
-#define I2C_PALM_DATAIN			0x05 
-#define I2C_PALM_STATUS			0x06
-#define I2C_PALM_STARTXFR		0x07
-#define I2C_PALM_BYTECNT		0x08
-#define I2C_PALM_HDSTATIM		0x09
-
-/* TEST Values!! Change as required */
-#define I2C_PALM_CFG_DEF		0x000000F8	/* 8-Bit Addr + POR Values */
-#define I2C_PALM_CLKDIV_DEF		0x14A //0x00000052	
-#define I2C_PALM_HDSTATIM_DEF		0x107 //0x00000000
-
-#define I2C_PALM_STARTXFR_RD		0x00000001
-#define I2C_PALM_STARTXFR_WR		0x00000000
-
-#endif /* I2C_PALM_H */
diff --git a/arch/mips/include/asm/netlogic/i2c.h b/arch/mips/include/asm/netlogic/i2c.h
deleted file mode 100644
index 7ad9bb4..0000000
--- a/arch/mips/include/asm/netlogic/i2c.h
+++ /dev/null
@@ -1,33 +0,0 @@
-
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_I2C_H
-#define _ASM_NLM_I2C_H
-
-#define NLM_XLR_I2C_BUS "xlr_i2c_adapter"
-
-#endif
-
diff --git a/arch/mips/include/asm/netlogic/io.h b/arch/mips/include/asm/netlogic/io.h
index c6a7437..db4d4ef 100644
--- a/arch/mips/include/asm/netlogic/io.h
+++ b/arch/mips/include/asm/netlogic/io.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/iomap.h b/arch/mips/include/asm/netlogic/iomap.h
index 8a1418e..a7bbe00 100644
--- a/arch/mips/include/asm/netlogic/iomap.h
+++ b/arch/mips/include/asm/netlogic/iomap.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/linux_crf.h b/arch/mips/include/asm/netlogic/linux_crf.h
deleted file mode 100644
index 2519c6d..0000000
--- a/arch/mips/include/asm/netlogic/linux_crf.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*********************************************************************
- This product is the confidential property of NetLogic Microsystems Inc.
- (“NetLogic”), is provided under a non-disclosure agreement, and is 
- protected under applicable copyright, patent, and trade secret laws.
- Unauthorized use, reproduction, distribution or other dissemination
- without the prior written authorization from NetLogic is
- strictly prohibited.
-
- NETLOGIC DISCLAIMS ALL WARRANTIES OF ANY NATURE, EXPRESS OR IMPLIED,
- INCLUDING, WITHOUT LIMITATION, THE WARRANTIES OF FITNESS FOR A PARTICULAR
- PURPOSE, MERCHANTABILITY AND/OR NON-INFRINGEMENT OF THIRD PARTY RIGHTS.
- NETLOGIC ASSUMES NO LIABILITY FOR ANY ERROR OR OMISSIONS IN THIS PRODUCT,
- OR FOR THE USE OF THIS PRODUCT. IN NO EVENT SHALL NETLOGIC BE LIABLE TO ANY
- OTHER PARTY FOR ANY SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL
- DAMAGES, WHETHER BASED ON BREACH OF CONTRACT, TORT, PRODUCT LIABILITY,
- INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR OTHERWISE. NETLOGIC
- RESERVES THE RIGHT TO MAKE CHANGES TO, OR DISCONTINUE, ITS PRODUCTS AT ANY
- TIME.
-
- Distribution of the product herein does not convey a license or any other
- right in any patent, trademark, or other intellectual property of NetLogic.
-
-Use of the product shall serve as acceptance of these terms and conditions.
-If you do not accept these terms, you should return or destroy the product
-and any other accompanying information immediately.
-
-Copyright, 2002-2010, NetLogic Microsystems, Inc. All rights reserved.
-
-*******************************NETL_3********************************/
-#ifndef _RMICRF_LINUX_H
-#define _RMICRF_LINUX_H
-#include <asm/netlogic/msgring.h>
-
-extern void fdt_parse_args(void);
-extern int fdt_get_core_tlb_size(int core);
-extern int fdt_add_console_string(char *cmdline);
-extern int fdt_get_pic_timer_map(unsigned int *timer_list, int max);
-extern int fdt_get_gmac_pde_reginfo(int id, uint64_t *);
-extern int fdt_get_xgmac_pde_reginfo(int id, uint64_t *);
-extern int fdt_get_spi4_pde_reginfo(int id, uint64_t *);
-extern uint64_t fdt_get_heap_size(void);
-extern int fdt_get_uart_status(int uartno);
-extern uint64_t fdt_get_vuart_fifo_addr(int tx, int instance);
-extern int fdt_get_msgring_int_status(int core, uint32_t *en);
-extern int fdt_get_core_bucket_conf(int core, char buckets[], int bklen, char credits[][8], int crlen);
-extern int fdt_get_bucketmask(uint64_t *);
-extern int fdt_get_sae_bucket_conf(char buckets[], int bklen, char credits[][8], int crlen);
-extern int fdt_get_cde_bucket_conf(char buckets[], int bklen, char credits[][8], int crlen);
-extern int fdt_get_sae_enabled(void);
-extern int fdt_get_cde_enabled(void);
-
-extern void *nlm_get_usermac_addr(int size);
-extern uint32_t dev_tree_en;
-extern uint32_t rmik_en;
-extern uint32_t rmik_cpu_msgring_int_mask[];
-
-extern void rmik_wakeup_cpus(void *fn, void *args, uint32_t cpu_mask);
-extern void config_net_init(void);
-extern void rmik_init(char *g_argv[], int *argc, char *g_envp[]);
-extern void rmik_cpu_to_cpu_msgring_handler(int bucket, int size, int code,
-				    int stid, struct msgrng_msg *msg,
-				    void *data /* ignored */ );
-extern void rmik_config_pde(int type, int instance, nlm_reg_t *mmio);
-extern void rmik_eventq_ipi_handler(void);
-extern void rmik_cpu_to_cpu_pkt_msgring_handler(int size, struct msgrng_msg *msg);
-extern void rmik_vmips_init(void);
-extern void rmik_nlm_common_msgring_cpu_init(void);
-extern int rmik_own_bucket_list_get(int *start, int *end, int *mask);
-extern int rmik_derive_msgring_int_mask(void);
-extern void rmik_register_net_events(void);
-extern int rmik_get_free_running_timer(void);
-extern void (*nlm_vnet_pkt_event_handler)(int len, void *msg);
-extern uint64_t rmik_get_pde_bktmap(int type, int instance);
-#endif
diff --git a/arch/mips/include/asm/netlogic/memory-exclusion.h b/arch/mips/include/asm/netlogic/memory-exclusion.h
deleted file mode 100644
index 02eca0f..0000000
--- a/arch/mips/include/asm/netlogic/memory-exclusion.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef NLM_MEMORY_EXCLUSION
-#define NLM_MEMORY_EXCLUSION
-
-#define NLM_RMIOS_TCPIP_START  (8<<20)
-#define NLM_RMIOS_TCPIP_END    (96<<20)
-
-#define NLM_RMIOS_IPSEC_START  (1<<20)
-#define NLM_RMIOS_IPSEC_END    (51<<20)
-
-#define NLM_RMIOS_LIB_START    (16<<20)
-#define NLM_RMIOS_LIB_END	(51<<20)
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/mips-exts.h b/arch/mips/include/asm/netlogic/mips-exts.h
index b8c3087..5b374e8 100644
--- a/arch/mips/include/asm/netlogic/mips-exts.h
+++ b/arch/mips/include/asm/netlogic/mips-exts.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
@@ -290,9 +293,6 @@ static __inline__ int netlogic_thr_id(void)
 #define CPU_BLOCKID_MMU      4
 #define CPU_BLOCKID_PRF      5
 
-#ifdef CONFIG_NLM_XLR
-#define LSU_CERRLOG_REGID    9
-#else
 #define CPU_BLOCKID_SCU      8
 
 #define ICU_CERRLOG0_REGID   0x10
@@ -306,8 +306,6 @@ static __inline__ int netlogic_thr_id(void)
 #define SCU_CERRLOG1_REGID   0x11
 #define SCU_CERRLOG2_REGID   0x12
 
-#endif
-
 static __inline__ unsigned int read_32bit_nlm_ctrl_reg(int block, int reg)
 {
   unsigned int __res;
@@ -394,27 +392,6 @@ static __inline__ void write_64bit_nlm_ctrl_reg(int block, int reg,unsigned long
 
 typedef struct { volatile int value; } nlm_common_atomic_t;
 
-#ifdef CONFIG_NLM_XLR
-static __inline__ int nlm_common_test_and_set(nlm_common_atomic_t *lock)
-{
-  int oldval = 0;
-
-  __asm__ __volatile__ (".set push\n"
-			".set noreorder\n"
-			"move $9, %2\n"
-			"li $8, 1\n"
-			//"swapw $8, $9\n"
-			".word 0x71280014\n"
-			"move %1, $8\n"
-			".set pop\n"
-			: "+m" (lock->value), "=r" (oldval)
-			: "r" ((unsigned long)&lock->value)
-			: "$8", "$9"
-			);
-  return (oldval == 0 ? 1/*success*/ : 0/*failure*/);
-}
-#endif /* CONFIG_NLM_XLR */
-
 #define nlm_write_os_scratch_2(val)	__write_64bit_c0_register($22, 2, val)
 #define nlm_read_os_scratch_2()	__read_64bit_c0_register($22, 2)
 
@@ -422,10 +399,6 @@ static __inline__ int nlm_common_test_and_set(nlm_common_atomic_t *lock)
 #define nlm_read_os_scratch_3()	__read_64bit_c0_register($22, 3)
 #endif
 
-#ifdef CONFIG_CPU_XLP
 #define SET_MIPS64 .set mips64r2
-#else
-#define SET_MIPS64 .set mips64
-#endif
 
 #endif /* _ASM_NLM_MIPS_EXTS_H */
diff --git a/arch/mips/include/asm/netlogic/msidef.h b/arch/mips/include/asm/netlogic/msidef.h
index df92e36..9754fc4 100644
--- a/arch/mips/include/asm/netlogic/msidef.h
+++ b/arch/mips/include/asm/netlogic/msidef.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/nlm_common_cde.h b/arch/mips/include/asm/netlogic/nlm_common_cde.h
deleted file mode 100644
index 9a1c966..0000000
--- a/arch/mips/include/asm/netlogic/nlm_common_cde.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _NLM_CDE_H
-#define _NLM_CDE_H
-
-#include <asm/netlogic/msgring.h>
-#include <asm/io.h>   // virt_to_phys
-
-#define CMP_REG_CNFG_MSG_CREDIT_SEL 14
-#define CMP_REG_CTRL_REG         0
-#define CMP_REG_DMA_CREDITS_REG  1
-#define CMP_REG_SPILL_ADDR0_REG  2
-#define CMP_REG_SPILL_ADDR1_REG  3
-#define CMP_REG_SPILL_SIZE_REG   4
-#define CMP_REG_SPILL_BYTES_REG  5
-#define CMP_REG_CRC_ADLER_SPILL  6
-#define CMP_REG_SCRATCH_PAGE     7
-#define CMP_REG_INTERRUPT_VEC    8
-#define CMP_REG_INTERRUPT_MASK   9
-#define CMP_REG_FREE_DESC_THRES  10
-#define CMP_REG_DESC_FIFO_COUNT  11
-#define CMP_REG_RESET_REG        12
-#define CMP_REG_ERROR_RESET_MASK 13
-#define CMP_REG_READ_ERROR_LIST0 14
-#define CMP_REG_READ_ERROR_LIST1 15
-
-//defines needed to be declared
-#define CMP_MSG_BUCKET0_SIZE 0x320
-#define CMP_MSG_BUCKET1_SIZE 0x321
-
-
-static inline uint32_t cmp_read_reg(int reg)
-{
-  nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_COMP_OFFSET);
-
-  return netlogic_read_reg(mmio, reg);
-}
-
-static inline void cmp_write_reg(int reg, uint32_t value)
-{
-  nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_COMP_OFFSET);
-
-  netlogic_write_reg(mmio, reg, value);
-}
-
-static __inline__ int make_fd_msg(struct msgrng_msg *msg, void *free_addr)
-{
-  int stid = MSGRNG_STNID_CMP_0;
-
-  msg->msg0 = ( ((uint64_t)virt_to_phys(free_addr) & 0xffffffffffULL)
-                );
-  return stid;
-}
-
-static __inline__ int make_cmp_msg(struct msgrng_msg *msg, int rtn_bkt,
-				   int op, int length, void *src_addr)
-{
-  int stid = MSGRNG_STNID_CMP_1;
-  
-  msg->msg0 = ( ((uint64_t) op << 60)  | 
-                ((uint64_t) rtn_bkt << 54) |
-                ((uint64_t) length << 40) |
-                ((uint64_t) virt_to_phys(src_addr) & 0xffffffffffULL)
-                );
-  return stid;
-}
-
-
-static __inline__ uint64_t make_src_desc(int eof, int type, int sod, int sob, int save,
-					 int restore, int eob, int length, void *src_addr)
-{
-  uint64_t src_desc = 0;
-  src_desc = (  ((uint64_t) eof << 63) | 
-                ((uint64_t) type << 61) |
-                ((uint64_t) sod << 60) |
-                ((uint64_t) sob << 59) |
-                ((uint64_t) save << 58) |
-                ((uint64_t) restore << 57) |
-                ((uint64_t) eob << 56) |
-                ((uint64_t) length << 40) |
-                ((uint64_t) virt_to_phys(src_addr) & 0xffffffffffULL)
-                );
-  return src_desc;
-}
-
-static __inline__ uint64_t get_dest_desc(uint64_t dest_addr)
-{
-  uint64_t *desc;
-  desc = phys_to_virt(dest_addr);
-  return *desc;
-}
-
-static __inline__ int read_cmp_msg(char *buffer, uint64_t payload) 
-{
-  uint64_t i,j,num_bytes;
-  int offset = 0;
-  uint64_t *desc, dest_addr;
-  int num_desc = (payload >> 40) & 0x3fff;
-  char * tmp_ptr;
-
-  //  printk("num_desc = %d\n", num_desc);
-
-  for (i = 0; i < num_desc; i++) {
-    desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
-
-    num_bytes = (*desc >> 40) & 0xffff;
-
-    //    printk("num_bytes = %lld\n", num_bytes);
-
-    dest_addr = *desc & 0xffffffffffUll;
-
-    tmp_ptr = (char *) phys_to_virt(dest_addr & 0xffffffffffUll);
-
-    for (j = 0; j < num_bytes; j++) {
-      buffer[offset+j] = tmp_ptr[j];
-      //   buffer[offset + j] = phys_to_virt(dest_addr & 0xffffffffff)+j;
-    }
-
-    offset = offset + num_bytes;
-  }
-
-  return offset;
-}
-
-
-#ifndef CDE_MAJOR
-#define CDE_MAJOR 0   /* dynamic major by default */
-#endif
-
-
-/*
- * Split minors in two parts
- */
-#define TYPE(minor)	(((minor) >> 4) & 0xf)	/* high nibble */
-#define NUM(minor)	((minor) & 0xf)		/* low  nibble */
-
-
-#define CDE_IOC_MAGIC  'k'
-#define CDE_IOCINFLATE _IO(CDE_IOC_MAGIC, 0)
-#define CDE_IOCDEFLATE _IO(CDE_IOC_MAGIC, 1)
-#define CDE_IOC_MAXNR  1
-
-#define CDE_INFLATE 0
-#define CDE_DEFLATE 1
-
-
-#endif /* _NLM_CDE_H_ */
diff --git a/arch/mips/include/asm/netlogic/nlm_common_rmios_debugger.h b/arch/mips/include/asm/netlogic/nlm_common_rmios_debugger.h
deleted file mode 100644
index 78fc371..0000000
--- a/arch/mips/include/asm/netlogic/nlm_common_rmios_debugger.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#define NLM_DEB_DEV_NAME  "phnxdeb"
-
-#define NLM_RMIOS_DEBUGGER_WRITE                   0xaa10
-#define NLM_RMIOS_DEBUGGER_READ                    0xaa11
-#define NLM_RMIOS_DEBUGGER_TX_MEM_WRITE            0xaa12
-#define NLM_RMIOS_DEBUGGER_TX_MEM_READ             0xaa13
-#define NLM_RMIOS_DEBUGGER_RX_MEM_WRITE            0xaa14
-#define NLM_RMIOS_DEBUGGER_RX_MEM_READ             0xaa15
-#define NLM_RMIOS_DEBUGGER_MEM_READ                0xaa16
-#define NLM_RMIOS_DEBUGGER_MEM_WRITE               0xaa17
-#define NLM_RMIOS_DEBUGGER_PIC_IPI                 0xaa18
-#define LINUX_RMIOS_SHARED_BASE                     0x00040000UL
-#define LINUX_RMIOS_VCPU                            32
-#define LINUX_RMIOS_TX_BUF_SIZE                     1600
-#define LINUX_RMIOS_RX_BUF_SIZE                     256
-#define LINUX_RMIOS_RX_BUF_BASE            LINUX_RMIOS_SHARED_BASE
-#define LINUX_RMIOS_TX_BUF_BASE            (LINUX_RMIOS_RX_BUF_BASE + (LINUX_RMIOS_RX_BUF_SIZE * LINUX_RMIOS_VCPU))
-#define LINUX_RMIOS_CPU_ONLINE_MAP_LOCK    (LINUX_RMIOS_TX_BUF_BASE + (LINUX_RMIOS_TX_BUF_SIZE * LINUX_RMIOS_VCPU))
-#define LINUX_RMIOS_CPU_ONLINE_MAP_LOCK_INIT_DONE  (LINUX_RMIOS_CPU_ONLINE_MAP_LOCK + CACHE_LINE_SIZE)
-#define LINUX_RMIOS_CPU_ONLINE_MAP         (LINUX_RMIOS_CPU_ONLINE_MAP_LOCK_INIT_DONE + CACHE_LINE_SIZE)
-
-#define LOCK_INIT_DONE                              0x900ddeed
-
diff --git a/arch/mips/include/asm/netlogic/nlm_common_sec.h b/arch/mips/include/asm/netlogic/nlm_common_sec.h
deleted file mode 100644
index b9d8253..0000000
--- a/arch/mips/include/asm/netlogic/nlm_common_sec.h
+++ /dev/null
@@ -1,767 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _PHONIEX_SEC_H
-#define _NETLOGIC_SEC_H
-
-#include <linux/types.h>
-#include <asm/netlogic/msgring.h>
-
-enum sec_pipe_config {
-
-  SEC_PIPE_CIPHER_KEY0_L0            = 0x00,
-  SEC_PIPE_CIPHER_KEY0_HI,
-  SEC_PIPE_CIPHER_KEY1_LO,
-  SEC_PIPE_CIPHER_KEY1_HI,
-  SEC_PIPE_CIPHER_KEY2_LO,
-  SEC_PIPE_CIPHER_KEY2_HI,
-  SEC_PIPE_CIPHER_KEY3_LO,
-  SEC_PIPE_CIPHER_KEY3_HI,
-  SEC_PIPE_HMAC_KEY0_LO,
-  SEC_PIPE_HMAC_KEY0_HI,
-  SEC_PIPE_HMAC_KEY1_LO,
-  SEC_PIPE_HMAC_KEY1_HI,
-  SEC_PIPE_HMAC_KEY2_LO,
-  SEC_PIPE_HMAC_KEY2_HI,
-  SEC_PIPE_HMAC_KEY3_LO,
-  SEC_PIPE_HMAC_KEY3_HI,
-  SEC_PIPE_HMAC_KEY4_LO,
-  SEC_PIPE_HMAC_KEY4_HI,
-  SEC_PIPE_HMAC_KEY5_LO,
-  SEC_PIPE_HMAC_KEY5_HI,
-  SEC_PIPE_HMAC_KEY6_LO,
-  SEC_PIPE_HMAC_KEY6_HI,
-  SEC_PIPE_HMAC_KEY7_LO,
-  SEC_PIPE_HMAC_KEY7_HI,
-  SEC_PIPE_NCFBM_LO,
-  SEC_PIPE_NCFBM_HI,
-  SEC_PIPE_INSTR_LO,
-  SEC_PIPE_INSTR_HI,
-  SEC_PIPE_RSVD0,
-  SEC_PIPE_RSVD1,
-  SEC_PIPE_RSVD2,
-  SEC_PIPE_RSVD3,
-
-  SEC_PIPE_DF_PTRS0,
-  SEC_PIPE_DF_PTRS1,
-  SEC_PIPE_DF_PTRS2,
-  SEC_PIPE_DF_PTRS3,
-  SEC_PIPE_DF_PTRS4,
-  SEC_PIPE_DF_PTRS5,
-  SEC_PIPE_DF_PTRS6,
-  SEC_PIPE_DF_PTRS7,
-
-  SEC_PIPE_DU_DATA_IN_LO,
-  SEC_PIPE_DU_DATA_IN_HI,
-  SEC_PIPE_DU_DATA_IN_CTRL,
-  SEC_PIPE_DU_DATA_OUT_LO,
-  SEC_PIPE_DU_DATA_OUT_HI,
-  SEC_PIPE_DU_DATA_OUT_CTRL,
-
-  SEC_PIPE_STATE0,
-  SEC_PIPE_STATE1,
-  SEC_PIPE_STATE2,
-  SEC_PIPE_STATE3,
-  SEC_PIPE_STATE4,
-  SEC_PIPE_INCLUDE_MASK0,
-  SEC_PIPE_INCLUDE_MASK1,
-  SEC_PIPE_INCLUDE_MASK2,
-  SEC_PIPE_INCLUDE_MASK3,
-  SEC_PIPE_INCLUDE_MASK4,
-  SEC_PIPE_EXCLUDE_MASK0,
-  SEC_PIPE_EXCLUDE_MASK1,
-  SEC_PIPE_EXCLUDE_MASK2,
-  SEC_PIPE_EXCLUDE_MASK3,
-  SEC_PIPE_EXCLUDE_MASK4,
-};
-
-enum sec_pipe_base_config {
-  
-  SEC_PIPE0_BASE = 0x00,
-  SEC_PIPE1_BASE = 0x40,
-  SEC_PIPE2_BASE = 0x80,
-  SEC_PIPE3_BASE = 0xc0
-
-};
-
-enum sec_rsa_config {
-  
-  SEC_RSA_PIPE0_DU_DATA_IN_LO = 0x100,
-  SEC_RSA_PIPE0_DU_DATA_IN_HI,
-  SEC_RSA_PIPE0_DU_DATA_IN_CTRL,
-  SEC_RSA_PIPE0_DU_DATA_OUT_LO,
-  SEC_RSA_PIPE0_DU_DATA_OUT_HI,
-  SEC_RSA_PIPE0_DU_DATA_OUT_CTRL,
-  SEC_RSA_RSVD0,
-  SEC_RSA_RSVD1,
-
-  SEC_RSA_PIPE0_STATE0,
-  SEC_RSA_PIPE0_STATE1,
-  SEC_RSA_PIPE0_STATE2,
-  SEC_RSA_PIPE0_INCLUDE_MASK0,
-  SEC_RSA_PIPE0_INCLUDE_MASK1,
-  SEC_RSA_PIPE0_INCLUDE_MASK2,
-  SEC_RSA_PIPE0_EXCLUDE_MASK0,
-  SEC_RSA_PIPE0_EXCLUDE_MASK1,
-  SEC_RSA_PIPE0_EXCLUDE_MASK2,
-  SEC_RSA_PIPE0_EVENT_CTR
-
-};
-
-enum sec_config {
-  
-  SEC_DMA_CREDIT = 0x140,
-  SEC_CONFIG1,
-  SEC_CONFIG2,
-  SEC_CONFIG3,  
-
-};
-
-enum sec_debug_config {
-  
-  SEC_DW0_DESCRIPTOR0_LO  = 0x180,
-  SEC_DW0_DESCRIPTOR0_HI,
-  SEC_DW0_DESCRIPTOR1_LO,
-  SEC_DW0_DESCRIPTOR1_HI,
-  SEC_DW1_DESCRIPTOR0_LO,
-  SEC_DW1_DESCRIPTOR0_HI,
-  SEC_DW1_DESCRIPTOR1_LO,
-  SEC_DW1_DESCRIPTOR1_HI,
-  SEC_DW2_DESCRIPTOR0_LO,
-  SEC_DW2_DESCRIPTOR0_HI,
-  SEC_DW2_DESCRIPTOR1_LO,
-  SEC_DW2_DESCRIPTOR1_HI,
-  SEC_DW3_DESCRIPTOR0_LO,
-  SEC_DW3_DESCRIPTOR0_HI,
-  SEC_DW3_DESCRIPTOR1_LO,
-  SEC_DW3_DESCRIPTOR1_HI,
-
-  SEC_STATE0,
-  SEC_STATE1,  
-  SEC_STATE2,
-  SEC_INCLUDE_MASK0,
-  SEC_INCLUDE_MASK1,
-  SEC_INCLUDE_MASK2,
-  SEC_EXCLUDE_MASK0,
-  SEC_EXCLUDE_MASK1,
-  SEC_EXCLUDE_MASK2,
-  SEC_EVENT_CTR
-
-};
-
-//enum sec_perf_config {
-  
-//  SEC_PERF0  = 0x1c0
-
-//};
-
-enum sec_msgring_bucket_config {
-
-  SEC_BIU_CREDITS = 0x308,
-  
-  SEC_MSG_BUCKET0_SIZE = 0x320,
-  SEC_MSG_BUCKET1_SIZE,
-  SEC_MSG_BUCKET2_SIZE,
-  SEC_MSG_BUCKET3_SIZE,
-  SEC_MSG_BUCKET4_SIZE,
-  SEC_MSG_BUCKET5_SIZE,
-  SEC_MSG_BUCKET6_SIZE,
-  SEC_MSG_BUCKET7_SIZE,
-};
-
-enum sec_msgring_credit_config {
-
-  SEC_CC_CPU0_0                        = 0x380,
-  SEC_CC_CPU1_0                        = 0x388,
-  SEC_CC_CPU2_0                        = 0x390,
-  SEC_CC_CPU3_0                        = 0x398,
-  SEC_CC_CPU4_0                        = 0x3a0,
-  SEC_CC_CPU5_0                        = 0x3a8,
-  SEC_CC_CPU6_0                        = 0x3b0,
-  SEC_CC_CPU7_0                        = 0x3b8
-
-};
-
-enum sec_engine_id {
-  SEC_PIPE0,
-  SEC_PIPE1,
-  SEC_PIPE2,
-  SEC_PIPE3,
-  SEC_RSA
-};
-
-enum sec_cipher {
-  SEC_AES256_MODE_HMAC,
-  SEC_AES256_MODE,
-  SEC_AES256_HMAC,
-  SEC_AES256,
-  SEC_AES192_MODE_HMAC,
-  SEC_AES192_MODE,
-  SEC_AES192_HMAC,
-  SEC_AES192,
-  SEC_AES128_MODE_HMAC,
-  SEC_AES128_MODE,
-  SEC_AES128_HMAC,
-  SEC_AES128,
-  SEC_DES_HMAC,
-  SEC_DES,
-  SEC_3DES,
-  SEC_3DES_HMAC,
-  SEC_HMAC
-};
-
-enum sec_msgrng_msg_ctrl_config {
-  SEC_EOP=5,
-  SEC_SOP=6,
-};
-
-/*
- * Security block data and control exchange
- *
- * A 2-word message ring descriptor is used to pass a pointer to the control descriptor data structure
- * and a pointer to the packet descriptor data structure:
- *
- *  63  61 60    54      53      52    48 47            45 44    40 39                                                     5 4      0
- *  ---------------------------------------------------------------------------------------------------------------------------------
- * | Ctrl | FREEBACKID | IF_L2ALLOC | UNUSED | Control Length | UNUSED | 35 MSB of address of control descriptor data structure | UNUSED |
- *  ---------------------------------------------------------------------------------------------------------------------------------
- *    3       7          1          5             3           5                              35                                 5
- *
- *  63  61 60    54     53          52             51        50    46      45       44    40 39                                                    5 4      0
- *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
- * | Ctrl | FREEBACKID | WRB_COH | WRB_L2ALLOC | DF_PTR_L2ALLOC | UNUSED | Data Length | UNUSED | 35 MSB of address of packet descriptor data structure | UNUSED |
- *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
- *    3       7         1          1               1            5           1          5                                35                              5
- *
- * Addresses assumed to be cache-line aligned, i.e., Address[4:0] ignored (using 5'h00 instead)
- *
- * Control length is the number of control cachelines to be read so user needs to round up
- * the control length to closest integer multiple of 32 bytes. Note that at present (03/18/04)
- * the longest (sensical) ctrl structure is <= 128 bytes.
- *
- * The packet descriptor data structure size is fixed at 1 cacheline (32 bytes).
- * This effectively makes "Data Length" a Load/NoLoad bit. NoLoad causes an abort.
- *
- *
- * Upon completion of operation, the security block returns a 2-word free descriptor
- * in the following format:
- *
- *  63  61 60            54 53   52 51       49   48   47               40 39                                                  0
- *  ----------------------------------------------------------------------------------------------------------------------------
- * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | 1'b0 | Instruction Error |    Address of control descriptor data structure     |
- *  ----------------------------------------------------------------------------------------------------------------------------
- * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | 1'b0 |     Data Error    |    Address of packet descriptor data structure      |
- *  ----------------------------------------------------------------------------------------------------------------------------
- *
- * The Instruction and Data Error codes are enumerated in the 
- * ControlDescriptor and PacketDescriptor sections below
- *
- *
- *                                              /----------------------------------------\
- *                                              |                                        |
- *                                              |   ControlDescriptor_s datastructure    |
- *                                              |                                        |
- *                                              \----------------------------------------/
- *
- *
- *       ControlDescriptor_t.Instruction
- *       -------------------------------
- *
- *   63        37   36   35   34    32 31  29 28         27 26           24
- *  ------------------------------------------------------------------------
- * ||   UNUSED   || V || E/D | Cipher | Mode | Init_Cipher | Cipher_Offset ||   ... CONT ...
- *  ------------------------------------------------------------------------
- *        28        1     1      3       3          2              3        
- *               <CTRL><--------------------CIPHER----------------------->
- *
- *
- *     23   22  21      20     19         18     17        16    15   14 13           2 1         0
- *  -----------------------------------------------------------------------------------------------
- * || HMAC | Hash | Init_Hash | Hash_Offset | Hash_Src || CkSum |  N/U  | CkSum_Offset | CkSum_Src ||
- *  -----------------------------------------------------------------------------------------------
- *     1      2         1            2            1         1       2         12            2
- *   <-----------------------HASH--------------------->  <-----------CHECKSUM-------------------->
- *
- *
- *
- *      CTRL.V                 =        1'b0       Instruction invalid
- *                                      1'b1       Instruction valid
- *      CIPHER.E/D             =        1'b0       Decrypt
- *                                      1'b1       Encrypt
- *             Cipher          =        3'b000     Bypass
- *                                      3'b001     DES
- *                                      3'b010     3DES
- *                                      3'b011     AES 128-bit key
- *                                      3'b100     AES 192-bit key
- *                                      3'b101     AES 256-bit key
- *                                      Remainder  UNDEFINED
- *             Mode            =        3'b000     ECB
- *                                      3'b001     CBC
- *                                      3'b010     CFB (AES only, otherwise undefined)
- *                                      3'b011     OFB (AES only, otherwise undefined)
- *                                      3'b100     CTR (AES only, otherwise undefined)
- *                                      Remainder  UNDEFINED
- *             Init_Cipher     =        2'b00      Preserve old IV/(Keys,NonceCFBMask)
- *                                      2'b01      Load new IV use old Keys,NonceCFBMask
- *                                      2'b10      Load new Keys,NonceCFBMask use old IV (?)
- *                                      2'b11      Load new IV/(Keys,NonceCFBMask)
- *             Cipher_Offset   =                   Nb of words between the first data segment 
- *                                                 and word on which to start cipher operation
- *                                                 (64 BIT WORDS !!!)
- *        HASH.HMAC            =        1'b0       Hash without HMAC
- *                                      1'b1       Hash with HMAC 
- *             Hash            =        2'b00      Hash NOP
- *                                      2'b01      MD5
- *                                      2'b10      SHA-1
- *                                      2'b11      SHA-256
- *             Init_Hash       =        1'b0       Preserve old key HMAC key stored in ID registers (moot if HASH.HMAC == 0)
- *                                      1'b1       Load new HMAC key from memory ctrl section to ID registers
- *             Hash_Offset     =                   Nb of words between the first data segment
- *                                                 and word on which to start hashing 
- *                                                 (64 bit words)
- *             Hash_Src        =        1'b0       DMA channel
- *                                      1'b1       Cipher if word count exceeded Cipher_Offset; 
- *                                                 DMA channel otherwise
- *    CHECKSUM.CkSum           =        1'b0       CkSum NOP
- *                                      1'b1       INTERNET_CHECKSUM
- *             N/U             =        2'bx       Field not used
- *             CkSum_Offset    =                   Nb of words between the first data segment 
- *                                                 and word on which to start 
- *                                                 checksum calculation (32 BIT WORDS !!!)
- *             CkSum_Src       =        2'b00      DMA channel if word count exceeded CkSum_Offset
- *                                      2'b01      Cipher if word count exceeded CkSum_Offset,
- *                                      2'b10      UNDEFINED
- *                                      2'b11      UNDEFINED
- *
- *
- *             OLD !!!
- *             CkSum_Src       =        2'b00      0
- *                                      2'b01      Cipher if word count exceeded CkSum_Offset,
- *                                                 0 otherwise
- *                                      2'b10      DMA channel if word count exceeded 
- *                                                 CkSum_Offset, 0 otherwise
- *                                      2'b11      UNDEFINED
- *
- *
- *       ControlDescriptor_t.cipherHashInfo.infoAES256ModeHMAC
- *       -----------------------------------------------------
- *  
- *  -----------------------------------------------------------------
- * ||63              AES Key0                                      0||
- *  -----------------------------------------------------------------
- *                   .
- *                   .
- *                   .
- *  -----------------------------------------------------------------
- * ||63              AES Key3                                      0||
- *  -----------------------------------------------------------------
- *                   .
- *                   .
- *                   .
- *  -----------------------------------------------------------------
- * ||63              HMAC Key0                                      0||
- *  -----------------------------------------------------------------
- *                   .
- *                   .
- *                   .
- *  -----------------------------------------------------------------
- * ||63              HMAC Key7                                      0||
- *  -----------------------------------------------------------------
- *
- *   63        40  39                   8  7                       0
- *  -----------------------------------------------------------------
- * ||   UNUSED   || Nonce (AES/CTR only) || CFB_Mask (AES/CFB only) ||
- *  -----------------------------------------------------------------
- *        24                 32                       8
- *
- */
-
-
-/*                                              /--------------------------------------------\
- *                                              |                                            |
- *                                              |    New PacketDescriptor_s datastructure    |
- *                                              |                                            |
- *                                              \--------------------------------------------/
- *
- *
- *       PacketDescriptor_t.srcLengthIVOffUseIVNext
- *       ------------------------------------------
- *
- *           63           62      61             59    58        57    56       54  53           43  42    40  39                  5  4      3  2                      0
- *  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
- * || Load HMAC key || Pad Hash || Hash Byte Count || Next || Use IV || IV Offset || Packet length || UNUSED || Segment src address || UNUSED || Global src data offset || 
- *  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
- *           1            1           3                1        1          3              11            3             35                 2                 3
- *
- *
- *             Load HMAC key           =        1'b0       Preserve old HMAC key stored in Auth engine (moot if HASH.HMAC == 0)
- *                                              1'b1       Load HMAC key from ID registers at beginning of op
- *             Pad Hash                =        1'b0       HASH will assume the data was padded to be a multiple
- *                                                         of 512 bits in length and that the last 64 bit word
- *                                                         expresses the total datalength in bits seen by HASH engine
- *                                              1'b1       The data was not padded to be a multiple of 512 bits in length;
- *                                                         The Hash engine will do its own padding to generate the correct digest.
- *             Hash Byte Count                             Number of BYTES on last 64-bit data word to use in digest calculation RELEVANT ONLY IF Pad Hash IS SET
- *                                              3'b000     Use all 8
- *                                              3'b001     Use first (MS) byte only (0-out rest), i.e., 0xddXXXXXXXXXXXXXX
- *                                              3'b010     Use first 2 bytes only (0-out rest), i.e., 0xddddXXXXXXXXXXXX     ... etc
- *             Next                    =        1'b0       Finish (return msg descriptor) at end of operation
- *                                              1'b1       Grab the next PacketDescriptor (i.e. next cache-line) - NOT YET IMPLEMENTED !!!
- *             Use IV                  =        1'b0       Use old IV
- *                                              1'b1       Use data @ Segment_address + IV_Offset as IV
- *             IV Offset               =                   Offset IN NB OF 8 BYTE WORDS from beginning of packet
- *                                                         (i.e. (Potentially shifted) Segment address) to cipher IV
- *             Packet length           =                   Nb double words to stream in (Including Segment address->CP/IV/Auth/CkSum offsets)
- *                                                         This is the total amount of data (x8 in bytes) read    (+1 dword if "Global src data offset" != 0)
- *                                                         This is the total amount of data (x8 in bytes) written (+1 dword if "Global dst data offset" != 0)
- *                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
- *                                                         If Packet length == 11'h7ff and (Global src data offset != 0 or Global dst data offset != 0)
- *                                                         the operation is aborted (no mem writes occur)
- *             Segment src address     =                   35 MSB of pointer to src data (i.e., cache-line aligned)
- *             Global src data offset  =                   Nb BYTES to right-shift data by before presenting it to engines
- *                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
- *
- *       PacketDescriptor_t.dstLLWMask
- *       -----------------------------
- *
- *   63    60  59                 58  57    40  39                 5  4      3  2                      0
- *  -----------------------------------------------------------------------------------------------------
- * || UNUSED || Last long word mask || UNUSED || Cipher dst address || UNUSED || Global dst data offset ||
- *  -----------------------------------------------------------------------------------------------------
- *      4                2               18              35              2                 3
- *
- *
- *             Last long word mask     =   2'b00      Give last 128 bit word to AES/HAMC/CKSUM engines as is
- *                                         2'b11      Mask (zero-out) 32 least significant bits
- *                                         2'b10      Mask 64 LSBs
- *                                         2'b01      Mask 96 LSBs
- *             Cipher dst address      =              35 MSB of pointer to dst location (i.e., cache-line aligned)
- *             Global dst data offset  =              Nb BYTES to left-shift (double-word boundary aligned) data by before writing it to memory
- *
- * Upon completion of operation, the Sec block returns a 2-word free descriptor
- * in the following format:
- *
- *  63  61 60            54 53   52 51       49  48          40 39             0
- *  ----------------------------------------------------------------------------
- * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | Control Error | Source Address |
- *  ----------------------------------------------------------------------------
- * | Ctrl | Destination Id | 2'b00 | Desc Ctrl |   Data Error  | Dest Address   |
- *  ----------------------------------------------------------------------------
- *
- * The Control and Data Error codes are enumerated below
- *
-
-*
- * Component strcts and unions defining CipherHashInfo_u
- */
-
-/* All AES256 possibilities */
- /* AES256, (CTR or CFB),    HMAC (MD5, SHA-1, SHA-256)      - 104 bytes */
-typedef struct AES256ModeHMAC_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-  uint64_t             cipherKey3;
-  uint64_t             hmacKey0;
-  uint64_t             hmacKey1;
-  uint64_t             hmacKey2;
-  uint64_t             hmacKey3;
-  uint64_t             hmacKey4;
-  uint64_t             hmacKey5;
-  uint64_t             hmacKey6;
-  uint64_t             hmacKey7;
-  uint64_t             nonceCFBMask;
-} AES256ModeHMAC_t, *AES256ModeHMAC_pt;
-
-/* AES256, (CTR or CFB),    Non-HMAC (MD5, SHA-1, SHA-256)  - 40  bytes */
-typedef struct AES256Mode_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-  uint64_t             cipherKey3;
-  uint64_t             nonceCFBMask;
-} AES256Mode_t, *AES256Mode_pt;
-
-/* AES256, (ECB, CBC, OFB), HMAC (MD5, SHA-1, SHA-256)      - 96  bytes */
-typedef struct AES256HMAC_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-  uint64_t             cipherKey3;
-  uint64_t             hmacKey0;
-  uint64_t             hmacKey1;
-  uint64_t             hmacKey2;
-  uint64_t             hmacKey3;
-  uint64_t             hmacKey4;
-  uint64_t             hmacKey5;
-  uint64_t             hmacKey6;
-  uint64_t             hmacKey7;
-} AES256HMAC_t, *AES256HMAC_pt;
-
-/* AES256, (ECB, CBC, OFB), Non-HMAC (MD5, SHA-1, SHA-256)  - 32  bytes */
-typedef struct AES256_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-  uint64_t             cipherKey3;
-} AES256_t, *AES256_pt;
-
-
-/* All AES192 possibilities */
-
-/* AES192, (CTR or CFB),    HMAC (MD5, SHA-1, SHA-192)      - 96  bytes */
-typedef struct AES192ModeHMAC_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-  uint64_t             hmacKey0;
-  uint64_t             hmacKey1;
-  uint64_t             hmacKey2;
-  uint64_t             hmacKey3;
-  uint64_t             hmacKey4;
-  uint64_t             hmacKey5;
-  uint64_t             hmacKey6;
-  uint64_t             hmacKey7;
-  uint64_t             nonceCFBMask;
-} AES192ModeHMAC_t, *AES192ModeHMAC_pt;
-
-/* AES192, (CTR or CFB),    Non-HMAC (MD5, SHA-1, SHA-192)  - 32  bytes */
-typedef struct AES192Mode_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-  uint64_t             nonceCFBMask;
-} AES192Mode_t, *AES192Mode_pt;
-
-/* AES192, (ECB, CBC, OFB), HMAC (MD5, SHA-1, SHA-192)      - 88  bytes */
-typedef struct AES192HMAC_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-  uint64_t             hmacKey0;
-  uint64_t             hmacKey1;
-  uint64_t             hmacKey2;
-  uint64_t             hmacKey3;
-  uint64_t             hmacKey4;
-  uint64_t             hmacKey5;
-  uint64_t             hmacKey6;
-  uint64_t             hmacKey7;
-} AES192HMAC_t, *AES192HMAC_pt;
-
-/* AES192, (ECB, CBC, OFB), Non-HMAC (MD5, SHA-1, SHA-192)  - 24  bytes */
-typedef struct AES192_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-} AES192_t, *AES192_pt;
-
-
-/* All AES128 possibilities */
-
-/* AES128, (CTR or CFB),    HMAC (MD5, SHA-1, SHA-128)      - 88  bytes */
-typedef struct AES128ModeHMAC_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             hmacKey0;
-  uint64_t             hmacKey1;
-  uint64_t             hmacKey2;
-  uint64_t             hmacKey3;
-  uint64_t             hmacKey4;
-  uint64_t             hmacKey5;
-  uint64_t             hmacKey6;
-  uint64_t             hmacKey7;
-  uint64_t             nonceCFBMask;
-} AES128ModeHMAC_t, *AES128ModeHMAC_pt;
-
-/* AES128, (CTR or CFB),    Non-HMAC (MD5, SHA-1, SHA-128)  - 24  bytes */
-typedef struct AES128Mode_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             nonceCFBMask;
-} AES128Mode_t, *AES128Mode_pt;
-
-/* AES128, (ECB, CBC, OFB), HMAC (MD5, SHA-1, SHA-128)      - 80  bytes */
-typedef struct AES128HMAC_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             hmacKey0;
-  uint64_t             hmacKey1;
-  uint64_t             hmacKey2;
-  uint64_t             hmacKey3;
-  uint64_t             hmacKey4;
-  uint64_t             hmacKey5;
-  uint64_t             hmacKey6;
-  uint64_t             hmacKey7;
-} AES128HMAC_t, *AES128HMAC_pt;
-
-/* AES128, (ECB, CBC, OFB), Non-HMAC (MD5, SHA-1, SHA-128)  - 16  bytes */
-typedef struct AES128_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-} AES128_t, *AES128_pt;
-
-
-/* All DES possibilities */
-
-/* DES, (ECB, CBC), HMAC (MD5, SHA-1, SHA-128)              - 72  bytes */
-typedef struct DESHMAC_s {
-  uint64_t             cipherKey0;
-  uint64_t             hmacKey0;
-  uint64_t             hmacKey1;
-  uint64_t             hmacKey2;
-  uint64_t             hmacKey3;
-  uint64_t             hmacKey4;
-  uint64_t             hmacKey5;
-  uint64_t             hmacKey6;
-  uint64_t             hmacKey7;
-} DESHMAC_t, *DESHMAC_pt;
-
-/* DES, (ECB, CBC), Non-HMAC (MD5, SHA-1, SHA-128)          - 9   bytes */
-typedef struct DES_s {
-  uint64_t             cipherKey0;
-} DES_t, *DES_pt;
-
-
-/* All 3DES possibilities */
-
-/* 3DES, (ECB, CBC), HMAC (MD5, SHA-1, SHA-128)             - 88  bytes */
-typedef struct TriDESHMAC_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-  uint64_t             hmacKey0;
-  uint64_t             hmacKey1;
-  uint64_t             hmacKey2;
-  uint64_t             hmacKey3;
-  uint64_t             hmacKey4;
-  uint64_t             hmacKey5;
-  uint64_t             hmacKey6;
-  uint64_t             hmacKey7;
-} TriDESHMAC_t, *TriDESHMAC_pt;
-
-/* 3DES, (ECB, CBC), Non-HMAC (MD5, SHA-1, SHA-128)         - 24  bytes */
-typedef struct TriDES_s {
-  uint64_t             cipherKey0;
-  uint64_t             cipherKey1;
-  uint64_t             cipherKey2;
-} TriDES_t, *TriDES_pt;
-
-
-/* HMAC only - no cipher */
-
-/* HMAC (MD5, SHA-1, SHA-128)                               - 64  bytes */
-typedef struct HMAC_s {
-  uint64_t             hmacKey0;
-  uint64_t             hmacKey1;
-  uint64_t             hmacKey2;
-  uint64_t             hmacKey3;
-  uint64_t             hmacKey4;
-  uint64_t             hmacKey5;
-  uint64_t             hmacKey6;
-  uint64_t             hmacKey7;
-} HMAC_t, *HMAC_pt;
-
-typedef union CipherHashInfo_u {
-  AES256ModeHMAC_t     infoAES256ModeHMAC;
-  AES256Mode_t         infoAES256Mode;
-  AES256HMAC_t         infoAES256HMAC;
-  AES256_t             infoAES256;
-  AES192ModeHMAC_t     infoAES192ModeHMAC;
-  AES192Mode_t         infoAES192Mode;
-  AES192HMAC_t         infoAES192HMAC;
-  AES192_t             infoAES192;
-  AES128ModeHMAC_t     infoAES128ModeHMAC;
-  AES128Mode_t         infoAES128Mode;
-  AES128HMAC_t         infoAES128HMAC;
-  AES128_t             infoAES128;
-  DESHMAC_t            infoDESHMAC;
-  DES_t                infoDES;
-  TriDESHMAC_t         info3DESHMAC;
-  TriDES_t             info3DES;
-  HMAC_t               infoHMAC;
-  uint64_t             infoDwords[12];
-} CipherHashInfo_t, *CipherHashInfo_pt;
-
-/*
- * This defines the security control descriptor format
- */
-typedef struct ControlDescriptor_s {
-  uint64_t            instruction;
-  CipherHashInfo_t    cipherHashInfo;
-} ControlDescriptor_t, *ControlDescriptor_pt;
-
-/*
- * This defines the security data descriptor format
- */
-typedef struct PacketDescriptor_s {
-  uint64_t             srcLengthIVOffUseIVNext;
-  uint64_t             dstLLWMask;
-  uint64_t             authDst;
-  uint64_t             ckSumDst;
-} PacketDescriptor_t, *PacketDescriptor_pt;
-
-#define SEC_CTRL_ERR_NONE                    0x000
-#define SEC_CTRL_ERR_UNKNOWN_CIPHER_OP       0x001
-#define SEC_CTRL_ERR_ILLEGAL_MODE            0x002
-#define SEC_CTRL_ERR_UNSUPP_CKSUM_SRC        0x004
-#define SEC_CTRL_ERR_FORBIDDEN_CFB_MASK      0x008
-#define SEC_CTRL_ERR_UNKNOWN_CTRL_OP         0x010
-#define SEC_CTRL_ERR_DATA_READ               0x080
-#define SEC_CTRL_ERR_DESC_CTRL_FIELD         0x100
-
-#define SEC_PKT_ERR_NONE                     0x000
-#define SEC_PKT_ERR_INSUFF_DATA_TO_CIPHER    0x001
-#define SEC_PKT_ERR_ILLEGAL_IV_LOCATION      0x002
-#define SEC_PKT_ERR_ILLEGAL_WORDCOUNT_AES    0x004
-#define SEC_PKT_ERR_ILLEGAL_PAD_BYTECOUNT_SPEC 00x8
-#define SEC_PKT_ERR_INSUFF_DATA_TO_CKSUM       0x010
-#define SEC_PKT_ERR_UNKNOWN_DATA_OP            0x020
-#define SEC_PKT_ERR_INSUFF_DATA_TO_AUTH        0x040
-#define SEC_PKT_ERR_DATA_READ                  0x080
-
-#define HASH_NOP    0
-#define HASH_MD5    1
-#define HASH_SHA1   2
-#define HASH_SHA256 3
-
-static __inline__ int make_sec_desc(struct msgrng_msg *msg, void *ctrl_addr, int ctrl_len, void *data_addr)
-{
-  int stid = MSGRNG_STNID_SEC0;
-  msg->msg0 = ( ((uint64_t)SEC_SOP<<61)  | 
-		((uint64_t)4<<54) |
-		((uint64_t)ctrl_len<<45) |
-		((uint64_t)virt_to_phys(ctrl_addr) & 0xffffffffe0ULL)
-		);
-  msg->msg1 = ( ((uint64_t)SEC_EOP<<61)  | 
-		((uint64_t)4<<54) |
-		((uint64_t)1<<45) |
-		((uint64_t)virt_to_phys(data_addr) & 0xffffffffe0ULL)
-		);
-  msg->msg2 = msg->msg3 = 0;
-
-  return stid;
-}
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/nlm_common_shim_drv.h b/arch/mips/include/asm/netlogic/nlm_common_shim_drv.h
deleted file mode 100644
index 88f4a03..0000000
--- a/arch/mips/include/asm/netlogic/nlm_common_shim_drv.h
+++ /dev/null
@@ -1,505 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _SHIM_H_
-#define _SHIM_H_
-
-#define DEBUG   1
-
-extern int debug_var;
-
-#ifdef DEBUG
-#define debug(level, fmt, args...) \
-	if (debug_var&level) printk(KERN_INFO fmt, ## args)
-#else
-#define debug(fmt, args...)
-#endif
-#define DEBUG_TRACE     0x8000
-#define DEBUG_INFO      0x4000
-#define DEBUG_TX_FSM    0x2000
-#define DEBUG_RX_FSM    0x1000
-#define DEBUG_REG_WRITE 0x0800
-#define DEBUG_ENTRY     0x0400
-#define DEBUG_EXIT      0x0200
-#define DEBUG_DSCR      0x0100
-#define DEBUG_ERROR     0x0080
-
-#define ENTRY_LO(v) ((uint32_t)(v&0xffffffff))
-#define ENTRY_HI(v) ((uint32_t)((v>>32)&0xffffffff))
-
-#define SHIM_OK     0
-#define SHIM_ERROR  -1
-
-/**********************************************************************
- *  DMA Descriptor structure
- ********************************************************************* */
-
-typedef struct shimdscr_s {
-	uint64_t  dscr_a;
-	uint64_t  dscr_b;
-} shimdscr_t;
-
-typedef unsigned long paddr_t;
-typedef unsigned long vaddr_t;
-typedef unsigned long shim_port_t;
-
-/**********************************************************************
- *  DMA Controller structure
- ********************************************************************* */
-
-typedef struct shim_cb_s {
-    int             shim_macnum;
-	int             shim_channel;	/* channel number */
-	int		        shim_txdir;     /* direction (1=transmit) */
-	int		        shim_maxdescr;	/* total # of descriptors in ring */
-	shim_port_t     shim_config0;	/* DMA config register 0 */
-	shim_port_t     shim_config1;	/* DMA config register 1 */
-	shim_port_t     shim_dscrbase;	/* Descriptor base address */
-	shim_port_t     shim_dscrcnt;   /* Descriptor count register */
-	shim_port_t     shim_curdscr;	/* current descriptor address */
-	shim_port_t     shim_dscraddcnt;/* Descriptor add count register */
-
-    /* This stuff is for maintenance of the ring */
-	
-	shimdscr_t     *shim_dscrtable;	/* base of descriptor table */
-	shimdscr_t     *shim_dscrtable_end; /* end of descriptor table */
-
-    struct packet **shim_ctxtable;
-
-    paddr_t         shim_dscrtable_phys; /* and also the phys addr */
-    shimdscr_t     *shim_addptr;  /* next dscr for sw to add */
-    shimdscr_t     *shim_remptr;  /* next dscr for sw to remove */
-    int             fsm_state;
-    int             shim_ready;    /* Activated by driver */
-    int             rcv_buf_full;   /* When set do not issue msgld */
-} shim_cb_t;
-
-#define SHIM_READCSR(t)    (*(uint64_t*)(t))
-#define SHIM_WRITECSR(t,v) (*(uint64_t*)(t) = v)
-#define SHIM_NEXTBUF(d,f) ((((d)->f+1) == (d)->shim_dscrtable_end) ? \
-              (d)->shim_dscrtable : (d)->f+1)
-#define SHIM_MAC_TYPE(macnum) ((macnum < MAC_MAX_GMAC) ? GMAC : XGMAC)
-#define SHIM_MAC_ID(macnum)   ((macnum < MAC_MAX_GMAC) ? macnum :\
-                             (macnum - MAC_MAX_GMAC))
-#define SHIM_GET_CB(macnum, txrx, chan) &shim_cb[macnum][txrx][chan]
-#define SHIM_CURDSCR(p) ((shimdscr_t *)(uint32_t)\
-                SHIM_READCSR(p->shim_curdscr))
-
-
-
-#define SHIM_ST_INVALID     -1
-#define SHIM_TR_INVALID     -1
-#define SHIM_EV_INVALID     -1
-
-/*
- *  Finite State machine States
- *
- *  Count of non-terminal states.  The generated states INVALID and DONE
- *  are terminal, but INIT is not  :-).
- */
-#define SHIM_TX_STATE_CT 3 
-#define SHIM_TX_EVENT_CT 5
-typedef enum {
-    SHIM_ST_TX_INIT,
-    SHIM_ST_TX_ACTIVE,
-    SHIM_ST_TX_PAUSE,  
-} te_shim_tx_state;
-
-typedef enum {
-    SHIM_EV_TX_RESET,     
-    SHIM_EV_TX_CPU_PAUSE_EN,    
-    SHIM_EV_TX_CPU_RESUME,
-    SHIM_EV_TX_DSCR_CNT,
-    SHIM_EV_TX_ADD_DSCR_CNT,
-} te_shim_tx_event;
-
-#define SHIM_RX_STATE_CT 2
-#define SHIM_RX_EVENT_CT 4
-
-typedef enum {
-    SHIM_ST_RX_INIT,
-    SHIM_ST_RX_ACTIVE,
-} te_shim_rx_state;
-
-typedef enum {
-    SHIM_EV_RX_RESET,     
-    SHIM_EV_RX_DSCR_CNT,
-    SHIM_EV_RX_DSCR_ADD_CNT,
-    SHIM_EV_RX_PKT_FROM_MSGRNG
-} te_shim_rx_event;
-
-
-/*
- *  Run the FSM.  Will return SHIM_ST_DONE or SHIM_ST_INVALID
- */
-int shim_run_rx_fsm(shim_cb_t *shim_cb_p, int trans_evt);
-int shim_run_tx_fsm(shim_cb_t *shim_cb_p, int trans_evt);
-
-        
-/*
- * Cast to 64-bit number.  Presumably the syntax is different in 
- * assembly language.
- *
- * Note: you'll need to define uint32_t and uint64_t in your headers.
- */
-
-#if !defined(__ASSEMBLER__)
-#define _SHIM_MAKE64(x) ((uint64_t)(x))
-#define _SHIM_MAKE32(x) ((uint32_t)(x))
-#else
-#define _SHIM_MAKE64(x) (x)
-#define _SHIM_MAKE32(x) (x)
-#endif
-
-
-/*
- * Make a mask for 1 bit at position 'n'
- */
-
-#define _SHIM_MAKEMASK1(n) (_SHIM_MAKE64(1) << _SHIM_MAKE64(n))
-#define _SHIM_MAKEMASK1_32(n) (_SHIM_MAKE32(1) << _SHIM_MAKE32(n))
-
-/*
- * Make a mask for 'v' bits at position 'n'
- */
-
-#define _SHIM_MAKEMASK(v,n) (_SHIM_MAKE64((_SHIM_MAKE64(1)<<(v))-1) << _SHIM_MAKE64(n))
-#define _SHIM_MAKEMASK_32(v,n) (_SHIM_MAKE32((_SHIM_MAKE32(1)<<(v))-1) << _SHIM_MAKE32(n))
-
-/*
- * Make a value at 'v' at bit position 'n'
- */
-
-#define _SHIM_MAKEVALUE(v,n) (_SHIM_MAKE64(v) << _SHIM_MAKE64(n))
-#define _SHIM_MAKEVALUE_32(v,n) (_SHIM_MAKE32(v) << _SHIM_MAKE32(n))
-
-#define _SHIM_GETVALUE(v,n,m) ((_SHIM_MAKE64(v) & _SHIM_MAKE64(m)) >> _SHIM_MAKE64(n))
-#define _SHIM_GETVALUE_32(v,n,m) ((_SHIM_MAKE32(v) & _SHIM_MAKE32(m)) >> _SHIM_MAKE32(n))
-
-/*
- * Macros to read/write on-chip registers
- * XXX should we do the PHYS_TO_K1 here?
- */
-
-
-#if !defined(__ASSEMBLER__)
-#define SHIMWRITECSR(csr,val) *((volatile uint64_t *) PHYS_TO_K1(csr)) = (val)
-#define SHIMREADCSR(csr) (*((volatile uint64_t *) PHYS_TO_K1(csr)))
-#endif /* __ASSEMBLER__ */
-
-
-/*  *********************************************************************
-    *  SHIM Registers
-    ********************************************************************* */
-
-/* 
- * Ethernet Configuration Register 0  
- * Registers: DMA_CONFIG0_MAC_x_RX_CH_0 
- * Registers: DMA_CONFIG0_MAC_x_TX_CH_0
- */
-
-
-#define M_SHIM_DROP                  _SHIM_MAKEMASK1(0)
-#define M_SHIM_CHAIN_SEL             _SHIM_MAKEMASK1(1)
-#define M_SHIM_RESERVED1             _SHIM_MAKEMASK1(2)
-#define M_SHIM_EOP_INT_EN            _SHIM_MAKEMASK1(3)
-#define M_SHIM_HWM_INT_EN            _SHIM_MAKEMASK1(4)
-#define M_SHIM_LWM_INT_EN            _SHIM_MAKEMASK1(5)
-#define M_SHIM_TBX_EN                _SHIM_MAKEMASK1(6)
-#define M_SHIM_TDX_EN                _SHIM_MAKEMASK1(7)
-
-#define S_SHIM_INT_PKTCNT            _SHIM_MAKE64(8)
-#define M_SHIM_INT_PKTCNT            _SHIM_MAKEMASK(8,S_SHIM_INT_PKTCNT)
-#define V_SHIM_INT_PKTCNT(x)         _SHIM_MAKEVALUE(x,S_SHIM_INT_PKTCNT)
-#define G_SHIM_INT_PKTCNT(x)         _SHIM_GETVALUE(x,S_SHIM_INT_PKTCNT,M_SHIM_INT_PKTCNT)
-
-#define S_SHIM_RINGSZ                _SHIM_MAKE64(16)
-#define M_SHIM_RINGSZ                _SHIM_MAKEMASK(16,S_SHIM_RINGSZ)
-#define V_SHIM_RINGSZ(x)             _SHIM_MAKEVALUE(x,S_SHIM_RINGSZ)
-#define G_SHIM_RINGSZ(x)             _SHIM_GETVALUE(x,S_SHIM_RINGSZ,M_SHIM_RINGSZ)
-
-#define S_SHIM_HIGH_WATERMARK        _SHIM_MAKE64(32)
-#define M_SHIM_HIGH_WATERMARK        _SHIM_MAKEMASK(16,S_SHIM_HIGH_WATERMARK)
-#define V_SHIM_HIGH_WATERMARK(x)     _SHIM_MAKEVALUE(x,S_SHIM_HIGH_WATERMARK)
-#define G_SHIM_HIGH_WATERMARK(x)     _SHIM_GETVALUE(x,S_SHIM_HIGH_WATERMARK,M_SHIM_HIGH_WATERMARK)
-
-#define S_SHIM_LOW_WATERMARK         _SHIM_MAKE64(48)
-#define M_SHIM_LOW_WATERMARK         _SHIM_MAKEMASK(16,S_SHIM_LOW_WATERMARK)
-#define V_SHIM_LOW_WATERMARK(x)      _SHIM_MAKEVALUE(x,S_SHIM_LOW_WATERMARK)
-#define G_SHIM_LOW_WATERMARK(x)      _SHIM_GETVALUE(x,S_SHIM_LOW_WATERMARK,M_SHIM_LOW_WATERMARK)
-
-/*
- * Ethernet Configuration Register 1 
- * Registers: DMA_CONFIG1_MAC_x_RX_CH_0 
- * Registers: DMA_CONFIG1_SHIM_x_TX_CH_0
- */
-
-#define M_SHIM_HDR_CF_EN             _SHIM_MAKEMASK1(0)
-#define M_SHIM_ASIC_XFR_EN           _SHIM_MAKEMASK1(1)
-#define M_SHIM_PRE_ADDR_EN           _SHIM_MAKEMASK1(2)
-#define M_SHIM_FLOW_CTL_EN           _SHIM_MAKEMASK1(3)
-#define M_SHIM_NO_DSCR_UPDT          _SHIM_MAKEMASK1(4)
-#define M_SHIM_L2CA		    _SHIM_MAKEMASK1(5)
-#define M_SHIM_CPU_PAUSE_EN		    _SHIM_MAKEMASK1(6)
-
-#define M_SHIM_MBZ1                  _SHIM_MAKEMASK(6,15)
-
-#define S_SHIM_HDR_SIZE              _SHIM_MAKE64(21)
-#define M_SHIM_HDR_SIZE              _SHIM_MAKEMASK(9,S_SHIM_HDR_SIZE)
-#define V_SHIM_HDR_SIZE(x)           _SHIM_MAKEVALUE(x,S_SHIM_HDR_SIZE)
-#define G_SHIM_HDR_SIZE(x)           _SHIM_GETVALUE(x,S_SHIM_HDR_SIZE,M_SHIM_HDR_SIZE)
-
-#define M_SHIM_MBZ2                  _SHIM_MAKEMASK(5,32)
-
-#define S_SHIM_ASICXFR_SIZE          _SHIM_MAKE64(37)
-#define M_SHIM_ASICXFR_SIZE          _SHIM_MAKEMASK(9,S_SHIM_ASICXFR_SIZE)
-#define V_SHIM_ASICXFR_SIZE(x)       _SHIM_MAKEVALUE(x,S_SHIM_ASICXFR_SIZE)
-#define G_SHIM_ASICXFR_SIZE(x)       _SHIM_GETVALUE(x,S_SHIM_ASICXFR_SIZE,M_SHIM_ASICXFR_SIZE)
-
-#define S_SHIM_INT_TIMEOUT           _SHIM_MAKE64(48)
-#define M_SHIM_INT_TIMEOUT           _SHIM_MAKEMASK(16,S_SHIM_INT_TIMEOUT)
-#define V_SHIM_INT_TIMEOUT(x)        _SHIM_MAKEVALUE(x,S_SHIM_INT_TIMEOUT)
-#define G_SHIM_INT_TIMEOUT(x)        _SHIM_GETVALUE(x,S_SHIM_INT_TIMEOUT,M_SHIM_INT_TIMEOUT)
-
-/*
- * Ethernet Descriptor base address 
- */
-
-#define M_SHIM_DSCRBASE_MBZ          _SHIM_MAKEMASK(4,0)
-#define M_SHIM_DSCRBASE              _SHIM_MAKEMASK(36,4)
-
-
-/* 
- * Current Descriptor Address Register 
- */
-
-#define S_SHIM_CURDSCR_ADDR          _SHIM_MAKE64(0)
-#define M_SHIM_CURDSCR_ADDR          _SHIM_MAKEMASK(40,S_SHIM_CURDSCR_ADDR)
-#define S_SHIM_CURDSCR_COUNT         _SHIM_MAKE64(0)
-#define M_SHIM_CURDSCR_COUNT         _SHIM_MAKEMASK(16,S_SHIM_CURDSCR_COUNT)
-
-#define M_SHIM_CURDSCR_ADD_COUNT     M_SHIM_CURDSCR_COUNT
-
-/*  ********************************************************************* 
-    * Ethernet, MAC is not used
-    ********************************************************************* */
-
-#define A_MAC_BASE_0               0 
-
-#define MAC_SPACING                 0x1000
-#define SHIM_TXRX_SPACING        0x0400
-#define SHIM_CHANNEL_SPACING     0x0100
-#define SHIM_RX                      0
-#define SHIM_TX                      1
-#define MAX_SHIM_TXRX                2
-#define MAC_NUM_SHIMCHAN         2           /* channels per direction */
-
-#define MAC_NUM_PORTS               6
-#define MAC_MAX_GMAC                4
-
-#define A_MAC_CHANNEL_BASE(macnum)                  \
-            (A_MAC_BASE_0 +                         \
-             MAC_SPACING*(macnum))
-
-#define R_SHIM_CHANNELS      0x800 /* Relative to A_MAC_CHANNEL_BASE */
-
-#define A_SHIM_CHANNEL_BASE(macnum,txrx,chan)    \
-             ((A_MAC_CHANNEL_BASE(macnum)) +        \
-             R_SHIM_CHANNELS +                   \
-             (SHIM_TXRX_SPACING*(txrx)) +        \
-             (SHIM_CHANNEL_SPACING*(chan)))
-
-#define R_SHIM_CHANNEL_BASE(txrx,chan)    \
-             (R_SHIM_CHANNELS +                   \
-             (SHIM_TXRX_SPACING*(txrx)) +        \
-             (SHIM_CHANNEL_SPACING*(chan)))
-
-#define A_SHIM_REGISTER(macnum,txrx,chan,reg)           \
-            (A_SHIM_CHANNEL_BASE(macnum,txrx,chan) +    \
-            (reg))
-
-#define R_SHIM_REGISTER(txrx,chan,reg)           \
-            (R_SHIM_CHANNEL_BASE(txrx,chan) +    \
-            (reg))
-
-#define I_SHIM_REGISTER(macnum,txrx,chan,reg)\
-            ((A_SHIM_CHANNEL_BASE(macnum,txrx,chan) +    \
-            (reg))/sizeof(unsigned long long int))
-/* 
- * SHIM channel registers, relative to A_SHIM_CHANNEL_BASE
- */
-
-#define R_SHIM_CONFIG0               0x00000000
-#define R_SHIM_CONFIG1               0x00000008
-#define R_SHIM_DSCR_BASE             0x00000010
-#define R_SHIM_DSCR_CNT              0x00000018
-#define R_SHIM_CUR_DSCRA             0x00000020
-#define R_SHIM_CUR_DSCRB             0x00000028
-#define R_SHIM_CUR_DSCRADDR          0x00000030
-#define R_SHIM_DSCR_ADD_CNT          0x00000038
-
-
-/*  *********************************************************************
-    *  DMA Descriptors
-    ********************************************************************* */
-
-/*
- * Descriptor doubleword "A"  (Table 7-12)
- */
-
-#define S_SHIM_DSCRA_OFFSET          _SHIM_MAKE64(0)
-#define M_SHIM_DSCRA_OFFSET          _SHIM_MAKEMASK(5,S_SHIM_DSCRA_OFFSET)
-
-/* Note: Don't shift the address over, just mask it with the mask below */
-#define S_SHIM_DSCRA_A_ADDR          _SHIM_MAKE64(5)
-#define M_SHIM_DSCRA_A_ADDR          _SHIM_MAKEMASK(35,S_SHIM_DSCRA_A_ADDR)
-
-#define M_SHIM_DSCRA_A_ADDR_OFFSET   (M_SHIM_DSCRA_OFFSET | M_SHIM_DSCRA_A_ADDR)
-
-#define S_SHIM_DSCRA_A_ADDR_UA        _SHIM_MAKE64(0)
-#define M_SHIM_DSCRA_A_ADDR_UA        _SHIM_MAKEMASK(40,S_SHIM_DSCRA_A_ADDR_UA)
-
-#define S_SHIM_DSCRA_A_SIZE          _SHIM_MAKE64(40)
-#define M_SHIM_DSCRA_A_SIZE          _SHIM_MAKEMASK(9,S_SHIM_DSCRA_A_SIZE)
-#define V_SHIM_DSCRA_A_SIZE(x)       _SHIM_MAKEVALUE(x,S_SHIM_DSCRA_A_SIZE)
-#define G_SHIM_DSCRA_A_SIZE(x)       _SHIM_GETVALUE(x,S_SHIM_DSCRA_A_SIZE,M_SHIM_DSCRA_A_SIZE)
-
-#define M_SHIM_DSCRA_INTERRUPT       _SHIM_MAKEMASK1(49)
-#define M_SHIM_DSCRA_OFFSETB	    _SHIM_MAKEMASK1(50)
-
-#define S_SHIM_DSCRA_STATUS          _SHIM_MAKE64(51)
-#define M_SHIM_DSCRA_STATUS          _SHIM_MAKEMASK(13,S_SHIM_DSCRA_STATUS)
-#define V_SHIM_DSCRA_STATUS(x)       _SHIM_MAKEVALUE(x,S_SHIM_DSCRA_STATUS)
-#define G_SHIM_DSCRA_STATUS(x)       _SHIM_GETVALUE(x,S_SHIM_DSCRA_STATUS,M_SHIM_DSCRA_STATUS)
-
-/*
- * Descriptor doubleword "B"  (Table 7-13)
- */
-
-
-#define S_SHIM_DSCRB_OPTIONS         _SHIM_MAKE64(0)
-#define M_SHIM_DSCRB_OPTIONS         _SHIM_MAKEMASK(4,S_SHIM_DSCRB_OPTIONS)
-#define V_SHIM_DSCRB_OPTIONS(x)      _SHIM_MAKEVALUE(x,S_SHIM_DSCRB_OPTIONS)
-#define G_SHIM_DSCRB_OPTIONS(x)      _SHIM_GETVALUE(x,S_SHIM_DSCRB_OPTIONS,M_SHIM_DSCRB_OPTIONS)
-
-#define R_SHIM_DSCRB_ADDR            _SHIM_MAKE64(0x10)
-
-/* Note: Don't shift the address over, just mask it with the mask below */
-#define S_SHIM_DSCRB_B_ADDR          _SHIM_MAKE64(5)
-#define M_SHIM_DSCRB_B_ADDR          _SHIM_MAKEMASK(35,S_SHIM_DSCRB_B_ADDR)
-
-#define S_SHIM_DSCRB_B_SIZE          _SHIM_MAKE64(40)
-#define M_SHIM_DSCRB_B_SIZE          _SHIM_MAKEMASK(9,S_SHIM_DSCRB_B_SIZE)
-#define V_SHIM_DSCRB_B_SIZE(x)       _SHIM_MAKEVALUE(x,S_SHIM_DSCRB_B_SIZE)
-#define G_SHIM_DSCRB_B_SIZE(x)       _SHIM_GETVALUE(x,S_SHIM_DSCRB_B_SIZE,M_SHIM_DSCRB_B_SIZE)
-
-#define M_SHIM_DSCRB_B_VALID         _SHIM_MAKEMASK1(49)
-
-#define S_SHIM_DSCRB_PKT_SIZE        _SHIM_MAKE64(50)
-#define M_SHIM_DSCRB_PKT_SIZE        _SHIM_MAKEMASK(14,S_SHIM_DSCRB_PKT_SIZE)
-#define V_SHIM_DSCRB_PKT_SIZE(x)     _SHIM_MAKEVALUE(x,S_SHIM_DSCRB_PKT_SIZE)
-#define G_SHIM_DSCRB_PKT_SIZE(x)     _SHIM_GETVALUE(x,S_SHIM_DSCRB_PKT_SIZE,M_SHIM_DSCRB_PKT_SIZE)
-
-/* 
- * Ethernet Descriptor Status Bits (Table 7-15)
- */
-
-#define M_SHIM_ETHRX_BADIP4CS        _SHIM_MAKEMASK1(51)
-#define M_SHIM_ETHRX_DSCRERR	    _SHIM_MAKEMASK1(52)
-
-#define S_SHIM_ETHRX_RXCH            53
-#define M_SHIM_ETHRX_RXCH            _SHIM_MAKEMASK(2,S_SHIM_ETHRX_RXCH)
-#define V_SHIM_ETHRX_RXCH(x)         _SHIM_MAKEVALUE(x,S_SHIM_ETHRX_RXCH)
-#define G_SHIM_ETHRX_RXCH(x)         _SHIM_GETVALUE(x,S_SHIM_ETHRX_RXCH,M_SHIM_ETHRX_RXCH)
-
-#define S_SHIM_ETHRX_PKTTYPE         55
-#define M_SHIM_ETHRX_PKTTYPE         _SHIM_MAKEMASK(3,S_SHIM_ETHRX_PKTTYPE)
-#define V_SHIM_ETHRX_PKTTYPE(x)      _SHIM_MAKEVALUE(x,S_SHIM_ETHRX_PKTTYPE)
-#define G_SHIM_ETHRX_PKTTYPE(x)      _SHIM_GETVALUE(x,S_SHIM_ETHRX_PKTTYPE,M_SHIM_ETHRX_PKTTYPE)
-
-#define K_SHIM_ETHRX_PKTTYPE_IPV4    0
-#define K_SHIM_ETHRX_PKTTYPE_ARPV4   1
-#define K_SHIM_ETHRX_PKTTYPE_802     2
-#define K_SHIM_ETHRX_PKTTYPE_OTHER   3
-#define K_SHIM_ETHRX_PKTTYPE_USER0   4
-#define K_SHIM_ETHRX_PKTTYPE_USER1   5
-#define K_SHIM_ETHRX_PKTTYPE_USER2   6
-#define K_SHIM_ETHRX_PKTTYPE_USER3   7
-
-#define M_SHIM_ETHRX_MATCH_EXACT     _SHIM_MAKEMASK1(58)
-#define M_SHIM_ETHRX_MATCH_HASH      _SHIM_MAKEMASK1(59)
-#define M_SHIM_ETHRX_BCAST           _SHIM_MAKEMASK1(60)
-#define M_SHIM_ETHRX_MCAST           _SHIM_MAKEMASK1(61)
-#define M_SHIM_ETHRX_BAD	            _SHIM_MAKEMASK1(62)
-#define M_SHIM_ETHRX_SOP             _SHIM_MAKEMASK1(63)
-
-/*
- * Ethernet Transmit Status Bits (Table 7-16)
- */
-
-#define M_SHIM_ETHTX_SOP	    	    _SHIM_MAKEMASK1(63)
-
-/* 
- * Ethernet Transmit Options (Table 7-17)
- */
-
-#define K_SHIM_ETHTX_NOTSOP          _SHIM_MAKE64(0x00)
-#define K_SHIM_ETHTX_APPENDCRC       _SHIM_MAKE64(0x01)
-#define K_SHIM_ETHTX_REPLACECRC      _SHIM_MAKE64(0x02)
-#define K_SHIM_ETHTX_APPENDCRC_APPENDPAD _SHIM_MAKE64(0x03)
-#define K_SHIM_ETHTX_APPENDVLAN_REPLACECRC _SHIM_MAKE64(0x04)
-#define K_SHIM_ETHTX_REMOVEVLAN_REPLACECRC _SHIM_MAKE64(0x05)
-#define K_SHIM_ETHTX_REPLACEVLAN_REPLACECRC _SHIM_MAKE64(0x6)
-#define K_SHIM_ETHTX_NOMODS          _SHIM_MAKE64(0x07)
-#define K_SHIM_ETHTX_RESERVED1       _SHIM_MAKE64(0x08)
-#define K_SHIM_ETHTX_REPLACESADDR_APPENDCRC _SHIM_MAKE64(0x09)
-#define K_SHIM_ETHTX_REPLACESADDR_REPLACECRC _SHIM_MAKE64(0x0A)
-#define K_SHIM_ETHTX_REPLACESADDR_APPENDCRC_APPENDPAD _SHIM_MAKE64(0x0B)
-#define K_SHIM_ETHTX_REPLACESADDR_APPENDVLAN_REPLACECRC _SHIM_MAKE64(0x0C)
-#define K_SHIM_ETHTX_REPLACESADDR_REMOVEVLAN_REPLACECRC _SHIM_MAKE64(0x0D)
-#define K_SHIM_ETHTX_REPLACESADDR_REPLACEVLAN_REPLACECRC _SHIM_MAKE64(0x0E)
-#define K_SHIM_ETHTX_RESERVED2       _SHIM_MAKE64(0x0F)
-
-#define S_MAC_RX_CH0                _SHIM_MAKE64(0)
-#define S_MAC_RX_CH1                _SHIM_MAKE64(8)
-#define S_MAC_TX_CH0                _SHIM_MAKE64(16)
-#define S_MAC_TX_CH1                _SHIM_MAKE64(24)
-
-#define M_MAC_INT_CHANNEL           _SHIM_MAKEMASK(8,0)
-#define R_MAC_ENABLE                    0x00000400
-#define R_MAC_STATUS                    0x00000408
-#define R_MAC_ETHERNET_ADDR             0x00000208
-        
-extern shim_cb_t shim_cb[MAC_NUM_PORTS][MAX_SHIM_TXRX][MAC_NUM_SHIMCHAN];
-/* Register file holding all register values, in a fixed location */
-extern uint64_t reg_file[MAC_SPACING * MAC_NUM_PORTS];
-int shim_handle_rx_pkt_from_msgrng(shim_cb_t *shim_cb_p);
-int shim_handle_reset(shim_cb_t *shim_cb_p);
-int shim_handle_tx_dscr_cnt(shim_cb_t *shim_cb_p);
-int shim_handle_tx_cpu_pause_en(shim_cb_t *shim_cb_p);
-int shim_handle_tx_resume(shim_cb_t *shim_cb_p);
-
-
-#endif /* _SHIM_H_ */
diff --git a/arch/mips/include/asm/netlogic/nlm_common_tb.h b/arch/mips/include/asm/netlogic/nlm_common_tb.h
deleted file mode 100644
index 123ed25..0000000
--- a/arch/mips/include/asm/netlogic/nlm_common_tb.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-#ifndef _NLM_NETLOGIC_TB_H
-#define _NLM_NETLOGIC_TB_H
-
-#include <linux/types.h>
-#include <asm/netlogic/iomap.h>
-#include <linux/nlm_common_tb.h>
-
-#define TB_REG_SIZE				4
-#define TB_NO_RDDATA_REGS		4
-#define TB_MAX_ENTRIES			256
-#define TB_ENTRY_SIZE		(TB_NO_RDDATA_REGS * TB_REG_SIZE)
-#define TB_SIZE				(TB_MAX_ENTRIES * TB_ENTRY_SIZE)
-
-/* ---------------------------------------------------------------------------- */
-/*                             RD/WR macros                                     */
-/* ---------------------------------------------------------------------------- */
-
-static inline unsigned int tb_read_reg_be32(unsigned int reg)
-{
-    nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_TB_OFFSET);
-    return netlogic_read_reg(mmio, reg);
-}
-
-static inline void tb_write_reg_be32 (unsigned int reg, unsigned int value)
-{
-    nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_TB_OFFSET);
-    netlogic_write_reg(mmio, reg, value);
-}
-
-static inline unsigned int tb_read_reg_le32 (unsigned int reg)
-{
-    nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_TB_OFFSET);
-    return netlogic_read_reg_le32(mmio, reg);
-}
-
-static inline void tb_write_reg_le32 (unsigned int reg, unsigned int value)
-{
-    nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_TB_OFFSET);
-    netlogic_write_reg_le32(mmio, reg, value);
-}
-
-#define tb_read_status_reg() tb_read_reg_be32(TB_STATUS_REG)
-#define tb_read_ctrl_reg() tb_read_reg_be32(TB_CTRL_REG)
-
-#define tb_read_reqmatch_reg(i) tb_read_reg_be32 (TB_REQMATCH_REGS + i)
-#define tb_read_raddr_reg(i) tb_read_reg_be32 (TB_RADDR_REGS + i)
-#define tb_read_rddata_reg(i) tb_read_reg_be32 (TB_RDDATA_REGS + i)
-
-#define tb_write_ctrl_reg(val) tb_write_reg_be32 (TB_CTRL_REG, val)
-#define tb_write_reqmatch_reg(i, val) tb_write_reg_be32 ((TB_REQMATCH_REGS+i), val)
-#define tb_write_raddr_reg(i, val) tb_write_reg_be32 ((TB_RADDR_REGS+i), val)
-
-#define tb_reinit(void) {tb_write_reg_be32(TB_INIT_REG, 0x0);tb_write_reg_be32(TB_INIT_REG, 0x1);}
-#define tb_pop_entry(void) tb_write_reg_be32(TB_ACCESS_REG, 0)
-#define disable_tb()    tb_write_reg_be32(TB_CTRL_REG, 0x01000000)
-
-typedef struct _tb_dev_t {
-	unsigned int	size;
-//	unsigned char   data[TB_SIZE];
-	unsigned char   *data;
-} tb_dev_t;
-
-ssize_t	tb_read (struct file *, char *, size_t, loff_t *);
-int		tb_open (struct inode *, struct file *);
-int		tb_ioctl (struct inode *, struct file *, unsigned int, unsigned long);
-int		tb_release (struct inode *, struct file *);
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/nlm_common_uart.h b/arch/mips/include/asm/netlogic/nlm_common_uart.h
deleted file mode 100644
index aabc985..0000000
--- a/arch/mips/include/asm/netlogic/nlm_common_uart.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _UART_H
-#define _UART_H
-
-#include <asm/netlogic/iomap.h>
-
-#define UART_RHR 0
-#define UART_THR 0
-#define UART_IER 1
-#define UART_IIR 2
-#define UART_FCR 2
-#define UART_LCR 3
-#define UART_MCR 4
-#define UART_LSR 5
-#define UART_MSR 6
-
-#define UART_DLB_1 0
-#define UART_DLB_2 1
-
-#define UART_DEBUG_1 8
-#define UART_DEBUG_2 9
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/nlm_dma.h b/arch/mips/include/asm/netlogic/nlm_dma.h
index afacc42..32267fa 100644
--- a/arch/mips/include/asm/netlogic/nlm_dma.h
+++ b/arch/mips/include/asm/netlogic/nlm_dma.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef _NLM_DMA_H
 #define _NLM_DMA_H
 
diff --git a/arch/mips/include/asm/netlogic/nlm_fs.h b/arch/mips/include/asm/netlogic/nlm_fs.h
index 4156f79..f89d623 100644
--- a/arch/mips/include/asm/netlogic/nlm_fs.h
+++ b/arch/mips/include/asm/netlogic/nlm_fs.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef _ASM_NLM_XLR_UACCESS_H
 #define _ASM_NLM_XLR_UACCESS_H
 
diff --git a/arch/mips/include/asm/netlogic/nlm_pcix_gen_dev.h b/arch/mips/include/asm/netlogic/nlm_pcix_gen_dev.h
deleted file mode 100644
index f73cbaf..0000000
--- a/arch/mips/include/asm/netlogic/nlm_pcix_gen_dev.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef __NLM_PCIX_DEVICE_H__
-#define __NLM_PCIX_DEVICE_H__
-
-#include <asm/types.h>
-#include <linux/cache.h>
-
-#ifdef NETLOGIC_LITTLE_ENDIAN
-#define PCIX_REG_BASE 64
-#else
-#define PCIX_REG_BASE (512 + 64)
-#endif
-
-/*Define this macro if device supports MAILBOX interrupt.*/
-//#define XLR_MAILBOX_IS_SUPPORTED 1
-
-/*Define this macro if host is MSI capable.*/
-//#define XLR_MSI_IS_SUPPORTED 1
-
-#define XLR_PCI_HOST_MODE 0x1
-#define XLR_PCI_DEV_MODE 0x2
-#define PCIX_INTRPT_CONTROL_REG ( PCIX_REG_BASE + 15)
-#define PCIX_NETLOGIC_CONTROL_REG ( PCIX_REG_BASE + 14)
-#define PCIX_INTRPT_STATUS_REG ( PCIX_REG_BASE + 16)
-#define PCIX_HOST_MODE_CTRL_STATUS_REG ( PCIX_REG_BASE + 35)
-#define PCIX_DEVICE_MODE_ADDR_MAPPER ( PCIX_REG_BASE + 36)
-#define PCIX_DEVMODE_TBL_BAR0_REG                   (PCIX_REG_BASE + 44)
-#define PCIX_DEVMODE_TBL_BAR1_REG                   (PCIX_REG_BASE + 45)
-#define PCIX_DEVMODE_TBL_BAR2_REG                   (PCIX_REG_BASE + 46)
-#define PCIX_DEVMODE_TBL_BAR3_REG                   (PCIX_REG_BASE + 47)
-
-#define NLM_MAX_IRQS_SUPPORTED 16
-
-#define nlm_common_host_to_pci(addr) ((uint64_t)(addr) | 0x8000000000UL)
-
-#define CACHELINE_ALIGNED_ADDR(addr) \
-			(((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
-
-
-int xlr_get_pci_mode(void);
-void nlm_common_interrupt_host(void);
-// DEVICE SIDE
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-typedef int (*mailbox_handler)(void *, struct pt_regs *);
-int nlm_common_request_mailbox_handler(mailbox_handler, void *, int *);
-int nlm_common_disable_mailbox_intr(int *);
-int nlm_common_enable_mailbox_intr(int *);
-int nlm_common_free_mailbox_handler(int *);
-#endif
-
-
-/*****************************************************************************************************************/
-/**********************************SHARED    MEMORY***************************************************************/
-/*****************************************************************************************************************/
-// DURING BOOT ONLY
-
-#define NLM_BOOT_SHARED_MEM_BASE 0x1000
-#define NLM_BOOT_SHARED_MEM_SIZE (32 * 1024 * 1024)
-
-
-// AFTER BOOTIN WHOLE SHARED MEMORY IS CLAIMED BY THE GENERIC PCI DRIVER 
-#define NLM_GENERIC_SHARED_MEM_BASE (20*1024*1024)
-#define NLM_GENERIC_SHARED_MEM_SIZE (10*1024*1024)
-
-#define NLM_PCIX_SHARED_MEM_START (0x8000000+NLM_GENERIC_SHARED_MEM_BASE)
-#define NLM_PCIX_SHARED_MEM_END (NLM_PCIX_SHARED_MEM_START+NLM_GENERIC_SHARED_MEM_SIZE)
-// All The Shared Address must be unique for each driver. Confliction of Address Space can cause unpredictable result. Shared Space Must be in sync with that of host driver.
-
-
-// SHARED SPACE BETWEEN MAC DRIVERS
-#define NLM_MAC_SHARED_MEM_BASE NLM_GENERIC_SHARED_MEM_BASE
-#define NLM_MAC_SHARED_MEM_SIZE (1 * 1024 * 1024)
-
-
-// SHARED SPACE BETWEEN CONSOLE DRIVERS
-#define NLM_CONSOLE_OVER_PCI_SHARED_MEM_BASE \
-	         (NLM_MAC_SHARED_MEM_BASE + NLM_MAC_SHARED_MEM_SIZE)
-#define NLM_CONSOLE_OVER_PCI_SHARED_MEM_SIZE (9 * 1024)
-
-// SHARED space for DMA
-#define NLM_DMA_MEM_BASE \
-			(NLM_CONSOLE_OVER_PCI_SHARED_MEM_BASE + \
-	 		NLM_CONSOLE_OVER_PCI_SHARED_MEM_SIZE)
-#define NLM_DMA_MEM_SIZE 1024
-
-// SHARED SPACE BETWEEN IP OVER PCI DRIVER...
-#define NLM_IP_OVER_PCI_MEM_BASE \
-			(NLM_DMA_MEM_BASE + NLM_DMA_MEM_SIZE)
-#define NLM_IP_OVER_PCI_MEM_SIZE (8*512+8*512+1024) 
-
-// SHARED SPACE BETWEEN SECURITY DRIVER... xxxx
-//
-//
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/nlm_pcix_gen_host.h b/arch/mips/include/asm/netlogic/nlm_pcix_gen_host.h
deleted file mode 100644
index 23c3c5a..0000000
--- a/arch/mips/include/asm/netlogic/nlm_pcix_gen_host.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef __NLM_PCIX_DEVICE_H__
-#define __NLM_PCIX_DEVICE_H__
-
-#include <asm/types.h>
-#include <linux/cache.h>
-
-/*Define this macro if device supports MAILBOX interrupt.*/
-//#define XLR_MAILBOX_IS_SUPPORTED 1
-
-/*Define this macro if host is MSI capable.*/
-//#define XLR_MSI_IS_SUPPORTED 1
-
-#ifdef CONFIG_NLM_COMMON
-#ifdef NETLOGIC_LITTLE_ENDIAN
-#define PCIX_REG_BASE 64
-#else
-#define PCIX_REG_BASE (512 + 64)
-#endif
-#define PCIX_HOST_MODE_CTRL_STATUS_REG ( PCIX_REG_BASE + 35)
-#endif
-
-#define XLR_PCI_HOST_MODE 0x1
-#define XLR_PCI_DEV_MODE 0x2
-
-#define nlm_common_host_to_pci(addr) ((uint64_t)(addr) | 0x8000000000UL)
-
-#define CACHELINE_ALIGNED_ADDR(addr) \
-			(((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
-
-#ifndef CONFIG_NLM_COMMON
-#ifdef XLR_MSI_IS_SUPPORTED
-typedef int (*msi_handler)(void *, struct pt_regs *);
-#endif
-#endif
-
-// HOST SIDE
-#ifndef CONFIG_NLM_COMMON
-#ifdef XLR_MSI_IS_SUPPORTED
-int nlm_common_request_msi_handler(msi_handler,void *,int *);
-void nlm_common_free_msi_handler(int *);
-int nlm_common_enable_msi(int *);
-int nlm_common_disable_msi(int *);
-void nlm_common_interrupt_host(void);
-#endif
-#endif
-
-#ifdef CONFIG_NLM_COMMON
-int nlm_get_pci_mode(void);
-#endif
-
-unsigned long nlm_common_get_shared_mem_base(void);
-unsigned int nlm_common_pci_readl(unsigned int *);
-u8 nlm_common_pci_readb(u8 *);
-void nlm_nlm_common_interrupt_device(void);
-
-
-
-
-/*****************************************************************************************************************/
-/**********************************SHARED    MEMORY***************************************************************/
-/*****************************************************************************************************************/
-// DURING BOOT ONLY
-
-#define NLM_BOOT_SHARED_MEM_BASE 0x1000
-#define NLM_BOOT_SHARED_MEM_SIZE (32 * 1024 * 1024)
-
-
-// AFTER BOOTIN WHOLE SHARED MEMORY IS CLAIMED BY THE GENERIC PCI DRIVER 
-#define NLM_GENERIC_SHARED_MEM_BASE (20*1024*1024)
-#define NLM_GENERIC_SHARED_MEM_SIZE (10* 1024 * 1024)
-
-// All The Shared Address must be unique for each driver. Confliction of Address Space can cause unpredictable result.
-
-
-// SHARED SPACE BETWEEN MAC DRIVERS
-#define NLM_MAC_SHARED_MEM_BASE NLM_GENERIC_SHARED_MEM_BASE
-#define NLM_MAC_SHARED_MEM_SIZE (1 * 1024 * 1024)
-
-
-// SHARED SPACE BETWEEN CONSOLE DRIVERS
-#define NLM_CONSOLE_OVER_PCI_SHARED_MEM_BASE \
-	         (NLM_MAC_SHARED_MEM_BASE + NLM_MAC_SHARED_MEM_SIZE)
-#define NLM_CONSOLE_OVER_PCI_SHARED_MEM_SIZE (9 * 1024)
-
-// SHARED space for DMA
-#define NLM_DMA_MEM_BASE \
-			(NLM_CONSOLE_OVER_PCI_SHARED_MEM_BASE + \
-	 		NLM_CONSOLE_OVER_PCI_SHARED_MEM_SIZE)
-#define NLM_DMA_MEM_SIZE 1024
-
-// SHARED SPACE BETWEEN IP OVER PCI DRIVER...
-#define NLM_IP_OVER_PCI_MEM_BASE \
-			(NLM_DMA_MEM_BASE + NLM_DMA_MEM_SIZE)
-#define NLM_IP_OVER_PCI_MEM_SIZE (8*512+8*512+1024) 
-
-// SHARED SPACE BETWEEN SECURITY DRIVER... xxxx
-//
-//
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/nlm_rw_lock.h b/arch/mips/include/asm/netlogic/nlm_rw_lock.h
index c331bf2..020fb8c 100644
--- a/arch/mips/include/asm/netlogic/nlm_rw_lock.h
+++ b/arch/mips/include/asm/netlogic/nlm_rw_lock.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/nlm_srio.h b/arch/mips/include/asm/netlogic/nlm_srio.h
deleted file mode 100644
index 91dd8c4..0000000
--- a/arch/mips/include/asm/netlogic/nlm_srio.h
+++ /dev/null
@@ -1,338 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-/*
- * XLS RapidIO definitions
- */
-
-#ifndef __XLS_SRIO_H__
-#define __XLS_SRIO_H__
-
-#include <asm/netlogic/sim.h>
-
-static inline int is_xlsb0_srio(void) 
-{
-    unsigned int gpio_srio = 0;
-    uint32_t *gpio_mmio = (uint32_t *)
-                            (DEFAULT_NETLOGIC_IO_BASE + NETLOGIC_IO_GPIO_OFFSET);
-
-    if (xlr_board_atx_xi() || xlr_board_atx_xii()) {
-        gpio_srio = ((netlogic_read_reg(gpio_mmio,21) >> 26) & 0x3);
-        if (gpio_srio) {
-            return 1;
-        }
-        else {
-            return 0;
-        }
-    }
-    return 0;
-}
-
-#define RIO_OPS_LOCAL_CONFIG_READ(i) \
-        static int nlm_local_config_read_##i(struct rio_mport *mport, int pindex, u32 offset,int len, \
-                    u32 *data) \
-        { \
-            return nlm_local_config_read(rio_controller[i], pindex, offset, len, data);\
-        }
-
-#define RIO_OPS_LOCAL_CONFIG_WRITE(i) \
-static int nlm_local_config_write_##i(struct rio_mport *mport, int pindex, u32 offset,int len, u32 data)\
-{ \
-  return nlm_local_config_write(rio_controller[i], pindex, offset, len, data);\
-}
-
-#define RIO_OPS_CONFIG_READ(i) \
-static int nlm_rio_config_read_##i(struct rio_mport *mport, int index, u16 destid, u8 hopcount,\
-                                     u32 offset,int len, u32 *val) \
-{ \
-    return nlm_rio_config_read(rio_controller[i], index, destid, hopcount,\
-                        offset, len, val);\
-}
-
-#define RIO_OPS_CONFIG_WRITE(i) \
-static int nlm_rio_config_write_##i(struct rio_mport *mport, int index, u16 destid, u8 hopcount, \
-                                    u32 offset,int len, u32 val)\
-{\
-    return nlm_rio_config_write(rio_controller[i], index, destid, \
-                            hopcount, offset, len, val);\
-}
-
-#define RIO_OPS_DOORBELL_SEND(i)\
-static int nlm_rio_doorbell_send_##i(struct rio_mport *mport, int index, u16 destid, u16 data)\
-{\
-    return nlm_rio_doorbell_send(rio_controller[i], index, destid, data);\
-}
-
-void nlm_rio_setup(void);
-
-#define SRIO_IRQ(irq) (PIC_SRIO_LINK0_IRQ+irq)
-#define SRIO_CFG_BIT 21
-
-#define SRIO_X1_MODE 1
-#define SRIO_X4_MODE 2
-
-#define MAX_SRIO_PORTS 4
-#define MIN_SRIO_PORTS 1
-
-#define NLM_SRIO_MEM_SIZE (16<<20)
-
-/*BE space starts @ 0x14000000*/
-#define NLM_SRIO_MEM_0 ((256<<20) + (64<<20))
-#define NLM_SRIO_MEM_1 (NLM_SRIO_MEM_0 + NLM_SRIO_MEM_SIZE) 
-#define NLM_SRIO_MEM_2 (NLM_SRIO_MEM_1 + NLM_SRIO_MEM_SIZE) 
-#define NLM_SRIO_MEM_3 (NLM_SRIO_MEM_2 + NLM_SRIO_MEM_SIZE) 
-
-#define MAX_TQ_ENTRY 256
-#define MAX_SQ_ENTRY MAX_TQ_ENTRY 
-
-#define SIZE_OF_TQ_ENTRY 24
-#define SIZE_OF_SQ_ENTRY (16<<1)
-
-#define MAX_TRANSACTION_Q   2
-#define MAX_STATUS_Q        MAX_TRANSACTION_Q 
-
-#define MAX_MAILBOX_Q       4
-#define MAX_FREEL_Q         MAX_MAILBOX_Q 
-#define MAX_MAILBOX_ENTRY   128
-#define MAX_FREEL_ENTRY     MAX_MAILBOX_ENTRY   
-#define SIZE_OF_MQ_ENTRY    (16<<1)
-#define SIZE_OF_FQ_ENTRY    (8)
-
-/***************************************/
-/**Glue logic Register Goes here**/
-/***************************************/
-#define SRIO_CTRL 0x0
-#define SRIO_PHY_CTRL0  0x1
-#define SRIO_PHY_CTRL1  0x2
-#define SRIO_PHY0_CTRL  0x3
-#define SRIO_PHY1_CTRL  0x4
-#define SRIO_PHY2_CTRL  0x5
-#define SRIO_PHY3_CTRL  0x6
-#define SRIO_COHERENT_MEM_BASE 0x8
-#define SRIO_COHERENT_MEM_LIMIT 0x9
-#define SRIO_REG_L2ALLOC_MEM_BASE 0x10
-#define SRIO_REG_L2ALLOC_MEM_LIMIT 0x11
-#define SRIO_REG_READEX_MEM_BASE 0x12
-#define SRIO_REG_READEX_MEM_LIMIT 0x13
-#define SRIO_REG_PHY_CR_CMD 0x16
-#define SRIO_REG_PHY_CR_WR_DATA 0x17
-#define SRIO_REG_PHY_CR_RESP 0x18
-#define SRIO_REG_PHY_CR_RD_DATA 0x19
-/***************************************/
-/**Glue logic Register Ends here**/
-/***************************************/
-
-/***************************************/
-/**Extended Feature Register Goes here**/
-/***************************************/
-#define P0_EAS_CSR 0x158
-
-#define P0_CTRL_CSR 0x15c
-    /*BIT Fields*/
-    #define OUTPUT_PORT_EN  22
-    #define INPUT_PORT_EN   21
-    #define MULTI_EVENT_EN  12
-
-/***************************************/
-/**Extended Feature Register Ends here**/
-/***************************************/
-
-/***************************************/
-/*Jennic Controller registers goes here*/
-/***************************************/
-
-/*Transaction Types goes here*/
-#define TYPE_MAINTAIN_READ      13
-#define TYPE_MAINTAIN_WRITE     14
-#define TYPE_MESSAGE            16
-#define TYPE_DOORBELL           17
-
-/*Transaction Types ends here*/
-
-/*Implementation defined registers starts*/
-#define MASTER_INTR_STATUS_REG 0x10000
-    #define MISR_DF     (1<<3)
-    #define MISR_MQ3    (1<<6)
-    #define MISR_SQ     (1<<9)
-    #define MISR_GEN    (1<<11)
-#define MASTER_INTR_ENABLE_REG 0x10004
-    /*BIT Fields*/
-    #define MIER_DF     3
-    #define MIER_MQ3    6
-    #define MIER_SQ     9
-    #define MIER_GEN    11
-#define GENERAL_INTR_STATUS_REG 0x10010
-    /*BIT Fields*/
-    #define GISR_PERR   (1<<2)
-    #define GISR_DEC    (1<<5)
-    #define GISR_MQWE   (1<<7)
-    #define GISR_SQWE   (1<<8)
-#define GENERAL_INTR_ENABLE_REG 0x10014
-    /*BIT Fields*/
-    #define GIER_PERR   2
-    #define GIER_DEC    5    
-    #define GIER_MQWE   7
-    #define GIER_SQWE   8
-#define DMA_ERR_CAP_HIGH    0x10030
-#define DMA_ERR_CAP_LOW     0x10034
-#define DMA_ERR_CAP_INFO    0x10038
-/*Transaction Q Registers*/
-#define TRANSACTION_QUEUE_START(n)  (0x20000+0x20*(n))
-#define TRANSACTION_QUEUE_END(n)    (0x20004+0x20*(n))
-#define TRANSACTION_QUEUE_HEAD(n)   (0x20008+0x20*(n))
-#define TRANSACTION_QUEUE_TAIL(n)   (0x2000c+0x20*(n))
-    /*BIT Fields*/
-    #define TQ_LOCK 0
-    #define TQ_FULL 1
-#define TRANSACTION_QUEUE_UPTR(n)   (0x20010+0x20*(n))
-#define TRANSACTION_QUEUE_CTRL_1    (0x20200)
-    /*BIT Fields*/
-    #define CONFIGURE_TQUEUE(n)      (16+n)
-    #define ENABLE_QUEUE            11
-#define TRANSACTION_QUEUE_CTRL_2    (0x20204)
-#define TRANSACTION_QUEUE_STAT      (0x20208)
-#define TRANSACTION_QUEUE_IER       (0x2020c)
-    /*BIT Fields*/
-    #define IN_ENABLE(n)            (16+n)
-
-/*Maintenance Transactions Fields starts*/
-/*word-0*/
-#define MAINT_DEST_ID 16
-#define MAINT_DID_SIZE 7
-/*word-1*/
-#define MAINT_TRANS_SIZE 2
-#define MAINT_TRANS_DEFAULT_BITS 0
-/*word-2*/
-/*word-3*/
-#define MAINT_HOP_COUNT     22
-#define MAINT_REG_OFFSET    0
-/*word-4*/
-/*word-5*/
-/*word-6*/
-
-/*Maintenance Transactions Fields ends*/
-
-/*Message Transactions Fields starts*/
-/*word-0*/
-#define MSG_DEST_ID 16
-#define MSG_DID_SIZE 7
-/*word-1*/
-#define MSG_TRAN_SIZE       3
-#define MSG_MAILBOX_NUMBER  24
-#define MSG_SEG_SIZE        16
-/*Message Transactions Fields ends*/
-
-/*Door bell Transactions Fields starts*/
-/*word-0*/
-#define DBELL_DEST_ID 16
-#define DBELL_DID_SIZE 7
-/*word-1*/
-#define DBELL_INFO  16
-/*Door bell Transactions Fields ends*/
-
-/*Status Q Registers Starts*/
-#define STATUS_QUEUE_START(n)   (0x20400+0x20*(n))
-#define STATUS_QUEUE_END(n)     (0x20404+0x20*(n))
-#define STATUS_QUEUE_HEAD(n)    (0x20408+0x20*(n))
-    /*Bit Fields */
-    #define  SQ_EMPTY 1
-#define STATUS_QUEUE_TAIL(n)    (0x2040c+0x20*(n))
-#define STATUS_QUEUE_UPTR(n)    (0x20410+0x20*(n))
-#define STATUS_QUEUE_CTRL       (0x20600)
-    /*BIT Fields*/
-    #define CONFIGURE_SQUEUE(n)      (16+n)
-#define STATUS_QUEUE_STAT       (0x20608)
-#define STATUS_QUEUE_IER        (0x2060c)
-    /*BIT Fields*/
-    #define NNE_INTR(n)         (n)
-/*Status Q Registers Ends*/
-
-/*Free list Q Registers Starts*/
-#define FREEL_QUEUE_START(n)       (0x20a00+0x20*(n))
-#define FREEL_QUEUE_END(n)         (0x20a04+0x20*(n))
-#define FREEL_QUEUE_HEAD(n)        (0x20a08+0x20*(n))
-#define FREEL_QUEUE_TAIL(n)        (0x20a0c+0x20*(n))
-#define FREEL_QUEUE_UPTR(n)        (0x20a10+0x20*(n))
-    /*Bit fields*/
-    #define FQ_LOCK     0
-    #define FQ_FULL     1
-#define FREEL_BUF_SIZE(n)          (0x20a14+0x20*(n))
-    /*BIT fields*/
-    #define FL_BUF_SIZE            3
-#define FREEL_CONTROL_REG          (0x20c00)
-    /*Bit fields*/
-    #define CONFIGURE_FLQUEUE(n)    (n+16)
-#define FREEL_STATUS_REG           (0x20c08)
-#define FREEL_INT_EN               (0x20c0c)
-/*Free list Q Registers Ends*/
-
-/*Mailbox Q Registers Starts*/
-#define MAILBOX_QUEUE_START(n)  (0x21000+0x20*(n))
-#define MAILBOX_QUEUE_END(n)    (0x21004+0x20*(n))
-#define MAILBOX_QUEUE_HEAD(n)  (0x21008+0x20*(n))
-    /*Bit fields*/
-    #define MQ_EMPTY    1
-#define MAILBOX_QUEUE_TAIL(n)    (0x2100c+0x20*(n))
-#define MAILBOX_QUEUE_UPTR(n)    (0x21010+0x20*(n))
-
-#define MAILBOX_CONTROL_1   0x21800
-    /*BIT Fields*/
-    #define CONFIGURE_MQUEUE(n) (n)
-#define MAILBOX_CONTROL_2   0x21804
-#define MAILBOX_CONTROL_3   0x21808
-    /*BIT Fields*/
-    #define HIGH_MAILB_NO   (6)
-
-#define MAILBOX_STATUS_1    0x21820
-#define MAILBOX_STATUS_2    0x21824
-#define MAILBOX_STATUS_3    0x21828
-#define MAILBOX_STATUS_4    0x2182c
-
-#define MAILBOX_INT_EN_1    0x21830
-#define MAILBOX_INT_EN_2    0x21834
-#define MAILBOX_INT_EN_3    0x21838
-#define MAILBOX_INT_EN_4    0x2183c
-
-/*Mailbox Q Registers Ends*/
-
-/*Door Bell Registers Starts*/
-#define DOORBELL_INFO       0x20804
-    /*Bit fields*/
-    #define DFIFO_NUM       16 
-#define DOORBELL_INTR       0x2080c
-    /*Bit fields*/
-    #define DB_NNE          0
-#define DOORBELL_READ       0x20810
-    /*Bit fields*/
-    #define DB_SRCID        16
-/*Door Bell Registers Ends*/
-
-/*Implementation defined registers ends*/
-
-
-/***************************************/
-/*Jennic Controller registers ends here*/
-/***************************************/
-
-#endif				/* __XLS_SRIO_H__ */
diff --git a/arch/mips/include/asm/netlogic/pci.h b/arch/mips/include/asm/netlogic/pci.h
deleted file mode 100644
index edb3078..0000000
--- a/arch/mips/include/asm/netlogic/pci.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_PCI_H
-#define _ASM_NLM_PCI_H
-
-#define NLM_PCI_VENDOR_ID            0xfecc
-#define NLM_PCI_UART_DEV_ID          2
-#define NLM_PCI_DUMMY_MAC_DEV_ID     16
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/perf_ctr.h b/arch/mips/include/asm/netlogic/perf_ctr.h
deleted file mode 100644
index 4a565b6..0000000
--- a/arch/mips/include/asm/netlogic/perf_ctr.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef __ASM_NLM_PERF_CTR_H
-#define __ASM_NLM_PERF_CTR_H
-
-#include <asm/mipsregs.h>
-
-#define CP0_PERF_CTR  $25
-
-/* Subset of perf ctr events */
-
-#define PERF_CTR_INSTR_FETCHED           0
-#define PERF_CTR_ICACHE_MISSES           1
-#define PERF_CTR_SLEEP_CYCLES           12
-#define PERF_CTR_INSTR_RETIRED          17
-#define PERF_CTR_BRJMP_INSTR            20
-#define PERF_CTR_BRJMP_FLUSH            21
-#define PERF_CTR_REPLAYFLUSH            27
-#define PERF_CTR_REPLAYFLUSH_LDUSE      28
-#define PERF_CTR_L1_HIT                 38
-#define PERF_CTR_L1_REF                 39
-#define PERF_CTR_SNOOP_UPGRADE_FAIL     47
-#define PERF_CTR_SNOOP_TRANSFERS        48
-#define PERF_CTR_SNOOP_HITS             49
-#define PERF_CTR_SNOOP_OPS              50
-#define PERF_CTR_CYCLES                 63
-
-/* 2 sets of counters are supported across all threads of a core */
-#define PERF_CTR_EVENT0        0
-#define PERF_CTR_EVENT0_VALUE  1
-#define PERF_CTR_EVENT1        2
-#define PERF_CTR_EVENT1_VALUE  3
-
-#define PERF_CTR_DEFAULT 0x0f /* disable int, enable counting in all modes */
-
-#define perf_ctr_start(ctr, event, global, thr) __write_32bit_c0_register($25, ctr, ((PERF_CTR_DEFAULT)|((global)<<13)|((thr)<<11)|((event)<<5)) ) 
-
-#define perf_ctr_stop(ctr) __write_32bit_c0_register($25, ctr, 0)
-
-#define perf_ctr_reset(ctr) __write_32bit_c0_register($25, ctr, 0)
-
-#define perf_ctr_read(ctr) __read_32bit_c0_register($25, ctr)
-
-#endif /* __ASM_NLM_PERF_CTR_H */
diff --git a/arch/mips/include/asm/netlogic/phnx_loader.h b/arch/mips/include/asm/netlogic/phnx_loader.h
index 429884a..dc6b99f 100644
--- a/arch/mips/include/asm/netlogic/phnx_loader.h
+++ b/arch/mips/include/asm/netlogic/phnx_loader.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
  * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
  * reserved.
diff --git a/arch/mips/include/asm/netlogic/pic.h b/arch/mips/include/asm/netlogic/pic.h
index 76a42f3..49fbca4 100644
--- a/arch/mips/include/asm/netlogic/pic.h
+++ b/arch/mips/include/asm/netlogic/pic.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/proc.h b/arch/mips/include/asm/netlogic/proc.h
index da729e3..55d1903 100644
--- a/arch/mips/include/asm/netlogic/proc.h
+++ b/arch/mips/include/asm/netlogic/proc.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/sim.h b/arch/mips/include/asm/netlogic/sim.h
deleted file mode 100644
index 307af89..0000000
--- a/arch/mips/include/asm/netlogic/sim.h
+++ /dev/null
@@ -1,449 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_SIM_H
-#define _ASM_SIM_H
-
-#include <linux/types.h>
-#include <asm/cpu.h>
-#include <asm/mipsregs.h>
-
-#define MAX_CPU_REV_LEN	 100
-#define PSB_INFO_VERSION 0x0001
-
-struct psb_info {
-	uint64_t boot_level;
-	uint64_t io_base;
-	uint64_t output_device;
-	uint64_t uart_print;
-	uint64_t led_output;
-	uint64_t init;
-	uint64_t exit;
-	uint64_t warm_reset;
-	uint64_t wakeup;
-	uint64_t nlm_cpu_online_map;
-	uint64_t master_reentry_sp;
-	uint64_t master_reentry_gp;
-	uint64_t master_reentry_fn;
-	uint64_t slave_reentry_fn;
-	uint64_t magic_dword;
-	uint64_t uart_putchar;
-	uint64_t size;
-	uint64_t uart_getchar;
-	uint64_t nmi_handler;
-	uint64_t psb_version;
-	uint64_t mac_addr;
-	uint64_t cpu_frequency;
-	uint64_t board_version;
-	uint64_t malloc;
-	uint64_t free;
-	uint64_t global_shmem_addr;
-	uint64_t global_shmem_size;
-	uint64_t psb_os_cpu_map;
-	uint64_t userapp_cpu_map;
-	uint64_t wakeup_os;
-	uint64_t psb_mem_map;
-	uint64_t board_major_version;
-	uint64_t board_minor_version;
-	uint64_t board_manf_revision;
-	uint64_t board_serial_number;
-	uint64_t psb_physaddr_map;
-	uint64_t xlr_loaderip_config;
-	uint64_t bldr_envp;
-	uint64_t avail_mem_map;
-};
-
-
-enum {
-        NETLOGIC_IO_SPACE = 0x10,
-        PCIX_IO_SPACE,
-        PCIX_CFG_SPACE,
-        PCIX_MEMORY_SPACE,
-        HT_IO_SPACE,
-        HT_CFG_SPACE,
-        HT_MEMORY_SPACE,
-        SRAM_SPACE,
-        FLASH_CONTROLLER_SPACE
-};
-
-#define MAX_ENV_BUF 0x00020000 // 128 KB = One sector of Intel flash.
-struct environment
-{
-        unsigned int crc;
-        unsigned char envbuf[MAX_ENV_BUF - 20]; // 4 bytes for CRC and 16 bytes reserved.
-        unsigned char reserved[16];
-};
-
-#define NLM_XLR_BOARD_ARIZONA_I   1
-#define NLM_XLR_BOARD_ARIZONA_II  2
-#define NLM_XLR_BOARD_ARIZONA_III 3
-#define NLM_XLR_BOARD_ARIZONA_IV  4
-#define NLM_XLR_BOARD_ARIZONA_V   5
-#define NLM_XLR_BOARD_ARIZONA_VI   6  /* XLS boards */
-#define NLM_XLR_BOARD_ARIZONA_VII 7 /*XLS 2xx boards*/
-#define NLM_XLR_BOARD_ARIZONA_VIII 8 /*XLS LTE boards*/
-#define NLM_XLR_BOARD_ARIZONA_XI 11
-#define NLM_XLR_BOARD_ARIZONA_XII  12
-
-struct smp_boot_info_percpu {
-  volatile unsigned long ready;
-  volatile unsigned long sp;
-  volatile unsigned long gp;
-  volatile unsigned long fn;
-};
-
-struct smp_boot_info {
-  struct smp_boot_info_percpu boot_info[NR_CPUS];
-  __u32 online_map;
-};
-
-extern struct smp_boot_info smp_boot;
-extern void prom_boot_cpus_secondary(void *);
-
-extern __u32 xlr_board_major_version;
-extern __u32 xlr_board_minor_version;
-
-#define XLR_REVISION_A0 0xc0000
-#define XLR_REVISION_A1 0xc0001
-#define XLR_REVISION_B0 0xc0002
-#define XLR_REVISION_B1 0xc0003
-#define XLR_REVISION_B2 0xc0004
-#define XLR_REVISION_C0 0xc0005
-#define XLR_REVISION_C1 0xc0006
-#define XLR_REVISION_C2 0xc0007
-#define XLR_REVISION_C3 0xc0008
-#define XLR_REVISION_C4 0xc0009
-
-static __inline__ unsigned int xlr_revision(void)
-{
-	return read_c0_prid() & 0xff00ff;
-}
-
-static __inline__ int xlr_revision_a0(void)
-{
-	return xlr_revision() == XLR_REVISION_A0;
-}
-
-static __inline__ int xlr_revision_b0(void)
-{
-	return xlr_revision() == XLR_REVISION_B0;
-}
-
-static __inline__ int xlr_revision_b1(void)
-{
-        return xlr_revision() == XLR_REVISION_B1;
-}
-
-static __inline__ int xlr_revision_c(void)
-{
-    uint32_t prid = read_c0_prid();
-    if(prid>=XLR_REVISION_C0 && prid<=XLR_REVISION_C4)
-        return 1;        
-    return 0; 
-}
-
-static __inline__ int xlr_board_atx_i(void)
-{
-	return xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_I;
-}
-
-static __inline__ int xlr_board_atx_ii(void)
-{
-	return xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_II;
-}
-
-static __inline__ int xlr_board_atx_ii_b(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_II)
-		&& (xlr_board_minor_version == 1);
-}
-
-static __inline__ int xlr_board_atx_iii(void)
-{
-	return xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_III;
-}
-
-static __inline__ int xlr_board_atx_iv(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_IV)
-		&& (xlr_board_minor_version == 0);
-}
-
-static __inline__ int xlr_board_atx_iv_b(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_IV)
-		&& (xlr_board_minor_version == 1);
-}
-
-static __inline__ int xlr_board_atx_v(void)
-{
-	return xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_V;
-}
-
-static __inline__ int xlr_board_atx_iii_256(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_III)
-		&& (xlr_board_minor_version == 0);
-}
-
-static __inline__ int xlr_board_atx_iii_512(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_III)
-		&& (xlr_board_minor_version == 1);
-}
-
-static __inline__ int xlr_board_atx_v_512(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_V)
-		&& (xlr_board_minor_version == 1);
-}
-
-static __inline__ int xlr_board_atx_vi(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_VI);
-}
-
-static __inline__ int xlr_board_atx_vii(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_VII);
-}
-
-static __inline__ int xlr_board_atx_viii(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_VIII);
-}
-
-static __inline__ int xlr_board_atx_xi(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_XI);
-}
-
-static __inline__ int xlr_board_atx_xii(void)
-{
-	return (xlr_board_major_version == NLM_XLR_BOARD_ARIZONA_XII);
-}
-
-static __inline__ int xlr_board_atx_xaui_rework(void)
-{
-	if ((xlr_board_atx_xi() || xlr_board_atx_xii()) &&
-			(xlr_board_minor_version == 4))
-		return 1;
-	else
-		return 0;
-}
-
-
-#define XLR_HYBRID_NONE              0
-#define XLR_HYBRID_USER_MAC          1
-#define XLR_HYBRID_RMIOS_IPSEC       2
-#define XLR_HYBRID_RMIOS_TCPIP_STACK 3
-#define XLR_HYBRID_USER_MAC_GMAC     4
-#define XLR_HYBRID_USER_MAC_XGMAC    5
-#define XLR_HYBRID_USER_MAC_SPI4     6
-#define XLR_HYBRID_USER_MAC_GMAC_XGMAC    7
-#define XLR_HYBRID_USER_MAC_GMAC_SPI4     8
-
-extern int xlr_hybrid;
-
-static __inline__ int xlr_hybrid_user_mac(void)
-{
-	return xlr_hybrid == XLR_HYBRID_USER_MAC;
-}
-
-static __inline__ int xlr_hybrid_user_mac_xgmac(void)
-{
-	return (xlr_hybrid == XLR_HYBRID_USER_MAC_XGMAC || 
-		xlr_hybrid == XLR_HYBRID_USER_MAC_SPI4);
-}
-
-static __inline__ int xlr_hybrid_rmios_tcpip_stack(void)
-{
-        return xlr_hybrid == XLR_HYBRID_RMIOS_TCPIP_STACK;
-}
-
-static __inline__ int xlr_hybrid_rmios_ipsec(void)
-{
-	return xlr_hybrid == XLR_HYBRID_RMIOS_IPSEC;
-}
-
-static __inline__ int xlr_hybrid_none(void)
-{
-	return xlr_hybrid == XLR_HYBRID_NONE;
-}
-
-struct boot_mem_map_entry *psb_get_physaddr_base_address(unsigned long type);
-
-
-#define CHIP_PROCESSOR_ID_XLS_608   0x80
-#define CHIP_PROCESSOR_ID_XLS_408   0x88
-#define CHIP_PROCESSOR_ID_XLS_404   0x8c
-#define CHIP_PROCESSOR_ID_XLS_208   0x8e
-#define CHIP_PROCESSOR_ID_XLS_204   0x8f
-#define CHIP_PROCESSOR_ID_XLS_108   0xce
-#define CHIP_PROCESSOR_ID_XLS_104   0xcf
-
-/* Defines for XLS B0*/
-#define CHIP_PROCESSOR_ID_XLS_616_B0   0x40
-#define CHIP_PROCESSOR_ID_XLS_608_B0   0x4a
-#define CHIP_PROCESSOR_ID_XLS_416_B0   0x44
-#define CHIP_PROCESSOR_ID_XLS_412_B0   0x4c
-#define CHIP_PROCESSOR_ID_XLS_408_B0   0x4e
-#define CHIP_PROCESSOR_ID_XLS_404_B0   0x4f
-
-#define CHIP_PROCESSOR_ID_XLR_B_308   0x06
-#define CHIP_PROCESSOR_ID_XLR_B_508   0x07
-#define CHIP_PROCESSOR_ID_XLR_B_516   0x08
-#define CHIP_PROCESSOR_ID_XLR_B_532   0x09
-#define CHIP_PROCESSOR_ID_XLR_B_716   0x0a
-#define CHIP_PROCESSOR_ID_XLR_B_732   0x0b
-
-#define CHIP_PROCESSOR_ID_XLR_C_308   0x0F
-#define CHIP_PROCESSOR_ID_XLR_C_508   0x0b
-#define CHIP_PROCESSOR_ID_XLR_C_516   0x0a
-#define CHIP_PROCESSOR_ID_XLR_C_532   0x08
-#define CHIP_PROCESSOR_ID_XLR_C_716   0x02
-
-#if defined(CONFIG_NLM_XLP)
-/* Fake Values for bring-up */
-#define CHIP_PROCESSOR_ID_XLP_A_832   0x00
-#define CHIP_PROCESSOR_ID_XLR_C_732   0xff
-#else
-/* Real Values */
-#define CHIP_PROCESSOR_ID_XLP_A_832   0x90
-#define CHIP_PROCESSOR_ID_XLR_C_732   0x00
-#endif
-
-/*  fill the xls chip family types 
- */
-extern int chip_is_xls6xx;
-extern int chip_is_xls4xx;
-extern int chip_is_xls2xx;
-extern int chip_is_xls1xx;
-extern int chip_is_xls;
-extern int chip_is_xls_b0;
-extern int chip_is_xls6xx_b0;
-extern int chip_is_xls4xx_b0;
-
-static __inline__ void set_xls_chip_family_types(void)
-{
-	int processor_id = ((read_c0_prid() & 0xff00) >> 8);
-	chip_is_xls = 1;
-	switch (processor_id) {
-        case CHIP_PROCESSOR_ID_XLS_608: 
-		{
-			chip_is_xls6xx = 1;
-			break;
-		}
-        case CHIP_PROCESSOR_ID_XLS_408:
-        case CHIP_PROCESSOR_ID_XLS_404:
-		{
-			chip_is_xls4xx = 1;
-			break;
-		}
-        case CHIP_PROCESSOR_ID_XLS_208:
-        case CHIP_PROCESSOR_ID_XLS_204:
-		{
-			chip_is_xls2xx = 1;
-			break;
-		}
-        case CHIP_PROCESSOR_ID_XLS_108:
-        case CHIP_PROCESSOR_ID_XLS_104:
-		{
-			chip_is_xls1xx = 1;
-			break;
-		}
-        case CHIP_PROCESSOR_ID_XLS_616_B0:
-        case CHIP_PROCESSOR_ID_XLS_608_B0:
-		{
-			chip_is_xls_b0 = 1;
-			chip_is_xls6xx_b0 = 1;
-			break;
-		}
-        case CHIP_PROCESSOR_ID_XLS_416_B0:
-        case CHIP_PROCESSOR_ID_XLS_412_B0:
-        case CHIP_PROCESSOR_ID_XLS_408_B0:
-        case CHIP_PROCESSOR_ID_XLS_404_B0:
-		{
-			chip_is_xls_b0 = 1;
-			chip_is_xls4xx_b0 = 1;
-			break;
-		}
-        default:
-			chip_is_xls = 0;
-	}
-	return;
-}
-
-static __inline__ int is_xls(void)
-{
-	return chip_is_xls;
-}
-
-static __inline__ int is_xls2xx(void)
-{
-	return chip_is_xls2xx;
-}
-
-static __inline__ int is_xls1xx(void)
-{
-	return chip_is_xls1xx;
-}
-
-static __inline__ int is_xls4xx(void)
-{
-	return chip_is_xls4xx;
-}
-
-static __inline__ int is_xls6xx(void)
-{
-	return chip_is_xls6xx;
-}
-
-static __inline__ int is_xls_b0_4xx(void)
-{
-	return chip_is_xls4xx_b0;
-}
-
-static __inline__ int is_xls_b0_6xx(void)
-{
-	return chip_is_xls6xx_b0;
-}
-
-static __inline__ int is_xls_b0(void)
-{
-	return chip_is_xls_b0;
-}
-
-
-
-#define NR_CORES 8
-#define NR_CPUS_PER_CORE 4
-#define NLM_MAX_ARGS 32
-#define NLM_MAX_ENVS 32
-
-extern char cpu_model_info[MAX_CPU_REV_LEN];
-extern char* get_cpu_info(void);
-
-#endif /* _ASM_SIM_H */
diff --git a/arch/mips/include/asm/netlogic/utils.h b/arch/mips/include/asm/netlogic/utils.h
deleted file mode 100644
index 53d9772..0000000
--- a/arch/mips/include/asm/netlogic/utils.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifdef CONFIG_64BIT
-#define LLX_FMT "lx"
-#define LLD_FMT "ld"
-#define LLU_FMT "lu"
-#else
-#define LLX_FMT "llx"
-#define LLD_FMT "lld"
-#define LLU_FMT "llu"
-#endif
-
-#define find_32bit_1st_one_bit(source)    \
-({ unsigned int __res;                    \
-    __asm__ __volatile__(                 \
-	".set\tpush\n\t"                  \
-	".set\tnoreorder\n\t"             \
-        ".set\tmips32\n\t"                \
-	"move\t$8,%1\n\t"                 \
-	"clz\t%0,$8\n\t"                  \
-	".set\tpop"                       \
-	: "=r"(__res): "r"(source): "$8");   \
-    __res;})
-
-#define find_32bit_1st_zero_bit(source)   \
-({ unsigned int __res;                    \
-    __asm__ __volatile__(                 \
-	".set\tpush\n\t"                  \
-	".set\tnoreorder\n\t"             \
-        ".set\tmips32\n\t"                \
-	"move\t$8,%1\n\t"                 \
-	"clo\t%0,$8\n\t"                  \
-	".set\tpop"                       \
-	: "=r"(__res): "r"(source): "$8" );      \
-    __res;})
-
-#define find_64bit_1st_one_bit(source)    \
-({ unsigned int __res;                    \
-    __asm__ __volatile__(                 \
-	".set\tpush\n\t"                  \
-	".set\tnoreorder\n\t"             \
-        ".set\tmips32\n\t"                \
-	"move\t$8,%1\n\t"                 \
-	"dclz\t%0,$8\n\t"                 \
-	".set\tpop"                       \
-	: "=r"(__res): "r"(source): "$8" );      \
-    __res;})
-
-#define find_64bit_1st_zero_bit(source)    \
-({ unsigned int __res;                    \
-    __asm__ __volatile__(                 \
-	".set\tpush\n\t"                  \
-	".set\tnoreorder\n\t"             \
-        ".set\tmips32\n\t"                \
-	"move\t$8,%1\n\t"                 \
-	"dclo\t%0,$8\n\t"                 \
-	".set\tpop"                       \
-	: "=r"(__res): "r"(source): "$8" );      \
-    __res;})
-
diff --git a/arch/mips/include/asm/netlogic/xgmac_mdio.h b/arch/mips/include/asm/netlogic/xgmac_mdio.h
deleted file mode 100644
index 4ce8b30..0000000
--- a/arch/mips/include/asm/netlogic/xgmac_mdio.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-// MDIO Low level Access routines
-// All Phy's accessed from GMAC0 base
-
-#ifndef _XGMAC_MDIO
-#define _XGMAC_MDIO
-
-static inline int xmdio_read  (volatile unsigned int *_mmio,
-		uint32_t phy_addr, uint32_t address) ;
-static inline void xmdio_write (volatile unsigned int *_mmio, 
-		uint32_t phy_addr, uint32_t address, uint32_t data) ;
-static inline void xmdio_address (volatile unsigned int *_mmio, 
-		uint32_t phy_addr, uint32_t dev_ad, uint32_t address) ;
-
-// function prototypes
-static inline int xmdio_read  (volatile unsigned int *_mmio, 
-		uint32_t phy_addr, uint32_t address) {
-	uint32_t st_field = 0x0 ;
-	uint32_t op_type  = 0x3 ; // read operation
-	uint32_t ta_field = 0x2 ; // ta field
-	uint32_t data = 0 ;
-
-        xmdio_address (_mmio, phy_addr, 5, address) ;
-	_mmio [0x11] =  ( ( st_field & 0x3    ) << 30 ) |
-		( ( op_type  & 0x3    ) << 28 ) | 
-		( ( phy_addr & 0x1F   ) << 23 ) | 
-		( ( 5  & 0x1F   ) << 18 ) | 
-		( ( ta_field & 0x3    ) << 16 ) | 
-		( ( data     & 0xffff ) <<  0 ) ;
-
-	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
-	_mmio [0x10] =  ( 0x1 << 3 ) | 0x5 ;
-	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
-
-	// wait for write cycle to complete
-	while (_mmio [0x14] & 0x1) {
-	} ; 
-
-	data = _mmio [0x11] & 0xffff ;
-	return (data);
-}
- 
-static inline void xmdio_write (volatile unsigned int *_mmio, 
-		uint32_t phy_addr, uint32_t address, uint32_t data) {
-	uint32_t st_field = 0x0 ;
-	uint32_t op_type  = 0x1 ; // write operation
-	uint32_t ta_field = 0x2 ; // ta field
-
-        xmdio_address ( _mmio, phy_addr, 5, address) ;
-	_mmio [0x11] =  ( ( st_field & 0x3    ) << 30 ) |
-		( ( op_type  & 0x3    ) << 28 ) | 
-		( ( phy_addr & 0x1F   ) << 23 ) | 
-		( ( 5  & 0x1F   ) << 18 ) | 
-		( ( ta_field & 0x3    ) << 16 ) | 
-		( ( data     & 0xffff ) <<  0 ) ;
-
-	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
-	_mmio [0x10] =  ( 0x1 << 3 ) | 0x5 ;
-	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
-
-	// wait for write cycle to complete
-	while (_mmio [0x14] & 0x1) {
-	} ; 
-
-}
-
-static inline void xmdio_address (volatile unsigned int *_mmio, 
-		uint32_t phy_addr, uint32_t dev_ad, uint32_t address) {
-	uint32_t st_field = 0x0 ;
-	uint32_t op_type  = 0x0 ; // address operation
-	uint32_t ta_field = 0x2 ; // ta field
-
-	_mmio [0x11] =  ( ( st_field & 0x3    ) << 30 ) |
-		( ( op_type  & 0x3    ) << 28 ) | 
-		( ( phy_addr & 0x1F   ) << 23 ) | 
-		( ( dev_ad  & 0x1F   ) << 18 ) | 
-		( ( ta_field & 0x3    ) << 16 ) | 
-		( ( address  & 0xffff ) <<  0 ) ;
-
-	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
-	_mmio [0x10] =  ( 0x1 << 3 ) | 0x5 ;
-	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
-
-	// wait for dev_ad cycle to complete
-	while (_mmio [0x14] & 0x1) {
-	} ; 
-
-}
- 
-#endif
diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index e7c864a..58c3ca6 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/cpu.h b/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
index ab1a881..f71c9b7 100644
--- a/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
+++ b/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /*
  * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
  * reserved. Redistribution and use in source and binary forms, with 
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
index ea85462..5f9c6c9 100644
--- a/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
+++ b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef __CPUCONTROL_MACROS_H__
 #define __CPUCONTROL_MACROS_H__
 #include <asm/netlogic/xlp8xx/cpu.h>
diff --git a/arch/mips/include/asm/netlogic/xlp_hal_pic.h b/arch/mips/include/asm/netlogic/xlp_hal_pic.h
index 8a78ac2..e6b5314 100644
--- a/arch/mips/include/asm/netlogic/xlp_hal_pic.h
+++ b/arch/mips/include/asm/netlogic/xlp_hal_pic.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index 70b5742..fee3f41 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
@@ -59,11 +62,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_IRQ_IPI_SMP_KGDB	     50
 #define XLP_IRQ_IPI_OPROFILE         51
 
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-#define XLP_IRQ_IPI_NETRX		49
-#define SMP_NETRX_IPI			32
-#endif /* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
-
 /* if you want some common #defines, please do it here */
 #define NLM_IRQ_DUMMY_UART		XLP_IRQ_DUMMY_UART
 #define NLM_IRQ_IPI_SMP_FUNCTION	XLP_IRQ_IPI_SMP_FUNCTION
diff --git a/arch/mips/include/asm/netlogic/xlp_usb.h b/arch/mips/include/asm/netlogic/xlp_usb.h
index 513147f..49b5e13 100644
--- a/arch/mips/include/asm/netlogic/xlp_usb.h
+++ b/arch/mips/include/asm/netlogic/xlp_usb.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
  * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
  * reserved.
diff --git a/arch/mips/include/asm/netlogic/xlr_board.h b/arch/mips/include/asm/netlogic/xlr_board.h
deleted file mode 100644
index 9226361..0000000
--- a/arch/mips/include/asm/netlogic/xlr_board.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-#ifndef _NLM_XLR_BOARD_H
-#define _NLM_XLR_BOARD_H
-
-#include <linux/types.h>
-
-typedef struct xlr_board_info {
-	int major;
-	int minor;
-	uint32_t cpu_freq;
-	uint8_t mac_addr[6];
-}xlr_board_info_t;
-
-/* These functions should be defined by the board dependent code */
-int read_board_info(xlr_board_info_t *board);
-
-
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/xlr_mac.h b/arch/mips/include/asm/netlogic/xlr_mac.h
deleted file mode 100644
index 46515eb..0000000
--- a/arch/mips/include/asm/netlogic/xlr_mac.h
+++ /dev/null
@@ -1,1158 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_MAC_H
-#define _ASM_NLM_MAC_H
-
-#include <linux/types.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/iomap.h>
-#include <linux/skbuff.h>
-#include <asm/netlogic/nlm_common_sec.h>
-#include <asm/netlogic/config_net.h>
-
-#define IPSEC_PACKET_PAYLOAD_SIZE 1696
-#define PHXSEC_HMAC_LENGTH 64
-#define SKBUF_HEAD (32 * 2)    // 2 cachelines reserved before payload
-
-//#define MAC_SPLIT_MODE
-
-#define MAC_SPACING                 0x400
-#define XGMAC_SPACING               0x400
-
-/* PE-MCXMAC register and bit field definitions */
-#define R_MAC_CONFIG_1                                              0x00
-#define   O_MAC_CONFIG_1__srst                                      31
-#define   O_MAC_CONFIG_1__simr                                      30
-#define   O_MAC_CONFIG_1__hrrmc                                     18
-#define   W_MAC_CONFIG_1__hrtmc                                      2
-#define   O_MAC_CONFIG_1__hrrfn                                     16
-#define   W_MAC_CONFIG_1__hrtfn                                      2
-#define   O_MAC_CONFIG_1__intlb                                      8
-#define   O_MAC_CONFIG_1__rxfc                                       5
-#define   O_MAC_CONFIG_1__txfc                                       4
-#define   O_MAC_CONFIG_1__srxen                                      3
-#define   O_MAC_CONFIG_1__rxen                                       2
-#define   O_MAC_CONFIG_1__stxen                                      1
-#define   O_MAC_CONFIG_1__txen                                       0
-#define R_MAC_CONFIG_2                                              0x01
-#define   O_MAC_CONFIG_2__prlen                                     12
-#define   W_MAC_CONFIG_2__prlen                                      4
-#define   O_MAC_CONFIG_2__speed                                      8
-#define   W_MAC_CONFIG_2__speed                                      2
-#define   O_MAC_CONFIG_2__hugen                                      5
-#define   O_MAC_CONFIG_2__flchk                                      4
-#define   O_MAC_CONFIG_2__crce                                       1
-#define   O_MAC_CONFIG_2__fulld                                      0
-#define R_IPG_IFG                                                   0x02
-#define   O_IPG_IFG__ipgr1                                          24
-#define   W_IPG_IFG__ipgr1                                           7
-#define   O_IPG_IFG__ipgr2                                          16
-#define   W_IPG_IFG__ipgr2                                           7
-#define   O_IPG_IFG__mifg                                            8
-#define   W_IPG_IFG__mifg                                            8
-#define   O_IPG_IFG__ipgt                                            0
-#define   W_IPG_IFG__ipgt                                            7
-#define R_HALF_DUPLEX                                               0x03
-#define   O_HALF_DUPLEX__abebt                                      24
-#define   W_HALF_DUPLEX__abebt                                       4
-#define   O_HALF_DUPLEX__abebe                                      19
-#define   O_HALF_DUPLEX__bpnb                                       18
-#define   O_HALF_DUPLEX__nobo                                       17
-#define   O_HALF_DUPLEX__edxsdfr                                    16
-#define   O_HALF_DUPLEX__retry                                      12
-#define   W_HALF_DUPLEX__retry                                       4
-#define   O_HALF_DUPLEX__lcol                                        0
-#define   W_HALF_DUPLEX__lcol                                       10
-#define R_MAXIMUM_FRAME_LENGTH                                      0x04
-#define   O_MAXIMUM_FRAME_LENGTH__maxf                               0
-#define   W_MAXIMUM_FRAME_LENGTH__maxf                              16
-#define R_TEST                                                      0x07
-#define   O_TEST__mbof                                               3
-#define   O_TEST__rthdf                                              2
-#define   O_TEST__tpause                                             1
-#define   O_TEST__sstct                                              0
-#define R_MII_MGMT_CONFIG                                           0x08
-#define   O_MII_MGMT_CONFIG__scinc                                   5
-#define   O_MII_MGMT_CONFIG__spre                                    4
-#define   O_MII_MGMT_CONFIG__clks                                    3
-#define   W_MII_MGMT_CONFIG__clks                                    3
-#define R_MII_MGMT_COMMAND                                          0x09
-#define   O_MII_MGMT_COMMAND__scan                                   1
-#define   O_MII_MGMT_COMMAND__rstat                                  0
-#define R_MII_MGMT_ADDRESS                                          0x0A
-#define   O_MII_MGMT_ADDRESS__fiad                                   8
-#define   W_MII_MGMT_ADDRESS__fiad                                   5
-#define   O_MII_MGMT_ADDRESS__fgad                                   5
-#define   W_MII_MGMT_ADDRESS__fgad                                   0
-#define R_MII_MGMT_WRITE_DATA                                       0x0B
-#define   O_MII_MGMT_WRITE_DATA__ctld                                0
-#define   W_MII_MGMT_WRITE_DATA__ctld                               16
-#define R_MII_MGMT_STATUS                                           0x0C
-#define R_MII_MGMT_INDICATORS                                       0x0D
-#define   O_MII_MGMT_INDICATORS__nvalid                              2
-#define   O_MII_MGMT_INDICATORS__scan                                1
-#define   O_MII_MGMT_INDICATORS__busy                                0
-#define R_INTERFACE_CONTROL                                         0x0E
-#define   O_INTERFACE_CONTROL__hrstint                              31
-#define   O_INTERFACE_CONTROL__tbimode                              27
-#define   O_INTERFACE_CONTROL__ghdmode                              26
-#define   O_INTERFACE_CONTROL__lhdmode                              25
-#define   O_INTERFACE_CONTROL__phymod                               24
-#define   O_INTERFACE_CONTROL__hrrmi                                23
-#define   O_INTERFACE_CONTROL__rspd                                 16
-#define   O_INTERFACE_CONTROL__hr100                                15
-#define   O_INTERFACE_CONTROL__frcq                                 10
-#define   O_INTERFACE_CONTROL__nocfr                                 9
-#define   O_INTERFACE_CONTROL__dlfct                                 8
-#define   O_INTERFACE_CONTROL__enjab                                 0
-#define R_INTERFACE_STATUS                                         0x0F
-#define   O_INTERFACE_STATUS__xsdfr                                  9
-#define   O_INTERFACE_STATUS__ssrr                                   8
-#define   W_INTERFACE_STATUS__ssrr                                   5
-#define   O_INTERFACE_STATUS__miilf                                  3
-#define   O_INTERFACE_STATUS__locar                                  2
-#define   O_INTERFACE_STATUS__sqerr                                  1
-#define   O_INTERFACE_STATUS__jabber                                 0
-#define R_STATION_ADDRESS_LS                                       0x10
-#define R_STATION_ADDRESS_MS                                       0x11
-
-/* A-XGMAC register and bit field definitions */
-#define R_XGMAC_CONFIG_0    0x00
-#define   O_XGMAC_CONFIG_0__hstmacrst               31
-#define   O_XGMAC_CONFIG_0__hstrstrctl              23
-#define   O_XGMAC_CONFIG_0__hstrstrfn               22
-#define   O_XGMAC_CONFIG_0__hstrsttctl              18
-#define   O_XGMAC_CONFIG_0__hstrsttfn               17
-#define   O_XGMAC_CONFIG_0__hstrstmiim              16
-#define   O_XGMAC_CONFIG_0__hstloopback             8
-#define R_XGMAC_CONFIG_1    0x01
-#define   O_XGMAC_CONFIG_1__hsttctlen               31
-#define   O_XGMAC_CONFIG_1__hsttfen                 30
-#define   O_XGMAC_CONFIG_1__hstrctlen               29
-#define   O_XGMAC_CONFIG_1__hstrfen                 28
-#define   O_XGMAC_CONFIG_1__tfen                    26
-#define   O_XGMAC_CONFIG_1__rfen                    24
-#define   O_XGMAC_CONFIG_1__hstrctlshrtp            12
-#define   O_XGMAC_CONFIG_1__hstdlyfcstx             10
-#define   W_XGMAC_CONFIG_1__hstdlyfcstx              2
-#define   O_XGMAC_CONFIG_1__hstdlyfcsrx              8
-#define   W_XGMAC_CONFIG_1__hstdlyfcsrx              2
-#define   O_XGMAC_CONFIG_1__hstppen                  7
-#define   O_XGMAC_CONFIG_1__hstbytswp                6
-#define   O_XGMAC_CONFIG_1__hstdrplt64               5
-#define   O_XGMAC_CONFIG_1__hstprmscrx               4
-#define   O_XGMAC_CONFIG_1__hstlenchk                3
-#define   O_XGMAC_CONFIG_1__hstgenfcs                2
-#define   O_XGMAC_CONFIG_1__hstpadmode               0
-#define   W_XGMAC_CONFIG_1__hstpadmode               2
-#define R_XGMAC_CONFIG_2    0x02
-#define   O_XGMAC_CONFIG_2__hsttctlfrcp             31
-#define   O_XGMAC_CONFIG_2__hstmlnkflth             27
-#define   O_XGMAC_CONFIG_2__hstalnkflth             26
-#define   O_XGMAC_CONFIG_2__rflnkflt                24
-#define   W_XGMAC_CONFIG_2__rflnkflt                 2
-#define   O_XGMAC_CONFIG_2__hstipgextmod            16
-#define   W_XGMAC_CONFIG_2__hstipgextmod             5
-#define   O_XGMAC_CONFIG_2__hstrctlfrcp             15
-#define   O_XGMAC_CONFIG_2__hstipgexten              5
-#define   O_XGMAC_CONFIG_2__hstmipgext               0
-#define   W_XGMAC_CONFIG_2__hstmipgext               5
-#define R_XGMAC_CONFIG_3    0x03
-#define   O_XGMAC_CONFIG_3__hstfltrfrm              31
-#define   W_XGMAC_CONFIG_3__hstfltrfrm              16
-#define   O_XGMAC_CONFIG_3__hstfltrfrmdc            15
-#define   W_XGMAC_CONFIG_3__hstfltrfrmdc            16
-#define R_XGMAC_STATION_ADDRESS_LS      0x04
-#define   O_XGMAC_STATION_ADDRESS_LS__hstmacadr0    0
-#define   W_XGMAC_STATION_ADDRESS_LS__hstmacadr0    32
-#define R_XGMAC_STATION_ADDRESS_MS      0x05
-#define R_XGMAC_MAX_FRAME_LEN           0x08
-#define   O_XGMAC_MAX_FRAME_LEN__hstmxfrmwctx       16
-#define   W_XGMAC_MAX_FRAME_LEN__hstmxfrmwctx       14
-#define   O_XGMAC_MAX_FRAME_LEN__hstmxfrmbcrx        0
-#define   W_XGMAC_MAX_FRAME_LEN__hstmxfrmbcrx       16
-#define R_XGMAC_REV_LEVEL               0x0B
-#define   O_XGMAC_REV_LEVEL__revlvl                  0
-#define   W_XGMAC_REV_LEVEL__revlvl                 15
-#define R_XGMAC_MIIM_COMMAND            0x10
-#define   O_XGMAC_MIIM_COMMAND__hstldcmd             3
-#define   O_XGMAC_MIIM_COMMAND__hstmiimcmd           0
-#define   W_XGMAC_MIIM_COMMAND__hstmiimcmd           3
-#define R_XGMAC_MIIM_FILED              0x11
-#define   O_XGMAC_MIIM_FILED__hststfield            30
-#define   W_XGMAC_MIIM_FILED__hststfield             2
-#define   O_XGMAC_MIIM_FILED__hstopfield            28
-#define   W_XGMAC_MIIM_FILED__hstopfield             2
-#define   O_XGMAC_MIIM_FILED__hstphyadx             23
-#define   W_XGMAC_MIIM_FILED__hstphyadx              5
-#define   O_XGMAC_MIIM_FILED__hstregadx             18
-#define   W_XGMAC_MIIM_FILED__hstregadx              5
-#define   O_XGMAC_MIIM_FILED__hsttafield            16
-#define   W_XGMAC_MIIM_FILED__hsttafield             2
-#define   O_XGMAC_MIIM_FILED__miimrddat              0
-#define   W_XGMAC_MIIM_FILED__miimrddat             16
-#define R_XGMAC_MIIM_CONFIG             0x12
-#define   O_XGMAC_MIIM_CONFIG__hstnopram             7
-#define   O_XGMAC_MIIM_CONFIG__hstclkdiv             0
-#define   W_XGMAC_MIIM_CONFIG__hstclkdiv             7
-#define R_XGMAC_MIIM_LINK_FAIL_VECTOR   0x13
-#define   O_XGMAC_MIIM_LINK_FAIL_VECTOR__miimlfvec   0
-#define   W_XGMAC_MIIM_LINK_FAIL_VECTOR__miimlfvec  32
-#define R_XGMAC_MIIM_INDICATOR          0x14
-#define   O_XGMAC_MIIM_INDICATOR__miimphylf          4
-#define   O_XGMAC_MIIM_INDICATOR__miimmoncplt        3
-#define   O_XGMAC_MIIM_INDICATOR__miimmonvld         2
-#define   O_XGMAC_MIIM_INDICATOR__miimmon            1
-#define   O_XGMAC_MIIM_INDICATOR__miimbusy           0
-
-/* Glue logic register and bit field definitions */
-#define R_MAC_ADDR0                                                 0x50
-#define R_MAC_ADDR1                                                 0x52
-#define R_MAC_ADDR2                                                 0x54
-#define R_MAC_ADDR3                                                 0x56
-#define R_MAC_ADDR_MASK2                                            0x58
-#define R_MAC_ADDR_MASK3                                            0x5A
-#define R_MAC_FILTER_CONFIG                                         0x5C
-#define   O_MAC_FILTER_CONFIG__BROADCAST_EN                         10
-#define   O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN                       9
-#define   O_MAC_FILTER_CONFIG__ALL_MCAST_EN                         8
-#define   O_MAC_FILTER_CONFIG__ALL_UCAST_EN                         7
-#define   O_MAC_FILTER_CONFIG__HASH_MCAST_EN                        6
-#define   O_MAC_FILTER_CONFIG__HASH_UCAST_EN                        5
-#define   O_MAC_FILTER_CONFIG__ADDR_MATCH_DISC                      4
-#define   O_MAC_FILTER_CONFIG__MAC_ADDR3_VALID                      3
-#define   O_MAC_FILTER_CONFIG__MAC_ADDR2_VALID                      2
-#define   O_MAC_FILTER_CONFIG__MAC_ADDR1_VALID                      1
-#define   O_MAC_FILTER_CONFIG__MAC_ADDR0_VALID                      0
-#define R_HASH_TABLE_VECTOR                                         0x30
-#define R_TX_CONTROL                                                 0x0A0
-#define   O_TX_CONTROL__Tx15Halt                                     31
-#define   O_TX_CONTROL__Tx14Halt                                     30
-#define   O_TX_CONTROL__Tx13Halt                                     29
-#define   O_TX_CONTROL__Tx12Halt                                     28
-#define   O_TX_CONTROL__Tx11Halt                                     27
-#define   O_TX_CONTROL__Tx10Halt                                     26
-#define   O_TX_CONTROL__Tx9Halt                                      25
-#define   O_TX_CONTROL__Tx8Halt                                      24
-#define   O_TX_CONTROL__Tx7Halt                                      23
-#define   O_TX_CONTROL__Tx6Halt                                      22
-#define   O_TX_CONTROL__Tx5Halt                                      21
-#define   O_TX_CONTROL__Tx4Halt                                      20
-#define   O_TX_CONTROL__Tx3Halt                                      19
-#define   O_TX_CONTROL__Tx2Halt                                      18
-#define   O_TX_CONTROL__Tx1Halt                                      17
-#define   O_TX_CONTROL__Tx0Halt                                      16
-#define   O_TX_CONTROL__TxIdle                                       15
-#define   O_TX_CONTROL__TxEnable                                     14
-#define   O_TX_CONTROL__TxThreshold                                  0
-#define   W_TX_CONTROL__TxThreshold                                  14
-#define R_RX_CONTROL                                                 0x0A1
-#define   O_RX_1588_TS                                               11
-#define   O_RX_CONTROL__RGMII                                        10
-#define   O_RX_CONTROL__RxHalt                                       1
-#define   O_RX_CONTROL__RxEnable                                     0
-#define R_DESC_PACK_CTRL                                            0x0A2
-#define   O_DESC_PACK_CTRL__ByteOffset                              17
-#define   W_DESC_PACK_CTRL__ByteOffset                              3
-#define   O_DESC_PACK_CTRL__PrePadEnable                            16
-#define   O_DESC_PACK_CTRL__MaxEntry                                14
-#define   W_DESC_PACK_CTRL__MaxEntry                                2
-#define   O_DESC_PACK_CTRL__RegularSize                             0
-#define   W_DESC_PACK_CTRL__RegularSize                             14
-#define R_STATCTRL                                                  0x0A3
-#define   O_STATCTRL__OverFlowEn                                    4
-#define   O_STATCTRL__GIG                                           3
-#define   O_STATCTRL__Sten                                          2
-#define   O_STATCTRL__ClrCnt                                        1
-#define   O_STATCTRL__AutoZ                                         0
-#define R_L2ALLOCCTRL                                               0x0A4
-#define   O_L2ALLOCCTRL__TxL2Allocate                               9
-#define   W_L2ALLOCCTRL__TxL2Allocate                               9
-#define   O_L2ALLOCCTRL__RxL2Allocate                               0
-#define   W_L2ALLOCCTRL__RxL2Allocate                               9
-#define R_INTMASK                                                   0x0A5
-#define   O_INTMASK__Spi4TxError                                     28
-#define   O_INTMASK__Spi4RxError                                     27
-#define   O_INTMASK__RGMIIHalfDupCollision                           27
-#define   O_INTMASK__Abort                                           26
-#define   O_INTMASK__Underrun                                        25
-#define   O_INTMASK__DiscardPacket                                   24
-#define   O_INTMASK__AsyncFifoFull                                   23
-#define   O_INTMASK__TagFull                                         22
-#define   O_INTMASK__Class3Full                                      21
-#define   O_INTMASK__C3EarlyFull                                     20
-#define   O_INTMASK__Class2Full                                      19
-#define   O_INTMASK__C2EarlyFull                                     18
-#define   O_INTMASK__Class1Full                                      17
-#define   O_INTMASK__C1EarlyFull                                     16
-#define   O_INTMASK__Class0Full                                      15
-#define   O_INTMASK__C0EarlyFull                                     14
-#define   O_INTMASK__RxDataFull                                      13
-#define   O_INTMASK__RxEarlyFull                                     12
-#define   O_INTMASK__RFreeEmpty                                      9
-#define   O_INTMASK__RFEarlyEmpty                                    8
-#define   O_INTMASK__P2PSpillEcc                                     7
-#define   O_INTMASK__FreeDescFull                                    5
-#define   O_INTMASK__FreeEarlyFull                                   4
-#define   O_INTMASK__TxFetchError                                    3
-#define   O_INTMASK__StatCarry                                       2
-#define   O_INTMASK__MDInt                                           1
-#define   O_INTMASK__TxIllegal                                       0
-#define R_INTREG                                                    0x0A6
-#define   O_INTREG__Spi4TxError                                     28
-#define   O_INTREG__Spi4RxError                                     27
-#define   O_INTREG__RGMIIHalfDupCollision                           27
-#define   O_INTREG__Abort                                           26
-#define   O_INTREG__Underrun                                        25
-#define   O_INTREG__DiscardPacket                                   24
-#define   O_INTREG__AsyncFifoFull                                   23
-#define   O_INTREG__TagFull                                         22
-#define   O_INTREG__Class3Full                                      21
-#define   O_INTREG__C3EarlyFull                                     20
-#define   O_INTREG__Class2Full                                      19
-#define   O_INTREG__C2EarlyFull                                     18
-#define   O_INTREG__Class1Full                                      17
-#define   O_INTREG__C1EarlyFull                                     16
-#define   O_INTREG__Class0Full                                      15
-#define   O_INTREG__C0EarlyFull                                     14
-#define   O_INTREG__RxDataFull                                      13
-#define   O_INTREG__RxEarlyFull                                     12
-#define   O_INTREG__RFreeEmpty                                      9
-#define   O_INTREG__RFEarlyEmpty                                    8
-#define   O_INTREG__P2PSpillEcc                                     7
-#define   O_INTREG__FreeDescFull                                    5
-#define   O_INTREG__FreeEarlyFull                                   4
-#define   O_INTREG__TxFetchError                                    3
-#define   O_INTREG__StatCarry                                       2
-#define   O_INTREG__MDInt                                           1
-#define   O_INTREG__TxIllegal                                       0
-#define R_TXRETRY                                                   0x0A7
-#define   O_TXRETRY__CollisionRetry                                 6
-#define   O_TXRETRY__BusErrorRetry                                  5
-#define   O_TXRETRY__UnderRunRetry                                  4
-#define   O_TXRETRY__Retries                                        0
-#define   W_TXRETRY__Retries                                        4
-#define R_CORECONTROL                                               0x0A8
-#define   O_CORECONTROL__ErrorThread                                4
-#define   W_CORECONTROL__ErrorThread                                7
-#define   O_CORECONTROL__Shutdown                                   2
-#define   O_CORECONTROL__Speed                                      0
-#define   W_CORECONTROL__Speed                                      2
-#define R_BYTEOFFSET0                                               0x0A9
-#define R_BYTEOFFSET1                                               0x0AA
-#define R_L2TYPE_0                                                  0x0F0
-#define   O_L2TYPE__ExtraHdrProtoSize                               26
-#define   W_L2TYPE__ExtraHdrProtoSize                               5
-#define   O_L2TYPE__ExtraHdrProtoOffset                             20
-#define   W_L2TYPE__ExtraHdrProtoOffset                             6
-#define   O_L2TYPE__ExtraHeaderSize                                 14
-#define   W_L2TYPE__ExtraHeaderSize                                 6
-#define   O_L2TYPE__ProtoOffset                                     8
-#define   W_L2TYPE__ProtoOffset                                     6
-#define   O_L2TYPE__L2HdrOffset                                     2
-#define   W_L2TYPE__L2HdrOffset                                     6
-#define   O_L2TYPE__L2Proto                                         0
-#define   W_L2TYPE__L2Proto                                         2
-#define R_L2TYPE_1                                                  0xF0
-#define R_L2TYPE_2                                                  0xF0
-#define R_L2TYPE_3                                                  0xF0
-#define R_PARSERCONFIGREG                                           0x100
-#define   O_PARSERCONFIGREG__CRCHashPoly                            8
-#define   W_PARSERCONFIGREG__CRCHashPoly                            7
-#define   O_PARSERCONFIGREG__PrePadOffset                           4
-#define   W_PARSERCONFIGREG__PrePadOffset                           4
-#define   O_PARSERCONFIGREG__UseCAM                                 2
-#define   O_PARSERCONFIGREG__UseHASH                                1
-#define   O_PARSERCONFIGREG__UseProto                               0
-#define R_L3CTABLE                                                  0x140
-#define   O_L3CTABLE__Offset0                                       25
-#define   W_L3CTABLE__Offset0                                       7
-#define   O_L3CTABLE__Len0                                          21
-#define   W_L3CTABLE__Len0                                          4
-#define   O_L3CTABLE__Offset1                                       14
-#define   W_L3CTABLE__Offset1                                       7
-#define   O_L3CTABLE__Len1                                          10
-#define   W_L3CTABLE__Len1                                          4
-#define   O_L3CTABLE__Offset2                                       4
-#define   W_L3CTABLE__Offset2                                       6
-#define   O_L3CTABLE__Len2                                          0
-#define   W_L3CTABLE__Len2                                          4
-#define   O_L3CTABLE__L3HdrOffset                                   26
-#define   W_L3CTABLE__L3HdrOffset                                   6
-#define   O_L3CTABLE__L4ProtoOffset                                 20
-#define   W_L3CTABLE__L4ProtoOffset                                 6
-#define   O_L3CTABLE__IPChksumCompute                               19
-#define   O_L3CTABLE__L4Classify                                    18
-#define   O_L3CTABLE__L2Proto                                       16
-#define   W_L3CTABLE__L2Proto                                       2
-#define   O_L3CTABLE__L3ProtoKey                                    0
-#define   W_L3CTABLE__L3ProtoKey                                    16
-#define R_L4CTABLE                                                  0x160
-#define   O_L4CTABLE__Offset0                                       21
-#define   W_L4CTABLE__Offset0                                       6
-#define   O_L4CTABLE__Len0                                          17
-#define   W_L4CTABLE__Len0                                          4
-#define   O_L4CTABLE__Offset1                                       11
-#define   W_L4CTABLE__Offset1                                       6
-#define   O_L4CTABLE__Len1                                          7
-#define   W_L4CTABLE__Len1                                          4
-#define   O_L4CTABLE__TCPChksumEnable                               0
-#define R_CAM4X128TABLE                                             0x172
-#define   O_CAM4X128TABLE__ClassId                                  7
-#define   W_CAM4X128TABLE__ClassId                                  2
-#define   O_CAM4X128TABLE__BucketId                                 1
-#define   W_CAM4X128TABLE__BucketId                                 6
-#define   O_CAM4X128TABLE__UseBucket                                0
-#define R_CAM4X128KEY                                               0x180
-#define R_TRANSLATETABLE                                            0x1A0
-#define R_DMACR0                                                    0x200
-#define   O_DMACR0__Data0WrMaxCr                                    27
-#define   W_DMACR0__Data0WrMaxCr                                    3
-#define   O_DMACR0__Data0RdMaxCr                                    24
-#define   W_DMACR0__Data0RdMaxCr                                    3
-#define   O_DMACR0__Data1WrMaxCr                                    21
-#define   W_DMACR0__Data1WrMaxCr                                    3
-#define   O_DMACR0__Data1RdMaxCr                                    18
-#define   W_DMACR0__Data1RdMaxCr                                    3
-#define   O_DMACR0__Data2WrMaxCr                                    15
-#define   W_DMACR0__Data2WrMaxCr                                    3
-#define   O_DMACR0__Data2RdMaxCr                                    12
-#define   W_DMACR0__Data2RdMaxCr                                    3
-#define   O_DMACR0__Data3WrMaxCr                                    9
-#define   W_DMACR0__Data3WrMaxCr                                    3
-#define   O_DMACR0__Data3RdMaxCr                                    6
-#define   W_DMACR0__Data3RdMaxCr                                    3
-#define   O_DMACR0__Data4WrMaxCr                                    3
-#define   W_DMACR0__Data4WrMaxCr                                    3
-#define   O_DMACR0__Data4RdMaxCr                                    0
-#define   W_DMACR0__Data4RdMaxCr                                    3
-#define R_DMACR1                                                    0x201
-#define   O_DMACR1__Data5WrMaxCr                                    27
-#define   W_DMACR1__Data5WrMaxCr                                    3
-#define   O_DMACR1__Data5RdMaxCr                                    24
-#define   W_DMACR1__Data5RdMaxCr                                    3
-#define   O_DMACR1__Data6WrMaxCr                                    21
-#define   W_DMACR1__Data6WrMaxCr                                    3
-#define   O_DMACR1__Data6RdMaxCr                                    18
-#define   W_DMACR1__Data6RdMaxCr                                    3
-#define   O_DMACR1__Data7WrMaxCr                                    15
-#define   W_DMACR1__Data7WrMaxCr                                    3
-#define   O_DMACR1__Data7RdMaxCr                                    12
-#define   W_DMACR1__Data7RdMaxCr                                    3
-#define   O_DMACR1__Data8WrMaxCr                                    9
-#define   W_DMACR1__Data8WrMaxCr                                    3
-#define   O_DMACR1__Data8RdMaxCr                                    6
-#define   W_DMACR1__Data8RdMaxCr                                    3
-#define   O_DMACR1__Data9WrMaxCr                                    3
-#define   W_DMACR1__Data9WrMaxCr                                    3
-#define   O_DMACR1__Data9RdMaxCr                                    0
-#define   W_DMACR1__Data9RdMaxCr                                    3
-#define R_DMACR2                                                    0x202
-#define   O_DMACR2__Data10WrMaxCr                                   27
-#define   W_DMACR2__Data10WrMaxCr                                   3
-#define   O_DMACR2__Data10RdMaxCr                                   24
-#define   W_DMACR2__Data10RdMaxCr                                   3
-#define   O_DMACR2__Data11WrMaxCr                                   21
-#define   W_DMACR2__Data11WrMaxCr                                   3
-#define   O_DMACR2__Data11RdMaxCr                                   18
-#define   W_DMACR2__Data11RdMaxCr                                   3
-#define   O_DMACR2__Data12WrMaxCr                                   15
-#define   W_DMACR2__Data12WrMaxCr                                   3
-#define   O_DMACR2__Data12RdMaxCr                                   12
-#define   W_DMACR2__Data12RdMaxCr                                   3
-#define   O_DMACR2__Data13WrMaxCr                                   9
-#define   W_DMACR2__Data13WrMaxCr                                   3
-#define   O_DMACR2__Data13RdMaxCr                                   6
-#define   W_DMACR2__Data13RdMaxCr                                   3
-#define   O_DMACR2__Data14WrMaxCr                                   3
-#define   W_DMACR2__Data14WrMaxCr                                   3
-#define   O_DMACR2__Data14RdMaxCr                                   0
-#define   W_DMACR2__Data14RdMaxCr                                   3
-#define R_DMACR3                                                    0x203
-#define   O_DMACR3__Data15WrMaxCr                                   27
-#define   W_DMACR3__Data15WrMaxCr                                   3
-#define   O_DMACR3__Data15RdMaxCr                                   24
-#define   W_DMACR3__Data15RdMaxCr                                   3
-#define   O_DMACR3__SpClassWrMaxCr                                  21
-#define   W_DMACR3__SpClassWrMaxCr                                  3
-#define   O_DMACR3__SpClassRdMaxCr                                  18
-#define   W_DMACR3__SpClassRdMaxCr                                  3
-#define   O_DMACR3__JumFrInWrMaxCr                                  15
-#define   W_DMACR3__JumFrInWrMaxCr                                  3
-#define   O_DMACR3__JumFrInRdMaxCr                                  12
-#define   W_DMACR3__JumFrInRdMaxCr                                  3
-#define   O_DMACR3__RegFrInWrMaxCr                                  9
-#define   W_DMACR3__RegFrInWrMaxCr                                  3
-#define   O_DMACR3__RegFrInRdMaxCr                                  6
-#define   W_DMACR3__RegFrInRdMaxCr                                  3
-#define   O_DMACR3__FrOutWrMaxCr                                    3
-#define   W_DMACR3__FrOutWrMaxCr                                    3
-#define   O_DMACR3__FrOutRdMaxCr                                    0
-#define   W_DMACR3__FrOutRdMaxCr                                    3
-#define R_REG_FRIN_SPILL_MEM_START_0                                0x204
-#define   O_REG_FRIN_SPILL_MEM_START_0__RegFrInSpillMemStart0        0
-#define   W_REG_FRIN_SPILL_MEM_START_0__RegFrInSpillMemStart0       32
-#define R_REG_FRIN_SPILL_MEM_START_1                                0x205
-#define   O_REG_FRIN_SPILL_MEM_START_1__RegFrInSpillMemStart1        0
-#define   W_REG_FRIN_SPILL_MEM_START_1__RegFrInSpillMemStart1        3
-#define R_REG_FRIN_SPILL_MEM_SIZE                                   0x206
-#define   O_REG_FRIN_SPILL_MEM_SIZE__RegFrInSpillMemSize             0
-#define   W_REG_FRIN_SPILL_MEM_SIZE__RegFrInSpillMemSize            32
-#define R_FROUT_SPILL_MEM_START_0                                   0x207
-#define   O_FROUT_SPILL_MEM_START_0__FrOutSpillMemStart0             0
-#define   W_FROUT_SPILL_MEM_START_0__FrOutSpillMemStart0            32
-#define R_FROUT_SPILL_MEM_START_1                                   0x208
-#define   O_FROUT_SPILL_MEM_START_1__FrOutSpillMemStart1             0
-#define   W_FROUT_SPILL_MEM_START_1__FrOutSpillMemStart1             3
-#define R_FROUT_SPILL_MEM_SIZE                                      0x209
-#define   O_FROUT_SPILL_MEM_SIZE__FrOutSpillMemSize                  0
-#define   W_FROUT_SPILL_MEM_SIZE__FrOutSpillMemSize                 32
-#define R_CLASS0_SPILL_MEM_START_0                                  0x20A
-#define   O_CLASS0_SPILL_MEM_START_0__Class0SpillMemStart0           0
-#define   W_CLASS0_SPILL_MEM_START_0__Class0SpillMemStart0          32
-#define R_CLASS0_SPILL_MEM_START_1                                  0x20B
-#define   O_CLASS0_SPILL_MEM_START_1__Class0SpillMemStart1           0
-#define   W_CLASS0_SPILL_MEM_START_1__Class0SpillMemStart1           3
-#define R_CLASS0_SPILL_MEM_SIZE                                     0x20C
-#define   O_CLASS0_SPILL_MEM_SIZE__Class0SpillMemSize                0
-#define   W_CLASS0_SPILL_MEM_SIZE__Class0SpillMemSize               32
-#define R_JUMFRIN_SPILL_MEM_START_0                                 0x20D
-#define   O_JUMFRIN_SPILL_MEM_START_0__JumFrInSpillMemStar0          0
-#define   W_JUMFRIN_SPILL_MEM_START_0__JumFrInSpillMemStar0         32
-#define R_JUMFRIN_SPILL_MEM_START_1                                 0x20E
-#define   O_JUMFRIN_SPILL_MEM_START_1__JumFrInSpillMemStart1         0
-#define   W_JUMFRIN_SPILL_MEM_START_1__JumFrInSpillMemStart1         3
-#define R_JUMFRIN_SPILL_MEM_SIZE                                    0x20F
-#define   O_JUMFRIN_SPILL_MEM_SIZE__JumFrInSpillMemSize              0
-#define   W_JUMFRIN_SPILL_MEM_SIZE__JumFrInSpillMemSize             32
-#define R_CLASS1_SPILL_MEM_START_0                                  0x210
-#define   O_CLASS1_SPILL_MEM_START_0__Class1SpillMemStart0           0
-#define   W_CLASS1_SPILL_MEM_START_0__Class1SpillMemStart0          32
-#define R_CLASS1_SPILL_MEM_START_1                                  0x211
-#define   O_CLASS1_SPILL_MEM_START_1__Class1SpillMemStart1           0
-#define   W_CLASS1_SPILL_MEM_START_1__Class1SpillMemStart1           3
-#define R_CLASS1_SPILL_MEM_SIZE                                     0x212
-#define   O_CLASS1_SPILL_MEM_SIZE__Class1SpillMemSize                0
-#define   W_CLASS1_SPILL_MEM_SIZE__Class1SpillMemSize               32
-#define R_CLASS2_SPILL_MEM_START_0                                  0x213
-#define   O_CLASS2_SPILL_MEM_START_0__Class2SpillMemStart0           0
-#define   W_CLASS2_SPILL_MEM_START_0__Class2SpillMemStart0          32
-#define R_CLASS2_SPILL_MEM_START_1                                  0x214
-#define   O_CLASS2_SPILL_MEM_START_1__Class2SpillMemStart1           0
-#define   W_CLASS2_SPILL_MEM_START_1__Class2SpillMemStart1           3
-#define R_CLASS2_SPILL_MEM_SIZE                                     0x215
-#define   O_CLASS2_SPILL_MEM_SIZE__Class2SpillMemSize                0
-#define   W_CLASS2_SPILL_MEM_SIZE__Class2SpillMemSize               32
-#define R_CLASS3_SPILL_MEM_START_0                                  0x216
-#define   O_CLASS3_SPILL_MEM_START_0__Class3SpillMemStart0           0
-#define   W_CLASS3_SPILL_MEM_START_0__Class3SpillMemStart0          32
-#define R_CLASS3_SPILL_MEM_START_1                                  0x217
-#define   O_CLASS3_SPILL_MEM_START_1__Class3SpillMemStart1           0
-#define   W_CLASS3_SPILL_MEM_START_1__Class3SpillMemStart1           3
-#define R_CLASS3_SPILL_MEM_SIZE                                     0x218
-#define   O_CLASS3_SPILL_MEM_SIZE__Class3SpillMemSize                0
-#define   W_CLASS3_SPILL_MEM_SIZE__Class3SpillMemSize               32
-#define R_REG_FRIN1_SPILL_MEM_START_0                               0x219
-#define R_REG_FRIN1_SPILL_MEM_START_1                               0x21a
-#define R_REG_FRIN1_SPILL_MEM_SIZE                                  0x21b
-#define R_SPIHNGY0                                                  0x219
-#define   O_SPIHNGY0__EG_HNGY_THRESH_0                              24
-#define   W_SPIHNGY0__EG_HNGY_THRESH_0                              7
-#define   O_SPIHNGY0__EG_HNGY_THRESH_1                              16
-#define   W_SPIHNGY0__EG_HNGY_THRESH_1                              7
-#define   O_SPIHNGY0__EG_HNGY_THRESH_2                              8
-#define   W_SPIHNGY0__EG_HNGY_THRESH_2                              7
-#define   O_SPIHNGY0__EG_HNGY_THRESH_3                              0
-#define   W_SPIHNGY0__EG_HNGY_THRESH_3                              7
-#define R_SPIHNGY1                                                  0x21A
-#define   O_SPIHNGY1__EG_HNGY_THRESH_4                              24
-#define   W_SPIHNGY1__EG_HNGY_THRESH_4                              7
-#define   O_SPIHNGY1__EG_HNGY_THRESH_5                              16
-#define   W_SPIHNGY1__EG_HNGY_THRESH_5                              7
-#define   O_SPIHNGY1__EG_HNGY_THRESH_6                              8
-#define   W_SPIHNGY1__EG_HNGY_THRESH_6                              7
-#define   O_SPIHNGY1__EG_HNGY_THRESH_7                              0
-#define   W_SPIHNGY1__EG_HNGY_THRESH_7                              7
-#define R_SPIHNGY2                                                  0x21B
-#define   O_SPIHNGY2__EG_HNGY_THRESH_8                              24
-#define   W_SPIHNGY2__EG_HNGY_THRESH_8                              7
-#define   O_SPIHNGY2__EG_HNGY_THRESH_9                              16
-#define   W_SPIHNGY2__EG_HNGY_THRESH_9                              7
-#define   O_SPIHNGY2__EG_HNGY_THRESH_10                             8
-#define   W_SPIHNGY2__EG_HNGY_THRESH_10                             7
-#define   O_SPIHNGY2__EG_HNGY_THRESH_11                             0
-#define   W_SPIHNGY2__EG_HNGY_THRESH_11                             7
-#define R_SPIHNGY3                                                  0x21C
-#define   O_SPIHNGY3__EG_HNGY_THRESH_12                             24
-#define   W_SPIHNGY3__EG_HNGY_THRESH_12                             7
-#define   O_SPIHNGY3__EG_HNGY_THRESH_13                             16
-#define   W_SPIHNGY3__EG_HNGY_THRESH_13                             7
-#define   O_SPIHNGY3__EG_HNGY_THRESH_14                             8
-#define   W_SPIHNGY3__EG_HNGY_THRESH_14                             7
-#define   O_SPIHNGY3__EG_HNGY_THRESH_15                             0
-#define   W_SPIHNGY3__EG_HNGY_THRESH_15                             7
-#define R_SPISTRV0                                                  0x21D
-#define   O_SPISTRV0__EG_STRV_THRESH_0                              24
-#define   W_SPISTRV0__EG_STRV_THRESH_0                              7
-#define   O_SPISTRV0__EG_STRV_THRESH_1                              16
-#define   W_SPISTRV0__EG_STRV_THRESH_1                              7
-#define   O_SPISTRV0__EG_STRV_THRESH_2                              8
-#define   W_SPISTRV0__EG_STRV_THRESH_2                              7
-#define   O_SPISTRV0__EG_STRV_THRESH_3                              0
-#define   W_SPISTRV0__EG_STRV_THRESH_3                              7
-#define R_SPISTRV1                                                  0x21E
-#define   O_SPISTRV1__EG_STRV_THRESH_4                              24
-#define   W_SPISTRV1__EG_STRV_THRESH_4                              7
-#define   O_SPISTRV1__EG_STRV_THRESH_5                              16
-#define   W_SPISTRV1__EG_STRV_THRESH_5                              7
-#define   O_SPISTRV1__EG_STRV_THRESH_6                              8
-#define   W_SPISTRV1__EG_STRV_THRESH_6                              7
-#define   O_SPISTRV1__EG_STRV_THRESH_7                              0
-#define   W_SPISTRV1__EG_STRV_THRESH_7                              7
-#define R_SPISTRV2                                                  0x21F
-#define   O_SPISTRV2__EG_STRV_THRESH_8                              24
-#define   W_SPISTRV2__EG_STRV_THRESH_8                              7
-#define   O_SPISTRV2__EG_STRV_THRESH_9                              16
-#define   W_SPISTRV2__EG_STRV_THRESH_9                              7
-#define   O_SPISTRV2__EG_STRV_THRESH_10                             8
-#define   W_SPISTRV2__EG_STRV_THRESH_10                             7
-#define   O_SPISTRV2__EG_STRV_THRESH_11                             0
-#define   W_SPISTRV2__EG_STRV_THRESH_11                             7
-#define R_SPISTRV3                                                  0x220
-#define   O_SPISTRV3__EG_STRV_THRESH_12                             24
-#define   W_SPISTRV3__EG_STRV_THRESH_12                             7
-#define   O_SPISTRV3__EG_STRV_THRESH_13                             16
-#define   W_SPISTRV3__EG_STRV_THRESH_13                             7
-#define   O_SPISTRV3__EG_STRV_THRESH_14                             8
-#define   W_SPISTRV3__EG_STRV_THRESH_14                             7
-#define   O_SPISTRV3__EG_STRV_THRESH_15                             0
-#define   W_SPISTRV3__EG_STRV_THRESH_15                             7
-#define R_TXDATAFIFO0                                               0x221
-#define   O_TXDATAFIFO0__Tx0DataFifoStart                           24
-#define   W_TXDATAFIFO0__Tx0DataFifoStart                           7
-#define   O_TXDATAFIFO0__Tx0DataFifoSize                            16
-#define   W_TXDATAFIFO0__Tx0DataFifoSize                            7
-#define   O_TXDATAFIFO0__Tx1DataFifoStart                           8
-#define   W_TXDATAFIFO0__Tx1DataFifoStart                           7
-#define   O_TXDATAFIFO0__Tx1DataFifoSize                            0
-#define   W_TXDATAFIFO0__Tx1DataFifoSize                            7
-#define R_TXDATAFIFO1                                               0x222
-#define   O_TXDATAFIFO1__Tx2DataFifoStart                           24
-#define   W_TXDATAFIFO1__Tx2DataFifoStart                           7
-#define   O_TXDATAFIFO1__Tx2DataFifoSize                            16
-#define   W_TXDATAFIFO1__Tx2DataFifoSize                            7
-#define   O_TXDATAFIFO1__Tx3DataFifoStart                           8
-#define   W_TXDATAFIFO1__Tx3DataFifoStart                           7
-#define   O_TXDATAFIFO1__Tx3DataFifoSize                            0
-#define   W_TXDATAFIFO1__Tx3DataFifoSize                            7
-#define R_TXDATAFIFO2                                               0x223
-#define   O_TXDATAFIFO2__Tx4DataFifoStart                           24
-#define   W_TXDATAFIFO2__Tx4DataFifoStart                           7
-#define   O_TXDATAFIFO2__Tx4DataFifoSize                            16
-#define   W_TXDATAFIFO2__Tx4DataFifoSize                            7
-#define   O_TXDATAFIFO2__Tx5DataFifoStart                           8
-#define   W_TXDATAFIFO2__Tx5DataFifoStart                           7
-#define   O_TXDATAFIFO2__Tx5DataFifoSize                            0
-#define   W_TXDATAFIFO2__Tx5DataFifoSize                            7
-#define R_TXDATAFIFO3                                               0x224
-#define   O_TXDATAFIFO3__Tx6DataFifoStart                           24
-#define   W_TXDATAFIFO3__Tx6DataFifoStart                           7
-#define   O_TXDATAFIFO3__Tx6DataFifoSize                            16
-#define   W_TXDATAFIFO3__Tx6DataFifoSize                            7
-#define   O_TXDATAFIFO3__Tx7DataFifoStart                           8
-#define   W_TXDATAFIFO3__Tx7DataFifoStart                           7
-#define   O_TXDATAFIFO3__Tx7DataFifoSize                            0
-#define   W_TXDATAFIFO3__Tx7DataFifoSize                            7
-#define R_TXDATAFIFO4                                               0x225
-#define   O_TXDATAFIFO4__Tx8DataFifoStart                           24
-#define   W_TXDATAFIFO4__Tx8DataFifoStart                           7
-#define   O_TXDATAFIFO4__Tx8DataFifoSize                            16
-#define   W_TXDATAFIFO4__Tx8DataFifoSize                            7
-#define   O_TXDATAFIFO4__Tx9DataFifoStart                           8
-#define   W_TXDATAFIFO4__Tx9DataFifoStart                           7
-#define   O_TXDATAFIFO4__Tx9DataFifoSize                            0
-#define   W_TXDATAFIFO4__Tx9DataFifoSize                            7
-#define R_TXDATAFIFO5                                               0x226
-#define   O_TXDATAFIFO5__Tx10DataFifoStart                          24
-#define   W_TXDATAFIFO5__Tx10DataFifoStart                          7
-#define   O_TXDATAFIFO5__Tx10DataFifoSize                           16
-#define   W_TXDATAFIFO5__Tx10DataFifoSize                           7
-#define   O_TXDATAFIFO5__Tx11DataFifoStart                          8
-#define   W_TXDATAFIFO5__Tx11DataFifoStart                          7
-#define   O_TXDATAFIFO5__Tx11DataFifoSize                           0
-#define   W_TXDATAFIFO5__Tx11DataFifoSize                           7
-#define R_TXDATAFIFO6                                               0x227
-#define   O_TXDATAFIFO6__Tx12DataFifoStart                          24
-#define   W_TXDATAFIFO6__Tx12DataFifoStart                          7
-#define   O_TXDATAFIFO6__Tx12DataFifoSize                           16
-#define   W_TXDATAFIFO6__Tx12DataFifoSize                           7
-#define   O_TXDATAFIFO6__Tx13DataFifoStart                          8
-#define   W_TXDATAFIFO6__Tx13DataFifoStart                          7
-#define   O_TXDATAFIFO6__Tx13DataFifoSize                           0
-#define   W_TXDATAFIFO6__Tx13DataFifoSize                           7
-#define R_TXDATAFIFO7                                               0x228
-#define   O_TXDATAFIFO7__Tx14DataFifoStart                          24
-#define   W_TXDATAFIFO7__Tx14DataFifoStart                          7
-#define   O_TXDATAFIFO7__Tx14DataFifoSize                           16
-#define   W_TXDATAFIFO7__Tx14DataFifoSize                           7
-#define   O_TXDATAFIFO7__Tx15DataFifoStart                          8
-#define   W_TXDATAFIFO7__Tx15DataFifoStart                          7
-#define   O_TXDATAFIFO7__Tx15DataFifoSize                           0
-#define   W_TXDATAFIFO7__Tx15DataFifoSize                           7
-#define R_RXDATAFIFO0                                               0x229
-#define   O_RXDATAFIFO0__Rx0DataFifoStart                           24
-#define   W_RXDATAFIFO0__Rx0DataFifoStart                           7
-#define   O_RXDATAFIFO0__Rx0DataFifoSize                            16
-#define   W_RXDATAFIFO0__Rx0DataFifoSize                            7
-#define   O_RXDATAFIFO0__Rx1DataFifoStart                           8
-#define   W_RXDATAFIFO0__Rx1DataFifoStart                           7
-#define   O_RXDATAFIFO0__Rx1DataFifoSize                            0
-#define   W_RXDATAFIFO0__Rx1DataFifoSize                            7
-#define R_RXDATAFIFO1                                               0x22A
-#define   O_RXDATAFIFO1__Rx2DataFifoStart                           24
-#define   W_RXDATAFIFO1__Rx2DataFifoStart                           7
-#define   O_RXDATAFIFO1__Rx2DataFifoSize                            16
-#define   W_RXDATAFIFO1__Rx2DataFifoSize                            7
-#define   O_RXDATAFIFO1__Rx3DataFifoStart                           8
-#define   W_RXDATAFIFO1__Rx3DataFifoStart                           7
-#define   O_RXDATAFIFO1__Rx3DataFifoSize                            0
-#define   W_RXDATAFIFO1__Rx3DataFifoSize                            7
-#define R_RXDATAFIFO2                                               0x22B
-#define   O_RXDATAFIFO2__Rx4DataFifoStart                           24
-#define   W_RXDATAFIFO2__Rx4DataFifoStart                           7
-#define   O_RXDATAFIFO2__Rx4DataFifoSize                            16
-#define   W_RXDATAFIFO2__Rx4DataFifoSize                            7
-#define   O_RXDATAFIFO2__Rx5DataFifoStart                           8
-#define   W_RXDATAFIFO2__Rx5DataFifoStart                           7
-#define   O_RXDATAFIFO2__Rx5DataFifoSize                            0
-#define   W_RXDATAFIFO2__Rx5DataFifoSize                            7
-#define R_RXDATAFIFO3                                               0x22C
-#define   O_RXDATAFIFO3__Rx6DataFifoStart                           24
-#define   W_RXDATAFIFO3__Rx6DataFifoStart                           7
-#define   O_RXDATAFIFO3__Rx6DataFifoSize                            16
-#define   W_RXDATAFIFO3__Rx6DataFifoSize                            7
-#define   O_RXDATAFIFO3__Rx7DataFifoStart                           8
-#define   W_RXDATAFIFO3__Rx7DataFifoStart                           7
-#define   O_RXDATAFIFO3__Rx7DataFifoSize                            0
-#define   W_RXDATAFIFO3__Rx7DataFifoSize                            7
-#define R_RXDATAFIFO4                                               0x22D
-#define   O_RXDATAFIFO4__Rx8DataFifoStart                           24
-#define   W_RXDATAFIFO4__Rx8DataFifoStart                           7
-#define   O_RXDATAFIFO4__Rx8DataFifoSize                            16
-#define   W_RXDATAFIFO4__Rx8DataFifoSize                            7
-#define   O_RXDATAFIFO4__Rx9DataFifoStart                           8
-#define   W_RXDATAFIFO4__Rx9DataFifoStart                           7
-#define   O_RXDATAFIFO4__Rx9DataFifoSize                            0
-#define   W_RXDATAFIFO4__Rx9DataFifoSize                            7
-#define R_RXDATAFIFO5                                               0x22E
-#define   O_RXDATAFIFO5__Rx10DataFifoStart                          24
-#define   W_RXDATAFIFO5__Rx10DataFifoStart                          7
-#define   O_RXDATAFIFO5__Rx10DataFifoSize                           16
-#define   W_RXDATAFIFO5__Rx10DataFifoSize                           7
-#define   O_RXDATAFIFO5__Rx11DataFifoStart                          8
-#define   W_RXDATAFIFO5__Rx11DataFifoStart                          7
-#define   O_RXDATAFIFO5__Rx11DataFifoSize                           0
-#define   W_RXDATAFIFO5__Rx11DataFifoSize                           7
-#define R_RXDATAFIFO6                                               0x22F
-#define   O_RXDATAFIFO6__Rx12DataFifoStart                          24
-#define   W_RXDATAFIFO6__Rx12DataFifoStart                          7
-#define   O_RXDATAFIFO6__Rx12DataFifoSize                           16
-#define   W_RXDATAFIFO6__Rx12DataFifoSize                           7
-#define   O_RXDATAFIFO6__Rx13DataFifoStart                          8
-#define   W_RXDATAFIFO6__Rx13DataFifoStart                          7
-#define   O_RXDATAFIFO6__Rx13DataFifoSize                           0
-#define   W_RXDATAFIFO6__Rx13DataFifoSize                           7
-#define R_RXDATAFIFO7                                               0x230
-#define   O_RXDATAFIFO7__Rx14DataFifoStart                          24
-#define   W_RXDATAFIFO7__Rx14DataFifoStart                          7
-#define   O_RXDATAFIFO7__Rx14DataFifoSize                           16
-#define   W_RXDATAFIFO7__Rx14DataFifoSize                           7
-#define   O_RXDATAFIFO7__Rx15DataFifoStart                          8
-#define   W_RXDATAFIFO7__Rx15DataFifoStart                          7
-#define   O_RXDATAFIFO7__Rx15DataFifoSize                           0
-#define   W_RXDATAFIFO7__Rx15DataFifoSize                           7
-#define R_XGMACPADCALIBRATION                                       0x231
-#define R_FREEQCARVE                                                0x233
-#define R_SPI4STATICDELAY0                                          0x240
-#define   O_SPI4STATICDELAY0__DataLine7                             28
-#define   W_SPI4STATICDELAY0__DataLine7                             4
-#define   O_SPI4STATICDELAY0__DataLine6                             24
-#define   W_SPI4STATICDELAY0__DataLine6                             4
-#define   O_SPI4STATICDELAY0__DataLine5                             20
-#define   W_SPI4STATICDELAY0__DataLine5                             4
-#define   O_SPI4STATICDELAY0__DataLine4                             16
-#define   W_SPI4STATICDELAY0__DataLine4                             4
-#define   O_SPI4STATICDELAY0__DataLine3                             12
-#define   W_SPI4STATICDELAY0__DataLine3                             4
-#define   O_SPI4STATICDELAY0__DataLine2                             8
-#define   W_SPI4STATICDELAY0__DataLine2                             4
-#define   O_SPI4STATICDELAY0__DataLine1                             4
-#define   W_SPI4STATICDELAY0__DataLine1                             4
-#define   O_SPI4STATICDELAY0__DataLine0                             0
-#define   W_SPI4STATICDELAY0__DataLine0                             4
-#define R_SPI4STATICDELAY1                                          0x241
-#define   O_SPI4STATICDELAY1__DataLine15                            28
-#define   W_SPI4STATICDELAY1__DataLine15                            4
-#define   O_SPI4STATICDELAY1__DataLine14                            24
-#define   W_SPI4STATICDELAY1__DataLine14                            4
-#define   O_SPI4STATICDELAY1__DataLine13                            20
-#define   W_SPI4STATICDELAY1__DataLine13                            4
-#define   O_SPI4STATICDELAY1__DataLine12                            16
-#define   W_SPI4STATICDELAY1__DataLine12                            4
-#define   O_SPI4STATICDELAY1__DataLine11                            12
-#define   W_SPI4STATICDELAY1__DataLine11                            4
-#define   O_SPI4STATICDELAY1__DataLine10                            8
-#define   W_SPI4STATICDELAY1__DataLine10                            4
-#define   O_SPI4STATICDELAY1__DataLine9                             4
-#define   W_SPI4STATICDELAY1__DataLine9                             4
-#define   O_SPI4STATICDELAY1__DataLine8                             0
-#define   W_SPI4STATICDELAY1__DataLine8                             4
-#define R_SPI4STATICDELAY2                                          0x242
-#define   O_SPI4STATICDELAY0__TxStat1                               8
-#define   W_SPI4STATICDELAY0__TxStat1                               4
-#define   O_SPI4STATICDELAY0__TxStat0                               4
-#define   W_SPI4STATICDELAY0__TxStat0                               4
-#define   O_SPI4STATICDELAY0__RxControl                             0
-#define   W_SPI4STATICDELAY0__RxControl                             4
-#define R_SPI4CONTROL                                               0x243
-#define   O_SPI4CONTROL__StaticDelay                                2
-#define   O_SPI4CONTROL__LVDS_LVTTL                                 1
-#define   O_SPI4CONTROL__SPI4Enable                                 0
-#define R_CLASSWATERMARKS                                           0x244
-#define   O_CLASSWATERMARKS__Class0Watermark                        24
-#define   W_CLASSWATERMARKS__Class0Watermark                        5
-#define   O_CLASSWATERMARKS__Class1Watermark                        16
-#define   W_CLASSWATERMARKS__Class1Watermark                        5
-#define   O_CLASSWATERMARKS__Class3Watermark                        0
-#define   W_CLASSWATERMARKS__Class3Watermark                        5
-#define R_RXWATERMARKS1                                              0x245
-#define   O_RXWATERMARKS__Rx0DataWatermark                          24
-#define   W_RXWATERMARKS__Rx0DataWatermark                          7
-#define   O_RXWATERMARKS__Rx1DataWatermark                          16
-#define   W_RXWATERMARKS__Rx1DataWatermark                          7
-#define   O_RXWATERMARKS__Rx3DataWatermark                          0
-#define   W_RXWATERMARKS__Rx3DataWatermark                          7
-#define R_RXWATERMARKS2                                              0x246
-#define   O_RXWATERMARKS__Rx4DataWatermark                          24
-#define   W_RXWATERMARKS__Rx4DataWatermark                          7
-#define   O_RXWATERMARKS__Rx5DataWatermark                          16
-#define   W_RXWATERMARKS__Rx5DataWatermark                          7
-#define   O_RXWATERMARKS__Rx6DataWatermark                          8
-#define   W_RXWATERMARKS__Rx6DataWatermark                          7
-#define   O_RXWATERMARKS__Rx7DataWatermark                          0
-#define   W_RXWATERMARKS__Rx7DataWatermark                          7
-#define R_RXWATERMARKS3                                              0x247
-#define   O_RXWATERMARKS__Rx8DataWatermark                          24
-#define   W_RXWATERMARKS__Rx8DataWatermark                          7
-#define   O_RXWATERMARKS__Rx9DataWatermark                          16
-#define   W_RXWATERMARKS__Rx9DataWatermark                          7
-#define   O_RXWATERMARKS__Rx10DataWatermark                         8
-#define   W_RXWATERMARKS__Rx10DataWatermark                         7
-#define   O_RXWATERMARKS__Rx11DataWatermark                         0
-#define   W_RXWATERMARKS__Rx11DataWatermark                         7
-#define R_RXWATERMARKS4                                              0x248
-#define   O_RXWATERMARKS__Rx12DataWatermark                         24
-#define   W_RXWATERMARKS__Rx12DataWatermark                         7
-#define   O_RXWATERMARKS__Rx13DataWatermark                         16
-#define   W_RXWATERMARKS__Rx13DataWatermark                         7
-#define   O_RXWATERMARKS__Rx14DataWatermark                         8
-#define   W_RXWATERMARKS__Rx14DataWatermark                         7
-#define   O_RXWATERMARKS__Rx15DataWatermark                         0
-#define   W_RXWATERMARKS__Rx15DataWatermark                         7
-#define R_FREEWATERMARKS                                            0x249
-#define   O_FREEWATERMARKS__FreeOutWatermark                        16
-#define   W_FREEWATERMARKS__FreeOutWatermark                        16
-#define   O_FREEWATERMARKS__JumFrWatermark                          8
-#define   W_FREEWATERMARKS__JumFrWatermark                          7
-#define   O_FREEWATERMARKS__RegFrWatermark                          0
-#define   W_FREEWATERMARKS__RegFrWatermark                          7
-#define R_EGRESSFIFOCARVINGSLOTS                                    0x24a
-
-
-#define CTRL_RES0           0
-#define CTRL_RES1           1
-#define CTRL_REG_FREE       2
-#define CTRL_CONT           4
-#define CTRL_EOP            5
-#define CTRL_START          6
-#define CTRL_SNGL           7
-
-#define CTRL_B0_NOT_EOP     0
-#define CTRL_B0_EOP         1
-
-#define R_ROUND_ROBIN_TABLE                 0
-#define R_PDE_CLASS_0                       0x300
-#define R_PDE_CLASS_1                       0x302
-#define R_PDE_CLASS_2                       0x304
-#define R_PDE_CLASS_3                       0x306
-
-#define R_MSG_TX_THRESHOLD                  0x308
-
-#define R_GMAC_RFR0_BUCKET_SIZE              0x321
-#define R_GMAC_TX0_BUCKET_SIZE              0x322
-#define R_GMAC_TX1_BUCKET_SIZE              0x323
-#define R_GMAC_TX2_BUCKET_SIZE              0x324
-#define R_GMAC_TX3_BUCKET_SIZE              0x325
-#define R_GMAC_RFR1_BUCKET_SIZE              0x327
-
-#define R_XGS_TX0_BUCKET_SIZE               0x320
-#define R_XGS_TX1_BUCKET_SIZE               0x321
-#define R_XGS_TX2_BUCKET_SIZE               0x322
-#define R_XGS_TX3_BUCKET_SIZE               0x323
-#define R_XGS_TX4_BUCKET_SIZE               0x324
-#define R_XGS_TX5_BUCKET_SIZE               0x325
-#define R_XGS_TX6_BUCKET_SIZE               0x326
-#define R_XGS_TX7_BUCKET_SIZE               0x327
-#define R_XGS_TX8_BUCKET_SIZE               0x328
-#define R_XGS_TX9_BUCKET_SIZE               0x329
-#define R_XGS_TX10_BUCKET_SIZE              0x32A
-#define R_XGS_TX11_BUCKET_SIZE              0x32B
-#define R_XGS_TX12_BUCKET_SIZE              0x32C
-#define R_XGS_TX13_BUCKET_SIZE              0x32D
-#define R_XGS_TX14_BUCKET_SIZE              0x32E
-#define R_XGS_TX15_BUCKET_SIZE              0x32F
-#define R_XGS_RFR_BUCKET_SIZE               0x331
-
-#define R_CC_CPU0_0                         0x380
-#define R_CC_CPU1_0                         0x388
-#define R_CC_CPU2_0                         0x390
-#define R_CC_CPU3_0                         0x398
-#define R_CC_CPU4_0                         0x3a0
-#define R_CC_CPU5_0                         0x3a8
-#define R_CC_CPU6_0                         0x3b0
-#define R_CC_CPU7_0                         0x3b8
-
-/* frame sizes need to be cacheline aligned */
-#define MAC_MAX_FRAME_SIZE          1600
-#define MAC_SKB_BACK_PTR_SIZE   SMP_CACHE_BYTES
-
-
-#ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
-#define MAC_PREPAD             32
-#else
-#define MAC_PREPAD             0
-#endif
-
-#define BYTE_OFFSET             2
-#define NLM_RX_BUF_SIZE (MAC_MAX_FRAME_SIZE+BYTE_OFFSET+MAC_PREPAD+MAC_SKB_BACK_PTR_SIZE+SMP_CACHE_BYTES)
-#define MAC_CRC_LEN             4
-
-
-enum {
-        SGMII_SPEED_10   = 0x00000000,
-        SGMII_SPEED_100  = 0x02000000,
-        SGMII_SPEED_1000 = 0x04000000,
-};
-
-enum tsv_rsv_reg{
-	TX_RX_64_BYTE_FRAME = 0x20,
-	TX_RX_64_127_BYTE_FRAME,
-	TX_RX_128_255_BYTE_FRAME,
-	TX_RX_256_511_BYTE_FRAME,
-	TX_RX_512_1023_BYTE_FRAME,
-	TX_RX_1024_1518_BYTE_FRAME,
-	TX_RX_1519_1522_VLAN_BYTE_FRAME,
-
-	RX_BYTE_COUNTER = 0x27,
-	RX_PACKET_COUNTER,
-	RX_FCS_ERROR_COUNTER,
-	RX_MULTICAST_PACKET_COUNTER,
-	RX_BROADCAST_PACKET_COUNTER,
-	RX_CONTROL_FRAME_PACKET_COUNTER,
-	RX_PAUSE_FRAME_PACKET_COUNTER,
-	RX_UNKNOWN_OP_CODE_COUNTER,
-	RX_ALIGNMENT_ERROR_COUNTER,
-	RX_FRAME_LENGTH_ERROR_COUNTER,
-	RX_CODE_ERROR_COUNTER,
-	RX_CARRIER_SENSE_ERROR_COUNTER,
-	RX_UNDERSIZE_PACKET_COUNTER,
-	RX_OVERSIZE_PACKET_COUNTER,
-	RX_FRAGMENTS_COUNTER,
-	RX_JABBER_COUNTER,
-	RX_DROP_PACKET_COUNTER,
-
-	TX_BYTE_COUNTER   = 0x38,
-	TX_PACKET_COUNTER,
-	TX_MULTICAST_PACKET_COUNTER,
-	TX_BROADCAST_PACKET_COUNTER,
-	TX_PAUSE_CONTROL_FRAME_COUNTER,
-	TX_DEFERRAL_PACKET_COUNTER,
-	TX_EXCESSIVE_DEFERRAL_PACKET_COUNTER,
-	TX_SINGLE_COLLISION_PACKET_COUNTER,
-	TX_MULTI_COLLISION_PACKET_COUNTER,
-	TX_LATE_COLLISION_PACKET_COUNTER,
-	TX_EXCESSIVE_COLLISION_PACKET_COUNTER,
-	TX_TOTAL_COLLISION_COUNTER,
-	TX_PAUSE_FRAME_HONERED_COUNTER,
-	TX_DROP_FRAME_COUNTER,
-	TX_JABBER_FRAME_COUNTER,
-	TX_FCS_ERROR_COUNTER,
-	TX_CONTROL_FRAME_COUNTER,
-	TX_OVERSIZE_FRAME_COUNTER,
-	TX_UNDERSIZE_FRAME_COUNTER,
-	TX_FRAGMENT_FRAME_COUNTER,
-
-	CARRY_REG_1 = 0x4c,
-	CARRY_REG_2 = 0x4d,
-};
-
-struct size_1_desc {
-	uint64_t entry0;
-};
-
-struct size_2_desc {
-	uint64_t entry0;
-	uint64_t entry1;
-};
-
-struct size_3_desc {
-	uint64_t entry0;
-	uint64_t entry1;
-	uint64_t entry2;
-};
-
-struct size_4_desc {
-	uint64_t entry0;
-	uint64_t entry1;
-	uint64_t entry2;
-	uint64_t entry3;
-};
-
-struct fr_desc {
-	struct size_1_desc d1;
-};
-
-union rx_tx_desc {
-	struct size_1_desc d1;
-};
-
-static inline int mac_make_desc_rfr(struct msgrng_msg *msg, int id, int type,
-				    unsigned long addr)
-{
-	int stid = 0;
-
-	if (type == TYPE_XGMAC) stid = msgrng_xgmac_stid_rfr(id);
-	else  {
-#ifdef MAC_SPLIT_MODE
-		stid =  msgrng_gmac_stid_rfr_split_mode(id);
-#else
-		stid = msgrng_gmac_stid_rfr(id);
-#endif
-	}
-	msg->msg0 = (((uint64_t)CTRL_REG_FREE << 61) |
-		     ((uint64_t)stid<<52) |
-		     (uint64_t)addr);
-	msg->msg1 = msg->msg2 = msg->msg3 = 0;
-	return stid;
-}
-
-
-
-static inline int
-msgrng_stid_rfr(int id, int type)
-{
-	int stid = 0;
-
-	if (type == TYPE_XGMAC)
-		stid = msgrng_xgmac_stid_rfr(id);
-	else  {
-		if (id < 4) {
-#ifdef MAC_SPLIT_MODE
-			stid =  msgrng_gmac_stid_rfr_split_mode(id);
-#else
-			stid = msgrng_gmac_stid_rfr(id);
-#endif
-		}
-		else
-			stid = msgrng_gmac1_stid_rfr(id);
-	}
-	return stid;
-}
-
-
-
-static inline int mac_make_desc_b0_rfr(struct msgrng_msg *msg, int id, int type,
-				       unsigned long addr)
-{
-	int stid = msgrng_stid_rfr(id, type);
-
-	msg->msg0 = (uint64_t)addr & 0xffffffffe0ULL;
-	msg->msg1 = msg->msg2 = msg->msg3 = 0;
-
-	return stid;
-}
-
-#define MAC_TX_DESC_ALIGNMENT (SMP_CACHE_BYTES - 1)
-static inline int mac_make_desc_tx(struct msgrng_msg *msg, int id, int type,
-				   unsigned long addr, int len)
-{
-	int tx_stid = 0;
-	int fr_stid = 0;
-	int desc_offset = addr & MAC_TX_DESC_ALIGNMENT;
-
-	if (type == TYPE_XGMAC) {
-		tx_stid = msgrng_xgmac_stid_tx(id);
-		fr_stid = 0;
-	}
-	else {
-		int cpu = hard_smp_processor_id() >> 2;
-		if (id < 4)
-			tx_stid = msgrng_gmac_stid_tx(id);
-		else
-			tx_stid = msgrng_gmac1_stid_tx(id);
-		fr_stid = (cpu << 3) + netlogic_thr_id();
-	}
-
-	msg->msg0 = ( ((uint64_t)CTRL_SNGL << 61) |
-		      ((uint64_t)desc_offset << 40) |
-		      ((uint64_t)tx_stid << 52) |
-		      ((uint64_t)addr & ~MAC_TX_DESC_ALIGNMENT)
-		);
-	msg->msg1 = ( ( (uint64_t)CTRL_EOP << 61) |
-		      ( ((uint64_t)fr_stid) << 54) |
-		      ( (uint64_t)len << 40)
-		);
-
-	msg->msg2 = msg->msg3 = 0;
-
-	return tx_stid;
-}
-
-extern __u8 xlr_base_mac_addr[];
-/*
- * Structure of an rmios ipsec packet
- */
-typedef struct tagIPSEC_PACKET {
-	// cacheline-aligned portion
-	PacketDescriptor_t packet_desc; // multiple of 32 (32)
-	PacketDescriptor_t particle_desc;// second particle (GCM)
-	unsigned char auth_dest[PHXSEC_HMAC_LENGTH];    // multiple of 32 (32)
-	unsigned char packet_data[IPSEC_PACKET_PAYLOAD_SIZE];
-	// end of cacheline-aligned portion
-	int src_id;
-} IPSEC_PACKET ____cacheline_aligned;
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/xlr_pcix_boot.h b/arch/mips/include/asm/netlogic/xlr_pcix_boot.h
deleted file mode 100644
index 0fb6b07..0000000
--- a/arch/mips/include/asm/netlogic/xlr_pcix_boot.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef __PCIX_BOOT_H__
-#define __PCIX_BOOT_H__
-
-#define PCIX_BOOT_FILE_START    (2<<20)
-#define PCIX_BOOT_ARG_CNT_OFF   0x100 /* Number of args */
-#define PCIX_BOOT_ARGS_LEN_OFF  0x104 /* Total length of the args */
-#define PCIX_BOOT_ARGS_OFF      0x108 /*  args string */
-#define PCIX_BOOT_MAGIC         0xa5a5a5a5
-
-
-#endif
-
diff --git a/arch/mips/include/asm/netlogic/xlr_rmik.h b/arch/mips/include/asm/netlogic/xlr_rmik.h
deleted file mode 100644
index 7bbf87c..0000000
--- a/arch/mips/include/asm/netlogic/xlr_rmik.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*********************************************************************
- This product is the confidential property of NetLogic Microsystems Inc.
- (“NetLogic”), is provided under a non-disclosure agreement, and is 
- protected under applicable copyright, patent, and trade secret laws.
- Unauthorized use, reproduction, distribution or other dissemination
- without the prior written authorization from NetLogic is
- strictly prohibited.
-
- NETLOGIC DISCLAIMS ALL WARRANTIES OF ANY NATURE, EXPRESS OR IMPLIED,
- INCLUDING, WITHOUT LIMITATION, THE WARRANTIES OF FITNESS FOR A PARTICULAR
- PURPOSE, MERCHANTABILITY AND/OR NON-INFRINGEMENT OF THIRD PARTY RIGHTS.
- NETLOGIC ASSUMES NO LIABILITY FOR ANY ERROR OR OMISSIONS IN THIS PRODUCT,
- OR FOR THE USE OF THIS PRODUCT. IN NO EVENT SHALL NETLOGIC BE LIABLE TO ANY
- OTHER PARTY FOR ANY SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL
- DAMAGES, WHETHER BASED ON BREACH OF CONTRACT, TORT, PRODUCT LIABILITY,
- INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR OTHERWISE. NETLOGIC
- RESERVES THE RIGHT TO MAKE CHANGES TO, OR DISCONTINUE, ITS PRODUCTS AT ANY
- TIME.
-
- Distribution of the product herein does not convey a license or any other
- right in any patent, trademark, or other intellectual property of NetLogic.
-
-Use of the product shall serve as acceptance of these terms and conditions.
-If you do not accept these terms, you should return or destroy the product
-and any other accompanying information immediately.
-
-Copyright, 2002-2010, NetLogic Microsystems, Inc. All rights reserved.
-
-*******************************NETL_3********************************/
-#ifndef _RMICRF_LINUX_H
-#define _RMICRF_LINUX_H
-#include <asm/netlogic/msgring.h>
-
-#if 0
-extern void fdt_parse_args(void);
-extern int fdt_get_core_tlb_size(int core);
-extern int fdt_add_console_string(char *cmdline);
-extern int fdt_get_pic_timer_map(unsigned int *timer_list, int max);
-extern int fdt_get_gmac_pde_reginfo(int id, uint64_t *);
-extern int fdt_get_xgmac_pde_reginfo(int id, uint64_t *);
-extern int fdt_get_spi4_pde_reginfo(int id, uint64_t *);
-extern uint64_t fdt_get_heap_size(void);
-extern int fdt_get_uart_status(int uartno);
-extern uint64_t fdt_get_vuart_fifo_addr(int tx, int instance);
-extern int fdt_get_msgring_int_status(int core, uint32_t *en);
-extern int fdt_get_core_bucket_conf(int core, char buckets[], int bklen, char credits[][8], int crlen);
-extern int fdt_get_bucketmask(uint64_t *);
-extern int fdt_get_sae_bucket_conf(char buckets[], int bklen, char credits[][8], int crlen);
-extern int fdt_get_cde_bucket_conf(char buckets[], int bklen, char credits[][8], int crlen);
-extern int fdt_get_sae_enabled(void);
-extern int fdt_get_cde_enabled(void);
-
-extern uint32_t dev_tree_en;
-extern uint32_t rmik_en;
-
-extern void rmik_wakeup_cpus(void *fn, void *args, uint32_t cpu_mask);
-extern void rmik_init(char *g_argv[], int *argc, char *g_envp[]);
-#endif
-
-extern uint32_t rmik_cpu_msgring_int_mask[];
-extern void *nlm_get_usermac_addr(int size);
-extern void config_net_init(void);
-extern void rmik_cpu_to_cpu_msgring_handler(int bucket, int size, int code,
-				    int stid, struct msgrng_msg *msg,
-				    void *data /* ignored */ );
-extern void rmik_config_pde(int type, int instance, nlm_reg_t *mmio);
-extern void rmik_eventq_ipi_handler(void);
-extern void rmik_cpu_to_cpu_pkt_msgring_handler(int size, struct msgrng_msg *msg);
-extern void rmik_vmips_init(void);
-extern void rmik_nlm_common_msgring_cpu_init(void);
-extern int rmik_own_bucket_list_get(int *start, int *end, int *mask);
-extern int rmik_derive_msgring_int_mask(void);
-extern void rmik_register_net_events(void);
-extern int rmik_get_free_running_timer(void);
-extern void (*nlm_vnet_pkt_event_handler)(int len, void *msg);
-extern uint64_t rmik_get_pde_bktmap(int type, int instance);
-#endif
diff --git a/arch/mips/include/asm/netlogic/xlr_user_mac.h b/arch/mips/include/asm/netlogic/xlr_user_mac.h
deleted file mode 100644
index 866a64e..0000000
--- a/arch/mips/include/asm/netlogic/xlr_user_mac.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_XLR_USER_MAC_H
-#define _ASM_NLM_XLR_USER_MAC_H
-
-#define NLM_USER_MAC_MMAP_VIRT_START 0x60000000
-#define NLM_USER_MAC_SIZE            0x800000
-
-#ifndef __ASSEMBLY__
-#include <asm/netlogic/sim.h>
-
-extern void nlm_common_user_mac_update_time(void);
-
-struct xlr_user_mac_config {
-	int l4_extract;
-	int fast_syscall;
-};
-
-extern struct xlr_user_mac_config xlr_user_mac;
-
-static __inline__ int xlr_user_mac_l4_extract(void)
-{
-	return xlr_hybrid_user_mac() ? xlr_user_mac.l4_extract  : 0;
-}
-
-static __inline__ int xlr_user_mac_fast_syscall(void)
-{
-	return xlr_hybrid_user_mac() && (xlr_user_mac.fast_syscall == 1);
-}
-
-#endif
-
-#endif
diff --git a/arch/mips/include/asm/netlogic/xlr_virt_uart.h b/arch/mips/include/asm/netlogic/xlr_virt_uart.h
deleted file mode 100644
index 7184103..0000000
--- a/arch/mips/include/asm/netlogic/xlr_virt_uart.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_XLR_VIRT_UART_H
-#define _ASM_XLR_VIRT_UART_H
-
-typedef struct test{
-        volatile unsigned char *tx_fifo;
-        volatile unsigned int *tx_pro;
-        volatile unsigned int  *tx_con;
-        volatile unsigned char *rx_fifo;
-        volatile unsigned int *rx_pro;
-        volatile unsigned int *rx_con;
-        volatile int *status;
-}virt_uart_struct;
-
-typedef struct outbyte_struct{
-      volatile unsigned char *rx_fifo;
-      volatile unsigned int *rx_pro;
-      volatile unsigned int  *rx_con;
-      volatile unsigned char *tx_fifo;
-      volatile unsigned int *tx_pro;
-      volatile unsigned int *tx_con;
-      volatile int *status;
-}virt_uart;
-
-#define USER_CMD_SIZE 			  (1*1024)
-#define USER_RESULT_SIZE 		  (7*1024)
-#define DELAY_TIME                         2
-#define VIRTUAL_UART_CONSOLE      	  "virt_uart"
-#define VIRTUAL_UART_CONSOLE_MAJOR        XLR_VIRT_UART_MAJOR
-#define VIRTUAL_UART_CONSOLE_MINOR        200
-#define VIRTUAL_UART_NR                   32
-#define VIRT_UART_OPENED 		  0xeadbeef
-#ifdef CONFIG_64BIT
-#define VIRT_UART_BUF_START               ((48<<20) | 0xffffffff80000000ULL)
-#else
-#define VIRT_UART_BUF_START               ((48<<20) | 0x80000000)
-#endif
-#endif
-
diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index de8e4b6..a93b652 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -84,14 +84,14 @@ struct page;
 static inline void clear_user_page(void *addr, unsigned long vaddr,
 	struct page *page)
 {
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	extern void nlm_common_flush_dcache_page(struct page *page);
 #else
 	extern void (*flush_data_cache_page)(unsigned long addr);
 #endif
 
 	clear_page(addr);
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	nlm_common_flush_dcache_page(page);
 #else
 	if (pages_do_alias((unsigned long) addr, vaddr & PAGE_MASK))
@@ -99,7 +99,7 @@ static inline void clear_user_page(void *addr, unsigned long vaddr,
 #endif
 }
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 static inline void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,
 		    struct page *to)
 {
diff --git a/arch/mips/include/asm/pci.h b/arch/mips/include/asm/pci.h
index 9b27624..fcd4060 100644
--- a/arch/mips/include/asm/pci.h
+++ b/arch/mips/include/asm/pci.h
@@ -125,8 +125,6 @@ static inline int pci_proc_domain(struct pci_bus *bus)
 
 /* implement the pci_ DMA API in terms of the generic device dma_ one */
 #include <asm-generic/pci-dma-compat.h>
-/* Give hook for any pci_ DMA API overrides. */
-#include <pci-dma.h>
 
 /* Do platform specific device initialization at pci_enable_device() time */
 extern int pcibios_plat_dev_init(struct pci_dev *dev);
diff --git a/arch/mips/include/asm/perfctr.h b/arch/mips/include/asm/perfctr.h
deleted file mode 100644
index f3cfda2..0000000
--- a/arch/mips/include/asm/perfctr.h
+++ /dev/null
@@ -1,237 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* $Id: perfctr.h,v 1.1.2.5 2006-09-28 01:24:19 nphilips Exp $
- * MIPS_XLR Performance-Monitoring Counters driver
- *
- * Copyright (C) 2005  Prasad Boddupalli
- */
-#ifndef _ASM_MIPS_PERFCTR_H
-#define _ASM_MIPS_PERFCTR_H
-
-#define PERFCTR_PAGE_SIZE 4096
-
-/* perfctr_info.cpu_type values */
-#define MIPS_GENERIC	0
-#define MIPS_XLR        1
-
-// Architecture-specific container for counter values.
-// Used in the kernel/user API, but not by low-level drivers.
-struct perfctr_sum_ctrs {
-	unsigned long long tsc;
-	unsigned long long pmc[2];	// just two perf registers
-};
-
-// architecture-specific container for control data.
-// used in both kernel/user API and by low-level drivers
-struct perfctr_cpu_control {
-	unsigned int tsc_on;		// initialize on perfctr_cpu_init()?
-	unsigned int nractrs;		/* # of a-mode counters (max(0,2)?) */
-	unsigned int nrictrs;		/* # of i-mode counters */
-
-    // We already have the control registers in the eventsel field
-	// of the struct {} pmc[]. We might not need the following
-	// registers 
-
-	/* struct {
-		unsigned int perfctrl0;
-		unsigned int perfctrl1;
-	} mips; */
-
-	unsigned int _reserved1;
-	unsigned int _reserved2;
-	unsigned int _reserved3;
-	unsigned int _reserved4;
-
-	struct {
-		unsigned int map;	/* physical counter to use */
-		unsigned int ctrl_reg;
-		int ireset;		/* [0,0x7fffffff], for i-mode counters */
-	} pmc[2];
-};
-
-struct perfctr_cpu_state {
-	unsigned int cstatus;
-
-	// k1 is opaque in the user ABI
-	struct {
-		unsigned int id;
-		int isuspend_cpu;
-	} k1;
-
-	// tsc fields must be inlined. Placing them in a sub-struct might 
-	// cause unwanted internal padding
-	unsigned int tsc_start;
-	unsigned long long tsc_sum;
-
-	struct {
-		unsigned int map;
-		unsigned int start;
-		unsigned long long sum;
-	} pmc[2];
-
-#ifdef __KERNEL__
-	struct perfctr_cpu_control control;
-#endif
-};
-
-/* cstatus is a re-encoding of control.tsc_on/nractrs/nrictrs
-   which should have less overhead in most cases */
-/* XXX: mips driver internally also uses cstatus&(1<<30) */
-
-// construct a cstatus value. 
-static inline
-unsigned int perfctr_mk_cstatus(unsigned int tsc_on, unsigned int nractrs,
-				unsigned int nrictrs)
-{
-	return ((tsc_on<<31) | (nrictrs<<16) | ((nractrs+nrictrs)<<8) | nractrs);
-}
-
-// check if any part (tsc_on, nractrs, nrictrs) of the cstatus is non-zero
-static inline unsigned int perfctr_cstatus_enabled(unsigned int cstatus)
-{
-	return cstatus;
-}
-
-// check if the tsc_on part of the cstatus is non-zero
-static inline int perfctr_cstatus_has_tsc(unsigned int cstatus)
-{
-	return ((int)cstatus < 0);	/* test and jump on sign */
-}
-
-// retrieve nractrs field
-static inline unsigned int perfctr_cstatus_nractrs(unsigned int cstatus)
-{
-	return (cstatus & 0x7F);		/* and with imm8 */
-}
-
-// retrieve nractrs+nrictrs from the cstatus
-static inline unsigned int perfctr_cstatus_nrctrs(unsigned int cstatus)
-{
-	return ((cstatus >> 8) & 0x7F);
-}
-
-// check if the nrictrs part of cstatus is non-zero
-static inline unsigned int perfctr_cstatus_has_ictrs(unsigned int cstatus)
-{
-	return (cstatus & (0x7F << 16));
-}
-
-/*
- * 'struct siginfo' support for perfctr overflow signals.
- * In unbuffered mode, si_code is set to SI_PMC_OVF and a bitmask
- * describing which perfctrs overflowed is put in si_pmc_ovf_mask.
- * A bitmask is used since more than one perfctr can have overflowed
- * by the time the interrupt handler runs.
- *
- * glibc's <signal.h> doesn't seem to define __SI_FAULT or __SI_CODE(),
- * and including <asm/siginfo.h> as well may cause redefinition errors,
- * so the user and kernel values are different #defines here.
- */
-#ifdef __KERNEL__
-#define SI_PMC_OVF	(__SI_FAULT|'P')
-#else
-#define SI_PMC_OVF	('P')
-#endif
-#define si_pmc_ovf_mask	_sifields._pad[0] /* XXX: use an unsigned field later */
-
-/* version number for user-visible CPU-specific data */
-#define PERFCTR_CPU_VERSION	0	/* XXX: not yet cast in stone */
-
-#ifdef __KERNEL__
-
-#ifdef CONFIG_PERFCTR
-
-/* Driver init/exit. */
-extern int perfctr_cpu_init(void);
-extern void perfctr_cpu_exit(void);
-
-/* CPU type name. */
-extern char *perfctr_cpu_name;
-
-/* Hardware reservation. */
-extern const char *perfctr_cpu_reserve(const char *service);
-extern void perfctr_cpu_release(const char *service);
-
-/* PRE: state has no running interrupt-mode counters.
-   Check that the new control data is valid.
-   Update the driver's private control data.
-   Returns a negative error code if the control data is invalid.
-*/
-extern int perfctr_cpu_update_control(struct perfctr_cpu_state *state, int is_global);
-
-
-/* Read a-mode counters. Subtract from start and accumulate into sums.
-   Must be called with preemption disabled. */
-extern void perfctr_cpu_suspend(struct perfctr_cpu_state *state);
-
-/* Write control registers. Read a-mode counters into start.
-   Must be called with preemption disabled. */
-extern void perfctr_cpu_resume(struct perfctr_cpu_state *state);
-
-/* Perform an efficient combined suspend/resume operation.
-   Must be called with preemption disabled. */
-extern void perfctr_cpu_sample(struct perfctr_cpu_state *state);
-
-/* The type of a perfctr overflow interrupt handler.
-   It will be called in IRQ context, with preemption disabled. */
-typedef void (*perfctr_ihandler_t)(unsigned long pc);
-
-unsigned int read_pmc (unsigned int);
-void write_pmc (unsigned int, unsigned int);
-void write_pmctrl (unsigned int, unsigned int);
-
-/* Operations related to overflow interrupt handling. */
-
-#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-extern void perfctr_cpu_set_ihandler(perfctr_ihandler_t);
-extern void perfctr_cpu_ireload(struct perfctr_cpu_state*);
-extern unsigned int perfctr_cpu_identify_overflow(struct perfctr_cpu_state*);
-#else
-static inline void perfctr_cpu_set_ihandler(perfctr_ihandler_t x) { }
-#endif
-
-static inline int perfctr_cpu_has_pending_interrupt(const struct perfctr_cpu_state *state)
-{
-	return 0;
-}
-
-extern perfctr_ihandler_t perfctr_ihandler;
-
-#endif	/* CONFIG_PERFCTR */
-
-#endif	/* __KERNEL__ */
-
-#define MIPS_XLR_DOM_KERNEL		0x2
-#define MIPS_XLR_DOM_SUP		0x4
-#define MIPS_XLR_DOM_USR		0x8
-
-#define MIPS_XLR_SET_EVNTCNT_MODE(x, mode)		x |= mode
-#define MIPS_XLR_UNSET_EVNTCNT_MODE(x, mode)	x &= ~mode
-
-#define MIPS_XLR_OVF_BIT                0x10
-#define MIPS_XLR_OVF_PMI_EABLE(x)		x |= MIPS_XLR_OVF_BIT
-#define MIPS_XLR_OVF_PMI_DABLE(x)		x &= ~MIPS_XLR_OVF_BIT
-#define MIPS_XLR_IS_OVF_PMI(x)			(x & MIPS_XLR_OVF_BIT)
-
-#define MIPS_XLR_EVNTSEL_MASK			0x3f
-#define MIPS_XLR_EVNTSEL_SHIFT			5
-#define MIPS_XLR_SET_EVNT(x, event)		\
-		x |= ((event & MIPS_XLR_EVNTSEL_MASK) << MIPS_XLR_EVNTSEL_SHIFT)
-#define MIPS_XLR_GET_EVNT(x)	\
-		((x >> MIPS_XLR_EVNTSEL_SHIFT) & MIPS_XLR_EVNTSEL_MASK)
-
-#define MIPS_XLR_THREADID_MASK				0x03
-#define MIPS_XLR_THREADID_SHIFT				11
-#define MIPS_XLR_SET_THREADID(x, tid)		\
-		x |= ((tid & MIPS_XLR_THREADID_MASK) << MIPS_XLR_THREADID_SHIFT)
-
-#define MIPS_XLR_SET_CNT_ALL_THREADS(x)		x |= 0x2000
-#define MIPS_XLR_UNSET_CNT_ALL_THREADS(x)	x &= ~0x2000
-
-#endif	/* _ASM_MIPS_PERFCTR_H */
diff --git a/arch/mips/include/asm/pgtable-bits.h b/arch/mips/include/asm/pgtable-bits.h
index 96c134b..7a7bbce 100644
--- a/arch/mips/include/asm/pgtable-bits.h
+++ b/arch/mips/include/asm/pgtable-bits.h
@@ -215,7 +215,7 @@ static inline uint64_t pte_to_entrylo(unsigned long pte_val)
 #define _CACHE_CACHABLE_NONCOHERENT (5<<_CACHE_SHIFT)
 #define _CACHE_UNCACHED_ACCELERATED (7<<_CACHE_SHIFT)
 
-#elif defined(CONFIG_CPU_XLR) || defined(CONFIG_CPU_XLP)
+#elif defined(CONFIG_CPU_XLP)
 
 #define _CACHE_UNCACHED             (2<<9)
 #define _CACHE_CACHABLE_COW         (3<<9)
diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h
index 11baf63..ad88aa5 100644
--- a/arch/mips/include/asm/processor.h
+++ b/arch/mips/include/asm/processor.h
@@ -56,11 +56,15 @@ extern unsigned int vced_count, vcei_count;
  * User space process size: 2GB. This is hardcoded into a few places,
  * so don't change it unless you know what you are doing.
  */
+#ifdef CONFIG_NLM_XLP
 /*
  * XLP_MERGE_TODO: changed TASK_SIZE from 0x7fff8000UL to 0x7fff0000UL
  * to fix page alignment of initial stack (vm_start) for 64KB pages
  * */
 #define TASK_SIZE	0x7fff0000UL
+#else
+#define TASK_SIZE	0x7fff8000UL
+#endif
 
 #ifdef __KERNEL__
 #define STACK_TOP_MAX	TASK_SIZE
diff --git a/arch/mips/include/asm/smp.h b/arch/mips/include/asm/smp.h
index 25eeb28..fa3de45 100644
--- a/arch/mips/include/asm/smp.h
+++ b/arch/mips/include/asm/smp.h
@@ -21,7 +21,7 @@ the header of the original work apply to this derived work.
 
 #include <linux/bitops.h>
 #include <linux/linkage.h>
-#ifndef CONFIG_NLM_COMMON
+#ifndef CONFIG_NLM_XLP
 #include <linux/smp.h>
 #endif
 #include <linux/threads.h>
diff --git a/arch/mips/include/asm/timex.h b/arch/mips/include/asm/timex.h
index f155232..d2cddd9 100644
--- a/arch/mips/include/asm/timex.h
+++ b/arch/mips/include/asm/timex.h
@@ -135,10 +135,10 @@ static inline int unsynchronized_tsc(void)
 	return !tsc_is_sync();
 }
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #define ARCH_HAS_READ_CURRENT_TIMER	1
 extern int read_current_timer(unsigned long *timer_val);
-#endif /* CONFIG_NLM_COMMON */
+#endif /* CONFIG_NLM_XLP */
 
 #endif /* __KERNEL__ */
 
diff --git a/arch/mips/include/asm/xlr_macros.h b/arch/mips/include/asm/xlr_macros.h
deleted file mode 100644
index 9d87855..0000000
--- a/arch/mips/include/asm/xlr_macros.h
+++ /dev/null
@@ -1,117 +0,0 @@
-#ifndef _XLR_MACROS_H
-#define _XLR_MACROS_H
-
-#ifndef __ASSEMBLY__
-
-#ifdef CONFIG_32BIT
-#define XKPHYS        0x8000000000000000ULL
-#endif
-
-#define CCA_UNCACHED  0x1000000000000000ULL
-#define CCA_CACHED    0x1800000000000000ULL
-
-#define enable_KX(flags)   \
-  preempt_disable();       \
- __asm__ __volatile__ (    \
-	".set push\n"          \
-	".set noat\n"          \
-	".set noreorder\n"     \
-	"mfc0 %0, $12\n\t"     \
-	"ori $1, %0, 0x81\n\t" \
-	"xori $1, 1\n\t"       \
-	"mtc0 $1, $12\n"       \
-    ".set pop\n"           \
-    : "=r"(flags) );       \
-  preempt_enable();
-	
-#define disable_KX(flags)  \
- __asm__ __volatile__ (    \
-	".set push\n"          \
-	"mtc0 %0, $12\n"       \
-    ".set pop\n"           \
-    :                      \
-    : "r"(flags))
-
-static __inline__ uint8_t lb_40bit_phys(uint64_t phys, uint64_t cca)
-{
-	uint32_t lsw, msw;
-	uint8_t value;
-	unsigned long flags;
-
-	phys &= 0xffffffffffULL;
-	phys |= (XKPHYS | cca);
-	lsw = (uint32_t) phys & 0xffffffff;
-	msw = (uint32_t) (phys >> 32);
-
-	enable_KX(flags);
-	__asm__ __volatile__(
-		".set push\n"
-        ".set noreorder\n"
-        ".set mips64\n"
-		".set noat\n"
-		"dsll32 $1, %2, 0\n"
-		"dsll32 %1, 0\n"
-		"dsrl32 %1, 0\n"
-        "or $1, $1, %1\n"
-        "lb %0, 0($1) \n"
-		".set at\n"
-        ".set pop\n"
-        : "=r"(value)
-        : "r"(lsw), "r"(msw)
-
-		: "$1"
-		);
-	disable_KX(flags);
-
-	return value;
-}
-static __inline__ uint8_t lb_40bit_phys_uncached(uint64_t phys)
-{
-        return lb_40bit_phys(phys, CCA_UNCACHED);
-}
-static __inline__ uint8_t lb_40bit_phys_cached(uint64_t phys)
-{
-        return lb_40bit_phys(phys, CCA_CACHED);
-}
-
-static __inline__ void sb_40bit_phys(uint64_t phys, uint64_t cca, uint8_t value)
-{
-	uint32_t lsw, msw;
-	unsigned long flags;
-
-	phys &= 0xffffffffffULL;
-	phys |= (XKPHYS | cca);
-	lsw = (uint32_t) phys & 0xffffffff;
-	msw = (uint32_t) (phys >> 32);
-	
-	enable_KX(flags);
-	__asm__ __volatile__(
-		".set push\n"
-        ".set noreorder\n"
-        ".set mips64\n"
-		".set noat\n"
-		"dsll32 $1, %2, 0\n"
-		"dsll32 %1, 0\n"
-		"dsrl32 %1, 0\n"
-        "or $1, $1, %1\n"
-        "sb %0, 0($1) \n"
-		".set at\n"
-        ".set pop\n"
-		:
-        : "r"(value), "r"(lsw), "r"(msw)
-		: "$1"
-		);
-	disable_KX(flags);
-}
-static __inline__ void sb_40bit_phys_uncached(uint64_t phys, uint8_t value)
-{
-      sb_40bit_phys(phys, CCA_UNCACHED, value);
-}
-static __inline__ void sb_40bit_phys_cached(uint64_t phys, uint8_t value)
-{
-      sb_40bit_phys(phys, CCA_CACHED, value);
-}
-
-#endif
-
-#endif
diff --git a/arch/mips/kernel/Makefile b/arch/mips/kernel/Makefile
index 25b51d9..c5246a2 100644
--- a/arch/mips/kernel/Makefile
+++ b/arch/mips/kernel/Makefile
@@ -57,7 +57,6 @@ obj-$(CONFIG_CPU_VR41XX)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= octeon_switch.o
 
 obj-$(CONFIG_CPU_XLR)		+= r4k_fpu.o r4k_switch.o
-obj-$(CONFIG_CPU_XLR)		+= nlm_fs_handler.o nlm_fs.o
 obj-$(CONFIG_CPU_XLP)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_XLP)		+= nlm_fs_handler.o nlm_fs.o
 
@@ -106,8 +105,6 @@ obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_SPINLOCK_TEST)	+= spinlock_test.o
 obj-$(CONFIG_MIPS_MACHINE)	+= mips_machine.o
 
-obj-$(CONFIG_RAPIDIO)		+= rio.o
-
 KBUILD_CFLAGS 			+= -I$(srctree)/arch/mips/mm/
 
 obj-$(CONFIG_OF)		+= prom.o
diff --git a/arch/mips/kernel/asm-offsets.c b/arch/mips/kernel/asm-offsets.c
index 99a8a4b..e18282c 100644
--- a/arch/mips/kernel/asm-offsets.c
+++ b/arch/mips/kernel/asm-offsets.c
@@ -221,6 +221,11 @@ void output_mm_defines(void)
 	DEFINE(_PTRS_PER_PGD, PTRS_PER_PGD);
 	DEFINE(_PTRS_PER_PMD, PTRS_PER_PMD);
 	DEFINE(_PTRS_PER_PTE, PTRS_PER_PTE);
+#ifdef CONFIG_NLM_XLP
+ 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
+ 	DEFINE(PAGE_SHIFT_asm, PAGE_SHIFT);
+ 	BLANK();
+#endif
 	BLANK();
 }
 
@@ -345,16 +350,6 @@ void output_octeon_cop2_state_defines(void)
 }
 #endif
 
-#ifdef CONFIG_NLM_COMMON
-#include <asm/netlogic/sim.h>
-void output_psb_info_defines(void)
-{
-        COMMENT("RMI struct psb_info structure offsets");
-        OFFSET(PSB_CPU_FREQUENCY, psb_info, cpu_frequency);
-	BLANK();
-}
-#endif /* CONFIG_NLM_COMMON */
-
 #ifdef CONFIG_HIBERNATION
 void output_pbe_defines(void)
 {
diff --git a/arch/mips/kernel/binfmt_elfo32.c b/arch/mips/kernel/binfmt_elfo32.c
index a34eaeb..0eb66e7 100644
--- a/arch/mips/kernel/binfmt_elfo32.c
+++ b/arch/mips/kernel/binfmt_elfo32.c
@@ -48,11 +48,15 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
 	__res;								\
 })
 
+#ifdef CONFIG_NLM_XLP
 /*
  * XLP_MERGE_TODO: changed TASK_SIZE from 0x7fff8000UL to 0x7fff0000UL
  * to fix page alignment of initial stack (vm_start) for 64KB pages
  */
 #define TASK32_SIZE		0x7fff0000UL
+#else
+#define TASK32_SIZE		0x7fff8000UL
+#endif
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
@@ -74,11 +78,6 @@ extern void elf32_core_copy_regs(elf_gregset_t grp, struct pt_regs *regs);
 	__res;								\
 })
 
-#include <asm/elf.h>
-#undef ELF_CORE_COPY_REGS
-void elf32_core_copy_regs(elf_gregset_t grp, struct pt_regs *regs);
-#define ELF_CORE_COPY_REGS(_dest,_regs) elf32_core_copy_regs(_dest,_regs);
-
 #include <linux/module.h>
 #include <linux/elfcore.h>
 #include <linux/compat.h>
@@ -158,30 +157,23 @@ static struct compat_timeval ns_to_timeval_compat(const s64 nsec)
 }
 #endif
 
-int elf32_dump_task_regs (struct task_struct *tsk, elf_gregset_t *regs)
-{
-	elf32_core_copy_regs(*regs, task_pt_regs(tsk));
-	return 1;
-}
-
-#define COMPAT_REG_BASE 6
 void elf32_core_copy_regs(elf_gregset_t grp, struct pt_regs *regs)
 {
 	int i;
 
-	for (i = 0; i < COMPAT_REG_BASE; i++)
+	for (i = 0; i < EF_R0; i++)
 		grp[i] = 0;
-	grp[COMPAT_REG_BASE] = 0;
+	grp[EF_R0] = 0;
 	for (i = 1; i <= 31; i++)
-		grp[COMPAT_REG_BASE + i] = (elf_greg_t) regs->regs[i];
-	grp[EF_R26 + COMPAT_REG_BASE] = 0;
-	grp[EF_R27 + COMPAT_REG_BASE] = 0;
-	grp[EF_LO + COMPAT_REG_BASE] = (elf_greg_t) regs->lo;
-	grp[EF_HI + COMPAT_REG_BASE] = (elf_greg_t) regs->hi;
-	grp[EF_CP0_EPC + COMPAT_REG_BASE] = (elf_greg_t) regs->cp0_epc;
-	grp[EF_CP0_BADVADDR + COMPAT_REG_BASE] = (elf_greg_t) regs->cp0_badvaddr;
-	grp[EF_CP0_STATUS + COMPAT_REG_BASE] = (elf_greg_t) regs->cp0_status;
-	grp[EF_CP0_CAUSE + COMPAT_REG_BASE] = (elf_greg_t) regs->cp0_cause;
+		grp[EF_R0 + i] = (elf_greg_t) regs->regs[i];
+	grp[EF_R26] = 0;
+	grp[EF_R27] = 0;
+	grp[EF_LO] = (elf_greg_t) regs->lo;
+	grp[EF_HI] = (elf_greg_t) regs->hi;
+	grp[EF_CP0_EPC] = (elf_greg_t) regs->cp0_epc;
+	grp[EF_CP0_BADVADDR] = (elf_greg_t) regs->cp0_badvaddr;
+	grp[EF_CP0_STATUS] = (elf_greg_t) regs->cp0_status;
+	grp[EF_CP0_CAUSE] = (elf_greg_t) regs->cp0_cause;
 #ifdef EF_UNUSED0
 	grp[EF_UNUSED0] = 0;
 #endif
diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index 030f679..02423ab 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -25,11 +25,12 @@
 #include <asm/watch.h>
 #include <asm/elf.h>
 #include <asm/spram.h>
-#include <asm/uaccess.h>
-#if defined(CONFIG_NLM_COMMON)
-#include <asm/netlogic/sim.h>
+#if defined(CONFIG_NLM_XLP)
+#include <asm/netlogic/xlp.h>
 #endif
 
+#include <asm/uaccess.h>
+
 /*
  * Not all of the MIPS CPUs have the "wait" instruction available. Moreover,
  * the implementation of the "wait" feature differs between CPU families. This
@@ -1018,6 +1019,7 @@ static inline void cpu_probe_ingenic(struct cpuinfo_mips *c, unsigned int cpu)
 	}
 }
 
+#ifndef CONFIG_NLM_XLP
 static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
 {
 	decode_configs(c);
@@ -1091,6 +1093,62 @@ static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
 		c->tlbsize = ((read_c0_config1() >> 25) & 0x3f) + 1;
 	}
 }
+#endif /* CONFIG_NLM_XLP */
+
+#ifdef CONFIG_NLM_XLP
+static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
+{
+	decode_configs(c);
+
+	c->options = (MIPS_CPU_TLB     |
+		      MIPS_CPU_4KEX    |
+		      MIPS_CPU_COUNTER |
+		      MIPS_CPU_DIVEC   |
+		      MIPS_CPU_WATCH   |
+		      MIPS_CPU_EJTAG   |
+		      MIPS_CPU_NLM_CACHE |
+		      MIPS_CPU_LLSC);
+
+	switch ((c->processor_id & 0xff00) >> 8) {
+	case CHIP_PROCESSOR_ID_XLP_8_4_XX:
+	case CHIP_PROCESSOR_ID_XLP_8XX:
+	case CHIP_PROCESSOR_ID_XLP_816:
+	case CHIP_PROCESSOR_ID_XLP_432:
+	case CHIP_PROCESSOR_ID_XLP_416:
+	case CHIP_PROCESSOR_ID_XLP_408:
+	case CHIP_PROCESSOR_ID_XLP_3XX:
+	case CHIP_PROCESSOR_ID_XLP_208:
+	case CHIP_PROCESSOR_ID_XLP_204:
+	case CHIP_PROCESSOR_ID_XLP_104:
+	case CHIP_PROCESSOR_ID_XLP_2XX:
+	{
+		c->cputype = CPU_XLP;
+
+		c->isa_level = MIPS_CPU_ISA_M64R2;
+		c->options |= (MIPS_CPU_FPU | MIPS_CPU_ULRI | MIPS_CPU_MCHECK);
+
+		c->tlbsize = ((read_c0_config6() >> 16 ) & 0xffff) + 1;
+		__cpu_name[cpu] = (const char *)get_cpu_info();
+
+		printk("Enabling XLP CPU (%s): pr id 0x%x  smp id %d\n",
+		       cpu_name_string(), c->processor_id, cpu);
+	}
+	break;
+	default:
+		c->isa_level = MIPS_CPU_ISA_M64R2;
+		c->options |= (MIPS_CPU_FPU | MIPS_CPU_ULRI | MIPS_CPU_MCHECK);
+
+		c->tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
+
+		c->cputype = CPU_XLP;
+		__cpu_name[cpu] = "Netlogic XLP";
+		printk(KERN_INFO "Unknown Netlogic chip id [%02x]!\n",
+		       c->processor_id);
+		break;
+
+	}
+}
+#endif /* CONFIG_NLM_XLP */
 
 #ifdef CONFIG_64BIT
 /* For use by uaccess.h */
diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S
index e18c83f..bf405ee 100644
--- a/arch/mips/kernel/genex.S
+++ b/arch/mips/kernel/genex.S
@@ -403,12 +403,13 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	KMODE
 	.endm
 
+#ifdef CONFIG_NLM_XLP
 	.macro	__build_clear_rixi
 	MFC0	t0, CP0_BADVADDR
 	PTR_S	t0, PT_BVADDR(sp)
 	STI
 	.endm
-
+#endif
 	.macro	__BUILD_silent exception
 	.endm
 
@@ -456,7 +457,7 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	BUILD_HANDLER ades ade ade silent		/* #5  */
 	BUILD_HANDLER ibe be cli silent			/* #6  */
 	BUILD_HANDLER dbe be cli silent			/* #7  */
-#if defined(CONFIG_NLM_COMMON) && defined (CONFIG_KGDB)
+#if defined(CONFIG_NLM_XLP) && defined (CONFIG_KGDB)
 	BUILD_HANDLER bp bp cli silent			/* #9  */
 #else
 	BUILD_HANDLER bp bp sti silent			/* #9  */
@@ -466,7 +467,9 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	BUILD_HANDLER ov ov sti silent			/* #12 */
 	BUILD_HANDLER tr tr sti silent			/* #13 */
 	BUILD_HANDLER fpe fpe fpe silent		/* #15 */
+#ifdef CONFIG_NLM_XLP
 	BUILD_HANDLER rixi rixi rixi silent		/* #16 */
+#endif
 	BUILD_HANDLER mdmx mdmx sti silent		/* #22 */
 #ifdef 	CONFIG_HARDWARE_WATCHPOINTS
 	/*
diff --git a/arch/mips/kernel/head.S b/arch/mips/kernel/head.S
index bdbcfe2..03a514c 100644
--- a/arch/mips/kernel/head.S
+++ b/arch/mips/kernel/head.S
@@ -29,6 +29,47 @@
 #include <asm/mach-netlogic/kernel-entry-init.h>
 #include <asm/mach-generic/kernel-entry-init.h>
 
+#ifndef CONFIG_NLM_XLP
+	/*
+	 * inputs are the text nasid in t1, data nasid in t2.
+	 */
+	.macro MAPPED_KERNEL_SETUP_TLB
+#ifdef CONFIG_MAPPED_KERNEL
+	/*
+	 * This needs to read the nasid - assume 0 for now.
+	 * Drop in 0xffffffffc0000000 in tlbhi, 0+VG in tlblo_0,
+	 * 0+DVG in tlblo_1.
+	 */
+	dli	t0, 0xffffffffc0000000
+	dmtc0	t0, CP0_ENTRYHI
+	li	t0, 0x1c000		# Offset of text into node memory
+	dsll	t1, NASID_SHFT		# Shift text nasid into place
+	dsll	t2, NASID_SHFT		# Same for data nasid
+	or	t1, t1, t0		# Physical load address of kernel text
+	or	t2, t2, t0		# Physical load address of kernel data
+	dsrl	t1, 12			# 4K pfn
+	dsrl	t2, 12			# 4K pfn
+	dsll	t1, 6			# Get pfn into place
+	dsll	t2, 6			# Get pfn into place
+	li	t0, ((_PAGE_GLOBAL|_PAGE_VALID| _CACHE_CACHABLE_COW) >> 6)
+	or	t0, t0, t1
+	mtc0	t0, CP0_ENTRYLO0	# physaddr, VG, cach exlwr
+	li	t0, ((_PAGE_GLOBAL|_PAGE_VALID| _PAGE_DIRTY|_CACHE_CACHABLE_COW) >> 6)
+	or	t0, t0, t2
+	mtc0	t0, CP0_ENTRYLO1	# physaddr, DVG, cach exlwr
+	li	t0, 0x1ffe000		# MAPPED_KERN_TLBMASK, TLBPGMASK_16M
+	mtc0	t0, CP0_PAGEMASK
+	li	t0, 0			# KMAP_INX
+	mtc0	t0, CP0_INDEX
+	li	t0, 1
+	mtc0	t0, CP0_WIRED
+	tlbwi
+#else
+	mtc0	zero, CP0_WIRED
+#endif
+	.endm
+#endif /* CONFIG_NLM_XLP */
+
 	/*
 	 * For the moment disable interrupts, mark the kernel mode and
 	 * set ST0_KX so that the CPU does not spit fire when using
@@ -107,8 +148,9 @@ FEXPORT(__kernel_entry)
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
 
+#ifdef CONFIG_NLM_XLP
 	MAPPED_KERNEL_SETUP_TLB
-
+#endif
 	kernel_entry_setup			# cpu specific setup
 
 	setup_c0_status_pri
diff --git a/arch/mips/kernel/kgdb.c b/arch/mips/kernel/kgdb.c
index d9f7ee1..185a727 100644
--- a/arch/mips/kernel/kgdb.c
+++ b/arch/mips/kernel/kgdb.c
@@ -234,7 +234,7 @@ static void kgdb_call_nmi_hook(void *ignored)
 	kgdb_nmicallback(raw_smp_processor_id(), NULL);
 }
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/interrupt.h>
 DEFINE_SPINLOCK(nlm_kgdb_lock);
 
@@ -266,7 +266,7 @@ void nlm_kgdb_call_nmi_hook(void)
 
 void kgdb_roundup_cpus(unsigned long flags)
 {
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	nlm_kgdb_smp_hook();
 	return;
 #else
@@ -330,12 +330,12 @@ void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)
 	regs->cp0_epc = pc;
 }
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 extern void nlm_common_flush_l1_icache_ipi(void *);
 extern void nlm_common_flush_l1_caches_ipi(void *);
 #endif
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 irqreturn_t xlr_kgdb_ipi_handler(int irq, struct pt_regs *regs)
 {
 	//int cpu = smp_processor_id();
@@ -447,7 +447,7 @@ static int kgdb_mips_notify(struct notifier_block *self, unsigned long cmd,
 			regs->cp0_epc += 4;
 
 	/* In SMP mode, __flush_cache_all does IPI */
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	nlm_common_flush_l1_icache_ipi(NULL);
 #else
 	local_irq_enable();
diff --git a/arch/mips/kernel/nlm_fs_handler.S b/arch/mips/kernel/nlm_fs_handler.S
index 670c032..5c47f08 100644
--- a/arch/mips/kernel/nlm_fs_handler.S
+++ b/arch/mips/kernel/nlm_fs_handler.S
@@ -31,7 +31,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/stackframe.h>
 #include <asm/asm-offsets.h>
 
-#include <asm/netlogic/perf_ctr.h>
 #include <asm/netlogic/interrupt.h>
 #include <asm/netlogic/nlm_fs.h>
 
@@ -385,6 +384,12 @@ NESTED(nlm_fs_msg_read, PT_SIZE, sp)
 	fs_eret
 END(nlm_fs_msg_read)
 
+#define CP0_PERF_CTR            CP0_PERFORMANCE
+#define PERF_CTR_EVENT0         0
+#define PERF_CTR_EVENT0_VALUE   1
+#define PERF_CTR_EVENT1         2
+#define PERF_CTR_EVENT1_VALUE   3
+
 NESTED(nlm_fs_perf_ctr_start, PT_SIZE, sp)
 
 	/* reset value counters */
diff --git a/arch/mips/kernel/proc.c b/arch/mips/kernel/proc.c
index d5b6bfa..e1af073 100644
--- a/arch/mips/kernel/proc.c
+++ b/arch/mips/kernel/proc.c
@@ -49,7 +49,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 #else
 	seq_printf(m, "processor\t\t: %ld\n", n);
 #endif
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	/* workaround for compiler warning */
 	version = fp_vers = 0;
 
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index cc67b1a..a12fdda 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -46,7 +46,9 @@ the header of the original work apply to this derived work.
 #include <asm/uaccess.h>
 #include <asm/bootinfo.h>
 #include <asm/reg.h>
+#ifdef CONFIG_NLM_XLP
 #include <asm/cacheflush.h>
+#endif
 
 DEFINE_TRACE(syscall_entry);
 DEFINE_TRACE(syscall_exit);
@@ -278,7 +280,7 @@ long arch_ptrace(struct task_struct *child, long request,
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 		__flush_cache_all();
 		/* Fall through */
 #endif
@@ -413,7 +415,7 @@ long arch_ptrace(struct task_struct *child, long request,
 
 	/* when I and D space are separate, this will have to be fixed. */
 	case PTRACE_POKETEXT: /* write the word at location addr. */
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 		__flush_cache_all();
 		/* Fall through */
 #endif
diff --git a/arch/mips/kernel/r4k_switch.S b/arch/mips/kernel/r4k_switch.S
index 8bf949d..b5767be 100644
--- a/arch/mips/kernel/r4k_switch.S
+++ b/arch/mips/kernel/r4k_switch.S
@@ -97,7 +97,11 @@
 	move	ra,t1
 #endif /* CONFIG_MIPS_MT_SMTC */
 	mfc0	t1, CP0_STATUS		/* Do we really need this? */
+#ifdef CONFIG_NLM_XLP
 	li	a3, 0x4000ff01
+#else
+	li	a3, 0xff01
+#endif
 	and	t1, a3
 	LONG_L	a2, THREAD_STATUS(a1)
 	nor	a3, $0, a3
diff --git a/arch/mips/kernel/rio.c b/arch/mips/kernel/rio.c
deleted file mode 100644
index 7a0da7b..0000000
--- a/arch/mips/kernel/rio.c
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * RapidIO MIPS support
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- */
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/rio.h>
-
-#include <asm/rio.h>
-
-/**
- * platform_rio_init - Do platform specific RIO init
- *
- * Any platform specific initialization of RapdIO
- * hardware is done here as well as registration
- * of any active master ports in the system.
- */
-void __attribute__ ((weak))
-    platform_rio_init(void)
-{
-	printk(KERN_WARNING "RIO: No platform_rio_init() present\n");
-}
-
-/**
- * mips_rio_init - Do MIPS RIO init
- *
- * Calls platform-specific RIO init code and then calls
- * rio_init_mports() to initialize any master ports that
- * have been registered with the RIO subsystem.
- */
-static int __init mips_rio_init(void)
-{
-	printk(KERN_INFO "RIO: RapidIO init\n");
-
-	/* Platform specific initialization */
-	platform_rio_init();
-
-	/* Enumerate all registered ports */
-	rio_init_mports();
-
-	return 0;
-}
-
-subsys_initcall(mips_rio_init);
diff --git a/arch/mips/kernel/scall32-o32.S b/arch/mips/kernel/scall32-o32.S
index 49c6a38..e2e2a61 100644
--- a/arch/mips/kernel/scall32-o32.S
+++ b/arch/mips/kernel/scall32-o32.S
@@ -36,10 +36,10 @@ the header of the original work apply to this derived work.
 	.align  5
 NESTED(handle_sys, PT_SIZE, sp)
 #ifdef CONFIG_32BIT
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	.set push
 	.set mips64
-    /* XLR Specific fast system calls */
+    /* XLP Specific fast system calls */
 	mfc0	k1, CP0_EPC
 	lw	k0, 0(k1)
 	dsll32	k0, k0, 0
diff --git a/arch/mips/kernel/scall64-n32.S b/arch/mips/kernel/scall64-n32.S
index b5917f5..a732601 100644
--- a/arch/mips/kernel/scall64-n32.S
+++ b/arch/mips/kernel/scall64-n32.S
@@ -340,7 +340,7 @@ EXPORT(sysn32_call_table)
 	PTR	compat_sys_io_submit
 	PTR	sys_io_cancel
 	PTR	sys_exit_group			/* 6205 */
-	PTR	compat_sys_lookup_dcookie
+	PTR	sys_lookup_dcookie
 	PTR	sys_epoll_create
 	PTR	sys_epoll_ctl
 	PTR	sys_epoll_wait
diff --git a/arch/mips/kernel/scall64-o32.S b/arch/mips/kernel/scall64-o32.S
index 908b0af..8cafbfa 100644
--- a/arch/mips/kernel/scall64-o32.S
+++ b/arch/mips/kernel/scall64-o32.S
@@ -28,7 +28,7 @@
 	.align  5
 NESTED(handle_sys, PT_SIZE, sp)
 #ifdef CONFIG_64BIT
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	.set push
 	.set	noat
 	.set mips64
@@ -479,7 +479,7 @@ EXPORT(syso32_call_table)
 	PTR	compat_sys_io_submit
 	PTR	sys_io_cancel			/* 4245 */
 	PTR	sys_exit_group
-	PTR	compat_sys_lookup_dcookie
+	PTR	sys32_lookup_dcookie
 	PTR	sys_epoll_create
 	PTR	sys_epoll_ctl
 	PTR	sys_epoll_wait			/* 4250 */
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 08c2108..fd6a633 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -41,9 +41,11 @@ the header of the original work apply to this derived work.
 #include <asm/smp-ops.h>
 #include <asm/prom.h>
 
+#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/sim.h>
 #include <asm/netlogic/debug.h>
 #include <asm/mach-netlogic/mmu.h>
+#endif /* CONFIG_NLM_XLP */
 
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
@@ -53,13 +55,6 @@ EXPORT_SYMBOL(cpu_data);
 struct screen_info screen_info;
 #endif
 
-#ifdef CONFIG_NLM_VMIPS
-extern unsigned long long nlm_vmips_highmem_start;
-#undef  HIGHMEM_START
-#define        HIGHMEM_START   (nlm_vmips_highmem_start)
-#endif
-
-
 /*
  * Despite it's name this variable is even if we don't have PCI
  */
@@ -98,7 +93,7 @@ static struct resource data_resource = { .name = "Kernel data", };
 void __init add_memory_region(uint64_t start, uint64_t size, long type)
 {
 	int x = boot_mem_map.nr_map;
-#ifndef CONFIG_NUMA
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_NUMA)
 	struct boot_mem_map_entry *prev = boot_mem_map.map + x - 1;
 #endif
 
@@ -108,8 +103,8 @@ void __init add_memory_region(uint64_t start, uint64_t size, long type)
 		return;
 	}
 
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_NUMA)
 	/* For numa, we want to avoid merging memories from different nodes */
-#ifndef CONFIG_NUMA
 	/*
 	 * Try to merge with previous entry if any.  This is far less than
 	 * perfect but is sufficient for most real world cases.
@@ -587,7 +582,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	}
     
 	bootmem_init();
-#ifndef CONFIG_NUMA
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_NUMA)
 	setup_mapped_kernel_tlbs(FALSE, TRUE);
 #endif
 	device_tree_init();
diff --git a/arch/mips/kernel/smp.c b/arch/mips/kernel/smp.c
index e439ace..34b973a 100644
--- a/arch/mips/kernel/smp.c
+++ b/arch/mips/kernel/smp.c
@@ -98,7 +98,7 @@ __cpuinit void register_smp_ops(struct plat_smp_ops *ops)
  */
 asmlinkage __cpuinit void start_secondary(void)
 {
-	unsigned int cpu = smp_processor_id();
+	unsigned int cpu;
 
 #ifdef CONFIG_MIPS_MT_SMTC
 	/* Only do cpu_probe for first TC of CPU */
@@ -107,9 +107,13 @@ asmlinkage __cpuinit void start_secondary(void)
 	cpu_probe();
 	cpu_report();
 	per_cpu_trap_init();
+#ifdef CONFIG_NLM_XLP
 	if (mips_clockevent_init() != 0) {
 		printk("[%s]: unable to setup timer interrupt!!\n", __FUNCTION__);
 	}
+#else
+	mips_clockevent_init();
+#endif
 	mp_ops->init_secondary();
 
 	/*
@@ -135,9 +139,6 @@ asmlinkage __cpuinit void start_secondary(void)
 	cpu_idle();
 }
 
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/mips-exts.h>
-
 /*
  * Call into both interrupt handlers, as we share the IPI for them
  */
@@ -280,11 +281,6 @@ int setup_profiling_timer(unsigned int multiplier)
 
 static void flush_tlb_all_ipi(void *info)
 {
-#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
-#include <asm/netlogic/mips-exts.h>
-	if((nlm_asid_mask == 0x3f) && netlogic_thr_id())
-		return;
-#endif
 	local_flush_tlb_all();
 }
 
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index e239449..2ed605f 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -68,9 +68,7 @@ the header of the original work apply to this derived work.
 DEFINE_TRACE(trap_entry);
 DEFINE_TRACE(trap_exit);
 
-#ifndef CONFIG_NLM_COMMON
-static void mmu_init(void) { }
-#else
+#ifdef CONFIG_NLM_XLP
 #include <asm/mach-netlogic/mmu.h>
 #endif
 
@@ -94,7 +92,9 @@ extern asmlinkage void handle_cpu(void);
 extern asmlinkage void handle_ov(void);
 extern asmlinkage void handle_tr(void);
 extern asmlinkage void handle_fpe(void);
+#ifdef CONFIG_NLM_XLP
 extern asmlinkage void handle_rixi(void);
+#endif
 extern asmlinkage void handle_mdmx(void);
 extern asmlinkage void handle_watch(void);
 extern asmlinkage void handle_mt(void);
@@ -113,7 +113,7 @@ void (*board_ejtag_handler_setup)(void);
 void (*board_bind_eic_interrupt)(int irq, int regset);
 void (*board_ebase_setup)(void);
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 extern unsigned long nlm_common_ebase;
 #endif
 
@@ -621,8 +621,10 @@ static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)
 	return -1;			/* Must be something else ... */
 }
 
+#ifdef CONFIG_NLM_XLP
 extern void nlm_cpu_stat_update_rdhwr(void);
 extern void nlm_cpu_stat_update_fp(void);
+#endif
 
 /*
  * Simulate trapping 'rdhwr' instructions to provide user accessible
@@ -661,7 +663,7 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 			return 0;
 		case 29:
 			regs->regs[rt] = ti->tp_value;
-#if defined(CONFIG_NLM_COMMON)
+#if defined(CONFIG_NLM_XLP)
 			nlm_cpu_stat_update_rdhwr();
 #endif
 			return 0;
@@ -739,7 +741,7 @@ asmlinkage void do_fpe(struct pt_regs *regs, unsigned long fcr31)
 		int sig;
 		void __user *fault_addr = NULL;
 
-#if defined(CONFIG_NLM_COMMON)
+#if defined(CONFIG_NLM_XLP)
 				nlm_cpu_stat_update_fp();
 #endif
 		/*
@@ -791,6 +793,7 @@ asmlinkage void do_fpe(struct pt_regs *regs, unsigned long fcr31)
 	trace_trap_exit();
 }
 
+#ifdef CONFIG_NLM_XLP
 asmlinkage void do_rixi(struct pt_regs *regs)
 {
 	struct task_struct *tsk = current;
@@ -821,6 +824,7 @@ asmlinkage void do_rixi(struct pt_regs *regs)
 	info.si_addr = (void __user *) regs->cp0_epc;
 	force_sig_info(SIGSEGV, &info, tsk);
 }
+#endif
 
 static void do_trap_or_bp(struct pt_regs *regs, unsigned int code,
 	const char *str)
@@ -977,8 +981,10 @@ asmlinkage void do_ri(struct pt_regs *regs)
 
 	if (unlikely(status > 0)) {
 		regs->cp0_epc = old_epc;		/* Undo skip-over.  */
+#ifdef CONFIG_NLM_XLP
 		printk("[%s]: killing with SIGILL\"%s\"\n", __FUNCTION__, current->comm);
 		show_regs(regs);
+#endif
 		force_sig(status, current);
 	}
 }
@@ -1621,12 +1627,14 @@ void __cpuinit per_cpu_trap_init(void)
 		secondaryTC = 1;
 #endif /* CONFIG_MIPS_MT_SMTC */
 
+#ifdef CONFIG_NLM_XLP
 #ifdef CONFIG_32BIT
 	/* Some firmware leaves the BEV flag set, clear it. */
 	clear_c0_status(ST0_CU1|ST0_CU2|ST0_CU3|ST0_BEV|ST0_KX);
 #else
 	clear_c0_status(ST0_CU1|ST0_CU2|ST0_CU3|ST0_BEV);
 #endif
+#endif
 	/*
 	 * Disable coprocessors and select 32-bit or 64-bit addressing
 	 * and the 16/32 or 32/32 FPR register model.  Reset the BEV
@@ -1634,7 +1642,10 @@ void __cpuinit per_cpu_trap_init(void)
 	 * IP27).  Set XX for ISA IV code to work.
 	 */
 #ifdef CONFIG_64BIT
-	status_set |= ST0_CU0|ST0_FR|ST0_KX|ST0_SX|ST0_UX;
+	status_set |= ST0_FR|ST0_KX|ST0_SX|ST0_UX;
+#ifdef CONFIG_NLM_XLP
+	status_set |= ST0_CU0;
+#endif
 #endif
 	if (current_cpu_data.isa_level == MIPS_CPU_ISA_IV)
 		status_set |= ST0_XX;
@@ -1683,9 +1694,11 @@ void __cpuinit per_cpu_trap_init(void)
 		} else
 			set_c0_cause(CAUSEF_IV);
 	}
+#ifdef CONFIG_NLM_XLP
 	else {
 		clear_c0_cause(CAUSEF_IV);
 	}
+#endif
 
 	/*
 	 * Before R2 both interrupt numbers were fixed to 7, so on R2 only:
@@ -1720,9 +1733,10 @@ void __cpuinit per_cpu_trap_init(void)
 #ifdef CONFIG_MIPS_MT_SMTC
 	if (bootTC) {
 #endif /* CONFIG_MIPS_MT_SMTC */
-
 		cpu_cache_init();
+#ifdef CONFIG_NLM_XLP
 		mmu_init();
+#endif
 		tlb_init();
 #ifdef CONFIG_MIPS_MT_SMTC
 	} else if (!secondaryTC) {
@@ -1775,7 +1789,7 @@ __setup("rdhwr_noopt", set_rdhwr_noopt);
 void __init trap_init(void)
 {
 	extern char except_vec3_generic;
-#ifndef CONFIG_NLM_COMMON
+#ifndef CONFIG_NLM_XLP
 	extern char except_vec3_r4000;
 #endif
 	extern char except_vec4;
@@ -1803,7 +1817,7 @@ void __init trap_init(void)
 	if (board_ebase_setup)
 		board_ebase_setup();
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	ebase = nlm_common_ebase;
 #endif
 
@@ -1905,8 +1919,10 @@ void __init trap_init(void)
 	if (cpu_has_fpu && !cpu_has_nofpuex)
 		set_except_vector(15, handle_fpe);
 
+#ifdef CONFIG_NLM_XLP
 	if (kernel_uses_smartmips_rixi)
 		set_except_vector(16, handle_rixi);
+#endif
 
 	set_except_vector(22, handle_mdmx);
 
@@ -1918,7 +1934,7 @@ void __init trap_init(void)
 
 	set_except_vector(26, handle_dsp);
 
-#ifndef CONFIG_NLM_COMMON
+#ifndef CONFIG_NLM_XLP
 	if (cpu_has_vce)
 		/* Special exception: R4[04]00 uses also the divec space. */
 		memcpy((void *)(ebase + 0x180), &except_vec3_r4000, 0x100);
diff --git a/arch/mips/kernel/unaligned.c b/arch/mips/kernel/unaligned.c
index 1fe2a28..6df27d8 100644
--- a/arch/mips/kernel/unaligned.c
+++ b/arch/mips/kernel/unaligned.c
@@ -99,14 +99,13 @@ enum {
 static u32 unaligned_instructions;
 static u32 unaligned_action;
 #else
-
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #define unaligned_action UNALIGNED_ACTION_SHOW
 #else
 #define unaligned_action UNALIGNED_ACTION_QUIET
 #endif
-
 #endif
+
 extern void show_registers(struct pt_regs *regs);
 
 static void emulate_load_store_insn(struct pt_regs *regs,
@@ -535,12 +534,17 @@ asmlinkage void do_ade(struct pt_regs *regs)
 		goto sigbus;
 	if (unaligned_action == UNALIGNED_ACTION_SIGNAL)
 		goto sigbus;
+#ifdef CONFIG_NLM_XLP
 	else if (unaligned_action == UNALIGNED_ACTION_SHOW) {
 		printk("[%s]: Killing process (%s) which is using ualigned accesses!\n",
 		       __FUNCTION__, current->comm);
 		show_registers(regs);
 		goto sigbus;
 	}
+#else
+	else if (unaligned_action == UNALIGNED_ACTION_SHOW)
+		show_registers(regs);
+#endif
 
 	/*
 	 * Do branch emulation only if we didn't forward the exception.
diff --git a/arch/mips/kernel/vmlinux.lds.S b/arch/mips/kernel/vmlinux.lds.S
index 775836f..ea744c6 100644
--- a/arch/mips/kernel/vmlinux.lds.S
+++ b/arch/mips/kernel/vmlinux.lds.S
@@ -6,14 +6,8 @@
 #undef mips
 #define mips mips
 OUTPUT_ARCH(mips)
-
-#ifdef PHYSADDR
-ENTRY(phys_entry)
-#define AT_LOCATION AT(PHYSADDR)
-#else
-ENTRY(kernel_entry)
+#ifdef CONFIG_NLM_XLP
 #define AT_LOCATION
-#endif
 
 PHDRS {
 	text PT_LOAD AT_LOCATION FLAGS(7);	/* RWX */
@@ -23,6 +17,14 @@ PHDRS {
 #ifdef PHYSADDR
 phys_entry = kernel_entry - LOADADDR + PHYSADDR;
 #endif
+ENTRY(phys_entry)
+#else /* CONFIG_NLM_XLP */
+ENTRY(kernel_entry)
+PHDRS {
+	text PT_LOAD FLAGS(7);	/* RWX */
+	note PT_NOTE FLAGS(4);	/* R__ */
+}
+#endif /* CONFIG_NLM_XLP */
 
 #ifdef CONFIG_32BIT
 	#ifdef CONFIG_CPU_LITTLE_ENDIAN
@@ -51,7 +53,6 @@ SECTIONS
 	/* . = 0xa800000000300000; */
 	. = 0xffffffff80300000;
 #endif
-
 	. = VMLINUX_LOAD_ADDRESS;
 	/* read-only */
 	_text = .;	/* Text and read-only data */
diff --git a/arch/mips/lib/delay.c b/arch/mips/lib/delay.c
index d9f25e4..131d720 100644
--- a/arch/mips/lib/delay.c
+++ b/arch/mips/lib/delay.c
@@ -15,9 +15,9 @@
 #include <asm/compiler.h>
 #include <asm/war.h>
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 
-extern u64 xlr_hpt_read(void);
+extern u64 xlp_hpt_read(void);
 inline void __delay(unsigned int loops)
 {
 	uint32_t initial_count,curr_count;
@@ -25,9 +25,9 @@ inline void __delay(unsigned int loops)
 
 	delta = loops; 
 
-	initial_count = xlr_hpt_read();
+	initial_count = xlp_hpt_read();
         while (1) {
-		curr_count = xlr_hpt_read();
+		curr_count = xlp_hpt_read();
 		if ((uint32_t)(curr_count - initial_count) > delta)
 			return;
 	}
@@ -42,9 +42,9 @@ inline void __udelay(unsigned long us)
 	delta = us * 66; /* clock runs at 66.6MHz speed */
 			    /* cant do floating point ops here */
 
-	initial_count = xlr_hpt_read();
+	initial_count = xlp_hpt_read();
         while (1) {
-		curr_count = xlr_hpt_read();
+		curr_count = xlp_hpt_read();
 		if ((uint32_t)(curr_count - initial_count) > delta)
 			return;
 	}
@@ -60,9 +60,9 @@ inline void __ndelay(unsigned long ns)
 	the minimum delay we have have is 1/66.67 = ~15 nsec */
 	delta = (ns >> 4) +1;
 
-	initial_count = xlr_hpt_read();
+	initial_count = xlp_hpt_read();
         while (1) {
-		curr_count = xlr_hpt_read();
+		curr_count = xlp_hpt_read();
 		if ((uint32_t)(curr_count - initial_count) > delta)
 			return;
 	}
diff --git a/arch/mips/mm/c-phoenix.c b/arch/mips/mm/c-phoenix.c
index 6d214e1..6978edf 100644
--- a/arch/mips/mm/c-phoenix.c
+++ b/arch/mips/mm/c-phoenix.c
@@ -43,12 +43,6 @@ the header of the original work apply to this derived work.
 static unsigned int icache_linesz;
 static unsigned int icache_lines;
 
-#ifdef CONFIG_NLM_VMIPS
-extern void nlm_vmips_temp_xkphys_tlb_add(phys_t start, phys_t end, int *tlbs, int *tlbe);
-extern void nlm_vmips_wired_entry_remove(int index);
-#endif
-
-
 #define cacheop(op, base) __asm__ __volatile__ (".set push\n.set mips4\ncache %0, 0(%1)\n.set pop\n" : : "i"(op), "r"(base))
 
 #define cacheop_extable(op, base) do {                    \
@@ -512,11 +506,6 @@ static void nlm_common_local_flush_icache_range_paddr(phys_t start, phys_t end)
 	unsigned long flags;
 	phys_t temp;
 #endif
-#ifdef CONFIG_NLM_VMIPS
-	int tlbs = 0, tlbe = 0;
-	nlm_vmips_temp_xkphys_tlb_add(start, end, &tlbs, &tlbe);
-#endif
-
 #ifdef CONFIG_NLM_XLP
 	int sets_per_way, niter, i;
 	uint64_t mask;
@@ -545,11 +534,6 @@ static void nlm_common_local_flush_icache_range_paddr(phys_t start, phys_t end)
 	disable_KX(flags);
 #endif
 
-#ifdef CONFIG_NLM_VMIPS
-	for(;tlbe >= tlbs; tlbe--)
-        nlm_vmips_wired_entry_remove(tlbe);
-
-#endif
 	cacheop_sync_istream();
 }
 
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index 3e77374..09a1f0a 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -216,12 +216,13 @@ void __cpuinit cpu_cache_init(void)
 
 		tx39_cache_init();
 	}
+#ifdef CONFIG_NLM_XLP
 	if (cpu_has_nlm_cache) {
 		extern void __weak ld_mmu_xlr(void);
 
 		ld_mmu_xlr();
 	}
-
+#endif
 	if (cpu_has_octeon_cache) {
 		extern void __weak octeon_cache_init(void);
 
diff --git a/arch/mips/mm/cex-gen.S b/arch/mips/mm/cex-gen.S
index 2e4274b..1eac431 100644
--- a/arch/mips/mm/cex-gen.S
+++ b/arch/mips/mm/cex-gen.S
@@ -44,7 +44,7 @@ the header of the original work apply to this derived work.
 	nop
 	nop
 	nop
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 
 	/* If some other cpu is already in the handler
 	 * just wait... */
diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c
index 0a3ccff..8b53c73 100644
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -27,7 +27,7 @@ the header of the original work apply to this derived work.
 #include <asm/mmu_context.h>
 #include <asm/pgtable.h>
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/mips-exts.h>
 #include <asm/mach-netlogic/mmu.h>
 #endif
@@ -79,11 +79,6 @@ extern void build_tlb_refill_handler(void);
 
 #endif
 
-#ifdef CONFIG_NLM_VMIPS
-#define UNIQUE_VMIPS_ENTRYHI(idx)  ((1ULL << 63) + (1ULL << 40) + ((idx) << (PAGE_SHIFT + 1)) + ( 1 << 8))
-extern int nlm_vmips_max_wired_entries;
-#endif
-
 void local_flush_tlb_all(void)
 {
 	unsigned long flags, config6_flags __maybe_unused;
@@ -106,11 +101,7 @@ void local_flush_tlb_all(void)
 	/* Blast 'em all away. */
 	while (entry < current_cpu_data.tlbsize) {
 		/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 		write_c0_entryhi(UNIQUE_ENTRYHI(entry));
-#else
-        __write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(entry)));
-#endif
 		write_c0_index(entry);
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
@@ -177,11 +168,7 @@ void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
 				if (idx < 0)
 					continue;
 				/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 				write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-#else
-				__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
-#endif
 				mtc0_tlbw_hazard();
 				tlb_write_indexed();
 			}
@@ -226,11 +213,7 @@ void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
 			if (idx < 0)
 				continue;
 			/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 			write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-#else
-			__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
-#endif
 			mtc0_tlbw_hazard();
 			tlb_write_indexed();
 		}
@@ -267,11 +250,7 @@ void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
 		if (idx < 0)
 			goto finish;
 		/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-#else
-		__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
-#endif
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -306,11 +285,7 @@ void local_flush_tlb_one(unsigned long page)
 	write_c0_entrylo1(0);
 	if (idx >= 0) {
 		/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-#else
-		__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
-#endif
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -487,23 +462,13 @@ static int __init set_ntlb(char *str)
 
 __setup("ntlb=", set_ntlb);
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 extern void nlm_common_tlb_init(void);
 
 void nlm_tlb_stats_init(void)
 {
 	nlm_write_os_scratch_2(0ULL);
 }
-
-#ifdef CONFIG_HUGETLBFS
-void nlm_tlb_entrylo0_mask_init(void);
-void nlm_tlb_entrylo0_mask_init()
-{
-	unsigned long long mask = ~(((1ULL<<HUGETLB_PAGE_ORDER)-1)<<6);
-	nlm_write_os_scratch_3(mask);
-}
-#endif
-
 #endif
 
 void __cpuinit tlb_init(void)
@@ -516,19 +481,17 @@ void __cpuinit tlb_init(void)
 	 *     be set to fixed-size pages.
 	 */
 	write_c0_pagemask(PM_DEFAULT_MASK);
-
-#if defined(CONFIG_NLM_VMIPS)
-	if(ntlb && ((current_cpu_data.tlbsize-ntlb) < nlm_vmips_max_wired_entries))
-		ntlb = current_cpu_data.tlbsize - nlm_vmips_max_wired_entries;
+#if !defined(CONFIG_MAPPED_KERNEL)
+	write_c0_wired(0);
 #endif
 
+
 	if (current_cpu_type() == CPU_R10000 ||
 	    current_cpu_type() == CPU_R12000 ||
 	    current_cpu_type() == CPU_R14000)
 		write_c0_framemask(0);
 
-#if !defined(CONFIG_MAPPED_KERNEL)
-	write_c0_wired(0);
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_MAPPED_KERNEL)
 	write_c0_framemask(0);
 #endif
 
@@ -561,14 +524,8 @@ void __cpuinit tlb_init(void)
 			printk("Ignoring invalid argument ntlb=%d\n", ntlb);
 	}
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	nlm_tlb_stats_init();
-
-#ifdef CONFIG_HUGETLBFS
-	nlm_tlb_entrylo0_mask_init();
 #endif
-
-#endif
-
 	build_tlb_refill_handler();
 }
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index 4171c1b..f84f859 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -32,8 +32,8 @@
 #include <asm/pgtable.h>
 #include <asm/war.h>
 #include <asm/uasm.h>
+#include <asm/setup.h>
 
-extern unsigned long ebase;
 /*
  * TLB load/store/modify handlers.
  *
@@ -56,7 +56,7 @@ struct tlb_reg_save {
 
 static struct tlb_reg_save handler_reg_save[NR_CPUS];
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/mips-exts.h>
 #endif
 
@@ -164,6 +164,7 @@ enum label_id {
 #ifdef CONFIG_HUGETLB_PAGE
 	label_tlb_huge_update,
 #endif
+#ifdef CONFIG_NLM_XLP
 	label_nohpage_tlbs,
 	label_hpage_tlb_leave,
 	label_non_btlb_process,
@@ -171,6 +172,7 @@ enum label_id {
 	label_illegal_access_tlbl,
 	label_exl_refill_exception,
 	label_r4000_write_probe_fail,
+#endif
 };
 
 UASM_L_LA(_second_part)
@@ -190,6 +192,7 @@ UASM_L_LA(_large_segbits_fault)
 #ifdef CONFIG_HUGETLB_PAGE
 UASM_L_LA(_tlb_huge_update)
 #endif
+#ifdef CONFIG_NLM_XLP
 UASM_L_LA(_nohpage_tlbs)
 UASM_L_LA(_hpage_tlb_leave)
 UASM_L_LA(_non_btlb_process)
@@ -197,6 +200,7 @@ UASM_L_LA(_read_entrylo1)
 UASM_L_LA(_illegal_access_tlbl)
 UASM_L_LA(_exl_refill_exception)
 UASM_L_LA(_r4000_write_probe_fail)
+#endif
 
 /*
  * For debug purposes.
@@ -229,8 +233,6 @@ static inline void dump_handler(const u32 *handler, int count)
 #define C0_ENTRYHI	10, 0
 #define C0_EPC		14, 0
 #define C0_XCONTEXT	20, 0
-#define v0    2
-#define C0_SCRATCH_4  22, 4
 
 #ifdef CONFIG_64BIT
 # define GET_CONTEXT(buf, reg) UASM_i_MFC0(buf, reg, C0_XCONTEXT)
@@ -1321,7 +1323,7 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 			/* No need for uasm_i_nop */
 		}
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 		uasm_i_dmfc0(&p, K0, OS_SCRATCH_REG2);
 		uasm_i_daddiu(&p, K0, K0, 1);
 		uasm_i_dmtc0(&p, K0, OS_SCRATCH_REG2);
@@ -1341,7 +1343,7 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 		build_update_entries(&p, K0, K1);
 		build_tlb_write_entry(&p, &l, &r, tlb_random);
 		uasm_l_leave(&l, p);
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 		/* this is to avoid split of the table at eret instruction
 		   The code below does a split at 30th instruction.
 		 */
@@ -1937,30 +1939,20 @@ build_r4000_tlbchange_handler_tail(u32 **p, struct uasm_label **l,
 	uasm_i_ori(p, ptr, ptr, sizeof(pte_t));
 	uasm_i_xori(p, ptr, ptr, sizeof(pte_t));
 	build_update_entries(p, tmp, ptr);
+#ifdef CONFIG_NLM_XLP
 	uasm_i_tlbp(p);
 	uasm_i_ehb(p);
 	uasm_i_mfc0(p, ptr, C0_INDEX);
 	uasm_il_bltz(p, r, ptr, label_r4000_write_probe_fail);
 	uasm_i_nop(p);
-
+#endif
 	build_tlb_write_entry(p, l, r, tlb_indexed);
+#ifdef CONFIG_NLM_XLP
+	uasm_il_b(p, r, label_leave);
+	uasm_i_nop(p);
 
-#ifdef CONFIG_HUGETLBFS
-#ifdef CONFIG_PAGE_SIZE_4KB
-	uasm_i_mtc0(p, ZERO, C0_PAGEMASK);
-#else
-	uasm_i_mtc0(p, K0, C0_PAGEMASK);
-#endif
-#endif
-	uasm_i_eret(p);
 	uasm_l_r4000_write_probe_fail(l, *p);
 	build_tlb_write_entry(p, l, r, tlb_random);
-#ifdef CONFIG_HUGETLBFS
-#ifdef CONFIG_PAGE_SIZE_4KB
-	i_mtc0(p, ZERO, C0_PAGEMASK);
-#else
-	i_mtc0(p, K0, C0_PAGEMASK);
-#endif
 #endif
 	uasm_l_leave(l, *p);
 	build_restore_work_registers(p);
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index db4c5bc..e30155e 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -1,10 +1,10 @@
 config NLM_COMMON
-	bool 
+	bool
 
 config NLM_XLR
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	select FDT
-	select NLM_ATOMICS
+	bool
+
+config NLMCOMMON
 	bool
 
 config NLM_XLP
@@ -21,138 +21,28 @@ config NLM_XLP_A0_WORKAROUNDS
 
 config NLMCOMMON_VM_DEBUG
 	bool "Debug VM System"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 
 config NLMCOMMON_USERSEGV_DEBUG
 	bool "Debug User process SEGV crash"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 
 config NLMCOMMON_SMP_PREFIX
 	bool "Prefix the cpu number for every printk"
-	depends on NLM_COMMON
-	default y
-
-config NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
-        bool "Enable Shared TLB in each CPU core"
-	depends on NLM_XLR
-	default n
-	help
-		This option enables the sharing of TLBs by all the threads in core.
-		
-
-config NLMCOMMON_MAC
-	bool "Enable On-Chip Networking support"
-	depends on NLM_XLR
-	default y
-
-config NLMCOMMON_PCIX_GEN_DRIVER
-	bool
-
-config NLMCOMMON_IP_OVER_PCI
-        bool "Enable IP-Over-Pci Networking Support"
-        depends on NLM_XLR
-	select NLMCOMMON_PCIX_GEN_DRIVER
-        default n
-
-config NLMCOMMON_BOOT_OVER_PCI
-        bool "Enable Boot-Over-Pci Support"
-        depends on NLM_XLR
-	select NLMCOMMON_PCIX_GEN_DRIVER
-        default n
-
-config NLMCOMMON_CONSOLE_OVER_PCI 
-        bool "Enable Console Over PCI Support"
-        depends on NLM_XLR
-	select NLMCOMMON_PCIX_GEN_DRIVER
-        default n
-
-config NLMCOMMON_SPI4
-        bool 'Support for on-chip SPI4 interfaces'
-        depends on NLM_XLR
-        default y
-        help
-          With the Vitesse SPI4 daughter card, this driver will abstract the
-          20 SPI4 channels as Gigabit ethernet interfaces.
-
-config NLMCOMMON_PSB
-	bool "Enable support for ATX eval board bootloader"
-
-config NLMCOMMON_MSGRING_NAPI
-	bool "XLR/XLS message ring NAPI"
-	depends on NLM_XLR
-	default y
-	help
-	  NAPI is a new driver API designed to reduce CPU and interrupt load
-	  when the driver is receiving lots of packets. This option enables 
-	  NAPI implementation for XLR/XLS message ring receive path.
-
-	  See <file:Documentation/networking/NAPI_HOWTO.txt> for more
-	  information.
-
-	  If in doubt, say N.
-
-
-config NLMCOMMON_HW_BUFFER_MGMT
-	bool "Enable support for network buffer recycling via hardware"
-	depends on NLM_XLR
+	depends on NLMCOMMON
 	default y
-	help
-	  Experimental addition to GMAC functionality allowing "recycling" of 
-          packet buffers by requesting HW to queue free elements upon Tx-complete 
-          back to the Rx free list.
-          This type of performance ehancement is important to forwarder-like
-          applications where fast path should stay as lean as possible.
-
-	  If in doubt, say N.
-
-
-config NLMCOMMON_IP_FLOW_AFFINITY
-	bool "Enable support for IP flow affinity"
-	depends on NLM_XLR
-	default n
-	help
-	  Experimental feature of GMAC driver guranteeing that IP flows are processed 
-          on logical CPUs corresponding to buckets assigned by packet classifier engine.
-          E.g. for XLR core #X, packets arriving to buckets 0 & 4 are processed by thread 0,
-          packets arriving to buckets 1 & 5 are processed by thread 1 and so on..
-          Such feature might be important for applications which require IP flows 
-          be seen on one logcal CPUs. Use of this feature involves performance cost.
-
-	  If in doubt, say N.
-
-config NLMCOMMON_IP_QUEUE_AFFINITY
-	bool "Enable multiprocess support for IP Queues"
-	depends on NLM_XLR && IP_NF_QUEUE
-	default n
-	help
-	  Experimental feature extending IP Queues by allowing multiple user space 
-          processes to receive IP packets from the kernel. Client processes should come 
-          with CPU affinity set to single logical CPU and will get packets which are 
-          recieved and processed by network stack on that logical CPU.
-
-          Example:
-
-               Let's Process_1 has CPU affinity set to x
-               Let's Process_2 has CPU affinity set to y
-
-               Packet1 --> Interrupt on CPU x --> IP Queues --> Process_1
-               Packet1 --> Interrupt on CPU y --> IP Queues --> Process_2
-
-          This feature could be useful for packet processing architectures requiring user 
-          space handling of multiple IP flows.
-
-          If in doubt, say N.
 
 config MAPPED_KERNEL
-       bool "Mapped kernel" 
+       bool "Mapped kernel"
+       depends on NLM_XLP
        default y
        help
-         Select this option if you want the kernel's code and data to 
-         be in mapped memory.  The kernel will be mapped using a 
+         Select this option if you want the kernel's code and data to
+         be in mapped memory.  The kernel will be mapped using a
          single wired TLB entry, thus reducing the number of
-         available TLB entries by one.  Kernel modules will be able 
+         available TLB entries by one.  Kernel modules will be able
          to use a more efficient calling convention.
 
 config PHYS_LOAD_ADDRESS
@@ -163,26 +53,26 @@ config PHYS_LOAD_ADDRESS
          The physical load address reflected as the program header
          physical address in the kernel ELF image.
 
-config NLM_COMMON_LOAD_ADDRESS
+config NLMCOMMON_LOAD_ADDRESS
 	hex "Netlogic Linux kernel start address"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default "0xffffffffc4000000"
 	help
 	  This is start address for the linux kernel. Default value
-          should be good for most of the applications unless specified 
+          should be good for most of the applications unless specified
           explicitly: e.g. running Netlogic ToE requires kernel to be linked
 	  at address 0xffffffff86000000.
  
 config NLMCOMMON_PTP_SUPPORT
 	bool "1588PTP Support(enables prepad)"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 	help
 	 Support for 1588 timing feature. Timestamps Rx/Tx packets. 
          
 config NLM_VMIPS
 	bool "Virtual Mips support"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 	help
 	 The kseg0 and kseg1 unmapped access will become mapped. 
@@ -194,7 +84,7 @@ config KSEG2_LOWMEM
 
 config NLM_NAS
 	bool "Enable NAS optimizations"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 	help
 	  This options enables some optimizations done for XLS NAS solutions
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index 02b07ab..1908937 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -1,6 +1,6 @@
 #EXTRA_CFLAGS := -Werror
 EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
-obj-y :=   cpu_proc.o memory.o bootinfo.o
+obj-$(CONFIG_NLM_XLP) :=   cpu_proc.o memory.o bootinfo.o
 
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal_sys.o nlm_evp_cpld.o nlm_hal_cpu_info.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal.o nlm_eeprom.o fdt_helper.o
@@ -15,14 +15,15 @@ obj-y					+= cortina_cs34x7/nlm_cortina_cs34x7.o cortina_cs34x7/nlm_cortina_cs34
 					   cortina_cs34x7/nlm_cortina_cs34x7_p12.o
 EXTRA_CFLAGS += -DNLM_CORTINA_SUPPORT
 endif
-obj-$(CONFIG_RAPIDIO)             	+= srio.o
-obj-$(CONFIG_NLMCOMMON_IP_OVER_PCI) 	+= dma.o
+
+ifdef CONFIG_NLM_XLP
 obj-$(CONFIG_SMP)                 	+= smp.o
+endif
 
 EXTRA_AFLAGS := $(CFLAGS)
 
 clean-files += nlm_hal_fmn_config.o nlm_hal_cpu_info.o
 clean-files += nlm_hal.o
-clean-files += srio.o dma.o smp.o cpu_proc.o
+clean-files += smp.o cpu_proc.o
 clean-files += nlm_hal.c
 
diff --git a/arch/mips/netlogic/common/cpu_proc.c b/arch/mips/netlogic/common/cpu_proc.c
index 09e7a73..515b84c 100644
--- a/arch/mips/netlogic/common/cpu_proc.c
+++ b/arch/mips/netlogic/common/cpu_proc.c
@@ -39,10 +39,6 @@
 
 extern struct proc_dir_entry *nlm_root_proc;
 
-#ifndef CONFIG_BTLB_LOADER
-extern void nlm_update_tlb_stats(void *ignored);
-#endif
-
 struct nlm_cpu_stat {
 	unsigned long long msgring_pic_int;
 	unsigned long long msgring_int;
@@ -124,11 +120,6 @@ static int nlm_cpu_proc_read(char *page, char **start, off_t off,
 	int len = 0;
 	off_t begin = 0;
 
-#ifndef CONFIG_BTLB_LOADER
-	/* Update the TLB stats from other CPUs */
-	on_each_cpu(nlm_update_tlb_stats, NULL, 1);
-#endif
-
 	len += sprintf(page + len, "CPU Frequency: %u HZ\n", (unsigned int)mips_hpt_frequency);
 	if (!proc_pos_check(&begin, &len, off, count))
 		goto out;
@@ -199,14 +190,6 @@ static int nlm_cpu_proc_read(char *page, char **start, off_t off,
 static int nlm_cpu_proc_init(void)
 {
 	struct proc_dir_entry *entry;
-#ifdef CONFIG_NLM_XLR
-	entry = create_proc_read_entry("xlr_cpu", 0 /* def mode */ ,
-				       nlm_root_proc/* parent */ ,
-				       nlm_cpu_proc_read
-				       /* proc read function */ ,
-				       0	/* no client data */
-		);
-#endif
 #ifdef CONFIG_NLM_XLP
 	entry = create_proc_read_entry("xlp_cpu", 0 /* def mode */ ,
 				       nlm_root_proc/* parent */ ,
diff --git a/arch/mips/netlogic/common/dma.c b/arch/mips/netlogic/common/dma.c
deleted file mode 100644
index 2fd2ffa..0000000
--- a/arch/mips/netlogic/common/dma.c
+++ /dev/null
@@ -1,602 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-
-#include <asm/io.h>
-#include <asm/mipsregs.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/iomap.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/sim.h>
-
-#define CH0_CONTROL 8
-#define MSGRNG_CODE_DMA 8
-#define XLR_DMA_RESP_TIMEOUT 500
-#define MAX_DMA_QUEUE_LEN 256
-#define PCIX_ACK_TIMER_VAL 0x18
-
-#define MAX_DMA_TRANS_PER_CPU 256
-#define XLR_MAX_DMA_LEN_PER_DESC ((1 << 20) - 1)	/* 1 MB - 1 */
-
-#define NEXT_SEQ_NUM(x) ((x->sequence_number + 1) & (MAX_DMA_TRANS_PER_CPU - 1))
-#define INC_SEQ_NUM(x) x->sequence_number = \
-		((x->sequence_number + 1) & (MAX_DMA_TRANS_PER_CPU - 1))
-
-#define DMA_SLOT_BUSY(x) (x->trans[x->sequence_number].pending)
-
-#define DMA_RESP_PENDING(x, seq) (x->trans[seq].pending)
-
-#define DMA_SLOT_GET(x) (x->trans[x->sequence_number].pending = 1); \
-				INC_SEQ_NUM(ctrl);
-
-#define DMA_SLOT_PUT(x, seq) (x->trans[seq].pending = 0)
-
-#define DMA_GET_RESP(x, seq) (x->trans[seq].dma_resp)
-
-#define DMA_PUT_RESP(x, seq, msg) x->trans[seq].dma_resp = msg; \
-				x->trans[seq].pending = 0;
-
-#define DMA_DONE(x, seq) (x->trans[seq].pending == 0)
-
-#define Message(a,b...)		//printk("\n[%s] - "a"\n",__FUNCTION__,##b)
-#define ErrorMsg(a,b...) printk("\nError in [%s] - "a"\n",__FUNCTION__,##b)
-enum dma_msgring_bucket_config {
-
-	DMA_MSG_BUCKET0_SIZE = 0x320,
-	DMA_MSG_BUCKET1_SIZE,
-	DMA_MSG_BUCKET2_SIZE,
-	DMA_MSG_BUCKET3_SIZE,
-};
-
-enum dma_msgring_credit_config {
-
-	DMA_CC_CPU0_0 = 0x380,
-	DMA_CC_CPU1_0 = 0x388,
-	DMA_CC_CPU2_0 = 0x390,
-	DMA_CC_CPU3_0 = 0x398,
-	DMA_CC_CPU4_0 = 0x3a0,
-	DMA_CC_CPU5_0 = 0x3a8,
-	DMA_CC_CPU6_0 = 0x3b0,
-	DMA_CC_CPU7_0 = 0x3b8
-};
-
-/* We use 10 bit transaction id in the DMA message to uniquely identify a DMA
-   response.
-   0-7 indicate a sequence number (0 to 255)
-   8-9 bits encode the CPU thread id (0 to 3)
-   */
-typedef struct dma_trans {
-	volatile int pending;
-	uint64_t dma_resp;
-	void (*func) (void *, uint64_t);
-	void *data;
-} dma_trans_t;
-
-typedef struct xlr_dma_ctrl {
-	spinlock_t q_lock;
-	int sequence_number;
-	dma_trans_t trans[MAX_DMA_TRANS_PER_CPU];
-} xlr_dma_ctrl_t;
-
-volatile static int xlr_dma_producer = 0;
-volatile static int xlr_dma_consumer = 0;
-struct msgrng_msg xlr_dma_queue[MAX_DMA_QUEUE_LEN];
-static int xlr_dma_init_done = 0;
-xlr_dma_ctrl_t xlr_dma_ctrl[NR_CPUS];
-
-spinlock_t xlr_dma_lock = SPIN_LOCK_UNLOCKED;
-spinlock_t xlr_enqueue_dma_spin = SPIN_LOCK_UNLOCKED;
-uint32_t xlr_total_dma_reqs, xlr_total_dma_bytes;
-uint32_t xlr_dma_req_failed, xlr_dma_timeout_errors, xlr_dma_errors,
-    xlr_dma_stale_resp;
-uint32_t xlr_dma_msg_send_failed;
-
-void xlr_async_dma_task(unsigned long data);
-extern unsigned int nlm_common_get_shared_mem_base(void);
-#define CONFIG_PROC_FS 1
-#ifdef CONFIG_PROC_FS
-#include <linux/proc_fs.h>
-
-extern int xlr_loader_own_dma;
-extern struct proc_dir_entry *nlm_root_proc;
-
-static int xlr_dma_proc_read(char *page, char **start, off_t off,
-			     int count, int *eof, void *data)
-{
-	int len, total_len;
-	char *ptr = page;
-
-	if (count < 512)	/* Need minimum of this space */
-		return -EINVAL;
-
-	total_len = 0;
-	len = sprintf(ptr, "Total DMA Requests = %d\n", xlr_total_dma_reqs);
-	ptr += len;
-	total_len += len;
-
-	len = sprintf(ptr, "Total DMA Bytes = %d\n", xlr_total_dma_bytes);
-	ptr += len;
-	total_len += len;
-
-	len = sprintf(ptr, "DMA Requests failed = %d\n", xlr_dma_req_failed);
-	ptr += len;
-	total_len += len;
-
-	len = sprintf(ptr, "DMA Timeout errors = %d\n", xlr_dma_timeout_errors);
-	ptr += len;
-	total_len += len;
-
-	len = sprintf(ptr, "DMA errors = %d\n", xlr_dma_errors);
-	ptr += len;
-	total_len += len;
-
-	len = sprintf(ptr, "DMA Stale responses = %d\n", xlr_dma_stale_resp);
-	total_len += len;
-
-	len = sprintf(ptr, "DMA Message Send Failed = %d\n",
-		      xlr_dma_msg_send_failed);
-	total_len += len;
-
-	return total_len;
-}
-void xlr_init_dma_proc(void)
-{
-	struct proc_dir_entry *entry;
-
-	if (!(entry = create_proc_entry("xlr_dma_stats", 0444, nlm_root_proc))) {
-		printk("%s: create_proc_entry failed\n", __FUNCTION__);
-		return;
-	}
-	entry->read_proc = xlr_dma_proc_read;
-
-}
-void xlr_uninit_dma_proc(void)
-{
-	remove_proc_entry("xlr_dma_stat", nlm_root_proc);
-}
-#endif
-
-/* DMA message handler - Called from interrupt context */
-static void xlr_dma_msgring_handler(int bucket, int size, int code,
-				    int stid, struct msgrng_msg *msg,
-				    void *data /* ignored */ )
-{
-	int cpu, thr_id, tx_id, seq;
-	xlr_dma_ctrl_t *ctrl;
-
-	tx_id = (msg->msg0 >> 48) & 0x3ff;
-	thr_id = (tx_id >> 8) & 0x3;
-	seq = (tx_id & 0xff);
-
-	cpu = (netlogic_cpu_id() * 4) + thr_id;
-	ctrl = &xlr_dma_ctrl[cpu];
-
-	spin_lock(&ctrl->q_lock);
-	/* Check if there was a pending request. This can happen if the
-	   requestor times out and gives up the request. So in that case
-	   do not update the response
-	   NOTE: One corner case that is not handled here is that when seq no
-	   wraps around and request was pending for the new one and this response
-	   was for the old request. This ideally must not happen.
-	 */
-	if (DMA_RESP_PENDING(ctrl, seq)) {
-
-		DMA_PUT_RESP(ctrl, seq, msg->msg0);
-		if (ctrl->trans[seq].func) {
-			ctrl->trans[seq].func(ctrl->trans[seq].data, msg->msg0);
-		}
-		spin_unlock(&ctrl->q_lock);
-		return;
-	}
-	spin_unlock(&ctrl->q_lock);
-	printk("ERROR: Stale response from DMA engine for transaction id %d\n",
-	       seq);
-	spin_lock(&xlr_dma_lock);
-	xlr_dma_stale_resp++;
-	spin_unlock(&xlr_dma_lock);
-	return;
-}
-
-inline void xlr_build_xfer_msg(struct msgrng_msg *msg, uint64_t src,
-			       uint64_t dest, uint32_t len, int tx_id,
-			       int resp_bkt)
-{
-	msg->msg0 = (1ULL << 63) | ((uint64_t) len << 40) |
-	    (src & 0xffffffffffULL);
-	msg->msg1 = (1ULL << 58) | ((uint64_t) tx_id << 48) |
-	    ((uint64_t) resp_bkt << 40) | (dest & 0xffffffffffull);
-
-}
-
-int xlr_enqueue_dma_msg(struct msgrng_msg *msg)
-{
-	unsigned long mflags;
-	spin_lock_irqsave(&xlr_enqueue_dma_spin, mflags);
-	if (((xlr_dma_producer + 1) % (MAX_DMA_QUEUE_LEN)) == xlr_dma_consumer) {
-		//ErrorMsg("DMA Async Queue is full");
-		spin_unlock_irqrestore(&xlr_enqueue_dma_spin, mflags);
-		return -ENOMEM;
-	}
-	//Enqueue Msg 
-	xlr_dma_queue[xlr_dma_producer].msg0 = msg->msg0;
-	xlr_dma_queue[xlr_dma_producer].msg1 = msg->msg1;
-	xlr_dma_queue[xlr_dma_producer].msg2 = 0ULL;
-	xlr_dma_queue[xlr_dma_producer].msg3 = 0ULL;
-	xlr_dma_producer = (xlr_dma_producer + 1) % (MAX_DMA_QUEUE_LEN);
-	spin_unlock_irqrestore(&xlr_enqueue_dma_spin, mflags);
-	return 0;
-}
-
-DECLARE_TASKLET(xlr_dma_task, xlr_async_dma_task, 0);
-void xlr_async_dma_task(unsigned long data)
-{
-	unsigned long flags = 0;
-	int data_len;
-	uint64_t phys1, phys2;
-	struct msgrng_msg *msg;
-	static int last_msg_send_success = 1;
-	int msg_send_success = 0;
-
-	while ((xlr_dma_consumer != xlr_dma_producer)) {
-
-		msg = &xlr_dma_queue[xlr_dma_consumer];
-		phys1 = msg->msg0 & 0xffffffffffULL;	//DEST
-		phys2 = msg->msg1 & 0xffffffffffULL;	//SRC
-		data_len = (msg->msg0 >> 40) & 0xfffff;
-		msgrng_access_enable(flags);
-		if (xlr_dma_consumer == xlr_dma_producer) {
-			ErrorMsg("Shdnt Happen.");
-		}
-		if (message_send_retry(2, MSGRNG_CODE_DMA, MSGRNG_STNID_DMA_0,
-				       &xlr_dma_queue[xlr_dma_consumer])) {
-			xlr_dma_msg_send_failed++;
-			msgrng_access_disable(flags);
-			last_msg_send_success = 1;
-			msg_send_success = 0;
-			tasklet_schedule(&xlr_dma_task);
-			break;
-		}
-
-		msg_send_success = 1;
-		last_msg_send_success = 1;
-		xlr_dma_consumer = (xlr_dma_consumer + 1) % (MAX_DMA_QUEUE_LEN);
-		msgrng_access_disable(flags);
-	}
-
-}
-
-/* Returns 0 on success, -1 otherwise */
-int xlr_async_request_dma(uint64_t src, uint64_t dest, uint32_t len,
-			  void (*func) (void *, uint64_t), void *data)
-{
-	int thr_id, cpu;
-	xlr_dma_ctrl_t *ctrl;
-	int tx_id, resp_bkt, seq;
-	struct msgrng_msg msg;
-	unsigned long flags;
-
-	/* Driver does not support multiple descriptor DMA yet */
-	if (len > XLR_MAX_DMA_LEN_PER_DESC) {
-		ErrorMsg("%s: Cannot do DMA for more than %d bytes\n",
-			 __FUNCTION__, XLR_MAX_DMA_LEN_PER_DESC);
-		return -1;
-	}
-	if (xlr_dma_init_done == 0) {
-		ErrorMsg("%s: XLR DMA engine is not initialized\n",
-			 __FUNCTION__);
-		return -1;
-	}
-	Message("\nSrc Addr %#llx Dst Addr %#llx\n", src, dest);
-
-	preempt_disable();
-	thr_id = netlogic_thr_id();
-	cpu = (netlogic_cpu_id() * 4) + thr_id;
-	ctrl = &xlr_dma_ctrl[cpu];
-
-	spin_lock_irqsave(&ctrl->q_lock, flags);
-	preempt_enable();
-
-	if (DMA_SLOT_BUSY(ctrl)) {
-		//ErrorMsg("%s: No space to enqueue this request\n", __FUNCTION__);
-		spin_unlock_irqrestore(&ctrl->q_lock, flags);
-		return -1;
-	}
-	tx_id = (thr_id << 8) | ctrl->sequence_number;
-	seq = ctrl->sequence_number;
-	DMA_SLOT_GET(ctrl);
-
-	/* use bucket 0 of each core as the bucket where response will be 
-	   received
-	 */
-	resp_bkt = netlogic_cpu_id() * 8;
-
-	spin_unlock_irqrestore(&ctrl->q_lock, flags);
-
-	/*CallBack For Async Call. */
-	ctrl->trans[seq].func = func;
-	ctrl->trans[seq].data = data;
-
-	/* Form the DMA simple xfer request and send to Channel 0 */
-
-	xlr_build_xfer_msg(&msg, src, dest, len, tx_id, resp_bkt);
-
-	if (xlr_enqueue_dma_msg(&msg)) {
-		//ErrorMsg("Cant Enqueue Msg.");
-		spin_lock_irqsave(&ctrl->q_lock, flags);
-		DMA_SLOT_PUT(ctrl, seq);
-		spin_unlock_irqrestore(&ctrl->q_lock, flags);
-		tasklet_schedule(&xlr_dma_task);
-		return -1;
-	}
-	tasklet_schedule(&xlr_dma_task);
-	return 0;
-}
-
-/* Returns 0 on success, -1 otherwise */
-int xlr_request_dma(uint64_t src, uint64_t dest, uint32_t len)
-{
-	int thr_id, cpu, i;
-	xlr_dma_ctrl_t *ctrl;
-	int tx_id, resp_bkt, seq, ret, err;
-	struct msgrng_msg  msg = {0}, r_msg = {0};
-	unsigned long flags;
-
-	/* Driver does not support multiple descriptor DMA yet */
-	if (len > XLR_MAX_DMA_LEN_PER_DESC) {
-		printk("%s: Cannot do DMA for more than %d bytes\n",
-		       __FUNCTION__, XLR_MAX_DMA_LEN_PER_DESC);
-		spin_lock_irqsave(&xlr_dma_lock, flags);
-		xlr_dma_req_failed++;
-		spin_unlock_irqrestore(&xlr_dma_lock, flags);
-		return -1;
-	}
-	if (xlr_dma_init_done == 0) {
-		printk("%s: XLR DMA engine is not initialized\n", __FUNCTION__);
-		spin_lock_irqsave(&xlr_dma_lock, flags);
-		xlr_dma_req_failed++;
-		spin_unlock_irqrestore(&xlr_dma_lock, flags);
-		return -1;
-	}
-
-	preempt_disable();
-	thr_id = netlogic_thr_id();
-	cpu = (netlogic_cpu_id() * 4) + thr_id;
-	ctrl = &xlr_dma_ctrl[cpu];
-
-	spin_lock_irqsave(&ctrl->q_lock, flags);
-	preempt_enable();	/* will not enable actually */
-	if (DMA_SLOT_BUSY(ctrl)) {
-		printk("%s: No space to enqueue this request\n", __FUNCTION__);
-		spin_unlock_irqrestore(&ctrl->q_lock, flags);
-
-		spin_lock_irqsave(&xlr_dma_lock, flags);
-		xlr_dma_req_failed++;
-		spin_unlock_irqrestore(&xlr_dma_lock, flags);
-		return -1;
-	}
-	tx_id = (thr_id << 8) | ctrl->sequence_number;
-	seq = ctrl->sequence_number;
-	DMA_SLOT_GET(ctrl);
-
-	/* use bucket 0 of each core as the bucket where response will be 
-	   received
-	 */
-	resp_bkt = netlogic_cpu_id() * 8;
-	spin_unlock_irqrestore(&ctrl->q_lock, flags);
-
-	/*Reset Callback - As this is not async call */
-	ctrl->trans[seq].func = NULL;
-	ctrl->trans[seq].data = NULL;
-
-	/* Form the DMA simple xfer request and send to Channel 0 */
-	xlr_build_xfer_msg(&msg, src, dest, len, tx_id, resp_bkt);
-	msgrng_access_enable(flags);
-	if (message_send_retry(2, MSGRNG_CODE_DMA, MSGRNG_STNID_DMA_0, &msg)) {
-		printk
-		    ("Message_send failed: Cannot submit DMA request to engine\n");
-		msgrng_access_disable(flags);
-		spin_lock_irqsave(&ctrl->q_lock, flags);
-		DMA_SLOT_PUT(ctrl, seq);
-		spin_unlock_irqrestore(&ctrl->q_lock, flags);
-
-		spin_lock_irqsave(&xlr_dma_lock, flags);
-		xlr_dma_req_failed++;
-		spin_unlock_irqrestore(&xlr_dma_lock, flags);
-		return -1;
-	}
-	msgrng_access_disable(flags);
-	/* wait for the response here */
-	for (i = 0; i < XLR_DMA_RESP_TIMEOUT; i++) {
-		if (DMA_DONE(ctrl, seq))
-			break;
-		udelay(50);
-	}
-	if (i == XLR_DMA_RESP_TIMEOUT) {
-		printk("%s:Did not get response from DMA engine\n",
-		       __FUNCTION__);
-		spin_lock_irqsave(&ctrl->q_lock, flags);
-		DMA_SLOT_PUT(ctrl, seq);
-		spin_unlock_irqrestore(&ctrl->q_lock, flags);
-
-		spin_lock_irqsave(&xlr_dma_lock, flags);
-		xlr_dma_timeout_errors++;
-		spin_unlock_irqrestore(&xlr_dma_lock, flags);
-		return -1;
-	}
-	/* Do some error checks */
-
-	r_msg.msg0 = DMA_GET_RESP(ctrl, seq);
-	ret = (r_msg.msg0 >> 62) & 0x3;
-	err = (r_msg.msg0 >> 60) & 0x3;
-	if (ret != 0x3) {
-		printk("%s: Bad return code %d from DMA engine\n", __FUNCTION__,
-		       ret);
-		spin_lock_irqsave(&xlr_dma_lock, flags);
-		xlr_dma_errors++;
-		spin_unlock_irqrestore(&xlr_dma_lock, flags);
-		return -1;
-	}
-	if (err & 0x2) {
-		printk("%s:DMA engine reported Message format error\n",
-		       __FUNCTION__);
-		spin_lock_irqsave(&xlr_dma_lock, flags);
-		xlr_dma_errors++;
-		spin_unlock_irqrestore(&xlr_dma_lock, flags);
-		return -1;
-	}
-	if (err & 0x1) {
-		printk("%s:DMA engine reported Bus error\n", __FUNCTION__);
-		spin_lock_irqsave(&xlr_dma_lock, flags);
-		xlr_dma_errors++;
-		spin_unlock_irqrestore(&xlr_dma_lock, flags);
-
-		return -1;
-	}
-	spin_lock_irqsave(&xlr_dma_lock, flags);
-	xlr_total_dma_reqs++;
-	xlr_total_dma_bytes += len;
-	spin_unlock_irqrestore(&xlr_dma_lock, flags);
-	return 0;
-}
-
-int xlr_init_dma(void)
-{
-	int i;
-	nlm_reg_t *mmio = netlogic_io_mmio(0x1A000);
-	xlr_dma_ctrl_t *ctrl;
-#ifdef NLM_BRIDGE_WKAROUND
-	unsigned int flags=0;
-#endif
-
-	for (i = 0; i < NR_CPUS; i++) {
-		ctrl = &xlr_dma_ctrl[i];
-		spin_lock_init(&ctrl->q_lock);
-		ctrl->sequence_number = 0;
-	}
-	/* Register for the Message ring handler */
-	if (register_msgring_handler(TX_STN_DMA, xlr_dma_msgring_handler, NULL)) {
-		printk("Couldn't register DMA msgring handler\n");
-		return -1;
-	}
-#ifdef NLM_BRIDGE_WKAROUND
-	if (nlm_enable_br_wrkaround) {
-		flags = nlm_write_lock_irq_save(nlm_bridge_lock);
-	}
-#endif
-	/* Use channel 0 for all DMA */
-	/* Pci Stream Hint En = 1, Report Error = 1, Section Size = 4, 
-	 * RMaxCr=4, WMaxCr =4, En=1; */
-	mmio[CH0_CONTROL] = (1 << 28) | (1 << 24) | (4 << 12) | (4 << 8) |
-	    (4 << 5) | (1 << 4);
-	mmio[PCIX_ACK_TIMER_VAL] = 100;
-	/* Configure the bucket sizes */
-	if (xlr_loader_own_dma) {
-		mmio[DMA_MSG_BUCKET0_SIZE] =
-		    shared_bucket_sizes.bucket[MSGRNG_STNID_DMA_0];
-		mmio[DMA_MSG_BUCKET1_SIZE] =
-		    shared_bucket_sizes.bucket[MSGRNG_STNID_DMA_1];
-		mmio[DMA_MSG_BUCKET2_SIZE] =
-		    shared_bucket_sizes.bucket[MSGRNG_STNID_DMA_2];
-		mmio[DMA_MSG_BUCKET3_SIZE] =
-		    shared_bucket_sizes.bucket[MSGRNG_STNID_DMA_3];
-
-		/* Configure the DMA credits */
-		for (i = 0; i < 128; i++) {
-			mmio[DMA_CC_CPU0_0 + i] =
-			    shared_cc_table_dma.counters[i >> 3][i & 0x07];
-		}
-	} else {
-		mmio[DMA_MSG_BUCKET0_SIZE] =
-		    bucket_sizes.bucket[MSGRNG_STNID_DMA_0];
-		mmio[DMA_MSG_BUCKET1_SIZE] =
-		    bucket_sizes.bucket[MSGRNG_STNID_DMA_1];
-		mmio[DMA_MSG_BUCKET2_SIZE] =
-		    bucket_sizes.bucket[MSGRNG_STNID_DMA_2];
-		mmio[DMA_MSG_BUCKET3_SIZE] =
-		    bucket_sizes.bucket[MSGRNG_STNID_DMA_3];
-
-		/* Configure the DMA credits */
-		for (i = 0; i < 128; i++) {
-			mmio[DMA_CC_CPU0_0 + i] =
-			    cc_table_dma.counters[i >> 3][i & 0x07];
-		}
-	}
-#ifdef NLM_BRIDGE_WKAROUND
-	if (nlm_enable_br_wrkaround) {
-		nlm_write_unlock_irq_restore(nlm_bridge_lock, flags);
-	}
-#endif
-#ifdef CONFIG_PROC_FS
-	xlr_init_dma_proc();
-#endif
-	xlr_dma_init_done = 1;
-	printk("Initialized XLR DMA Controller, Channel 0 \n");
-	tasklet_schedule(&xlr_dma_task);
-	return 0;
-}
-
-#ifdef TEST_DMA
-void xlr_dma_test(void)
-{
-	int i;
-	uint8_t *ptr1, *ptr2;
-	unsigned long s_jiffy, e_jiffy;
-
-	ptr1 = (uint8_t *) kmalloc(0x1000, GFP_KERNEL);
-	ptr2 = (uint8_t *) kmalloc(0x1000, GFP_KERNEL);
-	if (!ptr1 || !ptr2) {
-		if (ptr1)
-			kfree(ptr1);
-		if (ptr2)
-			kfree(ptr2);
-
-		printk("DMA test buffer alloc failed\n");
-		return;
-	}
-	memset(ptr1, 0xa5, 0x1000);
-	s_jiffy = read_c0_count();
-	for (i = 0; i < 512; i++) {
-		xlr_request_dma((uint64_t) virt_to_phys(ptr1),
-				(uint64_t) virt_to_phys(ptr2), 0x1000);
-	}
-	e_jiffy = read_c0_count();
-	if (memcmp(ptr1, ptr2, 0x1000)) {
-		printk("DMA Data does not match. Test failed\n");
-	} else
-		printk("DMA Data Matches. Test Successful\n");
-
-	printk("Start time = %lx end time = %lx\n", s_jiffy, e_jiffy);
-	kfree(ptr1);
-	kfree(ptr2);
-}
-#endif
-EXPORT_SYMBOL(xlr_request_dma);
diff --git a/arch/mips/netlogic/common/platform.c b/arch/mips/netlogic/common/platform.c
deleted file mode 100644
index 8616902..0000000
--- a/arch/mips/netlogic/common/platform.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*
- * Copyright 2004, Matt Porter <mporter@kernel.crashing.org>
- *
- * This file is licensed under the terms of the GNU General Public
- * License version 2.  This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- */
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/resource.h>
-#include <asm/netlogic/nlm_srio.h>
-
-static u64 xls_usb_dmamask = ~(u32) 0;
-
-static struct platform_device xls_usb_ehci_device = {
-	.name = "ehci-xls",
-	.id = 0,
-	.num_resources = 2,
-	.dev = {
-		.dma_mask = &xls_usb_dmamask,
-		.coherent_dma_mask = 0xffffffff,
-		},
-	.resource = (struct resource[]){
-					{
-					 .start = 0x1EF24000,
-					 .end = (0x1EF24000 + 0x400 - 0x01),
-					 .flags = IORESOURCE_MEM,
-					 },
-					{
-					 .start = 39,
-					 .end = 39,
-					 .flags = IORESOURCE_IRQ,
-					 },
-					},
-};
-
-static struct platform_device xls_usb_ohci_device_0 = {
-	.name = "ohci-xls-0",
-	.id = 1,
-	.num_resources = 2,
-	.dev = {
-		.dma_mask = &xls_usb_dmamask,
-		.coherent_dma_mask = 0xffffffff,
-		},
-	.resource = (struct resource[]){
-					{
-					 .start = 0x1EF24400,
-					 .end = (0x1EF24400 + 0x400 - 0x01),
-					 .flags = IORESOURCE_MEM,
-					 },
-					{
-					 .start = 39,
-					 .end = 39,
-					 .flags = IORESOURCE_IRQ,
-					 },
-					},
-};
-
-static struct platform_device xls_usb_ohci_device_1 = {
-	.name = "ohci-xls-1",
-	.id = 2,
-	.num_resources = 2,
-	.dev = {
-		.dma_mask = &xls_usb_dmamask,
-		.coherent_dma_mask = 0xffffffff,
-		},
-	.resource = (struct resource[]){
-					{
-					 .start = 0x1EF24800,
-					 .end = (0x1EF24800 + 0x400 - 0x01),
-					 .flags = IORESOURCE_MEM,
-					 },
-					{
-					 .start = 39,
-					 .end = 39,
-					 .flags = IORESOURCE_IRQ,
-					 },
-					},
-};
-
-static struct platform_device *xls_platform_devices[] __initdata = {
-	&xls_usb_ehci_device,
-	&xls_usb_ohci_device_0,
-	&xls_usb_ohci_device_1,
-};
-
-int xls_platform_init(void)
-{
-    return platform_add_devices(xls_platform_devices, ARRAY_SIZE(xls_platform_devices));
-}
-
-arch_initcall(xls_platform_init);
-
-#ifdef CONFIG_RAPIDIO
-void platform_rio_init(void)
-{
-	nlm_rio_setup();
-}
-#endif				/* CONFIG_RAPIDIO */
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index a156871..a06bbb2 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -35,8 +35,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/sim.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/pic.h>
-#include <asm/netlogic/msgring.h>
-
 
 /* ipi statistics counters for debugging */
 __u32 ipi_3_counter_tx[NR_CPUS][NR_CPUS];
@@ -68,11 +66,6 @@ void core_send_ipi(int logical_cpu, unsigned int action)
 	} else if (action & SMP_OPROFILE_IPI) {
 		SET_IPI_VECTOR(ipi, IRQ_IPI_OPROFILE);
 	}
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-	else if (action & SMP_NETRX_IPI) {
-		SET_IPI_VECTOR(ipi, IRQ_IPI_NETRX);
-	}
-#endif				/* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
 	else
 		return;
 
@@ -97,10 +90,6 @@ int nlm_cpu_ready[NR_CPUS];
 unsigned long nlm_next_gp;
 unsigned long nlm_next_sp;
 
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-extern void skb_transfer_finish(void);
-#endif				/* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
-
 #ifdef CONFIG_SMP
 /* IRQ_IPI_SMP_FUNCTION Handler */
 void nlm_smp_function_ipi_handler(unsigned int irq, struct irq_desc *desc)
@@ -121,20 +110,6 @@ void nlm_smp_resched_ipi_handler(unsigned int irq, struct irq_desc *desc)
 	set_need_resched();
 	nlm_common_ipi_stats[smp_processor_id()]--;
 }
-
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-/* nlm_ip_flow_ipi_handler HANDLER */
-void nlm_ip_flow_ipi_handler(unsigned int irq, struct irq_desc *desc)
-{
-	nlm_common_ipi_stats[smp_processor_id()]++;
-	save_epc(&nlm_common_ipi_epc[smp_processor_id()]);
-
-	/* do_IRQ called irq_enter() before calling this desc->handler */
-	skb_transfer_finish();
-	nlm_common_ipi_stats[smp_processor_id()]--;
-
-}
-#endif /* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
 #endif
 
 void nlm_common_ipi_handler(int irq, struct pt_regs *regs)
@@ -145,16 +120,6 @@ void nlm_common_ipi_handler(int irq, struct pt_regs *regs)
 	if (irq == NLM_IRQ_IPI_SMP_FUNCTION) {
 		smp_call_function_interrupt();
 	}
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-	else if (irq == IRQ_IPI_NETRX) {
-		irq_enter();
-
-		skb_transfer_finish();
-
-		/* run soft IRQ at the end */
-		irq_exit();
-	}
-#endif	/* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
 	else {
 		/* Announce that we are for reschduling */
 		scheduler_ipi();
diff --git a/arch/mips/netlogic/common/srio.c b/arch/mips/netlogic/common/srio.c
deleted file mode 100644
index 4b52575..0000000
--- a/arch/mips/netlogic/common/srio.c
+++ /dev/null
@@ -1,2225 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*
- * MPC85xx RapidIO support
- *
- * Copyright 2005 MontaVista Software, Inc.
- * Matt Porter <mporter@kernel.crashing.org>
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/rio.h>
-#include <linux/rio_drv.h>
-#include <linux/delay.h>
-#include <asm/netlogic/nlm_srio.h>
-#include <asm/netlogic/gpio.h>
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/netlogic/sim.h>
-
-#define MYDBG(a,b...)
-#define Message(a,b...)		//printk("\nFunction[%s]-Line[%d]\n"a"\n",__FUNCTION__,__LINE__,##b)
-
-struct transaction_queue {
-	uint32_t *orig;
-	uint32_t start;
-	uint32_t end;
-	uint32_t head;
-	uint32_t tail;
-	spinlock_t lock;
-	uint32_t max_entries;
-	int curr_free_tq_entry;
-	int active;
-};
-
-struct status_queue {
-	uint32_t *orig;
-	uint32_t start;
-	uint32_t end;
-	uint32_t head;
-	uint32_t tail;
-	int active;
-	spinlock_t lock;
-	void *dev_id;
-	uint32_t max_entries;
-	int curr_sq_index;
-};
-
-struct mailbox_queue {
-	uint32_t *orig;
-	uint32_t start;
-	uint32_t end;
-	uint32_t head;
-	uint32_t tail;
-	int active;
-	spinlock_t lock;
-	void *dev_id;
-	uint32_t max_entries;
-};
-
-struct freel_queue {
-	uint32_t *orig;
-	uint32_t start;
-	uint32_t end;
-	uint32_t head;
-	uint32_t tail;
-	int active;
-	spinlock_t lock;
-	uint32_t max_entries;
-};
-
-struct nlm_rio_controller {
-	struct rio_mport *port;
-	int host_deviceid;
-	int index;
-	unsigned long regs_phy_start;
-	unsigned long regs_virt_start;
-	struct transaction_queue tq[MAX_TRANSACTION_Q];
-	struct status_queue sq[MAX_STATUS_Q];
-	struct mailbox_queue mq[MAX_MAILBOX_Q];
-	struct freel_queue fq[MAX_FREEL_Q];
-	int irq;
-	spinlock_t maintenance_lock;	/*lock for maintenance transactions. */
-	spinlock_t mailbox_lock;	/*lock for mailbox transactions. */
-	spinlock_t freel_lock;	/*lock for freeq. */
-};
-
-/*All function declaration goes here.*/
-int nlm_local_config_read(struct nlm_rio_controller *rio_ctrl,
-			  int pindex, u32 offset, int len, u32 * data);
-int nlm_local_config_write(struct nlm_rio_controller *rio_ctrl,
-			   int pindex, u32 offset, int len, u32 data);
-int nlm_rio_config_read(struct nlm_rio_controller *rio_ctrl,
-			int pindex, u16 destid, u8 hopcount,
-			u32 offset, int len, u32 * val);
-int nlm_rio_config_write(struct nlm_rio_controller *rio_ctrl,
-			 int pindex, u16 destid, u8 hopcount, u32 offset,
-			 int len, u32 val);
-int nlm_rio_doorbell_send(struct nlm_rio_controller *rio_ctrl,
-			  int pindex, u16 destid, u16 data);
-
-int nlm_setup_transaction_queue(struct nlm_rio_controller *rio_ctrl,
-				struct transaction_queue *tq, int tq_index,
-				int tq_entries);
-
-int nlm_setup_status_queue(struct nlm_rio_controller *rio_ctrl,
-			   struct status_queue *sq, int sq_index,
-			   int sq_entries);
-
-int nlm_setup_mailbox_queue(struct nlm_rio_controller *rio_ctrl,
-			    struct mailbox_queue *mq, int mq_index,
-			    int mq_entries);
-
-int nlm_setup_freel_queue(struct nlm_rio_controller *rio_ctrl,
-			  struct freel_queue *fq, int fq_index, int fq_entries);
-
-void free_unregistered_resrources(void);
-
-int nlm_clear_transaction_queue(struct nlm_rio_controller *rio_ctrl,
-				struct transaction_queue *tq, int tq_index);
-
-int nlm_clear_status_queue(struct nlm_rio_controller *rio_ctrl,
-			   struct status_queue *sq, int sq_index);
-
-int nlm_clear_mailbox_queue(struct nlm_rio_controller *rio_ctrl,
-			    struct mailbox_queue *mq, int mq_index);
-
-int nlm_clear_freel_queue(struct nlm_rio_controller *rio_ctrl,
-			  struct freel_queue *fq, int fq_index);
-
-/*Global data structures*/
-int srio_ports;
-int srio_mode;
-extern unsigned long netlogic_io_base;
-
-int nlm_rio_host_id[MAX_SRIO_PORTS] = { -1, -1, -1, -1 };
-
-unsigned long rio_reg_phy_start[MAX_SRIO_PORTS] =
-    { NLM_SRIO_MEM_0, NLM_SRIO_MEM_1, NLM_SRIO_MEM_2, NLM_SRIO_MEM_3 };
-
-struct nlm_rio_controller *rio_controller[MAX_SRIO_PORTS] = { NULL };
-extern int fdt_get_srio_port_map(uint32_t *srio_port_map);
-extern uint32_t dev_tree_en;
-
-/*controller-0 rio ops*/
-RIO_OPS_LOCAL_CONFIG_READ(0)
-    RIO_OPS_LOCAL_CONFIG_WRITE(0)
-    RIO_OPS_CONFIG_READ(0)
-    RIO_OPS_CONFIG_WRITE(0)
-    RIO_OPS_DOORBELL_SEND(0)
-
-/*controller-1 rio ops*/
-    RIO_OPS_LOCAL_CONFIG_READ(1)
-    RIO_OPS_LOCAL_CONFIG_WRITE(1)
-    RIO_OPS_CONFIG_READ(1)
-    RIO_OPS_CONFIG_WRITE(1)
-    RIO_OPS_DOORBELL_SEND(1)
-
-/*controller-2 rio ops*/
-    RIO_OPS_LOCAL_CONFIG_READ(2)
-    RIO_OPS_LOCAL_CONFIG_WRITE(2)
-    RIO_OPS_CONFIG_READ(2)
-    RIO_OPS_CONFIG_WRITE(2)
-    RIO_OPS_DOORBELL_SEND(2)
-
-/*controller-3 rio ops*/
-    RIO_OPS_LOCAL_CONFIG_READ(3)
-    RIO_OPS_LOCAL_CONFIG_WRITE(3)
-    RIO_OPS_CONFIG_READ(3)
-    RIO_OPS_CONFIG_WRITE(3)
-    RIO_OPS_DOORBELL_SEND(3)
-
-int nlm_rio_get_cmdline_0(char *s)
-{
-	int id;
-	if (!s)
-		return 0;
-	id = simple_strtoul(s, NULL, 10);
-	nlm_rio_host_id[0] = id;
-	return 1;
-}
-
-__setup("riohdid0=", nlm_rio_get_cmdline_0);
-
-int nlm_rio_get_cmdline_1(char *s)
-{
-	int id;
-	if (!s)
-		return 0;
-	id = simple_strtoul(s, NULL, 10);
-	nlm_rio_host_id[1] = id;
-	return 1;
-}
-
-__setup("riohdid1=", nlm_rio_get_cmdline_1);
-
-int nlm_rio_get_cmdline_2(char *s)
-{
-	int id;
-	if (!s)
-		return 0;
-	id = simple_strtoul(s, NULL, 10);
-	nlm_rio_host_id[2] = id;
-	return 1;
-}
-
-__setup("riohdid2=", nlm_rio_get_cmdline_2);
-
-int nlm_rio_get_cmdline_3(char *s)
-{
-	int id;
-	if (!s)
-		return 0;
-	id = simple_strtoul(s, NULL, 10);
-	nlm_rio_host_id[3] = id;
-	return 1;
-}
-
-__setup("riohdid3=", nlm_rio_get_cmdline_3);
-
-void *nlm_rio_ops[MAX_SRIO_PORTS][5] = {
-
-	{nlm_local_config_read_0,
-	 nlm_local_config_write_0,
-	 nlm_rio_config_read_0,
-	 nlm_rio_config_write_0,
-	 nlm_rio_doorbell_send_0},
-	{nlm_local_config_read_1,
-	 nlm_local_config_write_1,
-	 nlm_rio_config_read_1,
-	 nlm_rio_config_write_1,
-	 nlm_rio_doorbell_send_1},
-	{nlm_local_config_read_2,
-	 nlm_local_config_write_2,
-	 nlm_rio_config_read_2,
-	 nlm_rio_config_write_2,
-	 nlm_rio_doorbell_send_2},
-	{nlm_local_config_read_3,
-	 nlm_local_config_write_3,
-	 nlm_rio_config_read_3,
-	 nlm_rio_config_write_3,
-	 nlm_rio_doorbell_send_3}
-};
-
-#ifdef NLM_SRIO_DEBUG
-
-void dump_mq_regs(struct nlm_rio_controller *rio_ctrl,
-		  struct mailbox_queue *mq, int mq_index)
-{
-	uint32_t data;
-	printk("\nmq->orig %#lx\n", mq->orig);
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_QUEUE_START(mq_index), 4,
-			      &data);
-	printk("\nMQ QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_QUEUE_END(mq_index), 4,
-			      &data);
-	printk("\nMQ QUEUE END = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_QUEUE_HEAD(mq_index), 4,
-			      &data);
-	printk("\nMQ QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_QUEUE_TAIL(mq_index), 4,
-			      &data);
-	printk("\nMQ QUEUE TAIL = %#x\n", data);
-
-}
-
-void dump_fq_regs(struct nlm_rio_controller *rio_ctrl,
-		  struct freel_queue *fq, int fq_index)
-{
-	uint32_t data;
-	printk("\nfq->orig %#lx\n", fq->orig);
-	nlm_local_config_read(rio_ctrl, 0, FREEL_QUEUE_START(fq_index), 4,
-			      &data);
-	printk("\nFREEL QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, FREEL_QUEUE_END(fq_index), 4, &data);
-	printk("\nFREEL QUEUE END = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, FREEL_QUEUE_HEAD(fq_index), 4,
-			      &data);
-	printk("\nFREEL QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, FREEL_QUEUE_TAIL(fq_index), 4,
-			      &data);
-	nlm_local_config_write(rio_ctrl, 0, FREEL_QUEUE_TAIL(fq_index), 4,
-			       data | 0x1);
-	printk("\nFREEL QUEUE TAIL = %#x\n", data);
-
-}
-
-void dump_tq_regs(struct nlm_rio_controller *rio_ctrl,
-		  struct transaction_queue *tq, int tq_index)
-{
-	uint32_t data;
-	printk("\ntq->orig %#lx\n", tq->orig);
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_START(tq_index), 4,
-			      &data);
-	printk("\nTRANSACTION QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_END(tq_index), 4,
-			      &data);
-	printk("\nTRANSACTION QUEUE END = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_HEAD(tq_index), 4,
-			      &data);
-	printk("\nTRANSACTION QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_TAIL(tq_index), 4,
-			      &data);
-	nlm_local_config_write(rio_ctrl, 0, TRANSACTION_QUEUE_TAIL(tq_index), 4,
-			       data | 0x1);
-	printk("\nTRANSACTION QUEUE TAIL = %#x\n", data);
-
-}
-
-void dump_sq_regs(struct nlm_rio_controller *rio_ctrl,
-		  struct status_queue *sq, int sq_index)
-{
-	uint32_t data;
-	printk("\nsq->orig %#lx\n", sq->orig);
-	nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_START(sq_index), 4,
-			      &data);
-	printk("\nSTATUS QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_END(sq_index), 4,
-			      &data);
-	printk("\nSTATUS QUEUE END = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_HEAD(sq_index), 4,
-			      &data);
-	printk("\nSTATUS QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_TAIL(sq_index), 4,
-			      &data);
-	printk("\nSTATUS QUEUE TAIL = %#x\n", data);
-
-}
-
-#endif
-
-struct nlm_rio_controller *to_nlm_rio_ctrl(struct rio_mport *mport)
-{
-	int i;
-	for (i = 0; i < MAX_SRIO_PORTS; i++) {
-		if (rio_controller[i]) {
-			if (rio_controller[i]->port == mport)
-				return rio_controller[i];
-		}
-	}
-	return NULL;
-}
-
-/**
- * rio_open_outb_mbox - Initialize outbound mailbox
- * @mport: Master port implementing the outbound message unit
- * @dev_id: Device specific pointer to pass on event
- * @mbox: Mailbox to open
- * @entries: Number of entries in the outbound mailbox ring
- *
- * Initializes buffer ring, request the outbound message interrupt,
- * and enables the outbound message unit. Returns %0 on success and
- * %-EINVAL or %-ENOMEM on failure.
- */
-int rio_open_outb_mbox(struct rio_mport *mport, void *dev_id, int mbox,
-		       int entries)
-{
-	struct nlm_rio_controller *rio_ctrl = to_nlm_rio_ctrl(mport);
-	int ret = 0;
-	uint32_t data;
-
-	MYDBG("Called");
-
-	if (entries < 4) {
-		printk("Minimum entries have to be 4\n");
-		return -1;
-	}
-
-	if (mbox != 0) {
-		printk("Invalid Resource for outb mbox - %d\n", mbox);
-		return -1;
-	}
-
-	/*setup transaction queue 0 */
-	ret = nlm_setup_transaction_queue(rio_ctrl, &rio_ctrl->tq[mbox], 0,
-					  entries);
-	if (ret)
-		return ret;
-
-	ret = nlm_setup_status_queue(rio_ctrl, &rio_ctrl->sq[mbox], 0, entries);
-
-	if (ret) {
-		nlm_clear_transaction_queue(rio_ctrl, &rio_ctrl->tq[mbox], 0);
-		return ret;
-	}
-
-	rio_ctrl->tq[mbox].curr_free_tq_entry = 0;
-	rio_ctrl->sq[mbox].curr_sq_index = 0;
-
-	/*Store max entries for this tq & sq */
-	rio_ctrl->tq[mbox].max_entries = entries;
-	rio_ctrl->sq[mbox].max_entries = entries;
-
-	/*Store dev_id to pass during callback */
-	rio_ctrl->sq[mbox].dev_id = dev_id;
-
-	/* Enable interrupts for status queue - TX OK */
-	nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_IER, 4, &data);
-	data = data | (1 << NNE_INTR(mbox));
-	nlm_local_config_write(rio_ctrl, 0, STATUS_QUEUE_IER, 4, data);
-
-	return 0;
-}
-
-/**
- * rio_close_outb_mbox - Shut down outbound mailbox
- * @mport: Master port implementing the outbound message unit
- * @mbox: Mailbox to close
- *
- * Disables the outbound message unit, free all buffers, and
- * frees the outbound message interrupt.
- */
-void rio_close_outb_mbox(struct rio_mport *mport, int mbox)
-{
-	struct nlm_rio_controller *rio_ctrl = to_nlm_rio_ctrl(mport);
-	struct transaction_queue *tq = &rio_ctrl->tq[mbox];
-	struct status_queue *sq = &rio_ctrl->sq[mbox];
-	unsigned long flags;
-
-	Message("");
-
-	spin_lock_irqsave(&tq->lock, flags);	/*lock against xmit */
-	spin_lock(&sq->lock);	/*lock against rx */
-
-	Message("");
-	/*clear transaction queue */
-	nlm_clear_transaction_queue(rio_ctrl, tq, mbox);
-
-	Message("");
-	/*clear status queue */
-	nlm_clear_status_queue(rio_ctrl, sq, mbox);
-
-	Message("");
-	spin_unlock(&sq->lock);
-	spin_unlock_irqrestore(&tq->lock, flags);
-	return;
-}
-
-/**
- * rio_hw_add_outb_message - Add message to the outbound message queue
- * @mport: Master port with outbound message queue
- * @rdev: Target of outbound message
- * @mbox: Destination mailbox number
- * @buffer: MYDBG to add to outbound queue
- * @len: Length of message
- *
- * Adds the @buffer message to the outbound message queue. Returns
- * %0 on success or %-EINVAL on failure.
- */
-int
-rio_hw_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev, int mbox,
-			void *buffer, size_t len)
-{
-	struct nlm_rio_controller *rio_ctrl = to_nlm_rio_ctrl(mport);
-	int tq_index = 0;
-	unsigned long flags;
-	uint32_t tail_value = 0;
-	uint32_t *tail_ptr = NULL;
-	struct transaction_queue *tq = &rio_ctrl->tq[tq_index];
-	uint32_t word[6];
-	uint64_t phys64 = 0;
-	uint32_t phys = 0;
-#ifdef CONFIG_32BIT
-	uint32_t max_phys = 256 << 20;
-#else
-	uint32_t max_phys = 0xffffffff;
-#endif
-	uint32_t tran_size;
-	int retry_count = 0;
-	int destid = rdev->destid;
-
-	MYDBG("");
-	if (!tq->active)
-		return -1;
-
-	MYDBG("");
-	if (!len || (len & 0x7)) {
-		printk("\nXmit len has to be 8 byte aligned");
-		printk("\nInvalid buffer len\n");
-		return -1;
-	}
-
-	MYDBG("");
-	phys64 = virt_to_phys(buffer);
-
-	if ((phys64 > max_phys) || ((phys64 + len) > max_phys)) {
-		printk("\nInvalid xmit buffer address\n");
-#ifdef CONFIG_32BIT
-		printk("\nBuffer address has to be below 256M\n");
-#else
-		printk("\nBuffer address has to be below 4G\n");
-#endif
-		return -1;
-	}
-	phys = (uint32_t) phys64;
-	tran_size = (len / 8) - 1;
-
-      retry:
-
-	MYDBG("");
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_TAIL(tq_index), 4,
-			      &tail_value);
-	while ((tail_value & (1 << TQ_LOCK))) {
-		printk("\nTailQ - Locked- %#x\n", tail_value);
-		nlm_local_config_read(rio_ctrl, 0,
-				      TRANSACTION_QUEUE_TAIL(tq_index), 4,
-				      &tail_value);
-	}
-
-	if (tail_value & (1 << TQ_FULL)) {
-		tail_value |= (1 << TQ_LOCK);
-		printk("\nTailQ -Full - %#x\n", tail_value);
-		nlm_local_config_write(rio_ctrl, 0,
-				       TRANSACTION_QUEUE_TAIL(tq_index), 4,
-				       tail_value);
-		if (retry_count++ < 20)
-			goto retry;
-		else
-			return -1;
-	}
-
-	spin_lock_irqsave(&tq->lock, flags);
-
-	MYDBG("");
-	if (!tq->active) {
-		spin_unlock_irqrestore(&tq->lock, flags);
-		return -1;
-	}
-
-	MYDBG("");
-	tail_value = tail_value & 0xfffffff8;
-	tail_ptr = (uint32_t *) (unsigned long)CKSEG0ADDR(tail_value);
-
-#ifdef CONFIG_RAPIDIO_8_BIT_TRANSPORT
-	destid = destid & 0xff;
-	word[0] = __swab32((destid << MSG_DEST_ID) |
-			   (0 << MSG_DID_SIZE) | TYPE_MESSAGE);
-#else
-	destid = destid & 0xffff;
-	word[0] = __swab32((destid << MSG_DEST_ID) |
-			   (1 << MSG_DID_SIZE) | TYPE_MESSAGE);
-#endif
-	word[1] = __swab32(0x7 /*lower 3 bits are always set to 1 */  |
-			   tran_size << MSG_TRAN_SIZE | 0xe << MSG_SEG_SIZE |	/*256 bytes per segment */
-			   mbox << MSG_MAILBOX_NUMBER);
-	word[2] = __swab32((uint32_t) (phys));
-	word[3] = word[4] = word[5] = 0x0;
-
-	MYDBG("");
-	tail_ptr[0] = word[0];
-	tail_ptr[1] = word[1];
-	tail_ptr[2] = word[2];
-	tail_ptr[3] = word[3];
-	tail_ptr[4] = word[4];
-	tail_ptr[5] = word[5];
-	mb();
-
-	tq->curr_free_tq_entry++;
-	if (tq->curr_free_tq_entry >= tq->max_entries)
-		tq->curr_free_tq_entry = 0;
-
-	/*Kick the transcation by incrementing tail ptr */
-	tail_value += SIZE_OF_TQ_ENTRY;
-	if (tail_value > tq->end) {
-		MYDBG("Wraparound of transaction Queue %d", tq_index);
-		tail_value = tq->start;
-	}
-	tail_value = tail_value & ~0x7;
-	mb();
-	/* `sync` - make sure all data is written */
-	nlm_local_config_write(rio_ctrl, 0, TRANSACTION_QUEUE_TAIL(tq_index), 4,
-			       tail_value);
-	/*`sync` - make sure transaction is initiated */
-	mb();
-	MYDBG("");
-	spin_unlock_irqrestore(&tq->lock, flags);
-	return 0;
-}
-
-/**
- * rio_hw_get_inb_message - Fetch inbound message from the message unit
- * @mport: Master port implementing the inbound message unit
- * @mbox: Inbound mailbox number
- *
- * Gets the next available inbound message from the inbound message queue.
- * A pointer to the message is returned on success or NULL on failure.
- */
-void *rio_hw_get_inb_message(struct rio_mport *mport, int mbox)
-{
-	struct nlm_rio_controller *rio_ctrl = to_nlm_rio_ctrl(mport);
-	uint32_t head_value;
-	volatile uint32_t word[4];
-	uint32_t orig_head_value;
-	volatile uint32_t *head_ptr = NULL;
-	struct mailbox_queue *mq = &rio_ctrl->mq[mbox];
-
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_QUEUE_HEAD(mbox), 4,
-			      &head_value);
-
-	if (!(head_value & (1 << MQ_EMPTY))) {
-
-		orig_head_value = head_value;
-		head_value = head_value & 0xfffffff8;
-
-		/*Left shift by 1 to get the actual physical address. */
-		head_value = head_value << 1;
-
-		/*Give sufficient delay so that glue logic copies data */
-//      udelay(1);
-
-		head_ptr =
-		    (volatile uint32_t *)(unsigned long)CKSEG0ADDR(head_value);
-
-	      retry:
-		word[0] = __swab32(head_ptr[0]);
-		if ((word[0] >> 2 & 0xf) == 0xf) {
-			goto retry;
-		}
-		mb();
-		if (((word[0] >> 2) & 0x8)) {
-			printk("\nword[0] = %#x\n", word[0]);
-			panic("\nSRIO: dma read from freel failed!!\n");
-		}
-
-		word[1] = __swab32(head_ptr[1]);
-		word[2] = __swab32(head_ptr[2]);
-		word[3] = __swab32(head_ptr[3]);
-
-#ifdef NLM_SRIO_DEBUG
-		if (((word[0] >> 2) & 0xf) != 0) {
-			printk
-			    ("\nMailbox Transaction turned in to an error !! Error %#x",
-			     word[0] >> 2 & 0xf);
-			panic("\npanic!!");
-		}
-#endif
-		head_ptr[0] = 0xffffffff;
-		mb();
-		/*Move head pointer ahead */
-		head_value += SIZE_OF_MQ_ENTRY;
-
-		/*Glue logic needs address to be right shifted by 1 */
-		head_value = head_value >> 1;
-
-		if (head_value > mq->end) {
-			head_value = mq->start;
-			MYDBG("Wraparound of Status Queue %d", sq_index);
-		}
-		nlm_local_config_write(rio_ctrl, 0, MAILBOX_QUEUE_HEAD(mbox), 4,
-				       head_value);
-
-		return phys_to_virt(word[2]);
-	}
-	return NULL;
-}
-
-/**
- * rio_hw_add_inb_buffer - Add buffer to the inbound message queue
- * @mport: Master port implementing the inbound message unit
- * @mbox: Inbound mailbox number
- * @buf: Buffer to add to inbound queue
- *
- * Assumes buffer size 4KB
- * Adds the @buf buffer to the inbound message queue. Returns
- * %0 on success or %-EINVAL on failure.
- */
-int rio_hw_add_inb_buffer(struct rio_mport *mport, int mbox, void *buf)
-{
-	struct nlm_rio_controller *rio_ctrl = to_nlm_rio_ctrl(mport);
-	unsigned long flags;
-	uint32_t tail_value = 0;
-	uint32_t *tail_ptr = NULL;
-	struct freel_queue *fq = &rio_ctrl->fq[mbox];
-	uint32_t word[2];
-	uint64_t phys64 = 0;
-	uint32_t phys = 0;
-#ifdef CONFIG_32BIT
-	uint32_t max_phys = 256 << 20;
-#else
-	uint32_t max_phys = 0xffffffff;
-#endif
-	int retry_count = 0;
-	int len = 4096;
-
-	if (!fq->active)
-		return -1;
-
-	phys64 = virt_to_phys(buf);
-
-	if ((unsigned long long)phys64 & 0x7ULL) {
-		printk("Invalid inb buffer address - %#llx\n",
-		       (unsigned long long)phys64);
-		return -1;
-	}
-
-	if ((phys64 > max_phys) || ((phys64 + len) > max_phys)) {
-		printk("\nInvalid xmit buffer address\n");
-#ifdef CONFIG_32BIT
-		printk("\nBuffer address has to be below 256M\n");
-#else
-		printk("\nBuffer address has to be below 4G\n");
-#endif
-		return -1;
-	}
-
-	phys = (uint32_t) phys64;
-
-      retry:
-
-	nlm_local_config_read(rio_ctrl, 0, FREEL_QUEUE_TAIL(mbox), 4,
-			      &tail_value);
-	while ((tail_value & (1 << FQ_LOCK))) {
-		printk("\nTailQ - Locked- %#x\n", tail_value);
-		nlm_local_config_read(rio_ctrl, 0, FREEL_QUEUE_TAIL(mbox),
-				      4, &tail_value);
-	}
-
-	if (tail_value & (1 << FQ_FULL)) {
-		tail_value |= (1 << FQ_LOCK);
-		printk("\nTailQ -Full - %#x\n", tail_value);
-		nlm_local_config_write(rio_ctrl, 0,
-				       FREEL_QUEUE_TAIL(mbox), 4, tail_value);
-		if (retry_count++ < 20) {
-			goto retry;
-		} else {
-			printk("\nFQ is full!! can't enqueue message.\n");
-			return -1;
-		}
-	}
-
-	spin_lock_irqsave(&fq->lock, flags);
-
-	if (!fq->active) {
-		spin_unlock_irqrestore(&fq->lock, flags);
-		return -1;
-	}
-
-	tail_value = tail_value & 0xfffffff8;
-	tail_ptr = (uint32_t *) (unsigned long)CKSEG0ADDR(tail_value);
-
-	word[0] = __swab32(phys);
-	word[1] = 0x0;
-
-	tail_ptr[0] = word[0];
-	tail_ptr[1] = word[1];
-	mb();
-
-	/*Kick the transcation by incrementing tail ptr */
-	tail_value += SIZE_OF_FQ_ENTRY;
-	if (tail_value > fq->end) {
-		MYDBG("Wraparound of transaction Queue %d", mbox);
-		tail_value = fq->start;
-	}
-	tail_value = tail_value & ~0x7;
-	mb();
-	/* `sync` - make sure all data is written */
-	nlm_local_config_write(rio_ctrl, 0, FREEL_QUEUE_TAIL(mbox), 4,
-			       tail_value);
-	/*`sync` - make sure transaction is initiated */
-	mb();
-	spin_unlock_irqrestore(&fq->lock, flags);
-
-	return 0;
-}
-
-/**
- * rio_open_inb_mbox - Initialize inbound mailbox
- * @mport: Master port implementing the inbound message unit
- * @dev_id: Device specific pointer to pass on event
- * @mbox: Mailbox to open
- * @entries: Number of entries in the inbound mailbox ring
- *
- * Initializes buffer ring, request the inbound message interrupt,
- * and enables the inbound message unit. Returns %0 on success
- * and %-EINVAL or %-ENOMEM on failure.
- */
-int rio_open_inb_mbox(struct rio_mport *mport, void *dev_id, int mbox,
-		      int entries)
-{
-	struct nlm_rio_controller *rio_ctrl = to_nlm_rio_ctrl(mport);
-	struct mailbox_queue *mq = &rio_ctrl->mq[mbox];
-	struct freel_queue *fq = &rio_ctrl->fq[mbox];
-	int ret = 0;
-
-	MYDBG("Called");
-
-	if (entries < 4) {
-		printk("Minimum entries have to be 4\n");
-		return -1;
-	}
-
-	if (mbox < 0 || mbox > 3) {
-		printk("Invalid Resource for outb mbox - %d\n", mbox);
-		return -1;
-	}
-
-	ret = nlm_setup_mailbox_queue(rio_ctrl, mq, mbox, entries);
-	if (ret)
-		return -1;
-
-	ret = nlm_setup_freel_queue(rio_ctrl, fq, mbox, entries);
-	if (ret) {
-		nlm_clear_mailbox_queue(rio_ctrl, mq, mbox);
-		return -1;
-	}
-
-	/*Store max entries for this tq & sq */
-	rio_ctrl->mq[mbox].max_entries = entries;
-	rio_ctrl->fq[mbox].max_entries = entries;
-
-	/*Store dev_id to pass during callback */
-	rio_ctrl->mq[mbox].dev_id = dev_id;
-
-	return 0;
-}
-
-int nlm_clear_mailbox_queue(struct nlm_rio_controller *rio_ctrl,
-			    struct mailbox_queue *mq, int mq_index)
-{
-	uint32_t data;
-	unsigned long flags;
-
-	spin_lock_irqsave(&rio_ctrl->mailbox_lock, flags);
-
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_CONTROL_1, 4, &data);
-	data = data & ~(1 << CONFIGURE_MQUEUE(mq_index));
-	nlm_local_config_write(rio_ctrl, 0, MAILBOX_CONTROL_1, 4, data);
-
-	mq->active = 0;
-
-	/*Disable NNE interrupt */
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_INT_EN_3, 4, &data);
-	data = data & ~(1 << mq_index);
-	nlm_local_config_write(rio_ctrl, 0, MAILBOX_INT_EN_3, 4, data);
-
-	kfree(mq->orig);
-
-	spin_unlock_irqrestore(&rio_ctrl->mailbox_lock, flags);
-
-	return 0;
-}
-
-int nlm_clear_freel_queue(struct nlm_rio_controller *rio_ctrl,
-			  struct freel_queue *fq, int fq_index)
-{
-	uint32_t data;
-	unsigned long flags;
-	fq->active = 0;
-
-	spin_lock_irqsave(&rio_ctrl->freel_lock, flags);
-
-	nlm_local_config_read(rio_ctrl, 0, FREEL_CONTROL_REG, 4, &data);
-	data = data & ~(1 << CONFIGURE_FLQUEUE(fq_index));
-	nlm_local_config_write(rio_ctrl, 0, FREEL_CONTROL_REG, 4, data);
-
-	kfree(fq->orig);
-
-	spin_unlock_irqrestore(&rio_ctrl->freel_lock, flags);
-	return 0;
-}
-
-/**
- * rio_close_inb_mbox - Shut down inbound mailbox
- * @mport: Master port implementing the inbound message unit
- * @mbox: Mailbox to close
- *
- * Disables the inbound message unit, free all buffers, and
- * frees the inbound message interrupt.
- */
-void rio_close_inb_mbox(struct rio_mport *mport, int mbox)
-{
-	struct nlm_rio_controller *rio_ctrl = to_nlm_rio_ctrl(mport);
-	struct mailbox_queue *mq = &rio_ctrl->mq[mbox];
-	struct freel_queue *fq = &rio_ctrl->fq[mbox];
-	unsigned long flags;
-
-	MYDBG("Called");
-
-	spin_lock_irqsave(&mq->lock, flags);	/*lock against xmit */
-	spin_lock(&fq->lock);	/*lock against rx */
-
-	nlm_clear_mailbox_queue(rio_ctrl, mq, mbox);
-	nlm_clear_freel_queue(rio_ctrl, fq, mbox);
-
-	spin_unlock(&fq->lock);	/*lock against rx */
-	spin_unlock_irqrestore(&mq->lock, flags);	/*lock against xmit */
-	return;
-}
-
-int nlm_setup_mailbox_queue(struct nlm_rio_controller *rio_ctrl,
-			    struct mailbox_queue *mq, int mq_index,
-			    int mq_entries)
-{
-	uint32_t phys = 0x0;
-	uint32_t size = SIZE_OF_MQ_ENTRY * mq_entries;
-	uint32_t data;
-	static int max_mailbox_number = 0;
-	unsigned long flags;
-
-	mq->orig = kmalloc(size + SMP_CACHE_BYTES, GFP_KERNEL | GFP_DMA);
-
-	if (!mq->orig)
-		return -ENOMEM;
-
-	memset(mq->orig, 0xff, size + SMP_CACHE_BYTES);
-
-	phys = virt_to_phys(mq->orig);
-
-	if (phys & (SMP_CACHE_BYTES - 1))
-		phys = (phys + SMP_CACHE_BYTES) & ~0x1f;
-
-	/*Glue logic needs address to be right shifted by 1 */
-	mq->start = phys >> 1;
-	mq->end = (phys + size - SIZE_OF_SQ_ENTRY) >> 1;
-
-	/*Configure MQ Start and End pointers */
-	nlm_local_config_write(rio_ctrl, 0, MAILBOX_QUEUE_START(mq_index), 4,
-			       mq->start);
-	nlm_local_config_write(rio_ctrl, 0, MAILBOX_QUEUE_END(mq_index), 4,
-			       mq->end);
-
-	/*Set MQ Upper pointer to 0 */
-	nlm_local_config_write(rio_ctrl, 0, MAILBOX_QUEUE_UPTR(mq_index), 4, 0);
-
-	if (max_mailbox_number == 0) {
-		/*Configure MAX Mailbox number */
-		max_mailbox_number = MAX_MAILBOX_Q - 1;
-		nlm_local_config_write(rio_ctrl, 0, MAILBOX_CONTROL_3, 4,
-				       max_mailbox_number << HIGH_MAILB_NO);
-	}
-
-	spin_lock_irqsave(&rio_ctrl->mailbox_lock, flags);
-
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_CONTROL_1, 4, &data);
-	data = data | (1 << CONFIGURE_MQUEUE(mq_index));
-	nlm_local_config_write(rio_ctrl, 0, MAILBOX_CONTROL_1, 4, data);
-
-	mq->active = 1;
-
-	/*Enable NNE interrupt */
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_INT_EN_3, 4, &data);
-	data = data | (1 << mq_index);
-	nlm_local_config_write(rio_ctrl, 0, MAILBOX_INT_EN_3, 4, data);
-
-#ifdef NLM_SRIO_DEBUG
-	dump_mq_regs(rio_ctrl, mq, mq_index);
-#endif
-	spin_unlock_irqrestore(&rio_ctrl->mailbox_lock, flags);
-
-	spin_lock_init(&mq->lock);
-	return 0;
-}
-
-int nlm_setup_freel_queue(struct nlm_rio_controller *rio_ctrl,
-			  struct freel_queue *fq, int fq_index, int fq_entries)
-{
-	uint32_t phys = 0x0;
-	uint32_t size = SIZE_OF_FQ_ENTRY * fq_entries;
-	uint32_t data;
-	unsigned long flags;
-
-	fq->orig = kmalloc(size + SMP_CACHE_BYTES, GFP_KERNEL | GFP_DMA);
-
-	if (!fq->orig)
-		return -ENOMEM;
-
-	phys = virt_to_phys(fq->orig);
-
-	if (phys & (SMP_CACHE_BYTES - 1))
-		phys = (phys + SMP_CACHE_BYTES) & ~0x1f;
-
-	fq->start = phys;
-	fq->end = phys + size - SIZE_OF_FQ_ENTRY;
-
-	phys = (uint32_t) virt_to_phys((void *)(unsigned long)fq->start);
-
-	/*Configure FQ Start and End pointers */
-	nlm_local_config_write(rio_ctrl, 0, FREEL_QUEUE_START(fq_index), 4,
-			       fq->start);
-	nlm_local_config_write(rio_ctrl, 0, FREEL_QUEUE_END(fq_index), 4,
-			       fq->end);
-
-	/*Set FQ Upper pointer to 0 */
-	nlm_local_config_write(rio_ctrl, 0, FREEL_QUEUE_UPTR(fq_index), 4, 0);
-
-	/*Freelist buff size */
-	nlm_local_config_write(rio_ctrl, 0, FREEL_BUF_SIZE(fq_index), 4,
-			       511 << FL_BUF_SIZE);
-
-	fq->active = 1;
-	/*Configure freelist q */
-
-	spin_lock_irqsave(&rio_ctrl->freel_lock, flags);
-
-	nlm_local_config_read(rio_ctrl, 0, FREEL_CONTROL_REG, 4, &data);
-	data = data | (1 << CONFIGURE_FLQUEUE(fq_index));
-	nlm_local_config_write(rio_ctrl, 0, FREEL_CONTROL_REG, 4, data);
-
-#ifdef NLM_SRIO_DEBUG
-	dump_fq_regs(rio_ctrl, fq, fq_index);
-#endif
-	spin_unlock_irqrestore(&rio_ctrl->freel_lock, flags);
-
-	spin_lock_init(&fq->lock);
-
-	return 0;
-}
-
-int nlm_clear_transaction_queue(struct nlm_rio_controller *rio_ctrl,
-				struct transaction_queue *tq, int tq_index)
-{
-	uint32_t data;
-	tq->active = 0;
-
-	/*disable transaction queue */
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_CTRL_1, 4, &data);
-	data = data & ~(1 << CONFIGURE_TQUEUE(tq_index));
-	nlm_local_config_write(rio_ctrl, 0, TRANSACTION_QUEUE_CTRL_1, 4, data);
-
-#ifdef NLM_SRIO_DEBUG
-	dump_tq_regs(rio_ctrl, tq, tq_index);
-#endif
-
-	kfree(tq->orig);
-	return 0;
-}
-
-int nlm_clear_status_queue(struct nlm_rio_controller *rio_ctrl,
-			   struct status_queue *sq, int sq_index)
-{
-	uint32_t data;
-	sq->active = 0;
-
-	/* Disable status q interrupt */
-	nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_IER, 4, &data);
-	data = data & ~(1 << NNE_INTR(sq_index));
-	nlm_local_config_write(rio_ctrl, 0, STATUS_QUEUE_IER, 4, data);
-
-#ifdef NLM_SRIO_DEBUG
-	dump_sq_regs(rio_ctrl, sq, sq_index);
-#endif
-
-	/*disable status queue */
-	nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_CTRL, 4, &data);
-	data = data & ~(1 << CONFIGURE_SQUEUE(sq_index));
-	nlm_local_config_write(rio_ctrl, 0, STATUS_QUEUE_CTRL, 4, data);
-	kfree(sq->orig);
-
-	return 0;
-}
-
-int nlm_setup_transaction_queue(struct nlm_rio_controller *rio_ctrl,
-				struct transaction_queue *tq, int tq_index,
-				int tq_entries)
-{
-	uint32_t phys = 0x0;
-	uint32_t size = SIZE_OF_TQ_ENTRY * tq_entries;
-	uint32_t data;
-
-	tq->orig = kmalloc(size + SMP_CACHE_BYTES, GFP_KERNEL | GFP_DMA);
-
-	if (!tq->orig)
-		return -ENOMEM;
-
-	phys = virt_to_phys(tq->orig);
-
-	if (phys & (SMP_CACHE_BYTES - 1))
-		phys = (phys + SMP_CACHE_BYTES) & ~0x1f;
-
-	tq->start = phys;
-	tq->end = phys + size - SIZE_OF_TQ_ENTRY;
-
-#if 0
-	/*Below are internal pointers. */
-	tq->head = phys;
-	tq->tail = phys + size - SIZE_OF_TQ_ENTRY;
-#endif
-
-	phys = (uint32_t) virt_to_phys((void *)(unsigned long)tq->start);
-
-	/*Configure TQ Start and End pointers */
-	nlm_local_config_write(rio_ctrl, 0, TRANSACTION_QUEUE_START(tq_index),
-			       4, tq->start);
-	nlm_local_config_write(rio_ctrl, 0, TRANSACTION_QUEUE_END(tq_index), 4,
-			       tq->end);
-
-	/*Set TQ Upper pointer to 0 */
-	nlm_local_config_write(rio_ctrl, 0, TRANSACTION_QUEUE_UPTR(tq_index), 4,
-			       0);
-	/*Configure and Enable TQ */
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_CTRL_1, 4, &data);
-	data = data | (1 << CONFIGURE_TQUEUE(tq_index)) | (1 << ENABLE_QUEUE);
-	nlm_local_config_write(rio_ctrl, 0, TRANSACTION_QUEUE_CTRL_1, 4, data);
-
-	tq->active = 1;
-
-#ifdef NLM_SRIO_DEBUG
-	dump_tq_regs(rio_ctrl, tq, tq_index);
-#endif
-
-	spin_lock_init(&tq->lock);
-
-	return 0;
-}
-
-int nlm_setup_status_queue(struct nlm_rio_controller *rio_ctrl,
-			   struct status_queue *sq, int sq_index,
-			   int sq_entries)
-{
-	uint32_t phys = 0x0;
-	uint32_t size = SIZE_OF_SQ_ENTRY * sq_entries;
-	uint32_t data;
-
-	sq->orig = kmalloc(size + SMP_CACHE_BYTES, GFP_KERNEL | GFP_DMA);
-
-	if (!sq->orig)
-		return -ENOMEM;
-
-	memset(sq->orig, 0xff, size + SMP_CACHE_BYTES);
-
-	phys = virt_to_phys(sq->orig);
-
-	if (phys & (SMP_CACHE_BYTES - 1))
-		phys = (phys + SMP_CACHE_BYTES) & ~0x1f;
-
-	/*Glue logic needs address to be right shifted by 1 */
-	sq->start = phys >> 1;
-	sq->end = (phys + size - SIZE_OF_SQ_ENTRY) >> 1;
-
-	/*Configure SQ Start and End pointers */
-	nlm_local_config_write(rio_ctrl, 0, STATUS_QUEUE_START(sq_index), 4,
-			       sq->start);
-	nlm_local_config_write(rio_ctrl, 0, STATUS_QUEUE_END(sq_index), 4,
-			       sq->end);
-
-	/*Set SQ Upper pointer to 0 */
-	nlm_local_config_write(rio_ctrl, 0, STATUS_QUEUE_UPTR(sq_index), 4, 0);
-
-	/*Configure and Enable SQ */
-	nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_CTRL, 4, &data);
-	data = data | (1 << CONFIGURE_SQUEUE(sq_index));
-	nlm_local_config_write(rio_ctrl, 0, STATUS_QUEUE_CTRL, 4, data);
-
-	sq->active = 1;
-
-#ifdef NLM_SRIO_DEBUG
-	dump_sq_regs(rio_ctrl, sq, sq_index);
-#endif
-
-	spin_lock_init(&sq->lock);
-
-	return 0;
-}
-
-#if 0
-int nlm_setup_maint_trans_rsrc_test(struct nlm_rio_controller *rio_ctrl)
-{
-	int ret = 0;
-	uint32_t data;
-
-	/*Init maintainence transaction lock. */
-	spin_lock_init(&rio_ctrl->maintenance_lock);
-
-	ret = nlm_setup_transaction_queue(rio_ctrl, &rio_ctrl->tq[1], 1, 16);
-	if (ret)
-		return ret;
-
-	printk("\nAllocated buffer for tq = %#x\n", rio_ctrl->tq[1].start);
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_HEAD(1), 4, &data);
-	printk("\nTRANSACTION QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_TAIL(1), 4, &data);
-	nlm_local_config_write(rio_ctrl, 0, TRANSACTION_QUEUE_TAIL(1), 4,
-			       data | 0x1);
-	printk("\nTRANSACTION QUEUE TAIL = %#x\n", data);
-
-	printk("\nDisableing Transaction Q Config bit for testing...\n");
-
-	/*Disable config bit */
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_CTRL_1, 4, &data);
-	data = data & ~(1 << CONFIGURE_TQUEUE(1));
-	nlm_local_config_write(rio_ctrl, 0, TRANSACTION_QUEUE_CTRL_1, 4, data);
-
-	printk("\nReconfiguring Transaction Queue for testing...\n");
-	ret = nlm_setup_transaction_queue(rio_ctrl, &rio_ctrl->tq[1], 1, 16);
-	if (ret)
-		return ret;
-
-	printk("\nNew Allocated buffer for tq = %#x\n", rio_ctrl->tq[1].start);
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_HEAD(1), 4, &data);
-	printk("\nNew TRANSACTION QUEUE HEAD = %#x\n", data);
-	nlm_local_config_read(rio_ctrl, 0, TRANSACTION_QUEUE_TAIL(1), 4, &data);
-	printk("\nNew TRANSACTION QUEUE TAIL = %#x\n", data);
-//    ret = nlm_setup_status_queue(rio_ctrl,&rio_ctrl->sq[1], 1, 16);
-//    if(ret)
-//        return ret;
-
-	return ret;
-}
-#endif
-
-int nlm_setup_maint_trans_rsrc(struct nlm_rio_controller *rio_ctrl)
-{
-	int ret = 0;
-
-	/*Init maintainence transaction lock. */
-	spin_lock_init(&rio_ctrl->maintenance_lock);
-
-	ret = nlm_setup_transaction_queue(rio_ctrl, &rio_ctrl->tq[1], 1, 16);
-	if (ret)
-		return ret;
-
-	ret = nlm_setup_status_queue(rio_ctrl, &rio_ctrl->sq[1], 1, 16);
-	if (ret) {
-		nlm_clear_transaction_queue(rio_ctrl, &rio_ctrl->tq[1], 1);
-		return ret;
-	}
-
-	return ret;
-}
-
-/**
- * nlm_local_rio_config_read - Generate a XLS local config space read
- * @pindex: ID of RapdiIO interface
- * @offset: Offset into configuration space
- * @len: Length (in bytes) of the maintenance transaction
- * @data: Value to be read into
- *
- * Generates a XLS local configuration space read. Returns %0 on
- * success or %-EINVAL on failure.
- */
-int nlm_local_config_read(struct nlm_rio_controller *rio_ctrl,
-			  int pindex, u32 offset, int len, u32 * data)
-{
-    unsigned long virt = rio_ctrl->regs_virt_start;
-	MYDBG("nlm_local_config_read: index %d offset %8.8x\n", pindex,
-		 offset);
-#ifdef CONFIG_64BIT
-	*data = *(u32 *)(unsigned long)(virt + offset);
-#else
-	*data = *(u32 *)(u32)(virt + offset);
-#endif
-	return 0;
-}
-
-/**
- * nlm_local_rio_config_write - Generate a XLS local config space write
- * @index: ID of RapdiIO interface
- * @offset: Offset into configuration space
- * @len: Length (in bytes) of the maintenance transaction
- * @data: Value to be written
- *
- * Generates a XLS local configuration space write. Returns %0 on
- * success or %-EINVAL on failure.
- */
-int nlm_local_config_write(struct nlm_rio_controller *rio_ctrl,
-			   int pindex, u32 offset, int len, u32 data)
-{
-	unsigned long virt = rio_ctrl->regs_virt_start;
-	MYDBG("nlm_local_config_write: index %d offset %8.8x\n", pindex,
-		 offset);
-#ifdef CONFIG_64BIT
-    *(u32 *)(unsigned long)(virt + offset) = data;
-#else
-    *(u32 *)(u32)(virt + offset) = data;
-#endif
-    return 0;
-}
-
-int setup_maint_tq_entry(struct nlm_rio_controller *rio_ctrl,
-			 int pindex, int tq_index, int type, u16 destid,
-			 u8 hopcount, u32 offset, int len, u32 phys)
-{
-	int words = 0;
-	uint32_t tail_value = 0;
-	uint32_t *tail_ptr = NULL;
-	struct transaction_queue *tq = &rio_ctrl->tq[tq_index];
-	uint32_t word[6];
-
-      retry:
-	nlm_local_config_read(rio_ctrl, pindex,
-			      TRANSACTION_QUEUE_TAIL(tq_index), 4, &tail_value);
-	while ((tail_value & (1 << TQ_LOCK))) {
-		printk("\nTailQ - Locked- %#x\n", tail_value);
-		nlm_local_config_read(rio_ctrl, pindex,
-				      TRANSACTION_QUEUE_TAIL(tq_index), 4,
-				      &tail_value);
-	}
-
-	if (tail_value & (1 << TQ_FULL)) {
-		tail_value |= (1 << TQ_LOCK);
-		printk("\nTailQ -Full - %#x\n", tail_value);
-		nlm_local_config_write(rio_ctrl, pindex,
-				       TRANSACTION_QUEUE_TAIL(tq_index), 4,
-				       tail_value);
-		goto retry;
-	}
-
-	tail_value = tail_value & 0xfffffff8;
-	tail_ptr = (uint32_t *) (unsigned long)CKSEG0ADDR(tail_value);
-
-#ifdef CONFIG_RAPIDIO_8_BIT_TRANSPORT
-	destid = destid & 0xff;
-	word[0] = __swab32((destid << MAINT_DEST_ID) |
-			   (0 << MAINT_DID_SIZE) | type);
-#else
-	destid = destid & 0xffff;
-	word[0] = __swab32((destid << MAINT_DEST_ID) |
-			   (1 << MAINT_DID_SIZE) | type);
-#endif
-	word[1] = __swab32((words << MAINT_TRANS_SIZE) |
-			   (0x3 << MAINT_TRANS_DEFAULT_BITS));
-	word[2] = __swab32((uint32_t) (phys));
-	word[3] = __swab32((hopcount << MAINT_HOP_COUNT) | (offset >> 2));
-	word[4] = word[5] = 0x0;
-
-	tail_ptr[0] = word[0];
-	tail_ptr[1] = word[1];
-	tail_ptr[2] = word[2];
-	tail_ptr[3] = word[3];
-	tail_ptr[4] = word[4];
-	tail_ptr[5] = word[5];
-	mb();
-	/*Kick the transcation by incrementing tail ptr */
-	tail_value += SIZE_OF_TQ_ENTRY;
-	if (tail_value > tq->end) {
-		MYDBG("Wraparound of transaction Queue %d", tq_index);
-		tail_value = tq->start;
-	}
-	tail_value = tail_value & ~0x7;
-	mb();
-	/*`sync` - make sure all data is written */
-	nlm_local_config_write(rio_ctrl, pindex,
-			       TRANSACTION_QUEUE_TAIL(tq_index), 4, tail_value);
-	/*`sync` - make sure transaction is initiated */
-	mb();
-	return 0;
-}
-
-int check_maint_sq_entry(struct nlm_rio_controller *rio_ctrl,
-			 int pindex, int sq_index, int type,
-			 u16 destid, u32 phys)
-{
-	uint32_t head_value = 0;
-	uint32_t *head_ptr = NULL;
-	struct status_queue *sq = &rio_ctrl->sq[sq_index];
-	uint32_t word[4];
-	uint32_t orig_head_value;
-
-	nlm_local_config_read(rio_ctrl, pindex, STATUS_QUEUE_HEAD(sq_index), 4,
-			      &head_value);
-	while (head_value & (1 << SQ_EMPTY)) {
-		mdelay(5);
-//      printk("\nStatusQ Is empty yet.. %#x\n",head_value);
-		nlm_local_config_read(rio_ctrl, pindex,
-				      STATUS_QUEUE_HEAD(sq_index), 4,
-				      &head_value);
-	}
-	orig_head_value = head_value;
-	head_value = head_value & 0xfffffff8;
-	/*Left shift by 1 to get the actual physical address. */
-	head_value = head_value << 1;
-
-	/*Give sufficient delay so that glue logic copies data */
-	udelay(1);
-
-	head_ptr = (uint32_t *) (unsigned long)CKSEG0ADDR(head_value);
-	word[0] = __swab32(head_ptr[0]);
-	word[1] = __swab32(head_ptr[1]);
-	word[2] = __swab32(head_ptr[2]);
-	word[3] = __swab32(head_ptr[3]);
-	mb();
-
-#ifdef NLM_SRIO_DEBUG
-	/*Check the transaction type is expected or not. */
-	if ((word[0] & 0x1f) != type) {
-		printk("\nhead_value = %#x\n", orig_head_value);
-		printk("word0=%#x, word1=%#x, word2=%#x, word3=%#x\n",
-		       word[0], word[1], word[2], word[3]);
-		printk("\nUnexpected Transaction %#x instead of %#x \n",
-		       word[0] & 0x1f, type);
-		panic("\npanic!!");
-	}
-
-	if (((word[0] >> 12) & 0xf) != 0) {
-		printk("\nTransaction turned in to an error !! Error %#x",
-		       word[0] >> 12 & 0xf);
-		panic("\npanic!!");
-	}
-	/*Check the phy address in response */
-	if (word[2] != phys) {
-		printk
-		    ("\n!!!Got the result for phys address %#x instead of %#x\n",
-		     word[2], phys);
-		panic("\npanic!!");
-	}
-#endif
-
-	/*Move head pointer ahead */
-	head_value += SIZE_OF_SQ_ENTRY;
-
-	/*Glue logic needs address to be right shifted by 1 */
-	head_value = head_value >> 1;
-
-	if (head_value > sq->end) {
-		head_value = sq->start;
-		MYDBG("Wraparound of Status Queue %d", sq_index);
-	}
-	nlm_local_config_write(rio_ctrl, pindex, STATUS_QUEUE_HEAD(sq_index), 4,
-			       head_value);
-	return 0;
-}
-
-/**
- * nlm_rio_config_read - Generate a XLS read maintenance transaction
- * @index: ID of RapdiIO interface
- * @destid: Destination ID of transaction
- * @hopcount: Number of hops to target device
- * @offset: Offset into configuration space
- * @len: Length (in bytes) of the maintenance transaction
- * @val: Location to be read into
- *
- * Generates a XLS read maintenance transaction. Returns %0 on
- * success or %-EINVAL on failure.
- */
-int
-nlm_rio_config_read(struct nlm_rio_controller *rio_ctrl,
-		    int pindex, u16 destid, u8 hopcount, u32 offset, int len,
-		    u32 * val)
-{
-	u8 *data;
-	int tq_index = 1;	/*Use TQ-1 for all maint transactions. */
-	uint32_t result = 0x0;
-	uint32_t result_phys = 0x0;
-	int sq_index = 1;
-	unsigned long flags;
-	MYDBG
-	    ("index %d destid %d hopcount %d offset %8.8x len %d\n",
-	     pindex, destid, hopcount, offset, len);
-	result_phys = virt_to_phys(&result);
-
-	spin_lock_irqsave(&rio_ctrl->maintenance_lock, flags);
-
-	setup_maint_tq_entry(rio_ctrl, pindex, tq_index, TYPE_MAINTAIN_READ,
-			     destid, hopcount, offset, len, result_phys);
-
-	/*Check on the status Q for transaction completion. */
-	check_maint_sq_entry(rio_ctrl, pindex, sq_index, TYPE_MAINTAIN_READ,
-			     destid, result_phys);
-
-	spin_unlock_irqrestore(&rio_ctrl->maintenance_lock, flags);
-
-	/*Store the result back.. */
-	data = (u8 *) (unsigned long)((unsigned long)&result + (offset & 0x3));
-
-	switch (len) {
-	case 1:
-		*val = (u32) * (u8 *) data;
-		break;
-	case 2:
-		*val = (u32) * (u16 *) data;
-		break;
-	default:
-		*val = (u32) * (u32 *) data;
-		break;
-	}
-	return 0;
-}
-
-/**
- * nlm_rio_config_write - Generate a XLS write maintenance transaction
- * @index: ID of RapdiIO interface
- * @destid: Destination ID of transaction
- * @hopcount: Number of hops to target device
- * @offset: Offset into configuration space
- * @len: Length (in bytes) of the maintenance transaction
- * @val: Value to be written
- *
- * Generates an XLS write maintenance transaction. Returns %0 on
- * success or %-EINVAL on failure.
- */
-int
-nlm_rio_config_write(struct nlm_rio_controller *rio_ctrl, int pindex,
-		     u16 destid, u8 hopcount, u32 offset, int len, u32 val)
-{
-	u8 *data;
-	int tq_index = 1;	/*Use TQ-1 for all maint transactions. */
-	uint32_t r_data = 0x0;
-	uint32_t r_data_phys = 0x0;
-	int sq_index = 1;
-	unsigned long flags;
-	uint32_t w_data = 0;
-	uint32_t w_data_phys = 0;
-
-	MYDBG
-	    ("index %d destid %d hopcount %d offset %8.8x len %d\n",
-	     pindex, destid, hopcount, offset, len);
-	w_data_phys = virt_to_phys(&w_data);
-
-	/*Check if we have to do read modify write */
-	if (len == 4) {
-		w_data = val;
-		goto skip;
-	}
-
-	/*Do Read Modify Write */
-
-	printk("\nWriting unaligned data\n");
-
-	r_data_phys = virt_to_phys(&r_data);
-
-	nlm_rio_config_read(rio_ctrl, pindex, destid, hopcount, offset & ~(0x3),
-			    4, &r_data);
-
-	data = (u8 *) (unsigned long)((unsigned long)&r_data + (offset & 0x3));
-
-	switch (len) {
-	case 1:
-		*data = (u8) val;
-		w_data = r_data;
-		break;
-	case 2:
-		*(u16 *) data = (u16) val;
-		w_data = r_data;
-		break;
-	default:
-		break;
-	}
-
-      skip:
-	spin_lock_irqsave(&rio_ctrl->maintenance_lock, flags);
-
-	setup_maint_tq_entry(rio_ctrl, pindex, tq_index, TYPE_MAINTAIN_WRITE,
-			     destid, hopcount, offset, len, w_data_phys);
-
-	/*Check on the status Q for transaction completion. */
-	check_maint_sq_entry(rio_ctrl, pindex, sq_index, TYPE_MAINTAIN_WRITE,
-			     destid, w_data_phys);
-
-	spin_unlock_irqrestore(&rio_ctrl->maintenance_lock, flags);
-
-	return 0;
-}
-
-int setup_doorbell_tq_entry(struct nlm_rio_controller *rio_ctrl,
-			    int pindex, int tq_index, u16 destid, u16 data)
-{
-	uint32_t tail_value = 0;
-	uint32_t *tail_ptr = NULL;
-	struct transaction_queue *tq = &rio_ctrl->tq[tq_index];
-	uint32_t word[6];
-	int type = TYPE_DOORBELL;
-
-      retry:
-
-	nlm_local_config_read(rio_ctrl, pindex,
-			      TRANSACTION_QUEUE_TAIL(tq_index), 4, &tail_value);
-
-	while ((tail_value & (1 << TQ_LOCK))) {
-		printk("\nTailQ - Locked- %#x\n", tail_value);
-		nlm_local_config_read(rio_ctrl, pindex,
-				      TRANSACTION_QUEUE_TAIL(tq_index), 4,
-				      &tail_value);
-	}
-
-	if (tail_value & (1 << TQ_FULL)) {
-		tail_value |= (1 << TQ_LOCK);
-		printk("\nTailQ -Full - %#x\n", tail_value);
-		nlm_local_config_write(rio_ctrl, pindex,
-				       TRANSACTION_QUEUE_TAIL(tq_index), 4,
-				       tail_value);
-		goto retry;
-	}
-
-	tail_value = tail_value & 0xfffffff8;
-	tail_ptr = (uint32_t *) (unsigned long)CKSEG0ADDR(tail_value);
-
-#ifdef CONFIG_RAPIDIO_8_BIT_TRANSPORT
-	destid = destid & 0xff;
-	word[0] = __swab32((destid << MAINT_DEST_ID) |
-			   (0 << MAINT_DID_SIZE) | type);
-#else
-	destid = destid & 0xffff;
-	word[0] = __swab32((destid << MAINT_DEST_ID) |
-			   (1 << MAINT_DID_SIZE) | type);
-#endif
-	word[1] = __swab32(data << DBELL_INFO);
-	word[2] = word[3] = word[4] = word[5] = 0x0;
-
-	tail_ptr[0] = word[0];
-	tail_ptr[1] = word[1];
-	tail_ptr[2] = word[2];
-	tail_ptr[3] = word[3];
-	tail_ptr[4] = word[4];
-	tail_ptr[5] = word[5];
-	mb();
-	/*Kick the transcation by incrementing tail ptr */
-	tail_value += SIZE_OF_TQ_ENTRY;
-	if (tail_value > tq->end) {
-		MYDBG("Wraparound of transaction Queue %d", tq_index);
-		tail_value = tq->start;
-	}
-	tail_value = tail_value & ~0x7;
-	mb();
-	/*`sync` - make sure all data is written */
-	nlm_local_config_write(rio_ctrl, pindex,
-			       TRANSACTION_QUEUE_TAIL(tq_index), 4, tail_value);
-	/*`sync` - make sure transaction is initiated */
-	mb();
-
-	return 0;
-}
-
-int check_doorbell_sq_entry(struct nlm_rio_controller *rio_ctrl,
-			    int pindex, int sq_index, u16 destid)
-{
-	uint32_t head_value = 0;
-	uint32_t *head_ptr = NULL;
-	struct status_queue *sq = &rio_ctrl->sq[sq_index];
-	uint32_t word[4];
-	uint32_t orig_head_value;
-
-#ifdef NLM_SRIO_DEBUG
-	int type = TYPE_DOORBELL;
-#endif
-
-	nlm_local_config_read(rio_ctrl, pindex, STATUS_QUEUE_HEAD(sq_index), 4,
-			      &head_value);
-	while (head_value & (1 << SQ_EMPTY)) {
-		mdelay(5);
-//      printk("\nStatusQ Is empty yet.. %#x\n",head_value);
-		nlm_local_config_read(rio_ctrl, pindex,
-				      STATUS_QUEUE_HEAD(sq_index), 4,
-				      &head_value);
-	}
-	orig_head_value = head_value;
-	head_value = head_value & 0xfffffff8;
-	/*Left shift by 1 to get the actual physical address. */
-	head_value = head_value << 1;
-
-	/*Give sufficient delay so that glue logic copies data */
-	udelay(1);
-
-	head_ptr = (uint32_t *) (unsigned long)CKSEG0ADDR(head_value);
-	word[0] = __swab32(head_ptr[0]);
-	word[1] = __swab32(head_ptr[1]);
-	word[2] = __swab32(head_ptr[2]);
-	word[3] = __swab32(head_ptr[3]);
-	mb();
-#ifdef NLM_SRIO_DEBUG
-	/*Check the transaction type is expected or not. */
-	if ((word[0] & 0x1f) != type) {
-		printk("\nhead_value = %#x\n", orig_head_value);
-		printk("word0=%#x, word1=%#x, word2=%#x, word3=%#x\n",
-		       word[0], word[1], word[2], word[3]);
-		printk("\nUnexpected Transaction %#x instead of %#x \n",
-		       word[0] & 0x1f, type);
-		panic("\npanic!!");
-	}
-
-	if (((word[0] >> 12) & 0xf) != 0) {
-		printk("\nTransaction turned in to an error !! Error %#x",
-		       word[0] >> 12 & 0xf);
-//      panic("\npanic!!");
-	}
-#endif
-
-	/*Move head pointer ahead */
-	head_value += SIZE_OF_SQ_ENTRY;
-
-	/*Glue logic needs address to be right shifted by 1 */
-	head_value = head_value >> 1;
-
-	if (head_value > sq->end) {
-		head_value = sq->start;
-		MYDBG("Wraparound of Status Queue %d", sq_index);
-	}
-	nlm_local_config_write(rio_ctrl, pindex, STATUS_QUEUE_HEAD(sq_index), 4,
-			       head_value);
-	return 0;
-}
-
-/**
- * nlm_rio_doorbell_send - Send a XLS doorbell message
- * @index: ID of RapidIO interface
- * @destid: Destination ID of target device
- * @data: 16-bit info field of RapidIO doorbell message
- *
- * Sends a XLS doorbell message. Returns %0 on success or
- * %-EINVAL on failure.
- */
-int nlm_rio_doorbell_send(struct nlm_rio_controller *rio_ctrl,
-			  int pindex, u16 destid, u16 data)
-{
-	int tq_index = 1;
-	int sq_index = 1;
-	unsigned long flags;
-
-	MYDBG("index %d destid %4.4x data %4.4x\n", pindex, destid, data);
-
-	spin_lock_irqsave(&rio_ctrl->maintenance_lock, flags);
-
-	MYDBG("");
-	setup_doorbell_tq_entry(rio_ctrl, pindex, tq_index, destid, data);
-	/*Check on the status Q for transaction completion. */
-	MYDBG("");
-	check_doorbell_sq_entry(rio_ctrl, pindex, sq_index, destid);
-	MYDBG("");
-	spin_unlock_irqrestore(&rio_ctrl->maintenance_lock, flags);
-
-	return 0;
-}
-
-void doorbell_intr(struct nlm_rio_controller *rio_ctrl, struct rio_mport *port)
-{
-	uint32_t no_of_msgs = 0;
-	uint32_t data;
-	struct rio_dbell *dbell;
-	u16 info, src;
-	int found = 0;
-
-	nlm_local_config_read(rio_ctrl, 0, DOORBELL_INFO, 4, &data);
-	no_of_msgs = (data >> DFIFO_NUM) & 0xf;
-	while (no_of_msgs) {
-		nlm_local_config_read(rio_ctrl, 0, DOORBELL_READ, 4, &data);
-
-		info = data & 0xffff;
-
-#ifdef CONFIG_RAPIDIO_8_BIT_TRANSPORT
-		src = (data >> DB_SRCID) & 0xff;
-#else
-		src = (data >> DB_SRCID) & 0xffff;
-#endif
-		list_for_each_entry(dbell, &port->dbells, node) {
-			if ((dbell->res->start <= info) &&
-			    (dbell->res->end >= info)) {
-				found = 1;
-				break;
-			}
-		}
-		if (found) {
-			dbell->dinb(port, dbell->dev_id, src, -1, info);
-		} else {
-			printk("RIO: spurious doorbell, sid %2.2x info %4.4x\n",
-			       src, info);
-		}
-		no_of_msgs--;
-	}
-	return;
-}
-
-void mailbox_intr(struct nlm_rio_controller *rio_ctrl, struct rio_mport *port)
-{
-	struct mailbox_queue *mq;
-	uint32_t status;
-	int i = 0;
-
-	nlm_local_config_read(rio_ctrl, 0, MAILBOX_STATUS_3, 4, &status);
-
-	for (i = 0; i < MAX_MAILBOX_Q; i++) {
-		if (!(status & (1 << i)))
-			continue;
-		mq = &rio_ctrl->mq[i];
-
-		spin_lock(&mq->lock);
-		if (!mq->active) {
-			spin_unlock(&mq->lock);
-			continue;
-		}
-		if (port->inb_msg[i].mcback)
-			port->inb_msg[i].mcback(port, mq->dev_id, -1, -1);
-		else
-			printk("No call back for this message !! Screwed ??\n");
-		spin_unlock(&mq->lock);
-	}
-	return;
-}
-
-void statusq_intr(struct nlm_rio_controller *rio_ctrl, struct rio_mport *port)
-{
-	int sq_index = 0;
-	struct status_queue *sq = &rio_ctrl->sq[sq_index];
-	uint32_t head_value = 0;
-	uint32_t orig_head_value = 0;
-	volatile uint32_t *head_ptr = NULL;
-	volatile uint32_t word[4];
-#ifdef NLM_SRIO_DEBUG
-	uint32_t ttype;
-#endif
-
-	MYDBG("Got status q intr");
-	/*Hold a lock, so that close does not free resources */
-	spin_lock(&sq->lock);
-
-	if (!sq->active) {
-		spin_unlock(&sq->lock);
-		return;
-	}
-
-	nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_HEAD(sq_index), 4,
-			      &head_value);
-
-	while (!(head_value & (1 << SQ_EMPTY))) {
-
-		orig_head_value = head_value;
-		head_value = head_value & 0xfffffff8;
-		/*Left shift by 1 to get the actual physical address. */
-		head_value = head_value << 1;
-
-		/*Give sufficient delay so that glue logic copies data */
-//      udelay(1);
-
-		head_ptr =
-		    (volatile uint32_t *)(unsigned long)CKSEG0ADDR(head_value);
-	      retry:
-		word[0] = __swab32(head_ptr[0]);
-		if (((word[0] >> 12) & 0xf) == 0xf) {
-			goto retry;
-		}
-
-		word[1] = __swab32(head_ptr[1]);
-		word[2] = __swab32(head_ptr[2]);
-		word[3] = __swab32(head_ptr[3]);
-		mb();
-#ifdef NLM_SRIO_DEBUG
-		ttype = word[0] & 0x1f;
-		/*Check the transaction type is expected or not. */
-		if (ttype != TYPE_MESSAGE) {
-			printk("\nhead_value = %#x\n", orig_head_value);
-			printk("word0=%#x, word1=%#x, word2=%#x, word3=%#x\n",
-			       word[0], word[1], word[2], word[3]);
-			printk("\nUnexpected Transaction %#x \n",
-			       word[0] & 0x1f);
-			panic("\npanic!!");
-		}
-
-		if (((word[0] >> 12) & 0xf) != 0) {
-			printk
-			    ("\nTransaction turned in to an error !! Error %#x",
-			     word[0] >> 12 & 0xf);
-			panic("\npanic!!");
-		}
-#endif
-		head_ptr[0] = 0xffffffff;
-		mb();
-
-		/*Move head pointer ahead */
-		head_value += SIZE_OF_SQ_ENTRY;
-
-		/*Glue logic needs address to be right shifted by 1 */
-		head_value = head_value >> 1;
-
-		if (head_value > sq->end) {
-			head_value = sq->start;
-			MYDBG("Wraparound of Status Queue %d", sq_index);
-		}
-		nlm_local_config_write(rio_ctrl, 0, STATUS_QUEUE_HEAD(sq_index),
-				       4, head_value);
-
-		sq->curr_sq_index++;
-		if (sq->curr_sq_index >= sq->max_entries)
-			sq->curr_sq_index = 0;
-		/*Call the callback for msg transactions. */
-		port->outb_msg[sq_index].mcback(port, sq->dev_id, -1,
-						sq->curr_sq_index);
-
-		nlm_local_config_read(rio_ctrl, 0, STATUS_QUEUE_HEAD(sq_index),
-				      4, &head_value);
-	}
-
-	spin_unlock(&sq->lock);
-
-	return;
-}
-
-void general_intr(struct nlm_rio_controller *rio_ctrl, struct rio_mport *port)
-{
-	uint32_t gisr = 0;
-	uint32_t dma_high, dma_low, dma_info;
-	uint32_t perr_csr = 0;
-
-	nlm_local_config_read(rio_ctrl, port->index, GENERAL_INTR_STATUS_REG, 4,
-			      &gisr);
-	if (gisr & GISR_DEC) {
-		nlm_local_config_read(rio_ctrl, port->index, DMA_ERR_CAP_HIGH,
-				      4, &dma_high);
-		nlm_local_config_read(rio_ctrl, port->index, DMA_ERR_CAP_LOW, 4,
-				      &dma_low);
-		nlm_local_config_read(rio_ctrl, port->index, DMA_ERR_CAP_INFO,
-				      4, &dma_info);
-		printk("\nSRIO DMA ERROR:\n dma_high: [%#x], dma_low: [%#x],\
-                dma_info[%#x]\n", dma_high, dma_low, dma_info);
-		panic("SRIO: DMA Error");
-	}
-	if (gisr & GISR_MQWE) {
-		nlm_local_config_read(rio_ctrl, port->index, DMA_ERR_CAP_HIGH,
-				      4, &dma_high);
-		nlm_local_config_read(rio_ctrl, port->index, DMA_ERR_CAP_LOW, 4,
-				      &dma_low);
-		nlm_local_config_read(rio_ctrl, port->index, DMA_ERR_CAP_INFO,
-				      4, &dma_info);
-		printk("\nMQ DMA ERROR:\n dma_high: [%#x], dma_low: [%#x], \
-                dma_info[%#x]\n", dma_high, dma_low, dma_info);
-		panic("SRIO: MQ Error");
-	}
-	if (gisr & GISR_SQWE) {
-		nlm_local_config_read(rio_ctrl, port->index, DMA_ERR_CAP_HIGH,
-				      4, &dma_high);
-		nlm_local_config_read(rio_ctrl, port->index, DMA_ERR_CAP_LOW, 4,
-				      &dma_low);
-		nlm_local_config_read(rio_ctrl, port->index, DMA_ERR_CAP_INFO,
-				      4, &dma_info);
-		printk("\nSQ DMA ERROR:\n dma_high: [%#x], dma_low: [%#x], \
-                dma_info[%#x]\n", dma_high, dma_low, dma_info);
-		panic("SRIO: SQ Error");
-	}
-	if (gisr & GISR_PERR) {
-		printk("\nPORT ERROR!!\n");
-		nlm_local_config_read(rio_ctrl, port->index, P0_EAS_CSR, 4,
-				      &perr_csr);
-		printk("port error status register [%#x]\n", perr_csr);
-		panic("SRIO: PORT ERROR - Software Recovery not available\n");
-	}
-}
-
-irqreturn_t nlm_srio_irq_handler(int irq, void *dev_id)
-{
-	struct nlm_rio_controller *rio_ctrl =
-	    (struct nlm_rio_controller *)dev_id;
-	struct rio_mport *port = rio_ctrl->port;
-	uint32_t misr = 0;
-
-	MYDBG("");
-	/*Read MISR */
-	nlm_local_config_read(rio_ctrl, port->index, MASTER_INTR_STATUS_REG, 4,
-			      &misr);
-	if (misr & MISR_GEN) {
-		general_intr(rio_ctrl, port);
-	}
-
-	if (misr & MISR_DF) {
-		MYDBG("DF INTR");
-		doorbell_intr(rio_ctrl, port);
-	}
-
-	if (misr & MISR_MQ3) {
-		MYDBG("MQ INTR");
-		mailbox_intr(rio_ctrl, port);
-	}
-
-	if (misr & MISR_SQ) {
-		MYDBG("SQ INTR");
-		statusq_intr(rio_ctrl, port);
-	}
-
-	MYDBG("");
-	return IRQ_HANDLED;
-}
-
-void setup_controller(struct nlm_rio_controller *rio_ctrl,
-		      struct rio_mport *port, int index)
-{
-	rio_ctrl->index = index;
-	rio_ctrl->port = port;
-	rio_ctrl->irq = SRIO_IRQ(index);
-	rio_ctrl->regs_phy_start = rio_reg_phy_start[index];
-	rio_ctrl->host_deviceid = nlm_rio_host_id[index];
-	rio_ctrl->regs_virt_start =
-	    ((unsigned long)CKSEG1ADDR(rio_reg_phy_start[index]));
-	MYDBG("\nController[%d] regs starts @ [%#lx]\n", index,
-	      rio_ctrl->regs_virt_start);
-	MYDBG("\nHost device id %d\n", rio_ctrl->host_deviceid);
-}
-
-int is_rio_link_up(int index)
-{
-	unsigned long addr = CKSEG1ADDR(rio_reg_phy_start[index]);
-	uint32_t result;
-	result = *(uint32_t *) (addr + P0_EAS_CSR);
-	if (result & PORT_N_ERR_STS_PORT_OK)
-		return 1;
-	return 0;
-}
-
-int setup_rio_ops(struct rio_mport *mport, int index)
-{
-	struct rio_ops *ops = NULL;
-
-	ops = kmalloc(sizeof(struct rio_ops), GFP_KERNEL | GFP_DMA);
-
-	if (!ops) {
-		printk("Allocation failed for rio_ops!\n");
-		return -1;
-	}
-	ops->lcread = nlm_rio_ops[index][0];
-	ops->lcwrite = nlm_rio_ops[index][1];
-	ops->cread = nlm_rio_ops[index][2];
-	ops->cwrite = nlm_rio_ops[index][3];
-	ops->dsend = nlm_rio_ops[index][4];
-	mport->ops = ops;
-	return 0;
-}
-
-static int nlm_srio_glue_init_done(void)
-{
-    nlm_reg_t *srio_be_mmio = 
-                (nlm_reg_t *)(netlogic_io_base + NETLOGIC_IO_SRIO_1_OFFSET);
-    uint32_t srio_ctrl = 0x0;
-    
-    srio_ctrl = netlogic_read_reg(srio_be_mmio, SRIO_CTRL);
-    if(((srio_ctrl>>28) & 0xf) == 0x3)
-        /*Bootloader has done required glue logic init*/
-        return 1;
-    return 0;
-}
-
-void nlm_rio_setup(void)
-{
-	nlm_reg_t *gpio_mmio =
-	    (nlm_reg_t *) (netlogic_io_base + NETLOGIC_IO_GPIO_OFFSET);
-	uint32_t gpio_reset_cfg;
-	struct rio_mport *port;
-    int i = 0;
-    extern int avail_mem_above_4G;
-    struct nlm_rio_controller *rio_ctrl;
-	uint32_t srio_port_map;
-    
-    if(!is_xlsb0_srio())
-        return;
-
-    if (avail_mem_above_4G) {
-        printk("------------------------------------------------\n");
-        printk("[SRIO]: Detected DRAM above 4G\n");
-        printk("      : HW Support for DMA >32-bit Un-available. \n");
-        printk("------------------------------------------------\n");
-        return;
-    }
-
-    if(!nlm_srio_glue_init_done()){
-        printk("------------------------------------------------\n");
-        printk("SRIO Init is not done from bootloader\n");
-        printk("Skipping SRIO Initialization\n");
-        printk("------------------------------------------------\n");
-        return;
-    }
-
-    /*Check srio mode - x1 or x4*/
-    gpio_reset_cfg = 
-        netlogic_read_reg(gpio_mmio,NETLOGIC_GPIO_PWRON_RESET_CFG_REG);
-    
-    if(gpio_reset_cfg & (1<<SRIO_CFG_BIT)){
-        srio_mode = SRIO_X1_MODE;
-        srio_ports = MAX_SRIO_PORTS;
-        printk("Detected SRIO x1 mode\n");
-        printk("Detected %d SRIO ports\n",srio_ports);
-    }else{
-        srio_mode = SRIO_X4_MODE;
-        srio_ports = MIN_SRIO_PORTS;
-        printk("Detected SRIO x4 mode\n");
-        printk("Detected %d SRIO port\n",srio_ports);
-    }
-
-	if(dev_tree_en) 
-		fdt_get_srio_port_map(&srio_port_map);
-	 else 
-		srio_port_map = (1 << srio_ports) - 1;
-
-	//printk("\nsrio_port_map = %#x\n",srio_port_map);
-    for(i=0; i<srio_ports; i++){
-
-	if(!(srio_port_map & ( 1 << i)))
-		continue;
-
-        /*Check if link is up*/
-        if(!is_rio_link_up(i)){
-//          printk("\nLink %d is down!!!\n",i);
-            continue;
-        }
-
-
-        printk("SRIO link %d up\n",i);
-
-	if (gpio_reset_cfg & (1 << SRIO_CFG_BIT)) {
-		srio_mode = SRIO_X1_MODE;
-		srio_ports = MAX_SRIO_PORTS;
-		printk("Detected SRIO x1 mode\n");
-		printk("Detected %d SRIO ports\n", srio_ports);
-	} else {
-		srio_mode = SRIO_X4_MODE;
-		srio_ports = MIN_SRIO_PORTS;
-		printk("Detected SRIO x4 mode\n");
-		printk("Detected %d SRIO port\n", srio_ports);
-	}
-
-	for (i = 0; i < srio_ports; i++) {
-		/*Check if link is up */
-		if (!is_rio_link_up(i)) {
-			//printk("\nLink %d is down!!!\n",i);
-			continue;
-		}
-
-		printk("SRIO link %d up\n", i);
-
-		rio_ctrl = rio_controller[i] = kmalloc
-		    (sizeof(struct nlm_rio_controller), GFP_KERNEL | GFP_DMA);
-
-		if (!rio_ctrl)
-			goto fail;
-
-		port = kmalloc(sizeof(struct rio_mport), GFP_KERNEL | GFP_DMA);
-
-		if (!port) {
-			printk("Allocation failed for rio_mport!\n");
-			printk("Registered %d rapidio controller\n", i);
-			goto fail;
-		}
-
-		sprintf(port->name, "RIO%d mport", i);
-
-		port->id = 0;
-		port->index = 0;
-		INIT_LIST_HEAD(&port->dbells);
-
-		port->phy_type = RIO_PHY_SERIAL;
-		port->sys_size = 1;	/*Controller supports 16bit transport addressing*/
-		port->host_deviceid = rio_ctrl->host_deviceid;
-
-		setup_controller(rio_ctrl, port, i);
-
-		port->iores.start = rio_ctrl->regs_phy_start;
-		port->iores.end = rio_ctrl->regs_phy_start + NLM_SRIO_MEM_SIZE;
-		port->iores.flags = IORESOURCE_MEM;
-
-		rio_init_dbell_res(&port->riores[RIO_DOORBELL_RESOURCE], 0,
-				   0xffff);
-		rio_init_mbox_res(&port->riores[RIO_INB_MBOX_RESOURCE], 0, 3);
-		rio_init_mbox_res(&port->riores[RIO_OUTB_MBOX_RESOURCE], 0, 0);
-
-		port->host_deviceid = rio_ctrl->host_deviceid;
-
-		/*Enable Output, Input and Multicast event partcipant */
-		nlm_local_config_write(rio_ctrl, port->index, P0_CTRL_CSR, 4,
-				       (1 << OUTPUT_PORT_EN) | (1 <<
-								INPUT_PORT_EN) |
-				       (1 << MULTI_EVENT_EN));
-
-		/*
-		   Setup resources for maintenance transactions.
-		   -setup Transaction Queue 1
-		   -setup Status Queue 1
-		 */
-		if (nlm_setup_maint_trans_rsrc(rio_ctrl))
-			goto fail;
-
-		/*Register irq for controller. */
-		if (request_irq
-		    (rio_ctrl->irq, nlm_srio_irq_handler, IRQF_DISABLED,
-		     rio_ctrl->port->name, rio_ctrl))
-			panic("Can't reserve srio irq!!");
-
-		/*Enable GENERL ERROR INTERRUPTS */
-		nlm_local_config_write(rio_ctrl, rio_ctrl->port->index,
-				       GENERAL_INTR_ENABLE_REG, 4,
-				       (1 << GIER_PERR) | (1 << GIER_DEC) |
-				       (1 << GIER_MQWE) | (1 << GIER_SQWE));
-		/*Enable MIER for SQ, MQ3 and DF */
-		nlm_local_config_write(rio_ctrl, rio_ctrl->port->index,
-				       MASTER_INTR_ENABLE_REG, 4,
-				       (1 << MIER_DF) | (1 << MIER_MQ3) | (1 <<
-									   MIER_SQ)
-				       | (1 << MIER_GEN));
-#if 0
-		nlm_setup_maint_trans_rsrc_test(rio_ctrl);
-		continue;
-#endif
-		/*Enable doorbell interrupts. Kernel doesn't give us any hook!! */
-		nlm_local_config_write(rio_ctrl, rio_ctrl->port->index,
-				       DOORBELL_INTR, 4, (1 << DB_NNE));
-
-		spin_lock_init(&rio_ctrl->mailbox_lock);
-		spin_lock_init(&rio_ctrl->freel_lock);
-		rio_register_mport(port);
-	}
-
-      fail:
-	free_unregistered_resrources();
-	return;
-}
-
-void free_unregistered_resrources(void)
-{
-	struct rio_mport *port = NULL;
-	struct rio_ops *ops = NULL;
-	int i = 0;
-
-	for (i = 0; i < srio_ports; i++) {
-		/*Free all partially initalized controller data struct */
-		if (!rio_controller[i])
-			continue;
-		port = rio_controller[i]->port;
-		if (!port) {
-			kfree(rio_controller[i]);
-			continue;
-		}
-		ops = port->ops;
-		if (!ops) {
-			kfree(port);
-			kfree(rio_controller[i]);
-			continue;
-		}
-	}
-}
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index 4d9a0a7..42329dc 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -8,6 +8,8 @@
 #include <asm/mach-netlogic/kernel-entry-init.h>
 #include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 
+#define SET_MIPS64 .set mips64r2
+
 	.macro  prog_c0_status set clr
 	.set 	push
 	mfc0    t0, CP0_STATUS
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 0731606..cd2d890 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -32,7 +32,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/module.h>
 #include <linux/timer.h>
 
-#include <asm/netlogic/msgring.h>
 #include <asm/netlogic/iomap.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/debug.h>
@@ -248,7 +247,6 @@ EXPORT_SYMBOL(nlm_xlp_register_vc_handler);
  ********************************************************************/
 void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 {
-	unsigned long mflags;
 	int vc = 0;
 	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
 	struct msgstn_handler *handler = 0;
@@ -272,7 +270,6 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 
 	irq_enter();
 
-        msgrng_access_enable(mflags);
 	cycles = read_c0_count();
 
 	for (;;) {
@@ -328,8 +325,6 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	/* Clear VC interrupt status by writing 1s */
 	xlp_write_status1( (msg_status1 | (pop_vc_mask << 16)) );
 
-        msgrng_access_disable(mflags);
-
 	irq_exit();
 }
 
@@ -370,7 +365,6 @@ void xlp_poll_vc0_messages(void)
         unsigned int msg_status1 = 0, vc_empty_status = 0;
         int loop = 0;
         int pop_vc_mask = 0x1;
-	unsigned long mflags;
 #if 0
 	if (hard_smp_processor_id() != 0)
 		printk("Called handler on cpu %d from %s msgstatus: 0x%x\n",
@@ -378,7 +372,6 @@ void xlp_poll_vc0_messages(void)
 			       __FUNCTION__,xlp_read_status1());
 #endif
         msg0 = msg1 = msg2 = msg3 = 0;
-        msgrng_access_enable(mflags);
         for (loop = 0; loop < 16; loop++) {
                 /* Read latest VC empty mask */
                 msg_status1 = xlp_read_status1();
@@ -393,7 +386,6 @@ void xlp_poll_vc0_messages(void)
                 (handler->action)(vc, src_id, size, code,
                                 msg0, msg1, msg2, msg3, handler->dev_id);
         }
-        msgrng_access_disable(mflags);
 }
 EXPORT_SYMBOL(xlp_poll_vc0_messages);
 
@@ -500,9 +492,7 @@ void enable_msgconfig_int(void)
 	uint32_t flags;
 
 	/* Need write interrupt vector to cp2 msgconfig register */
-	msgrng_access_enable(flags);
 	nlm_hal_set_fmn_interrupt(XLP_IRQ_MSGRING);
-	msgrng_access_disable(flags);
 }
 
 /*
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 76fe379..4422e43 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -35,7 +35,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/cacheops.h>
 
 #include <asm/netlogic/xlp.h>
-#include <asm/netlogic/msgring.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/interrupt.h>
 #include <asm/netlogic/xlp_hal_pic.h>
@@ -137,7 +136,7 @@ void nlm_cpus_done(void)
 {
 	int node = 0;
 	extern void *fdt;
-	nlm_hal_fmn_init(fdt, (void *)(long)node);
+	nlm_hal_fmn_init(fdt, node);
 	
 	/* Enable vc interupts for the online cpus */
 	nlm_enable_vc_intr();
diff --git a/arch/mips/netlogic/xlp/time.c b/arch/mips/netlogic/xlp/time.c
index 4acef9f..2385598 100644
--- a/arch/mips/netlogic/xlp/time.c
+++ b/arch/mips/netlogic/xlp/time.c
@@ -40,18 +40,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 extern spinlock_t xlp_pic_lock;
 
-#ifndef CONFIG_NLMCOMMON_MAC
-void nlm_common_user_mac_update_time(void)
-{
-}
-void nlm_common_user_mac_update_ktime(void)
-{
-}
-#else
-extern void nlm_common_user_mac_update_time(void);
-extern void nlm_common_user_mac_update_ktime(void);
-#endif
- 
 void save_epc(unsigned long *epc)
 {
 	__asm__ __volatile__(".set push\n"
@@ -63,60 +51,11 @@ void save_epc(unsigned long *epc)
 extern void nlm_common_oprofile_int_handler(int irq, void *dev_id,
 					 struct pt_regs *regs);
 #endif
-void nlm_common_timer_interrupt(struct pt_regs *regs, int irq)
-{
-//	int cpu = smp_processor_id();
-	int cpu = hard_smp_processor_id();
-
-#ifdef CONFIG_NLM_WATCHDOG
-        pic_reg_t *mmio = nlm_hal_pic_offset();
-
-	/* ack the watchdog */
-	/* Need to choose (?) the right heartbeat reg (0/1) and right chunk */
-	nlm_hal_write_pic_reg(mmio, PIC_WD_HEARTBEAT_0(0), 1 << cpu_logical_map(cpu));
-#endif
-
-#if defined (CONFIG_OPROFILE)
-	int    perfctr_overflow = 0;
-#endif
-
-#ifdef CONFIG_NLM_WATCHDOG
-	/* ack the watchdog */
-	netlogic_write_reg(mmio, 0x0c, 1 << cpu_logical_map(cpu));
-#endif
-
-	if (irq != XLP_IRQ_TIMER) {
-		printk("[%s]:cpu_%d: bad timer irq = %x\n", __FUNCTION__, cpu, irq);
-		BUG();
-	}
-
-#if defined (CONFIG_OPROFILE)
-    perfctr_overflow = ((read_c0_cause() >> 26) & 0x1);
-
-    if(perfctr_overflow == 0)
-#endif
-    {
-        do_IRQ(irq);
-
-        if (cpu == 0) {
-            nlm_common_user_mac_update_time();
-	    nlm_common_user_mac_update_ktime();
-        }
-    }
-
-#if defined (CONFIG_OPROFILE)
-	if (perfctr_overflow) {
-			nlm_common_oprofile_int_handler (irq, NULL, regs);
-		}
-#endif
-
-}
-
 /* PIC clock at 66Mhz takes more than 60 secs to come to 0 from max. So 32bit 
    counter is sufficient
    */
 #define PIC_FREE_RUNNING_TIMER_MAX_VAL 0xffffffff
-cycle_t xlr_hpt_read(void)
+cycle_t xlp_hpt_read(void)
 {
 	uint32_t counter;
 	pic_reg_t *mmio = nlm_hal_pic_offset();
@@ -126,7 +65,7 @@ cycle_t xlr_hpt_read(void)
 
 int read_current_timer(unsigned long *timer_val)
 {
-	*timer_val = xlr_hpt_read();
+	*timer_val = xlp_hpt_read();
 	return 0;
 }
 
diff --git a/arch/mips/oprofile/Makefile b/arch/mips/oprofile/Makefile
index d1b5b78..061a8f4 100644
--- a/arch/mips/oprofile/Makefile
+++ b/arch/mips/oprofile/Makefile
@@ -15,6 +15,5 @@ oprofile-$(CONFIG_CPU_MIPS64)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_R10000)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_SB1)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_RM9000)		+= op_model_rm9000.o
-oprofile-$(CONFIG_NLM_XLR)		+= op_model_mips_xlr.o
 oprofile-$(CONFIG_NLM_XLP)		+= op_model_mips_xlp.o
 oprofile-$(CONFIG_CPU_LOONGSON2)	+= op_model_loongson2.o
diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index 3adf84e..c1bee8b 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -53,7 +53,6 @@ obj-$(CONFIG_TOSHIBA_RBTX4927)	+= fixup-rbtx4927.o
 obj-$(CONFIG_TOSHIBA_RBTX4938)	+= fixup-rbtx4938.o
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
-obj-$(CONFIG_NLM_XLR)  	+= pci-xlr.o
 obj-$(CONFIG_NLM_XLP)  	+= pci-xlp.o
 obj-$(CONFIG_WR_PPMC)		+= fixup-wrppmc.o
 obj-$(CONFIG_MIKROTIK_RB532)	+= pci-rc32434.o ops-rc32434.o fixup-rc32434.o
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index 3b1fa0c..6ef9696 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -919,87 +919,3 @@ struct pci_fixup pcibios_fixups[] = {
 	{0}
 };
 
-
-/*
- * some ide specific io routines on PCI
- */
-#define pci_ide_phys_to_virt(x) (((x) - (xlp_io_resource.start)) + (unsigned long)pci_io_base )
-
-inline void nlm_ide_mm_insw(unsigned long port, void *addr, u32 count)
-{
-	unsigned long v_port = pci_ide_phys_to_virt(port);
-	while (count--) {
-		*(u16 *)addr = (readw((const volatile void *)v_port));
-		addr += 2;
-	}
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_insw);
-
-inline void nlm_ide_mm_insl(unsigned long port, void *addr, unsigned int count)
-{
-	unsigned long v_port = pci_ide_phys_to_virt(port);
-	while (count--) {
-		*(u32 *)addr = readl((const volatile void *) v_port);
-		addr += 4;
-	}
-}
-EXPORT_SYMBOL(nlm_ide_mm_insl);
-
-inline void nlm_ide_mm_outsw(unsigned long port, void *addr, unsigned int count)
-{
-	unsigned long v_port = pci_ide_phys_to_virt(port);
-	while (count--) {
-		writew(*(u16 *)addr, (volatile void *)v_port);
-		addr += 2;
-	}
-}
-EXPORT_SYMBOL(nlm_ide_mm_outsw);
-
-inline void nlm_ide_mm_outsl(unsigned long port, void *addr, unsigned int count)
-{
-	unsigned long v_port = pci_ide_phys_to_virt(port);
-	while (count--) {
-		writel(*(u32 *)addr, (volatile void *)v_port);
-		addr += 4;
-	}
-}
-EXPORT_SYMBOL(nlm_ide_mm_outsl);
-
-u8 nlm_ide_mm_inb (unsigned long port)
-{
-	return((u8)readb((const volatile void *)pci_ide_phys_to_virt(port)));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_inb);
-u16 nlm_ide_mm_inw (unsigned long port)
-{
-	return ((u16) (readw((const volatile void *)pci_ide_phys_to_virt(port))));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_inw);
-/* Not part of hwif anymore; remove static declaration */
-u32 nlm_ide_mm_inl (unsigned long port)
-{
-	return ((u32)readl((const volatile void *)pci_ide_phys_to_virt(port)));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_inl);
-void nlm_ide_mm_outb (u8 value, unsigned long port)
-{
-	writeb(value, (volatile void *)pci_ide_phys_to_virt(port));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_outb);
-void nlm_ide_mm_outw (u16 value, unsigned long port)
-{
-	writew(value, (volatile void *)pci_ide_phys_to_virt((u64)port));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_outw);
-/* Not part of hwif anymore; remove static declaration */
-void nlm_ide_mm_outl (u32 value, unsigned long port)
-{
-	writel((value), (volatile void *)pci_ide_phys_to_virt(port));
-}
-EXPORT_SYMBOL(nlm_ide_mm_outl);
diff --git a/arch/mips/xen/Kconfig b/arch/mips/xen/Kconfig
index c50136f..9f6ca9b 100644
--- a/arch/mips/xen/Kconfig
+++ b/arch/mips/xen/Kconfig
@@ -6,7 +6,7 @@ config XEN
 	bool "Xen guest support"
 	select PARAVIRT
 	select PARAVIRT_CLOCK
-	depends on RMI_XLR || RMI_XLP
+	depends on NLM_XLP
 	help
 	  This is the Linux Xen port.  Enabling this will allow the
 	  kernel to boot in a paravirtualized environment under the
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index ee90207..1baabdd 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -264,18 +264,6 @@ config NWFLASH
 
 source "drivers/char/hw_random/Kconfig"
 
-config NETLOGIC_RMIOS_DEBUGGER
-	bool "RMIOS Debugger support"
-	depends on NLM_COMMON!=n
-	default n
-	---help---
-	This module provides debugging facility for rmios images loaded on the
-	board, before loading linux image. Network interface is used to
-	communicate with remote gdb host. GDB clients communicate using the
-	network connection. Multiple rmios sessions can be run on different
-	virtual cpus. These gdb capable rmios sessions can be debugged
-	remotely by connecting to these session remotely through gdb.
-
 config NVRAM
 	tristate "/dev/nvram support"
 	depends on ATARI || X86 || (ARM && RTC_DRV_CMOS) || GENERIC_NVRAM
@@ -651,11 +639,4 @@ config NLM_XLP_DMA
 	    If you want this as a module, choose M here. The driver
 	    will be called nlm_xlp_dma.ko
 
-config RMICDE
-	tristate "RMI Compression/Decompression Engine"
-	depends on NLM_COMMON!=n
-	default n
-	help
-	  The CDE allows deflate/inflate through hardware
-
 endmenu
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 6946b17..b8a6204 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -2,7 +2,7 @@
 # Makefile for the kernel character device drivers.
 #
 
-EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL 
+EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL
 
 obj-y				+= mem.o random.o
 obj-$(CONFIG_TTY_PRINTK)	+= ttyprintk.o
@@ -57,18 +57,8 @@ obj-$(CONFIG_AGP)		+= agp/
 obj-$(CONFIG_PCMCIA)		+= pcmcia/
 obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
 
-obj-$(CONFIG_NLMCOMMON_UART)	+= nlm_common_uart.o
-obj-$(CONFIG_NLM_COMMON)	+= nlm_common_msgring_debugger.o
-obj-$(CONFIG_NLM_XLR)		+= nlm_xlr_msgring.o
-obj-$(CONFIG_NLMCOMMON_RMIOS_DEBUGGER)	+= nlm_common_rmios_debugger.o
-obj-$(CONFIG_RMICDE)		+= nlm_xlr_cde.o
-obj-$(CONFIG_NLM_XLR)		+= nlm_common_tb.o
-obj-$(CONFIG_NLM_COMMON)	+= nlm_vuart.o
+obj-$(CONFIG_NLM_XLP)		+= nlm_vuart.o
 obj-$(CONFIG_XEN)		+= nlm_sharedmem.o
-obj-$(CONFIG_NLMCOMMON_PCIX_GEN_DRIVER)	+= nlm_pcix_gen_dev.o
-obj-$(CONFIG_NLMCOMMON_PCIX_GEN_DRIVER)	+= nlm_pcix_gen_host.o
-obj-$(CONFIG_NLMCOMMON_CONSOLE_OVER_PCI)	+= xlr_pcix_console_dev.o
-obj-$(CONFIG_NLMCOMMON_CONSOLE_OVER_PCI)	+= xlr_pcix_console_host.o
 obj-$(CONFIG_NLM_XLP_DMA)	+= nlm_xlp_dma.o
 
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
diff --git a/drivers/char/hw_random/Kconfig b/drivers/char/hw_random/Kconfig
index af1d5b5..b2402eb 100644
--- a/drivers/char/hw_random/Kconfig
+++ b/drivers/char/hw_random/Kconfig
@@ -139,11 +139,6 @@ config HW_RANDOM_OMAP
 
  	  If unsure, say Y.
 
-config HW_RANDOM_MIPS_XLR
-	bool "Netlogic XLR Random Number Generator support"
-	depends on HW_RANDOM && NLM_COMMON
-	default y
-
 config HW_RANDOM_OCTEON
 	tristate "Octeon Random Number Generator support"
 	depends on HW_RANDOM && CPU_CAVIUM_OCTEON
diff --git a/drivers/char/hw_random/Makefile b/drivers/char/hw_random/Makefile
index 441970c..b2ff526 100644
--- a/drivers/char/hw_random/Makefile
+++ b/drivers/char/hw_random/Makefile
@@ -14,7 +14,6 @@ n2-rng-y := n2-drv.o n2-asm.o
 obj-$(CONFIG_HW_RANDOM_VIA) += via-rng.o
 obj-$(CONFIG_HW_RANDOM_IXP4XX) += ixp4xx-rng.o
 obj-$(CONFIG_HW_RANDOM_OMAP) += omap-rng.o
-obj-$(CONFIG_HW_RANDOM_MIPS_XLR) += xlr-rng.o
 obj-$(CONFIG_HW_RANDOM_PASEMI) += pasemi-rng.o
 obj-$(CONFIG_HW_RANDOM_VIRTIO) += virtio-rng.o
 obj-$(CONFIG_HW_RANDOM_TX4939) += tx4939-rng.o
diff --git a/drivers/char/hw_random/xlr-rng.c b/drivers/char/hw_random/xlr-rng.c
deleted file mode 100644
index 9b2f183..0000000
--- a/drivers/char/hw_random/xlr-rng.c
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * RNG driver for Netlogic XLR CPU
- *
- * derived from
- *
- * Hardware driver for the AMD 768 Random Number Generator (RNG)
- * (c) Copyright 2001 Red Hat Inc <alan@redhat.com>
- *
- * derived from
- *
- * Hardware driver for Intel i810 Random Number Generator (RNG)
- * Copyright 2000,2001 Jeff Garzik <jgarzik@pobox.com>
- * Copyright 2000,2001 Philipp Rumpf <prumpf@mandrakesoft.com>
- *
- * This file is licensed under  the terms of the GNU General Public
- * License version 2. This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/hw_random.h>
-#include <asm/io.h>
-#include <asm/netlogic/gpio.h>
-
-
-#define PFX	KBUILD_MODNAME ": "
-
-
-static nlm_reg_t   *mmio;
-static int xlr_data_present(struct hwrng *rng, int wait)
-{
-	return 1;
-}
-
-static int xlr_data_read(struct hwrng *rng, u32 *data)
-{
-	*data = netlogic_read_reg(mmio, NETLOGIC_GPIO_RNG_REG);
-	return 4;
-}
-
-static int xlr_init(struct hwrng *rng)
-{
-	mmio = netlogic_io_mmio(NETLOGIC_IO_GPIO_OFFSET);
-	return 0;
-
-}
-
-static void xlr_cleanup(struct hwrng *rng)
-{
-}
-
-
-static struct hwrng xlr_rng = {
-	.name		= "xlr",
-	.init		= xlr_init,
-	.cleanup	= xlr_cleanup,
-	.data_present	= xlr_data_present,
-	.data_read	= xlr_data_read,
-};
-
-
-static int __init mod_init(void)
-{
-	int err = -ENODEV;
-	err = hwrng_register(&xlr_rng);
-	if (err) {
-		printk(KERN_ERR PFX "RNG registering failed (%d)\n",
-		       err);
-	}
-	printk(KERN_INFO "Netlogic RNG registered\n");
-	return err;
-}
-
-static void __exit mod_exit(void)
-{
-	hwrng_unregister(&xlr_rng);
-}
-
-module_init(mod_init);
-module_exit(mod_exit);
-
-MODULE_AUTHOR("The Linux Kernel team");
-MODULE_DESCRIPTION("H/W RNG driver for Netlogic XLR chipsets");
-MODULE_LICENSE("GPL");
diff --git a/drivers/char/nlm_common_dummy_uart.c b/drivers/char/nlm_common_dummy_uart.c
deleted file mode 100644
index ff86dc4..0000000
--- a/drivers/char/nlm_common_dummy_uart.c
+++ /dev/null
@@ -1,288 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/console.h>
-#include <linux/termios.h>
-#include <linux/tty.h>
-#include <linux/tty_flip.h>
-#include <linux/serial.h>
-#include <linux/tty_driver.h>
-#include <linux/kdev_t.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/pci.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/interrupt.h>
-
-#define MMIO_START          (0xbf402000)
-#define GETCHAR_ADDRESS     (MMIO_START)
-#define PUTCHAR_ADDRESS     (MMIO_START + 4)
-#define UART_STATUS_ADDRESS (MMIO_START + 8)
-
-
-/**************************************************************
- *
- * Serial driver
- *
- ****************************************************************/
-static struct tty_struct *serial_tty;
-static int open_count = 0;
-
-static irqreturn_t serial_int_handler(int irq, void *data, struct pt_regs *regs)
-{
-  unsigned char ch = 0;
-  struct tty_struct *tty = serial_tty;
-
-  //printk("[%s]: IN\n", __FUNCTION__);
-  if (siminfo->uart_status & UART_RX_RDY) {
-    while (siminfo->uart_status & UART_RX_RDY) {
-      ch = siminfo->getchar;
-      if (tty) {
-	//printk("[%s]: inserting %c\n", __FUNCTION__, ch);
-	tty_insert_flip_char(tty, ch, 0);
-      }
-    }
-    if (tty)
-      tty_flip_buffer_push(tty);
-  }
-
-  return IRQ_HANDLED;
-}
-
-static int serial_open(struct tty_struct *tty, struct file *filp)
-{
-  //printk("[%s]: IN tty %p\n", __FUNCTION__, tty);
-  serial_tty = tty;
-  open_count++;
-  
-  return 0;
-}
-
-static void serial_close(struct tty_struct *tty, struct file *filp)
-{
-  //printk("[%s]: IN count %d tty %p\n", __FUNCTION__, open_count, tty);
-  if (open_count == 0)
-    return;
-  if (--open_count == 0)
-    serial_tty = 0;
-}
-
-static void serial_put_char(struct tty_struct *tty, u_char ch)
-{
-  static int flag = 1;
-
-  if (flag == 1) {
-
-#ifdef CONFIG_NLMCOMMON_SMP_PREFIX
-    siminfo->putchar = '0' + (__u8)(smp_processor_id() & 0xff);
-    siminfo->putchar = ':';
-#endif
-    flag = 0;
-  }
-
-  siminfo->putchar = (char)ch;  
-  
-  if (ch == '\n')
-    flag = 1;  
-}
-
-static int serial_write_room(struct tty_struct *tty)
-{
-  /* This doesn't quite apply to the simulator. However, it is
-   * needed by the tty code. So, fake it
-   */
-  return 15;
-}
-
-static int serial_write(struct tty_struct *tty, int from_user, 
-			const unsigned char *buf, int count)
-{
-  int i=0, total=0;
-  unsigned char ch = 0;
-
-  //printk("[%s]: count = %d\n", __FUNCTION__, count);
-  if (from_user && verify_area(VERIFY_READ, buf, count))
-    return -EINVAL;
- 
-  if (count == 0)
-    return 0;
-
-  for (i = 0, total=0; i < count; i++, total++) {
-    if (from_user) 
-      copy_from_user(&ch, &buf[i], 1);
-    else 
-      ch = buf[i];
-    serial_put_char(tty, ch);
-  }
-
-  return total;
-}
-
-void serial_set_termios(struct tty_struct *tty, struct termios *old)
-{
-#if 0
-  printk("[%s]: IN old_cflag=%x, new_cflag=%x\n", __FUNCTION__, 
-	 (int)old->c_cflag, (int)tty->termios->c_cflag);
-#endif
-}
-
-void serial_start(struct tty_struct *tty)
-{
-  printk("[%s]: IN\n", __FUNCTION__);
-}
-
-void serial_stop(struct tty_struct *tty)
-{
-  printk("[%s]: IN\n", __FUNCTION__);
-}
-
-void serial_hangup(struct tty_struct *tty)
-{
-  printk("[%s]: IN\n", __FUNCTION__);
-}
-
-static struct termios    *serial_termios[2];
-static struct termios    *serial_termios_locked[2];
-
-static struct tty_driver serial_driver = {
-  magic:                       TTY_DRIVER_MAGIC,
-  driver_name:                 "serial",
-  name:                        "ttyS",
-  major:                       TTY_MAJOR,
-  minor_start:                 0,
-  num:                         1,
-  type:                        TTY_DRIVER_TYPE_SERIAL,
-  subtype:                     SERIAL_TYPE_NORMAL,
-  flags:                       TTY_DRIVER_REAL_RAW,
-  refcount:                    1,
-  termios:                     serial_termios,
-  termios_locked:              serial_termios_locked,
-
-  open:                        serial_open,
-  close:                       serial_close,
-  write:                       serial_write,
-  write_room:                  serial_write_room,
-  put_char:                    serial_put_char,
-  set_termios:                 serial_set_termios,
-  start:                       serial_start,
-  stop:                        serial_stop,
-  hangup:                      serial_hangup  
-};
-
-int nlm_common_duart_init(void)
-{
-  if (request_irq(NLM_IRQ_DUMMY_UART, serial_int_handler, SA_INTERRUPT, "uart0", 0)) {
-    panic("Couldn't get uart0 interrupt line");
-  }
-  
-  serial_driver.init_termios = tty_std_termios;
-  
-  if (tty_register_driver(&serial_driver)) {
-    printk("Couldn't register xlr duart serial driver\n");
-    return -1;
-  }
-  printk("Registered xlr dummy uart driver\n");
-  
-  return 0;
-}
-
-void nlm_common_duart_exit(void)
-{
-  if (tty_unregister_driver(&serial_driver)) {
-    printk("Couldn't unregister xlr duart serial driver\n");
-  }
-  printk("unregistered xlr duart serial driver\n");
-  
-}
-
-module_init(nlm_common_duart_init);
-module_exit(nlm_common_duart_exit);
-
-
-/**************************************************************
- *
- * Serial Console 
- *
- ****************************************************************/
-
-static int console_read(struct console *cons, char *str, 
-			unsigned int count)
-{
-  return 0;
-}
-
-static void console_write(struct console *cons, const char *str,
-                              unsigned int count)
-{
-  int i=0;
-
-  for(i=0; i<count; i++) {
-    if (str[i] == 0)
-      continue;
-    siminfo->putchar = (char)str[i];
-  }  
-}
-
-static struct tty_driver *console_device(struct console *c, int *index)
-{
-  *index = c->index;
-  return &serial_driver;
-}
-
-static int console_setup(struct console *cons, char *str)
-{
-  siminfo->uart_status |= 0x80;
-
-  return 0;
-}
-
-static struct console nlm_common_dummy_uart_console = {
-  name:              "ttyS",
-  read:              console_read,
-  write:             console_write,
-  device:            console_device,
-  setup:             console_setup,
-  flags:             CON_PRINTBUFFER,
-  index:             -1,
-};
-
-int nlm_common_console_init(void)
-{
-  register_console(&nlm_common_dummy_uart_console);
-  
-  return 0;
-}
-
-void nlm_common_console_exit(void)
-{
-  /* do nothing */
-}
-
-console_initcall(nlm_common_console_init);
diff --git a/drivers/char/nlm_common_loader.c b/drivers/char/nlm_common_loader.c
deleted file mode 100644
index 1879863..0000000
--- a/drivers/char/nlm_common_loader.c
+++ /dev/null
@@ -1,625 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/spinlock.h>
-#include <linux/sched.h>
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
-#include <linux/poll.h>
-#include <asm/uaccess.h>
-#include <asm/netlogic/devices.h>
-#include <asm/netlogic/nlm_common_loader.h>
-#include <user/netlogic/nlm_common_loader.h>
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/hal/nlm_hal_pic.h>
-#include <asm/io.h>
-#include <asm/system.h>
-#include <linux/rwsem.h>
-#define dbg_msg(fmt, args...) //printk(fmt,##args)
-
-#define Message(fmt, args...) //printk("\n[%s]-[%d] "fmt"\n",__FUNCTION__,__LINE__,##args)
-
-extern int xlr_lib_launch_userapp(int cpu);
-extern void wakeup_cpu(unsigned int cpu, unsigned long fn, unsigned long args);
-extern void xlr_send_stop_ipi(unsigned long mask);
-extern volatile unsigned int xlr_lib_shmem_size;
-static int nlm_common_loader_major;
-static spinlock_t nlm_common_loader_lock;
-static int nlm_common_loader_user = 0;
-static int nlm_common_map_sh_mem=0;
-static int nlm_common_map_persistent_mem = 0;
-static int nlm_common_map_load_addr = 0;
-static int nlm_common_map_app_shmem=0;
-unsigned char *xlr_persistent_data_start=NULL;
-unsigned char *xlr_persistent_data_start_orig=NULL;
-static uint64_t xlr_app_shmem_start = 0x0;
-
-unsigned int xlr_persistent_data_size=0;
-/* Size of the shared memory b/w Linux userapp and rmios apps */
-extern uint32_t nlm_common_app_sh_mem_sz;
-extern unsigned long  nlm_common_app_shmem_start;
-
-extern uint64_t nlm_common_loader_kuseg_size, nlm_common_loader_kuseg_start;
-extern uint32_t nlm_common_loader_kseg_size, nlm_common_loader_kseg_start;
-extern int xlr_loader_support;
-extern uint32_t nlm_common_loader_mask;
-extern void prom_check_image(void);
-unsigned char load_env[32][6];
-extern unsigned char *xlr_lib_shmem_start;
-
-struct wakeup_info
-{
-	int vcpu;
-    unsigned long long func;
-    unsigned long long data;
-};
-
-struct xlr_load_addr
-{
-	uint64_t phys;
-	uint64_t size;
-	uint32_t flag;
-}xlr_image_load_addr;
-
-
-struct loader_send_ipi
-{
-	uint32_t mask;
-	uint32_t ipi;
-};
-
-struct xlr_lib_shared_mem
-{
-	uint64_t entries;
-	uint64_t tot_size;
-	uint64_t addr[32];
-	uint64_t size[32];
-};
-static struct xlr_lib_shared_mem app_shared_mem;
-
-static int nlm_common_loader_open (struct inode *inode, struct file *filp)
-{
-	uint32_t minor=0;
-	if(xlr_loader_support == 0) 
-		return -EPERM;
-
-	minor = MINOR(inode->i_rdev);	
-	if(minor == XLR_MAP_SLAVE_DEVICE){
-		filp->private_data = (void *)inode;
-		return 0;
-	}
-
-	/* ALLOW ONLY ONE OPEN at a time */
-	spin_lock(&nlm_common_loader_lock);
-	if(nlm_common_loader_user == 1){
-		spin_unlock(&nlm_common_loader_lock);
-		return -EAGAIN;
-	}
-	filp->private_data = (void *)inode;
-	nlm_common_loader_user = 1;
-	nlm_common_map_load_addr = 0;
-	nlm_common_map_persistent_mem = 0;
-	nlm_common_map_sh_mem = 0;
-	nlm_common_map_app_shmem = 0;
-
-	spin_unlock(&nlm_common_loader_lock);
-
-
-	return 0;
-}
-
-void nlm_common_loader_send_ipi(struct loader_send_ipi *data)
-{
-	uint32_t i;
-
-	for(i=0; i<32; i++){
-		if((data->mask) & (1<<i)){
-#if defined(CONFIG_NLM_XLP)
-			nlm_hal_pic_send_ipi(0, data->ipi, 0, i);
-#else
-			uint32_t pid, tid;
-			uint32_t val;
-			nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
-
-			pid = i >> 2;
-			tid = i % 4;
-			val = (pid << 20) | (tid << 16) | data->ipi;
-			netlogic_write_reg(mmio, PIC_IPI, val);
-#endif /* #if defined(CONFIG_NLM_XLP) */
-		}
-	}
-}
-
-int nlm_common_loader_ioctl (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	unsigned int *addr = (unsigned int*)arg;
-	struct loader_send_ipi data;
-	switch (cmd) {
-
-		/*size of the data structures shared memory - this includes
-		 all xlr_vcpu_wakeup_info and other lib data structure.*/
-		case NLM_LOADER_IOC_SHMEM_SIZE: 
-		{
-			Message(" available shared mem [%#x]",xlr_lib_shmem_size);
-			if(put_user(xlr_lib_shmem_size, addr)){
-				panic("\nput user failed for ioc shmem size\n");
-			}
-		}
-		break;
-
-		/*Next mmap should be for global data structure - 
-		 wakeup_info and other structures*/
-		case NLM_LOADER_IOC_MMAP_SHMEM:
-		{
-			nlm_common_map_sh_mem = 1;
-			nlm_common_map_persistent_mem = 0;
-			nlm_common_map_load_addr = 0;
-			nlm_common_map_app_shmem = 0;
-		}
-		break;
-
-		/*Do an mmap of the passed physical address and size*/
-		case NLM_LOADER_IOC_MMAP_LOAD_ADDR:
-		{
-			if(copy_from_user((void *)&xlr_image_load_addr,
-								(const void __user *)addr,
-								sizeof(struct xlr_load_addr)))
-					panic("\nmmap load addr - copy frm user - failed\n");
-			nlm_common_map_load_addr = 1;
-			nlm_common_map_persistent_mem = 0;
-			nlm_common_map_sh_mem = 0;
-			nlm_common_map_app_shmem = 0;
-		}
-		break;
-
-		/*Wakeup cpu*/
-		case NLM_LOADER_IOC_START_IPI: 
-		{
-			struct wakeup_info tmp;
-			if(copy_from_user((void *)&tmp, (const void __user *)addr,
-								sizeof(struct wakeup_info)))
-				panic("copy from user failed for START IPI\n");
-			wakeup_cpu(tmp.vcpu, (unsigned long)tmp.func, 
-									(unsigned long)tmp.data);
-		}
-		break;
-
-		/*Stop cpu*/
-		case NLM_LOADER_IOC_STOP_IPI:
-		{
-			uint32_t vcpu=0;
-			if(get_user(vcpu, (uint32_t *)addr))
-				panic("\nGetUser Failed for stop ipi\n");	
-			/*Below Func Is Library Call.*/
-			xlr_send_stop_ipi(vcpu);
-		}
-		break;
-
-		/*Send ipi to the cpu*/
-		case NLM_LOADER_SEND_IPI:
-		{
-			if(copy_from_user((void *)&data , (const void __user *)arg, 
-							sizeof(data))){
-					panic("\ncopy_from_user failed for send_ipi\n");
-			}
-			nlm_common_loader_send_ipi(&data);
-		}
-		break;
-
-		/*Check if pereistent memory is present*/
-		case NLM_LOADER_IOC_LIB_BKP:
-		{
-			if(xlr_persistent_data_start_orig){
-				if(put_user(1, addr)){
-					panic("\nput_user failed for lib_bkp\n");
-				}
-			}
-			else{
-				if(put_user(0, addr))
-					panic("\nput_user failed for lib_bkp\n");
-			}
-		}
-		break;
-
-		/*Store shared memory info*/
-		case NLM_LOADER_IOC_STORE_APP_SHMEM_INFO:
-		{
-			if(copy_from_user((void *)&app_shared_mem, (const void __user *)arg, 
-							sizeof(app_shared_mem))){
-				panic("copy from User failed for app shared mem info\n");
-			}
-			/*
-			int i=0;
-			for(i=0; i<app_shared_mem.entries; i++){
-				printk("\nStoring Physical Addr %#llx, Size %#llx\n",
-						(unsigned long long)app_shared_mem.addr[i], 
-						(unsigned long long)app_shared_mem.size[i]);
-			}
-			*/
-		}
-		break;
-
-		/*Retrive shared memory info*/
-		case NLM_LOADER_IOC_GET_APP_SHMEM_INFO:
-		{
-			/*
-			int i=0;
-			for(i=0; i<app_shared_mem.entries; i++){
-				printk("\nRetrive Physical Addr %#llx, Size %#llx\n",
-						(unsigned long long)app_shared_mem.addr[i], 
-						(unsigned long long)app_shared_mem.size[i]);
-			}*/
-
-			if(copy_to_user((void __user *)arg, (const void *)&app_shared_mem,
-							sizeof(app_shared_mem))){
-				panic("\ncopy_to_user failed for app shared mem info\n");
-			}			
-		}
-		break;
-
-#if 0
-		/*Check if app shared memory is already reserved*/
-		case NLM_LOADER_IOC_APP_SHMEM_RESERVE:
-		{
-			if(xlr_app_shmem_start){
-				if(put_user(1, addr)){
-					panic("\nput_user failed for lib_bkp\n");
-				}
-			}
-			else{
-				if(put_user(0, addr)){
-					panic("\nput_user failed for lib_bkp\n");
-				}
-			}	
-		}
-		break;
-		
-		/*Get the app shared memory physical address start from user space*/
-		case NLM_LOADER_IOC_APP_SHMEM_PHYS:
-		{
-				if(get_user(xlr_app_shmem_start, (uint64_t *)addr)){
-					panic("\nput_user failed for lib_bkp\n");
-				}
-		}
-		break;
-
-		/*Get the app shared memory size*/
-		case NLM_LOADER_IOC_APP_SHMEM_SIZE:
-		{
-			if(put_user(nlm_common_app_sh_mem_sz, addr)){
-				panic("\nput user failed for ioc shmem size\n");
-			}
-		}
-		break;
-
-		/*mmap app shared memory in next mmap call*/
-		case NLM_LOADER_IOC_MMAP_APP_SHMEM:
-		{
-			nlm_common_map_app_shmem = 1;
-			nlm_common_map_persistent_mem = 0;
-			nlm_common_map_sh_mem = 0;
-			nlm_common_map_load_addr = 0;
-		}
-		break;
-#endif	
-
-		/*Get the kseg0 base of the data structure's shared memory
-		  used bye mmap_to_kseg/kseg_to_mmap*/
-		case NLM_LOADER_IOC_SHMEM_KSEG_ADDR:
-		{
-			if (put_user((long long)(int)(long)xlr_lib_shmem_start, (uint64_t *)addr)){
-				panic("\nput user failed for ioc shmem kseg addr\n");
-			}
-		}
-		break;
-		
-		
-		/*Free persistent memory*/
-		case NLM_LOADER_IOC_FREE_PERSISTENT_MEM:
-		{
-			unsigned long addr=0;
-			if(!xlr_persistent_data_start_orig){
-				printk("\nData Is Not Allocated.\n");
-				return -EINVAL;
-			}
-			addr = (unsigned long)xlr_persistent_data_start;
-			while(addr < (unsigned long)
-						(xlr_persistent_data_start+xlr_persistent_data_size)){
-                ClearPageReserved(virt_to_page((void *)addr));
-                addr += PAGE_SIZE;	
-			}
-			kfree(xlr_persistent_data_start_orig);
-			xlr_persistent_data_start_orig = xlr_persistent_data_start = NULL;
-		}
-		break;
-
-		/*Alloc persistent memory*/
-		case NLM_LOADER_IOC_ALLOC_PERSISTENT_MEM:
-		{
-			unsigned long tmp_addr=0;
-			if(get_user(xlr_persistent_data_size,(unsigned int *)addr)){
-				panic("\nGetUser Failed for alloc persistent mem\n");	
-			}
-			if(!xlr_persistent_data_size){
-				printk("\nInvalid Len %#x\n", xlr_persistent_data_size);
-				return -EINVAL;
-			}
-			xlr_persistent_data_start_orig = 
-				kmalloc(xlr_persistent_data_size+PAGE_SIZE, GFP_KERNEL|GFP_DMA);
-			if(!xlr_persistent_data_start_orig)
-				return -ENOMEM;
-			xlr_persistent_data_start = (unsigned char *)
-						(((unsigned long)(xlr_persistent_data_start_orig + 
-											PAGE_SIZE)) & ~(PAGE_SIZE-1));
-			tmp_addr = (unsigned long)xlr_persistent_data_start;
-			while(tmp_addr < (unsigned long)
-						(xlr_persistent_data_start+xlr_persistent_data_size)){
-                SetPageReserved(virt_to_page((void *)tmp_addr));
-                tmp_addr += PAGE_SIZE;	
-			}
-		}
-		break;
-
-		/*mmap persistent memory in next mmap call.*/
-		case NLM_LOADER_IOC_MMAP_PERSISTENT_MEM:
-		{
-			nlm_common_map_persistent_mem = 1;
-			nlm_common_map_sh_mem = 0;
-			nlm_common_map_load_addr = 0;
-			nlm_common_map_app_shmem = 0;
-		}
-		break;
-
-		/*call lib_launch.c's launch_userapp for kseg app*/
-		case NLM_LOADER_IOC_LAUNCH_KSEG:
-		{
-				uint32_t vcpu=0;
-				if(get_user(vcpu, (uint32_t *)addr))
-						panic("\nGetUser Failed for launch kseg\n");
-				/*Below Func Is Library Call.*/
-				xlr_lib_launch_userapp(vcpu);
-		}
-		break;
-
-		/*store UART info*/
-		case NLM_LOADER_STORE_ENV:
-		{
-				int i;
-				unsigned char temp[32][6];
-				copy_from_user ((void *)&temp , (const void __user *)addr, sizeof(temp));
-
-				for (i=0; i<32; i++)    {
-						if (strcmp(temp[i],"") != 0)
-								strcpy(load_env[i],temp[i]);
-				}
-		}
-		break;
-		default:
-		{
-			printk("ioctl(): invalid command=0x%x\n", cmd);
-			return -EINVAL;
-		}
-	}
-	return 0;
-}
-
-static long nlm_common_loader_compat_ioctl(struct file *filp, unsigned int cmd, 
-		unsigned long arg)
-{
-	unsigned long ret = -1;
-	Message("");
-	lock_kernel();	
-	Message("Got the user space address [%#lx]",arg);
-	ret = nlm_common_loader_ioctl(NULL,filp,cmd,(uint32_t)arg);
-	unlock_kernel();
-	if(ret){
-		printk("nlm_common_loader_ioctl returned with an error.");
-		return -ENOIOCTLCMD;
-	}
-	return ret;
-}
-
-static int nlm_common_loader_mmap_app_shared_mem(struct file *file,
-		struct vm_area_struct *vma)
-{
-	struct xlr_lib_shared_mem *shmem = &app_shared_mem;
-	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
-	unsigned long vaddr = 0;
-	int i=0;
-	int result = 0;
-	unsigned long mmap_size = 0;
-	unsigned long size = 0;
-
-	for(i=0; i<shmem->entries; i++){
-		if(shmem->addr[i] & (PAGE_SIZE-1)){
-			printk("\nMmaping to invalid address ... %#llx\n",
-						(unsigned long long)shmem->addr[i]);
-			return -EINVAL;
-		}
-	}
-
-	if (vma->vm_flags & VM_LOCKED) return -EPERM;
-
-	if (offset >= shmem->tot_size) return -ESPIPE;
-	
-	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
-	pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
-
-	vaddr = vma->vm_start;
-	size = vma->vm_end - vma->vm_start;
-
-	for(i=0; i<shmem->entries && size; i++){
-	/*	printk("\nMapping vaddr = %#lx, Physical Addr %#llx, Size %#llx\n",
-						(unsigned long)vaddr, 
-						(unsigned long long)shmem->addr[i], 
-						(unsigned long long)shmem->size[i]);
-	*/
-		mmap_size = (shmem->size[i] > size) ? size : shmem->size[i];
-		result = remap_pfn_range(vma, vaddr, (shmem->addr[i])>>PAGE_SHIFT, 
-					mmap_size, vma->vm_page_prot);
-		if (result) return -EAGAIN;
-		vaddr += shmem->size[i];
-		size -= mmap_size;
-	}
-	return 0;
-}
-
-static int nlm_common_loader_map_helper(struct file *file, struct vm_area_struct *vma)
-{
-	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
-	uint64_t shm_addr;
-	unsigned long shm_size;
-	unsigned long size = 0;
-	int result = 0;
-	unsigned long shm_pfn_addr = 0;
-	struct inode *i;
-	uint32_t minor;
-	i = (struct inode *)file->private_data;
-	minor = MINOR(i->i_rdev);	
-	if(minor == XLR_MAP_SLAVE_DEVICE){
-		return nlm_common_loader_mmap_app_shared_mem(file, vma);
-	}else if(nlm_common_map_sh_mem){
-		shm_addr = (uint64_t)(49<<20);
-		shm_size = xlr_lib_shmem_size; 
-		shm_pfn_addr = ((uint64_t)shm_addr >> PAGE_SHIFT);
-	}else if(nlm_common_map_persistent_mem){
-		shm_addr = (uint64_t)virt_to_phys(xlr_persistent_data_start);
-		shm_size = xlr_persistent_data_size;
-		shm_pfn_addr = ((uint64_t)shm_addr >> PAGE_SHIFT);
-	}else if(nlm_common_map_load_addr){
-		shm_addr = xlr_image_load_addr.phys;
-		shm_size = (unsigned long)xlr_image_load_addr.size;
-		shm_pfn_addr = ((uint64_t)shm_addr >> PAGE_SHIFT);
-	}else if(nlm_common_map_app_shmem){
-		shm_addr = xlr_app_shmem_start;
-		shm_size = nlm_common_app_sh_mem_sz;
-		shm_pfn_addr = (unsigned long)((uint64_t)shm_addr >> PAGE_SHIFT);
-	}else{
-		printk("\nInvalid mmap command.\n");
-		return -EINVAL;
-	}
-	dbg_msg("[%s]: shm_addr=%lx, shm_size=%lx, offset = %lx, vm_start=%lx, vm_size=%lx, vm_flags=%lx, vm_page_prot=%lx\n", __FUNCTION__, shm_addr, shm_size, offset, vma->vm_start, vm_size, vma->vm_flags, pgprot_val(vma->vm_page_prot));
-	if (!shm_addr) return -ENXIO;
-
-	if(shm_addr & (PAGE_SIZE-1)){
-		printk("\nMmaping to invalid address ... %#llx\n",
-						(unsigned long long)shm_addr);
-		return -EINVAL;
-	}
-	if (offset >= shm_size) return -ESPIPE;
-
-	if (vma->vm_flags & VM_LOCKED) return -EPERM;
-
-	size = vma->vm_end - vma->vm_start;
-	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
-	if(nlm_common_map_load_addr && (xlr_image_load_addr.flag == XLR_MAP_UNCACHED)){
-		pgprot_val (vma->vm_page_prot) |= _CACHE_UNCACHED;
-	}else{
-		pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
-	}
-	result = remap_pfn_range(vma, vma->vm_start, shm_pfn_addr, size, 
-								vma->vm_page_prot);
-	if (result) return -EAGAIN;
-
-	return 0;
-}
-
-static int nlm_common_loader_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	int res;
-	
-	res = nlm_common_loader_map_helper(file, vma);
-	nlm_common_map_app_shmem = 0;
-	nlm_common_map_sh_mem = 0;
-	nlm_common_map_persistent_mem = 0;
-	nlm_common_map_load_addr = 0;
-	return res;
-}
-
-static int nlm_common_loader_release (struct inode *inode, struct file *filp)
-{
-	return 0;
-}
-
-static int nlm_common_loader_flush(struct file *fp, fl_owner_t id)
-{
-	uint32_t minor=0;
-	struct inode *inode = (struct inode *)(fp->private_data);
-	minor = MINOR(inode->i_rdev);
-	if(minor == XLR_MAP_SLAVE_DEVICE){
-		return 0;
-	}
-	spin_lock(&nlm_common_loader_lock);
-	nlm_common_loader_user = 0;
-	spin_unlock(&nlm_common_loader_lock);
-	return 0;
-
-}
-
-struct file_operations nlm_common_loader_fops = {
-	.mmap     = nlm_common_loader_mmap,
-	.open	  = nlm_common_loader_open,
-	.ioctl    = nlm_common_loader_ioctl,
-	.release  = nlm_common_loader_release,
-	.flush = nlm_common_loader_flush,
-	.compat_ioctl = nlm_common_loader_compat_ioctl,
-};
-
-static int nlm_common_loader_init(void)	
-{
-	if(xlr_loader_support == 0)
-		return -EINVAL;
-
-	spin_lock_init(&nlm_common_loader_lock);
-
-	nlm_common_loader_major = register_chrdev (XLR_APP_LOADER_MAJOR, 
-					     NLM_APP_LOADER_CHRDEV_NAME, &nlm_common_loader_fops);
-
-	if (nlm_common_loader_major < 0) {
-		printk("[%s]: register_chrdev failed\n", __FUNCTION__);
-		return nlm_common_loader_major;
-	}
-
-	/* Launch the threads now */
-/*
-	nlm_common_start_loader_threads();
-
-	printk("Registered xlr app loader driver: nlm_common_loader_major=%d\n", XLR_APP_LOADER_MAJOR);
-*/
-	return 0;
-}
-
-static void nlm_common_loader_exit(void)
-{
-	/*TODO: Clean up*/
-    unregister_chrdev (nlm_common_loader_major, NLM_APP_LOADER_CHRDEV_NAME);
-}
-
-module_init (nlm_common_loader_init);
-module_exit (nlm_common_loader_exit);
-
diff --git a/drivers/char/nlm_common_msgring_debugger.c b/drivers/char/nlm_common_msgring_debugger.c
deleted file mode 100644
index 5e91959..0000000
--- a/drivers/char/nlm_common_msgring_debugger.c
+++ /dev/null
@@ -1,86 +0,0 @@
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/proc_fs.h>
-
-
-struct proc_dir_entry *msgring_debug;
-struct proc_dir_entry *msgring_dbglevel;
-
-static int initstatus = 0;
-
-int msgring_debug_level = 3;
-EXPORT_SYMBOL(msgring_debug_level);
-extern struct proc_dir_entry *nlm_root_proc;
-
-#define MAX_DEBUG_LEVEL 128
-
-
-static int msgring_debug_read(char *page, char **start, off_t off, int count, int *eof,
-				       void *data) {
-	int ret = 0;
-	if(off > 0) {
-		*eof = 1;
-		return 0;
-	}
-
-	if(!initstatus) {
-		ret = sprintf(page, "%d", msgring_debug_level);
-	}
-	return ret;
-}
-
-static int msgring_debug_write(struct file *filp, const char __user *buf,
-					unsigned long count, void *data) {
-	int ret = 0;
-	int level = 0;
-	if(!initstatus) {
-		char scratch[10];
-		if(count < sizeof(scratch)) {
-			__copy_from_user(&scratch, buf, count);
-			scratch[count] = '\0';
-			level = simple_strtol(scratch, NULL, 0);
-			if(level < 0 || level > MAX_DEBUG_LEVEL) {
-				ret = -EINVAL;
-			} else {
-				msgring_debug_level = level;
-				ret = count;
-			}
-		} else {
-			ret = -ENOSPC;
-		}
-	}
-	return ret;
-}
-
-
-static int msgring_debug_init(void) {
-	msgring_debug = proc_mkdir("msgring_debug", nlm_root_proc);
-	if(!msgring_debug) {
-		printk(KERN_ERR "unable to create /proc/msgring_debug.\n");
-		initstatus = -ENOMEM;
-	}
-
-	if(!initstatus) {
-		msgring_dbglevel = create_proc_entry("level", 0644, msgring_debug);
-		if(!msgring_dbglevel) {
-			printk(KERN_ERR "unable to create proc entry: /proc/msgring_debug/level.\n");
-			initstatus = -ENOMEM;
-			remove_proc_entry("msgring_debug", nlm_root_proc);
-		} else {
-			msgring_dbglevel->read_proc = msgring_debug_read;
-			msgring_dbglevel->write_proc = msgring_debug_write;
-		}
-	}
-	return initstatus;
-}
-
-static void msgring_debug_exit(void) {
-	if(!initstatus) {
-		remove_proc_entry("level", msgring_debug);
-		remove_proc_entry("msgring_debug", nlm_root_proc);
-	}
-}
-
-module_init(msgring_debug_init);
-module_exit(msgring_debug_exit);
diff --git a/drivers/char/nlm_common_rmios_debugger.c b/drivers/char/nlm_common_rmios_debugger.c
deleted file mode 100644
index dfb844a..0000000
--- a/drivers/char/nlm_common_rmios_debugger.c
+++ /dev/null
@@ -1,327 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
-#include <linux/poll.h>
-#include <linux/workqueue.h>
-#include <linux/module.h>
-#include <linux/init.h>
-/*#include <linux/proc_fs.h>*/
-/*#include <linux/cpumask.h>*/
-
-#include <asm/uaccess.h>
-#include <asm/mman.h>
-#include <asm/atomic.h>
-#include <asm/smp.h>
-#include <asm/bootinfo.h>
-
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/devices.h>
-#include <asm/netlogic/nlm_common_rmios_debugger.h>
-
-#define PHXDEB_DIAG(a, b...) //printk(a, ##b)
-#define ErrorMsg(a, b...) printk(a, ##b) 
-//#define barrier() __asm__ __volatile__(".set mips3\n" "sync": : :"memory")
-
-struct nlm_common_rmios_debugger_struct {
-	int cpu;
-	int bucket;
-	int code;
-	int msgsize;
-	int stid;
-	struct msgrng_msg msg;
-	uint64_t buf;
-	uint64_t mem_addr;
-};
-static spinlock_t nlm_common_rmios_debugger_lock[LINUX_RMIOS_VCPU];
-static struct __wait_queue_head nlm_common_rmios_debugger_waitq[LINUX_RMIOS_VCPU];
-static u32 length[LINUX_RMIOS_VCPU];
-static struct nlm_common_rmios_debugger_struct nlm_common_rmios_debugger_data[LINUX_RMIOS_VCPU][2]; /* one pending message allowed. */
-static int nlm_common_rmios_data_available[LINUX_RMIOS_VCPU];
-static spinlock_t msgrng_lock;
-
-
-static ssize_t nlm_common_rmios_debugger_read(struct file *filep, char __user *user,
-					size_t len, loff_t *offset)
-{
-	int cpu;
-	struct nlm_common_rmios_debugger_struct local;
-	if(copy_from_user((void *)&local, (void __user *)user, sizeof(local))) {
-		ErrorMsg("Invalid address\n");
-		return -EINVAL;
-	}
-	cpu = local.cpu;
-
-	wait_event_interruptible(nlm_common_rmios_debugger_waitq[cpu], (nlm_common_rmios_data_available[cpu] > 0) /* condition */);
-
-    
-	if(copy_to_user((void __user *)user, (void *)&nlm_common_rmios_debugger_data[cpu][0], sizeof(local))){
-		return -EINVAL;
-	}
-	spin_lock_irq(&nlm_common_rmios_debugger_lock[cpu]);
-	nlm_common_rmios_data_available[cpu]--;
-	if (nlm_common_rmios_data_available[cpu]) {
-		nlm_common_rmios_debugger_data[cpu][0].code = 
-			nlm_common_rmios_debugger_data[cpu][1].code;
-		nlm_common_rmios_debugger_data[cpu][0].msgsize =
-			nlm_common_rmios_debugger_data[cpu][1].msgsize;
-		nlm_common_rmios_debugger_data[cpu][0].stid =
-			nlm_common_rmios_debugger_data[cpu][1].stid;
-		memcpy(&(nlm_common_rmios_debugger_data[cpu][0].msg), &(nlm_common_rmios_debugger_data[cpu][1].msg), sizeof(struct msgrng_msg));
-	}
-	spin_unlock_irq(&nlm_common_rmios_debugger_lock[cpu]);
-	return 0;
-}
-
-static ssize_t nlm_common_rmios_debugger_write(struct file *filep, const char __user *user,
-					size_t len, loff_t *offset)
-{
-	struct nlm_common_rmios_debugger_struct local;
-	struct msgrng_msg msg;
-	int bucket;
-	int code;
-	int msgsize;
-	unsigned long flags, msgrng_flags;
-
-	if(copy_from_user((void *)&local, (void __user *)user, sizeof(local))) {
-		ErrorMsg("Invalid address\n");
-		return -EINVAL;
-	}
-	bucket = local.bucket;
-	code = local.code;
-	msgsize = local.msgsize;
-	memcpy(&msg, &local.msg, sizeof(msg));
-	
-	msgrng_access_save(&msgrng_lock, flags, msgrng_flags);
-
-	while ((code = message_send(msgsize, code, bucket, &msg)) != 0) { };     
-
-	PHXDEB_DIAG("Message Sent:   code = %x\n", code);
-
-	msgrng_access_restore(&msgrng_lock, flags, msgrng_flags); 
-	return 0;
-
-}
-
-static int nlm_common_rmios_debugger_ioctl(struct inode *inode, struct file *file,
-        unsigned int cmd, unsigned long arg)
-{
-	struct nlm_common_rmios_debugger_struct local;
-	struct msgrng_msg msg;
-	int bucket;
-	int code;
-	int msgsize=0;
-	int cpu;
-	unsigned long flags, msgrng_flags;
-	char *buf;
-	
-	if (copy_from_user(&local, (void __user *)arg, sizeof(local)))
-	{
-		ErrorMsg("Invalid address\n");
-		return -EINVAL;
-	}
-	cpu = local.cpu;
-
-	switch (cmd) {
-		case NLM_RMIOS_DEBUGGER_WRITE: 
-			bucket = local.bucket;
-			code = local.code;
-			msgsize = local.msgsize;
-			memcpy(&msg, &local.msg, sizeof(msg));
-			msgrng_access_save(&msgrng_lock, flags, msgrng_flags);
-
-			while ((code = message_send(msgsize, code, bucket, &msg)) != 0) { };     
-
-			PHXDEB_DIAG("Message Sent:   code = %x\n", code);
-
-			msgrng_access_restore(&msgrng_lock, flags, msgrng_flags); 
-			break;
-		case NLM_RMIOS_DEBUGGER_READ:
-			wait_event_interruptible(nlm_common_rmios_debugger_waitq[cpu], (nlm_common_rmios_data_available[cpu] > 0) /* condition */);
-
-			spin_lock_irq(&nlm_common_rmios_debugger_lock[cpu]);
-			if (copy_to_user((void __user *)arg, (void *)&nlm_common_rmios_debugger_data[cpu][0], sizeof(local))){
-				return -EINVAL;
-			}
-			nlm_common_rmios_data_available[cpu]--;
-			if (nlm_common_rmios_data_available[cpu]) {
-				nlm_common_rmios_debugger_data[cpu][0].code = 
-					nlm_common_rmios_debugger_data[cpu][1].code;
-				nlm_common_rmios_debugger_data[cpu][0].msgsize =
-					nlm_common_rmios_debugger_data[cpu][1].msgsize;
-				nlm_common_rmios_debugger_data[cpu][0].stid =
-					nlm_common_rmios_debugger_data[cpu][1].stid;
-				memcpy(&(nlm_common_rmios_debugger_data[cpu][0].msg), &(nlm_common_rmios_debugger_data[cpu][1].msg), sizeof(struct msgrng_msg));
-			}
-			spin_unlock_irq(&nlm_common_rmios_debugger_lock[cpu]);
-			break;
-		case NLM_RMIOS_DEBUGGER_TX_MEM_WRITE:
-			buf = (unsigned char *)(LINUX_RMIOS_TX_BUF_BASE + LINUX_RMIOS_TX_BUF_SIZE * cpu);
-			msgsize = local.msgsize;
-			if (copy_from_user(buf, (void __user *)(long)(local.buf), msgsize))
-			{
-				ErrorMsg("Invalid address\n");
-				return -EINVAL;
-			}
-			barrier();
-			break;
-		case NLM_RMIOS_DEBUGGER_TX_MEM_READ:
-			buf = (unsigned char *)(LINUX_RMIOS_TX_BUF_BASE + LINUX_RMIOS_TX_BUF_SIZE * cpu);
-			msgsize = local.msgsize;
-			if (copy_to_user((void __user *)(long)(local.buf), (void *)buf, msgsize))
-			{
-				ErrorMsg("Invalid address\n");
-				return -EINVAL;
-			}
-			break;
-		case NLM_RMIOS_DEBUGGER_RX_MEM_WRITE:
-			buf = (unsigned char *)(LINUX_RMIOS_RX_BUF_BASE + LINUX_RMIOS_RX_BUF_SIZE * cpu);
-			msgsize = local.msgsize;
-			if (copy_from_user(buf, (void __user *)(long)(local.buf), msgsize))
-			{
-				ErrorMsg("Invalid address\n");
-				return -EINVAL;
-			}
-			barrier();
-			break;
-		case NLM_RMIOS_DEBUGGER_RX_MEM_READ:
-			buf = (unsigned char *)(LINUX_RMIOS_RX_BUF_BASE + LINUX_RMIOS_RX_BUF_SIZE * cpu);
-			msgsize = local.msgsize;
-			if (copy_to_user((void __user *)(long)(local.buf), (void *)buf, msgsize))
-			{
-				ErrorMsg("Invalid address\n");
-				return -EINVAL;
-			}
-			break;
-		case NLM_RMIOS_DEBUGGER_MEM_READ:
-			buf = (char *)(long)(local.mem_addr);
-			msgsize = local.msgsize;
-			if (copy_to_user((void __user *)(long)(local.buf), (void *)buf, msgsize))
-			{
-				ErrorMsg("Invalid address\n");
-				return -EINVAL;
-			}
-			break;
-		case NLM_RMIOS_DEBUGGER_MEM_WRITE:
-			buf = (char *)(long)(local.mem_addr);
-			msgsize = local.msgsize;
-			if (copy_from_user(buf, (void __user *)(long)(local.buf), msgsize))
-			{
-				ErrorMsg("Invalid address\n");
-				return -EINVAL;
-			}
-			barrier();
-			break;
-		case NLM_RMIOS_DEBUGGER_PIC_IPI:
-			{
-			nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);	
-			netlogic_write_reg(mmio, PIC_IPI, local.cpu);
-			}
-			break;
-		default:
-			ErrorMsg("Invalid command\n");
-			return -EINVAL;
-	}
-	return 0;
-}
-
-static long nlm_common_rmios_debugger_compat_ioctl(struct file *filp, unsigned int cmd,
-                unsigned long arg)
-{
-        unsigned long ret = -1;
-        lock_kernel();
-        ret = nlm_common_rmios_debugger_ioctl(NULL, filp, cmd, arg);
-        unlock_kernel();
-        if(ret){
-                printk("%s: ioctl error\n", __FUNCTION__);
-                return -EINVAL;
-        }
-        return ret;
-}
-
-static int nlm_common_rmios_debugger_open(struct inode *inode, struct file *filp)
-{
-	return 0;
-}
-
-static int nlm_common_rmios_debugger_release(struct inode *inode, struct file *filp)
-{
-	return 0;
-}
-
-struct file_operations nlm_common_rmios_debugger_fops = {
-	.owner    = THIS_MODULE,
-	.open     = nlm_common_rmios_debugger_open,
-	.release  = nlm_common_rmios_debugger_release,
-	.read     = nlm_common_rmios_debugger_read,
-	.write    = nlm_common_rmios_debugger_write,
-	.ioctl    = nlm_common_rmios_debugger_ioctl,
-	.compat_ioctl    = nlm_common_rmios_debugger_compat_ioctl, /* 32-bit appn in 64-bit linux goes through this */
-};
-
-static int nlm_common_rmios_debugger_major;
-
-static int nlm_common_rmios_debugger_init(void)
-{
-	int i;
-	printk("%s - Phnx Rmios Debugger\n", __FUNCTION__);
-
-	nlm_common_rmios_debugger_major = register_chrdev(XLR_DEBUGGER_MAJOR, NLM_DEB_DEV_NAME, 
-			&nlm_common_rmios_debugger_fops);
-	if(nlm_common_rmios_debugger_major < 0) {
-		printk("%s: register_chrdev() failed\n", __FUNCTION__);
-		return nlm_common_rmios_debugger_major;
-	}
-	printk("Created Device %s with major number %d\n", NLM_DEB_DEV_NAME,
-				XLR_DEBUGGER_MAJOR);
-	for (i = 0; i < LINUX_RMIOS_VCPU; i++) {
-		init_waitqueue_head(&nlm_common_rmios_debugger_waitq[i]);
-		spin_lock_init(&nlm_common_rmios_debugger_lock[i]);
-	}
-	return 0;
-}
-
-static void nlm_common_rmios_debugger_exit(void)
-{
-	printk("%s - Exit called\n", __FUNCTION__);
-	unregister_chrdev(nlm_common_rmios_debugger_major, NLM_DEB_DEV_NAME);
-}
-
-static void __init reserve_linux_rmios_memory(void)
-{
-	add_memory_region (LINUX_RMIOS_SHARED_BASE, 0x10000, BOOT_MEM_RESERVED);
-}
-early_initcall(reserve_linux_rmios_memory);
-
-
-module_init(nlm_common_rmios_debugger_init);
-module_exit(nlm_common_rmios_debugger_exit);
-
diff --git a/drivers/char/nlm_common_tb.c b/drivers/char/nlm_common_tb.c
deleted file mode 100644
index b8bf5c6..0000000
--- a/drivers/char/nlm_common_tb.c
+++ /dev/null
@@ -1,320 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <asm/uaccess.h>
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/nlm_common_tb.h>
-#include <linux/nlm_common_tb.h>
-#include <asm/netlogic/sim.h>
-
-#define NLM_TB_DEBUG 1
-#define TB_INT_FLAGS 0
-
-#define Message(a,b...) //printk("\n"a"\n",##b)
-#define ErrorMsg(a,b...) printk("\n"a"\n",##b)
-
-
-static int			tb_major;
-long tb_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
-static spinlock_t trace_buf_lock=SPIN_LOCK_UNLOCKED;
-static int tb_is_opened = 0;
-tb_dev_t    tb_dev; 
-loff_t tb_seek (struct file *filp, loff_t offset, int where);
-
-
-
-struct file_operations tb_fops = {
-	.read	    = tb_read,
-	.open	    = tb_open,
-	.llseek	    = tb_seek,
-	.ioctl      = tb_ioctl,
-	.release    = tb_release,
-	.compat_ioctl = tb_compat_ioctl,
-};
-
-
-
-/* -----------------------------    LAYER 2 Code   ------------------------------ */
-
-static inline void read_tb_entry(unsigned char *tb_entry_ptr)
-{
-	int j;
-	unsigned int *x;
-
-	tb_pop_entry();
-	for (j = 0; j < 4; ++j) {
-		x = (unsigned int *) (tb_entry_ptr + 4*j);
-		*x = tb_read_rddata_reg (j);
-	}
-}
-
-
-irqreturn_t tb_int_handler(int irq, void *dev_id) 
-{
-  unsigned int  status_reg, ctrl_reg;
-	unsigned int  tb_wr_ptr, tb_rd_ptr, tb_first_match_ptr;
-	int    m, n;
-	unsigned int no_of_junk_entry;
-	unsigned int no_of_valid_entry;
-	unsigned int req_read_pos =0;
-	status_reg = tb_read_status_reg();
-	Message("Interrupt Handler Called.");
-	
-	if (!TB_IS_STATUS_DONE(status_reg)){
-		ErrorMsg("something is wrong as int must not have been generated");
-		return IRQ_HANDLED;
-	}
-
-	tb_wr_ptr = TB_GET_WRPTR(status_reg);
-	tb_rd_ptr = TB_GET_RDPTR(status_reg);
-	tb_first_match_ptr = TB_GET_FIRST_MATCH_PTR(status_reg); 
-
-	ctrl_reg = tb_read_ctrl_reg();
-	n = TB_GET_CTRL_REQCNT(ctrl_reg);
-
-	Message("tb_wr_ptr %d, tb_rd_ptr %d, tb_first_match_ptr %d, Count %d",
-									tb_wr_ptr,tb_rd_ptr,tb_first_match_ptr,n);
-
-	if (!(status_reg & TB_FULL)) {
-		req_read_pos = tb_first_match_ptr;
-		no_of_valid_entry = n;
-	} else {
-		if (tb_first_match_ptr >= tb_rd_ptr)
-			no_of_valid_entry = tb_first_match_ptr - tb_rd_ptr;
-		else 
-			no_of_valid_entry = 256 - ( tb_rd_ptr - tb_first_match_ptr);
-		req_read_pos = no_of_valid_entry;
-	}
-	no_of_junk_entry = req_read_pos;
-
-	while(no_of_junk_entry--)
-	  tb_pop_entry();
-
-	status_reg = tb_read_status_reg();
-	tb_rd_ptr = TB_GET_RDPTR(status_reg);
-	Message("After Removin Junk Entry ReadPtr %d",tb_rd_ptr);
-	
-	tb_dev.size = 16 * TB_GET_CTRL_REQCNT(ctrl_reg);
-	for (m = 0; m < tb_dev.size; m += 16)
-	  read_tb_entry (tb_dev.data + m);
-
-	status_reg = tb_read_status_reg();
-	tb_rd_ptr = TB_GET_RDPTR(status_reg);
-	Message("After Popin All Valid Entry ReadPtr %d",tb_rd_ptr);
-	return IRQ_HANDLED;
-}
-
-/* -----------------------------    LAYER 3 Code   ------------------------------ */
-
-int tb_open (struct inode *inode, struct file *filp)
-{
-	unsigned long flags=0;
-
-	Message("tb_open() invoked");
-	spin_lock_irqsave(&trace_buf_lock,flags);
-	if(tb_is_opened){
-		spin_unlock_irqrestore(&trace_buf_lock,flags);
-		return -1;
-	}
-	tb_is_opened = 1;
-	spin_unlock_irqrestore(&trace_buf_lock,flags);
-	tb_dev.size =0;
-	return 0;
-}
-
-ssize_t tb_read (struct file *filp, char *buf, size_t count, loff_t *offset)
-{
-	// if current position is past the size of the buffer
-
-	if (*offset >= tb_dev.size)
-		return 0;
-
-	if ((*offset + count) > tb_dev.size)
-		count = tb_dev.size - *offset;
-
-	if (__copy_to_user (buf, (tb_dev.data+*offset) , count))
-		return -EFAULT;
-
-	*offset += count;
-	return count;
-}
-
-loff_t tb_seek (struct file *filp, loff_t offset, int where)
-{
-	loff_t position;
-
-	switch(where) {
-		case 0: /* SEEK_SET */
-			position = offset;
-			break;
-		case 1: /* SEEK_CUR */
-			position = filp->f_pos + offset;
-			break;
-		case 2: /* SEEK_END */
-			position = tb_dev.size + offset;
-			break;
-		default: 
-			return -EINVAL;
-	}
-	if (position < 0) 
-		return -EINVAL;
-	filp->f_pos = position;
-	return position;
-}
-
-
-long tb_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	unsigned long ret = -1;
-	lock_kernel();	
-	ret = tb_ioctl(NULL,filp,cmd,arg);
-	unlock_kernel();
-	if(ret){
-		ErrorMsg("tb_ioctl returned with an error.");
-		return -ENOIOCTLCMD;
-	}
-	return ret;
-}
-
-
-int tb_ioctl (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	switch (cmd) {
-		case TB_IOC_GTBREG: {
-			struct tb_register requested_reg;
-		
-			Message("file: %s, line: %d: ioctl(): TB_IOC_GTBREG\n", __FILE__, __LINE__);
-			// copy_from_user(to, from, size)
-			if ( copy_from_user (&requested_reg, (struct tb_register *)arg, 
-					sizeof(struct tb_register))) {
-				ErrorMsg("ioctl(): copy_to_user() failed in file %s at line %d",
-					__FILE__, __LINE__);
-				return -EFAULT;
-			}
-			if(requested_reg.type > 0xf || requested_reg.type < 0){
-				ErrorMsg("Invalid Register Access");
-				return -EINVAL;
-			}
-			requested_reg.val = tb_read_reg_be32(requested_reg.type);
-			if ( copy_to_user ((struct tb_register *) arg, &requested_reg, 
-					sizeof(struct tb_register)) ) {
-				ErrorMsg("ioctl(): copy_to_user() failed in file %s at line %d",
-					__FILE__, __LINE__);
-				return -EFAULT;
-			}
-		}
-			break;
-
-		case TB_IOC_STBREG: {
-			struct tb_register reg;
-		
-			Message("file: %s, line: %d: ioctl(): TB_IOC_STBREG\n", __FILE__, __LINE__);
-			// copy_from_user(to, from, size)
-			if ( copy_from_user (&reg, (struct tb_register *)arg, 
-					sizeof(struct tb_register))) {
-				ErrorMsg("ioctl(): copy_to_user() failed in file %s at line %d",
-					__FILE__, __LINE__);
-				return -EFAULT;
-			}
-			if(reg.type > 0xf || reg.type < 0){
-				ErrorMsg("Invalid Register Access");
-				return -EINVAL;
-			}
-
-
-			tb_write_reg_be32(reg.type, reg.val);
-			if (reg.type == TB_CTRL_REG) {
-							unsigned int x;
-
-							Message("ioctl(): the reqcnt in the ctrl reg is(1): %d\n", TB_GET_CTRL_REQCNT(reg.val));
-							x = tb_read_ctrl_reg();
-							Message("ioctl(): the reqcnt in the ctrl reg is(2): %d\n", TB_GET_CTRL_REQCNT(x));
-			}
-			
-		}
-			break;
-
-		case TB_IOC_REINIT: {
-			Message("file: %s, line: %d: ioctl(): TB_REINIT\n", __FILE__, __LINE__);
-			tb_reinit();
-			tb_dev.size =0;
-		}
-			break;
-
-		default:
-			ErrorMsg("Unindentified ioctl() command");
-			return -EINVAL;
-	}
-
-	return 0;
-}
-
-int tb_release (struct inode *inode, struct file *filp)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&trace_buf_lock,flags);
-	tb_is_opened = 0;
-	spin_unlock_irqrestore(&trace_buf_lock,flags);
-	return 0;
-}
-
-// tb_init(): invoked as part of the kernel bootup process
-static int tb_init(void)	
-{
-	int err=0;
-
-	Message("tb_init() invoked");
-	tb_major = register_chrdev (240, "xlr_tracebuffer", &tb_fops);
-	if (tb_major < 0) {
-		ErrorMsg("tb_init() register_chrdev() failed");
-		return tb_major;
-	}
-	
-	// the handler too gets registered in the following call 
-	err = request_irq(PIC_BRIDGE_TB_IRQ(), tb_int_handler, TB_INT_FLAGS, "trace buffer", NULL);
-	if (err) {
-		unregister_chrdev (tb_major, "trace buffer");
-		ErrorMsg("tb_init(): request_irq() failed");
-		return err;
-	}
-	tb_dev.data = (unsigned char *)kmalloc(TB_SIZE,GFP_KERNEL);
-	Message("tb_init() request_irq() succeeded");
-	printk("Registered tracebuffer driver with Major No. [%d]\n", 240);
-
-	return 0;
-}
-
-static void tb_exit(void)
-{
-	free_irq(PIC_BRIDGE_TB_IRQ(), NULL);
-	kfree(tb_dev.data);
-
-	unregister_chrdev (tb_major, "trace buffer");
-}
-module_init (tb_init);
-module_exit (tb_exit);
-// Do we need to export any names ?
diff --git a/drivers/char/nlm_common_uart.c b/drivers/char/nlm_common_uart.c
deleted file mode 100644
index 384407b..0000000
--- a/drivers/char/nlm_common_uart.c
+++ /dev/null
@@ -1,684 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/console.h>
-#include <linux/termios.h>
-#include <linux/tty.h>
-#include <linux/tty_flip.h>
-#include <linux/serial.h>
-#include <linux/tty_driver.h>
-#include <linux/kdev_t.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-
-#include <asm/io.h>
-#include <asm/uaccess.h>
-
-#include <asm/netlogic/interrupt.h>
-#include <asm/netlogic/nlm_common_uart.h>
-
-/**************************************************************
- *
- * Serial Console 
- *
- ****************************************************************/
-
-#define NUM_CHANNELS     2
-#define NUM_CHANNEL_REGS 32
-#define NUM_GLOBAL_REGS  5
-
-#define CONFIG_CHAN_REG_SIZE (NUM_CHANNELS     *  \
-                                    NUM_CHANNEL_REGS )
-
-#define CONFIG_REG_SIZE      (NUM_CHANNELS     *  \
-                              NUM_CHANNEL_REGS +  \
-                              NUM_GLOBAL_REGS )
-
-enum GDA_UART_REGS {
-  THR = 0,
-  RHR,
-  IER,
-  IIR,
-  FCR,
-  LCR,
-  MCR,
-  LSR,
-  MSR,
-  SCR,
-  CSR,
-  M_IER,
-  M_ISR,
-  M_CSR,
-  M_TX_ADDR,
-  M_RX_AD,
-  M_TX_LEN,
-  M_RX_LEN,
-  GI_GR,
-  GI_SR_0,
-  GI_SR_1,
-  GI_SR_2,
-  GI_SR_3,
-  DLL,
-  DLM,
-};
-
-static volatile __u32 *mmio;
-
-#define GDA_TX_FIFO_BUF_SIZE 128
-
-struct fifo {
-  __u8 buf[GDA_TX_FIFO_BUF_SIZE];
-  int head;
-  int tail;
-  spinlock_t lock;
-};
-
-struct channel_info {
-  struct tty_struct *tty;
-  struct fifo        tx_fifo;
-  unsigned int       open_count;
-};
-
-static struct channel_info gda_channels[NUM_CHANNELS];
-
-static __inline__ void fifo_init(struct fifo *f)
-{
-  f->head = f->tail = 0;
-  spin_lock_init(&f->lock);
-}
-
-static __inline__ int fifo_empty(struct fifo *f)
-{
-  int ret = 0;
-  __u32 flags = 0;
-  
-  spin_lock_irqsave(&f->lock, flags);
-  ret = (f->head == f->tail);
-  spin_unlock_irqrestore(&f->lock, flags);
-
-  return ret;
-}
-
-#define FIFO_NEXT(p) ( ((p) + 1) % GDA_TX_FIFO_BUF_SIZE)
-
-static __inline__ int fifo_full(struct fifo *f)
-{
-  int ret = 0;
-  __u32 flags = 0;
-  
-  spin_lock_irqsave(&f->lock, flags);
-  ret = (FIFO_NEXT(f->tail) == f->head);
-  spin_unlock_irqrestore(&f->lock, flags);
-
-  return ret;  
-}
-
-static __inline__ int fifo_enqueue(struct fifo *f, __u8 data)
-{
-  int ret = 0;
-  __u32 flags = 0;
-  
-  spin_lock_irqsave(&f->lock, flags);
-  if (FIFO_NEXT(f->tail) == f->head)
-    goto out;
-  
-  f->buf[f->tail] = data;
-  f->tail = FIFO_NEXT(f->tail);
-  ret = 1;
-
-out:
-  spin_unlock_irqrestore(&f->lock, flags);
-  
-  return ret;
-}
-
-static __inline__ int fifo_dequeue(struct fifo *f, __u8 *data)
-{
-  __u32 flags = 0;
-  int ret = 0;
-  
-  spin_lock_irqsave(&f->lock, flags);
-  if (f->head == f->tail)
-    goto out;
-  
-  *data = f->buf[f->head];
-  f->head = FIFO_NEXT(f->head);
-  ret = 1;
-
- out:
-  spin_unlock_irqrestore(&f->lock, flags);
-  
-  return ret;
-}
-
-static __inline__ int fifo_count(struct fifo *f)
-{
-  int ret = 0;
-  __u32 flags = 0;
-
-  spin_lock_irqsave(&f->lock, flags);  
-  ret = (f->head <= f->tail ? (f->tail - f->head) : (GDA_TX_FIFO_BUF_SIZE - f->head + f->tail));
-  spin_unlock_irqrestore(&f->lock, flags);    
-
-  return ret;
-}
-
-static __inline__ int fifo_room(struct fifo *f)
-{
-  int ret = 0;
-  __u32 flags = 0;
-  __u32 count = 0;
-
-  /* Note: fifo implementation "wastes" one space in the buffer */
-  spin_lock_irqsave(&f->lock, flags);
-  count = (f->head <= f->tail ? (f->tail - f->head) : (GDA_TX_FIFO_BUF_SIZE - f->head + f->tail));
-  ret = (GDA_TX_FIFO_BUF_SIZE - count - 1);
-  spin_unlock_irqrestore(&f->lock, flags);
-
-  return ret;
-}
-
-static volatile __u32  gda_read_reg(int chan, int reg);
-static void  gda_write_reg(int chan, int reg, __u32 data);
-
-static void  gda_write_reg(int chan, int reg, __u32 data)
-{
-  if (reg == GI_GR || (reg >= GI_SR_0 && reg <= GI_SR_0+3)) {
-    mmio[ CONFIG_CHAN_REG_SIZE + (reg - GI_GR) ] = data;
-    return;
-  }
-
-  if (chan < 0 || chan >= NUM_CHANNELS || reg < 0 || reg >= 32)
-    return;
-  
-  if (reg == DLL || reg == DLM) {
-    gda_write_reg(chan, LCR, (gda_read_reg(chan, LCR) | (0x01<<7)) );
-
-    if (reg == DLL)
-      gda_write_reg(chan, THR, data);
-    else
-      gda_write_reg(chan, RHR, data);
-    
-    gda_write_reg(chan, LCR, (gda_read_reg(chan, LCR) & ~(0x01<<7)) );
-    return;
-  }
-  
-  mmio[ (chan << 5) + (reg) ] = data;
-}
-
-static volatile __u32 gda_read_reg(int chan, int reg)
-{
-  if (reg == GI_GR || (reg >= GI_SR_0 && reg <= GI_SR_0+3)) 
-    return mmio[ CONFIG_CHAN_REG_SIZE + (reg - GI_GR) ];
-
-  if (chan < 0 || chan >= NUM_CHANNELS || reg < 0 || reg >= 32)
-    return ~0;
-  
-  if (reg == DLL || reg == DLM) {
-    volatile __u32 data = 0;
-
-    gda_write_reg(chan, LCR, (gda_read_reg(chan, LCR) | (0x01<<7)) );
-
-    if (reg == DLL)
-      data = gda_read_reg(chan, THR);
-    else
-      data = gda_read_reg(chan, RHR);
-
-    gda_write_reg(chan, LCR, (gda_read_reg(chan, LCR) & ~(0x01<<7)) );
-
-    return data;
-  }
-  
-  return mmio[ (chan << 5) + (reg)];
-}
-/**************************************************************
- *
- * Serial driver
- *
- ****************************************************************/
-static spinlock_t open_lock = SPIN_LOCK_UNLOCKED;
-
-static __inline__ unsigned int get_channel(struct tty_struct *tty)
-{
-  /*return MINOR(tty->device) - tty->driver.minor_start;*/
-  return tty->index;
-}
-
-static irqreturn_t serial_int_handler(int irq, void *data, struct pt_regs *regs)
-{
-  unsigned char ch             = 0;
-  unsigned int chan            = 0;
-  struct channel_info *channel = 0;
-   __u32 lsr             = 0; 
-   __u32 flags           = 0;
-   __u32 int_grp         = 0;
-   __u32 int_sel         = 0;
-   __u32 iid             = 0;
-   __u32 iir             = 0;
-   int i = 0, j = 0;
-
-   for (;;) { /* Repeat as long as the GI_GR has bits set */
-
-     /* Determine the Channel */
-     int_grp = gda_read_reg(-1, GI_GR);
-     if (!int_grp) break;
-     
-     /* XXX: Should use count leading zeros or figure out someother smarter
-      * way to calc the set bits instead of iterating thru all possible bits
-      */     
-     for (i=0;i<4;i++) {
-
-       if (!(int_grp & (1<<i)))
-	 continue;
-   
-       int_sel = gda_read_reg(-1, GI_SR_0 + i);
-       if (!int_sel) break;
-
-       for (j=0;j<8;j++) {
-
-	 if (!(int_sel & (1<<j)))
-	   continue;
-
-	 chan     = (i<<8) + j;
-	 channel  = gda_channels + chan;
-
-	 iir = gda_read_reg(chan, IIR);
-   
-	 /* intr_pending? */
-	 if (iir & 0x01)
-	   continue;
-
-	 iid = (iir >> 1) & 0x07;
-
-	 if (iid == 3 || iid == 2 || iid == 1) {
-	   /* Recv Line Status, Recv Data Avail, THR Empty */
-     
-	   for (;;) {
-	     int k=0;
-       
-	     lsr = gda_read_reg(chan, LSR);
-       
-	     if (lsr == 0)
-	       break;
-       
-	     if (lsr & 0x40) {
-	       __u8 data = 0;
-	 
-	       for(k=0;k<8;k++) {
-
-		 if (fifo_dequeue(&channel->tx_fifo, &data))
-		   gda_write_reg(chan, THR, data);	 
-		 else
-		   break;
-
-	       }
-	       if (fifo_empty(&channel->tx_fifo)) {
-
-		 gda_write_reg(chan, IER, (gda_read_reg(chan, IER) & ~0x02));
-		 if (channel->tty->ldisc.write_wakeup)
-		   channel->tty->ldisc.write_wakeup(channel->tty);
-		 wake_up_interruptible(&(channel->tty->write_wait));
-
-	       }
-	     }
-       
-	     ch = 0;     
-	     if (lsr & 0x81) {
-
-	       /* Receive FIFO error */
-	       if (lsr & 0x08)
-		 flags |= TTY_FRAME;
-
-	       if (lsr & 0x04)
-		 flags |= TTY_PARITY;     
-
-	       if (lsr & 0x01)
-		 ch = (gda_read_reg(chan, RHR) & 0xff);
-
-	       tty_insert_flip_char(channel->tty, ch, flags);
-	     }
-	     if (lsr & 0x02) 
-	       tty_insert_flip_char(channel->tty, 0, TTY_OVERRUN);
-	   }
-	   tty_flip_buffer_push(channel->tty);
-	   
-	 }
-	 else {
-	   /* Char Time Out, Modem Status Change, Tx & Rx Buffer Status */
-	   printk("[%s]: Unhandled value in IIR!\n", __FUNCTION__);
-	 }
-       }
-     }
-   } /* All channels */
-
-   return IRQ_HANDLED;
-}
-
-static int serial_open(struct tty_struct *tty, struct file *filp)
-{
-  unsigned long flags          = 0;
-  unsigned int chan            = get_channel(tty);
-  struct channel_info *channel = gda_channels + chan;
-  
-  spin_lock_irqsave(&open_lock, flags);
-  if (!channel->open_count) {
-    tty->driver_data = channel;
-    channel->tty     = tty;
-  }
-  channel->open_count++;
-  gda_write_reg(chan, IER, 0x05);/* Enable all interrupts */  
-  spin_unlock_irqrestore(&open_lock, flags);
-  
-  return 0;
-}
-
-static void serial_close(struct tty_struct *tty, struct file *filp)
-{
-  struct channel_info *channel = gda_channels + get_channel(tty);
-  unsigned long flags = 0;
-
-  if (!channel || !channel->open_count)
-    return;
-
-  spin_lock_irqsave(&open_lock, flags);
-  channel->open_count--;
-  if (!channel->open_count) {
-    channel->tty     = 0;
-    tty->driver_data = 0;
-  }
-  spin_unlock_irqrestore(&open_lock, flags);
-}
-
-static void serial_put_char(struct tty_struct *tty, u_char ch)
-{
-  struct channel_info *channel = (struct channel_info *)tty->driver_data;
-  unsigned int chan            = get_channel(tty);
-
-  fifo_enqueue(&channel->tx_fifo, ch);
-  gda_write_reg(chan, IER, (gda_read_reg(chan, IER) | 0x02));
-}
-
-static int serial_write_room(struct tty_struct *tty)
-{
-  struct channel_info *channel = (struct channel_info *)tty->driver_data;
-  
-  return fifo_room(&channel->tx_fifo);
-}
-
-static int serial_write(struct tty_struct *tty, int from_user, 
-			const unsigned char *buf, int count)
-{
-  int i=0, total=0;
-  unsigned char ch             = 0;
-  struct channel_info *channel = (struct channel_info *)tty->driver_data;
-  unsigned int chan            = get_channel(tty);
-  
-  if (from_user && verify_area(VERIFY_READ, buf, count))
-    return -EINVAL;
- 
-  if (count == 0)
-    return 0;
-
-#ifdef CONFIG_NLMCOMMON_SMP_PREFIX  
-  {
-    __u8 tmp_buf[8];
-    __u8 *p = tmp_buf;
-    sprintf(tmp_buf, "%1d:", smp_processor_id());
-    tmp_buf[7] = 0;
-    for(p=tmp_buf; *p; p++)
-      if (!fifo_enqueue(&channel->tx_fifo, *p))
-	break;
-  }
-#endif
-
-  for (i = 0, total=0; i < count; i++, total++) {
-    if (from_user) 
-      copy_from_user(&ch, &buf[i], 1);
-    else 
-      ch = buf[i];
-    if (!fifo_enqueue(&channel->tx_fifo, ch))
-      break;
-  }
-
-  if (total)
-    gda_write_reg(chan, IER, (gda_read_reg(chan, IER) | 0x02));
-
-  return total;
-}
-
-void serial_set_termios(struct tty_struct *tty, struct termios *old)
-{
-  printk("[%s]: IN\n", __FUNCTION__);
-}
-
-void serial_start(struct tty_struct *tty)
-{
-  printk("[%s]: IN\n", __FUNCTION__);
-}
-
-void serial_stop(struct tty_struct *tty)
-{
-  printk("[%s]: IN\n", __FUNCTION__);
-}
-
-void serial_hangup(struct tty_struct *tty)
-{
-  printk("[%s]: IN\n", __FUNCTION__);
-}
-
-static struct termios    *serial_termios[2];
-static struct termios    *serial_termios_locked[2];
-
-static struct tty_driver serial_driver = {
-  magic:                       TTY_DRIVER_MAGIC,
-  driver_name:                 "serial",
-  name:                        "ttyS",
-  major:                       TTY_MAJOR,
-  minor_start:                 0,
-  num:                         1,
-  type:                        TTY_DRIVER_TYPE_SERIAL,
-  subtype:                     SERIAL_TYPE_NORMAL,
-  flags:                       TTY_DRIVER_REAL_RAW,
-  refcount:                    1,
-  termios:                     serial_termios,
-  termios_locked:              serial_termios_locked,
-
-  open:                        serial_open,
-  close:                       serial_close,
-  write:                       serial_write,
-  write_room:                  serial_write_room,
-  put_char:                    serial_put_char,
-  set_termios:                 serial_set_termios,
-  start:                       serial_start,
-  stop:                        serial_stop,
-  hangup:                      serial_hangup  
-};
-
-static struct pci_device_id nlm_common_serial_id_table[] = {
-  {NLM_PCI_VENDOR_ID, NLM_PCI_UART_DEV_ID, 0xaaaa, 0xaaaa, 0, 0},
-  {0}
-};
-
-static int nlm_common_serial_pci_probe(struct pci_dev *dev, 
-				    const struct pci_device_id *id)
-{
-  static unsigned long     ioaddr = 0;
-  int i = 0;
-
-  printk("[%s]: slot_name = [%s], irq=%d, base=%lx\n", 
-	 __FUNCTION__, dev->slot_name, dev->irq, pci_resource_start(dev, 0));
-  
-  /* Initialize the device */
-  if (request_irq(dev->irq, serial_int_handler, SA_INTERRUPT, "uart0", 0)) 
-    panic("Couldn't get uart0 interrupt line");
-  
-  if (pci_request_regions(dev, "Phoenix Uart")) 
-    panic("[%s]: Cannot reserve MMIO region\n", __FUNCTION__);    
-  
-  ioaddr = (unsigned long)ioremap(pci_resource_start(dev, 0),
-				  pci_resource_len(dev, 0));
-  if (!ioaddr) {
-    panic("[%s]: Unable to ioremap MMIO region %lx @ %lx\n",
-	  __FUNCTION__, pci_resource_len(dev, 0), pci_resource_start(dev, 0));
-  }
-  printk("[%s]: Registered MMIO region (%lx @ %lx): %lx\n",
-	 __FUNCTION__, pci_resource_len(dev, 0), pci_resource_start(dev, 0),
-	 ioaddr);
-  
-  mmio = (volatile __u32 *)ioaddr;
-  
-  for (i=0;i<NUM_CHANNELS;i++) 
-    fifo_init(&(gda_channels[i].tx_fifo));
-
-  return 0;
-}
-
-int nlm_common_uart_init(void)
-{
-  int count = 0;
-  
-  count = pci_register_driver(&nlm_common_serial_driver);
-  if (!count) 
-    printk("[%s]: No devices found? Should wait for a Hot Plug!\n", __FUNCTION__);
-  /*printk("[%s]: count = %d\n", __FUNCTION__, count);*/
-  
-  serial_driver.init_termios = tty_std_termios;
-  
-  gda_write_reg(0, CSR, 0x0f);/* Enable the receiver and transmitter */
-
-  /* TODO: Configure these registers later:
-   * The performance of the simulator varies drastically depending on these
-   * values
-   */
-  /*gda_write_reg(0, DLL, ((16) & 0x00ff));
-    gda_write_reg(0, DLM, ((16) & 0xff00) >> 8);*/
-
-  gda_write_reg(0, LCR, (gda_read_reg(0, LCR) | 0x03));
-  gda_write_reg(0, FCR, 0); /* int trigger level is 0 */
-#if 0
-  {
-    __u32 csr = gda_read_reg(0, CSR);
-    __u32 ier = gda_read_reg(0, IER);
-    
-    /*printk("[%s]: configuring divisor = %08x\n", __FUNCTION__, (512 * smp_num_cpus));*/
-    printk("[%s]: csr = %08x, ier = %08x, divisor = %08x\n", __FUNCTION__, csr, ier, 
-	   ( (gda_read_reg(0, DLM) << 8)| gda_read_reg(0, DLL)) );
-  }
-#endif
-  
-  if (tty_register_driver(&serial_driver)) {
-    printk("Couldn't register xlr uart serial driver\n");
-    return -1;
-  }
-  printk("Registered xlr uart serial driver\n");
-  
-  return 0;
-}
-
-void nlm_common_uart_exit(void)
-{
-  if (tty_unregister_driver(&serial_driver)) 
-    printk("Couldn't unregister xlr uart serial driver\n");
-  
-  pci_unregister_driver(&nlm_common_serial_driver);
-
-  printk("unregistered xlr uart serial driver\n");  
-}
-
-module_init(nlm_common_uart_init);
-module_exit(nlm_common_uart_exit);
-
-/************************************************************************
- * Phoenix Serial Console 
- ************************************************************************/
-
-static void console_write(struct console *cons, const char *str,
-                              unsigned int count)
-{
-  nlm_reg_t *mmio = nlm_common_mmio_offset(NETLOGIC_IO_UART_0_OFFSET);
-  int i=0;
-  int next=0;
-
-  for(;;) {
-
-    for (;;) {
-      nlm_reg_t lsr = netlogic_read_reg(mmio, UART_LSR);
-
-      /* Tx Fifo empty */
-      if (lsr & 0x20) break;
-    }
-
-    for (i=0; i<14 && next<count; i++, next++)
-      netlogic_write_reg(mmio, UART_THR, (int)str[next]);
-
-    /* More to process? */
-    if (next < count) break;
-  }  
-}
-
-static struct tty_driver *console_device(struct console *c, int *index)
-{
-  *index = c->index;
-  return &serial_driver;
-}
-
-static int console_setup(struct console *cons, char *str)
-{
-  nlm_reg_t *mmio = nlm_common_mmio_offset(NETLOGIC_IO_UART_0_OFFSET);
-  int lcr = netlogic_read_reg(mmio, UART_LCR);
-  
-  netlogic_write_reg(mmio, UART_LCR, (lcr | (1<<7)));
-  netlogic_write_reg(mmio, UART_DLB_1, 0x01);
-  netlogic_write_reg(mmio, UART_DLB_2, 0x00);
-  netlogic_write_reg(mmio, UART_LCR, (lcr & ~(1<<7)));
-
-  return 0;
-}
-
-static struct console nlm_common_console = {
-  name:              "ttyS",
-  write:             console_write,
-  device:            console_device,
-  setup:             console_setup,
-  flags:             CON_PRINTBUFFER,
-  index:             -1,
-};
-
-int nlm_common_console_init(void)
-{
-  register_console(&nlm_common_console);
-  
-  return 0;
-}
-
-void nlm_common_console_exit(void)
-{
-  /* do nothing */
-}
-
-console_initcall(nlm_common_console_init);
-
diff --git a/drivers/char/nlm_pcix_gen_dev.c b/drivers/char/nlm_pcix_gen_dev.c
deleted file mode 100644
index 23c375e..0000000
--- a/drivers/char/nlm_pcix_gen_dev.c
+++ /dev/null
@@ -1,277 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/sched.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/compiler.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/netdevice.h>
-#include <linux/interrupt.h>
-#include <linux/etherdevice.h>
-#include <linux/rtnetlink.h>
-#include <linux/delay.h>
-#include <linux/ethtool.h>
-#include <linux/mii.h>
-#include <linux/completion.h>
-#include <linux/crc32.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/atomic.h>
-#include <linux/timer.h>
-#include <asm/netlogic/sim.h>
-#include <linux/bootmem.h>
-#include <asm/bootinfo.h>
-#include <asm/netlogic/nlm_pcix_gen_dev.h>
-//#include <linux/moduleparam.h>
-#define Message(a,b...)  //printk("\nFun [%s]\t"a"\n",__FUNCTION__,##b);
-#define ErrorMsg(a,b...) printk("\nFun [%s]\t"a"\n",__FUNCTION__,##b);
-
-
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-static rwlock_t nlm_mailbox_rw_lock = RW_LOCK_UNLOCKED;
-static spinlock_t nlm_mailbox_spin_lock = SPIN_LOCK_UNLOCKED;
-static int no_of_active_handler;
-
-struct nlm_mailbox_irq{
-  int valid;
-  int disabled;
-  mailbox_handler func;
-  void *data;
-}mailbox_desc[NLM_MAX_IRQS_SUPPORTED];
-#endif
-
-static long nlm_common_shared_mem_base;
-int nlm_pcix_early_setup_dev(void);
-long nlm_common_get_shared_mem_base_dev(void)
-{
-	return nlm_common_shared_mem_base;
-}
-void nlm_common_interrupt_host(void)
-{
-#ifdef XLR_MSI_IS_SUPPORTED
-  nlm_reg_t *pcix_ctrl_mmio = 0;
-  pcix_ctrl_mmio = netlogic_io_mmio(NETLOGIC_IO_PCIX_OFFSET);
-  /* Trigger an MSI to the host */
-  pcix_ctrl_mmio[PCIX_INTRPT_CONTROL_REG] = 0x2;	
-#endif
-}
-
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-static inline void nlm_nlm_common_mask_mailbox(void)
-{
-  nlm_reg_t *pcix_ctrl_mmio = 0;
-  pcix_ctrl_mmio = netlogic_io_mmio(NETLOGIC_IO_PCIX_OFFSET);
-  /*Mask the mailbox interrupts */
-  pcix_ctrl_mmio[PCIX_INTRPT_CONTROL_REG] = 0xc0;
-}
-
-
-static void nlm_nlm_common_unmask_mailbox(void)
-{
-  nlm_reg_t *pcix_ctrl_mmio = 0;
- /* Setup the mailbox and MSI interrupts
-  * Setup the shared memory regions with the host.
- */
-  pcix_ctrl_mmio = netlogic_io_mmio(NETLOGIC_IO_PCIX_OFFSET);
-  //pcix_ctrl_mmio[PCIX_NETLOGIC_CONTROL_REG] = 0xf2;
-  pcix_ctrl_mmio[PCIX_NETLOGIC_CONTROL_REG] = (pcix_ctrl_mmio[PCIX_NETLOGIC_CONTROL_REG] & 0xffffff00) | 0xf2;  
-  pcix_ctrl_mmio[PCIX_INTRPT_CONTROL_REG] = 0x0;
-}
-
-static int nlm_nlm_common_generic_mailbox_handler(int irq, void *data, struct pt_regs *regs)
-{
-  int i;
-  unsigned int status;
-  nlm_reg_t *pcix_ctrl_mmio = 0;
-
-  pcix_ctrl_mmio = netlogic_io_mmio(NETLOGIC_IO_PCIX_OFFSET);
-
-  Message("Got some Mailbox intr");
-/* First ack the interrupt */
-  status = pcix_ctrl_mmio[PCIX_INTRPT_STATUS_REG];
-  if(status == 0) /* Not our interrupt */
-    return IRQ_NONE;
-
-  pcix_ctrl_mmio[PCIX_INTRPT_STATUS_REG] = status;
-
-  read_lock(&nlm_mailbox_rw_lock);
-
-  Message("Scheduling mailbox ISRs");
-  for(i=0; i<NLM_MAX_IRQS_SUPPORTED; i++)
-    if(mailbox_desc[i].valid && !mailbox_desc[i].disabled)
-      mailbox_desc[i].func(mailbox_desc[i].data,regs);
-    
-  read_unlock(&nlm_mailbox_rw_lock);
-  return IRQ_HANDLED;
-}
-
-int nlm_common_enable_mailbox_intr(int *index)
-{
-  mailbox_desc[*index].disabled = 0;
-  spin_lock(&nlm_mailbox_spin_lock);
-
-  no_of_active_handler++;
-  nlm_nlm_common_unmask_mailbox();
-
-  spin_unlock(&nlm_mailbox_spin_lock);
-  return 0;
-}
-
-int nlm_common_disable_mailbox_intr(int *index)
-{
-  mailbox_desc[*index].disabled = 1;
-
-  spin_lock(&nlm_mailbox_spin_lock);
-  no_of_active_handler--;
-  if(no_of_active_handler == 0)
-    nlm_nlm_common_mask_mailbox();
-
-  spin_unlock(&nlm_mailbox_spin_lock);
-  return 0;
-}
-
-int nlm_common_request_mailbox_handler(mailbox_handler func,void *data, int *index)
-{
-  int i;
-  u32 flags;
-
-  Message("Request for mailbox intr reg");
-  write_lock_irqsave(&nlm_mailbox_rw_lock, flags);
-  for(i=0; i<NLM_MAX_IRQS_SUPPORTED; i++)
-    if(!mailbox_desc[i].valid)
-      break;
-  if(i == NLM_MAX_IRQS_SUPPORTED)
-    return -EIO;
-		  
-  mailbox_desc[i].valid = 1;
-  mailbox_desc[i].func = func;
-  mailbox_desc[i].data = data;
-  *index = i;
-  Message("Request for mailbox intr reg SUCCESSFUL index %d", i);
-
-  write_unlock_irqrestore(&nlm_mailbox_rw_lock, flags);
-
-  nlm_common_enable_mailbox_intr(index);
-  return 0;
-}
-
-int nlm_common_free_mailbox_handler(int *index)
-{
-  u32 flags;
-
-  write_lock_irqsave(&nlm_mailbox_rw_lock, flags);
-  mailbox_desc[*index].valid = 0;
-  write_unlock_irqrestore(&nlm_mailbox_rw_lock, flags);
-
-  nlm_common_disable_mailbox_intr(index);
-  return 0;
-}
-#endif
-
-static int nlm_nlm_common_device_generic_init(void)
-{
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-  int err;
-#endif
-
-  nlm_pcix_early_setup_dev();
-  if(xlr_get_pci_mode() == XLR_PCI_HOST_MODE){
-	  nlm_common_shared_mem_base = 0;
-	  return -ENODEV;
-  }
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-  Message("Registring Generic Intr Handler.");	
-  if((err = request_irq(PIC_PCIX_IRQ,nlm_nlm_common_generic_mailbox_handler,
-		SA_INTERRUPT,"nlm_nlm_common_generic_mailbox_handler",NULL)))
-  {
-	  ErrorMsg("Cannot register handler for PCIX irq Error %d", err);
-	  return err;
-  }
-#endif
-  printk(KERN_INFO "Phoenix PCIX Shared membase is %lx\n", nlm_common_shared_mem_base);
-  return 0;
-}
-
-void nlm_nlm_common_device_generic_cleanup(void)
-{
-  free_irq(PIC_PCIX_IRQ,NULL);	
-  return;
-}
-int xlr_get_pci_mode()
-{
-  nlm_reg_t *pcix_ctrl_mmio = netlogic_io_mmio(NETLOGIC_IO_PCIX_OFFSET);
-  uint32_t mode;
-  if(is_xls()){
-      return XLR_PCI_HOST_MODE;
-  }
-  mode = pcix_ctrl_mmio[PCIX_HOST_MODE_CTRL_STATUS_REG];
-  if(mode & 0x2){
-	  return XLR_PCI_HOST_MODE;
-  }
-  return XLR_PCI_DEV_MODE;
-}
-
-int nlm_pcix_early_setup_dev(void)
-{
-  uint32_t mapper ;
-  unsigned long phy_addr;
-  static int done = 0;
-  nlm_reg_t *pcix_ctrl_mmio = netlogic_io_mmio(NETLOGIC_IO_PCIX_OFFSET);
-
-  if(xlr_get_pci_mode() == XLR_PCI_HOST_MODE){
-	  nlm_common_shared_mem_base = 0;
-	  return -ENODEV;
-  }
-
-  if(done)
-    return 0;
-  done = 1;	
-
-  pcix_ctrl_mmio[PCIX_DEVMODE_TBL_BAR0_REG] = (0x8000000 >> 8);
-
-  mapper = pcix_ctrl_mmio[PCIX_DEVMODE_TBL_BAR0_REG];
-  phy_addr = (mapper << 8);
-  nlm_common_shared_mem_base = (long)(int)((mapper << 8) | 0x80000000);
-  
-  return 0;
-}
-
-arch_initcall(nlm_pcix_early_setup_dev);
-
-module_init(nlm_nlm_common_device_generic_init); 
-module_exit(nlm_nlm_common_device_generic_cleanup);
-
-EXPORT_SYMBOL(nlm_common_get_shared_mem_base_dev);
-EXPORT_SYMBOL(nlm_common_interrupt_host);
-EXPORT_SYMBOL(xlr_get_pci_mode);
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-EXPORT_SYMBOL(nlm_common_free_mailbox_handler);
-EXPORT_SYMBOL(nlm_common_request_mailbox_handler);
-EXPORT_SYMBOL(nlm_common_disable_mailbox_intr);
-EXPORT_SYMBOL(nlm_common_enable_mailbox_intr);
-#endif
diff --git a/drivers/char/nlm_pcix_gen_host.c b/drivers/char/nlm_pcix_gen_host.c
deleted file mode 100644
index d7c09d8..0000000
--- a/drivers/char/nlm_pcix_gen_host.c
+++ /dev/null
@@ -1,513 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/sched.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/compiler.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/rtnetlink.h>
-#include <linux/delay.h>
-#include <linux/ethtool.h>
-#include <linux/mii.h>
-#include <linux/completion.h>
-#include <linux/crc32.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/atomic.h>
-#include <linux/timer.h>
-#include <linux/sysctl.h>
-#ifdef CONFIG_NLM_COMMON
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/nlm_pcix_gen_host.h>
-#else
-#include "nlm_pcix_gen_host.h"
-#endif
-
-#define Message(a,b...) //printk("\n[%s]\t"a"\n",__FUNCTION__,##b)
-#define ErrorMsg(a,b...) printk("\n[%s]\t"a"\n",__FUNCTION__,##b)
-#define NLM_VENDOR_ID 0x182e
-#define NLM_DEVICE_ID 0x0000
-
-#define NLM_DRIVER "nlm_pcix_gen_drv"
-#define NLM_MAX_IRQS_SUPPORTED 16
-
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-static unsigned volatile int *nlm_nlm_common_mailbox_addr=NULL;
-#endif
-static unsigned volatile int *nlm_nlm_common_shared_mem_base_host=NULL;
-
-
-struct pci_dev *nlm_pdev=NULL;
-
-#if !defined(CONFIG_NLM_COMMON) && defined(XLR_MSI_IS_SUPPORTED)
-static rwlock_t nlm_msi_rw_lock = RW_LOCK_UNLOCKED;
-static spinlock_t nlm_msi_spin_lock = SPIN_LOCK_UNLOCKED;
-static int no_of_active_handler=0;
-static int msi_irq=0;
-struct nlm_msi_irq{
-  int valid;
-  int disabled;
-  msi_handler func;
-  void *data;  
-}msi_desc[NLM_MAX_IRQS_SUPPORTED] = {{0}};
-#endif
-
-void nlm_nlm_common_interrupt_device(void);
-
-void nlm_common_pci_writel(unsigned int  data,unsigned int *addr)
-{
-#ifdef CONFIG_NLM_COMMON
-  writel(cpu_to_le32(data),addr);
-#else
-  writel(cpu_to_be32(data),addr);
-#endif
-}
-void nlm_common_pci_writeb(unsigned char data, void *addr)
-{
-  writeb(data,addr);
-}
-
-unsigned int nlm_common_pci_readl(unsigned int  *base)
-{
-#ifdef CONFIG_NLM_COMMON
-  return le32_to_cpu(readl(base));
-#else
-  return be32_to_cpu(readl(base));
-#endif
-}
- 
-
-u8 nlm_common_pci_readb(u8 *base)
-{
-  return readb(base);
-}
-#if !defined(CONFIG_NLM_COMMON) && defined(XLR_MSI_IS_SUPPORTED)
-static void nlm_common_unmask_msi(void)
-{
-#if 0
-  unsigned short  word;
-  Message("\nPhnxUnmaskMsi Called.\n");
-  pci_read_config_word(nlm_pdev, 0x56, &word);
-  word = word | 0x1;
-  pci_write_config_word(nlm_pdev, 0x56, word);
-  Message("--Returns..");
-#endif
-}
-
-static void nlm_common_mask_msi(void)
-{
-#if 0
-  unsigned short  word;
-  Message("\nMask Msi Called.\n");
-  pci_read_config_word(nlm_pdev, 0x56, &word);
-  word = word & ~(0x1);
-  pci_write_config_word(nlm_pdev, 0x56, word);
-#endif
-}
-
-static int nlm_nlm_common_generic_msi_handler(int irq, void *data, struct pt_regs *regs)
-{
-  int i;
-  Message("Got MSI intr");
-  read_lock(&nlm_msi_rw_lock);
-  for(i=0; i<NLM_MAX_IRQS_SUPPORTED; i++){
-    if(msi_desc[i].valid && !msi_desc[i].disabled)
-      msi_desc[i].func(msi_desc[i].data,regs);
-  }
-  read_unlock(&nlm_msi_rw_lock);
-  return IRQ_HANDLED;
-}
-
-int nlm_common_enable_msi(int *index)
-{
-  Message("\nEnable Msi Called...With Index %d\n",*index);
-	if(*index < 0 || *index > NLM_MAX_IRQS_SUPPORTED)
-		return -EINVAL;
-
-  msi_desc[*index].disabled = 0;
-
-  spin_lock(&nlm_msi_spin_lock);
-
-  no_of_active_handler++;
-  nlm_common_unmask_msi();
-  Message("\nNoActiveHandler %d\n",no_of_active_handler);
-  spin_unlock(&nlm_msi_spin_lock);
-  return 0;
-  
-}
-
-int nlm_common_disable_msi(int *index)
-{
-  if(*index < 0 || *index > NLM_MAX_IRQS_SUPPORTED)
-    	return -EINVAL;
-
-  msi_desc[*index].disabled = 1;
-
-  spin_lock(&nlm_msi_spin_lock);
-
-  no_of_active_handler--;
-  if(no_of_active_handler == 0)
-    nlm_common_mask_msi();
-
-  spin_unlock(&nlm_msi_spin_lock);
-  return 0;
-}
-
-int nlm_common_request_msi_handler(msi_handler func,void *data, int *index)
-{
-  int i;
-  unsigned long flags=0;
-
-  Message("\nRequest for MSI handler\n");
-
-  write_lock_irqsave(&nlm_msi_rw_lock, flags);
- 
-  for(i=0; i<NLM_MAX_IRQS_SUPPORTED; i++)
-    if(!msi_desc[i].valid)
-      break;
-  
-  if(i == NLM_MAX_IRQS_SUPPORTED) {
-    write_unlock_irqrestore(&nlm_msi_rw_lock, flags);
-    return -EIO;
-	}
-  Message("\nGot The Index %d Max %d\n",i,NLM_MAX_IRQS_SUPPORTED);
-  msi_desc[i].valid = 1;
-  msi_desc[i].disabled = 0;
-  msi_desc[i].func = func;
-  msi_desc[i].data = data;
-  *index = i;
-
-  Message("\nRequest for MSI handler DONE at index %d\n", *index);
-
-  write_unlock_irqrestore(&nlm_msi_rw_lock, flags);
-  nlm_common_enable_msi(index);
-  return 0;  
-
-}
-
-void nlm_common_free_msi_handler(int *index)
-{
-  unsigned long flags=0;
-
-  write_lock_irqsave(&nlm_msi_rw_lock, flags);
-  msi_desc[*index].valid = 0;  
-  write_unlock_irqrestore(&nlm_msi_rw_lock, flags);
-  
-  nlm_common_disable_msi(index);
-  Message("\nIndex %d Freed\n",*index);
-  return;
-}
-#endif
-
-static struct pci_device_id nlm_id_table[] = {
-  {NLM_VENDOR_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-  {0,}
-};
-
-#ifdef CONFIG_SYSCTL
-static int nlm_gen_mailbox=0;
-static struct ctl_table_header *nlm_pcix_sysctl_header;
-int nlm_ctl_handler(ctl_table *ctl, int write,
-			void __user *buffer, size_t *lenp, loff_t *ppos)
-{
-	int ret;
-	ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
-
-	if (write && *(int *)(ctl->data))
-		*(int *)(ctl->data) = 1;
-	nlm_nlm_common_interrupt_device();
-	return ret;
-}
-
-static ctl_table nlm_tbl[] = {
-	{
-		.ctl_name       = 28,
-		.procname       = "nlm_pcix",
-		.mode           = 0555,
-		.data           = &nlm_gen_mailbox,
-		.maxlen         = sizeof(int),
-		.mode           = 0644,
-		.proc_handler   = &nlm_ctl_handler,
-	},
-	{ .ctl_name = 0 }
-
-};
-static ctl_table nlm_pcix_sysctl_tbl[] = {
-	{
-		.ctl_name       = CTL_NET,
-		.procname       = "net",
-		.mode           = 0555,
-		.child          = nlm_tbl,
-	},
-	{ .ctl_name = 0 }
-
-};
-#endif
-
-
-static int nlm_nlm_common_generic_probe(struct pci_dev *pdev, const struct pci_device_id *id)
-{
-
-  int err;
-  unsigned long base;
-#ifdef CONFIG_NLM_COMMON
-  static int x=0;
-  uint32_t tmp;
-
-  if(!x){
-    /*Setting MaxOutSplitTrans to zero*/
-    pci_read_config_dword(pdev,0x40,&tmp); 
-    tmp = tmp & ~(0x7U<<20);
-    pci_write_config_dword(pdev,0x40,tmp);
-    pci_read_config_dword(pdev,0x40,&tmp); 
-    x=1;
-    return -1;
-  }
-#endif
-  nlm_pdev = pdev;
-#ifndef CONFIG_NLM_COMMON
-  if((err = pci_enable_device(pdev)))
-  {
-    ErrorMsg("Cannot enable PCI device, aborting.");
-    return err;
-  }
-#endif
-  if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM))
-  {
-    ErrorMsg("Cannot find proper PCI device " 
-	     	    "base address BAR0, aborting.\n");
-    err = -ENODEV;
-    pci_disable_device(pdev);
-    return err;
-  }
-  err = pci_request_region(pdev, 0, NLM_DRIVER);
-  if (err)
-  {
-    ErrorMsg("Cannot obtain PCI resources, aborting.");
-    err = -ENODEV;
-    pci_disable_device(pdev);
-    return err;
-  }
-  pci_set_master(pdev);
-#if !defined(CONFIG_NLM_COMMON) && defined(XLR_MSI_IS_SUPPORTED)
-  if ((err = pci_find_capability(pdev, PCI_CAP_ID_MSI)))
-  {
-    Message("Device is MSI capable..Enabling MSI");
-    err = pci_enable_msi(pdev);
-    msi_irq = pdev->irq;
-    if(err == 0) {
-      Message("MSI Enabled");
-	}
-    else{
-      ErrorMsg("MSI Enable failed");
-      return err;
-    }
-  }
-  else
-  {
-    ErrorMsg("Device is NOT MSI capable");
-    err = -ENODEV;
-    pci_disable_device(pdev);
-    return err;
-  }
-#endif
-  base = pci_resource_start(pdev, 0);
-  nlm_nlm_common_shared_mem_base_host = (unsigned volatile int *)
-			ioremap_nocache(base,pci_resource_len(pdev, 0));
-  printk("Device Memory Available @ %#x \n",
-			(uint32_t)(unsigned long)nlm_nlm_common_shared_mem_base_host);
-  if(nlm_nlm_common_shared_mem_base_host == NULL)
-  {
-    err = -ENODEV;
-#if !defined(CONFIG_NLM_COMMON) && defined(XLR_MSI_IS_SUPPORTED)
-    pci_disable_msi(pdev);
-#endif
-#ifndef CONFIG_NLM_COMMON
-    pci_disable_device(pdev);
-#endif
-    return err;
-  }
-
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-  /* Use BAR2 as the mailbox address */
-  base = pci_resource_start(pdev, 2);
-  nlm_nlm_common_mailbox_addr = (unsigned int *)ioremap(base,pci_resource_len(pdev, 2));
-
-  if(nlm_nlm_common_mailbox_addr == NULL || base == 0)
-  {
-    ErrorMsg("MailBox Is Not Supported");
-    err = -ENODEV;
-    iounmap((void *)nlm_nlm_common_shared_mem_base_host);
-		nlm_nlm_common_mailbox_addr	= nlm_nlm_common_shared_mem_base_host = 0;
-
-#if !defined(CONFIG_NLM_COMMON) && defined(XLR_MSI_IS_SUPPORTED)
-    pci_disable_msi(pdev);
-#endif
-#ifndef CONFIG_NLM_COMMON
-    pci_disable_device(pdev);
-#endif
-    return err;
-  }
-#endif 
-
-#if !defined(CONFIG_NLM_COMMON) && defined(XLR_MSI_IS_SUPPORTED)
-  if((err = request_irq(msi_irq,nlm_nlm_common_generic_msi_handler, SA_INTERRUPT,												"nlm_nlm_common_generic_msi_handler", (void *)NULL)))
-	{
-		ErrorMsg("Cant Register interrupt handler irq %d",msi_irq);
-		iounmap((void *)nlm_nlm_common_shared_mem_base_host);
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-		iounmap((void *)nlm_nlm_common_mailbox_addr);
-#endif
-		pci_disable_msi(pdev);
-		pci_disable_device(pdev);
-		return err ;
-	}
-//pci_set_mwi(pdev); 
-#endif
-
-#ifdef CONFIG_SYSCTL
-  nlm_pcix_sysctl_header = register_sysctl_table(nlm_pcix_sysctl_tbl);
-  if(nlm_pcix_sysctl_header == NULL) {
-	  printk(KERN_WARNING "Could not register to sysctl\n");
-  }
-  else{
-	  printk("nlm_pcix: registered with sysctl\n");
-  }
-#endif
-
-  return 0;
-}
-
-void nlm_nlm_common_interrupt_device(void)
-{
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-  writel(0x1234abcd, nlm_nlm_common_mailbox_addr);
-#endif
-}
-
-
-
-unsigned volatile long nlm_common_get_shared_mem_base_host(void)
-{
-  return (unsigned volatile long)nlm_nlm_common_shared_mem_base_host;
-}
-
-static void nlm_nlm_common_generic_remove(struct pci_dev *pdev)
-{
-#if !defined(CONFIG_NLM_COMMON) && defined(XLR_MSI_IS_SUPPORTED)
-  nlm_common_unmask_msi();	
-  free_irq(pdev->irq, NULL);
-  pci_disable_msi(pdev);
-#endif
-  iounmap((void *)nlm_nlm_common_shared_mem_base_host);
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-  iounmap((void *)nlm_nlm_common_mailbox_addr);
-#endif
-  pci_release_regions(pdev);
-  pci_disable_device(pdev);
-  pci_set_drvdata(pdev, NULL);
-
-#ifdef CONFIG_SYSCTL
-  if(nlm_pcix_sysctl_header)
-  	unregister_sysctl_table(nlm_pcix_sysctl_header);
-#endif
-  return;     
-}
-
-static struct pci_driver nlm_pci_driver = {
-  .name = NLM_DRIVER,
-  .id_table = nlm_id_table,
-  .probe  = nlm_nlm_common_generic_probe,
-  .remove = nlm_nlm_common_generic_remove,
-  #ifdef POWER_MANAGEMENT
-    .suspend = nlm_suspend,
-    .resume  = nlm_resume
-  #endif
-};
-#ifdef CONFIG_NLM_COMMON
-#include <asm/netlogic/iomap.h>
-int nlm_get_pci_mode()
-{
-  nlm_reg_t *pcix_ctrl_mmio;
-  uint32_t mode;
-
-  if (is_xls()) {
-	  return XLR_PCI_HOST_MODE;
-  }
-
-  pcix_ctrl_mmio = netlogic_io_mmio(NETLOGIC_IO_PCIX_OFFSET);
-
-  mode = pcix_ctrl_mmio[PCIX_HOST_MODE_CTRL_STATUS_REG];
-  if(mode & 0x2){
-	  return XLR_PCI_HOST_MODE;
-  }
-  return XLR_PCI_DEV_MODE;
-}
-#endif
-
-int __init nlm_pcix_gen_init(void)
-{
-#ifdef CONFIG_NLM_COMMON
-  if(nlm_get_pci_mode() == XLR_PCI_DEV_MODE)
-    return -EIO;
-  /* This driver is currently support on XLR hosts in case of RMI boards */
-  if(is_xls())
-      return -EIO;
-#endif
-  return pci_register_driver(&nlm_pci_driver);
-}
-
-void __exit nlm_pcix_gen_uninit(void)
-{
-  pci_unregister_driver(&nlm_pci_driver);
-}
-EXPORT_SYMBOL(nlm_common_pci_readl);
-EXPORT_SYMBOL(nlm_common_pci_readb);
-EXPORT_SYMBOL(nlm_common_pci_writel);
-EXPORT_SYMBOL(nlm_common_pci_writeb);
-EXPORT_SYMBOL(nlm_common_get_shared_mem_base_host);
-#if !defined(CONFIG_NLM_COMMON) && defined(XLR_MSI_IS_SUPPORTED)
-EXPORT_SYMBOL(nlm_common_request_msi_handler);
-EXPORT_SYMBOL(nlm_common_free_msi_handler);
-EXPORT_SYMBOL(nlm_common_enable_msi);
-EXPORT_SYMBOL(nlm_common_disable_msi);
-#endif
-EXPORT_SYMBOL(nlm_nlm_common_interrupt_device);
-EXPORT_SYMBOL(nlm_pdev);
-
-module_init(nlm_pcix_gen_init);
-module_exit(nlm_pcix_gen_uninit);
-#ifdef CONFIG_NLM_COMMON
-//Xlr Can be either pci dev or pci host
-EXPORT_SYMBOL(nlm_get_pci_mode);
-#endif
-#ifndef CONFIG_NLM_COMMON
-MODULE_LICENSE("GPL");
-#endif
diff --git a/drivers/char/nlm_xlr_cde.c b/drivers/char/nlm_xlr_cde.c
deleted file mode 100644
index d908c52..0000000
--- a/drivers/char/nlm_xlr_cde.c
+++ /dev/null
@@ -1,822 +0,0 @@
-/***********************************************************************
- * Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
- * reserved.
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 1. Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in
- * the documentation and/or other materials provided with the
- * distribution.
- * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- * *****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
-#include <linux/poll.h>
-
-#include <linux/slab.h>         /* kmalloc() */
-#include <linux/fs.h>           /* everything... */
-#include <linux/errno.h>        /* error codes */
-#include <linux/types.h>        /* size_t */
-#include <linux/proc_fs.h>
-#include <linux/fcntl.h>        /* O_ACCMODE */
-#include <linux/seq_file.h>
-#include <linux/cdev.h>
-#include <linux/module.h>
-
-#include <asm/system.h>         /* cli(), *_flags */
-#include <asm/uaccess.h>        /* copy_*_user */
-#include <asm/netlogic/sim.h>        /* is_xls */
-
-#include <asm/netlogic/nlm_common_cde.h>
-#include <asm/netlogic/linux_crf.h>
-#include <asm/netlogic/nlm_rw_lock.h>
-
-
-#define CDE_NON      0
-#define CDE_STATIC   1
-#define CDE_DYNAMIC  2
-#define CDE_DYNAMIC2 3
-
-#define FD_BURST_SIZE 1
-#define RTN_BKT 2
-#define CC_CPU0_0 0x380
-
-#define SPILL_SIZE   1024
-#define NUM_FREE_DESCRIPTORS 100 //must be less or equal to MAX_NUM_PAGES
-#define MAX_NUM_PAGES 100
-#define MAX_BUFFER_SIZE 1024*16
-#define CMP_PAGE_SIZE   1024
-#define SCRATCH_SIZE    1024
-
-#define MAX_NUM_MESSAGES 20
-
-extern __u32 cpu_to_frstid[];
-
-/*
-typedef struct cmp_data_structure {
-  char src[MAX_BUFFER_SIZE];    // source data
-  char target[MAX_BUFFER_SIZE]; // inflated or deflated result
-  unsigned long long src_desc[CMP_PAGE_SIZE];  // source descriptors
-  unsigned long long scratch[SCRATCH_SIZE];    // scratch page
-  unsigned long long src_size;    //size of source data
-  unsigned long long target_size; // size of result
-  unsigned long long num_desc;    // number of source descriptors including scratch desc
-  short op;                       // to deflate or inflate
-} cmp_data_t;
-
-*/
-
-typedef struct cmp_data_structure {
-  char *src;    // source data
-  char *target; // inflated or deflated result
-  unsigned long long *src_desc;  // source descriptors
-  unsigned long long *scratch;    // scratch page
-  unsigned long long src_size;    //size of source data
-  unsigned long long target_size; // size of result
-  unsigned long long num_desc;    // number of source descriptors including scratch desc
-  short op;                       // to deflate or inflate
-} cmp_data_t;
-
-typedef enum {
-	CDE_READ_DONE = 0,
-	CDE_WRITE_PENDING,
-	CDE_WRITE_DONE
-} nlm_common_cde_state;
-
-typedef struct msgrng_msg msg;
-wait_queue_head_t cde_write_queue;
-static volatile int cde_write_completed;
-static spinlock_t cde_read_write_lock;
-
-// Data Structures
-struct cde_dev {
-  struct cdev cdev;	  /* Char device structure	    */
-  void *data;
-};
-
-typedef struct free_page_structure {
-	  char *data_array;
-} fr_page;
-
-typedef struct spill_page_structure {
-	  char *data_array;
-} sp_page;
-
-
-volatile msg cmp_msg[MAX_NUM_MESSAGES]    __attribute__((aligned(32)));
-volatile fr_page page_array[MAX_NUM_PAGES]    __attribute__((aligned(32)));
-volatile sp_page spill_page  __attribute__((aligned(32)));
-volatile char *spill_page_tmp_data_array __attribute__((aligned(32)));
-volatile char *(page_array_tmp_data_array[MAX_NUM_PAGES])__attribute__((aligned(32)));
-
-
-#define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
-
-static __inline__ void *cacheline_aligned_kmalloc(int size, char **buf_addr, int gfp_mask)
-{
-	void *buf = kmalloc(size + SMP_CACHE_BYTES, gfp_mask);
-	
-	if (buf)	{
-		*buf_addr = (char *)buf;
-		buf = (void*)(CACHELINE_ALIGNED_ADDR((unsigned long)buf +
-					SMP_CACHE_BYTES));
-	}
-	return buf;
-}
-
-static int cde_debug = 0;
-
-
-static int config_cmp(void)
-{
-  int i;
-  nlm_reg_t *cmp_mmio = netlogic_io_mmio(NETLOGIC_IO_COMP_OFFSET);
-  
-  spill_page.data_array = cacheline_aligned_kmalloc(SPILL_SIZE+SMP_CACHE_BYTES,(char **)&spill_page_tmp_data_array, GFP_KERNEL);
-  if(!spill_page.data_array)
-	  return -1;
-
-  if (dev_tree_en) {
-    char bkt[8], cc[16][8];
-    int rv = fdt_get_cde_bucket_conf(bkt, 4, cc, 128);
-
-    if (rv == -1) {
-       printk(KERN_ERR "CDE: Could not get credit info from FDT\n");
-       return -1;
-    }
-    netlogic_write_reg(cmp_mmio, CMP_MSG_BUCKET0_SIZE, bkt[0]);
-    netlogic_write_reg(cmp_mmio, CMP_MSG_BUCKET1_SIZE, bkt[1]);
-
-    for (i = 0; i < 32; i++)
-       netlogic_write_reg(cmp_mmio, CC_CPU0_0 + i, cc[i/8][i%8]);
-  } else {
-    netlogic_write_reg(cmp_mmio, CMP_MSG_BUCKET0_SIZE, xls_bucket_sizes.bucket[MSGRNG_STNID_CMP_0]);
-    netlogic_write_reg(cmp_mmio, CMP_MSG_BUCKET1_SIZE, xls_bucket_sizes.bucket[MSGRNG_STNID_CMP_1]);
-    for (i = 0; i < 32; i++)
-      netlogic_write_reg(cmp_mmio, CC_CPU0_0 + i, 
-			xls_cc_table_cmp.counters[i >> 3][i & 0x7]);
-  }
-   
-  cmp_write_reg(CMP_REG_CTRL_REG,        ((0x39CE << 16) | CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
-  cmp_write_reg(CMP_REG_DMA_CREDITS_REG, 0x0FFFFFFF);
-  cmp_write_reg(CMP_REG_SPILL_ADDR0_REG, (virt_to_phys(spill_page.data_array) >> 5) & 0xffffffffffffffffUll);
-  cmp_write_reg(CMP_REG_SPILL_ADDR1_REG, ((__u64)virt_to_phys(spill_page.data_array) >> 36) & 0x7);
-  cmp_write_reg(CMP_REG_SPILL_SIZE_REG,  SPILL_SIZE); //16'h{SPILL_SIZE}
-
-  if (cde_debug) {
-    printk("COMP OFFSET = 0x%x\n", NETLOGIC_IO_COMP_OFFSET);
-    printk("register = 0x%0x data = 0x%0x\n", CMP_MSG_BUCKET0_SIZE,cmp_mmio[CMP_MSG_BUCKET0_SIZE]);
-    printk("register = 0x%0x data = 0x%0x\n", CMP_MSG_BUCKET1_SIZE,cmp_mmio[CMP_MSG_BUCKET1_SIZE]);
-
-    printk("register=0x%0x data=0x%0x\n", CMP_REG_CTRL_REG, cmp_read_reg(CMP_REG_CTRL_REG));
-    printk("register=0x%0x data=0x%0x\n", CMP_REG_DMA_CREDITS_REG, cmp_read_reg(CMP_REG_DMA_CREDITS_REG));
-    printk("register=0x%0x data=0x%0x\n", CMP_REG_SPILL_ADDR0_REG, cmp_read_reg(CMP_REG_SPILL_ADDR0_REG));
-    printk("register=0x%0x data=0x%0x\n", CMP_REG_SPILL_ADDR1_REG, cmp_read_reg(CMP_REG_SPILL_ADDR1_REG));
-    printk("register=0x%0x data=0x%0x\n", CMP_REG_SPILL_SIZE_REG, cmp_read_reg(CMP_REG_SPILL_SIZE_REG));
-  }
-  return 0;
-}
-
-static int send_message(int stid, struct msgrng_msg *msg)
-{
-  unsigned long mflags = 0;
-  int ret = 0;
-
-  msgrng_flags_save(mflags);
-  ret = message_send_retry(1, 0, stid, msg);
-  msgrng_flags_restore(mflags);
-
-  return ret;
-}
-
-
-static int send_free_desc(void)
-{
-  int i;
-  int status = 0;
-  int stid;
-  struct msgrng_msg fd_msg;
-
-
-  // send free descriptors to cmp block
-  for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
-    if (!page_array[i].data_array)	  
-       page_array[i].data_array = cacheline_aligned_kmalloc(CMP_PAGE_SIZE+SMP_CACHE_BYTES, (char **)&page_array_tmp_data_array[i], GFP_KERNEL);
-    if (!page_array[i].data_array)	{
-	    printk("cacheline_aligned_kmalloc returmed error\n");
-	    return -1;
-    }
-
-    stid = make_fd_msg(&fd_msg, page_array[i].data_array);
-    //    printk("Free descriptor message [%0d] = 0x%016llx\n", i, fd_msg.msg0);
-
-    status = send_message(MSGRNG_STNID_CMP_0, &fd_msg);
-
-    if (status != 0) {
-      printk("[%s@%d]: Free descriptor (%d) didnt not reach cmpm status=%0d\n",
-	     __FUNCTION__, __LINE__, i, status);
-      return -1;
-    }
-  }
-
-  if (cde_debug) {
-    printk("[%s@%d]: Sent %d free desc to comp engine\n",
-	   __FUNCTION__, __LINE__, i);
-  }
-
-  return 0;
-}
-
-
-int create_message(cmp_data_t *cmp_data, int num_blk, int num_desc, int en_save_restore)
-{
-  int num_messages;
-  int i,j,k,stid;
-
-  int type = CDE_STATIC;
-  int rtn_bkt;
-
-  int cur_blk = 0;
-  int cur_desc = 0;
-
-  int eof  = 0;
-  int sod  = 0;
-  int sob  = 0;
-  int eob  = 0;
-  int save = 0;
-  int restore = 0;
-
-  int length = 0;
-  int start = 0;
-  int div = num_blk * num_desc;
-
-  int desc_idx = 0;
-
-  if (en_save_restore)
-    num_messages = num_blk;
-  else
-    num_messages = 1;
-
-  rtn_bkt = cpu_to_frstid[hard_smp_processor_id()];
-  /*
-   * dliao: num_messages = 1 for now. not sure how it works when num_messages > 0 or num_desc > 0
-   * what is num_blk or num_desc for ?
-   */
-  for (i = 0; i < num_messages; i++) {
-    //create scratch page descriptor
-    cur_desc = 0;
-    restore = ((num_messages > 1) & (cur_blk != 0));
-    length = SCRATCH_SIZE;
-
-    cmp_data->src_desc[desc_idx] =
-      make_src_desc(0, 0, 0, 0, 0, restore, 0, length, cmp_data->scratch);
-
-    if (cde_debug) {
-      printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
-	     cmp_data->scratch, virt_to_phys(cmp_data->scratch), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0])); 
-    }
-
-    cur_desc++;
-
-    for (j = 0; j < num_blk/num_messages; j++) {
-      for (k = 0; k < num_desc; k++) {
-	eof = (cur_blk == num_blk-1);
-
-	sod = (start == 0);
-	sob = (k == 0);
-	eob = (k == num_desc-1);
-	save = ((en_save_restore == 1) & (eob == 1) & (eof == 0));
-	restore = 0; //restore only can be 1 on scratch descriptor
-
-	//	length = (cmp_data->src_size - start) / div;
-	length = (cmp_data->src_size - start); //dliao: assume div == 1
-
-	cmp_data->src_desc[cur_desc] =
-	  make_src_desc(eof, type, sod, sob, save, restore, eob, length, cmp_data->src + start);
-
-	if (cde_debug) {
-	  printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
-		 __FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
-	  
-	  printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
-		 __FUNCTION__, __LINE__,
-		 cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
-	}
-
-	start = start + length;
-	div--;
-	cur_desc++;
-      }
-
-      if (type == 2) {//dynamic has 2x descriptors
-	cur_desc = cur_desc + num_desc;
-      }
-
-      cur_blk++;
-    }
-
-    stid = make_cmp_msg((struct msgrng_msg *) (cmp_msg + i), rtn_bkt, cmp_data->op,
-			cur_desc, cmp_data->src_desc + desc_idx);
-    if (cde_debug) {
-      printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0); 
-    }
-
-    desc_idx = desc_idx + cur_desc;
-  }
-
-  // returns the number of messages created
-  return (num_messages);
-}
-
-
-void return_free_descriptors(msg *msg_list, int msg_index)
-{
-  int i, j, k, status, num_desc;
-  msg return_msg, fd_msg;
-  uint64_t * temp_desc;
-  uint64_t dest_desc;
-  int used_fd_index = 0;
-
-  volatile uint64_t used_fd[NUM_FREE_DESCRIPTORS] __attribute__((aligned(32)));
-
-  for (i = 0; i < msg_index; i++) {
-
-    memcpy ((void *) &return_msg, (void *)(msg_list+i), sizeof(msg));
-    used_fd[used_fd_index++] = ((uint64_t) return_msg.msg1 & 0xffffffffffUll);
-
-    num_desc = (return_msg.msg1>>40 & 0xffff);
-
-    temp_desc = (uint64_t *) phys_to_virt(return_msg.msg1 & 0xffffffffffUll);
-
-    for (j = 0; j< num_desc; j++) {
-      dest_desc = temp_desc[j];
-      used_fd[used_fd_index++] = ((uint64_t) dest_desc & 0xffffffffffUll);
-    }
-
-
-    if (used_fd_index > FD_BURST_SIZE) {
-      for (k = 0; k < used_fd_index; k++) {
-	fd_msg.msg0 = ((uint64_t) used_fd[k]);
-	status = send_message(MSGRNG_STNID_CMP_0, &fd_msg);
-	if (status != 0)
-	  printk("Return free descriptor didnt not reach cmp! status=%0d\n", status);
-	}
-        used_fd_index = 0;
-    }
-  }
-}
-
-static cmp_data_t *cmp_data = 0;
-
-static void nlm_common_msgring_comp_int_handler(int bucket, int size, int code, int stid,
-					  struct msgrng_msg *msg, void *data/* ignored */)
-{
-  int last = 0; 
-  int msg_index = 0; 
-  struct msgrng_msg msg_list[MAX_NUM_MESSAGES]; 
-  int offset = cmp_data->target_size;
-  
-  if (cde_debug) {
-    printk("[%s@%d]: bucket=%d, size=%d, code=%d, stid=%d "
-	   " msg0=0x%016llx, msg1=0x%016llx\n",
-	   __FUNCTION__, __LINE__, bucket, size, code, stid, msg->msg0, msg->msg1);
-    printk("@msg = %p \n", msg);
-  }
-
-  // TODO need to fix not-last case
-  last = ((msg->msg0 >> 63) & 0x1ULL); 
-  
-  if (cde_debug)
-    printk("[%s@%d]: last = %d\n", __FUNCTION__, __LINE__, last); 
-    
-  offset = cmp_data->target_size; 
-  cmp_data->target_size += read_cmp_msg((char *) cmp_data->target + offset, msg->msg1);
-
-  if (last) {
-	  spin_lock(&cde_read_write_lock);
-	  cde_write_completed = CDE_WRITE_DONE;
-	  spin_unlock(&cde_read_write_lock);
-  }
-
-  memcpy((void *)&msg_list[msg_index],(void *)msg, sizeof(struct msgrng_msg));
-
-  if (cde_write_completed == CDE_WRITE_DONE) {
-	  wake_up_interruptible(&cde_write_queue);
-  }
-
-  return_free_descriptors(msg_list, msg_index); 
-//  printk("[\n%s@%d]:end of nlm_common_msgring_comp_int_handler\n", __FUNCTION__, __LINE__);
-}
-
-/*
- * Our parameters which can be set at load time.
- */
-
-static int cde_major =   CDE_MAJOR;
-static int cde_minor =   0;
-static int cde_nr_devs = 1;
-
-module_param(cde_major, int, S_IRUGO);
-module_param(cde_minor, int, S_IRUGO);
-module_param(cde_nr_devs, int, S_IRUGO);
-
-struct cde_dev *cde_device;
-static int cde_open_flag = 0;
-static spinlock_t cde_open_lock; 
-
-
-int cde_open(struct inode *inode, struct file *filp)
-{
-  spin_lock(&cde_open_lock);
-  if (cde_open_flag)
-  {       spin_unlock(&cde_open_lock);
-	  return -EAGAIN;
-  }
- 
-  cde_open_flag = 1;
-  spin_unlock(&cde_open_lock);
-
-  cmp_data = (cmp_data_t *) kmalloc(sizeof(cmp_data_t), GFP_KERNEL);
-  if (!cmp_data)
-    return -ENOMEM;
-  memset(cmp_data, 0, sizeof(cmp_data_t));
-
-  cmp_data->src = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
-  if (! cmp_data->src)	{
-	  printk("kmalloc returns Error : cmp_data->src\n");
-	  kfree(cmp_data);
-	  
-	  return -ENOMEM;
-  }
-	  
-  cmp_data->target = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
-  if (! cmp_data->target)	{
-	  printk("kmalloc returns Error : cmp_data->target\n");
-	  kfree(cmp_data->src);
-	  kfree(cmp_data);
-	  return -ENOMEM;
-  }
-  cmp_data->src_desc = kmalloc(sizeof(unsigned long long) * CMP_PAGE_SIZE , GFP_KERNEL);
-  if (! cmp_data->src_desc)	{
-	  printk("kmalloc returns Error : cmp_data->src_desc\n");
-	  kfree(cmp_data->src);
-	  kfree(cmp_data->target);
-	  kfree(cmp_data);
-	  return -ENOMEM;
-  }
-  cmp_data->scratch = kmalloc(sizeof(unsigned long long) * SCRATCH_SIZE , GFP_KERNEL);
-  if (! cmp_data->scratch)	{
-	  printk("kmalloc returns Error : cmp_data->scratch\n");
-	  kfree(cmp_data->src);
-	  kfree(cmp_data->target);
-	  kfree(cmp_data->src_desc);
-	  kfree(cmp_data);
-	  return -ENOMEM;
-  }
-  memset(cmp_data->src, 0, MAX_BUFFER_SIZE);
-  memset(cmp_data->target, 0, MAX_BUFFER_SIZE);
-  memset(cmp_data->src_desc, 0, sizeof(unsigned long long) * CMP_PAGE_SIZE);
-  memset(cmp_data->scratch, 0, sizeof(unsigned long long) * SCRATCH_SIZE);
-
-  if (config_cmp() == -1)
-	return -ENOMEM;
-
-  if (send_free_desc() == -1)
-	return -ENOMEM;
-
-  init_waitqueue_head(&cde_write_queue);
-  return 0;
-}
-
-
-int cde_release(struct inode *inode, struct file *filp)
-{ 
-	
-  int i;
-  if (cmp_data->src)  
-	  kfree(cmp_data->src);
-  if (cmp_data->target)  
-	  kfree(cmp_data->target);
-  if (cmp_data->src_desc)  
-	  kfree(cmp_data->src_desc);
-  if (cmp_data->scratch)  
-	  kfree(cmp_data->scratch);
-  if (cmp_data)
-    kfree(cmp_data);
-    cmp_data->src = NULL;
-    cmp_data->target = NULL;
-    cmp_data->src_desc = NULL; 
-    cmp_data->scratch = NULL;
-    cmp_data = NULL;
-
-  
-  cmp_write_reg(CMP_REG_RESET_REG, 0x10);
-  do {
-    unsigned int ret = cmp_read_reg(CMP_REG_RESET_REG);
-    if (((ret >> 4) & 0x1) == 1)
-      break;
-  } while (1);
-
-  cmp_write_reg(CMP_REG_RESET_REG, 0x01);
-  cmp_write_reg(CMP_REG_RESET_REG, 0x00);
-  
-  if (spill_page.data_array)	{
-    kfree((void *)spill_page_tmp_data_array);
-    spill_page_tmp_data_array = NULL;
-    spill_page.data_array = NULL;
-  }
-
-  for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
-    if (page_array[i].data_array)	{
-	kfree((void *)page_array_tmp_data_array[i]);
-	page_array_tmp_data_array[i] = NULL;
-	page_array[i].data_array = NULL;
-    }	
-  }
-  spin_lock(&cde_open_lock);
-	cde_open_flag = 0;
-  spin_unlock(&cde_open_lock);
-  return 0;
-}
-
-
-// TODO: 1. fix the case when more data than user want to read.
-//       2. mutiple reads
-ssize_t cde_read(struct file *filp, char __user *buf,
-		 size_t count, loff_t *f_pos)
-{
-  int size = 0;
-  unsigned long irq_flags;
-  static volatile int readlock;
-
-  spin_lock_irqsave(&cde_read_write_lock, irq_flags);
-  if (readlock == 1)
-  {
-  	spin_unlock_irqrestore(&cde_read_write_lock, irq_flags);
-	return -EAGAIN;
-  }
-  readlock = 1;
-  spin_unlock_irqrestore(&cde_read_write_lock, irq_flags);
-
-  if (cde_write_completed != CDE_WRITE_DONE)	{
-	  wait_event_interruptible(cde_write_queue, 
-			  (cde_write_completed == CDE_WRITE_DONE) );         
-  }
-  
-  spin_lock_irqsave(&cde_read_write_lock, irq_flags);
-  if (cde_write_completed != CDE_WRITE_DONE) {
-	  readlock = 0;
-	  spin_unlock_irqrestore(&cde_read_write_lock, irq_flags);
-	  return -EAGAIN;
-  }
-  spin_unlock_irqrestore(&cde_read_write_lock, irq_flags);
-
-  size = count < cmp_data->target_size ? count : cmp_data->target_size;
-  
-  if (copy_to_user(buf, cmp_data->target, size)) {
-    printk("copy_to_user failed\n");
-    size = -EFAULT;
-  }
-
-  cmp_data->target_size = 0;
-
-  spin_lock_irqsave(&cde_read_write_lock, irq_flags);
-  cde_write_completed = CDE_READ_DONE;
-  readlock = 0;
-  spin_unlock_irqrestore(&cde_read_write_lock, irq_flags);
-
-  return size;
-}
-
-
-ssize_t cde_write(struct file *filp, const char __user *buf,
-		  size_t count, loff_t *f_pos)
-{
-  int i;
-  int num_messages = 0;
-  unsigned long irq_flags;
-
-  spin_lock_irqsave(&cde_read_write_lock, irq_flags);
-  if (cde_write_completed != CDE_READ_DONE)
-  {
-	  spin_unlock_irqrestore(&cde_read_write_lock, irq_flags);
-	  return -EAGAIN;
-  }
-  cde_write_completed = CDE_WRITE_PENDING;
-  spin_unlock_irqrestore(&cde_read_write_lock, irq_flags);
-  
-  if (copy_from_user(cmp_data->src, buf, count)) {
-	  spin_lock_irqsave(&cde_read_write_lock, irq_flags);
-	  cde_write_completed = CDE_READ_DONE;
-	  spin_unlock_irqrestore(&cde_read_write_lock, irq_flags);
-	  return -EFAULT;
-  }
-
-  cmp_data->src_size = count;
-
-  num_messages = create_message(cmp_data, 1, 1, 0);
-
-  // send message
-  for (i = 0; i < num_messages; i++) {
-
-    int status = send_message(MSGRNG_STNID_CMP_1, (struct msgrng_msg *) (cmp_msg + i));
-
-    if (status != 0) {
-	    printk("Cmp Message didnt not reach cmp, status=%0d\n", status);
-	    spin_lock_irqsave(&cde_read_write_lock, irq_flags);
-	    cde_write_completed = CDE_READ_DONE;
-	    spin_unlock_irqrestore(&cde_read_write_lock, irq_flags);
-    }
-
-  }
-
-  return count;
-}
-
-
-int cde_ioctl(struct inode *inode, struct file *filp,
-	      unsigned int cmd, unsigned long arg)
-{
-  int err = 0;
-  /*
-    if (_IOC_TYPE(cmd) != CDE_IOC_MAGIC)
-    return -ENOTTY;
-
-    if (_IOC_NR(cmd) > CDE_IOC_MAXNR)
-    return -ENOTTY;
-
-    if (_IOC_DIR(cmd) & _IOC_READ)
-    err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
-
-    else if (_IOC_DIR(cmd) & _IOC_WRITE)
-    err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-
-    if (err)
-    return -EFAULT;
-  */
-
-  switch(cmd) {
-
-  case CDE_INFLATE:
-    cmp_data->op = CDE_INFLATE;
-    break;
-
-  case CDE_DEFLATE:
-    cmp_data->op = CDE_DEFLATE;
-    break;
-
-  default:
-    return -ENOTTY;
-  }
-
-  return err;
-}
-
-long  cde_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-  unsigned long ret = -1;
-  lock_kernel();
-  ret = cde_ioctl(NULL, filp, cmd, arg);
-  unlock_kernel();
-  if(ret){
-     printk("%s: ioctl error\n", __FUNCTION__);
-     return -EINVAL;
-  }
-  return ret;
-}
-
-struct file_operations cde_fops = {
-  .owner =    THIS_MODULE,
-  .read =     cde_read,
-  .write =    cde_write,
-  .ioctl =    cde_ioctl,
-  .compat_ioctl = cde_compat_ioctl,
-  .open =     cde_open,
-  .release =  cde_release,
-};
-
-
-void cde_cleanup_module(void)
-{
-  dev_t devno = MKDEV(cde_major, cde_minor);
-  
-  if (cde_device) {
-    cdev_del(&(cde_device->cdev));
-    kfree(cde_device);
-  }
-
-  /* cleanup_module is never called if registering failed */
-  unregister_chrdev_region(devno, cde_nr_devs);
-}
-
-
-static int cde_setup_cdev(struct cde_dev *dev)
-{
-  int err, devno = MKDEV(cde_major, cde_minor);
-
-  cdev_init(&dev->cdev, &cde_fops);
-  dev->cdev.owner = THIS_MODULE;
-  dev->cdev.ops = &cde_fops;
-  err = cdev_add(&dev->cdev, devno, 1);
-
-  if (err)
-    printk(KERN_NOTICE "Error %d adding cde", err);
-
-  return err;
-}
-
-
-#ifdef CONFIG_NLM_MSGRING_NAPI
-extern int nlm_on_chip_napi;
-extern int nlm_msgring_napi;
-#endif /* CONFIG_NLM_MSGRING_NAPI */
-
-
-int cde_init_module(void)
-{
-  int ret;
-  dev_t dev = 0;
-
-  if (!is_xls_b0())
-    return 0;
-  cde_write_completed = CDE_READ_DONE;
-  spin_lock_init(&cde_open_lock);
-  spin_lock_init(&cde_read_write_lock);
-
-  if (dev_tree_en && fdt_get_cde_enabled() == 0) {
-    printk("Compression Engine disabled in configuration, skipping...\n");
-    return -ENODEV;
-  }
-
-#ifdef CONFIG_NLM_MSGRING_NAPI
-  if (nlm_msgring_napi && !nlm_on_chip_napi) {
-	  printk(KERN_ALERT "%s: RMI Compression Driver: Incompatibility with GMAC"
-		 " NAPI mode\n", __FUNCTION__);
-	  printk(KERN_ALERT "%s: RMI Compression Driver: Aborting init sequence.\n", 
-		 __FUNCTION__);
-	  return -EINVAL;
-  }
-#endif /* CONFIG_NLM_MSGRING_NAPI */
-
-  if (cde_major) {
-    dev = MKDEV(cde_major, cde_minor);
-    ret = register_chrdev_region(dev, cde_nr_devs, "xls_cde");
-  }
-  else {
-    ret = alloc_chrdev_region(&dev, cde_minor, cde_nr_devs, "xls_cde");
-    cde_major = MAJOR(dev);
-  }
-
-  if (ret < 0) {
-    printk(KERN_WARNING "xls_cde: can't get major %d\n", cde_major);
-    return ret;
-  }
-
-  /*
-   * allocate the devices or static variable?
-   */
-  cde_device = kmalloc(sizeof(struct cde_dev), GFP_KERNEL);
-  if (!cde_device) {
-    printk(KERN_WARNING "xls_cde: can't allocate memory\n");
-    ret = -ENOMEM;
-    goto fail;
-  }
-
-  memset(cde_device, 0, sizeof(struct cde_dev));
-
-  ret = cde_setup_cdev(cde_device);
-  if (ret)
-    goto fail;
-  ret = register_msgring_handler(TX_STN_CMP, nlm_common_msgring_comp_int_handler, NULL);
-  if (ret) {
-    printk("[%s@%d]: unable to register handler for msgring stations for Compression Station\n",
-	   __FILE__, __LINE__);
-    goto fail;
-  }
-
-  return 0;
-
- fail:
-  cde_cleanup_module();
-  return ret;
-}
-
-module_init(cde_init_module);
-module_exit(cde_cleanup_module);
diff --git a/drivers/char/nlm_xlr_msgring.c b/drivers/char/nlm_xlr_msgring.c
deleted file mode 100644
index af71bb4..0000000
--- a/drivers/char/nlm_xlr_msgring.c
+++ /dev/null
@@ -1,732 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
-#include <linux/poll.h>
-#include <linux/module.h>
-
-#include <asm/uaccess.h>
-#include <asm/mman.h>
-
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/devices.h>
-#include <asm/netlogic/xlr_user_mac.h>
-
-#include <user/netlogic/nlm_common_msgring.h>
-
-#define MAX_MSG_FIFOS 12
-#define MSG_FIFO_SIZE 1024
-#define MSG_FIFO_MASK (MSG_FIFO_SIZE-1)
-
-enum LEVEL {
-	LOG_EMERG = 0,
-		LOG_ALERT,
-		LOG_CRIT,
-		LOG_ERR,
-		LOG_WARNING,
-		LOG_NOTICE,
-		LOG_INFO,
-		LOG_DEBUG
-};
-
-#define PRINTK_ERR(FMT, ...) \
-do { \
-    if(msgring_debug_level >= LOG_ERR) { \
-        printk(KERN_ERR FMT, ## __VA_ARGS__); \
-    } \
-} while(0)
-
-#define PRINTK_INFO(FMT, ...) \
-do { \
-    if(msgring_debug_level >= LOG_INFO) { \
-        printk(KERN_INFO FMT, ## __VA_ARGS__); \
-    } \
-} while(0)
-
-typedef enum syscall_id_s {
-	SYSCALL_exec,
-	SYSCALL_socketcall,
-	SYSCALL_open,
-	SYSCALL_write,
-	SYSCALL_read,
-	SYSCALL_close,
-	SYSCALL_ioctl,
-	SYSCALL_select,
-	SYSCALL_exit,
-	SYSCALL_interrupt,
-	SYSCALL_max
-} SYSCALL_ID;
-
-typedef struct syscall {
-	wait_queue_head_t sleep;
-	int done;
-	void *process;
-	int pid;
-	SYSCALL_ID id;
-	int err;
-	int _errno;
-	int num;
-	int src_id;
-	void *trace;
-	union {
-		struct {
-			int call;
-		} socketcall;
-	} u;
-} SYSCALL;
-
-extern char *saved_command_line;
-static char *hybrid = 0;
-extern int msgring_debug_level;
-
-extern void *nlm_common_psb_shm;
-extern unsigned long nlm_common_psb_shm_size;
-
-static int    msgring_major;
-
-
-struct fifo {
-	struct msgring_msg_data *data;
-	int       size;
-	int       head;
-	int       tail;
-	spinlock_t lock;
-	wait_queue_head_t wq;
-};
-
-static void fifo_init (struct fifo *fifo, int fifo_size)
-{
-	void *ptr = kmalloc(fifo_size * sizeof(struct msgring_msg_data), GFP_KERNEL);
-
-	if (!ptr) panic("[%s]: Unable to allocate memory for Tx Fifos\n", __FUNCTION__);
-
-	fifo->data = ptr;
-	fifo->head = fifo->tail = 0;
-	fifo->size = fifo_size;
-	spin_lock_init(&fifo->lock);
-}
-
-/* TODO: Change all modulos to boolean arithmetic */
-__inline__ int fifo_next_index(volatile struct fifo *fifo, int index)
-{
-	return (index+1) & MSG_FIFO_MASK;
-}
-
-__inline__ int  fifo_next_head(volatile struct fifo *fifo)
-{ return (fifo->head+1) & MSG_FIFO_MASK ; }
-
-__inline__ int  fifo_next_tail(volatile struct fifo *fifo)
-{ return (fifo->tail+1) & MSG_FIFO_MASK ; }
-
-__inline__ int  fifo_empty(volatile struct fifo *fifo)
-{ return (fifo->head == fifo->tail); }
-
-static __inline__ int  fifo_full(volatile struct fifo *fifo)
-{ return (fifo_next_tail(fifo) == fifo->head); }
-
-static __inline__ int  fifo_count(volatile struct fifo *fifo)
-{
-	if (fifo->head <= fifo->tail)
-		return fifo->tail - fifo->head;
-	else
-		return (fifo->size - fifo->head) + fifo->tail;
-}
-static __inline__ int fifo_dequeue(volatile struct fifo *fifo,
-				   struct msgring_msg_data *data)
-{
-	if (fifo_empty(fifo))
-		return 0;
-
-	*data = fifo->data[fifo->head];
-	fifo->head = fifo_next_head(fifo);
-
-	return 1;
-}
-static __inline__ int fifo_enqueue(volatile struct fifo *fifo,
-				   struct msgring_msg_data *data)
-{
-	int cnt = 0;
-	while (fifo_full(fifo)) {
-		++cnt;
-	}
-	if(cnt > 10000) {
-		PRINTK_ERR("%s:%d fifo queue full cnt=%d.\n", __FUNCTION__, __LINE__,
-			   cnt);
-	}
-
-	fifo->data[fifo->tail] = *data;
-	fifo->tail = fifo_next_tail(fifo);
-
-	return 1;
-}
-
-#define PRINT_NLM_FIFO_DATA(p) \
-do { \
-	PRINTK_INFO("%s:%d fifo=%p fifo size=%d head=%d tail=%d.\n", __FUNCTION__, \
-		    __LINE__, p, p->size, p->head, p->tail); \
-} while(0)
-
-static struct fifo msg_fifos[MAX_MSG_FIFOS];
-
-#ifdef CONFIG_NLMCOMMON_MAC
-extern void nlm_xlr_rmios_msgring_handler(int bucket, int size, int code, int stid,
-					   struct msgrng_msg *msg, void *data/* ignored */);
-#else /* CONFIG_NLMCOMMON_MAC */
-void nlm_xlr_rmios_msgring_handler(int bucket, int size, int code,
-                                    int stid, struct msgrng_msg *msg,
-                                    void *data /* ignored */ ) { }
-#endif /* CONFIG_NLMCOMMON_MAC */
-extern void nlm_nlm_common_mac_msgring_handler(int bucket, int size, int code, int stid,
-                                           struct msgrng_msg *msg, void *data/* ignored */);
-static void nlm_nlm_common_syscall_msgring_handler(int bucket, int size, int code, int stid,
-                                           struct msgrng_msg *msg, void *data/* ignored */);
-
-
-
-void nlm_common_msgring_drv_int_handler(int bucket, int size, int code, int stid,
-				  struct msgrng_msg *msg, void *data/* ignored */)
-{
-	volatile struct fifo *msg_fifo = 0;
-	struct msgring_msg_data msg_data;
-	int ret = 0;
-	int tx_stid = MAX_MSG_FIFOS;
-
-
-	if (stid < MSGRING_STNID_DEVICES) {
-
-
-		if (((code&0xf) == 0xf) && hybrid) {
-			// forward to linux driver
-			nlm_xlr_rmios_msgring_handler(bucket, size, code, stid, msg, data);
-			return;
-		}
-		if (((code&0xf) == 0xe) && hybrid) {
-			nlm_nlm_common_syscall_msgring_handler(bucket, size, code, stid, msg, data);
-			return;
-		}
-		tx_stid = stid >> 3;
-	}
-	else {
-		if (stid == 96 || (is_xls() && stid == 80)) {
-			tx_stid = 8 + (msg->msg1 & 0x0f);
-		}
-		else {
-			printk("[%s]: illegal tx_stid = %d, stid=%d\n", __FUNCTION__, tx_stid, stid);
-			return;
-		}
-	}
-
-	//printk("[%s:%d]: \n", __FUNCTION__, __LINE__);
-
-	if (hybrid)
-		tx_stid = (msg->msg0 & 0xffffffff);
-
-	msg_fifo = &msg_fifos[tx_stid];
-
-	msg_data.size = size;
-	msg_data.code = code;
-	msg_data.rx_bucket = bucket;
-	msg_data.stid = stid;
-	msg_data.msgs[0] = (msg->msg0 & 0xffffffff);
-	msg_data.msgs[1] = (msg->msg0 >> 32);
-	msg_data.msgs[2] = (msg->msg1 & 0xffffffff);
-	msg_data.msgs[3] = (msg->msg1 >> 32);
-	msg_data.msgs[4] = (msg->msg2 & 0xffffffff);
-	msg_data.msgs[5] = (msg->msg2 >> 32);
-	msg_data.msgs[6] = (msg->msg3 & 0xffffffff);
-	msg_data.msgs[7] = (msg->msg3 >> 32);
-
-	PRINTK_INFO("%s:%d adding message to txid=%d fifo:%p\n", __FUNCTION__, __LINE__,
-		    tx_stid, msg_fifo);
-	spin_lock((spinlock_t *)(&msg_fifo->lock));
-	ret = fifo_enqueue(msg_fifo, &msg_data);
-	spin_unlock((spinlock_t *)(&msg_fifo->lock));
-
-	/* wake up any readers */
-	wake_up_interruptible((wait_queue_head_t *)&msg_fifo->wq);
-
-	if (!ret) {
-		PRINTK_ERR("[%s]: Unable to queue message from %d tx_stid (stid=%d)\n", __FUNCTION__, tx_stid, stid);
-	}
-
-}
-
-static int msgring_open (struct inode *inode, struct file *filp)
-{
-	//printk("msgring_open() invoked\n");
-
-	filp->private_data = NULL;
-
-	return 0;
-}
-
-static DECLARE_WAIT_QUEUE_HEAD(msgring_read_wait);
-static DECLARE_WAIT_QUEUE_HEAD(msgring_write_wait);
-
-static unsigned int msgring_poll(struct file *filp, struct poll_table_struct *wait)
-{
-	unsigned int mask;
-	volatile struct fifo *msg_fifo = NULL;
-	int count = 0;
-	unsigned long flags;
-
-	if (!filp->private_data) return -EINVAL;
-
-	msg_fifo = filp->private_data;
-
-	mask = 0;
-
-	spin_lock_irqsave((spinlock_t *)&msg_fifo->lock, flags);
-	count = fifo_count(msg_fifo);
-	spin_unlock_irqrestore((spinlock_t *)&msg_fifo->lock, flags);
-
-	if(!count) {
-		poll_wait(filp, (wait_queue_head_t *)&msg_fifo->wq, wait);
-
-		spin_lock_irqsave((spinlock_t *)&msg_fifo->lock, flags);
-		count = fifo_count(msg_fifo);
-		spin_unlock_irqrestore((spinlock_t *)&msg_fifo->lock, flags);
-	}
-	/* if there is data in the read buffer */
-	if (count > 0) {
-		PRINT_NLM_FIFO_DATA(msg_fifo);
-		mask |= POLLIN | POLLRDNORM;
-	} else {
-		PRINT_NLM_FIFO_DATA(msg_fifo);
-		PRINTK_INFO("%s:%d count=%d\n", __FUNCTION__, __LINE__, count);
-	}
-
-	/* mark it writable always! */
-	mask |= POLLOUT | POLLWRNORM;
-
-	return mask;
-}
-
-static ssize_t msgring_read (struct file *filp, char __user *buf, size_t count, loff_t *offset)
-// offset: the offset in the file
-// count : no of bytes to read
-// buf   : start location (in user space) to which to copy the contents
-// filp  : pointer to 'struct file'  of the file
-{
-	volatile struct fifo *msg_fifo = NULL;
-	int msg_size = sizeof(struct msgring_msg_data);
-	struct msgring_msg_data msg;
-	int ret = 0;
-	unsigned long flags;
-
-	if (!filp->private_data) return -EINVAL;
-
-	if (count < msg_size) return -EINVAL;
-
-	msg_fifo = filp->private_data;
-
-	// we don't care about the passed file offset, but will update it
-	// with the no of bytes read
- retry:
-	spin_lock_irqsave((spinlock_t *)&msg_fifo->lock, flags);
-	ret = fifo_dequeue(msg_fifo, &msg);
-	spin_unlock_irqrestore((spinlock_t *)&msg_fifo->lock, flags);
-
-	if (!ret) {
-		if (filp->f_flags & O_NONBLOCK) return -EAGAIN;
-		if (wait_event_interruptible((((struct fifo *)(msg_fifo))->wq), 
-					fifo_count(msg_fifo)))
-			return -ERESTARTSYS;
-		goto retry;
-	}
-
-	PRINTK_INFO("%s:%d reading message from fifo:%p\n", __FUNCTION__, __LINE__, msg_fifo);
-	if ( __copy_to_user(buf, &msg, count) )
-		return -EFAULT;
-
-	filp->f_pos += count;
-	return count;
-}
-
-static ssize_t msgring_write(struct file *filp, const char __user *buf, size_t count, loff_t *off)
-{
-	struct msgring_msg_data *umsg_data = NULL;
-	int msg_size = sizeof(struct msgring_msg_data);
-	struct msgrng_msg msg;
-	int size=0, code=0, stid=0;
-	unsigned long mflags = 0;
-	struct msgring_msg_data msg_data;
-
-	if (count < msg_size) return -EINVAL;
-
-	umsg_data = (struct msgring_msg_data *)buf;
-
-	__copy_from_user(&size, &umsg_data->size, 4);
-	__copy_from_user(&code, &umsg_data->code, 4);
-	__copy_from_user(&stid, &umsg_data->stid, 4);
-
-	__copy_from_user(&msg_data.msgs[0], &umsg_data->msgs[0], 4);
-	__copy_from_user(&msg_data.msgs[1], &umsg_data->msgs[1], 4);
-	__copy_from_user(&msg_data.msgs[2], &umsg_data->msgs[2], 4);
-	__copy_from_user(&msg_data.msgs[3], &umsg_data->msgs[3], 4);
-	__copy_from_user(&msg_data.msgs[4], &umsg_data->msgs[4], 4);
-	__copy_from_user(&msg_data.msgs[5], &umsg_data->msgs[5], 4);
-	__copy_from_user(&msg_data.msgs[6], &umsg_data->msgs[6], 4);
-	__copy_from_user(&msg_data.msgs[7], &umsg_data->msgs[7], 4);
-
-	msg.msg0 = ((__u64)msg_data.msgs[1] << 32) | ((__u64)msg_data.msgs[0]);
-	msg.msg1 = ((__u64)msg_data.msgs[3] << 32) | ((__u64)msg_data.msgs[2]);
-	msg.msg2 = ((__u64)msg_data.msgs[5] << 32) | ((__u64)msg_data.msgs[4]);
-	msg.msg3 = ((__u64)msg_data.msgs[7] << 32) | ((__u64)msg_data.msgs[6]);
-
-	__sync();
-
-	msgrng_flags_save(mflags);
-
-	if (message_send_retry(size, code, stid, &msg)) {
-		printk("Failed to send message!\n");
-		msgrng_flags_restore(mflags);
-		return -EAGAIN;
-	}
-
-	msgrng_flags_restore(mflags);
-
-
-	return msg_size;
-}
-
-static int msgring_mmap_syscall (struct file *file, struct vm_area_struct *vma)
-{
-        unsigned long addr = __pa(file->private_data);
-        unsigned long size = vma->vm_end - vma->vm_start;
-
-	if (vma->vm_flags & VM_LOCKED) return -EPERM;
-	vma->vm_flags |= (VM_RESERVED | VM_IO);
-	if (remap_pfn_range(vma, vma->vm_start, (addr >> PAGE_SHIFT), size, vma->vm_page_prot))
-		return -EAGAIN;
-	return 0;
-}
-
-static int msgring_mmap (struct file *file, struct vm_area_struct *vma)
-{
-	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
-	unsigned long shm_addr = __pa(nlm_common_psb_shm);
-	unsigned long shm_size = nlm_common_psb_shm_size;
-	unsigned long size = 0;
-	unsigned long vm_size = vma->vm_end - vma->vm_start;
-
-	if (file->private_data != 0 &&
-           ((char *)file->private_data < (char *)&msg_fifos[0] ||
-            (char *)file->private_data > (char *)&msg_fifos[MAX_MSG_FIFOS]))
-		return msgring_mmap_syscall(file, vma);
-
-	if (vma->vm_start != (unsigned long)NLM_USER_MAC_MMAP_VIRT_START)
-		return -EINVAL;
-
-	if (!shm_addr) return -ENXIO;
-
-	if (offset >= shm_size) return -ESPIPE;
-
-	if (vma->vm_flags & VM_LOCKED) return -EPERM;
-
-	size = shm_size - offset;
-	if (vm_size > size) return -ENOSPC;
-
-	vma->vm_flags |= (VM_RESERVED | VM_IO);
-
-	if (remap_pfn_range(vma, vma->vm_start, (shm_addr >> PAGE_SHIFT), size, vma->vm_page_prot))
-		return -EAGAIN;
-
-	return 0;
-}
-static DEFINE_PER_CPU(spinlock_t, msgring_lock) = SPIN_LOCK_UNLOCKED;
-static int cpu_spread[16];
-
-static int send_syscall (SYSCALL *syscall, int arg)
-{
-	struct msgrng_msg msg;
-	unsigned long mflags = 0;
-	int cpu, dst_stid, src_stid;
-	int ret;
-
-	cpu = hard_smp_processor_id();
-	src_stid = (((cpu >> 2) << 3) | (cpu & 0x3));
-	if (smp_boot.online_map == 0xff)
-		dst_stid = 16 + src_stid + (((cpu_spread[cpu]++ % 3) & 0x3) << 4);
-	else if (smp_boot.online_map == 0xf) {
-		dst_stid = 8 + src_stid;
-	}
-	else
-		dst_stid = 32 + src_stid;
-	msg.msg0 = (1ULL<<63) | ((uint64_t)src_stid<<40) |
-		((uint64_t)arg<<32) | (uint32_t)(unsigned long)syscall;
-	msg.msg1 = msg.msg2 = msg.msg3 = 0;
-	spin_lock(&__get_cpu_var(msgring_lock));
-	msgrng_flags_save(mflags);
-	ret = message_send_retry(1, 0, dst_stid, &msg);
-	msgrng_flags_restore(mflags);
-	spin_unlock(&__get_cpu_var(msgring_lock));
-
-	return ret;
-}
-
-static int msgring_ioctl (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	unsigned long shm_vaddr = (unsigned long)nlm_common_psb_shm;
-	unsigned long shm_paddr = __pa(nlm_common_psb_shm); // assume it is in kseg0, for now
-
-	switch (cmd) {
-
-	case MSGRING_IOC_SSTNNO: {
-		int tx_stn = arg;
-		if (tx_stn >= MAX_MSG_FIFOS) {
-			printk("[%s]: illegal tx stn id=%d\n", __FUNCTION__, tx_stn);
-			return -EINVAL;
-		}
-		filp->private_data = &msg_fifos[tx_stn];
-		PRINTK_INFO("%s:%d registering tx_stn=%d fifo=%p\n", __FUNCTION__, __LINE__,
-			    tx_stn, filp->private_data);
-		msg_fifos[tx_stn].head = msg_fifos[tx_stn].tail = 0;
-	}
-		break;
-
-	case MSGRING_IOC_GSHMPHYS: {
-		*(unsigned int *)arg = shm_paddr;
-	}
-		break;
-
-	case MSGRING_IOC_GSHMVIRT: {
-		*(unsigned int *)arg = shm_vaddr;
-	}
-		break;
-
-	case MSGRING_IOC_GMMAP_START:{
-			*(unsigned int *)arg =
-			    (unsigned int)NLM_USER_MAC_MMAP_VIRT_START;
-	}
-		break;
-
-	case MSGRING_IOC_SYSINIT: {
-		/* allocate the socket interfacxe */
-		SYSCALL *syscall;
-
-		/* allocate the syscall interface */
-		syscall = kmalloc(arg, GFP_KERNEL);
-		if (!syscall) {
-			printk("syscall: no memory\n");
-			return -ENOMEM;
-		}
-		init_waitqueue_head(&syscall->sleep);
-                syscall->process = 0;
-		syscall->pid = current->pid;
-		filp->private_data = syscall;
-	}
-		break;
-
-	case MSGRING_IOC_SYSPHYS:
-		*(unsigned int *)arg = (unsigned int)(unsigned long)filp->private_data;
-		break;
-
-	case MSGRING_IOC_SYSCALL: {
-		SYSCALL *syscall;
-		DEFINE_WAIT(wait);
-		int not_sent;
-
-		/* send a system call */
-		syscall = filp->private_data;
-		syscall->done = 0;
-		syscall->num++;
-		syscall->trace = 0;
-		not_sent = send_syscall(syscall, arg);
-
-		/* wait for the answer */
-		if (syscall->done) {
-			if (syscall->id == 10) /*SYSCALL_memcpy */
-  		          return 100;
-			/* the system call was acknowledged */
-			break;
-		}
-
-		do {
-			prepare_to_wait(&syscall->sleep, &wait, TASK_INTERRUPTIBLE);
-			schedule_timeout(1);
-			if (not_sent)
-				/* we have not yet sent the system call */
-				not_sent = send_syscall(syscall, arg);
-		} while (!signal_pending(current) && !syscall->done);
-		finish_wait(&syscall->sleep, &wait);
-		if (syscall->done) {
-			if (syscall->id == 10) /*SYSCALL_memcpy */
-  		          return 100;
-
-			/* the system call was acknowledged, stop, because rmios will not
-			 * reply to an interrupt when it is idle */
-			break;
-		}
-		if (not_sent)
-			/* the system call was not sent and the process caught a signal,
-			 * stop, because rmios will not reply to an interrupt when it is
-			 * idle */
-			return -EINTR;
-		not_sent = send_syscall(syscall, SYSCALL_interrupt);
-		if (syscall->done)
-			/* the interrupt was acknowledged wither by a system call response
-			 * or by an interrupt response */
-			return -EINTR;
-		do {
-			prepare_to_wait(&syscall->sleep, &wait, TASK_UNINTERRUPTIBLE);
-			schedule_timeout(1);
-			if (not_sent)
-				/* we have not yet sent the interrupt */
-				not_sent = send_syscall(syscall, SYSCALL_interrupt);
-		} while (!syscall->done);
-		finish_wait(&syscall->sleep, &wait);
-		/* the interrupt was acknowledged wither by a system call response
-		 * or by an interrupt response */
-		return -EINTR;
-	}
-		break;
-
-	default: {
-		printk("ioctl(): invalid command\n");
-		return -EINVAL;
-	}
-
-	}
-
-	//printk("[%s:%d]: \n", __FUNCTION__, __LINE__);
-
-	return 0;
-}
-
-static long msgring_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	unsigned long ret = -1;
-	lock_kernel();
-	ret = msgring_ioctl(NULL,filp,cmd,arg);
-	unlock_kernel();
-	if(ret){
-		printk("msgring_ioctl returned with an error %lx", ret);
-		return -ENOIOCTLCMD;
-	}
-	return ret;
-}
-
-static void nlm_nlm_common_syscall_msgring_handler(int bucket, int size, int code, int stid,
-                                      struct msgrng_msg *msg, void *data/* ignored */) {
-
-	SYSCALL *syscall;
-	syscall = (SYSCALL *)(unsigned long)msg->msg0;
-	//printk("Wake up syscall %p sleep %p\n",syscall,&syscall->sleep);
-	if (msg->msg0 & (1ULL<<62))
-		syscall->done = 2;
-	else
-		syscall->done = 1;
-	wake_up_interruptible(&syscall->sleep);
-}
-
-// called only when the reference count (maintained in inode) is zero
-static int msgring_release (struct inode *inode, struct file *filp)
-{
-	if (filp->private_data != 0 &&
-           ((char *)filp->private_data < (char *)&msg_fifos[0] ||
-            (char *)filp->private_data > (char *)&msg_fifos[MAX_MSG_FIFOS])) {
-		SYSCALL *syscall;
-		syscall = filp->private_data;
-		if (syscall->process) {
-			int sig = test_tsk_thread_flag(current, TIF_SIGPENDING);
-			if (sig)
-				clear_tsk_thread_flag(current, TIF_SIGPENDING);
-			msgring_ioctl(inode, filp, MSGRING_IOC_SYSCALL, SYSCALL_exit);
-			if (sig)
-				set_tsk_thread_flag(current, TIF_SIGPENDING);
-		}
-		kfree(filp->private_data);
-		filp->private_data = 0;
-	}
-	return 0;
-}
-
-static struct file_operations msgring_fops = {
-	owner:		THIS_MODULE,
-	read:		msgring_read,
-	write:		msgring_write,
-	mmap:		msgring_mmap,
-	open:		msgring_open,
-	ioctl:		msgring_ioctl,
-	poll:		msgring_poll,
-	release:	msgring_release,
-	compat_ioctl:	msgring_compat_ioctl,
-};
-
-// msgring_init(): invoked as part of the kernel bootup process
-static int msgring_init(void)
-{
-	int err;
-	int i=0;
-
-	/* if support for loading apps on same core as Linux is enabled */
-	if(!xlr_hybrid_rmios_ipsec())
-		return -EINVAL;
-
-	hybrid = strstr(saved_command_line, "hybrid=");
-
-	// Intitialize 8 FIFO queues for each of the 8 cpu stations
-	for (i = 0; i < MAX_MSG_FIFOS; ++i) {
-
-		fifo_init(&msg_fifos[i], MSG_FIFO_SIZE);
-		init_waitqueue_head(&msg_fifos[i].wq);
-
-		if (i > 7) continue;
-
-		err = register_msgring_handler(TX_STN_CPU_0 + i, nlm_common_msgring_drv_int_handler, NULL);
-		if (err) {
-			// should we panic or just return an error message
-			panic("In %s at line %d: unable to register handler for msgring stations for stn %d\n",
-			      __FILE__, __LINE__, i);
-		}
-	}
-
-	msgring_major = register_chrdev (XLR_MSGRING_SHM_MAJOR, NLM_MSGRING_CHRDEV_NAME, &msgring_fops);
-	if (msgring_major < 0) {
-		printk("msgring_init() register_chrdev() failed\n");
-		return msgring_major;
-	}
-	msgring_major = XLR_MSGRING_SHM_MAJOR;
-	printk("Registered phoenix msgring driver: major=%d\n", msgring_major);
-
-	return 0;
-}
-
-static void msgring_exit(void)
-{
-	unregister_chrdev (msgring_major, NLM_MSGRING_CHRDEV_NAME);
-}
-
-module_init (msgring_init);
-module_exit (msgring_exit);
-
-// Do we need to export any names ?
diff --git a/drivers/char/random.c b/drivers/char/random.c
index 44b5948..aa7ead0 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -1,11 +1,3 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
 /*
  * random.c -- A strong random number generator
  *
@@ -1061,7 +1053,6 @@ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
 	return ret;
 }
 
-#if !(defined(CONFIG_NLM_COMMON) && defined(CONFIG_HW_RANDOM))
 static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
 				    size_t nbytes)
 {
@@ -1099,7 +1090,6 @@ static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
 
 	return ret;
 }
-#endif
 
 /*
  * This function is the exported kernel interface.  It returns some
@@ -1206,17 +1196,6 @@ void rand_initialize_disk(struct gendisk *disk)
 }
 #endif
 
-#if defined(CONFIG_NLM_COMMON) && defined(CONFIG_HW_RANDOM)
-static ssize_t
-random_read(struct file * file, char * buf, size_t nbytes, loff_t *ppos)
-{
-  get_random_bytes(buf, nbytes);
-
-  file_accessed(file);
-	
-  return nbytes;
-}
-#else
 static ssize_t
 random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
@@ -1272,25 +1251,12 @@ random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 
 	return (count ? count : retval);
 }
-#endif
 
-#if defined(CONFIG_NLM_COMMON) && defined(CONFIG_HW_RANDOM)
-static ssize_t
-urandom_read(struct file * file, char * buf, size_t nbytes, loff_t *ppos)
-{
-  get_random_bytes(buf, nbytes);
-
-  file_accessed(file);
-	
-  return nbytes;
-}
-#else
 static ssize_t
 urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
 	return extract_entropy_user(&nonblocking_pool, buf, nbytes);
 }
-#endif
 
 static unsigned int
 random_poll(struct file *file, poll_table * wait)
diff --git a/drivers/char/xlr_pcix_console_dev.c b/drivers/char/xlr_pcix_console_dev.c
deleted file mode 100644
index 5604ba3..0000000
--- a/drivers/char/xlr_pcix_console_dev.c
+++ /dev/null
@@ -1,459 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/console.h>
-#include <linux/pci.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/tty.h>
-#include <linux/tty_flip.h>
-#include <linux/serial.h>
-#include <linux/serial_core.h>
-#include <linux/module.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/rtnetlink.h>
-#include <linux/delay.h>
-#include <linux/ethtool.h>
-#include <linux/mii.h>
-#include <linux/completion.h>
-#include <linux/crc32.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/atomic.h>
-#include <linux/timer.h>
-#include <asm/netlogic/nlm_pcix_gen_dev.h>
-#include <asm/netlogic/devices.h>
-
-#define DRIVER_VERSION "v0.1"
-#define DRIVER_AUTHOR "Netlogic"
-#define DRIVER_DESC "Virtual serial console driver for Arizona3"
-#define BUF_SIZE (1024*4)
-#define USER_CMD_SIZE (1*1024)
-#define USER_RESULT_SIZE (7*1024)
-
-
-/* Module information */
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
-MODULE_LICENSE("GPL");
-
-#define DELAY_TIME   2	     /* 2 seconds per character */
-#define CONSOLE_OVER_PCI_MINORSS	244	/* only have one minor */
-#define UART_NR			1	/* only use one port */
-
-#define CONSOLE_OVER_PCI	"pci_co"
-
-#define Message(a,b...) //printk("Function [%s]"a"\n",__FUNCTION__,##b)
-#define ErrorMsg(a,b...) printk("Function [%s]"a"\n",__FUNCTION__,##b)
-static u32 *nlm_common_user_cmd_producer;
-static u32 *nlm_common_user_cmd_consumer;
-static u32 *nlm_common_user_result_consumer;
-static u32 *nlm_common_user_result_producer;
-static u8 *nlm_common_user_cmd;
-static u8 *nlm_common_user_result;
-static volatile u32 *nlm_common_dev_status;
-static volatile u32 *nlm_common_host_status;
-
-
-static wait_queue_head_t user_result_buffer;
-
-static struct timer_list *timer;
-
-extern int nlm_pcix_early_setup_dev(void);
-extern long nlm_common_get_shared_mem_base_dev(void);
-static void nlm_pcix_console_stop_tx(struct uart_port *port)
-{
-	Message("");
-}
-
-static void nlm_pcix_console_stop_rx(struct uart_port *port)
-{
-	Message("");
-}
-
-static void nlm_pcix_console_enable_ms(struct uart_port *port)
-{
-	Message("");
-}
-
-static void nlm_dev_put_char(char ch)
-{
- 
-  if(*nlm_common_host_status != 0xdeadbeef)
-	return;
-
-  Message("-- Called"); 
-
-  if((*nlm_common_user_result_producer) + 1 == *nlm_common_user_result_consumer){
-    return;
-  }  
-  *(nlm_common_user_result + *nlm_common_user_result_producer) = ch;
-  
-  *nlm_common_user_result_producer = (*nlm_common_user_result_producer + 1) % (USER_RESULT_SIZE);
-
-   Message("nlm_common_user_result_producer [%d]",*nlm_common_user_result_producer);
-}
-
-static void nlm_pcix_console_rx_chars(struct uart_port *port)
-{
-  struct tty_struct *tty;
-  char ch;
-	
-  if(*nlm_common_user_cmd_producer == *nlm_common_user_cmd_consumer)
-    return;
-
-  tty = port->state->port.tty;
-  if (!tty){
-	  ErrorMsg("tty is nt thr...");
-	  return;
-  }
-
-  do{
-    ch = *(nlm_common_user_cmd + (*nlm_common_user_cmd_consumer));
-    Message("[%c]",ch);
-    tty_insert_flip_char(tty, ch, TTY_NORMAL); 
-    tty_flip_buffer_push(tty);
-    *nlm_common_user_cmd_consumer = (*nlm_common_user_cmd_consumer + 1) % (USER_CMD_SIZE);
-  }while(*nlm_common_user_cmd_producer != *nlm_common_user_cmd_consumer);
-  
-}
-
-static void nlm_pcix_console_tx_chars(struct uart_port *port)
-{
-	struct circ_buf *xmit = &port->state->xmit;
-	int count;
-	Message("");
-	if (port->x_char) {
-		Message ("DATA [%c] - port->x_char", port->x_char);
-		nlm_dev_put_char(port->x_char);
-		port->icount.tx++;
-		port->x_char = 0;
-		return;
-	}
-	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
-		nlm_pcix_console_stop_tx(port);
-		return;
-	}
-
-	count = port->fifosize >> 1;
-	do{
-		Message ("DATA [%c] - do while", xmit->buf[xmit->tail]);
-		
-		nlm_dev_put_char(xmit->buf[xmit->tail]);
-		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		port->icount.tx++;
-		
-		if (uart_circ_empty(xmit))
-			break;
-		
-	}while(--count > 0);
-
-
-	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS){
-		Message("uart write wakeup");
-		uart_write_wakeup(port);
-	}
-
-}
-
-static void nlm_pcix_console_start_tx(struct uart_port *port)
-{
-	Message("");
-}
-
-static void nlm_pcix_console_timer (unsigned long data)
-{
-	struct uart_port *port;
-
-	Message("");
-	port = (struct uart_port *)data;
-	if (!port){
-		ErrorMsg("port is nt there...");
-		return;
-	}
-
-	/* see if port is closed ??*/
-        if(*nlm_common_host_status != 0xdeadbeef){
-	  /*hangup device*/  	
-	  goto out;
-	}
-	/* see if we have any data for rx*/
-	nlm_pcix_console_rx_chars(port);
-out:
-	/* see if we have any data to transmit */
-	nlm_pcix_console_tx_chars(port);
-	/* resubmit the timer again */
-	timer->expires = jiffies + DELAY_TIME;
-	add_timer (timer);
-}
-
-static unsigned int nlm_pcix_console_tx_empty(struct uart_port *port)
-{
-	return 1;
-}
-
-static unsigned int nlm_pcix_console_get_mctrl(struct uart_port *port)
-{
-	return port->mctrl;
-}
-
-static void nlm_pcix_console_set_mctrl(struct uart_port *port, unsigned int mctrl)
-{
-  port->mctrl = mctrl;
-}
-
-static void nlm_pcix_console_break_ctl(struct uart_port *port, int break_state)
-{
-}
-
-static int nlm_pcix_console_startup(struct uart_port *port)
-{
-  /* this is the first time this port is opened */
-  /* do any hardware initialization needed here */
-  /* create our timer and submit it */
-
-  Message("Open Called..");	
-  Message("nlm_common_user_result_consumer is [%d]",*nlm_common_user_result_consumer);
-  Message("nlm_common_user_result_producer is [%d]",*nlm_common_user_result_producer);
-
-  if (!timer) {
-    timer = kmalloc (sizeof (*timer), GFP_KERNEL);
-    if (!timer)
-      return -ENOMEM;
-  }
-  init_timer(timer);
-  timer->data = (unsigned long )port;
-  timer->expires = jiffies + DELAY_TIME;
-  timer->function = nlm_pcix_console_timer;
-  add_timer (timer);
-  *nlm_common_dev_status = 0xdeadbeef;
-  Message("-- Returns");	
-  return 0;
-}
-
-static void nlm_pcix_console_shutdown(struct uart_port *port)
-{
-  /* The port is being closed by the last user. */
-  /* Do any hardware specific stuff here */
-
-  /* shut down our timer */
-  Message("Close Called");
-  del_timer (timer);
-  *nlm_common_dev_status = 0x0;
-}
-
-static const char *nlm_pcix_console_type(struct uart_port *port)
-{
-  return "nlm_pcix_consoletty";
-}
-
-static void nlm_pcix_console_release_port(struct uart_port *port)
-{
-
-}
-
-static int nlm_pcix_console_request_port(struct uart_port *port)
-{
-  return 0;
-}
-
-static void nlm_pcix_console_config_port(struct uart_port *port, int flags)
-{
-}
-
-static int nlm_pcix_console_verify_port(struct uart_port *port, struct serial_struct *ser)
-{
-  return 0;
-}
-static void
-nlm_pcix_console_set_termios(struct uart_port *port, struct ktermios *termios,
-		       struct ktermios *old)
-{
-	return;
-}
-static struct uart_ops nlm_pcix_console_ops = {
-  .tx_empty	= nlm_pcix_console_tx_empty,
-  .set_mctrl	= nlm_pcix_console_set_mctrl,
-  .get_mctrl	= nlm_pcix_console_get_mctrl,
-  .stop_tx	= nlm_pcix_console_stop_tx,
-  .start_tx	= nlm_pcix_console_start_tx,
-  .stop_rx	= nlm_pcix_console_stop_rx,
-  .enable_ms	= nlm_pcix_console_enable_ms,
-  .break_ctl	= nlm_pcix_console_break_ctl,
-  .startup	= nlm_pcix_console_startup,
-  .shutdown	= nlm_pcix_console_shutdown,
-  .set_termios  = nlm_pcix_console_set_termios,
-  .type		= nlm_pcix_console_type,
-  .release_port	= nlm_pcix_console_release_port,
-  .request_port	= nlm_pcix_console_request_port,
-  .config_port	= nlm_pcix_console_config_port,
-  .verify_port	= nlm_pcix_console_verify_port,
-};
-
-static struct uart_port nlm_pcix_console_port = {
-  .ops		= &nlm_pcix_console_ops,
-  .type 	= PORT_8250,
-  .fifosize	= 255,
-};
-
-static struct console nlm_common_pcix_console; 
-
-static struct uart_driver nlm_pcix_console_reg = {
-  .owner  = THIS_MODULE,
-  .driver_name  = CONSOLE_OVER_PCI,
-  .dev_name  = CONSOLE_OVER_PCI,
-  .major  = XLR_CONSOLE_OVER_PCI_MAJOR,
-  .minor  = CONSOLE_OVER_PCI_MINORSS,
-  .nr  = UART_NR,
-  .cons = &nlm_common_pcix_console
-};
-
-static int __init nlm_pcix_console_init(void)
-{
-  int result;
-
-  if(xlr_get_pci_mode() == XLR_PCI_HOST_MODE){
-    Message("Xlr Is configured in Host Mode - unloading console_over_pci_dev\n");
-    return -EIO;
-  }
-  if(nlm_common_get_shared_mem_base_dev() == 0){
-	ErrorMsg("Get Shared Mem Base Iz Zero");
-	return -ENODEV;
-  }
-
-  Message ("Tiny serial driver");
-
-  result = uart_register_driver(&nlm_pcix_console_reg);
-  if (result){
-    ErrorMsg("Cant Register Driver");
-    return result;
-  }
-
-  result = uart_add_one_port(&nlm_pcix_console_reg, &nlm_pcix_console_port);
-		
-  if (result){
-    ErrorMsg("Cant Add Port");	  
-    uart_unregister_driver(&nlm_pcix_console_reg);
-  }
-  Message("Returning From init_module [%d]",result);
-
-  Message("\nnlm_common_user_cmd @ %#x\n",(u32)nlm_common_user_cmd);
-  Message("nlm_common_user_result @ %#x\n",(u32)nlm_common_user_result);
-  Message("User_Cmd_Producer [%#x]\n",(u32)nlm_common_user_cmd_producer);
-  Message("User_Cmd_Consumer [%#x]\n",(u32)nlm_common_user_cmd_consumer);
-  Message("User_Result_Consumer [%#x]\n",(u32)nlm_common_user_result_consumer);
-  Message("User_Result_Producer [%#x]\n",(u32)nlm_common_user_result_producer);
-
-  init_waitqueue_head(&user_result_buffer);
-  printk("\nConsole Over Pci Driver - Registered\n"); 
-  return result;
-}
-
-static void __exit nlm_pcix_console_cleanup(void)
-{
-  uart_remove_one_port(&nlm_pcix_console_reg, &nlm_pcix_console_port);
-  uart_unregister_driver(&nlm_pcix_console_reg);
-}
-
-static void
-nlm_common_pcix_console_write(struct console *co, const char *str, unsigned int count)
-{
-  int i;
-  *nlm_common_dev_status = 0xdeadbeef;
-  for(i=0;i<count;i++){
-    nlm_dev_put_char(*(str+i));
-    if(*(str+i) == '\n')
-      nlm_dev_put_char('\r');	    
-  }
-}
-
-static int __init nlm_common_pcix_console_setup(struct console *co,char *options)
-{
-  return 0;
-}
-static struct console nlm_common_pcix_console= {
-	.name           = CONSOLE_OVER_PCI,
-	.write          = nlm_common_pcix_console_write,
-	.device         = uart_console_device,
-	.setup          = nlm_common_pcix_console_setup,
-	.flags          = CON_PRINTBUFFER,
-	.index          = -1,
-	.data           = &nlm_pcix_console_reg,
-};
-
-
-
-static int __init nlm_common_pcix_console_init(void)
-{
-
-  if(xlr_get_pci_mode() == XLR_PCI_HOST_MODE)
-    return -EIO;
-
-  nlm_pcix_early_setup_dev();
-
-  if(nlm_common_get_shared_mem_base_dev() == 0){
-	ErrorMsg("Either XLR Is in Host Mode or pci_shared_mem option is not specified");
-	return -ENODEV;
-  }
-  nlm_common_user_cmd = (u8 *)nlm_common_get_shared_mem_base_dev() + 
-                   NLM_CONSOLE_OVER_PCI_SHARED_MEM_BASE;
-
-  nlm_common_user_result = nlm_common_user_cmd + USER_CMD_SIZE;
-  nlm_common_user_cmd_producer = (u32 *)(nlm_common_user_result + USER_RESULT_SIZE);
-  
-  nlm_common_user_cmd_consumer = nlm_common_user_cmd_producer + 1;
-  nlm_common_user_result_consumer= nlm_common_user_cmd_consumer + 1;
-  nlm_common_user_result_producer= nlm_common_user_result_consumer + 1;
-  nlm_common_dev_status = nlm_common_user_result_producer + 1;
-  nlm_common_host_status = nlm_common_dev_status + 1;
-  *nlm_common_user_cmd_consumer = *nlm_common_user_result_consumer = 
-	  *nlm_common_user_cmd_producer = *nlm_common_user_result_producer =
-	  *nlm_common_dev_status = 0;
-  Message("\nnlm_common_user_cmd @ %#x\n",(uint32_t)nlm_common_user_cmd);
-  Message("nlm_common_user_result @ %#x\n",(uint32_t)nlm_common_user_result);
-  Message("nlm_common_user_cmd_producer @ %#x\n",(uint32_t)nlm_common_user_cmd_producer);
-  Message("nlm_common_user_cmd_consumer @ %#x\n",(uint32_t)nlm_common_user_cmd_consumer);
-  Message("nlm_common_user_result_consumer @ %#x\n",
-				(uint32_t)nlm_common_user_result_consumer);
-  Message("nlm_common_user_result_producer @ %#x\n",
-			(uint32_t)nlm_common_user_result_producer);
-  Message("*nlm_common_user_cmd %#x\n",(uint32_t)*nlm_common_user_cmd);
-  Message("nlm_common_dev_status %#x\n",(uint32_t)nlm_common_dev_status);
-  Message("nlm_common_host_status %#x\n",(uint32_t)nlm_common_host_status);
-
-  register_console(&nlm_common_pcix_console);
-  return 0;
-}
-
-console_initcall(nlm_common_pcix_console_init);
-
-
-module_init(nlm_pcix_console_init);
-module_exit(nlm_pcix_console_cleanup);
-
diff --git a/drivers/char/xlr_pcix_console_host.c b/drivers/char/xlr_pcix_console_host.c
deleted file mode 100644
index 4589b22..0000000
--- a/drivers/char/xlr_pcix_console_host.c
+++ /dev/null
@@ -1,476 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/pci.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/tty.h>
-#include <linux/tty_flip.h>
-#include <linux/serial.h>
-#include <linux/serial_core.h>
-#include <linux/module.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/rtnetlink.h>
-#include <linux/delay.h>
-#include <linux/ethtool.h>
-#include <linux/mii.h>
-#include <linux/completion.h>
-#include <linux/crc32.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/atomic.h>
-#include <linux/timer.h>
-#ifdef CONFIG_NLM_COMMON
-#include <asm/netlogic/nlm_pcix_gen_host.h>
-#include <asm/netlogic/devices.h>
-#else
-#include "nlm_pcix_gen_host.h"
-#endif
-
-
-#define DRIVER_VERSION "v0.1"
-#define DRIVER_AUTHOR "RMI-INDIA"
-#define DRIVER_DESC "console over pci"
-#define BUF_SIZE (1024*4)
-#define NLM_USER_CMD_SIZE (1*1024)
-#define NLM_USER_RESULT_SIZE (7*1024)
-
-/* Module information */
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
-MODULE_LICENSE("GPL");
-
-#define DELAY_TIME  2	/* 2 seconds per character */
-
-#ifndef CONFIG_NLM_COMMON
-#define XLR_CONSOLE_OVER_PCI_MAJOR 246
-#endif
-#define CONSOLE_OVER_PCI_MINORS	244	/* only have one minor */
-#define UART_NR			1	/* only use one port */
-
-#define CONSOLE_OVER_PCI	"pci_console"
-
-
-#define Message(a,b...) //printk("Function [%s]"a"\n",__FUNCTION__,##b)
-#define ErrorMsg(a,b...) printk("Function [%s]"a"\n",__FUNCTION__,##b)
-
-static volatile u32 *nlm_common_user_cmd_producer;
-static volatile u32 *nlm_common_user_cmd_consumer;
-static volatile u32 *nlm_common_user_result_consumer;
-static volatile u32 *nlm_common_user_result_producer;
-static volatile u8 *nlm_common_user_cmd;
-static volatile u8 *nlm_common_user_result;
-static volatile u32 *nlm_common_dev_status;
-static volatile u32 *nlm_common_host_status;
-static int nlm_common_pcix_dev_up=0;
-
-extern unsigned long nlm_common_get_shared_mem_base_host(void);
-static struct timer_list *nlm_common_timer=NULL;
-extern void nlm_common_pci_writel(unsigned int  data,unsigned int *addr);
-extern void nlm_common_pci_writeb(unsigned char data, unsigned int *addr);
-
-unsigned int nlm_nlm_common_readl(unsigned int *base)
-{
-  return (nlm_common_pci_readl(base));
-}
-
-static void get_user_data(struct uart_port *port)
-{
-  u32 next_consumer;
-  u8 ch;
-  struct tty_struct *tty;
-  int flag=0;
-  
-  
-  nlm_common_pcix_dev_up=1;
-  Message("\nGot MSI - nlm_common_pcix_dev_up iz %d\n",nlm_common_pcix_dev_up);
-  
-  if (!port){
-    ErrorMsg("port is nt there...");
-    return;
-  }
-
-  tty = port->state->port.tty;
-  if (!tty){
-    ErrorMsg("tty is nt thr...");
-    return;
-  }
-
-  /* Read The Data And Push It To TTY Buffer */
-
-  next_consumer = nlm_nlm_common_readl((uint32_t *)nlm_common_user_result_consumer);
-  Message("next_consumer [%d]",next_consumer);
-  Message("nlm_common_user_result_producer [%d]",
-		nlm_nlm_common_readl((uint32_t *)nlm_common_user_result_producer));
-  tty->low_latency = 1;
-  while(next_consumer != nlm_nlm_common_readl((uint32_t *)nlm_common_user_result_producer)){
-    ch = nlm_common_pci_readb((u8 *)(nlm_common_user_result + next_consumer));
-    tty_insert_flip_char(tty, ch, TTY_NORMAL);
-    tty_flip_buffer_push(tty);  
-    flag = 1;
-    next_consumer = (next_consumer + 1) % (NLM_USER_RESULT_SIZE);
-
-    Message("next_consumer [%d]",next_consumer);
-    Message("nlm_common_user_result_producer [%d]",nlm_nlm_common_readl((uint32_t *)nlm_common_user_result_producer));
-  }
-  
-  
-  if(flag)
-    nlm_common_pci_writel(next_consumer,(uint32_t *)nlm_common_user_result_consumer);
-  
-  return;
-}
-#ifdef CONFIG_NLM_COMMON
-static void nlm_pcix_console_stop_tx(struct uart_port *port)
-#else
-static void nlm_pcix_console_stop_tx(struct uart_port *port, unsigned int tty_stop)
-#endif
-{
-	Message("");
-}
-
-static void nlm_pcix_console_stop_rx(struct uart_port *port)
-{
-	Message("");
-}
-
-static void nlm_pcix_console_enable_ms(struct uart_port *port)
-{
-	Message("");
-}
-
-static int nlm_host_put_char(char ch)
-{
-  u32 next_producer=0;
- 
-  Message("-- Called"); 
-  next_producer = nlm_nlm_common_readl((uint32_t *)nlm_common_user_cmd_producer);
-
-  if(((next_producer + 1) % NLM_USER_CMD_SIZE) == nlm_nlm_common_readl((uint32_t *)nlm_common_user_cmd_consumer)){
-      Message("in if cond\n");
-      return 0;
-  }
-
-  nlm_common_pci_writeb(ch,(void *)(nlm_common_user_cmd + next_producer));
-
-  next_producer = (next_producer + 1) % (NLM_USER_CMD_SIZE);
-
-  nlm_common_pci_writel((next_producer),(uint32_t *)nlm_common_user_cmd_producer);
-  
-  Message("next_producer [%u] nlm_common_user_cmd_producer [%p]",
-               next_producer,nlm_common_user_cmd_producer);
-
-  Message("[%c]",ch);
-
-  return 1;
-
-}
-
-static void nlm_pcix_console_tx_chars(struct uart_port *port)
-{
-	struct circ_buf *xmit = &port->state->xmit;
-	int count;
-
-	if(!nlm_common_pcix_dev_up)   // Xmit if Device Is Up.
-		return;
-  Message("\nInside TX CHARS\n");	
-	if (port->x_char) {
-		
-		if(!nlm_host_put_char(port->x_char))
-		   return;
-		Message ("DATA [%c] - port->x_char", port->x_char);
-		port->icount.tx++;
-		port->x_char = 0;
-		return;
-	}
-	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
-#ifdef CONFIG_NLM_COMMON
-		nlm_pcix_console_stop_tx(port);
-#else
-		nlm_pcix_console_stop_tx(port, 0);
-#endif
-		return;
-	}
-
-	count = port->fifosize >> 1;
-	do{
-		Message ("DATA [%c] - do while", xmit->buf[xmit->tail]);
-		
-		if(!nlm_host_put_char(xmit->buf[xmit->tail]))
-		  return;
-		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		port->icount.tx++;
-		
-		if (uart_circ_empty(xmit))
-			break;
-		
-	}while(--count > 0);
-
-	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS){
-		Message("uart write wakeup");
-		uart_write_wakeup(port);
-	}
-
-	if (uart_circ_empty(xmit))
-#ifdef CONFIG_NLM_COMMON
-		nlm_pcix_console_stop_tx(port);
-#else
-		nlm_pcix_console_stop_tx(port, 0);
-#endif
-	else
-	   Message("xmit->tail [%d] != xmit->head = [%d]",xmit->tail,
-			   xmit->head);
-}
-
-#ifdef CONFIG_NLM_COMMON
-static void nlm_pcix_console_start_tx(struct uart_port *port)
-#else
-static void nlm_pcix_console_start_tx(struct uart_port *port, unsigned int tty_start)
-#endif
-{
-	Message("");
-}
-
-static void nlm_pcix_console_timer (unsigned long data)
-{
-	struct uart_port *port;
-
-
-	port = (struct uart_port *)data;
-	if (!port){
-		ErrorMsg("port is nt there...");
-		return;
-	}
-
-	/* see if we have any data to transmit */
-	nlm_pcix_console_tx_chars(port);
- 
-        /* see if nythin to rcv */
-//	if(nlm_common_pci_readl((uint32_t *)nlm_common_dev_status) == 0xdeadbeef)
-	get_user_data(port);
-	/* resubmit the timer again */
-	nlm_common_timer->expires = jiffies + DELAY_TIME;
-	add_timer (nlm_common_timer);
-}
-
-static unsigned int nlm_pcix_console_tx_empty(struct uart_port *port)
-{
-	return 1;
-}
-
-static unsigned int nlm_pcix_console_get_mctrl(struct uart_port *port)
-{
-	return port->mctrl;
-}
-
-static void nlm_pcix_console_set_mctrl(struct uart_port *port, unsigned int mctrl)
-{
-  port->mctrl = mctrl;
-}
-
-static void nlm_pcix_console_break_ctl(struct uart_port *port, int break_state)
-{
-}
-
-static int nlm_pcix_console_startup(struct uart_port *port)
-{
-	/* this is the first time this port is opened */
-	/* do any hardware initialization needed here */
-
-	/* create our timer and submit it */
-
-  Message("Open Called..");	
-  if (!nlm_common_timer) {
-	  nlm_common_timer = kmalloc (sizeof(*nlm_common_timer), GFP_KERNEL);
-	  if (!nlm_common_timer)
-		  return -ENOMEM;
-	  Message("\nRequest Msi Handler Returned..\n");
-  }
-  init_timer(nlm_common_timer);
-  nlm_common_timer->data = (unsigned long )port;
-  nlm_common_timer->expires = jiffies + DELAY_TIME;
-  nlm_common_timer->function = nlm_pcix_console_timer;
-
-
-  Message("Opening Port");
-  nlm_common_pci_writel(0xdeadbeef,(uint32_t *)nlm_common_host_status);
-
-  add_timer (nlm_common_timer);
-  return 0;
-}
-
-static void nlm_pcix_console_shutdown(struct uart_port *port)
-{
-  /* The port is being closed by the last user. */
-  /* Do any hardware specific stuff here */
-
-  /* shut down our timer */
-  Message("Close Called");
-  Message("\nGoin To Free MSI HANDLER Index %d\n",index);
-  if(nlm_common_timer){
-  	del_timer_sync(nlm_common_timer);
-  	kfree(nlm_common_timer);
-  }
-  nlm_common_timer = NULL;
-  nlm_common_pci_writel(0,(uint32_t *)nlm_common_host_status);
-  Message("nlm_common_host_status 2 written");
-}
-
-static const char *nlm_pcix_console_type(struct uart_port *port)
-{
-  return "nlm_pcix_consoletty";
-}
-
-static void nlm_pcix_console_release_port(struct uart_port *port)
-{
-
-}
-
-static int nlm_pcix_console_request_port(struct uart_port *port)
-{
-  return 0;
-}
-
-static void nlm_pcix_console_config_port(struct uart_port *port, int flags)
-{
-}
-
-static int nlm_pcix_console_verify_port(struct uart_port *port, struct serial_struct *ser)
-{
-  return 0;
-}
-static void
-nlm_pcix_console_set_termios(struct uart_port *port, struct ktermios *termios,
-		       struct ktermios *old)
-{
-	return;
-}
-static struct uart_ops nlm_pcix_console_ops = {
-  .tx_empty	= nlm_pcix_console_tx_empty,
-  .set_mctrl	= nlm_pcix_console_set_mctrl,
-  .get_mctrl	= nlm_pcix_console_get_mctrl,
-  .stop_tx	= nlm_pcix_console_stop_tx,
-  .start_tx	= nlm_pcix_console_start_tx,
-  .stop_rx	= nlm_pcix_console_stop_rx,
-  .enable_ms	= nlm_pcix_console_enable_ms,
-  .break_ctl	= nlm_pcix_console_break_ctl,
-  .startup	= nlm_pcix_console_startup,
-  .shutdown	= nlm_pcix_console_shutdown,
-  .set_termios  = nlm_pcix_console_set_termios,
-  .type		= nlm_pcix_console_type,
-  .release_port	= nlm_pcix_console_release_port,
-  .request_port	= nlm_pcix_console_request_port,
-  .config_port	= nlm_pcix_console_config_port,
-  .verify_port	= nlm_pcix_console_verify_port,
-};
-
-static struct uart_port nlm_pcix_console_port = {
-  .ops		= &nlm_pcix_console_ops,
-  .type 	= PORT_8250,
-  .fifosize	= 255,
-};
-
-static struct uart_driver nlm_pcix_console_reg = {
-  .owner  = THIS_MODULE,
-  .driver_name  = CONSOLE_OVER_PCI,
-  .dev_name  = CONSOLE_OVER_PCI,
-  .major  = XLR_CONSOLE_OVER_PCI_MAJOR,
-  .minor  = CONSOLE_OVER_PCI_MINORS,
-  .nr  = UART_NR,
-};
-
-
-static int __init nlm_pcix_console_init(void)
-{
-  int result;
-
-#ifdef CONFIG_NLM_COMMON
-  if(nlm_get_pci_mode() == XLR_PCI_DEV_MODE){
-    return -EIO;
-  }
-#endif
-  if(nlm_common_get_shared_mem_base_host() == 0){
-    printk("\nLooks like device is not connected.\n");
-    return -ENODEV; 
-  }
-  result = uart_register_driver(&nlm_pcix_console_reg);
-  if (result){
-    ErrorMsg("Cant Register Driver");
-    return result;
-  }
-
-  result = uart_add_one_port(&nlm_pcix_console_reg, &nlm_pcix_console_port);
-		
-  if (result){
-    ErrorMsg("Cant Add Port");	  
-    uart_unregister_driver(&nlm_pcix_console_reg);
-    return result;
-  }
-  Message("Returning From init_module [%d]",result);
-  
-  nlm_common_user_cmd = (u8 *)nlm_common_get_shared_mem_base_host() + 
-                   NLM_CONSOLE_OVER_PCI_SHARED_MEM_BASE;
-  nlm_common_user_result = nlm_common_user_cmd + NLM_USER_CMD_SIZE;
-  nlm_common_user_cmd_producer = (u32 *)(nlm_common_user_result + NLM_USER_RESULT_SIZE);
-  nlm_common_user_cmd_consumer = nlm_common_user_cmd_producer + 1;
-  nlm_common_user_result_consumer= nlm_common_user_cmd_consumer + 1;
-  nlm_common_user_result_producer= nlm_common_user_result_consumer + 1;
-
-  nlm_common_dev_status  = nlm_common_user_result_producer + 1;
-  nlm_common_host_status = nlm_common_dev_status + 1;
-
-  Message("\nnlm_common_user_cmd @ %#x\n",(uint32_t)nlm_common_user_cmd);
-  Message("nlm_common_user_result @ %#x\n",(uint32_t )nlm_common_user_result);
-  Message("nlm_common_user_cmd_producer @ %#x\n",(uint32_t )nlm_common_user_cmd_producer);
-  Message("nlm_common_user_cmd_consumer @ %#x\n",(uint32_t )nlm_common_user_cmd_consumer);
-  Message("nlm_common_user_result_consumer @ %#x\n",
-			(uint32_t )nlm_common_user_result_consumer);
-  Message("nlm_common_user_result_producer @ %#x\n",
-				(uint32_t )nlm_common_user_result_producer);
-  Message("*nlm_common_user_cmd %#x\n",(uint32_t )*nlm_common_user_cmd);
-  Message("nlm_common_dev_status %#x\n",(uint32_t)nlm_common_dev_status);
-  Message("nlm_common_host_status %#x\n",(uint32_t)nlm_common_host_status);
-
-  nlm_common_pci_writel(0,(uint32_t *)nlm_common_user_result_producer);
-  nlm_common_pci_writel(0,(uint32_t *)nlm_common_user_result_consumer);
-  nlm_common_pci_writel(0,(uint32_t *)nlm_common_user_cmd_producer);
-  nlm_common_pci_writel(0,(uint32_t *)nlm_common_user_cmd_consumer);
-  nlm_common_pci_writel(0,(uint32_t *)nlm_common_host_status);
-  printk("xlr_console_over_pci: registerd successfully.\n");
-  return 0;
-}
-
-static void __exit nlm_pcix_console_cleanup(void)
-{
-  uart_remove_one_port(&nlm_pcix_console_reg, &nlm_pcix_console_port);
-  uart_unregister_driver(&nlm_pcix_console_reg);
-}
-
-module_init(nlm_pcix_console_init);
-module_exit(nlm_pcix_console_cleanup);
diff --git a/drivers/char/xlr_virtual_uart.c b/drivers/char/xlr_virtual_uart.c
deleted file mode 100644
index ed71730..0000000
--- a/drivers/char/xlr_virtual_uart.c
+++ /dev/null
@@ -1,384 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/console.h>
-#include <linux/pci.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/tty.h>
-#include <linux/tty_flip.h>
-#include <linux/serial.h>
-#include <linux/serial_core.h>
-#include <linux/module.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/rtnetlink.h>
-#include <linux/delay.h>
-#include <linux/ethtool.h>
-#include <linux/mii.h>
-#include <linux/completion.h>
-#include <linux/crc32.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/atomic.h>
-#include <linux/timer.h>
-#include <asm/netlogic/nlm_pcix_gen_dev.h>
-#include <asm/netlogic/devices.h>
-#include <asm/netlogic/xlr_virt_uart.h>
-
-#define RX_THRESHOLD 10
-#define DRIVER_VERSION "v0.1"
-#define DRIVER_AUTHOR "Netlogic"
-#define DRIVER_DESC "Virtual uart serial console driver for Arizona3"
-
-#define Message(a,b...) //printk("Function [%s]"a"\n",__FUNCTION__,##b)
-#define ErrorMsg(a,b...) printk("Function [%s]"a"\n",__FUNCTION__,##b)
-
-virt_uart_struct virt_uart_tx_rx[32];
-
-static struct timer_list *timer[32];
-
-extern int xlr_loader_support;
-
-static struct uart_driver virtual_uart_console_reg = {
-  	.owner  = THIS_MODULE,
-	.driver_name  = VIRTUAL_UART_CONSOLE,
-  	.dev_name  = "virt_uart",
-  	.major  = VIRTUAL_UART_CONSOLE_MAJOR,
-  	.minor  = VIRTUAL_UART_CONSOLE_MINOR,
-  	.nr  = VIRTUAL_UART_NR,
-};
-
-static int virtual_uart_console_request_port(struct uart_port *port) 
-{
- 	return 0;
-}
-
-static void virtual_uart_console_config_port(struct uart_port *port, int flags)
-{
-}
-
-static int virtual_uart_console_verify_port(struct uart_port *port, struct serial_struct *ser)
-{
-  	return 0;
-}
-
-static void virtual_uart_console_release_port(struct uart_port *port)
-{
-
-}
-
-static const char *virtual_uart_console_type(struct uart_port *port)
-{
-  	return "nlm_virtual_uart_consoletty";
-}
-
-static void virtual_uart_console_set_termios(struct uart_port *port, 
-			struct ktermios *termios, struct ktermios *old)
-{
-        return;
-}
-
-static unsigned int virtual_uart_console_tx_empty(struct uart_port *port)
-{
-        return 1;
-}
-
-static unsigned int virtual_uart_console_get_mctrl(struct uart_port *port)
-{
-        return port->mctrl;
-}
-
-static void virtual_uart_console_set_mctrl(struct uart_port *port, unsigned int mctrl)
-{
-  	port->mctrl = mctrl;
-}
-
-static void virtual_uart_console_break_ctl(struct uart_port *port, int break_state)
-{
-}
-
-static void virtual_uart_console_start_tx(struct uart_port *port)
-{
-        Message("");
-}
-
-static void virtual_uart_console_stop_tx(struct uart_port *port)
-{
-        Message("");
-}
-
-static void virtual_uart_console_stop_rx(struct uart_port *port)
-{
-        Message("");
-}
-
-static void virtual_uart_console_enable_ms(struct uart_port *port)
-{
-        Message("");
-}
-
-static int virtual_uart_console_startup(struct uart_port *port);
-static void virtual_uart_console_shutdown(struct uart_port *port);
-
-static struct uart_ops virtual_uart_console_ops = {
-  	.tx_empty     = virtual_uart_console_tx_empty,
-  	.set_mctrl    = virtual_uart_console_set_mctrl,
-  	.get_mctrl    = virtual_uart_console_get_mctrl,
-  	.stop_tx      = virtual_uart_console_stop_tx,
-  	.start_tx     = virtual_uart_console_start_tx,
-  	.stop_rx      = virtual_uart_console_stop_rx,
-  	.enable_ms    = virtual_uart_console_enable_ms,
-  	.break_ctl    = virtual_uart_console_break_ctl,
-  	.startup      = virtual_uart_console_startup,
-  	.shutdown     = virtual_uart_console_shutdown,
-  	.set_termios  = virtual_uart_console_set_termios,
-  	.type         = virtual_uart_console_type,
-  	.release_port = virtual_uart_console_release_port,
-  	.request_port = virtual_uart_console_request_port,
-  	.config_port  = virtual_uart_console_config_port,
-  	.verify_port  = virtual_uart_console_verify_port,
-};
-
-
-static struct uart_port virtual_uart_console_port [VIRTUAL_UART_NR] = {
-  	[0 ... VIRTUAL_UART_NR-1] = {
-  	.ops          = &virtual_uart_console_ops,
-  	.type         = PORT_8250,
-  	.fifosize     = 255,
-  	}
-};
-
-static void virtual_uart_console_rx_chars(struct uart_port *port)
-{
-  	struct tty_struct *tty;
-  	char ch;
-	int rx_cnt = 0;
-	if (*(virt_uart_tx_rx[port->line].rx_pro) == *(virt_uart_tx_rx[port->line].rx_con))
-		return;
-     
-  	tty = port->state->port.tty;
-  	if (!tty){
-          	ErrorMsg("tty is nt thr...");
-          	return;
-  	}
-
-  	tty->low_latency = 1;
-  	do{     
-	
-		ch = *((virt_uart_tx_rx[port->line].rx_fifo) + (*(virt_uart_tx_rx[port->line].rx_con)));
-		tty_insert_flip_char(tty, ch, TTY_NORMAL); 
-    		tty_flip_buffer_push(tty);
-		*(virt_uart_tx_rx[port->line].rx_con) = (*(virt_uart_tx_rx[port->line].rx_con) + 1) % (USER_RESULT_SIZE);
-
-		if(rx_cnt++ > RX_THRESHOLD)
-			break;
-  	}while(*(virt_uart_tx_rx[port->line].rx_pro) != *(virt_uart_tx_rx[port->line].rx_con));
-
-}
-
-static int nlm_cmd_put_char(char ch, int thrd_id)
-{
-
-  	Message("-- Called");
-	Message("\nXmitting [%d]\n",ch);
-	
-	if(((*(virt_uart_tx_rx[thrd_id].tx_pro) + 1) % USER_CMD_SIZE ) == (*(virt_uart_tx_rx[thrd_id].tx_con)))	
-		return -1;
-
-   	*((virt_uart_tx_rx[thrd_id].tx_fifo) + *(virt_uart_tx_rx[thrd_id].tx_pro)) = ch;
-
-	*(virt_uart_tx_rx[thrd_id].tx_pro) = (*(virt_uart_tx_rx[thrd_id].tx_pro) + 1) % (USER_CMD_SIZE);
-	return 0;
-}
-
-
-/* Take the data(command) from the user and write it in to the Tx buf buffer.*/
-static void virtual_uart_console_tx_chars(struct uart_port *port)
-{
-        struct circ_buf *xmit = &port->state->xmit; 
-        int count;
-
-        if (port->x_char) {
-
-               	if(nlm_cmd_put_char(port->x_char, port->line))
-			return;
-                port->icount.tx++;
-                port->x_char = 0;
-                return;
-        }
-        if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
-                virtual_uart_console_stop_tx(port);
-                return;
-        }
-
-        count = port->fifosize >> 1;
-        do{
-		if(nlm_cmd_put_char(xmit->buf[xmit->tail], port->line))
-			break;
-                xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-                port->icount.tx++;
-
-                if (uart_circ_empty(xmit))
-                        break;
-
-        }while(--count > 0);
-
-
-        if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS){
-                uart_write_wakeup(port);
-        }
-}
-
-
-static void virtual_uart_console_timer (unsigned long data)
-{
-        struct uart_port *port;
-
-        port = (struct uart_port *)data;
-        if (!port){
-                ErrorMsg("port is nt there...");
-                return;
-        }
-        if (!port->state){
-                ErrorMsg("port->info is nt there... ");
-                return;
-        }
-
-        /* see if we have any data for rx*/
-        virtual_uart_console_rx_chars(port);
-        /* see if we have any data to transmit */
-        virtual_uart_console_tx_chars(port);
-        /* resubmit the timer again */
-        timer[port->line]->expires = jiffies + DELAY_TIME;
-        add_timer (timer[port->line]);
-}
-
-static int virtual_uart_console_startup(struct uart_port *port)
-{
-  	/* this is the first time this port is opened */
-  	/* do any hardware initialization needed here */
-
-  	/* create our timer and submit it */
-
-  	Message("Open Called..");
-  	if (!timer[port->line]) {
-          	timer[port->line] = kmalloc (sizeof(*timer[port->line]), GFP_KERNEL);
-          	if (!timer[port->line])
-                  	return -ENOMEM;
-  	}
-  	init_timer(timer[port->line]);
-  	timer[port->line]->data = (unsigned long )port;
-  	timer[port->line]->expires = jiffies + DELAY_TIME;
-  	timer[port->line]->function = virtual_uart_console_timer;
-  	Message("Opening Port");
-	*(virt_uart_tx_rx[port->line].tx_pro) = 0;
-	*(virt_uart_tx_rx[port->line].tx_con) = 0;
-	*(virt_uart_tx_rx[port->line].rx_pro) = 0;
-	*(virt_uart_tx_rx[port->line].rx_con) = 0;
-  	add_timer(timer[port->line]);
-	*(virt_uart_tx_rx[port->line].status) = VIRT_UART_OPENED;
-  	return 0;
-}
-
-
-static int __init virtual_uart_init(void)
-{
-	int result, i, size;
-  	unsigned int line;
-
-  	result = uart_register_driver(&virtual_uart_console_reg);
-
-  	if (result){
-    		ErrorMsg("Cant Register Driver");
-    		return result;
-  	}
-  
-  	for (line=0; line < VIRTUAL_UART_NR; line++){
-        	virtual_uart_console_port[line].line = line;
-        	result = uart_add_one_port(&virtual_uart_console_reg, &virtual_uart_console_port[line]);
-
-        	if (result){
-                	for(; line > 0; line--) {
-                        	virtual_uart_console_port[line].line = line;
-                        	uart_remove_one_port(&virtual_uart_console_reg, &virtual_uart_console_port[line]);
-                	}
-			virtual_uart_console_port[line].line = line;
-			uart_remove_one_port(&virtual_uart_console_reg, &virtual_uart_console_port[line]);
-                	uart_unregister_driver(&virtual_uart_console_reg);
-                	return result;
-        	}
-  	}
-
-  
-  	size = USER_CMD_SIZE + 4 + 4 + USER_RESULT_SIZE + 4 + 4 + 4;
-
-  	for (i=0; i<VIRTUAL_UART_NR; i++){
-        	virt_uart_tx_rx[i].tx_fifo = i*size + (unsigned char *) VIRT_UART_BUF_START;
-        	virt_uart_tx_rx[i].tx_pro = (unsigned int *) (virt_uart_tx_rx[i].tx_fifo + USER_CMD_SIZE); 
-        	virt_uart_tx_rx[i].tx_con = (unsigned int *) (virt_uart_tx_rx[i].tx_pro + 1);
-        	virt_uart_tx_rx[i].rx_fifo = (unsigned char *) (virt_uart_tx_rx[i].tx_con + 1);
-        	virt_uart_tx_rx[i].rx_pro = (unsigned int *) (virt_uart_tx_rx[i].rx_fifo + USER_RESULT_SIZE); 
-        	virt_uart_tx_rx[i].rx_con = (unsigned int *) (virt_uart_tx_rx[i].rx_pro + 1);
-		virt_uart_tx_rx[i].status = (unsigned int *) (virt_uart_tx_rx[i].rx_con + 1);
-		*(virt_uart_tx_rx[i].tx_pro) = *(virt_uart_tx_rx[i].tx_con) = 
-		*(virt_uart_tx_rx[i].rx_pro) = *(virt_uart_tx_rx[i].rx_con) = 0;
-		*(virt_uart_tx_rx[i].status) = 0;
-  	}
-
-  	return 0;
-}
-
-static void virtual_uart_console_shutdown(struct uart_port *port)
-{
-  	/* The port is being closed by the last user. */
-  	/* Do any hardware specific stuff here */
-
-  	/* shut down our timer */
-  	Message("Close Called");
-	*(virt_uart_tx_rx[port->line].status) = 0;
-  	del_timer_sync(timer[port->line]);
-}
-
-
-static void __exit virtual_uart_console_cleanup(void)
-{
-  	int line;
-
-  	for (line=0; line < VIRTUAL_UART_NR; line++)  {
-		virtual_uart_console_port[line].line = line;
-        	uart_remove_one_port(&virtual_uart_console_reg, &virtual_uart_console_port[line]);
-  	}
-  	uart_unregister_driver(&virtual_uart_console_reg);
-}
-
-module_init(virtual_uart_init);
-module_exit(virtual_uart_console_cleanup);
-
-
-
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index 25d52ec..7a356fe 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -355,15 +355,4 @@ config CRYPTO_DEV_ATMEL_TEST
 	  To compile this driver as a module, choose M here: the module
 	  will be called atmel-test.
 
-config CRYPTO_XLR
-	tristate "Support for the XLR Security engine"
-	depends on CRYPTO && NLM_COMMON 
-	default Y
-	help
-	  Say 'Y' here to use the XLR hardware Security engine for the 
-	  Crypto operations.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called xlr_sec.
-
 endif # CRYPTO_HW
diff --git a/drivers/crypto/netlogic/Makefile b/drivers/crypto/netlogic/Makefile
deleted file mode 100644
index 6ee3939..0000000
--- a/drivers/crypto/netlogic/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-obj-$(CONFIG_CRYPTO_XLR) += xlr_sec.o
-xlr_sec-objs := common/sec_api.o nlmsec.o nlm_auth.o nlm_enc.o
diff --git a/drivers/crypto/netlogic/ecc_ucode_data.h b/drivers/crypto/netlogic/ecc_ucode_data.h
deleted file mode 100644
index f8f86a2..0000000
--- a/drivers/crypto/netlogic/ecc_ucode_data.h
+++ /dev/null
@@ -1,364 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-#ifndef ECC_UCODE_DATA_H
-#define ECC_UCODE_DATA_H
-static const uint64_t ecc_msg0 = 0xc07c000000000010ULL;
-static const uint64_t ecc_msg1 = 0xa000000000000000ULL;
-
-static uint64_t ecc_uc_data [] __attribute__((aligned(32))) = {
-    0x0000000022000006ULL,
-    0x0000000022000009ULL,
-    0x0000000022000288ULL,
-    0x220000232200028fULL,
-    0x2200028f24000000ULL,
-    0x2400000022000062ULL,
-    0x0000000022000240ULL,
-    0x000000002200022fULL,
-    0x0000000022000213ULL,
-    0x0000000022000225ULL,
-    0x0000000022000239ULL,
-    0x0000000022000248ULL,
-    0x000000002200025eULL,
-    0x000000002200001eULL,
-    0x000000002200027eULL,
-    0x4518400008c00001ULL,
-    0x4308868044184400ULL,
-    0x220000ae2000010dULL,
-    0x4500c3c0220000bcULL,
-    0x10c0000050d07e00ULL,
-    0x08a0010043004780ULL,
-    0x21a0003415ba8000ULL,
-    0x15ba800008a00200ULL,
-    0x68d0fa0021a00034ULL,
-    0x4400478031600032ULL,
-    0x3100003650b0f200ULL,
-    0x2000003b50b0fa00ULL,
-    0x50d07e004500c3c0ULL,
-    0x14ba800010c00000ULL,
-    0x3300006120000040ULL,
-    0x2200015028a00040ULL,
-    0x2000005f22000084ULL,
-    0x68b0fa0028a00048ULL,
-    0x08c0000131600045ULL,
-    0x220001ad2000004eULL,
-    0x2000005f2200008bULL,
-    0x08c0000110a00000ULL,
-    0x68f0fa0008e00000ULL,
-    0x08c000003360004eULL,
-    0x220001ad10a00000ULL,
-    0x11a000002200007dULL,
-    0x6890fa0008800001ULL,
-    0x23c000593160005bULL,
-    0x08c000012200008bULL,
-    0x220001502000005bULL,
-    0x220001ad22000084ULL,
-    0x108000002200007dULL,
-    0x2200009228a00053ULL,
-    0x24000000220000a0ULL,
-    0x220000ae4008dc00ULL,
-    0x2200020040185000ULL,
-    0x4018120040180380ULL,
-    0x2200020040184000ULL,
-    0x220001f940181200ULL,
-    0x4018320040180340ULL,
-    0x220001f94010d800ULL,
-    0x220001f940181200ULL,
-    0x40183a00401802c0ULL,
-    0x220001f94010d800ULL,
-    0x22000248d0005c00ULL,
-    0x22000248d0006c00ULL,
-    0x50988000d8007400ULL,
-    0x40182a0024000000ULL,
-    0x40186800401840c0ULL,
-    0x4018a800401802c0ULL,
-    0x24000000401804c0ULL,
-    0x4018408040182200ULL,
-    0x4018028040186000ULL,
-    0x401804804018a000ULL,
-    0x40182a0024000000ULL,
-    0x4018680040184080ULL,
-    0x4018a80040180280ULL,
-    0x2400000040180480ULL,
-    0x4418400040181200ULL,
-    0x40180200220001f9ULL,
-    0x4018500040184080ULL,
-    0x220001f944180200ULL,
-    0x4018900040180280ULL,
-    0x220001f944180200ULL,
-    0x2400000040180480ULL,
-    0x4018900040181400ULL,
-    0x40188080220000a9ULL,
-    0x4018900040185400ULL,
-    0x40188280220000a9ULL,
-    0x08c0000024000000ULL,
-    0x430887004010c200ULL,
-    0x24000000220000caULL,
-    0x4010d80040181200ULL,
-    0x40180200220001f9ULL,
-    0x4018500040184080ULL,
-    0x220001f94010da00ULL,
-    0x4018900040180280ULL,
-    0x220001f94010da00ULL,
-    0x2400000040180480ULL,
-    0x4010d80040181a00ULL,
-    0x40180200220001f9ULL,
-    0x40185800401840c0ULL,
-    0x220001f94010da00ULL,
-    0x40189800401802c0ULL,
-    0x220001f94010da00ULL,
-    0x24000000401804c0ULL,
-    0x4010c20008800000ULL,
-    0x200000d023c000ceULL,
-    0x200000d708c00000ULL,
-    0x50a18a00d8004440ULL,
-    0x688804003300010cULL,
-    0x41180440336000dfULL,
-    0x6888860040188800ULL,
-    0x41008240336000dcULL,
-    0x200000d040014c00ULL,
-    0x41180c00d010c040ULL,
-    0x68804400200000d0ULL,
-    0x41184440336000ecULL,
-    0x6888e40040188a00ULL,
-    0x4100e440336000e8ULL,
-    0x200000d040018f00ULL,
-    0xd011c0404000e440ULL,
-    0x200000d041110f00ULL,
-    0x334000fcd8004440ULL,
-    0xd810e04041088800ULL,
-    0x314000f440090c00ULL,
-    0x40180c00d010c040ULL,
-    0x336000f968888700ULL,
-    0x40180c0041188040ULL,
-    0xd010c040200000d0ULL,
-    0x200000d041180c00ULL,
-    0x41008a00d8080440ULL,
-    0x40090f00d81c8040ULL,
-    0xd001c44031400103ULL,
-    0x6888e40040018f00ULL,
-    0x4100e44033600108ULL,
-    0x200000d040018f00ULL,
-    0xd011c0404000e440ULL,
-    0x200000d041100f00ULL,
-    0x0880000024000000ULL,
-    0x23c001114010c200ULL,
-    0x08c0000020000113ULL,
-    0xd80044402000011aULL,
-    0x3300014f50a18a00ULL,
-    0x3360012268880400ULL,
-    0x4018880041180440ULL,
-    0x3360011f68888600ULL,
-    0x40014c0041008240ULL,
-    0xd010c04020000113ULL,
-    0x2000011341180c00ULL,
-    0x3360012f68804400ULL,
-    0x40188a0041184440ULL,
-    0x3360012b6888d400ULL,
-    0x40018e804100d440ULL,
-    0x4000d44020000113ULL,
-    0x41110e80d011c040ULL,
-    0xd800444020000113ULL,
-    0x410888003340013fULL,
-    0x40090c00d810d040ULL,
-    0xd010c04031400137ULL,
-    0x6888868040180c00ULL,
-    0x411880403360013cULL,
-    0x2000011340180c00ULL,
-    0x41180c00d010c040ULL,
-    0xd808044020000113ULL,
-    0xd81a804041008a00ULL,
-    0x3140014640090e80ULL,
-    0x40018e80d001c440ULL,
-    0x3360014b6888d400ULL,
-    0x40018e804100d440ULL,
-    0x4000d44020000113ULL,
-    0x41100e80d011c040ULL,
-    0x2400000020000113ULL,
-    0x4018980040101200ULL,
-    0x40080700220001f9ULL,
-    0x4008900040101a00ULL,
-    0x40100300220001f9ULL,
-    0x22000207d80ce400ULL,
-    0xd00ce40040180500ULL,
-    0x4008054022000248ULL,
-    0x220002004018a000ULL,
-    0x4000a20040100740ULL,
-    0x40080780220001f9ULL,
-    0x4000aa004010e800ULL,
-    0x40100340220001f9ULL,
-    0x40189a0040185000ULL,
-    0x40180580220001f9ULL,
-    0x4018920040185800ULL,
-    0x40100700220001f9ULL,
-    0x40187400d81cb380ULL,
-    0x4010038022000207ULL,
-    0x40180400d01cb000ULL,
-    0x401003c022000248ULL,
-    0x2200020040107000ULL,
-    0x401845c040100200ULL,
-    0x40189a0040189000ULL,
-    0x40100700220001f9ULL,
-    0x220001f94018ba00ULL,
-    0xd8006c0040080740ULL,
-    0x4018a20022000207ULL,
-    0x40180200220001f9ULL,
-    0x4210680040184100ULL,
-    0x2200024840180400ULL,
-    0x22000248d00d0400ULL,
-    0x4208ec0040180500ULL,
-    0x4018020022000248ULL,
-    0x40180400d8144000ULL,
-    0x4018020022000207ULL,
-    0x220001f940187000ULL,
-    0x4018780040180500ULL,
-    0x220001f94000f200ULL,
-    0x4000ec00d8140740ULL,
-    0x4010074022000207ULL,
-    0x68f0e80008e00000ULL,
-    0x200001a7336001a4ULL,
-    0xd008e8004010c200ULL,
-    0x4110eb0040100740ULL,
-    0x4010f2004008e000ULL,
-    0x40080500220001f9ULL,
-    0x40009a0024000000ULL,
-    0x220001f940185800ULL,
-    0x2200024842080400ULL,
-    0x40101a0040080540ULL,
-    0x2200020040104000ULL,
-    0x4210020040100780ULL,
-    0x2200024840004400ULL,
-    0x22000248d000f400ULL,
-    0x4018980040180580ULL,
-    0x401804c022000200ULL,
-    0x4010d80040183200ULL,
-    0x40189a00220001f9ULL,
-    0xd0160200220001f9ULL,
-    0x2200024840004400ULL,
-    0x40101a0040180580ULL,
-    0x220001f940105800ULL,
-    0x4018b000401805c0ULL,
-    0x4010038022000200ULL,
-    0x4018ba004018a800ULL,
-    0x401003c0220001f9ULL,
-    0x220002004018a800ULL,
-    0x42187c0040080700ULL,
-    0x4010074022000248ULL,
-    0x2200024842180400ULL,
-    0x40187000401803c0ULL,
-    0x22000207d8007c00ULL,
-    0x220001f94018aa00ULL,
-    0x4018814040180400ULL,
-    0x22000248d00fec00ULL,
-    0x22000207d8007400ULL,
-    0x220001f94018b200ULL,
-    0x40185800401803c0ULL,
-    0x4010e20022000200ULL,
-    0x42180400220001f9ULL,
-    0xd80f040022000248ULL,
-    0x4018034022000207ULL,
-    0x4000e2004018a800ULL,
-    0x40180540220001f9ULL,
-    0xc800440024000000ULL,
-    0xc808c000c910ca00ULL,
-    0x40184c00d1008200ULL,
-    0x2400000022000248ULL,
-    0xc910ca00ca004400ULL,
-    0xd1008200c808c000ULL,
-    0x2200024840184c00ULL,
-    0x3340020924000000ULL,
-    0xd010c0002000020bULL,
-    0x400880002000020cULL,
-    0x3340020f24000000ULL,
-    0xd010c00020000211ULL,
-    0x4008800020000212ULL,
-    0x3340021c24000000ULL,
-    0x08c0000133200220ULL,
-    0xd000440022000257ULL,
-    0xd800c40022000248ULL,
-    0x2000022431400218ULL,
-    0x4310024043104040ULL,
-    0x20000217d0014c00ULL,
-    0x4310024043104040ULL,
-    0x20000217d8014c00ULL,
-    0x2200025724000000ULL,
-    0x3340022b22000251ULL,
-    0x40188000d8188040ULL,
-    0xd81880002000022eULL,
-    0x2000022e40188040ULL,
-    0x4010468024000000ULL,
-    0x4008040022000240ULL,
-    0x400086804010d000ULL,
-    0x4010d20022000240ULL,
-    0x22000244220001f9ULL,
-    0x4018820024000000ULL,
-    0x4018440022000257ULL,
-    0x08c0000043104680ULL,
-    0x240000002200010dULL,
-    0x4010d80040180200ULL,
-    0x24000000220001f9ULL,
-    0x08c000014410c200ULL,
-    0x24000000220001f9ULL,
-    0x2000024c3320024aULL,
-    0x40080c00d810c040ULL,
-    0xd800c40040088000ULL,
-    0x4008800033400250ULL,
-    0xd800440024000000ULL,
-    0x2000025633400254ULL,
-    0xd8004440d8080400ULL,
-    0x4010068024000000ULL,
-    0x2200024840184400ULL,
-    0x4008d40040100200ULL,
-    0x2400000022000248ULL,
-    0x43180a00f8000000ULL,
-    0x4318404043080e40ULL,
-    0x4110c24044184000ULL,
-    0x6a8044005180c400ULL,
-    0xd100440008c00000ULL,
-    0x3340026ed91a88c0ULL,
-    0x401880003300027aULL,
-    0x6a80cc0040188840ULL,
-    0x6b004c0008c00001ULL,
-    0x08c0000033600272ULL,
-    0x41004c4041004400ULL,
-    0x40008a4040008200ULL,
-    0x6d20440021c00278ULL,
-    0x2000026711800000ULL,
-    0x3100026e51c08600ULL,
-    0x240000006a80cc00ULL,
-    0x6b10020008c00003ULL,
-    0xd000c20031600283ULL,
-    0x4118020040184000ULL,
-    0x28c0027f40184000ULL,
-    0x24000000400806c0ULL,
-    0x401032002200028fULL,
-    0x40103a0040104000ULL,
-    0x2200022f40104040ULL,
-    0x2200027e24000000ULL,
-    0x400086802200001eULL,
-    0x440044802200025eULL,
-    0x24000000440044c0ULL,
-    0x0000000000000000ULL,
-};
-#endif /* ECC_UCODE_DATA_H */
diff --git a/drivers/crypto/netlogic/nlm_auth.c b/drivers/crypto/netlogic/nlm_auth.c
deleted file mode 100644
index 1dcb53b..0000000
--- a/drivers/crypto/netlogic/nlm_auth.c
+++ /dev/null
@@ -1,459 +0,0 @@
-/*
- * Cryptographic API.
- *
- * Support for XLR hardware crypto engine.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-#include <crypto/algapi.h>
-#include <crypto/sha.h>
-#include <linux/err.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/cryptohash.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/scatterlist.h>
-#include "nlm_state_info.h"
-#include "nlmsae.h"
-#include "nlmsec_internal.h" 
-
-#define XLR_AUTH_PRIORITY      300
-#define XLR_HMAC_PRIORITY      320
-
-#define MD5_DIGEST_SIZE		16
-#define MD5_BLOCK_SIZE		64
-
-#define AUTH_BUFFER_SIZE	(16 * 1024)
-
-//#define SEC_DEBUG
-
-#ifdef SEC_DEBUG
-#ifdef __KERNEL__
-#define debug_print(fmt, args...) printk(fmt, ##args)
-#else  /* __KERNEL__ */
-#define debug_print(fmt, args...) printf(fmt, ##args)
-#endif /* __KERNEL__ */
-#else /* SEC_DEBUG */
-#define debug_print(fmt, args...)
-#endif /* SEC_DEBUG */
-
-static inline struct xlr_crypt_state* ctx(struct crypto_tfm *tfm)
-{
-	return crypto_tfm_ctx(tfm);
-}
-
-static void xlr_auth_init(struct crypto_tfm *tfm)
-{
-	struct xlr_crypt_state *op = ctx(tfm);
-	op->auth_src = kmalloc(AUTH_BUFFER_SIZE, GFP_KERNEL);
-        debug_print("in func %s\n",__FUNCTION__);
-	op->len = 0;
-}
-
-static void xlr_auth_update(struct crypto_tfm *tfm,
-			const uint8_t *data, unsigned int length)
-{
-	struct xlr_crypt_state *op = ctx(tfm);
-
-	if (!op->auth_src)
-		return;
-	if (op->len + length > AUTH_BUFFER_SIZE)
-		return;
-
-	memcpy(op->auth_src + op->len, data, length);
-	op->len += length;
-        debug_print(KERN_INFO "in func %s\n",__FUNCTION__);
-//	dump_stack();
-
-}
-
-static void xlr_auth_final(struct crypto_tfm *tfm, uint8_t *out)
-{
-	struct xlr_crypt_state *op = ctx(tfm);
-	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
-	int ret;
-
-	ret = nlmsec_op_init(&handle);
-        debug_print("in func %s\n",__FUNCTION__);
-
-	if (ret) {
-		printk("Cannot malloc. returning from %s\n", __FUNCTION__);
-		return; 
-	}
-
-	debug_print(KERN_INFO "hash = %d, hmac keylen = %d\n",op->hash, op->hmac_keylen);
-
-	ret = nlmsec_cipher_and_hash(handle, CIPHER_BYPASS, NLM_ECB, NULL, NULL,
-				     0, 0, op->hash, 
-				     (op->hmac_keylen?op->hmac_key:NULL), 0, 0,
-				     op->auth_src, op->len, NULL, out);
-
-	if(IS_SUCCESS_SAEOP(ret)) {
-		xlr_inc_auth_stat(op->hash, op->len);
-	}
-        debug_print(KERN_INFO "ret val after hashing is %d\n",ret);
-	op->len = 0;
-	nlmsec_op_cleanup(&handle);
-	kfree(op->auth_src);
-}
-
-static void xlr_sha1_final(struct crypto_tfm *tfm, uint8_t *out)
-{
-	struct xlr_crypt_state *op = ctx(tfm);
-
-	op->hash = NLM_SHA1;
-	xlr_auth_final(tfm, out);
-}
-
-static void xlr_sha256_final(struct crypto_tfm *tfm, uint8_t *out)
-{
-	struct xlr_crypt_state *op = ctx(tfm);
-
-	op->hash = NLM_SHA256;
-	xlr_auth_final(tfm, out);
-}
-
-static void xlr_sha384_final(struct crypto_tfm *tfm, uint8_t *out)
-{
-	struct xlr_crypt_state *op = ctx(tfm);
-
-	op->hash = NLM_SHA384;
-	xlr_auth_final(tfm, out);
-}
-
-static void xlr_sha512_final(struct crypto_tfm *tfm, uint8_t *out)
-{
-	struct xlr_crypt_state *op = ctx(tfm);
-
-	op->hash = NLM_SHA512;
-	xlr_auth_final(tfm, out);
-}
-
-static void xlr_md5_final(struct crypto_tfm *tfm, uint8_t *out)
-{
-	struct xlr_crypt_state *op = ctx(tfm);
-
-	op->hash = NLM_MD5;
-	xlr_auth_final(tfm, out);
-}
-
-static int xlr_auth_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
-{
-	struct xlr_crypt_state *op = ctx(tfm);
-	op->hmac = 1;
-	op->hmac_keylen = keylen;
-	memcpy(op->hmac_key, key, keylen);
-        debug_print(KERN_INFO "[%s] keylen is %d\n",__FUNCTION__ ,keylen);
-	return 0;
-}
-
-static struct crypto_alg sha512_alg = {
-	.cra_name		=	"sha512",
-	.cra_driver_name	=	"sha512-xlr",
-	.cra_priority		=	XLR_AUTH_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST|
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	SHA512_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(sha512_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	SHA512_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_sha512_final,
-		}
-	}
-};
-
-
-static struct crypto_alg sha384_alg = {
-	.cra_name		=	"sha384",
-	.cra_driver_name	=	"sha384-xlr",
-	.cra_priority		=	XLR_AUTH_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST|
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	SHA384_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(sha384_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	SHA384_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_sha384_final,
-		}
-	}
-};
-
-static struct crypto_alg sha256_alg = {
-	.cra_name		=	"sha256",
-	.cra_driver_name	=	"sha256-xlr",
-	.cra_priority		=	XLR_AUTH_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST |
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	SHA256_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(sha256_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	SHA256_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_sha256_final,
-		}
-	}
-};
-
-static struct crypto_alg sha1_alg = {
-	.cra_name		=	"sha1",
-	.cra_driver_name	=	"sha1-xlr",
-	.cra_priority		=	XLR_AUTH_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST|
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	SHA1_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(sha1_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	SHA1_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_sha1_final,
-		}
-	}
-};
-
-static struct crypto_alg md5_alg = {
-	.cra_name		=	"md5",
-	.cra_driver_name	=	"md5-xlr",
-	.cra_priority		=	XLR_AUTH_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST |
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	MD5_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(md5_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	MD5_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_md5_final,
-		}
-	}
-};
-
-static struct crypto_alg sha512_hmac_alg = {
-	.cra_name		=	"hmac(sha512)",
-	.cra_driver_name	=	"hmac-sha512-xlr",
-	.cra_priority		=	XLR_HMAC_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST|
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	SHA512_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(sha512_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	SHA512_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_sha512_final,
-			.dia_setkey     =	xlr_auth_setkey,
-		}
-	}
-};
-
-
-static struct crypto_alg sha384_hmac_alg = {
-	.cra_name		=	"hmac(sha384)",
-	.cra_driver_name	=	"hmac-sha384-xlr",
-	.cra_priority		=	XLR_HMAC_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST|
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	SHA384_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(sha384_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	SHA384_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_sha384_final,
-			.dia_setkey     =	xlr_auth_setkey,
-		}
-	}
-};
-
-
-static struct crypto_alg sha256_hmac_alg = {
-	.cra_name		=	"hmac(sha256)",
-	.cra_driver_name	=	"hmac-sha256-xlr",
-	.cra_priority		=	XLR_HMAC_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST |
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	SHA256_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(sha256_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	SHA256_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_sha256_final,
-			.dia_setkey     =	xlr_auth_setkey,
-		}
-	}
-};
-
-static struct crypto_alg sha1_hmac_alg = {
-	.cra_name		=	"hmac(sha1)",
-	.cra_driver_name	=	"hmac-sha1-xlr",
-	.cra_priority		=	XLR_HMAC_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST|
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	SHA1_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(sha1_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	SHA1_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_sha1_final,
-			.dia_setkey     =	xlr_auth_setkey,
-		}
-	}
-};
-
-static struct crypto_alg md5_hmac_alg = {
-	.cra_name		=	"hmac(md5)",
-	.cra_driver_name	=	"hmac-md5-xlr",
-	.cra_priority		=	XLR_HMAC_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST |
-					CRYPTO_ALG_HW,
-	.cra_blocksize		=	MD5_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(md5_alg.cra_list),
-	.cra_u			=	{
-		.digest = {
-			.dia_digestsize	=	MD5_DIGEST_SIZE,
-			.dia_init   	= 	xlr_auth_init,
-			.dia_update 	=	xlr_auth_update,
-			.dia_final  	=	xlr_md5_final,
-			.dia_setkey	=	xlr_auth_setkey,
-		}
-	}
-};
-
-static int __init xlr_auth_alg_init(void)
-{
-	int rc = -ENODEV;
-
-	rc = crypto_register_alg(&sha1_alg);
-	if (rc)
-		goto out;
-
-	rc = crypto_register_alg(&sha256_alg);
-	if (rc)
-		goto out_unreg1;
-
-	rc = crypto_register_alg(&sha384_alg);
-	if (rc)
-		goto out_unreg2;
-
-	rc = crypto_register_alg(&sha512_alg);
-	if (rc)
-		goto out_unreg3;
-
-	rc = crypto_register_alg(&md5_alg);
-	if (rc)
-		goto out_unreg4;
-
-	rc = crypto_register_alg(&sha1_hmac_alg);
-	if (rc)
-		goto out_unreg5;
-
-	rc = crypto_register_alg(&sha256_hmac_alg);
-	if (rc)
-		goto out_unreg6;
-
-	rc = crypto_register_alg(&sha384_hmac_alg);
-	if (rc)
-		goto out_unreg7;
-
-	rc = crypto_register_alg(&sha512_hmac_alg);
-	if (rc)
-		goto out_unreg8;
-
-	rc = crypto_register_alg(&md5_hmac_alg);
-	if (rc)
-		goto out_unreg9;
-
-	printk(KERN_NOTICE "Using XLR hardware for SHA/MD5 algorithms.\n");
-
-	return 0;
-
-out_unreg9:
-	crypto_unregister_alg(&sha512_hmac_alg);
-out_unreg8:
-	crypto_unregister_alg(&sha384_hmac_alg);
-out_unreg7:
-	crypto_unregister_alg(&sha256_hmac_alg);
-out_unreg6:
-	crypto_unregister_alg(&sha1_hmac_alg);
-out_unreg5:
-	crypto_unregister_alg(&md5_alg);
-out_unreg4:
-	crypto_unregister_alg(&sha512_alg);
-out_unreg3:
-	crypto_unregister_alg(&sha384_alg);
-out_unreg2:
-	crypto_unregister_alg(&sha256_alg);
-out_unreg1:
-	crypto_unregister_alg(&sha1_alg);
-out:
-	printk(KERN_ERR "XLR SHA/MD5 initialization failed.\n");
-	return rc;
-
-}
-
-static void __exit xlr_auth_alg_fini(void)
-{
-	crypto_unregister_alg(&sha1_alg);
-	crypto_unregister_alg(&sha256_alg);
-	crypto_unregister_alg(&sha384_alg);
-	crypto_unregister_alg(&sha512_alg);
-	crypto_unregister_alg(&md5_alg);
-	crypto_unregister_alg(&md5_hmac_alg);
-	crypto_unregister_alg(&sha1_hmac_alg);
-	crypto_unregister_alg(&sha256_hmac_alg);
-	crypto_unregister_alg(&sha384_hmac_alg);
-	crypto_unregister_alg(&sha512_hmac_alg);
-}
-
-//module_init(xlr_auth_alg_init);
-//module_exit(xlr_auth_alg_fini);
-
-MODULE_DESCRIPTION("XLR SHA/MD5 algorithms support.");
-MODULE_LICENSE("GPL/BSD");
-MODULE_AUTHOR("Sandip Matte");
-
-MODULE_ALIAS("sha-xlr");
-MODULE_ALIAS("md5-xlr");
diff --git a/drivers/crypto/netlogic/nlm_enc.c b/drivers/crypto/netlogic/nlm_enc.c
deleted file mode 100644
index 34890c6..0000000
--- a/drivers/crypto/netlogic/nlm_enc.c
+++ /dev/null
@@ -1,822 +0,0 @@
-
- /* Copyright (C) 2004-2009, RMI Corporation.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/pci.h>
-#include <linux/pci_ids.h>
-#include <linux/crypto.h>
-#include <linux/spinlock.h>
-#include <crypto/algapi.h>
-#include <crypto/aes.h>
-#include <crypto/des.h>
-
-#include <linux/hardirq.h>
-
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <asm/netlogic/msgring.h>
-#include "nlm_state_info.h"
-#include "nlmsae.h"
-#include "nlmsec_internal.h" 
-
-
-#define AES_CTR_IV_SIZE		8
-#define XLR_CRYPT_PRIORITY	300
-
-//#define SEC_DEBUG
-
-#ifdef SEC_DEBUG
-#ifdef __KERNEL__
-#define debug_print(fmt, args...) printk(fmt, ##args)
-#else  /* __KERNEL__ */
-#define debug_print(fmt, args...) printf(fmt, ##args)
-#endif /* __KERNEL__ */
-#else /* SEC_DEBUG */
-#define debug_print(fmt, args...)
-#endif /* SEC_DEBUG */
-
-
-/* CRYPTO-API Functions */
-
-static int xlr_aes_setkey(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int len)
-{
-	struct xlr_crypt_state *op = crypto_tfm_ctx(tfm);
-	u32 *flags = &tfm->crt_flags;
-
-	op->key_len = len;
-
-	debug_print("in %s keylen is %d\n",__FUNCTION__, len);
-
-	switch (len) {
-	case 16: op->cipher = NLM_AES128; break;
-	case 24: op->cipher = NLM_AES192; break;
-	case 32: op->cipher = NLM_AES256; break;
-	default: printk(KERN_WARNING"[%s]: Cannot handle keylen = %d\n",
-			__FUNCTION__,len);
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		 return -EINVAL;
-	}
-
-	op->block_size = AES_BLOCK_SIZE;
-	op->iv_len = AES_BLOCK_SIZE;
-	memcpy(op->key, in_key, len);
-	return 0;
-}
-
-static int xlr_aes_ctr_setkey(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int len)
-{
-	struct xlr_crypt_state *op = crypto_tfm_ctx(tfm);
-	u32 *flags = &tfm->crt_flags;
-
-	debug_print("in %s keylen is %d\n",__FUNCTION__, len);
-	op->key_len = len - 4;
-
-	switch (len) {
-	case 20: op->cipher = NLM_AES128; break;
-	case 28: op->cipher = NLM_AES192; break;
-	case 36: op->cipher = NLM_AES256; break;
-
-	default: printk(KERN_WARNING"[%s]: Cannot handle keylen = %d\n",
-			__FUNCTION__,len);
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		 return -EINVAL;
-	}
-
-	op->block_size = 1; // stream cipher
-	op->iv_len = AES_CTR_IV_SIZE;
-	memcpy(op->key, in_key, len);
-	memcpy(&op->nonce, in_key + len - 4, 4);
-	return 0;
-}
-
-static int xlr_des_setkey(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int len)
-{
-	struct xlr_crypt_state *op = crypto_tfm_ctx(tfm);
-	u32 *flags = &tfm->crt_flags;
-
-	op->key_len = len;
-	op->cipher = NLM_DES;
-
-	if (len == DES_KEY_SIZE) {
-		memcpy(op->key, in_key, len);
-		op->block_size = DES_BLOCK_SIZE;
-	} else {
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		 return -EINVAL;
-	}
-	op->iv_len = DES_BLOCK_SIZE;
-	return 0;
-}
-
-static int xlr_des3_setkey(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int len)
-{
-	struct xlr_crypt_state *op = crypto_tfm_ctx(tfm);
-	u32 *flags = &tfm->crt_flags;
-
-	op->key_len = len;
-	op->cipher = NLM_DES3;
-
-	if (len == DES3_EDE_KEY_SIZE) {
-		memcpy(op->key, in_key, len);
-		op->block_size = DES3_EDE_BLOCK_SIZE;
-	} else {
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		 return -EINVAL;
-	}
-	op->iv_len = DES3_EDE_BLOCK_SIZE;
-	return 0;
-}
-
-int xlr_crypt_op_init(struct xlr_crypt_state *op, op_handle_t *handle, Crypto_Operation_pt *cop_ptr)
-{
-	operation_pt op_ptr;
-	Crypto_Operation_pt cop;
-	int ret;
-
-	ret = nlmsec_op_init(handle);
-
-	if(ret) {
-		printk("Cannot malloc. returning from %s\n", __FUNCTION__);
-		return ret;
-	}
-
-	op_ptr = (operation_pt)(*handle);
-	cop = &op_ptr->cop_instance;
-	*cop_ptr = cop;
-
-	cop->c = op->cipher;
-	cop->h = HASH_BYPASS;
-	cop->hmac = NULL;
-	cop->hmac_len = 0;
-//	cop->cipher_mask = ; //probably nonce...
-	cop->key = op->key; // use the thing setup in setkey...
-	cop->key_len = op->key_len;
-//	cop->hash_bytes_to_skip = 0;
-//	cop->nonce = NULL;
-//	cop->cksum_output = NULL;
-
-	return 0;
-}
-
-static int
-xlr_ecb_decrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
-	Crypto_Operation_pt cop=NULL;
-	struct blkcipher_walk walk;
-	int err, ret;
-
-	if (( ret = xlr_crypt_op_init(op, &handle, &cop)))
-		return ret; 
-
-	cop->m = NLM_ECB;
-	cop->encrypt = CIPHER_DECRYPT;
-
-	blkcipher_walk_init(&walk, dst, src, nbytes);
-	err = blkcipher_walk_virt(desc, &walk);
-
-	while((nbytes = walk.nbytes)) {
-		cop->iv_len = 0;
-		cop->input = walk.src.virt.addr;
-		cop->input_len = nbytes - (nbytes % op->block_size);
-		cop->output = walk.dst.virt.addr;
-
-		ret = nlmsec_cipher_digest_hmac_cksum(handle, cop);
-		if(IS_SUCCESS_SAEOP(ret)) 
-			xlr_inc_enc_stat(cop->c, cop->m, cop->input_len);
-		if (ret == -1)
-			return ret;
-		nbytes -= ret;
-		err = blkcipher_walk_done(desc, &walk, nbytes);
-	}
-
-	nlmsec_op_cleanup(&handle);
-	return err;
-}
-
-static int
-xlr_ecb_encrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
-	Crypto_Operation_pt cop=NULL;
-	struct blkcipher_walk walk;
-	int err, ret;
-
-	if (( ret = xlr_crypt_op_init(op, &handle, &cop)))
-		return ret; 
-
-	cop->m = NLM_ECB;
-	cop->encrypt = CIPHER_ENCRYPT;
-
-	blkcipher_walk_init(&walk, dst, src, nbytes);
-	err = blkcipher_walk_virt(desc, &walk);
-
-	while((nbytes = walk.nbytes)) {
-		cop->iv_len = 0;
-		cop->input = walk.src.virt.addr;
-		cop->input_len = nbytes - (nbytes % op->block_size);
-		cop->output = walk.dst.virt.addr;
-
-		ret = nlmsec_cipher_digest_hmac_cksum(handle, cop);
-		if(IS_SUCCESS_SAEOP(ret)) 
-			xlr_inc_enc_stat(cop->c, cop->m, cop->input_len);
-		if (ret == -1)
-			return ret;
-		nbytes -= ret;
-		ret =  blkcipher_walk_done(desc, &walk, nbytes);
-	}
-	nlmsec_op_cleanup(&handle);
-
-	return err;
-}
-
-static void
-xlr_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
-{
-	struct xlr_crypt_state *op = crypto_tfm_ctx(tfm);
-	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
-	Crypto_Operation_pt cop=NULL;
-	int ret;
-
-	if ((out == NULL) || (in == NULL))
-		return;
-
-        debug_print(KERN_INFO "in func %s\n",__FUNCTION__);
-
-	if (xlr_crypt_op_init(op, &handle, &cop))
-		return; 
-
-	cop->m = NLM_ECB;
-	cop->encrypt = CIPHER_ENCRYPT;
-	cop->input = in;
-	cop->input_len = op->block_size;
-	cop->output = out;
-
-	ret = nlmsec_cipher_digest_hmac_cksum(handle, cop);
-	if(IS_SUCCESS_SAEOP(ret))
-		xlr_inc_enc_stat(cop->c, cop->m, cop->input_len);
-	nlmsec_op_cleanup(&handle);
-	return;
-}
-
-static void
-xlr_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
-{
-	struct xlr_crypt_state *op = crypto_tfm_ctx(tfm);
-	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
-	Crypto_Operation_pt cop=NULL;
-	int ret;
-
-	if ((out == NULL) || (in == NULL))
-		return;
-
-        debug_print(KERN_INFO "in func %s\n",__FUNCTION__);
-
-	if (xlr_crypt_op_init(op, &handle, &cop))
-		return; 
-
-	cop->m = NLM_ECB;
-	cop->encrypt = CIPHER_DECRYPT;
-	cop->input = in;
-	cop->input_len = op->block_size;
-	cop->output = out;
-
-	ret = nlmsec_cipher_digest_hmac_cksum(handle, cop);
-	if(IS_SUCCESS_SAEOP(ret)) 
-		xlr_inc_enc_stat(cop->c, cop->m, cop->input_len);
-	nlmsec_op_cleanup(&handle);
-	return;
-}
-
-static int
-xlr_cbc_decrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
-	Crypto_Operation_pt cop=NULL;
-	struct blkcipher_walk walk;
-	int err, ret;
-
-        debug_print(KERN_INFO "in func %s:%d\n",__FUNCTION__,__LINE__);
-
-	if (( ret = xlr_crypt_op_init(op, &handle, &cop)))
-		return ret; 
-
-	cop->m = NLM_CBC;
-	cop->encrypt = CIPHER_DECRYPT;
-
-	blkcipher_walk_init(&walk, dst, src, nbytes);
-	err = blkcipher_walk_virt(desc, &walk);
-	while((nbytes = walk.nbytes)) {
-
-		cop->iv = op->iv;
-		cop->iv_len = op->iv_len;
-		cop->input = walk.src.virt.addr;
-		cop->input_len = nbytes - (nbytes % op->block_size);
-		cop->output = walk.dst.virt.addr;
-
-		memcpy(op->iv, walk.iv, op->iv_len);
-
-        debug_print(KERN_INFO "in func %s:%d\n",__FUNCTION__,__LINE__);
-		ret = nlmsec_cipher_digest_hmac_cksum(handle, cop);
-		if(IS_SUCCESS_SAEOP(ret)) 
-			xlr_inc_enc_stat(cop->c, cop->m, cop->input_len);
-
-	debug_print(KERN_INFO "input_len = %d, retval = %d \n",cop->input_len, 
-		    ret);
-		if (ret == -1)
-			return ret;
-//		memcpy(walk.iv, op->iv, AES_IV_LENGTH);
-		memcpy(walk.iv, cop->input + cop->input_len - op->iv_len,
-		       op->iv_len);
-//		nbytes -= ret;
-		nbytes -= cop->input_len;
-
-		err = blkcipher_walk_done(desc, &walk, nbytes);
-		if (err)
-			return err;
-	}
-
-	nlmsec_op_cleanup(&handle);
-	return err;
-}
-
-static int
-xlr_cbc_encrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
-	Crypto_Operation_pt cop=NULL;
-	struct blkcipher_walk walk;
-	int err, ret;
-
-	if (( ret = xlr_crypt_op_init(op, &handle, &cop)))
-		return ret; 
-
-	cop->m = NLM_CBC;
-	cop->encrypt = CIPHER_ENCRYPT;
-
-	blkcipher_walk_init(&walk, dst, src, nbytes);
-	err = blkcipher_walk_virt(desc, &walk);
-
-        debug_print(KERN_INFO "in func %s:%d\n",__FUNCTION__,__LINE__);
-	while((nbytes = walk.nbytes)) {
-		cop->iv = op->iv;
-		cop->iv_len = op->iv_len;
-		cop->input = walk.src.virt.addr;
-		cop->input_len = nbytes - (nbytes % op->block_size);
-		cop->output = walk.dst.virt.addr;
-
-		memcpy(op->iv, walk.iv, op->iv_len);
-
-		ret = nlmsec_cipher_digest_hmac_cksum(handle, cop);
-		if(IS_SUCCESS_SAEOP(ret)) 
-			xlr_inc_enc_stat(cop->c, cop->m, cop->input_len);
-
-		if (ret == -1)
-			return ret;
-		
-		memcpy(walk.iv, cop->output + cop->input_len - op->iv_len,
-		       op->iv_len);
-
-		nbytes -= cop->input_len;
-		err = blkcipher_walk_done(desc, &walk, nbytes);
-	}
-	debug_print(KERN_INFO "in func %s:%d\n",__FUNCTION__,__LINE__);
-
-	nlmsec_op_cleanup(&handle);
-	return err;
-}
-
-
-static int
-xlr_ctr_decrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
-	Crypto_Operation_pt cop=NULL;
-	struct blkcipher_walk walk;
-	int err, ret;
-
-        debug_print(KERN_INFO "in func %s:%d\n",__FUNCTION__,__LINE__);
-
-	if (( ret = xlr_crypt_op_init(op, &handle, &cop)))
-		return ret; 
-
-	cop->m = NLM_CTR;
-	cop->encrypt = CIPHER_DECRYPT;
-
-	blkcipher_walk_init(&walk, dst, src, nbytes);
-	err = blkcipher_walk_virt(desc, &walk);
-	while((nbytes = walk.nbytes)) {
-
-		cop->iv = op->iv;
-		cop->iv_len = op->iv_len;
-		cop->nonce = op->nonce;
-		cop->input = walk.src.virt.addr;
-		cop->input_len = nbytes - (nbytes % op->block_size);
-		cop->output = walk.dst.virt.addr;
-
-		memcpy(op->iv, walk.iv, op->iv_len);
-
-		debug_print(KERN_INFO "in func %s:%d\n",__FUNCTION__,__LINE__);
-		ret = nlmsec_cipher_digest_hmac_cksum(handle, cop);
-		if(IS_SUCCESS_SAEOP(ret)) 
-			xlr_inc_enc_stat(cop->c, cop->m, cop->input_len);
-
-		debug_print(KERN_INFO "input_len = %d, retval = %d \n",
-			    cop->input_len, ret);
-		if (ret == -1)
-			return ret;
-		memcpy(walk.iv, cop->input + cop->input_len - op->iv_len,
-		       op->iv_len);
-		nbytes -= cop->input_len;
-
-		err = blkcipher_walk_done(desc, &walk, nbytes);
-		if (err)
-			return err;
-	}
-
-	nlmsec_op_cleanup(&handle);
-	return err;
-}
-
-static int
-xlr_ctr_encrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
-	Crypto_Operation_pt cop=NULL;
-	struct blkcipher_walk walk;
-	int err, ret;
-
-	if (( ret = xlr_crypt_op_init(op, &handle, &cop)))
-		return ret; 
-
-
-	cop->m = NLM_CTR;
-	cop->encrypt = CIPHER_ENCRYPT;
-
-	blkcipher_walk_init(&walk, dst, src, nbytes);
-	err = blkcipher_walk_virt(desc, &walk);
-
-        debug_print(KERN_INFO "in func %s:%d\n",__FUNCTION__,__LINE__);
-	while((nbytes = walk.nbytes)) {
-		cop->iv = op->iv;
-		cop->iv_len = op->iv_len;
-		cop->nonce = op->nonce;
-		cop->input = walk.src.virt.addr;
-		cop->input_len = nbytes - (nbytes % op->block_size);
-		cop->output = walk.dst.virt.addr;
-
-		memcpy(op->iv, walk.iv, op->iv_len);
-
-		ret = nlmsec_cipher_digest_hmac_cksum(handle, cop);
-		if(IS_SUCCESS_SAEOP(ret)) 
-			xlr_inc_enc_stat(cop->c, cop->m, cop->input_len);
-		debug_print(KERN_INFO "input_len = %d, retval = %d \n",
-			    cop->input_len, ret);
-
-		if (ret == -1)
-			return ret;
-		
-		memcpy(walk.iv, cop->output + cop->input_len - op->iv_len,
-		       op->iv_len);
-
-		nbytes -= cop->input_len;
-		err = blkcipher_walk_done(desc, &walk, nbytes);
-	}
-	debug_print(KERN_INFO "in func %s:%d\n",__FUNCTION__,__LINE__);
-
-	nlmsec_op_cleanup(&handle);
-	return err;
-}
-
-static struct crypto_alg xlr_ecb_aes_alg = {
-	.cra_name		=	"ecb(aes)",
-	.cra_driver_name	=	"ecb-aes-xlr",
-	.cra_priority		=	XLR_CRYPT_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	AES_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_alignmask		=	15,
-	.cra_type		=	&crypto_blkcipher_type,
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_ecb_aes_alg.cra_list),
-	.cra_u			=	{
-		.blkcipher = {
-			.min_keysize		=	AES_MIN_KEY_SIZE,
-			.max_keysize		=	AES_MAX_KEY_SIZE,
-			.setkey			=	xlr_aes_setkey,
-			.encrypt		=	xlr_ecb_encrypt,
-			.decrypt		=	xlr_ecb_decrypt,
-		}
-	}
-};
-
-static struct crypto_alg xlr_aes_alg = {
-	.cra_name               =       "aes",
-	.cra_driver_name	=       "aes-xlr",
-	.cra_priority           =       XLR_CRYPT_PRIORITY,
-	.cra_alignmask          =       15,
-	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
-	.cra_blocksize		=	AES_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_aes_alg.cra_list),
-	.cra_u			=	{
-		.cipher = {
-			.cia_min_keysize	=  AES_MIN_KEY_SIZE,
-			.cia_max_keysize	=  AES_MAX_KEY_SIZE,
-			.cia_setkey		=  xlr_aes_setkey,
-			.cia_encrypt		=  xlr_encrypt,
-			.cia_decrypt		=  xlr_decrypt
-		}
-	}
-};
-
-static struct crypto_alg xlr_cbc_aes_alg = {
-	.cra_name		=	"cbc(aes)",
-	.cra_driver_name	=	"cbc-aes-xlr",
-	.cra_priority		=	XLR_CRYPT_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	AES_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_alignmask		=	15,
-	.cra_type		=	&crypto_blkcipher_type,
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_cbc_aes_alg.cra_list),
-	.cra_u			=	{
-		.blkcipher = {
-			.min_keysize		=	AES_MIN_KEY_SIZE,
-			.max_keysize		=	AES_MAX_KEY_SIZE,
-			.setkey			=	xlr_aes_setkey,
-			.encrypt		=	xlr_cbc_encrypt,
-			.decrypt		=	xlr_cbc_decrypt,
-			.ivsize			=	AES_BLOCK_SIZE,
-		}
-	}
-};
-
-static struct crypto_alg xlr_ctr_aes_alg = {
-	.cra_name		=	"ctr(aes)",
-	.cra_driver_name	=	"ctr-aes-xlr",
-	.cra_priority		=	XLR_CRYPT_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	1,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_alignmask		=	15,
-	.cra_type		=	&crypto_blkcipher_type,
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_ctr_aes_alg.cra_list),
-	.cra_u			=	{
-		.blkcipher = {
-			.min_keysize		=	AES_MIN_KEY_SIZE,
-			.max_keysize		=	AES_MAX_KEY_SIZE,
-			.setkey			=	xlr_aes_ctr_setkey,
-			.encrypt		=	xlr_ctr_encrypt,
-			.decrypt		=	xlr_ctr_decrypt,
-			.ivsize			=	AES_CTR_IV_SIZE,
-		}
-	}
-};
-
-static struct crypto_alg xlr_ecb_des_alg = {
-	.cra_name		=	"ecb(des)",
-	.cra_driver_name	=	"ecb-des-xlr",
-	.cra_priority		=	XLR_CRYPT_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	DES_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_alignmask		=	15,
-	.cra_type		=	&crypto_blkcipher_type,
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_ecb_des_alg.cra_list),
-	.cra_u			=	{
-		.blkcipher = {
-			.min_keysize		=	DES_KEY_SIZE,
-			.max_keysize		=	DES_KEY_SIZE,
-			.setkey			=	xlr_des_setkey,
-			.encrypt		=	xlr_ecb_encrypt,
-			.decrypt		=	xlr_ecb_decrypt,
-		}
-	}
-};
-
-static struct crypto_alg xlr_des_alg = {
-	.cra_name               =       "des",
-	.cra_driver_name	=       "des-xlr",
-	.cra_priority           =       XLR_CRYPT_PRIORITY,
-	.cra_alignmask          =       15,
-	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
-	.cra_blocksize		=	DES_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_des_alg.cra_list),
-	.cra_u			=	{
-		.cipher = {
-			.cia_min_keysize	=  DES_KEY_SIZE,
-			.cia_max_keysize	=  DES_KEY_SIZE,
-			.cia_setkey		=  xlr_des_setkey,
-			.cia_encrypt		=  xlr_encrypt,
-			.cia_decrypt		=  xlr_decrypt
-		}
-	}
-};
-
-static struct crypto_alg xlr_cbc_des_alg = {
-	.cra_name		=	"cbc(des)",
-	.cra_driver_name	=	"cbc-des-xlr",
-	.cra_priority		=	XLR_CRYPT_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	DES_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_alignmask		=	15,
-	.cra_type		=	&crypto_blkcipher_type,
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_cbc_des_alg.cra_list),
-	.cra_u			=	{
-		.blkcipher = {
-			.min_keysize		=	DES_KEY_SIZE,
-			.max_keysize		=	DES_KEY_SIZE,
-			.setkey			=	xlr_des_setkey,
-			.encrypt		=	xlr_cbc_encrypt,
-			.decrypt		=	xlr_cbc_decrypt,
-			.ivsize			=	DES_BLOCK_SIZE,
-		}
-	}
-};
-
-static struct crypto_alg xlr_ecb_des3_alg = {
-	.cra_name		=	"ecb(des3_ede)",
-	.cra_driver_name	=	"ecb-des3-xlr",
-	.cra_priority		=	XLR_CRYPT_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	DES3_EDE_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_alignmask		=	15,
-	.cra_type		=	&crypto_blkcipher_type,
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_ecb_des3_alg.cra_list),
-	.cra_u			=	{
-		.blkcipher = {
-			.min_keysize		=	DES3_EDE_KEY_SIZE,
-			.max_keysize		=	DES3_EDE_KEY_SIZE,
-			.setkey			=	xlr_des3_setkey,
-			.encrypt		=	xlr_ecb_encrypt,
-			.decrypt		=	xlr_ecb_decrypt,
-		}
-	}
-};
-
-static struct crypto_alg xlr_des3_alg = {
-	.cra_name               =       "des3_ede",
-	.cra_driver_name	=       "des3_ede-xlr",
-	.cra_priority           =       XLR_CRYPT_PRIORITY,
-	.cra_alignmask          =       15,
-	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
-	.cra_blocksize		=	DES3_EDE_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_des3_alg.cra_list),
-	.cra_u			=	{
-		.cipher = {
-			.cia_min_keysize	=  DES3_EDE_KEY_SIZE,
-			.cia_max_keysize	=  DES3_EDE_KEY_SIZE,
-			.cia_setkey		=  xlr_des3_setkey,
-			.cia_encrypt		=  xlr_encrypt,
-			.cia_decrypt		=  xlr_decrypt
-		}
-	}
-};
-
-static struct crypto_alg xlr_cbc_des3_alg = {
-	.cra_name		=	"cbc(des3_ede)",
-	.cra_driver_name	=	"cbc-des3_ede-xlr",
-	.cra_priority		=	XLR_CRYPT_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	DES3_EDE_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct xlr_crypt_state),
-	.cra_alignmask		=	15,
-	.cra_type		=	&crypto_blkcipher_type,
-	.cra_module		=	THIS_MODULE,
-	.cra_list		=	LIST_HEAD_INIT(xlr_cbc_aes_alg.cra_list),
-	.cra_u			=	{
-		.blkcipher = {
-			.min_keysize		=	DES3_EDE_KEY_SIZE,
-			.max_keysize		=	DES3_EDE_KEY_SIZE,
-			.setkey			=	xlr_des3_setkey,
-			.encrypt		=	xlr_cbc_encrypt,
-			.decrypt		=	xlr_cbc_decrypt,
-			.ivsize			=	DES3_EDE_BLOCK_SIZE,
-		}
-	}
-};
-
-
-static int __init xlr_crypt_alg_init(void)
-{
-	int ret;
-
-	if ((ret = crypto_register_alg(&xlr_aes_alg)))
-		goto err_out;
-
-	if ((ret = crypto_register_alg(&xlr_ecb_aes_alg)))
-		goto err1;
-
-	if ((ret = crypto_register_alg(&xlr_cbc_aes_alg)))
-		goto err2;
-
-	if ((ret = crypto_register_alg(&xlr_des_alg)))
-		goto err3;
-
-	if ((ret = crypto_register_alg(&xlr_ecb_des_alg)))
-		goto err4;
-
-	if ((ret = crypto_register_alg(&xlr_cbc_des_alg)))
-		goto err5;
-
-	if ((ret = crypto_register_alg(&xlr_des3_alg)))
-		goto err6;
-
-	if ((ret = crypto_register_alg(&xlr_ecb_des3_alg)))
-		goto err7;
-
-	if ((ret = crypto_register_alg(&xlr_cbc_des3_alg)))
-		goto err8;
-	
-//	if ((ret = crypto_register_alg(&xlr_ctr_aes_alg)))
-//		goto err9;
-
-	printk(KERN_NOTICE "Using XLR hardware for AES/DES/3DES algorithm.\n");
-	return 0;
-
-//err9:
-//	crypto_unregister_alg(&xlr_cbc_des3_alg);
-err8:
-	crypto_unregister_alg(&xlr_ecb_des3_alg);
-err7:
-	crypto_unregister_alg(&xlr_des3_alg);
-err6:
-	crypto_unregister_alg(&xlr_cbc_des_alg);
-err5:
-	crypto_unregister_alg(&xlr_ecb_des_alg);
-err4:
-	crypto_unregister_alg(&xlr_des_alg);
-err3:
-	crypto_unregister_alg(&xlr_cbc_aes_alg);
-err2:
-	crypto_unregister_alg(&xlr_ecb_aes_alg);
-err1:
-	crypto_unregister_alg(&xlr_aes_alg);
-err_out:
-	printk(KERN_ERR "XLR hardware AES/DES/3DES initialization failed.\n");
-	return ret;
-}
-
-static void __exit xlr_crypt_alg_fini(void)
-{
-	crypto_unregister_alg(&xlr_cbc_aes_alg);
-	crypto_unregister_alg(&xlr_ecb_aes_alg);
-	crypto_unregister_alg(&xlr_aes_alg);
-	crypto_unregister_alg(&xlr_cbc_des_alg);
-	crypto_unregister_alg(&xlr_ecb_des_alg);
-	crypto_unregister_alg(&xlr_des_alg);
-	crypto_unregister_alg(&xlr_cbc_des3_alg);
-	crypto_unregister_alg(&xlr_ecb_des3_alg);
-	crypto_unregister_alg(&xlr_des3_alg);
-//	crypto_unregister_alg(&xlr_ctr_aes_alg);
-}
-
-//module_init(xlr_crypt_alg_init);
-//module_exit(xlr_crypt_alg_fini);
-
-MODULE_DESCRIPTION("XLR Hardware AES/DES/3DES algorithms support.");
-MODULE_LICENSE("GPL/BSD");
-MODULE_AUTHOR("Sandip Matte");
-
diff --git a/drivers/crypto/netlogic/nlm_state_info.h b/drivers/crypto/netlogic/nlm_state_info.h
deleted file mode 100644
index e952750..0000000
--- a/drivers/crypto/netlogic/nlm_state_info.h
+++ /dev/null
@@ -1,115 +0,0 @@
-struct xlr_crypt_state {
-
-	void *src;
-	void *dst;
-	void *auth_dst;
-	void *auth_src;
-	
-	u32 cipher;
-	u32 hash;
-
-	u32 mode;
-	u32 dir;
-	u32 flags;
-	int len;
-	int iv_len;
-	int block_size;
-	u8 *iv_ptr;
-	u8 *data_ptr;
-	u8 *out_data_ptr;
-	u8 *auth_ptr;
-	int hmac;
-	int hmac_keylen;
-	void *malloc_ptr;
-	int nr_data_desc;
-	//sandip -> check data_desc ptr...
-	uint64_t *cipher_desc;
-	uint64_t *cipher_key_hash_info;
-	uint64_t *data_desc;
-	int key_len;
-
-	u8 key[32]; // max key length
-	u8 iv[32]; // max iv length
-	u8 hmac_key[128]; // max hmac key length //sandip -> Check this length
-	u8 hash_result[128];
-	uint32_t nonce;
-//	u8 nonce[16];
-//	int nonce_len;
-	uint64_t data_msg;
-	uint64_t ctrl_msg;
-};
-
-#ifdef SANDIP
-
-/**
- * SIZES of control data in bytes
- */
-#define CTRL_DESC_VECTOR_SIZE 8
-#define CTRL_INSTR_SIZE 8
-#define MAX_CTRL_DATA_SIZE 472
-#define DATA_DESC_VECTOR_SIZE 8
-#define DATA_DESC_SIZE 32
-#define CEIL_BY_DIV(a,b) (((a)/b) + ((a%b)?1:0))
-#define ADDR_MASK 0xffffffffe0ULL
-#define DATA_DESC_VECTOR_TEMPLATE         ((5ULL << 61) | (1ULL << 45))
-#define MAX_FRAG_TOT_SIZE (((1 << 11) -1) * 8) /* 16 K - 8 */
-#define MAX_PER_FRAG_FIELD_SIZE (MAX_FRAG_TOT_SIZE >> 5 << 2)
-#define MAX_PER_FRAG_SIZE (MAX_FRAG_TOT_SIZE >> 5 << 5);
-
-#define PTR_OFFSET(a,b) (unsigned long)((((unsigned long)a) + (b)))
-#define HAS_REMINDER(x, y)  (((uint64_t)(x) & ((1ULL << (y)) - 1))?1:0)
-#define CEIL(n, bits) ((((uint64_t)n)>>(bits)) + HAS_REMINDER(n,bits))
-#define CEIL_BYTES(m,n) ((CEIL(m,n))<<(n))
-#define NEXT_CACHELINE_ALIGN(m) (unsigned long)(CEIL_BYTES(m, 5))
-#define CACHELINE_ALIGN(m) ((unsigned long long)(unsigned long)(m) >> 5 << 5)
-#define PTR_DIFF(x, y)   (((unsigned long)x) - ((unsigned long)(y)))
-
-#define APPLY_ADDR_MASK(phys,mask) ((unsigned long long)(phys) & (mask))
-
-typedef enum CipherAlgo {
-	CIPHER_BYPASS = 0,
-	NLM_DES,
-	NLM_DES3,
-	NLM_AES128,
-	NLM_AES192,
-	NLM_AES256,
-	NLM_ARC4,
-	NLM_KASUMI_F8,
-	MAX_CIPHER_ALGO
-} CipherAlgo_t;
-
-typedef enum CipherMode {
-	NLM_ECB = 0,
-	NLM_CBC,
-	NLM_CFB,
-	NLM_OFB,
-	NLM_CTR,
-	NLM_F8,
-	NLM_CCM,
-	MAX_CIPHER_MODE
-} CipherMode_t;
-
-typedef enum HashAlgo {
-	HASH_BYPASS = 0,
-	NLM_MD5,
-	NLM_SHA1,
-	NLM_SHA256,
-	NLM_SHA384,
-	NLM_SHA512,
-	NLM_GCM,
-	NLM_KASUMI_F9,
-	NLM_DES3_CMAC,
-	NLM_AES_CMAC,
-	MAX_HASH_ALGO
-} HashAlgo_t;
-
-typedef enum {
-	CIPHER_DECRYPT=0,
-	CIPHER_ENCRYPT
-} Cipher_Function_t;
-
-#endif /* SANDIP */
-
-//extern unsigned int xlr_digest(struct xlr_sae_op *op);
-//extern unsigned int xlr_crypt(struct xlr_sae_op *op);
-//extern int xlr_sec_init(void);
diff --git a/drivers/crypto/netlogic/nlmsec.c b/drivers/crypto/netlogic/nlmsec.c
deleted file mode 100644
index f9560dd..0000000
--- a/drivers/crypto/netlogic/nlmsec.c
+++ /dev/null
@@ -1,2401 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef AUTOCONF_INCLUDED
-#include <linux/config.h>
-#endif
-
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/sched.h>
-#include <linux/cdev.h>
-#include <linux/list.h>
-#include <linux/slab.h>
-#include <linux/mm.h>
-#include <linux/highmem.h>
-#include <linux/proc_fs.h>
-#include <linux/kernel.h>
-#include <linux/hardirq.h>
-#include <linux/netdevice.h>
-#include <asm/current.h>
-#include <asm/atomic.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/utils.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/linux_crf.h>
-
-#ifdef CONFIG_OCF_OCF_MODULE
-#include <linux/crypto.h>
-#include <cryptodev.h>
-#endif /* CONFIG_OCF_OCF_MODULE */
-#include "nlmsec_internal.h"
-#include "ecc_ucode_data.h"
-
-#define	ECC_UC_LOAD 0x70
-MODULE_AUTHOR("Netlogic Microsystem Inc.");
-MODULE_DESCRIPTION("XLS/XLR SAE Driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
-typedef struct device_info *device_info_pt;
-
-enum progress_type {
-	NOT_IN_PROGRESS = 0,
-	IN_PROGRESS,
-	IN_WAIT_QUEUE
-};
-
-#define IS_IN_PROGRESS(m) ((m)->in_progress == IN_PROGRESS)
-#define IS_IN_WAIT_QUEUE(m) ((m)->in_progress == IN_WAIT_QUEUE)
-
-#define NR_CRYPTO_BITS 9
-#define NR_PK_BITS 3
-/* we use only the last 8 bits, so we offet result of
- * clz with this offset */
-#define PK_BITMAP_OFFSET 24
-
-#define NR_CRYPTO_OPS (1 << NR_CRYPTO_BITS)
-#define NR_PK_OPS     (1 << NR_PK_BITS)
-
-#define MAX_CRYPTO_OPS_INDEX   (NR_CRYPTO_OPS >> 5)
-
-#define CRYPTO_BITMAP_INDEX(x) (x >> 5)
-#define BITMAP_OFF_MASK(x)     ~(0x80000000 >> ((x) & 0x1f))
-#define BITMAP_ON_MASK(x)       (0x80000000 >> ((x) & 0x1f))
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-
-DECLARE_PER_CPU(struct napi_struct, xlr_napi_poll_struct);
-extern struct net_device xlr_napi_dummy_dev;
-void xlr_napi_poll_upper(struct net_device *dummy_dev, int *budget);
-extern int xlr_napi_ready, nlm_on_chip_napi;
-#define upper_buckets_nonempty() ((~msgrng_read_status() >> 28) & 0xf)
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-extern __u32 cpu_to_frstid[];
-static char driver_name[] = DRIVER_NAME;
-static char debug_name[] __attribute__((unused)) = "debug";
-static char stats_name[] = "stats";
-static char NLMSAE_BUILD_VERSION[] = "1.7";
-static const char *versionstr = NLMSAE_BUILD_VERSION;
-extern int xlr_loader_support;
-extern int xlr_loader_sharedcore;
-
-static atomic_t vma_count __cacheline_aligned;
-static uint64_t msgs_sent[NR_CPUS] __cacheline_aligned;
-static uint64_t resp_recieved[NR_CPUS] __cacheline_aligned;
-static uint64_t wait_count[NR_CPUS] __cacheline_aligned;
-static uint64_t mmap_cnt[NR_CPUS] __cacheline_aligned __attribute__((unused));
-static uint64_t mmapfree[NR_CPUS] __cacheline_aligned __attribute__((unused));
-static uint64_t cipher_cnt[NR_CPUS][MAX_CIPHER_ALGO][MAX_CIPHER_MODE] __cacheline_aligned;
-static uint64_t cipher_data_cnt[NR_CPUS][MAX_CIPHER_ALGO][MAX_CIPHER_MODE] __cacheline_aligned;
-static uint64_t hash_cnt[NR_CPUS][MAX_HASH_ALGO] __cacheline_aligned;
-static uint64_t hash_data_cnt[NR_CPUS][MAX_HASH_ALGO] __cacheline_aligned;
-static uint64_t mod_exp_cnt[NR_CPUS][2] __cacheline_aligned;
-static uint64_t ecc_prime_cnt[NR_CPUS][NLM_ECC_PRIME_CURVE_MAX][NLM_ECC_PRIME_OP_MAX] __cacheline_aligned __attribute__((unused));
-static uint64_t ecc_binary_cnt[NR_CPUS][NLM_ECC_BINARY_CURVE_MAX][NLM_ECC_BINARY_OP_MAX] __cacheline_aligned __attribute__((unused));
-
-static struct device_info {
-	int version;
-	dev_t device;
-	struct proc_dir_entry *pdir;
-	struct proc_dir_entry *pdebug;
-	struct proc_dir_entry *pstats;
-	struct cdev nlmsec_cdev;
-#ifdef CONFIG_OCF_OCF_MODULE
-	op_callback_t ocf_cb;
-	softc_device_decl ocf_dev;
-	int32_t ocf_id;
-#endif /* CONFIG_OCF_OCF_MODULE */
-	spinlock_t mem_lock;
-	struct list_head pmem_list;
-
-	spinlock_t crypto_lock;
-	atomic_t crypto_used_slots;
-	unsigned int max_crypto_used_slots;
-	meminfo_pt crypto_ops_slot[NR_CRYPTO_OPS];
-	unsigned int pk_used_slots;
-	unsigned int max_pk_used_slots;
-	uint32_t crypto_ops_bitmap[MAX_CRYPTO_OPS_INDEX];
-	unsigned int bitmap_start;
-
-	spinlock_t pkops_lock;
-	volatile uint32_t pk_ops_bitmap;
-	meminfo_pt pk_ops_slot[NR_PK_OPS];
-	wait_queue_head_t crypto_queue;
-	wait_queue_head_t pkop_queue;
-	int exit_driver;
-} dev_info;
-
-extern void nlm_common_msgring_int_handler(unsigned int irq, struct pt_regs *regs);
-extern int msgring_int_type;
-
-static inline void remote_napi_poll_upper(void)
-{
-	unsigned long flags;
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-	if(xlr_napi_ready && nlm_on_chip_napi &&
-	   upper_buckets_nonempty()) {
-		xlr_napi_poll_upper(&xlr_napi_dummy_dev, 0);
-	} else if (in_softirq() && (!msgring_int_type)){
-		local_irq_save(flags);
-		nlm_common_msgring_int_handler(-1,NULL);
-		local_irq_restore(flags);
-	}
-#else
-	if (in_softirq() && (!msgring_int_type)) {
-		local_irq_save(flags);
-		nlm_common_msgring_int_handler(-1,NULL);
-		local_irq_restore(flags);
-	}
-	return;
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-}
-
-
-#ifdef CONFIG_OCF_OCF_MODULE
-int nlmsae_ocf_newsession(device_t dev, u_int64_t *sidp, struct cryptoini *cri);
-int nlmsae_ocf_freesession(device_t dev, u_int64_t sid);
-int nlmsae_ocf_process(device_t dev, struct cryptop *crp, int hint);
-
-static device_method_t nlmsae_ocf_methods = {
-	DEVMETHOD(cryptodev_newsession, nlmsae_ocf_newsession),
-	DEVMETHOD(cryptodev_freesession, nlmsae_ocf_freesession),
-	DEVMETHOD(cryptodev_process, nlmsae_ocf_process)
-};
-
-static struct {
-	int ocf_algo_num;
-	CipherAlgo_t c;
-	CipherMode_t m;
-	HashAlgo_t h;
-	int hmac;
-} algo_mapper[] = {
-	{CRYPTO_DES_CBC, NLM_DES, NLM_CBC, HASH_BYPASS, 0},
-	{CRYPTO_3DES_CBC, NLM_DES3, NLM_CBC, HASH_BYPASS, 0},
-	{-1},/* CRYPTO_BLF_CBC */
-	{-1},/* CRYPTO_CAST_CBC */
-	{-1},/* CRYPTO_SKIPJACK_CBC */
-	{CRYPTO_MD5_HMAC, CIPHER_BYPASS, NLM_ECB, NLM_MD5, 1},
-	{CRYPTO_SHA1_HMAC, CIPHER_BYPASS, NLM_ECB, NLM_SHA1, 1},
-	{-1},/* CRYPTO_RIPEMD160_HMAC */
-	{-1},/* CRYPTO_MD5_KPDK */
-	{-1},/* CRYPTO_SHA1_KPDK */
-	{CRYPTO_AES_CBC, NLM_AES128, NLM_CBC, HASH_BYPASS, 0},
-	{-1},/* ARC4 */
-	{CRYPTO_MD5, CIPHER_BYPASS, NLM_ECB, NLM_MD5, 0},
-	{CRYPTO_SHA1, CIPHER_BYPASS, NLM_ECB, NLM_SHA1, 0},
-	{-1},/* CRYPTO_NULL_HMAC */
-	{-1},/* CRYPTO_NULL_CBC */
-	{-1},/* CRYPTO_DEFLATE_COMP */
-	{CRYPTO_SHA2_256_HMAC, CIPHER_BYPASS, NLM_ECB, NLM_SHA256, 1},
-	{CRYPTO_SHA2_384_HMAC, CIPHER_BYPASS, NLM_ECB, NLM_SHA384, 1},
-	{CRYPTO_SHA2_512_HMAC, CIPHER_BYPASS, NLM_ECB, NLM_SHA512, 1},
-	{-1},/* CRYPTO_CAMELLIA_CBC */
-	{CRYPTO_SHA2_256, CIPHER_BYPASS, NLM_ECB, NLM_SHA256, 0},
-	{CRYPTO_SHA2_384, CIPHER_BYPASS, NLM_ECB, NLM_SHA384, 0},
-	{CRYPTO_SHA2_512, CIPHER_BYPASS, NLM_ECB, NLM_SHA512, 0},
-	{-1},/* CRYPTO_RIPEMD160 */
-};
-
-int nlmsae_ocf_newsession(device_t dev, u_int64_t *sidp, struct cryptoini *cri)
-{
-	Crypto_Operation_pt cop;
-	if(in_atomic() || in_interrupt()) {
-		cop = (Crypto_Operation_pt)kmalloc(sizeof(Crypto_Operation_t),
-						  GFP_ATOMIC);
-	} else {
-		cop = (Crypto_Operation_pt)kmalloc(sizeof(Crypto_Operation_t),
-						  GFP_KERNEL);
-	}
-	if(cop == NULL) {
-		return -ENOMEM;
-	}
-
-	memset(cop, 0, sizeof(Crypto_Operation_t));
-
-	// populate all crypto fields here
-	cop->c = algo_mapper[cri->cri_alg].c;
-	cop->m = algo_mapper[cri->cri_alg].m;
-	cop->key = cri->key;
-	cop->key_len = cri->klen;
-	cop->iv = cri->cri_iv;
-	if(crp->flags & CRYPTO_OP_ENCRYPT) {
-		cop->encrypt = CIPHER_ENCRYPT;
-	}
-
-	/* authentication parameters */
-	if(cri->cri_next != NULL) {
-		cri = cri->next;
-		cop->h = algo_mapper[cri->cri_alg].h;
-		if(algo_mapper[cri->cri_alg].hmac) {
-			cop->hmac = (unsigned char *)cri->cri_key;
-			cop->hmac_len = cri->cri_klen;
-		}
-	}
-
-
-	*sidp = (u_int64_t)op;
-	return 0;
-
-	return nlmsec_op_init(sidp);
-}
-
-int nlmsae_ocf_freesession(device_t dev, u_int64_t sid)
-{
-	op_handle_t op = (op_handle_t)sid;
-	return nlmsec_op_cleanup(&op);
-}
-
-int nlmsae_ocf_process(device_t dev, struct cryptop *crp, int hint)
-{
-	Crypto_Operation_pt *cop = (Crypto_Operation_pt)crp->crp_sid;
-	op_handle_t op;
-	int ret = NLMSAE_SUCCESS;
-
-	ret = nlmsec_op_init(&op);
-	if(ret) {
-		goto bail;
-	}
-
-	if((ret = nlmsec_op_callback_setup(op, &dev_info.ocf_cb,
-					  (unsigned long)op, 0))) {
-		printk(KERN_ALERT "%s:%d Error while submitting operation to SAE.",
-		       __FUNCTION__, __LINE__);
-		nlmsec_op_cleanup(&op);
-		goto bail;
-	}
-
-	ret = nlmsec_cipher_and_hash(op, cop->c, cop->m, cop->key, cop->iv,
-				     0, (crp->crp_desc.crd_flags & CRD_F_ENCRYPT),
-				     cop->h, cop->hmac,
-				     0, /* hash_src */
-				     0, /* hash_bytes_to_skip */
-				     crp->crp_buf, crp->crp_ilen,
-
-);
-	crypto_copyback(crp->crp_flags, crp->crp_buf,
-			crd->crd_inject, sw->u.hmac.sw_mlen, result);
-
-	if(!IS_ASYNC_SUCCESS_SAEOP(ret)) {
-		nlmsec_op_cleanup(&op);
-	}
- bail:
-	return ret;
-}
-
-void nlmsae_ocf_callback(int result, unsigned long arg)
-{
-}
-
-#endif /* CONFIG_OCF_OCF_MODULE */
-
-#ifdef CONFIG_64BIT
-// doesn't read the old value
-static __inline__ void ldadd_d_noread(long long value, uint64_t *addr)
-{
-  __asm__ __volatile__(
-                       ".set push\n"
-                       ".set noreorder\n"
-                       "move $8, %2\n"
-                       "move $9, %3\n"
-//                       "ldaddd $8, $9\n"
-		       ".word 0x71280012\n"
-                       // "move %0, $8\n"
-                       ".set pop\n"
-                       : "=&r"(value), "+m"(*addr)
-                       : "0" (value), "r"((unsigned long)addr)
-                       : "$8", "$9"
-                       );
-}
-#endif /* CONFIG_64BIT */
-
-static inline int
-message_send_fast_2(unsigned int code,
-                    unsigned int stid,
-                    unsigned long long msg0,
-                    unsigned long long msg1)
-{
-        int ret;
-
-
-        msgrng_load_tx_msg0(msg0);
-        msgrng_load_tx_msg1(msg1);
-
-        __asm__ __volatile__ (".set push\n"
-                              ".set noreorder\n"
-                              ".set mips64\n"
-                              "sync\n"
-                              "1:move $8, %1\n"
-                              "c2 0x80001\n"
-			      "nop\n"
-			      "nop\n"
-			      "nop\n"
-			      "nop\n"
-			      "nop\n"
-                              "mfc2 $8, "STR(MSGRNG_MSG_STATUS_REG)"\n"
-                              "andi $8, $8, 0x6\n"
-                              "beqz $8, 2f\n"
-                              "andi $8, 2\n"
-                              "bnez $8, 1b\n"
-                              "2:move %0, $8\n"
-                              ".set pop\n"
-                              :"=r"(ret)
-                              : "r"((1<<16)|(code<<8)|stid)
-                              : "$8"
-                             );
-        return ret;
-}
-
-static inline int add_meminfo_to_queue(secop_queue_pt q, meminfo_pt mem)
-{
-	unsigned long flags = 0;
-	if(q->response_type == SECOP_Q) {
-		spin_lock_irqsave(&q->q.lock, flags);
-
-		if(q->q.max_length != -1 && q->q.length >= q->q.max_length) {
-			spin_unlock_irqrestore(&q->q.lock, flags);
-			return -EAGAIN;
-		}
-
-		q->q.length++;
-#ifdef SAE_STATS
-		if(q->q.length > q->q.stats_max_length) {
-			q->q.stats_max_length = q->q.length;
-		}
-#endif /* SAE_STATS */
-		mem->async_next = &q->q.head;
-		q->q.tail->async_next = mem;
-		q->q.tail = mem;
-
-#ifdef DEBUG_QUEUE
-		printk("%s:%d q=%p q->head=%p q->length=%d q->tail=%p "
-		       "h->next=%p t->next=%p\n", __FILE__, __LINE__, q,
-		       &q->q.head, q->q.length, q->q.tail, q->q.head.async_next,
-		       q->q.tail->async_next);
-#endif /* DEBUG_QUEUE */
-
-		spin_unlock_irqrestore(&q->q.lock, flags);
-	} else {
-		q->cb.cbfunc(mem->result, mem->return_value);
-	}
-
-	return 0;
-}
-
-static inline meminfo_pt remove_meminfo_from_queue(secop_queue_pt q)
-{
-	meminfo_pt ret = NULL;
-	unsigned long flags;
-
-	if(q->response_type == SECOP_Q) {
-		spin_lock_irqsave(&q->q.lock, flags);
-
-		if(q->q.head.async_next != &q->q.head) {
-			ret = q->q.head.async_next;
-			q->q.length--;
-			q->q.head.async_next = ret->async_next;
-
-			if(ret->async_next == &q->q.head) {
-				q->q.tail = &q->q.head;
-			}
-			ret->async_next = NULL;
-		}
-
-		spin_unlock_irqrestore(&q->q.lock, flags);
-	}
-	return ret;
-}
-
-#define ALL_SEC_STN 120
-#define PK_STN 124
-struct {
-	wait_queue_head_t *wq;
-	int stid;
-} op_data[OP_ALL] = {
-	{0, 0},
-	{&dev_info.crypto_queue, ALL_SEC_STN},
-	{&dev_info.pkop_queue, PK_STN},
-	{&dev_info.pkop_queue, PK_STN}
-};
-
-struct page *nlmsec_vma_nopage(struct vm_area_struct *vma,
-			       unsigned long address, int *type);
-
-void nlmsec_vma_open(struct vm_area_struct *vma);
-void nlmsec_vma_close(struct vm_area_struct * vma);
-void write_magic(meminfo_pt mem, char __user *buf);
-
-struct vm_operations_struct vmops = {
-	.open = nlmsec_vma_open,
-	.close = nlmsec_vma_close,
-//	.nopage = nlmsec_vma_nopage,
-};
-
-#define MEMINFO_MATCHED_PTR(m, ptr) ((m)->ptr == ptr)
-#define MEMINFO_MATCHED_VMA(m, vma) ((m)->vma == vma)
-
-/*
- * Ops slot functions
- */
-static int inline
-find_free_crypto_slot(device_info_pt dinfo)
-{
-	unsigned int start = dinfo->bitmap_start % MAX_CRYPTO_OPS_INDEX, i, j;
- 	uint32_t *ptr = &dinfo->crypto_ops_bitmap[0];
-
-	i = start;
-	do {
-		j = find_32bit_1st_zero_bit(ptr[i]);
-		if(j < 32) {
-			ptr[i] |= BITMAP_ON_MASK(j);
-			dinfo->bitmap_start = i;
-			atomic_inc(&dinfo->crypto_used_slots);
-			return ((i << 5) + j);
-		}
-		i = ((i + 1) % MAX_CRYPTO_OPS_INDEX);
-	} while(i != start);
-
-	return -1;
-}
-
-static int inline
-alloc_crypto_op_slot(device_info_pt dinfo, meminfo_pt mem)
-{
-	unsigned long flags;
-	int i;
-	spin_lock_irqsave(&dinfo->crypto_lock, flags);
-	i = find_free_crypto_slot(dinfo);
-	spin_unlock_irqrestore(&dinfo->crypto_lock, flags);
-	if(i > -1) {
-		dinfo->crypto_ops_slot[i] = mem;
-#ifdef SAE_STATS
-		if(dinfo->max_crypto_used_slots < dinfo->crypto_used_slots.counter) {
-			dinfo->max_crypto_used_slots = dinfo->crypto_used_slots.counter;
-		}
-#endif /* SAE_STATS */
-	}
-	return i;
-}
-
-static int inline
-alloc_pk_ops_slot(device_info_pt dinfo, meminfo_pt mem)
-{
-	int j;
-	unsigned long flags;
-	spin_lock_irqsave(&dinfo->pkops_lock, flags);
-	j = find_32bit_1st_zero_bit(dinfo->pk_ops_bitmap);
-	if(j < 32) {
-		dinfo->pk_ops_bitmap |= BITMAP_ON_MASK(j);
-	}
-	spin_unlock_irqrestore(&dinfo->pkops_lock, flags);
-	if(j < 32) {
-		j = j - PK_BITMAP_OFFSET;
-		dinfo->pk_ops_slot[j] = mem;
-		/* for PK Ops bit 3 needs to be set to 1 */
-		j |= 0x8;
-		ldadd_wu_no_read(1, &dinfo->pk_used_slots);
-#ifdef SAE_STATS
-		if(dinfo->max_pk_used_slots < dinfo->pk_used_slots) {
-			dinfo->max_pk_used_slots = dinfo->pk_used_slots;
-		}
-#endif /* SAE_STATS */
-	} else {
-		j = -1;
-	}
-	return j;
-}
-
-static int inline
-alloc_op_slot(device_info_pt dinfo, meminfo_pt mem)
-{
-	if(mem->op_type == NLM_CRYPTO_OP) {
-		return alloc_crypto_op_slot(dinfo, mem);
-	} else if(mem->op_type > NLM_CRYPTO_OP && mem->op_type < OP_ALL) {
-		return alloc_pk_ops_slot(dinfo, mem);
-	} else {
-		printk("%s:%d Unknown op_type=%d\n", __FUNCTION__, __LINE__, mem->op_type);
-	}
-	return -1;
-}
-
-static void inline
-clear_op_slot(device_info_pt dinfo, OpType_t op_type, int cs)
-{
-	unsigned long flags;
-
-	if(op_type == NLM_CRYPTO_OP) {
-		spin_lock_irqsave(&dinfo->crypto_lock, flags);
-		dinfo->crypto_ops_bitmap[CRYPTO_BITMAP_INDEX(cs)] &= BITMAP_OFF_MASK(cs);
-		atomic_dec(&dinfo->crypto_used_slots);
-		spin_unlock_irqrestore(&dinfo->crypto_lock, flags);
-	} else if(op_type > NLM_CRYPTO_OP && op_type < OP_ALL) {
-		spin_lock_irqsave(&dinfo->pkops_lock, flags);
-		dinfo->pk_ops_bitmap &= BITMAP_OFF_MASK(cs + PK_BITMAP_OFFSET);
-		ldadd_w_no_read(-1, &dinfo->pk_used_slots);
-		spin_unlock_irqrestore(&dinfo->pkops_lock, flags);
-	} else {
-		printk("%s:%d Unknown op_type=%d crypto=%d cs=%d\n", __FUNCTION__, __LINE__,
-		       op_type, NLM_CRYPTO_OP, cs);
-	}
-	return;
-}
-
-/*
- * Proc memlist functions
- */
-static void inline
-free_proc_memlist(device_info_pt dinfo, proc_memlist_pt proc_info)
-{
-	meminfo_pt mem;
-	memlist_pt tmp, m;
-	int i = 0;
-
-	if(proc_info == NULL) {
-		printk(KERN_ALERT "%s:%d Invalid proc_memlist passed for "
-		       "freeing.\n", __FUNCTION__, __LINE__);
-		return;
-	}
-
-	list_for_each_safe(m, tmp, &proc_info->mem) {
-		mem = (meminfo_pt) m;
-		if(mem->owner != current->tgid) {
-			printk(KERN_ALERT "%s:%d Memory attempted to be freed by "
-			       "non-owner. owner=%d tgid=%d\n", __FUNCTION__, __LINE__,
-			       mem->owner, current->tgid);
-			return;
-		}
-		/*
-		 * Waiting for existing operation to complete.
-		 */
-		while(IS_IN_PROGRESS(mem)) {
-			i = 0;
-			while(IS_IN_PROGRESS(mem) && i < 100000) ++i;
-			if(IS_IN_PROGRESS(mem)) {
-				printk(KERN_NOTICE "%s:%d Waiting for meminfo "
-				       "in_progress state to change mem=%p\n",
-				       __FUNCTION__, __LINE__, mem);
-			}
-		}
-		free_meminfo(mem);
-	}
-
-	INIT_LIST_HEAD(&proc_info->mem);
-
-	kfree(proc_info);
-	return;
-}
-
-static proc_memlist_pt inline
-find_proc_memlist(device_info_pt dev)
-{
-	proc_memlist_pt proc_info = (proc_memlist_pt)dev->pmem_list.next;
-	while(proc_info != (proc_memlist_pt)&dev->pmem_list) {
-		if(proc_info->tgid == current->tgid) {
-			return proc_info;
-		}
-		proc_info = (proc_memlist_pt)proc_info->elem.next;
-	}
-	return NULL;
-}
-
-/*
- * Meminfo functions
- */
-static inline meminfo_pt
-find_meminfo_for_virt_addr(proc_memlist_pt proc_info, unsigned long start_addr)
-{
-	memlist_pt tmp;
-	meminfo_pt mem;
-	list_for_each(tmp, &proc_info->mem) {
-		mem = (meminfo_pt)tmp;
-		if(mem->owner == current->tgid) {
-			if(mem->vma->vm_start == start_addr) {
-				return mem;
-			}
-		} else {
-			printk(KERN_ALERT "%s:%d Memory attempted to be freed by "
-			       "non-owner. owner=%d tgid=%d\n", __FUNCTION__, __LINE__,
-			       mem->owner, current->tgid);
-		}
-	}
-	return 0;
-}
-
-void
-free_meminfo(meminfo_pt mem)
-{
-	if(!mem) return;
-	mem->magic = 0xBADBADBADBADBADAULL;
-#ifdef SAE_STATS
-#ifdef SYSTEM_CALL_STATS
-	dev_info.mmapfree[hard_smp_processor_id()]++;
-#endif /* SYSTEM_CALL_STATS */
-#endif /* SAE_STATS */
-	if(mem->ptr && mem->order > -1) {
-		if(mem->ctx == PROCESS_CTX) {
-			__free_pages((struct page *)mem->ptr, mem->order);
-		} else {
-			free_pages((unsigned long)mem->ptr, mem->order);
-		}
-	}
-	mem->memlist.next = mem->memlist.prev = NULL;
-	mem->ptr = NULL;
-	mem->proc = NULL;
-	mem->async_next = NULL;
-	mem->owner = 0;
-	mem->order = -1;
-	kfree(mem);
-	return;
-}
-
-static void inline
-insert_meminfo(proc_memlist_pt proc_info, meminfo_pt mem)
-{
-	list_add_tail((memlist_pt)mem, &proc_info->mem);
-	return;
-}
-
-static void inline
-free_meminfo_for_proc(proc_memlist_pt proc_info, meminfo_pt mem)
-{
-	if(mem->owner == current->tgid) {
-		list_del((memlist_pt)mem);
-		free_meminfo(mem);
-	} else {
-		printk(KERN_ALERT "%s:%d Memory attempted to be freed by "
-		       "non-owner. owner=%d tgid=%d\n", __FUNCTION__, __LINE__,
-		       mem->owner, current->tgid);
-	}
-	return;
-}
-
-void nlmsec_vma_open(struct vm_area_struct *vma)
-{
-#ifdef DEBUG_2
-	printk(KERN_NOTICE "%s:%d\n", __FUNCTION__, __LINE__);
-#endif /* DEBUG */
-	atomic_inc(&vma_count);
-	return;
-}
-
-static meminfo_pt inline
-alloc_meminfo(proc_memlist_pt proc_info, CALL_CTX c_ctx,
-	      struct vm_area_struct *vma, int korder)
-{
-	unsigned long size;
-	unsigned int nrpages, order;
-	void *page_or_addr;
-	gfp_t gfp_flags = GFP_KERNEL;
-	int in_asi = (in_atomic() || in_softirq() || in_interrupt());
-
-	meminfo_pt ret;
-
-	if(c_ctx == PROCESS_CTX) {
-		/* find required size */
-		size = vma->vm_end - vma->vm_start;
-
-		/* find next higher order of 2 */
-		nrpages = CEIL(size, PAGE_SHIFT);
-
-		order = (31 - find_32bit_1st_one_bit(nrpages));
-
-		order += HAS_REMINDER(nrpages, order);
-		if(order) {
-			page_or_addr = alloc_pages(GFP_HIGHUSER|__GFP_COMP, order);
-		} else {
-			page_or_addr = alloc_pages(GFP_HIGHUSER, order);
-		}
-		if(!page_or_addr) {
-			printk("%s:%d No memory allocated to kernel %p\n", __FUNCTION__,
-			       __LINE__, page_or_addr);
-		}
-	} else {
-		if(in_asi) {
-		    gfp_flags = GFP_ATOMIC;
-		}
-		order = korder;
-		if(order) {
-			page_or_addr = (void *)__get_free_pages(gfp_flags|__GFP_COMP,
-								order);
-		} else {
-			page_or_addr = (void *)__get_free_page(gfp_flags);
-		}
-	}
-
-	if(page_or_addr != NULL) {
-		ret = (meminfo_pt)kmalloc(sizeof(meminfo_t), gfp_flags);
-		if(ret == NULL) {
-			if(c_ctx == PROCESS_CTX) {
-				__free_pages((struct page *)page_or_addr, order);
-			} else {
-				free_pages((unsigned long)page_or_addr, order);
-			}
-			printk(KERN_ALERT "%s:%d Error allocating meminfo "
-			       "structure.\n", __FUNCTION__, __LINE__);
-			return NULL;
-		}
-	} else {
-		printk(KERN_ALERT "%s:%d Error allocating pages "
-		       "order=%d\n", __FUNCTION__, __LINE__, order);
-		return NULL;
-	}
-
-	memset(ret, 0, sizeof(meminfo_t));
-	ret->magic = DRIVER_MAGIC;
-	ret->order = order;
-	ret->ptr = page_or_addr;
-	ret->ctx = c_ctx;
-	ret->vma = vma;
-	ret->memlist.next = ret->memlist.prev = NULL;
-	ret->async_next = NULL;
-	ret->in_progress = NOT_IN_PROGRESS;
-	init_waitqueue_head(&ret->wq);
-
-	if(c_ctx == PROCESS_CTX) {
-		ret->return_queue = &proc_info->async_queue;
-		ret->return_value = vma->vm_start;
-		ret->owner = current->tgid;
-		ret->proc = proc_info;
-		vma->vm_ops = &vmops;
-		vma->vm_private_data = ret;
-//		vma->vm_flags &= ~(VM_IO | VM_RESERVED);
-		vma->vm_flags |= VM_DONTCOPY;
-		nlmsec_vma_open(vma);
-	}
-
-#ifdef DEBUG_MEMINFO
-	printk(KERN_NOTICE "%s:%d mem=%p order=%d page=%p\n",
-	       __FUNCTION__, __LINE__, ret, ret->order, ret->ptr);
-#endif /* DEBUG_MEMINFO */
-
-	return ret;
-}
-
-meminfo_pt
-alloc_meminfo_kernel_ctx(int order)
-{
-	meminfo_pt ret= alloc_meminfo(NULL, KERNEL_CTX, NULL, order);
-	if(ret) {
-		write_magic(ret, NULL);
-	}
-	return ret;
-}
-
-static meminfo_pt inline
-alloc_meminfo_process_ctx(proc_memlist_pt proc_info,
-			  struct vm_area_struct *vma)
-{
-	return alloc_meminfo(proc_info, PROCESS_CTX, vma, 0);
-}
-
-void nlmsec_vma_close(struct vm_area_struct *vma)
-{
-	meminfo_pt mem = (meminfo_pt)vma->vm_private_data;
-	proc_memlist_pt proc_info;
-	int i;
-
-#ifdef DEBUG_2
-	printk(KERN_NOTICE "%s:%d\n", __FUNCTION__, __LINE__);
-#endif /* DEBUG */
-
-	if(mem != NULL && mem->magic == DRIVER_MAGIC &&
-	   mem->owner == current->tgid && mem->ptr != NULL && mem->order > -1) {
-		proc_info = mem->proc;
-		mem->proc = NULL;
-		if(proc_info && proc_info->tgid == current->tgid) {
-			do {
-				i = 0;
-				while(IS_IN_PROGRESS(mem) && i < 100000) ++i;
-				if(IS_IN_PROGRESS(mem)) {
-					printk(KERN_NOTICE "%s:%d Waiting for meminfo "
-					       "in_progress state to change mem=%p\n",
-					       __FUNCTION__, __LINE__, mem);
-				}
-			} while(IS_IN_PROGRESS(mem));
-			spin_lock_bh(&dev_info.mem_lock);
-			free_meminfo_for_proc(proc_info, mem);
-			spin_unlock_bh(&dev_info.mem_lock);
-
-			vma->vm_ops = NULL;
-			vma->vm_private_data = NULL;
-			atomic_dec(&vma_count);
-		}
-#if 0
-	} else {
-		if(mem) {
-			printk(KERN_ALERT "%s:%d Invalid meminfo %p %"LLX_FMT,
-			       __FUNCTION__, __LINE__, mem, mem->magic);
-		} else {
-			printk(KERN_ALERT "%s:%d meminfo is null",
-			       __FUNCTION__, __LINE__);
-		}
-#endif
-	}
-	return;
-}
-
-#if 0
-struct page *
-nlmsec_vma_nopage(struct vm_area_struct *vma, unsigned long address, int *type)
-{
-	meminfo_pt m = (meminfo_pt)vma->vm_private_data;
-	struct page *page = NOPAGE_SIGBUS;
-	unsigned long offset = address - vma->vm_start;
-	int pg_idx = offset >> PAGE_SHIFT;
-
-	if(m && m->magic == DRIVER_MAGIC) {
-		if(pg_idx > ((1 << m->order) - 1)) {
-			printk(KERN_ALERT "%s:%d page=%p idx=%d count=%d map_count=%d "
-			       "flags=%08lx\n", __FUNCTION__, __LINE__, page, pg_idx,
-			       page->_count.counter, page->_mapcount.counter,
-			       page->flags);
-			return page;
-		}
-
-		page = ((struct page *)m->ptr) + pg_idx;
-#ifdef DEBUG
-		printk(KERN_NOTICE "%s:%d pid=%d tid=%d idx=%d pfn=0x%lx page=%p "
-		       "address=0x%lx vma->vm_start=0x%lx\n",
-		       __FUNCTION__, __LINE__, current->pid, current->tgid, pg_idx,
-		       page_to_pfn(page), page, address, vma->vm_start);
-#endif /* DEBUG */
-
-		get_page(page);
-
-		if(type)
-			*type = VM_FAULT_MINOR;
-	} else {
-		printk(KERN_ALERT "%s:%d no page mapping found at addr=0x%lx\n",
-		       __FILE__, __LINE__, address);
-	}
-
-	return page;
-}
-#endif /* 0 */
-
-void insert_proc_memlist(device_info_pt dinfo, proc_memlist_pt proc_info)
-{
-	proc_info->elem.prev = dinfo->pmem_list.prev;
-	proc_info->elem.next = &dinfo->pmem_list;
-
-	dinfo->pmem_list.prev->next = (struct list_head *)proc_info;
-	dinfo->pmem_list.prev = (struct list_head *)proc_info;
-}
-
-int nlmsec_open(struct inode *iptr, struct file *fptr)
-{
-#ifdef DEBUG_SYSTEM_CALL
-	printk(KERN_NOTICE "%s:%d pid=%d tgid=%d ftpr=%p\n",
-	       __FUNCTION__, __LINE__, current->pid, current->tgid, fptr);
-#endif /* DEBUG_SYSTEM_CALL */
-	fptr->private_data = (void *)&dev_info;
-	return 0;
-}
-
-int nlmsec_flush(struct file *fptr, fl_owner_t id)
-{
-#ifdef DEBUG_SYSTEM_CALL
-	printk(KERN_NOTICE "%s:%d pid=%d tgid=%d\n", __FUNCTION__, __LINE__,
-	       current->pid, current->tgid);
-#endif /* DEBUG_SYSTEM_CALL */
-	return 0;
-}
-
-int nlmsec_release(struct inode *iptr, struct file *fptr)
-{
-	proc_memlist_pt proc_info;
-	device_info_pt dinfo = (device_info_pt)fptr->private_data;
-	if(current->pid != current->tgid) {
-		printk(KERN_DEBUG "%s:%d thread exit pid=%d tgid=%d\n",
-		       __FUNCTION__, __LINE__, current->pid, current->tgid);
-		return 0;
-	}
-
-	if(dinfo) {
-		fptr->private_data = NULL;
-		spin_lock_bh(&dinfo->mem_lock);
-		proc_info = find_proc_memlist(dinfo);
-		if(proc_info) {
-			/* dequeue proc_info */
-			proc_info->elem.prev->next = proc_info->elem.next;
-			proc_info->elem.next->prev = proc_info->elem.prev;
-			proc_info->elem.prev = proc_info->elem.next = NULL;
-		}
-		spin_unlock_bh(&dinfo->mem_lock);
-		if (proc_info) free_proc_memlist(dinfo, proc_info);
-	}
-
-#ifdef DEBUG_SYSTEM_CALL
-	printk(KERN_NOTICE "%s:%d pid=%d tgid=%d\n", __FUNCTION__, __LINE__,
-	       current->pid, current->tgid);
-#endif /* DEBUG_SYSTEM_CALL */
-	return 0;
-}
-
-void write_magic(meminfo_pt mem, char __user *buf)
-{
-	uint64_t ptr2 = 0;
-	control_struct_t ctrl;
-	control_struct_t *ptr;
-
-	if(mem->ctx == PROCESS_CTX) {
-		ptr = &ctrl;
-	} else {
-		ptr = mem->ptr;
-	}
-
-	memset(ptr, 0, sizeof(control_struct_t));
-	if(ptr != NULL) {
-		ptr->version = dev_info.version;
-		ptr->owner = current->tgid;
-		if(mem->ctx == PROCESS_CTX && ptr->owner == 0) {
-			printk("%s:%d tgid=0x%x\n", __FUNCTION__, __LINE__,
-			       current->tgid);
-/* 		} else { */
-/* 			printk("%s:%d tgid=0x%x\n", __FUNCTION__, __LINE__, */
-/* 			       current->tgid); */
-		}
-		ptr->magic = DRIVER_MAGIC;
-		if(mem->ctx == PROCESS_CTX) {
-			ptr2 = page_to_pfn((struct page *)(mem->ptr));
-			ptr2 <<= PAGE_SHIFT;
-		} else {
-			ptr2 = virt_to_phys(mem->ptr);
-		}
-		ptr->phy_addr = ptr2;
-		ptr->mem_addr = (uint64_t)((unsigned long)mem);
-		ptr->msg0 = ptr->msg1 = 0ULL;
-	} else {
-		printk(KERN_ALERT "%s:%d mem=%p ctx=%d ptr=NULL\n",
-		       __FUNCTION__, __LINE__, mem, mem->ctx);
-		return;
-	}
-
-	ptr = NULL;
-	if(mem->ctx == PROCESS_CTX) {
-		copy_to_user(buf, &ctrl, sizeof(control_struct_t));
-	}
-
-#ifdef DEBUG_MEMINFO
-	printk(KERN_NOTICE "%s:%d version=%x mem=%p ctx=%d buf=%p mptr=%p "
-	       "ptr2=0x%" LLX_FMT "\n",
-	       __FUNCTION__, __LINE__, dev_info.version, mem, mem?mem->ctx:-1,
-	       buf, mem->ptr, ptr2);
-#endif /* DEBUG_MEMINFO */
-	return;
-}
-
-
-int nlmsec_mmap(struct file *fptr, struct vm_area_struct *vma)
-{
-	proc_memlist_pt proc_info;
-	meminfo_pt mem;
-	device_info_pt dinfo = (device_info_pt)fptr->private_data;
-	int ret = 0;
-	unsigned long pfn;
-//	unsigned long flags;
-
-	if(!dinfo) {
-		printk(KERN_NOTICE "%s:%d pid=%d tgid=%d ftpr=%p\n",
-		       __FUNCTION__, __LINE__, current->pid, current->tgid, fptr);
-		return -EINVAL;
-	}
-#ifdef DEBUG_SYSTEM_CALL
-	printk(KERN_NOTICE "%s:%d pid=%d tgid=%d ftpr=%p\n",
-	       __FUNCTION__, __LINE__, current->pid, current->tgid, fptr);
-#endif /* DEBUG_SYSTEM_CALL */
-
-	spin_lock_bh(&dinfo->mem_lock);
-
-	proc_info = find_proc_memlist(dinfo);
-#ifdef SAE_STATS
-#ifdef SYSTEM_CALL_STATS
-	dinfo->mmapcnt[hard_smp_processor_id()]++;
-#endif /* SYSTEM_CALL */
-#endif /* SAE_STATS */
-	spin_unlock_bh(&dev_info.mem_lock);
-
-	if(proc_info == NULL) {
-		proc_info = (proc_memlist_pt)kmalloc(sizeof(proc_memlist_t),
-						     GFP_KERNEL);
-		if(proc_info != NULL) {
-			INIT_SECOP_QUEUE(&proc_info->async_queue, -1);
-			proc_info->tgid = current->tgid;
-			INIT_LIST_HEAD(&proc_info->mem);
-			insert_proc_memlist(dinfo, proc_info);
-		} else {
-			printk("%s:%d Error allocating proc_memlist.\n",
-			       __FUNCTION__, __LINE__);
-			ret = -ENOMEM;
-			goto bail;
-		}
-	}
-
-	mem = alloc_meminfo_process_ctx(proc_info, vma);
-	if(mem == NULL) {
-		printk("%s:%d Error allocating meminfo.\n", __FUNCTION__,
-		       __LINE__);
-		ret = -ENOMEM;
-		goto bail;
-	}
-
-	spin_lock_bh(&dinfo->mem_lock);
-	insert_meminfo(proc_info, mem);
-#if 1
-	pfn = page_to_pfn((struct page *)mem->ptr);
-	if((ret = remap_pfn_range(vma, vma->vm_start,
-				  pfn, vma->vm_end - vma->vm_start,
-				  vma->vm_page_prot)) < 0) {
-		printk("%s:%d ret=%d\n", __FUNCTION__, __LINE__, ret);
-	}
-//	printk("%s:%d pfn=0x%lx page=%p\n", __FUNCTION__, __LINE__, pfn, mem->ptr);
-#endif
-	spin_unlock_bh(&dinfo->mem_lock);
-
-
- bail:
-	return ret;
-}
-
-/*
- * Send the operation pointed by meminfo to the crypto engine.
- * Params:
- * mem - Memory structure where the operation exists
- * allow_sync - If asynchronous dispatch of this operation is allowed
- * Returns:
- * EAGAIN         : if the operation could not be sent to security engine
- *                  due to credit failure
- * NLMSAE_SUCCESS : If the operation succeded
- */
-
-int send_to_sae(meminfo_pt mem, int allow_async)
-{
-	device_info_pt dinfo = &dev_info;
-	int ret = NLMSAE_SUCCESS;
-	int cs, stid;
-	unsigned long flags;
-	OpType_t op_type = mem->op_type;
-	struct msgrng_msg msg = {0ULL};
-	unsigned int t, hcpuid;
-	int in_asi = (in_atomic() || in_softirq() || in_interrupt());
-
-	if ((op_type != NLM_CRYPTO_OP) && (op_type != NLM_RSA_OP) &&
-	    (op_type != NLM_ECC_OP)) {
-		printk(KERN_ALERT "%s:%d Invalid op_type=%d mem=%p page=%p\n",
-		       __FUNCTION__, __LINE__, op_type, mem, mem->ptr);
-		return -EINVAL;
-	}
-
-	do {
-		cs = alloc_op_slot(dinfo, mem);
-		if(cs < 0) {
-			if(!in_asi &&
-			   waitqueue_active(op_data[op_type].wq)) {
-				init_waitqueue_entry(&mem->wqe, current);
-				add_wait_queue_exclusive(&mem->wq, &mem->wqe);
-				schedule_timeout(1);
-				remove_wait_queue(op_data[op_type].wq,
-						  &mem->wqe);
-			}
-		}
-	} while(cs < 0);
-
-	/* set response bucket and callslot.  That's the only
-	 * information userspace driver can't set.
-	 */
-	msg.msg0 = mem->msg0;
-	msg.msg1 = mem->msg1;
-
-	if(op_type == NLM_CRYPTO_OP) {
-		SET_CTRL_SCRATCH_VALUE(msg.msg0, cs);
-		SET_DATA_SCRATCH_VALUE(msg.msg1, cs);
-	} else if(op_type == NLM_RSA_OP || op_type == NLM_ECC_OP) {
-		/* bit 3 needs to be set to 1 for public key ops */
-		SET_CTRL_PK_SCRATCH_VALUE(msg.msg0, cs);
-		SET_DATA_PK_SCRATCH_VALUE(msg.msg1, cs);
-	}
-
-	stid = op_data[op_type].stid;
-
-	if(is_xls() && op_type != NLM_CRYPTO_OP) {
-		stid = MSGRNG_STNID_XLS_PK0;
-	}
-
-
-#ifdef DEBUG_MSGRNG
-	printk(KERN_NOTICE "%s:%d stid=%d ctrl_msg=0x%016" LLX_FMT
-	       " data_msg=0x%016" LLX_FMT " mem=%p cs=0x%x op_type=%d\n",
-	       __FUNCTION__, __LINE__, stid, msg.msg0, msg.msg1, mem,
-	       cs, op_type);
-#endif /* DEBUG_MSGRNG */
-
-	mem->resp0 = mem->resp1 = 0ULL;
-	mem->in_progress = IN_PROGRESS;
-
-	if(!in_asi) {
-		init_waitqueue_entry(&mem->wqe, current);
-		add_wait_queue(&mem->wq, &mem->wqe);
-	}
-
-	do {
-		t = 0;
-		msgrng_access_enable(flags);
-		hcpuid = hard_smp_processor_id();
-		remote_napi_poll_upper();
-		SET_FREEBACK_STN(msg.msg1, (cpu_to_frstid[hcpuid]));
-
-		ret = message_send_fast_2(0, stid, msg.msg0, msg.msg1);
-		if(ret != 0) {
-#ifdef DEBUG
-			printk(KERN_WARNING "%s:%d Error returned=%d cs=%d op_type=%d\n",
-			       __FUNCTION__, __LINE__, ret, cs, op_type);
-#endif /* DEBUG */
-#ifdef SAE_STATS
-			wait_count[hcpuid]++;
-#endif /* SAE_STATS */
-			if(allow_async && IS_ASYNC_OP(mem)) {
-				msgrng_access_disable(flags);
-				clear_op_slot(dinfo, op_type, cs);
-				ret = -EAGAIN;
-				mem->in_progress = NOT_IN_PROGRESS;
-				goto out;
-			} else {
-				if(++t == 100000) {
-					printk(KERN_WARNING
-					       "%s:%d Waiting to send message to SAE "
-					       "op_type=%d stid=%x ret=0x%x\n",
-					       __FUNCTION__, __LINE__, op_type, stid, ret);
-					t = 0;
-				}
-			}
-		}
-		msgrng_access_disable(flags);
-	} while(ret);
-#ifdef SAE_STATS
-	msgs_sent[hcpuid]++;
-#endif
-	t = 0;
-
-	// wait only if the ASYNC flag is not set
-	if(!IS_ASYNC_OP(mem)) {
-		if(op_type == NLM_CRYPTO_OP) {
-			while(IS_IN_PROGRESS(mem)) {
-				if(dinfo->crypto_used_slots.counter > 60 && !in_asi) {
-					schedule();
-				}
-				msgrng_access_enable(flags);
-				remote_napi_poll_upper();
-				msgrng_access_disable(flags);
-				if(++t == 10000000) {
-					printk("Stuck here\n");
-					t = 0;
-				}
-			}
-		} else {
-			while(IS_IN_PROGRESS(mem)) {
-				if(dinfo->pk_used_slots > 4 && !in_asi) {
-					schedule();
-				}
-				if(++t == 10000000) {
-					printk("Stuck here\n");
-					t = 0;
-				}
-				msgrng_access_enable(flags);
-				remote_napi_poll_upper();
-				msgrng_access_disable(flags);
-			}
-
-#if 0
-			printk("%s:%d th=%p qh=%p wq_active=%d\n",
-			       __FUNCTION__, __LINE__, mem->wqe.task_list.next,
-			       op_data[op_type].wq,
-			       waitqueue_active(op_data[op_type].wq));
-			printk("%s:%d qh=%p\n", __FUNCTION__, __LINE__,
-			       op_data[op_type].wq);
-#endif
-		}
-		ret = mem->result;
-	}
-
- out:
-	if(!in_asi) {
-		remove_wait_queue(&mem->wq, &mem->wqe);
-	}
-	return ret;
-}
-
-#if 0
-static void print_meminfo_proclist(device_info_pt dinfo)
-{
-	proc_memlist_pt proc_info;
-	memlist_pt tmp;
-	meminfo_pt mem;
-
-	spin_lock_bh(&dinfo->mem_lock);
-	proc_info = find_proc_memlist(dinfo);
-	if (proc_info) {
-		list_for_each(tmp, &proc_info->mem) {
-			mem = (meminfo_pt)tmp;
-			printk(KERN_ALERT "[%s:%d] magic=%llx op_type=%x mem=%p page=%p, "
-			       "msg0=%" LLX_FMT ", msg1=%" LLX_FMT "\n",
-			       __FUNCTION__, __LINE__, mem->magic, mem->op_type,
-			       mem, mem->ptr, mem->msg0, mem->msg1);
-		}
-	}
-	spin_unlock_bh(&dinfo->mem_lock);
-}
-#endif
-
-static long
-nlmsec_ioctl(struct file *fptr, unsigned int type, unsigned long val)
-{
-	char __user *buf = (char __user *)val;
-	device_info_pt dinfo = (device_info_pt)fptr->private_data;
-	proc_memlist_pt proc_info;
-	meminfo_pt mem = NULL;
-	int ret = 0;
-
-	if(type == NLMSEC_IOCTL_GET_MEMINFO) {
-		spin_lock_bh(&dinfo->mem_lock);
-		proc_info = find_proc_memlist(dinfo);
-
-		mem = find_meminfo_for_virt_addr(proc_info, val);
-		if(mem) {
-			write_magic(mem, buf);
-		} else {
-			ret = -2;
-		}
-		spin_unlock_bh(&dinfo->mem_lock);
-	} else {
-		ret = -1;
-	}
-
-#ifdef DEBUG
-	printk("%s:%d type=%d val=%lx ret=%d\n", __FUNCTION__, __LINE__, type, val, ret);
-#endif /* DEBUG */
-	return ret;
-}
-
-// no range checking... Take care while calling this function
-void xlr_inc_enc_stat(int cipher_algo, int cipher_mode, int data_size)
-{
-	int cpu = hard_smp_processor_id();
-
-	if(cipher_algo != CIPHER_BYPASS) {
-		cipher_cnt[cpu][cipher_algo][cipher_mode]++;
-		cipher_data_cnt[cpu][cipher_algo][cipher_mode] += data_size;
-	}
-}
-
-// no range checking... Take care while calling this function
-void xlr_inc_auth_stat(int hash_algo, int data_size)
-{
-	int cpu = hard_smp_processor_id();
-
-	if(hash_algo != HASH_BYPASS) {
-		hash_cnt[cpu][hash_algo]++;
-		hash_data_cnt[cpu][hash_algo] += data_size;
-	}
-}
-
-void
-add_stats_count(control_struct_pt ctrl, int cpu)
-{
-	if(ctrl->op_type == NLM_CRYPTO_OP) {
-		if(ctrl->cipher_algo != CIPHER_BYPASS) {
-			cipher_cnt[cpu][ctrl->cipher_algo][ctrl->cipher_mode]++;
-			cipher_data_cnt[cpu][ctrl->cipher_algo][ctrl->cipher_mode] += ctrl->data_size;
-		}
-
-		if(ctrl->hash_algo != HASH_BYPASS) {
-			hash_cnt[cpu][ctrl->hash_algo]++;
-			hash_data_cnt[cpu][ctrl->hash_algo] += ctrl->data_size;
-		}
-	}
-
-	if(ctrl->op_type == NLM_RSA_OP) {
-		if(ctrl->rsa_algo == BIT_512 ||
-		   ctrl->rsa_algo == BIT_1024) {
-			mod_exp_cnt[cpu][ctrl->rsa_algo - 1]++;
-		}
-	}
-
-	if(ctrl->op_type == NLM_ECC_OP) {
-		if(ctrl->ecc_degree < NLM_ECC_PRIME_CURVE_MAX) {
-			ecc_prime_cnt[cpu][ctrl->ecc_degree][ctrl->ecc_algo]++;
-		} else {
-			ecc_binary_cnt[cpu][ctrl->ecc_degree -
-					    NLM_ECC_BINARY_163][ctrl->ecc_algo]++;
-		}
-	}
-
-	return;
-}
-
-static ssize_t
-nlmsec_read(struct file *fptr, char __user *cptr, size_t size,
-	     loff_t *off)
-{
-	uint64_t magic;
-	pid_t owner_pid;
-	int ret = 0;
-	meminfo_pt mem = NULL;
-	device_info_pt dinfo = (device_info_pt)fptr->private_data;
-	control_struct_t ctrl;
-	int async = 0;
-
-	if(size != sizeof(control_struct_t)) {
-		printk(KERN_ALERT "%s:%d Incorrect operation attempted.\n",
-		       __FUNCTION__, __LINE__);
-		return -EFAULT;
-	}
-
-	copy_from_user(&ctrl, cptr, sizeof(control_struct_t));
-
-	if(ctrl.magic != DRIVER_MAGIC) {
-		printk(KERN_ALERT "%s:%d Invalid call to write system call id=%"
-		       LLX_FMT "\n",
-		       __FUNCTION__, __LINE__, ctrl.magic);
-		return -EINVAL;
-	}
-
-
-	mem = (meminfo_pt)((unsigned long)ctrl.mem_addr);
-
-#ifdef DEBUG
-	printk(KERN_NOTICE "%s:%d tgid=0x%x pid=0x%x ptr=%p size=%u magic=%llx "
-	       "owner=0x%x mem=%p\n",
-	       __FUNCTION__, __LINE__, current->tgid, current->pid, cptr,
-	       (unsigned int)size, ctrl.magic, ctrl.owner, mem);
-#endif /* DEBUG */
-
-	spin_lock_bh(&dinfo->mem_lock);
-
-	if(mem == NULL || mem->ptr == NULL || mem->magic != DRIVER_MAGIC) {
-		printk(KERN_ALERT "%s:%d Unknown operation structure mem=%p magic=%llx\n",
-		       __FUNCTION__, __LINE__, mem, mem?mem->magic:0ULL);
-
-//		print_meminfo_proclist(dinfo);
-		ret = -EINVAL;
-		goto bail;
-	}
-
-	if(mem->owner != current->tgid) {
-		printk(KERN_ALERT "%s:%d The memory region was allocated by "
-		       "another process pid=%d and now being accessed by process %d",
-		       __FUNCTION__, __LINE__, mem->owner, current->tgid);
-		ret = -EFAULT;
-		goto bail;
-	}
-
-	magic = ctrl.magic;
-	mem->msg0 = ctrl.msg0;
-	mem->msg1 = ctrl.msg1;
-	if(async) {
-		mem->op_flags = OP_NO_WAIT;
-	}
-	mem->result = NLMSAE_SUCCESS;
-//	mem->return_queue = proc_info->async_queue;
-//	mem->return_value = proc_info;
-	mem->op_type = ctrl.op_type;
-	mem->in_progress = IN_PROGRESS;
-	owner_pid = ctrl.owner;
- bail:
-	spin_unlock_bh(&dinfo->mem_lock);
-	if(ret) {
-		printk("%s:%d Aborting operation due to error=%d\n",
-		       __FUNCTION__, __LINE__, ret);
-		return ret;
-	}
-
-	ret = -1;
-	/* Check magic of the memory passed to kernel */
-	if ((magic != DRIVER_MAGIC) || (current->tgid != owner_pid) ||
-	     ((mem->op_type != NLM_CRYPTO_OP) &&
-	      (mem->op_type != NLM_RSA_OP) && (mem->op_type != NLM_ECC_OP))) {
-
-		printk(KERN_ALERT "%s:%d magic=%" LLX_FMT
-		       " pid=0x%x owner=0x%x op_type=%x mem=%p page=%p, msg0=%" LLX_FMT
-		       ", msg1=%" LLX_FMT "\n", __FUNCTION__, __LINE__, magic,
-		       current->tgid, owner_pid, mem->op_type, mem, mem->ptr,
-		       mem->msg0, mem->msg1);
-		mem->in_progress = NOT_IN_PROGRESS;
-		return -EFAULT;
-	}
-
-	ret = send_to_sae(mem, async);
-
-#ifdef DEBUG_3
-	copy_from_user(&junk_buf[0], cptr, 4096);
-	print_4k(&junk_buf[0], 0);
-#endif /* DEBUG_2 */
-	if(IS_SUCCESS_SAEOP(ret)) {
-		add_stats_count(&ctrl, hard_smp_processor_id());
-		/* copying response back */
-		ctrl.msg0 = mem->resp0;
-		ctrl.msg1 = mem->resp1;
-		copy_to_user(cptr, &ctrl, sizeof(control_struct_t));
-		ret = mem->result;
-	}
-
-	return ret;
-}
-
-struct file_operations fops = {
-    .owner = THIS_MODULE,
-    .open = nlmsec_open,
-    .mmap = nlmsec_mmap,
-    .read = nlmsec_read,
-//    .write = nlmsec_write,
-
-    .unlocked_ioctl = nlmsec_ioctl,
-//    .flush = nlmsec_flush,
-    .release = nlmsec_release,
-};
-
-static int
-print_stats_info(device_info_pt dinfo, char *buf, int size)
-{
-	int i, x, t = size, p, q;
-	uint64_t m_sent = 0, r_received = 0, w_count = 0;
-	uint64_t c_cnt[MAX_CIPHER_ALGO][MAX_CIPHER_MODE] = {{0}};
-	uint64_t c_data_cnt[MAX_CIPHER_ALGO][MAX_CIPHER_MODE] = {{0}};
-	uint64_t h_cnt[MAX_HASH_ALGO] = {0};
-	uint64_t h_data_cnt[MAX_HASH_ALGO] = {0};
-	uint64_t m_exp_cnt[2] = {0};
-	uint64_t ec_p_cnt[NLM_ECC_PRIME_CURVE_MAX][NLM_ECC_PRIME_OP_MAX] = {{0}};
-	uint64_t ec_b_cnt[NLM_ECC_BINARY_CURVE_MAX][NLM_ECC_BINARY_OP_MAX] = {{0}};
-
-#ifdef SYSTEM_CALL_STATS
-	uint64_t map_cnt = 0, map_free = 0;
-#endif /* SYSTEM_CALL_STATS */
-	x = snprintf(buf, t, "CPU\t\tSent\t\tReceived\n");
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-
-	for(i = 0; i < NR_CPUS; ++i) {
-		x = snprintf(buf, t, "%d\t\t%" LLU_FMT "\t\t%" LLU_FMT "\n", i,
-			     msgs_sent[i], resp_recieved[i]);
-		t -= x;
-		buf += x;
-		if(t <= 0) {
-			goto end;
-		}
-
-		m_sent += msgs_sent[i];
-		r_received += resp_recieved[i];
-		w_count += wait_count[i];
-		for(p = 1; p < MAX_CIPHER_ALGO; ++p) {
-			for(q = 0; q < MAX_CIPHER_MODE; ++q) {
-				if(valid_cipher_algo_mode_matrix[p][q]) {
-					c_cnt[p][q] += cipher_cnt[i][p][q];
-					c_data_cnt[p][q] += cipher_data_cnt[i][p][q];
-//					cipher_cnt[i][p][q] = cipher_data_cnt[i][p][q] = 0;
-				}
-			}
-		}
-
-		for(p = 1; p < MAX_HASH_ALGO-2; ++p) {
-			h_cnt[p] += hash_cnt[i][p];
-			h_data_cnt[p] += hash_data_cnt[i][p];
-//			hash_cnt[i][p] = hash_data_cnt[i][p] = 0;
-		}
-
-		if(is_xls()) {
-			for(p = NLM_ECC_PRIME_160;
-			    p < NLM_ECC_PRIME_CURVE_MAX; ++p) {
-				for(q = NLM_ECC_PRIME_P_MUL; q < NLM_ECC_PRIME_OP_MAX;
-				    ++q) {
-					ec_p_cnt[p][q] += ecc_prime_cnt[i][p][q];
-//					ecc_prime_cnt[i][p][q] = 0;
-				}
-			}
-
-			for(p = 0; p < NLM_ECC_BINARY_CURVE_MAX; ++p) {
-				for(q = NLM_ECC_BINARY_P_MUL;
-				    q < NLM_ECC_BINARY_OP_MAX; ++q) {
-					ec_b_cnt[p][q] += ecc_binary_cnt[i][p][q];
-//					ecc_binary_cnt[i][p][q] = 0;
-				}
-			}
-		}
-#ifdef SYSTEM_CALL_STATS
-		map_cnt += mmapcnt[i];
-		map_free += mmapfree[i];
-		mmapcnt[i] = mmapfree[i] =
-#endif /* SYSTEM_CALL_STATS */
-//			wait_count[i] =
-//			msgs_sent[i] =
-//			resp_recieved[i] = 0;
-	}
-
-	x = snprintf(buf, t, "Total msgs\t\t%"LLU_FMT "\t\t%" LLU_FMT "\n",
-		     m_sent, r_received);
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-
-	x = snprintf(buf, t, "Cipher Algorithms:\n");
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-
-	for(p = 1; p < MAX_CIPHER_ALGO; ++p) {
-		for(q = 0; q < MAX_CIPHER_MODE; ++q) {
-			if(valid_cipher_algo_mode_matrix[p][q] && c_cnt[p][q]) {
-				x = snprintf(buf, t,
-					     "%11s-%-4s Count: %16" LLU_FMT
-					     " Size: %16" LLU_FMT "\n",
-					     cipher_str[p], mode_str[q], c_cnt[p][q],
-					     c_data_cnt[p][q]);
-				t -= x;
-				buf += x;
-				if(t <= 0) {
-					goto end;
-				}
-			}
-		}
-	}
-
-	x = snprintf(buf, t, "Hash Algorithms:\n");
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-
-	for(p = 1; p < MAX_HASH_ALGO - 2; ++p) {
-		if(h_cnt[p]) {
-			x = snprintf(buf, t, "%11s Count: %16" LLU_FMT " Size: %16"
-				     LLU_FMT "\n", hash_str[p],
-				     h_cnt[p], h_data_cnt[p]);
-			t -= x;
-			buf += x;
-			if(t <= 0) {
-				goto end;
-			}
-		}
-	}
-
-	x = snprintf(buf, t, "RSA Mod Exp Algorithms:\n");
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-
-	for(p = BIT_512; p < BIT_SIZE_MAX; ++p) {
-		for(i = 0; i < NR_CPUS; ++i) {
-			m_exp_cnt[p-1] += mod_exp_cnt[i][p-1];
-//			mod_exp_cnt[i][p-1] = 0;
-		}
-		if(m_exp_cnt[p-1]) {
-			x = snprintf(buf, t, "%11s: %11" LLU_FMT "\n",
-				     rsa_mod_str[p-1], m_exp_cnt[p-1]);
-			t -= x;
-			buf += x;
-			if(t <= 0) {
-				goto end;
-			}
-		}
-	}
-
-	if(is_xls()) {
-		x = snprintf(buf, t, "ECC Algorithms:\n");
-		t -= x;
-		buf += x;
-		if(t <= 0) {
-			goto end;
-		}
-
-
-		for(p = NLM_ECC_PRIME_160;
-		    p < NLM_ECC_PRIME_CURVE_MAX; ++p) {
-			for(q = NLM_ECC_PRIME_P_MUL; q < NLM_ECC_PRIME_OP_MAX;
-			    ++q) {
-				if(ec_p_cnt[p][q]) {
-					x = snprintf(buf, t,
-						     "%11s-%-11s: %11" LLU_FMT "\n",
-						     ecc_prime_curve_str[p],
-						     ecc_prime_func_str[q],
-						     ec_p_cnt[p][q]);
-					t -= x;
-					buf += x;
-					if(t <= 0) {
-						goto end;
-					}
-				}
-			}
-		}
-
-		for(p = 0; p < NLM_ECC_BINARY_CURVE_MAX; ++p) {
-			for(q = NLM_ECC_BINARY_P_MUL;
-			    q < NLM_ECC_BINARY_OP_MAX; ++q) {
-				if(ec_b_cnt[p][q]) {
-					x = snprintf(buf, t,
-						     "%11s-%-11s: %11" LLU_FMT "\n",
-						     ecc_binary_curve_str[p],
-						     ecc_binary_func_str[q],
-						     ec_b_cnt[p][q]);
-					t -= x;
-					buf += x;
-					if(t <= 0) {
-						goto end;
-					}
-				}
-			}
-		}
-	}
-
-	x = snprintf(buf, t, "Current Crypto outstanding msg=%u\n", dinfo->crypto_used_slots.counter);
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-
-	x = snprintf(buf, t, "Max Crypto outstanding msg=%u\n", dinfo->max_crypto_used_slots);
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-//	dinfo->max_crypto_used_slots = 0;
-
-	x = snprintf(buf, t, "Current Pk outstanding msg=%u\n", dinfo->pk_used_slots);
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-
-	x = snprintf(buf, t, "Max Pk outstanding msg=%u\n", dinfo->max_pk_used_slots);
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-//	dinfo->max_pk_used_slots = 0;
-
-	x = snprintf(buf, t, "Wait count =%"LLU_FMT "\n", w_count);
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-
-	x = snprintf(buf, t, "VMA count =%u\n", vma_count.counter);
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-//	vma_count.counter = 0;
-
-#ifdef SYSTEM_CALL_STATS
-	x = snprintf(buf, t, "MMap count =%"LLU_FMT "\n", map_cnt);
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-
-	x = snprintf(buf, t, "MMap free =%"LLU_FMT "\n", map_free);
-	t -= x;
-	buf += x;
-	if(t <= 0) {
-		goto end;
-	}
-#endif /* SYSTEM_CALL_STATS */
- end:
-	return size - t;
-}
-
-#ifdef ENABLE_DEBUG_PROC
-static int
-print_page_info(device_info_pt dinfo, char *buf, int size)
-{
-	proc_memlist_pt proc_info;
-	memlist_pt m;
-	meminfo_pt mem;
-	int t = size, x;
-
-	if(!spin_trylock_bh(&dinfo->mem_lock)) {
-		return snprintf(buf, t, "Lock not acquired.  Please try later.\n");
-	}
-
-	x = snprintf(buf, t, "Build version: %s\n", versionstr);
-	t -= x;
-	buf += x;
-
-	x = snprintf(buf, t, "pid\torder\tpage addr\t\tpfn\n");
-	t -= x;
-	buf += x;
-
-	proc_info = (proc_memlist_pt)dinfo->pmem_list.next;
-	while(proc_info != (proc_memlist_pt)&dinfo->pmem_list) {
-		list_for_each(m, &proc_info->mem) {
-			mem = (meminfo_pt)m;
-			x = snprintf(buf, t, "%d\t%d\t%p\t\t%lx\n", proc_info->tgid,
-				     mem->order, mem->ptr,
-				     page_to_pfn((struct page *)(mem->ptr)));
-			t -= x;
-			buf += x;
-			if(t <= 0) {
-				break;
-			}
-		}
-		proc_info = (proc_memlist_pt)proc_info->elem.next;
-	}
-
-	spin_unlock_bh(&dinfo->mem_lock);
-	return size - t;
-}
-#endif /* ENABLE_DEBUG_PROC */
-
-static inline
-meminfo_pt get_meminfo(device_info_pt dinfo, uint64_t msg0, uint64_t msg1)
-{
-#define CRYPTO_SCRATCH_VALUE(x,y)     ((((x) & 0xfULL) << 5) | \
-				       ((y) & 0x1fULL))
-
-#define PK_SCRATCH_VALUE(x,y)         ((((x) & 0x8ULL) >> 1) | \
-				       (((y) >> 3) & 0x3ULL))
-	int cs;
-	meminfo_pt mem = NULL;
-
-	if(msg0 & 0x10) {  /* PK OP Condition */
-		cs = PK_SCRATCH_VALUE(msg0, msg1);
-		mem = dinfo->pk_ops_slot[cs];
-		dinfo->pk_ops_slot[cs] = NULL;
-		clear_op_slot(dinfo, NLM_RSA_OP, cs);
-	} else { /* Crypto Condition */
-		cs = CRYPTO_SCRATCH_VALUE(msg0, msg1);
-		mem = dinfo->crypto_ops_slot[cs];
-		dinfo->crypto_ops_slot[cs] = NULL;
-		clear_op_slot(dinfo, NLM_CRYPTO_OP, cs);
-	}
-
-	/* Added this to catch a problem observed a few times when
-	 * response comes back, but mem ptr is NULL. */
-	if(mem == NULL) {
-		int i;
-		printk("%s:%d MEMPTR is NULL. OpType=%" LLX_FMT " msg0=%" LLX_FMT " msg1=%"
-		       LLX_FMT " cs=%d mem=%p\n",
-		       __FUNCTION__, __LINE__, (msg0 & 0x10), msg0, msg1, cs, mem);
-		if(msg0 & 0x10) {
-			for(i = 0; i < 8; ++i) {
-				printk("%d=[%p] ", i, dinfo->pk_ops_slot[i]);
-			}
-		} else {
-			for(i = 0; i < 8; ++i) {
-				printk(" %d=[%p] ", i,
-				       dinfo->crypto_ops_slot[i]);
-			}
-		}
-		printk("\n");
-	}
-
-	return mem;
-}
-
-void nlmsec_msgring_handler(int bucket, int size, int code, int stid,
-                            struct msgrng_msg *msg, void *data)
-{
-	device_info_pt dinfo = (device_info_pt)data;
-	volatile meminfo_pt mem;
-	int ret = NLMSAE_SUCCESS;
-	control_struct_pt ctrl;
-#ifdef SAE_STATS
-	resp_recieved[hard_smp_processor_id()]++;
-#endif /* SAE_STATS */
-
-#ifdef DEBUG_MSGRNG
-	printk("%s:%d msg0=%016" LLX_FMT " msg1=%016" LLX_FMT "\n", __FUNCTION__,
-	       __LINE__, msg->msg0, msg->msg1);
-#endif
-
-	if(CTRL_HEAD(msg->msg0) != 2ULL ||
-	   CTRL_DEST_CTRL(msg->msg0) != 6ULL ||
-	   DATA_HEAD(msg->msg1) != 2ULL ||
-	   DATA_DEST_CTRL(msg->msg1) != 5ULL ||
-	   CTRL_ERROR(msg->msg0) != 0ULL ||
-	   DATA_ERROR(msg->msg1) != 0ULL) {
-		printk(KERN_ALERT "%s:%d Invalid/Error response from SAE "
-		       "msg0=%016" LLX_FMT " msg1=%016" LLX_FMT " ctrl_head=%"
-		       LLX_FMT " ctrl_error=%" LLX_FMT " ctrl_ctrl=%" LLX_FMT
-		       " data_head=%" LLX_FMT " data_error=%" LLX_FMT
-		       " dest_ctrl=%" LLX_FMT "\n",
-		       __FUNCTION__, __LINE__,
-		       msg->msg0, msg->msg1, CTRL_HEAD(msg->msg0),
-		       CTRL_ERROR(msg->msg0),
-		       CTRL_DEST_CTRL(msg->msg0), DATA_HEAD(msg->msg1),
-		       DATA_ERROR(msg->msg1), DATA_DEST_CTRL(msg->msg1));
-		ret = -CTRL_ERROR(msg->msg0);
-		if(!ret)
-			ret = -DATA_ERROR(msg->msg1);
-	}
-
-#if 0
-	if(dinfo != &dev_info) {
-		printk(KERN_ALERT
-		       "%s:%d Error returning handler data=%p dev_info=%p\n",
-		       __FUNCTION__, __LINE__, data, &dev_info);
-		dinfo = &dev_info;
-	}
-#endif
-
-	mem = get_meminfo(dinfo, msg->msg0, msg->msg1);
-#ifdef DEBUG_MSGRNG
-	printk(KERN_NOTICE "%s:%d stid=%d code=%d meminfo=%p\n",
-	       __FUNCTION__, __LINE__, stid, code, mem);
-#endif /* DEBUG_MSGRNG */
-
-	if(mem != NULL && mem->magic == DRIVER_MAGIC) {
-		mem->resp0 = msg->msg0;
-		mem->resp1 = msg->msg1;
-
-		if(mem->ctx == PROCESS_CTX) {
-			mem->resp0 = msg->msg0;
-			mem->resp1 = msg->msg1;
-		} else if(mem->ctx == KERNEL_CTX) {
-			ctrl = (control_struct_pt)(mem->ptr);
-//			magic = ctrl->magic;
-			ctrl->msg0 = msg->msg0;
-			ctrl->msg1 = msg->msg1;
-		}
-
-		ctrl = NULL;
-
-		mem->result = ret;
-
-		if(IS_ASYNC_OP(mem)) {
-			add_meminfo_to_queue(mem->return_queue, mem);
-		} else {
-			if(waitqueue_active(&mem->wq)) {
-				wake_up(&mem->wq);
-			}
-
-			if(waitqueue_active(op_data[mem->op_type].wq)) {
-				wake_up_interruptible(op_data[mem->op_type].wq);
-			}
-		}
-
-		mem->in_progress = NOT_IN_PROGRESS;
-		wmb();
-
-#if 0
-		if(unlikely(magic != DRIVER_MAGIC)) {
-			printk(KERN_ALERT "%s:%d Invalid magic=%" LLX_FMT " mem=%p\n",
-			       __FUNCTION__, __LINE__, magic, mem);
-		}
-#endif
-
-#ifdef DEBUG
-	} else {
-		printk(KERN_NOTICE "%s:%d Operation completed but, "
-		       "no meminfo found.\n", __FUNCTION__, __LINE__);
-#endif /* DEBUG */
-	}
-
-	return;
-}
-
-static int
-nlmsec_read_stats_proc(char *page, char **start, off_t offset, int count,
-		       int *eof, void *data)
-{
-	device_info_pt dinfo = (device_info_pt)data;
-	int len = 0;
-	if(offset == 0) {
-		len = print_stats_info(dinfo, page, count);
-	}
-	*eof = 1;
-	return len;
-}
-
-#ifdef ENABLE_DEBUG_PROC
-static int
-nlmsec_read_proc(char *page, char **start, off_t offset, int count,
-		 int *eof, void *data)
-{
-	device_info_pt dinfo = (device_info_pt)data;
-	int len = 0;
-	if(offset == 0) {
-		len = print_page_info(dinfo, page, count);
-	}
-	*eof = 1;
-	return len;
-}
-#endif /* ENABLE_DEBUG_PROC */
-
-static void nlmsec_driver_exit(void)
-{
-	unsigned long flags;
-
-	/* device cleanup */
-	// unregister the character device
-	dev_info.exit_driver = 1;
-	unregister_chrdev_region(dev_info.device, 1);
-
-	cdev_del(&dev_info.nlmsec_cdev);
-
-	// remove proc entries
-	spin_lock_irqsave(&dev_info.mem_lock, flags);
-	remove_proc_entry(stats_name, dev_info.pdir);
-#ifdef ENABLE_DEBUG_PROC
-	remove_proc_entry(debug_name, dev_info.pdir);
-#endif /* ENABLE_DEBUG_PROC */
-	remove_proc_entry(driver_name, (struct proc_dir_entry *)NULL);
-	spin_unlock_irqrestore(&dev_info.mem_lock, flags);
-
-
-	printk(KERN_NOTICE "Unloading driver\n");
-
-	return;
-}
-
-
-static int ecc_init(void)
-{
-	meminfo_t mem;
-	struct page *page;
-	unsigned char *ecc;
-	unsigned long flags, phy;
-
-	memset(&mem, 0, sizeof(meminfo_t));
-
-	mem.msg0 = ecc_msg0;
-	mem.msg1 = ecc_msg1;
-	mem.magic = DRIVER_MAGIC;
-	mem.ctx = INIT_CTX;
-	mem.op_type = NLM_ECC_OP;
-	mem.in_progress = IN_PROGRESS;
-	mem.result = NLMSAE_SUCCESS;
-	mem.return_value = (unsigned long)&mem;
-	init_waitqueue_head(&mem.wq);
-
-	page = alloc_pages(GFP_ATOMIC | __GFP_ZERO, 0);
-
-	local_irq_save(flags);
-	ecc = (unsigned char *)kmap_atomic(page, KM_USER0);
-	mem.ptr = ecc;
-	memcpy(ecc, ecc_uc_data, sizeof(ecc_uc_data));
-	kunmap_atomic(page, KM_USER0);
-	local_irq_restore(flags);
-	ecc = NULL;
-
-	phy = page_to_pfn(page);
-	phy <<= PAGE_SHIFT;
-	SET_SEGMENT_ADDR(mem.msg0, phy);
-	send_to_sae(&mem, 0);
-
-	__free_page(page);
-
-	if(mem.result != NLMSAE_SUCCESS) {
-		printk(KERN_ALERT "%s:%d ECC init failed with error=%x\n", __FUNCTION__,
-		       __LINE__, mem.result);
-		return -1;
-	}
-	return 0;
-}
-
-static int msgring_config_init(void)
-{
-	int i;
-	uint8_t sae_bkt[8];
-	uint8_t sae_crdt[16][8];
-	
-	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_SECURITY_OFFSET);
-
-	netlogic_write_reg(mmio, SEC_DMA_CREDIT, SEC_DMA_CREDIT_CONFIG);
-
-	netlogic_write_reg(mmio, SEC_CONFIG2, SEC_CFG2_ROUND_ROBIN_ON);
-
-
-	if (xlr_hybrid_rmios_ipsec() || xlr_hybrid_rmios_tcpip_stack())
-		return;
-
-	if(dev_tree_en) {
-		if(fdt_get_sae_bucket_conf(sae_bkt, 8, sae_crdt, 128) != 0) {
-			printk("Bucket and credit config failed for sae\n");
-			return -1;
-		}
-		
-		for(i = 0; i < 5; i++)
-			netlogic_write_reg (mmio, SEC_MSG_BUCKET0_SIZE + i, sae_bkt[i]);
-
-		for(i = 0; i < 128; i++)
-			netlogic_write_reg (mmio,  SEC_CC_CPU0_0 + i, sae_crdt[i/8][i%8]);
-
-	} else if (!is_xls()) {
-		for(i = 0; i < 8; i++)
-			netlogic_write_reg (mmio, SEC_MSG_BUCKET0_SIZE + i,
-					   bucket_sizes.bucket[MSGRNG_STNID_SEC + i]);
-		for(i = 0; i < 128; i++)
-			netlogic_write_reg (mmio,  SEC_CC_CPU0_0 + i,
-						   cc_table_sec.counters[i>>3][i&0x07]);
-	} else {
-		for(i = 0; i < 8; i++)
-			netlogic_write_reg (mmio, SEC_MSG_BUCKET0_SIZE + i,
-					   xls_bucket_sizes.bucket[MSGRNG_STNID_SEC + i]);
-		for(i = 0; i < 128; i++)
-			netlogic_write_reg (mmio,  SEC_CC_CPU0_0 + i,
-					   xls_cc_table_sec.counters[i>>3][i&0x07]);
-	}
-	return 0;
-}
-
-extern int xlr_loader_support;
-extern int xlr_loader_sharedcore;
-static int __init nlmsec_driver_init(void)
-{
-    int ret;
-    int major, minor;
-
-    /* In case of RMI CRF, check for ownership */
-    if (dev_tree_en && fdt_get_sae_enabled() == 0)
-	return -ENODEV;
-
-    if ((xlr_loader_support && xlr_loader_sharedcore))
-        return -ENODEV;
-
-    /* init device_info strucuture */
-    memset(&dev_info, 0, sizeof(struct device_info));
-    dev_info.version = MKDEV(2,0);
-
-    /* the pk ops bitmap uses only 8 bits, rest are marked used */
-    dev_info.pk_ops_bitmap = 0xffffff00;
-
-#if 0 /* set this to serialize crypto operations */
-    for(ret = 0; ret < 15; ++ret) {
-	    dev_info.crypto_ops_bitmap[ret] = 0xffffffff;
-    }
-    dev_info.crypto_ops_bitmap[ret] = 0xfffffffe;
-#endif
-
-    init_waitqueue_head(&dev_info.crypto_queue);
-    init_waitqueue_head(&dev_info.pkop_queue);
-    spin_lock_init(&dev_info.pkops_lock);
-    spin_lock_init(&dev_info.crypto_lock);
-
-    spin_lock_init(&dev_info.mem_lock);
-    dev_info.pmem_list.next = &dev_info.pmem_list;
-    dev_info.pmem_list.prev = &dev_info.pmem_list;
-
-    /* registering device */
-    dev_info.device = MKDEV(0, 0);
-    ret = alloc_chrdev_region(&dev_info.device, 0, 1, driver_name);
-    if(ret < 0) {
-	printk(KERN_ALERT "%s:%d device could not get major number\n",
-	       __FILE__, __LINE__);
-	goto bail;
-    }
-
-    major = MAJOR(dev_info.device);
-    minor = MINOR(dev_info.device);
-
-    cdev_init(&dev_info.nlmsec_cdev, &fops);
-    dev_info.nlmsec_cdev.owner = THIS_MODULE;
-
-#ifdef CONFIG_OCF_OCF_MODULE
-    /* create a asyncrhonous queue to process OCF operations */
-    if(nlmsec_create_operation_callback(&dev_info.ocf_cb, nlmsae_ocf_callback)) {
-	    unregister_chrdev_region(dev_info.device, 1);
-	    printk(KERN_ALERT "%s:%d OCF async queue initialization failed.",
-		   __FUNCTION__, __LINE__);
-	    goto bail;
-    }
-
-    softc_device_init(&dev_info.ocf_dev, "nlmsae", 0, nlmsae_methods);
-    dev_info.ocf_id = crypto_get_driverid(softc_get_device(&dev_info.ocf_dev),
-					  CRYPTOCAP_F_HARDWARE);
-    if(dev_info.ocf_id < 0) {
-	    unregister_chrdev_region(dev_info.device, 1);
-	    printk(KERN_ALERT "%s:%d NLMSAE cannot initialize into OCF.",
-		   __FUNCTION__, __LINE__);
-	    goto bail;
-    } else {
-#define	REGISTER(alg) \
-	crypto_register(dev_info.ocf_id,alg,0,0)
-	REGISTER(CRYPTO_DES_CBC);
-	REGISTER(CRYPTO_3DES_CBC);
-	REGISTER(CRYPTO_RIJNDAEL128_CBC);
-	REGISTER(CRYPTO_MD5);
-	REGISTER(CRYPTO_SHA1);
-	REGISTER(CRYPTO_MD5_HMAC);
-	REGISTER(CRYPTO_SHA1_HMAC);
-    }
-#endif /* CONFIG_OCF_OCF_MODULE */
-
-    // create character device
-    ret = cdev_add(&dev_info.nlmsec_cdev, dev_info.device, 1);
-    if(ret < 0) {
-	    unregister_chrdev_region(dev_info.device, 1);
-#ifdef CONFIG_OCF_OCF_MODULE
-	    crypto_unregister_all(dev_info.ocf_id);
-#endif /* CONFIG_OCF_OCF_MODULE */
-	    printk(KERN_ALERT "%s:%d Error adding char driver err=%d.\n",
-		   __FUNCTION__, __LINE__, ret);
-	    goto bail;
-    }
-
-    // initialize the sae configuration
-    msgring_config_init();
-
-    // create proc fs entries
-    dev_info.pdir = proc_mkdir("netlogic/" DRIVER_NAME, NULL);
-    if(dev_info.pdir == NULL)
-    {
-	    printk("%s:%d failed creating proc directory: %s\n",
-		   __FUNCTION__, __LINE__, driver_name);
-	    ret = -ENOMEM;
-	    goto bail;
-    } else {
-#ifdef ENABLE_DEBUG_PROC
-	    dev_info.pdebug = create_proc_read_entry(debug_name, 0, dev_info.pdir,
-						     nlmsec_read_proc,
-						     &dev_info);
-	    if(dev_info.pdebug == NULL) {
-		    remove_proc_entry(driver_name, NULL);
-		    printk("%s:%d failed creating debug entry: %s/%s\n",
-			   __FUNCTION__, __LINE__, driver_name, debug_name);
-		    ret = -EINVAL;
-		    goto bail;
-	    }
-#endif /* ENABLE_DEBUG_PROC */
-
-	    dev_info.pstats = create_proc_read_entry(stats_name, 0, dev_info.pdir,
-						     nlmsec_read_stats_proc,
-						     &dev_info);
-
-	    if(dev_info.pstats == NULL) {
-#ifdef ENABLE_DEBUG_PROC
-		    remove_proc_entry(debug_name, dev_info.pdir);
-#endif /* ENABLE_DEBUG_PROC */
-		    remove_proc_entry("netlogic/" DRIVER_NAME, NULL);
-		    printk("%s:%d failed creating stats entry: %s/%s\n",
-			   __FUNCTION__, __LINE__, driver_name, stats_name);
-		    ret = -EINVAL;
-		    goto bail;
-	    }
-
-    }
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-    if(nlm_on_chip_napi) {
-	    printk(KERN_NOTICE "SAE NAPI-compatible Subsystem.\n");
-    }
-#endif
-
-    // register handler
-    if ((ret = register_msgring_handler(TX_STN_SEC,
-					nlmsec_msgring_handler,
-					&dev_info))) {
-	    nlmsec_driver_exit();
-	    ret = -EINVAL;
-	    goto bail;
-    }
-
-    if(is_xls()) {
-	    ecc_init();
-    }
-
-#ifdef DEBUG
-    printk(KERN_NOTICE "%s:%d SEC handler=%p\n", __FUNCTION__, __LINE__,
-	   nlmsec_msgring_handler);
-#endif /* DEBUG */
-    printk(KERN_NOTICE "Loaded SAE driver version=[%s] major=%d minor=%d\n",
-	   versionstr, major, minor);
-
-    return 0;
- bail:
-    nlmsec_driver_exit();
-    return ret;
-}
-
-/* Queuing functions */
-int nlmsec_op_setup(op_handle_t handle, op_queue_t async_queue,
-		    unsigned long arg, int op_flags)
-{
-	operation_pt op = (operation_pt)handle;
-
-	if(op == NULL)
-		return -1;
-
-	op->return_queue = (secop_queue_pt)async_queue;
-	op->op_flags = op_flags;
-
-	if(op->return_queue != NULL) {
-		op->op_flags |= OP_NO_WAIT;
-	} else {
-		op->op_flags &= ~(OP_NO_WAIT);
-	}
-
-	op->arg = arg;
-	return 0;
-}
-EXPORT_SYMBOL(nlmsec_op_setup);
-
-int
-nlmsec_op_callback_setup(op_handle_t handle, op_callback_t async_callback,
-			     unsigned long arg, int op_flags)
-{
-	return nlmsec_op_setup(handle, (op_queue_t)async_callback, arg, op_flags);
-}
-EXPORT_SYMBOL(nlmsec_op_callback_setup);
-
-int nlmsec_create_operation_queue(op_queue_pt handle)
-{
-	secop_queue_pt ret;
-	gfp_t flg;
-	if(in_atomic() || in_softirq() || in_interrupt()) {
-		flg = GFP_ATOMIC;
-	} else {
-		flg = GFP_KERNEL;
-	}
-
-	ret = (secop_queue_pt)kmalloc(sizeof(secop_queue_t), flg);
-	if(ret == NULL) {
-		return -ENOMEM;
-	}
-	INIT_SECOP_QUEUE(ret, -1);
-	*handle = (op_queue_t)ret;
-
-	return 0;
-}
-EXPORT_SYMBOL(nlmsec_create_operation_queue);
-
-int nlmsec_destroy_operation_queue(op_queue_pt handle)
-{
-	secop_queue_pt ret = (secop_queue_pt)(*handle);
-	if(ret && ret->response_type == SECOP_Q) {
-		if(ret->q.length != 0) {
-			printk(KERN_INFO "%s:%d Error queue not empty: %d\n",
-			       __FUNCTION__, __LINE__, ret->q.length);
-			return -1;
-		}
-
-		kfree(ret);
-		*handle = 0;
-	}
-	return 0;
-}
-EXPORT_SYMBOL(nlmsec_destroy_operation_queue);
-
-int nlmsec_create_operation_callback(op_callback_pt handle,
-				     op_callback_func_t func)
-{
-	secop_queue_pt ret;
-	gfp_t flg;
-	if(in_atomic() || in_softirq() || in_interrupt()) {
-		flg = GFP_ATOMIC;
-	} else {
-		flg = GFP_KERNEL;
-	}
-
-	ret = (secop_queue_pt)kmalloc(sizeof(secop_queue_t), flg);
-	if(ret == NULL) {
-		return -ENOMEM;
-	}
-	INIT_SECOP_CB(ret, func);
-	*handle = (op_queue_t)ret;
-
-	return 0;
-}
-EXPORT_SYMBOL(nlmsec_create_operation_callback);
-
-int nlmsec_destroy_operation_callback(op_callback_pt handle)
-{
-	secop_queue_pt queue = (secop_queue_pt)handle;
-	if(queue && queue->response_type == SECOP_CB) {
-		kfree(queue);
-		*handle = (op_callback_t)NULL;
-	}
-	return 0;
-}
-EXPORT_SYMBOL(nlmsec_destroy_operation_callback);
-
-int nlmsec_op_queue_dequeue(op_queue_t qhandle, int *result, op_handle_pt phandle)
-{
-	secop_queue_pt queue = (secop_queue_pt)qhandle;
-	operation_pt op;
-	meminfo_pt mem = remove_meminfo_from_queue(queue);
-
-	if(mem != NULL) {
-		if(mem->magic == DRIVER_MAGIC) {
-			*result = mem->result;
-			op = (operation_pt)mem->return_value;
-			if(mem->ctx == KERNEL_CTX ) {
-				*result = post_process_op(*result, op);
-			} else {
-				printk(KERN_WARNING "%s:%d Meminfo Not kernel context\n",
-				       __FUNCTION__, __LINE__);
-			}
-			*phandle = (op_handle_t)op;
-			return 0;
-		} else {
-			printk(KERN_WARNING "%s:%d Invalid mem=%p magic=%llx\n",
-			       __FUNCTION__, __LINE__, mem, mem->magic);
-		}
-	}
-	return -1;
-}
-EXPORT_SYMBOL(nlmsec_op_queue_dequeue);
-
-unsigned int nlmsec_op_queue_size(op_queue_t qhandle)
-{
-	int ret = 0;
-	secop_queue_pt queue = (secop_queue_pt)qhandle;
-	if(queue && queue->response_type == SECOP_Q) {
-		ret = queue->q.length;
-	}
-	return ret;
-}
-EXPORT_SYMBOL(nlmsec_op_queue_size);
-
-unsigned long nlmsec_op_get_arg(op_handle_t handle)
-{
-	operation_pt op;
-	if(handle != 0UL) {
-		op = (operation_pt)handle;
-		return op->arg;
-	}
-	return 0;
-}
-EXPORT_SYMBOL(nlmsec_op_get_arg);
-
-module_init(nlmsec_driver_init);
-module_exit(nlmsec_driver_exit);
diff --git a/drivers/i2c/algos/Kconfig b/drivers/i2c/algos/Kconfig
index ccbe357..f1cfe7e 100644
--- a/drivers/i2c/algos/Kconfig
+++ b/drivers/i2c/algos/Kconfig
@@ -11,15 +11,6 @@ config I2C_ALGOBIT
 config I2C_ALGOPCF
 	tristate "I2C PCF 8584 interfaces"
 
-config I2C_ALGOPALM
-        tristate "PalmChip's I2C interfaces"
-        depends on I2C
-        help
-          This allows you to use the BK3220 I2C Host Adapter on the RMI Phoenix.
-
-          This support is also available as a module.  If so, the module
-          will be called i2c-algo-palm.
-
 config I2C_ALGOPCA
 	tristate "I2C PCA 9564 interfaces"
 
diff --git a/drivers/i2c/algos/Makefile b/drivers/i2c/algos/Makefile
index 48e9b8e..215303f 100644
--- a/drivers/i2c/algos/Makefile
+++ b/drivers/i2c/algos/Makefile
@@ -5,6 +5,5 @@
 obj-$(CONFIG_I2C_ALGOBIT)	+= i2c-algo-bit.o
 obj-$(CONFIG_I2C_ALGOPCF)	+= i2c-algo-pcf.o
 obj-$(CONFIG_I2C_ALGOPCA)	+= i2c-algo-pca.o
-obj-$(CONFIG_I2C_ALGOPALM)      += i2c-algo-palm.o
 
 ccflags-$(CONFIG_I2C_DEBUG_ALGO) := -DDEBUG
diff --git a/drivers/i2c/algos/i2c-algo-palm.c b/drivers/i2c/algos/i2c-algo-palm.c
deleted file mode 100644
index 89b23c6..0000000
--- a/drivers/i2c/algos/i2c-algo-palm.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/*********************************************************************
-
-  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
-  reserved.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-  1. Redistributions of source code must retain the above copyright
-  notice, this list of conditions and the following disclaimer.
-  2. Redistributions in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer in
-  the documentation and/or other materials provided with the
-  distribution.
-
-  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
-  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
-  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-  THE POSSIBILITY OF SUCH DAMAGE.
-
-  *****************************#RMI_2#**********************************/
-
-/*
- *  i2c-algo-palm.c i2c driver algorithms for the BK3220 I2C Host 
- *  adapter on the RMI Phoenix System.
- *  Derived from the PCA-ISA I2C-Algo/Bus files.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/spinlock.h>
-#include <linux/i2c.h>
-#include <linux/i2c-algo-palm.h>
-#include <asm/netlogic/i2c-algo-palm.h>
-
-#define DRIVER "i2c-algo-palm"
-
-#define DEB1(fmt, args...) do { if (i2c_debug>=1) printk(fmt, ## args); } while(0)
-#define DEB2(fmt, args...) do { if (i2c_debug>=2) printk(fmt, ## args); } while(0)
-#define DEB3(fmt, args...) do { if (i2c_debug>=3) printk(fmt, ## args); } while(0)
-
-static int i2c_debug=0;
-spinlock_t palm_lock;
-					
-#define palm_write(algo_data, reg, val) 	algo_data->write(reg, val)
-#define palm_read(algo_data, reg) 		algo_data->read(reg)
-
-#define palm_clock(adap) 		adap->get_clock(adap)
-#define palm_status(adap) 		palm_inw(adap, I2C_PCA_STA)
-#define palm_set_con(adap, val) 	palm_outw(adap, I2C_PCA_CON, val)
-#define palm_get_con(adap) 		palm_inw(adap, I2C_PCA_CON)
-
-/*
- * Check if the I2C Bus is idle or busy
- */
-static int wait_for_idle(struct i2c_algo_palm_data *algo_data)
-{
-	int timeOut=0x1000;
-	volatile __u32 regVal=0x00;
-	regVal = palm_read(algo_data, I2C_PALM_STATUS) & 0x0001;
-	while (regVal && timeOut--) {
-		regVal = palm_read(algo_data, I2C_PALM_STATUS) & 0x0001;
-	}
-	if (timeOut == 0x00)
-		return -1;	/* Timed Out */
-	else
-		return 0;
-}
-
-
-static int palm_rx(struct i2c_algo_palm_data *algo_data, __u8 *buf,
-		__u16 addr, __u16 length)
-{
-	volatile __u32 tmp, regVal;
-	int len = length, i;
-
-	if(length == 0) /* special case of I2C_SMBUS_QUICK */ {
-		/* issue a address only transaction */
-		palm_write(algo_data, I2C_PALM_DEVADDR, addr);
-		palm_write(algo_data, I2C_PALM_CFG,     0xfa);
-		palm_write(algo_data, I2C_PALM_STARTXFR,0x3);
-
-		regVal = palm_read(algo_data, I2C_PALM_STATUS);
-		if (regVal & 0x0008) {
-			printk("start quick: ACKERR. Aborting...\n");
-			return -1;
-		}
-		return 0;
-	}
-
-
-	palm_write(algo_data, I2C_PALM_DEVADDR, addr);
-	palm_write(algo_data, I2C_PALM_CFG,     0xfa);
-	palm_write(algo_data, I2C_PALM_BYTECNT, len-1);
-	palm_write(algo_data, I2C_PALM_STARTXFR,0x1);
-
-
-	regVal = palm_read(algo_data, I2C_PALM_STATUS);
-	if (regVal & 0x0008) {
-		printk("start read: ACKERR. Aborting...\n");
-		return -1;
-	}
-
-	for(tmp=0; tmp < len; tmp++) {
-		i = 0;
-		while(1) {
-			regVal = palm_read(algo_data, I2C_PALM_STATUS);
-			if (regVal & 0x4) {
-				buf[tmp] = (__u8)palm_read(algo_data, 
-							I2C_PALM_DATAIN);
-				break;
-
-			}
-			mdelay(1);
-			i++;
-			if (i >= 1000) {
-				printk("* read Timed OUT byte %d.\n", tmp);
-				return -1;
-			}
-		}
-	}
-	return 0;
-}
-
-
-
-
-static int palm_tx(struct i2c_algo_palm_data *algo_data,  __u16 len, 
-		__u8 *buf, __u16 addr)
-{
-	volatile __u32 tmp, regVal;
-	int i;
-
-	if (wait_for_idle(algo_data) < 0) {
-		printk("TimedOut on Waiting for I2C Bus Idle.\n");
-		return -1;
-	}
-
-	if(len == 0) { /* special case of I2C_SMBUS_QUICK */
-		/* issue a address only transaction */
-		palm_write(algo_data, I2C_PALM_DEVADDR, addr);
-		palm_write(algo_data, I2C_PALM_CFG,     0xfa);
-		palm_write(algo_data, I2C_PALM_STARTXFR,0x2);
-
-		regVal = palm_read(algo_data, I2C_PALM_STATUS);
-		if (regVal & 0x0008) {
-			printk("start quick: ACKERR. Aborting...\n");
-			return -1;
-		}
-		return 0;
-	}
-
-	palm_write(algo_data, I2C_PALM_DEVADDR, addr);
-	palm_write(algo_data, I2C_PALM_DATAOUT, buf[0]);
-	palm_write(algo_data, I2C_PALM_CFG,     0xfa);
-	palm_write(algo_data, I2C_PALM_BYTECNT, len-1);
-	palm_write(algo_data, I2C_PALM_STARTXFR, 0x0);
-
-	regVal = palm_read(algo_data, I2C_PALM_STATUS);
-	if (regVal & 0x0008) {
-		printk("write: ACKERR. Aborting...\n");
-		return -1;
-	}
-
-
-	i= 0x1000;
-	regVal = palm_read(algo_data, I2C_PALM_STATUS);
-	while (!(regVal & 0x0002) && i) {
-		regVal = palm_read(algo_data, I2C_PALM_STATUS);
-		i--;
-	}
-	if (i==0x00) {
-		printk(" Write %d Test failed.[TimeOut]SDOEMPTY Not Set\n", tmp);
-		printk(" status: 0x%x.\n", regVal);
-		return -1;
-	}
-
-	for(tmp=1; tmp < len; tmp++) {
-		// palm_write(algo_data, I2C_PALM_CFG,     0xfa);
-		// palm_write(algo_data, I2C_PALM_BYTECNT, 0);
-		palm_write(algo_data, I2C_PALM_DATAOUT, buf[tmp]);
-		palm_write(algo_data, I2C_PALM_STARTXFR,0x0);
-
-		regVal = palm_read(algo_data, I2C_PALM_STATUS);
-		if (regVal & 0x0008) {
-			printk("start write: ACKERR. Aborting...\n");
-			return -1;
-		}
-
-		i= 0x1000;
-		regVal = palm_read(algo_data, I2C_PALM_STATUS);
-		while (!(regVal & 0x0002) && i) {
-			regVal = palm_read(algo_data, I2C_PALM_STATUS);
-			i--;
-		}
-		if (i==0x00) {
-			printk(" Write %d Test failed.[TimeOut]SDOEMPTY Not Set\n", tmp);
-			return -1;
-		}
-	}
-	return 0;
-}
-
-
-static int palm_xfer(struct i2c_adapter *i2c_adap,
-		struct i2c_msg msgs[],
-		int num)
-{
-	struct 	i2c_algo_palm_data *algo_data = i2c_adap->algo_data;
-	struct 	i2c_msg *msg = NULL;
-	int 	curmsg;
-
-
-	for (curmsg = 0; curmsg < num; curmsg++) {
-
-		int addr;
-		msg = &msgs[curmsg];
-
-		addr = (0x7f & msg->addr);
-
-		/*
-		 * Check if I2C State Machine is idle
-		 * 'wait_for_idle' returns 0 => timedOut
-		 * 'BUSY' bit cleared => BUS is IDLE
-		 */
-		if (wait_for_idle(algo_data) < 0) {
-			printk("TimedOut on Waiting for I2C Bus Idle.\n");
-			return -EIO;
-		}
-		if (msg->flags & I2C_M_RD ) {
-			if ((palm_rx(algo_data, &msg->buf[0], addr, 
-							msg->len)) == -1) {
-				printk("I2C Read Fail.\n");
-				return -EIO;
-			}
-			if(msg->flags & I2C_M_RECV_LEN)
-				msg->len += msg->buf[0];
-		}
-		else {
-			if ((palm_tx(algo_data, msg->len, &msg->buf[0], 
-						addr)) == -1) {
-				printk("I2C Write Fail.\n");
-				return -EIO;
-			}
-		}
-	}
-	return num;
-}
-
-static u32 palm_func(struct i2c_adapter *adap)
-{
-	/* We emulate SMBUS over I2C */
-	return I2C_FUNC_SMBUS_EMUL;
-}
-
-static int palm_init(struct i2c_algo_palm_data *algo_data)
-{
-	printk("Intializing BK-3220 I2C Host Adapter...");
-	spin_lock_init(&palm_lock);
-#if 0
-	/* RMI Phoenix has a hardcoded value for CLKDIV now... */
-	palm_write(algo_data, I2C_PALM_CLKDIV, I2C_PALM_CLKDIV_DEF);
-	/* Needed only for Multi-master environments */
-	palm_write(algo_data, I2C_PALM_HDSTATIM, I2C_PALM_HDSTATIM_DEF);
-#endif
-	printk("done.\n");
-	return 0;
-}
-
-static struct i2c_algorithm palm_algo = {
-/* 	.name		= "PalmChips I2C algorithm", */
-/* 	.id		= I2C_ALGO_PALM, */
-	.master_xfer	= palm_xfer,
-	.functionality	= palm_func,
-};
-
-/* 
- * registering functions to load algorithms at runtime 
- */
-int i2c_palm_add_bus(struct i2c_adapter *adap)
-{
-	struct i2c_algo_palm_data *palm_adap = adap->algo_data;
-	int rval;
-
-/* 	adap->id |= palm_algo.id; */
-	/* HLDS */
-	adap->nr = 1;
-	adap->algo = &palm_algo;
-
-	adap->timeout = 100;		
-	adap->retries = 3;		
-
-	rval = palm_init(palm_adap);
-
-	/* register new adapter to i2c module... */
-	if (!rval)
-		i2c_add_numbered_adapter(adap);
-		//i2c_add_adapter(adap);
-
-	return rval;
-}
-
-int i2c_palm_del_bus(struct i2c_adapter *adap)
-{
-	return i2c_del_adapter(adap);
-}
-
-EXPORT_SYMBOL(i2c_palm_add_bus);
-EXPORT_SYMBOL(i2c_palm_del_bus);
-
-MODULE_AUTHOR("RMI");
-MODULE_DESCRIPTION("I2C-Bus PalmChip's Host Adapter algorithm");
-MODULE_LICENSE("GPL");
-
-module_param(i2c_debug, int, 0);
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 9344228..a686379 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -303,17 +303,6 @@ config I2C_AT91
 	  the latency to fill the transmission register is too long. If you
 	  are facing this situation, use the i2c-gpio driver.
 
-config I2C_BK3220
-        tristate "PalmChip BK-3220"
-        depends on I2C && EXPERIMENTAL
-        select I2C_ALGOPALM
-        help
-          This supports the BK-3220 I2C adapter.  Say Y if you own
-          such an adapter.
-
-          This support is also available as a module.  If so, the module
-          will be called i2c-bk3220.
-
 config I2C_AU1550
 	tristate "Au1550/Au1200/Au1300 SMBus interface"
 	depends on MIPS_ALCHEMY
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 0a6c709..5ab1003 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -15,7 +15,6 @@ obj-$(CONFIG_I2C_ALI15X3)	+= i2c-ali15x3.o
 obj-$(CONFIG_I2C_AMD756)	+= i2c-amd756.o
 obj-$(CONFIG_I2C_AMD756_S4882)	+= i2c-amd756-s4882.o
 obj-$(CONFIG_I2C_AMD8111)	+= i2c-amd8111.o
-obj-$(CONFIG_I2C_BK3220)        += i2c-bk3220.o
 obj-$(CONFIG_I2C_I801)		+= i2c-i801.o
 obj-$(CONFIG_I2C_ISCH)		+= i2c-isch.o
 obj-$(CONFIG_I2C_NFORCE2)	+= i2c-nforce2.o
diff --git a/drivers/i2c/busses/i2c-bk3220.c b/drivers/i2c/busses/i2c-bk3220.c
deleted file mode 100644
index f6b6045..0000000
--- a/drivers/i2c/busses/i2c-bk3220.c
+++ /dev/null
@@ -1,154 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-/*
- *  i2c-palm-bk3220.c driver for the BK-3220 Host Adapter on the
- *  RMI Phoenix System.
- */
-
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/pci.h>
-#include <linux/wait.h>
-#include <linux/i2c.h>
-#include <linux/i2c-algo-palm.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/netlogic/iomap.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/i2c.h>
-
-#undef 	DEBUG
-
-#define ARIZONA_RTC_BUS 1
-#define NETLOGIC_CPLD_PHYS_ADDR	0xbd850000
-
-static wait_queue_head_t palm_wait;
-__u32 * iobase_i2c_regs = 0;
-
-__u32 * get_i2c_base(unsigned short bus)
-{
-	nlm_reg_t *mmio = 0;
-
-	if (bus == 0)
-		mmio = netlogic_io_mmio(NETLOGIC_IO_I2C_0_OFFSET);
-	else
-		mmio = netlogic_io_mmio(NETLOGIC_IO_I2C_1_OFFSET);
-
-	return (__u32 *)mmio;
-}
-
-static void	
-palm_bk3220_write(int reg, int val)
-{
-	/* Code to access the low-level
-	 * I2C Block on the RMI Phoenix 
-	 */		
-	netlogic_write_reg(iobase_i2c_regs, reg, val);
-}
-
-static int
-palm_bk3220_read(int reg)
-{
-  /* Code to access the low-level
-   * I2C Block on the RMI Phoenix 
-   */		
-  __u32 retVal = netlogic_read_reg(iobase_i2c_regs, reg);
-  return (int)retVal;
-}
-
-static struct i2c_algo_palm_data palm_bk3220_data = {
-	.write		= palm_bk3220_write,
-	.read		= palm_bk3220_read,
-};
-
-/* This is our i2c_adapter structure */
-static struct i2c_adapter palm_bk3220_ops = {
-	.owner          = THIS_MODULE,
-	.id		= I2C_HW_PALM_BK3220,			
-	.algo_data	= &palm_bk3220_data,
-	.name		= "Palm Chip BK3220 Adapter",
-};
-
-static int __devinit palm_bk3220_probe(struct platform_device *pd)
-{
-	printk("Registering I2C Bus %d\n", pd->id);
-
-    	iobase_i2c_regs = get_i2c_base(ARIZONA_RTC_BUS);
-
-	init_waitqueue_head(&palm_wait);
-
-	if (i2c_palm_add_bus(&palm_bk3220_ops) < 0) {
-		printk(KERN_ERR "i2c-palm-bk3220: Failed to add i2c bus\n");
-		goto out;
-	}
-	else {
-		printk("i2c-palm-bk3220: Added I2C Bus.\n");
-	}
-
-	return 0;
-out:
-	return -ENODEV;
-}
-
-static int __devexit palm_bk3220_remove(struct platform_device *pd)
-{
-	return i2c_palm_del_bus(&palm_bk3220_ops);
-}
-
-static struct platform_driver nlm_bk3220_i2c_driver = {
-	.probe  = palm_bk3220_probe,
-	.remove = __devexit_p(palm_bk3220_remove),
-	.driver = {
-		.owner  = THIS_MODULE,
-		.name   = NLM_XLR_I2C_BUS,
-	},
-};
-
-
-static int __init palm_bk3220_init(void)
-{
-	return platform_driver_register(&nlm_bk3220_i2c_driver);
-}
-
-static void __exit palm_bk3220_exit(void)
-{
-	platform_driver_unregister(&nlm_bk3220_i2c_driver);
-}
-
-
-
-MODULE_AUTHOR("Netlogic Semiconductors.");
-MODULE_DESCRIPTION("BK3220 I2C Host adapter driver");
-MODULE_LICENSE("GPL");
-
-module_init(palm_bk3220_init);
-module_exit(palm_bk3220_exit);
diff --git a/drivers/ide/Kconfig b/drivers/ide/Kconfig
index c204000..5a26584 100644
--- a/drivers/ide/Kconfig
+++ b/drivers/ide/Kconfig
@@ -679,11 +679,6 @@ config BLK_DEV_IDE_AU1XXX
        bool "IDE for AMD Alchemy Au1200"
        depends on MIPS_ALCHEMY
        select IDE_XFER_MODE
-
-config BLK_DEV_IDE_PHOENIX
-       bool "IDE for Netlogic XLR eval boards" 
-       depends on NLM_COMMON 
-
 choice
        prompt "IDE Mode for AMD Alchemy Au1200"
        default BLK_DEV_IDE_AU1XXX_PIO_DBDMA
diff --git a/drivers/ide/ide-dma-sff.c b/drivers/ide/ide-dma-sff.c
index 4fbb012..289d16c 100644
--- a/drivers/ide/ide-dma-sff.c
+++ b/drivers/ide/ide-dma-sff.c
@@ -6,12 +6,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/io.h>
 
-#ifdef CONFIG_NLM_COMMON
-extern u8 nlm_ide_mm_inb (unsigned long port);              /* readb  */
-extern void nlm_ide_mm_outb (u8 value, unsigned long port); /* writeb */
-extern void nlm_ide_mm_outl (u32 value, unsigned long port);
-#endif
-
 /**
  *	config_drive_for_dma	-	attempt to activate IDE DMA
  *	@drive: the drive to place in DMA mode
@@ -63,11 +57,7 @@ u8 ide_dma_sff_read_status(ide_hwif_t *hwif)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		return readb((void __iomem *)addr);
 	else
-#ifdef CONFIG_NLM_COMMON
-		return (u8) nlm_ide_mm_inb(addr);
-#else
 		return inb(addr);
-#endif
 }
 EXPORT_SYMBOL_GPL(ide_dma_sff_read_status);
 
@@ -78,11 +68,7 @@ static void ide_dma_sff_write_status(ide_hwif_t *hwif, u8 val)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		writeb(val, (void __iomem *)addr);
 	else
-#ifdef CONFIG_NLM_COMMON
-		nlm_ide_mm_outb(val, addr);
-#else
 		outb(val, addr);
-#endif
 }
 
 /**
@@ -216,21 +202,13 @@ int ide_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)
 		writel(hwif->dmatable_dma,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_TABLE_OFS));
 	else
-#ifdef CONFIG_NLM_COMMON
-		nlm_ide_mm_outl(hwif->dmatable_dma, hwif->dma_base + ATA_DMA_TABLE_OFS);
-#else
 		outl(hwif->dmatable_dma, hwif->dma_base + ATA_DMA_TABLE_OFS);
-#endif
 
 	/* specify r/w */
 	if (mmio)
 		writeb(rw, (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 	else
-#ifdef CONFIG_NLM_COMMON
-		nlm_ide_mm_outb(rw, hwif->dma_base + ATA_DMA_CMD);
-#else
 		outb(rw, hwif->dma_base + ATA_DMA_CMD);
-#endif
 
 	/* read DMA status for INTR & ERROR flags */
 	dma_stat = hwif->dma_ops->dma_sff_read_status(hwif);
@@ -297,13 +275,8 @@ void ide_dma_start(ide_drive_t *drive)
 		writeb(dma_cmd | ATA_DMA_START,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 	} else {
-#ifdef CONFIG_NLM_COMMON
-		dma_cmd = (u8)nlm_ide_mm_inb(hwif->dma_base + ATA_DMA_CMD);
-		nlm_ide_mm_outb(dma_cmd | ATA_DMA_START, hwif->dma_base + ATA_DMA_CMD);
-#else
 		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
 		outb(dma_cmd | ATA_DMA_START, hwif->dma_base + ATA_DMA_CMD);
-#endif
 	}
 }
 EXPORT_SYMBOL_GPL(ide_dma_start);
@@ -320,13 +293,8 @@ int ide_dma_end(ide_drive_t *drive)
 		writeb(dma_cmd & ~ATA_DMA_START,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 	} else {
-#ifdef CONFIG_NLM_COMMON
-		dma_cmd = (u8)nlm_ide_mm_inb(hwif->dma_base + ATA_DMA_CMD);
-		nlm_ide_mm_outb(dma_cmd & ~ATA_DMA_START, hwif->dma_base + ATA_DMA_CMD);
-#else
 		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
 		outb(dma_cmd & ~ATA_DMA_START, hwif->dma_base + ATA_DMA_CMD);
-#endif
 	}
 
 	/* get DMA status */
diff --git a/drivers/ide/ide-io-std.c b/drivers/ide/ide-io-std.c
index 3486c4b..1976397 100644
--- a/drivers/ide/ide-io-std.c
+++ b/drivers/ide/ide-io-std.c
@@ -14,31 +14,14 @@
  *	Conventional PIO operations for ATA devices
  */
 
-#ifdef CONFIG_NLM_COMMON
-extern u8 nlm_ide_mm_inb (unsigned long port);              /* readb  */
-extern void nlm_ide_mm_outb (u8 value, unsigned long port); /* writeb */
-extern void nlm_ide_mm_insl(unsigned long port, void *addr, unsigned int count);
-extern void nlm_ide_mm_outsl(unsigned long port, void *addr,unsigned int count);
-extern void nlm_ide_mm_insw(unsigned long port, void *addr, u32 count);
-extern void nlm_ide_mm_outsw(unsigned long port, void *addr,unsigned int count);
-#endif
-
 static u8 ide_inb(unsigned long port)
 {
-#ifdef CONFIG_NLM_COMMON
-	return (u8) nlm_ide_mm_inb(port);
-#else
 	return (u8) inb(port);
-#endif
 }
 
 static void ide_outb(u8 val, unsigned long port)
 {
-#ifdef CONFIG_NLM_COMMON
-	nlm_ide_mm_outb(val, port);
-#else
 	outb(val, port);
-#endif
 }
 
 /*
@@ -60,11 +43,7 @@ void ide_exec_command(ide_hwif_t *hwif, u8 cmd)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		writeb(cmd, (void __iomem *)hwif->io_ports.command_addr);
 	else
-#ifdef CONFIG_NLM_COMMON
-		nlm_ide_mm_outb(cmd, hwif->io_ports.command_addr);
-#else
 		outb(cmd, hwif->io_ports.command_addr);
-#endif
 }
 EXPORT_SYMBOL_GPL(ide_exec_command);
 
@@ -73,11 +52,7 @@ u8 ide_read_status(ide_hwif_t *hwif)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		return readb((void __iomem *)hwif->io_ports.status_addr);
 	else
-#ifdef CONFIG_NLM_COMMON
-		return (u8) nlm_ide_mm_inb(hwif->io_ports.status_addr);
-#else
 		return inb(hwif->io_ports.status_addr);
-#endif
 }
 EXPORT_SYMBOL_GPL(ide_read_status);
 
@@ -86,11 +61,7 @@ u8 ide_read_altstatus(ide_hwif_t *hwif)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		return readb((void __iomem *)hwif->io_ports.ctl_addr);
 	else
-#ifdef CONFIG_NLM_COMMON
-		return (u8) nlm_ide_mm_inb(hwif->io_ports.ctl_addr);
-#else
 		return inb(hwif->io_ports.ctl_addr);
-#endif
 }
 EXPORT_SYMBOL_GPL(ide_read_altstatus);
 
@@ -99,11 +70,7 @@ void ide_write_devctl(ide_hwif_t *hwif, u8 ctl)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		writeb(ctl, (void __iomem *)hwif->io_ports.ctl_addr);
 	else
-#ifdef CONFIG_NLM_COMMON
-		nlm_ide_mm_outb(ctl, hwif->io_ports.ctl_addr);
-#else
 		outb(ctl, hwif->io_ports.ctl_addr);
-#endif
 }
 EXPORT_SYMBOL_GPL(ide_write_devctl);
 
@@ -115,11 +82,7 @@ void ide_dev_select(ide_drive_t *drive)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		writeb(select, (void __iomem *)hwif->io_ports.device_addr);
 	else
-#ifdef CONFIG_NLM_COMMON
-		nlm_ide_mm_outb(select, hwif->io_ports.device_addr);
-#else
 		outb(select, hwif->io_ports.device_addr);
-#endif
 }
 EXPORT_SYMBOL_GPL(ide_dev_select);
 
@@ -235,11 +198,7 @@ void ide_input_data(ide_drive_t *drive, struct ide_cmd *cmd, void *buf,
 	if (mmio)
 		__ide_mm_insw((void __iomem *)data_addr, buf, words);
 	else
-#ifdef CONFIG_NLM_COMMON
-		nlm_ide_mm_insw(data_addr, buf, words);
-#else
 		insw(data_addr, buf, words);
-#endif
 }
 EXPORT_SYMBOL_GPL(ide_input_data);
 
@@ -283,11 +242,7 @@ void ide_output_data(ide_drive_t *drive, struct ide_cmd *cmd, void *buf,
 	if (mmio)
 		__ide_mm_outsw((void __iomem *)data_addr, buf, words);
 	else
-#ifdef CONFIG_NLM_COMMON
-		nlm_ide_mm_outsw(data_addr, buf, words);
-#else
 		outsw(data_addr, buf, words);
-#endif
 }
 EXPORT_SYMBOL_GPL(ide_output_data);
 
diff --git a/drivers/ide/pdc202xx_new.c b/drivers/ide/pdc202xx_new.c
index 15819a9..9546fe2 100644
--- a/drivers/ide/pdc202xx_new.c
+++ b/drivers/ide/pdc202xx_new.c
@@ -63,11 +63,6 @@ static u8 max_dma_rate(struct pci_dev *pdev)
 	return mode;
 }
 
-#ifdef CONFIG_NLM_COMMON
-extern void nlm_ide_mm_outb (u8 value, unsigned long port);
-extern u8 nlm_ide_mm_inb (unsigned long port);
-#endif
-
 /**
  * get_indexed_reg - Get indexed register
  * @hwif: for the port address
@@ -77,13 +72,8 @@ static u8 get_indexed_reg(ide_hwif_t *hwif, u8 index)
 {
 	u8 value;
 
-#ifdef CONFIG_NLM_COMMON
-	nlm_ide_mm_outb(index, hwif->dma_base + 1);
-	value = nlm_ide_mm_inb(hwif->dma_base + 3);
-#else
 	outb(index, hwif->dma_base + 1);
 	value = inb(hwif->dma_base + 3);
-#endif
 
 	DBG("index[%02X] value[%02X]\n", index, value);
 	return value;
@@ -96,13 +86,8 @@ static u8 get_indexed_reg(ide_hwif_t *hwif, u8 index)
  */
 static void set_indexed_reg(ide_hwif_t *hwif, u8 index, u8 value)
 {
-#ifdef CONFIG_NLM_COMMON
-	nlm_ide_mm_outb(index, hwif->dma_base + 1);
-	nlm_ide_mm_outb(value, hwif->dma_base + 3);
-#else
 	outb(index, hwif->dma_base + 1);
 	outb(value, hwif->dma_base + 3);
-#endif
 	DBG("index[%02X] value[%02X]\n", index, value);
 }
 
@@ -227,16 +212,6 @@ static long read_counter(u32 dma_base)
 		last = count;
 
 		/* Read the current count */
-#ifdef CONFIG_NLM_COMMON
-		nlm_ide_mm_outb(0x20, pri_dma_base + 0x01);
-		cnt0 = nlm_ide_mm_inb(pri_dma_base + 0x03);
-		nlm_ide_mm_outb(0x21, pri_dma_base + 0x01);
-		cnt1 = nlm_ide_mm_inb(pri_dma_base + 0x03);
-		nlm_ide_mm_outb(0x20, sec_dma_base + 0x01);
-		cnt2 = nlm_ide_mm_inb(sec_dma_base + 0x03);
-		nlm_ide_mm_outb(0x21, sec_dma_base + 0x01);
-		cnt3 = nlm_ide_mm_inb(sec_dma_base + 0x03);
-#else
 		outb(0x20, pri_dma_base + 0x01);
 		cnt0 = inb(pri_dma_base + 0x03);
 		outb(0x21, pri_dma_base + 0x01);
@@ -245,7 +220,6 @@ static long read_counter(u32 dma_base)
 		cnt2 = inb(sec_dma_base + 0x03);
 		outb(0x21, sec_dma_base + 0x01);
 		cnt3 = inb(sec_dma_base + 0x03);
-#endif
 
 		count = (cnt3 << 23) | (cnt2 << 15) | (cnt1 << 8) | cnt0;
 
@@ -278,17 +252,10 @@ static long detect_pll_input_clock(unsigned long dma_base)
 	do_gettimeofday(&start_time);
 
 	/* Start the test mode */
-#ifdef CONFIG_NLM_COMMON
-	nlm_ide_mm_outb(0x01, dma_base + 0x01);
-	scr1 = nlm_ide_mm_inb(dma_base + 0x03);
-	DBG("scr1[%02X]\n", scr1);
-	nlm_ide_mm_outb(scr1 | 0x40, dma_base + 0x03);
-#else
 	outb(0x01, dma_base + 0x01);
 	scr1 = inb(dma_base + 0x03);
 	DBG("scr1[%02X]\n", scr1);
 	outb(scr1 | 0x40, dma_base + 0x03);
-#endif
 
 	/* Let the counter run for 10 ms. */
 	mdelay(10);
@@ -297,17 +264,10 @@ static long detect_pll_input_clock(unsigned long dma_base)
 	do_gettimeofday(&end_time);
 
 	/* Stop the test mode */
-#ifdef CONFIG_NLM_COMMON
-	nlm_ide_mm_outb(0x01, dma_base + 0x01);
-	scr1 = nlm_ide_mm_inb(dma_base + 0x03);
-	DBG("scr1[%02X]\n", scr1);
-	nlm_ide_mm_outb(scr1 & ~0x40, dma_base + 0x03);
-#else
 	outb(0x01, dma_base + 0x01);
 	scr1 = inb(dma_base + 0x03);
 	DBG("scr1[%02X]\n", scr1);
 	outb(scr1 & ~0x40, dma_base + 0x03);
-#endif
 
 	/*
 	 * Calculate the input clock in Hz
@@ -344,9 +304,7 @@ static int init_chipset_pdcnew(struct pci_dev *dev)
 {
 	const char *name = DRV_NAME;
 	unsigned long dma_base = pci_resource_start(dev, 4);
-#ifndef CONFIG_NLM_COMMON
 	unsigned long sec_dma_base = dma_base + 0x08;
-#endif
 	long pll_input, pll_output, ratio;
 	int f, r;
 	u8 pll_ctl0, pll_ctl1;
@@ -393,17 +351,10 @@ static int init_chipset_pdcnew(struct pci_dev *dev)
 	/* Show the current clock value of PLL control register
 	 * (maybe already configured by the BIOS)
 	 */
-#ifdef CONFIG_NLM_COMMON
-	nlm_ide_mm_outb(0x02, sec_dma_base + 0x01);
-	pll_ctl0 = nlm_ide_mm_inb(sec_dma_base + 0x03);
-	nlm_ide_mm_outb(0x03, sec_dma_base + 0x01);
-	pll_ctl1 = nlm_ide_mm_inb(sec_dma_base + 0x03);
-#else
 	outb(0x02, sec_dma_base + 0x01);
 	pll_ctl0 = inb(sec_dma_base + 0x03);
 	outb(0x03, sec_dma_base + 0x01);
 	pll_ctl1 = inb(sec_dma_base + 0x03);
-#endif
 
 	DBG("pll_ctl[%02X][%02X]\n", pll_ctl0, pll_ctl1);
 #endif
@@ -447,12 +398,10 @@ static int init_chipset_pdcnew(struct pci_dev *dev)
 
 	DBG("Writing pll_ctl[%02X][%02X]\n", pll_ctl0, pll_ctl1);
 
-#ifndef CONFIG_NLM_COMMON
 	outb(0x02,     sec_dma_base + 0x01);
 	outb(pll_ctl0, sec_dma_base + 0x03);
 	outb(0x03,     sec_dma_base + 0x01);
 	outb(pll_ctl1, sec_dma_base + 0x03);
-#endif
 
 	/* Wait the PLL circuit to be stable */
 	mdelay(30);
@@ -461,17 +410,10 @@ static int init_chipset_pdcnew(struct pci_dev *dev)
 	/*
 	 *  Show the current clock value of PLL control register
 	 */
-#ifdef CONFIG_NLM_COMMON
-	nlm_ide_mm_outb(0x02, sec_dma_base + 0x01);
-	pll_ctl0 = nlm_ide_mm_inb(sec_dma_base + 0x03);
-	nlm_ide_mm_outb(0x03, sec_dma_base + 0x01);
-	pll_ctl1 = nlm_ide_mm_inb(sec_dma_base + 0x03);
-#else
 	outb(0x02, sec_dma_base + 0x01);
 	pll_ctl0 = inb(sec_dma_base + 0x03);
 	outb(0x03, sec_dma_base + 0x01);
 	pll_ctl1 = inb(sec_dma_base + 0x03);
-#endif
 
 	DBG("pll_ctl[%02X][%02X]\n", pll_ctl0, pll_ctl1);
 #endif
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index 3818d15..3a9bd22 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -249,12 +249,6 @@ config MTD_LANTIQ
 	help
 	  Support for NOR flash attached to the Lantiq SoC's External Bus Unit.
 
-config MTD_XLR
-	tristate "XLR Flash MTD support"
-	depends on NLM_COMMON
-	help
-	  Flash memory access on XLR/XLS Reference Boards
-
 config MTD_XLP
 	tristate "XLP Flash MTD support"
 	depends on NLM_XLP
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 70bf11c..f23a741 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -57,7 +57,6 @@ obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_vr_nor.o
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
-obj-$(CONFIG_MTD_XLR)           += xlr-flash.o
 obj-$(CONFIG_MTD_XLP)           += xlp-flash.o
 obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
 obj-$(CONFIG_MTD_LATCH_ADDR)	+= latch-addr-flash.o
diff --git a/drivers/mtd/maps/xlr-flash.c b/drivers/mtd/maps/xlr-flash.c
deleted file mode 100644
index 2990443..0000000
--- a/drivers/mtd/maps/xlr-flash.c
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Flash memory access on XLR evaluation boards
- *
- * (C) 2008, 2009  RMI Corp <sandip@rmicorp.com>
- *
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/map.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/io.h>
-#include <asm/netlogic/sim.h>
-
-#ifdef 	DEBUG_RW
-#define	DBG(x...)	printk(x)
-#else
-#define	DBG(x...)
-#endif
-
-#define BOARD_MAP_NAME "SPS Flash"
-#define BOARD_FLASH_SIZE 0x01000000 /* 16MB */
-#define BOARD_FLASH_BASE 0x1c000000 
-#define BOARD_FLASH_WIDTH 2 /* 16-bits */
-
-static struct map_info sps_map = {
-	.name =	BOARD_MAP_NAME,
-};
-
-static struct mtd_partition sps_partitions[] = {
-        {
-                .name = "User FS",
-                .offset = 0x800000, // Upto 8 MB is used by bootloader.
-		.size = MTDPART_SIZ_FULL ,
-        }
-};
-
-static struct mtd_info *mymtd;
-
-int __init sps_mtd_init(void)
-{
-	struct mtd_partition *parts;
-	int nb_parts = 0;
-	unsigned long window_addr;
-	unsigned long window_size;
-
-	if (xlr_board_atx_viii()){
-		return -ENODEV;
-	}
-	/* Default flash buswidth */
-	sps_map.bankwidth = BOARD_FLASH_WIDTH;
-
-	window_addr = BOARD_FLASH_BASE;
-	window_size = BOARD_FLASH_SIZE;
-
-	/*
-	 * Static partition definition selection
-	 */
-	parts = sps_partitions;
-	nb_parts = ARRAY_SIZE(sps_partitions);
-	sps_map.size = window_size;
-
-	/*
-	 * Now let's probe for the actual flash.  Do it here since
-	 * specific machine settings might have been set above.
-	 */
-	printk(KERN_NOTICE BOARD_MAP_NAME ": probing %d-bit flash bus\n",
-			sps_map.bankwidth*8);
-	sps_map.virt = ioremap(window_addr, window_size);
-	mymtd = do_map_probe("cfi_probe", &sps_map);
-	if (!mymtd) {
-		iounmap(sps_map.virt);
-		return -ENXIO;
-	}
-	mymtd->owner = THIS_MODULE;
-
-	add_mtd_partitions(mymtd, parts, nb_parts);
-	return 0;
-}
-
-static void __exit sps_mtd_cleanup(void)
-{
-	if (mymtd) {
-		del_mtd_partitions(mymtd);
-		map_destroy(mymtd);
-		iounmap(sps_map.virt);
-	}
-}
-
-module_init(sps_mtd_init);
-module_exit(sps_mtd_cleanup);
-
-MODULE_AUTHOR("Sandip Matte, RMI Corporation");
-MODULE_DESCRIPTION(BOARD_MAP_NAME " MTD driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/nand/xls_nand.c b/drivers/mtd/nand/xls_nand.c
deleted file mode 100644
index 759b32e..0000000
--- a/drivers/mtd/nand/xls_nand.c
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * drivers/mtd/nand/xls_nand.c
- *
- *  Copyright (C) 2007 Raza microelectronics Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-
-#include <linux/genhd.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/nand_ecc.h>
-#include <linux/mtd/partitions.h>
-#include <linux/interrupt.h>
-#include <asm/io.h>
-#include <asm/netlogic/sim.h>
-
-#include "xls_nand.h"
-
-static u8 hwctl;
-static void __iomem *xls_io_base;
-static int xls_nand_phys_base = 0xBD800000;
-
-/* register offset */
-#define FLASHIO	 	0xBD800000		/* Flash I/O */
-
-/*
- * MTD structure for xls
- */
-static struct mtd_info *xls_mtd= NULL;
-
-/*
- * Define partitions for flash device
- */
-#define DEFAULT_NUM_PARTITIONS 2
-
-#define CLE_REG (0xbef19240 + (long)(((struct nand_chip *)(mtd->priv))->priv) * 4)
-#define ALE_REG (0xbef19280 + (long)(((struct nand_chip *)(mtd->priv))->priv) * 4)
-#define RW_OFFSET  0xbd800000 
-
-#define WRITE_NAND_CLE(command)(nand_write_cmd((long)(int)CLE_REG, command))
-#define WRITE_NAND_ALE(address)(nand_write_addr((long)(int)ALE_REG, address))
-#define WRITE_NAND_ARRAY(data,n) (nand_write_multi((long)(int)RW_OFFSET, data, n))
-#define READ_NAND_BYTE(data)(nand_read_byte((long)(int)RW_OFFSET, &(data)))
-#define READ_NAND_ARRAY(data,n) (nand_read_multi((long)(int)RW_OFFSET, data, n))
-
-
-static int nr_partitions;
-static struct mtd_partition xls_nand_default_partition_info[] = {
-	{
-	.name = "Root Filesystem",
-	.offset = 64 * 64 * 2048, /* 54M@8M */
-	.size = 432 * 64 * 2048,
-	},
-	{
-	.name = "Home Filesystem",
-	.offset = MTDPART_OFS_APPEND , /* Rest@62M */
-	.size = MTDPART_SIZ_FULL ,
-	},
-};
-
-/*
- *	hardware specific access to control-lines
- *	In case of xls, we remember the access, and accordingly do read/write of
- *	ale/cle or IO.
- */
-static void xls_nand_hwcontrol(struct mtd_info *mtd, int cmd,
-				   unsigned int ctrl)
-{
-	unsigned char bits = ctrl & 0x07;
-
-		if (bits & NAND_CLE)
-			WRITE_NAND_CLE(cmd);
-		else if (bits & NAND_ALE)
-			WRITE_NAND_ALE(cmd);
-}
-
-#define STATUS_BIT_0 0x01
-#define STATUS_BIT_6 0x40
-#define MAX_READ_STATUS_COUNT 100000
-#define NAND_CMD_READ_STATUS 0x70
-
-int nand_read_status(struct mtd_info *mtd)
-{
-	int status_count;
-	unsigned char status;
-
-	WRITE_NAND_CLE(NAND_CMD_READ_STATUS);		
-	status_count = 0;
-
-	while(status_count < MAX_READ_STATUS_COUNT)
-	{
-		/* Read status byte */
-		READ_NAND_BYTE(status);
-		/* Check status */
-		if((status& STATUS_BIT_6) == STATUS_BIT_6)  /* if 1, device is ready */
-		{
-			if((status& STATUS_BIT_0) == 0)	/* if 0, the last operation was succesful */
-				return 1;
-			else
-				return 0;
-		}			
-		status_count++;
-	}
-
-	return 0;
-}
-
-static unsigned char xls_nand_read_byte(struct mtd_info *mtd)
-{
-	unsigned char x;
-	READ_NAND_BYTE(x);
-	return x;
-}
-
-static void xls_nand_write_buf(struct mtd_info *mtd, const unsigned char *buf, int len)
-{
-	int i;
-    unsigned char *tmp = (unsigned char *)buf;
-
-	for (i = 0; i < len; i++) {
-		WRITE_NAND_ARRAY((void *)&tmp[i],1);
-	}
-}
-
-static void xls_nand_read_buf(struct mtd_info *mtd, unsigned char *buf, int len)
-{
-	READ_NAND_ARRAY(buf,len);
-}
-
-static int xls_nand_verify_buf(struct mtd_info *mtd, const unsigned char *buf, int len)
-{
-	int i;
-	unsigned char temp_byte;
-
-	for (i = 0; i < len; i++) {
-		READ_NAND_BYTE(temp_byte);
-		if (buf[i] != temp_byte)
-			return i;
-	}
-
-	return 0;
-}
-
-static int xls_nand_dev_ready(struct mtd_info *mtd)
-{
-	return nand_read_status(mtd);
-}
-
-#ifdef CONFIG_MTD_PARTITIONS
-const char *part_probes[] = { "cmdlinepart", NULL };
-#endif
-
-/*
- * Main initialization routine
- */
-int __init
-xls_nand_init(void)
-{
-	struct nand_chip *this;
-	struct mtd_partition* xls_partition_info;
-	int err = 0;
-	uint32_t nand_gpio_check;
-	uint32_t read_cs_base;
-	int nand_chip_select;
-	
-	hwctl = 0;
-
-	if (!is_xls())
-		return -ENODEV;
-
-
-	/* nand is present */
-	nand_gpio_check = *(uint32_t *)((long)(int)(0xbef00000 + 0x18000 + 84));
-	if ((nand_gpio_check >> 16) & 0x1)
-		nand_chip_select = 0;
-	else
-		nand_chip_select = 2;
-	
-	read_cs_base = *(uint32_t *)((long)(int)(0xbef19000 + nand_chip_select * 4));
-
-	read_cs_base = read_cs_base & 0xffff;
-
-	if (read_cs_base  != 384) { /* This checks if flash bar is mapped at
-				       0xbd800000 */
-		printk ("Burn bootloader version > 1.4.2 to use nand flash\n");
-		return -ENODEV;
-	}
-	/* Allocate memory for MTD device structure and private data */
-	xls_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip),
-				GFP_KERNEL);
-	if (!xls_mtd) {
-		printk ("Unable to allocate xls NAND MTD device structure.\n");
-		return -ENOMEM;
-	}
-
-	/* map physical adress */
-	xls_io_base = ioremap((long)xls_nand_phys_base, 0x1000);
-	if(!xls_io_base){
-		printk("ioremap to access XLS NAND chip failed\n");
-		kfree(xls_mtd);
-		return -EIO;
-	}
-
-	/* Get pointer to private data */
-	this = (struct nand_chip *) (&xls_mtd[1]);
-
-	/* Initialize structures */
-	memset((char *) xls_mtd, 0, sizeof(struct mtd_info));
-	memset((char *) this, 0, sizeof(struct nand_chip));
-
-	/* Link the private data with the MTD structure */
-	xls_mtd->priv = this;
-
-	/* Set address of NAND IO lines */
-	this->IO_ADDR_R = (char *)(long)(int)FLASHIO;
-	this->IO_ADDR_W = (char *)(long)(int)FLASHIO;
-	/* Set address of hardware control function */
-	this->cmd_ctrl = xls_nand_hwcontrol;
-	this->dev_ready = xls_nand_dev_ready;
-	this->read_byte  = xls_nand_read_byte;
-	this->write_buf  = xls_nand_write_buf;
-	this->read_buf   = xls_nand_read_buf;
-	this->verify_buf = xls_nand_verify_buf;
-	
-	/* 15 us command delay time */
-	this->chip_delay = 15;
-	this->ecc.mode = NAND_ECC_SOFT;
-	this->priv = (void *)(unsigned long)nand_chip_select;
-
-	/* Scan to find existence of the device */
-	err=nand_scan(xls_mtd,1);
-	if (err) {
-		iounmap(xls_io_base);
-		kfree(xls_mtd);
-		return err;
-	}
-
-	xls_mtd->name = "xls-nand";
-	/* Register the partitions */
-#ifdef CONFIG_MTD_PARTITIONS
-	nr_partitions = parse_mtd_partitions(xls_mtd, part_probes,
-						&xls_partition_info, 0);
-#endif 
-
-	if (nr_partitions <= 0) {
-		nr_partitions = DEFAULT_NUM_PARTITIONS;
-		xls_partition_info = xls_nand_default_partition_info;
-	}
-
-	add_mtd_partitions(xls_mtd, xls_partition_info, nr_partitions);
-
-	return 0;
-}
-module_init(xls_nand_init);
-
-#ifdef MODULE
-static void __exit xls_nand_cleanup(void)
-{
-	struct nand_chip *this = (struct nand_chip *) &xls_mtd[1];
-
-	/* Release resources, unregister device */
-	nand_release(xls_mtd);
-
-	iounmap(xls_io_base);
-
-	/* Free the MTD device structure */
-	kfree(xls_mtd);
-}
-module_exit(xls_nand_cleanup);
-#endif
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Raza Micronelectronics <sandip@razamicro.com>");
-MODULE_DESCRIPTION("Device specific logic for NAND flash on XLS Series");
diff --git a/drivers/mtd/nand/xls_nand.h b/drivers/mtd/nand/xls_nand.h
deleted file mode 100644
index 6558b8b..0000000
--- a/drivers/mtd/nand/xls_nand.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef __XLS_NAND_H__
-#define __XLS_NAND_H__
-
-static void nand_write_cmd(unsigned long offset, unsigned char cmd)
-{
-	*(volatile uint32_t *)offset = (uint32_t)cmd;
-}
-
-static void nand_write_addr(unsigned long offset, unsigned char addr)
-{
-	*(volatile uint32_t *)offset = (uint32_t)addr;
-}
-
-static void nand_read_multi(unsigned long offset, void *buf, unsigned short len)
-{
-	int i;
-	volatile unsigned char *tbuf = (volatile unsigned char *)buf;
-
-	for (i = 0; i < len; i++) {
-		*tbuf = *(volatile unsigned char *)offset;
-		tbuf++;
-	}
-}
-
-static void nand_read_byte(unsigned long offset, void *buf)
-{
-	*(volatile unsigned char *) buf = *(volatile unsigned char *)offset;
-}
-
-static void nand_write_multi(unsigned long offset, void *buf, unsigned short len)
-{
-	int i;
-	volatile unsigned char *tbuf = (volatile char *)buf;
-
-	for (i = 0; i < len; i++) {
-		*(volatile unsigned char *)offset = *(volatile unsigned char *)tbuf;
-		tbuf++;
-	}
-}
-
-#endif /* __XLS_NAND_H__ */
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 63d38c2..b982854 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -160,12 +160,6 @@ config NETCONSOLE
 	If you want to log kernel messages over the network, enable this.
 	See <file:Documentation/networking/netconsole.txt> for details.
 
-config NLM_VNET
-	bool "Virtual Networking for CRF"
-	---help---
-	This enables internal network for CRF domains using shared memory and
-	event queues.
-
 config NETCONSOLE_DYNAMIC
 	bool "Dynamic reconfiguration of logging targets"
 	depends on NETCONSOLE && SYSFS && CONFIGFS_FS && \
@@ -350,13 +344,4 @@ config VMXNET3
 
 source "drivers/net/hyperv/Kconfig"
 
-config XLP_NAE 
-	tristate "netlogic microsystems xlp nae mac driver"
-#	depends on m
-	---help---
-	  This driver supports netlogic xls/xlr/xlp soc network driver. 
-	  For more information on xls/xlr/xlp mac driver, please visit
-
-	  <http://support.netlogicmicro.com/support>
-
 endif # NETDEVICES
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index a714429..72fb7dd 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -27,11 +27,7 @@ obj-$(CONFIG_MDIO) += mdio.o
 obj-$(CONFIG_NET) += Space.o loopback.o
 obj-$(CONFIG_NETCONSOLE) += netconsole.o
 obj-$(CONFIG_PHYLIB) += phy/
-ifdef CONFIG_NLM_COMMON
-obj-$(CONFIG_RIONET) += nlm_rionet.o
-else
 obj-$(CONFIG_RIONET) += rionet.o
-endif
 obj-$(CONFIG_NET_TEAM) += team/
 obj-$(CONFIG_TUN) += tun.o
 obj-$(CONFIG_VETH) += veth.o
diff --git a/drivers/net/kgdboe.c b/drivers/net/kgdboe.c
deleted file mode 100644
index 3528739..0000000
--- a/drivers/net/kgdboe.c
+++ /dev/null
@@ -1,216 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*
- * drivers/net/kgdboe.c
- *
- * A network interface for GDB.
- * Based upon 'gdbserial' by David Grothe <dave@gcom.com>
- * and Scott Foehner <sfoehner@engr.sgi.com>
- *
- * Maintainers: Amit S. Kale <amitkale@linsyssoft.com> and
- * 		Tom Rini <trini@kernel.crashing.org>
- *
- * 2004 (c) Amit S. Kale <amitkale@linsyssoft.com>
- * 2004-2005 (c) MontaVista Software, Inc.
- * 2005 (c) Wind River Systems, Inc.
- *
- * Other folks:
- * San Mehat <nettwerk@biodome.org>
- * Robert Walsh <rjwalsh@durables.org>
- * wangdi <wangdi@clusterfs.com>.
- * Matt Mackall <mpm@selenic.com>
- * Pavel Machek <pavel@suse.cz>
- * Jason Wessel <jason.wessel@windriver.com>
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2. This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- *
- * Changes:
- * 3/10/05 - Jason Wessel <jason.wessel@windriver.com>
- * - Added ability to compile/load as module
- *
- * Known problems:
- * - There is no way to deny the unloading of the module
- *   if KGDB is connected, but an attempt is made to handle it
- */
-
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/string.h>
-#include <linux/kgdb.h>
-#include <linux/netpoll.h>
-#include <linux/init.h>
-
-#include <asm/atomic.h>
-
-#define IN_BUF_SIZE 512		/* power of 2, please */
-#define OUT_BUF_SIZE 30		/* We don't want to send too big of a packet. */
-
-static char in_buf[IN_BUF_SIZE], out_buf[OUT_BUF_SIZE];
-static int in_head, in_tail, out_count;
-static atomic_t in_count;
-/* 0 = unconfigured, 1 = netpoll options parsed, 2 = fully configured. */
-static int configured;
-
-static void rx_hook(struct netpoll *np, int port, char *msg, int len);
-static void eth_pre_exception_handler(void);
-static void eth_post_exception_handler(void);
-static int eth_get_char(void);
-static void eth_flush_buf(void);
-static void eth_put_char(int chr);
-int init_kgdboe(void);
-
-static struct netpoll np = {
-	.name = "kgdboe",
-	.dev_name = "eth0",
-	.rx_hook = rx_hook,
-	.local_port = 6443,
-	.remote_port = 6442,
-	.remote_mac = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
-};
-
-MODULE_DESCRIPTION("KGDB driver for network interfaces");
-MODULE_LICENSE("GPL");
-static char config[256];
-module_param_string(kgdboe, config, 256, 0);
-MODULE_PARM_DESC(kgdboe, " kgdboe=[src-port]@[src-ip]/[dev],"
-		 "[tgt-port]@<tgt-ip>/<tgt-macaddr>\n");
-
-static struct kgdb_io local_kgdb_io_ops = {
-	.read_char = eth_get_char,
-	.write_char = eth_put_char,
-	.init = init_kgdboe,
-	.flush = eth_flush_buf,
-	.pre_exception = eth_pre_exception_handler,
-	.post_exception = eth_post_exception_handler
-};
-
-static void eth_pre_exception_handler(void)
-{
-	netpoll_set_trap(1);
-}
-
-static void eth_post_exception_handler(void)
-{
-	netpoll_set_trap(0);
-}
-
-static int eth_get_char(void)
-{
-	int chr;
-
-	while (atomic_read(&in_count) == 0)
-		netpoll_poll(&np);
-
-	chr = in_buf[in_tail++];
-	in_tail &= (IN_BUF_SIZE - 1);
-	atomic_dec(&in_count);
-	return chr;
-}
-
-static void eth_flush_buf(void)
-{
-	if (out_count && np.dev) {
-		netpoll_send_udp(&np, out_buf, out_count);
-		memset(out_buf, 0, sizeof(out_buf));
-		out_count = 0;
-	}
-}
-
-static void eth_put_char(int chr)
-{
-	out_buf[out_count++] = chr;
-	if (out_count == OUT_BUF_SIZE)
-		eth_flush_buf();
-}
-
-static void rx_hook(struct netpoll *np, int port, char *msg, int len)
-{
-	int i;
-
-	np->remote_port = port;
-
-	/*
-	 * This could be GDB trying to attach.  But it could also be GDB
-	 * finishing up a session, with kgdb_connected=0 but GDB sending
-	 * an ACK for the final packet.  To make sure we don't try and
-	 * make a breakpoint when GDB is leaving, make sure that if
-	 * !kgdb_connected the only len == 1 packet we allow is ^C.
-	 */
-	if (!kgdb_connected && (len != 1 || msg[0] == 3) &&
-	    !atomic_read(&kgdb_setting_breakpoint))
-		tasklet_schedule(&kgdb_tasklet_breakpoint);
-
-	for (i = 0; i < len; i++) {
-		if (msg[i] == 3)
-			tasklet_schedule(&kgdb_tasklet_breakpoint);
-
-		if (atomic_read(&in_count) >= IN_BUF_SIZE) {
-			/* buffer overflow, clear it */
-			in_head = in_tail = 0;
-			atomic_set(&in_count, 0);
-			break;
-		}
-		in_buf[in_head++] = msg[i];
-		in_head &= (IN_BUF_SIZE - 1);
-		atomic_inc(&in_count);
-	}
-}
-
-static int option_setup(char *opt)
-{
-	configured = !netpoll_parse_options(&np, opt);
-	return 0;
-}
-
-__setup("kgdboe=", option_setup);
-
-int init_kgdboe(void)
-{
-	/* Already done? */
-	if (configured == 2)
-		return 0;
-
-	if (strlen(config))
-		option_setup(config);
-
-	if (!configured) {
-		printk("kgdboe: configuration incorrect - kgdboe not "
-		       "loaded.\n");
-		printk("  Usage: kgdboe=[src-port]@[src-ip]/[dev],[tgt-port]"
-		       "@<tgt-ip>/[tgt-macaddr]\n");
-		return -EINVAL;
-	}
-
-	if (netpoll_setup(&np)) {
-		printk("kgdboe: netpoll_setup failed kgdboe failed\n");
-		return -EINVAL;
-	}
-
-	if (kgdb_register_io_module(&local_kgdb_io_ops))
-		return -EINVAL;
-
-	printk(KERN_INFO "kgdboe: debugging over ethernet enabled\n");
-
-	configured = 2;
-
-	return 0;
-}
-
-static void cleanup_kgdboe(void)
-{
-	netpoll_cleanup(&np);
-	configured = 0;
-
-	kgdb_unregister_io_module(&local_kgdb_io_ops);
-}
-
-module_init(init_kgdboe);
-module_exit(cleanup_kgdboe);
diff --git a/drivers/net/nlm_ptp1588/Makefile b/drivers/net/nlm_ptp1588/Makefile
deleted file mode 100644
index 28cbd52..0000000
--- a/drivers/net/nlm_ptp1588/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-################################################################################
-
-#
-# Makefile for nlm_ptp1588
-#
-#EXTRA_CFLAGS := -Werror
-
-obj-y += ptp_main.o
diff --git a/drivers/net/nlm_ptp1588/ptp_common.h b/drivers/net/nlm_ptp1588/ptp_common.h
deleted file mode 100644
index 867d525..0000000
--- a/drivers/net/nlm_ptp1588/ptp_common.h
+++ /dev/null
@@ -1,35 +0,0 @@
-#ifndef PTP_COMMON_H
-#define PTP_COMMON_H
-                
-enum {
-    PTP_INIT     = 1, 
-    PTP_TX_TIMESTAMP,        
-    PTP_SET_TIME,
-    PTP_GET_INF_IDX,
-    PTP_SET_INF_IDX,
-    PTP_MAX_IOCTL
- };
-            
-typedef struct _ptp_ts_t_ {
-    u32    ts_msb;
-    u32    ts_lsb;
-    } ptp_ts_t;
-
-typedef struct _ptp_clock_val_t_ {
-       u32 inf_type;
-       u32 inf_idx;
-       u32 offset0;
-       u32 offset1;
-       u32 frac_div;
-       u32 frac_mul;
-       u32 src_div;
-       u32 src_clk;
-    }ptp_clk_t;
-
-typedef struct _intf_type_t_{
-     unsigned char name[8][10];
-     unsigned long numif;
-     unsigned int inf_idx[8];
- } intf_type_t;
-
-#endif
diff --git a/drivers/net/nlm_ptp1588/ptp_main.c b/drivers/net/nlm_ptp1588/ptp_main.c
deleted file mode 100644
index 4150f9a..0000000
--- a/drivers/net/nlm_ptp1588/ptp_main.c
+++ /dev/null
@@ -1,358 +0,0 @@
-#include <linux/module.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-
-#include <linux/kernel.h>	
-#include <linux/slab.h>		
-#include <linux/fs.h>		
-#include <linux/errno.h>	
-#include <linux/types.h>	
-#include <linux/proc_fs.h>
-#include <linux/fcntl.h>	
-#include <linux/seq_file.h>
-#include <linux/cdev.h>
-#include <linux/time.h>
-#include <linux/skbuff.h>
-
-//#include <linux/config.h>
-#include <linux/init.h>
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/pci.h>
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/xlr_mac.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/xlr_user_mac.h>
-#include <asm/netlogic/atx_cpld.h>
-#include <asm/netlogic/xgmac_mdio.h>
-#include <asm/netlogic/proc.h>
-#include <asm-mips/smp.h>
-#include <asm-mips/rmi/iomap.h>
-#include <asm-mips/rmi/gpio.h>
-#include <user/rmi/xlr_user_mac.h>
-#include <asm-mips/div64.h>
-#include "ptp_common.h"
-#include "ptp_mod.h"
-extern struct psb_info *prom_info;
-void dump_all_interface(u32 reg);
-u32 nlm_macreg_get(u32 reg, u32 val);
-void nlm_macreg_set_all(u32 reg, u32 val, u32 mask);
-//int nlm_macreg_set_all(int inf, u32 reg, u32 val, u32 mask);
-int  nlm_macreg_set(int inf, u32 reg, u32 val);
-void nlm_register_ptp_ts_fp(void (*fp) (u32,u32,ktime_t *, u32));
-void nlm_clr_ptp_ts_fp(void);
-void tgl_timer_bit(u32, u32);
-int nlm_mac_get_inf_idx(char *infname);
-
-
-dev_t dev;
-struct cdev cdev;
-spinlock_t ptp_lock;
-struct timespec g_srttime;
-intf_type_t intf;
-
-#define GMAC_CORE_0                 0
-#define GMAC_CORE_1                 4
-ptp_clk_t clk;
-ptp_ts_t     ptp_ts;
-#define PTP1588_CONTROL                 0x077
-
-#define PTP1588_FREQ_MUL                3    
-#define PTP1588_FREQ_INS                2
-#define PTP_TICKS_PER_SEC               66666666ULL // assume 66MHZ
-#define PTP_FRM_MASK                    0x3
-#define ANY_INF                         2
-#define CLK_SRC_DIV                    7
-#define CLK_FREQ_DIV                   10000000
-#define dbg_ptp(...)            
-
-int ptp_ioctl(struct inode *inode, struct file *filp, u32 cmd, unsigned long arg);
-   
-int ptp_open(struct inode *inode, struct file *filp);
-
-struct file_operations ptp_fops = {
-        .owner = THIS_MODULE,
-        .ioctl = ptp_ioctl,
-        .open = ptp_open,
-    };
-#if 0
-unsigned long tmp_buff[1000];
-void dump_offset(void)
-{
-    static u32 prev = 0, cur = 0, idx = 0, iter = 0, cur_sec = 0 , 
-               cur_msec= 0 ,prev_sec = 0, prev_msec = 0, cnt = 0; 
-    int i = 0;
-    u32  msb = 0;
-    u64 cur_tic, tmp_tic;
-    static u64 prev_tic = 0;
-    tgl_timer_bit(1<<12, 1<<12);
-    cur = nlm_macreg_get( 2, PTP_TIMER_LATCH_VAL);
-    msb = nlm_macreg_get( 2, PTP_TIMER_LATCH_VAL1);
-
- 
-//    get_cur_clk_val( &cur, &msb);
-    tmp_tic = cur_tic = ((u64)msb <<32|cur); 
-    #if 0
-    dbg_ptp("dump %u %u off %u systic %lu\n", nlm_macreg_get( 2, PTP_TIMER_LATCH_VAL1), cur, 
-                                   (cur - prev),   nlm_common_timer_get_stats(0)); 
-    #endif
-    tmp_buff[idx] = (cur - prev);
-    if(!(idx = (++idx)%1000)) {
-        iter++;
-     //   for(i = 0; i < 1000 ; i ++) {
-            dbg_ptp("iter %d off[%d] %lu\n",iter, i, tmp_buff[0]);
-       // }
-    }
-    cur_msec  = do_div(tmp_tic, PTP_TICKS_PER_SEC);
-    cur_sec = tmp_tic;
-//    dbg_ptp("cur %lu %lu diff %lu %lu\n", cur_sec, cur_msec, 
-//                                        (cur_sec - prev_sec), (cur_msec- prev_msec));
-    if(!(cnt%1000))
-        dbg_ptp("%u num seco %d tic %lld curtic %lld sec %u %u\n", cnt, cnt/1000, cur_tic - prev_tic, cur_tic, cur_sec, cur_msec);
-    prev_tic = cur_tic;
-    prev_sec = cur_sec;
-    prev_msec = cur_msec;
-
-    cnt ++; 
-    
-    prev = nlm_macreg_get( 2, PTP_TIMER_LATCH_VAL);
-}
-#endif
-
-
-
-void tgl_timer_bit(u32 ctr, u32 mask)
-{
-    nlm_macreg_set_all( PTP1588_CONTROL, 0, mask);
-    nlm_macreg_set_all( PTP1588_CONTROL, ctr, mask);
-    return;
-}
-
-int get_cur_clk_val( u32 *cur, u32 *msb)
-{    
-    tgl_timer_bit( 1<<O_PTP_CTRL_RTC_LATCH, NUM_BITS_1<<O_PTP_CTRL_RTC_LATCH);
-    *cur = nlm_macreg_get( ANY_INF, PTP_TIMER_LATCH_VAL);
-    *msb = nlm_macreg_get( ANY_INF, PTP_TIMER_LATCH_VAL1);
-   return 0;
-}
-
-void set_prepad_frm(u32 frm)
-{
-    nlm_macreg_set_all( R_RX_CONTROL, frm<<O_PTP_Rx1588TS, NUM_BITS_2<<O_PTP_Rx1588TS);
-    dbg_ptp("set format %x\n", 1<<11);
-    return;
-}
-
-
-void set_prepad(u32 enable)
-{
-    nlm_macreg_set_all( R_DESC_PACK_CTRL, (enable<<O_DESC_PACK_CTRL__PrePadEnable) , (NUM_BITS_1<<O_DESC_PACK_CTRL__PrePadEnable));
-    return;
-}
-
-/* 
-
-    Assume only one instance of ptp can run in the box
-    Convert Ticks to seconds and nano seconds
- 
-*/
-void __inline__ ptp_set_tx_ts(u32 sec , u32 usec)
-{
-    spin_lock(&ptp_lock);
-    ptp_ts.ts_msb = usec;
-    ptp_ts.ts_lsb = sec; 
-    spin_unlock(&ptp_lock);
-}
-
-void ptp_set_ts(u32 msb, u32 lsb, ktime_t *tv, u32 flags)
-{
-   u64 cur_tic = ((u64)msb <<32|lsb) ;
-   // total nano seconds 
-   u32 sec = 0, nsec = 0;
-  
-  nsec = (do_div( cur_tic, PTP_TICKS_PER_SEC));
-  sec = cur_tic;
-  nsec += g_srttime.tv_nsec;
-  sec  += g_srttime.tv_sec ;
-
-  if(!tv) {
-    ptp_set_tx_ts( sec , nsec/1000);
-#if 0 
-       dbg_ptp(" TX TV %u %u hex %x %x \n", ptp_ts.ts_msb, ptp_ts.ts_lsb, 
-                                           ptp_ts.ts_msb, ptp_ts.ts_lsb);
-#endif
-
-    } else {
-	    *tv = ktime_set(sec, nsec);
- #if 0 
-   struct timespec l_time;
-       l_time       = current_kernel_time(); 
-       dbg_ptp("RX TV sec %u  usec%u hex %x %x\n", tv->off_sec, tv->off_usec,
-                                         tv->off_sec, tv->off_usec); 
-       dbg_ptp("gxtime %lu %lu\n", g_srttime.tv_sec, g_srttime.tv_nsec);
-       dbg_ptp("xtime  %lu %lu\n", l_time.tv_sec, l_time.tv_nsec);
-       dbg_ptp("sxtime %u %u\n",  tv->off_sec , 
-                                   tv->off_usec);
-#endif
-    }
-
-    return;
-}
-
-void ptp_get_tx_ts(ptp_ts_t *ts)
-{
-    spin_lock(&ptp_lock);
-    ts->ts_msb = ptp_ts.ts_msb; 
-    ts->ts_lsb = ptp_ts.ts_lsb; 
-    spin_unlock(&ptp_lock);
-    return;
-}
-int  ptp_set_clk(ptp_clk_t *clk, int flag)
-{ 
- dbg_ptp("clk %d,div %d, den %d, num %d, off0 %d, off1 %d\n", clk->src_clk, clk->src_div,
-                                                             clk->frac_div, clk->frac_mul,
-                                                             clk->offset0, clk->offset1);
-
- nlm_macreg_set_all( PTP_SOURCE     , clk->src_clk , NUM_BITS_1); 
- nlm_macreg_set_all( PTP_SOURCE_DIV , clk->src_div , NUM_BITS_3); 
- nlm_macreg_set_all( PTP_FRAC_DIV   , clk->frac_div, NUM_BITS_32); 
- nlm_macreg_set_all( PTP_FRAC_MUL   , clk->frac_mul, NUM_BITS_32); 
- nlm_macreg_set_all( PTP_OFFSET0    , clk->offset0 , NUM_BITS_32); 
- nlm_macreg_set_all( PTP_OFFSET1    , clk->offset1 , NUM_BITS_32);
- return 0;
-}
-
-int ptp_open(struct inode *inode, struct file *filp)
-{
-    dbg_ptp("%s\n", __FUNCTION__);
-    return 0;
-}
-
-int init_ptp(void)
-{
-u32  cur = 0 , msb = 0, biu_clk_div = 1;
-u64  cur64, tmp64;
-u32 gpio_reset_cfg = 0;
-nlm_reg_t *gpio_mmio =
-                    (nlm_reg_t *)(netlogic_io_base + NETLOGIC_IO_GPIO_OFFSET); 
-u64 clk_freq = prom_info->cpu_frequency;
-
-gpio_reset_cfg = netlogic_read_reg(gpio_mmio,NETLOGIC_GPIO_PWRON_RESET_CFG_REG);
-
- do_div( clk_freq, CLK_SRC_DIV);
- if(gpio_reset_cfg & (PTP_BIU_HALF_CLOCK) ) {
-        biu_clk_div = 2;
-  } else {
-        biu_clk_div = 1;
-  }
- memset( &clk, 0, sizeof(ptp_clk_t)); 
- 
- clk.src_clk  = PTP_CLK_SRC_CORE; 
-// (Pic clock hz)/(clock hz/src_div)
- clk.frac_mul = 4444444*biu_clk_div;
- dbg_ptp("multi %d \n", (PTP_TICKS_PER_SEC*1000000/(u32)clk_freq));
-// clk.frac_mul = (prom_info->cpu_frequency)*biu_clk_div;
-
- clk.frac_div = CLK_FREQ_DIV;
- clk.src_div  = CLK_SRC_DIV;
-
-// Reset clock 
- tgl_timer_bit(1, NUM_BITS_1);
-
-/*  Set clock
-    u need to toggle the control bits for the setting to work,hardware anomaly */
-
- ptp_set_clk( &clk, 0);
-
-//set prepad format
- set_prepad(1);
- set_prepad_frm(2);
-
- tgl_timer_bit( (1<<PTP1588_FREQ_MUL), (1<<PTP1588_FREQ_MUL));
-//Register timestamp 
-nlm_register_ptp_ts_fp(ptp_set_ts);
-
-
-
-// store the number the "time zero"
-
- tgl_timer_bit((1<<O_PTP_CTRL_RTC_LATCH), (1<<O_PTP_CTRL_RTC_LATCH));
- cur = nlm_macreg_get( ANY_INF, PTP_TIMER_LATCH_VAL);
- msb = nlm_macreg_get( ANY_INF, PTP_TIMER_LATCH_VAL1);
-   
- tmp64=  cur64 = ((u64)msb<<32 | cur);
- g_srttime=  current_kernel_time();
-
- dbg_ptp("INIT gstart %lu %lu \n", g_srttime.tv_sec , g_srttime.tv_nsec);
- g_srttime.tv_nsec -= do_div(cur64, PTP_TICKS_PER_SEC);;
- g_srttime.tv_sec  -= (u32) cur64;
-
- dbg_ptp("INIT start %llu sec %lu nsec %lu \n", tmp64, g_srttime.tv_sec, g_srttime.tv_nsec );
- return 0;
-}
-
-void deinit_ptp(void)
-{
- dbg_ptp("%s\n", __FUNCTION__); 
-// set_prepad(0);
- //set_prepad_frm(0);
- tgl_timer_bit(( 1<<PTP1588_FREQ_MUL) , ( 1<<PTP1588_FREQ_MUL));
- nlm_clr_ptp_ts_fp();
- return;
-}
-
-int ptp_ioctl(struct inode *inode, struct file *filp,
-                 u32 cmd, unsigned long arg)
-{
-int  rc = 0;
-ptp_ts_t ptp;
-ptp_clk_t ptp_clk;
-
-switch (cmd) {
-    case PTP_INIT:
-        dbg_ptp("init %s\n", __FUNCTION__);
-        rc= init_ptp();
-        break;
-    case PTP_GET_INF_IDX:
-        break;
-    case PTP_SET_INF_IDX:
-        copy_from_user( &intf, (const char __user *)arg, sizeof(intf_type_t));
-        dbg_ptp("intfname %s num %ld\n", &intf.name[0][0], intf.numif); 
-        break;
-    case PTP_TX_TIMESTAMP:  
-        dbg_ptp("%s %d\n", __FUNCTION__, cmd);
-        memset( &ptp,  0 , sizeof(ptp));
-        ptp_get_tx_ts(&ptp);   
-        copy_to_user((void *)arg, &ptp, sizeof(ptp_ts_t));
-        break;
-    case PTP_SET_TIME:
-        memset( &ptp_clk, 0, sizeof(ptp_clk_t));
-        copy_from_user( &ptp_clk, (const char __user *)arg, sizeof(ptp_clk_t));
-        rc = ptp_set_clk( &ptp_clk, 0);
-        break;
-    default:
-        dbg_ptp("default\n");
-        break;
-   }
-return rc;
-}
-static int __init init_mod(void)
-{
-int  major = 0;
-   major = register_chrdev( PTP_DEV_MAJOR_NUM, PTP_DRV_NAME, &ptp_fops);
-   
-   spin_lock_init(&ptp_lock);
-   return 0;
-}
-static void __exit exit_mod(void)
-{
-    dbg_ptp("%s \n", __FUNCTION__);
-    unregister_chrdev_region(0, dev);
-    deinit_ptp(); 
-    return;
-}
-EXPORT_SYMBOL(ptp_set_ts);
-module_init(init_mod);
-module_exit(exit_mod);
diff --git a/drivers/net/nlm_ptp1588/ptp_mod.h b/drivers/net/nlm_ptp1588/ptp_mod.h
deleted file mode 100644
index 8a4509b..0000000
--- a/drivers/net/nlm_ptp1588/ptp_mod.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef PTP_MOD_H
-#define PTP_MOD_H
-
-
-#define     PTP_SOURCE_DIV          0x24a
-#define     PTP_SOURCE              0x24b
-#define     PTP_FRAC_DIV            0x70
-#define     PTP_FRAC_MUL            0x71
-#define     PTP_INCR                0x72
-#define     PTP_OFFSET0             0x73
-#define     PTP_OFFSET1             0x74
-#define     PTP_TX_LATCH_LSB        0x75
-#define     PTP_TX_LATCH_MSB        0x76
-#define     PTP_CTRL                0x77
-#define     O_PTP_CTRL_RTC_LATCH    12
-#define     PTP_TIMER_LATCH_VAL     0x7e
-#define     PTP_TIMER_LATCH_VAL1    0x7f
-
-#define     O_PTP_Rx1588TS          11
-
-#define     PTP_BIU_HALF_CLOCK      (1<<23)
-#define     PTP_CLK_SRC_GMAC        0x0
-#define     PTP_CLK_SRC_CORE        0x1
-#define     PTP_DEV_MAJOR_NUM       250
-
-
-#define   NUM_BITS_1        0x1
-#define   NUM_BITS_2        0x3
-#define   NUM_BITS_3        0x7
-#define   NUM_BITS_32       0xffffffff  
-
-#define   PTP_DRV_NAME      "ptp1588"     
-#endif
diff --git a/drivers/net/nlm_rionet.c b/drivers/net/nlm_rionet.c
deleted file mode 100644
index fab2600..0000000
--- a/drivers/net/nlm_rionet.c
+++ /dev/null
@@ -1,615 +0,0 @@
-/*
- * rionet - Ethernet driver over RapidIO messaging services
- *
- * Copyright 2005 MontaVista Software, Inc.
- * Matt Porter <mporter@kernel.crashing.org>
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/dma-mapping.h>
-#include <linux/delay.h>
-#include <linux/rio.h>
-#include <linux/rio_drv.h>
-#include <linux/rio_ids.h>
-
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/crc32.h>
-#include <linux/ethtool.h>
-
-#define DRV_NAME        "rionet"
-#define DRV_VERSION     "0.2"
-#define DRV_AUTHOR      "Matt Porter <mporter@kernel.crashing.org>"
-#define DRV_DESC        "Ethernet over RapidIO"
-
-#define NLM_RIO_MAX_ROUTE_ENTRIES (1<<16)
-MODULE_AUTHOR(DRV_AUTHOR);
-MODULE_DESCRIPTION(DRV_DESC);
-MODULE_LICENSE("GPL");
-
-#define MYDBG(a, ...)
-#define Message(a,b...) //printk("\nFunction [%s], Line [%d] "a"\n",__FUNCTION__,__LINE__,##b)
-
-#define RIONET_DEFAULT_MSGLEVEL \
-			(NETIF_MSG_DRV          | \
-			 NETIF_MSG_LINK         | \
-			 NETIF_MSG_RX_ERR       | \
-			 NETIF_MSG_TX_ERR)
-
-#define RIONET_DOORBELL_JOIN	0x1000
-#define RIONET_DOORBELL_LEAVE	0x1001
-
-#define RIONET_MAILBOX		0
-
-#define RIONET_TX_RING_SIZE	CONFIG_RIONET_TX_SIZE
-#define RIONET_RX_RING_SIZE	CONFIG_RIONET_RX_SIZE
-
-static LIST_HEAD(rionet_peers);
-
-struct rionet_private {
-	struct rio_mport *mport;
-	struct sk_buff *rx_skb[RIONET_RX_RING_SIZE];
-	struct sk_buff *tx_skb[RIONET_TX_RING_SIZE];
-	struct net_device_stats stats;
-	int rx_slot;
-	int tx_slot;
-	int tx_cnt;
-	int ack_slot;
-	spinlock_t lock;
-	spinlock_t tx_lock;
-	spinlock_t tx_cnt_lock;
-	u32 msg_enable;
-};
-
-struct rionet_peer {
-	struct list_head node;
-	struct rio_dev *rdev;
-	struct resource *res;
-};
-
-static int rionet_check = 0;
-static int rionet_capable = 1;
-
-/*
- * This is a fast lookup table for for translating TX
- * Ethernet packets into a destination RIO device. It
- * could be made into a hash table to save memory depending
- * on system trade-offs.
- */
-static struct rio_dev *rionet_active[NLM_RIO_MAX_ROUTE_ENTRIES];
-#if 0
-#define is_rionet_capable(pef, src_ops, dst_ops)		\
-			((pef & RIO_PEF_INB_MBOX) &&		\
-			 (pef & RIO_PEF_INB_DOORBELL) &&	\
-			 (src_ops & RIO_SRC_OPS_DOORBELL) &&	\
-			 (dst_ops & RIO_DST_OPS_DOORBELL))
-#endif
-#define is_rionet_capable(pef, src_ops, dst_ops)		\
-            ((src_ops & RIO_SRC_OPS_DOORBELL) && \
-              (dst_ops & RIO_DST_OPS_DOORBELL) && \
-               (src_ops & RIO_SRC_OPS_DATA_MSG) && \
-               (dst_ops & RIO_DST_OPS_DATA_MSG))
-
-#define dev_rionet_capable(dev) \
-	is_rionet_capable(dev->pef, dev->src_ops, dev->dst_ops)
-
-#define RIONET_MAC_MATCH(x)	(*(u32 *)x == 0x00010001)
-#define RIONET_GET_DESTID(x)	(*(u16 *)(x + 4))
-
-static struct net_device_stats *rionet_stats(struct net_device *ndev)
-{
-	struct rionet_private *rnet = ndev->priv;
-	return &rnet->stats;
-}
-
-static int rionet_rx_clean(struct net_device *ndev)
-{
-	int i;
-	int error = 0;
-	struct rionet_private *rnet = ndev->priv;
-	void *data;
-    volatile unsigned long dummy;
-
-	i = rnet->rx_slot;
-
-	do {
-		if (!rnet->rx_skb[i])
-			continue;
-
-		if (!(data = rio_get_inb_message(rnet->mport, RIONET_MAILBOX))){
-			break;
-        }
-
-        /*dummy read to make sure data is valid!*/
-        dummy = *(volatile unsigned long *)data;
-
-		rnet->rx_skb[i]->data = data;
-		skb_put(rnet->rx_skb[i], RIO_MAX_MSG_SIZE);
-		rnet->rx_skb[i]->dev = ndev;
-		rnet->rx_skb[i]->protocol =
-		    eth_type_trans(rnet->rx_skb[i], ndev);
-		error = netif_rx(rnet->rx_skb[i]);
-
-		if (error == NET_RX_DROP) {
-			rnet->stats.rx_dropped++;
-		} else if (error == NET_RX_BAD) {
-			if (netif_msg_rx_err(rnet))
-				printk(KERN_WARNING "%s: bad rx packet\n",
-				       DRV_NAME);
-			rnet->stats.rx_errors++;
-		} else {
-			rnet->stats.rx_packets++;
-			rnet->stats.rx_bytes += RIO_MAX_MSG_SIZE;
-		}
-
-	} while ((i = (i + 1) % RIONET_RX_RING_SIZE) != rnet->rx_slot);
-
-	return i;
-}
-
-static void rionet_rx_fill(struct net_device *ndev, int end)
-{
-	int i;
-	struct rionet_private *rnet = ndev->priv;
-
-	i = rnet->rx_slot;
-	do {
-		rnet->rx_skb[i] = dev_alloc_skb(RIO_MAX_MSG_SIZE);
-
-		if (!rnet->rx_skb[i])
-			break;
-
-		if(rio_add_inb_buffer(rnet->mport, RIONET_MAILBOX,
-				   rnet->rx_skb[i]->data))
-            break;
-	} while ((i = (i + 1) % RIONET_RX_RING_SIZE) != end);
-
-	rnet->rx_slot = i;
-}
-
-static int rionet_queue_tx_msg(struct sk_buff *skb, struct net_device *ndev,
-			       struct rio_dev *rdev)
-{
-	struct rionet_private *rnet = ndev->priv;
-    int len = skb->len;
-    unsigned long flags;
-    int ret = 0;
-
-    if(len & 0x7)
-        len = (len + 0x7) & ~(0x7);
-
-	if(rio_add_outb_message(rnet->mport, rdev, 0, skb->data, len))
-        return -EIO;
-
-	rnet->tx_skb[rnet->tx_slot] = skb;
-
-	rnet->stats.tx_packets++;
-	rnet->stats.tx_bytes += skb->len;
-
-    spin_lock_irqsave(&rnet->tx_cnt_lock, flags);
-    rnet->tx_cnt++;
-	if (rnet->tx_cnt == RIONET_TX_RING_SIZE){
-        MYDBG("Max tx_cnt reached stopping queue");
-		netif_stop_queue(ndev);
-    }
-    spin_unlock_irqrestore(&rnet->tx_cnt_lock, flags);
-
-	++rnet->tx_slot;
-	rnet->tx_slot &= (RIONET_TX_RING_SIZE - 1);
-
-	if (netif_msg_tx_queued(rnet))
-		printk(KERN_INFO "%s: queued skb %8.8x len %8.8x\n", DRV_NAME,
-		       (u32) skb, skb->len);
-
-	return ret;
-}
-
-static int rionet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
-{
-	int i;
-	struct rionet_private *rnet = ndev->priv;
-	struct ethhdr *eth = (struct ethhdr *)skb->data;
-	u16 destid;
-	unsigned long flags;
-    int ret = 0;
-
-	local_irq_save(flags);
-	if ((rnet->tx_cnt + 1) > RIONET_TX_RING_SIZE) {
-        MYDBG("Stopping queue");
-		netif_stop_queue(ndev);
-		local_irq_restore(flags);
-		printk(KERN_ERR "%s: BUG! Tx Ring full when queue awake!\n",
-		       ndev->name);
-		return NETDEV_TX_BUSY;
-	}
-
-	if (eth->h_dest[0] & 0x01) {
-		for (i = 0; i < NLM_RIO_MAX_ROUTE_ENTRIES; i++){
-			if (rionet_active[i]){
-				if((ret = rionet_queue_tx_msg(skb, ndev,
-						    rionet_active[i]))){
-                    MYDBG("Xmit failed!!!\n");
-                    break;
-                }
-            }
-        }
-	} else if (RIONET_MAC_MATCH(eth->h_dest)) {
-		destid = RIONET_GET_DESTID(eth->h_dest);
-		if (rionet_active[destid]){
-			ret = rionet_queue_tx_msg(skb, ndev, rionet_active[destid]);
-            if(ret)
-                MYDBG("XMIT FAILED!!\n");
-        }
-	}else{
-        ret = -EIO;
-	}
-
-    local_irq_restore(flags);
-	return ret;
-}
-
-static void rionet_dbell_event(struct rio_mport *mport, void *dev_id, u16 sid, 
-                                u16 tid, u16 info)
-{
-	struct net_device *ndev = dev_id;
-	struct rionet_private *rnet = ndev->priv;
-	struct rionet_peer *peer;
-
-	if (netif_msg_intr(rnet))
-		printk(KERN_INFO "%s: doorbell sid %4.4x tid %4.4x info %4.4x",
-		       DRV_NAME, sid, tid, info);
-	if (info == RIONET_DOORBELL_JOIN) {
-		if (!rionet_active[sid]) {
-			list_for_each_entry(peer, &rionet_peers, node) {
-				if (peer->rdev->destid == sid)
-					rionet_active[sid] = peer->rdev;
-			}
-			rio_mport_send_doorbell(mport, sid,
-						RIONET_DOORBELL_JOIN);
-		}
-	} else if (info == RIONET_DOORBELL_LEAVE) {
-		rionet_active[sid] = NULL;
-	} else {
-		if (netif_msg_intr(rnet))
-			printk(KERN_WARNING "%s: unhandled doorbell\n",
-			       DRV_NAME);
-	}
-}
-
-static void rionet_inb_msg_event(struct rio_mport *mport, void *dev_id, int mbox, int slot)
-{
-	int n;
-	struct net_device *ndev = dev_id;
-	struct rionet_private *rnet = (struct rionet_private *)ndev->priv;
-
-	if (netif_msg_intr(rnet))
-		printk(KERN_INFO "%s: inbound message event, mbox %d slot %d\n",
-		       DRV_NAME, mbox, slot);
-
-	spin_lock(&rnet->lock);
-	if ((n = rionet_rx_clean(ndev)) != rnet->rx_slot)
-		rionet_rx_fill(ndev, n);
-	spin_unlock(&rnet->lock);
-}
-
-static void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbox, int slot)
-{
-	struct net_device *ndev = dev_id;
-	struct rionet_private *rnet = ndev->priv;
-
-	spin_lock(&rnet->lock);
-    MYDBG("Rcvd TX OK!!! - slot %d, ack_slot = %d",slot,rnet->ack_slot);
-	if (netif_msg_intr(rnet))
-		printk(KERN_INFO
-		       "%s: outbound message event, mbox %d slot %d\n",
-		       DRV_NAME, mbox, slot);
-
-	while (rnet->tx_cnt && (rnet->ack_slot != slot)) {
-		/* dma unmap single */
-		dev_kfree_skb_irq(rnet->tx_skb[rnet->ack_slot]);
-		rnet->tx_skb[rnet->ack_slot] = NULL;
-		++rnet->ack_slot;
-		rnet->ack_slot &= (RIONET_TX_RING_SIZE - 1);
-        spin_lock(&rnet->tx_cnt_lock);
-		rnet->tx_cnt--;
-        spin_unlock(&rnet->tx_cnt_lock);
-	}
-
-    spin_lock(&rnet->tx_cnt_lock);
-	if (rnet->tx_cnt < RIONET_TX_RING_SIZE){
-        MYDBG("Waking queue\n");
-		netif_wake_queue(ndev);
-    }
-    spin_unlock(&rnet->tx_cnt_lock);
-
-	spin_unlock(&rnet->lock);
-}
-
-static int rionet_open(struct net_device *ndev)
-{
-	int i, rc = 0;
-	struct rionet_peer *peer, *tmp;
-	struct rionet_private *rnet = ndev->priv;
-
-	if (netif_msg_ifup(rnet))
-		printk(KERN_INFO "%s: open\n", DRV_NAME);
-
-	/* Initialize inbound message ring */
-	for (i = 0; i < RIONET_RX_RING_SIZE; i++)
-		rnet->rx_skb[i] = NULL;
-	rnet->rx_slot = 0;
-
-	if ((rc = rio_request_inb_dbell(rnet->mport,
-					(void *)ndev,
-					RIONET_DOORBELL_JOIN,
-					RIONET_DOORBELL_LEAVE,
-					rionet_dbell_event)) < 0)
-		goto out;
-
-	if ((rc = rio_request_inb_mbox(rnet->mport,
-				       (void *)ndev,
-				       RIONET_MAILBOX,
-				       RIONET_RX_RING_SIZE,
-				       rionet_inb_msg_event)) < 0)
-		goto out;
-
-	if ((rc = rio_request_outb_mbox(rnet->mport,
-					(void *)ndev,
-					RIONET_MAILBOX,
-					RIONET_TX_RING_SIZE,
-					rionet_outb_msg_event)) < 0)
-		goto out;
-
-	rionet_rx_fill(ndev, 0);
-
-	rnet->tx_slot = 0;
-	rnet->tx_cnt = 0;
-	rnet->ack_slot = 0;
-
-	netif_carrier_on(ndev);
-	netif_start_queue(ndev);
-
-	list_for_each_entry_safe(peer, tmp, &rionet_peers, node) {
-		if (!(peer->res = rio_request_outb_dbell(peer->rdev,
-							 RIONET_DOORBELL_JOIN,
-							 RIONET_DOORBELL_LEAVE)))
-		{
-			printk(KERN_ERR "%s: error requesting doorbells\n",
-			       DRV_NAME);
-			continue;
-		}
-
-		/*
-		 * send a join message to peer.
-		 */
-			rio_send_doorbell(peer->rdev, RIONET_DOORBELL_JOIN);
-	}
-
-	return rc;
-      out:
-	return rc;
-}
-
-static int rionet_close(struct net_device *ndev)
-{
-	struct rionet_private *rnet = (struct rionet_private *)ndev->priv;
-	struct rionet_peer *peer, *tmp;
-	int i;
-
-	if (netif_msg_ifup(rnet))
-		printk(KERN_INFO "%s: close\n", DRV_NAME);
-
-    MYDBG("Stopping queue");
-	netif_stop_queue(ndev);
-	netif_carrier_off(ndev);
-
-	list_for_each_entry_safe(peer, tmp, &rionet_peers, node) {
-		if (rionet_active[peer->rdev->destid]) {
-			rio_send_doorbell(peer->rdev, RIONET_DOORBELL_LEAVE);
-		}
-		rio_release_outb_dbell(peer->rdev, peer->res);
-	}
-
-	rio_release_inb_dbell(rnet->mport, RIONET_DOORBELL_JOIN,
-			      RIONET_DOORBELL_LEAVE);
-	rio_release_inb_mbox(rnet->mport, RIONET_MAILBOX);
-	rio_release_outb_mbox(rnet->mport, RIONET_MAILBOX);
-
-
-	for (i = 0; i < RIONET_RX_RING_SIZE; i++)
-		if (rnet->rx_skb[i])
-			kfree_skb(rnet->rx_skb[i]);
-
-	return 0;
-}
-
-static void rionet_remove(struct rio_dev *rdev)
-{
-	struct net_device *ndev = NULL;
-	struct rionet_peer *peer, *tmp;
-
-	unregister_netdev(ndev);
-	kfree(ndev);
-
-	list_for_each_entry_safe(peer, tmp, &rionet_peers, node) {
-		list_del(&peer->node);
-		kfree(peer);
-	}
-}
-
-static void rionet_get_drvinfo(struct net_device *ndev,
-			       struct ethtool_drvinfo *info)
-{
-	struct rionet_private *rnet = ndev->priv;
-
-	strcpy(info->driver, DRV_NAME);
-	strcpy(info->version, DRV_VERSION);
-	strcpy(info->fw_version, "n/a");
-	strcpy(info->bus_info, rnet->mport->name);
-}
-
-static u32 rionet_get_msglevel(struct net_device *ndev)
-{
-	struct rionet_private *rnet = ndev->priv;
-
-	return rnet->msg_enable;
-}
-
-static void rionet_set_msglevel(struct net_device *ndev, u32 value)
-{
-	struct rionet_private *rnet = ndev->priv;
-
-	rnet->msg_enable = value;
-}
-
-static const struct ethtool_ops rionet_ethtool_ops = {
-	.get_drvinfo = rionet_get_drvinfo,
-	.get_msglevel = rionet_get_msglevel,
-	.set_msglevel = rionet_set_msglevel,
-	.get_link = ethtool_op_get_link,
-};
-
-static int rionet_setup_netdev(struct rio_mport *mport)
-{
-	int rc = 0;
-	struct net_device *ndev = NULL;
-	struct rionet_private *rnet;
-	u16 device_id;
-
-	/* Allocate our net_device structure */
-	ndev = alloc_etherdev(sizeof(struct rionet_private));
-	if (ndev == NULL) {
-		printk(KERN_INFO "%s: could not allocate ethernet device.\n",
-		       DRV_NAME);
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	/* Set up private area */
-	rnet = (struct rionet_private *)ndev->priv;
-	rnet->mport = mport;
-
-	/* Set the default MAC address */
-	device_id = rio_local_get_device_id(mport);
-	ndev->dev_addr[0] = 0x00;
-	ndev->dev_addr[1] = 0x01;
-	ndev->dev_addr[2] = 0x00;
-	ndev->dev_addr[3] = 0x01;
-	ndev->dev_addr[4] = device_id >> 8;
-	ndev->dev_addr[5] = device_id & 0xff;
-
-	/* Fill in the driver function table */
-	ndev->open = &rionet_open;
-	ndev->hard_start_xmit = &rionet_start_xmit;
-	ndev->stop = &rionet_close;
-	ndev->get_stats = &rionet_stats;
-	ndev->mtu = RIO_MAX_MSG_SIZE - 14;
-	SET_ETHTOOL_OPS(ndev, &rionet_ethtool_ops);
-
-	spin_lock_init(&rnet->lock);
-	spin_lock_init(&rnet->tx_lock);
-	spin_lock_init(&rnet->tx_cnt_lock);
-
-	rnet->msg_enable = RIONET_DEFAULT_MSGLEVEL;
-
-	rc = register_netdev(ndev);
-	if (rc != 0)
-		goto out;
-
-	printk("%s: %s %s Version %s, MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
-	       ndev->name,
-	       DRV_NAME,
-	       DRV_DESC,
-	       DRV_VERSION,
-	       ndev->dev_addr[0], ndev->dev_addr[1], ndev->dev_addr[2],
-	       ndev->dev_addr[3], ndev->dev_addr[4], ndev->dev_addr[5]);
-
-      out:
-	return rc;
-}
-
-/*
- * XXX Make multi-net safe
- */
-static int rionet_probe(struct rio_dev *rdev, const struct rio_device_id *id)
-{
-	int rc = -ENODEV;
-	u32 lpef, lsrc_ops, ldst_ops;
-	struct rionet_peer *peer;
-
-	/* If local device is not rionet capable, give up quickly */
-	if (!rionet_capable)
-		goto out;
-
-	/*
-	 * First time through, make sure local device is rionet
-	 * capable, setup netdev,  and set flags so this is skipped
-	 * on later probes
-	 */
-	if (!rionet_check) {
-		rio_local_read_config_32(rdev->net->hport, RIO_PEF_CAR, &lpef);
-		rio_local_read_config_32(rdev->net->hport, RIO_SRC_OPS_CAR,
-					 &lsrc_ops);
-		rio_local_read_config_32(rdev->net->hport, RIO_DST_OPS_CAR,
-					 &ldst_ops);
-		if (!is_rionet_capable(lpef, lsrc_ops, ldst_ops)) {
-			printk(KERN_ERR
-			       "%s: local device is not network capable\n",
-			       DRV_NAME);
-			rionet_check = 1;
-			rionet_capable = 0;
-			goto out;
-		}
-
-		rc = rionet_setup_netdev(rdev->net->hport);
-		rionet_check = 1;
-	}
-
-	/*
-	 * If the remote device has mailbox/doorbell capabilities,
-	 * add it to the peer list.
-	 */
-	if (dev_rionet_capable(rdev)) {
-		if (!(peer = kmalloc(sizeof(struct rionet_peer), GFP_KERNEL))) {
-			rc = -ENOMEM;
-			goto out;
-		}
-		peer->rdev = rdev;
-        rionet_active[rdev->destid] = peer->rdev;
-		list_add_tail(&peer->node, &rionet_peers);
-	}
-
-      out:
-	return rc;
-}
-
-static struct rio_device_id rionet_id_table[] = {
-	{RIO_DEVICE(RIO_ANY_ID, RIO_ANY_ID)}
-};
-
-static struct rio_driver rionet_driver = {
-	.name = "rionet",
-	.id_table = rionet_id_table,
-	.probe = rionet_probe,
-	.remove = rionet_remove,
-};
-
-static int __init rionet_init(void)
-{
-	return rio_register_driver(&rionet_driver);
-}
-
-static void __exit rionet_exit(void)
-{
-	rio_unregister_driver(&rionet_driver);
-}
-
-module_init(rionet_init);
-module_exit(rionet_exit);
diff --git a/drivers/net/nlm_spi4/Makefile b/drivers/net/nlm_spi4/Makefile
deleted file mode 100644
index fa7b0d6..0000000
--- a/drivers/net/nlm_spi4/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-################################################################################
-
-#
-# Makefile for the nlm_spi4 ethernet driver
-#
-EXTRA_CFLAGS := -Werror
-
-obj-$(CONFIG_NLMCOMMON_SPI4) += os_layer.o nlm_spi4.o nlm_vits_eth.o vitesse_highlevel.o \
-                            vitesse_io.o vitesse_phy_ctrl.o nlm_vits_driver.o  nlm_vits_wrapper.o
diff --git a/drivers/net/nlm_spi4/meigsii_reg.h b/drivers/net/nlm_spi4/meigsii_reg.h
deleted file mode 100644
index 1b26f8b..0000000
--- a/drivers/net/nlm_spi4/meigsii_reg.h
+++ /dev/null
@@ -1,459 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/************************************************************-*- mode: C -*-*/
-/*                                                                          */
-/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
-/*                           All Rights Reserved.                           */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*                            Copyright Notice:                             */
-/*                                                                          */
-/*  Unpublished rights reserved under the copyright laws of the             */
-/*  United States of America, other countries and international treaties.   */
-/*  The software is provided without fee.                                   */  
-/*  Permission to use,  copy, store, modify, disclose, transmit or          */
-/*  distribute the software is granted, provided that this copyright        */
-/*  notice must appear in any copy, modification, disclosure,               */
-/*  transmission or distribution of the software.                           */
-/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
-/*  trade secret and proprietary rights in the software.                    */
-/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
-/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
-/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*                                                                          */
-/*  meigsii_reg.h  -- Definitions for Meigs-II chip internal registers.     */
-/*                                                                          */
-/*                                                                          */
-/* The general rule used for naming the registers is to prefix M2_ to the   */
-/* register name as described in the datasheet, using all capital letters.  */
-/* However, there are a few deviations, which are kept to a minimum and     */
-/* pointed out in the code using comments.                                  */
-/*                                                                          */
-/*                                                                          */
-/*                                                                          */
-/****************************************************************************/
-#ifndef _MEIGSII_REG_H
-#define _MEIGSII_REG_H 1
-
-
-/*
- * Register Addressing:
- *
- * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
- * |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
- * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
- * |Block ID| Sub Block |    Register Address   |WS|
- * +--------+--+--+--+--+--+--+--+--+--+--+--+--+--+
- *
- * The WS (Word Select) bit selects between the most or least
- * significant 16 bits of the register. Which one it selects
- * depends on the endian mode set in the Parallel Interface
- * setup register.
- */
-
-/*
-#define M2_REG_ADDR(block,subblock,register) (((block)<<13)|((subblock)<<9)|((register)<<1))
-
-*/
-
-/* Meigs-II Block IDs */
-
-#define M2_BLK_MACS     1       /* Port - Sub Block: 0-10)                */
-#define M2_BLK_FIFO     2       /* FIFOs - Sub Block: 0 Ingress           */
-                                /*                    1 Egress            */
-#define M2_BLK_MIIM     3       /* MII Management - Sub Block: 0-1)       */
-#define M2_BLK_STAT     4       /* Statistics - Sub Block: 0-10)          */
-#define M2_BLK_SPI4     5       /* SPI-4.2 I/F - Sub Block: 0)            */
-#define M2_BLK_SYSTEM   7       /* System Regs - Sub Block: 1 Aggregator  */
-                                /*                          2 Ram BIST    */
-                                /*                          F Regs/CPU IF */
-
-
-/* Meigs-II Sub Block IDs */
-
-#define M2_SUBBLK_MIIM_0 0      /* MII Management Sub Block 0 */
-#define M2_SUBBLK_MIIM_1 1      /* MII Management Sub Block 1 */
-
-
-
-/* System Block Registers (Block ID: SYSTEM) */
-/* Subblock Control 0x0F */
-#define M2_SUBBLK_CTRL      0x0F
-/* Subblock Aggregator 0x01 */
-#define M2_SUBBLK_AGGR      0x01
-/* Subblock BIST 0x02 */
-#define M2_SUBBLK_BIST      0x02
-
-
-/* Block without subblocks -- currently only the value of '0' is used */
-#define M2_SUBBLK_NONE      0x00
-
-/* Two fifo's subblocks */
-#define M2_SUBBLK_INGRESS   0x00
-#define M2_SUBBLK_EGRESS    0x01
-
-/* 10x1G mac subblocks + 1x10G mac */
-#define M2_SUBBLK_MAC_10G   0x0A
-
-
-
-#define M2_CHIPID           0x00    /* Chip Identification */
-#define M2_BLADE_ID         0x01    /* Blade Identification */
-#define M2_SW_RESET         0x02    /* Global Software Reset */
-#define M2_IFACE_MODE       0x07    /* Interface Mode */
-#define M2_CRC_CNT          0x0A    /* CRC Error Count */
-#define M2_CRC_CFG          0x0B    /* CRC Configuration */
-#define M2E_SI_INSERT_BYTES 0x0F    /* SI insert bytes on read */
-#define M2_SI_TRANSFER_SEL  0x18    /* SI Transfer Select */
-#define M2_PLL_CLK_SPEED    0x19    /* Clock Speed Selection */
-#define M2_SYS_CLK_SELECT   0x1C    /* System Clock Select */
-#define M2_GPIO_CTRL        0x1D    /* GPIO Control */
-#define M2_GPIO_OUT         0x1E    /* GPIO Out */
-#define M2_GPIO_IN          0x1F    /* GPIO In */
-#define M2_CPU_TRANSFER_SEL 0x20    /* CPU Transfer Select */
-#define M2_LOCAL_DATA       0xFE    /* Local CPU Data */
-#define M2_LOCAL_STATUS     0xFF    /* Local CPU Status */
-
-/* System Block Registers (Block ID: SYSTEM) */
-/* Subblock Aggregator 0x01 */
-#define M2_AGGR_SETUP       0x00    /* Aggregator Setup */
-#define M2_PMAP_TABLE       0x01    /* Port Map Table */
-#define M2_MPLS_BIT0        0x08    /* MPLS Bit0 Position */
-#define M2_MPLS_BIT1        0x09    /* MPLS Bit1 Position */
-#define M2_MPLS_BIT2        0x0A    /* MPLS Bit2 Position */
-#define M2_MPLS_BIT3        0x0B    /* MPLS Bit3 Position */
-#define M2_MPLS_BITMASK     0x0C    /* MPLS Bit Mask */
-#define M2_PRE_BIT0POS      0x10    /* Preamble Bit0 Position */
-#define M2_PRE_BIT1POS      0x11    /* Preamble Bit1 Position */
-#define M2_PRE_BIT2POS      0x12    /* Preamble Bit2 Position */
-#define M2_PRE_BIT3POS      0x13    /* Preamble Bit3 Position */
-#define M2_PRE_ERR_CNT      0x14    /* Preamble Parity Error Counter */
-
-/* System Block Registers (Block ID: SYSTEM) */
-/* Subblock BIST 0x02 */
-
-#define M2_RAM_BIST_CMD     0x00    /* RAM BIST Command */
-#define M2_RAM_BIST_RESULT  0x01    /* RAM BIST Read Status & Read Result */
-
-/* System Block Registers (Block ID: SYSTEM) */
-/* Subblock BIST 0x02, Indirect BIST Register */
-
-#define M2_BIST_PORT_SELECT 0x00    /* BIST Port Select */
-#define M2_BIST_COMMAND     0x01    /* BIST Command */
-#define M2_BIST_STATUS      0x02    /* BIST Status */
-#define M2_BIST_ERR_CNT_LSB 0x03    /* BIST Error Count LSB */
-#define M2_BIST_ERR_CNT_MSB 0x04    /* BIST Error Count MSB */
-#define M2_BIST_ERR_SEL_LSB 0x05    /* BIST Error Select LSB */
-#define M2_BIST_ERR_SEL_MSB 0x06    /* BIST Error Select MSB */
-#define M2_BIST_ERROR_STATE 0x07    /* BIST Error State */
-#define M2_BIST_ERR_ADR0    0x08    /* BIST Error Address 0 */
-#define M2_BIST_ERR_ADR1    0x09    /* BIST Error Address 1 */
-#define M2_BIST_ERR_ADR2    0x0A    /* BIST Error Address 2 */
-#define M2_BIST_ERR_ADR3    0x0B    /* BIST Error Address 3 */
-
-/* FIFO Block Registers (Block ID: FIFO) */
-/* Subblock Ingress 0x00 */
-/* Subblock Egress 0x01 */
-/* These values are actually base addresses where the actual port
- * address is obtained by adding the port # (0-9) to the address
- */
-
-#define M2_TEST             0x00    /* Mode & Test */
-#define M2_TOP_BOTTOM       0x10    /* FIFO Buffer Top & Bottom */
-#define M2_TAIL             0x20    /* Write Pointer */
-#define M2_HEAD             0x30    /* Read Pointer */
-#define M2_HIGH_LOW_WM      0x40    /* Flow Control Water Marks */
-#define M2_CT_THRHLD        0x50    /* Cut Through Threshold */
-#define M2_FIFO_DROP_CNT    0x60    /* Drop & CRC Error Counter */
-#define M2_DEBUG_BUF_CNT    0x70    /* Input Side Debug Counter */
-
-/* FIFO Block Registers (Block ID: FIFO) */
-/* Subblock Ingress 0x00 */
-/* Subblock Egress 0x01 */
-
-#define M2_TRAFFIC_SHAPER_BUCKET0  0x0A    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET1  0x1A    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET2  0x2A    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET3  0x3A    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET4  0x4A    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET5  0x5A    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET6  0x6A    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET7  0x7A    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET8  0x0B    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET9  0x1B    /* Traffic Shaper Bucket Setting */
-#define M2_TRAFFIC_SHAPER_BUCKET10 0x2B    /* Traffic Shaper Bucket Setting */
-
-#define M2_TRAFFIC_SHAPER_CTRL     0x3B    /* Traffic Shaper Control Register */
-
-
-#define M2_SRAM_ADR         0x0E    /* SRAM Address in FIFO Buffer */
-#define M2_SRAM_WR_STRB     0x1E    /* SRAM Write Storage Block */
-#define M2_SRAM_RD_STRB     0x2E    /* SRAM Read Storage Block */
-#define M2_SRAM_DATA_0      0x3E    /* Bytes  3-0 of Data in Block */
-#define M2_SRAM_DATA_1      0x4E    /* Bytes  7-4 of Data in Block */
-#define M2_SRAM_DATA_2      0x5E    /* Bytes 11-8 of Data in Block */
-#define M2_SRAM_DATA_3      0x6E    /* Bytes 15-12 of Data in Block */
-#define M2_DATA_BLK_TYPE    0x7E    /* Data Block Type */
-
-
-/* FIFO Block Registers (Block ID: FIFO) */
-/* Subblock Ingress 0x00 */
-
-#define M2_ING_CONTROL      0x0F    /* Ingress Control */
-
-/* FIFO Block Registers (Block ID: FIFO) */
-/* Subblock Egress 0x01 */
-
-#define M2_EGR_CONTROL      0x0F    /* Egress Control */
-
-/* FIFO Block Registers (Block ID: FIFO) */
-/* Subblock Ingress 0x00 */
-/* Subblock Egress 0x01 */
-
-#define M2_AGE_TIMER        0x1F    /* Age Timer */
-#define M2_AGE_INC          0x2F    /* Age Increment */
-#define M2_DEBUG_OUT        0x3F    /* Output Side Debug Counter Control */
-#define M2_DEBUG_CNT        0x4F    /* Output Side Debug Counter */
-
-
-/* SPI-4.2 Host Interface Block Registers (Block ID: SPI4) */
-/* Subblock SPI-4.2 Interface 0x00 */
-
-#define M2_SPI4_MISC        0x00    /* Miscellaneous */
-#define M2_SPI4_STATUS      0x01    /* CML Status */
-#define M2_SPI4_ING_SETUP0  0x02    /* Ingress Status Channel Setup */
-#define M2_SPI4_ING_SETUP1  0x03    /* Ingress Data Training Setup */
-#define M2_SPI4_ING_SETUP2  0x04    /* Ingress Data Burst Sizes Setup */
-#define M2_SPI4_EGR_SETUP0  0x05    /* Egress Status Channel Setup */
-#define M2_SPI4_DBG_CNT     0x10    /* Debug Counters (Add Port # 0 - 9) */
-#define M2_SPI4_DBG_SETUP   0x1A    /* Counters Setup */
-
-#define M2_SPI4_TEST        0x20    /* Test Setup */
-#define M2_TPGEN_UP0        0x21    /* Test Pattern Generator User Pattern0 */
-#define M2_TPGEN_UP1        0x22    /* Test Pattern Generator User Pattern1 */
-#define M2_TPCHK_UP0        0x23    /* Test Pattern Checker User Pattern0 */
-#define M2_TPCHK_UP1        0x24    /* Test Pattern Checker User Pattern1 */
-#define M2_TPSAM_P0         0x25    /* Sampled Pattern 0 */
-#define M2_TPSAM_P1         0x26    /* Sampled Pattern 1 */
-#define M2_TPERR_CNT        0x27    /* Pattern Checker Error Counter */
-#define M2_SPI4_STICKY      0x30    /* Sticky Bits */
-
-#define M2_SPI4_DBG_INH     0x31    /* MeigsII Core Egress & Ingress Inhibit */
-#define M2_SPI4_DBG_STATUS  0x32    /* Sampled Ingress Status Channel */
-#define M2_SPI4_DBG_GRANT   0x33    /* Ingress Status Channel Granted
-                                       Credit Value */
-
-/* MAC Block Registers (Block ID: MAC) */
-/* Subblock 10 GbE 0x0A */
-
-#define M2_MISC_10G          0x00    /* Miscellaneous 10GbE Setup */
-#define M2_PAUSE             0x01    /* Pause */
-#define M2_MAX_LEN           0x02    /* Max Length */
-#define M2_MAC_HIGH_ADDR     0x03    /* MAC High Address */
-#define M2_MAC_LOW_ADDR      0x04    /* MAC Low Address */
-#define M2_NORMALIZER        0x05    /* Normalizer Control */
-#define M2_STICKY_RX         0x06    /* RX Debug */
-#define M2_DENORM            0x07    /* Denormalizer Control */
-#define M2_STICKY_TX         0x08    /* TX Debug */
-#define M2_MAC_RXHIGH        0x0A    /* XGMII Lane 0-3 Debug */
-#define M2_MAC_RXLOW         0x0B    /* XGMII Lane 4-7 Debug */
-#define M2_MAC_TX_STICKY     0x0C    /* MAC TX State Sticky Debug */
-#define M2_MAC_TX_RUNNING    0x0D    /* MAC TX State Running Debug */
-#define M2_TX_ABORT_AGE      0x14    /* Aged TX Frames Discards Counter */
-#define M2_TX_ABORT_SHORT    0x15    /* Short TX Frames Discards Counter */
-#define M2_TX_ABORT_TAXI     0x16    /* Taxi Error TX Frames Discards 
-                                        Counter */
-#define M2_TX_ABORT_UNDERRUN 0x17    /* TX Underrun Abort Discards Counter */
-#define M2_TX_DENORM_DISCARD 0x18    /* TX Denormalizer Discards Counter */
-
-#define M2_XAUI_STAT_A       0x20    /* XAUI Status Register A */
-#define M2_XAUI_STAT_B       0x21    /* XAUI Status Register B */
-#define M2_XAUI_STAT_C       0x22    /* XAUI Status Register C */
-#define M2_XAUI_CONF_A       0x23    /* XAUI Configuration Register A */
-#define M2_XAUI_CONF_B       0x24    /* XAUI Configuration Register B */
-#define M2_XAUI_CODE_GRP_CNT 0x25    /* XAUI Code Group Error Counter */
-#define M2_XAUI_CONF_TEST_A  0x26    /* XAUI Test Register A */
-#define M2_PDERRCNT          0x27    /* XAUI Test Register B */
-
-/* MAC Block Registers (Block ID: MAC) */
-/* Subblock Tri-Speed MACs 0x00-0x09 */
-
-#define M2_MODE_CFG          0x00    /* Mode Configuration */
-#define M2_PAUSE_CFG         0x01    /* Pause Configuration */
-#define M2_MAXLEN_CFG        0x02    /* Max Length Configuration */
-#define M2_MAC_ADDR_HIGH_CFG 0x03    /* MAC Address Configuration - High */
-#define M2_MAC_ADDR_LOW_CFG  0x04    /* MAC Address Configuration - Low */
-/* Following #define is duplicate of 10 GbE version, so redefine the name
- * to avoid namespace collision, although, the value is equivalent, so
- * it's benign to use either #define
- */
-#define M2_TRI_NORMALIZER    0x05    /* Tri-Speed MAC Normalizer */
-#define M2_PCS_STATUS        0x06    /* PCS Status */
-#define M2_PCS_STATUS_DBG    0x07    /* PCS Status Debug */
-#define M2_PCS_CTRL          0x08    /* PCS Control */
-#define M2_PCS_CONFIG        0x09    /* PCS Configuration */
-#define M2_STICK_BIT         0x0A    /* Sticky Bits */
-#define M2_DEV_SETUP         0x0B    /* Tri-Speed MAC Clock/Reset Setup */
-#define M2_DROP_CNT          0x0C    /* Drop Counter */
-#define M2_PORT_POS          0x0D    /* Preamble Port Position */
-#define M2_SERDES_CONF       0x0F    /* SerDes Configuration */
-#define M2_SERDES_TEST       0x10    /* SerDes Test */
-#define M2_SERDES_STAT       0x11    /* SerDes Status */
-#define M2_SERDES_COM_CNT    0x12    /* SerDes Comma Detect Counter */
-
-
-#define M2E_TRI_MULTI_DBG    0x0E    /* Multidebug register */
-
-
-/* M2_DENORM is already defined as 0x07 for 10 GbE, but it's 0x15 for
- * tri-speed macs.  This is an unfortunate name collision in the manual,
- * so define it as M2_TRI_DENORM for tri-speed macs. Unfortunately, it is
- * not benign to mix up the tri-speed and 10G #defines!!!
- */
-
-#define M2_TRI_DENORM        0x15    /* Frame Denormalization */
-
-#define M2E_TX_IFG           0x18    /* Tx Inter Frame Gap configuration */
-#define M2E_ADV_HDX_CFG      0x19    /* Advance Half Duplex configuration */
-
-
-/* Only Campbell-I have the following GFP-T registers */
-#define C1_GFPT_CONFIG       0x1A    /* GFP-T block configuration */
-#define C1_GFPT_CLIENT1      0x1B    /* Client signal configuration */
-#define C1_GFPT_CLIENT2      0x1C    /* Rate adaptation configuration */
-#define C1_GFPT_BLOCK_CODE   0x1D    /* GFP-T block encode */
-#define C1_GFPT_FRM_LEN      0x1E    /* GFP-T Frame length */
-#define C1_GFPT_HEAD_ENA     0x1F    /* GFP-T header expectation/generation */
-#define C1_GFPT_BIT_ERR_CORR  0x20   /* Bit error correction configuration */
-#define C1_GFPT_BIT_ERR_POS1  0x21   /* Bit error insertion position 1 */
-#define C1_GFPT_BIT_ERR_POS2  0x22   /* Bit error insertion position 2 */
-#define C1_GFPT_BIT_ERR_ONCE  0x23   /* Force bit error insertion once or continuously */
-#define C1_GFPT_BIT_ERR_FORCE 0x24   /* Force bit error insert at pos1 and/or pos2 */
-#define C1_GFPT_STATUS       0x25    /* GFPT Status */
-#define C1_GFPT_PCS_RX       0x26    /* PCS RX Setup */
-#define C1_GFPT_PCS_TX       0x27    /* PCS TX Setup */
-
-
-/* Statistics Block Registers (Block ID: STATISTICS) */
-/* Subblock Tri-Speed MACs 0x00-0x09 */
-
-#define M2_RX_IN_BYTES       0x00    /* RX # of Nibbles or Bytes */
-#define M2_RX_SYMBOL_CARRIER 0x01    /* RX # of Symbol Errors, No Collisions */
-#define M2_RX_PAUSE          0x02    /* RX # of Pause Control Frames */
-#define M2_RX_UNSUP_OPCODE   0x03    /* RX # of Unsupported Opcode Frames */
-#define M2_RX_OK_BYTES       0x04    /* RX # of Bytes in Valid Frames */
-#define M2_RX_BAD_BYTES      0x05    /* RX # of Bytes in Error Frames */
-#define M2_RX_UNICAST        0x06    /* RX # of Valid Unicast Frames */
-#define M2_RX_MULTICAST      0x07    /* RX # of Valid Multicast Frames */
-#define M2_RX_BROADCAST      0x08    /* RX # of Valid Broadcast Frames */
-#define M2_RX_CRC            0x09    /* RX # of CRC Error Only Frames */
-#define M2_RX_ALIGNMENT      0x0A    /* RX # of Alignment Error Frames */
-#define M2_RX_UNDERSIZE      0x0B    /* RX # of Undersize Well Formed Frames */
-#define M2_RX_FRAGMENTS      0x0C    /* RX # of Undersize with CRC Error */
-#define M2_RX_IN_RANGE_LENGTH_ERROR 0x0D    /* RX # of Frames with Legal
-                                               Lengths but Mismatch */
-#define M2_RX_OUT_OF_RANGE_ERROR    0x0E    /* RX # of Frames with Illegal
-                                               Length Field */
-
-/* NOTE: Names for RX_SIZE_ and TX_SIZE_ registers deviate from manual names
- * for typing convenience
- */
-
-#define M2_RX_OVERSIZE       0x0F    /* RX # of Oversize Well Formed Frames */
-#define M2_RX_JABBERS        0x10    /* RX # of Oversize with CRC Error */
-#define M2_RX_SIZE_64        0x11    /* RX # of 64 Byte Frames */
-#define M2_RX_SIZE_65        0x12    /* RX # of 65-127 Byte Frames */
-#define M2_RX_SIZE_128       0x13    /* RX # of 128-255 Byte Frames */
-#define M2_RX_SIZE_256       0x14    /* RX # of 256-511 Byte Frames */
-#define M2_RX_SIZE_512       0x15    /* RX # of 512-1023 Byte Frames */
-#define M2_RX_SIZE_1024      0x16    /* RX # of 1024-1518 Byte Frames */
-#define M2_RX_SIZE_1519      0x17    /* RX # of > 1518 Byte Allowed Frames */
-
-
-#define M2_TX_OUT_BYTES      0x18    /* TX # of Bytes (Good, Bad, Framing) */
-#define M2_TX_PAUSE          0x19    /* TX # of Pause Control Frames */
-#define M2_TX_OK_BYTES       0x1A    /* TX # of Bytes Successful */
-#define M2_TX_UNICAST        0x1B    /* TX # of Unicast Frames */
-#define M2_TX_MULTICAST      0x1C    /* TX # of Multicast Frames */
-#define M2_TX_BROADCAST      0x1D    /* TX # of Broadcast Frames */
-#define M2_TX_MULTIPLE_COLL  0x1E    /* TX # of Frames Successful After
-                                        Multiple Collisions */
-#define M2_TX_LATE_COL       0x1F    /* TX # of Late Collisions Detected */
-#define M2_TX_XCOLL          0x20    /* TX # of Frames Lost Due to 
-                                        Excessive Collisions */
-#define M2_TX_DEFER          0x21    /* TX # of Frames Deferred on First Try */
-#define M2_TX_XDEFER         0x22    /* TX # of Frames Sent with Excessive
-                                        Deferral*/
-#define M2_TX_CSENSE         0x23    /* TX # of Carrier Sense Error at End
-                                        of Frame Transmission*/
-#define M2_TX_SIZE_64        0x24    /* TX # of 64 Byte Frames */
-#define M2_TX_SIZE_65        0x25    /* TX # of 65-127 Byte Frames */
-#define M2_TX_SIZE_128       0x26    /* TX # of 128-255 Byte Frames */
-#define M2_TX_SIZE_256       0x27    /* TX # of 256-511 Byte Frames */
-#define M2_TX_SIZE_512       0x28    /* TX # of 512-1023 Byte Frames */
-#define M2_TX_SIZE_1024      0x29    /* TX # of 1024-1518 Byte Frames */
-#define M2_TX_SIZE_1519      0x2A    /* TX # of > 1518 Byte Allowed Frames */
-#define M2_TX_SINGLE_COL     0x2B    /* TX # of Single Collision Transmits */
-#define M2_TX_BACKOFF2       0x2C    /* TX # of Frames 2 backoff/collision */
-#define M2_TX_BACKOFF3       0x2D    /* TX # of Frames 3 backoff/collision */
-#define M2_TX_BACKOFF4       0x2E    /* TX # of Frames 4 backoff/collision */
-#define M2_TX_BACKOFF5       0x2F    /* TX # of Frames 5 backoff/collision */
-#define M2_TX_BACKOFF6       0x30    /* TX # of Frames 6 backoff/collision */
-#define M2_TX_BACKOFF7       0x31    /* TX # of Frames 7 backoff/collision */
-#define M2_TX_BACKOFF8       0x32    /* TX # of Frames 8 backoff/collision */
-#define M2_TX_BACKOFF9       0x33    /* TX # of Frames 9 backoff/collision */
-#define M2_TX_BACKOFF10      0x34    /* TX # of Frames 10 backoff/collision */
-#define M2_TX_BACKOFF11      0x35    /* TX # of Frames 11 backoff/collision */
-#define M2_TX_BACKOFF12      0x36    /* TX # of Frames 12 backoff/collision */
-#define M2_TX_BACKOFF13      0x37    /* TX # of Frames 13 backoff/collision */
-#define M2_TX_BACKOFF14      0x38    /* TX # of Frames 14 backoff/collision */
-#define M2_TX_BACKOFF15      0x39    /* TX # of Frames 15 backoff/collision */
-#define M2_TX_UNDERRUN       0x3A    /* TX # of FIFO Underrun Frame Drops */
-
-
-#define M2_RX_XGMII_PROT_ERR 0x3B    /* XGMII_RX Interface Protocol Errors */
-                                     /* NOTE: Only Available on 10 GbE MAC */
-
-#define M2_RX_IPG_SHRINK     0x3C    /* IPG Shrink Detected Counter */
-
-#define M2_STAT_STICKY1G     0x3E    /* Tri-Speed MAC Sticky Bits */
-#define M2_STAT_STICKY10G    0x3E    /* 10 GbE MAC Sticky Bits */
-
-#define M2_STAT_INIT         0x3F    /* Clears Statistics in all Tri-Speed
-                                        or 10 GbE depending on subblock */
-
-/* MII Management Block Registers (Block ID: MIIM) */
-/* Subblock Management #0-1 0x00-0x01 */
-
-#define M2_MIIM_STATUS       0x00    /* MII-M Status */
-#define M2_MIIM_CMD          0x01    /* MII-M Command */
-#define M2_MIIM_DATA         0x02    /* MII-M Data */
-#define M2_MIIM_PRESCALE     0x03    /* MII-M MDC Pre-Scale */
-
-
-/*************   Most oftern used bits and bitmasks       ******************** */
-#define M2_NORMALIZER_BIT_NLE    0x00000004
-#define M2_NORMALIZER_BIT_NH     0x00000002
-#define M2_NORMALIZER_BIT_PH     0x00000001
-
-
-#define M2_DENORMAL_BIT_EXP_NH   0x00000002
-#define M2_DENORMAL_BIT_ECP_PH   0x00000001
-
-
-#endif /* _MEIGSII_REG_H */
-/****************************************************************************/
-/*                                                                          */
-/*  End of file.                                                            */
-/*                                                                          */
-/****************************************************************************/
diff --git a/drivers/net/nlm_spi4/nlm_spi4.c b/drivers/net/nlm_spi4/nlm_spi4.c
deleted file mode 100644
index 2ac3862..0000000
--- a/drivers/net/nlm_spi4/nlm_spi4.c
+++ /dev/null
@@ -1,859 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-
-#include <asm/system.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/cache.h>
-
-#include "os_layer.h"
-#include "nlm_spi4.h"
-#include "nlm_spi4_config.h"
-#include <asm/netlogic/xlr_mac.h>
-#include <asm/netlogic/msgring.h>
-#include "nlm_vits_driver.h"
-
-#define CLEAR_INT 0xf
-#define CLEAR_TX_STATUS 0x0f
-#define CLEAR_RX_STATUS 0x1f
-#define MAX_BUCKET 64
-#define NLM_SPI4_MAX_THREADS 32
-#define NLM_SPI4_DEBUG 0
-#define MAX_NUM_MSGRNG_STN_CC   128
-
-unsigned long g_dip4_error[NLM_SPI4_MAX_THREADS];
-
-extern int xlr_loader_support;
-extern int xlr_loader_sharedcore;
-//extern void rmik_config_pde(int type, int instance, nlm_reg_t *mmio);
-
-spi4_driver_data*	spi4_data[TOTAL_SPI4];
-
-static void spi4_msgring_handler(	int 	bucket, 
-					int 	size, 
-					int 	code, 
-					int 	stid, 
-					struct msgrng_msg *msg, 
-					void 	*data);
-
-extern void rx_indication(int port, 	char* addr, 	int len);
-extern void tx_complete(int port, 	char* addr);
-
-#if NLM_SPI4_DEBUG
-void spi4_init_read_counter(unsigned int	*mmio)
-{
-	mmio[0x236] = 0; // read count0 of debugcount0
-	mmio[0x237] = 0; // read count1 of debugcount0
-
-	mmio[0x23a] = 0; // read count0 of debugcount1
-	mmio[0x23b] = 0; // read count1 of debugcount1
-
-	return;
-}
-
-void spi4_write_select(unsigned int  *mmio,int write_select,	int bit_no)
-{
-	long value;
-	value = 1<<bit_no;
-	printk("write_select=%d, bit no=%d,value=0x%lx\n", 
-		write_select, bit_no,value);
-	switch(write_select){
-	case 0:
-		mmio[0x234] = value;
-		break;
-	case 1:
-		mmio[0x235] = value;
-		break;
-	case 2:
-		mmio[0x238] = value;
-		break;
-	case 3:
-		mmio[0x239] = value;
-		break;
-	default:
-		printk("wrong write select\n");
-	}// end of switch
-	return;
-}
-
-void spi4_print_debug_value(unsigned int  *mmio)
-{
-
-	printk(" Read counter0 = %d\n", mmio[0x236]);
-	printk(" Read counter1 = %d\n", mmio[0x237]);
-	printk(" Read counter3 = %d\n", mmio[0x23a]);
-	printk(" Read counter4 = %d\n", mmio[0x23b]);
-
-	return;
-}
-
-#endif
-/*******************************************************************************
-*
-* Function name	:	spi4_configure_pde_spray_mode
-* Input		:	spi4 slot
-* Description	:	This function will program the PDE for the given 
-*	spi4 slot. Based on the cpu mask, it will check the enabled cpu and 
-*	then calculates the bucket mapp, with this bucket map it will program
-*	all the 4 classes of PDE .
-*	
-* RETURNS: void
-*******************************************************************************/
-static int spi4_configure_pde_spray_mode(uint32 slot, struct port_cfg *pcfg)
-{
-
-	int i, cpu=0, bkt=0;
-	__u64 bucket_map = 0;
-	bucket_t *bucket;
-	struct stn_cc *credit;
-	spi4_driver_data*   driver_data;
-	unsigned int        *mmio;
-
-	driver_data = spi4_data[slot];
-	mmio = driver_data->mmio;
-
-	if(!(PORT_INIT(driver_data->cfg_flag)))
-		return SPI4_CONFIG_PDE_SUCCESS;
-
-	for_each_online_cpu(i) {
-		cpu = cpu_logical_map(i);
-		bkt = ((cpu >> 2)<<3)|(cpu & 0x03);
-		bucket_map |= (1ULL << bkt);
-	}
-
-	if(pcfg->config_pde) {
-		netlogic_write_reg(mmio, R_PDE_CLASS_0, (bucket_map & 0xffffffff));
-		netlogic_write_reg(mmio, R_PDE_CLASS_0+1, 
-				((bucket_map>>NLM_SPI4_MAX_THREADS) & 0xffffffff));
-
-		netlogic_write_reg(mmio, R_PDE_CLASS_1, (bucket_map & 0xffffffff));
-		netlogic_write_reg(mmio, R_PDE_CLASS_1+1, 
-				((bucket_map>>NLM_SPI4_MAX_THREADS) & 0xffffffff));
-
-		netlogic_write_reg(mmio, R_PDE_CLASS_2, (bucket_map & 0xffffffff));
-		netlogic_write_reg(mmio, R_PDE_CLASS_2+1,
-			 ((bucket_map>>NLM_SPI4_MAX_THREADS) & 0xffffffff));
-
-		netlogic_write_reg(mmio, R_PDE_CLASS_3, (bucket_map & 0xffffffff));
-		netlogic_write_reg(mmio, R_PDE_CLASS_3+1, 
-			((bucket_map>>NLM_SPI4_MAX_THREADS) & 0xffffffff));
-	}
-
-
-	bucket = pcfg->bucket;
-	credit = pcfg->credit;
-
-	if(slot == SPI4_0){
-		for(i=0;i<XLR_MAX_SPI4_CHANNEL;i++){
-			netlogic_write_reg(mmio, R_XGS_TX0_BUCKET_SIZE+i, 
-			bucket[MSGRNG_STNID_XGS0_TX+i]);
-		}
-
-		netlogic_write_reg(mmio, R_XGS_RFR_BUCKET_SIZE, 
-			bucket[MSGRNG_STNID_XMAC0RFR]);
-
-	}
-	else if(slot == SPI4_1){
-		for(i=0;i<XLR_MAX_SPI4_CHANNEL;i++)
-			netlogic_write_reg(mmio, R_XGS_TX0_BUCKET_SIZE+i, 
-				bucket[MSGRNG_STNID_XGS1_TX+i]);
-
-		netlogic_write_reg(mmio, R_XGS_RFR_BUCKET_SIZE, 
-			bucket[MSGRNG_STNID_XMAC1RFR]);
-
-	}
-	for(i=0;i<128;i++){
-		netlogic_write_reg(mmio, R_CC_CPU0_0 + i, 
-		credit->counters[i>>3][i&0x07]);
-	}
-
-	return SPI4_CONFIG_PDE_SUCCESS;
-}
-
-static void spi4_free_spill_memory(spi4_driver_data*   driver_data)
-{
-	if(driver_data->frin_spill != NULL)
-		kfree(driver_data->frin_spill);
-	
-	if(driver_data->frout_spill != NULL)
-		kfree(driver_data->frout_spill);
-	
-	if(driver_data->class_0_spill != NULL)
-		kfree(driver_data->class_0_spill);
-
-	if(driver_data->class_1_spill != NULL)
-		kfree(driver_data->class_1_spill);
-
-	if(driver_data->class_2_spill != NULL)
-		kfree(driver_data->class_2_spill);
-
-	if(driver_data->class_3_spill != NULL)
-		kfree(driver_data->class_3_spill);
-
-	return;
-}	
-
-static void* config_spill(unsigned int *mmio, int reg_start_0,
-		int 	reg_start_1,
-		int 	reg_size, 
-		int 	size,
-		void**	spill_orig)
-{
-
-	__u32 spill_size = CACHELINE_ALIGNED_ADDR(size);
-	void *spill = os_cacheline_aligned_kmalloc(spill_size);
-	__u64 phys_addr = 0;
-
-	if (!spill) {
-		return NULL;
-	}
-	*spill_orig = spill;
-	phys_addr = virt_to_phys(spill);
-	netlogic_write_reg(mmio, reg_start_0, ((phys_addr >> 5) & 0xffffffff));
-
-	netlogic_write_reg(mmio, reg_start_1, ((phys_addr >> 37) & 0x07));
-
-	netlogic_write_reg(mmio, reg_size, spill_size);
-
-	return spill;
-}
-
-/*******************************************************************************
-* Function name :       spi4_configure_spill_memory
-* Input         :
-* Description   :       This function programs the freein, free out and class0, 
-*	class1, class2 spill memory
-* RETURNS       :       void
-*******************************************************************************/
-
-static int spi4_configure_spill_memory(uint32 slot)
-{
-
-	spi4_driver_data*   driver_data;
-	unsigned int        *mmio;
-
-	driver_data = spi4_data[slot];
-	mmio = driver_data->mmio;
-
-	if(!(MSGRNG_OWN(driver_data->cfg_flag)))
-		return SPI4_CONFIG_SPILL_SUCCESS;
-
-	if(config_spill(mmio,R_REG_FRIN_SPILL_MEM_START_0,
-			R_REG_FRIN_SPILL_MEM_START_1,R_REG_FRIN_SPILL_MEM_SIZE,
-			MAX_FRIN_SPILL * sizeof(struct fr_desc),
-			&driver_data->frin_spill) == NULL){
-		return SPI4_CONFIG_SPILL_FAIL ;
-	}
-
-	if(config_spill(mmio, R_FROUT_SPILL_MEM_START_0,
-			R_FROUT_SPILL_MEM_START_1,
-			R_FROUT_SPILL_MEM_SIZE,
-			(2* MAX_FROUT_SPILL * sizeof(struct fr_desc)),
-			&driver_data->frout_spill) == NULL){
-			spi4_free_spill_memory(driver_data);
-			return SPI4_CONFIG_SPILL_FAIL ;	
-	}
-
-	if(config_spill(mmio, R_CLASS0_SPILL_MEM_START_0,
-			R_CLASS0_SPILL_MEM_START_1,
-			R_CLASS0_SPILL_MEM_SIZE,
-			MAX_CLASS_0_SPILL * sizeof(union rx_tx_desc),
-			&driver_data->class_0_spill) == NULL){
-			spi4_free_spill_memory(driver_data);
-			return SPI4_CONFIG_SPILL_FAIL;
-	}
-
-	if(config_spill(mmio,R_CLASS1_SPILL_MEM_START_0,
-			R_CLASS1_SPILL_MEM_START_1,
-			R_CLASS1_SPILL_MEM_SIZE,
-			MAX_CLASS_1_SPILL * sizeof(union rx_tx_desc),
-			&driver_data->class_1_spill) == NULL){
-			spi4_free_spill_memory(driver_data);
-			return SPI4_CONFIG_SPILL_FAIL ;
-	}
-
-
-	if(config_spill(mmio,R_CLASS2_SPILL_MEM_START_0,
-			R_CLASS2_SPILL_MEM_START_1,
-			R_CLASS2_SPILL_MEM_SIZE,
-			MAX_CLASS_2_SPILL * sizeof(union rx_tx_desc),
-			&driver_data->class_2_spill) == NULL){
-			spi4_free_spill_memory(driver_data);
-			return SPI4_CONFIG_SPILL_FAIL ;
-	}
-
-	if( config_spill(mmio, R_CLASS3_SPILL_MEM_START_0,
-			R_CLASS3_SPILL_MEM_START_1,
-			R_CLASS3_SPILL_MEM_SIZE,
-			MAX_CLASS_3_SPILL * sizeof(union rx_tx_desc),
-			&driver_data->class_3_spill) == NULL){
-			spi4_free_spill_memory(driver_data);
-			return SPI4_CONFIG_SPILL_FAIL ;
-	}
-
-	return SPI4_CONFIG_SPILL_SUCCESS;
-}//end of spi4_configure_spill_memory
-
-
-/*******************************************************************************
-*
-* Function name :       spi4_register_msgrng_handler
-* Input         :       spi4 slot
-* Description   :       This function will register message ring handler for the 
-*       given spi4. Registered function will be called whenever msg will be send 
-*	by the spi4. 
-* RETURNS	: 	int
-*			1 - fail
-*			0 - success
-*******************************************************************************/
-
-static int spi4_register_msgrng_handler(uint32 slot)
-{
-	spi4_driver_data*   driver_data;
-	driver_data = spi4_data[slot];
-	
-	if(slot == SPI4_0){
-		if (register_msgring_handler(TX_STN_XGS_0, 
-		spi4_msgring_handler, NULL)) {
-			return SPI4_REGISTER_MSGRING_FAIL;
-		}
-	}	
-	else if(slot == SPI4_1){
-		if (register_msgring_handler(TX_STN_XGS_1, 
-		spi4_msgring_handler, NULL)) {
-			return SPI4_REGISTER_MSGRING_FAIL;
-		}
-	}
-	else{
-		/*invalid spi4*/
-		return SPI4_SLOT_ERROR;
-	}
-
-	return SPI4_REGISTER_MSGRING_SUCESS;
-}// end of spi4_register_msgrng_handler()
-
-static int spi4_validate_config_params(void)
-{
-	if(XLR_TOTAL_CHANNELS > XLR_MAX_SPI4_CHANNEL){
-		printk("invalid total channels\n");
-		return SPI4_CALENDER_LEN_ERROR ;
-	}
-	if(XLR_SPI4_TX_MAXBURST1 > XLR_MAX_TX_BURST){
-		printk("invalid TX max burst1\n");
-		return SPI4_TX_MAXBURST1_ERROR;
-	}
-	if(XLR_SPI4_TX_MAXBURST2 > XLR_MAX_TX_BURST){
-		printk("invalid TX max burst2\n");
-		return SPI4_TX_MAXBURST2_ERROR;
-	}
-	if(XLR_SPI4_RX_MAXBURST1 > XLR_MAX_RX_BURST){
-		printk("invalid RX max burst1\n");
-		return SPI4_RX_MAXBURST1_ERROR;
-	}
-	if(XLR_SPI4_RX_MAXBURST2 > XLR_MAX_RX_BURST){
-		printk("invalid RX max burst2\n");
-		return SPI4_RX_MAXBURST2_ERROR;
-	}
-	if(XLR_SPI4_TX_MAXBURST2 < XLR_SPI4_TX_MAXBURST1){
-		printk("invalid TX max bursts\n");
-		return SPI4_TX_MAX_BURST_ERROR;
-	}
-	if(XLR_SPI4_RX_MAXBURST2 < XLR_SPI4_RX_MAXBURST1){
-		printk("invalid RX max bursts\n");
-		return SPI4_RX_MAX_BURST_ERROR ;
-	}
-	if(SPI4_BYTE_OFFSET > XLR_MAX_SPI4_BYTE_OFFSET){
-		printk("invalid byte offset\n");
-		return SPI4_BYTE_OFFSET_ERROR;
-	}
-	return SPI4_PARAMS_VALID;
-}	
-
-void spi4_disable_tx_rx(unsigned int	*mmio)
-{
-	uint32  reg_val;
-	
-	reg_val = netlogic_read_reg(mmio, SPI4_CNTRL_REG);
-        reg_val &= ~(0xa);
-        netlogic_write_reg(mmio, SPI4_CNTRL_REG, reg_val ) ;
-
-	return;
-}	
-
-void spi4_enable_tx_rx(unsigned int	*mmio)
-{
-	uint32  reg_val;
-	
-	reg_val = netlogic_read_reg(mmio, SPI4_CNTRL_REG);
-        reg_val |= 0xa;
-        netlogic_write_reg(mmio, SPI4_CNTRL_REG, reg_val ) ;
-
-	return;
-}
-
-/*******************************************************************************
-*
-* Function name :       spi4_init
-* Input         :       spi4 slot, callback function
-* Description   :       This function will initialize the given spi4. It resets 
-*	the spi4, programs the tx calender, max burst, DMA and spi4 channels 
-*	and FIFO. 
-* RETURNS: void
-*******************************************************************************/
-
-unsigned int spi4_init(uint32 	slot, spi4_callback_func calbk_func )
-{
-	uint32	reg_val, byte_offset=0;
-	int i;
-	unsigned int 			*mmio, spi4_ret_value;
-	spi4_driver_data*		driver_data;
-	int tx_fifo_base[XLR_MAX_SPI4_CHANNEL];
-	int tx_fifo_size[XLR_MAX_SPI4_CHANNEL];
-	int rx_fifo_base[XLR_MAX_SPI4_CHANNEL];
-	int rx_fifo_size[XLR_MAX_SPI4_CHANNEL];
-	extern struct net_device_cfg xlr_net_dev_cfg;
-	struct net_device_cfg *net_cfg = &xlr_net_dev_cfg;
-	struct port_cfg *port_cfg;
-
-	port_cfg = &net_cfg->xgs_port[slot];
-	/* if support for loading apps on same core as Linux is enabled */
-	if(port_cfg->cfg_flag == 0)
-		return -EINVAL;
-
-	if((slot < SPI4_0) || (slot > SPI4_1)){
-		return SPI4_SLOT_ERROR;
-	}
-	driver_data = (spi4_driver_data*) os_malloc(sizeof(spi4_driver_data));
-	
-	if(driver_data == NULL){
-		return SPI4_MALLOC_FAIL;
-	}
-	driver_data->frin_spill =driver_data->frout_spill = NULL; 
-	driver_data->class_0_spill = driver_data->class_1_spill = NULL;
-	driver_data->class_2_spill = driver_data->class_3_spill = NULL; 
-
-	spi4_data[slot] = driver_data;
-
-
-	/*initilizing the spi4 and elements of the driver data*/
-	driver_data->calbk_func  = calbk_func;
-	driver_data->spi4_slot   = slot;
-	driver_data->tx_calendar = driver_data->rx_calendar = XLR_TOTAL_CHANNELS;
-	driver_data->tx_cal_sequence = TX_CAL_SEQ;
-	driver_data->rx_cal_sequence = RX_CAL_SEQ;	
-	driver_data->tx_maxburst1 = XLR_SPI4_TX_MAXBURST1;
-	driver_data->tx_maxburst2 = XLR_SPI4_TX_MAXBURST2;
-	driver_data->rx_maxburst1 = XLR_SPI4_RX_MAXBURST1;
-	driver_data->rx_maxburst2 = XLR_SPI4_RX_MAXBURST2;
-
-	driver_data->cfg_flag = port_cfg->cfg_flag;
-	driver_data->mmio = (uint32_t *)port_cfg->mmio_addr;
-	mmio = driver_data->mmio;
-
-	if(PORT_INIT(driver_data->cfg_flag)) {
-		spi4_ret_value = spi4_validate_config_params();
-		if(spi4_ret_value != SPI4_PARAMS_VALID){
-			printk("invalid configuration parameters\n");
-			return spi4_ret_value ;
-		}
-
-		/*configuring the IP registers*/
-		reg_val = netlogic_read_reg(mmio, SPI4_CNTRL_REG);
-		reg_val &= ~(0xa);
-		netlogic_write_reg(mmio, SPI4_CNTRL_REG, reg_val ) ; 
-
-		/*programming the Hungry thresholds*/
-		netlogic_write_reg(mmio, R_SPIHNGY0, 0x04040404);
-		netlogic_write_reg(mmio, R_SPIHNGY1, 0x04040404 );
-		netlogic_write_reg(mmio, R_SPIHNGY2, 0x04040404);
-		netlogic_write_reg(mmio, R_SPIHNGY3, 0x04040404);
-
-		/*programming the starving thresholds*/
-		netlogic_write_reg(mmio, R_SPISTRV0, 0x06060606);
-		netlogic_write_reg(mmio, R_SPISTRV1, 0x06060606);
-		netlogic_write_reg(mmio, R_SPISTRV2, 0x06060606);
-		netlogic_write_reg(mmio, R_SPISTRV3, 0x06060606);
-
-		netlogic_write_reg(mmio, 0x50, 4);/* F_ALPHA */
-		/*programming the DMA credits*/
-		netlogic_write_reg(mmio, R_DMACR0, 0xffffffff);
-		netlogic_write_reg(mmio, R_DMACR1, 0xffffffff);
-		netlogic_write_reg(mmio, R_DMACR2, 0xffffffff);
-		netlogic_write_reg(mmio, R_DMACR3, 
-			(0xff<<24)|(2<<21)|(2<<18)|(2<<12)|(2<<9)|(2<<6)|(2<<3)|(2<<0));
-
-		vtss_nlm_init(slot+1);
-
-		for(i=0; i<8; i++){
-			byte_offset <<= 3 ;
-			byte_offset |= SPI4_BYTE_OFFSET ; 	
-		}
- 		netlogic_write_reg(mmio,DESC_PKT_CTRL_1,byte_offset);
-	 	netlogic_write_reg(mmio,DESC_PKT_CTRL_2,byte_offset);
-		netlogic_write_reg(mmio, PAD_CALIB_0,0x02030);
-
-
-	  /*configure: TX cal, RX cal and cal seq*/
-	  netlogic_write_reg(mmio, SPI4_TX_CAL_LEN, driver_data->tx_calendar);
-	  netlogic_write_reg(mmio, SPI4_RX_CAL_LEN, driver_data->rx_calendar);
-	  netlogic_write_reg(mmio, SPI4_TX_CAL_MAX , driver_data->tx_cal_sequence);
-	  netlogic_write_reg(mmio, SPI4_RX_CAL_MAX, driver_data->rx_cal_sequence);
-
-
-		for(i=0;i< driver_data->tx_calendar; i++){
-		  	netlogic_write_reg(mmio,SPI4_TX_CAL_X, (i | (i<<16)));
-		}
-		for(i=0;i< driver_data->rx_calendar; i++){
-		  	netlogic_write_reg(mmio,SPI4_RX_CAL_X, (i | (i<<16)));
-		}
-	}
-	
-	if(PORT_EN(driver_data->cfg_flag)) {
-
-		netlogic_write_reg(mmio, R_TX_CONTROL,
-      		((1<<W_TX_CONTROL__TxThreshold) | TX_THRESHOLD_SIZE));
-
-		netlogic_write_reg(mmio, R_RX_CONTROL, 1);
-
-	}
-
-	if(PORT_INIT(driver_data->cfg_flag)) {
-		netlogic_write_reg(mmio, R_DESC_PACK_CTRL,
-		    ((4 << 20) | REG_FRAME_SIZE));
-
-		netlogic_write_reg(mmio, R_L2ALLOCCTRL, 0x2);
-
-		mdelay(5);
-
-		netlogic_write_reg(mmio, SPI4_INTR_REG, CLEAR_INT);
-		netlogic_write_reg(mmio, SPI4_TX_STATUS , CLEAR_TX_STATUS);
-		netlogic_write_reg(mmio, SPI4_RX_STATUS, CLEAR_RX_STATUS);
-
-
-		/* change rx maxburst 1 */
-		for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++)
-    		netlogic_write_reg(mmio, SPI4_RX_MAXBURST1_I,
-        		XLR_SPI4_RX_MAXBURST1 + (i << XLR_MAX_SPI4_CHANNEL));
-
-
-	  	/* change rx maxburst 2 */
-		for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++)
-		    netlogic_write_reg(mmio, SPI4_RX_MAXBURST2_I,
-        		XLR_SPI4_RX_MAXBURST2 + (i << XLR_MAX_SPI4_CHANNEL));
-
-		for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++){
-    		tx_fifo_base[i]  = i*8;  
-		    tx_fifo_size[i]  = 8 ; 
-    		rx_fifo_base[i]  = i*32;  
-	    	rx_fifo_size[i]  = 32 ; 
-  		}
-
-
-		for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++){
-    		netlogic_write_reg(mmio, SPI4_TX_FIFO_BASE_I,
-      				tx_fifo_base[i] + (i<<XLR_MAX_SPI4_CHANNEL));
-		    netlogic_write_reg(mmio, SPI4_RX_FIFO_BASE_I,
-      				rx_fifo_base[i] + (i<<XLR_MAX_SPI4_CHANNEL));
-  		}
-
-	 	for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++){
-    		netlogic_write_reg(mmio, SPI4_TX_FIFO_DEPTH_I,
-		   		tx_fifo_size[i] + (i<< XLR_MAX_SPI4_CHANNEL));
-		    netlogic_write_reg(mmio, SPI4_RX_FIFO_DEPTH_I,
-      			rx_fifo_size[i] + (i<< XLR_MAX_SPI4_CHANNEL));
-  		}
-	}
-
-	if(PORT_EN(driver_data->cfg_flag)) {
-		netlogic_write_reg(mmio, 0x78, 4);
-		netlogic_write_reg(mmio, SPI4_CNTRL_REG, 0x00000e0f);
-
-		mdelay(10);
-
-		i = netlogic_read_reg(mmio, SPI4_TX_STATUS);
-		if(!(i & SPI4_TX_STATUS_TX_SYNC)){
-			spi4_disable_tx_rx(mmio);
-			printk("TX path no sync\n");
-			return SPI4_TX_SYNC_FAIL;
-		}
-
-		i = netlogic_read_reg(mmio, SPI4_RX_STATUS);
-		if(!(i & SPI4_RX_STATUS_RX_SYNC)){
-			spi4_disable_tx_rx(mmio);
-			printk("RX path no sync\n");
-			return SPI4_RX_SYNC_FAIL;
-		}
-	}
-	
-	spi4_ret_value = spi4_configure_spill_memory(slot);
-	if(spi4_ret_value != SPI4_CONFIG_SPILL_SUCCESS){
-			spi4_disable_tx_rx(mmio);
-			printk("spill memory configuration failed\n");
-			return spi4_ret_value;
-	}
-
-	spi4_ret_value = spi4_configure_pde_spray_mode(slot, port_cfg);
-	if(spi4_ret_value != SPI4_CONFIG_PDE_SUCCESS){
-			spi4_disable_tx_rx(mmio);
-			spi4_free_spill_memory(driver_data);
-			printk("pde configuration failed\n");
-			return spi4_ret_value ;
-	}
-
-//	if(PORT_INIT(driver_data->cfg_flag)) 
-//		rmik_config_pde(TYPE_SPI4, slot, mmio);
-
-	spi4_ret_value = spi4_register_msgrng_handler(slot);
-	if(spi4_ret_value != SPI4_REGISTER_MSGRING_SUCESS){
-		spi4_disable_tx_rx(mmio);
-		spi4_free_spill_memory(driver_data);
-		printk("registering msgring handler failed\n");
-		return spi4_ret_value ;
-	}
-
-	return SPI4_INIT_SUCCESS;
-
-}// end of function spi4_init()
-/*******************************************************************************
-* Function name :       spi4_msgring_handler
-* Input         :       
-* Description   :       This function will be called when spi4 sends any msg. 
-*	It handles TX_DONE and RX_IND mesg and informs the same to registered
-*	function by the upper application.
-* RETURNS       :       void
-*******************************************************************************/
-static void spi4_msgring_handler(int 	bucket, 	int size, 
-			int	code, 		int stid,
-			struct 	msgrng_msg *msg, void *data)
-{
-
-	unsigned int slot, port, ctrl, length;
-	unsigned long addr = 0;
-	unsigned int  error=0, th_id;
-	char*	ptr;
-	spi4_driver_data*   driver_data;
-
-
-	if(stid == MSGRNG_STNID_XGS0FR)
-		slot = SPI4_0;
-	else if(stid == MSGRNG_STNID_XGS1FR)
-		slot = SPI4_1;
-	else{
-		printk("ERROR: wrong slot\n");
-		return;
-	}
-	driver_data = spi4_data[slot];
-	port = get_port(msg->msg0);
-
-
-
-	length = get_length(msg->msg0);
-  if(length == 0)
-    ctrl = CTRL_REG_FREE;
-  else
-	  ctrl = CTRL_SNGL;
-
-
-	if (ctrl == CTRL_REG_FREE ) {
-   	/*TX complete*/
-    		addr = msg->msg0 & 0xffffffffffULL;
-    		addr = (unsigned long) phys_to_virt(addr);
-		ptr = (char*) addr;
-   	(*driver_data->calbk_func)
-      (SPI4_TX_DONE,slot,bucket,ptr,length, error);
-	}	
-	else if(ctrl == CTRL_SNGL || ctrl == CTRL_START){
-		/*RX indication*/
-		addr = (unsigned long) bus_to_virt(get_address(msg->msg0));
-		ptr = (char*) addr;
-		error = ((msg->msg0 >> 62)& 0x01);
-
-		if((port >= XLR_TOTAL_CHANNELS)){
-			/*if wrong port is received, then treat that as error packet
-			and try to replenish it*/
-			error = 1; 
-		}
-		
-		if(error){
-			spi4_program_rx_desc(slot,ptr);
-			th_id = hard_smp_processor_id();
-			g_dip4_error[th_id]++;
-		}
-		else{
-		length -=  (SPI4_BYTE_OFFSET + MAC_CRC_LEN );
-		(*driver_data->calbk_func)
-			(SPI4_RX_IND,slot,port,ptr,length, error);
-		}
-	}
-	return;
-}//spi4_msgring_handler()
-
-/*******************************************************************************
-* Function name :       spi4_tx
-* Input         :
-* Description   :       This function will be called by the upper application
-*	to transmit data. Before doing TX it makes sure TX and RX path are in 
-*	sync.
-* RETURNS       :       int
-*			1 - fail
-*			0 - success
-*******************************************************************************/
-
-int spi4_tx(	unsigned int thr_id, uint32 slot,  uint32 spi4_port, 
-						char* data, unsigned char* skb,uint32 len)
-{
-	unsigned int 		msgrng_flags;
-	spi4_driver_data*   	driver_data;
-	struct msgrng_msg 	msg;
-	int 			stid=0, ret =0;
-
-
-	driver_data = spi4_data[slot];
-
-	stid = spi4_make_desc_tx(thr_id, &msg,  driver_data->spi4_slot,
-													spi4_port, TYPE_SPI4, virt_to_phys(data), 
-													(unsigned long) skb, len);
-
-	__sync();
-	msgrng_access_enable(msgrng_flags);
-  if (message_send_retry(2, MSGRNG_CODE_SPI4, stid, &msg)){
-    ret =  SPI4_TX_FAIL;
-	}
-	msgrng_access_disable(msgrng_flags);
-	return ret;
-}// end of spi4_tx()
-
-/*******************************************************************************
-* Function name :       spi4_program_rx_desc
-* Input         :
-* Description   :       This function will make a regular free descriptor 
-*	and sends it to spi4.
-* RETURNS       :       int
-*                       1 - fail
-*                       0 - success
-*******************************************************************************/
-
-void spi4_program_rx_desc(uint32 	slot, 	
-			char*		addr)
-{
-
-	unsigned long 		msgrng_flags;
-	int 			stid = 0;
-	struct msgrng_msg 	msg;
-	spi4_driver_data*   	driver_data;
-
-	driver_data = spi4_data[slot];
-
-	stid = spi4_make_desc_rfr(&msg, driver_data->spi4_slot,
-				TYPE_SPI4 , virt_to_bus(addr));
-	__sync();
-	msgrng_access_enable(msgrng_flags);
-	while (message_send(1, MSGRNG_CODE_SPI4, stid, &msg));
-	msgrng_access_disable(msgrng_flags);
-
-
-	return ;	
-}
-
-
-/*******************************************************************************
-* Function name :       spi4_open
-* Input         :
-* Description   :       This function enable TX and RX of the spi4 also sends 
-*	a jumbo frame.
-* RETURNS       :       void
-*******************************************************************************/
-
-int spi4_open(uint32 slot)
-{
-
-	spi4_driver_data*	driver_data;
-	unsigned int        	*mmio;
-
-	driver_data = spi4_data[slot];
-	if(driver_data == NULL){
-		return  SPI4_SLOT_ERROR;
-	}
-
-	mmio = driver_data->mmio;
-	if(mmio == NULL){
-		return SPI4_MMIO_ERROR;
-	}
-
-		return SPI4_OPEN_SUCCESS;
-}// end of function spi4_open()
-
-/*******************************************************************************
-* Function name :       spi4_close
-* Input         :
-* Description   :       This function disable TX and RX of the spi4 .
-* RETURNS       :       void
-*******************************************************************************/
-
-void spi4_close(uint32 slot)
-{
-
-	spi4_driver_data*   	driver_data;
-	unsigned int        	*mmio;
-	unsigned int 		tmp;
-
-	driver_data = spi4_data[slot];
-	mmio = driver_data->mmio;
-
-	tmp = netlogic_read_reg(mmio, R_TX_CONTROL);
-	tmp &= ~(1<<W_TX_CONTROL__TxThreshold);
-	netlogic_write_reg(mmio, R_TX_CONTROL, tmp);
-
-	tmp = netlogic_read_reg(mmio, R_RX_CONTROL);
-	tmp &= ~(1<<O_RX_CONTROL__RxEnable) ;
-	netlogic_write_reg(mmio, R_RX_CONTROL, tmp);
-
-	tmp = netlogic_read_reg(mmio, SPI4_CNTRL_REG);
-	tmp &= ~(TX_ENABLE |  RX_ENABLE);
-	netlogic_write_reg(mmio, SPI4_CNTRL_REG, tmp);
-
-	return;
-
-}
-
-int spi4_read_reg(uint32 slot, uint32 addr)
-{
-
-	spi4_driver_data*   driver_data;
-	unsigned int        *mmio;
-	unsigned int        tmp;
-
-	driver_data = spi4_data[slot];
-	mmio = driver_data->mmio;
-
-	tmp = netlogic_read_reg(mmio, addr);
-	return tmp;
-}
-
-
diff --git a/drivers/net/nlm_spi4/nlm_spi4.h b/drivers/net/nlm_spi4/nlm_spi4.h
deleted file mode 100644
index 486d3e8..0000000
--- a/drivers/net/nlm_spi4/nlm_spi4.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_SPI4_H
-#define _ASM_NLM_SPI4_H
-
-#include <linux/types.h>
-#include <asm/netlogic/iomap.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/xlr_mac.h>
-#include <asm/netlogic/sim.h>
-#include "nlm_spi4_config.h"
-
-
-#define NLM_SPI4_MAX_THREADS 32
-#define NLM_SPI4_PORTS_PER_CARD XLR_TOTAL_CHANNELS
-
-
-#define MAX_SPILL_SIZE          (MAX_NUM_DESC + 128)
-#define MAX_FRIN_SPILL          (MAX_SPILL_SIZE * NLM_SPI4_PORTS_PER_CARD)
-#define MAX_FROUT_SPILL         (MAX_SPILL_SIZE * NLM_SPI4_PORTS_PER_CARD)
-#define MAX_CLASS_0_SPILL       (MAX_SPILL_SIZE * NLM_SPI4_PORTS_PER_CARD)
-#define MAX_CLASS_1_SPILL       (MAX_SPILL_SIZE * NLM_SPI4_PORTS_PER_CARD)
-#define MAX_CLASS_2_SPILL       (MAX_SPILL_SIZE * NLM_SPI4_PORTS_PER_CARD)
-#define MAX_CLASS_3_SPILL       (MAX_SPILL_SIZE * NLM_SPI4_PORTS_PER_CARD)
-
-
-
-#define SPI4_0_BASE_ADDR 0x10000
-#define SPI4_1_BASE_ADDR 0x12000
-#define XLR_MAX_SPI4_CHANNEL 0x10
-#define XLR_MAX_SPI4_BYTE_OFFSET 7
-#define XLR_MAX_TX_BURST 8
-#define XLR_MAX_RX_BURST 32
-#define TX_CAL_SEQ      0x01
-#define RX_CAL_SEQ      0x01
-
-
-#define TOTAL_SPI4	2
-#define SPI4_0	0
-#define SPI4_1	1
-
-
-/* SPI4 registers */
-#define SPI4_TX_CAL_LEN 	0x0
-#define SPI4_TX_CAL_MAX	0x04
-#define SPI4_TX_CAL_X 0x08
-#define SPI4_RX_CAL_LEN	0x18
-#define SPI4_RX_CAL_X 0x20
-#define SPI4_RX_CAL_MAX	0x1c
-#define SPI4_TX_MAXBURST1_I 0x30
-#define	SPI4_TX_MAXBURST2_I 0x34
-#define SPI4_RX_MAXBURST1_I 0x38
-#define	SPI4_RX_MAXBURST2_I 0x3c
-
-/* spi4 control register and its bit fields */
-#define SPI4_CNTRL_REG	0x6c
-#define	TX_RESET		0x1
-#define	TX_ENABLE		0x2	
-#define	RX_RESET		0x04
-#define	RX_ENABLE		0x08
-#define	RX_CAL_Y		0x10
-#define	USR_SHAL_LPB	0x20
-#define	USR_DEEP_LPB	0x40
-#define	SPI_SHAL_LPB	0x80
-#define	SPI_DEP_LPB		0x100
-#define	DDL_ENABLE		0x200
-#define	FIFO_SW_RESET	0x400
-#define	RX_TRAIN_RESET 	0x800
-#define	RX_TRAIN_LOS		0x1000
-#define	TX_FRM_ERR_EN		0x2000
-#define	MORE_TRN_EN			0x4000
-#define	ERL_TRN_EN			0x8000
-#define	SYNC_PAT_EN			0x10000
-
-
-#define SPI4_INTR_REG		0x70
-#define	SPI4_TX_STATUS		0x7c
-#define	SPI4_TX_STATUS_TX_SYNC 0x4
-#define	SPI4_RX_STATUS		0x80
-#define SPI4_RX_STATUS_RX_SYNC 0x02
-#define	SPI4_RX_FIFO_DEPTH_I 0x88
-#define	SPI4_RX_FIFO_BASE_I 0x90
-#define	SPI4_TX_FIFO_DEPTH_I 0x8c
-#define	SPI4_TX_FIFO_BASE_I	0x94
-
-/* glue logic registers */
-
-#define DESC_PKT_CTRL_1 0xa9
-#define DESC_PKT_CTRL_2 0xaa
-#define PAD_CALIB_0	0x231
-#define RX_P_PRESET 0x1
-#define RX_N_PRESET 0x02
-#define	TX_P_PRESET 0x4
-#define TX_N_PRESET	0x08
-#define	RX_EN_COUNTER	 0x10
-#define	TX_EN_COUNTER  0x20
-#define	CAL_PRESET		0
-#define	HSTL_TERMINATION 0x1000
-#define	LVDS_TERMINATION 0x2000
-
-/********** CPLD register     **************/
-#define  CPLD_MISC_STATUS_REG  0x0e
-#define SPI4_MASK_BIT1 1
-
-
-typedef struct _spi4_driver_data{
-
-	uint32  tx_calendar; // number of ports
-	uint32  tx_cal_sequence ;
-
-	uint32  rx_calendar; // number of ports
-	uint32  rx_cal_sequence ;
-
-	uint32  tx_maxburst1;
-	uint32  tx_maxburst2;
-
-	uint32  rx_maxburst1;
-	uint32  rx_maxburst2;
-
-	uint32 		*mmio;
-	uint    spi4_slot ; 
-	uint32_t cfg_flag;
-
-	spi4_callback_func calbk_func;
-
-	void*	frin_spill;
-	void*	frout_spill;
-	void*	class_0_spill;
-	void*	class_1_spill;
-	void*	class_2_spill;
-	void*	class_3_spill;
-	
-}spi4_driver_data;
-
-/* spi4 descriptors */
-#define PORT_MASK 0xf
-#define DESK_CTRL_MASK 0x7
-#define DESC_CTRL_OFFSET  61
-#define DESC_LEN_MASK 0x3fff
-#define DESC_LEN_OFFSET 40
-#define DESC_ERROR_OFFSET 60 
-#define DESC_ERROR_MASK 0x01
-
-#define get_error(a) ((((a)>> DESC_ERROR_OFFSET) & DESC_ERROR_MASK ))
-#define get_port(a) ((a)&(PORT_MASK))
-#define get_ctrl(a) (((a)>>(DESC_CTRL_OFFSET))& (DESK_CTRL_MASK))
-#define get_length(a) (((a) >> (DESC_LEN_OFFSET)) & (DESC_LEN_MASK))
-#define get_address(a) (((a)&(0xffffffffe0ULL)))
-
-
-
-#define SPI4_TX_DESC_ALIGNMENT (SMP_CACHE_BYTES - 1)
-extern int cpu_to_frstid[];
-
-static inline int spi4_make_desc_tx(unsigned int thr_id,
-		struct  msgrng_msg *msg,
-    int   id,
-    int   port,
-    int   type,
-    unsigned long addr,
-    unsigned long skb,
-    int   len)
-{
-  int tx_stid = 0;
-  int fr_stid = 0;
-
-  tx_stid = msgrng_xgmac_stid_tx(id);
-  tx_stid += port;
-  fr_stid = cpu_to_frstid[thr_id];
-
-  msg->msg0 = ( ((uint64_t)1 << 63) |
-              ( ((uint64_t)127) << 54) |
-                ((uint64_t)len << 40) |
-                ((uint64_t)addr & 0xffffffffffULL)
-              );
-
-  msg->msg1 = ( ((uint64_t)1 << 63) |
-              ( ((uint64_t)fr_stid) << 54) |
-                ((uint64_t)0 << 40) |
-                ((uint64_t)virt_to_phys((void*)skb) & 0xffffffffffULL)
-              );
-
-  msg->msg2 = msg->msg3 = 0;
-
-  return tx_stid;
-
-}
-
-
-static inline int spi4_make_desc_rfr(struct msgrng_msg *msg, int id, int type,
-                                           unsigned long addr)
-{
-  int stid = 0;
-
-  stid = msgrng_xgmac_stid_rfr(id);
-
-  msg->msg0 = (uint64_t)addr & 0xffffffffe0ULL;
-  msg->msg1 = msg->msg2 = msg->msg3 = 0;
-
-  return stid;
-}
-
-
-#endif
diff --git a/drivers/net/nlm_spi4/nlm_spi4_config.h b/drivers/net/nlm_spi4/nlm_spi4_config.h
deleted file mode 100644
index fa554e5..0000000
--- a/drivers/net/nlm_spi4/nlm_spi4_config.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_SPI4_CONFIG_H
-#define _ASM_NLM_SPI4_CONFIG_H
-
-#include <linux/types.h>
-
-typedef unsigned int uint32;
-
-
-
-/* configuration parameters*/
-
-/* indicates how many spi4 channels currently need to be used
- * by the upper driver */
-#define XLR_TOTAL_CHANNELS 0xa
-
-/* indicates number of 16 byte blocks that fifo can accept
- * during fifo starving for the transmit path*/
-#define XLR_SPI4_TX_MAXBURST1    0x8
-
-/* indicates number of 16 byte blocks that fifo can accept
- *  * during fifo hungry for the transmit path*/
-#define XLR_SPI4_TX_MAXBURST2    0x8
-
-/* indicates number of 16 byte blocks that fifo can accept
- * during fifo starving for the receive path*/
-#define XLR_SPI4_RX_MAXBURST1    0x8
-
-/* indicates number of 16 byte blocks that fifo can accept
- * during fifo hungry for the receive path*/
-#define XLR_SPI4_RX_MAXBURST2    0x8
-
-
-
-/* folowing are the configuration parameters for the ethrnet mac 
- * driver */
-
-/* threshold for tx starts*/
-#define TX_THRESHOLD_SIZE      	512
-
-/* max buffer size for the tx and rx*/
-#define REG_FRAME_SIZE 		1536
-#define MAX_FRAME_SIZE          REG_FRAME_SIZE
-
-/* indicates byte offset for rx data start 
- * from the rx buffer  */
-#define SPI4_BYTE_OFFSET        2
-
-#define MAC_CRC_LEN             4
-#define MAC_SKB_BACK_PTR_SIZE   SMP_CACHE_BYTES
-
-#ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
-#define MAC_PREPAD             32
-#else 
-#define MAC_PREPAD              0
-#endif
-
-/* number of descriptors for each spi4 channel given for the 
- * rx data*/
-#define MAX_NUM_DESC            512
-
-
-
-
-typedef void (*spi4_callback_func)(uint32,uint32, uint32, char*, 
-		uint32, uint32 error);
-
-enum spi4_callback_cmd{
-	SPI4_TX_DONE ,
-	SPI4_RX_IND
-};
-
-/* exported API*/
-
-extern unsigned int spi4_init(uint32   slot, spi4_callback_func);
-extern void spi4_program_rx_desc(uint32  slot,  char*);
-extern int spi4_open(uint32 slot);
-extern void spi4_close(uint32 slot);
-extern int spi4_tx(unsigned int thr_id, uint32 slot,  uint32 spi4_port,
-                char* data, unsigned char* skb,uint32 len);
-extern int spi4_read_reg(uint32 slot, uint32 addr);
-
-
-enum spi4_returns{
-        SPI4_PASS = 0x0,
-        SPI4_TX_FAIL,
-        SPI4_SLOT_ERROR,
-        SPI4_MALLOC_FAIL,
-        SPI4_TX_SYNC_FAIL,
-	SPI4_RX_SYNC_FAIL,
-        SPI4_INIT_SUCCESS,
-	SPI4_CALENDER_LEN_ERROR,
-	SPI4_TX_MAXBURST1_ERROR,
-	SPI4_TX_MAXBURST2_ERROR,
-	SPI4_RX_MAXBURST1_ERROR,
-	SPI4_RX_MAXBURST2_ERROR,
-	SPI4_TX_MAX_BURST_ERROR,
-	SPI4_RX_MAX_BURST_ERROR,
-	SPI4_BYTE_OFFSET_ERROR,
-	SPI4_PARAMS_VALID,
-	SPI4_CONFIG_SPILL_FAIL,
-        SPI4_CONFIG_SPILL_SUCCESS,
-        SPI4_CONFIG_PDE_SUCCESS,
-	SPI4_REGISTER_MSGRING_FAIL,
-        SPI4_REGISTER_MSGRING_SUCESS,
-        SPI4_MMIO_ERROR,
-        SPI4_OPEN_SUCCESS,
-
-};
-
-#endif
-
diff --git a/drivers/net/nlm_spi4/nlm_vits_driver.c b/drivers/net/nlm_spi4/nlm_vits_driver.c
deleted file mode 100644
index 66449cc..0000000
--- a/drivers/net/nlm_spi4/nlm_vits_driver.c
+++ /dev/null
@@ -1,277 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <asm/netlogic/iomap.h>
-#include "nlm_spi4_config.h"
-#include "nlm_vits_wrapper.h"
-#include "nlm_vits_driver.h"
-#include "vitesse_common.h"
-#include "vitesse_highlevel.h"
-#include "vitesse_io.h"
-#include "vitesse_phy_ctrl.h"
-#include <asm/netlogic/debug.h>
-#include "meigsii_reg.h"
-#include <linux/kernel.h>
-
-vtss_mapped_port_t eds_ports_table[VTSS_PORT_ARRAY_SIZE] = {
-
-	/* chip_port, miim_controller, phy_addr */
-	/* logical port 0 doesn't exsist */
-	{         -1,              -1,     -1  }, 
-	{          0,               0,     0x3 },
-	{          1,               0,     0x2 },
-	{          2,               0,     0x1 },
-	{          3,               0,     0x0 },
-	{          4,               0,     0x7 },
-	{          5,               0,     0x6 },
-	{          6,               0,     0x5 },
-	{          7,               0,     0x4 },
-	{          8,               0,     0xb },
-	{          9,               0,     0xa },
-	{         10,               1,     0x1 }  /* This is 10g port */
-};
-
-
-void vtss_eds_init( vtss_mac_major_mode_t mmode, vtss_port_interface_t pmode, BOOL fc)
-{
-	vtss_rc phy_val;
-
-	/* Note that the (R/)GMII ports must be mapped before calling this function */
-
-	int ports_in_use = XLR_TOTAL_CHANNELS; /* all 10 GMII ports are used */
-	int portnum = 0;       
-	vtss_system_setup_t sys_setup;
-	vtss_fifo_setup_t   egress_fifo_setup;
-	vtss_fifo_setup_t   ingress_fifo_setup;
-	vtss_port_setup_t   port_1G_setup;
-	vtss_spi4_setup_t   spi4_setup;
-	vtss_fifo_fc_watermarks_t fc_watermarks;
-	vtss_mac_t smac = {{0,0,0,0,0,0}};
-
-	/* Reset I/O-level software (will also reset the chip) */
-	vtss_chip_reset();
-
-	/* Prepare major mode for runtime calls */
-	vtss_major_mode_set(mmode);
-
-	/* Mapping logical ports with physical ports */
-	vtss_port_map_set(eds_ports_table);
-
-	/* Setup of basic system parameters -- clock, endianess, etc.. */
-	vtss_system_setup_get_default_values( &sys_setup, mmode);
-	vtss_system_setup( &sys_setup);
-
-	/* Setup Host interface */
-	vtss_spi4_setup_get_default_values( &spi4_setup, mmode);
-	vtss_spi4_setup( &spi4_setup);
-
-	/* Setup FIFO */
-	vtss_fifo_setup_get_default_values( &ingress_fifo_setup, 
-				&egress_fifo_setup, mmode);
-	vtss_fifo_setup( &ingress_fifo_setup, &egress_fifo_setup);
-
-
-	/* Setup logical ports */
-	for (portnum = 1; portnum <= ports_in_use; portnum++) {
-
-		phy_val = vtss_phy_reset(portnum) ;
-		if(phy_val != VTSS_OK)
-			printk("Not able to reset phy=%d\n",portnum);
-
-		vtss_port_setup_get_default_values( &port_1G_setup, mmode);
-		/* Change default gmii to pmode */
-		port_1G_setup.interface_mode.interface_type = pmode;
-
-		if (fc) {
-			/* Change flowcontrol settings i MAC */
-			smac.addr[5] = portnum;
-			port_1G_setup.flowcontrol.smac = smac;
-			port_1G_setup.flowcontrol.obey = 1;
-			port_1G_setup.flowcontrol.generate = 1;
-
-			/* Change watermarks settings in FIFO buffer 
-			 * to be used for flowcontrol Ingress for port 
-			 * flowcontrol. Egress for SPI4 flowcontrol */
-			fc_watermarks.low_watermark = 0xc6;
-			fc_watermarks.high_watermark = 0xca;
-			vtss_fifo_watermarks_set( portnum, &fc_watermarks,
-						 &fc_watermarks);
-		}
-		if(vtss_port_setup( portnum, &port_1G_setup))
-			printk("Not able to set the port=%d\n",portnum);
-		if(vtss_port_set_mode(portnum, VTSS_SPEED_100M, 1)!= VTSS_OK)
-			printk("not able to set 100mb\n");	
-
-		/* Port enable */
-		vtss_port_set_enable( portnum, 1, 1);
-	}
-}
-
-
-
-void vtss_nlm_init(int device_number) 
-{
-	long egr_control, crc_cfg, crc_add;
-	int loop;
-	int  portnum  ;
-	unsigned long	tx_rx_status;
-
-	ulong value;
-	BOOL  flow_ena;
-	vtss_mac_major_mode_t eds_mmode; /* major mode */
-	vtss_port_interface_t eds_pmode; /* port  mode */ 
-
-	megis_nlm_common_init(device_number);
-
-	/* Reset I/O layer, configure operating system driver, and reset chip */
-	vtss_io_reset();
-
-	/* Get Chip ID */
-	value = vtss_chip_id_get();
-
-
-	/* Initialize MAC to major mode and port mode */
-	eds_mmode = VTSS_MAC_MAJOR_MODE_SPI4_1G; /* default SPI4<->1G*/
-	eds_pmode = VTSS_PORT_INTERFACE_RGMII; /* default RGMII */
-	flow_ena = 0; 
-
-	vtss_eds_init( eds_mmode, eds_pmode, flow_ena);
-
-	// reset training period 
-	vtss_io_write(M2_BLK_SPI4,0,M2_SPI4_ING_SETUP1, 0x1000f);
-
-	// setup debug counter to count ingress fifo events
-	vtss_io_write(M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_TEST, 0x00010000);
-	vtss_io_write(M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_DEBUG_BUF_CNT, 0x00010000);
-
-	// Setting IFG to small value
-	for(loop=0; loop<=10; loop++){
-		vtss_io_write(M2_BLK_MACS, loop, M2E_TX_IFG, 0x6);
-	}
-
-	// not to drop frame with crc error in egress
-	crc_cfg = vtss_io_read(M2_BLK_SYSTEM,M2_SUBBLK_CTRL,0xb);
-	crc_cfg |= 1<<5;
-	vtss_io_write(M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 0xb, crc_cfg);
-
-	egr_control = vtss_io_read(M2_BLK_FIFO,M2_SUBBLK_EGRESS,M2_EGR_CONTROL);
-	egr_control |= 1<<18;
-	vtss_io_write(M2_BLK_FIFO,M2_SUBBLK_EGRESS,M2_EGR_CONTROL, egr_control);
-
-	for(portnum=0; portnum < XLR_TOTAL_CHANNELS; portnum++){
-			crc_add = vtss_io_read(M2_BLK_MACS, portnum, M2_TRI_DENORM);
-			crc_add &= ~(1<<5); // clear 5th bit crc_upd
-			crc_add |= 1<<4;  // set 4th bit crc_add
-			vtss_io_write(M2_BLK_MACS, portnum, 
-						M2_TRI_DENORM,crc_add);
-			crc_add = vtss_io_read(M2_BLK_MACS, 
-						portnum, M2_TRI_DENORM);
-
-				crc_add = vtss_io_read(M2_BLK_MACS, 
-						portnum, M2_DEV_SETUP);
-			tx_rx_status = vtss_io_read(M2_BLK_MACS, portnum, M2_MODE_CFG);
-			tx_rx_status &= ~(0X3) ; // DISABLE TX RX
-	  	vtss_io_write(M2_BLK_MACS, portnum, M2_MODE_CFG, tx_rx_status);
-		}
-	
-
-	// setup debug counter to count egress fifo events
-	vtss_io_write(M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TEST, 0x00010000);
-	vtss_io_write(M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_DEBUG_BUF_CNT, 0);
-
-
-	// setup debug counter to count spi4 egress traffic
-	vtss_io_write(M2_BLK_SPI4, 0, M2_SPI4_DBG_CNT, 0);
-	vtss_io_write(M2_BLK_SPI4, 0, M2_SPI4_DBG_SETUP, 0x00000002);
-
-	return;
-}
-
-
-int vtss_nlm_monitor_phy_status(int port, int *speed, int *duplexity)
-{
-	vtss_rc ret, dup;
-	vtss_phy_status_t   status;
-
-	ret = vtss_phy_status_get(port, &status);
-	if(ret != VTSS_OK){
-		return 0;
-	}
-	dup = ret = vtss_phy_read(port, 0x1c);
-	if(ret<0) return 0;
-
-	ret >>=3;
-	ret &= 0x3;
-	switch(ret){
-		case 2:
-			(*speed) =(int) SPEED_1000M;
-			break;
-		case 1:
-			(*speed )= (int)SPEED_100M;
-			break;
-		case 0:
-			(*speed) = (int)SPEED_10M;
-			break;
-		default:
-			(*speed) = (int)UNDEFINED_SPEED;
-	}
-	dup >>= 5;
-	dup &= 0x01;
-	if(dup){
-		(*duplexity) = 1;
-	}
-	else{
-		(*duplexity) = 0;
-	}
-
-	return 1;
-}
-
-int vtss_nlm_change_port_status(int port, int speed, int duplexity)
-{
-	int i;
-
-	switch(speed){
-	case SPEED_1000M:
-		speed = VTSS_SPEED_1G;
-		break;
-	case SPEED_100M:
-		speed = VTSS_SPEED_100M;
-		break;
-	case SPEED_10M:
-		speed = VTSS_SPEED_10M;
-		break;
-	default :
-		speed = VTSS_SPEED_1G;
-	}
-	i = vtss_port_set_mode(port, speed, duplexity);
-	if(i == VTSS_OK ){
-		return 1;
-	}
-	else{
-		return 0;
-	}
-}
-
diff --git a/drivers/net/nlm_spi4/nlm_vits_driver.h b/drivers/net/nlm_spi4/nlm_vits_driver.h
deleted file mode 100644
index 18bc537..0000000
--- a/drivers/net/nlm_spi4/nlm_vits_driver.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_VITS_DRIVER_H
-#define _ASM_NLM_VITS_DRIVER_H
-
-#include "vitesse_highlevel.h"
-
-typedef enum _vits_driver_speed{
-	SPEED_10M = 1,
-	SPEED_100M,
-	SPEED_1000M,
-	UNDEFINED_SPEED
-}vits_driver_speed;
-
-
-// driver function prototypes
-void vtss_eds_init( vtss_mac_major_mode_t mmode, 
-		vtss_port_interface_t pmode, BOOL fc);
-void vtss_nlm_init(int device_number);
-int vtss_nlm_monitor_phy_status(int port, int *speed, int *duplexity);
-int vtss_nlm_change_port_status(int port, int speed, int duplexity);
-
-
-#endif
diff --git a/drivers/net/nlm_spi4/nlm_vits_eth.c b/drivers/net/nlm_spi4/nlm_vits_eth.c
deleted file mode 100644
index ca1f5d4..0000000
--- a/drivers/net/nlm_spi4/nlm_vits_eth.c
+++ /dev/null
@@ -1,1221 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/workqueue.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-
-#include <linux/inet.h>
-#include <linux/netdevice.h>
-#include <linux/ethtool.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-
-#include "nlm_vits_eth.h"
-#include "nlm_spi4_config.h"
-#include "os_layer.h"
-
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/sim.h>
-#include "meigsii_reg.h"
-#include "nlm_vits_wrapper.h"
-#include "nlm_vits_driver.h"
-#include "vitesse_common.h"
-#include "vitesse_highlevel.h"
-#include "vitesse_io.h"
-#include "vitesse_phy_ctrl.h"
-
-#include <asm/netlogic/xlr_mac.h>
-
-#define DRV_NAME  "nlm_vits_spi4"
-#define DRV_VERSION "0.1"
-#define DRV_RELDATE "10Aug2005"
-
-#define PHY_MONITOR	1
-#define NLM_SPI4_MAX_CPUS 32
-#define SPI4_FRIN_THRESHOLD spi4_frin_threashold
-#define NLM_SPI4_TX_MAX_COUNTER 100
-#define MAKE_CACHE_ALIGN ~(0x1f)
-#define NLM_SPI4_DEBUG 0
-
-enum vits_returns{
-	VITS_PROGRAM_RX_DESC_FAIL,
-	VITS_PROGRAM_RX_DESC_SUCCESS,
-	VITS_COMMON_INIT_SUCCESS,
-};
-
-struct net_device  *spi4_dev[NLM_SPI4_MAX_PORTS];
-typedef struct _driver_data{
-
-	struct net_device 	*dev;
-	spinlock_t          lock;
-
-	uint	port; // this is eth port: 0-19
-	uint	slot;
-	uint	spi4_port;	//this is spi4 port :0-9
-	uint	speed;
-	uint	duplex;
-	uint 	autoneg;
-	uint	type;
-	uint	cfg_flag;
-	struct net_device_stats        stats;
-  atomic_t     frin_to_be_sent[NLM_SPI4_MAX_CPUS];
-
-}driver_data ;
-
-static int spi4_frin_threashold;
-static struct net_device_ops nlm_spi4_net_ops;
-
-unsigned int g_spi4_card_flag;
-static spinlock_t pending_tx_lock[NLM_SPI4_MAX_PORTS] __cacheline_aligned;
-static spinlock_t base_change=SPIN_LOCK_UNLOCKED;
-
-struct timer_list link_monitor_timer;
-extern unsigned long g_dip4_error[];
-extern int cpu_to_bktmask[];
-static struct 	work_struct vits_frin_replenish_work[NLM_SPI4_MAX_CPUS];
-
-void set_ethtool_ops(struct net_device *netdev);
-
-void nlm_vits_rx_tx_done( uint32  cmd, uint32 slot,  	uint32	port,
-		char*	addr, uint32  len,	uint32	error);
-
-
-unsigned char spi4_check_daughter_cards(void);
-static __inline__ struct sk_buff *spi4_get_skb_back_ptr(unsigned long addr)
-{
-	unsigned long *back_ptr =
-		(unsigned long *)(addr - MAC_SKB_BACK_PTR_SIZE);
-
-	/* this function should be used only for newly allocated packets.
-	 * It assumes the first cacheline is for the back pointer related
-	 * book keeping info
-	 */
-	return (struct sk_buff *)(*back_ptr);
-}
-
-static __inline__ void spi4_put_skb_back_ptr(struct sk_buff *skb)
-{
-	unsigned long *back_ptr = (unsigned long *)skb->data;
-
-	/* this function should be used only for newly allocated
-	 * packets. It assumes  the first cacheline is for the back
-	 * pointer related book keeping info
-	 */
-	skb_reserve(skb, MAC_SKB_BACK_PTR_SIZE);
-
-	*back_ptr = (unsigned long)skb;
-}
-
-void change_vits_base(int port)
-{
-    if(port < NLM_SPI4_PORTS_PER_CARD){
-      megis_nlm_common_init(1);
-    }
-    else{
-      megis_nlm_common_init(2);
-    }
-	return;
-}
-
-/*******************************************************************************
-* Function name :       nlm_link_monitor
-* Input         :
-* Description   :       This function monitors all the phy channels and if speed
-*	or duplexity changed, then it changes the mac's speed and duplexity.
-* RETURNS       :       void
-*******************************************************************************/
-
-void nlm_link_monitor(unsigned long data)
-{
-
-	int i, port, cpu, thr_id, slot;
-	struct net_device *dev;
-	driver_data *priv ;
-	int speed, duplexity;
-	unsigned long flags;
-	vtss_phy_status_t phy_status;
-
-	cpu = netlogic_cpu_id() ;
-	thr_id = netlogic_thr_id() ;
-
-	spin_lock_irqsave(&base_change, flags);
-	for(i =0; i< NLM_SPI4_MAX_PORTS; i++){
-		slot = active_port[i].slot ;
-
-		if((spi4_slot[slot] == INVALID_SLOT ) ||
-		(active_port[i].port == INVALID_PORT)) continue;
-
-		if(!(g_spi4_card_flag & (1<<slot)))
-      			continue;
-
-		change_vits_base(i);
-
-		if(active_port[i].slot == SPI4_0)
-			port = active_port[i].port;
-		else if(active_port[i].slot == SPI4_1)
-			port = (active_port[i].port) - NLM_SPI4_PORTS_PER_CARD;
-		else{
-			printk("ERROR: wrong slot should never happen\n");
-			continue;
-		}
-
-		/*if the link is down for the particular port just continue
-		  for the remaining ports */
-		port++;
-		if(!vtss_nlm_monitor_phy_status(port, &speed, &duplexity)){
-			continue;
-		}
-		dev = spi4_dev[i];
-		if(!dev) continue;
-		priv = netdev_priv(dev);
-		if(speed == UNDEFINED_SPEED){
-			continue;
-		}
-#if NLM_SPI4_DEBUG
-		printk("new speed=%d, old_speed=%d\n",
-			speed, priv->speed);
-#endif
-		if((priv->speed != speed) || (priv->duplex != duplexity)){
-#if NLM_SPI4_DEBUG
-			printk("speed change to port=%d : speed=%d, dup=%d\n",
-				port, speed, duplexity);
-#endif
-			if(vtss_nlm_change_port_status(port, speed, duplexity)){
-				priv->speed = speed;
-				priv->duplex = duplexity;
-			}
-		}
-
-		if(vtss_phy_status_get(port, &phy_status) == VTSS_OK){
-			if (phy_status.link_status) {
-				netif_carrier_on(dev);
-			}
-			else {
-				netif_carrier_off(dev);
-			}
-		}
-		else {
-#if NLM_SPI4_DEBUG
-			printk("phy status read failed\n");
-#endif
-		}
-	}// end of for loop
-
-	spin_unlock_irqrestore(&base_change,flags);
-	link_monitor_timer.expires = jiffies +  HZ;
-	add_timer(&link_monitor_timer);
-
-	return;
-}
-
-
-
-static int nlm_vits_open(struct net_device *dev)
-{
-	unsigned int vits_port;
-  unsigned long  tx_rx_status;
-	driver_data *priv = netdev_priv(dev);
-  unsigned long flags;
-
-#if NLM_SPI4_DEBUG
-	printk("opening the spi4 interface: %d\n", priv->port);
-#endif
-
-  spin_lock_irqsave(&base_change, flags);
-  if(priv->port < NLM_SPI4_PORTS_PER_CARD){
-		vits_port =  priv->port ;
-	}
-	else {
-		vits_port =  priv->port - NLM_SPI4_PORTS_PER_CARD;
-	}
-	change_vits_base(priv->port);
-  tx_rx_status = vtss_io_read(M2_BLK_MACS, vits_port, M2_MODE_CFG);
-	tx_rx_status |= 0x3 ; // enable TX and RX
-	vtss_io_write(M2_BLK_MACS, vits_port, M2_MODE_CFG, tx_rx_status);
-
-  spin_unlock_irqrestore(&base_change,flags);
-	return 0;
-}
-
-static int nlm_vits_close(struct net_device *dev)
-{
-  unsigned int vits_port;
-  unsigned long  tx_rx_status;
-  unsigned long flags;
-
-	driver_data *priv = netdev_priv(dev);
-
-#if NLM_SPI4_DEBUG
-	printk("closing the spi4 interface: %d\n", priv->port);
-#endif
-  spin_lock_irqsave(&base_change, flags);
-  if(priv->port < NLM_SPI4_PORTS_PER_CARD){
-		vits_port =  priv->port ;
-	}
-	else {
-		vits_port =  priv->port - NLM_SPI4_PORTS_PER_CARD;
-	}
-  change_vits_base(priv->port);
-  tx_rx_status = vtss_io_read(M2_BLK_MACS, vits_port, M2_MODE_CFG);
-	tx_rx_status &= ~(0x3) ; // disable TX and RX
-	vtss_io_write(M2_BLK_MACS, vits_port, M2_MODE_CFG, tx_rx_status);
-  spin_unlock_irqrestore(&base_change,flags);
-	return 0;
-}
-
-#if NLM_SPI4_DEBUG
-void print_stats(vtss_port_counters_t *stat)
-{
-
-	printk("out byte		: %ld\n",stat->tx_out_bytes);
-	printk("tx_pause		: %ld\n", stat->tx_pause);
-	printk("tx_ok_by		: %ld\n", stat->tx_ok_bytes);
-	printk("tx_unicast		: %ld\n", stat->tx_unicast);
-	printk("tx_multicast		: %ld\n", stat->tx_multicast);
-	printk("tx_broadcast		: %ld\n", stat->tx_broadcast);
-	printk("tx_multiple_coll	: %ld\n", stat->tx_multiple_coll);
-	printk("tx_late_coll		: %ld\n", stat->tx_late_coll);
-	printk("tx_xcoll		: %ld\n", stat->tx_xcoll);
-	printk("tx_defer		: %ld\n", stat->tx_defer);
-	printk("tx_xdefer		: %ld\n", stat->tx_xdefer);
-	printk("tx_carrier_sense	: %ld\n", stat->tx_carrier_sense);
-	printk("tx_size_64		: %ld\n", stat->tx_size_64);
-	printk("tx_size_65_to_127	: %ld\n", stat->tx_size_65_to_127);
-	printk("tx_size_128_to_255	: %ld\n", stat->tx_size_128_to_255);
-	printk("tx_size_256_to_511	: %ld\n", stat->tx_size_256_to_511);
-
-	printk("tx_single_coll		: %ld\n", stat->tx_single_coll);
-	printk("tx_backoff2		: %ld\n", stat->tx_backoff2);
-	printk("tx_backoff3		: %ld\n", stat->tx_backoff3);
-	printk("\n");
-	printk("tx_underrun		: %ld\n", stat->tx_underrun);
-	printk("ingress_overflow_drop	: %ld\n", stat->ingress_overflow_drop);
-	printk("egress_overflow_drop	: %ld\n", stat->egress_overflow_drop);
-	printk("\n");
-
-
-	printk("rx_in_bytes            : %ld\n",stat->rx_in_bytes);
-	printk("rx_ok_bytes            : %ld\n",stat->rx_ok_bytes);
-	printk("rx_bad_bytes           : %ld\n", stat->rx_bad_bytes);
-	printk("rx_unicast             : %ld\n", stat->rx_unicast);
-	printk("rx_multicast           : %ld\n",stat->rx_multicast);
-	printk("rx_broadcast           : %ld\n", stat->rx_broadcast);
-	printk("rx_crc                 : %ld\n", stat->rx_crc);
-	printk("rx_undersize           : %ld\n", stat->rx_undersize);
-	printk("rx_fragments           : %ld\n", stat->rx_fragments);
-	printk("rx_in_range_error      : %ld\n", stat->rx_in_range_error);
-	printk("rx_out_of_range_error  : %ld\n", stat->rx_out_of_range_error);
-	printk("rx_oversize            : %ld\n", stat->rx_oversize);
-
-	printk("\n");
-	printk("\n");
-
-	return;
-}
-
-void nlm_vits_dump_dbg_regs(struct net_device *dev)
-{
-
-	int port;
-	long reg_value;
-
-	driver_data *priv = netdev_priv(dev);
-	if(priv->slot == SPI4_0)
-		port = priv->port;
-	else if(priv->slot == SPI4_1)
-		port = priv->port - NLM_SPI4_PORTS_PER_CARD;
-	else
-		return ;
-
-	port++;
-	reg_value = spi4_read_reg(priv->slot, R_TX_CONTROL);
-	printk("GLUE REG: TX CONTROL addr : A0 = %lx\n", reg_value);
-	reg_value = spi4_read_reg(priv->slot, SPI4_TX_STATUS);
-	printk("TX STATUS = 0x%lx\n", reg_value);
-	reg_value = spi4_read_reg(priv->slot, SPI4_RX_STATUS);
-	printk("RX STATUS = 0x%lx\n", reg_value);
-	reg_value = spi4_read_reg(priv->slot, 0x70);
-	printk("INT REG = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(1, port, 0x0a);
-	printk("VTSS reg stick_bit - addr 0x0a = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(1, port, 0x0c);
-	printk("VTSS reg drop count - addr 0x0c = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(7, 0xf, 0x0a);
-	printk("VTSS reg egr crc count -(7,f,a)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(7, 0xf, 0x0b);
-	printk("VTSS reg crc config -(7,f,b)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x0f);
-	printk("VTSS reg EGR_CONTROL -(2,1,f)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x60);
-	printk("VTSS reg EGR DROP COUNT -(2,1,60)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x61);
-	printk("VTSS reg EGR DROP COUNT  -(2,1,61)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x62);
-	printk("VTSS reg EGR DROP COUNT  -(2,1,62)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x63);
-	printk("VTSS reg EGR DROP COUNT  -(2,1,63)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x64);
-	printk("VTSS reg EGR DROP COUNT  -(2,1,64)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x65);
-	printk("VTSS reg EGR DROP COUNT  -(2,1,65)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x66);
-	printk("VTSS reg EGR DROP COUNT  -(2,1,66)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x67);
-	printk("VTSS reg EGR DROP COUNT  -(2,1,67)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x68);
-	printk("VTSS reg EGR DROP COUNT  -(2,1,68)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(2, 1, 0x69);
-	printk("VTSS reg EGR DROP COUNT  -(2,1,69)  = 0x%lx\n", reg_value);
-	reg_value = vtss_io_read(5, 0, 0x30);
-	printk("VTSS reg spi4_sticky : host spi:   -(5,0,30)  = 0x%lx\n", reg_value);
-
-	return;
-}
-#endif
-
-int nlm_vits_collect_stats(struct net_device *dev,
-		vtss_port_counters_t *stat)
-{
-	int port;
-	driver_data *priv = netdev_priv(dev);
-
-	if(priv->slot == SPI4_0)
-		port = priv->port;
-	else if(priv->slot == SPI4_1)
-		port = priv->port - NLM_SPI4_PORTS_PER_CARD ;
-	else
-		return 1;
-	change_vits_base(priv->port);
-	// this is for the VTSS API, which will search the port data structure
-	port++;
-	if(vtss_port_counters_get((const vtss_port_no_t)port,stat)== VTSS_OK){
-		return 0;
-	}
-	return 1;
-}
-/*
-   VTSS API for clearing stat has some problem, one can't clear for a
-   particular port, it will clear all the ports, so currently stat clear
-   is not done
- */
-static struct net_device_stats* nlm_vits_get_stats(struct net_device *dev)
-{
-  unsigned long flags, i ;
-	unsigned long total_dip4=0;
-	vtss_port_counters_t stat;
-	driver_data *priv = netdev_priv(dev);
-
-  spin_lock_irqsave(&base_change, flags);
-	if((priv->slot == INVALID_SLOT ) ||
-	(priv->port == INVALID_PORT)){
-	  spin_unlock_irqrestore(&base_change,flags);
-		return &priv->stats;
-	}
-	if(nlm_vits_collect_stats(dev, &stat)){
-	  spin_unlock_irqrestore(&base_change,flags);
-		return &priv->stats;
-	}
-
-	/*update the vits stats to dev stats*/
-	priv->stats.rx_packets = stat.rx_unicast + stat.rx_broadcast;
-	priv->stats.tx_packets = stat.tx_unicast;
-	priv->stats.rx_bytes =	stat.rx_ok_bytes;
-	priv->stats.tx_bytes = stat.tx_ok_bytes;
-	priv->stats.rx_fifo_errors = stat.ingress_overflow_drop;
-	priv->stats.tx_fifo_errors = stat.egress_overflow_drop;
-	priv->stats.multicast = stat.rx_multicast;
-	for(i = 0; i< NLM_SPI4_MAX_THREADS; i++){
-		total_dip4 += g_dip4_error[i] ;
-	}
-	priv->stats.rx_errors = total_dip4;
-	priv->stats.rx_crc_errors = stat.rx_crc ;
-	priv->stats.multicast = stat.rx_multicast;
-  spin_unlock_irqrestore(&base_change,flags);
-	return &priv->stats;
-
-}
-
-static int nlm_vits_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	unsigned int thr_id, ret = 0;
-	unsigned eth_port;
-  unsigned long flags;
-	driver_data *priv = netdev_priv(dev);
-
-#if NLM_SPI4_DEBUG
-	printk("[%s]: port=%d, skb=%p, len=%d\n",
-			__FUNCTION__, priv->port,skb, skb->len);
-	for(i=0; i<skb->len; i++)
-		printk("%x  ", skb->data[i]);
-	printk("\n");
-#endif
-	thr_id = hard_smp_processor_id();
-	
-	if(cpu_to_bktmask[thr_id] == 0) {
-		printk("Tx fail : No buckets are allocated for this cpu\n");
-		return 1;
-	}
-
-
-	if(spi4_tx(thr_id,priv->slot, priv->spi4_port, skb->data,
-						(unsigned char*) skb, skb->len)){
-		eth_port = priv->port;
-		spin_lock_irqsave(&pending_tx_lock[eth_port], flags);
-		/* now once again attempt to send, in case, by this time
-			 if any TX_DONE happend for the corresponding port*/
-  	if(spi4_tx(thr_id,priv->slot, priv->spi4_port, skb->data,
-            (unsigned char*) skb, skb->len)){
-	    netif_stop_queue(dev);
-			ret = 1;
-		}
-		else{
-			ret = 0;
-		}
-		spin_unlock_irqrestore(&pending_tx_lock[eth_port], flags);
-	}
-
-	return ret;
-}
-
-
-int nlm_vits_program_rx_desc(unsigned int slot,
-		int total_desc)
-{
-	int     i;
-	struct  sk_buff *skb = 0;
-	unsigned int ret = VITS_PROGRAM_RX_DESC_SUCCESS;
-
-	for(i=0; i< total_desc; i++){
-		skb = os_alloc_skb();
-		if (!skb) {
-			printk("ERROR: alloc skb failed\n");
-			ret = VITS_PROGRAM_RX_DESC_FAIL;
-			break;
-		}
-		spi4_put_skb_back_ptr(skb);
-		spi4_program_rx_desc(slot, skb->data) ;
-	}
-	return ret;
-}
-
-/*******************************************************************************
-* Function name :       nlm_vits_frin_replenish
-* Input         :
-* Description   :       This function replenish RX desc for all ports for
-*	a cpu on which it is scheduled.
-* RETURNS       :       void
-*******************************************************************************/
-static void nlm_vits_frin_replenish(struct work_struct *data)
-{
-  int done = 0;
-  int cpu = hard_smp_processor_id();
-
-  driver_data *priv;
-  struct net_device *dev;
-  atomic_t *frin_to_be_sent;
-  int i;
-
-  while(1){
-    done = 0;
-    for(i=0; i< NLM_SPI4_MAX_PORTS; i++){
-      if(active_port[i].port == INVALID_PORT){
-        goto skip;
-      }
-      dev = spi4_dev[i];
-      if(dev == NULL){
-        goto skip;
-      }
-      priv =netdev_priv(dev);
-
-	  if(!(MSGRNG_OWN(priv->cfg_flag)))
-			continue;
-
-      frin_to_be_sent = &priv->frin_to_be_sent[cpu];
-      if(atomic_read(frin_to_be_sent) < 0) {
-        printk("ERROR: wrong frin_to_be_sent \n");
-      }
-
-		
-      if (!atomic_read(frin_to_be_sent)) goto skip;
-      			if(nlm_vits_program_rx_desc(priv->slot, 1) ==
-					VITS_PROGRAM_RX_DESC_SUCCESS){
-        atomic_dec(frin_to_be_sent);
-      }
-      continue;
-      skip:
-      done++;
-    }
-    if(done == NLM_SPI4_MAX_PORTS) break;
-  }
-  return;
-}
-
-/*******************************************************************************
-* Function name :    	nlm_vits_rx_tx_done
-* Input         :
-* Description   :       This function handles the TX DONE and RX IND. It keeps
-*	track the RX desc to be replenish, if it crosses the water mark then
-*	schedules the replenish work item.
-* RETURNS       :       void
-*******************************************************************************/
-
-void nlm_vits_rx_tx_done(	uint32  cmd, 	uint32 	slot,
-				uint32 	port,	char*   addr,
-				uint32  len,	uint32	error)
-{
-	struct 	net_device   *dev;
-	struct 	sk_buff      *skb = 0;
-	int 	cpu ;
-	driver_data	*priv;
-	unsigned int 	eth_interface ;
-
-	cpu = hard_smp_processor_id();
-	switch(cmd){
-	case SPI4_TX_DONE:
-	 	/*in TX_DONE case, port indicates bucket*/
-    skb = (struct  sk_buff*)addr;
-
-		if(skb==NULL){
-			printk("ERROR - TX_DONE: null skb \n");
-			return;
-		}
-    		priv = netdev_priv(skb->dev);
-		eth_interface = priv->port;
-    		spin_lock(&pending_tx_lock[eth_interface]);
-		if(netif_queue_stopped(skb->dev)){
-		 	netif_wake_queue(skb->dev);
-		}
-    		spin_unlock(&pending_tx_lock[eth_interface]);
-		os_free(skb);
-		break;
-	case SPI4_RX_IND:
-#if NLM_SPI4_DEBUG
-		printk("[%s]RX_IND :   port=%d\n",
-			__FUNCTION__,  priv->port);
-#endif
-
-    if(slot == SPI4_0){
-      eth_interface = port;
-    }
-    else if(slot == SPI4_1){
-      eth_interface = port + NLM_SPI4_PORTS_PER_CARD;
-    }
-    else{
-      printk("[%s] ERROR!!! invalid slot\n",__FUNCTION__);
-      return;
-    }
-    dev = spi4_dev[eth_interface];
-    if(dev == NULL){
-      			printk("[%s]ERROR!! eth interface=%d , port=%d , \
-					not registered\n",
-          __FUNCTION__, eth_interface,port);
-      return;
-    }
-
-    priv = netdev_priv(dev);
-		skb = spi4_get_skb_back_ptr((unsigned long)addr);
-		if(!skb){
-			printk("NULL skb pointer in RX handling\n");
-			return;
-		}
-		skb->dev = dev;
-		skb_reserve(skb, MAC_PREPAD+SPI4_BYTE_OFFSET);
-		skb_put(skb, len);
-		skb->protocol = eth_type_trans(skb, skb->dev);
-		//schedule work to do replenishing
-    if (atomic_inc_return(&priv->frin_to_be_sent[cpu]) >
-      SPI4_FRIN_THRESHOLD){
-      schedule_work(&vits_frin_replenish_work[cpu]);
-    }
-
-#if NLM_SPI4_DEBUG
-		{
-			int loop;
-			printk("[%s] skb: len=%d, data is:\n",
-				__FUNCTION__, skb->len);
-			for(loop=0; loop<skb->len; loop++)
-				printk("%x  ", skb->data[loop]);
-			printk("\n");
-
-		}
-#endif
-		netif_rx(skb);
-		break;
-	}//end of switch
-	return;
-}
-
-/*******************************************************************************
-* Function name :    	nlm_vits_station_unowned_rx_tx_done
-* Input         :
-* Description   :       This function handles the TX DONE and RX IND. It keeps
-*	track the RX desc to be replenish, if it crosses the water mark then
-*	schedules the replenish work item.
-* RETURNS       :       void
-*******************************************************************************/
-
-void nlm_vits_station_unowned_rx_tx_done(	uint32  cmd, 	uint32 	slot,
-				uint32 	port,	char*   addr,
-				uint32  len,	uint32	error)
-{
-	struct 	net_device   *dev;
-	struct 	sk_buff      *skb = 0;
-	int 	cpu ;
-	driver_data	*priv;
-	unsigned int 	eth_interface ;
-	int fbstid;
-
-	cpu = hard_smp_processor_id();
-	switch(cmd){
-	case SPI4_TX_DONE:
-	 	/*in TX_DONE case, port indicates bucket*/
-    skb = (struct  sk_buff*)addr;
-
-		if(skb==NULL){
-			printk("ERROR - TX_DONE: null skb \n");
-			return;
-		}
-    		priv = netdev_priv(skb->dev);
-		eth_interface = priv->port;
-    		spin_lock(&pending_tx_lock[eth_interface]);
-		if(netif_queue_stopped(skb->dev)){
-		 	netif_wake_queue(skb->dev);
-		}
-    		spin_unlock(&pending_tx_lock[eth_interface]);
-		os_free(skb);
-		break;
-	case SPI4_RX_IND:
-#if NLM_SPI4_DEBUG
-		printk("[%s]RX_IND :   port=%d\n",
-			__FUNCTION__,  priv->port);
-#endif
-
-    if(slot == SPI4_0){
-		fbstid = msgrng_xgmac_stid_rfr(0);
-      eth_interface = port;
-    }
-    else if(slot == SPI4_1){
-		fbstid = msgrng_xgmac_stid_rfr(1);
-      eth_interface = port + NLM_SPI4_PORTS_PER_CARD;
-    }
-    else{
-      printk("[%s] ERROR!!! invalid slot\n",__FUNCTION__);
-      return;
-    }
-    dev = spi4_dev[eth_interface];
-    if(dev == NULL){
-      			printk("[%s]ERROR!! eth interface=%d , port=%d , \
-					not registered\n",
-          __FUNCTION__, eth_interface,port);
-      return;
-    }
-
-    priv = netdev_priv(dev);
-	/*
-	 * Allocate an skbuff, initialize it, and copy the data to it.
-	 */
-	skb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_ATOMIC);
-	if (!skb) {
-		printk("[%s] - no skbuff\n", __FUNCTION__);
-		goto err_exit;
-	}
-
-		skb->dev = dev;
-		skb_reserve(skb, MAC_PREPAD+SPI4_BYTE_OFFSET);
-		skb_put(skb, len);
-		skb->protocol = eth_type_trans(skb, skb->dev);
-		memcpy(skb->data, (char *)addr + 2, len);
-/*
-		if(rmik_queue_pkt_mem(fbstid, virt_to_phys(addr) & 0xffffffffe0ULL) < 0)
-		nlm_nlm_common_drop_message_unowned(fbstid, virt_to_phys(addr) & 0xffffffffe0ULL, 1);
-*/
-	
-#if NLM_SPI4_DEBUG
-		{
-			int loop;
-			printk("[%s] skb: len=%d, data is:\n",
-				__FUNCTION__, skb->len);
-			for(loop=0; loop<skb->len; loop++)
-				printk("%x  ", skb->data[loop]);
-			printk("\n");
-
-		}
-#endif
-		netif_rx(skb);
-		return;
-		err_exit:
-/*
-		nlm_nlm_common_drop_message_unowned(fbstid, virt_to_phys(addr) & 0xffffffffe0ULL, 1);
-*/
-		if(skb)
-			kfree_skb(skb);
-
-	}//end of switch
-	return;
-}
-
-
-/****************************************************************************
-* Function name :       spi4_check_daughter_cards
-* Input         :
-* Description   :       This function reads the cpld register and checks
-*                       whether any spi4 daughter card present on the board.
-* RETURNS       :       0-if no spi4 cards present
-*                       1-if only spi4-A present
-*                       2-if only spi4-B present
-*                       3-if both spi4-A and spi4-B present
-****************************************************************************/
-unsigned char spi4_check_daughter_cards(void)
-{
-	unsigned char value, flag = 0;
-	unsigned long cpld_base;
-	unsigned char *mmio ;
-
-        cpld_base = (unsigned long)(NETLOGIC_CPLD_OFFSET);
-        mmio = (unsigned char*) cpld_base;
-	value = mmio[CPLD_MISC_STATUS_REG];
-
-
-	value = value>>3;
-       	if(!(value & SPI4_MASK_BIT1))
-		flag = 1;
-
-	value = value >>1;
-	if(!(value & SPI4_MASK_BIT1))
-		flag |=2;
-
-        return flag;
-
-}
-
-/*******************************************************************************
-* Function name :	nlm_vits_common_init
-* Input         :
-* Description   :       This function calls the spi4 drivers functions to
-*	ititilize the spi4, configure spills and programs RX desc.
-* RETURNS       :       void
-*******************************************************************************/
-
-int  nlm_vits_common_init(unsigned int slot)
-{
-	unsigned int spi4_ret_value;
-	static int work_init = 0;
-	extern struct net_device_cfg xlr_net_dev_cfg;
-	struct net_device_cfg *net_cfg = &xlr_net_dev_cfg;
-	struct port_cfg *port_cfg;
-	spi4_callback_func callback;
-
-	port_cfg = &net_cfg->xgs_port[slot];
-
-	if(spi4_frin_threashold == 0)
-		spi4_frin_threashold =  MAX_NUM_DESC / NR_CPUS;
-
-	if(MSGRNG_OWN(port_cfg->cfg_flag))
-		callback = nlm_vits_rx_tx_done;
-	else
-		callback = nlm_vits_station_unowned_rx_tx_done;
-
-	spi4_ret_value = spi4_init(slot, (spi4_callback_func)callback);
-	if(spi4_ret_value != SPI4_INIT_SUCCESS)
-		return spi4_ret_value ;
-
-	if(MSGRNG_OWN(port_cfg->cfg_flag)) {
-		spi4_ret_value = nlm_vits_program_rx_desc(slot,
-							  (int)MAX_NUM_DESC * XLR_TOTAL_CHANNELS);
-		if( spi4_ret_value != VITS_PROGRAM_RX_DESC_SUCCESS ){
-			return spi4_ret_value ;
-		}
-	}
-
-	if(PORT_INIT(port_cfg->cfg_flag)) {
-		spi4_ret_value = spi4_open(slot);
-		if( spi4_ret_value != SPI4_OPEN_SUCCESS ){
-			return spi4_ret_value ;
-		}
-	}
-
-	if(MSGRNG_OWN(port_cfg->cfg_flag)) {
-		if(!work_init){
-			for(slot=0; slot<NLM_SPI4_MAX_CPUS; slot++){
-				INIT_WORK(&vits_frin_replenish_work[slot],
-					nlm_vits_frin_replenish);
-			}
-			work_init = 1;
-		}
-	}
-	return  VITS_COMMON_INIT_SUCCESS;
-}
-
-
-static void setup_net_ops(struct net_device_ops *spi4_ops)
-{
-	spi4_ops->ndo_open = nlm_vits_open;
-	spi4_ops->ndo_stop = nlm_vits_close;
-	spi4_ops->ndo_get_stats = nlm_vits_get_stats;
-	spi4_ops->ndo_start_xmit = nlm_vits_xmit;
-}
-/*******************************************************************************
-* Function name :      	nlm_vits_init
-* Input         :
-* Description   :       This function allocates the dev data structure for the
-*	eth drivers and initializes it
-* RETURNS       :       void
-*******************************************************************************/
-
-int nlm_vits_init(void)
-{
-	unsigned int 				slot, port_start, port_end;
-	struct net_device  	*dev  = 0;
-	driver_data 				*priv = 0;
-	extern struct net_device_cfg xlr_net_dev_cfg;
-	struct net_device_cfg *net_cfg = &xlr_net_dev_cfg;
-	struct port_cfg *port_cfg;
-	int 	i = 0;
-	int 	ret = 0, port_register_flag=0;
-
-  	for(slot =0; slot < NLM_SPI4_MAX_SLOTS; slot++){
-		if(net_cfg->xgs_type[slot] == TYPE_SPI4)
-			break;
-	}
-	if(slot == NLM_SPI4_MAX_SLOTS) {
-		printk(KERN_INFO "This board does not support spi4\n");
-		return -1;
-	}
-
-  	g_spi4_card_flag = spi4_check_daughter_cards();
-
-	if(!g_spi4_card_flag){
-        printk(KERN_INFO "nlm_spi4: No SPI4 cards detected\n");
-		return -1;
-	}
-
-	setup_net_ops(&nlm_spi4_net_ops);
-
-	for(slot =0; slot < NLM_SPI4_MAX_SLOTS; slot++){
-		if(spi4_slot[slot] == INVALID_SLOT) continue;
-
-    		if(!(g_spi4_card_flag & (1<<slot))) continue;
-
-			port_cfg = &net_cfg->xgs_port[slot];
-			if(port_cfg->cfg_flag == 0)
-				continue;
-
-    		printk("initializing spi4-%d\n", slot);
-		   if(nlm_vits_common_init(slot) != VITS_COMMON_INIT_SUCCESS){
-      			printk("initialization failed for spi4-%d\n",slot);
-			continue;
-		}
-
-		if(slot == SPI4_0){
-			port_start = 0;
-			port_end =  NLM_SPI4_PORTS_PER_CARD;
-		}
-		else if(slot == SPI4_1){
-      port_start = 0 + NLM_SPI4_PORTS_PER_CARD;
-      port_end = NLM_SPI4_MAX_PORTS ;
-    }
-		else{
-			port_start = port_end = 0;
-		}
-		for(i = port_start; i < port_end; i++){
-			if((active_port[i].slot == INVALID_SLOT ) ||
-			(active_port[i].port == INVALID_PORT)) continue;
-
-			dev = alloc_etherdev(sizeof(driver_data));
-			if (!dev) {
-				ret = -ENOMEM;
-				goto out;
-			}
-			spi4_dev[i] = dev;
-			priv = netdev_priv(dev);
-			priv->dev= dev;
-			ether_setup(dev);
-
-			sprintf(dev->name, "%s%d", "spi",i);
-			dev->netdev_ops = &nlm_spi4_net_ops;
-
-			/* initializing priv member */
-			spin_lock_init(&priv->lock);
-			priv->port =(uint) active_port[i].port;
-			priv->slot =(uint) active_port[i].slot;
-			priv->cfg_flag = port_cfg->cfg_flag;
-
-			if(priv->slot == SPI4_0){
-				priv->spi4_port = priv->port;
-			}
-			else{
-				priv->spi4_port = priv->port - NLM_SPI4_PORTS_PER_CARD;
-			}
-			priv->type = (uint)TYPE_SPI4;
-			/*this is the default link configuration*/
-			priv->speed = SPEED_100M;
-			priv->duplex = 1;
-			priv->autoneg = 1;
-
-			dev->dev_addr[0] = 0x0;
-			dev->dev_addr[1] = 0x0f;
-			dev->dev_addr[2] = 0x30;
-			dev->dev_addr[3] = 0x00;
-			dev->dev_addr[4] = 0x01;
-			dev->dev_addr[5] = i ;
-
-			if(PORT_ATTACH(port_cfg->cfg_flag)){
-			ret = register_netdev(dev);
-			if (ret) {
-				printk("Unable to register %s  eth interface \n",
-				dev->name);
-	    	free_netdev(dev);
-				continue;
-			}
-			printk("%s eth interface is registered\n", dev->name);
-			set_ethtool_ops(dev);
-		}
-			else{
-				nlm_vits_open(dev);
-			}
-			port_register_flag = 1;
-		}
-	}
-
-  	if(port_register_flag){
-	// starting a timer to monitor the link
-	init_timer(&link_monitor_timer);
-	link_monitor_timer.expires = jiffies + 2 * HZ/100;
-	link_monitor_timer.function = nlm_link_monitor;
-	add_timer(&link_monitor_timer);
-	}
-out:
-	if (ret < 0) {
-		printk("Error, ret = %d\n", ret);
-	}
-	return ret;
-}
-
-
-
-void nlm_vits_exit(void)
-{
-	struct net_device *dev;
-	int i;
-
-	for (i = 0; i < NLM_SPI4_MAX_PORTS; i++) {
-		dev = spi4_dev[i];
-		if (!dev)
-			continue;
-		printk("unregistering dev%d\n", i);
-		unregister_netdev(dev);
-		free_netdev(dev);
-	}
-}
-
-/*******************************************************************************
-* Function name :       spi4_get_settings
-* Input         :
-* Description   :       This function provides info about speed, duplexity,
-*	autoneg to ethtool commands.
-* RETURNS       :       void
-*******************************************************************************/
-
-static int
-spi4_get_settings(	struct net_device *dev,
-			struct ethtool_cmd *ecmd)
-{
-
-	driver_data *priv = netdev_priv(dev);
-
-
-	ecmd->supported = (SUPPORTED_10baseT_Half |
-			SUPPORTED_10baseT_Full |
-			SUPPORTED_100baseT_Half |
-			SUPPORTED_100baseT_Full |
-			SUPPORTED_1000baseT_Full|
-			SUPPORTED_Autoneg
-			);
-
-	ecmd->advertising = ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half |
-		ADVERTISED_100baseT_Full | ADVERTISED_100baseT_Half |
-		ADVERTISED_1000baseT_Full | ADVERTISED_Autoneg;
-
-	switch(priv->speed){
-	case  SPEED_1000M:
-		ecmd->speed = SPEED_1000;
-		break;
-
-	case SPEED_100M:
-		ecmd->speed = SPEED_100;
-		break;
-
-	case SPEED_10M:
-		ecmd->speed = SPEED_10;
-		break;
-
-	}// end of switch
-	ecmd->duplex = priv->duplex;
-	ecmd->phy_address = priv->port;
-	ecmd->port = PORT_TP;
-	ecmd->autoneg = priv->autoneg;
-	return 0;
-}
-
-/*******************************************************************************
-* Function name :       spi4_set_settings
-* Input         :
-* Description   :       This function provides ethtool to set speed, duplexity,
-*       autoneg to ethtool commands.
-* RETURNS       :       void
-*******************************************************************************/
-
-static int
-spi4_set_settings(	struct net_device *netdev,
-			struct ethtool_cmd *ecmd)
-{
-
-  unsigned long flags;
-	driver_data *priv = netdev_priv(netdev);
-	vtss_phy_control_t    phy_cnt;
-	int speed	, driver_speed;
-	int ret = 0;
-	int port;
-	vtss_pcs_autoneg_control_t  autoneg;
-
-	/*
-	   only speed and duplexity parameters are supported
-	 */
-  spin_lock_irqsave(&base_change, flags);
-	port = active_port[ecmd->port].port ;
-	if(port == INVALID_PORT){
-	  	spin_unlock_irqrestore(&base_change,flags);
-		return -EINVAL;
-	}
-	change_vits_base(port);
-	port++;// this is to make the vtss APIs to get the correct PHY port
-	if(vtss_phy_control_get(port, &phy_cnt) == VTSS_OK){
-#if NLM_SPI4_DEBUG
-		printk("phy status read success\n");
-#endif
-	}
-	else{
-	  spin_unlock_irqrestore(&base_change,flags);
-#if NLM_SPI4_DEBUG
-		printk("phy status read failed\n");
-#endif
-		return  1;
-	}
-
-
-	if(ecmd->autoneg == AUTONEG_ENABLE){
-		phy_cnt.autoneg_enable = 1 ;
-	}
-	else{
-		phy_cnt.autoneg_enable = 0 ;
-	}
-	if(priv->autoneg != phy_cnt.autoneg_enable){
-		/*changeing the autoneg*/
-		autoneg.enable = phy_cnt.autoneg_enable;
-		if(vtss_pcs_autoneg_control_set(port,&autoneg) == VTSS_OK){
-			priv->autoneg = phy_cnt.autoneg_enable;
-		}
-		else{
-		  spin_unlock_irqrestore(&base_change,flags);
-			return 1;
-		}
-	}
-	phy_cnt.fdx = ecmd->duplex ;
-	switch(ecmd->speed){
-	case SPEED_1000:
-		speed = (int) VTSS_SPEED_1G ;
-		driver_speed = SPEED_1000M;
-		break;
-	case SPEED_100:
-		speed = (int) VTSS_SPEED_100M ;
-		driver_speed = SPEED_100M;
-		break;
-	case SPEED_10 :
-		speed = (int) VTSS_SPEED_10M ;
-		driver_speed = SPEED_10M;
-		break;
-	default:
-	  spin_unlock_irqrestore(&base_change,flags);
-		return -EINVAL;
-	}
-
-	phy_cnt.speed =  speed;
-	if(vtss_port_set_mode( port, speed, ecmd->duplex) == VTSS_OK){
-	}
-	else{
-		ret = 1;
-	}
-	if(ret){
-		/*mac speed is not success so, no need to change phy speed*/
-		return ret;
-	}
-	if(vtss_phy_control_set(port, &phy_cnt) == VTSS_OK){
-	}
-	else{
-		ret = 1;
-	}
-
-	if(ret==0){
-		/*update the speed, and duplexity*/
-		priv->speed = driver_speed;
-		priv->duplex = ecmd->duplex;
-	}
-
-  spin_unlock_irqrestore(&base_change,flags);
-	return ret;
-}
-
-
-static void
-spi4_get_drvinfo(	struct net_device *dev,
-		struct ethtool_drvinfo *drvinfo)
-{
-
-	printk("[%s]: \n",__FUNCTION__);
-	strcpy(drvinfo->driver,DRV_NAME);
-	strcpy(drvinfo->version, DRV_VERSION);
-	strcpy(drvinfo->fw_version, "N/A");
-	return;
-}
-
-struct ethtool_ops spi4_ethtool_ops = {
-	.get_settings           = spi4_get_settings,
-	.set_settings           = spi4_set_settings,
-	.get_drvinfo            = spi4_get_drvinfo
-};
-
-void set_ethtool_ops(struct net_device *netdev)
-{
-	SET_ETHTOOL_OPS(netdev, &spi4_ethtool_ops);
-}
-
-
-
-
-module_init(nlm_vits_init);
-module_exit(nlm_vits_exit);
-
diff --git a/drivers/net/nlm_spi4/nlm_vits_eth.h b/drivers/net/nlm_spi4/nlm_vits_eth.h
deleted file mode 100644
index e3e55e8..0000000
--- a/drivers/net/nlm_spi4/nlm_vits_eth.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_VITS_ETH_H
-#define _ASM_NLM_VITS_ETH_H
-
-#include "nlm_spi4.h"
-
-#define INVALID_SLOT 	100
-#define INVALID_PORT	100
-
-#define NLM_SPI4_MAX_PORTS 20 
-#define NLM_SPI4_MAX_SLOTS 2
-
-#define PORT_0 0
-#define PORT_1 1
-#define PORT_2 2
-#define PORT_3 3 
-#define PORT_4 4
-#define PORT_5 5
-#define PORT_6 6
-#define PORT_7 7
-#define PORT_8 8
-#define PORT_9 9
-#define PORT_10 10
-#define PORT_11 11
-#define PORT_12 12
-#define PORT_13 13
-#define PORT_14 14
-#define PORT_15 15 
-#define PORT_16 16
-#define PORT_17 17
-#define PORT_18 18
-#define PORT_19 19
-
-struct spi4_port{
-	int	slot; // value should be either SPI4_0 or SPI4_1
-	int port;
-	unsigned long	io_base;
-
-};
-
-int spi4_slot[] = {SPI4_0,SPI4_1};
-static struct spi4_port active_port[] = {
-	{
-		.slot=SPI4_0,
-		.port=PORT_0
-	},
-	{
-		.slot=SPI4_0,
-		.port=PORT_1
-	},
-	{
-		.slot=SPI4_0,
-		.port=PORT_2
-	},
-	{
-		.slot=SPI4_0,
-		.port=PORT_3
-	},
-	{
-		.slot=SPI4_0,
-		.port=PORT_4
-	},
-	{
-		.slot=SPI4_0,
-		.port=PORT_5
-	},
-	{
-		.slot=SPI4_0,
-		.port=PORT_6
-	},
-	{
-		.slot=SPI4_0,
-		.port=PORT_7
-	},
-	{
-		.slot=SPI4_0,
-		.port=PORT_8
-	},
-	{
-		.slot=SPI4_0,
-		.port=PORT_9
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_10
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_11
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_12
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_13
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_14
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_15
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_16
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_17
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_18
-	},
-	{
-		.slot=SPI4_1,
-		.port=PORT_19
-	},
-
-};
-#endif
diff --git a/drivers/net/nlm_spi4/nlm_vits_wrapper.c b/drivers/net/nlm_spi4/nlm_vits_wrapper.c
deleted file mode 100644
index 3c7cd17..0000000
--- a/drivers/net/nlm_spi4/nlm_vits_wrapper.c
+++ /dev/null
@@ -1,98 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <asm/netlogic/iomap.h>
-#include "nlm_vits_wrapper.h"
-#include <asm/netlogic/debug.h>
-
-
-// global reference   
-volatile unsigned int *megis = (unsigned int*)(long)VITESS_BASE_ADDR_1;
-
-
-// function to setup CS_2 area correctly
-void megis_nlm_common_init(int vitess_device) 
-{
-
-	if (vitess_device == 1)
-		megis = (unsigned int*)(long)VITESS_BASE_ADDR_1;
-
-	if (vitess_device == 2)
-		megis = (unsigned int*)(long)VITESS_BASE_ADDR_2;
-	return;
-}  
-
-
-
-
-
-// function to convert from littleE to bigE
-unsigned int swizzle(unsigned int _in) 
-{
-	unsigned int i;
-	i = (((_in & 0xff00ff00) >> 8) | ((_in & 0x00ff00ff) << 8));
-	return i;
-}
-
-
-
-
-// lower level register write routines
-void megis_write(unsigned int _block, unsigned int _sub, 
-		unsigned int _addr, unsigned int value) 
-{
-	//  printf ("MEIGS: Write block %x sub %x Addr %x Value %x\n", _block, _sub, 
-	//  	_addr, value);
-	int lvalue = swizzle(value);
-	megis[(  (_block << 12) + (_sub << 8) + (_addr))] = lvalue; 
-	return;
-}
-
-
-
-
-// lower level register read routine
-unsigned int megis_read(unsigned int _block, unsigned int _sub, 
-			unsigned int _addr) 
-{
-	unsigned int i;
-	i =  megis[((_block << 12) + (_sub << 8) + (_addr))];
-	i = swizzle(i);
-	return i;
-}
-
-
-
-// lower level posted register read routine
-unsigned int megis_pread(unsigned int _block, unsigned int _sub, 
-unsigned int _addr) 
-{
-	unsigned int i;
-	i =  megis[((_block << 12) + (_sub << 8) + (_addr))];
-	i =  megis[((_block << 12) + (_sub << 8) + (0xfe))];
-	i = swizzle(i);
-	return i;
-}
-
diff --git a/drivers/net/nlm_spi4/nlm_vits_wrapper.h b/drivers/net/nlm_spi4/nlm_vits_wrapper.h
deleted file mode 100644
index 5cab68e..0000000
--- a/drivers/net/nlm_spi4/nlm_vits_wrapper.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_VITS_WRAPPER_H
-#define _ASM_NLM_VITS_WRAPPER_H 1
-#define VITESS_BASE_ADDR_1 0xffffffffBD800000ULL
-#define VITESS_BASE_ADDR_2 0xffffffffBD820000ULL
-
-
-
-// lower level access functions
-void 		megis_nlm_common_init(int vitess_device);
-unsigned int 	swizzle     (unsigned int _in);
-void 		megis_write (unsigned int _block, unsigned int _sub, 
-		unsigned int _addr, unsigned int value);
-unsigned int 	megis_read  (unsigned int _block, unsigned int _sub, unsigned int _addr);
-unsigned int 	megis_pread (unsigned int _block, unsigned int _sub, unsigned int _addr);
-
-#endif
diff --git a/drivers/net/nlm_spi4/os_layer.c b/drivers/net/nlm_spi4/os_layer.c
deleted file mode 100644
index da8700e..0000000
--- a/drivers/net/nlm_spi4/os_layer.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/gfp.h>
-
-#include <linux/skbuff.h>
-#include <linux/netdevice.h>
-
-#include "os_layer.h"
-
-#define NLM_RX_BUF_SIZE (MAX_FRAME_SIZE+SPI4_BYTE_OFFSET+MAC_PREPAD+ \
-		                MAC_SKB_BACK_PTR_SIZE+SMP_CACHE_BYTES)
-
-
-void os_free_buffer(char *addr){
-	kfree(addr);
-	return;
-}
-
-char*	os_malloc(unsigned long size){
-	return	kmalloc(size, GFP_KERNEL);
-
-}
-
-
-char*	os_malloc_buffer(){
-
-	return  kmalloc(NLM_RX_BUF_SIZE, GFP_KERNEL);
-
-}
-
-
-
-void* os_cacheline_aligned_kmalloc(int size){
-
-	void *buf = kmalloc(size+SMP_CACHE_BYTES, GFP_KERNEL);
-	if (buf){
-		buf = (void *)(CACHELINE_ALIGNED_ADDR(
-			(unsigned long)buf+SMP_CACHE_BYTES));
-	}
-	return buf;
-}
-
-
-struct sk_buff *os_alloc_skb(void){
-
-	int offset=0;
-	struct sk_buff *skb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_KERNEL);
-
-	if (!skb) {
-		return NULL;
-	}
-
-	/* align the data to the next cache line */
-	offset = ((unsigned long)skb->data + SMP_CACHE_BYTES) &
-		~(SMP_CACHE_BYTES - 1);
-	skb_reserve(skb, (offset - (unsigned long)skb->data));
-
-	return skb;
-}
-
-
-void os_free(struct sk_buff *skb){
-
-	//	dev_kfree_skb(skb);
-	dev_kfree_skb_irq(skb);
-
-	return;
-}
diff --git a/drivers/net/nlm_spi4/os_layer.h b/drivers/net/nlm_spi4/os_layer.h
deleted file mode 100644
index 1590054..0000000
--- a/drivers/net/nlm_spi4/os_layer.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_OS_LAYER_H
-#define _ASM_NLM_OS_LAYER_H
-
-#include "nlm_spi4_config.h"
-
-extern char* os_malloc(unsigned long size);
-
-extern char* os_malloc_buffer(void);
-
-extern void* os_cacheline_aligned_kmalloc(int size);
-
-extern struct sk_buff *os_alloc_skb(void);
-
-extern void os_free(struct sk_buff *skb);
-
-extern void os_free_buffer(char *addr);
-
-#define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
-
-
-#endif
diff --git a/drivers/net/nlm_spi4/vitesse_common.h b/drivers/net/nlm_spi4/vitesse_common.h
deleted file mode 100644
index d46e0de..0000000
--- a/drivers/net/nlm_spi4/vitesse_common.h
+++ /dev/null
@@ -1,279 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*
-
- vitesse_common.h  -- Vitesse common definitions
-
- This file is used by the Vitesse Switch/Mac API software.
- Modify it to fit your configuration.
-
- Copyright (c) 2003 Vitesse Semiconductor Corporation. All Rights Reserved.
- Unpublished rights reserved under the copyright laws of the United States of 
- America, other countries and international treaties. The software is provided
- without fee. Permission to use, copy, store, modify, disclose, transmit or 
- distribute the software is granted, provided that this copyright notice must 
- appear in any copy, modification, disclosure, transmission or distribution of 
- the software. Vitesse Semiconductor Corporation retains all ownership, 
- copyright, trade secret and proprietary rights in the software. THIS SOFTWARE
- HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY INCLUDING, 
- WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
- PARTICULAR USE AND NON-INFRINGEMENT.
- 
-*/
-#include <linux/types.h>
-
-#define VSC7323
-
-#ifndef _VITESSE_COMMON_H
-#define _VITESSE_COMMON_H 1
-
-/* ================================================================= *
- *  Basic types:
- *    uint, ulong, ushort, uchar - unsigned standard types.
- *    longlong, ulonglong - 64 bit integers.
- *    BOOL - The boolean type. false: 0, true: anything but 0.
- * ================================================================= */
-
-//typedef unsigned long       ulong;
-typedef unsigned char       uchar;
-
-/* - longlong, ulonglong ------------------------------------------- */
-
-/* longlong and ulonglong: 64 bit integers */
-#ifdef __GNUC__
-typedef long long           longlong;
-typedef unsigned long long  ulonglong;
-#endif /* __GNUC__ */
-#ifdef _MSC_VER
-typedef __int64             longlong;
-typedef unsigned __int64    ulonglong;
-#endif /* _MSC_VER */
-
-/* - BOOL ---------------------------------------------------------- */
-
-/* BOOL: The boolean type. false: 0, true: anything but 0. */
-/* You may redefine it to any other type, e.g. char. */
-typedef int                 BOOL;
-
-
-/* ================================================================= *
- *  Custom types
- * ================================================================= */
-
-/* Big counter type, may be 32 or 64 bits depending on the OS */
-/* You may redefine it to ulong or ulonglong */
-typedef ulonglong vtss_counter_t;
-
-
-/* ================================================================= *
- *  Macros:
- *    VTSS_ASSERT(expr) - Call assert(expr).
- *    VTSS_NSLEEP(nsec) - Sleep at least nsec nanoseconds.
- *    VTSS_MSLEEP(msec) - Sleep at least msec milliseconds.
- *  Notes:
- *    VTSS_NSLEEP uses busy waiting, so it should only be used for
- *    very short intervals.
- *    VTSS_MSLEEP should not use busy waiting, but may do so.
- * ================================================================= */
-
-
-/* - VTSS_ASSERT(expr) -------------------------------------------------- */
-
-/* VTSS_ASSERT(expr): Call assert(). */
-#if !defined(VTSS_ASSERT)
-/* You may define your own VTSS_ASSERT here. */
-#endif
-
-#ifndef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 0
-#endif
-
-#if !defined(VTSS_ASSERT) && (_POSIX_C_SOURCE > 0)
-#include <assert.h>
-#define VTSS_ASSERT(expr) { assert(expr); }
-#endif
-
-/* - VTSS_NSLEEP(nsec) -------------------------------------------------- */
-#define VTSS_NSLEEP(nsec)
-
-/* VTSS_NSLEEP(nsec): Sleep nsec nanoseconds. Use busy waiting. */
-#if !defined(VTSS_NSLEEP)
-/* You may define your own VTSS_NSLEEP here. */
-#endif
-
-#if !defined(VTSS_NSLEEP) && defined(_BSD_SOURCE)
-/* The function "gettimeofday" is available, so use it. */
-#include <sys/time.h>
-#define VTSS_NSLEEP(nsec) { \
-    struct timeval tve, tv; \
-    gettimeofday(&tve,NULL); \
-    tve.tv_usec+=(nsec+999)/1000;\
-    if (tve.tv_usec>=1000000) { tve.tv_sec+=tve.tv_usec/1000000; tve.tv_usec%=1000000; } \
-    do { gettimeofday(&tv,NULL); } \
-    while ( timercmp(&tv,&tve,<) ); \
-}
-#endif /* _BSD_SOURCE */
-#if !defined(VTSS_NSLEEP) && ( (_POSIX_C_SOURCE - 0) >= 199309L )
-/* The function "nanosleep" is available, so use it. */
-#include <time.h>
-#include <errno.h>
-#define VTSS_NSLEEP(nsec) {struct timespec ts = { 0, nsec }; while (nanosleep(&ts,&ts)==-1 && errno==EINTR) ;}
-#endif /* (_POSIX_C_SOURCE - 0) >= 199309L */
-#if !defined(VTSS_NSLEEP) && defined(_WIN32)
-#define VTSS_NSLEEP(nsec) {VOID Sleep(DWORD); Sleep((nsec+999999)/1000000);}
-#endif /* _WIN32 */
-/* VTSS_NSLEEP is required by the API. */
-#if defined(__VTSS_LIBRARY__) && !defined(VTSS_NSLEEP)
-#error Macro function VTSS_NSLEEP must be defined in vitesse_common.h.
-#endif /* __VTSS_LIBRARY__ && !VTSS_NSLEEP */
-
-/* - VTSS_MSLEEP(msec) -------------------------------------------------- */
-#define VTSS_MSLEEP(msec)
-
-/* VTSS_MSLEEP(msec): Sleep msec milliseconds. Avoid busy waiting. */
-#if !defined(VTSS_MSLEEP)
-/* You may define your own VTSS_MSLEEP here. */
-#endif
-
-#if !defined(VTSS_MSLEEP) && ( (_POSIX_C_SOURCE - 0) >= 199309L )
-/* The function "nanosleep" is available, so use it. */
-#include <time.h>
-#include <errno.h>
-#define VTSS_MSLEEP(msec) { \
-    struct timespec ts; \
-    ts.tv_sec = msec/1000; \
-    ts.tv_nsec = (msec%1000)*1000000; \
-    while (nanosleep(&ts,&ts)==-1 && errno==EINTR) ; \
-}
-#endif /* (_POSIX_C_SOURCE - 0) >= 199309L */
-#if !defined(VTSS_MSLEEP) && defined(_WIN32)
-#define VTSS_MSLEEP(msec) {VOID Sleep(DWORD); Sleep(msec);}
-#endif /* _WIN32 */
-/* VTSS_MSLEEP is required by the API. */
-#if defined(__VTSS_LIBRARY__) && !defined(VTSS_MSLEEP)
-#error Macro function VTSS_MSLEEP must be defined in vitesse_common.h.
-#endif /* __VTSS_LIBRARY__ && !VTSS_MSLEEP */
-
-
-/* ================================================================= *
- *  Debugging Macros:
- *    VTSS_E(args) - Error.
- *    VTSS_D(args) - Debug.
- *    VTSS_N(args) - Noise.
- *
- *    Usage Example: VTSS_E(("Port %d",port_no));
- * ================================================================= */
-
-#if !defined(VTSS_E) && !defined(VTSS_D) && !defined(VTSS_N)
-/* You may define your own VTSS_E, VTSS_D and VTSS_N here. */
-#endif
-
-#if !defined(VTSS_E) && !defined(VTSS_D) && !defined(VTSS_N) && defined(SWITCH_APP_TRACE)
-/* Debugging for an VTSS internal application. */
-#include <stdio.h>
-#include <stdarg.h>
-
-extern const char *vtss_trace_func;
-extern int vtss_trace_line;
-extern int vtss_trace_layer;
-extern int vtss_trace_level;
-void vtss_api_trace(int level, BOOL debug, const char *func, int line, char *msg);
-void vtss_trace(const char *fmt, ...);
-
-#define E(args); {vtss_trace_level=1, vtss_trace_layer=VTSS_TRACE_LAYER, vtss_trace_func=__FUNCTION__; vtss_trace_line=__LINE__; vtss_trace args;}
-#define D(args); {vtss_trace_level=2, vtss_trace_layer=VTSS_TRACE_LAYER, vtss_trace_func=__FUNCTION__; vtss_trace_line=__LINE__; vtss_trace args;}
-#define N(args); {vtss_trace_level=3, vtss_trace_layer=VTSS_TRACE_LAYER, vtss_trace_func=__FUNCTION__; vtss_trace_line=__LINE__; vtss_trace args;}
-#endif
-
-#if !defined(VTSS_E) && !defined(VTSS_D) && !defined(VTSS_N)
-#if (_POSIX_C_SOURCE > 0)
-/* Fallback to debugging using printf. */
-#include <stdio.h>
-#define VTSS_E(args) { printf("E:%s#%d: ",__FUNCTION__,__LINE__); printf args; printf("\n"); }
-#define VTSS_D(args) { printf("D:%s#%d: ",__FUNCTION__,__LINE__); printf args; printf("\n"); }
-#define VTSS_N(args) { printf("N:%s#%d: ",__FUNCTION__,__LINE__); printf args; printf("\n"); }
-#else
-/* Fallback to no debugging. */
-#define VTSS_E(args)
-#define VTSS_D(args)
-#define VTSS_N(args)
-#endif
-#endif
-
-
-/* ================================================================= *
- *  No changes should be needed below this line
- * ================================================================= */
-
-#if !defined(MEIGS2) && !defined(MEIGS2E) && !defined(CAMPBELL) && \
-    !defined(VSC7321) && !defined(VSC7323) && !defined(VSC7331) 
-#warning Device MEIGS2, MEIGS2E, CAMPBELL, VSC7321, VSC7323 or VSC7331 should be defined.
-#endif
-
-/* ================================================================= *
- *  Various definitions and macros
- * ================================================================= */
-
-/* MAKEBOOL01(value): Convert BOOL value to 0 (false) or 1 (true). */
-/* Use this to ensure BOOL values returned are always 1 or 0. */
-#ifndef MAKEBOOL01
-#define MAKEBOOL01(value) ((value)?1:0)
-#endif
-#ifndef TRUE
-#define TRUE MAKEBOOL01(1)
-#endif
-#ifndef FALSE
-#define FALSE MAKEBOOL01(0)
-#endif
-
-/* - Basic defines/macros: NULL, offsetof() ------------------------ */
-
-#ifndef NULL
-#ifdef __cplusplus
-#define NULL 0
-#else
-#define NULL ((void *)0)
-#endif
-#endif
-
-#ifndef offsetof
-#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
-#endif
-
-/* - Compiler Hints ------------------------------------------------ */
-
-#ifdef __GNUC__
-/* "__attribute__ ((const))" informs the GNU C compiler that a
- * function does not change any states anywhere
- */
-#define __VTSS_ATTRIB_CONST_FUNCTION__ __attribute__ ((const))
-#else
-#define __VTSS_ATTRIB_CONST_FUNCTION__ /* no "const" compiler hint */
-#endif
-
-
-/* ================================================================= *
- *  Private data and functions (used internally by VTSS library)
- * ================================================================= */
-#ifdef __VTSS_LIBRARY__
-
-/* - Compiler Hints ------------------------------------------------ */
-
-#ifdef __GNUC__
-/* "__attribute__ ((unused))" informs the GNU C compiler that a
- * variable is not used, so we don't get a warning about it
- */
-#define __VTSS_ATTRIB_UNUSED_VARIABLE__ __attribute__ ((unused))
-#else
-#define __VTSS_ATTRIB_UNUSED_VARIABLE__ /* no "unused" compiler hint */
-#endif
-
-#endif /* __VTSS_LIBRARY__ */
-
-#endif /* _VITESSE_COMMON_H_ */
diff --git a/drivers/net/nlm_spi4/vitesse_highlevel.c b/drivers/net/nlm_spi4/vitesse_highlevel.c
deleted file mode 100644
index cc76714..0000000
--- a/drivers/net/nlm_spi4/vitesse_highlevel.c
+++ /dev/null
@@ -1,5363 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/************************************************************-*- mode: C -*-*/
-/*                                                                          */
-/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
-/*                           All Rights Reserved.                           */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*                            Copyright Notice:                             */
-/*                                                                          */
-/*  Unpublished rights reserved under the copyright laws of the United      */
-/*  States of America, other countries and international treaties.          */
-/*                                                                          */
-/*      The software is provided without fee.                               */
-/*                                                                          */
-/*  Permission to use,  copy, store, modify, disclose, transmit or          */
-/*  distribute the software is granted, provided that this copyright notice */
-/*  must appear in any copy, modification, disclosure, transmission or      */
-/*  distribution of the software.                                           */
-/*                                                                          */
-/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
-/*  trade secret and proprietary rights in the software.                    */
-/*                                                                          */
-/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
-/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
-/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
-/*                                                                          */
-/*    $Id: vitesse_highlevel.c,v 1.1.2.6 2008-05-22 02:59:56 kmurthy Exp $         */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*  File content:                                                           */
-/*                                                                          */
-/*  vitesse_highlevel.c -- a set of functions for configuration of various  */
-/*                  system features in a MeigsII/MeigsIIe/Campbell chip     */
-/*                                                                          */
-/****************************************************************************/
-#define __MEIGSII_LIBRARY__
-
-
-
-#include "vitesse_highlevel.h"
-#include "meigsii_reg.h"
-#include "vitesse_io.h"
-#include <asm/netlogic/debug.h>
-#include <linux/kernel.h>
-
-#define     SET_BIT( A,SHIFT)    A |=  ((ulong)1<<SHIFT)
-#define     CLR_BIT( A,SHIFT)    A &= ~((ulong)1<<SHIFT)
-
-#define     SET_BITS_MASKED( result, value, mask)  \
-	result = (result & ~(mask))|(value & mask)
-
-
-/****************************************************************************/
-/*                                                                          */
-/*   Type definitions                                                       */
-/*                                                                          */
-/****************************************************************************/
-typedef struct _vtss_device_setup_t {
-
-	vtss_mac_major_mode_t    mmode;
-	ulong                    chip_id;
-
-} vtss_device_setup_t;
-
-
-/************     Use of the normalised and preamble headers   *************/
-/*
-   The related NLE bit selects the way data is transmitted internally in the 
-   device and is always used when the normalized header is used.
- */
-typedef struct _m2_header_t {
-
-	BOOL use_norm_hdr;
-	BOOL use_prm_hdr;
-	/*
-	   BOOL mpls_normalize;
-	   BOOL vlan_normalize;
-	 */
-} m2_header_t;
-
-
-/****************************************************************************/
-/*                                                                          */
-/*   Local function prototypes                                              */
-/*                                                                          */
-/****************************************************************************/
-/*static vtss_rc vtss_aggr_mode_set( vtss_aggr_mode_t *p_aggrmode);*/
-
-/* control of the use of header in ingress direction */
-static vtss_rc vtss_hdr_insert( BOOL enable, m2_header_t hdr);
-#if 0
-/* control of the use of header in egress direction */
-static vtss_rc vtss_hdr_expect( BOOL enable, m2_header_t hdr);
-#endif
-
-
-/* Enabling/disabling use of the header in different blocks */
-static void vtss_fifo_use_hdr( int fifo, BOOL enable, m2_header_t hdr);
-
-static void vtss_aggr_use_header( BOOL enable, m2_header_t hdr);
-
-
-static void vtss_port10G_header_insert( BOOL enable, m2_header_t hdr);
-
-static void vtss_port1G_header_insert( int ppn, BOOL enable, 
-		const m2_header_t hdr);
-
-/* vtss_rc vtss_device_major_mode_setup( vtss_mac_major_mode_t mm); */
-
-
-/****************************************************************************/
-/*                                                                          */
-/*   Global data                                                            */
-/*                                                                          */
-/****************************************************************************/
-
-static vtss_mapped_port_t vtss_logical_ports[VTSS_PORT_ARRAY_SIZE] = {
-	{ -1, -1, -1},
-	{ -1, -1, -1},
-};
-
-static vtss_device_setup_t vtss_device_setup = {
-	VTSS_MAC_MAJOR_MODE_UNDEFINED,
-	0,  /* chip id */
-};
-
-
-/* Current state of 1G ports */
-static vtss_port_setup_t vtss_1G_ports_setup[VTSS_PORT_ARRAY_SIZE];/* = {} */
-
-
-/* Pointer to the global device setup structure */
-static vtss_device_setup_t *pdevice = &vtss_device_setup;
-
-
-/*******************************************************************************
-
-  Function vtss_port_map_set()
-  =================================================================================
-
-Description:
-The function initializes internally kept port mapping structure based on 
-the information received from the user 
-
-
-Syntax
-vtss_rc  vtss_port_map_set( const vtss_mapped_port_t 
-mapped_ports[VTSS_PORT_ARRAY_SIZE]);
-
-Arguments:
-mapped_ports    an array mapping logical port numbers to physical 
-(on-chip) port numbers, MIIM controller channel and
-PHY addresses.
-
-Return code:
-VTSS_OK   if operation completed successfully
-
- *******************************************************************************/
-vtss_rc vtss_port_map_set( const vtss_mapped_port_t 
-		mapped_ports[VTSS_PORT_ARRAY_SIZE])
-{
-	int i;
-
-	for (i=0;i<VTSS_PORT_ARRAY_SIZE; i++) {
-		vtss_logical_ports[i] = mapped_ports[i];
-	}
-
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-
-  Function vtss_port_mapped()
-  =================================================================================
-
-Description:
-Checks whether the logical port is mapped to any physical port or not.
-
-Syntax
-BOOL vtss_port_mapped( const vtss_port_no_t port_no )
-
-Arguments:
-port_no     logical port number
-
-
-Return code:
-VTSS_OK   if operation completed successfully
-
- *******************************************************************************/
-BOOL vtss_port_mapped( const vtss_port_no_t port_no )
-{
-
-	return ( -1 != vtss_logical_ports[port_no].chip_port);
-}
-
-
-/*******************************************************************************
-
-  Function vtss_chip_reset()
-================================================================================
-
-Description:
-Performs a software reset of the chip
-
-
-Syntax
-void vtss_chip_reset(void);
-
-Arguments:
-None
-
-Return code:
-None
-
-*******************************************************************************/
-void vtss_chip_reset(void)
-{
-
-	/* Reset the chip */
-	vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
-			M2_SW_RESET, M2_SW_GLOBAL_RESET);
-	VTSS_NSLEEP(VTSS_T_RESET);
-
-}
-
-
-/*******************************************************************************
-
-  Function vtss_get_chip_id()
-================================================================================
-
-Description:
-Returns the content of the chip identification register
-
-NOTE: -----------------------------    
-|  device         chip id   |
------------------------------
-|  VSC7321       0x0F407321 |
-|  VSC7323       0x073230E9 |
-|  VSC7331       0x073310E9 |
------------------------------
-
-Syntax
-ulong vtss_chip_id_get(void);
-
-
-Arguments:
-None
-
-
-Return code:
-The content of the chip identification register.
-
- *******************************************************************************/
-ulong vtss_chip_id_get(void)
-{
-	vtss_device_setup_t *pvds = pdevice;
-	pvds->chip_id = vtss_io_read( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_CHIPID);
-	return pvds->chip_id;
-}
-
-
-/*******************************************************************************
-
-  Function vtss_major_mode_set( )
-  ================================================================================
-
-Description:
-Prepares the system to run in one of the major modes.
-This function must be called only once after reset. If the function is 
-called when the system is up and running it will return an error.
-It is not allowed to call this function with VTSS_MAC_MAJOR_MODE_UNDEFINED
-as an argument.
-
-NOTE:
-
-
-Syntax
-vtss_rc vtss_major_mode_set( vtss_mac_major_mode_t mm);
-
-Arguments:
-mm     select the major mode for the session
-
-
-Return code:
-VTSS_OK                  successful completion
-VTSS_WRONG_PARAMETER     if called after the major mode has been set
-
- *******************************************************************************/
-vtss_rc vtss_major_mode_set( vtss_mac_major_mode_t mm)
-{
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-
-	if (mm == VTSS_MAC_MAJOR_MODE_UNDEFINED) {
-		return VTSS_WRONG_PARAMETER;
-	}
-
-	if ( VTSS_MAC_MAJOR_MODE_UNDEFINED != pvds->mmode) { 
-		return VTSS_WRONG_PARAMETER;
-	} else {
-		pvds->mmode = mm;
-	}
-
-	return VTSS_OK;
-}
-
-
-/******************************************************************************
- *
- * Description: Performs several low-level initialization operations on the chip.
- *              The function must be called after start-up or chip reset.
- *
- * NOTE:        This function does not perform COMPLETE initialization of the chip.
- *
- * \param:      psystem   pointer to a structure with configuration data
- *
- * \return:     VTSS_OK   if operation completed successfully or
- *              VTSS_WRONG_PARAMETER
- *
- **************************************************************************kbp*/
-vtss_rc vtss_system_setup( vtss_system_setup_t *ps)
-{
-	ulong reg  = 0;
-
-	/* Setup Serial and Parallel CPU interfaces */
-	/* Assuming order of bits in a byte big-endian, 
-		however it can be changed */
-	if ( ps->big_endian == FALSE) {
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
-			M2_SI_TRANSFER_SEL, M2_LTL_END_BYTE_BIG_END_BIT);
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
-			M2_CPU_TRANSFER_SEL, M2_LTL_END_BYTE_BIG_END_BIT);
-	} else {
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
-			M2_SI_TRANSFER_SEL, M2_BIG_END_BYTE_BIG_END_BIT);
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
-			M2_CPU_TRANSFER_SEL, M2_BIG_END_BYTE_BIG_END_BIT);
-	}
-
-
-#if !defined MEIGS2 && !defined VSC7321
-	/* Set-up wait states on serial read when frequency > 0.5MHz 
-	   to match the chip response time on reads of 1 us. */
-	if ( ps->si_dummy_bytes < 8 ) {
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
-				M2E_SI_INSERT_BYTES, ps->si_dummy_bytes);
-	} else {
-		return VTSS_WRONG_PARAMETER;
-	}
-#endif
-
-
-	reg = 0;
-	/* Take SerDes PLL out of reset when not in Single Channel mode */
-	if ( ps->rx_chain_mode_10G == FALSE) { SET_BIT( reg, 7); }
-
-	/* Setup SerDes reference clock sources */
-	if ( ps->serdes_ref_clk_external == FALSE) {
-		/* NB: serdes_ref_clk_external must be 
-			TRUE when using VSC7323 or VSC7331 */
-#if !defined MEIGS2 && !defined VSC7321
-		return VTSS_WRONG_PARAMETER;
-#endif
-	} else {
-		SET_BIT( reg, 1);
-	}
-	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
-			M2_PLL_CLK_SPEED, reg, 0x82);
-
-
-	/* Setup System reference clock sources */
-	if ( ps->system_ref_clk_extern == FALSE) {
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_SYS_CLK_SELECT, 0);
-	} else {
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_SYS_CLK_SELECT, 1);
-	}
-
-
-	reg = 0;
-	/* Setup interface mode */
-	if( ps->single_chip_mode != FALSE) { SET_BIT( reg, 3); SET_BIT( reg, 2); }
-	if( ps->rx_chain_mode_10G != FALSE) { SET_BIT( reg, 1); SET_BIT( reg, 0); }
-	vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_IFACE_MODE, reg);
-
-
-	return VTSS_OK;
-}
-
-
-/******************************************************************************
- *
- * Description: This is a supplementary function.
- *              It configures a structure referenced by the pointer to the
- *              default values for the chosen major mode.
- *
- * \param:      ps        pointer to a structure, which will be filled out
- *              mjm       mode the device will run
- *
- * \return:     VTSS_OK   if operation completed successfully or
- *
- **************************************************************************kbp*/
-vtss_rc vtss_system_setup_get_default_values( vtss_system_setup_t *ps,
-		vtss_mac_major_mode_t mjm)
-{
-
-	/* TRUE (default):  CPU interface runs as big-endian */
-	ps->big_endian = TRUE;
-
-
-	/* Number of dummy bytes that will be inserted in the 
-	   reply before valid data when serial interface is used
-	   at high frequency. Set to 0 if not used */
-	ps->si_dummy_bytes = 0;  
-
-
-	/* Select the source of the serdes reference clock */
-	/* TRUE (default):  external source of the reference clock */
-	/* FALSE         :  internal source of the reference clock */
-	/* NOTE!!   MUST be TRUE when using VSC7323 or VSC7331 */
-	ps->serdes_ref_clk_external = TRUE;
-
-
-	/* Select the source of the system clock */
-	/* FALSE (default): system clock uses internal source */
-	/* TRUE             system clock uses GPIO15 as system clock input */
-	ps->system_ref_clk_extern = FALSE; 
-
-
-	/* Single Chip Aggregation or trunking mode */
-	if ( mjm == VTSS_MAC_MAJOR_MODE_10G_1G_AGGR || 
-			mjm == VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK) {
-		ps->single_chip_mode = TRUE; 
-	} else {
-		ps->single_chip_mode = FALSE;
-	}
-
-
-	/* Single Channel mode */
-	if ( mjm == VTSS_MAC_MAJOR_MODE_SPI4_10G) {
-		ps->rx_chain_mode_10G = TRUE;  /* SPI4.2<->10G mode */
-	} else {
-		ps->rx_chain_mode_10G = FALSE; /* all other modes */
-	}
-
-	return VTSS_OK;
-}
-
-
-/****************************************************************************/
-/*                                                                          */
-/*   1G(triple speed) port setup                                            */
-/*                                                                          */
-/****************************************************************************/
-
-
-
-/*******************************************************************************
-
-  Function 
-  ================================================================================
-
-Description:
-Configures 10M/100M/1G port according to the structure provided.
-
-
-Syntax
-vtss_rc vtss_port_setup( vtss_port_no_t portnum, vtss_port_setup_t* ps);
-
-Arguments:
-portnum      logical port to be initialized
-ps           pointer to the setup structure
-
-Return code:
-VTSS_OK   if operation completed successfully
-VTSS_PORT_NOT_MAPPED
-VTSS_MAJOR_MODE_NOT_SET
-VTSS_WRONG_MAJOR_MODE
-VTSS_WRONG_PARAMETER
-
- *******************************************************************************/
-vtss_rc vtss_port_setup( vtss_port_no_t portnum, vtss_port_setup_t* ps)
-{
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-
-	ulong mode_cfg_reg = 0;
-	ulong dev_setup_reg_value = 0x80; /* Bit 7 shall be set to 1 */
-	ulong pcs_enable = 0;
-	ulong pause_reg_value = 0;
-	ulong reg = 0;
-
-	/* Some hardcoded values */
-	BOOL use_back_seed = FALSE;
-	/*  ulong backseed = 0; */
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-	//  VTSS_N(("Port setup. Logic port #%d, phys prt #%d", portnum, ppn));
-	//printk("Port setup. Logic port #%d, phys prt #%d\n", portnum, ppn);
-
-	/* Check the physical port number */
-	if (ppn < 0) { 
-		printk("[%s]port=%d not mapped\n",__FUNCTION__,portnum);
-		return VTSS_PORT_NOT_MAPPED; 
-	}
-
-
-	/* Check major mode */
-	switch ( pvds->mmode) {
-	/* valid major modes */
-	case VTSS_MAC_MAJOR_MODE_SPI4_1G:      /* SPI4 <-> 10x1G */
-	case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:  /* Single Chip aggr */
-	case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* Single Chip trunking */
-		break;
-
-	/* Error - major mode undefined */
-	case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-		return VTSS_MAJOR_MODE_NOT_SET;
-
-	/* Error - wrong major mode */
-	case VTSS_MAC_MAJOR_MODE_SPI4_10G:     /* SPI4 <-> 1x10G */
-	case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:   /* */
-	case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-	default:
-		printk("[%s]wrong major mode=%d\n",__FUNCTION__,pvds->mmode);
-		return VTSS_WRONG_MAJOR_MODE;
-	}
-
-#if defined MEIGS2 || defined VSC7321
-	/* VSC7321 (Meigs-II) requires BOTH fields being either set or cleared */
-	if (ps->flowcontrol.obey != ps->flowcontrol.generate) { return VTSS_WRONG_PARAMETER; }
-#endif
-
-	/* -------------------- Device Setup Register ------------------------ */
-
-	/* While changing speed, the port must be in reset state */
-	SET_BIT( dev_setup_reg_value, 0);
-
-	/* Select speed and interface for the device */
-	switch (ps->interface_mode.speed) {
-	case VTSS_SPEED_10M:
-		SET_BITS_MASKED( dev_setup_reg_value, M2_1G_PORT_CLOCK_MODE_10M<<1, 
-				M2_1G_PORT_CLOCK_MODE_MASK<<1);
-		break;
-	case VTSS_SPEED_100M:
-		SET_BITS_MASKED( dev_setup_reg_value, M2_1G_PORT_CLOCK_MODE_100M<<1, 
-				M2_1G_PORT_CLOCK_MODE_MASK<<1);
-		break;
-	case VTSS_SPEED_1G:
-	case VTSS_SPEED_ETH_GFPT:
-	case VTSS_SPEED_FC2_GFPT: /* 6    Gbit/s Fibre Channel */
-	case VTSS_SPEED_FC4_GFPT: /* 7    Gbit/s Fibre Channel */
-	case VTSS_SPEED_1FC_GFPT: /* 8    1Gbit/s Fibre Channel or FICON*/
-	case VTSS_SPEED_2FC_GFPT: /* 9    2Gbit/s Fibre Channel */
-	case VTSS_SPEED_ESC_GFPT: /* 10 200Mbit/s ESCON or SBCON */
-	case VTSS_SPEED_DVB_GFPT: /* 11 270Mbit/s DVB ASI */
-
-	if (ps->interface_mode.interface_type == VTSS_PORT_INTERFACE_SERDES) {
-		SET_BITS_MASKED( dev_setup_reg_value, 
-			M2_1G_PORT_CLOCK_MODE_1G_SERDES<<1, 
-			M2_1G_PORT_CLOCK_MODE_MASK<<1);
-
-	} else if (ps->interface_mode.interface_type == VTSS_PORT_INTERFACE_TBI) {
-		SET_BITS_MASKED( dev_setup_reg_value, 
-			M2E_1G_PORT_CLOCK_MODE_TBI<<1, 
-			M2_1G_PORT_CLOCK_MODE_MASK<<1);
-
-	} else {
-		SET_BITS_MASKED( dev_setup_reg_value, 
-			M2_1G_PORT_CLOCK_MODE_1G_GMII<<1, 
-			M2_1G_PORT_CLOCK_MODE_MASK<<1);
-	}
-
-	/* Overrule setting by disable Ingress CRC updating when in GFP-T mode */
-	if (ps->interface_mode.speed != VTSS_SPEED_1G) { ps->crc_update = FALSE; }
-		break;
-
-	default:
-		//VTSS_E(("1G port #%d. Wrong speed: %d", ppn, ps->interface_mode.speed));
-		printk("1G port #%d. Wrong speed: %d\n", ppn, ps->interface_mode.speed);
-		return VTSS_WRONG_PARAMETER;
-	}
-
-	/* Set-up selected interface */
-	switch ( ps->interface_mode.interface_type) {
-	case VTSS_PORT_INTERFACE_GMII:
-		/* Invert (R)GMII_TX_clock when GMII */
-		SET_BIT( dev_setup_reg_value, 6); 
-			break;
-#if !defined MEIGS2 && !defined VSC7321
-	case VTSS_PORT_INTERFACE_RGMII:
-		SET_BIT( dev_setup_reg_value, 4);   /* Enable RGMII */
-		break;
-#endif
-	case VTSS_PORT_INTERFACE_SERDES:
-		SET_BIT( pcs_enable, 0);            /* Enable Ethernet PCS */
-		break;
-	case VTSS_PORT_INTERFACE_TBI:
-		/* Disable Signal detect */
-		vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PCS_CTRL, 0, (ulong)3<<22);
-		SET_BIT( dev_setup_reg_value, 23);  /* Enable TBI */
-		SET_BIT( dev_setup_reg_value, 22);  /* Invert TBI_TX_clock when TBI */
-		SET_BIT( pcs_enable, 0);            /* Enable Ethernet PCS */
-		break;
-	default:
-		printk("1G port #%d. Wrong interface type: %d\n", 
-			ppn, ps->interface_mode.interface_type);
-		break;
-	}
-
-
-	/* -------------------- Mode config Register ------------------------ */
-
-	/* interframe gaps */  
-	SET_BITS_MASKED( mode_cfg_reg, ps->frame_gaps.ifg1 << 6, VTSS_IFG_MASK << 6);
-	SET_BITS_MASKED( mode_cfg_reg, ps->frame_gaps.ifg2 << 10, VTSS_IFG_MASK << 10);
-
-	/* duplex mode */
-	if ( ps->fdx != FALSE) {
-		SET_BIT( mode_cfg_reg, 2);
-		if (ps->interface_mode.speed == VTSS_SPEED_1G) { SET_BIT( mode_cfg_reg, 3); }
-	}
-
-	/* vlan_awr */
-	if ( ps->vlan_aware != FALSE) { SET_BIT( mode_cfg_reg, 4); }
-
-	/* back_seed */
-	/*
-	   if (use_back_seed) {
-	   SET_BITS_MASKED( mode_cfg_reg, (ulong)back_seed << 16); SET_BIT( mode_cfg_reg, 14);
-	   }
-	 */
-
-	/* drop_on_length_error */
-	if ( ps->drop_on_length_error != FALSE) { SET_BIT( mode_cfg_reg, 15); }
-
-	/* Old Backoff Enable */
-	/*
-	//VTSS_ASSERT((old_backoff >= 0) && (old_backoff <= 2));
-	switch (old_backoff) {
-	case 0:
-	CLR_BITS_MASKED( mode_cfg_reg, (ulong)0x3 << 24);
-	break;
-	case 1:
-	SET_BITS_MASKED( mode_cfg_reg, (ulong)0x1 << 24);
-	break;
-	case 2:
-	SET_BITS_MASKED( mode_cfg_reg, (ulong)0x2 << 24);
-	break;
-	}
-	 */
-
-	/* Write to device Mode configureation register */
-	vtss_io_write( M2_BLK_MACS, ppn, M2_MODE_CFG, mode_cfg_reg);
-
-	/* Clear load_seed bit */
-	if (use_back_seed) { 
-		vtss_io_writemasked( M2_BLK_MACS, ppn, 
-				M2_MODE_CFG, 0, (ulong)1<<14); 
-	}
-
-	/* -------------------- Update other Register ------------------------ */
-
-	/* Set flow control */
-	pause_reg_value = (ps->tx_pause_value & VTSS_PORT_1G_TX_PAUSE_MASK);
-	if( ps->enable_tx_pause_xon_xoff != FALSE){ 
-		SET_BIT( pause_reg_value, 17); 
-	}
-	vtss_io_write( M2_BLK_MACS, ppn, M2_PAUSE_CFG, pause_reg_value);
-
-	/* VSC7321 (Meigs-II) requires both bits to be set */
-	vtss_port_flow_control_mode( portnum, ps->flowcontrol.obey, ps->flowcontrol.generate);
-
-	/* Set-up MAC address. Will be written if flowcontrol setup is requested. */
-	if( ps->flowcontrol.obey != FALSE || ps->flowcontrol.generate != FALSE ) {
-		ulong mac_addr_low_reg = 
-			(ps->flowcontrol.smac.addr[2] << 16)| 
-			(ps->flowcontrol.smac.addr[1] <<  8)|
-			ps->flowcontrol.smac.addr[0];
-
-		ulong mac_addr_high_reg = 
-			(ps->flowcontrol.smac.addr[5] << 16)| 
-			(ps->flowcontrol.smac.addr[4] <<  8)|
-			ps->flowcontrol.smac.addr[3];
-
-		vtss_io_write( M2_BLK_MACS, ppn, M2_MAC_ADDR_HIGH_CFG, mac_addr_high_reg);
-		vtss_io_write( M2_BLK_MACS, ppn, M2_MAC_ADDR_LOW_CFG, mac_addr_low_reg);
-	}
-
-	/* Write to device max length register */
-	vtss_io_write( M2_BLK_MACS, ppn, M2_MAXLEN_CFG, 
-			ps->maxframelength & VTSS_MAX_FRAME_LENGTH_MASK);
-
-	/* Change Egress CT_THRSHLD to maxframelength when set to store&forward */
-	if (( pvds->mmode == VTSS_MAC_MAJOR_MODE_SPI4_1G )|| 
-		(pvds->mmode == VTSS_MAC_MAJOR_MODE_SPI4_10G )){
-		if ( vtss_io_read ( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-					M2_CT_THRHLD + ppn) == 0 ) { 
-			vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-					M2_CT_THRHLD + ppn, ps->maxframelength>>5); 
-		}
-	}
-
-	/* HOLD device clock in reset while changing the clock-mode */
-	/* vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP, 0x1, 0x1); */
-
-	/* Write to device PCS config register */
-	vtss_io_write( M2_BLK_MACS, ppn, M2_PCS_CONFIG, pcs_enable);
-
-	/* Write to device setup register */
-	vtss_io_write( M2_BLK_MACS, ppn, M2_DEV_SETUP, dev_setup_reg_value);
-
-	/* Configure 1G SERDES */
-	if (ps->interface_mode.interface_type == VTSS_PORT_INTERFACE_SERDES) {
-		/* Apply RESET to SERDES. This will keep it reset */
-		vtss_io_write( 	M2_BLK_MACS, ppn, M2_SERDES_TEST, 
-				VTSS_SERDES_RESET_AND_ENABLE);
-		/* Write the serdes configuration word */
-		vtss_io_write( M2_BLK_MACS, ppn, M2_SERDES_CONF, 
-				VTSS_SERDES_CONFIG_WORD);
-		/* Take SERDES out of reset */
-		vtss_io_write( M2_BLK_MACS, ppn, M2_SERDES_TEST, 
-				VTSS_SERDES_ENABLE);
-	}
-
-	/* Take the MAC block out of RESET */
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP, 0, 0x1);
-
-	/* --------------- Update Normalizer Register ------------- */
-
-	/* Set-up port number in fake preamble header */
-	reg = ((ps->prm_hdr_value & 0xF)<<12);
-
-	/* Insert fake preamble header */
-	if( ps->prm_hdr_insert != FALSE) { SET_BIT( reg, 0); }
-
-	/* Insert Normalized header */
-	if( ps->norm_hdr_insert != FALSE) {
-		SET_BIT( reg, 1);
-	} else {
-		SET_BIT( reg, 2); /* NLE */
-	}
-
-	/* Disable Ingress CRC updating */
-	if( ps->crc_update == FALSE) { SET_BIT( reg, 9); }
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_NORMALIZER, reg, (ulong)0xF207);
-
-	/* ----------- Update De-Normalizer Register --------- */
-
-	reg = 0;
-	if ( ps->norm_hdr_expect != FALSE) { SET_BIT( reg, 1); }
-	if ( ps->prm_hdr_expect != FALSE) { SET_BIT( reg, 0); }
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_DENORM, reg, (ulong)0x3);
-
-	/* Egress CRC-32 Checker after SPI4 must be disabled to 
-		let bad frames pass through */
-	if( VTSS_OK != vtss_port_fcs_modify( portnum, ps->fcs_modify)){
-		/* Issue a warning */
-		printk("[%s] not able to modify fcs\n",__FUNCTION__);
-	}
-
-	/* Save user data to the global structure */
-	vtss_1G_ports_setup[ppn] = *ps;
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-
-  Function void vtss_port_setup_get_default_values( vtss_port_setup_t* ps,
-  vtss_mac_major_mode_t mmode)
-
-================================================================================
-
-Description:
-Supplementary function: fills the structure referenced by the pointer 
-with the default values for a given major_mode.
-By default the port is setup to run in 1G GMII mode.
-
-NOTE: 
-Requires global port mapping table to be initialized
-
-Syntax
-void vtss_port_setup_get_default_values( vtss_port_setup_t* ps,
-vtss_mac_major_mode_t mmode);
-
-Arguments:
-ps           pointer to a structure that will be filled with default data
-mmode        one of the major modes
-
-Return code:
-VTSS_OK
-
- *******************************************************************************/
-vtss_rc vtss_port_setup_get_default_values( vtss_port_setup_t* ps,
-		vtss_mac_major_mode_t mmode)
-{
-
-	vtss_mac_t mac_addr = {{0,0,0,0,0,0}};
-
-
-	switch ( mmode) {
-		/* valid major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	/* By default 1G GMII interface is assumed */
-	ps->interface_mode.interface_type = VTSS_PORT_INTERFACE_GMII;
-	ps->interface_mode.speed = VTSS_SPEED_1G;
-
-
-	ps->fdx = TRUE; /* Full duplex: TRUE, half duplex: FALSE */
-
-	/* Flow control setup */
-	ps->flowcontrol.obey = FALSE;
-	ps->flowcontrol.generate = FALSE;
-	ps->flowcontrol.smac = mac_addr;
-
-
-	ps->enable_tx_pause_xon_xoff = TRUE;
-	ps->tx_pause_value = VTSS_PORT_1G_TX_PAUSE_VALUE;
-
-
-	/* interframe gaps for 1G speed */
-	ps->frame_gaps.ifg1 = VTSS_IFG1_1G;
-	ps->frame_gaps.ifg2 = VTSS_IFG2_1G;
-
-	ps->maxframelength = VTSS_MAX_FRAME_LENGTH; /* Max frame length. */
-
-	ps->vlan_aware = FALSE;
-
-	ps->drop_on_length_error = FALSE;
-
-	ps->crc_update = FALSE;
-	ps->fcs_modify = VTSS_FCS_DO_NOTHING;
-
-
-
-	/* The following two fields are hw related */
-	ps->invert_gtx_tx_clock = TRUE;  /* HW related */
-	ps->invert_rx_clock     = FALSE; /* HW related */
-
-
-	switch ( mmode) {
-		/* valid major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-			ps->norm_hdr_insert = FALSE;
-			ps->prm_hdr_insert = FALSE;
-			ps->prm_hdr_value = 0;
-
-			ps->norm_hdr_expect = FALSE;
-			ps->prm_hdr_expect = FALSE;
-			break;
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-			ps->norm_hdr_insert = TRUE;
-			ps->prm_hdr_insert = FALSE;
-			ps->prm_hdr_value = 0;
-
-			ps->norm_hdr_expect = FALSE;
-			ps->prm_hdr_expect = FALSE;
-			break;
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			/* by default configured to preamble trunking */
-			ps->norm_hdr_insert = TRUE;
-			ps->prm_hdr_insert = TRUE;
-			ps->prm_hdr_value = 0;
-
-			ps->norm_hdr_expect = FALSE;
-			ps->prm_hdr_expect = TRUE;
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
-			/* these cases are needed only to make the compiler happy */
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	return VTSS_OK;
-}
-
-
-/*----------------  Run-time funcitons  ---------------------------------------*/
-/*******************************************************************************
-
-  Function  vtss_port_set_mode( )
-================================================================================
-
-Description:
-Configure speed and duplex mode of a 10M/100M/1G port
-
-NOTE: 
-
-
-Registers affected:
-DEV_SETUP     0xB
-MODE_CFG      0x0
-
-
-Syntax
-vtss_rc vtss_port_set_mode( vtss_port_no_t portnum, vtss_speed_t speed, 
-BOOL fdx);
-
-Arguments:
-portnum   logical port number
-speed     10M, 100M, 1G
-fdx       TRUE - full duplex, FALSE -- half duplex
-
-Return code:
-VTSS_OK                 if operation completed successfully
-VTSS_PORT_NOT_MAPPED    if the logical port is not mapped
-VTSS_WRONG_PARAMETER    wrong value or combination of input parameters
-
-*******************************************************************************/
-vtss_rc vtss_port_set_mode( 	vtss_port_no_t 	portnum, 
-				vtss_speed_t 	speed, 
-				BOOL 		fdx)
-{
-
-	ulong dev_setup_reg = 0;
-	ulong mode_cfg_reg = 0, mode_cfg_reg_mask = 0;
-	ulong old_value = 0;
-	uchar ifg1 = 0, ifg2 = 0;
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	/* 1G requre full duplex mode */
-	if ((speed == VTSS_SPEED_1G) && (!fdx)) {
-		return VTSS_WRONG_PARAMETER;
-	}
-
-
-	switch (speed) {
-		case VTSS_SPEED_10M:
-			SET_BIT( dev_setup_reg, 1);
-
-			ifg1 = (fdx) ? VTSS_IFG1_10M_FDX : VTSS_IFG1_10M_HDX;
-			ifg2 = (fdx) ? VTSS_IFG2_10M_FDX : VTSS_IFG2_10M_HDX;
-
-			break;
-		case VTSS_SPEED_100M:
-			SET_BIT( dev_setup_reg, 2);
-
-			ifg1 = (fdx) ? VTSS_IFG1_10M_FDX : VTSS_IFG1_10M_HDX;
-			ifg2 = (fdx) ? VTSS_IFG2_10M_FDX : VTSS_IFG2_10M_HDX;
-
-			break;
-		case VTSS_SPEED_1G:
-			if ( vtss_1G_ports_setup[ppn].interface_mode.interface_type == 
-					VTSS_PORT_INTERFACE_SERDES) {
-				SET_BIT( dev_setup_reg, 3);
-			} else {
-				SET_BIT( dev_setup_reg, 2);
-				SET_BIT( dev_setup_reg, 1);
-			}
-
-			ifg1 = VTSS_IFG1_1G;
-			ifg2 = VTSS_IFG2_1G;
-
-			SET_BIT( mode_cfg_reg, 3); /*GIGA mode*/
-
-			break;
-		default:
-			//    VTSS_E(("1G port #%d. Wrong speed: %d", ppn, speed));
-			printk("1G port #%d. Wrong speed: %d\n", ppn, speed);
-			return VTSS_WRONG_PARAMETER;
-	}
-
-	SET_BIT( mode_cfg_reg_mask, 3);
-
-	/* Prepare port for reset */
-	SET_BIT( dev_setup_reg, 0);
-
-	if(fdx) {
-		SET_BIT( mode_cfg_reg, 2);
-	}
-	SET_BIT( mode_cfg_reg_mask, 2);
-
-	SET_BITS_MASKED( mode_cfg_reg, (ulong)ifg1<<6, (ulong)VTSS_IFG_MASK<<6);
-	SET_BITS_MASKED( mode_cfg_reg, (ulong)ifg2<<10, (ulong)VTSS_IFG_MASK<<10);
-	/* set the mode_cfg_reg mask */
-	SET_BITS_MASKED( mode_cfg_reg_mask, (ulong)VTSS_IFG_MASK<<6, 
-			(ulong)VTSS_IFG_MASK<<6);
-	SET_BITS_MASKED( mode_cfg_reg_mask, (ulong)VTSS_IFG_MASK<<10, 
-			(ulong)VTSS_IFG_MASK<<10);
-
-	/* Read the current value */
-	old_value = 0x3 & vtss_io_read( M2_BLK_MACS, ppn, M2_MODE_CFG); 
-	/* Disable port */
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_MODE_CFG, 0, 0x3);
-
-	/* Change the mode */
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_MODE_CFG,
-			mode_cfg_reg, mode_cfg_reg_mask);
-
-	/* Write device setup register. It will also reset the port */
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP,
-			dev_setup_reg, 0xF);
-
-	/* leave reset state */
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP,
-			0, 0x1);
-
-	/* Restore old RX and TX values */
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_MODE_CFG, old_value, 0x3);
-
-
-	/* Update global data */
-	vtss_1G_ports_setup[ppn].interface_mode.speed = speed;
-	vtss_1G_ports_setup[ppn].fdx = fdx;
-	vtss_1G_ports_setup[ppn].frame_gaps.ifg1 = ifg1;
-	vtss_1G_ports_setup[ppn].frame_gaps.ifg2 = ifg2;
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-
-  Function vtss_port_set_enable()
-================================================================================
-
-Description:
-Enable/disable rx, tx or both in a 10M/100M/1G port 
-
-NOTE: 
-
-
-Syntax
-vtss_rc vtss_port_set_enable( vtss_port_no_t portnum, 
-BOOL rx_en, BOOL tx_en);
-
-Arguments:
-portnum      logical port number
-rx_en        if TRUE, enables reception of Ethernet frames
-if FALSE, disables reception of Ethernet frames
-tx_en        if TRUE, enables transmission of Ethernet frames
-if FALSE, disables transmission of Ethernet frames
-
-Return code:
-VTSS_OK                if operation completed successfully
-VTSS_PORT_NOT_MAPPED   if the logical port is not mapped
-
- *******************************************************************************/
-vtss_rc vtss_port_set_enable( vtss_port_no_t portnum, BOOL rx_en, BOOL tx_en)
-{
-	ulong mode_cfg_reg = 0;
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	if(rx_en) {
-		SET_BIT(mode_cfg_reg, 1);
-	}
-	if(tx_en) {
-		SET_BIT(mode_cfg_reg, 0);
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_MODE_CFG, mode_cfg_reg, 0x3);
-
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-
-  Function vtss_port_fcs_modify()
-================================================================================
-
-Description:
-Set CRC adding/updating mode (done in the denormalizer).
-
-NOTE:
-Only in egress direction.
-SPI4 block must not discard frames with incorrect FCS.
-
-
-Syntax
-vtss_rc vtss_port_fcs_modify( vtss_port_no_t portnum, vtss_fcs_modify_t mc);
-
-Arguments:
-portnum     logical port number
-mc          select the way FCS is modified
-
-Return code:
-VTSS_OK                 if operation completed successfully
-VTSS_PORT_NOT_MAPPED    logical port not mapped
-
- *******************************************************************************/
-vtss_rc vtss_port_fcs_modify( vtss_port_no_t portnum, vtss_fcs_modify_t mc)
-{
-	ulong denorm_reg = 0;
-	ulong mask = (1<<5)|(1<<4);
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	/* Meigs2 has two independent bits: UPDATE and ADD, which should always have
-	   opposite values */
-	switch ( mc) {
-		case  VTSS_FCS_DO_NOTHING:
-			/* denorm_reg is already set to 0 */
-			break;
-		case VTSS_FCS_UPDATE:
-			SET_BIT( denorm_reg, 5);
-			/* CLR_BIT( denorm_reg, 4); denorm_reg is already set to 0 */
-			break;
-		case VTSS_FCS_ADD:
-			SET_BIT( denorm_reg, 4);
-			/* CLR_BIT( denorm_reg, 5); denorm_reg is already set to 0 */
-			break;
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_DENORM, denorm_reg, mask);
-
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-
-  Function 
-  ================================================================================
-
-Description:
-Discard/do_not_discard  Ethernet frames with wrong FCS in ingress direciton
-
-NOTE: 
-Not only frames with incorrect FCS will be allowed upstream, but also 
-all wrong frames including fragments.
-
-Syntax
-vtss_rc vtss_port_check_fcs( vtss_port_no_t portnum, BOOL check);
-
-Arguments:
-portnum   logical port number
-check     TRUE   -- frames with wrong FCS are discarded (default)
-FALSE  -- frames with wrong FCS are forwarded upstream
-
-Return code:
-VTSS_OK   if operation completed successfully
-VTSS_FEATURE_NOT_SUPPORTED
-VTSS_PORT_NOT_MAPPED   logical port not mapped
-
- *******************************************************************************/
-vtss_rc vtss_port_check_fcs( vtss_port_no_t portnum, BOOL check)
-{
-
-#if defined MEIGS2 || defined VSC7321
-
-	/* MEIGS2 always discards ingress frames with bad FCS */
-	/* it is not possible to disable this feature */
-	return VTSS_FEATURE_NOT_SUPPORTED;
-
-#else
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-
-	ulong norm_reg_value = 0;
-	ulong mdbg_reg_value = 0;
-	ulong gress_test_reg = 0;
-	ulong gress = M2_SUBBLK_INGRESS;
-
-	vtss_device_setup_t *pvds = pdevice;
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	/* Only one global device per API is currently supported */
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			gress = M2_SUBBLK_EGRESS;
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-	if (check) {
-		SET_BIT( norm_reg_value, 9); /* NO_CRC update */
-		SET_BITS_MASKED( mdbg_reg_value, 0x3, 0x3); /* SET_FAIL & KEEP_BAD */
-		SET_BIT( gress_test_reg, 4); /* NO_DROP_IN_FRM */
-	} else {
-		/* bits are already cleared, just write them down */
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_NORMALIZER, 
-			norm_reg_value, 1<<9);
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2E_TRI_MULTI_DBG, 
-			mdbg_reg_value, 0x3);
-
-	vtss_io_writemasked(M2_BLK_FIFO, gress, ppn,
-			gress_test_reg, 1<<4);
-
-	return VTSS_OK;
-
-#endif
-}
-
-
-/*******************************************************************************
-
-  Function   vtss_port_forward_pause_frames( )
-  ================================================================================
-
-Description: 
-Allow pause frames pass through the device. By default 10M/100M/1G block
-prevents propagation of pause frames through the device.
-
-NOTE: 
-
-Syntax
-vtss_rc vtss_port_forward_pause_frames( vtss_port_no_t portnum, BOOL allow);
-
-Arguments:
-portnum   number of the logical port
-allow     if TRUE, allows pause frames pass through the device
-if FALSE, pause frames will not be allowed to pass
-
-Return code:
-VTSS_OK               if operation completed successfully
-VTSS_PORT_NOT_MAPPED  logical port is not mapped to any physical port
-
- *******************************************************************************/
-vtss_rc vtss_port_forward_pause_frames( vtss_port_no_t portnum, BOOL allow)
-{
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_NORMALIZER, (allow)?0:(1<<6), 1<<6);
-	return VTSS_OK;
-}
-
-
-
-/*******************************************************************************
-
-  Function vtss_port_flow_control_mode( )
-
-  ================================================================================
-
-Description:
-Select different modes of flow control on Ethernet interface.
-
-Terminology:
-obey        obeys pause frames received from Ethernet 
-generate    generate pause frames/backpressure upon request from the 
-destination (FIFO or the host interface)
-
-NOTE:
-If fc_obey AND fc_generate are set to FALSE, then flow control is disabled
-
-IMPORTANT
-VSC7321 supports only symmetrical flow control and requires both
-arguments to be set to TRUE.
-
-Syntax
-vtss_rc vtss_port_flow_control_mode( vtss_port_no_t port_num, 
-BOOL fc_obey, 
-BOOL fc_generate)
-
-Arguments:
-obey        if TRUE, obeys pause frames from Ethernet
-if FALSE, disregard pause frames from Ethernet
-generate    if TRUE, generate pause frames/backpressure upon request 
-from the destination block (FIFO or the host interface)
-
-
-Return code:
-VTSS_OK               if operation completed successfully
-VTSS_PORT_NOT_MAPPED  logical port is not mapped to any physical port
-
- *******************************************************************************/
-vtss_rc vtss_port_flow_control_mode( vtss_port_no_t port_num, 
-		BOOL fc_obey, 
-		BOOL fc_generate)
-{
-	ulong pause_reg_value = 0;
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_num].chip_port;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-
-#if defined MEIGS2 || defined VSC7321
-
-	if(fc_obey && fc_generate) {
-
-		/* The only mode supported in Meigs-II*/
-		SET_BIT( pause_reg_value, 16);
-		/* IMPORTANT:                                                */
-		/* tx_pause_value and mac_address must be already initialized */
-
-	} else {
-		/* disable flow control */
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PAUSE_CFG, pause_reg_value, 1<<16);
-
-#else /* VSC7323 && VSC7331*/
-
-	if(fc_obey && fc_generate) {
-		SET_BIT( pause_reg_value, 16);
-	} else if (fc_obey) {
-		SET_BIT( pause_reg_value, 18);
-		CLR_BIT( pause_reg_value, 16);
-	} else if (fc_generate) {
-		SET_BIT( pause_reg_value, 19);
-		/* SET_BIT( pause_reg_value, 17); */
-		CLR_BIT( pause_reg_value, 16);
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PAUSE_CFG, 
-			pause_reg_value, 0xD<<16);
-
-#endif
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-
-  Function vtss_port_counters_clear(  )
-
-  ================================================================================
-
-Description:
-Clears counter for the logical port 
-
-NOTE:
-In its current form this funciton clears counters in all 1G ports.
-This behaviour will be corrected in the next release.
-
-
-Syntax
-vtss_rc vtss_port_counters_clear( const vtss_port_no_t portnum );
-
-Arguments:
-
-
-Return code:
-
- *******************************************************************************/
-vtss_rc vtss_port_counters_clear( const vtss_port_no_t portnum )
-{
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-	//  VTSS_N(("Port setup. Logic port #%d, phys prt #%d", portnum, ppn));
-	//printk("Port setup. Logic port #%d, phys prt #%d\n", portnum, ppn);
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-
-	/* Writing to this register clears counters in all 1G ports */
-	vtss_io_write( M2_BLK_STAT, ppn, M2_STAT_INIT, 0x0);
-
-
-	return VTSS_OK;
-}
-
-
-
-/*******************************************************************************
-
-  Function  vtss_port_counters_get()
-
-  ================================================================================
-
-Description:
-Clears counter for the logical port 
-
-Syntax
-vtss_rc vtss_port_counters_get( const vtss_port_no_t  portnum,
-vtss_port_counters_t *pcounters)
-
-Arguments:
-portnum   number of the logical port
-pc 
-
-Return code:
-
- *******************************************************************************/
-vtss_rc vtss_port_counters_get( const vtss_port_no_t  portnum,
-		vtss_port_counters_t *pc)
-{
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-	//  VTSS_N(("Port setup. Logic port #%d, phys prt #%d", portnum, ppn));
-	//	printk("Port setup. Logic port #%d, phys prt #%d\n", portnum, ppn);
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-
-	pc->rx_in_bytes = vtss_io_read(M2_BLK_STAT, ppn, M2_RX_IN_BYTES);
-	pc->rx_symbol_carrier = vtss_io_read( M2_BLK_STAT, ppn, 
-			M2_RX_SYMBOL_CARRIER);
-	pc->rx_pause = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_PAUSE);
-	pc->rx_unsup_opcode = vtss_io_read( M2_BLK_STAT, ppn, 
-					M2_RX_UNSUP_OPCODE);
-
-	pc->rx_ok_bytes = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_OK_BYTES);
-	pc->rx_bad_bytes = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_BAD_BYTES);
-
-	pc->rx_unicast = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_UNICAST);
-	pc->rx_multicast = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_MULTICAST);
-	pc->rx_broadcast = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_BROADCAST);
-	pc->rx_crc = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_CRC);
-	pc->rx_alignment = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_ALIGNMENT); 
-	pc->rx_undersize = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_UNDERSIZE);
-
-	pc->rx_fragments = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_FRAGMENTS);
-	pc->rx_in_range_error = vtss_io_read( M2_BLK_STAT, ppn, 
-			M2_RX_IN_RANGE_LENGTH_ERROR);
-	pc->rx_out_of_range_error = vtss_io_read( M2_BLK_STAT, ppn, 
-			M2_RX_OUT_OF_RANGE_ERROR);
-	pc->rx_oversize = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_OVERSIZE);
-	pc->rx_jabbers = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_JABBERS);
-	pc->rx_size_64 = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_SIZE_64);
-
-	pc->rx_size_65_to_127 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_RX_SIZE_65);
-	pc->rx_size_128_to_255 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_RX_SIZE_128);
-	pc->rx_size_256_to_511 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_RX_SIZE_256);
-	pc->rx_size_512_to_1023 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_RX_SIZE_512);
-	pc->rx_size_1024_to_1518 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_RX_SIZE_1024);
-	pc->rx_size_1519_to_max = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_RX_SIZE_1519);
-
-	pc->rx_xgmii_prot_err = 0; /* Only on 10G MAC port */
-
-	pc->rx_ipg_shrink = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_RX_IPG_SHRINK);
-
-
-	pc->tx_out_bytes = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_TX_OUT_BYTES);
-	pc->tx_pause = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_PAUSE);
-	pc->tx_ok_bytes = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_OK_BYTES);
-
-	pc->tx_unicast = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_UNICAST);
-	pc->tx_multicast = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_MULTICAST);
-	pc->tx_broadcast = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BROADCAST);
-
-	pc->tx_multiple_coll = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_TX_MULTIPLE_COLL);
-	pc->tx_late_coll = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_LATE_COL);
-	pc->tx_xcoll = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_XCOLL);
-	pc->tx_defer = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_DEFER);
-	pc->tx_xdefer = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_XDEFER);
-	pc->tx_carrier_sense = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_CSENSE);
-
-
-	pc->tx_size_64 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_SIZE_64);
-	pc->tx_size_65_to_127 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_TX_SIZE_65);
-	pc->tx_size_128_to_255 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_TX_SIZE_128);
-	pc->tx_size_256_to_511 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_TX_SIZE_256);
-	pc->tx_size_512_to_1023 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_TX_SIZE_512);
-	pc->tx_size_1024_to_1518 = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_TX_SIZE_1024);
-	pc->tx_size_1519_to_max = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_TX_SIZE_1519);
-
-
-	pc->tx_single_coll = vtss_io_read( M2_BLK_STAT, ppn, 
-						M2_TX_SINGLE_COL);
-	pc->tx_backoff2 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF2);
-	pc->tx_backoff3 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF3);
-	pc->tx_backoff4 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF4);
-	pc->tx_backoff5 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF5);
-	pc->tx_backoff6 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF6);
-	pc->tx_backoff7 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF7);
-	pc->tx_backoff8 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF8);
-	pc->tx_backoff9 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF9);
-	pc->tx_backoff10 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF10);
-	pc->tx_backoff11 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF11);
-	pc->tx_backoff12 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF12);
-	pc->tx_backoff13 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF13);
-	pc->tx_backoff14 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF14);
-	pc->tx_backoff15 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF15);
-
-	pc->tx_underrun = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_UNDERRUN);
-
-
-	/* 10G is not properly being handled for the drop counters */
-	/* It must reflect the major mode: 10G as single or multi channel, kbp */
-
-	pc->ingress_overflow_drop = 
-		vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_FIFO_DROP_CNT+ppn);
-	pc->egress_overflow_drop = 
-		vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_FIFO_DROP_CNT+ppn);
-
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-
-  Function   
-
-  ================================================================================
-
-Description:
-Configure 1G MAC block to insert normalisation of incoming ethernet frames.
-Works in the direction from 1G MAC to the ingress FIFO.
-
-NOTE. If an element in the 'hdr' structure is set to FALSE, that type of 
-header is left unmodified. 
-
-Syntax
-
-
-
-Arguments:
-ppn        physical port (port-on-chip)
-enable     action to be taken -- enable or disable header insertion
-hdr        normalized header/preamble header structure
-
-
-Return code:
-
- *******************************************************************************/
-static void vtss_port1G_header_insert( int ppn, BOOL enable, 
-		const m2_header_t hdr)
-{
-	ulong reg = 0, reg_mask = 0;
-
-	if ( hdr.use_norm_hdr) {
-
-		if (enable == TRUE) {
-			reg |= M2_NORMALIZER_BIT_NH;
-			/* Norm hdr requires NLE bit to be set */
-			reg |= M2_NORMALIZER_BIT_NLE;
-		}
-		/* else -- do nothing, the bits are already cleared */
-
-		reg_mask |= M2_NORMALIZER_BIT_NH;
-		reg_mask |= M2_NORMALIZER_BIT_NLE;
-	}
-
-	if ( hdr.use_prm_hdr) {
-		if (enable == TRUE)
-			reg |= M2_NORMALIZER_BIT_PH;
-
-		reg_mask |= M2_NORMALIZER_BIT_PH;
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_NORMALIZER, reg, reg_mask);
-
-	return;
-}
-
-
-/*******************************************************************************
- *
- *      Autonegotiation functions. Used when TBI or Serdes is enabled.
- *
- ******************************************************************************/
-
-/*
-   Returns the autonegotiation advertisment word and the status (enabled/disabled) 
-   of the autonegotiation.
- */
-vtss_rc vtss_pcs_autoneg_control_get( const vtss_port_no_t  port_num,
-		vtss_pcs_autoneg_control_t * const        control )
-{
-
-	ulong reg_value = 0;
-
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_num].chip_port;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	reg_value = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_CTRL);
-
-
-	control->advertisement.fdx = ( (reg_value >> 5) & 0x1) ? TRUE : FALSE;
-	control->advertisement.hdx = ( (reg_value >> 6) & 0x1) ? TRUE : FALSE;
-
-	control->advertisement.symmetric_pause =   /* a.k.a. PAUSE (PS1) */
-		((reg_value >> 7) & 0x1) ? TRUE : FALSE;
-
-	control->advertisement.asymmetric_pause = /* a.k.a. ASM_DIR (PS2) */
-		((reg_value >> 8) & 0x1) ? TRUE : FALSE;
-
-	switch ( ( reg_value >> 12) & 0x3) {
-
-	case VTSS_1000BASEX_LINK_OK:
-		control->advertisement.remote_fault = VTSS_1000BASEX_LINK_OK;
-		break;
-	case VTSS_1000BASEX_OFFLINE:
-		control->advertisement.remote_fault = VTSS_1000BASEX_OFFLINE;
-		break;
-	case VTSS_1000BASEX_LINK_FAILURE:
-		control->advertisement.remote_fault = VTSS_1000BASEX_LINK_FAILURE;
-		break;
-	case VTSS_1000BASEX_AUTONEG_ERROR:
-		control->advertisement.remote_fault = VTSS_1000BASEX_AUTONEG_ERROR;
-		break;
-	}
-
-
-	control->advertisement.acknowledge = ((reg_value>>14) & 0x1)?TRUE:FALSE;
-
-	control->advertisement.next_page = ( ( reg_value>>15) & 0x1)?TRUE:FALSE;
-
-
-	control->enable = ( ( reg_value>>17) & 0x1)?TRUE:FALSE;
-
-	return VTSS_OK;
-}
-
-/*
-   Enables/disables autonegotiation in the PCS module and sets advertisment word
- */
-vtss_rc vtss_pcs_autoneg_control_set( const vtss_port_no_t                      port_num,
-		const vtss_pcs_autoneg_control_t * const  control )
-{
-
-	ulong reg_value = 0, reg_mask = 0;
-
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_num].chip_port;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	if ( control->enable == TRUE) {
-		/* Autonegotiation must be enabled and the advertisment word must be 
-		   written down */
-
-		if ( control->advertisement.fdx == TRUE) {
-			SET_BIT( reg_value, 5);
-		} 
-		SET_BIT(reg_mask, 5);
-
-		if ( control->advertisement.hdx) {
-			SET_BIT( reg_value, 6);
-		}
-		SET_BIT( reg_mask, 6);
-
-		if ( control->advertisement.symmetric_pause) { /* a.k.a. PAUSE (PS1) */
-			SET_BIT( reg_value, 7);
-		}
-		SET_BIT(reg_mask, 7);
-
-		if ( control->advertisement.asymmetric_pause) { /* a.k.a. ASM_DIR (PS2) */
-			SET_BIT( reg_value, 8);
-		}
-		SET_BIT( reg_mask, 8);
-
-		switch ( control->advertisement.remote_fault) {
-			case VTSS_1000BASEX_LINK_OK:
-				CLR_BIT( reg_value, 12);
-				CLR_BIT( reg_value, 13);
-				break;
-			case VTSS_1000BASEX_OFFLINE:
-				CLR_BIT( reg_value, 12);
-				SET_BIT( reg_value, 13);
-				break;
-			case VTSS_1000BASEX_LINK_FAILURE:
-				SET_BIT( reg_value, 12);
-				CLR_BIT( reg_value, 13);
-				break;
-			case VTSS_1000BASEX_AUTONEG_ERROR:
-				SET_BIT( reg_value, 12);
-				SET_BIT( reg_value, 13);
-				break;
-		}
-		SET_BIT( reg_mask, 12);
-		SET_BIT( reg_mask, 13);
-
-
-		if( control->advertisement.acknowledge == TRUE) {
-			SET_BIT( reg_value, 14);
-		}
-		SET_BIT( reg_mask, 14);
-
-		if ( control->advertisement.next_page == TRUE) {
-			SET_BIT( reg_value, 15);
-		}
-		SET_BIT( reg_mask, 15);
-
-
-		/* enable and restart autoneg bits */
-		SET_BIT( reg_value, 16);
-		SET_BIT( reg_value, 17);
-
-		SET_BIT( reg_mask, 16);
-		SET_BIT( reg_mask, 17);
-
-		/* and the write_strobe: used in Meigs2, harmless in VSC7323/7331 */
-		SET_BIT( reg_value, 31);
-		SET_BIT( reg_mask, 31);
-
-	} else {
-		/* restart autoneg bits must be set when disabling autoneg */
-		SET_BIT( reg_value, 16);
-		/* disable autoneg */
-		CLR_BIT( reg_value, 17);
-
-		SET_BIT( reg_mask, 16);
-		SET_BIT( reg_mask, 17);
-
-		/* and the write_strobe: used in Meigs2, harmless in VSC7323/7331 */
-		SET_BIT( reg_value, 31);
-		SET_BIT( reg_mask, 31);
-
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PCS_CTRL, reg_value, reg_mask);
-
-	return VTSS_OK;
-}
-
-
-/*
-   Restarts autonegotiation, does not check whether autonegotiation is enabled
- */
-vtss_rc vtss_pcs_autoneg_restart( const vtss_port_no_t  port_num )
-{
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_num].chip_port;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-
-	/* Autoneg restart bit#16
-	   Write strobe bit#31 -- used in VSC7321, harmless in VSC7323/7331
-	 */
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PCS_CTRL, 
-			0x8001<<16, 0x8001<<16);
-
-	return VTSS_OK;
-}
-
-
-/*  
-    Return the status of the current status of the link partner
- */
-vtss_rc vtss_pcs_autoneg_status_get( const vtss_port_no_t port_num,
-		vtss_pcs_autoneg_status_t *paneg)
-{
-
-	ulong reg_value = 0;
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_num].chip_port;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	reg_value = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_STATUS);
-
-
-	/*  Read XMIT_MODE: bits #18-19  */
-	switch ( ( reg_value >> 18) & 0x3) {
-
-		case VTSS_PCS_ANEG_STATE_IDLE:      /* Idle */
-			paneg->aneg_state = VTSS_PCS_ANEG_STATE_IDLE;
-			break;
-		case VTSS_PCS_ANEG_STATE_CONFIG:    /* Config (i.e. ANEG in progress) */
-			paneg->aneg_state = VTSS_PCS_ANEG_STATE_CONFIG;
-			break;
-		case VTSS_PCS_ANEG_STATE_DATA:      /* Data */
-			paneg->aneg_state = VTSS_PCS_ANEG_STATE_DATA;
-			break;
-		default:
-			paneg->aneg_state = VTSS_PCS_ANEG_STATE_NOTVALID;
-	}
-
-	/* ANC:  autoneg complete bit #16 */
-	paneg->aneg_complete = ( (reg_value >> 16) & 0x1) ? TRUE : FALSE;
-
-	paneg->partner_advertisement.fdx = ( (reg_value >> 5) & 0x1) ? TRUE : FALSE;
-	paneg->partner_advertisement.hdx = ( (reg_value >> 6) & 0x1) ? TRUE : FALSE;
-
-	paneg->partner_advertisement.symmetric_pause =   /* a.k.a. PAUSE (PS1) */
-		((reg_value >> 7) & 0x1) ? TRUE : FALSE;
-
-	paneg->partner_advertisement.asymmetric_pause = /* a.k.a. ASM_DIR (PS2) */
-		((reg_value >> 8) & 0x1) ? TRUE : FALSE;
-
-
-
-	switch ( ( reg_value >> 12) & 0x3) {
-
-		case VTSS_1000BASEX_LINK_OK:
-			paneg->partner_advertisement.remote_fault = VTSS_1000BASEX_LINK_OK;
-			break;
-		case VTSS_1000BASEX_OFFLINE:
-			paneg->partner_advertisement.remote_fault = VTSS_1000BASEX_OFFLINE;
-			break;
-		case VTSS_1000BASEX_LINK_FAILURE:
-			paneg->partner_advertisement.remote_fault = VTSS_1000BASEX_LINK_FAILURE;
-			break;
-		case VTSS_1000BASEX_AUTONEG_ERROR:
-			paneg->partner_advertisement.remote_fault = VTSS_1000BASEX_AUTONEG_ERROR;
-			break;
-	}
-
-
-	paneg->partner_advertisement.acknowledge = ((reg_value>>14) & 0x1)?TRUE:FALSE;
-
-	paneg->partner_advertisement.next_page = ( ( reg_value>>15) & 0x1)?TRUE:FALSE;
-
-	return VTSS_OK;
-}
-
-
-/* Returns more detailed status than vtss_pcs_autoneg_status_get */
-vtss_rc vtss_pcs_status_get( const vtss_port_no_t       port_num,
-		vtss_pcs_status_t * const  pstatus )
-{
-
-	ulong pcs_status = 0;
-	ulong pcs_ctrl = 0;
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_num].chip_port;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	pcs_status = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_STATUS);
-	pcs_ctrl = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_CTRL);
-
-
-	/*  Read XMIT_MODE: bits #18-19  */
-	switch ( ( pcs_status >> 18) & 0x3) {
-
-		case VTSS_PCS_ANEG_STATE_IDLE:  /* Idle */
-			pstatus->autoneg.aneg_state = VTSS_PCS_ANEG_STATE_IDLE;
-			break;
-		case VTSS_PCS_ANEG_STATE_CONFIG:    /* Config (i.e. ANEG in progress) */
-			pstatus->autoneg.aneg_state = VTSS_PCS_ANEG_STATE_CONFIG;
-			break;
-		case VTSS_PCS_ANEG_STATE_DATA:       /* Data */
-			pstatus->autoneg.aneg_state = VTSS_PCS_ANEG_STATE_DATA;
-			break;
-		default:
-			pstatus->autoneg.aneg_state = VTSS_PCS_ANEG_STATE_NOTVALID;
-	}
-
-	/* ANC:  autoneg complete bit #16 */
-	pstatus->autoneg.aneg_complete = ( (pcs_status >> 16) & 0x1) ? TRUE : FALSE;
-
-	/* SHOW_LDC_TOP bit of the PCS_CTRL register (bit #25) selects how to 
-	   interpret bits 24..31 of the PCS_STATUS register */
-	if ( ( pcs_ctrl >> 25) & 0x1) { /* the link down counter is 8 bit long */
-
-		pstatus->show_ldc_top = TRUE;
-
-		pstatus->losync = FALSE;
-
-		pstatus->pcs_in_sync = FALSE;
-
-		/* link down counter is 8bit long */
-		pstatus->link_down_counter = (pcs_status >> 24) & 0xFF;
-
-	} else { /* the link down counter is 6 bit long */
-
-		pstatus->show_ldc_top = FALSE;;
-
-		pstatus->losync = 
-			((pcs_status >> 31) & 0x1) ? TRUE : FALSE;
-
-		pstatus->pcs_in_sync = 
-			((pcs_status >> 30) & 0x1) ? TRUE : FALSE;
-
-
-		/* link down counter is only 6 bits long */
-		pstatus->link_down_counter = (pcs_status >> 24) & 0x3F;
-
-	}
-
-
-	/* signal_detected indicates that there is light in the fiber; 
-	   require SD_EN in the PCS_CTRL register to be set */
-	pstatus->signal_detected = 
-		((pcs_status >> 23) & 0x1) ? TRUE : FALSE;
-
-
-	pstatus->jtp_lock = 
-		((pcs_status >> 22) & 0x1) ? TRUE : FALSE;
-
-	pstatus->jtp_error = 
-		((pcs_status >> 21) & 0x1) ? TRUE : FALSE;
-
-
-	/* link_status:  FALSE if link has been down since last status read */
-	pstatus->link_status_ok =
-		((pcs_status >> 20) & 0x1) ? TRUE : FALSE;
-
-
-
-
-	pstatus->autoneg.partner_advertisement.fdx = ( (pcs_status >> 5) & 0x1) ? TRUE : FALSE;
-	pstatus->autoneg.partner_advertisement.hdx = ( (pcs_status >> 6) & 0x1) ? TRUE : FALSE;
-
-	pstatus->autoneg.partner_advertisement.symmetric_pause =   /* a.k.a. PAUSE (PS1) */
-		((pcs_status >> 7) & 0x1) ? TRUE : FALSE;
-
-	pstatus->autoneg.partner_advertisement.asymmetric_pause = /* a.k.a. ASM_DIR (PS2) */
-		((pcs_status >> 8) & 0x1) ? TRUE : FALSE;
-
-
-
-	switch ( ( pcs_status >> 12) & 0x3) {
-
-		case VTSS_1000BASEX_LINK_OK:
-			pstatus->autoneg.partner_advertisement.remote_fault = VTSS_1000BASEX_LINK_OK;
-			break;
-		case VTSS_1000BASEX_OFFLINE:
-			pstatus->autoneg.partner_advertisement.remote_fault = VTSS_1000BASEX_OFFLINE;
-			break;
-		case VTSS_1000BASEX_LINK_FAILURE:
-			pstatus->autoneg.partner_advertisement.remote_fault = VTSS_1000BASEX_LINK_FAILURE;
-			break;
-		case VTSS_1000BASEX_AUTONEG_ERROR:
-			pstatus->autoneg.partner_advertisement.remote_fault = VTSS_1000BASEX_AUTONEG_ERROR;
-			break;
-	}
-
-
-	pstatus->autoneg.partner_advertisement.acknowledge = ((pcs_status>>14) & 0x1)?TRUE:FALSE;
-
-	pstatus->autoneg.partner_advertisement.next_page = ( ( pcs_status>>15) & 0x1)?TRUE:FALSE;
-
-	return VTSS_OK;
-}
-
-
-vtss_rc vtss_serdes_signal_detect_setup( const vtss_port_no_t port_num,
-		BOOL enable,
-		BOOL sd_polarity_high,
-		BOOL sd_source_extern)
-{
-
-	ulong reg = 0, mask = 0;
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_num].chip_port;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-
-
-	if ( enable == TRUE) {
-
-		/* set Signal Detect source */
-		if ( sd_source_extern == TRUE)
-			SET_BIT( reg, 8);
-		SET_BIT( mask, 8);
-		vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP, reg, mask);
-		reg = mask = 0;
-
-		/* and now Polarity and Enable */
-		SET_BIT( reg, 22); /* Signal Detect Enable */
-
-		if ( sd_polarity_high == TRUE)
-			SET_BIT( reg, 23); /* Signal Detect Polarity */
-
-		SET_BIT( mask, 22);
-		SET_BIT( mask, 23);
-
-	} else {
-		/* Disable serdes Signal Detect */
-		SET_BIT( mask, 22);
-	}
-
-	/* write_strobe used in Meigs2, otherwise harmless */
-	SET_BIT( reg, 31);
-	SET_BIT( mask, 31);
-
-
-	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PCS_CTRL, reg, mask);
-
-
-
-	return VTSS_OK;
-
-}
-
-
-
-vtss_rc vtss_serdes_extern_signal_detect_status_get(const vtss_port_no_t port_num, 
-		BOOL *pstatus)
-{
-	ulong reg = 0;
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_num].chip_port;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* right major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-
-	reg = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_STATUS);
-
-	if ( (reg >> 23) & 0x1 ) { /* bit 23 is set */
-		*pstatus = TRUE;
-	} else {
-		*pstatus = FALSE;
-	}
-
-	return VTSS_OK;
-}
-
-
-/*****************************************************************************/
-/*                                                                           */
-/*        10G port setup                                                     */
-/*                                                                           */
-/*****************************************************************************/
-
-
-/*--       Setup  Funtions                            -----------------------*/
-
-
-/* Setup 10G port */
-vtss_rc vtss_10Gport_setup( vtss_port_no_t port_num, vtss_10Gport_setup_t* ps)
-{
-
-
-	ulong misc_reg_value = 0;
-	ulong reg_mask = 0;
-	ulong reg_value = 0;
-
-	ulong max_len_reg_value = 0;
-
-	ulong pause_reg_value = 0;
-
-	ulong denorm_reg = 0;
-
-	m2_header_t hdr;
-
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-
-
-	//  VTSS_N(("10G port setup."));
-	printk("10G port setup.\n");
-
-	/* check for appropriate major mode */
-	switch ( pvds->mmode) {
-		/* Suppported modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:      /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
-			break;
-
-			/* Undefined major mode */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-			/* Wrong mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-
-	if (VTSS_SPEED_10G != ps->interface_mode.speed) {
-		printk("10G port. Wrong speed: %d\n", ps->interface_mode.speed);
-		return VTSS_WRONG_PARAMETER;
-	}
-
-	if (VTSS_PORT_INTERFACE_XAUI != ps->interface_mode.interface_type) {
-		printk("10G port. Wrong interface type: %d\n", 
-					ps->interface_mode.interface_type);
-		return VTSS_WRONG_PARAMETER;
-	}
-
-	/* -------------------  MISC  ------------------------- */
-
-	/* Enable the 10G block */
-	SET_BIT( misc_reg_value, 1);
-	SET_BIT( misc_reg_value, 0);
-
-	if ( ps->vlan_aware)           { SET_BIT( misc_reg_value, 2); }
-	if ( ps->prm_hdr_insert)       { SET_BIT( misc_reg_value, 3); }
-	if ( ps->pace_mode)            { SET_BIT( misc_reg_value, 5); }
-	if ( ps->drop_in_range_error)  { SET_BIT( misc_reg_value, 6); }
-	if ( ps->drop_on_length_error) { SET_BIT( misc_reg_value, 7); }
-	if ( ps->sfd_check)            { SET_BIT( misc_reg_value, 8); }
-
-	/* It is recommended to set 3-bit LFS_MODE bitfield to 000b */
-	SET_BITS_MASKED( misc_reg_value, 0, (ulong)7<<9);
-	SET_BITS_MASKED( reg_mask, (ulong)7<<9, (ulong)7<<9);
-
-	if ( ps->ext_sop_check_enable) { SET_BIT( misc_reg_value, 13); }
-	if ( ps->ext_eop_check_enable) { SET_BIT( misc_reg_value, 14); }
-
-	/* Before writing the value down to the register, take the 10g block 
-	   out of reset */
-	CLR_BIT( misc_reg_value, 31);
-
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MISC_10G, 
-			misc_reg_value, 0XFFFFFFFF);
-
-
-	/* -------------------  DENORM  ------------------------- */
-
-	/* For this to work SPI4(when used) must be set to let bad frames 
-	   pass through */
-	switch ( ps->fcs_modify) {
-		case  VTSS_FCS_DO_NOTHING:
-			/* bits are cleared, do nothing */
-			break;
-		case VTSS_FCS_UPDATE:
-			SET_BIT( denorm_reg, 5);
-			/* bit #4 is cleared */
-			break;
-		case VTSS_FCS_ADD:
-			SET_BIT( denorm_reg, 4);
-			/* bit #5 is cleared */
-			break;
-	}
-
-	if( ps->norm_hdr_expect == TRUE) { SET_BIT(denorm_reg, 1); }
-	if( ps->prm_hdr_expect  == TRUE) { SET_BIT(denorm_reg, 0); }
-
-	/* Denormalizer register */
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_DENORM, denorm_reg, 0x3f);
-
-
-	/* -------------------  Flowcontrol  ----------------------- */
-
-	if(ps->flowcontrol.obey || ps->flowcontrol.generate) {
-
-		/* Mac address will be written if flowcontrol setup is requested */
-		ulong mac_addr_low_reg = 
-			(ps->flowcontrol.smac.addr[3] << 16)| 
-			(ps->flowcontrol.smac.addr[4] <<  8)|
-			ps->flowcontrol.smac.addr[5];
-
-		ulong mac_addr_high_reg = 
-			(ps->flowcontrol.smac.addr[0] << 16)| 
-			(ps->flowcontrol.smac.addr[1] <<  8)|
-			ps->flowcontrol.smac.addr[2];
-
-		vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, 
-				M2_MAC_HIGH_ADDR, mac_addr_high_reg);
-		vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, 
-				M2_MAC_LOW_ADDR, mac_addr_low_reg);
-
-		if (ps->flowcontrol.obey) {
-			SET_BIT( pause_reg_value, 17);
-		}
-		if (ps->flowcontrol.generate) {
-			SET_BIT( pause_reg_value, 16);
-		}
-
-
-	}
-
-
-	if( ps->enable_tx_pause_xon_xoff == TRUE) {
-		SET_BIT( pause_reg_value, 18);
-	}
-
-	/*  TX pause value */
-	SET_BITS_MASKED( pause_reg_value, ps->tx_pause_value,
-			VTSS_PORT_10G_TX_PAUSE_MASK);
-	vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_PAUSE, pause_reg_value);
-
-
-	/* maxframelength */
-	SET_BITS_MASKED( max_len_reg_value, ps->maxframelength, 
-			VTSS_MAX_FRAME_LENGTH_MASK);
-
-	vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MAX_LEN, max_len_reg_value);
-
-
-
-	/* -------------------  NORMALIZER  ------------------------- */
-	/* RxChainMode must be set in the system block */
-
-	/* 10G port always reads data from the FIFO (i.e. in egress direction) on 
-	   frame-interleaved basis, thus normalised header is needed */
-	/* Chip major mode must be defined at this point */
-	hdr.use_norm_hdr = TRUE;
-	hdr.use_prm_hdr = FALSE;
-	//VTSS_ASSERT( VTSS_OK == vtss_hdr_expect( TRUE, hdr));
-
-	reg_value = reg_mask =  0;
-	if ( ps->norm_hdr_insert == TRUE ) {
-		SET_BIT(reg_value, 1); /* NH bit */
-		/* NLE must be cleared */
-	} else {
-		/* witout normalized header NLE must be set */
-		SET_BIT(reg_value, 2);
-	}
-	SET_BIT(reg_mask, 1); /* NH bit */
-	SET_BIT(reg_mask, 2); /* NLE bit */
-
-	if ( ps->prm_hdr_insert == TRUE) {
-		SET_BIT( reg_value, 0);
-	}
-	SET_BIT( reg_mask, 0);
-
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_NORMALIZER,
-			reg_value, reg_mask);
-
-
-	/* -------------------  XAUI  ------------------------- */
-
-
-	/* Power-up control */
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_XAUI_CONF_B,
-			0x4, 0x7);
-
-
-	/* Reset the block */
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_XAUI_CONF_A,
-			(ulong)1<<31, (ulong)1<<31);
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_XAUI_CONF_A,
-			0, (ulong)1<<31);
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_XAUI_CONF_A,
-			(ulong)1<<31, (ulong)1<<31);
-
-	return VTSS_OK;
-}
-
-
-/* 
-   Supplementary function: fills the structure referenced by the pointer 
-   with the default values for a given major_mode.
- */
-vtss_rc vtss_10Gport_setup_get_default_values( vtss_10Gport_setup_t* psetup,
-		vtss_mac_major_mode_t major_mode)
-{
-	vtss_mac_t smac_addr = {{0,0,0,0,0,0}};
-
-	switch ( major_mode) {
-		/* Suppported modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:      /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
-			break;
-
-			/* Wrong mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-	psetup->interface_mode.interface_type = VTSS_PORT_INTERFACE_XAUI;
-	psetup->interface_mode.speed          = VTSS_SPEED_10G;
-
-
-	psetup->flowcontrol.obey     = TRUE;
-	psetup->flowcontrol.generate = TRUE;
-	psetup->flowcontrol.smac     = smac_addr;
-
-
-	psetup->enable_tx_pause_xon_xoff = TRUE;
-	psetup->tx_pause_value           = VTSS_PORT_10G_TX_PAUSE_VALUE;
-
-
-	psetup->maxframelength = VTSS_MAX_FRAME_LENGTH; /* Max frame length. */
-
-	psetup->vlan_aware = FALSE;
-	psetup->pace_mode = FALSE;
-	psetup->drop_on_length_error = FALSE;
-	psetup->drop_in_range_error = FALSE;
-
-	psetup->fcs_modify = VTSS_FCS_DO_NOTHING;
-
-	psetup->ext_eop_check_enable = FALSE;
-	psetup->ext_sop_check_enable = FALSE;
-
-
-
-	switch ( major_mode) {
-		/* Suppported modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:      /* SPI4 <-> 1x10G */
-			psetup->norm_hdr_insert = FALSE;
-			psetup->prm_hdr_insert = FALSE;
-			psetup->norm_hdr_expect = FALSE;
-			psetup->prm_hdr_expect = FALSE;
-			psetup->sfd_check = TRUE;
-			break;
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
-			psetup->norm_hdr_insert = FALSE;
-			psetup->prm_hdr_insert = FALSE;
-			psetup->norm_hdr_expect = TRUE;
-			psetup->prm_hdr_expect = FALSE;
-			psetup->sfd_check = TRUE;
-			break;
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
-			psetup->norm_hdr_insert = FALSE;
-			psetup->prm_hdr_insert = TRUE;
-			psetup->norm_hdr_expect = TRUE;
-			psetup->prm_hdr_expect = TRUE;
-			psetup->sfd_check = FALSE;
-			break;
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
-			psetup->norm_hdr_insert = TRUE;
-			psetup->prm_hdr_insert = FALSE;
-			psetup->norm_hdr_expect = TRUE;
-			psetup->prm_hdr_expect = FALSE;
-			psetup->sfd_check = TRUE;
-			break;
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
-			psetup->norm_hdr_insert = TRUE;
-			psetup->prm_hdr_insert = TRUE;
-			psetup->norm_hdr_expect = TRUE;
-			psetup->prm_hdr_expect = TRUE;
-			psetup->sfd_check = FALSE;
-			break;
-
-			/* Wrong mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-	return VTSS_OK;
-
-}
-
-
-/*----------------  Run-time funcitons  ---------------------------------------*/
-/* Enable/disable rx, tx or both in a 10G port */
-vtss_rc vtss_10Gport_set_enable( vtss_port_no_t port_num, 
-		BOOL rx_en, BOOL tx_en)
-{
-
-	ulong mode_cfg_reg = 0;
-	ulong mode_cfg_reg_mask = 0x3; /* two bits are affected */
-
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-
-	/* check for appropriate major mode */
-	switch ( pvds->mmode) {
-		/* Suppported modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:      /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
-			break;
-
-			/* Undefined major mode */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-			/* Wrong mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	if(rx_en) {
-		SET_BIT(mode_cfg_reg, 1);
-	}
-	if(tx_en) {
-		SET_BIT(mode_cfg_reg, 0);
-	}
-
-
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MISC_10G, 
-			mode_cfg_reg, mode_cfg_reg_mask);
-
-
-	return VTSS_OK;
-}
-
-
-/* Set CRC adding/updating mode */
-vtss_rc vtss_10Gport_fcs_modify( vtss_port_no_t port_num, vtss_fcs_modify_t mc)
-{
-
-	ulong denorm_reg = 0;
-	ulong denorm_reg_mask = (1<<5)|(1<<4);
-
-	/* Check for the right major mode */
-	/* TBD */
-
-	/* Meigs2 has two independent bits: UPDATE and ADD, which should always have
-	   opposite values */
-	switch ( mc) {
-		case  VTSS_FCS_DO_NOTHING:
-			break;
-		case VTSS_FCS_UPDATE:
-			SET_BIT( denorm_reg, 5);
-			CLR_BIT( denorm_reg, 4);
-			break;
-		case VTSS_FCS_ADD:
-			SET_BIT( denorm_reg, 4);
-			CLR_BIT( denorm_reg, 5);
-			break;
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_DENORM, 
-			denorm_reg, denorm_reg_mask);
-
-
-	return VTSS_OK;
-
-}
-
-
-/* Allow pause frames pass through the device. By default 10G block
-   prevents propagation of pause frames through the device.
- */
-vtss_rc vtss_10Gport_forward_pause_frames( vtss_port_no_t port_num, BOOL allow)
-{
-
-	/*!!! DROP_PAUSE bit (bit #5) is different from its counterpart in 1G ports*/
-	ulong norm_reg = (allow)?0:(1<<5);
-	ulong norm_reg_mask = 1<<5;
-
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_NORMALIZER, 
-			norm_reg, norm_reg_mask);
-	return VTSS_OK;
-}
-
-/*
-   obey -- obeys pause frames from external Eth client 
-   generate -- generate pause frames/backpressure upon request from the 
-   destination (FIFO or the host interface)
-
-   If fc_obey AND fc_generate are set to FALSE, then flow control is disabled
-
-
- */
-vtss_rc vtss_10Gport_flow_control_mode( vtss_port_no_t port_num, 
-		BOOL fc_obey, 
-		BOOL fc_generate)
-{
-	ulong pause_reg_value = 0;
-	ulong pause_reg_mask = ((ulong)1<<16)|(1<<17);
-
-
-
-	if (fc_obey) {
-		SET_BIT( pause_reg_value, 17);
-	} 
-
-	if (fc_generate) {
-		SET_BIT( pause_reg_value, 16);
-	}
-
-	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_PAUSE, 
-			pause_reg_value, pause_reg_mask);
-
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-
-  Function   vtss_10Gport_signal_detect
-
-  ================================================================================
-
-Description:
-Once a 10G Base-X optical module is connected to the XAUI port,
-this function can use to drive an GPIO connected LED to visualize 
-signal detection/link status. The CPU must poll this function.
-
-Syntax
-
-Arguments: None
-
-Return code: TRUE/FALSE
-
- *******************************************************************************/
-BOOL vtss_10Gport_signal_detect(void)
-{
-	ulong mac_tx_sticky_value = 0;
-
-	/* Clear sticky-bits in MAC_TX_STICKY */
-	vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MAC_TX_STICKY, 0x1f);
-	mac_tx_sticky_value = vtss_io_read( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MAC_TX_STICKY);
-
-	return (mac_tx_sticky_value & ((ulong)1 << 4))?(FALSE):(TRUE);
-}
-
-
-/*******************************************************************************
-
-  Function   
-
-  ================================================================================
-
-Description:
-Works in the direction from MAC to FIFO.
-
-Syntax
-
-Arguments:
-hdr   normalized header/preamble header structure
-
-Return code:
-
- *******************************************************************************/
-static void vtss_port10G_header_insert( BOOL enable, const m2_header_t hdr)
-{
-	ulong reg = 0, reg_mask = 0;
-
-	if ( hdr.use_norm_hdr) {
-
-		if( enable == TRUE) {
-			SET_BIT( reg, 1);
-			/* Normalized header requires the NLE bit set */
-			SET_BIT( reg, 2);
-		}
-
-		SET_BIT( reg_mask,1);
-		SET_BIT( reg_mask,2);
-	}
-
-
-	if ( hdr.use_prm_hdr) {
-		if ( enable == TRUE)
-			SET_BIT( reg, 0);
-
-		SET_BIT( reg_mask, 0);
-	}
-
-
-	/* If any changes, write to the register */
-	if( reg_mask) {
-		vtss_io_writemasked( M2_BLK_MACS, M2_PHYS_PORT_10G, M2_NORMALIZER, 
-				reg, reg_mask);
-	}
-
-	return;
-}
-
-/*******************************************************************************
-
-  Function   
-
-  ================================================================================
-
-Description:
-FIFO -> MAC
-
-Syntax
-
-
-
-Arguments:
-ppn   physical port (port-on-chip)
-hdr   normalized header/preamble header structure
-
-
-Return code:
-
- *******************************************************************************/
-#if 0 
-static void vtss_port10G_header_expect( BOOL enable, const m2_header_t hdr)
-{
-	ulong reg = 0, reg_mask = 0;
-
-	if ( hdr.use_norm_hdr) {
-		if (enable == TRUE) {
-			SET_BIT( reg,1);
-		}
-
-		SET_BIT( reg_mask,1);
-	}
-
-	if ( hdr.use_prm_hdr) {
-		if (hdr.use_prm_hdr == TRUE)
-			SET_BIT( reg, 0);
-
-		SET_BIT( reg_mask, 0);
-	}
-
-	if( reg_mask != 0) {
-		vtss_io_writemasked( M2_BLK_MACS, M2_PHYS_PORT_10G, M2_DENORM, 
-				reg, reg_mask);
-	}
-
-	return;
-}
-#endif
-
-/******************************************************************************
- *                                                                            *
- *       SPI4.2 Setup                                                         *
- *                                                                            *
- ******************************************************************************/
-
-
-/******************************************************************************
- *
- * Description: Set up the SPI4.2 block 
- *
- * \param:      ps       Pointer to a structure which determines configuration
- *
- * \return:     VTSS_OK  Operation completed successfully.
- *              VTSS_WRONG_MAJOR_MODE
- *              VTSS_MAJOR_MODE_NOT_SET
- *              VTSS_WRONG_PARAMETER
- *
- **************************************************************************kbp*/
-vtss_rc vtss_spi4_setup( vtss_spi4_setup_t* ps)
-{
-	ulong reg  = 0;
-	ulong mask = 0;
-	ulong active_ports = 0;
-	ulong pll_clk_speed = 0;
-	int i;
-	m2_header_t hdr;
-	BOOL hdr_present;
-
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	switch ( pvds->mmode) {
-		/* valid major modes */
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:  /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK: /* */
-			break;
-
-			/* Error - major mode undefined */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-			/* Error - wrong major mode */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:  /* Single Chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* Single Chip trunking */
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-
-	/* Burst size from ingress FIFO -> SPI4 */
-	reg = ps->burst_size & 0xF;
-
-	/* Selection between burst or frame interleaved scheduling
-	   is done in the ingress FIFO: CM bit in ing_ctrl_reg */
-	hdr.use_norm_hdr = TRUE; hdr.use_prm_hdr = FALSE;
-	switch ( ps->sch_mode) {
-#if !defined MEIGS2 && !defined VSC7321
-		case VTSS_SPI4_BURST_MODE_WITH_HEADER:
-			vtss_hdr_insert( TRUE, hdr);
-			SET_BIT( reg, 4); /* set CM bit */
-			break;
-#endif
-		case VTSS_SPI4_BURST_MODE:
-			SET_BIT( reg, 4); /* set CM bit */
-			break;
-		case VTSS_SPI4_FRAME_MODE:
-			CLR_BIT( reg, 4); /* clear CM bit */
-			vtss_hdr_insert( TRUE, hdr);
-			break;
-		default:
-			return VTSS_WRONG_PARAMETER;
-	}
-	/* Write to ingress fifo control register */
-	vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_ING_CONTROL, reg, 0x1F);
-
-
-	/* Set-up Header Stripper located before Ingress SPI4.2 */
-	if( ps->norm_hdr_strip == FALSE) {
-		vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_IFACE_MODE, 0, (ulong)1<<4);
-	} else {
-		vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_IFACE_MODE, (ulong)1<<4, (ulong)1<<4);
-	}
-
-
-	/* Set-up FCS/CRC-32 Checker located after Egress SPI4.2 */
-	if ( ps->norm_hdr_expect != FALSE) {
-		hdr_present = TRUE;
-		if ( ps->prm_hdr_expect != FALSE) {
-			reg = 0x0; /* hdr_size = 16 bytes */
-		} else {
-			reg = 0x9; /* hdr_size = 9 bytes */
-		}
-	} else {
-		if ( ps->prm_hdr_expect != FALSE) {
-			hdr_present = TRUE;
-			reg = 0x7; /* hdr_size = 7 bytes */
-		} else {
-			hdr_present = FALSE; /* no header */
-			reg = 0x0; /* hdr_size = 0 bytes */
-		}
-	}
-	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_CRC_CFG,
-			((hdr_present)?((ulong)1<<4):0) | reg, 0x1F);
-
-
-	/******************    SPI4  MISC register  setup    ************************/
-
-	/* SPI4 output frequency 390(default), 312, 195, 156 MHz */
-	reg = 0x1; mask = 0x11;
-	switch ( ps->spi4_output_freq) {
-		case VTSS_SPI4_OUTPUT_FREQ_390MHZ:
-			SET_BIT( pll_clk_speed, 0);
-			break;
-#if defined MEIGS2 || defined VSC7321
-		case VTSS_SPI4_OUTPUT_FREQ_312MHZ:
-			break;
-		case VTSS_SPI4_OUTPUT_FREQ_156MHZ:
-			SET_BIT( reg, 4);
-			break;
-#endif
-		case VTSS_SPI4_OUTPUT_FREQ_195MHZ:
-			SET_BIT( pll_clk_speed, 0);
-			SET_BIT( reg, 4);
-			break;
-		default:
-			return VTSS_WRONG_PARAMETER;
-	}
-	/* Select SPI4 clock source from either SerDes or XAUI PLL */
-	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_PLL_CLK_SPEED, 
-			pll_clk_speed, 0x1);
-
-
-	/* 1. Power-up CML logic
-	   2. Release reset on CML logic and set-up RQC
-
-	   3. Set-up rest
-	   Always assert bit 18, SD; spi4_swap_bytes in order to be spi4 compliant
-	   Always de-assert bits 29-31: SPI clock reset bits */
-
-	/* Power-up CML logic */
-	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_MISC, reg, mask);
-
-	/* Set-up RQC. Board dependent. */
-	if ( ps->spi4_data_clock_skew != FALSE)  { SET_BIT( reg, 2); }
-	SET_BIT( mask, 2);
-
-	/* Release reset on CML logic */
-	SET_BIT( reg, 3); SET_BIT( mask, 3);
-
-	/* Release reset on CML logic and set-up RQC */
-	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_MISC, reg, mask);
-
-	/* Bit SD. Swap bytes in order to be spi4 compliant */
-	SET_BIT( reg, 18); SET_BIT( mask, 18);
-
-	/* Enable all clocks */
-	SET_BITS_MASKED( mask, (ulong)7<<29, (ulong)7<<29);
-
-	/* Bit WI. Board dependent. */
-	if ( ps->spi4_swap_ingress_data != FALSE) { SET_BIT( reg, 9); }
-	SET_BIT( mask, 9);
-
-	/* Bit WE. Board dependent. */
-	if ( ps->spi4_swap_egress_data != FALSE) { SET_BIT( reg, 8); }
-	SET_BIT( mask, 8);
-
-	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_MISC, reg, mask);
-
-
-	/******************    SPI4_ING_SETUP0 register setup   *********************/
-
-	/* Calendar length is defined by number of ports. Calculate active ports */
-	for(i=0; i<VTSS_PORT_ARRAY_SIZE; i++) {
-		ulong ppn = vtss_logical_ports[i].chip_port;
-		if ( ppn != -1) {
-			SET_BIT(active_ports, ppn);
-		}
-	}
-	/* Setup active ports, kbp_test: active_ports = 0x3FF;*/
-	reg = active_ports & 0x3FF; mask = 0x3FF;
-
-	/* SPI4_calendar_order */
-	if ( ps->spi4_calendar_order_ascending == FALSE) { SET_BIT( reg, 10); }
-	SET_BIT( mask, 10);
-
-	/* SPI4_calendar_m */
-	SET_BITS_MASKED( reg, (ulong)(ps->spi4_calendar_m)<<12, 0xF<<12);
-	SET_BITS_MASKED( mask, 0xF<<12, 0xF<<12);
-
-	/* write to spi4_ingress_setup0_reg register */
-	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_ING_SETUP0, reg, mask);
-
-
-	/******************    SPI4_ING_SETUP1 register setup   *********************/
-
-	/* kbp: Where do we set-up this ?
-#if defined MEIGS2 || defined VSC7321
-ps->tm = VTSS_SPI4_TRAINING_OFF;
-#else
-ps->tm = VTSS_SPI4_TRAINING_AUTO;
-#endif
-	 */
-
-	/* Parameters of the training mode (only in ingress direction) */
-	vtss_io_write( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_ING_SETUP1,
-			(ps->alpha<<16) | (ps->tsperiod));
-
-
-	/******************    SPI4_ING_SETUP2 register setup   *********************/
-
-	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_ING_SETUP2,
-			(ps->maxburst2<<24) | (ps->maxburst1<<16) | ps->burst_size, 
-			0xFFFF000F);
-
-
-	/******************    SPI4_EGR_SETUP0 register setup   *********************/
-
-	/* Setup active ports */
-	reg = active_ports & 0x3FF; mask = 0x3FF;
-
-	/* Shift status clock output. Board dependent. */
-	if ( ps->spi4_status_clock_skew != FALSE) { SET_BIT( reg, 18); }
-	SET_BIT( mask, 18);
-
-	/* SPI4_calendar_order */
-	if ( ps->spi4_calendar_order_ascending == FALSE) { SET_BIT( reg, 10); }
-	SET_BIT( mask, 10);
-
-	/* SPI4_calendar_m */
-	SET_BITS_MASKED( reg, (ulong)(ps->spi4_calendar_m)<<12, 0xF<<12);
-	SET_BITS_MASKED( mask, 0xF<<12, 0xF<<12);
-
-	/* write to spi4_egress_setup0_reg register. */
-	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_EGR_SETUP0, reg, mask);
-
-
-	return VTSS_OK;
-}
-
-
-/******************************************************************************
- *
- * Description: Configures a user provided structure with default values for
- *              the selected major mode.
- *
- * \param:      ps       Pointer to a structure which determines configuration
- *              mode     Major mode
- *
- * \return:     VTSS_OK  Operation completed successfully.
- *              VTSS_MAJOR_MODE_NOT_SET
- *
- **************************************************************************kbp*/
-vtss_rc vtss_spi4_setup_get_default_values( vtss_spi4_setup_t* ps, 
-		vtss_mac_major_mode_t mode)
-{
-
-	/* By default in the ingress direction SPI4.2 runs in burst interleaved mode*/
-	ps->sch_mode   = VTSS_SPI4_BURST_MODE;
-	ps->burst_size = VTSS_SPI4_BURST_SIZE;
-	ps->maxburst1  = VTSS_SPI4_MAX_BURST_1;
-	ps->maxburst2  = VTSS_SPI4_MAX_BURST_2;
-
-
-	/* Parameters of the training mode (only in ingress direction) */
-#if defined MEIGS2 || defined VSC7321
-	ps->tm = VTSS_SPI4_TRAINING_OFF;
-#else
-	ps->tm = VTSS_SPI4_TRAINING_AUTO;
-#endif
-	ps->alpha    = 1;
-	ps->tsperiod = 0;
-
-	/* spi4 output frequency: 390(default), 312, 195, 156 MHz */
-	ps->spi4_output_freq = VTSS_SPI4_OUTPUT_FREQ_390MHZ;
-
-	/* For the description of the following four elements refer to the desription 
-	   of the SPI4 misc register in the datasheet */
-	ps->spi4_swap_ingress_data = FALSE;  /* Board dependent */ /* Bit WI, SPI4 MISC reg*/
-	ps->spi4_swap_egress_data  = FALSE;  /* Board dependent */ /* Bit WE, SPI4 MISC reg*/
-	ps->spi4_data_clock_skew   = FALSE;  /* Board dependent */
-	ps->spi4_status_clock_skew = FALSE;  /* Board dependent */
-
-	/* calendar length is defined by number of ports */
-	ps->spi4_calendar_order_ascending = TRUE;
-	ps->spi4_calendar_m = 1;
-
-	/* normalized and preamble headers */
-	/* ingress direction: strip the norm header before sending it over SPI4 */
-	/* if normalization is not used (i.e there is no header to strip) this 
-	   parameter must be set to FALSE */
-	ps->norm_hdr_strip = FALSE;
-
-
-	/* egress direction: expect/do not expect headers  */
-	switch (mode) {
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:  /* SPI4 <-> 10x1G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
-			ps->prm_hdr_expect = FALSE;
-			ps->norm_hdr_expect = FALSE;
-			break;
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-			ps->prm_hdr_expect = FALSE;
-			ps->norm_hdr_expect = TRUE;
-			break;
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK: /* */
-			ps->prm_hdr_expect = TRUE;
-			ps->norm_hdr_expect = TRUE;
-			break;
-		default:
-			/* VTSS_MAC_MAJOR_MODE_10G_1G_AGGR  - Single Chip aggr */
-			/* VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK - Single Chip trunking */
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-
-  Function  vtss_spi4_fcs_check_enable()
-  ================================================================================
-
-Description:
-The function turns on/off FCS check of Ethernet frames arriving from the 
-host interface. This is done for all channels simultaneously.
-
-
-NOTE. FCS check in the SPI4 block must be OFF, if FCS will be modified
-(added/updated) in Ethernet port(s) in the egress direction
-
-Syntax
-vtss_rc vtss_spi4_fcs_check_enable( BOOL check_fcs);
-
-Arguments:
-check_fcs    TRUE  -- turns FCS check ON
-FALSE -- turns FCS check OFF
-
-Return code:
-VTSS_OK   if operation completed successfully
-
- *******************************************************************************/
-vtss_rc vtss_spi4_fcs_check_enable( BOOL check_fcs)
-{
-	ulong fcs = 0;
-
-	if (check_fcs) {
-		/* CLR_BIT(fcs,5); Already cleared */
-	} else {
-		/*ignore fcs check*/
-		SET_BIT(fcs,5);
-	}
-
-	vtss_io_writemasked(M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_CRC_CFG,
-			fcs, 1<<5);
-
-	return VTSS_OK;
-}
-
-
-
-
-/*******************************************************************************
-
-  Function  vtss_spi4_keep_norm_header()
-  ================================================================================
-
-Description:
-The function controls whether to strip the normalised header or to keep it.
-Usually the normalised header is stripped before the frame is sent over 
-SPI4. However, if the remove receiver can use information in the header, 
-keeping it may be an advantage.
-
-
-NOTE. Works in ingress direction
-
-Syntax
-vtss_rc vtss_spi4_keep_norm_header( BOOL keep);
-
-Arguments:
-keep     TRUE  -- the noramlised header is not stripped
-FALSE -- the noramlised header is stripped (Default)
-
-Return code:
-VTSS_OK   if operation completed successfully
-
- *******************************************************************************/
-vtss_rc vtss_spi4_keep_norm_header( BOOL keep)
-{
-	ulong reg_value = 0, reg_mask = 0;
-
-
-	if ( keep == TRUE)
-		SET_BIT( reg_value, 4);
-
-	SET_BIT( reg_mask, 4);
-
-	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_IFACE_MODE, 
-			reg_value, reg_mask);
-
-	return VTSS_OK;
-}
-
-
-/******************************************************************************/
-/***        Flow Control Configuration        *********************************/
-/******************************************************************************/
-
-/* 
-
-   transparent off -- filling of the FIFO causes generation of pause frames
-   transparent on  -- destination (host i/f), not FIFO, requests pause frames
-
-Note:
-
- */
-/*******************************************************************************
-
-  Function 
-  ================================================================================
-
-Description:
-Function vtss_device_transparent_flow_control_mode() selects FIFO flow 
-control mode 
-
-NOTE: 
-This mode is enabled for all 10/100/1000 Eth ports simultaneously.
-This functions does not set RX_PAUSE or TX_PAUSE bits in 1G port blocks,
-the user need to do it after calling this function.
-
-
-Syntax
-vtss_rc vtss_device_transparent_flow_control_mode( BOOL ingress_enable,
-BOOL egress_enable);
-
-
-Arguments:
-ingress_enable      when set to TRUE, SPI4.2 flow control signals will 
-cause generation of Ethernet flow control frames
-egress_enable       when set to TRUE, Ethernet flow control frames will
-translate to SPI4.2 flow control signals
-
-Return code:
-VTSS_OK   if operation completed successfully
-
- *******************************************************************************/
-vtss_rc vtss_device_transparent_flow_control_mode( BOOL ingress_enable,
-		BOOL egress_enable)
-{
-	ulong gress_ctrl_reg = 0;
-	ulong gress = M2_SUBBLK_INGRESS;
-
-
-	if (ingress_enable) {
-		SET_BIT( gress_ctrl_reg, 11); /* IPT bit */
-		SET_BIT( gress_ctrl_reg, 12); /* IGI bit */
-	} 
-	vtss_io_writemasked(M2_BLK_FIFO, gress, M2_ING_CONTROL,
-			gress_ctrl_reg, (1<<11)|(1<<12));
-
-
-	gress_ctrl_reg = 0;
-	gress = M2_SUBBLK_EGRESS;
-
-	if (egress_enable) {
-		/* In egress direction use the MFE bit, not IPT/IGI */
-		SET_BIT( gress_ctrl_reg, 15);
-	}
-	vtss_io_writemasked(M2_BLK_FIFO, gress, M2_EGR_CONTROL,
-			gress_ctrl_reg, 1<<15);
-
-	/* Remember to set RX_PAUSE_EN, TX_PAUSE_EN or PAUSE_EN bits in the PAUSE_CFG 
-	   register of 1G ports */
-
-
-	return VTSS_OK;
-}
-
-
-
-
-/******************************************************************************/
-/***        FIFO Configuration                       **************************/
-/******************************************************************************/
-
-
-/*-----------------  FIFO setup funcitons   ----------------------------------*/
-
-
-/*******************************************************************************
-
-  Function vtss_fifo_setup()
-  ================================================================================
-
-Description:
-Initializes the FIFO block based on the information in the provided 
-structures. If the pointer to the structure is set to NULL, the corresponding
-FIFO will not be initialized (it will be left in its current state).
-
-The function must be called after start-up and may be called at run-
-time to reconfigure the FIFO. 
-
-NOTE: port mapping table must be initialized.
-
-
-Syntax
-vtss_rc vtss_fifo_setup( vtss_fifo_setup_t *ps_ingress, 
-vtss_fifo_setup_t *ps_egress)
-
-Arguments:
-ps_ingress   pointer to a structure for the ingress fifo
-ps_egress   pointer to a structure for the egress fifo
-
-Return code:
-VTSS_OK   if operation completed successfully
-VTSS_MAJOR_MODE_NOT_SET
-
- *******************************************************************************/
-
-vtss_rc vtss_fifo_setup( vtss_fifo_setup_t *ps_ingress, 
-		vtss_fifo_setup_t *ps_egress)
-{
-	int i, ppn;
-	ulong reg, mask;
-
-	/* Only one global device per API is currently supported */
-	vtss_device_setup_t *pvds = pdevice;
-	if ( pvds->mmode == VTSS_MAC_MAJOR_MODE_UNDEFINED) { return VTSS_MAJOR_MODE_NOT_SET; }
-
-	for ( i=1; i<=VTSS_PORTS_1G; i++) {
-
-		ppn = vtss_logical_ports[i].chip_port;
-		//    VTSS_N(("FIFO setup: log port#%d, phys port #%d", i, ppn));
-		//printk("FIFO setup: log port#%d, phys port #%d\n", i, ppn);
-		if( ppn < 0 ) { continue; }
-
-		/* Clear pointer mode when changing top/bottom */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
-				M2_TEST + ppn, M2_TEST_FIFO_CLR, 0xF);
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-				M2_TEST + ppn, M2_TEST_FIFO_CLR, 0xF);
-
-		/* TOP and BOTTOM values */
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_TOP_BOTTOM + ppn, 
-				(ulong)((ps_ingress->fifo_port_area[i].top<<16) | 
-					ps_ingress->fifo_port_area[i].bottom));
-
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TOP_BOTTOM + ppn, 
-				(ulong)((ps_egress->fifo_port_area[i].top<<16) | 
-					ps_egress->fifo_port_area[i].bottom));
-
-		/* Watermarks */
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_HIGH_LOW_WM + ppn, 
-			(ulong)((ps_ingress->fifo_port_wm[i].low_watermark<<16) | 
-					ps_ingress->fifo_port_wm[i].high_watermark));
-
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_HIGH_LOW_WM + ppn, 
-			(ulong)((ps_egress->fifo_port_wm[i].low_watermark<<16) | 
-				ps_egress->fifo_port_wm[i].high_watermark));
-
-		/* Threshold, if cut-through mode enabled */
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_CT_THRHLD + ppn, 
-				(ulong)((ps_ingress->thrhld[i].cut_through_enable)?
-					ps_ingress->thrhld[i].threshold_value:0));
-
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_CT_THRHLD + ppn, 
-				(ulong)((ps_egress->thrhld[i].cut_through_enable)?
-					ps_egress->thrhld[i].threshold_value:0));
-
-		/* Enable FIFO again */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
-				M2_TEST + ppn, M2_TEST_FIFO_NORMAL, 0xF);
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-				M2_TEST + ppn, M2_TEST_FIFO_NORMAL, 0xF);
-	}
-
-	/* Ageing */
-	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_AGE_INC,
-		 (ps_ingress->ageing.enable)? ps_ingress->ageing.interval:0);
-	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_AGE_INC, 
-			(ps_egress->ageing.enable)? ps_egress->ageing.interval:0);
-
-	/* --- Ingress FIFO control register setup (major mode dependent) --- */
-	reg = 0;
-	if( ps_ingress->prm_hdr_used != FALSE) { SET_BIT( reg, 9); }
-
-	if( ps_ingress->norm_hdr_used != FALSE) {
-		SET_BIT( reg, 8);
-		/* Ingress FIFO gets data only from MACs thus bit 
-		   LE must always be set when the normalized header is used */
-		SET_BIT( reg, 13);
-	}
-
-	/* OUT_PORT_OFFSET */
-	reg  |= (ps_ingress->output_port_offset<<28) & 0xF0000000;
-
-	/* IN_PORT_OFFSET */
-	reg  |= (ps_ingress->input_port_offset<<24) & 0x0F000000;
-
-	/* Single Channel, M10G mode */
-	if (pvds->mmode == VTSS_MAC_MAJOR_MODE_SPI4_10G){ SET_BIT( reg, 5); }
-
-	/* Ingress FIFO by default is always set to run in burst-interleaved mode */
-	SET_BIT( reg, 4);
-
-	/* MUX bits, SS bit and burst size */
-	if ( (pvds->mmode == VTSS_MAC_MAJOR_MODE_10G_1G_AGGR) ||
-			(pvds->mmode == VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK)) {
-		/* if Single Chip aggr or single chip trunking */
-		SET_BIT( reg, 16);
-		SET_BIT( reg, 7);
-		/* burst size towards 1G ports */
-		SET_BITS_MASKED( reg, 
-			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_1G_PORT, 0xF);
-	} else {
-		/* burst size towards SPI4.2 */
-		SET_BITS_MASKED( reg, 
-			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_SPI4_2, 0xF); 
-	}
-
-	/* Enable the FIFO */
-	CLR_BIT( reg, 6);
-
-	mask = 0xFF0323FF;
-	vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
-		M2_ING_CONTROL, reg, mask);
-
-
-	/* --- Egress FIFO control register setup (major mode dependent) --- */
-	reg = 0;
-	if( ps_egress->prm_hdr_used != FALSE) { SET_BIT( reg, 9); }
-
-	if( ps_egress->norm_hdr_used != FALSE) {
-		SET_BIT( reg, 8);
-		/* Single Chip aggr o trunking */
-		if( ( pvds->mmode == VTSS_MAC_MAJOR_MODE_10G_1G_AGGR) || 
-			( pvds->mmode == VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK)) {
-			/* Receiving data from 1G MACs in SMES mode */
-			SET_BIT( reg, 13);
-		} else {
-			/* Receiving data from SPI4.2 always SME mode */
-			CLR_BIT( reg, 13);
-		}
-	}
-
-	/* OUT_PORT_OFFSET */
-	reg  |= (ps_egress->output_port_offset<<28) & 0xF0000000;
-
-	/* IN_PORT_OFFSET */
-	reg  |= (ps_egress->input_port_offset<<24) & 0x0F000000;
-
-	switch (pvds->mmode) {
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:       /* SPI4 <-> 1x10G */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK: /* */
-			CLR_BIT( reg, 17);
-			CLR_BIT( reg, 16); /* MUX bits */
-			CLR_BIT( reg, 7); /* SS bit */
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:        /* SPI4 <-> 10x1G */
-			CLR_BIT( reg, 17);
-			SET_BIT( reg, 16); /* MUX bits */
-			SET_BIT( reg, 7); /* SS bit */
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:    /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:   /* single chip trunking */
-			SET_BIT( reg, 17);
-			CLR_BIT( reg, 16); /* MUX bits */
-			CLR_BIT( reg, 7); /* SS bit */
-			break;
-
-		default:
-			break;
-	}
-
-	/* Activate the FIFO */
-	CLR_BIT( reg, 6);
-
-	/* Frame-, burst- interleaving and burst size */
-	switch (pvds->mmode) {
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:  /* Single Channel, M10G mode */
-			/* Egress FIFO sends data to 10G MAC from onei
-			 channel burst-interleaved is fine */
-			SET_BIT( reg, 4);
-			SET_BIT( reg, 5);
-			SET_BITS_MASKED( reg, 
-			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_10G_PORT, 0xF);
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:   /* */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:     /* Single Chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:    /* Single Chip trunking */
-			/* Egress FIFO sends data to 10G MAC 
-			from upto 10 channels always frame-interleaved */
-			CLR_BIT( reg, 4);
-			/* It's recommended to write a value into the 
-			   burst size bitfield even  when running in frame-interleaved
-			     mode */
-			SET_BITS_MASKED( reg, 
-			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_10G_PORT, 0xF);
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
-			/* Egress FIFO sends data to 1G MACs from upto
-			 10 channels always burst-interleaved */
-			SET_BIT( reg, 4);
-			SET_BITS_MASKED( reg,
-			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_1G_PORT, 0xF);
-			break;
-
-		default:
-			break;
-	}
-
-	mask = 0xFF0323FF;
-	vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-				M2_EGR_CONTROL, reg, mask);
-
-	return VTSS_OK;
-}
-
-
-/******************************************************************************
- * Description:
- *     This is a supplementary function. It configures a structure referenced 
- *     by the pointer to the default values for the chosen major mode.
- *     After that the user may modify the fields of the structure for 
- *     fine-tuning of the system and then call the vtss_fifo_setup() function.
- *
- * Arguments:
- *     ps_ingress   pointer to a structure for the ingress fifo
- *     ps_egress    pointer to a structure for the egress fifo
- *     major_mode   select the major mode  for the session
- *
- * Return code:
- *     VTSS_OK      if operation completed successfully
- *     VTSS_WRONG_MAJOR_MODE
- *     VTSS_PORT_NOT_MAPPED
- *
- **************************************************************************kbp*/
-vtss_rc vtss_fifo_setup_get_default_values( vtss_fifo_setup_t *ps_ingress,
-		vtss_fifo_setup_t *ps_egress,
-		vtss_mac_major_mode_t major_mode)
-{
-	uint  i;
-	uint  ports = 0;
-	uint  ingress_tb = 0;
-	uint  egress_tb  = 0;
-	ulong fifo_ingress_block_size = 0x0; 
-	ulong fifo_egress_block_size  = 0x0; 
-
-	switch (major_mode) {
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:   /* SPI4 <-> 1x10G */
-			ps_ingress->prm_hdr_used = FALSE;
-			ps_ingress->norm_hdr_used = FALSE;
-			ps_egress->prm_hdr_used = FALSE;
-			ps_egress->norm_hdr_used = FALSE;
-
-			ps_ingress->output_port_offset = 0;
-			ps_ingress->input_port_offset = 0;
-			ps_egress->output_port_offset = 0;
-			ps_egress->input_port_offset = 0;
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
-			ps_ingress->prm_hdr_used = FALSE;
-			ps_ingress->norm_hdr_used = FALSE;
-			ps_egress->prm_hdr_used = FALSE;
-			ps_egress->norm_hdr_used = FALSE;
-
-			ps_ingress->output_port_offset = 0;
-			ps_ingress->input_port_offset = 0xA;
-			ps_egress->output_port_offset = 0xA;
-			ps_egress->input_port_offset = 0;
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
-			ps_ingress->prm_hdr_used = FALSE;
-			ps_ingress->norm_hdr_used = FALSE;
-			ps_egress->prm_hdr_used = FALSE;
-			ps_egress->norm_hdr_used = TRUE;
-
-			ps_ingress->output_port_offset = 0xA;
-			ps_ingress->input_port_offset = 0;
-			ps_egress->output_port_offset = 0;
-			ps_egress->input_port_offset = 0xA;
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
-			ps_ingress->prm_hdr_used = TRUE;
-			ps_ingress->norm_hdr_used = FALSE;
-			ps_egress->prm_hdr_used = TRUE;
-			ps_egress->norm_hdr_used = TRUE;
-
-			ps_ingress->output_port_offset = 0xA;
-			ps_ingress->input_port_offset = 0;
-			ps_egress->output_port_offset = 0;
-			ps_egress->input_port_offset = 0xA;
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
-			ps_ingress->prm_hdr_used = FALSE;
-			ps_ingress->norm_hdr_used = TRUE;
-			ps_egress->prm_hdr_used = FALSE;
-			ps_egress->norm_hdr_used = TRUE;
-
-			ps_ingress->output_port_offset = 0;
-			ps_ingress->input_port_offset = 0;
-			ps_egress->output_port_offset = 0;
-			ps_egress->input_port_offset = 0;
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
-			ps_ingress->prm_hdr_used = TRUE;
-			ps_ingress->norm_hdr_used = TRUE;
-			ps_egress->prm_hdr_used = TRUE;
-			ps_egress->norm_hdr_used = TRUE;
-
-			ps_ingress->output_port_offset = 0;
-			ps_ingress->input_port_offset = 0;
-			ps_egress->output_port_offset = 0;
-			ps_egress->input_port_offset = 0;
-			break;
-
-		default:
-			/* VTSS_MAC_MAJOR_MODE_UNDEFINED */
-			return VTSS_WRONG_MAJOR_MODE;
-	}
-
-	fifo_ingress_block_size = VTSS_MAX_INGRESS_FIFO_SIZE >> 11;
-	fifo_egress_block_size  = VTSS_MAX_EGRESS_FIFO_SIZE  >> 11;
-
-	/* Single Channel mode, 10G is logical port number 1 */
-	if (major_mode == VTSS_MAC_MAJOR_MODE_SPI4_10G) {   /* SPI4 <-> 1x10G */
-
-		/* vtss_fifo_block_t  */
-		ps_ingress->fifo_port_area[1].bottom = 0;
-		ps_ingress->fifo_port_area[1].top = fifo_ingress_block_size;
-		ps_egress->fifo_port_area[1].bottom = 0;
-		ps_egress->fifo_port_area[1].top = fifo_egress_block_size;
-
-		/* vtss_fifo_fc_watermarks_t */
-		ps_ingress->fifo_port_wm[1].low_watermark = 0xFFFFFFFF;
-		ps_ingress->fifo_port_wm[1].high_watermark = 0xFFFFFFFF;
-		ps_egress->fifo_port_wm[1].low_watermark = 0xFFFFFFFF;
-		ps_egress->fifo_port_wm[1].high_watermark = 0xFFFFFFFF;
-
-		/* cut-through mode/threshold. If not enabled then store-forward */
-		/* vtss_fifo_cut_through_mode_t */
-		ps_ingress->thrhld[1].cut_through_enable = FALSE;
-		ps_ingress->thrhld[1].threshold_value = 0;
-		ps_egress->thrhld[1].cut_through_enable = FALSE;
-		ps_egress->thrhld[1].threshold_value = 0;
-
-	} else {
-
-		/* Multi Channel mode */
-		for( i=1; i<=VTSS_PORTS_1G; i++ ) {
-			if( vtss_logical_ports[i].chip_port >= 0 ) { ports++; }
-		}
-
-		if ( ports == 0 ) { return VTSS_PORT_NOT_MAPPED; } 
-		fifo_ingress_block_size = fifo_ingress_block_size / ports;
-		fifo_egress_block_size  = fifo_egress_block_size  / ports;
-
-
-		for(i=1; i<=VTSS_PORTS_1G; i++) {
-			if( vtss_logical_ports[i].chip_port < 0 ) { continue; }
-
-			/* TOP and BOTTOM values */
-			ps_ingress->fifo_port_area[i].bottom = ingress_tb;
-			ingress_tb = ingress_tb + fifo_ingress_block_size;
-			ps_ingress->fifo_port_area[i].top = ingress_tb;
-			ps_egress->fifo_port_area[i].bottom = egress_tb;
-			egress_tb = egress_tb + fifo_egress_block_size;
-			ps_egress->fifo_port_area[i].top = egress_tb;
-			/*VTSS_D(("tb: 0x%08lX 0x%08lX", ingress_tb, egress_tb));*/
-
-			/* Watermarks */
-			ps_ingress->fifo_port_wm[i].low_watermark = 0xFFFFFFFF;
-			ps_ingress->fifo_port_wm[i].high_watermark = 0xFFFFFFFF;
-			ps_egress->fifo_port_wm[i].low_watermark = 0x40; 
-			ps_egress->fifo_port_wm[i].high_watermark = 256; 
-
-			/* cut-through mode/threshold. If not enabled then store-forward */
-			ps_ingress->thrhld[i].cut_through_enable = FALSE;
-			ps_ingress->thrhld[i].threshold_value = 0;
-			ps_egress->thrhld[i].cut_through_enable = FALSE;
-			ps_egress->thrhld[i].threshold_value = 0;
-		}
-
-	}
-
-	/* vtss_fifo_ageing_t */
-	ps_ingress->ageing.enable = FALSE;
-	ps_ingress->ageing.interval = 0;
-	ps_egress->ageing.enable = FALSE;
-	ps_egress->ageing.interval = 0;
-
-	return VTSS_OK;
-}
-
-/*-----------------  Run-time funcitons   ------------------------------------*/
-
-
-
-/*******************************************************************************
-  Function 
-  Syntax 
-  Parameters 
-
-  Returns 
-  VTSS_OK        No errors detected
-
-  Description
-
- ********************************************************************************/
-vtss_rc vtss_fifo_thrhld_set( vtss_port_no_t portnum, 
-		vtss_fifo_cut_through_mode_t *pctt_ingress,
-		vtss_fifo_cut_through_mode_t *pctt_egress)
-{
-	/* Find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-
-	/* Check the physical port number */
-	if (ppn == -1) { return VTSS_PORT_NOT_MAPPED; }
-
-	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
-			M2_CT_THRHLD + ppn, 
-			(pctt_ingress->cut_through_enable)?
-			(pctt_ingress->threshold_value):0);
-
-	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-			M2_CT_THRHLD + ppn, 
-			(pctt_egress->cut_through_enable)?
-				(pctt_egress->threshold_value):0);
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-  Function 
-  vtss_fifo_watermarks_set()
-
-  Syntax 
-  vtss_fifo_watermarks_set( vtss_port_no_t portnum,
-  vtss_fifo_fc_watermarks_t *pwm_ingress,
-  vtss_fifo_fc_watermarks_t *pwm_egress)
-  Parameters 
-  portnum        Logical port number
-  pwm_ingress    Pointer to the 'watermarks' structure in ingress direction. 
-  If set to NULL no initialization is performed.
-  pwm_egress     Pointer to the 'watermarks' structure in egress directon.
-  If set to NULL no initalization is performed
-
-  Returns 
-  VTSS_OK        No errors detected
-
-  Description
-  This function sets watermarks for a given logical port
-
- ********************************************************************************/
-vtss_rc vtss_fifo_watermarks_set( vtss_port_no_t portnum,
-		vtss_fifo_fc_watermarks_t *pwm_ingress,
-		vtss_fifo_fc_watermarks_t *pwm_egress)
-{
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_HIGH_LOW_WM + ppn, 
-			(ulong)((pwm_ingress->low_watermark<<16) |
-			 pwm_ingress->high_watermark));
-
-	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_HIGH_LOW_WM + ppn, 
-			(ulong)((pwm_egress->low_watermark<<16) |  
-			pwm_egress->high_watermark));
-
-	return VTSS_OK;
-}
-
-
-/*
-
-   Set a fifo to expect incoming data with/without the header (normalised or 
-   preamble)
-
-   The function does not check how the fifo is configured. (Note: running in 
-   cut-through mode with the header makes no sense)
-
-
-   Parameters
-   fifo      which fifo to use: engress or ingress
-   enable    enable or disable the feature
-   if TRUE,  incoming frame have normalized and/or preamble header
-   if FALSE, incoming frame co not have normalized and/or preamble 
-   header
-   hdr       Describes what header to expect
-
-Note: this function will set or clear only that bit in the register which 
-corresponding element in the 'hdr' structure is set, i.e. it will not 
-affect preamble header settings, if the use_prm_hdr element is not set.
-
- */
-static void vtss_fifo_use_hdr( int fifo, BOOL enable, m2_header_t hdr)
-{
-	ulong value = 0;
-	ulong mask = 0;
-	ulong reg_offset = 0;
-
-	switch( fifo) {
-		case M2_SUBBLK_EGRESS:
-			reg_offset = M2_EGR_CONTROL;
-			break;
-		case M2_SUBBLK_INGRESS:
-			reg_offset = M2_ING_CONTROL;
-			break;
-		default:
-			return;
-	}
-
-	if ( hdr.use_norm_hdr != FALSE) {
-		if ( enable != FALSE)
-			SET_BIT( value, 8);
-		SET_BIT( mask, 8);
-	}
-
-	if ( hdr.use_prm_hdr != FALSE){
-		if (enable != FALSE)
-			SET_BIT( value, 9);
-		SET_BIT( mask, 9);
-	}
-
-
-
-	vtss_io_writemasked( M2_BLK_FIFO, fifo, reg_offset, value, mask);
-
-	return;
-}
-
-
-#define VTSS_MIIM_READ_OPR      0x2
-#define VTSS_MIIM_WRITE_OPR     0x1
-
-#define VTSS_MIIM_OPR_MODE      0x1
-#define VTSS_MDIO_OPR_MODE      0x0
-
-
-/* Direct miim read/write operation using miim_controller address as a 
-   parameter */
-long vtss_miim_subblock_read( const uint miim_chnl, const uint phy_addr, 
-		const uint phy_reg)
-{
-	uint opcode = VTSS_MIIM_READ_OPR; /* read operation */
-	uint mode = VTSS_MIIM_OPR_MODE; /* MIIM operation, not MDIO */
-	ulong i = 0;
-	ulong data;
-
-
-	/* read status of the channel */
-	while ( 0 != (0x1C & vtss_io_read( M2_BLK_MIIM, 
-				miim_chnl, M2_MIIM_STATUS))) {
-		i++;
-		if(i > VTSS_MIIM_READ_ATTEMPT) {
-//			printk("API: channel busy1\n");
-			return VTSS_MIIM_CHANNEL_BUSY;
-		}
-	}
-
-
-	vtss_io_write( M2_BLK_MIIM, miim_chnl, M2_MIIM_CMD, 
-			(phy_addr<<9)|(phy_reg<<4)|(opcode <<2)|mode);
-
-
-	/* read status of the channel */
-	while ( 0 != (0x1C & vtss_io_read( M2_BLK_MIIM, 
-			miim_chnl, M2_MIIM_STATUS))) {
-		VTSS_NSLEEP( 2000000); /* sleep 2 uS */
-		i++;
-		if(i > VTSS_MIIM_READ_ATTEMPT) {
-			printk("API: channel busy2\n");
-			return VTSS_MIIM_CHANNEL_BUSY;
-		}
-	}
-
-	data = vtss_io_read( M2_BLK_MIIM, miim_chnl, M2_MIIM_DATA);
-
-	return (data & ((ulong)1 << 16))?(-1):(data&0xFFFF);
-
-}
-
-
-void vtss_miim_subblock_write( const uint miim_chnl, const uint phy_addr, 
-		const uint phy_reg, const ushort value)
-{
-	uint opcode = VTSS_MIIM_WRITE_OPR; /* write operation */
-	uint mode = VTSS_MIIM_OPR_MODE; /* MIIM operation, not MDIO */
-
-
-	/* read status of the channel */
-	while( 0 != (0x1C & vtss_io_read( M2_BLK_MIIM, miim_chnl, M2_MIIM_STATUS))) 
-		; /* wait until the channel is ready */
-
-
-	vtss_io_write( M2_BLK_MIIM, miim_chnl, M2_MIIM_CMD, 
-	(ulong)((value<<16)|(phy_addr<<9)|(phy_reg<<4)|(opcode <<2)|mode));
-
-	return;
-}
-
-
-/* Indirect miim read/write operation. Accesses the PHY corresponding to the 
-   logical port number (PHY address is found via the mapping table)
- */
-long vtss_miim_port_reg_read( const vtss_port_no_t portnum, 
-		const uint phy_reg){
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-	int miimchnl =  vtss_logical_ports[portnum].miim_controller;
-	int phy_addr =  vtss_logical_ports[portnum].phy_addr;
-	long data;
-
-	/* check the physical port number */
-	if (ppn == -1) {
-		printk("API: port not mapped\n");
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	/* long */ 
-	data = vtss_miim_subblock_read( miimchnl, phy_addr,  phy_reg);
-	return data;
-}
-
-
-void  vtss_miim_port_reg_write( const vtss_port_no_t portnum, 
-		const uint phy_reg, const ushort value)
-{
-	/* find the physical port number in the global map table */
-	/* int ppn = vtss_logical_ports[portnum].chip_port; */
-	int miimchnl =  vtss_logical_ports[portnum].miim_controller;
-	int phy_addr =  vtss_logical_ports[portnum].phy_addr;
-
-
-
-
-	/* long */ 
-	vtss_miim_subblock_write( miimchnl, phy_addr,  phy_reg, value);
-}
-
-
-BOOL vtss_phy_mapped( const vtss_port_no_t port_no )
-{
-	return  -1 != vtss_logical_ports[port_no].phy_addr;
-
-}
-
-/*******************************************************************************
-  Policing and shaping traffic.
-
-Terminology:
-Policer limits traffic in ingress direction
-Shaper does the same in engress direction
-
-In functions below only the term 'shaper' is used.
- ********************************************************************************/
-int get_shaper_register( int port_on_chip)
-{
-	if ( port_on_chip >= 0 && port_on_chip <= 7)
-		return 0xA | (port_on_chip << 4);
-	else if ( port_on_chip >= 8 && port_on_chip <= 9)
-		return 0xB | ((port_on_chip & 0x7) << 4);
-	else 
-		return -1;
-
-}
-
-#if 0
-/*******************************************************************************
-  Function 
-  vtss_egress_shaper_set()
-
-  Description
-  This function configures bitrate and leaky buvket level in the egress 
-  direction for a given logical port.
-
-  Syntax 
-  vtss_rc vtss_egress_shaper_set( vtss_port_no_t portnum, vtss_bitrate_t br);
-
-  Parameters 
-  portnum        Logical port number
-  br             Bitrate (in kilobits/second)
-  lblvl          Leaky bucket level in bytes. Range (0...0xFFFF)*128 bytes
-
-  Note
-  The bitrate is in kbits/second, so to get a throughput in bits/second 
-  the value must be multiplied by 1000.
-
-  Returns 
-  VTSS_OK        No errors detected
-
-
- ********************************************************************************/
-vtss_rc vtss_egress_shaper_set( vtss_port_no_t portnum, vtss_kbitrate_t br, 
-		ulong lblvl)
-{
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-	//  VTSS_N(("Shaper setup (egress dir). Logic port #%d, phys prt #%d", portnum, ppn));
-	//	printk("Shaper setup (egress dir). Logic port #%d, phys prt #%d\n", portnum, ppn);
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	if( br == VTSS_DISABLE_SHAPER) {
-		/* disable the shaper */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TRAFFIC_SHAPER_CTRL,
-				(ulong)1<<22, (ulong)1<<22);
-
-	} else {
-
-		ulonglong reg_value = (ulonglong)br*1000/VTSS_SHAPER_BITRATE_UNIT_PER_PORT;
-		ulong lvl = lblvl/VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-
-		if (reg_value > 0xFFFF)
-			reg_value = 0xFFFF;
-
-		if ( lvl > 0xFFFF)
-			lvl = 0xFFFF;
-
-		reg_value |= (lvl << 16);
-
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, get_shaper_register( ppn),
-				(ulong)reg_value);
-
-		/* Enable the shaper */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TRAFFIC_SHAPER_CTRL,
-				0, (ulong)1<<22);
-
-	}
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-  Function 
-  vtss_ingress_shaper_set()
-
-  Description
-  This function configures bitrate in the ingress direction for a given 
-  logical port.
-
-  Syntax 
-  vtss_rc vtss_ingress_shaper_set( vtss_port_no_t portnum, vtss_bitrate_t br);
-
-  Parameters 
-  portnum        Logical port number
-  br             Bitrate (in kilobits/second)
-
-  Note
-  The bitrate is in kbits/second, so to get a throughput in bits/second 
-  the value must be multiplied by 1000.
-
-  Returns 
-  VTSS_OK        No errors detected
-
-
- ********************************************************************************/
-vtss_rc vtss_ingress_shaper_set( vtss_port_no_t portnum, vtss_kbitrate_t br,
-		ulong lblvl)
-{
-
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-	//  VTSS_N(("Shaper setup (ingress dir). Logic port #%d, phys prt #%d", portnum, ppn));
-	printk("Shaper setup (ingress dir). Logic port #%d, phys prt #%d\n", portnum, ppn);
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-	if( br == VTSS_DISABLE_SHAPER) {
-		/* disable the shaper */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_TRAFFIC_SHAPER_CTRL,
-				(ulong)1<<22, (ulong)1<<22);
-
-	} else {
-
-		ulonglong reg_value = (ulonglong)br*1000/VTSS_SHAPER_BITRATE_UNIT_PER_PORT;
-		ulong lvl = lblvl/VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-
-		if (reg_value > 0xFFFF)
-			reg_value = 0xFFFF;
-
-		if ( lvl > 0xFFFF)
-			lvl = 0xFFFF;
-
-		reg_value |= (lvl << 16);
-
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, get_shaper_register( ppn), 
-				reg_value);
-
-		/* Enable the shaper */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TRAFFIC_SHAPER_CTRL,
-				0, (ulong)1<<22 | (ulong)1<<ppn);
-	}
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-  Function 
-  vtss_egress_common_shaper_set()
-
-  Description
-  This function configures bitrate and leaky bucket level  of the common 
-  bucket in the egress direction.
-
-  Syntax 
-  vtss_rc vtss_ingress_common_shaper_set( vtss_bitrate_t br);
-
-  Parameters 
-  br             Bitrate (in kilobits/second)
-  lblvl          Leaky bucket level in bytes. Range (0..0xFFFF)*128 bytes
-
-  Note
-  The bitrate is in kbits/second, so to get a throughput in bits/second 
-  the value must be multiplied by 1000.
-
-
-  Returns 
-  VTSS_OK        No errors detected
-
-
- ********************************************************************************/
-vtss_rc vtss_egress_common_shaper_set( vtss_kbitrate_t br, ulong lblvl)
-{
-	if( br == VTSS_DISABLE_SHAPER) {
-		/* disable the shaper */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TRAFFIC_SHAPER_CTRL,
-				(ulong)1<<22, (ulong)1<<22);
-
-	} else {
-		/* Check that shaping is enabled */
-
-		ulonglong reg_value = (ulonglong)br*1000/VTSS_SHAPER_BITRATE_UNIT_PER_LINK;
-		ulong lvl = lblvl/VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-
-		if (reg_value > 0xFFFF)
-			reg_value = 0xFFFF;
-
-		if ( lvl > 0xFFFF)
-			lvl = 0xFFFF;
-
-		reg_value |= (lvl << 16);
-
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TRAFFIC_SHAPER_BUCKET10,
-				reg_value);
-
-		/* Enable the shaper */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TRAFFIC_SHAPER_CTRL,
-				0, (ulong)1<<22 | (ulong)1<<10);
-	}
-
-	return VTSS_OK;
-}
-
-
-/*******************************************************************************
-  Function 
-  vtss_ingress_common_shaper_set()
-
-  Description
-  This function configures bitrate and leaky bucket level in the ingress 
-  direction for the common shaper
-
-  Syntax 
-  vtss_rc vtss_ingress_shaper_set( vtss_port_no_t portnum, vtss_bitrate_t br);
-
-  Parameters 
-  portnum        Logical port number
-  br             Bitrate (in kilobits/second)
-
-  Note
-  The bitrate is in kbits/second, so to get a throughput in bits/second 
-  the value must be multiplied by 1000.
-
-  Returns 
-  VTSS_OK        No errors detected
-
-
- ********************************************************************************/
-vtss_rc vtss_ingress_common_shaper_set( vtss_kbitrate_t br, ulong lblvl)
-{
-	if( br == VTSS_DISABLE_SHAPER) {
-		/* disable the shaper -- set DB (disable buckets) bit in the */
-		/* TRAFFIC_SHAPER_CTRL register */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_TRAFFIC_SHAPER_CTRL,
-				(ulong)1<<22, (ulong)1<<22);
-
-	} else {
-		/* Check that shaping is enabled */
-
-		ulonglong reg_value = (ulonglong)br*1000/VTSS_SHAPER_BITRATE_UNIT_PER_LINK;
-		ulong lvl = lblvl/VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-
-		if (reg_value > 0xFFFF)
-			reg_value = 0xFFFF;
-
-		if ( lvl > 0xFFFF)
-			lvl = 0xFFFF;
-
-		reg_value |= (lvl << 16);
-
-		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_TRAFFIC_SHAPER_BUCKET10,
-				reg_value);
-
-		/* Enable the shaper */
-		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_TRAFFIC_SHAPER_CTRL,
-				0, (ulong)1<<22 | (ulong)1<<10);
-	}
-
-	return VTSS_OK;
-}
-
-
-vtss_rc vtss_egress_shaper_get( vtss_port_no_t port_no, vtss_kbitrate_t *pbr, 
-		ulong *leaky_bucket_level)
-{
-	ulong ctrl_reg_value=0;
-	ulong bitrate_reg_value=0;
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_no].chip_port;
-	//  VTSS_N(("Shaper setup (ingress dir). Logic port #%d, phys prt #%d", port_no, ppn));
-	printk("Shaper setup (ingress dir). Logic port #%d, phys prt #%d\n", port_no, ppn);
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-
-	/* Check that shaping is enabled */
-	ctrl_reg_value = vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-			M2_TRAFFIC_SHAPER_CTRL);
-	bitrate_reg_value = vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-			get_shaper_register( ppn));
-
-
-	if( 0x1 == (( ctrl_reg_value >> 22) & 0x1)) {
-		/* shaping disabled, return VTSS_DISABLE_SHAPER */
-		*pbr = VTSS_DISABLE_SHAPER;
-		*leaky_bucket_level = 
-			(0xFFFF & (bitrate_reg_value >> 16)) * VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-	} else {
-		/* if the shaper is enabled, return the value from the device */
-		*pbr = (ulong)( (ulonglong)VTSS_SHAPER_BITRATE_UNIT_PER_PORT * 
-				(bitrate_reg_value & 0xFFFF) / 1000);
-		*leaky_bucket_level = 
-			(0xFFFF & (bitrate_reg_value>>16)) * VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-	}
-
-	return VTSS_OK;
-}
-
-
-vtss_rc vtss_ingress_shaper_get( vtss_port_no_t port_no, vtss_kbitrate_t *pbr, 
-		ulong *leaky_bucket_level)
-{
-
-	ulong ctrl_reg_value=0;
-	ulong bitrate_reg_value=0;
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[port_no].chip_port;
-	//  VTSS_N(("Shaper setup (ingress dir). Logic port #%d, phys prt #%d", port_no, ppn));
-	printk("Shaper setup (ingress dir). Logic port #%d, phys prt #%d\n", port_no, ppn);
-	/* check the physical port number */
-	if (ppn == -1) {
-		return VTSS_PORT_NOT_MAPPED;
-	}
-
-
-	/* Check that shaping is enabled */
-	ctrl_reg_value = vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
-			M2_TRAFFIC_SHAPER_CTRL);
-	bitrate_reg_value = vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
-			get_shaper_register( ppn));
-
-
-	if( 0x1 == (( ctrl_reg_value >> 22) & 0x1)) {
-		/* shaping disabled, return VTSS_DISABLE_SHAPER */
-		*pbr = VTSS_DISABLE_SHAPER;
-		*leaky_bucket_level = 
-			(0xFFFF & (bitrate_reg_value >> 16)) * VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-	} else {
-		/* if the shaper is enabled, return the value from the device */
-		*pbr = (ulong)( (ulonglong)VTSS_SHAPER_BITRATE_UNIT_PER_PORT * 
-				(bitrate_reg_value & 0xFFFF) / 1000);
-		*leaky_bucket_level = 
-			(0xFFFF & (bitrate_reg_value>>16)) * VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-	}
-
-	return VTSS_OK;
-}
-
-
-
-vtss_rc vtss_egress_common_shaper_get( vtss_kbitrate_t *pbr, 
-		ulong *leaky_bucket_level)
-{
-
-	ulong ctrl_reg_value=0;
-	ulong bitrate_reg_value=0;
-
-	//  VTSS_N(("Egress common shaper get"));
-	printk("Egress common shaper get\n");
-
-	/* Check that shaping is enabled */
-	ctrl_reg_value = vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-			M2_TRAFFIC_SHAPER_CTRL);
-	bitrate_reg_value = vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-			M2_TRAFFIC_SHAPER_BUCKET10);
-
-
-	if( 0x1 == (( ctrl_reg_value >> 22) & 0x1)) {
-		/* shaping disabled, return VTSS_DISABLE_SHAPER */
-		*pbr = VTSS_DISABLE_SHAPER;
-		*leaky_bucket_level = 
-			(0xFFFF & (bitrate_reg_value >> 16)) * VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-	} else {
-		/* if the shaper is enabled, return the value from the device */
-		*pbr = (ulong)( (ulonglong)VTSS_SHAPER_BITRATE_UNIT_PER_LINK * 
-				(bitrate_reg_value & 0xFFFF) / 1000);
-		*leaky_bucket_level = 
-			(0xFFFF & (bitrate_reg_value>>16)) * VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-	}
-
-	return VTSS_OK;
-}
-
-
-vtss_rc vtss_ingress_common_shaper_get( vtss_kbitrate_t *pbr, 
-		ulong *leaky_bucket_level)
-{
-
-	ulong ctrl_reg_value=0;
-	ulong bitrate_reg_value=0;
-
-	//  VTSS_N(("Ingress common shaper get"));
-	printk("Ingress common shaper get\n");
-
-	/* Check that shaping is enabled */
-	ctrl_reg_value = vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
-			M2_TRAFFIC_SHAPER_CTRL);
-	bitrate_reg_value = vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
-			M2_TRAFFIC_SHAPER_BUCKET10);
-
-
-	if( 0x1 == (( ctrl_reg_value >> 22) & 0x1)) {
-		/* shaping disabled, return VTSS_DISABLE_SHAPER */
-		*pbr = VTSS_DISABLE_SHAPER;
-		*leaky_bucket_level = 
-			(0xFFFF & (bitrate_reg_value >> 16)) * VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-	} else {
-		/* if the shaper is enabled, return the value from the device */
-		*pbr = (ulong)( (ulonglong)VTSS_SHAPER_BITRATE_UNIT_PER_LINK * 
-				(bitrate_reg_value & 0xFFFF) / 1000);
-		*leaky_bucket_level = 
-			(0xFFFF & (bitrate_reg_value>>16)) * VTSS_SHAPER_LEAKY_BUCKET_UNIT;
-	}
-
-	return VTSS_OK;
-}
-
-#endif
-
-/*******************************************************************************
-
-  Aggregation/trunking 
-
-
- ********************************************************************************/
-
-/*
-   Initialises port map table of the aggregator.
-   The function must be called after virtual ports have been mapped to 
-   physical ports.
-   The function also tests whether the port is enabled or disabled.
-   Disabled ports are removed from the aggregation table.
- */
-vtss_rc vtss_aggr_pmap_table_initialise( void)
-{
-	int i;
-
-	for ( i=0; i < M2_AGGR_PMAP_TABLE_SIZE; i++) {
-		vtss_aggr_pmap_table_set( i, i % VTSS_PORTS_1G);
-	}
-
-	return VTSS_OK;
-}
-
-
-
-/*
-   Writes one entry into the port map table of the aggregator
- */
-vtss_rc vtss_aggr_pmap_table_set( int index, int portnum)
-{
-	vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR,
-		 M2_PMAP_TABLE, (portnum<<8)|(index & 0xFF));
-
-	return VTSS_OK;
-}
-
-
-
-vtss_rc vtss_aggr_setup( vtss_aggr_mode_t *pamode)
-{
-	ulong reg_value = 0;
-	ulong reg_mask = 0x1BE; /* will not alter NLE,HDR,P_PAR and reserved bits */
-
-
-
-	if (pamode->preamble_trunking) {
-
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_PRE_BIT0POS,
-				pamode->u.bit.pos0);
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_PRE_BIT1POS,
-				pamode->u.bit.pos1);
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_PRE_BIT2POS,
-				pamode->u.bit.pos2);
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_PRE_BIT3POS,
-				pamode->u.bit.pos3);
-		reg_value = 1 << 5;
-
-	} else if (pamode->mpls_trunking) {
-
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BIT0,
-				pamode->u.bit.pos0);
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BIT1,
-				pamode->u.bit.pos1);
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BIT2,
-				pamode->u.bit.pos2);
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BIT3,
-				pamode->u.bit.pos3);
-		reg_value = (1<<8) |( 1<<7);
-
-	} else if (pamode->mpls_aggregation) {
-
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BITMASK,
-				pamode->u.mpls_bitmask);
-		reg_value = 1<<7;
-
-	} else if (pamode->l2_aggr || pamode->l3_aggr || pamode->l4_aggr) {
-
-		if ( pamode->l2_aggr)
-			SET_BIT( reg_value, 2);
-		if ( pamode->l3_aggr)
-			SET_BIT( reg_value, 3);
-		if ( pamode->l4_aggr)
-			SET_BIT( reg_value, 4);
-
-		SET_BIT(reg_value, 1);
-
-	}
-
-	if( pamode->norm_hdr_used == TRUE) {
-		SET_BIT( reg_value, 0);/* Norm header is present */
-		CLR_BIT( reg_value, 9);/* NLE bit must be cleared when the norm header
-					  is present */
-	} else {
-		CLR_BIT( reg_value, 0);
-		SET_BIT( reg_value, 9);
-	}
-
-	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_AGGR_SETUP,
-			reg_value, reg_mask);
-
-	return VTSS_OK;
-}
-
-
-
-vtss_rc vtss_aggr_setup_get_default_values( vtss_aggr_mode_t* pam, 
-		vtss_mac_major_mode_t mmode)
-{
-
-	pam->preamble_trunking = FALSE;
-	pam->mpls_trunking = FALSE;
-	pam->mpls_aggregation = FALSE;
-	pam->l2_aggr = FALSE;
-	pam->l3_aggr = FALSE;
-	pam->l4_aggr = FALSE;
-
-	pam->u.bit.pos0 = 0;
-	pam->u.bit.pos1 = 0;
-	pam->u.bit.pos2 = 0;
-	pam->u.bit.pos3 = 0;
-
-	pam->u.mpls_bitmask = 0;
-
-	pam->norm_hdr_used = FALSE;
-
-
-	switch (mmode) {
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:   /* SPI4 <-> 1x10G */
-
-			return VTSS_WRONG_MAJOR_MODE;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
-
-			return VTSS_WRONG_MAJOR_MODE;
-
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
-			/* Default: layer 2 aggregation */
-			pam->l2_aggr = TRUE;
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
-
-			/* Default: preamble trunking */
-			pam->preamble_trunking = TRUE;
-
-			pam->u.bit.pos0 = M2_PREAMBLE_BIT0_POS;
-			pam->u.bit.pos1 = M2_PREAMBLE_BIT1_POS;
-			pam->u.bit.pos2 = M2_PREAMBLE_BIT2_POS;
-			pam->u.bit.pos3 = M2_PREAMBLE_BIT3_POS;
-
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
-			/* Default: layer 2 aggregation */
-			pam->l2_aggr = TRUE;
-			break;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
-			/* Default: preamble trunking */
-			pam->preamble_trunking = TRUE;
-
-			pam->u.bit.pos0 = M2_PREAMBLE_BIT0_POS;
-			pam->u.bit.pos1 = M2_PREAMBLE_BIT1_POS;
-			pam->u.bit.pos2 = M2_PREAMBLE_BIT2_POS;
-			pam->u.bit.pos3 = M2_PREAMBLE_BIT3_POS;
-
-			break;
-
-		default:
-			/* VTSS_MAC_MAJOR_MODE_UNDEFINED */
-			return VTSS_WRONG_MAJOR_MODE;
-
-	}
-
-	return VTSS_OK;
-}
-
-
-/*
-   Inform the aggregator that frames are with/without a normalized and/or 
-   preamble header
- */
-static void vtss_aggr_use_header( BOOL enable, m2_header_t hdr)
-{
-	ulong cfg_reg = 0;
-	BOOL prm_hdr_enabled = FALSE;
-	BOOL norm_hdr_enabled = FALSE;
-
-	if( hdr.use_norm_hdr == FALSE && hdr.use_prm_hdr == FALSE)
-		return;
-
-	cfg_reg = vtss_io_read( M2_BLK_FIFO, M2_BLK_SYSTEM, M2_CRC_CFG);
-
-	if ( cfg_reg & (1<<4)) {
-		switch (cfg_reg & 0xf) {
-			case 0:
-				prm_hdr_enabled = TRUE;
-				norm_hdr_enabled = TRUE;
-				break;
-			case 7:
-				prm_hdr_enabled = TRUE;
-				break;
-			case 9:
-				norm_hdr_enabled = TRUE;
-				break;
-			default:
-				break;
-		}
-	}
-
-	if( hdr.use_norm_hdr == TRUE) {
-
-		if( enable == TRUE) {
-			SET_BIT( cfg_reg, 4);
-			if( prm_hdr_enabled == TRUE)
-				cfg_reg &= ~(ulong)0xF;
-			else
-				cfg_reg = (cfg_reg & ~(ulong)0xF) + 9;
-
-		} else {
-			/* disable norm hdr */
-			if (prm_hdr_enabled == TRUE) {
-				SET_BIT( cfg_reg, 4);
-				cfg_reg = (cfg_reg & ~(ulong)0xF) + 7;
-			}
-
-		}
-
-	}
-
-	if (hdr.use_prm_hdr == TRUE) {
-
-		if ( enable == TRUE) {
-			SET_BIT( cfg_reg, 4);
-			if( norm_hdr_enabled == TRUE)
-				cfg_reg &= ~(ulong)0xF;
-			else
-				cfg_reg = (cfg_reg & ~(ulong)0xF) + 7;
-
-		} else {
-			/* disable preamble header */
-			if ( norm_hdr_enabled == TRUE) {
-				SET_BIT( cfg_reg, 4);
-				cfg_reg = (cfg_reg & ~(ulong)0xF) + 9;
-			}
-
-		}
-
-	}
-
-	vtss_io_writemasked( M2_BLK_FIFO, M2_BLK_SYSTEM, 
-				M2_CRC_CFG, cfg_reg, 0x1F);
-
-}
-
-
-/*
-
-   Works only in INGRESS direction. To use normalized header in egress direction
-   use the vtss_norm_hdr_expect_enable() function.
-
-   Configures the whole device to use normalized header in ingress direction.
-   In 1G<->SPI4 mode normalization (insertion of the normalized header)
-   is done by 1G MAC devices.
-   In other modes normalized header is inserted by 10G MAC.
-
-   Normalized header is needed when the ingress FIFO runs in frame-interleaved
-   mode. 
-
-   To enable normalized header (that also requires setting the LE/NLE bit):
-   - write to the 10M/100M/1G/10G MAC block
-   - write to the ingress FIFO
-   - 
- */
-static vtss_rc vtss_hdr_insert( BOOL able, m2_header_t hdr)
-{
-
-	/* Global pointer to a structure that can tell in which mode we are */
-	vtss_device_setup_t *pdv = pdevice;
-	int i;
-
-	switch( pdv->mmode) {
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:        /* SPI4 <-> 10x1G */
-			/* configure all 1G devices to normalize frames */
-			for (i = M2_PHYS_PORT_1G_MIN; i <= M2_PHYS_PORT_1G_MAX; i++) {
-
-				vtss_port1G_header_insert( i, able, hdr);
-			}
-
-			/* Aggregator is not involved in this major mode */
-
-			/* Configure the ingress FIFO */
-			vtss_fifo_use_hdr( M2_SUBBLK_INGRESS, able, hdr);
-			break;
-
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-			/* Aggregator must be configured */
-			vtss_aggr_use_header( able, hdr);
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-
-			/* normalizer in 10G device, only one 10G port in M2 */
-			vtss_port10G_header_insert( able, hdr);
-
-			/* Aggregator must be configured */
-
-			/* Ingress FIFO must be configured to run with the norm header */
-			vtss_fifo_use_hdr( M2_SUBBLK_INGRESS, able, hdr);
-
-			break;
-
-
-			/* Undefined major mode */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			/* undefined major mode */
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-
-			/* In the following two modes the ingress channel 
-			(1x10G->10x1G) always runs in burst-interleaved mode,
-			 i.e. without the normalised  header. Currently, 
-			there does not seem to be a reason to use 
-		   	normalisation of frames in ingress direction.
-
-			In the egress direction (10x1G->1x10G) the normalized header
-			is always enabled, because the egress fifo runs in 
-			frame-interleaved mode. Currently there is no reason to
-			disable it   */
-
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:    /* single chip aggr */
-
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:   /* single chip trunking */
-
-		/* In the next major mode ingress fifo always runs in the 
-		burst-interleaved  mode */
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:       /* SPI4 <-> 1x10G */
-
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-
-	}
-	return VTSS_OK;
-}
-
-#if 0
-/*
-   Works only in EGRESS direction
-
- */
-static vtss_rc vtss_hdr_expect( BOOL able, m2_header_t hdr)
-{
-
-	/* Global pointer to a structure that can tell in which mode we are */
-	vtss_device_setup_t *pdv = pdevice;
-	int i;
-
-	switch( pdv->mmode) {
-		case VTSS_MAC_MAJOR_MODE_SPI4_1G:        /* SPI4 <-> 10x1G */
-			/*
-			   Blocks affected:
-			   - System (CRC_CFG)
-			   - SPI4
-			   - Egress FIFO
-			   - 1G MAC (denormalizer register)
-			 */
-
-			/* configure all 1G devices to denormalize frames */
-			for (i = M2_PHYS_PORT_1G_MIN; i <= M2_PHYS_PORT_1G_MAX; i++) {
-
-				vtss_port1G_header_insert( i, able, hdr);
-			}
-
-			/* Aggregator is not involved in this major mode */
-
-			/* Configure the egress FIFO */
-			vtss_fifo_use_hdr( M2_SUBBLK_EGRESS, able, hdr);
-			break;
-
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
-
-			/* normalizer in 10G device, only one 10G port in M2 */
-			vtss_port10G_header_insert( able, hdr);
-
-			/* Aggregator must be configured */
-
-			/* Ingress FIFO must be configured to run with the norm header */
-
-			break;
-
-
-			/* In the following two modes the ingress channel 
-			(1x10G->10x1G) always runs in burst-interleaved mode, 
-			i.e. without the normalised header. Thus just repeat 
-			initalization.
-
-			In the egress direction (10x1G->1x10G) the normalized 
-			header  is always enabled, because the egress fifo 
-			runs in frame-interleaved mode */
-
-		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:    /* single chip aggr */
-		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:   /* single chip trunking */
-
-		/* 1G devices are configured in vtss_norm_hdr_expect_enable() 
-		function */
-		/* configure all 1G devices to normalize frames */
-		/*
-			   hdr.use_norm_hdr = TRUE;
-			   hdr.use_prm_hdr = FALSE;
-			   for (i = M2_PHYS_PORT_1G_MIN; 
-				i <= M2_PHYS_PORT_1G_MAX; i++) {
-
-			   vtss_port1G_header_insert_enable( i, hdr);
-			   }
-			 */
-
-			/* Aggregator is not involved in this major mode, 
-			skipping it */
-
-			/* Configure the egress FIFO */
-			vtss_fifo_use_hdr( M2_SUBBLK_EGRESS, able, hdr);
-
-
-			/* normalizer in 10G device, only one 10G port in M2 */
-			vtss_port10G_header_insert( able, hdr);
-
-			break;
-
-			/* */
-		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
-			/* undefined major mode */
-			return VTSS_MAJOR_MODE_NOT_SET;
-
-		case VTSS_MAC_MAJOR_MODE_SPI4_10G:       /* SPI4 <-> 1x10G */
-			/* In this major mode ingress and egress fifo's 
-			always runs in burst-interleaved mode */
-			break;
-
-		default:
-			return VTSS_WRONG_MAJOR_MODE;
-
-	}
-
-	return VTSS_OK;
-}
-#endif
-
-
-/******************************************************************************
- * Description: Set GPIO direction to input or output.
- *
- * \param gpio_no (input): GPIO pin number.
- * \param output (input) : TRUE if output, FALSE if input.
- *
- * \return : Return code OK.
- ******************************************************************************/
-vtss_rc vtss_gpio_direction_set(const vtss_gpio_no_t gpio_no, const BOOL output)
-{
-	//  VTSS_D(("gpio_no: %d, direction: %d",gpio_no,output));
-//	printk("gpio_no: %d, direction: %d\n",gpio_no,output);  
-	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_GPIO_CTRL, 
-			output ? (ulong)1<<(gpio_no & 0xF) : 0, 
-			(ulong)1<<(gpio_no & 0xF));
-
-	return VTSS_OK;
-}
-
-
-/******************************************************************************
- * Description: Read from GPIO input pin.
- *
- * \param gpio_no (input): GPIO pin number.
- *
- * \return : TRUE if pin is high, FALSE if it is low.
- ******************************************************************************/
-BOOL vtss_gpio_input_read(const vtss_gpio_no_t gpio_no)
-{
-	uint value;
-
-	value = vtss_io_read( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_GPIO_IN);
-
-	//  VTSS_D(("gpio_no: %d, input: %i", gpio_no, value));
-//	printk("gpio_no: %d, input: %i\n", gpio_no, value);  
-	return ( value & ((ulong)1<<(gpio_no & 0xF))) ? 1 : 0;
-}
-
-
-/******************************************************************************
- * Description: Write to GPIO output pin.
- *
- * \param gpio_no (input): GPIO pin number.
- * \param value (input)  : TRUE to set pin high, FALSE to set pin low.
- *
- * \return : TRUE if pin is high, FALSE if it is low.
- ******************************************************************************/
-vtss_rc vtss_gpio_output_write(const vtss_gpio_no_t gpio_no, const BOOL value)
-{
-	//  VTSS_D(("gpio_no: %d, output: %d", gpio_no, value));
-//	printk("gpio_no: %d, output: %d\n",gpio_no, value);
-	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
-		M2_GPIO_OUT, value ?
-		(ulong)1<<(gpio_no & 0xF) : 0, (ulong)1<<(gpio_no & 0xF));
-
-	return VTSS_OK;
-}
-
-
-/******************************************************************************/
-/***        BIST test                                **************************/
-/******************************************************************************/
-
-/******************************************************************************
- * Description: Start a specific bist test
- *
- * \param bist_no (input): bist test number range <0..VTSS_BIST_NAME_SIZE-1>.
- *
- * \return : VTSS_OK if write was started,
- *           VTSS_BIST_CMD_FAILED if last write was still in progress.
- **************************************************************************kbp*/
-vtss_rc vtss_chip_bist_start(const uint bist_no)
-{
-	ulong value = 0;
-
-	/*Last write completed?*/
-	value = vtss_io_read( M2_BLK_SYSTEM, M2_SUBBLK_BIST, M2_RAM_BIST_CMD);
-	if ( (value & (1<<27)) != 0 ) { return  VTSS_BIST_CMD_FAILED; }
-
-	/*Enable bist_no test by writing 0x1 to the indirect BIST_COMMAND register*/
-	vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_BIST, M2_RAM_BIST_CMD,  
-			(1<<24)|(M2_BIST_COMMAND<<16)|(0x1<<8)|bist_no);
-
-	return VTSS_OK;
-}
-
-
-/******************************************************************************
- * Description: Get result for a specific bist test
- *
- * \param bist_no (input): bist test number range <0..VTSS_BIST_NAME_SIZE-1>.
- *                         >= VTSS_BIST_NAME_SIZE returns the write status.
- *
- * \return : VTSS_OK               when bist test went OK
- *           VTSS_BIST_CMD_FAILED  when write accesses failed.
- *           VTSS_BIST_TEST_FAILED when bist test failed.
- **************************************************************************kbp*/
-vtss_rc vtss_chip_bist_result(const uint bist_no)
-{
-	ulong value = 0;
-	uint i = 0;
-
-	/* Test for any previous write errors */
-	if ( bist_no >= VTSS_BIST_NAME_SIZE ) {
-		value = vtss_io_read( M2_BLK_SYSTEM, M2_SUBBLK_BIST, M2_RAM_BIST_CMD);
-		if ( (value & (1<<25)) != 0 ) { return  VTSS_BIST_CMD_FAILED; }
-		return VTSS_OK;
-	}
-
-	/*Wait for the BIST test to be done RD_DATA and when valid.*/
-	while ( (value & 0x3FD) == 0 && i++ < 0xF ) {
-
-		/*Transfer bist_no BIST_STATUS register to the 
-		RAM_BIST_RESULT register*/
-		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_BIST, 
-			M2_RAM_BIST_CMD,  
-			(0<<24)|(M2_BIST_STATUS<<16)|(bist_no & 0x3f));
-
-		/*Wait for read to complete*/
-		do {
-			value = vtss_io_read( M2_BLK_SYSTEM, 
-			M2_SUBBLK_BIST, M2_RAM_BIST_RESULT);
-		} while ( (value & (1<<9) ) != 0 ) ;
-	}
-	return ( value & (ulong)1<<1 ? VTSS_OK : VTSS_BIST_TEST_FAILED );
-}
-
-
-/******************************************************************************
- * Description: Setup for GFP-T handling in Campbell-I
- *
- * \param portnum
- *          vtss_gfpt_setup_t* gs
- *       
- *
- * \return : VTSS_OK               
- *           VTSS_PORT_NOT_MAPPED
- *           VTSS_WRONG_PARAMETER
- **************************************************************************kbp*/
-vtss_rc vtss_gfpt_setup( vtss_port_no_t portnum, vtss_gfpt_setup_t* gs)
-{
-	ulong gfpt_rx_pcs_reg = 0;
-
-	/* find the physical port number in the global map table */
-	int ppn = vtss_logical_ports[portnum].chip_port;
-	/* Check the physical port number */
-	if (ppn < 0) { return VTSS_PORT_NOT_MAPPED; }
-
-	/* Check selected interface */
-	switch ( gs->interface_mode.interface_type) {
-		/* right interface */
-		case VTSS_PORT_INTERFACE_SERDES:
-			if (gs->interface_mode.speed != VTSS_SPEED_ETH_GFPT) {
-				return VTSS_WRONG_PARAMETER; 
-			}
-			break;
-		case VTSS_PORT_INTERFACE_TBI:
-			/* Select Rx path as TBI interface */
-			SET_BIT(gfpt_rx_pcs_reg, 8); 
-			break;
-			/* Error - wrong interface */
-		default:
-			return VTSS_WRONG_PARAMETER;
-	}
-
-	/* Setup client clock when in clock source mode. */
-	/* Note: Per default the GPIos are set as input. */
-	/* GBE: use Internal SerDes, FC/2,FC/4,FC: Use GPIO1,
-	 (2FC or GBE: Use GPIO4), ESC: Use GPIO7, DVB: Use GPIO10 */  
-	if (gs->source_mode_en) {
-		vtss_io_writemasked( M2_BLK_MACS, ppn, 
-		M2_DEV_SETUP, (ulong)((1<<20)|
-			(gs->interface_mode.speed<<16)), (ulong)17<<16);
-	}
-
-	/* Setup client signal for the Egress and Ingress direction */
-	switch (gs->interface_mode.speed) {
-	case VTSS_SPEED_ETH_GFPT:
-		/* Setup client signal */
-		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_CLIENT1, 
-			(C1_GFPT_CLIENT_GBE<<16)|(C1_GFPT_CLIENT_GBE));
-		/* Setup PCS TX */
-		vtss_io_write( M2_BLK_MACS, ppn, 
-		C1_GFPT_PCS_TX, (ulong)(
-			(1<<20)|(0xF1<<4)|((gs->gfpt_en)? 1:0)));
-		break;
-	case VTSS_SPEED_FC2_GFPT: /* 6    Gbit/s Fibre Channel */
-	case VTSS_SPEED_FC4_GFPT: /* 7    Gbit/s Fibre Channel */
-	case VTSS_SPEED_1FC_GFPT: /* 8    1Gbit/s Fibre Channel or FICON*/
-	case VTSS_SPEED_2FC_GFPT: /* 9    2Gbit/s Fibre Channel */
-		/* Setup client signal */
-		vtss_io_write( M2_BLK_MACS, ppn,
-		C1_GFPT_CLIENT1, 
-		(C1_GFPT_CLIENT_FC<<16)|(C1_GFPT_CLIENT_FC));
-		/* Setup PCS TX */
-		vtss_io_write( M2_BLK_MACS, ppn, 
-		C1_GFPT_PCS_TX, (ulong)(
-			(3<<20)|(0xF1<<4)|((gs->gfpt_en)? 1:0)));
-		/* Rx Synchronization mode, FC/FICON */    
-		SET_BIT(gfpt_rx_pcs_reg, 1); 
-		break;
-	case VTSS_SPEED_ESC_GFPT: /* 10 200Mbit/s ESCON or SBCON */
-		/* Setup client signal */
-		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_CLIENT1, 
-			(C1_GFPT_CLIENT_ESC<<16)|(C1_GFPT_CLIENT_ESC));
-		/* Setup PCS TX */
-		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_PCS_TX, 
-			(ulong)((0xF1<<4)|((gs->gfpt_en)? 1:0)));
-		/* Rx Synchronization mode, ESCON/SBCON */    
-		SET_BIT(gfpt_rx_pcs_reg, 2); 
-		break;
-	case VTSS_SPEED_DVB_GFPT: /* 11 270Mbit/s DVB ASI */
-		/* Setup client signal */
-		vtss_io_write( M2_BLK_MACS, ppn, 
-		C1_GFPT_CLIENT1, (C1_GFPT_CLIENT_DVB<<16)|(C1_GFPT_CLIENT_DVB));
-		/*Setup PCS TX */
-		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_PCS_TX, 
-		(ulong)((0xF1<<4)|((gs->gfpt_en)? 1:0)));
-		/* Rx Synchronization mode, DVB ASI */    
-		SET_BIT(gfpt_rx_pcs_reg, 2); 
-		SET_BIT(gfpt_rx_pcs_reg, 1); 
-		break;
-
-		/* Error - wrong client */
-		default:
-			return VTSS_WRONG_PARAMETER;
-	}
-
-	/* Enable Rx symbol alignment, explicit bit 6=0 */
-	SET_BIT(gfpt_rx_pcs_reg, 7); 
-	/* Enable GFP-T processing */
-	if (gs->gfpt_en != FALSE) { SET_BIT(gfpt_rx_pcs_reg, 0); }
-	/* Setup PCS RX */
-	vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_PCS_RX, gfpt_rx_pcs_reg);
-
-	/* Change FIFO Threshold levels for GFP-T */
-	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
-		M2_CT_THRHLD + ppn, (ulong)1); 
-	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
-		M2_CT_THRHLD + ppn, (ulong)((gs->threshold_level<<16)|1)); 
-
-	/* Setup rate adaptation rules */
-	if ( gs->rate_period >= 16 ) {
-		return VTSS_WRONG_PARAMETER;
-	} else if ( gs->rate_max_delta >= 8 ) {
-		return VTSS_WRONG_PARAMETER;
-	} else if ( gs->rate_min_idles >= 8 ) {
-		return VTSS_WRONG_PARAMETER;
-	} else {
-		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_CLIENT2, 
-		/* (ulong)1<<26 */
-		(gs->rate_period<<16) | (gs->rate_max_delta<<8) | 
-						gs->rate_min_idles);
-	}
-
-	/* Setup Ingress Pading rate */
-	if ( gs->rate_padding >= 1024) {
-		return VTSS_WRONG_PARAMETER;
-	} else {
-		vtss_io_write( M2_BLK_MACS, ppn, 
-		C1_GFPT_BLOCK_CODE, gs->rate_padding);
-	}
-
-	/* GFPT frame length */
-	if ( gs->frame_length <= 0 || gs->frame_length >= 256) {
-		return VTSS_WRONG_PARAMETER;
-	} else {
-		vtss_io_write( M2_BLK_MACS, ppn, 
-		C1_GFPT_FRM_LEN, gs->frame_length);
-	}
-
-	/* GFPT header */
-	vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_HEAD_ENA,
-			(ulong)(((gs->egress_header_expect)? 1<<1:0) |
-			((gs->ingress_header_insert)? 1:0)));
-
-	/* Error correction */
-	vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_BIT_ERR_CORR,
-		(ulong)((gs->egress_err_corr == VTSS_GFPT_DISABLE_ERR)? 0 : 
-		(1 | (gs->egress_err_corr<<1)) & 0x7));
-
-	/* GFP enable */
-	vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_CONFIG, 
-		(ulong)((gs->gfpt_en)? 1:0));
-
-	return VTSS_OK;
-}
-
-
-/******************************************************************************
- * Description: Get default setting for GFP-T handling in Campbell-I
- *
- * \param     : vtss_gfpt_setup_t* gs
- *              vtss_port_interface_mode_t  mode
- *
- * \return    : VTSS_OK               
- *              VTSS_WRONG_PARAMETER
- **************************************************************************kbp*/
-vtss_rc vtss_gfpt_setup_get_default_values( vtss_gfpt_setup_t* gs,
-		vtss_port_interface_mode_t mode)
-{
-
-	gs->gfpt_en = TRUE;
-	gs->interface_mode = mode;
-	gs->rate_padding = 0;
-	gs->egress_err_corr = VTSS_GFPT_FORWARD_ERR; /* Let 
-			uncorretable error come through */
-	gs->source_mode_en = FALSE; /* Let Campbell-I 
-		deliver the clock source for TBI */
-
-	/* Setup parameters specific for the client signal  */
-	switch (gs->interface_mode.speed) {
-		case VTSS_SPEED_ETH_GFPT:
-			gs->threshold_level = 14;
-			gs->rate_period = 12;
-			gs->rate_max_delta = 1;
-			gs->rate_min_idles = 3;
-			gs->frame_length = 95;
-			gs->ingress_header_insert = TRUE;
-			gs->egress_header_expect = TRUE;
-			break;
-		case VTSS_SPEED_2FC_GFPT: /* 6    2Gbit/s Fibre Channel */
-		case VTSS_SPEED_1FC_GFPT: /* 7    1Gbit/s Fibre 
-					Channel or FICON*/
-		case VTSS_SPEED_FC2_GFPT: /* 8    Gbit/s Fibre Channel */
-		case VTSS_SPEED_FC4_GFPT: /* 9    Gbit/s Fibre Channel */
-			gs->threshold_level = 12;
-			gs->rate_period = 12;
-			gs->rate_max_delta = 1;
-			gs->rate_min_idles = 2;
-			gs->frame_length = 13;
-			gs->ingress_header_insert = FALSE;
-			gs->egress_header_expect = FALSE;
-			break;
-		case VTSS_SPEED_ESC_GFPT: /* 10 200Mbit/s ESCON or SBCON */
-			gs->threshold_level = 8;
-			gs->rate_period = 10;
-			gs->rate_max_delta = 2;
-			gs->rate_min_idles = 2;
-			gs->frame_length = 1;
-			gs->ingress_header_insert = TRUE;
-			gs->egress_header_expect = TRUE;
-			break;
-		case VTSS_SPEED_DVB_GFPT: /* 11 270Mbit/s DVB ASI */
-			gs->threshold_level = 10;
-			gs->rate_period = 10;
-			gs->rate_max_delta = 2;
-			gs->rate_min_idles = 2;
-			gs->frame_length = 2;
-			gs->ingress_header_insert = TRUE;
-			gs->egress_header_expect = TRUE;
-			break;
-			/* Error - wrong client */
-		default:
-			return VTSS_WRONG_PARAMETER;
-	}
-
-	return VTSS_OK;
-}
-
-
-/****************************************************************************/
-/*                                                                          */
-/*  End of file.                                                            */
-/*                                                                          */
-/****************************************************************************/
-
-
-
diff --git a/drivers/net/nlm_spi4/vitesse_highlevel.h b/drivers/net/nlm_spi4/vitesse_highlevel.h
deleted file mode 100644
index 14ec40f..0000000
--- a/drivers/net/nlm_spi4/vitesse_highlevel.h
+++ /dev/null
@@ -1,1384 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/************************************************************-*- mode: C -*-*/
-/*                                                                          */
-/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
-/*                           All Rights Reserved.                           */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*                            Copyright Notice:                             */
-/*                                                                          */
-/*  Unpublished rights reserved under the copyright laws of the             */
-/*  United States of America, other countries and international treaties.   */
-/*  The software is provided without fee.                                   */  
-/*  Permission to use,  copy, store, modify, disclose, transmit or          */
-/*  distribute the software is granted, provided that this copyright        */
-/*  notice must appear in any copy, modification, disclosure,               */
-/*  transmission or distribution of the software.                           */
-/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
-/*  trade secret and proprietary rights in the software.                    */
-/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
-/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
-/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*                                                                          */
-/*  vitesse_highlevel.h  -- API functions and data structures for MAC       */
-/*                          devices.                                        */
-/*                                                                          */
-/*                                                                          */
-/*  $Id: vitesse_highlevel.h,v 1.1.2.4 2006-09-28 01:24:16 nphilips Exp $           */
-/*                                                                          */
-/****************************************************************************/
-#ifndef _VITESSE_HIGHLEVEL_H
-#define _VITESSE_HIGHLEVEL_H 1
-
-
-
-/******************************************************************************/
-/***        Common Type Definitions                  **************************/
-/******************************************************************************/
-
-#include <linux/types.h>
-#include "vitesse_common.h"
-
-
-
-/******     Return codes   ****************************************************/
-typedef int vtss_rc;
-
-#define VTSS_OK                        0     /* rc>=0 means OK */
-/* General warnings */
-#define VTSS_WARNING                (-0x01)  /* Error, but fixed by API. */
-/* General errors */
-#define VTSS_UNSPECIFIED_ERROR      (-0x02)
-#define VTSS_NOT_IMPLEMENTED        (-0x03)
-#define VTSS_INVALID_PARAMETER      (-0x04)
-#define VTSS_DATA_NOT_READY         (-0x05)
-#define VTSS_PORT_NOT_MAPPED        (-0x06)
-#define VTSS_FEATURE_NOT_SUPPORTED  (-0x07)
-#define VTSS_WRONG_PARAMETER        (-0x08)
-#define VTSS_MAJOR_MODE_NOT_SET     (-0x09)
-#define VTSS_WRONG_MAJOR_MODE       (-0x0A)
-#define VTSS_MIIM_CHANNEL_BUSY      (-0x0C)
-#define VTSS_PHY_READ_ERROR         (-0x0D)
-#define VTSS_PHY_NOT_MAPPED         (-0x0E)
-#define VTSS_PHY_ABILITY            (-0x0F)
-#define VTSS_BIST_CMD_FAILED        (-0x10)
-#define VTSS_BIST_TEST_FAILED       (-0x11)
-
-
-/******************************************************************************/
-/***        Type definitions common for 1G and 10G MAC ports   ****************/
-/******************************************************************************/
-typedef struct _vtss_mac_t {
-  uchar addr[6]; /* Network byte order */
-} vtss_mac_t;
-
-
-typedef enum _vtss_speed_t {
-  VTSS_SPEED_UNDEFINED,
-  VTSS_SPEED_10M,      /* 1   10Mbit/s Ethernet */
-  VTSS_SPEED_100M,     /* 2  100Mbit/s Ethernet */
-  VTSS_SPEED_1G,       /* 3    1Gbit/s Ethernet */
-  VTSS_SPEED_10G,      /* 4   10Gbit/s Ethernet */
-  VTSS_SPEED_ETH_GFPT, /* 5    1Gbit/s Ethernet */
-  VTSS_SPEED_FC2_GFPT, /* 6    Gbit/s Fibre Channel */
-  VTSS_SPEED_FC4_GFPT, /* 7    Gbit/s Fibre Channel */
-  VTSS_SPEED_1FC_GFPT, /* 8    1Gbit/s Fibre Channel or FICON*/
-  VTSS_SPEED_2FC_GFPT, /* 9    2Gbit/s Fibre Channel */
-  VTSS_SPEED_ESC_GFPT, /* 10 200Mbit/s ESCON or SBCON */
-  VTSS_SPEED_DVB_GFPT  /* 11 270Mbit/s DVB ASI */
-} vtss_speed_t;
-
-
-/* In egress direction it is possible to alter FCS in those frames that 
-   were inserted in the stream without FCS, for ex. by the host 
-   
-   For this feature to work FCS check done in the SPI4 block must be 
-   disabled.
-*/
-typedef enum _vtss_fcs_modify_t {
-  VTSS_FCS_DO_NOTHING,
-  VTSS_FCS_UPDATE,
-  VTSS_FCS_ADD
-} vtss_fcs_modify_t;
-
-
-/******************************************************************************/
-/***        Major mode type definitions              **************************/
-/******************************************************************************/
-/* ----- TBD: mode detailed description of major modes  ------- */
-typedef enum _vtss_mac_major_mode_t {
-  VTSS_MAC_MAJOR_MODE_UNDEFINED,      /* After the reset */
-  VTSS_MAC_MAJOR_MODE_SPI4_1G,        /* SPI4 <-> 10x1G */
-  VTSS_MAC_MAJOR_MODE_SPI4_10G,       /* SPI4 <-> 1x10G */
-  VTSS_MAC_MAJOR_MODE_10G_1G_AGGR,    /* single chip aggr */
-  VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK,   /* single chip trunking */
-  VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR,  /* */
-  VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK  /* */
-} vtss_mac_major_mode_t;
-
-
-/******************************************************************************/
-/***        Device Specific Configuration                 *********************/
-/***        may be moved to a device specific .h file     *********************/
-/******************************************************************************/
-
-/* Time to wait after a reset in nanoseconds */
-#define VTSS_T_RESET                     2000000L
-
-#if defined MEIGS2 || defined VSC7321
-#define VTSS_MAX_INGRESS_FIFO_SIZE       (128*1024)
-#define VTSS_MAX_EGRESS_FIFO_SIZE        (128*1024)
-#elif defined CAMPBELL || defined VSC7331 || defined MEIGS2E || defined VSC7323
-/* Meigs2e and Campbell have 3Mbit ingress fifo, egress fifo is the same */
-#define VTSS_MAX_INGRESS_FIFO_SIZE       (3*128*1024)
-#define VTSS_MAX_EGRESS_FIFO_SIZE        (128*1024)
-#endif
-
-
-#define M2_TEST_FIFO_NORMAL              0x0
-#define M2_TEST_FIFO_RX_STOP             0x1
-#define M2_TEST_FIFO_CLR                 0x2
-#define M2_TEST_FIFO_TX_STOP             0x3
-#define M2_TEST_FIFO_REPLAY_TO_TOP       0x4
-#define M2_TEST_FIFO_REPLAY_TO_TAIL      0xC
-
-
-#define VTSS_MAX_FRAME_LENGTH            1518  /* 16-bit value */
-#define VTSS_MAX_FRAME_LENGTH_MASK       0xFFFF
-#define VTSS_MAX_IFG_VALUE               0xF   /*  4-bit value */
-#define VTSS_IFG_MASK                    0xF
-
-/* Recommended values for interframe gaps */
-#define VTSS_IFG1_1G                     5
-#define VTSS_IFG1_100M_HDX               6
-#define VTSS_IFG1_100M_FDX               7
-#define VTSS_IFG1_10M_HDX                6
-#define VTSS_IFG1_10M_FDX                7
-
-
-#define VTSS_IFG2_1G                     1
-#define VTSS_IFG2_100M_HDX               8
-#define VTSS_IFG2_100M_FDX               11
-#define VTSS_IFG2_10M_HDX                8
-#define VTSS_IFG2_10M_FDX                11
-
-
-#define M2_1G_PORT_CLOCK_MODE_10M        0x1
-#define M2_1G_PORT_CLOCK_MODE_100M       0x2
-#define M2_1G_PORT_CLOCK_MODE_1G_GMII    0x3
-#define M2_1G_PORT_CLOCK_MODE_1G_SERDES  0x4
-#ifndef VSC7321
-#define M2E_1G_PORT_CLOCK_MODE_TBI       0x5
-#endif
-
-#define M2_1G_PORT_CLOCK_MODE_MASK       0x7
-
-
-/* Order of bytes in a word and bits in a byte */
-#define M2_BIG_END_BYTE_BIG_END_BIT      0x99999999
-#define M2_LTL_END_BYTE_BIG_END_BIT      0x81818181
-
-#define M2_BIG_END_BYTE_LTL_END_BIT      0x18181818
-#define M2_LTL_END_BYTE_LTL_END_BIT      0x00000000
-
-
-/**/
-#define M2_SW_GLOBAL_RESET               0x80000001
-
-/* Some default values */
-#define VTSS_PORT_1G_TX_PAUSE_VALUE      ((ushort)0xFF)
-#define VTSS_PORT_1G_TX_PAUSE_MASK       0xFFFF   /* 16bit field */
-/* #define VTSS_PORT_1G_TX_PAUSE_XON_XOFF   FALSE */
-
-#define VTSS_PORT_10G_TX_PAUSE_VALUE      ((ushort)0xFF)
-#define VTSS_PORT_10G_TX_PAUSE_MASK       0xFFFF   /* 16bit field */
-/* #define VTSS_PORT_10G_TX_PAUSE_XON_XOFF   FALSE */
-
-
-#define VTSS_SPI4_BURST_SIZE     4
-#define VTSS_SPI4_MAX_BURST_1    8
-#define VTSS_SPI4_MAX_BURST_2    8
-
-#define VTSS_SPI4_OUTPUT_FREQ_390MHZ   390
-#define VTSS_SPI4_OUTPUT_FREQ_312MHZ   312
-#define VTSS_SPI4_OUTPUT_FREQ_195MHZ   195
-#define VTSS_SPI4_OUTPUT_FREQ_156MHZ   156
-
-
-/* Meigs2 physical port numbering */
-#define M2_PHYS_PORT_1G_MIN   0
-#define M2_PHYS_PORT_1G_MAX   9
-
-#define M2_PHYS_PORT_10G     10
-
-
-/* Default values for preamble bit position */
-/*     same values as in the datasheet      */
-#define M2_PREAMBLE_BIT0_POS   0x37
-#define M2_PREAMBLE_BIT1_POS   0x36
-#define M2_PREAMBLE_BIT2_POS   0x35
-#define M2_PREAMBLE_BIT3_POS   0x34
-
-
-/* Default values for burst size from FIFO to the ouput module */
-#define VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_1G_PORT   1
-#define VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_10G_PORT  1
-#define VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_SPI4_2    4
-
-
-#define VTSS_SHAPER_BITRATE_UNIT_PER_PORT   152588
-#define VTSS_SHAPER_BITRATE_UNIT_PER_LINK   305176 
-#define VTSS_SHAPER_LEAKY_BUCKET_UNIT          128
-
-
-/* GPIO number: VTSS_GPIO_NO_START..(VTSS_GPIO_NO_END-1) */
-typedef uint vtss_gpio_no_t;
-
-#define VTSS_GPIOS (16)
-#define VTSS_GPIO_NO_START ((vtss_gpio_no_t)0)
-#define VTSS_GPIO_NO_END   (VTSS_GPIO_NO_START+VTSS_GPIOS)
-
-
-
-/******************************************************************************/
-/***        Default Device Configuration             **************************/
-/******************************************************************************/
-
-
-/*-------        Mapping of logical into physical ports           ------------*/
-/* Port Number: 1..VTSS_PORTS */
-typedef uint vtss_port_no_t;    /* VTSS_PORT_NO_START..(VTSS_PORT_NO_END-1) */
-
-#define VTSS_PORTS              (10+1)
-#define VTSS_PORTS_1G           10
-#define VTSS_PORTS_10G          1 /* How many of the VTSS_PORTS are 10G ports */
-#define VTSS_CHIP_PORTS         11 /* Number of ports inside chip */
-#define VTSS_CHIP_PORT_IS_10G(chip_port) (chip_port == 10)
-
-#define VTSS_PORT_NO_START      ((vtss_port_no_t)1) /* The first logical port 
-						       number is 1 */
-#define VTSS_PORT_NO_END        (VTSS_PORT_NO_START+VTSS_PORTS)
-#define VTSS_PORT_ARRAY_SIZE    VTSS_PORT_NO_END
-
-#define VTSS_PORT_IS_PORT(x)    (x>=VTSS_PORT_NO_START && x<VTSS_PORT_NO_END)
-
-/* MeigsII/MeigsIIe/Campbell port mapping: 0..9 -- 10/100/1000M, 10 -- 10G */
-
-
-
-
-/******************************************************************************/
-/***        General Device Configuration             **************************/
-/******************************************************************************/
-
-/* 1G ports of a MAC device are known to the user under the numbers on the 
-   front panel of the final system. This numeration is not necessarily the same 
-   as the internal numeration from 0..MAX_PORT_NUMBER. Thus the need for 
-   mapping. Terminology: logical port number -- the number on the front panel,
-   physical "chip_port" port number -- internal number from 0 to 
-   MAX_1G_PORT_NUMBER. Some additional information such as the address of the 
-   corresponding PHY device and the number of a MIIM controller to use to 
-   communicate with the PHY device is also in the mapping table */
-
-typedef struct _vtss_mapped_port_t {
-    int     chip_port;          /* Physical port. Set to -1 if not in use. */
-    int     miim_controller;    /* Set to 0 or 1. Set to -1 if not in use. */
-    int     phy_addr;           /* Ignored if miim_controller==-1. */
-} vtss_mapped_port_t;
-
-
-/* 
-   Set physical addresses of logical ports. Index is logical port_no. 
-   The mapping table must be initialized early in the initialization phase,
-   as most funcitons use logical port number as an argument and get the
-   matching physical port from the table.
-*/
-vtss_rc vtss_port_map_set( const vtss_mapped_port_t mapped_ports[VTSS_PORT_ARRAY_SIZE] );
-
-BOOL vtss_port_mapped( const vtss_port_no_t port_no );
-
-
-/*******************************************************************************
-
-  Function vtss_major_mode_set( ).
-
-  Prepares the system to run in one of the major modes.
-  This function must be called only once after reset. If the function is 
-  called when the system is up and running it will return an error.
-  It is not allowed to call this function with VTSS_MAC_MAJOR_MODE_UNDEFINED
-  as an argument.
-
-*******************************************************************************/
-vtss_rc vtss_major_mode_set( vtss_mac_major_mode_t mm);
-
-
-
-/******************************************************************************/
-/***        System Configuration                     **************************/
-/******************************************************************************/
-typedef struct vtss_system_setup_t {
-
-  BOOL big_endian;      /* TRUE -- CPU interface runs as big-endian */
-  uint si_dummy_bytes;  /* number of dummy bytes that will be inserted in the 
-			   reply before valid data when serial interface is used
-			   at high frequency. Set to 0 if not used */
-
-  /* serdes_ref_clk_external must be TRUE when using VSC7323 or VSC7331 */
-  BOOL serdes_ref_clk_external; /* TRUE serdes ref clk is external, 
-				   FALSE -- internal */
-
-  BOOL system_ref_clk_extern;  /* TRUE  -- one of the GPIO pins is used as 
-				  system clock input 
-				  FALSE -- internal source is used for the 
-				  system clock (default)
-			       */
-
-  BOOL single_chip_mode;  /* TRUE -- 1x10G<->10x1G mode is used 
-			     FALSE -- all other modes */
-
-  BOOL rx_chain_mode_10G; /* TRUE -- when in 10G<->SPI4.2 mode 
-		         FALSE -- all other modes */
-
-} vtss_system_setup_t;
-
-
-/*
-  Function vtss_system_setup()
-
-  Performs most basic initialization of the chip.
-  The function must be called after start-up or chip reset.
-
-
-  Arguments:
-       psystem   pointer to a structure with configuration data
-
-  Return code:
-       VTSS_OK   if operation completed successfully
-       
- */
-vtss_rc vtss_system_setup( vtss_system_setup_t *psystem);
-
-/* 
-   This is a supplementary function. It configures a structure referenced 
-   by the pointer to the default values for the chosen major mode.
-   After that the user may modify the fields of the structure for 
-   fine-tuning of the system and than call the vtss_system_setup() function.
-*/
-vtss_rc vtss_system_setup_get_default_values( vtss_system_setup_t *psystem,
-					   vtss_mac_major_mode_t major_mode);
-
-
-/* vtss_chip_reset() performs a software reset of the chip */
-void vtss_chip_reset(void);
-
-
-/* vtss_get_chip_id() returns the content of the chip identification register */
-ulong vtss_chip_id_get(void);
-
-
-
-/******************************************************************************/
-/***        FIFO Configuration                       **************************/
-/******************************************************************************/
-typedef struct _vtss_fifo_block_t {
-  uint top;       /* 2Kbytes granularity */
-  uint bottom;
-} vtss_fifo_block_t;
-
-
-/* Flow control watermarks */
-typedef struct _vtss_fifo_fc_watermarks_t {
-  uint low_watermark; /* 32 bytes granularity */
-  uint high_watermark;
-} vtss_fifo_fc_watermarks_t;
-
-
-/* Cut-through threshold */
-typedef struct _vtss_fifo_cut_through_mode_t {
-  BOOL cut_through_enable;  /* If FALSE -- FIFO runs in store-forward mode */
-  uint threshold_value;
-} vtss_fifo_cut_through_mode_t;
-
-
-/* Ageing mode */
-typedef struct _vtss_fifo_ageing_t {
-  BOOL enable;    /* enables ageing timer */
-  uint interval;  /* ageing interval */
-} vtss_fifo_ageing_t;
-
-
-/* 
-   Used for one-time complete setup of the fifo. Usually used after reset,
-   Using this structure the user can alter the default setup of the block.
-*/
-/* May be used to initialize both ingress and egress fifo */
-typedef struct vtss_fifo_setup_t {
-
-  vtss_fifo_block_t       fifo_port_area[VTSS_PORT_NO_START+VTSS_PORTS_1G];
-  vtss_fifo_fc_watermarks_t fifo_port_wm[VTSS_PORT_NO_START+VTSS_PORTS_1G];
-
-  /* cut-through mode/threshold. If not enabled then store-forward */
-  vtss_fifo_cut_through_mode_t    thrhld[VTSS_PORT_NO_START+VTSS_PORTS_1G];
-
-  vtss_fifo_ageing_t ageing;
-
-  /* */
-  BOOL norm_hdr_used;
-  BOOL prm_hdr_used;
-
-  /**/
-  ulong output_port_offset;
-  ulong input_port_offset;
-
-} vtss_fifo_setup_t;
-
-
-/*-----------------  FIFO setup funcitons   ----------------------------------*/
-
-/*
-  Function vtss_fifo_setup()
-
-  Initializes the FIFO block based on the information in the provided 
-  structures. If the pointer to the structure is set to NULL, the corresponding
-  FIFO will not be initialized (it will be left in its current state).
-
-  The function must be called after start-up and may be called at run-
-  time to reconfigure the FIFO. 
-
-  Note: port mapping table must be initialized.
-
-  Arguments:
-       ps_ingress   pointer to a structure for the ingress fifo
-       ps_egress   pointer to a structure for the egress fifo
-
-  Return code:
-       VTSS_OK   if operation completed successfully
-       
- */
-vtss_rc vtss_fifo_setup( vtss_fifo_setup_t *ps_ingress, 
-			 vtss_fifo_setup_t *ps_egress);
-
-/* 
-   This is a supplementary function. It configures a structure referenced 
-   by the pointer to the default values for the chosen major mode.
-   After that the user may modify the fields of the structure for 
-   fine-tuning of the system and then call the vtss_fifo_setup() function.
-*/
-vtss_rc vtss_fifo_setup_get_default_values( vtss_fifo_setup_t *ps_ingress,
-					    vtss_fifo_setup_t *ps_engress,
-					    vtss_mac_major_mode_t major_mode);
-
-/*-----------------  Run-time funcitons   ------------------------------------*/
-/* 
-   Select store-forward or cut-through mode of fifo for a specified logical 
-   port 
-*/
-vtss_rc vtss_fifo_thrhld_set( vtss_port_no_t portnum, 
-			      vtss_fifo_cut_through_mode_t *pctt_ingress,
-			      vtss_fifo_cut_through_mode_t *pctt_egress);
-
-/*
-  Configure watermarks for a given logical port
-*/
-vtss_rc vtss_fifo_watermarks_set( vtss_port_no_t portnum,
-				  vtss_fifo_fc_watermarks_t *pwm_ingress,
-				  vtss_fifo_fc_watermarks_t *pwm_egress);
-
-
-
-/******************************************************************************/
-/***      10M/100M/1G  Ethernet Port Configuration   **************************/
-/******************************************************************************/
-/* ================================================================= *
- *  Port
- * ================================================================= */
-
-/* - Port Setup (Operational) -------------------------------------- */
-
-/* The different interfaces for connecting MAC and PHY. */
-typedef enum _vtss_port_interface_t {
-    VTSS_PORT_INTERFACE_NO_CONNECTION,  /* No connection */
-    VTSS_PORT_INTERFACE_MII,            /* MII */
-    VTSS_PORT_INTERFACE_GMII,           /* GMII */
-    VTSS_PORT_INTERFACE_RGMII,          /* RGMII */
-    VTSS_PORT_INTERFACE_TBI,            /* TBI */
-    VTSS_PORT_INTERFACE_SERDES,         /* SERDES */
-    VTSS_PORT_INTERFACE_XAUI            /* XAUI */
-} vtss_port_interface_t;
-
-
-typedef struct _vtss_port_interface_mode_t {
-    vtss_port_interface_t   interface_type; /* not just "interface" because it 
-					       is a reserved word in C++ */
-    vtss_speed_t            speed;
-} vtss_port_interface_mode_t;
-
-
-typedef struct _vtss_flowcontrol_setup_t {
-    BOOL                obey;       /* Should PAUSE frames be obeyed. */
-    BOOL                generate;   /* Show flow control:
-				       fdx: PAUSE frames, 
-				       hdx: backpressure  be generated. */
-    vtss_mac_t          smac;
-} vtss_flowcontrol_setup_t;
-
-
-/* Interframe gaps */
-typedef struct _vtss_frame_gaps_t {
-
-    uint    ifg1;
-    uint    ifg2;
-
-} vtss_frame_gaps_t;
-
-
-
-/* Advertisement Word (Refer to IEEE 802.3 Clause 37):
- *  MSB                                                                         LSB
- *  D15  D14  D13  D12  D11  D10   D9   D8   D7   D6   D5   D4   D3   D2   D1   D0 
- * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
- * | NP | Ack| RF2| RF1|rsvd|rsvd|rsvd| PS2| PS1| HD | FD |rsvd|rsvd|rsvd|rsvd|rsvd|
- * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
- */
-
-/* enum used in vtss_autoneg_1000base_x_config_t */
-typedef enum _vtss_autoneg_1000base_x_remote_fault_t {
-                                     /* RF2 */  /* RF1 */
-    VTSS_1000BASEX_LINK_OK          = (( 0 <<1) | ( 0 <<0)),
-    VTSS_1000BASEX_OFFLINE          = (( 1 <<1) | ( 0 <<0)),
-    VTSS_1000BASEX_LINK_FAILURE     = (( 0 <<1) | ( 1 <<0)),
-    VTSS_1000BASEX_AUTONEG_ERROR    = (( 1 <<1) | ( 1 <<0))
-} vtss_autoneg_1000base_x_remote_fault_t;
-
-typedef struct _vtss_autoneg_1000base_x_advertisement_t {
-    BOOL                                    fdx;
-    BOOL                                    hdx;
-    BOOL                                    symmetric_pause;    /* a.k.a. PAUSE (PS1) */
-    BOOL                                    asymmetric_pause;   /* a.k.a. ASM_DIR (PS2) */
-    vtss_autoneg_1000base_x_remote_fault_t  remote_fault;
-    BOOL                                    acknowledge;
-    BOOL                                    next_page;
-} vtss_autoneg_1000base_x_advertisement_t;
-
-
-typedef struct _vtss_pcs_autoneg_control_t {
-    BOOL                                    enable;
-    vtss_autoneg_1000base_x_advertisement_t advertisement;
-} vtss_pcs_autoneg_control_t;
-
-
-
-/* Used for the initial setup of the PCS module */
-typedef struct _vtss_pcs_control_t {
-
-  BOOL   disable_lss_on_gpio14;
-
-  BOOL   disable_link_timer;
-  BOOL   debug_link_timer_select;
-
-  BOOL   signal_detect_polarity_low;
-  BOOL   signal_detect_enable;
-
-  BOOL   show_complete_link_down_counter;
-
-  BOOL   pcs_aneg_sw_resolve;
-
-  BOOL   pcs_autoneg_enable;
-  BOOL   pcs_autoneg_restart;
-
-  vtss_autoneg_1000base_x_advertisement_t advertisement;
-
-} vtss_pcs_control_t;
-
-
-/* Used for the setup of the Serdes module */
-#define VTSS_SERDES_CONFIG_WORD        0x0000003E
-/* the following two values to be written to the SERDES_TEST register */
-#define VTSS_SERDES_RESET_AND_ENABLE   0x00000003
-#define VTSS_SERDES_ENABLE             0x00000023
-
-
-/* Port setup, which may change dynamically, e.g. after auto-negotiation */
-typedef struct _vtss_port_setup_t {
-  vtss_port_interface_mode_t  interface_mode;
-  BOOL                        fdx;                /* Full duplex: TRUE, 
-						     Half duplex: FALSE */
-  vtss_flowcontrol_setup_t    flowcontrol;
-  vtss_frame_gaps_t           frame_gaps;
-  BOOL                        enable_tx_pause_xon_xoff;
-  uint                        tx_pause_value;
-  uint                        maxframelength; /* Max frame length. */
-  BOOL                        vlan_aware;
-  BOOL                        drop_on_length_error;
-  BOOL                        crc_update;
-  vtss_fcs_modify_t           fcs_modify;
-  BOOL                        invert_gtx_tx_clock;  /* HW related */
-  BOOL                        invert_rx_clock;      /* HW related */
-  BOOL norm_hdr_insert;
-  BOOL prm_hdr_insert;
-  uint prm_hdr_value;
-  BOOL norm_hdr_expect;
-  BOOL prm_hdr_expect;
-} vtss_port_setup_t;
-
-
-/* Setup 10M/100M/1G port */
-vtss_rc vtss_port_setup( vtss_port_no_t portnum, vtss_port_setup_t* psetup);
-
-/* 
-   Supplementary function: fills the structure referenced by the pointer 
-   with the default values for a given major_mode.
-
-   Requires global port mapping table to be initialized
-*/
-vtss_rc vtss_port_setup_get_default_values( vtss_port_setup_t* psetup,
-					 vtss_mac_major_mode_t major_mode);
-
-/*----------------  Run-time funcitons  ---------------------------------------*/
-/* Configure speed and duplex mode of a 10M/100M/1G port */
-/*
-  Arguments:
-      portnum   logical port number
-      speed     10M, 100M, 1G
-      fdx       TRUE - full duplex, FALSE -- half duplex
- */
-vtss_rc vtss_port_set_mode( vtss_port_no_t portnum, vtss_speed_t speed, 
-			    BOOL fdx);
-
-/* Enable/disable rx, tx or both in a 10M/100M/1G port */
-vtss_rc vtss_port_set_enable( vtss_port_no_t portnum, BOOL rx_en, BOOL tx_en);
-
-
-/* Set CRC adding/updating mode */
-/* Only 10/100/1000 ports have this feature -- done in the denormalizer */
-vtss_rc vtss_port_fcs_modify( vtss_port_no_t portnum, vtss_fcs_modify_t mc);
-
-/* 
-   Discard/do_not_discard  Ethernet frames with wrong FCS in ingress direciton
-
-   Arguments:
-        portnum   logical port number
-	check     TRUE   -- frames with wrong FCS are discarded (default)
-	          FALSE  -- frames with wrong FCS are forwarded upstream
-*/
-vtss_rc vtss_port_check_fcs( vtss_port_no_t portnum, BOOL check);
-
-
-/* Allow pause frames pass through the device. By default 10M/100M/1G block
-   prevents propagation of pause frames through the device.
- */
-vtss_rc vtss_port_forward_pause_frames( vtss_port_no_t portnum, BOOL allow);
-
-
-
-/*
-  obey -- obeys pause frames from external Eth client 
-  generate -- generate pause frames/backpressure upon request from the 
-              destination (FIFO or the host interface)
-
-  If fc_obey AND fc_generate are set to FALSE, then flow control is disabled
-
-
- */
-vtss_rc vtss_port_flow_control_mode( vtss_port_no_t port_num, 
-				     BOOL fc_obey, 
-				     BOOL fc_generate);
-
-
-
-/******************************************************************************/
-/***      10G  Ethernet Port Configuration           **************************/
-/******************************************************************************/
-
-/* 10G Port setup */
-typedef struct _vtss_10Gport_setup_t {
-  vtss_port_interface_mode_t  interface_mode;
-
-  vtss_flowcontrol_setup_t    flowcontrol;
-
-  uint                        maxframelength; /* Max frame length. */
-
-  BOOL                        enable_tx_pause_xon_xoff;
-  uint                        tx_pause_value;
-
-  BOOL                        vlan_aware;
-  BOOL                        pace_mode;
-  BOOL                        drop_on_length_error;
-  BOOL                        drop_in_range_error;
-
-  /* Extended End-of-packet and Start-of-packet checks */
-  BOOL                        ext_eop_check_enable;
-  BOOL                        ext_sop_check_enable;
-
-  vtss_fcs_modify_t           fcs_modify;
-
-
-  /* Start-of-frame delimiter check */
-  /* Must be disabled, ie set to FALSE, when using preamble trunking */
-  BOOL sfd_check;
-
-  /* Use of the headers */
-  BOOL norm_hdr_insert;
-  BOOL prm_hdr_insert;
-
-  BOOL norm_hdr_expect;
-  BOOL prm_hdr_expect;
-
-
-} vtss_10Gport_setup_t;
-
-
-/* Setup 10G port */
-vtss_rc vtss_10Gport_setup( vtss_port_no_t port_num, vtss_10Gport_setup_t* psetup);
-
-/* 
-   Supplementary function: fills the structure referenced by the pointer 
-   with the default values for a given major_mode.
-
-*/
-vtss_rc vtss_10Gport_setup_get_default_values( vtss_10Gport_setup_t* psetup,
-					    vtss_mac_major_mode_t major_mode);
-
-/*----------------  Run-time funcitons  ---------------------------------------*/
-/* Enable/disable rx, tx or both in a 10G port */
-vtss_rc vtss_10Gport_set_enable( vtss_port_no_t port_num, 
-				 BOOL rx_en, BOOL tx_en);
-
-
-/* Set CRC adding/updating mode */
-vtss_rc vtss_10Gport_fcs_modify( vtss_port_no_t port_num, vtss_fcs_modify_t mc);
-
-
-
-/* Allow pause frames pass through the device. By default 10G block
-   prevents propagation of pause frames through the device.
- */
-vtss_rc vtss_10Gport_forward_pause_frames( vtss_port_no_t port_num, BOOL allow);
-
-
-
-/*
-  obey -- obeys pause frames from external Eth client 
-  generate -- generate pause frames/backpressure upon request from the 
-              destination (FIFO or the host interface)
-
-  If fc_obey AND fc_generate are set to FALSE, then flow control is disabled
-
-
- */
-vtss_rc vtss_10Gport_flow_control_mode( vtss_port_no_t port_num, 
-					BOOL fc_obey, 
-					BOOL fc_generate);
-
-/*
-  Once a 10G Base-X optical module is connected to the XAUI port,
-  this function can use to drive an GPIO connected LED to visualize 
-  signal detection/link status. The CPU must poll this function.
- */
-BOOL vtss_10Gport_signal_detect(void);
-
-
-/******************************************************************************/
-/***        Host Interface (SPI-4.2) Configuration     ************************/
-/******************************************************************************/
-
-/*--        type definitions                           -----------------------*/
-
-typedef enum _vtss_spi4_sch_mode_t {
-  /* Controled by Ingress(Egress)_Fifo_Ctrl register */
-  VTSS_SPI4_BURST_MODE_WITH_HEADER, /* when user wants header on SPI4 */
-  VTSS_SPI4_BURST_MODE,  /* Burst interleaved output */
-  VTSS_SPI4_FRAME_MODE   /* Frame interleaved output */
-} vtss_spi4_sch_mode_t;
-
-
-typedef enum _vtss_spi4_training_mode_t {
-  /* VTSS_SPI4_TRAINING_AUTO not used in Meigs-II */
-  VTSS_SPI4_TRAINING_AUTO, /* issue training sequences in response to all '11's
-			     in the status channel */
-  VTSS_SPI4_TRAINING_OFF,  /* don't issue training sequences */
-  VTSS_SPI4_TRAINING_FORCE /* send training sequences continiously */
-
-} vtss_spi4_training_mode_t;
-
-
-typedef struct _vtss_spi4_setup_t {
-
-  /* 
-     This stucture gives a possibility to alter the default configuration of
-     the spi4 block after reset according to end-user needs.
-  */
-
-  vtss_spi4_sch_mode_t sch_mode;
-  uint burst_size;
-  uint maxburst1;
-  uint maxburst2;
-
-  /* Parameters of the training mode (only in ingress direction) */
-  vtss_spi4_training_mode_t tm;
-  uint alpha;
-  uint tsperiod;
-
-  /* spi4 output frequency*/
-  uint spi4_output_freq; /* 390, 312, 195, 156 MHz */
-
-  /* For the description of the following four elements refer to the desription 
-     of the SPI4 misc register in the datasheet */
-  BOOL spi4_swap_ingress_data;    /* Board dependent */ /* Bit WI, SPI4 MISC reg*/
-  BOOL spi4_swap_egress_data;     /* Board dependent */ /* Bit WE, SPI4 MISC reg*/
-  BOOL spi4_data_clock_skew;      /* Board dependent */
-  BOOL spi4_status_clock_skew;    /* Board dependent */
-
-  /* calendar length is defined by number of ports */
-  BOOL	spi4_calendar_order_ascending;  /* Ascending or descending order */
-  uint	spi4_calendar_m;
-
-  /* In ingress direction */
-  BOOL norm_hdr_strip;
-
-  /* In egress direction */
-  BOOL prm_hdr_expect;
-  BOOL norm_hdr_expect;
-
-
-} vtss_spi4_setup_t;
-
-
-/*--        Setup  Funtions                            -----------------------*/
-vtss_rc vtss_spi4_setup( vtss_spi4_setup_t* ps);
-
-/* Configures a user provided structure with values default for the selected 
-   major mode.
-*/
-vtss_rc vtss_spi4_setup_get_default_values( vtss_spi4_setup_t* ps, 
-					    vtss_mac_major_mode_t mode);
-
-/*--        Run-time Functions                         -----------------------*/
-
-
-/*
-  Function vtss_spi4_fcs_check_enable()
-
-  The function turns on/off FCS check of Ehternet frames arriving from the 
-  host interface. This is done for all channels.
-
-
-  NOTE. FCS check in the SPI4 block must be OFF if the FCS modify feature is
-        used in the egress direction
-
-*/
-vtss_rc vtss_spi4_fcs_check_enable( BOOL check);
-
-
-/*
-  Function vtss_spi4_keep_norm_header()
-
-  The funciton controls whether to strip the normalised header or to keep it.
-  Usually the normalised header is stripped before the frame is sent over 
-  SPI4. However, if the remove receiver can use information in the header, 
-  keeping it may be an advantage.
-
-
-  NOTE. Works in ingress direction
-
-*/
-vtss_rc vtss_spi4_keep_norm_header( BOOL keep);
-
-
-
-/******************************************************************************/
-/***        Flow Control Configuration        *********************************/
-/******************************************************************************/
-
-/* 
-   Function device_flow_control() selects FIFO flow control mode 
-      transparent off -- filling of the FIFO causes generation of pause frames
-      transparent on  -- destination (host i/f), not FIFO, requests pause frames
-
-   Note:
-   This mode is enabled for all 10/100/1000 Eth ports simultaneously 
-*/
-vtss_rc vtss_device_transparent_flow_control_mode( BOOL ingress_enable,
-						   BOOL egress_enable);
-
-
-
-
-
-/******************************************************************************/
-/***        Statistics                                         ****************/
-/******************************************************************************/
-typedef struct _vtss_port_counters_t {
-
-  /* if a counter is not implemented in 10G or 1G module the software will 
-     return 0 */
-  ulong rx_in_bytes;
-  ulong rx_symbol_carrier;
-  ulong rx_pause;
-  ulong rx_unsup_opcode;
-
-  ulong rx_ok_bytes;
-  ulong rx_bad_bytes;
-
-  ulong rx_unicast;
-  ulong rx_multicast;
-  ulong rx_broadcast;
-  ulong rx_crc;
-  ulong rx_alignment; /* 10/100/1G mac only */
-  ulong rx_undersize;
-
-  ulong rx_fragments;
-  ulong rx_in_range_error;
-  ulong rx_out_of_range_error;
-  ulong rx_oversize;
-  ulong rx_jabbers;
-  ulong rx_size_64;
-
-  ulong rx_size_65_to_127;
-  ulong rx_size_128_to_255;
-  ulong rx_size_256_to_511;
-  ulong rx_size_512_to_1023;
-  ulong rx_size_1024_to_1518;
-  ulong rx_size_1519_to_max;
-
-  ulong rx_xgmii_prot_err; /* Only on 10G MAC port */
-
-  ulong rx_ipg_shrink;
-
-
-  ulong tx_out_bytes;
-  ulong tx_pause;
-  ulong tx_ok_bytes;
-
-  ulong tx_unicast;
-  ulong tx_multicast;
-  ulong tx_broadcast;
-
-  ulong tx_multiple_coll; /* 10/100/1G MAC only */
-  ulong tx_late_coll;     /* 10/100/1G MAC only */
-  ulong tx_xcoll;         /* 10/100/1G MAC only */
-  ulong tx_defer;         /* 10/100/1G MAC only */
-  ulong tx_xdefer;        /* 10/100/1G MAC only */
-  ulong tx_carrier_sense; /* 10/100/1G MAC only */
-
-
-  ulong tx_size_64;
-  ulong tx_size_65_to_127;
-  ulong tx_size_128_to_255;
-  ulong tx_size_256_to_511;
-  ulong tx_size_512_to_1023;
-  ulong tx_size_1024_to_1518;
-  ulong tx_size_1519_to_max;
-
-
-  ulong tx_single_coll; /* 10/100/1G MAC only */
-  ulong tx_backoff2;    /* 10/100/1G MAC only */
-  ulong tx_backoff3;    /* 10/100/1G MAC only */
-  ulong tx_backoff4;    /* 10/100/1G MAC only */
-  ulong tx_backoff5;    /* 10/100/1G MAC only */
-  ulong tx_backoff6;    /* 10/100/1G MAC only */
-  ulong tx_backoff7;    /* 10/100/1G MAC only */
-  ulong tx_backoff8;    /* 10/100/1G MAC only */
-  ulong tx_backoff9;    /* 10/100/1G MAC only */
-  ulong tx_backoff10;   /* 10/100/1G MAC only */
-  ulong tx_backoff11;   /* 10/100/1G MAC only */
-  ulong tx_backoff12;   /* 10/100/1G MAC only */
-  ulong tx_backoff13;   /* 10/100/1G MAC only */
-  ulong tx_backoff14;   /* 10/100/1G MAC only */
-  ulong tx_backoff15;   /* 10/100/1G MAC only */
-
-  ulong tx_underrun;
-
-  ulong ingress_overflow_drop;
-  ulong egress_overflow_drop;
-
-
-} vtss_port_counters_t;
-
-
-/*------------   TBD:  Error monitoring    ---------------------------------*/
-/* DIP4, sync errors, fifo ageing drop, etc.. */
-
-
-
-
-/* Clears counter for the logical port */
-vtss_rc vtss_port_counters_clear( const vtss_port_no_t port_no );
-
-/* */
-vtss_rc vtss_port_counters_get( const vtss_port_no_t  port_no,
-				vtss_port_counters_t *pcounters);
-
-
-/******************************************************************************/
-/***        MIIM(MDIO) Interface Functions           **************************/
-/******************************************************************************/
-
-#define VTSS_MIIM_READ_ATTEMPT    0xF000
-
-/* Direct miim read/write operation using miim_controller address as a 
-parameter */
-long vtss_miim_subblock_read( const uint miim_chnl, const uint phy_addr, 
-			       const uint phy_reg);
-void vtss_miim_subblock_write( const uint miim_chnl, const uint phy_addr, 
-			       const uint phy_reg, const ushort value);
-
-
-/* Indirect miim read/write operation. Accesses the PHY corresponding to the 
-   logical port number (PHY address is found via the mapping table)
-*/
-long vtss_miim_port_reg_read( const vtss_port_no_t port_no, 
-			       const uint phy_reg);
-void  vtss_miim_port_reg_write( const vtss_port_no_t port_no, 
-				const uint phy_reg, const ushort value);
-
-
-/******************************************************************************/
-/***        Policer/shaper                           **************************/
-/******************************************************************************/
-typedef ulong   vtss_kbitrate_t;
-
-#define VTSS_DISABLE_SHAPER  ((vtss_kbitrate_t)-1)
-
-vtss_rc vtss_egress_shaper_set( vtss_port_no_t port_no, vtss_kbitrate_t br,
-				ulong lb_lvl);
-vtss_rc vtss_ingress_shaper_set( vtss_port_no_t port_no, vtss_kbitrate_t br,
-				 ulong lb_lvl);
-vtss_rc vtss_egress_common_shaper_set( vtss_kbitrate_t br, ulong lb_lvl);
-vtss_rc vtss_ingress_common_shaper_set( vtss_kbitrate_t br, ulong lb_lvl);
-
-vtss_rc vtss_egress_shaper_get( vtss_port_no_t port_no, vtss_kbitrate_t *pbr, 
-				ulong *lb_lvl);
-vtss_rc vtss_ingress_shaper_get( vtss_port_no_t port_no, vtss_kbitrate_t *pbr, 
-				ulong *lb_lvl);
-vtss_rc vtss_egress_common_shaper_get( vtss_kbitrate_t *pbr, ulong *lb_lvl);
-vtss_rc vtss_ingress_common_shaper_get( vtss_kbitrate_t *pbr, ulong *lb_lvl);
-
-
-
-/******************************************************************************/
-/***        Aggregator Configuration                 **************************/
-/******************************************************************************/
-
-#define M2_AGGR_PMAP_TABLE_SIZE    256
-
-typedef struct _vtss_aggr_mode_t {
-  BOOL preamble_trunking;
-  BOOL mpls_trunking;
-  BOOL mpls_aggregation;
-  BOOL l2_aggr;
-  BOOL l3_aggr;
-  BOOL l4_aggr;
-  union {
-    struct {
-      ulong pos0;
-      ulong pos1;
-      ulong pos2;
-      ulong pos3;
-    } bit;
-    ulong mpls_bitmask;
-  } u;
-
-  BOOL norm_hdr_used;
-
-} vtss_aggr_mode_t;
-
-
-vtss_rc vtss_aggr_pmap_table_set( int index, int portnum);
-
-/* Reinitialises aggregation map table, if the port is mot mapped or disabled */
-/* it will be removed from the table, if the port has been enabled it will be */
-/* added to the table */
-vtss_rc vtss_aggr_pmap_table_initialise( void);
-
-
-/*--        Setup  Funtions                            -----------------------*/
-vtss_rc vtss_aggr_setup( vtss_aggr_mode_t* pam);
-
-/* Configures a user provided structure with values default for the selected 
-   major mode.
-*/
-vtss_rc vtss_aggr_setup_get_default_values( vtss_aggr_mode_t* pam, 
-					    vtss_mac_major_mode_t mmode);
-
-
-/******************************************************************************/
-/***        PCS Autonegotiation (Serdes and TBI)     **************************/
-/******************************************************************************/
-
-vtss_rc vtss_pcs_autoneg_control_get( const vtss_port_no_t                      port_no,
-                                      vtss_pcs_autoneg_control_t * const        control );
-
-vtss_rc vtss_pcs_autoneg_control_set( const vtss_port_no_t                      port_no,
-                                      const vtss_pcs_autoneg_control_t * const  control );
-
-vtss_rc vtss_pcs_autoneg_restart( const vtss_port_no_t  port_no );
-
-
-/* Current state of the PCS autonegotiation state machine */
-typedef enum _vtss_pcs_aneg_state_t {
-  VTSS_PCS_ANEG_STATE_IDLE,      /* Idle */
-  VTSS_PCS_ANEG_STATE_CONFIG,    /* Config (i.e. ANEG in progress) */
-  VTSS_PCS_ANEG_STATE_NOTVALID,  /*  */
-  VTSS_PCS_ANEG_STATE_DATA       /* Data */
-} vtss_pcs_aneg_state_t;
-
-typedef struct _vtss_pcs_autoneg_status_t {
-  vtss_pcs_aneg_state_t                   aneg_state;
-  BOOL                                    aneg_complete;
-  vtss_autoneg_1000base_x_advertisement_t partner_advertisement;
-} vtss_pcs_autoneg_status_t;
-
-
-
-vtss_rc vtss_pcs_autoneg_status_get( const vtss_port_no_t port_no,
-				     vtss_pcs_autoneg_status_t *paneg);
-
-
-typedef struct _vtss_pcs_status_t {
-
-  BOOL  losync;   /* loss of sync: sticky self-cleared bit. PCS sync state 
-		     machine has lost sync at least once since last read 
-		     of the register */
-  BOOL  pcs_in_sync; 
-  BOOL  signal_detected; /* signal_detected indicates that there is light 
-			    in fiber; require SD_EN in the PCS_CTRL register 
-			    to be set */
-  BOOL  jtp_lock;
-  BOOL  jtp_error;
-
-  BOOL  link_status_ok;  /* link_status:  FALSE if link has been down since 
-			    last status read */
-
-  uint  link_down_counter;  /* link down counter: 8bit counter (only 6 bits 
-			       visible), saturates when reaching 256 */
-
-  BOOL  show_ldc_top; /* if TRUE indicates that the link down counter 
-			 is 8 bit long, not 6 bit as usually */
-
-  vtss_pcs_autoneg_status_t autoneg;
-
-} vtss_pcs_status_t;
-
-#define VTSS_PCS_LINK_DOWN_COUNTER_SATURATED 255
-
-/* Returns more detailed status than vtss_pcs_autoneg_status_get */
-vtss_rc vtss_pcs_status_get( const vtss_port_no_t       port_no,
-                             vtss_pcs_status_t * const  status );
-
-
-
-/******************************************************************************/
-/***        Serdes Signal Detect Control             **************************/
-/******************************************************************************/
-vtss_rc vtss_serdes_signal_detect_setup( const vtss_port_no_t port_num,
-					 BOOL enable,
-					 BOOL sd_polarity_high,
-					 BOOL sd_source_extern);
-
-
-/*
-  Reads serdes signal detect status.
-
-  Return values 
-    VTSS_OK                    successful completion
-
-    or an error:
-    VTSS_WRONG_MAJOR_MODE
-    VTSS_MAJOR_MODE_NOT_SET
-    VTSS_PORT_NOT_MAPPED
-
-  If VTSS_OK, then if the content of psignal_detected is 
-    TRUE    signal is detected
-    FALSE   no signal detected
-
-
-*/
-vtss_rc vtss_serdes_extern_signal_detect_status_get( const vtss_port_no_t port_num,
-						     BOOL *psignal_detected);
-
-
-
-
-/******************************************************************************
- * Description: Set GPIO direction to input or output.
- *
- * \param chip_no (input): Chip number (for multi chip targets only).
- * \param gpio_no (input): GPIO pin number.
- * \param output (input) : TRUE if output, FALSE if input.
- *
- * \return : Return code.
- ******************************************************************************/
-#if defined(VTSS_CHIPS)
-vtss_rc vtss_gpio_direction_set(const vtss_chip_no_t chip_no,
-                                const vtss_gpio_no_t gpio_no,
-                                const BOOL output);
-#else
-vtss_rc vtss_gpio_direction_set(const vtss_gpio_no_t gpio_no,
-                                const BOOL output);
-#endif /* VTSS_CHIPS */
-
-
-/******************************************************************************
- * Description: Read from GPIO input pin.
- *
- * \param chip_no (input): Chip number (for multi chip targets only).
- * \param gpio_no (input): GPIO pin number.
- *
- * \return : TRUE if pin is high, FALSE if it is low.
- ******************************************************************************/
-#if defined(VTSS_CHIPS)
-BOOL vtss_gpio_input_read(const vtss_chip_no_t chip_no,
-                          const vtss_gpio_no_t gpio_no);
-#else
-BOOL vtss_gpio_input_read(const vtss_gpio_no_t gpio_no);
-#endif /* VTSS_CHIPS */
-
-
-/******************************************************************************
- * Description: Write to GPIO output pin.
- *
- * \param chip_no (input): Chip number (for multi chip targets only).
- * \param gpio_no (input): GPIO pin number.
- * \param value (input)  : TRUE to set pin high, FALSE to set pin low.
- *
- * \return : TRUE if pin is high, FALSE if it is low.
- ******************************************************************************/
-#if defined(VTSS_CHIPS)
-/* Write to GPIO output pin */
-vtss_rc vtss_gpio_output_write(const vtss_chip_no_t chip_no,
-                            const vtss_gpio_no_t gpio_no, 
-                            const BOOL value);
-#else
-vtss_rc vtss_gpio_output_write(const vtss_gpio_no_t gpio_no, 
-                            const BOOL value);
-#endif /* VTSS_CHIPS */
-
-
-
-/******************************************************************************/
-/***        BIST test                                **************************/
-/******************************************************************************/
-
-#if defined MEIGS2 || defined VSC7321
-#define VTSS_BIST_NAME_SIZE 29
-#else
-#define VTSS_BIST_NAME_SIZE 33
-#endif
-
-
-/******************************************************************************
- * Description: Start a specific bist test
- *
- * \param bist_no (input): bist test number range <0..VTSS_BIST_NAME_SIZE-1>.
- *
- * \return : VTSS_OK if write was started,
- *           VTSS_BIST_CMD_FAILED if last write was still in progress.
- **************************************************************************kbp*/
-vtss_rc vtss_chip_bist_start(const uint bist_no);
-
-
-/******************************************************************************
- * Description: Get result for a specific bist test
- *
- * \param bist_no (input): bist test number range <0..VTSS_BIST_NAME_SIZE-1>.
- *                         >= VTSS_BIST_NAME_SIZE returns the write status.
- *
- * \return : VTSS_OK               when bist test went OK
- *           VTSS_BIST_CMD_FAILED  when write accesses failed.
- *           VTSS_BIST_TEST_FAILED when bist test failed.
- **************************************************************************kbp*/
-vtss_rc vtss_chip_bist_result(const uint bist_no);
-
-
-/******************************************************************************/
-/***        GFP-T Configuration                      **************************/
-/******************************************************************************/
-
-/* Used to define the client signal type for GFP-T */
-#define C1_GFPT_CLIENT_GBE    0x0
-#define C1_GFPT_CLIENT_FC     0x1
-#define C1_GFPT_CLIENT_ESC    0x2
-#define C1_GFPT_CLIENT_DVB    0x3
-
-/* GFP-T Egress Frame Disassembler, Single bit Error Correction mode */
-typedef enum _vtss_gfpt_error_corr_t {
-  VTSS_GFPT_REPLACE_10B_ERR,
-  VTSS_GFPT_FORWARD_ERR,
-  VTSS_GFPT_DISCARD_ERR,
-  VTSS_GFPT_DISABLE_ERR
-} vtss_gfpt_error_corr_t;
-
-/* GFP-T port setup, which may change dynamically */
-typedef struct _vtss_gfpt_setup_t {
-  BOOL                        gfpt_en;
-  BOOL                        source_mode_en;
-  vtss_port_interface_mode_t  interface_mode;
-  uint                        threshold_level;
-  uint                        rate_period;
-  uint                        rate_max_delta;
-  uint                        rate_min_idles;
-  uint                        rate_padding;
-  uint                        frame_length;
-  BOOL                        ingress_header_insert;
-  BOOL                        egress_header_expect;
-  vtss_gfpt_error_corr_t      egress_err_corr;
-} vtss_gfpt_setup_t;
-
-
-/******************************************************************************
- * Description: Setup for GFP-T handling in Campbell-I
- *
- * \param     : portnum
- *              vtss_gfpt_setup_t* gs
- *       
- *
- * \return    : VTSS_OK               
- *              VTSS_PORT_NOT_MAPPED
- *              VTSS_WRONG_PARAMETER
- **************************************************************************kbp*/
-vtss_rc vtss_gfpt_setup( vtss_port_no_t portnum, vtss_gfpt_setup_t* gs);
-
-
-/******************************************************************************
- * Description: Get default setting for GFP-T handling in Campbell-I
- *
- * \param     : vtss_gfpt_setup_t* gs
- *              vtss_port_interface_mode_t  mode
- *
- * \return    : VTSS_OK               
- *              VTSS_WRONG_PARAMETER
- **************************************************************************kbp*/
-vtss_rc vtss_gfpt_setup_get_default_values( vtss_gfpt_setup_t* gs,
-					    vtss_port_interface_mode_t mode);
-
-
-/******************************************************************************/
-/***        Debug Section                            **************************/
-/******************************************************************************/
-
-/*-------------   Loopback  funtions will be added here  ---------------------*/
-
-/*-------------   Error counters will be added here      ---------------------*/
-
-
-BOOL vtss_port_mapped( const vtss_port_no_t port_no );
-BOOL vtss_phy_mapped( const vtss_port_no_t port_no );
-
-#endif /* _VITESSE_HIGHLEVEL_H */
-/****************************************************************************/
-/*                                                                          */
-/*  End of file.                                                            */
-/*                                                                          */
-/****************************************************************************/
diff --git a/drivers/net/nlm_spi4/vitesse_io.c b/drivers/net/nlm_spi4/vitesse_io.c
deleted file mode 100644
index e194d5f..0000000
--- a/drivers/net/nlm_spi4/vitesse_io.c
+++ /dev/null
@@ -1,229 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*
-
-   vitesse_io.c  -- Vitesse hardware access layer.
-
-   This file provides the hardware access to target chip registers.
-   Modify it to fit your configuration.
-
-   Copyright (c) 2003 Vitesse Semiconductor Corporation. All Rights Reserved.
-   Unpublished rights reserved under the copyright laws of the United States of 
-   America, other countries and international treaties. The software is provided
-   without fee. Permission to use, copy, store, modify, disclose, transmit or 
-   distribute the software is granted, provided that this copyright notice must 
-   appear in any copy, modification, disclosure, transmission or distribution of 
-   the software. Vitesse Semiconductor Corporation retains all ownership, 
-   copyright, trade secret and proprietary rights in the software. THIS SOFTWARE
-   HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY INCLUDING, 
-   WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
-   PARTICULAR USE AND NON-INFRINGEMENT.
-
-   $Id: vitesse_io.c,v 1.1.2.4 2007-05-17 01:15:36 rpmbuilder Exp $
-
- */
-
-#include "nlm_vits_wrapper.h"
-#include <asm/netlogic/debug.h>
-
-#define __VTSS_LIBRARY__
-
-#define VTSS_TRACE_LAYER 1
-
-#include "vitesse_io.h"
-#include "meigsii_reg.h"
-
-
-#define VTSS_CHIP_ADDR_MMAP_SIZE (0x8000*sizeof(ulong))
-
-#ifdef VITGENIO
-#include <linux/vitgenio.h>
-#include <fcntl.h> /* open() */
-#include <sys/ioctl.h> /* ioctl() */
-#include <sys/mman.h> /* mmap() */
-#endif
-
-
-
-
-#ifdef CUSTOMERIO
-#endif
-
-#define VTSS_BLK_SYSTEM             M2_BLK_SYSTEM
-#define VTSS_SUBBLK_CTRL            M2_SUBBLK_CTRL
-#define VTSS_REG_SW_RESET           M2_SW_RESET
-#define VTSS_REG_CPU_TRANSFER_SEL   M2_SI_TRANSFER_SEL
-#define VTSS_REG_LOCAL_DATA         M2_LOCAL_DATA
-#define VTSS_REG_LOCAL_STATUS       M2_LOCAL_STATUS
-
-#define VTSS_T_RESET 2000000L
-
-/* ================================================================= *
- *  I/O Layer Helper functions
- * ================================================================= */
-
-
-
-/* ================================================================= *
- *  I/O Layer initialisation and
- *  Chip hardware access configuration (pin polarity etc.)
- * ================================================================= */
-#if 0 
-/* Reset and configure the chip. */
-static void vtss_io_reset_chip( void )
-{
-	/* Reset the chip */
-	vtss_io_write(VTSS_BLK_SYSTEM,VTSS_SUBBLK_CTRL,VTSS_REG_SW_RESET,0x80000001);
-	VTSS_NSLEEP(VTSS_T_RESET);
-
-	/* Set the chip hardware access configuration (pin polarity etc.). */
-	{
-		const ulong DONE_PINPOLARITY_BITS = 0x99999999;
-
-		vtss_io_writemasked(VTSS_BLK_SYSTEM,VTSS_SUBBLK_CTRL,
-					VTSS_REG_CPU_TRANSFER_SEL,
-			(0/*done_pinpolarity_activehigh*/)?0:
-			DONE_PINPOLARITY_BITS,DONE_PINPOLARITY_BITS);
-	}
-}
-#endif
-/* Note: This must be called before any access to the target chip.
- *       vtss_reset_io_layer() calls this directly.
- */
-void vtss_io_reset( void )
-{
-
-#ifdef VITGENIO
-	/* Setup the hardware access (open device driver and setup MMU). */
-	if (vtss_io_state->chip_addr == NULL) {
-		vtss_io_state->fd_driver = open( "/dev/vitgenio", 0 );
-		//VTSS_ASSERT(vtss_io_state->fd_driver != -1);
-
-#ifdef NO_MMAP
-		printf ("VTSS:io_reset no_mmap\n");
-
-		vtss_io_state->chip_addr = (void*)4; /* Any non-NULL value to indicate that the driver is ready. */
-#else
-		vtss_io_state->chip_addr = mmap( 0, VTSS_CHIP_ADDR_MMAP_SIZE, 
-						PROT_READ | PROT_WRITE, 
-						MAP_SHARED, 
-						vtss_io_state->fd_driver, 
-						0 );
-		//VTSS_ASSERT( vtss_io_state->chip_addr != MAP_FAILED );
-#endif
-	}
-
-	/* Call the I/O Layer driver callback, if present. */
-	if (vtss_io_state->io_driver_callback) vtss_io_state->io_driver_callback();
-#endif
-
-
-#ifdef CUSTOMERIO
-	/* Setup the hardware access (open device driver and setup MMU). */
-	/* Call the I/O Layer driver callback, if present. */
-	vtss_io_state->chip_addr = (void*)4;
-	if (vtss_io_state->io_driver_callback) vtss_io_state->io_driver_callback();
-#endif
-	/* Reset and configure the chip. */
-	/* vtss_io_reset_chip(); */
-}
-
-
-
-
-/* ================================================================= *
- *  Chip register access methods
- * ================================================================= */
-
-static ulong vtss_io_pi_read(const uint block, const uint subblock, const uint reg)
-{
-	//VTSS_ASSERT( (block<=0x7)&&(subblock<=0xF)&&(reg<=0xFF) );
-
-	/* Use 32 bit access, letting the CPU split it up to two 16 bit bus accesses */
-	VTSS_NSLEEP( 240 ); /* Refer to the data sheet for timing diagrams. */
-	if ((block==VTSS_BLK_SYSTEM)
-		&&
-	(subblock==VTSS_SUBBLK_CTRL)
-		&&
-	((reg==VTSS_REG_LOCAL_DATA)||(reg==VTSS_REG_LOCAL_STATUS))) {
-		return (ulong)megis_read(block, subblock, reg);
-	} else {
-		/* Perform a dummy read to activate read request. */
-		megis_read(block, subblock, reg) ;
-		/* Wait for data ready. */
-		VTSS_NSLEEP( 1000 ); /* Refer to the data sheet for timing diagrams. */
-		return (ulong)megis_read(VTSS_BLK_SYSTEM, 
-					VTSS_SUBBLK_CTRL, 
-					VTSS_REG_LOCAL_DATA);
-	}
-}
-
-static void vtss_io_pi_write(const uint block, const uint subblock, const uint reg, const ulong value)
-{
-	//VTSS_ASSERT( (block<=0x7)&&(subblock<=0xF)&&(reg<=0xFF) );
-
-	/* Use 32 bit access, letting the CPU 
-	split it up to two 16 bit bus accesses */
-	VTSS_NSLEEP( 120 ); /* Refer to the data sheet for timing diagrams. */
-	megis_write(block, subblock, reg, value);
-}
-
-
-ulong vtss_io_read(uint block, uint subblock, const uint reg)
-{
-	ulong value;
-
-	value = vtss_io_pi_read(block, subblock, reg);
-
-	VTSS_N(("R 0x%01X 0x%01X 0x%02X 0x%08lX",block,subblock,reg,value));
-
-	return value;
-}
-
-void vtss_io_write(uint block, uint subblock, const uint reg, const ulong value)
-{
-	VTSS_N(("W 0x%01X 0x%01X 0x%02X 0x%08lX",block,subblock,reg,value));
-
-	vtss_io_pi_write(block, subblock, reg, value);
-}
-
-void vtss_io_writemasked(uint block, uint subblock, 
-			const uint reg, const ulong value, 
-			const ulong mask)
-{
-	VTSS_N(("M 0x%01X 0x%01X 0x%02X 0x%08lX 0x%08lX",
-		block,subblock,reg,value,mask));
-
-	vtss_io_write(block,subblock,reg, 
-			(vtss_io_read(block,subblock,reg) & ~mask) | 
-			(value & mask) );
-}
-
-
-/* ================================================================= *
- *  I/O Layer state information
- * ================================================================= */
-
-static vtss_io_state_t default_io_state =
-{
-
-	/* The following members must be present: */
-	/* This optional callback function will be called after 
-		the vtss_io_init function has completed. */
-	NULL,       /*void                (*io_driver_callback) (void);*/
-
-	/* The following members are implementation specific: */
-	0,          /*int                 fd_driver;*/
-	NULL        /*ulong *             chip_addr;*/
-
-};
-
-/* Pointer to current state. */
-vtss_io_state_t * vtss_io_state = &default_io_state;
-
diff --git a/drivers/net/nlm_spi4/vitesse_io.h b/drivers/net/nlm_spi4/vitesse_io.h
deleted file mode 100644
index 5bfbd91..0000000
--- a/drivers/net/nlm_spi4/vitesse_io.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*
-
- vitesse_io.h  -- Vitesse hardware access layer.
- This file provides the hardware access to target chip registers.
- Modify it to fit your configuration.
-
- Copyright (c) 2003 Vitesse Semiconductor Corporation. All Rights Reserved.
- Unpublished rights reserved under the copyright laws of the United States of 
- America, other countries and international treaties. The software is provided
- without fee. Permission to use, copy, store, modify, disclose, transmit or 
- distribute the software is granted, provided that this copyright notice must 
- appear in any copy, modification, disclosure, transmission or distribution of 
- the software. Vitesse Semiconductor Corporation retains all ownership, 
- copyright, trade secret and proprietary rights in the software. THIS SOFTWARE
- HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY INCLUDING, 
- WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
- PARTICULAR USE AND NON-INFRINGEMENT.
- 
- $Id: vitesse_io.h,v 1.1.2.3 2006-09-28 01:24:16 nphilips Exp $
-
-*/
-
-#ifndef _VITESSE_IO_H
-#define _VITESSE_IO_H 1
-
-//#include <stdio.h>
-#include "vitesse_common.h"
-
-/* ================================================================= *
- *  I/O Layer initialisation and
- *  Chip hardware access configuration (pin polarity etc.)
- * ================================================================= */
-
-/* Note: This must be called before any access to the target chip.
- *       vtss_reset_io_layer() calls this directly.
- */
-void vtss_io_reset( void );
-
-/* ================================================================= *
- *  Chip register access
- * ================================================================= */
-
-ulong vtss_io_read(uint block, uint subblock, const uint reg);
-void vtss_io_write(uint block, uint subblock, const uint reg, const ulong value);
-void vtss_io_writemasked(uint block, uint subblock, const uint reg, const ulong value, const ulong mask);
-
-
-/* ================================================================= *
- *  I/O Layer state information
- * ================================================================= */
-
-typedef struct _vtss_io_state_t {
-
-/* The following members must be present: */
-    /* This optional callback function will be called after the chip hardware access driver has been opened,
-       but before the chip has been reset and configured for hardware access (pin polarity etc.).
-       It can be used for passing extra parameters to the chip hardware access driver. */
-    void                (*io_driver_callback) (void);
-
-/* The following members are implementation specific: */
-    int                 fd_driver; /* File descriptor to VitGenIO Linux driver */
-    ulong *             chip_addr; /* mmap'ed address of chip */
-
-} vtss_io_state_t;
-
-/* Pointer to I/O layer current state information. */
-extern vtss_io_state_t * vtss_io_state;
-
-#endif /* _VITESSE_IO_H */
diff --git a/drivers/net/nlm_spi4/vitesse_phy_ctrl.c b/drivers/net/nlm_spi4/vitesse_phy_ctrl.c
deleted file mode 100644
index 3608795..0000000
--- a/drivers/net/nlm_spi4/vitesse_phy_ctrl.c
+++ /dev/null
@@ -1,440 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/************************************************************-*- mode: C -*-*/
-/*                                                                          */
-/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
-/*                           All Rights Reserved.                           */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*                            Copyright Notice:                             */
-/*                                                                          */
-/*  Unpublished rights reserved under the copyright laws of the United      */
-/*  States of America, other countries and international treaties.          */
-/*                                                                          */
-/*      The software is provided without fee.                               */
-/*                                                                          */
-/*  Permission to use,  copy, store, modify, disclose, transmit or          */
-/*  distribute the software is granted, provided that this copyright notice */
-/*  must appear in any copy, modification, disclosure, transmission or      */
-/*  distribution of the software.                                           */
-/*                                                                          */
-/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
-/*  trade secret and proprietary rights in the software.                    */
-/*                                                                          */
-/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
-/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
-/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
-/*                                                                          */
-/*    $Id: vitesse_phy_ctrl.c,v 1.1.2.3 2006-09-28 01:24:16 nphilips Exp $           */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*  File content:                                                           */
-/*                                                                          */
-/*  vitesse_phy_ctrl.c -- C-library for controlling PHY devices             */
-/*                        Copied/compiled from Heathrow PHY ctrl functions  */
-/*                                                                          */
-/****************************************************************************/
-#include "vitesse_highlevel.h"
-#include "meigsii_reg.h"
-#include "vitesse_io.h"
-#include "vitesse_phy_ctrl.h"
-#include <asm/netlogic/debug.h>
-
-
-/* ================================================================= *
- *  PHY
- * ================================================================= */
-
-/* - Read/Write PHY registers via MII-Management ------------------- */
-/* returns >=0: (ushort)result or <0: (long)error */
-long vtss_phy_read(             const vtss_port_no_t    port_no,
-		const uint              phy_reg )
-{
-	long rc;
-
-	if (!vtss_phy_mapped(port_no)) return VTSS_PHY_NOT_MAPPED;
-	rc = vtss_miim_port_reg_read( port_no, phy_reg );
-	if (rc<0) return VTSS_PHY_READ_ERROR;
-	return rc;
-}
-
-vtss_rc vtss_phy_write(         const vtss_port_no_t    port_no,
-		const uint              phy_reg,
-		const ushort            value )
-{
-	if (!vtss_phy_mapped(port_no)) return VTSS_PHY_NOT_MAPPED;
-	vtss_miim_port_reg_write( port_no, phy_reg, value );
-	return VTSS_OK;
-}
-
-vtss_rc vtss_phy_writemasked(   const vtss_port_no_t    port_no,
-		const uint              phy_reg,
-		const ushort            value,
-		const ushort            mask )
-{
-	long rc;
-
-	if (!vtss_phy_mapped(port_no)) return VTSS_PHY_NOT_MAPPED;
-	rc = vtss_miim_port_reg_read( port_no, phy_reg );
-	if (rc<0) return VTSS_PHY_READ_ERROR;
-	rc = (rc & (0xFFFF^mask)) | (value & mask);
-	vtss_miim_port_reg_write( port_no, phy_reg, rc );
-	return VTSS_OK;
-}
-
-/* - PHY Registers, see IEEE 802.3 clause 22.2.4 ------------------- */
-
-vtss_rc vtss_phy_reset( const vtss_port_no_t port_no )
-{
-	vtss_rc rc;
-	vtss_phy_control_t  control;
-
-	control.reset = 1;
-	if ((rc=vtss_phy_control_set( port_no, &control ))<0) return rc;
-	do {
-		uint read_attempt=0;
-		do {
-			rc = vtss_phy_control_get( port_no, &control );
-		} while ((rc==VTSS_PHY_READ_ERROR) 
-				&& 
-			(read_attempt++<VTSS_PHY_RESET_READ_MAXRETRIES));
-		if (rc<0) return rc;
-	} while (control.reset);
-	return VTSS_OK;
-}
-
-vtss_rc vtss_phy_control_get(   const vtss_port_no_t                port_no,
-		vtss_phy_control_t * const          control )
-{
-	long reg0;
-
-	if ((reg0 = vtss_phy_read( port_no, 0 ))<0) return (vtss_rc)reg0;
-	control->reset          = MAKEBOOL01(reg0 & (1<<15));
-	control->loopback       = MAKEBOOL01(reg0 & (1<<14));
-	switch ( reg0 & ((1<<6)|(1<<13)) ) {
-	case (1<<6)|(1<<13): control->speed = VTSS_SPEED_UNDEFINED; 
-		break;
-	case (1<<6)|(0<<13): control->speed = VTSS_SPEED_1G; 
-		break;
-	case (0<<6)|(1<<13): control->speed = VTSS_SPEED_100M; 
-		break;
-	case (0<<6)|(0<<13): control->speed = VTSS_SPEED_10M; 
-		break;
-	}
-	control->autoneg_enable = MAKEBOOL01(reg0 & (1<<12));
-	control->powerdown      = MAKEBOOL01(reg0 & (1<<11));
-	control->isolate        = MAKEBOOL01(reg0 & (1<<10));
-	control->autoneg_restart = MAKEBOOL01(reg0 & (1<< 9));
-	control->fdx            = MAKEBOOL01(reg0 & (1<< 8));
-	control->collision_test = MAKEBOOL01(reg0 & (1<< 7));
-	return VTSS_OK;
-}
-
-vtss_rc vtss_phy_control_set(   const vtss_port_no_t                port_no,
-				const vtss_phy_control_t * const    control )
-{
-	vtss_rc rc;
-	ushort reg0 = 0;
-
-	reg0 |= control->reset          ? (1<<15) : 0;
-	reg0 |= control->loopback       ? (1<<14) : 0;
-	switch (control->speed) {
-	case VTSS_SPEED_UNDEFINED:  
-		reg0 |= (1<<6)|(1<<13); 
-		break;
-	case VTSS_SPEED_1G:         
-		reg0 |= (1<<6)|(0<<13); 
-		break;
-	case VTSS_SPEED_100M:       
-		reg0 |= (0<<6)|(1<<13); 
-		break;
-	case VTSS_SPEED_10M:        
-		reg0 |= (0<<6)|(0<<13); 
-		break;
-	default:  
-		reg0 |= (1<<6)|(1<<13); 
-		break;
-	}
-	reg0 |= control->autoneg_enable ? (1<<12) : 0;
-	reg0 |= control->powerdown      ? (1<<11) : 0;
-	reg0 |= control->isolate        ? (1<<10) : 0;
-	reg0 |= (control->autoneg_enable && control->autoneg_restart) ? (1<< 9) : 0;
-	reg0 |= control->fdx            ? (1<< 8) : 0;
-	reg0 |= control->collision_test ? (1<< 7) : 0;
-
-	rc=vtss_phy_write( port_no, 0, reg0 );
-#if VTSS_PHY_RESET_PAUSE
-	if (control->reset) {
-		/* Wait after issuing a soft reset to the PHY. */
-		VTSS_NSLEEP(VTSS_PHY_RESET_PAUSE);
-	}
-#endif
-	return rc;
-}
-
-vtss_rc vtss_phy_status_get(    const vtss_port_no_t        port_no,
-		vtss_phy_status_t * const   status )
-{
-	const long reg1 = vtss_phy_read( port_no, 1 );
-	if (reg1<0) return (vtss_rc)reg1;
-	status->ability_100base_t4              = MAKEBOOL01(reg1 & (1<<15));
-	status->ability_100base_x_fdx           = MAKEBOOL01(reg1 & (1<<14));
-	status->ability_100base_x_hdx           = MAKEBOOL01(reg1 & (1<<13));
-	status->ability_10mbps_fdx              = MAKEBOOL01(reg1 & (1<<12));
-	status->ability_10mbps_hdx              = MAKEBOOL01(reg1 & (1<<11));
-	status->ability_100base_t2_fdx          = MAKEBOOL01(reg1 & (1<<10));
-	status->ability_100base_t2_hdx          = MAKEBOOL01(reg1 & (1<< 9));
-	status->accepts_mf_preamble_suppression = MAKEBOOL01(reg1 & (1<< 6));
-	status->autoneg_complete                = MAKEBOOL01(reg1 & (1<< 5));
-	status->remote_fault                    = MAKEBOOL01(reg1 & (1<< 4));
-	status->ability_autoneg                 = MAKEBOOL01(reg1 & (1<< 3));
-	status->link_status                     = MAKEBOOL01(reg1 & (1<< 2));
-	status->jabber_detected                 = MAKEBOOL01(reg1 & (1<< 1));
-	status->extended_capability             = MAKEBOOL01(reg1 & (1<< 0));
-	status->extended_status                 = MAKEBOOL01(reg1 & (1<< 8));
-	if (status->extended_status) {
-		const long reg15 = vtss_phy_read( port_no, 15 );
-		if (reg15<0) return (vtss_rc)reg15;
-		status->extended.ability_1000base_x_fdx = 
-					MAKEBOOL01(reg15 & (1<<15));
-		status->extended.ability_1000base_x_hdx = 
-					MAKEBOOL01(reg15 & (1<<14));
-		status->extended.ability_1000base_t_fdx = 
-					MAKEBOOL01(reg15 & (1<<13));
-		status->extended.ability_1000base_t_hdx = 
-					MAKEBOOL01(reg15 & (1<<12));
-	} else {
-		status->extended.ability_1000base_x_fdx = 0;
-		status->extended.ability_1000base_x_hdx = 0;
-		status->extended.ability_1000base_t_fdx = 0;
-		status->extended.ability_1000base_t_hdx = 0;
-	}
-	return VTSS_OK;
-}
-
-/* Note: This function can be used to see if a PHY is present by calling it with id=NULL. */
-vtss_rc vtss_phy_id_get(const vtss_port_no_t    port_no,
-			vtss_phy_id_t * const   id )
-{
-	long reg2, reg3;
-
-	if ((reg2 = vtss_phy_read( port_no, 2 ))<0) 
-		return (vtss_rc)reg2;
-	if ((reg3 = vtss_phy_read( port_no, 3 ))<0) 
-		return (vtss_rc)reg3;
-	if (id) {
-		/* 16 bits from reg2 and 6 bits from reg3 */
-		id->manufacturer = (reg2 <<6) | ((reg3 >> 10) & 0x3F); 
-		id->model        = (reg3 >> 4) & 0x3F; /* 6 bits */
-		id->revision     = reg3 & 0xF;         /* 4 bits */
-	}
-	return VTSS_OK;
-}
-
-vtss_rc vtss_phy_autoneg_advertisement_get( const 	uint   	port_no,
-		vtss_phy_autoneg_advertisement_t * const        advertisement )
-{
-	long reg4;
-
-	if ((reg4 = vtss_phy_read( port_no, 4 ))<0) return (vtss_rc)reg4;
-	advertisement->ability_100base_t4   = MAKEBOOL01(reg4 & (1<< 9));
-	advertisement->ability_100base_x_fdx= MAKEBOOL01(reg4 & (1<< 8));
-	advertisement->ability_100base_x_hdx= MAKEBOOL01(reg4 & (1<< 7));
-	advertisement->ability_10base_t_fdx = MAKEBOOL01(reg4 & (1<< 6));
-	advertisement->ability_10base_t_hdx = MAKEBOOL01(reg4 & (1<< 5));
-	advertisement->symmetric_pause      = MAKEBOOL01(reg4 & (1<<10));
-	advertisement->asymmetric_pause     = MAKEBOOL01(reg4 & (1<<11));
-	advertisement->remote_fault         = MAKEBOOL01(reg4 & (1<<13));
-	advertisement->acknowledge          = 0;    /* Unused in Register 4 */
-	advertisement->next_page_present    = MAKEBOOL01(reg4 & (1<<15));
-	return VTSS_OK;
-}
-
-vtss_rc vtss_phy_autoneg_advertisement_set( const uint   port_no,
-		const vtss_phy_autoneg_advertisement_t * const  advertisement )
-{
-	ushort reg4 = 0;
-
-	reg4 |= advertisement->ability_100base_t4   ? (1<< 9) : 0;
-	reg4 |= advertisement->ability_100base_x_fdx? (1<< 8) : 0;
-	reg4 |= advertisement->ability_100base_x_hdx? (1<< 7) : 0;
-	reg4 |= advertisement->ability_10base_t_fdx ? (1<< 6) : 0;
-	reg4 |= advertisement->ability_10base_t_hdx ? (1<< 5) : 0;
-	reg4 |= advertisement->symmetric_pause      ? (1<<10) : 0;
-	reg4 |= advertisement->asymmetric_pause     ? (1<<11) : 0;
-	reg4 |= advertisement->remote_fault         ? (1<<13) : 0;
-	/* advertisement->acknowledge is unused in Register 4 */
-	reg4 |= advertisement->next_page_present    ? (1<<15) : 0;
-
-	/* Selector field must be set to 1 for IEEE802.3 twisted pair. 
-	(Refer to IEEE 802.3 Clause 28.2.1.2.1 and Annex 28A) */
-	reg4 |= ((1 & 0x1F)<<0);
-
-	return vtss_phy_write( port_no, 4, reg4 );
-}
-
-vtss_rc vtss_phy_autoneg_linkpartner_ability_get(   const uint    port_no,
-		vtss_phy_autoneg_advertisement_t * const    linkpartner_advertisement )
-{
-	long reg5;
-
-	if ((reg5 = vtss_phy_read( port_no, 5 ))<0) return (vtss_rc)reg5;
-	linkpartner_advertisement->ability_100base_t4   = 
-					MAKEBOOL01(reg5 & (1<< 9));
-	linkpartner_advertisement->ability_100base_x_fdx= 
-					MAKEBOOL01(reg5 & (1<< 8));
-	linkpartner_advertisement->ability_100base_x_hdx= 
-					MAKEBOOL01(reg5 & (1<< 7));
-	linkpartner_advertisement->ability_10base_t_fdx = 
-					MAKEBOOL01(reg5 & (1<< 6));
-	linkpartner_advertisement->ability_10base_t_hdx = 
-					MAKEBOOL01(reg5 & (1<< 5));
-	linkpartner_advertisement->symmetric_pause      = 
-					MAKEBOOL01(reg5 & (1<<10));
-	linkpartner_advertisement->asymmetric_pause     = 
-					MAKEBOOL01(reg5 & (1<<11));
-	linkpartner_advertisement->remote_fault         = 
-					MAKEBOOL01(reg5 & (1<<13));
-	linkpartner_advertisement->acknowledge          = 
-					MAKEBOOL01(reg5 & (1<<14));
-	linkpartner_advertisement->next_page_present    = 
-					MAKEBOOL01(reg5 & (1<<15));
-	return VTSS_OK;
-}
-
-vtss_rc vtss_phy_masterslave_control_get(   const vtss_port_no_t    port_no,
-		vtss_phy_masterslave_control_t * const  masterslave_control )
-{
-	long reg9;
-
-	if ((reg9 = vtss_phy_read( port_no, 9 ))<0) 
-		return (vtss_rc)reg9;
-	masterslave_control->test_mode              = 
-					(reg9 & (7<<13)) >> 13;
-	masterslave_control->masterslave_force      = 
-					MAKEBOOL01(reg9 & (1<<12));
-	masterslave_control->masterslave_master     = 
-					MAKEBOOL01(reg9 & (1<<11));
-	masterslave_control->port_type              = 
-					MAKEBOOL01(reg9 & (1<<10));
-	masterslave_control->ability_1000base_t_fdx = 
-					MAKEBOOL01(reg9 & (1<< 9));
-	masterslave_control->ability_1000base_t_fdx = 
-					MAKEBOOL01(reg9 & (1<< 8));
-	return VTSS_OK;
-}
-
-vtss_rc vtss_phy_masterslave_control_set(   const vtss_port_no_t  port_no,
-	const vtss_phy_masterslave_control_t * const  masterslave_control )
-{
-	ushort reg9 = 0;
-
-	reg9 |= (masterslave_control->test_mode & 7)            <<13;
-	reg9 |= masterslave_control->masterslave_force      ? (1<<12) : 0;
-	reg9 |= masterslave_control->masterslave_master     ? (1<<11) : 0;
-	reg9 |= masterslave_control->port_type              ? (1<<10) : 0;
-	reg9 |= masterslave_control->ability_1000base_t_fdx ? (1<< 9) : 0;
-	reg9 |= masterslave_control->ability_1000base_t_fdx ? (1<< 8) : 0;
-
-	return vtss_phy_write( port_no, 9, reg9 );
-}
-
-vtss_rc vtss_phy_masterslave_status_get(    const vtss_port_no_t     port_no,
-	vtss_phy_masterslave_status_t * const   masterslave_status )
-{
-	long reg10;
-
-	if ((reg10 = vtss_phy_read( port_no, 10 ))<0) return (vtss_rc)reg10;
-	masterslave_status->fault                               = 
-					MAKEBOOL01(reg10 & (1<<15));
-	masterslave_status->master                              = 
-					MAKEBOOL01(reg10 & (1<<14));
-	masterslave_status->local_receiver_status_ok            = 
-					MAKEBOOL01(reg10 & (1<<13));
-	masterslave_status->remote_receiver_status_ok           = 
-					MAKEBOOL01(reg10 & (1<<12));
-	masterslave_status->linkpartner_ability_1000base_t_fdx  = 
-					MAKEBOOL01(reg10 & (1<<11));
-	masterslave_status->linkpartner_ability_1000base_t_hdx  = 
-					MAKEBOOL01(reg10 & (1<<10));
-	masterslave_status->idle_error_count                    = 
-							reg10 & 0xFF;
-	return VTSS_OK;
-}
-
-/* - PHY Auto-Negotiation and Forced Speed ------------------------- */
-
-/* Note: Some PHYs (DP83865) requires a reset to run with forced speed. This function does not reset the PHY. */
-vtss_rc vtss_phy_force_speed(   const vtss_port_no_t    port_no,
-		const vtss_speed_t      speed,
-		const BOOL              fdx /* Full duplex: TRUE, Half duplex: FALSE */ )
-{
-	vtss_rc rc;
-	vtss_phy_status_t   status;
-	vtss_phy_control_t  control;
-
-	/* Verify PHY ability. */
-	if ((rc=vtss_phy_status_get( port_no, &status ))<0) 
-		return rc;
-	switch (speed) {
-	case VTSS_SPEED_10M:
-		if (fdx) {
-			if (status.ability_10mbps_fdx) break;
-		} else {
-			if (status.ability_10mbps_hdx) break;
-		}
-		return VTSS_PHY_ABILITY;
-	case VTSS_SPEED_100M:
-		if (fdx) {
-			if (status.ability_100base_x_fdx) break;
-			if (status.ability_100base_t2_fdx) break;
-		} else {
-			/* Note: 100Base-T4 is always half duplex. */
-			if (status.ability_100base_t4) break;
-			if (status.ability_100base_x_hdx) break;
-			if (status.ability_100base_t2_hdx) break;
-		}
-		return VTSS_PHY_ABILITY;
-	case VTSS_SPEED_1G:
-		if (!status.extended_status) return VTSS_PHY_ABILITY;
-		if (fdx) {
-			if (status.extended.ability_1000base_x_fdx) break;
-			if (status.extended.ability_1000base_t_fdx) break;
-		} else {
-			if (status.extended.ability_1000base_x_hdx) break;
-			if (status.extended.ability_1000base_t_hdx) break;
-		}
-		return VTSS_PHY_ABILITY;
-	default:
-		return VTSS_PHY_ABILITY;
-	}
-
-	/* Set PHY mode. */
-	control.reset           = 0;
-	control.loopback        = 0;
-	control.speed           = speed;
-	control.autoneg_enable  = 0;
-	control.powerdown       = 0;
-	control.isolate         = 0;
-	control.autoneg_restart = 0;
-	control.fdx             = fdx;
-	control.collision_test  = 0;
-	return vtss_phy_control_set( port_no, &control );
-}
-
-
-
-
-/****************************************************************************/
-/*                                                                          */
-/*  End of file.                                                            */
-/*                                                                          */
-/****************************************************************************/
diff --git a/drivers/net/nlm_spi4/vitesse_phy_ctrl.h b/drivers/net/nlm_spi4/vitesse_phy_ctrl.h
deleted file mode 100644
index f6de7e7..0000000
--- a/drivers/net/nlm_spi4/vitesse_phy_ctrl.h
+++ /dev/null
@@ -1,292 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/************************************************************-*- mode: C -*-*/
-/*                                                                          */
-/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
-/*                           All Rights Reserved.                           */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*                            Copyright Notice:                             */
-/*                                                                          */
-/*  Unpublished rights reserved under the copyright laws of the United      */
-/*  States of America, other countries and international treaties.          */
-/*                                                                          */
-/*      The software is provided without fee.                               */
-/*                                                                          */
-/*  Permission to use,  copy, store, modify, disclose, transmit or          */
-/*  distribute the software is granted, provided that this copyright notice */
-/*  must appear in any copy, modification, disclosure, transmission or      */
-/*  distribution of the software.                                           */
-/*                                                                          */
-/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
-/*  trade secret and proprietary rights in the software.                    */
-/*                                                                          */
-/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
-/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
-/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
-/*                                                                          */
-/*    $Id: vitesse_phy_ctrl.h,v 1.1.2.3 2006-09-28 01:24:16 nphilips Exp $           */
-/*                                                                          */
-/****************************************************************************/
-/*                                                                          */
-/*  File content:                                                           */
-/*                                                                          */
-/*  vitesse_phy_ctrl.h -- C-library for controlling PHY devices             */
-/*                                                                          */
-/*                                                                          */
-/****************************************************************************/
-
-
-
-/* ================================================================= *
- *  PHY
- * ================================================================= */
-
-/* - Read/Write PHY registers via MII-Management ------------------- */
-
-/* returns >=0: (ushort)result or <0: (long)error */
-long vtss_phy_read(             const vtss_port_no_t    port_no,
-                                const uint              phy_reg );
-
-vtss_rc vtss_phy_write(         const vtss_port_no_t    port_no,
-                                const uint              phy_reg,
-                                const ushort            value );
-
-vtss_rc vtss_phy_writemasked(   const vtss_port_no_t    port_no,
-                                const uint              phy_reg,
-                                const ushort            value,
-                                const ushort            mask );
-
-/* - PHY Registers, see IEEE 802.3 clause 22.2.4 ------------------- */
-
-/* Some PHYs do not respond to MII-M READ during Reset, although they
-   must (according to IEEE 802.3 clause 22.2.4.1.1), so we try reading
-   a number of times before we give up when there is no read response
-   from the PHY during reset. Set to 0 to disable retrying. */
-#define VTSS_PHY_RESET_READ_MAXRETRIES 15625
-
-/* Some PHYs require silence on the MII-M bus a short period after
-   soft reset, so we pause this many nanoseconds.
-   Set to 0 to disable. */
-#define VTSS_PHY_RESET_PAUSE 1000
-
-vtss_rc vtss_phy_reset( const vtss_port_no_t port_no );
-
-/* PHY Basic Capability registers */
-
-/* PHY Control Register (Register 0) */
-typedef struct _vtss_phy_control_t {
-    BOOL                reset;              /* Self Clearing */
-    BOOL                loopback;
-    vtss_speed_t        speed;
-    BOOL                autoneg_enable;
-    BOOL                powerdown;
-    BOOL                isolate;
-    BOOL                autoneg_restart;    /* Self Clearing */
-    BOOL                fdx;                /* Full duplex: TRUE, Half duplex: FALSE */
-    BOOL                collision_test;
-} vtss_phy_control_t;
-
-vtss_rc vtss_phy_control_get(   const vtss_port_no_t                port_no,
-                                vtss_phy_control_t * const          control );
-
-vtss_rc vtss_phy_control_set(   const vtss_port_no_t                port_no,
-                                const vtss_phy_control_t * const    control );
-
-/* PHY Status Registers (Registers 1 and 15) */
-/* Note: The link_status entry is "shared" between vtss_port_status and 
-	vtss_phy_status_get functions. 
-*/
-
-typedef struct _vtss_phy_status_t {
-    BOOL            ability_100base_t4; /* Note: 100Base-T4 is always hdx. */
-    BOOL            ability_100base_x_fdx; /* Covers 100Base-TX or 100Base-FX */
-    BOOL            ability_100base_x_hdx; /* Covers 100Base-TX or 100Base-FX */
-    BOOL            ability_10mbps_fdx;
-    BOOL            ability_10mbps_hdx;
-    BOOL            ability_100base_t2_fdx;
-    BOOL            ability_100base_t2_hdx;
-    BOOL            accepts_mf_preamble_suppression;
-    BOOL            autoneg_complete;
-    BOOL            remote_fault;
-    BOOL            ability_autoneg;
-    BOOL            link_status;
-    BOOL            jabber_detected;
-    BOOL            extended_capability;    /* PHY supports Registers 2-14 and 16-31 */
-    BOOL            extended_status;
-    struct {
-    BOOL            ability_1000base_x_fdx;
-    BOOL            ability_1000base_x_hdx;
-    BOOL            ability_1000base_t_fdx;
-    BOOL            ability_1000base_t_hdx;
-    }               extended;    /* Only available when extended_status==TRUE. */
-} vtss_phy_status_t;
-
-vtss_rc vtss_phy_status_get(    const vtss_port_no_t        port_no,
-                                vtss_phy_status_t * const   status );
-
-/* PHY Extended Capability registers */
-
-/* PHY Identifier (Registers 2 and 3) */
-typedef struct _vtss_phy_id_t {
-    uint            manufacturer;   /* 22 bits (bits 3-24 of the manufacturer's OUI) */
-    uint            model;          /* 6 bits */
-    uint            revision;       /* 4 bits */
-} vtss_phy_id_t;
-
-/* Note: This function can be used to see if a PHY is present by calling it with id=NULL. */
-vtss_rc vtss_phy_id_get(    const vtss_port_no_t    port_no,
-                            vtss_phy_id_t * const   id );
-
-/* PHY Auto-Negotiation Advertisement (Register 4) and Link Partner Ability (Register 5) */
-typedef struct _vtss_phy_autoneg_advertisement_t {
-    BOOL            ability_100base_t4; /* Note: 100Base-T4 is always half duplex. */
-    BOOL            ability_100base_x_fdx; /* Covers 100Base-TX or 100Base-FX */
-    BOOL            ability_100base_x_hdx; /* Covers 100Base-TX or 100Base-FX */
-    BOOL            ability_10base_t_fdx;
-    BOOL            ability_10base_t_hdx;
-    BOOL            symmetric_pause;    /* a.k.a. PAUSE (PS1) */
-    BOOL            asymmetric_pause;   /* a.k.a. ASM_DIR (PS2) */
-    BOOL            remote_fault;
-    BOOL            acknowledge;    /* Unused in Register 4 */
-    BOOL            next_page_present;
-} vtss_phy_autoneg_advertisement_t;
-
-/* PHY Auto-Negotiation Advertisement (Register 4) */
-vtss_rc vtss_phy_autoneg_advertisement_get( const uint   port_no,
-      vtss_phy_autoneg_advertisement_t * const        advertisement );
-
-/* PHY Auto-Negotiation Advertisement (Register 4) */
-vtss_rc vtss_phy_autoneg_advertisement_set( const uint   port_no,
-        const vtss_phy_autoneg_advertisement_t * const  advertisement );
-
-/* PHY Auto-Negotiation Link Partner Ability (Register 5) */
-vtss_rc vtss_phy_autoneg_linkpartner_ability_get(   const uint    port_no,
-      vtss_phy_autoneg_advertisement_t * const    linkpartner_advertisement );
-
-/* PHY Master-Slave Control Register (Register 9), 1000Base-T only. 
-Set this before PHY Control Register */
-typedef struct _vtss_phy_masterslave_control_t {
-    uint                test_mode;          /* (3 bits wide), 0: Normal operation */
-    BOOL                masterslave_force;  /* Manually set Master/Slave mode */
-    BOOL                masterslave_master; /* Only used when masterslave_force==TRUE */
-    BOOL                port_type;          /* TRUE: multi-port device, FALSE: single-port device */
-    BOOL                ability_1000base_t_fdx; /* Used for Auto-Negotiation */
-    BOOL                ability_1000base_t_hdx; /* Used for Auto-Negotiation */
-} vtss_phy_masterslave_control_t;
-
-vtss_rc vtss_phy_masterslave_control_get(   const vtss_port_no_t  port_no,
-     vtss_phy_masterslave_control_t * const          masterslave_control );
-
-vtss_rc vtss_phy_masterslave_control_set(   const vtss_port_no_t   port_no,
-      const vtss_phy_masterslave_control_t * const    masterslave_control );
-
-/* PHY Master-Slave Status Register (Register 10), 1000Base-T only */
-typedef struct _vtss_phy_masterslave_status_t {
-    BOOL                fault;
-    BOOL                master;
-    BOOL                local_receiver_status_ok;
-    BOOL                remote_receiver_status_ok;
-    BOOL                linkpartner_ability_1000base_t_fdx; /* Used for Auto-Negotiation */
-    BOOL                linkpartner_ability_1000base_t_hdx; /* Used for Auto-Negotiation */
-    uchar               idle_error_count;   /* Saturates when reaching 0xFF */
-} vtss_phy_masterslave_status_t;
-
-vtss_rc vtss_phy_masterslave_status_get(    const vtss_port_no_t    port_no,
-         vtss_phy_masterslave_status_t * const   masterslave_status );
-
-/* - PHY Auto-Negotiation and Forced Speed ------------------------- */
-
-vtss_rc vtss_phy_force_speed(   const vtss_port_no_t    port_no,
-                                const vtss_speed_t      speed,
-                                const BOOL              fdx /* Full duplex: TRUE, 
-				Half duplex: FALSE */ );
-
-
-#if defined(HEATHROW2) || defined(STAPLEFORD)
-/* ================================================================= *
- *  TBI Auto-Negotiation and Status
- * ================================================================= */
-
-BOOL vtss_tbi_enabled(  const vtss_port_no_t    port_no );
-
-/* Advertisement Word (Refer to IEEE 802.3 Clause 37):
- *  MSB                                                                         LSB
- *  D15  D14  D13  D12  D11  D10   D9   D8   D7   D6   D5   D4   D3   D2   D1   D0 
- * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
- * | NP | Ack| RF2| RF1|rsvd|rsvd|rsvd| PS2| PS1| HD | FD |rsvd|rsvd|rsvd|rsvd|rsvd|
- * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
- */
-
-/* enum used in vtss_autoneg_1000base_x_config_t */
-typedef enum _vtss_autoneg_1000base_x_remote_fault_t {
-                                     /* RF2 */  /* RF1 */
-    VTSS_1000BASEX_LINK_OK          = (( 0 <<1) | ( 0 <<0)),
-    VTSS_1000BASEX_OFFLINE          = (( 1 <<1) | ( 0 <<0)),
-    VTSS_1000BASEX_LINK_FAILURE     = (( 0 <<1) | ( 1 <<0)),
-    VTSS_1000BASEX_AUTONEG_ERROR    = (( 1 <<1) | ( 1 <<0))
-} vtss_autoneg_1000base_x_remote_fault_t;
-
-typedef struct _vtss_autoneg_1000base_x_advertisement_t {
-    BOOL                                    fdx;
-    BOOL                                    hdx;
-    BOOL                                    symmetric_pause;    /* a.k.a. PAUSE (PS1) */
-    BOOL                                    asymmetric_pause;   /* a.k.a. ASM_DIR (PS2) */
-    vtss_autoneg_1000base_x_remote_fault_t  remote_fault;
-    BOOL                                    acknowledge;
-    BOOL                                    next_page;
-} vtss_autoneg_1000base_x_advertisement_t;
-
-typedef struct _vtss_tbi_autoneg_control_t {
-    BOOL                                    enable;
-    vtss_autoneg_1000base_x_advertisement_t advertisement;
-} vtss_tbi_autoneg_control_t;
-
-vtss_rc vtss_tbi_autoneg_control_get( const vtss_port_no_t    port_no,
-                   vtss_tbi_autoneg_control_t * const        control );
-
-vtss_rc vtss_tbi_autoneg_control_set( const vtss_port_no_t   port_no,
-	        const vtss_tbi_autoneg_control_t * const  control );
-
-vtss_rc vtss_tbi_autoneg_restart( const vtss_port_no_t  port_no );
-
-/* TBI Status, Current state of the PCS */
-typedef enum _vtss_tbi_pcs_state_t {
-    VTSS_TBI_PCS_STATE_IDLE,      /* Idle */
-    VTSS_TBI_PCS_STATE_CONFIG,    /* Config (i.e. ANEG in progress) */
-    VTSS_TBI_PCS_STATE_DATA       /* Data */
-} vtss_tbi_pcs_state_t;
-
-/* Note: The link_status entry is "shared" between vtss_port_status 
-and vtss_tbi_status_get functions. */
-typedef struct _vtss_tbi_status_t {
-    BOOL                                    link_status;        /* FALSE if link has been down since last status read */
-    uint                                    link_down_counter;  /* Note: Saturates when reaching VTSS_TBI_LINK_DOWN_COUNTER_SATURATED. */
-    struct {
-    vtss_tbi_pcs_state_t                    pcs_state;
-    BOOL                                    priority_resolution;
-    BOOL                                    complete;
-    vtss_autoneg_1000base_x_advertisement_t partner_advertisement;
-    }                                       autoneg;
-} vtss_tbi_status_t;
-
-#define VTSS_TBI_LINK_DOWN_COUNTER_SATURATED 255
-
-vtss_rc vtss_tbi_status_get( const vtss_port_no_t       port_no,
-                             vtss_tbi_status_t * const  status );
-
-#endif /* HEATHROW2/STAPLEFORD */
-
-
-/****************************************************************************/
-/*                                                                          */
-/*  End of file.                                                            */
-/*                                                                          */
-/****************************************************************************/
diff --git a/drivers/net/nlm_vnet.c b/drivers/net/nlm_vnet.c
deleted file mode 100644
index a882c46..0000000
--- a/drivers/net/nlm_vnet.c
+++ /dev/null
@@ -1,653 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*
- * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
- * Copyright (C) 2001 O'Reilly & Associates
- *
- * The source code in this file can be freely used, adapted,
- * and redistributed in source or binary form, so long as an
- * acknowledgment appears in derived source files.  The citation
- * should list that the code comes from the book "Linux Device
- * Drivers" by Alessandro Rubini and Jonathan Corbet, published
- * by O'Reilly & Associates.   No warranty is attached;
- * we cannot take responsibility for errors or fitness for use.
- *
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/moduleparam.h>
-
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/interrupt.h>
-
-#include <linux/in.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/ip.h>
-#include <linux/tcp.h>
-#include <linux/skbuff.h>
-
-#include "nlm_vnet.h"
-
-
-/*
- * Transmitter lockup simulation, normally disabled.
- */
-static int lockup = 0;
-module_param(lockup, int, 0);
-
-static int timeout = NLM_VNET_TIMEOUT;
-module_param(timeout, int, 0);
-
-int nlm_vnet_debug = 0;
-struct net_device *vnet_dev;  /* The device */
-
-/*
- * This structure is private to each device. It is used to pass
- * packets in and out, so there is place for a packet
- */
-struct nlm_vnet_priv {
-	struct net_device_stats stats;
-	int status;
-	struct sk_buff *skb;
-	spinlock_t lock;
-};
-
-struct nlm_vnet_cluster_cache {
-	struct nlm_cluster *cl;
-};
-
-static struct nlm_vnet_cluster_cache cl_cache_send[NLM_MAX_DOMAINS];
-static struct nlm_vnet_cluster_cache cl_cache_rx;
-
-/*
- * Addr of 64-bit vnet dom-map which has respective domain id bits
- * set for the domains where vnet0 interface is up.
- */
-static nlm_addr_t nlm_vnet_dom_map_addr;
-/*
- * Addr of 64-bit vnet promisc-dom-map which has respective domain id
- * bits set for the domains where vnet0 interface is in promiscuous mode.
- * .
- */
-static nlm_addr_t nlm_vnet_promisc_dom_map_addr;
-
-
-static inline void nlm_vnet_dump_ether_hdr(struct ethhdr* eth)
-{
-	DECLARE_MAC_BUF(dest);
-	DECLARE_MAC_BUF(src);
-
-	VNET_DBG("eth header: dest %s source %s proto %04x\n",
-		 print_mac(dest, eth->h_dest),
-		 print_mac(src, eth->h_source),
-		 ntohs(eth->h_proto));
-}
-
-
-static void nlm_vnet_dump_pkt_info(struct sk_buff *skb)
-{
-	struct iphdr *ih;
-	uint32_t *saddr, *daddr;
-
-	nlm_vnet_dump_ether_hdr((struct ethhdr*)skb->data);
-
-	/*
-	 * Ethhdr is 14 bytes, but the kernel arranges for iphdr
-	 * to be aligned (i.e., ethhdr is unaligned)
-	 */
-	ih = (struct iphdr *)(skb->data + sizeof (struct ethhdr));
-	saddr = &ih->saddr;
-	daddr = &ih->daddr;
-
-	VNET_DBG("%s: %08x:%05i --> %08x:%05i\n", __FUNCTION__,
-		ntohl(ih->saddr),ntohs(((struct tcphdr *)(ih+1))->source),
-		ntohl(ih->daddr),ntohs(((struct tcphdr *)(ih+1))->dest));
-}
-
-
-static void nlm_vnet_rx(struct net_device *dev, uint64_t datalen, void *data)
-{
-
-	struct sk_buff *skb;
-	struct nlm_vnet_priv *priv = netdev_priv(dev);
-	int rval;
-
-	/*
-	 * The packet has been retrieved from the transmission
-	 * medium. Build an skb around it, so upper layers can handle it
-	 */
-	skb = dev_alloc_skb(datalen + 2);
-	if (!skb) {
-		if (printk_ratelimit())
-		    printk(KERN_NOTICE "nlm_vnet: rx - low on mem - packet dropped\n");
-		priv->stats.rx_dropped++;
-		goto out;
-	}
-
-	skb_reserve(skb, 2); /* align IP on 16B boundary */  
-	memcpy(skb_put(skb, datalen), data, datalen);
-
-	/* Write metadata, and then pass to the receive level */
-	skb->dev = dev;
-	skb->protocol = eth_type_trans(skb, dev);
-
-	priv->stats.rx_packets++;
-	priv->stats.rx_bytes += datalen;
-
-	rval = netif_rx(skb);
-  out:
-	return;
-}
-
-
-static void nlm_vnet_pkt_get_event(int len, void *msg)
-{
-	struct nlm_event_simple_msg *smsg = msg;
-	struct nlm_event_vnet_msg *vnet_msg = nlm_addr_to_ptr(smsg->arg);
-
-	VNET_DBG("%s: rx from domid %u in %u msg len %u type %u datalen %llu "
-		 "data %p arg 0x%llx\n", __FUNCTION__, smsg->domid,
-		 nlm_this_domain->id, len, smsg->msgtype,
-		 (unsigned long long)vnet_msg->datalen,
-		 nlm_addr_to_ptr(vnet_msg->data),
-		 (unsigned long long)smsg->arg);
-
-	if (!cl_cache_rx.cl) {
-	    if ((cl_cache_rx.cl = nlm_clpool_getref(nlm_this_domain->id,
-						 NLM_PKT_POOL_NAME)) == NULL) {
-		printk("No pool found for domain %u\n", nlm_this_domain->id);
-		nlm_send_pool_event(nlm_this_domain->id,
-				    NLM_EVENT_MSG_CL_POOL_NOT_FOUND, 0ULL);
-		return;
-	    }
-	}
-
-	nlm_vnet_dump_ether_hdr((struct ethhdr*)nlm_addr_to_ptr(vnet_msg->data));
-	nlm_vnet_rx(vnet_dev, vnet_msg->datalen, vnet_msg->data);
-	nlm_cluster_free(cl_cache_rx.cl, vnet_msg);
-}
-
-
-static void nlm_vnet_pkt_unicast(nlm_dom_t domid, struct sk_buff *skb)
-{
-    struct nlm_event_vnet_msg *vnet_msg;
-    struct nlm_event_simple_msg smsg;
-    char *shortpkt = NULL;
-    char *skbdata;
-    int skblen;
-    struct nlm_vnet_priv *priv;
-
-    skblen = skb->len;
-    skbdata = skb->data;
-
-    if (skblen < ETH_ZLEN) {
-	    shortpkt = kmalloc(ETH_ZLEN, GFP_KERNEL);
-	    if (shortpkt == NULL) {
-		printk (KERN_NOTICE "Ran out of memory allocating short packet\n");
-		return;
-	    }
-	    memset(shortpkt, 0, ETH_ZLEN);
-	    memcpy(shortpkt, skbdata, skblen);
-	    skblen = ETH_ZLEN;
-	    skbdata = shortpkt;
-    }
-
-    if (!cl_cache_send[domid].cl) {
-
-	VNET_DBG("%s: caching cluster ref for domid %u\n", __FUNCTION__, domid);
-
-	if ((cl_cache_send[domid].cl =
-	    nlm_clpool_getref(domid, NLM_PKT_POOL_NAME)) == NULL) {
-	    printk("No pool found for domain %u\n", domid);
-	    nlm_send_pool_event(domid, NLM_EVENT_MSG_CL_POOL_NOT_FOUND, 0ULL);
-	    return;
-	}
-    }
-
-    if ((vnet_msg = nlm_cluster_alloc(cl_cache_send[domid].cl, 0)) == NULL) {
-	printk("Cluster alloc failed %d\n", domid);
-	nlm_send_pool_event(domid, NLM_EVENT_MSG_CL_POOL_EMPTY, 0ULL);
-	return;
-    }
-
-    memset(vnet_msg, 0, sizeof(*vnet_msg));
-    vnet_msg->datalen = skblen;
-    memcpy(vnet_msg->data, skbdata, skblen);
-
-    smsg.msgtype = NLM_EVENT_VNET_PKT;
-    smsg.domid = nlm_this_domain->id;
-    smsg.arg = nlm_ptr_to_addr(vnet_msg);
-
-    VNET_DBG("%s: tx from domid %u to %u msglen %llu type %u datalen %llu "
-	     "data %p arg 0x%llx\n", __FUNCTION__, smsg.domid, domid,
-	     (unsigned long long)sizeof(smsg), smsg.msgtype,
-	     (unsigned long long)vnet_msg->datalen,
-	     nlm_addr_to_ptr(vnet_msg->data), (unsigned long long)smsg.arg);
-
-    if (nlm_send_event(domid, NLM_EVENT_VNET, sizeof(smsg),
-		       nlm_addr_to_ptr(&smsg)) < 0) {
-	printk("Critical : Event send failed for domain %d\n", domid);
-	nlm_cluster_free(cl_cache_send[domid].cl, vnet_msg);
-    }
-
-    priv = netdev_priv(vnet_dev);
-    priv->stats.tx_packets++;
-    priv->stats.tx_bytes += skblen;
-
-    if (shortpkt)
-	kfree(shortpkt);
-
-}
-
-
-/*
- * Broadcast vnet packet to all up and running domains which
- * have vnet0 interface up.
- */
-static void nlm_vnet_pkt_broadcast(uint64_t vnet_dom_map, struct sk_buff *skb)
-{
-    struct nlm_domain dest_dom;
-    nlm_dom_t domid;
-
-    for (domid = NLM_DOMAIN_REMOVED + 1; domid < NLM_MAX_DOMAINS; domid++) {
-
-	nlm_get_domain(domid, &dest_dom);
-
-	if ((domid == nlm_this_domain->id) ||
-	    (dest_dom.state != NLM_D_RUNNING)) {
-	    continue;
-	}
-
-	if (!((1ULL << domid) & vnet_dom_map))
-	    continue;
-	
-
-	VNET_DBG("broadcast to domid %u dest_dom.id %u state %d\n",
-		 domid, dest_dom.id, dest_dom.state);
-
-	nlm_vnet_pkt_unicast(domid, skb);
-
-    }
-}
-
-
-static void nlm_vnet_pkt_send_event(struct sk_buff *skb, int broadcast)
-{
-    struct nlm_domain promisc_dest_dom;
-    nlm_dom_t promisc_domid;
-    struct nlm_domain dest_dom;
-    nlm_dom_t domid;
-    char *skb_data;
-    volatile uint64_t vnet_dom_map = 0x0ULL;
-    volatile uint64_t vnet_promisc_map = 0x0ULL;
-    uint64_t mask;
-    int i;
-
-    skb_data = skb->data;
-    domid = skb_data[ETH_ALEN - 1];
-
-    vnet_dom_map = *(uint64_t*)(long)nlm_vnet_dom_map_addr;
-    vnet_promisc_map = *(uint64_t*)(long)nlm_vnet_promisc_dom_map_addr;
-
-    if (!broadcast) { /* unicast packets */
-
-	/*
-	 * First check for promiscuous vnet0 interfaces and steer the packets
-	 * to the owning domains.
-	 */
-	for (i = NLM_DOMAIN_REMOVED + 1; i < NLM_MAX_DOMAINS; i++) {
-	    
-	    mask = 0x1ULL << i;
-	    promisc_domid = i;
-
-	    if (!(vnet_promisc_map & mask))
-		continue;
-
-	    nlm_get_domain(promisc_domid, &promisc_dest_dom);
-	    if ((promisc_domid == nlm_this_domain->id) ||
-		(promisc_dest_dom.state != NLM_D_RUNNING)) {
-		continue;
-	    }
-
-	    VNET_DBG("unicast to promisc domid %u dest_dom.id %u state %d\n",
-		    promisc_domid, promisc_dest_dom.id, promisc_dest_dom.state);
-	    nlm_vnet_pkt_unicast(promisc_domid, skb);
-	}
-
-	/*
-	 * Now send the packets to the specified domain id.
-	 */
-	if ((domid <= NLM_DOMAIN_REMOVED) || (domid >= NLM_MAX_DOMAINS)) {
-	    return;
-	}
-
-	nlm_get_domain(domid, &dest_dom);
-	if ((domid == nlm_this_domain->id) || (dest_dom.state != NLM_D_RUNNING)) {
-	    return;
-	}
-
-	if (!((1ULL << domid) & vnet_dom_map))
-	    return;
-
-	nlm_vnet_pkt_unicast(domid, skb);
-    } else {  /* broadcast packets */
-	nlm_vnet_pkt_broadcast(vnet_dom_map, skb);
-    }
-}
-
-
-/*
- * nlm_vnet_open
- *
- * Open the "vnet0" device.
- */
-static int nlm_vnet_open(struct net_device *dev)
-{
-	/* Interface coming up; set the domain bit in vnet bitmap. */
-	nlm_vnet_dom_map_set_clear_bit(nlm_vnet_dom_map_addr,
-				       nlm_this_domain->id, 1);
-	netif_start_queue(dev);
-	return 0;
-}
-
-
-static int nlm_vnet_release(struct net_device *dev)
-{
-	int domid;
-    
-	for (domid = 0; domid < NLM_MAX_DOMAINS; domid++) {
-	    if (cl_cache_send[domid].cl) {
-		nlm_clpool_putref(cl_cache_send[domid].cl);
-		cl_cache_send[domid].cl = NULL;
-	    }
-	}
-
-	if (cl_cache_rx.cl) {
-	    nlm_clpool_putref(cl_cache_rx.cl);
-	    cl_cache_rx.cl = NULL;
-	}
-
-	/* Interface going down; clear domain bit in vnet bitmap. */
-	nlm_vnet_dom_map_set_clear_bit(nlm_vnet_dom_map_addr,
-				       nlm_this_domain->id, 0);
-	/* Clear promisc bit */
-	nlm_vnet_promisc_map_set_clear_bit(nlm_vnet_promisc_dom_map_addr,
-					   nlm_this_domain->id, 0);
-	netif_stop_queue(dev); /* can't transmit any more */
-	return 0;
-}
-
-
-/*
- * Configuration changes (passed on by ifconfig)
- */
-static int nlm_vnet_config(struct net_device *dev, struct ifmap *map)
-{
-
-	if (dev->flags & IFF_UP) /* can't act on a running interface */
-		return -EBUSY;
-
-	/* Don't allow changing the I/O address */
-	if (map->base_addr != dev->base_addr) {
-		printk(KERN_WARNING "nlm_vnet: Can't change I/O address\n");
-		return -EOPNOTSUPP;
-	}
-
-	/* ignore other fields */
-	return 0;
-}
-
-
-
-/*
- * Transmit a packet (low level interface)
- */
-static void nlm_vnet_hw_tx(struct sk_buff *skb)
-{
-	int is_broadcast = 1;	
-	struct ethhdr *eth;
-	int i;
-    
-	VNET_DBG("%s\n", __FUNCTION__);
-	/* I am paranoid. Ain't I? */
-	if (skb->len < sizeof(struct ethhdr) + sizeof(struct iphdr)) {
-		printk("nlm_vnet: Hmm... packet too short (%i octets)\n", skb->len);
-		return;
-	}
-
-	nlm_vnet_dump_pkt_info(skb);
-
-	/*
-	 * If it is a broadcast packet, broadcast it to all running CRF
-	 * domains.
-	 */
-	eth = (struct ethhdr*)skb->data;
-
-	for (i = 0; i < 6; i++) {
-	    if ((eth->h_dest[i] & 0xff) != 0xff) {
-		is_broadcast = 0;
-		break;
-	    }
-	}
-
-	nlm_vnet_pkt_send_event(skb, is_broadcast);
-}
-
-
-/*
- * Transmit a packet (called by the kernel)
- */
-static int nlm_vnet_tx(struct sk_buff *skb, struct net_device *dev)
-{
-	dev->trans_start = jiffies; /* save the timestamp */
-	nlm_vnet_hw_tx(skb);
-	dev_kfree_skb(skb); /* Free the skbuf */
-
-	return 0; /* Our simple device can not fail */
-}
-
-
-/*
- * Deal with a transmit timeout.
- */
-static void nlm_vnet_tx_timeout (struct net_device *dev)
-{
-	struct nlm_vnet_priv *priv = netdev_priv(dev);
-
-	VNET_DBG("nlm_vnet: Transmit timeout at %ld, latency %ld\n", jiffies,
-		jiffies - dev->trans_start);
-
-	priv->stats.tx_errors++;
-	netif_wake_queue(dev);
-	return;
-}
-
-
-/*
- * Ioctl commands 
- */
-static int nlm_vnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	VNET_DBG("nlm_vnet: ioctl\n");
-	return 0;
-}
-
-
-/*
- * Return statistics to the caller
- */
-static struct net_device_stats *nlm_vnet_stats(struct net_device *dev)
-{
-	struct nlm_vnet_priv *priv = netdev_priv(dev);
-	return &priv->stats;
-}
-
-
-/*
- * Change MTU
- */
-static int nlm_vnet_change_mtu(struct net_device *dev, int new_mtu)
-{
-	unsigned long flags;
-	struct nlm_vnet_priv *priv = netdev_priv(dev);
-	spinlock_t *lock = &priv->lock;
-    
-	/* check ranges */
-	if ((new_mtu < 68) || (new_mtu > 1500))
-		return -EINVAL;
-
-	/* accept the value */
-	spin_lock_irqsave(lock, flags);
-	dev->mtu = new_mtu;
-	spin_unlock_irqrestore(lock, flags);
-
-	return 0; /* success */
-}
-
-
-/*
- * Hard code mac address and associate the CRF domainid with it.
- */
-static void nlm_vnet_set_mac_address(struct net_device *dev) {
-	/* 
-	 * Assign the hardware address to the vnet interface:
-	 * Use "\0VNETx", where x is 0. The first byte is '\0'
-	 * to avoid being a multicast address (the first byte
-	 * of multicast addrs is odd).
-	 */
-	memcpy(dev->dev_addr, "\0VNET0", ETH_ALEN);
-
-	/*
-	 * Make last byte of MAC addr as domainid. This helps
-	 * identify CRF domain to which ether packet belongs.
-	 */
-	dev->dev_addr[ETH_ALEN - 1] = nlm_this_domain->id;
-}
-
-
-static void nlm_vnet_multicast_list(struct net_device *dev)
-{
-
-    if (dev->flags & IFF_PROMISC) {
-	VNET_DBG("%s: vnet0 interface entering promisc mode\n", __FUNCTION__);
-	nlm_vnet_promisc_map_set_clear_bit(
-				nlm_vnet_promisc_dom_map_addr,
-				nlm_this_domain->id, 1);
-    } else {
-	VNET_DBG("%s: vnet0 interface exiting promisc mode\n", __FUNCTION__);
-	nlm_vnet_promisc_map_set_clear_bit(
-				nlm_vnet_promisc_dom_map_addr,
-				nlm_this_domain->id, 0);
-    }
-}
-
-
-/*
- * The init function (sometimes called probe).
- * It is invoked by register_netdev()
- */
-static void nlm_vnet_init(struct net_device *dev)
-{
-	struct nlm_vnet_priv *priv;
-
-	ether_setup(dev);
-
-	dev->open            = nlm_vnet_open;
-	dev->stop            = nlm_vnet_release;
-
-	/*
-	 * MAC addr change is not allowed as last byte is hardcoded
-	 * to represent domainid within CRF
-	 */
-	dev->set_mac_address = NULL; 
-
-	dev->set_config      = nlm_vnet_config;
-	dev->hard_start_xmit = nlm_vnet_tx;
-	dev->do_ioctl        = nlm_vnet_ioctl;
-	dev->get_stats       = nlm_vnet_stats;
-	dev->change_mtu      = nlm_vnet_change_mtu;  
-	dev->tx_timeout      = nlm_vnet_tx_timeout;
-	dev->set_multicast_list = nlm_vnet_multicast_list;
-	dev->watchdog_timeo = timeout;
-
-	/*
-	 * Then, initialize the priv field. This encloses the statistics
-	 * and a few private fields.
-	 */
-	priv = netdev_priv(dev);
-	memset(priv, 0, sizeof(struct nlm_vnet_priv));
-	spin_lock_init(&priv->lock);
-	nlm_vnet_dom_map_addr = nlm_vnet_dom_map_get_addr();
-	nlm_vnet_promisc_dom_map_addr = nlm_vnet_promisc_map_get_addr();
-}
-
-
-/*
- * Finally, the module stuff
- */
-static void nlm_vnet_cleanup(void)
-{
-	if (vnet_dev) {
-	    unregister_netdev(vnet_dev);
-	    free_netdev(vnet_dev);
-	}
-
-	return;
-}
-
-
-static int nlm_vnet_init_module(void)
-{
-	int result, ret = -ENOMEM;
-
-	/* 
-	 * This driver is meant for communicating between different domains in CRF.
-	 * So, if CRF is not up, simply return.
-	 */
-	if (!rmik_en) {
-	    return -ENODEV;
-	}
-
-	/* Allocate the devices */
-	vnet_dev = alloc_netdev(sizeof(struct nlm_vnet_priv), "vnet%d", nlm_vnet_init);
-
-	if (vnet_dev == NULL)
-		goto out;
-
-	ret = -ENODEV;
-
-
-	if ((result = register_netdev(vnet_dev))) {
-	    printk("nlm_vnet: error %i registering device \"%s\" \n",
-		    result, vnet_dev->name);
-	} else {
-	    ret = 0;
-	}
-
-	/* Assign mac address */
-	nlm_vnet_set_mac_address(vnet_dev);
-
-	/* Register virtual net handler for receiving events from other CRF domain */
-	nlm_vnet_pkt_event_handler = nlm_vnet_pkt_get_event;
-
-   out:
-	if (ret) 
-		nlm_vnet_cleanup();
-	return ret;
-}
-
-
-module_init(nlm_vnet_init_module);
-module_exit(nlm_vnet_cleanup);
diff --git a/drivers/net/nlm_vnet.h b/drivers/net/nlm_vnet.h
deleted file mode 100644
index 7d4c9e8..0000000
--- a/drivers/net/nlm_vnet.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * $Id: $
- *
- * nlm_vnet.h - Shared memory based virtual network driver defines
- *
- */
-
-#ifndef _NLM_VNET_H
-#define _NLM_VNET_H
-
-
-extern uint32_t rmik_en;
-extern int nlm_vnet_debug;
-
-#define VNET_DBG(format, args...) \
-    if (nlm_vnet_debug) printk(KERN_DEBUG format, ##args );
-
-#define NLM_VNET_TIMEOUT	5
-
-static inline nlm_addr_t nlm_vnet_dom_map_get_addr(void)
-{
-	nlm_addr_t addr = 0x0ULL;
-	nlm_resource_t res;
-
-	if (nlm_resource_getref("vnet", &res, NULL) != 0) {
-		return 0;
-	}
-
-	if (nlm_get_addr_property(res, "dom-map", &addr) < 0) {
-		nlm_resource_putref(res);
-		return 0;
-	}
-
-	nlm_resource_putref(res);
-	return addr;
-
-}
-
-static inline void nlm_vnet_dom_map_set_clear_bit(nlm_addr_t vnet_dom_map_addr,
-						  nlm_dom_t domid, int set)
-{
-	if (domid < 0 || domid >= NLM_MAX_DOMAINS)
-		return;
-
-	if (set) {
-		xlr_atomic_bit_set_u64(domid,
-				       nlm_addr_to_ptr(vnet_dom_map_addr));
-	} else {
-		xlr_atomic_bit_clear_u64(domid,
-					 nlm_addr_to_ptr(vnet_dom_map_addr));
-	}
-}
-
-
-static inline nlm_addr_t nlm_vnet_promisc_map_get_addr(void)
-{
-	nlm_addr_t addr = 0x0ULL;
-	nlm_resource_t res;
-
-	if (nlm_resource_getref("vnet", &res, NULL) != 0) {
-		return 0;
-	}
-
-	if (nlm_get_addr_property(res, "promisc-dom-map", &addr) < 0) {
-		nlm_resource_putref(res);
-		return 0;
-	}
-
-	nlm_resource_putref(res);
-	return addr;
-
-}
-
-static inline void nlm_vnet_promisc_map_set_clear_bit(
-					    nlm_addr_t promisc_dom_map_addr,
-					    nlm_dom_t domid, int set)
-{
-	if (domid < 0 || domid >= NLM_MAX_DOMAINS)
-		return;
-
-	if (set) {
-		xlr_atomic_bit_set_u64(domid,
-				       nlm_addr_to_ptr(promisc_dom_map_addr));
-	} else {
-		xlr_atomic_bit_clear_u64(domid,
-					 nlm_addr_to_ptr(promisc_dom_map_addr));
-	}
-}
-
-#endif /* _NLM_VNET_H */
diff --git a/drivers/net/xlr_ip_over_pci_dev.c b/drivers/net/xlr_ip_over_pci_dev.c
deleted file mode 100644
index 85d996d..0000000
--- a/drivers/net/xlr_ip_over_pci_dev.c
+++ /dev/null
@@ -1,610 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/socket.h>
-#include <linux/errno.h>
-#include <linux/fcntl.h>
-#include <linux/in.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/workqueue.h>
-#include <linux/kernel.h>
-#include <linux/inet.h>
-#include <linux/netdevice.h>
-#include <linux/ethtool.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <net/sock.h>
-#include <linux/if_ether.h>	/* For the statistics structure. */
-#include <linux/if_arp.h>	/* For ARPHRD_ETHER */
-#include <linux/autoconf.h>
-#include <linux/proc_fs.h>
-
-#include <asm/system.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/cache.h>
-
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/pci.h>
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/proc.h>
-#include <asm/netlogic/nlm_pcix_gen_dev.h>
-
-#define DRV_NAME	"nlm_ip_over_pci"
-#define DRV_VERSION	"0.1"
-#define DRV_RELDATE	"10Feb2004"
-
-#define XLR_TX_DESC 512 
-#define XLR_RX_DESC 512
-
-#define BRIDGE_PCIXMEM_BAR 35
-
-#define Message(a,b...) //printk("\n[%s] - "a"\n",__FUNCTION__,##b)
-#define ErrorMsg(a,b...) printk("\nError in [%s] - "a"\n",__FUNCTION__,##b)
-
-#define XLR_INTERFACE_IS_UP 1
-#define XLR_INTERFACE_IS_DOWN 2
-#define XLR_MAGIC_NO 0xdeadbeef
-
-static struct net_device *xlr_netdev= NULL;
-static unsigned int *xlr_ip_over_pci_base = NULL;
-typedef volatile unsigned int xlr_reg_t;
-static struct net_device_ops nlm_dev_net_ops;
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-static int mailbox_index;
-#endif
-
-extern int xlr_init_dma(void);
-extern int xlr_request_dma(uint64_t src, uint64_t dest, uint32_t len);
-extern int xlr_async_request_dma(uint64_t src, uint64_t dest, uint32_t len,
-			void (*func)(void *,uint64_t),void *data);
-extern long nlm_common_get_shared_mem_base_dev(void);
-static void setup_shared_mem(void);
-static void xlr_pcix_init(void);
-
-/*DEBUG CNTRS*/
-static int xlr_rx_pkt;
-static int xlr_tx_pkt;
-static int xlr_rx_dma_enqueue_failed;
-static int xlr_tx_dma_enqueue_failed;
-static int xlr_rx_dma_error;
-static int xlr_tx_dma_error;
-/*DEBUG CNTRS END*/
-
-#define XLR_GET_OWN(x) (x->info & 0x80000000)
-#define XLR_RESET_OWN(x) (x->info = x->info & 0x7fffffff)
-#define XLR_GET_HOST_PHYS(x) (x->addr)
-#define XLR_SET_LEN(x,len) x->info = x->info & ~(0x3fff); \
-			   x->info |= len;
-#define XLR_GET_LEN(x) (x->info & 0x3fff)
-
-
-struct xlr_xmit_desc{
-	uint32_t addr;
-	uint32_t info;/*  Bit 0 to 15 LEN
-    		 	  Bit 16 to 30 Reserved 
-			  Bit 31 OWN						                       */
-
-};
-struct xlr_rcv_desc{
-	uint32_t addr;
-	uint32_t info;/*  Bit 0 to 15 LEN
-    		 	  Bit 16 to 30 RESERVED
-			  Bit 31 OWN						                       */
-
-};
-
-static volatile struct xlr_xmit_desc *xlr_xmit_desc_base;
-
-static volatile struct xlr_rcv_desc *xlr_rcv_desc_base;
-
-static volatile unsigned int xmit_producer=0;
-static volatile unsigned int rx_consumer=0;
-
-static volatile uint32_t *xlr_magic_no;
-static volatile uint32_t *xlr_host_status;
-static volatile uint32_t *xlr_dev_status;
-static struct timer_list xlr_link_status_timer;
-static volatile uint32_t xlr_dev_status_local;
-static struct driver_data{
-	struct net_device *dev;	
-	struct xlr_xmit_desc *curr_xmit;
-	struct xlr_xmit_desc *xmit_base;
-	struct xlr_rcv_desc *curr_rx;
-	struct xlr_rcv_desc *rx_base;
-}*ip_over_pci_priv;
-
-
-static volatile int xmit_dma_request_submitted=0;
-static volatile int xmit_dma_request_completed=0;
-static volatile int rx_dma_request_submitted=0;
-static volatile int rx_dma_request_completed=0;
-static volatile int xlr_queue_is_stop=0;
-static spinlock_t xlr_tx_ok_sync=SPIN_LOCK_UNLOCKED;
-static spinlock_t xlr_rx_dma=SPIN_LOCK_UNLOCKED;
-static spinlock_t xlr_tx_dma=SPIN_LOCK_UNLOCKED;
-static spinlock_t xlr_xmit_sync = SPIN_LOCK_UNLOCKED;
-
-#if !defined(XLR_MAILBOX_IS_SUPPORTED)
-static void ip_over_pci_rx(struct work_struct *data);
-#else
-static irqreturn_t ip_over_pci_rx(void *data, struct pt_regs *regs);
-#endif
-struct priv_rx_data{
-	struct sk_buff *skb;
-	int rx_consumer;
-};
-
-struct priv_tx_data{
-	struct sk_buff *skb;
-	int tx_producer;
-};
-
-static void tx_dma_done(void *data, uint64_t status)
-{
-	struct priv_tx_data *priv= (struct priv_tx_data *)data;
-	int ret,err;
-	int error_flag=0;
-	volatile struct xlr_xmit_desc *curr_xmit_desc;
-	unsigned long mflags;
-
-	ret = (status >> 62) & 0x3;
-	err = (status >> 60) & 0x3;
-	
-	if(ret != 0x3) {
-		ErrorMsg("%s: Bad return code %d from DMA engine\n", \
-				__FUNCTION__,ret);
-		error_flag=1;
-	}
-	if(err & 0x2) {
-		ErrorMsg("%s:DMA engine reported Message format error\n", \
-				__FUNCTION__);
-		error_flag=1;
-	}
-	if(err & 0x1) {
-		ErrorMsg("%s:DMA engine reported Bus error\n", __FUNCTION__);
-		error_flag=1;
-	}
-
-	dev_kfree_skb_irq(priv->skb);
-	if(error_flag){
-		curr_xmit_desc = xlr_xmit_desc_base + priv->tx_producer;
-		//TODO: Instead of own bit set some error flag in descriptor.
-		//This packet will be dropped by host proto stack.
-		XLR_RESET_OWN(curr_xmit_desc);
-		xlr_tx_dma_error++;
-		nlm_common_interrupt_host();
-	}
-	else{
-		curr_xmit_desc = xlr_xmit_desc_base + priv->tx_producer;
-		XLR_RESET_OWN(curr_xmit_desc);
-		xlr_tx_pkt++;
-		//Send msi to host - Rx For HOST 
-		nlm_common_interrupt_host();
-	}
-	spin_lock_irqsave(&xlr_tx_dma,mflags);
-	xmit_dma_request_completed = (xmit_dma_request_completed+1)%XLR_TX_DESC;
-	spin_unlock_irqrestore(&xlr_tx_dma,mflags);
-	kfree(priv);
-	spin_lock_irqsave(&xlr_tx_ok_sync,mflags);
-	if(xlr_queue_is_stop){
-		netif_start_queue(xlr_netdev);
-		xlr_queue_is_stop = 0;
-	}
-	spin_unlock_irqrestore(&xlr_tx_ok_sync,mflags);
-}
-
-
-static void rx_dma_done(void *data, uint64_t status)
-{
-	struct priv_rx_data *priv= (struct priv_rx_data *)data;
-	int ret,err;
-	int error_flag=0;
-	volatile struct xlr_rcv_desc *curr_rcv_desc;
-	unsigned long mflags;
-
-	
-	ret = (status >> 62) & 0x3;
-	err = (status >> 60) & 0x3;
-	if(ret != 0x3) {
-		ErrorMsg("%s: Bad return code %d from DMA engine\n", \
-				__FUNCTION__,ret);
-		error_flag=1;
-	}
-	if(err & 0x2) {
-		ErrorMsg("%s:DMA engine reported Message format error\n", \
-				__FUNCTION__);
-		error_flag=1;
-	}
-	if(err & 0x1) {
-		ErrorMsg("%s:DMA engine reported Bus error\n", __FUNCTION__);\
-		error_flag=1;
-	}
-	if(error_flag){
-		dev_kfree_skb_irq(priv->skb);
-		curr_rcv_desc = xlr_rcv_desc_base + priv->rx_consumer;
-		XLR_RESET_OWN(curr_rcv_desc);
-		xlr_rx_dma_error++;
-		nlm_common_interrupt_host();
-	}
-	else{
-		curr_rcv_desc = xlr_rcv_desc_base + priv->rx_consumer;
-		XLR_RESET_OWN(curr_rcv_desc);
-		priv->skb->protocol = eth_type_trans(priv->skb,priv->skb->dev);
-		netif_rx(priv->skb);
-		Message("\nSKB QUEUED TO UPPER LAYER - Len %d\n",priv->skb->len);
-		//Send msi to host - tx_ok
-		nlm_common_interrupt_host();
-		xlr_rx_pkt++;
-	}
-	spin_lock_irqsave(&xlr_rx_dma,mflags);
-	rx_dma_request_completed = (rx_dma_request_completed+1)%XLR_RX_DESC;
-	spin_unlock_irqrestore(&xlr_rx_dma,mflags);
-	kfree(priv);
-}
-
-#if !defined(XLR_MAILBOX_IS_SUPPORTED)
-static DECLARE_DELAYED_WORK(ip_over_pci_task,ip_over_pci_rx);
-static void ip_over_pci_rx(struct work_struct  *data)
-#else
-static irqreturn_t ip_over_pci_rx (void *data,struct pt_regs *regs)
-#endif
-{
-	volatile struct xlr_rcv_desc *curr_rcv_desc;
-	uint64_t phys_addr=0;
-	struct sk_buff *skb;
-	int data_len;
-	int count = 0x0;
-	struct priv_rx_data *priv;
-
-	curr_rcv_desc = xlr_rcv_desc_base + rx_consumer;
-	/*Check If There Is ANyting To Rcv.*/
-	while(XLR_GET_OWN(curr_rcv_desc)){
-		if(((rx_dma_request_submitted + 1)%XLR_RX_DESC) == 
-						rx_dma_request_completed){
-			//ErrorMsg("rx_dma_request_completed = %d,rx_dma_request_submitted = %d",	rx_dma_request_completed,rx_dma_request_submitted);
-			break;
-		}
-    count++;
-		priv = kmalloc(sizeof(struct priv_rx_data),GFP_ATOMIC);
-		
-		if(!priv){
-			ErrorMsg("Priv Allocation Failed In tasklet");
-			break;
-		}
-		
-		phys_addr = XLR_GET_HOST_PHYS(curr_rcv_desc);
-		phys_addr = phys_addr | 0x8000000000ULL;
-		data_len = XLR_GET_LEN(curr_rcv_desc);
-
-		skb = dev_alloc_skb(data_len+14);
-		Message("\nRcvd Buf From Host\n");
-		if(!skb){
-			ErrorMsg("\nSKB Alloction Failed\n");
-			kfree(priv);
-			break;
-		}
-		priv->skb = skb;
-		priv->rx_consumer = rx_consumer;
-
-		Message("\nRcvd Pkt Len of %d\n",data_len);
-		skb_reserve(skb, 2);
-		skb_put(skb,data_len);
-		skb->dev = xlr_netdev;
-
-		if(xlr_async_request_dma(phys_addr,virt_to_phys(skb->data),
-					data_len,rx_dma_done,(void *)priv)){
-			//ErrorMsg("Rx DMA Queue Failed");
-			xlr_rx_dma_enqueue_failed++;
-			dev_kfree_skb(skb);
-			kfree(priv);
-			break;
-		}
-		rx_dma_request_submitted = (rx_dma_request_submitted+1)%
-							XLR_RX_DESC;
-		rx_consumer = (rx_consumer + 1)% XLR_RX_DESC;
-		curr_rcv_desc = xlr_rcv_desc_base + rx_consumer;
-	}
-	if(*xlr_magic_no != XLR_MAGIC_NO){
-		//Reset All Prod/Cons here.
-		spin_lock(&xlr_xmit_sync);
-                xmit_dma_request_submitted = xmit_dma_request_completed = 0;
-                xmit_producer = rx_consumer = 0;
-                rx_dma_request_submitted = rx_dma_request_completed = 0;
-		spin_unlock(&xlr_xmit_sync);
-	}	
-#if defined(XLR_MAILBOX_IS_SUPPORTED)
-	return IRQ_HANDLED;
-#else
-	schedule_delayed_work(&ip_over_pci_task, 1);
-#endif
-}
-
-
-static void put_dummy_mac_address(struct net_device *dev)
-{
-	dev->dev_addr[0] = 0x0;
-	dev->dev_addr[1] = 0xa;
-	dev->dev_addr[2] = 0x0;
-	dev->dev_addr[3] = 0xa;
-	dev->dev_addr[4] = 0x0;
-	dev->dev_addr[5] = 0xa;
-}
-
-static int xlr_ip_over_pci_open(struct net_device *dev)
-{
-	xlr_dev_status_local = 1;
-	*xlr_dev_status = 1;
-	return 0;
-}
-
-static int xlr_ip_over_pci_close(struct net_device *dev)
-{
-	netif_stop_queue(dev);
-	xlr_dev_status_local = 2;
-	*xlr_dev_status = 2;
-	return 0;
-}
-
-static int xlr_ip_over_pci_xmit (struct sk_buff *skb,struct net_device *dev)
-{
-	volatile struct xlr_xmit_desc *curr_xmit_desc;
-	uint64_t phys_addr=0;
-	struct priv_tx_data *priv;
-	int old_val;
-	unsigned long mflags;
-
-	if(*xlr_magic_no != XLR_MAGIC_NO){
-		netif_stop_queue(dev);
-		return -EIO;
-	}
-	if(*xlr_host_status == XLR_INTERFACE_IS_DOWN){
-		netif_stop_queue(dev);
-		return -EIO;
-	}
-	if(skb->len > 1514){
-		ErrorMsg("\n %d Len Not Supported\n",skb->len);
-		return -ENOMEM;
-	}
-	if(((xmit_dma_request_submitted + 1)%XLR_TX_DESC) == 
-				xmit_dma_request_completed){
-		Message("xmit_dma_request_completed = %d,xmit_dma_request_submitted = %d",xmit_dma_request_completed,xmit_dma_request_submitted);
-		spin_lock_irqsave(&xlr_tx_ok_sync,mflags);
-		if(((xmit_dma_request_submitted + 1)%XLR_TX_DESC) !=
-                                xmit_dma_request_completed){
-			spin_unlock_irqrestore(&xlr_tx_ok_sync,mflags);
-			goto try_again;
-		}
-		xlr_queue_is_stop = 1;
-		netif_stop_queue(dev);	
-		spin_unlock_irqrestore(&xlr_tx_ok_sync,mflags);
-		return -ENOMEM;
-	}
-try_again:
-	priv = kmalloc(sizeof(struct priv_tx_data),GFP_KERNEL);
-	if(!priv){
-		ErrorMsg("priv allocation failed");
-		return -ENOMEM;
-	}
-	curr_xmit_desc = xlr_xmit_desc_base + xmit_producer;
-
-	if(!XLR_GET_OWN(curr_xmit_desc)){
-		Message("\nHost Memory is Not Available for XMIT\n");
-		kfree(priv);
-		return -ENOMEM;
-	}
-	phys_addr = XLR_GET_HOST_PHYS(curr_xmit_desc);
-	
-	
-	phys_addr = phys_addr | 0x8000000000ULL;
-	priv->tx_producer = xmit_producer;
-	priv->skb = skb;
-	XLR_SET_LEN(curr_xmit_desc,skb->len);
-
-	old_val = xmit_dma_request_submitted;
-	xmit_dma_request_submitted = (xmit_dma_request_submitted+1)%XLR_TX_DESC;
-	if(xlr_async_request_dma(virt_to_phys(skb->data),phys_addr,skb->len,\
-				tx_dma_done,priv)){
-		//ErrorMsg("Cant Queue XMIT Msg.");
-		kfree(priv);
-		xlr_tx_dma_enqueue_failed++;
-		xmit_dma_request_submitted = old_val;
-		return -EIO;
-	}
-	Message("Xmit Pkt With Len skblen %d -> desc len %d",
-				skb->len,XLR_GET_LEN(curr_xmit_desc));
-
-	spin_lock_irqsave(&xlr_xmit_sync,mflags);
-	if(*xlr_magic_no == XLR_MAGIC_NO)
-		xmit_producer = (xmit_producer + 1) % XLR_TX_DESC;
-	spin_unlock_irqrestore(&xlr_xmit_sync,mflags);
-	return 0;
-}
-
-
-static void setup_shared_mem(void)
-{
-	xlr_ip_over_pci_base = (unsigned int *)(nlm_common_get_shared_mem_base_dev()
-				 +NLM_IP_OVER_PCI_MEM_BASE);
-	xlr_xmit_desc_base = (struct xlr_xmit_desc *)xlr_ip_over_pci_base;
-	xlr_rcv_desc_base = (struct xlr_rcv_desc *)
-				((unsigned char *)xlr_xmit_desc_base
-				 + XLR_TX_DESC*sizeof(struct xlr_xmit_desc));
-
-	xlr_magic_no = (uint32_t *)((xlr_rcv_desc_base + XLR_RX_DESC));
-        xlr_host_status = xlr_magic_no + 1;
-        xlr_dev_status = xlr_host_status + 1;
-
-        Message("\nXlrXmitBase %#x to %#x\n",(uint32_t)xlr_xmit_desc_base,
-			(uint32_t)xlr_rcv_desc_base);
-        Message("\nXlrRxBase %#x to %#x\n",(uint32_t)xlr_rcv_desc_base,
-	(uint32_t)(xlr_rcv_desc_base+XLR_RX_DESC*sizeof(struct xlr_rcv_desc)));
-	Message("XlrMagicNo. %#x",xlr_magic_no);
-}
-
-static void xlr_pcix_init(void)
-{
-        xlr_reg_t *bmmio = 0;
-        bmmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
-	/*Set Defeature bit*/
-	bmmio[59] |= 0x2;
-	/* Use 0x8000000000ULL and above for PCI addresses in XLR memory map */
-	bmmio[BRIDGE_PCIXMEM_BAR] = 0x8000ffff;
-	Message("\nDefeature REgister Addr %#x And Value Is %#x\n",
-			(unsigned int)&bmmio[59],bmmio[59]);
-	Message("\nBRIDGE PCIXMEM BAR REG ADDR %#x and Value Is %#x\n",
-			(unsigned int)&bmmio[BRIDGE_PCIXMEM_BAR],
-			bmmio[BRIDGE_PCIXMEM_BAR]);
-}
-
-static struct net_device_stats xlr_net_stats;;
-static struct net_device_stats* xlr_get_stats(struct net_device *dev)
-{
-	memset(&xlr_net_stats,0,sizeof(struct net_device_stats));
-	xlr_net_stats.rx_packets = xlr_rx_pkt;
-	xlr_net_stats.tx_packets = xlr_tx_pkt;
-	xlr_net_stats.rx_errors = xlr_rx_dma_error;
-	xlr_net_stats.tx_errors = xlr_tx_dma_error;
-	return &xlr_net_stats;
-}
-
-static void xlr_link_status(unsigned long data)
-{
-	uint32_t host_status, dev_status;
-
-	*xlr_dev_status = xlr_dev_status_local;
-
-	if(*xlr_magic_no != XLR_MAGIC_NO){
-		if(!netif_queue_stopped(xlr_netdev))
-			netif_stop_queue(xlr_netdev);
-		goto try_again;
-	}
-
-	/*Read Host n Dev Status*/
-	/*1 = open, 2 = close*/
-	host_status = *xlr_host_status;
-	dev_status = *xlr_dev_status;
-
-	if(dev_status == 1 && host_status == 1){
-		if(netif_queue_stopped(xlr_netdev) && !xlr_queue_is_stop){
-			netif_start_queue(xlr_netdev);
-		}
-	}else if(!netif_queue_stopped(xlr_netdev)){
-		Message("\nStoppin Queue.\n");
-		netif_stop_queue(xlr_netdev);
-	}
-
-try_again:
-	xlr_link_status_timer.expires = jiffies + 10;
-	add_timer(&xlr_link_status_timer);
-}
-
-static void setup_net_ops(struct net_device *dev)
-{
-	nlm_dev_net_ops.ndo_open = xlr_ip_over_pci_open;
-	nlm_dev_net_ops.ndo_stop = xlr_ip_over_pci_close;
-	nlm_dev_net_ops.ndo_get_stats = xlr_get_stats;
-	nlm_dev_net_ops.ndo_start_xmit = xlr_ip_over_pci_xmit;
-	dev->netdev_ops = &nlm_dev_net_ops;
-}
-
-static int xlr_ip_over_pci_init(void)
-{
-	struct net_device *dev = 0;
-	struct driver_data *priv = 0;
-	int ret = 0;
-
-  if(xlr_get_pci_mode() == XLR_PCI_HOST_MODE){
-    Message("\nXlr Is Configured In Host Mode - Unloading xlr_ip_over_pci_dev");
-		return -EIO;
-  }
-	
-	/*Do DMA initialization*/
-	if(xlr_init_dma()){
-		ErrorMsg("xlr_init_dma failed");
-		ret = -EIO;
-		goto out;
-	}
-
-	xlr_netdev = dev = alloc_etherdev(sizeof(struct driver_data));
-	if (!dev) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	/*Set Defeature bit and bridge pcix mmio bar*/	
-	xlr_pcix_init();	
-	/*Get the shared region base address for ip_over_pci descriptors.*/
-	setup_shared_mem();
-
-	ip_over_pci_priv = priv = netdev_priv(dev);
-	priv->dev = dev;
-
-	setup_net_ops(dev);
-	
-	put_dummy_mac_address(dev);
-
-	ether_setup(dev);
-
-	ret = register_netdev(dev);
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-	nlm_common_request_mailbox_handler(ip_over_pci_rx,NULL,&mailbox_index);
-#else
-	schedule_delayed_work(&ip_over_pci_task, 0);
-#endif
-	init_timer(&xlr_link_status_timer);       
-        xlr_link_status_timer.function = xlr_link_status;
-        xlr_link_status_timer.expires = jiffies + 10;
-        add_timer(&xlr_link_status_timer);
-
-  printk("xlr_ip_over_pci_dev registered\n");
-out:
-	return ret;
-}
-
-/**********************************************************************
- **********************************************************************/
-static void xlr_ip_over_pci_exit(void)
-{
-	if(!xlr_netdev)
-		return;	
-	unregister_netdev(xlr_netdev);
-	free_netdev(xlr_netdev);
-#ifdef XLR_MAILBOX_IS_SUPPORTED
-	nlm_common_free_mailbox_handler(&mailbox_index);
-#endif
-}
-
-module_init(xlr_ip_over_pci_init);
-module_exit(xlr_ip_over_pci_exit);
diff --git a/drivers/net/xlr_ip_over_pci_host.c b/drivers/net/xlr_ip_over_pci_host.c
deleted file mode 100644
index bce6039..0000000
--- a/drivers/net/xlr_ip_over_pci_host.c
+++ /dev/null
@@ -1,703 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/socket.h>
-#include <linux/errno.h>
-#include <linux/fcntl.h>
-#include <linux/in.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/workqueue.h>
-#include <linux/kernel.h>
-#include <linux/inet.h>
-#include <linux/netdevice.h>
-#include <linux/ethtool.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <net/sock.h>
-#include <linux/if_ether.h>	/* For the statistics structure. */
-#include <linux/if_arp.h>	/* For ARPHRD_ETHER */
-#include <linux/autoconf.h>
-#include <linux/proc_fs.h>
-
-#include <asm/system.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/cache.h>
-#include <linux/delay.h>
-#include <linux/timer.h>
-
-
-#ifdef CONFIG_NLM_COMMON
-#include <asm/netlogic/nlm_pcix_gen_host.h>
-#else
-#include "nlm_pcix_gen_host.h"
-#endif
-
-#define DRV_NAME	"nlm_ip_over_pci"
-#define DRV_VERSION	"0.1"
-#define DRV_RELDATE	"10Feb2004"
-
-#define XLR_TX_DESC 512 
-#define XLR_RX_DESC 512  
-#define RX_DESC_SIZE (sizeof(struct xlr_rcv_desc) / sizeof(unsigned int)) 
-#define TX_DESC_SIZE (sizeof(struct xlr_xmit_desc) / sizeof(unsigned int)) 
-#define NLM_SMP_CACHE_BYTES 32
-
-#define Message(a,b...) //printk("\n[%s] - "a"\n",__FUNCTION__,##b)
-#define ErrorMsg(a,b...) printk("\nError in [%s] - "a"\n",__FUNCTION__,##b)
-#define XLR_MAX_RX_LEN 1536
-
-static struct net_device *xlr_netdev= NULL;
-static unsigned int *xlr_ip_over_pci_base = NULL;
-typedef volatile unsigned int xlr_reg_t;
-static struct sk_buff *tx_skb_ptr[XLR_TX_DESC];
-static void setup_shared_mem(void);
-static struct sk_buff * xlr_alloc_skb(void);
-static int xlr_replenish_buffer(void);
-static int replenish_buffer_at_index(int index);
-static int process_rx_desc(void);
-static void process_tx_ok_desc(void);
-static void free_rx_desc(void);
-static void free_rx_desc_index(int i);
-static void free_tx_desc(void);
-
-extern unsigned volatile long nlm_common_get_shared_mem_base_host(void);
-extern int xlr_init_dma(void);
-extern int xlr_request_dma(uint64_t src, uint64_t dest, uint32_t len);
-extern void nlm_nlm_common_interrupt_device(void);
-
-
-#define XLR_GET_OWN(x) (((x)->info) & 0x80000000)
-#define XLR_RESET_OWN(x) ((x)->info = ((x)->info) & 0x7fffffff)
-#define XLR_SET_OWN(x) ((x)->info = (x)->info | 0x80000000)
-#define XLR_GET_HOST_PHYS(x) ((x)->addr)
-#define XLR_GET_LEN(x) ((x)->info & 0x3fff)
-#define XLR_SET_LEN(x,len) (x)->info = ((x)->info & ~(0x3fff));\
-		   	    (x)->info |= len
-#define XLR_SET_HOST_PHYS(x,y) ((x)->addr = (y))
-
-#define XLR_INTERFACE_IS_UP 1
-#define XLR_INTERFACE_IS_DOWN 2
-#define XLR_MAGIC_NO 0xdeadbeef
-struct xlr_xmit_desc{
-	uint32_t addr;
-	uint32_t info;/*  Bit 0 to 14 LEN
-    		 	  Bit 15 to 30 Reserved 
-			  Bit 31 OWN						                       */
-
-};
-struct xlr_rcv_desc{
-	uint32_t addr;
-	uint32_t info;/*  Bit 0 to 15 LEN
-    		 	  Bit 16 to 30 RESERVED
-			  Bit 31 OWN						                       */
-
-};
-struct tx_free_info
-{
-        struct sk_buff *tx_skb_ptr;
-        dma_addr_t phys_addr;
-        int len;
-}xlr_tx_free_info[XLR_TX_DESC];
-
-struct rx_free_info
-{
-        struct sk_buff *skb;
-        dma_addr_t phys_addr;
-        int len;
-}xlr_rx_info[XLR_RX_DESC];
-extern struct pci_dev *nlm_pdev;
-
-static struct net_device_ops nlm_host_net_ops;
-/*DEBUG CNTR START*/
-static int xlr_tx_pkt;
-static int xlr_rx_pkt;
-static int xlr_tx_enqueue_failed;
-/*DEBUG CNTR END*/
-
-static spinlock_t xlr_tx_ok_sync = SPIN_LOCK_UNLOCKED;
-static volatile int xlr_queue_is_stop=0;
-
-// xlr_xmit_desc - Xmit Pkt towards host from xlr. Host has to give its memory address where xlr can xmit.
-static volatile struct xlr_xmit_desc *xlr_xmit_desc_base;
-
-static volatile struct xlr_rcv_desc *xlr_rcv_desc_base;
-
-static unsigned int xmit_producer;
-static unsigned int xmit_consumer;
-static unsigned int rx_consumer;
-#if !defined(CONFIG_NLM_COMMON) && defined(XLR_MSI_IS_SUPPORTED)
-static int msi_index;
-#endif
-static volatile uint32_t *xlr_magic_no;
-static volatile uint32_t *xlr_host_status;
-static volatile uint32_t *xlr_dev_status;
-static volatile uint32_t xlr_host_status_local;
-
-extern unsigned int nlm_common_pci_readl(unsigned int  *base);
-extern void nlm_common_pci_writel(unsigned int  data,unsigned int *addr);
-static struct driver_data{
-	struct net_device *dev;	
-	struct xlr_xmit_desc *curr_xmit;
-	struct xlr_xmit_desc *xmit_base;
-	struct xlr_rcv_desc *curr_rx;
-	struct xlr_rcv_desc *rx_base;
-}*ip_over_pci_priv;
-
-volatile static int rmmod_is_set=0;
-static struct timer_list xlr_link_status_timer;
-
-static void nlm_pci_read(u32 *src, int words, u32 *dest)
-{
-  int i;
-
-  for(i=0; i<words; i++){
-      *(dest + i) = nlm_common_pci_readl(src+i);
-  }
-  return;
-}
-
-static void nlm_pci_write(u32 *src, int words, u32 *dest)
-{
-  int i;
-  for(i=0; i<words; i++){
-	nlm_common_pci_writel(*(src+i), dest + i);
-  }
-  return;
-}
-
-static int process_rx_desc(void)
-{
-	volatile struct xlr_rcv_desc *curr_rcv_desc;
-	struct xlr_rcv_desc tmp_rx;
-	uint32_t phys_addr=0;
-	struct sk_buff *skb;
-	int data_len;
-	unsigned int status;
-  int count = 0x0;
-
-	curr_rcv_desc = xlr_rcv_desc_base + rx_consumer;
-	nlm_pci_read((uint32_t *)curr_rcv_desc,RX_DESC_SIZE,
-			(uint32_t *)&tmp_rx);
-	while(!XLR_GET_OWN(&tmp_rx)){
-                pci_unmap_single(nlm_pdev,xlr_rx_info[rx_consumer].phys_addr,
-                                xlr_rx_info[rx_consumer].len,DMA_FROM_DEVICE);
-
-		count++;
-		data_len = XLR_GET_LEN(&tmp_rx);
-		if(data_len > 1514){
-			ErrorMsg("Rcvd Wrong Len Pkt %d",data_len);
-		}
-		Message("\nRcvd A Pkt Frm XLR With LEN %d, Addr %#x Len %#x\n",
-					data_len,tmp_rx.addr,tmp_rx.info);
-                skb = xlr_rx_info[rx_consumer].skb;
-		if(!skb){
-			panic("xlr_ip_over_pci.c - Rcvd skb is null\n");
-		}	
-		if(replenish_buffer_at_index(rx_consumer)){
-			Message("Droppin Packet As replenishment is failed");
-			phys_addr = pci_map_single(nlm_pdev,skb->data,
-						XLR_MAX_RX_LEN,DMA_FROM_DEVICE);
-			xlr_rx_info[rx_consumer].phys_addr = phys_addr;
-        		xlr_rx_info[rx_consumer].skb = skb;
-		        xlr_rx_info[rx_consumer].len = XLR_MAX_RX_LEN;
-
-			XLR_SET_HOST_PHYS(&tmp_rx,phys_addr);
-			XLR_SET_OWN(&tmp_rx);
-			nlm_pci_write((uint32_t *)&tmp_rx,RX_DESC_SIZE,
-				(uint32_t *)curr_rcv_desc);	
-			rx_consumer = (rx_consumer + 1)% XLR_RX_DESC;
-			break;
-		}
-		skb_put(skb,data_len);
-		skb->dev = xlr_netdev;
-		skb->protocol = eth_type_trans(skb,skb->dev);
-
-		if((status = netif_rx(skb)) == NET_RX_DROP){
-			ErrorMsg("netif rx failed with status %d",status);	
-		}
-		xlr_rx_pkt++;
-		rx_consumer = (rx_consumer + 1)% XLR_RX_DESC;
-		curr_rcv_desc = xlr_rcv_desc_base + rx_consumer;
-		nlm_pci_read((uint32_t *)curr_rcv_desc,RX_DESC_SIZE,
-				(uint32_t *)&tmp_rx);
-	}
-	return count;
-}
-
-static void process_tx_ok_desc()
-{
-	volatile struct xlr_xmit_desc *curr_xmit = NULL; 
-	struct xlr_xmit_desc tmp_xmit;
-
-	if(xmit_consumer == xmit_producer)
-		return;
-	curr_xmit = xlr_xmit_desc_base + xmit_consumer;
-	nlm_pci_read((uint32_t *)curr_xmit+1,TX_DESC_SIZE-1,
-			(uint32_t *)&tmp_xmit.info);
-	
-	while((!XLR_GET_OWN(&tmp_xmit)) && (xmit_consumer != xmit_producer)){
-		Message("Rcvd Tx Ok");
-                pci_unmap_single(nlm_pdev,
-                        xlr_tx_free_info[xmit_consumer].phys_addr,
-                        xlr_tx_free_info[xmit_consumer].len,
-                        DMA_TO_DEVICE);
-#if defined(CONFIG_NLM_COMMON) || !defined(XLR_MSI_IS_SUPPORTED)
-                dev_kfree_skb(xlr_tx_free_info[xmit_consumer].tx_skb_ptr);
-#else
-                dev_kfree_skb_irq(xlr_tx_free_info[xmit_consumer].tx_skb_ptr);
-#endif
-		xmit_consumer = (xmit_consumer + 1) % XLR_TX_DESC;
-		curr_xmit = xlr_xmit_desc_base + xmit_consumer;
-		xlr_tx_pkt++;
-		nlm_pci_read((uint32_t *)curr_xmit+1,TX_DESC_SIZE-1,
-			(uint32_t *)&tmp_xmit.info);
-		spin_lock(&xlr_tx_ok_sync);
-		if(xlr_queue_is_stop){
-			netif_start_queue(xlr_netdev);
-			xlr_queue_is_stop = 0;
-		}
-		spin_unlock(&xlr_tx_ok_sync);
-	}
-}
-
-#if defined(CONFIG_NLM_COMMON) || !defined(XLR_MSI_IS_SUPPORTED)
-static void ip_over_pci_rx(struct work_struct *data);
-static DECLARE_DELAYED_WORK(ip_over_pci_task_host,ip_over_pci_rx);
-static void ip_over_pci_rx(struct work_struct *data)
-#else
-static irqreturn_t ip_over_pci_rx (void *data,struct pt_regs *regs)
-#endif
-{
-	uint32_t dev_status , count;
-	nlm_pci_read((uint32_t *)xlr_dev_status,1,&dev_status);
-
-	if(dev_status == XLR_INTERFACE_IS_UP){
-		process_tx_ok_desc();	
-		count = process_rx_desc();
-	}
-#if defined(CONFIG_NLM_COMMON) || !defined(XLR_MSI_IS_SUPPORTED)
-	if(!rmmod_is_set) {
-		schedule_delayed_work(&ip_over_pci_task_host, 1);
-	}
-	return;
-#else
-	return IRQ_HANDLED;
-#endif
-}
-
-static void put_dummy_mac_address(struct net_device *dev)
-{
-	dev->dev_addr[0] = 0x0;
-	dev->dev_addr[1] = 0xb;
-	dev->dev_addr[2] = 0x0;
-	dev->dev_addr[3] = 0xb;
-	dev->dev_addr[4] = 0x0;
-	dev->dev_addr[5] = 0xb;
-}
-
-static int xlr_ip_over_pci_open(struct net_device *dev)
-{
-	uint32_t tmp = XLR_INTERFACE_IS_UP;
-	xlr_host_status_local = XLR_INTERFACE_IS_UP;
-	nlm_pci_write((uint32_t *)&tmp,1,(uint32_t *)xlr_host_status);
-	return 0;
-}
-
-static int xlr_ip_over_pci_close(struct net_device *dev)
-{
-	uint32_t tmp = XLR_INTERFACE_IS_DOWN;
-	if(!netif_queue_stopped(dev))
-		netif_stop_queue(dev);
-	xlr_host_status_local = XLR_INTERFACE_IS_DOWN;
-	nlm_pci_write((uint32_t *)&tmp,1,(uint32_t *)xlr_host_status);
-	return 0;
-}
-
-static int xlr_ip_over_pci_xmit (struct sk_buff *skb,struct net_device *dev)
-{
-	volatile struct xlr_xmit_desc *curr_xmit_desc;
-	struct xlr_xmit_desc tmp_xmit;
-	uint64_t phys_addr=0;
-	uint32_t dev_status;
-	unsigned long mflags;
-
-	nlm_pci_read((uint32_t *)xlr_dev_status,1,&dev_status);
-
-	if(dev_status != XLR_INTERFACE_IS_UP){
-		netif_stop_queue(xlr_netdev);
-		return -EIO;
-	}
-	
-	if(skb->len > 1514){
-		ErrorMsg("Pkt Iz Greater Than Max Size %d",skb->len);
-		return -EIO;
-	}
-	if(((xmit_producer + 1)%(XLR_TX_DESC)) == xmit_consumer){
-		Message("No TX Desc Available.");
-		spin_lock_irqsave(&xlr_tx_ok_sync,mflags);
-	        if(((xmit_producer + 1)%(XLR_TX_DESC)) != xmit_consumer){
-			spin_unlock_irqrestore(&xlr_tx_ok_sync,mflags);
-			goto try_again;
-		}
-		xlr_queue_is_stop=1;
-		netif_stop_queue(xlr_netdev);
-		spin_unlock_irqrestore(&xlr_tx_ok_sync,mflags);
-		xlr_tx_enqueue_failed++;
-		return -ENOMEM;
-	}
-try_again:
-	curr_xmit_desc = xlr_xmit_desc_base + xmit_producer;
-	Message("\nCurrXmitDescBase %#x, xmit_prod %d, xlr_xmit_desc_base %#x\n",curr_xmit_desc,xmit_producer,xlr_xmit_desc_base);
-	nlm_pci_read((uint32_t *)curr_xmit_desc, TX_DESC_SIZE,
-				 (uint32_t *)&tmp_xmit);
-	if(XLR_GET_OWN(&tmp_xmit)){
-		Message("All Xmit Desc are full...");
-		return -ENOMEM;
-	}
-	tx_skb_ptr[xmit_producer] = skb;
-        phys_addr = xlr_tx_free_info[xmit_producer].phys_addr =
-                pci_map_single(nlm_pdev,skb->data,skb->len,DMA_TO_DEVICE);
-        xlr_tx_free_info[xmit_producer].tx_skb_ptr = skb;
-	memset(&tmp_xmit,0,sizeof(tmp_xmit));
-	XLR_SET_HOST_PHYS(&tmp_xmit,phys_addr);
-	XLR_SET_LEN(&tmp_xmit,skb->len);
-	XLR_SET_OWN(&tmp_xmit);
-	Message("\nXmittin Pkt With Len %d\n",XLR_GET_LEN(&tmp_xmit));
-	nlm_pci_write((uint32_t *)&tmp_xmit,TX_DESC_SIZE,
-			(uint32_t *)curr_xmit_desc);
-	xmit_producer = (xmit_producer + 1) % XLR_TX_DESC;
-	nlm_nlm_common_interrupt_device();
-	return 0;
-}
-
-static void setup_shared_mem()
-{
-	uint32_t tmp;
-	struct xlr_rcv_desc tmp_desc;
-	int i;
-	xlr_ip_over_pci_base = (uint32_t *)(nlm_common_get_shared_mem_base_host() +
-			NLM_IP_OVER_PCI_MEM_BASE);
-	xlr_rcv_desc_base = (struct xlr_rcv_desc *)xlr_ip_over_pci_base;
-	xlr_xmit_desc_base = (struct xlr_xmit_desc *)
-				((unsigned char *)xlr_rcv_desc_base
-				 + XLR_RX_DESC*sizeof(struct xlr_rcv_desc));
-
-        xlr_magic_no = (unsigned int *)((xlr_xmit_desc_base + XLR_TX_DESC));
-	Message("\nMajic no. Addr %#x\n",virt_to_phys(xlr_magic_no));
-	xlr_host_status = xlr_magic_no + 1;
-	xlr_dev_status = xlr_host_status + 1;
-	Message("\nxlr_rcv_desc_base %#x",xlr_rcv_desc_base);
-	Message("\nxlr_xmit_desc_base %#x",xlr_xmit_desc_base);
-	Message("\nxlr_magic_no %#x",xlr_magic_no);
-	Message("\nxlr_host_status %#x",xlr_host_status);
-	Message("\nxlr_dev_status %#x",xlr_dev_status);
-	
-	tmp = 0;
-	nlm_pci_write((uint32_t *)&tmp,1,(uint32_t *)xlr_magic_no);
-	nlm_pci_write((uint32_t *)&tmp,1,(uint32_t *)xlr_host_status);
-	nlm_pci_write((uint32_t *)&tmp,1,(uint32_t *)xlr_dev_status);
-
-	memset(&tmp_desc,0,sizeof(struct xlr_rcv_desc));
-	for(i=0;i<XLR_RX_DESC;i++){
-		nlm_pci_write((uint32_t *)&tmp_desc,2,
-				(uint32_t *)xlr_rcv_desc_base+i);	
-		nlm_pci_write((uint32_t *)&tmp_desc,2,
-				(uint32_t *)xlr_xmit_desc_base+i);	
-	}
-
-	Message("\nXlrRxBase %#x to %#x\n",
-		(uint32_t)xlr_rcv_desc_base,(uint32_t)xlr_xmit_desc_base);
-	Message("\nXlrXmitBase %#x to %#x\n",
-			(uint32_t)xlr_xmit_desc_base,
-	(uint32_t)(xlr_xmit_desc_base+XLR_TX_DESC*sizeof(struct xlr_rcv_desc)));
-}
-
-
-static struct sk_buff * xlr_alloc_skb()
-{
-	struct sk_buff *skb;
-	unsigned long *tmp;
-	unsigned long offset;
-	unsigned char *tmp_addr;
-	skb = dev_alloc_skb(1536+32+32);
-	if(!skb){
-		Message("SKB Allocation Failed");
-		return NULL;
-	}
-	tmp_addr = skb->data;
-	offset = ((unsigned long)skb->data + NLM_SMP_CACHE_BYTES) &  
-			~(NLM_SMP_CACHE_BYTES - 1);
-	skb_reserve(skb, (offset - (unsigned long)skb->data));
-	tmp = (unsigned long*)(skb->data);
-	*tmp = (unsigned long)skb;
-	skb_reserve(skb,NLM_SMP_CACHE_BYTES+2);
-	Message("\nSKB->DATA %#x, orig_addr %#x, diff %#x\n",
-			(unsigned int)virt_to_phys((void *)skb->data),
-			(uint32_t)virt_to_phys((void *)tmp_addr),
-			(uint32_t)virt_to_phys
-		((void *)((unsigned int)tmp_addr - (unsigned int)skb->data)));
-	return skb;
-}
-
-static int replenish_buffer_at_index(int index)
-{
-	struct sk_buff *skb;
-	struct xlr_rcv_desc *curr_desc =
-			 (struct xlr_rcv_desc *)xlr_rcv_desc_base+index;
-	struct xlr_rcv_desc tmp_desc;
-        unsigned int phys_addr;
-
-	memset(&tmp_desc,0,sizeof(struct xlr_rcv_desc));
-
-	skb = xlr_alloc_skb();
-
-	if(!skb){
-		ErrorMsg("\nCouldnt Replenish Buffer\n");
-		return -ENOMEM;
-	}
-        phys_addr = pci_map_single(nlm_pdev,skb->data,XLR_MAX_RX_LEN,
-                                DMA_FROM_DEVICE);
-        xlr_rx_info[index].phys_addr = phys_addr;
-        xlr_rx_info[index].skb = skb;
-        xlr_rx_info[index].len = XLR_MAX_RX_LEN;
-
-	XLR_SET_HOST_PHYS(&tmp_desc,phys_addr);
-	XLR_SET_OWN(&tmp_desc);
-	nlm_pci_write((uint32_t *)&tmp_desc,RX_DESC_SIZE,
-			(uint32_t *)curr_desc);	
-	return 0;
-}
-
-static int xlr_replenish_buffer()
-{
-	int i, j;
-
-	for(i=0;i<XLR_RX_DESC;i++){
-		if(replenish_buffer_at_index(i)){
-			ErrorMsg("replenish failed for buffer %d",i);
-			break;
-		}
-	}
-	if(i != XLR_RX_DESC){
-		for(j=0;j<i;j++)
-			free_rx_desc_index(j);
-		return -ENOMEM;
-	}
-	return 0;
-}
-
-static struct net_device_stats xlr_net_stats;
-static struct net_device_stats* xlr_get_stats(struct net_device *dev)
-{
-	memset(&xlr_net_stats,0,sizeof(struct net_device_stats));
-	xlr_net_stats.rx_packets = xlr_rx_pkt;
-	xlr_net_stats.tx_packets = xlr_tx_pkt;
-	return &xlr_net_stats;
-}
-
-static void xlr_link_status(unsigned long data)
-{
-	uint32_t host_status, dev_status;
-
-	/*Read Host n Dev Status*/
-	/*1 = open, 2 = close*/
-	host_status = xlr_host_status_local;
-	nlm_pci_read((uint32_t *)xlr_dev_status,1,&dev_status);
-
-	if(host_status == XLR_INTERFACE_IS_UP && 
-			dev_status == XLR_INTERFACE_IS_UP){
-		if(netif_queue_stopped(xlr_netdev) && !xlr_queue_is_stop){
-			netif_start_queue(xlr_netdev);
-		}
-	}else if(!netif_queue_stopped(xlr_netdev)){
-		Message("\nStoppin Queue.\n");
-		netif_stop_queue(xlr_netdev);
-	}
-	xlr_link_status_timer.expires = jiffies + 10;
-	add_timer(&xlr_link_status_timer);
-}
-
-static void setup_net_ops(struct net_device *dev)
-{
-	nlm_host_net_ops.ndo_open = xlr_ip_over_pci_open;
-	nlm_host_net_ops.ndo_stop = xlr_ip_over_pci_close;
-	nlm_host_net_ops.ndo_get_stats = xlr_get_stats;
-	nlm_host_net_ops.ndo_start_xmit = xlr_ip_over_pci_xmit;
-	dev->netdev_ops = &nlm_host_net_ops;
-}
-static int xlr_ip_over_pci_init(void)
-{
-	struct net_device *dev = 0;
-	struct driver_data *priv = 0;
-	int ret = 0;
-	uint32_t status;
-
-#ifdef CONFIG_NLM_COMMON
-  if(nlm_get_pci_mode() == XLR_PCI_DEV_MODE){
-    Message("Xlr Is configured in Dev Mode - unloading xlr_ip_over_pci_host");
-    return -ENODEV;
-  }
-#endif
-  if(nlm_common_get_shared_mem_base_host() == 0){
-    printk("\nLooks like device is not connected.\n");
-    return -ENODEV; 
-  }
-	xlr_netdev = dev = alloc_etherdev(sizeof(struct driver_data));
-	if (!dev) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	setup_shared_mem();	
-	ip_over_pci_priv = priv = netdev_priv(dev);
-	priv->dev = dev;
-
-	setup_net_ops(dev);
-	put_dummy_mac_address(dev);
-
-	ether_setup(dev);
-
-	ret = register_netdev(dev);
-
-	if(xlr_replenish_buffer()){
-		unregister_netdev(xlr_netdev);
-		free_netdev(xlr_netdev);
-		return -ENOMEM;
-	}
-#if defined(CONFIG_NLM_COMMON) || !defined(XLR_MSI_IS_SUPPORTED)
-  schedule_delayed_work(&ip_over_pci_task_host, 0);
-#else
-	nlm_common_request_msi_handler(ip_over_pci_rx,(void *)NULL,&msi_index);
-#endif
-	status = XLR_MAGIC_NO;
-	nlm_pci_write((void *)&status,1,(void *)xlr_magic_no);	
-	init_timer(&xlr_link_status_timer);
-	xlr_link_status_timer.function = xlr_link_status;
-	xlr_link_status_timer.expires = jiffies + 10;		
-	add_timer(&xlr_link_status_timer);	
-
-	printk("xlr_ip_over_pci_host registered\n");
-out:
-	return ret;
-}
-
-static void free_tx_desc(void)
-{
-	while(xmit_consumer != xmit_producer){
-                pci_unmap_single(nlm_pdev,
-                        xlr_tx_free_info[xmit_consumer].phys_addr,
-                        xlr_tx_free_info[xmit_consumer].len,
-                        DMA_TO_DEVICE);
-		dev_kfree_skb(tx_skb_ptr[xmit_consumer]);
-		xmit_consumer = (xmit_consumer + 1 ) % XLR_TX_DESC;
-	}
-}
-
-static void free_rx_desc_index(int i)
-{
-	struct xlr_rcv_desc *curr_rcv_desc, tmp_rx;
-	uint64_t phys_addr;
-	struct sk_buff *skb;
-	curr_rcv_desc = (struct xlr_rcv_desc *)xlr_rcv_desc_base+i;
-	nlm_pci_read((uint32_t *)curr_rcv_desc,RX_DESC_SIZE,
-			(uint32_t *)&tmp_rx);
-	phys_addr = XLR_GET_HOST_PHYS(&tmp_rx);
-        pci_unmap_single(nlm_pdev,xlr_rx_info[i].phys_addr,
-                                xlr_rx_info[i].len,DMA_FROM_DEVICE);
-        skb = xlr_rx_info[i].skb;
-	dev_kfree_skb(skb);	
-}
-
-static void free_rx_desc(void)
-{
-	int i;
-	for(i=0;i<XLR_RX_DESC;i++){
-		free_rx_desc_index(i);
-	}
-}
-
-static void reset_tx_desc(void)
-{
-        int i=0;
-	uint32_t info;
-        for(i=0;i<XLR_TX_DESC;i++){
-		nlm_pci_read((void *)&info,1,
-			(void *)&((xlr_xmit_desc_base+i)->info));
-		info = info & (0x7fffffffU);
-		nlm_pci_write((void *)&info,1,
-			(void *)&((xlr_xmit_desc_base+i)->info));
-	}
-}
-static void reset_rx_desc(void)
-{
-        int i=0;
-	uint32_t info;
-        for(i=0;i<XLR_RX_DESC;i++){
-		nlm_pci_read((void *)&info,1,
-			(void *)&((xlr_rcv_desc_base+i)->info));
-		info = info & (0x7fffffffU);
-		nlm_pci_write((void *)&info,1,
-			(void *)&((xlr_rcv_desc_base+i)->info));
-	}
-}
-		
-
-static void xlr_ip_over_pci_exit(void)
-{
-	uint32_t status;
-	if(!xlr_netdev)
-		return;	
-	del_timer_sync(&xlr_link_status_timer);
-	status = 0x0;
-	nlm_pci_write((uint32_t *)&status,1,(uint32_t *)xlr_magic_no);	
-	nlm_nlm_common_interrupt_device();
-
-#if defined(CONFIG_NLM_COMMON) || !defined(XLR_MSI_IS_SUPPORTED)
-	rmmod_is_set=1;
-#else
-	nlm_common_free_msi_handler(&msi_index);
-#endif
-
-	
-	reset_rx_desc();
-	reset_tx_desc();
-	mdelay(3000);
-	unregister_netdev(xlr_netdev);
-	free_tx_desc();
-	free_rx_desc();
-	free_netdev(xlr_netdev);
-}
-
-module_init(xlr_ip_over_pci_init);
-module_exit(xlr_ip_over_pci_exit);
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/net/xlr_mac.c b/drivers/net/xlr_mac.c
deleted file mode 100644
index 1c3dbf8..0000000
--- a/drivers/net/xlr_mac.c
+++ /dev/null
@@ -1,4557 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/socket.h>
-#include <linux/errno.h>
-#include <linux/fcntl.h>
-#include <linux/in.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/workqueue.h>
-#include <linux/kernel.h>
-#include <linux/inet.h>
-#include <linux/netdevice.h>
-#include <linux/ethtool.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <net/sock.h>
-#include <linux/if_ether.h>	/* For the statistics structure. */
-#include <linux/if_arp.h>	/* For ARPHRD_ETHER */
-#include <linux/autoconf.h>
-#include <linux/proc_fs.h>
-#include <linux/mii.h>
-#include <linux/delay.h>
-#include <asm/system.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/cache.h>
-
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/pci.h>
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/xlr_mac.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/xlr_user_mac.h>
-#include <asm/netlogic/atx_cpld.h>
-#include <asm/netlogic/xgmac_mdio.h>
-#include <asm/netlogic/proc.h>
-#include <asm/smp.h>
-#include <asm/netlogic/iomap.h>
-#include <asm/netlogic/gpio.h>
-#include <user/netlogic/xlr_user_mac.h>
-#include <asm/netlogic/debug.h>
-/*
-#include <asm/netlogic/xlr_rmik.h>
-*/
-#define DRV_NAME	"nlm_xlr_mac"
-#define DRV_VERSION	"0.1"
-/* #define DEBUG */
-
-#ifdef DEBUG
-#undef dbg_msg
-int mac_debug = 1;
-#define dbg_msg(fmt, args...) \
-        do {\
-            if (mac_debug) {\
-                printk("[%s@%d|%s]: cpu_%d: " fmt, \
-                __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args);\
-            }\
-        } while(0);
-
-#define DUMP_PACKETS
-#else
-#undef dbg_msg
-#define dbg_msg(fmt, args...)
-int mac_debug = 0;
-#endif
-extern int xlr_loader_support;
-extern int xlr_loader_sharedcore;
-extern int xlr_loader_own_gmac;
-
-
-extern struct proc_dir_entry *nlm_root_proc;
-extern int xlsb0_in_xaui(int block);
-
-static struct net_device_ops nlm_mac_net_ops;
-
-#ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
-void dump_all_interface(unsigned int reg);
-void ( *p_ptp_set_ts) (u32 , u32, ktime_t *, u32);
-#endif
-/* 
- *  Packet dump tools
-*/
-#define dump_packet(skb) \
-do \
-{ \
-	int i = 0; \
-	printk("%s: Packet: length=%d\n", __FUNCTION__, skb->len); \
-	for (i = 0; i < 64; i++) { \
-		printk("%02x ", skb->data[i]); \
-		if (i && (i % 16) == 0) \
-			printk("\n"); \
-	} \
-	printk("\n"); \
-} while (0)
-
-
-
-/*
- * This macro returns non-zero if any of the upper buckets (4-7) is non-empty
-*/
-#define upper_buckets_nonempty() ((~msgrng_read_status() >> 28) & 0xf)
-
-
-extern __u32 cpu_to_frstid[];
-extern __u32 cpu_to_bktmask[];
-extern uint32_t hard_cpu_online_map;
-uint64_t free_back_stid_map = 0ULL;
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-
-/* XLR_NAPI global data strucutre */
-struct net_device xlr_napi_dummy_dev;  
-DEFINE_PER_CPU(struct napi_struct, xlr_napi_poll_struct);  
-EXPORT_SYMBOL(xlr_napi_dummy_dev);
-EXPORT_PER_CPU_SYMBOL(xlr_napi_poll_struct);
-
-/* XLR NAPI per CPU packet counter */
-DEFINE_PER_CPU(unsigned long long, xlr_napi_rx_count); 
-
-/* NAPI is disabled by default */
-int nlm_msgring_napi = 0; 
-int nlm_on_chip_napi = 0; 
-EXPORT_SYMBOL(nlm_on_chip_napi);
-int xlr_napi_ready = 0; 
-EXPORT_SYMBOL(xlr_napi_ready);
-static inline void nlm_xlr_free_skb(struct msgrng_msg *msg);
-
-struct napi_control_s 
-{
-  /* core-wide lock */
-  spinlock_t xlr_napi_msgrng_lock __attribute__((aligned(SMP_CACHE_BYTES)));
-
-  /* Mask tracking if NetRx SoftIRQ is scheduled on core's threads
-   *
-   * Only bits 0-3 are used:
-   *
-   *   i-th bit 0:  iff netrx SoftIRQ has been scheduled for thread i
-   *   i-th bit 1:  iff netrx SoftIRQ has NOT been scheduled for thread i
-  */
-  unsigned long netrx_mask;
-};
-
-__aligned(SMP_CACHE_BYTES) struct napi_control_s napi_control[NR_CPUS / 4];
-
-
-/* We need this little hack to improve handler speed */
-static int *rxstn_to_txstn_ptr;
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-
-#define MAC_B2B_IPG             88
-
-/* 
- * Weight for GMAC/XGMAC NAPI polls. We override standard value of 300 
- * to improve packet forwarding rate 
-*/
-#define XLR_NAPI_WEIGHT		1200
-static int napi_weight = XLR_NAPI_WEIGHT;
-
-
-/* 
- * TCP stack termination in NAPI mode requires spill area for FreeOut's of 
- * considerable size. We always set it to 15K descriptors which traslates into
- * 15K * 8 bytes kernel memory alloc.
-*/
-#define XLR_FROUT_JUMBO_SPILL	(15 * 1024)
-
-
-/* NOTE:
-   Don't change this threshold to > 15 if MAX_NUM_DESC is 512. 
-   When msgring_thread_mask is 0xf, each cpu could receive 16 packets 
-   and replenishment may never happen.
-   THRESHOLD should be less than 
-   max_num_desc / (number of threads processing msgring * number of cores)
-   */
-#define MAC_FRIN_TO_BE_SENT_THRESHOLD max_frin_threshold
-#define MAC_FRIN_WORK_NUM 32
-
-/* Computed as described above */
-static int max_frin_threshold;
-
-/* Total Nr of Free Descriptors to GMACs > 2816 for Usermac 
- * If configuring max_num_desc use at least 2816/4.
- */
-
-static struct net_device *dev_mac[NETLOGIC_MAX_MACS];
-struct net_device *dev_mac_type[MAX_NET_TYPES][NETLOGIC_MAX_MACS];
-#define mac_addr_to_ptr(x) ((void *)(long)x)
-
-#define NLM_NUM_REG_DUMP 9 /* Register 0xa0 to 0xa8 */
-#define NLM_ETHTOOL_REG_LEN (NLM_NUM_REG_DUMP * 4) 
-
-static void xlr_get_mac_stats(struct net_device *dev, 
-					struct net_device_stats *stats);
-
-/*
- * New message assembly toolbox: newer, faster versions of messge send functions!
- *
- * NB: Please be advised that they require interrupts be off
- *
- * TODO: move them into msgring.h, if all goes well here
-*/
-static inline int 
-message_send_fast_1(unsigned int code, 
-                    unsigned int stid, 
-                    unsigned long long msg0)
-{
-	int ret, retry = 16;
-
-
-  	msgrng_load_tx_msg0(msg0);
-
-	__asm__ __volatile__ (".set push\n"
-	                      ".set noreorder\n"
-		              ".set mips64\n"
-		              "move $8, %1\n"
-		              "1: c2 0x80001\n"
-		              "mfc2 $8, "STR(MSGRNG_MSG_STATUS_REG)"\n"
-		              "andi $8, $8, 0x6\n"
-		              "beqz $8, 2f\n"
-			      "addi %2, -1\n"
-			      "bnez %2, 1b\n"
-		              "move $8, %1\n"
-			      "addiu $8, $0, 4\n"
-			      "2: move %0, $8\n"
-		              ".set pop\n"
-		              :"=r"(ret)
-		              : "r"((code<<8)|stid), "r"(retry)
-		              : "$8"
-		             );
-	return ret;
-}
-
-
-static inline int 
-message_send_fast_2(unsigned int code, 
-                    unsigned int stid, 
-                    unsigned long long msg0, 
-                    unsigned long long msg1)
-{
-	int ret, retry = 16;
-
-
-  	msgrng_load_tx_msg0(msg0);
-  	msgrng_load_tx_msg1(msg1);
-
-	__asm__ __volatile__ (".set push\n"
-	                      ".set noreorder\n"
-		              ".set mips64\n"
-		              "move $8, %1\n"
-		              "1: c2 0x80001\n"
-		              "mfc2 $8, "STR(MSGRNG_MSG_STATUS_REG)"\n"
-		              "andi $8, $8, 0x6\n"
-		              "beqz $8, 2f\n"
-			      "addi %2, -1\n"
-			      "bnez %2, 1b\n"
-		              "move $8, %1\n"
-			      "addiu $8, $0, 4\n"
-			      "2: move %0, $8\n"
-		              ".set pop\n"
-		              :"=r"(ret)
-		              : "r"((1<<16)|(code<<8)|stid), "r"(retry)
-		              : "$8"
-		             );
-	return ret;
-}
-
-
-#define message_receive_fast_1(bucket, size, code, stid, msg0)   \
-        ( { unsigned int _status=0, _tmp=0;                     \
-           msgrng_receive(bucket);                              \
-           while ( (_status=msgrng_read_status()) & 0x08) ;     \
-           _tmp = _status & 0x30;                               \
-           if (likely(!_tmp)) {                                 \
-                 (size)=((_status & 0xc0)>>6)+1;                \
-                 (code)=(_status & 0xff00)>>8;                  \
-                 (stid)=(_status & 0x7f0000)>>16;               \
-                 (msg0)=msgrng_load_rx_msg0();                  \
-                 _tmp=0;                                        \
-                }                                               \
-           _tmp;                                                \
-        } )
-
-
-static inline void prefetch_local(const void *addr)
-{
-	__asm__ __volatile__(
-	"	.set	mips4		\n"
-	"	pref	%0, (%1)	\n"
-	"	.set	mips0		\n"
-	:
-	: "i" (Pref_StoreStreamed), "r" (addr));
-}
-
-
-
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-/* skb transfer statistics */
-unsigned long long skb_transfer_stat[NR_CPUS][NR_CPUS];
-void skb_transfer_finish(void);
-static void skb_transfer(int bucket, struct sk_buff *skb);
-
-
-/* skb transfer queues, one per CPU */
-static struct sk_buff_head cpu_skb_tqueue[NR_CPUS];
-
-static void
-cpu_tx_queue_init(void)
-{
-  int i;
-
-  for (i = 0; i < NR_CPUS; i++)
-  {
-    skb_queue_head_init(&(cpu_skb_tqueue[i]));
-  }
-}
-
-#endif /* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
-
-
-/* This message ring interrupt type, can be adjusted by NAPI setup callback */
-extern int msgring_int_type;
-extern struct user_mac_data *user_mac;
-extern struct user_mac_kernal_data user_mac_krnl_data;
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-static int nlm_xlr_napi_setup(void);
-#endif
-
-#ifdef CONFIG_NLMCOMMON_HW_BUFFER_MGMT
-static int setup_auto_free(struct sk_buff *skb, int type, struct msgrng_msg *msg);
-#endif /* CONFIG_NLMCOMMON_HW_BUFFER_MGMT */
-
-/* global flag for automatic hardware buffer management, disabled by default */
-int nlm_auto_buffer_mgmt = 0;
-
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-void xlr_napi_rx_schedule(void);
-static int mac_frin_replenish_one_msg(struct net_device *dev);
-static int nlm_xlr_napi_mac_xmit(struct sk_buff *skb, struct net_device *dev);
-
-/*
- * get_adjusted_bucket_index: returns index of the highest bit set incremented by 4
- * 
- * E.g.: get_adjusted_bucket_index(1) = 4
- *       get_adjusted_bucket_index(2) = 5
- *       get_adjusted_bucket_index(3) = 5
- *
-*/
-static inline int
-get_adjusted_bucket_index(int word)
-{
-	__asm__ __volatile__ (".set push\n"
-	                      ".set noreorder\n"
-		              ".set mips64\n"
-			      "clz %0, %1\n"
-			      ".set pop\n"
-			      : "=r" (word) : "r" (word));
-	return 35 - word;
-}
-
-
-/*
- * The following function checks if bucket/freeback allocation scheme is NAPI-compatible
- *
- * Returns 0 if napi compatibility fails and != 0 otherwise
-*/
-static int
-nlm_napi_compatibility_check(void)
-{
-	__u32 freeback, i;
-
-
-	printk("MSGRING_NAPI: HARD_CPU_ONLINE_MAP: 0x%08x\n", hard_cpu_online_map);
-
-/*
-	if (rmik_en) {
-		for (i = 0; i < NR_CPUS; i++) {
-			if ((hard_cpu_online_map & (1 << i)) == 0)
-				continue;
-			free_back_stid_map |= (1ULL << cpu_to_frstid[i]);
-		}
-
-		printk("MSGRING_NAPI: Incompatibility with CRF mode detected\n");
-		return 0;
-	}
-*/
-	for (i = 0; i < NR_CPUS; i++) {
-
-		if ((hard_cpu_online_map & (1 << i)) == 0) {
-			continue;
-		}
-
-		freeback = i / 4 * 8 + i % 4 + 4;
-
-		if (cpu_to_frstid[i] != freeback) {
-
-			printk("MSGRING_NAPI: Bucket allocation is not compatible with NAPI mode\n");
-			printk("MSGRING_NAPI: Conflict detected: thread %d, freeback %d\n", i, cpu_to_frstid[i]);
-			printk("MSGRING_NAPI: Expected freeback %d\n", freeback);
-
-			return 0;
-		}
-	}
-	return 1;
-}
-
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-/*****************************************************************
- * Phoenix Generic Mac driver
- *****************************************************************/
-
-typedef enum { xlr_mac_speed_10, xlr_mac_speed_100,
-	       xlr_mac_speed_1000, xlr_mac_speed_rsvd
-} xlr_mac_speed_t;
-
-typedef enum { xlr_mac_duplex_auto, xlr_mac_duplex_half,
-	       xlr_mac_duplex_full
-} xlr_mac_duplex_t;
-
-typedef enum { xlr_mac_fc_auto, xlr_mac_fc_disabled, xlr_mac_fc_frame,
-	       xlr_mac_fc_collision, xlr_mac_fc_carrier
-} xlr_mac_fc_t;
-
-/* These 2 structures are always indexed by "hard_smp_processor_id()" */
-static struct work_struct mac_frin_replenish_work[MAC_FRIN_WORK_NUM];
-static struct tasklet_struct mac_frin_replenish_task[MAC_FRIN_WORK_NUM];
-
-struct cpu_stat {
-	unsigned long tx_packets;
-	unsigned long txc_packets;
-	unsigned long rx_packets;
-	unsigned long interrupts;
-};
-
-struct phy_info {
-	int addr;
-	int mode;
-	nlm_reg_t *mii_addr;
-	nlm_reg_t *pcs_addr;
-	nlm_reg_t *serdes_addr;
-};
-
-struct driver_data {
-
-	/* Let these be the first fields in this structure 
-	 * the structure is cacheline aligned when allocated in 
-	 * init_etherdev
-	 */
-	struct fr_desc *frin_spill;
-	struct fr_desc *frout_spill;
-	union rx_tx_desc *class_0_spill;
-	union rx_tx_desc *class_1_spill;
-	union rx_tx_desc *class_2_spill;
-	union rx_tx_desc *class_3_spill;
-
-	struct net_device *dev;	/* pointer to linux device */
-	struct timer_list link_timer;	/* for monitoring MII */
-	struct net_device_stats stats;
-	spinlock_t lock;
-
-	nlm_reg_t *mmio;
-
-	__u8 hwaddr[6];
-	int phy_oldbmsr;
-	int phy_oldanlpar;
-	int phy_oldk1stsr;
-	int phy_oldlinkstat;
-	unsigned char phys_addr[2];
-
-	xlr_mac_speed_t speed;	/* current speed */
-	xlr_mac_duplex_t duplex;	/* current duplex */
-	xlr_mac_fc_t flow_ctrl;	/* current flow control setting */
-	int				advertising;
-
-	int id;
-	int type;
-	int instance;
-	uint32_t cfg_flag;
-
-	int spill_init;
-	int config_pde;
-	int num_desc;
-
-	struct phy_info phy;
-	
-	atomic_t frin_to_be_sent[MAC_FRIN_WORK_NUM];
-	int init_frin_desc;
-
-	struct cpu_stat cpu_stats[NR_CPUS];
-
-	int fr_stid;
-	int tx_stid;
-	int frstid_rsvd;
-};
-
-enum {
-	PORT_TX,
-	PORT_TX_COMPLETE,
-	PORT_STARTQ,
-	PORT_STOPQ,
-	PORT_START_DEV_STATE,
-	PORT_STOP_DEV_STATE,
-};
-
-#define port_inc_counter(port, counter) 	atomic_inc(&port_counters[port][(counter)])
-#define port_set_counter(port, counter, value) 	atomic_set(&port_counters[port][(counter)], (value))
-static atomic_t port_counters[8][8] __cacheline_aligned;
-static spinlock_t pending_tx_lock[NETLOGIC_MAX_MACS] __cacheline_aligned;
-static volatile int pending_tx[NETLOGIC_MAX_MACS] __cacheline_aligned;
-
-int mac_xmit(struct sk_buff *skb, struct net_device *dev,
-		    struct driver_data *priv, int txq);
-
-static __inline__ unsigned int nlm_ldadd_wu(unsigned int value, unsigned long *addr)
-{
-	__asm__ __volatile__(".set push\n"
-			     ".set noreorder\n"
-			     ".set mips64\n"
-			     "move $8, %2\n" "move $9, %3\n"
-#ifdef CONFIG_64BIT
-			     //"ldadd $8, $9\n"
-			     ".dword 0x71280012\n"
-#else
-			     //"ldaddwu $8, $9\n"
-			     ".word 0x71280011\n"
-#endif
-			     "move %0, $8\n"
-			     ".set pop\n":"=&r"(value), "+m"(*addr)
-			     :"0"(value), "r"((unsigned long)addr)
-			     :"$8", "$9");
-	return value;
-}
-#define mac_stats_add(x, val) nlm_ldadd_wu(val, &x)
-
-void mac_stats_update(int pkts, struct sk_buff *skb)
-{
-	struct driver_data *priv;
-	priv = netdev_priv(skb->dev);
-	mac_stats_add(priv->stats.rx_packets, pkts);
-	mac_stats_add(priv->stats.rx_bytes, skb->len);
-}
-
-void nlm_xlr_mac_set_enable(struct driver_data *priv, int flag);
-static void xlr_mac_set_rx_mode(struct net_device *dev);
-void nlm_xlr_mac_msgring_handler(int bucket, int size, int code,
-				  int stid, struct msgrng_msg *msg,
-				  void *data);
-static irqreturn_t nlm_xlr_mac_int_handler(int irq, void *dev_id);
-static int nlm_xlr_mac_open(struct net_device *dev);
-static int nlm_xlr_mac_xmit(struct sk_buff *skb, struct net_device *dev);
-static int nlm_xlr_mac_close(struct net_device *dev);
-static void nlm_xlr_mac_timer(unsigned long data);
-static struct net_device_stats *nlm_xlr_mac_get_stats(struct net_device *dev);
-static void nlm_xlr_mac_set_multicast_list(struct net_device *dev);
-static int nlm_xlr_mac_do_ioctl(struct net_device *dev,
-				 struct ifreq *rq, int cmd);
-static void nlm_xlr_mac_tx_timeout(struct net_device *dev);
-static int nlm_xlr_mac_change_mtu(struct net_device *dev, int new_mtu);
-static int nlm_xlr_mac_fill_rxfr(struct net_device *dev);
-static void nlm_xlr_config_spill_area(struct driver_data *priv);
-static int mac_frin_replenish_one_msg(struct net_device *dev);
-
-
-
-#define MSGRING_PROCESS_FROUT_START_BUCKET 4
-#define MSGRING_PROCESS_FROUT_END_BUCKET 8
-#define MSGRING_PROCESS_FROUT_POP_BUCKET_MASK 0xf0
-void msgring_process_rx_msgs(int start_bucket, int end_bucket, __u32 pop_bucket_mask);
-
-
-
-/*****************************************************************
- * Driver Helper Functions
- *****************************************************************/
-
-static __inline__ struct sk_buff *mac_get_skb_back_ptr(unsigned long addr)
-{
-	unsigned long *back_ptr =
-		(unsigned long *)(addr - MAC_SKB_BACK_PTR_SIZE);
-	dbg_msg("addr = %lx,  skb = %lx\n", addr, *back_ptr);
-	/* this function should be used only for newly allocated packets. It assumes
-	 * the first cacheline is for the back pointer related book keeping info
-	 */
-	return (struct sk_buff *)(*back_ptr);
-}
-
-static __inline__ void mac_put_skb_back_ptr(struct sk_buff *skb)
-{
-	unsigned long *back_ptr = (unsigned long *)skb->data;
-
-	/* this function should be used only for newly allocated packets. It assumes
-	 * the first cacheline is for the back pointer related book keeping info
-	 */
-	skb_reserve(skb, MAC_SKB_BACK_PTR_SIZE);
-	*back_ptr = (unsigned long)skb;
-	dbg_msg("p=%p, skb=%p\n", back_ptr, skb);
-}
-
-#define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
-
-static __inline__ void *cacheline_aligned_kmalloc(int size, int gfp_mask)
-{
-	void *buf = kmalloc(size + SMP_CACHE_BYTES, gfp_mask);
-	if (buf)
-		buf =
-			(void
-			 *)(CACHELINE_ALIGNED_ADDR((unsigned long)buf +
-						   SMP_CACHE_BYTES));
-	return buf;
-}
-
-static __inline__ struct sk_buff *nlm_xlr_alloc_skb(void)
-{
-	int offset = 0;
-	struct sk_buff *skb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_KERNEL);
-
-	if (!skb) {
-		return NULL;
-	}
-
-	/* align the data to the next cache line */
-	offset = ((unsigned long)skb->data + SMP_CACHE_BYTES) &
-		~(SMP_CACHE_BYTES - 1);
-	skb_reserve(skb, (offset - (unsigned long)skb->data));
-
-	return skb;
-}
-
-/**********************************************************************
- **********************************************************************/
-void nlm_xlr_mac_set_enable(struct driver_data *priv, int flag)
-{
-	uint32_t regval;
-	int tx_threshold = 512;
-
-	if(!(PORT_EN(priv->cfg_flag)))
-		return;
-
-
-	if (flag) {
-		regval = netlogic_read_reg(priv->mmio, R_TX_CONTROL);
-		regval &= ~(0x3fff);
-		regval |= (1 << O_TX_CONTROL__TxEnable) |
-			(tx_threshold << O_TX_CONTROL__TxThreshold);
-
-		netlogic_write_reg(priv->mmio, R_TX_CONTROL, regval);
-
-		regval = netlogic_read_reg(priv->mmio, R_RX_CONTROL);
-		regval |= 1 << O_RX_CONTROL__RxEnable;
-		if (priv->phy.serdes_addr != 0 && (priv->phy.mode & PHY_MODE_RGMII))
-			regval |= 1 << O_RX_CONTROL__RGMII;
-		netlogic_write_reg(priv->mmio, R_RX_CONTROL, regval);
-	} else {
-		regval = netlogic_read_reg(priv->mmio, R_TX_CONTROL);
-		regval &= ~((1 << O_TX_CONTROL__TxEnable) |
-			    (tx_threshold << O_TX_CONTROL__TxThreshold));
-
-		netlogic_write_reg(priv->mmio, R_TX_CONTROL, regval);
-
-		regval = netlogic_read_reg(priv->mmio, R_RX_CONTROL);
-		regval &= ~(1 << O_RX_CONTROL__RxEnable);
-		netlogic_write_reg(priv->mmio, R_RX_CONTROL, regval);
-	}
-}
-
-
-
-/**********************************************************************
- **********************************************************************/
-static __inline__ int xlr_mac_send_fr(struct driver_data *priv,
-				       unsigned long addr, int len)
-{
-	int stid = 0;
-	struct msgrng_msg msg;
-
- 	stid = priv->fr_stid;
-	msg.msg0 = (uint64_t)addr & 0xffffffffe0ULL;
-    	msg.msg1 = msg.msg2 = msg.msg3 = 0;
-
-	/* Send the packet to MAC */
-	dbg_msg("mac_%d: Sending free packet to stid %d\n",
-		                                  priv->instance, stid);
-	__sync();
-	if (priv->type == TYPE_XGMAC) {
-		while (message_send_fast_1(MSGRNG_CODE_XGMAC, stid, msg.msg0));
-	} else {
-		while (message_send_fast_1(MSGRNG_CODE_MAC, stid, msg.msg0));
-	}
-
-	/* Let the mac keep the free descriptor */
-	return 0;
-}
-
-
-
-
-
-/*
- * Configure and send SKB to device free-in ring
-*/
-static int
-mac_frin_send_skb(struct net_device *dev, struct sk_buff *skb)
-{
-	int offset = 0;
-	unsigned long msgrng_flags = 0;
-	struct driver_data *priv;
-
-
-	priv = netdev_priv(dev);
-
-	/* align the data to the next cache line */
-	offset = (((unsigned long)skb->data + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1));
-	skb_reserve(skb, (offset - (unsigned long)skb->data));
-
-#ifdef CONFIG_NLMCOMMON_HW_BUFFER_MGMT
-	if (nlm_auto_buffer_mgmt) {
-		/* Put skb under automatic buffer management */
-		skb_shinfo(skb)->nlm_flags = 1;
-		skb_shinfo(skb)->nlm_owner = dev;
-		skb_shinfo(skb)->nlm_refill = mac_frin_replenish_one_msg;
-	} else {
-		skb_shinfo(skb)->nlm_flags = 0;
-		skb_shinfo(skb)->nlm_owner = NULL;
-		skb_shinfo(skb)->nlm_refill = NULL;
-	}
-#endif /* CONFIG_NLMCOMMON_HW_BUFFER_MGMT */
-
-	mac_put_skb_back_ptr(skb);
-	msgrng_access_enable(msgrng_flags);
-	if (xlr_mac_send_fr(priv, virt_to_bus(skb->data), skb->len)) {
-		dev_kfree_skb(skb);
-		printk("[%s]: rx free message_send failed!\n", __FUNCTION__);
-	}
-	msgrng_access_disable(msgrng_flags);
-
-	return 0; 
-}
-
-
-/*
- * Allocates new SKB for a particular device and queues it
- * up to the device Rx ring
-*/
-static int
-mac_frin_replenish_one_msg(struct net_device *dev)
-{
-	struct sk_buff *skb = 0;
-
-
-	if (!dev) {
-		return 0;
-	}
-
-	skb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_ATOMIC);
-	if (!skb) {
-		printk(KERN_ALERT "%s: can't alloc skb\n", __FUNCTION__);
-		return 0;
-	}
-	xlr_inc_counter(REPLENISH_FRIN);
-  
-	return mac_frin_send_skb(dev, skb); 
-}
-
-
-
-
-#ifdef CONFIG_NLMCOMMON_HW_BUFFER_MGMT
-/*
- * This helper macro resets SKB data pointers for reuse
- * as free-in buffer
-*/
-#define skb_reset_ptrs(skb) \
-do { \
-	struct skb_shared_info *shinfo; \
-	\
-	shinfo = skb_shinfo(skb); \
-	\
-	\
-	/* Now reinitialize old skb, cut & paste from dev_alloc_skb */ \
-	memset(skb, 0, offsetof(struct sk_buff, tail)); \
-	skb->data = skb->head;  \
-	skb_reset_tail_pointer(skb);\
-	\
-	atomic_set(&shinfo->dataref, 1); \
-	shinfo->nr_frags  = 0; \
-	shinfo->gso_size = 0; \
-	shinfo->gso_segs = 0; \
-	shinfo->gso_type = 0; \
-	shinfo->ip6_frag_id = 0; \
-	shinfo->frag_list = NULL; \
-} while (0)
-
-
-/*
- * If we are in the HW buffer management case we handler frames with rx errors
- * via this function
-*/
-static void 
-discard_rx_frame(struct net_device *dev, struct sk_buff *skb, int cpu)
-{
-	/* Reset all fields to 0, reset data pointers */
-	skb_reset_ptrs(skb);
-
-	mac_frin_send_skb(dev, skb); 
-}
-
-
-/*
- *  Prepare SKB for automatic memory management operation (buffer recycling)
- *
- *  Return: 0 -- recycling is not possible
- *          1 -- SKB set up for recycling successfully
-*/
-static int
-setup_auto_free(struct sk_buff *skb, int type, struct msgrng_msg *msg)
-{
-	struct driver_data *priv;
-	struct skb_shared_info *shinfo;
-	int fr_stid, offset;
-
-	shinfo = skb_shinfo(skb);
-	if (!shinfo->nlm_flags)
-		return 0;
-
-	if (atomic_read(&skb->users) != 1) {
-		printk(KERN_ALERT "%s: Can't recycle because of users count\n", __FUNCTION__);
-		return 0;
-	}
-
-	if (skb->cloned || atomic_read(&(skb_shinfo(skb)->dataref)) != 1) {
-		printk(KERN_EMERG "%s: Can't recycle because of cloned or dataref\n", __FUNCTION__);
-		return 0;
-	}
-
-	/* Leak no dsk entries! */
-	skb_dst_drop(skb);
-
-	/* Reset all fields to 0, reset data pointers */
-	skb_reset_ptrs(skb);
-
-	offset = (((unsigned long)skb->data + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1));
-	skb_reserve(skb, (offset - (unsigned long)skb->data));
-
-	priv = netdev_priv(skb_shinfo(skb)->nlm_owner);
-	fr_stid = priv->fr_stid;
-
-	mac_put_skb_back_ptr(skb);
-
-	msg->msg1 = ( ((uint64_t) 1 << 63) |
-		      ((uint64_t) fr_stid << 54) |
-		      ((uint64_t) 0 << 40) |
-		      ((uint64_t)virt_to_phys(skb->data) & 0xffffffffffULL)
-		    );
-	return 1;
-}
-
-#endif /* CONFIG_NLMCOMMON_HW_BUFFER_MGMT */
-
-
-
-/**************************************************************/
-
-static void xgmac_mdio_setup(volatile unsigned int *_mmio)
-{
-	int i;
-	uint32_t rd_data;
-
-	for (i = 0; i < 4; i++) {
-		rd_data = xmdio_read(_mmio, 1, 0x8000 + i);
-		rd_data = rd_data & 0xffffdfff;	// clear isolate bit
-		xmdio_write(_mmio, 1, 0x8000 + i, rd_data);
-	}
-}
-
-/**********************************************************************
- *  Init MII interface
- *  
- *  Input parameters: 
- *  	   s - priv structure
- ********************************************************************* */
-#define PHY_STATUS_RETRIES 25000
-
-static void nlm_xlr_mac_mii_init(struct driver_data *priv)
-{
-    /* use the lowest clock divisor - divisor 28 */
-    netlogic_write_reg(priv->phy.mii_addr, R_MII_MGMT_CONFIG, 0x07);
-}
-
-/**********************************************************************
- *  Read a PHY register.
- *  
- *  Input parameters: 
- *  	   phyaddr - PHY's address
- *  	   regidx = index of register to read
- *  	   
- *  Return value:
- *  	   value read (16 bits), or 0xffffffff if an error occurred.
- ********************************************************************* */
-static unsigned int nlm_xlr_mac_mii_read(nlm_reg_t *mmio, int phyaddr, int regidx)
-{
-	int i;
-	/* setup the phy reg to be used */
-	netlogic_write_reg(mmio, R_MII_MGMT_ADDRESS,
-			  (phyaddr << 8) | (regidx << 0));
-
-	/* Issue the read command */
-	netlogic_write_reg(mmio, R_MII_MGMT_COMMAND,
-			  (1 << O_MII_MGMT_COMMAND__rstat));
-
-	/* poll for the read cycle to complete */
-	for (i = 0; i < PHY_STATUS_RETRIES; i++) {
-		if (netlogic_read_reg(mmio, R_MII_MGMT_INDICATORS) == 0)
-			break;
-	}
-
-	/* clear the read cycle */
-	netlogic_write_reg(mmio, R_MII_MGMT_COMMAND, 0);
-
-	if (i == PHY_STATUS_RETRIES) {
-		return 0xffffffff;
-	}
-
-	/* Read the data back */
-	return netlogic_read_reg(mmio, R_MII_MGMT_STATUS);
-}
-
-/**********************************************************************
- *  Write a value to a PHY register.
- *  
- *  Input parameters: 
- *  	   s - priv structure
- *  	   phyaddr - PHY to use
- *  	   regidx - register within the PHY
- *  	   regval - data to write to register
- *  	   
- *  Return value:
- *  	   nothing
- ********************************************************************* */
-static void nlm_xlr_mac_mii_write(nlm_reg_t *mmio, int phyaddr, int regidx, unsigned int regval)
-{
-	int i = 0;
-
-	netlogic_write_reg(mmio, R_MII_MGMT_ADDRESS,
-			  (phyaddr << 8) | (regidx << 0));
-
-	/* Write the data which starts the write cycle */
-	netlogic_write_reg(mmio, R_MII_MGMT_WRITE_DATA, regval);
-
-	/* poll for the write cycle to complete */
-	for (i = 0; i < PHY_STATUS_RETRIES; i++) {
-		if (netlogic_read_reg(mmio, R_MII_MGMT_INDICATORS) == 0)
-			break;
-	}
-
-	return;
-}
-
-
-/*****************************************************************
- * Initialize GMAC
- *****************************************************************/
-static void nlm_xlr_config_pde(struct driver_data *priv)
-{
-	int i = 0, cpu = 0, bucket = 0;
-	__u64 bucket_map = 0;
-
-	for (i = 0; i < 32; i++) {
-		if (cpu_isset(i, cpu_online_map)) {
-			cpu = cpu_logical_map(i);
-				bucket = ((cpu >> 2) << 3) | (cpu & 0x03);
-			bucket_map |= (1ULL << bucket);
-			dbg_msg("i=%d, cpu=%d, bucket = %d, bucket_map=%llx\n",
-				i, cpu, bucket, bucket_map);
-		}
-	}
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_0, (bucket_map & 0xffffffff));
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_0 + 1,
-			  ((bucket_map >> 32) & 0xffffffff));
-
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_1, (bucket_map & 0xffffffff));
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_1 + 1,
-			  ((bucket_map >> 32) & 0xffffffff));
-
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_2, (bucket_map & 0xffffffff));
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_2 + 1,
-			  ((bucket_map >> 32) & 0xffffffff));
-
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_3, (bucket_map & 0xffffffff));
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_3 + 1,
-			  ((bucket_map >> 32) & 0xffffffff));
-}
-
-static void nlm_xlr_config_parser(struct driver_data *priv)
-{
-	/* Mark it as no classification 
-	 * The parser extract is gauranteed to be zero with no classfication
-	 */
-	netlogic_write_reg(priv->mmio, R_L2TYPE_0, 0x00);
-	
-}
-
-static void nlm_xlr_config_classifier(struct driver_data *priv)
-{
-	int i = 0;
-
-	if (priv->type == TYPE_XGMAC) {
-		/* xgmac translation table doesn't have sane values on reset */
-		for(i=0;i<64;i++)
-			netlogic_write_reg(priv->mmio, R_TRANSLATETABLE + i, 0x0);		
-
-		/* use upper 7 bits of the parser extract to index the translate
-		 * table
-		 */
-		netlogic_write_reg(priv->mmio, R_PARSERCONFIGREG, 0x0);
-	}
-}
-
-static void nlm_xlr_gmac_clr_pending_intr(struct driver_data *phy_priv)
-{
-	nlm_reg_t *mmio = NULL;
-
-    if(!xlr_board_atx_vii())
-        return;
-
-    if(phy_priv->instance == 0){
-        /*All MDIO interrupts goes to mdio 0 - ack mac 0*/
-        mmio = phy_priv->mmio;
-	    netlogic_write_reg(mmio, R_INTREG, 0xffffffff);
-    }
-}
-
-static void nlm_xlr_gmac_config_speed(struct driver_data *priv)
-{
-	nlm_reg_t *mmio = priv->mmio;
-	int id = priv->instance;
-
-	priv->speed = nlm_xlr_mac_mii_read(priv->phy.mii_addr, priv->phy.addr, 28);
-	priv->speed = (priv->speed >> 3) & 0x03;
-
-	if (priv->speed == xlr_mac_speed_10) {
-		if (priv->phy.serdes_addr)
-			netlogic_write_reg(mmio, R_INTERFACE_CONTROL, SGMII_SPEED_10);
-		netlogic_write_reg(mmio, R_MAC_CONFIG_2, 0x7117);
-		netlogic_write_reg(mmio, R_CORECONTROL, 0x02);
-		printk("configuring gmac_%d in 10Mbps mode\n", id);
-	} else if (priv->speed == xlr_mac_speed_100) {
-		if (priv->phy.serdes_addr)
-			netlogic_write_reg(mmio, R_INTERFACE_CONTROL, SGMII_SPEED_100);
-		netlogic_write_reg(mmio, R_MAC_CONFIG_2, 0x7117);
-		netlogic_write_reg(mmio, R_CORECONTROL, 0x01);
-		printk("configuring gmac_%d in 100Mbps mode\n", id);
-	} else {
-		if (priv->phy.serdes_addr)
-			netlogic_write_reg(mmio, R_INTERFACE_CONTROL, SGMII_SPEED_1000);
-		if (priv->speed != xlr_mac_speed_1000) {
-			printk("gmac_%d phy reported unknown mac speed," 
-				" defaulting to 100Mbps mode\n",id);
-			netlogic_write_reg(mmio, R_MAC_CONFIG_2, 0x7117);
-			netlogic_write_reg(mmio, R_CORECONTROL, 0x01);
-		}else{
-			netlogic_write_reg(mmio, R_MAC_CONFIG_2, 0x7217);
-			netlogic_write_reg(mmio, R_CORECONTROL, 0x00);
-			printk("configuring gmac_%d in 1000Mbps mode\n", id);
-		}
-	}
-}
-
-/*****************************************************************
- * Initialize XGMAC
- *****************************************************************/
-static void nlm_xlr_xgmac_init(struct driver_data *priv, struct port_cfg *pcfg)
-{
-	int i = 0;
-	nlm_reg_t *mmio = priv->mmio;
-	int id = priv->instance;
-	volatile unsigned short *cpld;
-	uint32_t rx_control;
-	bucket_t *bucket;
-	struct stn_cc *credit;
-
-	cpld = (volatile unsigned short *)(unsigned long)0xffffffffBD840000ULL;
-	netlogic_write_reg(priv->mmio, R_DESC_PACK_CTRL,
-			  (MAC_MAX_FRAME_SIZE << O_DESC_PACK_CTRL__RegularSize) | (4 << 20));
-	netlogic_write_reg(priv->mmio, R_BYTEOFFSET0, BYTE_OFFSET);
-
-	if(priv->config_pde) {
-	nlm_xlr_config_pde(priv);
-	nlm_xlr_config_parser(priv);
-	nlm_xlr_config_classifier(priv);
-	}
-
-	netlogic_write_reg(priv->mmio, R_MSG_TX_THRESHOLD, 1);
-
-	/* configure the XGMAC Registers */
-	netlogic_write_reg(mmio, R_XGMAC_CONFIG_1, 0x50000026);
-
-	/* configure the XGMAC_GLUE Registers */
-	netlogic_write_reg(mmio, R_DMACR0, 0xffffffff);
-	netlogic_write_reg(mmio, R_DMACR1, 0xffffffff);
-	netlogic_write_reg(mmio, R_DMACR2, 0xffffffff);
-	netlogic_write_reg(mmio, R_DMACR3, 0xffffffff);
-	netlogic_write_reg(mmio, R_STATCTRL, 0x04);
-	netlogic_write_reg(mmio, R_L2ALLOCCTRL, 0xffffffff);
-
-	netlogic_write_reg(mmio, R_XGMACPADCALIBRATION, 0x030);
-	netlogic_write_reg(mmio, R_EGRESSFIFOCARVINGSLOTS, 0x0f);
-	netlogic_write_reg(mmio, R_L2ALLOCCTRL, 0xffffffff);
-	netlogic_write_reg(mmio, R_XGMAC_MIIM_CONFIG, 0x3e);
-
-	/* take XGMII phy out of reset 
-	 */
-	/* we are pulling everything out of reset because writing a 0 would
-	 * reset other devices on the chip
-	 */
-	cpld[ATX_CPLD_RESET_1] = 0xffff;
-	cpld[ATX_CPLD_MISC_CTRL] = 0xffff;
-	cpld[ATX_CPLD_RESET_2] = 0xffff;
-
-	xgmac_mdio_setup(mmio);
-
-	nlm_xlr_config_spill_area(priv);
-
-	bucket = pcfg->bucket;
-	credit = pcfg->credit;
-
-	if (id == 0) {
-		for (i = 0; i < 16; i++) {
-			netlogic_write_reg(mmio, R_XGS_TX0_BUCKET_SIZE + i,
-					  bucket[MSGRNG_STNID_XGS0_TX + i]);
-		}
-
-		netlogic_write_reg(mmio, R_XGS_RFR_BUCKET_SIZE,
-				  bucket[MSGRNG_STNID_XMAC0RFR]);
-
-	} else if (id == 1) {
-		for (i = 0; i < 16; i++) {
-			netlogic_write_reg(mmio, R_XGS_TX0_BUCKET_SIZE + i,
-					  bucket[MSGRNG_STNID_XGS1_TX + i]);
-		}
-
-		netlogic_write_reg(mmio, R_XGS_RFR_BUCKET_SIZE,
-				  bucket[MSGRNG_STNID_XMAC1RFR]);
-
-	}
-		for (i = 0; i < MAX_NUM_MSGRNG_STN_CC; i++) {
-			netlogic_write_reg(mmio, R_CC_CPU0_0 + i,
-				credit->counters[i >> 3][i & 0x07]);
-	}
-
-	priv->init_frin_desc = 1;
-
-    /* Clear the flagging of rx length check errors */
-    rx_control = netlogic_read_reg(mmio, R_RX_CONTROL);
-    rx_control &= ~(1 << 9);
-    netlogic_write_reg(mmio, R_RX_CONTROL, rx_control);
-}
-
-
-void sgmii_serdes_reset(void) 
-{
-	int i;
-	volatile unsigned int *mmio_gpio;
-	mmio_gpio = (unsigned int *)(netlogic_io_base + NETLOGIC_IO_GPIO_OFFSET);
-
-	for (i=0;i<1000000;i++);
-
-	// use 125 Mhz instead of 156.25Mhz ref clock
-	if (!xlsb0_in_xaui(0)) {
-		mmio_gpio[0x10] = 0x7103;
-	}
-
-	if (!xlsb0_in_xaui(1)) {
-		mmio_gpio[0x21] = 0x7103;
-	}
-
-	for (i=0;i<1000000;i++);
-}
-
-
-
-static void serdes_regs_init(struct driver_data *priv) 
-{
-    int i;
-    volatile unsigned int *mmio_gpio;
-    mmio_gpio = (unsigned int *)(netlogic_io_base + NETLOGIC_IO_GPIO_OFFSET);
-    /*
-       P Reg   Val
-       -------------
-       26 0     6DB0
-       26 1     0FFF
-       26 2     B6D0
-       26 3     00FF
-       26 4     0000
-       26 5     0000
-       26 6     0005
-       26 7     0001
-       26 8     0000
-       26 9     0000
-       26 10    0000
-     */
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 0, 0x6DB0);
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 1, 0xFFFF);  
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 2, 0xB6D0);
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 3, 0x00FF);
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 4, 0x0000);
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 5, 0x0000);
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 6, 0x0005);
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 7, 0x0001);
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 8, 0x0000);
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26, 9, 0x0000);
-    nlm_xlr_mac_mii_write (priv->phy.serdes_addr, 26,10, 0x0000);
-
-    for(i=0;i<10000000;i++){}
-
-    /* program  GPIO values for serdes init parameters */
-    mmio_gpio[0x20] = 0x7e6802;
-    mmio_gpio[0x10] = 0x7104;
-    for(i=0;i<100000000;i++){}
-
-    if (xlr_board_atx_xaui_rework())
-	    sgmii_serdes_reset();
-}
-
-static void serdes_autoconfig(struct driver_data *priv)
-{
-    int delay = 100;
-
-    /* Enable Auto negotiation in the PCS Layer*/
-    if ( (priv->instance == 0) || (priv->instance == 4)) {
-	nlm_xlr_mac_mii_write (priv->phy.pcs_addr, 27, 0, 0x1000);
-	mdelay(delay);
-	nlm_xlr_mac_mii_write (priv->phy.pcs_addr, 27, 0, 0x0200);
-	mdelay(delay);
-    }
-
-    if ( (priv->instance == 1) || (priv->instance == 5)) {
-	nlm_xlr_mac_mii_write (priv->phy.pcs_addr, 28, 0, 0x1000);
-	mdelay(delay);
-	nlm_xlr_mac_mii_write (priv->phy.pcs_addr, 28, 0, 0x0200);
-	mdelay(delay);
-    }
-
-    if ( (priv->instance == 2) || (priv->instance == 6)) {
-	nlm_xlr_mac_mii_write (priv->phy.pcs_addr, 29, 0, 0x1000);
-	mdelay(delay);
-	nlm_xlr_mac_mii_write (priv->phy.pcs_addr, 29, 0, 0x0200);
-	mdelay(delay);
-    }
-
-    if ( (priv->instance == 3) || (priv->instance == 7)) {
-	nlm_xlr_mac_mii_write (priv->phy.pcs_addr, 30, 0, 0x1000);
-	mdelay(delay);
-	nlm_xlr_mac_mii_write (priv->phy.pcs_addr, 30, 0, 0x0200);
-	mdelay(delay);
-    }
-
-    return;
-}
-
-void xaui_serdes_reset( void ) 
-{
-    int i;
-    volatile unsigned int *mmio_gpio;
-    mmio_gpio = (unsigned int *)(netlogic_io_base +
-            NETLOGIC_IO_GPIO_OFFSET);
-
-    for (i=0;i<1000000;i++);
-
-    // disable serdes pll for both serdes
-    mmio_gpio[0x20] = 0x007e6804;
-    mmio_gpio[0x22] = 0x007e6804;
-    for (i=0;i<1000000;i++);
-
-    // use 156.25Mhz ref clock instead of 125Mhz
-    // ref clk
-    mmio_gpio[0x10] = 0x7104;
-    mmio_gpio[0x21] = 0x7104;
-    for (i=0;i<1000000;i++);
-
-    // re-enable serdes pll
-    mmio_gpio[0x20] = 0x007e6801;
-    mmio_gpio[0x22] =
-        0x007e6801;
-
-    for (i=0;i<1000000;i++);
-}
-
-
-static void nlm_xlr_xaui_init(struct driver_data *priv, struct port_cfg *pcfg)
-{
-	int i = 0;
-	nlm_reg_t *mmio = priv->mmio;
-	__u32 value = 0;
-	bucket_t *bucket;
-	struct stn_cc *credit;
-
-    value = netlogic_read_reg(mmio, R_XGMAC_CONFIG_1);
-    netlogic_write_reg(mmio, R_XGMAC_CONFIG_1, (value | 0x50000020));
-    netlogic_write_reg(mmio, R_XGMAC_MAX_FRAME_LEN, 0x0A000A00);
-
-	nlm_xlr_config_spill_area(priv);
-
-	netlogic_write_reg(priv->mmio, R_DESC_PACK_CTRL,
-			  (BYTE_OFFSET << O_DESC_PACK_CTRL__ByteOffset) |
-			  (1 << O_DESC_PACK_CTRL__MaxEntry)| 
-			  (MAC_MAX_FRAME_SIZE << O_DESC_PACK_CTRL__RegularSize));
-   #ifdef CONFIG_NLMCOMMON_PTP_SUPPORT 
-   	netlogic_write_reg(priv->mmio, R_DESC_PACK_CTRL,
-                      netlogic_read_reg(priv->mmio, R_DESC_PACK_CTRL)|
-                      (1<< O_DESC_PACK_CTRL__PrePadEnable)); 
-   #endif
-
-	if(priv->config_pde) {
-	nlm_xlr_config_pde(priv);
-	nlm_xlr_config_parser(priv);
-	nlm_xlr_config_classifier(priv);
-	}
-
-    netlogic_write_reg(priv->mmio, R_MSG_TX_THRESHOLD, 3);
-
-    netlogic_write_reg(mmio,R_RX_CONTROL,(0x7<<6));
-
-	netlogic_write_reg(mmio, R_DMACR0, (7<<28)|(7<<24));
-	netlogic_write_reg(mmio, R_DMACR3,
-            (2<<21)|(2<<18)|(2<<15)|(2<<12)|(2<<9)|(2<<6)|(2<<3)|(2<<0));
-	netlogic_write_reg(mmio, R_L2ALLOCCTRL, 0xffffffff);
-	netlogic_write_reg(mmio, 0x221, (224 << 16));
-	netlogic_write_reg(mmio, R_STATCTRL, 0x04);
-	netlogic_write_reg(mmio, R_INTMASK, 0);
-	netlogic_write_reg(mmio, R_FREEQCARVE, 0);
-
-    priv->init_frin_desc = 1;
-    bucket = pcfg->bucket;
-	credit = pcfg->credit;
-
-	if(bucket != NULL) {
-			netlogic_write_reg(mmio, R_GMAC_RFR0_BUCKET_SIZE, bucket[1]);
-			netlogic_write_reg(mmio, R_GMAC_TX0_BUCKET_SIZE,  bucket[2]);
-			netlogic_write_reg(mmio, R_GMAC_TX1_BUCKET_SIZE,  bucket[3]);
-			netlogic_write_reg(mmio, R_GMAC_TX2_BUCKET_SIZE,  bucket[4]);
-			netlogic_write_reg(mmio, R_GMAC_TX3_BUCKET_SIZE,  bucket[5]);
-			netlogic_write_reg(mmio, R_GMAC_RFR1_BUCKET_SIZE, bucket[7]);
-	}
-
-	if(credit != NULL) {
-		for (i = 0; i < MAX_NUM_MSGRNG_STN_CC; i++) {
-			netlogic_write_reg(mmio, R_CC_CPU0_0 + i,
-					credit->counters[i >> 3][i & 0x07]);
-		}
-	}
-	return;
-}
-/*******************************************************
- * Initialization gmac
- *******************************************************/
-static void nlm_xlr_gmac_init(struct driver_data *priv, struct port_cfg *pcfg)
-{
-	int i = 0;
-	nlm_reg_t *mmio = priv->mmio;
-	__u32 value = 0;
-	bucket_t *bucket;
-	struct stn_cc *credit;
-
-	nlm_xlr_config_spill_area(priv);
-
-	netlogic_write_reg(priv->mmio, R_DESC_PACK_CTRL,
-			  (BYTE_OFFSET << O_DESC_PACK_CTRL__ByteOffset) |
-			  (1 << O_DESC_PACK_CTRL__MaxEntry)| 
-			  (MAC_MAX_FRAME_SIZE << O_DESC_PACK_CTRL__RegularSize));
-   #ifdef CONFIG_NLMCOMMON_PTP_SUPPORT 
-   	netlogic_write_reg(priv->mmio, R_DESC_PACK_CTRL,
-                      netlogic_read_reg(priv->mmio, R_DESC_PACK_CTRL)|
-                      (1<< O_DESC_PACK_CTRL__PrePadEnable)); 
-   #endif
-
-	if(priv->config_pde) {
-	nlm_xlr_config_pde(priv);
-	nlm_xlr_config_parser(priv);
-	nlm_xlr_config_classifier(priv);
-	}
-
-	netlogic_write_reg(priv->mmio, R_MSG_TX_THRESHOLD, 3);
-
-	netlogic_write_reg(mmio, R_MAC_CONFIG_1, 0x35);
-
-          netlogic_write_reg(mmio,R_RX_CONTROL,(0x7<<6));
-
-	if (priv->phy.serdes_addr != 0 && (priv->phy.mode & PHY_MODE_RGMII)) {
-		value = netlogic_read_reg(priv->mmio, R_RX_CONTROL);
-		value |= 1 << O_RX_CONTROL__RGMII;
-		netlogic_write_reg(priv->mmio, R_RX_CONTROL, value);
-	}
-
-	nlm_xlr_mac_mii_init(priv);
-
-	priv->advertising = ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half | 
-			ADVERTISED_100baseT_Full | ADVERTISED_100baseT_Half |
-			ADVERTISED_1000baseT_Full | ADVERTISED_Autoneg |
-			ADVERTISED_MII;
-    
-	/*Clear pending mdio interrupt*/
-	nlm_xlr_gmac_clr_pending_intr(priv);
-    
-
-	/* Enable all MDIO interrupts in the phy 
-	 * RX_ER bit seems to be get set about every 1 sec in GigE mode,
-	 * ignore it for now...
-	 */
-	nlm_xlr_mac_mii_write(priv->phy.mii_addr, priv->phy.addr, 25, 0xfffffffe);
-	if(priv->phy.serdes_addr) {
-        serdes_regs_init(priv);
-        mdelay(10);
-        serdes_autoconfig(priv);
-    }
-	nlm_xlr_gmac_config_speed(priv);
-
-	value = netlogic_read_reg(mmio, R_IPG_IFG);
-	netlogic_write_reg(mmio, R_IPG_IFG, ((value & ~0x7f) | MAC_B2B_IPG));
-	netlogic_write_reg(mmio, R_DMACR0, 0xffffffff);
-	netlogic_write_reg(mmio, R_DMACR1, 0xffffffff);
-	netlogic_write_reg(mmio, R_DMACR2, 0xffffffff);
-	netlogic_write_reg(mmio, R_DMACR3, 0xffffffff);
-	netlogic_write_reg(mmio, R_STATCTRL, 0x04);
-	netlogic_write_reg(mmio, R_L2ALLOCCTRL, 0xffffffff);
-	netlogic_write_reg(mmio, R_INTMASK, 0);
-	netlogic_write_reg(mmio, R_FREEQCARVE, 0);
-
-		priv->init_frin_desc = 1;
-	bucket = pcfg->bucket;
-	credit = pcfg->credit;
-
-	if(bucket != NULL) {
-			netlogic_write_reg(mmio, R_GMAC_RFR0_BUCKET_SIZE, bucket[1]);
-			netlogic_write_reg(mmio, R_GMAC_TX0_BUCKET_SIZE,  bucket[2]);
-			netlogic_write_reg(mmio, R_GMAC_TX1_BUCKET_SIZE,  bucket[3]);
-			netlogic_write_reg(mmio, R_GMAC_TX2_BUCKET_SIZE,  bucket[4]);
-			netlogic_write_reg(mmio, R_GMAC_TX3_BUCKET_SIZE,  bucket[5]);
-			netlogic_write_reg(mmio, R_GMAC_RFR1_BUCKET_SIZE, bucket[7]);
-	}
-
-	if(credit != NULL) {
-		for (i = 0; i < MAX_NUM_MSGRNG_STN_CC; i++) {
-			netlogic_write_reg(mmio, R_CC_CPU0_0 + i,
-					credit->counters[i >> 3][i & 0x07]);
-		}
-	}
-	return;
-}
-
-/**********************************************************************
- * Set promiscuous mode
- **********************************************************************/
-static void xlr_mac_set_rx_mode(struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	uint32_t regval;
-
-	regval = netlogic_read_reg(priv->mmio, R_MAC_FILTER_CONFIG);
-
-	if (dev->flags & IFF_PROMISC) {
-		regval |= (1 << O_MAC_FILTER_CONFIG__BROADCAST_EN) |
-			(1 << O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN) |
-			(1 << O_MAC_FILTER_CONFIG__ALL_MCAST_EN) |
-			(1 << O_MAC_FILTER_CONFIG__ALL_UCAST_EN);
-	} else {
-		regval &= ~((1 << O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN) |
-			    (1 << O_MAC_FILTER_CONFIG__ALL_UCAST_EN));
-#ifdef PA10401_1_GMAC_PKT_DISCARD
-	  if (!is_xls()){
-                regval |= (1 << O_MAC_FILTER_CONFIG__ALL_MCAST_EN) |
-		          (1 << O_MAC_FILTER_CONFIG__ALL_UCAST_EN);
-          } 
-#endif
-	}
-
-	netlogic_write_reg(priv->mmio, R_MAC_FILTER_CONFIG, regval);
-}
-
-/**********************************************************************
- *  Configure LAN speed for the specified MAC.
- ********************************************************************* */
-static int nlm_xlr_mac_set_speed(struct driver_data *s, xlr_mac_speed_t speed)
-{
-	return 0;
-}
-
-/**********************************************************************
- *  Set Ethernet duplex and flow control options for this MAC
- ********************************************************************* */
-static int nlm_xlr_mac_set_duplex(struct driver_data *s,
-				   xlr_mac_duplex_t duplex, xlr_mac_fc_t fc)
-{
-	return 0;
-}
-
-/*****************************************************************
- * Kernel Net Stack <-> MAC Driver Interface
- *****************************************************************/
-/**********************************************************************
- **********************************************************************/
-#define MAC_TX_PASS NETDEV_TX_OK
-#define MAC_TX_FAIL NETDEV_TX_BUSY
-
-static inline int xlr_netif_queue_tx(struct net_device *dev, 
-		struct sk_buff *skb, int txq)
-{
-	unsigned long flags, mflags;
-	int port = ((struct driver_data *)netdev_priv(dev))->id;
-	struct driver_data *priv = netdev_priv(dev);
-	int ret;
-
-	spin_lock_irqsave(&pending_tx_lock[port], flags);
-	/* try xmit once again. This should take care of the race b/w stopq 
-	   here and wakeup in tx complete 
-	   */
-
-	msgrng_access_enable(mflags);
-	ret = mac_xmit(skb, dev, priv, txq);
-	msgrng_access_disable(mflags);
-
-	if (ret == MAC_TX_PASS) {
-		mac_stats_add(priv->cpu_stats[txq].tx_packets, 1);
-		spin_unlock_irqrestore(&pending_tx_lock[port], flags);
-		return ret;
-	}
-	pending_tx[port]++;
-	netif_tx_stop_queue(netdev_get_tx_queue(dev, smp_processor_id()));
-	priv->stats.tx_dropped++;
-	ret = MAC_TX_FAIL;
-	spin_unlock_irqrestore(&pending_tx_lock[port], flags);
-	return ret;
-}
-
-static inline void xlr_netif_queue_tx_complete(struct net_device *dev)
-{
-	int port = ((struct driver_data *)netdev_priv(dev))->id;
-	struct driver_data *priv = netdev_priv(dev);
-	int end_port = 0;
-	if(port < NETLOGIC_MAX_GMACS){
-		port = (port/4) * 4;
-		end_port = port + 4;
-		for(; port<end_port; port++){
-			if(pending_tx[port]) {
-				priv = netdev_priv(dev_mac[port]);
-				spin_lock(&pending_tx_lock[port]);
-				if(pending_tx[port]){
-					pending_tx[port] = 0;
-					/* is there a easy way to wake up only stopped queues ? */
-					netif_tx_wake_all_queues(dev);
-				}
-				spin_unlock(&pending_tx_lock[port]);
-			}
-		}
-	}else{
-		if(pending_tx[port]) {
-			spin_lock(&pending_tx_lock[port]);
-			if(pending_tx[port]){
-				pending_tx[port] = 0;
-				/* is there a easy way to wake up only stopped queues ? */
-				netif_tx_wake_all_queues(dev);
-			}
-			spin_unlock(&pending_tx_lock[port]);
-		}
-	}
-}
-
-
-
-static int mac_fill_tx_stid(int id, int type)
-{
-	int tx_stid;
-	if (type == TYPE_XGMAC) {
-		tx_stid = msgrng_xgmac_stid_tx(id);
-	} 
-	else {
-		tx_stid = msgrng_gmac_stid_tx(id);
-	}
-	return tx_stid;
-}
-
-
-static inline int mac_make_desc_b0_tx(struct msgrng_msg *msg, struct driver_data *priv,
-				      unsigned long addr, struct sk_buff *skb, unsigned long desc_id)
-{
-	int tx_stid = 0;
-	int fr_stid = 0;
-	int cpu = (netlogic_cpu_id() << 2) | netlogic_thr_id();
-	int len = skb->len;
-
-	fr_stid = cpu_to_frstid[cpu];
-	tx_stid = priv->tx_stid;
-
-
-	msg->msg0 = ( ((uint64_t)1 << 63) | 
-		      (((uint64_t)desc_id) << 54) | 
-		      ((uint64_t)len << 40) | 
-		      ((uint64_t)addr)
-		    );
-
-#ifdef CONFIG_NLMCOMMON_HW_BUFFER_MGMT
-        if (nlm_auto_buffer_mgmt && setup_auto_free(skb, priv->type, msg))
-		return tx_stid;
-	else 
-#endif /* CONFIG_NLMCOMMON_HW_BUFFER_MGMT */
-	{
-		msg->msg1 = ( ((uint64_t)1 << 63) |
-			      ((uint64_t)fr_stid << 54) |
-		      	      ((uint64_t)0 << 40) |
-#ifdef CONFIG_64BIT
-		              ((uint64_t)virt_to_phys(skb))
-#else
-		              ((unsigned long)(skb)&0xffffffffUL)
-#endif
-		            );
-	}
-		
-	msg->msg2 = msg->msg3 = 0;
-
-	return tx_stid;
-}
-
-int
-mac_xmit(struct sk_buff *skb, struct net_device *dev,
-		    struct driver_data *priv, int txq)
-{
-	struct msgrng_msg msg;
-	int stid = 0;
-	int cpu = (netlogic_cpu_id() << 2) | netlogic_thr_id();
-
-	if(cpu_to_bktmask[cpu] == 0) {
-		printk("Tx fail : No buckets are allocated for this cpu\n");
-		return MAC_TX_FAIL;
-	}
-#ifdef  CONFIG_NLMCOMMON_PTP_SUPPORT
-    if(skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMP)) {
-           dbg_msg("transmit timestamp packet \n"); 
-       	   stid = mac_make_desc_b0_tx(&msg, priv, virt_to_phys(skb->data), skb, 126);
-        } else 
-#endif
-        {
-           	stid = mac_make_desc_b0_tx(&msg, priv, virt_to_phys(skb->data), skb, 127);
-        }
-       
-	__sync();
-
-	if (message_send_fast_2(MSGRNG_CODE_MAC, stid, msg.msg0, msg.msg1))
-		return MAC_TX_FAIL;
-
-	port_inc_counter(priv->instance, PORT_TX);
-
-	/* Send the packet to MAC */
-	dbg_msg("Sent tx packet to stid %d, msg0=%llx, msg1=%llx \n", stid, msg.msg0, msg.msg1);
-#ifdef DUMP_PACKETS
-	dump_packet(skb);
-#endif
-
-	xlr_inc_counter(NETIF_TX);
-
-	dev->trans_start = jiffies;
-
-	return MAC_TX_PASS;
-}
-
-
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-
-/* 
- * NAPI poll function on upper four buckets 
-*/
-void
-xlr_napi_poll_upper(struct net_device *dummy_dev, int budget)
-{
-	struct msgrng_msg msg_body, *msg = &msg_body;
-	int bucket, stid = 0, length;
-	unsigned long mflags = 0;
-	unsigned int status;
-	int data_rx_bucket;
-	int size = 0, code = 0;
-	struct tx_stn_handler *handler;
-	int tx_stid, rcv_mask;
-
-	data_rx_bucket = netlogic_thr_id() + 4;
-
-	msg_body.msg0 = 0; // Keep compiler happy
-	while (1) {
-
-		msgrng_access_enable(mflags);
-		if ((rcv_mask = (~msgrng_read_status() >> 28) & 0xf))
-			bucket = get_adjusted_bucket_index(rcv_mask);
-		else {
-			msgrng_access_disable(mflags);
-			break;
-		}
-
-		if (nlm_on_chip_napi) {
-			status = message_receive(bucket, &size, &code, &stid, msg);
-		}
-		else {
-			status = message_receive_fast_1(bucket, size, code, stid, msg_body.msg0);
-		}
-
-		msgrng_access_disable(mflags);
-
-		if (status) {
-			continue;
-		}
-
-		if (nlm_on_chip_napi) {
-			/* this block is a quick check for messages arriving from non GMAC/XGMAC stations */
-			tx_stid = rxstn_to_txstn_ptr[stid];
-			if (tx_stns[tx_stid].handler.action != nlm_xlr_mac_msgring_handler) {
-				handler = &tx_stns[tx_stid].handler;
-				if (handler->action) {
-					(handler->action)(bucket, size, code, stid, msg, handler->dev_id);
-				}
-				continue;
-			}
-		}
-
-		length = (msg->msg0 >> 40) & 0x3fff;
-
-		if (length) {
-			printk("%s: message with non-zero length from buckets 4-7\n", __FUNCTION__);
-			continue;
-		}
-
-		nlm_xlr_free_skb(msg);
-	} /* closing while (1) */
-}
-EXPORT_SYMBOL(xlr_napi_poll_upper);
-
-/* 
- * NAPI poll function on lower four buckets 
-*/
-int
-napi_poll_lower(struct net_device *dummy_dev, int budget)
-{
-	struct msgrng_msg msg_body, *msg = &msg_body;
-	int stid = 0, length;
-	int port;
-	struct sk_buff *skb;
-	int received = 0;
-	unsigned int data_rx_bucket; 
-	unsigned long addr;
-	unsigned long mflags = 0;
-	unsigned int status;
-	int size = 0, code = 0;
-	int cpu = hard_smp_processor_id();
-	struct driver_data *priv;
-	unsigned int rxStatus;
-	struct tx_stn_handler *handler;
-	int tx_stid;
-#ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
-	unsigned char *prepad = NULL;
-#endif /* CONFIG_NLMCOMMON_PTP_SUPPORT */
-
-	data_rx_bucket = netlogic_thr_id();
-	msg_body.msg0 = 0;
-
-	while (1) {
-		msgrng_access_enable(mflags);
-
-		if  ((msgrng_read_status() >> (data_rx_bucket + 24)) & 0x1) {
-			msgrng_access_disable(mflags);
-			break;
-		}
-
-		if (nlm_on_chip_napi) {
-			status = message_receive(data_rx_bucket, &size, &code, &stid, msg);
-		}
-		else {
-			status = message_receive_fast_1(data_rx_bucket, size, code, stid, msg_body.msg0);
-		}
-
-		msgrng_access_disable(mflags);
-   
-		if (status) {
-			continue;
-		}
-
-		if (nlm_on_chip_napi) {
-			/* quick check for messages arriving from stations different from GMAC/XGMAC */
-			tx_stid = rxstn_to_txstn_ptr[stid];
-			if (tx_stns[tx_stid].handler.action != nlm_xlr_mac_msgring_handler) {
-				handler = &tx_stns[tx_stid].handler;
-				if (handler->action) {
-					(handler->action)(data_rx_bucket, size, code, stid, msg, handler->dev_id);
-				}
-				continue;
-			}
-		}
-
-		length = (msg->msg0 >> 40) & 0x3fff;
-		if (length == 0) {
-			printk("%s: message from data buckets with zero length...\n", __FUNCTION__);
-			continue;
-		}
-
-		/* we got a rx buffer with data from the MAC */
-		addr = (unsigned long) bus_to_virt(msg->msg0 & 0xffffffffe0ULL);
-		length = length  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD;
-		port = msg->msg0 & 0x0f;
-		skb = mac_get_skb_back_ptr(addr);
-    
-		prefetch_local(skb->data);
-	    
-		if (is_xls()) {
-			if (stid == MSGRNG_STNID_GMAC0)
-				skb->dev = dev_mac_type[TYPE_GMAC][port];
-			else if (stid == MSGRNG_STNID_GMAC1)
-				skb->dev = dev_mac_type[TYPE_GMAC][4 + port];
-			else {
-				printk("[%s]: desc (0x%lx) for unknown station %d? dropping\n",
-									__FUNCTION__, addr, stid);
-				continue;
-			}
-		}
-		else {
-			if (stid == MSGRNG_STNID_XGS0FR)
-				skb->dev = dev_mac_type[TYPE_XGMAC][0];
-			else if (stid == MSGRNG_STNID_XGS1FR)
-				skb->dev = dev_mac_type[TYPE_XGMAC][1];
-			else
-				skb->dev = dev_mac_type[TYPE_GMAC][port];
-		}
-
-		priv = netdev_priv(skb->dev);
-   
-		if (msg->msg0 & (0x40ULL << 56))
-		{
-			rxStatus = (msg->msg0 >> 56 ) & 0x7f;
-			dbg_msg("Rx err 0x%x\n",rxStatus);
-			mac_stats_add(priv->stats.rx_errors,1);
-			if (rxStatus & 0x02)
-				mac_stats_add(priv->stats.rx_crc_errors,1);
-			if (rxStatus & 0x01)
-				mac_stats_add(priv->stats.rx_length_errors,1);
-
-			if (!nlm_auto_buffer_mgmt) {
-				mac_frin_replenish_one_msg(skb->dev);
-			}
-			dev_kfree_skb(skb);
-
-			continue;
-		}
-
-#ifdef PA10401_1_GMAC_PKT_DISCARD
-		if ((!is_xls()) && (!(skb->dev->flags & IFF_PROMISC))) {
-			if (!(msg->msg0 & (0x20ULL << 56))) {
-				if ((*(uint64_t *)(skb->data + MAC_PREPAD + BYTE_OFFSET)>>16) !=
-							   ((*(uint64_t *)skb->dev->dev_addr)>>16))
-				{
-					if (!nlm_auto_buffer_mgmt) {
-						mac_frin_replenish_one_msg(skb->dev);
-					}
-					dev_kfree_skb(skb);
-					continue;
-				}
-			}
-		}
-#endif
-
-       	skb_reserve(skb, MAC_PREPAD+BYTE_OFFSET );
-        
-		skb_put(skb, length);
-		skb->protocol = eth_type_trans(skb, skb->dev);
-// 1588
-    #ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
-        prepad =(unsigned char *) addr; 
-        if(p_ptp_set_ts)
-            p_ptp_set_ts(*((unsigned int *) prepad), 
-                         *((unsigned int *) prepad + 1), 
-                         &skb->tstamp, 1); 
-    #endif
-        
-		mac_stats_add(priv->stats.rx_packets, 1);
-		mac_stats_add(priv->stats.rx_bytes, skb->len);
-		mac_stats_add(priv->cpu_stats[cpu].rx_packets, 1);
-
-		xlr_inc_counter(NETIF_RX);
-		xlr_set_counter(NETIF_RX_CYCLES, (read_c0_count() - msgrng_msg_cycles));
-
-		if (!nlm_auto_buffer_mgmt) {
-			mac_frin_replenish_one_msg(skb->dev);
-		}
-
-		skb->dev->last_rx = jiffies;
-		netif_receive_skb(skb);
-
-		__get_cpu_var(xlr_napi_rx_count)++; 
-
-		/* If number of received packets is exceeding poll weight we exit */
-		if (++received >= budget) {
-			break;
-		}
-	} /* end of while loop */
-
-	return received;
-}
-
-
-
-/*
- *  Version of transmit used in conjunction with NAPI mode
-*/
-static int
-nlm_xlr_napi_mac_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	unsigned long mflags = 0;
-	int txq = hard_smp_processor_id();
-	int count = 0, ret;
-
-
-	xlr_inc_counter(NETIF_STACK_TX);
-
-	do {
-		msgrng_access_enable(mflags);
-
-		if (upper_buckets_nonempty()) {
-			msgrng_access_disable(mflags);
-			xlr_napi_poll_upper(dev, 0);
-			msgrng_access_enable(mflags);
-		}
-
-		ret = mac_xmit(skb, dev, priv, txq);
-		msgrng_access_disable(mflags);
-
-		if (ret == MAC_TX_PASS) {
-			mac_stats_add(priv->cpu_stats[txq].tx_packets, 1);
-			return ret;
-		}
-
-		count++;
-
-		if(count < 16)
-			continue;
-
-		ret = xlr_netif_queue_tx(dev, skb, txq);
-		break;
-
-	} while (1);
-	
-	if (ret == MAC_TX_FAIL) {
-		/* FULL */
-		dbg_msg("Msg Ring Full. Stopping upper layer Q\n");
-		port_inc_counter(priv->instance, PORT_STOPQ);
-	}
-
-	return ret;
-}
-
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-
-/*
- * Version of transmit used in regular interrupt-driven mode
-*/
-static int
-nlm_xlr_mac_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	int ret = -ENOSPC;
-	unsigned long mflags = 0;
-	int txq = hard_smp_processor_id();
-	int count = 0;
-
-
-	xlr_inc_counter(NETIF_STACK_TX);
-
-	do {
-		msgrng_access_enable(mflags);
-		
-		if (priv->frstid_rsvd == 1 && upper_buckets_nonempty()) {
-
-			irq_enter();
-			msgring_process_rx_msgs(MSGRING_PROCESS_FROUT_START_BUCKET,
-						MSGRING_PROCESS_FROUT_END_BUCKET,
-						MSGRING_PROCESS_FROUT_POP_BUCKET_MASK);
-			irq_exit();
-		}
-		ret = mac_xmit(skb, dev, priv, txq);
-		msgrng_access_disable(mflags);
-
-		if (ret == MAC_TX_PASS) {
-			mac_stats_add(priv->cpu_stats[txq].tx_packets, 1);
-			break;
-		}
-
-		count++;
-
-		if(count < 16)
-			continue;
-
-		ret = xlr_netif_queue_tx(dev, skb, txq);
-		break;
-	} while (1);
-
-	return ret;
-}
-
-
-/* If allocation fails in the replenish tasklet, this function will replenish
-   the RX buffers from the workqueue context. Replenish tasklet is disabled
-   until this function is done with replenishment.
-   */
-static void mac_frin_replenish_wq(struct work_struct *args /* ignored */)
-{
-	int cpu = hard_smp_processor_id();
-	int done = 0;
-	int i = 0;
-
-	xlr_inc_counter(REPLENISH_ENTER);
-	//xlr_set_counter(REPLENISH_ENTER_COUNT, atomic_read(frin_to_be_sent));
-	xlr_set_counter(REPLENISH_CPU, hard_smp_processor_id());
-
-	for (;;) {
-
-		done = 0;
-
-		for (i = 0; i < NETLOGIC_MAX_MACS; i++) {
-			int offset = 0;
-			unsigned long msgrng_flags;
-			struct sk_buff *skb = 0;
-			__u32 cycles;
-			struct net_device *dev;
-			struct driver_data *priv;
-			atomic_t *frin_to_be_sent;
-
-			dev = dev_mac[i];
-			if (dev == 0)
-				goto skip;
-
-			priv = netdev_priv(dev);
-			frin_to_be_sent = &priv->frin_to_be_sent[cpu];
-
-			if(!(MSGRNG_OWN(priv->cfg_flag)))
-				goto skip;
-
-			if (atomic_read(frin_to_be_sent) < 0) {
-				panic
-					("BUG?: [%s]: gmac_%d illegal value for frin_to_be_sent=%d\n",
-					 __FUNCTION__, i,
-					 atomic_read(frin_to_be_sent));
-			}
-
-			if (!atomic_read(frin_to_be_sent))
-				goto skip;
-
-			cycles = read_c0_count();
-			{
-				skb = __dev_alloc_skb(NLM_RX_BUF_SIZE,
-					GFP_ATOMIC | __GFP_REPEAT |
-				       	__GFP_NOWARN);
-
-				if (!skb) {
-					skb =
-					__dev_alloc_skb(NLM_RX_BUF_SIZE,
-								GFP_KERNEL);
-					if (!skb)
-						panic
-						("[%s]:Unable to allocate skb!\n",
-							 __FUNCTION__);
-				}
-			}
-			xlr_inc_counter(REPLENISH_FRIN);
-
-			/* align the data to the next cache line */
-			offset = (((unsigned long)skb->data + SMP_CACHE_BYTES) &
-				  ~(SMP_CACHE_BYTES - 1));
-			skb_reserve(skb, (offset - (unsigned long)skb->data));
-
-			//skb->dev = dev;
-
-			msgrng_access_enable(msgrng_flags);
-			mac_put_skb_back_ptr(skb);
-
-			if (xlr_mac_send_fr(priv, virt_to_bus(skb->data), skb->len)) {
-				dev_kfree_skb(skb);
-				printk("[%s]: rx free message_send failed!\n",
-				       __FUNCTION__);
-				break;
-			}
-			msgrng_access_disable(msgrng_flags);
-
-			xlr_set_counter(REPLENISH_CYCLES,
-					 (read_c0_count() - cycles));
-
-			atomic_dec(frin_to_be_sent);
-
-			continue;
-		skip:
-			done++;
-		}
-		if (done == NETLOGIC_MAX_MACS)
-			break;
-	}
-	tasklet_enable(&mac_frin_replenish_task[cpu]);
-}
-
-
-static void mac_frin_replenish(unsigned long arg /* ignored */ )
-{
-	int cpu = hard_smp_processor_id();
-	int done = 0;
-	int i = 0;
-
-	xlr_inc_counter(REPLENISH_ENTER);
-	//xlr_set_counter(REPLENISH_ENTER_COUNT, atomic_read(frin_to_be_sent));
-	xlr_set_counter(REPLENISH_CPU, hard_smp_processor_id());
-
-	for (;;) {
-
-		done = 0;
-
-		for (i = 0; i < NETLOGIC_MAX_MACS; i++) {
-			int offset = 0;
-			unsigned long msgrng_flags;
-			struct sk_buff *skb = 0;
-			__u32 cycles;
-			struct net_device *dev;
-			struct driver_data *priv;
-			atomic_t *frin_to_be_sent;
-
-			dev = dev_mac[i];
-			if (dev == 0)
-				goto skip;
-
-			priv = netdev_priv(dev);
-			frin_to_be_sent = &priv->frin_to_be_sent[cpu];
-
-			if(!(MSGRNG_OWN(priv->cfg_flag)))
-				goto skip;
-
-			if (atomic_read(frin_to_be_sent) < 0) {
-				panic
-					("BUG?: [%s]: gmac_%d illegal value for frin_to_be_sent=%d\n",
-					 __FUNCTION__, i,
-					 atomic_read(frin_to_be_sent));
-			}
-
-			if (!atomic_read(frin_to_be_sent))
-				goto skip;
-
-			cycles = read_c0_count();
-			{
-				skb =
-					__dev_alloc_skb(NLM_RX_BUF_SIZE,
-							GFP_ATOMIC | __GFP_REPEAT |
-							__GFP_NOWARN);
-				if (!skb) {
-					tasklet_disable_nosync
-					(&mac_frin_replenish_task[cpu]);
-					schedule_work
-					(&mac_frin_replenish_work[cpu]);
-					return;
-				}
-			}
-			xlr_inc_counter(REPLENISH_FRIN);
-
-			/* align the data to the next cache line */
-			offset = (((unsigned long)skb->data + SMP_CACHE_BYTES) &
-				  ~(SMP_CACHE_BYTES - 1));
-			skb_reserve(skb, (offset - (unsigned long)skb->data));
-
-			//skb->dev = dev;
-
-			msgrng_access_enable(msgrng_flags);
-			mac_put_skb_back_ptr(skb);
-
-			if (xlr_mac_send_fr(priv, virt_to_bus(skb->data), skb->len)) {
-				dev_kfree_skb(skb);
-				printk("[%s]: rx free message_send failed!\n",
-				       __FUNCTION__);
-				break;
-			}
-			msgrng_access_disable(msgrng_flags);
-
-			xlr_set_counter(REPLENISH_CYCLES,
-					 (read_c0_count() - cycles));
-
-			atomic_dec(frin_to_be_sent);
-
-			continue;
-		skip:
-			done++;
-		}
-		if (done == NETLOGIC_MAX_MACS)
-			break;
-	}
-}
-
-/*
- * Send a packet back to the station
- */
-void nlm_xlr_drop_message_unowned(int fbid, uint64_t physaddr, int cop_en)
-{
-	struct msgrng_msg msg;
-	unsigned long msgrng_flags = 0;
-
-	/*printk(" nlm_xlr_drop_message_unowned fbid = %d physaddr=%llx\n",
-			fbid, physaddr); */
-
-	if(cop_en)
-		msgrng_access_enable(msgrng_flags);
-
-	msg.msg0 =
-		((u64) CTRL_REG_FREE << 61) | ((u64) fbid << 52) | (u64) physaddr;
-	msg.msg1 = msg.msg2 = msg.msg3 = 0;
-	while (message_send(1, MSGRNG_CODE_MAC, fbid, &msg)) ;
-
-	if(cop_en)
-		msgrng_access_disable(msgrng_flags);
-}
-
-
-
-
-static inline void nlm_xlr_free_skb(struct msgrng_msg *msg)
-{
-	struct sk_buff *skb;
-	struct driver_data *priv;
-	int cpu = hard_smp_processor_id();
-	#ifdef CONFIG_64BIT
-	unsigned long tmp;
-	tmp = (unsigned long)(msg->msg0 & 0xffffffffffULL);
-	skb = (struct sk_buff *)phys_to_virt(tmp);
-	#else
-	skb = (struct sk_buff *)(unsigned long)msg->msg0;
-	#endif
-	/* Tx Complete */
-	xlr_inc_counter(NETIF_TX_COMPLETE);
-
-	dbg_msg("skb = %p\n", skb);
-	/* release the skb and update statistics outside the spinlock */
-	priv = netdev_priv(skb->dev);
-	mac_stats_add(priv->stats.tx_packets, 1);
-	mac_stats_add(priv->stats.tx_bytes, skb->len);
-	mac_stats_add(priv->cpu_stats[cpu].txc_packets, 1);
-#ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
-        if(skb->sk) {
-        	if (sock_flag(skb->sk, SOCK_TIMESTAMP)) {
-//               dump_all_interface(0x75); 
-              if(p_ptp_set_ts) {
-                   
-                    p_ptp_set_ts(netlogic_read_reg(priv->mmio, 0x76), 
-                                   netlogic_read_reg(priv->mmio, 0x75), NULL, 1); 
-                }
-            }
-        }
-#endif
-
-
-	port_inc_counter(priv->instance, PORT_TX_COMPLETE);
-	xlr_netif_queue_tx_complete(skb->dev);
-
-	xlr_set_counter(NETIF_TX_COMPLETE_CYCLES,
-		(read_c0_count() - msgrng_msg_cycles));
-	dev_kfree_skb_any(skb);
-}
-
-
-/*
- * Send a packet back to ipsec rmios
- */
-static void ipsec_drop_packet(IPSEC_PACKET * pbuf)
-{
-	int stid=0;
-	u32 addr;
-	struct msgrng_msg msg;
-        if (is_xls()) {
-            if (pbuf->src_id == MSGRNG_STNID_GMAC0)
-		stid = MSGRNG_STNID_GMAC0_FR;
-            else if (pbuf->src_id == MSGRNG_STNID_GMAC1)
-		stid = MSGRNG_STNID_GMAC1_FR;
-            else {
-                printk("[%s]: rx packet (0x%p) for unknown station %d? dropping packet\n",
-                       __FUNCTION__, pbuf, stid);
-                return;
-	    }
-        }
-        else {
-	    if (pbuf->src_id == MSGRNG_STNID_XGS0FR)
-		stid = MSGRNG_STNID_XMAC0RFR;
-	    else if (pbuf->src_id == MSGRNG_STNID_XGS1FR)
-		stid = MSGRNG_STNID_XMAC1RFR;
-	    else
-		stid = MSGRNG_STNID_GMACRFR_0;
-        }
-	addr = virt_to_phys(pbuf->packet_data + SKBUF_HEAD);
-	msg.msg0 =
-		((u64) CTRL_REG_FREE << 61) | ((u64) stid << 52) | (u64) addr;
-	msg.msg1 = msg.msg2 = msg.msg3 = 0;
-	while (message_send(1, MSGRNG_CODE_MAC, stid, &msg)) ;
-}
-
-/*
- * Receive a packet from rmios ipsec. This function is called by the message
- * ring driver when the message source is a CPU and the message code indicates
- * a packet from rmios. The message ring driver can also receive a fifo message
- * from a CPU sending an event or response to a user space process.
- */
-void nlm_xlr_rmios_msgring_handler(int bucket, int size, int code,
-				    int stid, struct msgrng_msg *msg,
-				    void *data /* ignored */ )
-{
-	unsigned long addr;
-	__u32 length;
-	int port;
-	struct sk_buff *skb;
-	struct driver_data *priv;
-	IPSEC_PACKET *ipsec_packet;
-	/*
-	 * Find the ipsec packet
-	 */
-	addr = (unsigned long)bus_to_virt(msg->msg0 & 0xffffffffe0ULL);
-	ipsec_packet = (IPSEC_PACKET *) (addr - SKBUF_HEAD -
-					 offsetof(IPSEC_PACKET, packet_data));
-	/*
-	 * Do nothing during the boot.
-	 */
-	if (system_state != SYSTEM_RUNNING) {
-		ipsec_drop_packet(ipsec_packet);
-		return;
-	}
-	/*
-	 * Allocate an skbuff, initialize it, and copy the data to it.
-	 */
-	length =
-		((msg->msg0 >> 40) & 0x3fff) - BYTE_OFFSET - MAC_CRC_LEN -MAC_PREPAD;
-	skb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_ATOMIC);
-	if (!skb) {
-		printk("[%s] - no skbuff\n", __FUNCTION__);
-		ipsec_drop_packet(ipsec_packet);
-		return;
-	}
-	port = code >> 4;
-	skb->dev = dev_mac_type[TYPE_GMAC][port];
-	skb_put(skb, length);
-	memcpy(skb->data, (char *)addr + 2, length);
-	ipsec_drop_packet(ipsec_packet);
-	skb->protocol = eth_type_trans(skb, skb->dev);
-	/*
-	 * Increment the driver stats counters.
-	 */
-	priv = netdev_priv(skb->dev);
-	mac_stats_add(priv->stats.rx_packets, 1);
-	mac_stats_add(priv->stats.rx_bytes, skb->len);
-	/*
-	 * Queue the packet to the upper layer.
-	 */
-	skb->dev->last_rx = jiffies;
-	netif_rx(skb);
-}
-
-
-
-/* This function is called from an interrupt handler */
-void nlm_xlr_mac_msgring_handler(int bucket, int size, int code,
-				  int stid, struct msgrng_msg *msg,
-				  void *data /* ignored */ )
-{
-#ifndef CONFIG_NLMCOMMON_HW_BUFFER_MGMT
-/* 
- * Special helper macro to handle Rx errors within this interrupt handler
- * macro is used locally in this function only
- *
- * NB: the alternative case when HW buffer management is on is handled by a 
- * larger function defined above
-*/
-#define discard_rx_frame(dev, skb, cpu) \
-do { \
-	if (atomic_inc_return(&priv->frin_to_be_sent[cpu]) > \
-				MAC_FRIN_TO_BE_SENT_THRESHOLD) { \
-		tasklet_schedule(&mac_frin_replenish_task[cpu]); \
-	} \
-	dev_kfree_skb_irq(skb); \
-} while (0)
-
-#endif /* !CONFIG_NLMCOMMON_HW_BUFFER_MGMT */
-
-	unsigned long addr = 0;
-	__u32 length = 0;
-	int ctrl = 0, port = 0;
-	struct sk_buff *skb = 0;
-	int cpu = hard_smp_processor_id();
-
-#ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
-	unsigned char *prepad = NULL;
-#endif /* CONFIG_NLMCOMMON_PTP_SUPPORT */
-
-	dbg_msg("mac: bucket=%d, size=%d, code=%d, stid=%d, msg0=%llx msg1=%llx\n",
-		 bucket, size, code, stid, msg->msg0, msg->msg1);
-
-	addr = (unsigned long)bus_to_virt(msg->msg0 & 0xffffffffe0ULL);
-	length = (msg->msg0 >> 40) & 0x3fff;
-	if (length == 0) {
-		ctrl = CTRL_REG_FREE;
-		port = (msg->msg0 >> 54) & 0x0f;
-	}
-	else {
-		ctrl = CTRL_SNGL;
-		length = length - BYTE_OFFSET - MAC_CRC_LEN - MAC_PREPAD;
-		port = msg->msg0 & 0x0f;
-	}
-
-	dbg_msg("msg0 = %llx, msg1 = %llx, stid = %d, port = %d, addr=%lx, length=%d, ctrl=%d\n", 
-		msg->msg0, msg->msg1, stid, port, addr, length, ctrl);
-
-	if (ctrl == CTRL_REG_FREE) {
-		/* free the message , freeback should be the 
-			packets send by linux */
-		nlm_xlr_free_skb(msg);
-
-	} else if (ctrl == CTRL_SNGL || ctrl == CTRL_START) {
-		/* Rx Packet */
-
-		struct driver_data *priv = 0;
-                unsigned int rxStatus=0;
-
-		dbg_msg("Received packet, port = %d\n", port);
-
-		skb = mac_get_skb_back_ptr(addr);
-		if (!skb) {
-			printk("[%s]: rx desc (0x%lx) for unknown skb? dropping packet\n", 
-                                                                                __FUNCTION__, addr);
-			return;
-		}
-		
-		if (is_xls()) {
-			if (stid == MSGRNG_STNID_GMAC0)
-				skb->dev = dev_mac_type[TYPE_GMAC][port];
-			else if (stid == MSGRNG_STNID_GMAC1)
-				skb->dev = dev_mac_type[TYPE_GMAC][4 + port];
-			else {
-				printk("[%s]: rx desc (0x%lx) for unknown station %d? dropping packet\n",
-					__FUNCTION__, addr, stid);
-				return;
-			}
-		}
-		else {
-			if (stid == MSGRNG_STNID_XGS0FR)
-				skb->dev = dev_mac_type[TYPE_XGMAC][0];
-			else if (stid == MSGRNG_STNID_XGS1FR)
-				skb->dev = dev_mac_type[TYPE_XGMAC][1];
-			else
-				skb->dev = dev_mac_type[TYPE_GMAC][port];
-		}
-		
-		priv = netdev_priv(skb->dev);
-                
-                rxStatus = (msg->msg0 >> 56 ) & 0x7f;
-                if (rxStatus & 0x40)
-                {
-                  dbg_msg("Rx err 0x%x\n",rxStatus);
-                  mac_stats_add(priv->stats.rx_errors,1);
-                  if (rxStatus & 0x02)
-                    mac_stats_add(priv->stats.rx_crc_errors,1);
-                  if (rxStatus & 0x01)
-                    mac_stats_add(priv->stats.rx_length_errors,1);
-
-                  discard_rx_frame(skb->dev, skb, cpu);
-                  return;
-                }
-
-#ifdef PA10401_1_GMAC_PKT_DISCARD
-               if ((!is_xls()) && (!(skb->dev->flags & IFF_PROMISC)))
-                {
-                  if (!(rxStatus & 0x20))
-                  {
-                    if ((*(uint64_t *)(skb->data+MAC_PREPAD + BYTE_OFFSET)>>16) !=
-                     ((*(uint64_t *)skb->dev->dev_addr)>>16))
-                     {
-		      discard_rx_frame(skb->dev, skb, cpu);
-                      return;
-                     }
-                  }
-               }
-#endif
-
-		/* if num frins to be sent exceeds threshold, wake up the helper thread */
-		if (!nlm_auto_buffer_mgmt && 
-			     atomic_inc_return(&priv->frin_to_be_sent[cpu]) > MAC_FRIN_TO_BE_SENT_THRESHOLD) {
-			tasklet_schedule(&mac_frin_replenish_task[cpu]);
-		}
-
-#ifdef DUMP_PACKETS
-		dump_packet(skb);
-#endif /* DUMP_PACKETS */
-
-		/* compensate for the prepend data, byte offset */
-		skb_reserve(skb, MAC_PREPAD + BYTE_OFFSET);
-
-		skb_put(skb, length);
-		skb->protocol = eth_type_trans(skb, skb->dev);
-                
-		dbg_msg("gmac_%d: rx packet: addr = %lx, length = %x, protocol=%d\n",
-			 priv->instance, addr, length, skb->protocol);
-
-		mac_stats_add(priv->stats.rx_packets, 1);
-		mac_stats_add(priv->stats.rx_bytes, skb->len);
-		mac_stats_add(priv->cpu_stats[cpu].rx_packets, 1);
-
-    #ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
-        prepad =(unsigned char *) addr; 
-        if(p_ptp_set_ts)
-            p_ptp_set_ts(*((unsigned int *) prepad), 
-                         *((unsigned int *) prepad + 1), 
-                         &skb->tstamp, 1); 
-    #endif
- 
-		xlr_inc_counter(NETIF_RX);
-		xlr_set_counter(NETIF_RX_CYCLES, (read_c0_count() - msgrng_msg_cycles));
-
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-		/* 
-                 * We pass bucket number in the last field of skb->cb[] structure 
-                 * it might be later picked up by multiprocess ip_queue
-                */
-                skb->cb[sizeof(skb->cb) - 1] = bucket;
-#endif /* CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY */
-
-
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-		skb_transfer(bucket, skb);
-#else
-		skb->dev->last_rx = jiffies;
-		netif_rx(skb);
-#endif /* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
-
-	} else {
-		printk("[%s]: unrecognized ctrl=%d!\n", __FUNCTION__, ctrl);
-	}
-}
-
-/* message ring handler where mac is owned by apps not linux */
-void nlm_xlr_station_unowned_msgring_handler(int bucket, int size, int code,
-				    int stid, struct msgrng_msg *msg,
-				    void *data /* ignored */ )
-{
-	unsigned long addr;
-	__u32 length;
-	int port;
-	struct sk_buff *skb = NULL;
-	struct driver_data *priv;
-	int fbstid = 0x0;
-
-	addr = (unsigned long)bus_to_virt(msg->msg0 & 0xffffffffe0ULL);
-	port = ((msg->msg0)  & 0x0f);
-	length = ((msg->msg0 >> 40) & 0x3fff);
-
-	/* printk("[%s] : port=%d length=%d\n", __FUNCTION__, port, length); */
-
-	/* free back should be the packets send by linux */
-	if(length == 0x0)  {
-		/* free the message , freeback should be the 
-			packets send by linux */
-		nlm_xlr_free_skb(msg);
-		return;
-	}
-
-
-	/*
-	 * Allocate an skbuff, initialize it, and copy the data to it.
-	 */
-	skb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_ATOMIC);
-	if (!skb) {
-		printk("[%s] - no skbuff\n", __FUNCTION__);
-		goto err_exit;
-	}
-
-	if (is_xls()) {
-		if (stid == MSGRNG_STNID_GMAC0) {
-			skb->dev = dev_mac_type[TYPE_GMAC][port];
-			fbstid = MSGRNG_STNID_GMAC0_FR;
-		} else if (stid == MSGRNG_STNID_GMAC1) {
-			skb->dev = dev_mac_type[TYPE_GMAC][4 + port];
-			fbstid = MSGRNG_STNID_GMAC1_FR;
-		} else {
-			printk("[%s]: rx desc (0x%lx) for unknown station %d? dropping packet\n",
-				__FUNCTION__, addr, stid);
-			goto err_exit;
-		}
-	} else {
-		if (stid == MSGRNG_STNID_XGS0FR) {
-			skb->dev = dev_mac_type[TYPE_XGMAC][0];
-			fbstid = MSGRNG_STNID_XMAC0RFR;
-		} else if (stid == MSGRNG_STNID_XGS1FR) {
-			skb->dev = dev_mac_type[TYPE_XGMAC][1];
-			fbstid = MSGRNG_STNID_XMAC1RFR;
-		} else {
-			skb->dev = dev_mac_type[TYPE_GMAC][port];
-			fbstid = MSGRNG_STNID_GMACRFR_0;
-		}
-	}
-
-#if 0
-	printk("nlm_xlr_station_unowned_msgring_handler ingress port=%d stid=%d\n", port, stid);
-#endif
-	if(skb->dev == 0) {
-		printk("[%s] - no dev\n", __FUNCTION__);
-		goto err_exit;
-	}
-	
-	length = length - (BYTE_OFFSET + MAC_CRC_LEN);
-	skb_put(skb, length);
-	memcpy(skb->data, (char *)addr + 2, length);
-/*	
-	if(rmik_queue_pkt_mem(fbstid, msg->msg0 & 0xffffffffe0ULL) < 0)
-		nlm_xlr_drop_message_unowned(fbstid, msg->msg0 & 0xffffffffe0ULL, 1);
-*/
-#if 0
-		{
-			int i = 0;
-			printk("Rx Packet: length=%d\n", length);
-			for (i = 0; i < 64; i++) {
-				printk("%02x ", skb->data[i]);
-				if (i && (i % 16) == 0)
-					printk("\n");
-			}
-			printk("\n");
-		}
-#endif
-
-	skb->protocol = eth_type_trans(skb, skb->dev);
-	/*
-	 * Increment the driver stats counters.
-	 */
-	priv = netdev_priv(skb->dev);
-	mac_stats_add(priv->stats.rx_packets, 1);
-	mac_stats_add(priv->stats.rx_bytes, skb->len);
-	/*
-	 * Queue the packet to the upper layer.
-	 */
-	skb->dev->last_rx = jiffies;
-	netif_rx(skb);
-	return;
-
-	err_exit:
-/*
-		nlm_xlr_drop_message_unowned(fbstid, msg->msg0 & 0xffffffffe0ULL, 1);
-*/
-		if(skb)
-			kfree_skb(skb);
-		return;
-
-}
-
-
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-extern void core_send_ipi(int cpu, unsigned int action);
-
-static void
-skb_transfer(int bucket, struct sk_buff *skb)
-{
-  u_long my_cpu_no, my_thread_no, my_core_no, target_cpu_no, target_thread_no;
-
-
-  target_thread_no = bucket & 0x3;
-  my_cpu_no = smp_processor_id();
-  my_thread_no = netlogic_thr_id();
-  my_core_no = netlogic_cpu_id();
-  target_cpu_no = cpu_number_map((my_core_no << 2) | target_thread_no);
-
-  /*
-   * Version with NETRX IPI aggregation
-  */
-  if (target_thread_no != my_thread_no && cpu_isset(target_cpu_no, cpu_online_map))
-  {
-    unsigned long flags;
-    struct sk_buff_head *ptqueue = &cpu_skb_tqueue[target_cpu_no];
-
-    spin_lock_irqsave(&ptqueue->lock, flags);
-    if (ptqueue->qlen)
-    {
-       __skb_queue_tail(ptqueue, skb);
-    }
-    else
-    {
-       __skb_queue_tail(ptqueue, skb);
-       core_send_ipi(target_cpu_no, SMP_NETRX_IPI);
-    }
-    spin_unlock_irqrestore(&ptqueue->lock, flags);
-
-    skb_transfer_stat[my_cpu_no][target_cpu_no]++;
-  }
-  else
-  {
-    skb_transfer_stat[my_cpu_no][my_cpu_no]++;
-
-    skb_queue_tail(&cpu_skb_tqueue[my_cpu_no], skb);
-    skb_transfer_finish();
-  }
-
-}
-
-
-/* second part of SKB transfer logic, called from IRQ_IPI_NETRX handler */
-void
-skb_transfer_finish(void)
-{
-  struct sk_buff *skb;
-  u_long cpu = smp_processor_id();
-
-  while ((skb = skb_dequeue(&cpu_skb_tqueue[cpu])) != NULL)
-  {
-	  skb->dev->last_rx = jiffies;
-	  netif_rx(skb);
-  }
-}
-
-#endif /* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
-
-
-/**********************************************************************
- **********************************************************************/
-static irqreturn_t nlm_xlr_mac_int_handler(int irq, void *dev_id)
-{
-    struct net_device *dev = (struct net_device *)dev_id;
-    struct driver_data *priv = netdev_priv(dev);
-    nlm_reg_t *mmio = priv->mmio;
-    __u32 intreg = netlogic_read_reg(mmio, R_INTREG);
-    int cpu = hard_smp_processor_id();
-
-    mac_stats_add(priv->cpu_stats[cpu].interrupts, 1);
-
-    if (intreg & (1 << O_INTREG__MDInt)) {
-        __u32 phy_int_status = 0;
-        int i=0;
-
-        for(i=0; i<NETLOGIC_MAX_MACS; i++) {
-            struct net_device *phy_dev = 0;
-            struct driver_data *phy_priv = 0;
-            uint32_t config_val =0;
-
-            phy_dev = dev_mac[i];
-			if(phy_dev == 0)
-				continue;
-
-            phy_priv = netdev_priv(phy_dev);
-
-            if (phy_priv->type == TYPE_XGMAC) continue;
-            if (phy_priv->phy.mode == PHY_MODE_XAUI) continue;
-
-           		phy_int_status = nlm_xlr_mac_mii_read(phy_priv->phy.mii_addr, phy_priv->phy.addr, 26);
-			
-            /*printk(KERN_DEBUG"[%s]: Received MDIO interrupt from mac_%d (type=%d), "
-              "phy_int_status = 0x%08x reconfiguring gmac speed \n",
-              __FUNCTION__, phy_priv->instance, phy_priv->type,
-              phy_int_status);*/
-            if (!phy_priv->instance && phy_priv->phy.serdes_addr != 0x0 
-						&& phy_priv->phy.mode & PHY_MODE_SELECTABLE) {
-				int phyaddr;
-				unsigned long mii_addr, temp;
-				int mode = PHY_MODE_RGMII;
-				if(phy_priv->phy.mode & PHY_MODE_RGMII)
-					mode = PHY_MODE_SGMII;
-
-				phyaddr = xlr_get_phy_info(phy_priv->instance, mode, &mii_addr, &temp, &temp);
-		        phy_int_status = nlm_xlr_mac_mii_read((nlm_reg_t *)mii_addr, phyaddr, 26);
-				/*ack rgmii/sgmii mac*/
-    			netlogic_write_reg((nlm_reg_t *)mii_addr, R_INTREG, 
-										0xffffffff);
-
-                /*	printk(KERN_DEBUG"[%s]: Received MDIO interrupt from mac_%d (type=%d), "
-                    "phy_int_status = 0x%08x reconfiguring gmac speed \n",
-                    __FUNCTION__, phy_priv->instance, phy_priv->type,
-                    phy_int_status);*/
-            } 
-            config_val = netlogic_read_reg(phy_priv->mmio, R_MAC_CONFIG_1);
-            netlogic_write_reg(phy_priv->mmio,R_MAC_CONFIG_1,(config_val & ~(0x35)));
-
-            if(phy_priv->phy.serdes_addr) {
-                serdes_autoconfig(phy_priv);
-            }
-            nlm_xlr_gmac_config_speed(phy_priv);
-            netlogic_write_reg(phy_priv->mmio,R_MAC_CONFIG_1,config_val);
-        }
-    } else {
-        printk("[%s]: mac type = %d, instance %d error "
-                "interrupt: INTREG = 0x%08x\n", 
-                __FUNCTION__, priv->type, priv->instance, intreg);
-    }
-
-    /* clear all interrupts and hope to make progress */
-    netlogic_write_reg(mmio, R_INTREG, 0xffffffff);
-    //xlr_set_counter(NETIF_INT_REG, intreg);
-
-    /* on A0 and B0, xgmac interrupts are routed only to xgs_1 irq */
-    if ( (xlr_revision_b0()) && (priv->type == TYPE_XGMAC) ) {
-        struct net_device *xgs0_dev = dev_mac_type[TYPE_XGMAC][0];
-        struct driver_data *xgs0_priv = netdev_priv(xgs0_dev);
-        nlm_reg_t *xgs0_mmio = xgs0_priv->mmio;			
-        __u32 xgs0_intreg = netlogic_read_reg(xgs0_mmio, R_INTREG);
-
-        if (xgs0_intreg) {
-            printk("[%s]: mac type = %d, instance %d error "
-                    "interrupt: INTREG = 0x%08x\n", 
-                    __FUNCTION__, xgs0_priv->type, xgs0_priv->instance, xgs0_intreg);
-
-            netlogic_write_reg(xgs0_mmio, R_INTREG, 0xffffffff);
-        }
-    }
-
-    return IRQ_HANDLED;
-}
-
-/**********************************************************************
- **********************************************************************/
-static int nlm_xlr_mac_open(struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-
-	dbg_msg("IN\n");
-
-	if (nlm_xlr_mac_fill_rxfr(dev)) {
-		return -1;
-	}
-
-	spin_lock_bh(&priv->lock);
-	if(PORT_INIT(priv->cfg_flag))
-		xlr_mac_set_rx_mode(dev);
-
-
-	if(PORT_INT_ATTACH(priv->cfg_flag)) {
-		netlogic_write_reg(priv->mmio, R_INTMASK, 
-				(1<<O_INTMASK__TxIllegal)       |
-				(((priv->instance&0x3)==0)<<O_INTMASK__MDInt)|
-				(1<<O_INTMASK__TxFetchError)    |
-				(1<<O_INTMASK__P2PSpillEcc)     |
-				(1<<O_INTMASK__TagFull)         |
-				(1<<O_INTMASK__Underrun)        |
-				(1<<O_INTMASK__Abort)
-				);
-	}
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-	if (nlm_msgring_napi) {
-		xlr_napi_ready = 1; 
-	}
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-	if(PORT_INIT(priv->cfg_flag)) {
-	/*
-	 * Configure the speed, duplex, and flow control
-	 */
-	nlm_xlr_mac_set_speed(priv, priv->speed);
-	nlm_xlr_mac_set_duplex(priv, priv->duplex, priv->flow_ctrl);
-	nlm_xlr_mac_set_enable(priv, 1);
-	}
-
-	spin_unlock_bh(&priv->lock);
-	netif_tx_start_all_queues(dev);
-
-	/* Set the timer to check for link beat. */
-	init_timer(&priv->link_timer);
-	priv->link_timer.expires = jiffies + 2 * HZ / 100;
-	priv->link_timer.data = (unsigned long)dev;
-	priv->link_timer.function = &nlm_xlr_mac_timer;
-	priv->phy_oldlinkstat = -1; /* set link state to undefined */
-	add_timer(&priv->link_timer);
-
-	return 0;
-}
-
-/**********************************************************************
- **********************************************************************/
-static int nlm_xlr_mac_close(struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	spin_lock_irq(&priv->lock);
-
-	/* There may have left over skbs in the ring as well as in free in 
-	 * they will be reused next time open is called 
-	 */
-
-	nlm_xlr_mac_set_enable(priv, 0);
-
-	del_timer_sync(&priv->link_timer);
-	netif_tx_stop_all_queues(dev);
-	xlr_inc_counter(NETIF_STOP_Q);
-	port_inc_counter(priv->instance, PORT_STOPQ);
-
-	spin_unlock_irq(&priv->lock);
-
-	return 0;
-}
-
-/**********************************************************************
- **********************************************************************/
-static void nlm_xlr_mac_timer(unsigned long data)
-{
-	struct net_device *dev = (struct net_device *)data;
-	struct driver_data *priv = netdev_priv(dev);
-	int next_tick = HZ;
-	int mii_status;
-
-	spin_lock_irq(&priv->lock);
-
-	if((priv->type == TYPE_GMAC) && (priv->phy.mode != PHY_MODE_XAUI))
-	/* read flag "Link established" (0x04) of MII status register (1) */
-	mii_status = nlm_xlr_mac_mii_read(priv->phy.mii_addr, priv->phy.addr, 1) & 0x04;
-	else
-		mii_status = 1;
-
-	if (mii_status != priv->phy_oldlinkstat) {
-		priv->phy_oldlinkstat = mii_status;
-		if (mii_status) {
-			netif_carrier_on(dev);
-			netif_tx_start_all_queues( dev);
-		} else {
-			netif_carrier_off(dev);
-		}
-	}
-
-	spin_unlock_irq(&priv->lock);
-	priv->link_timer.expires = jiffies + next_tick;
-	add_timer(&priv->link_timer);
-}
-
-/**********************************************************************
- **********************************************************************/
-static struct net_device_stats *nlm_xlr_mac_get_stats(struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	xlr_get_mac_stats(dev, &priv->stats);
-
-	/* XXX update other stats here */
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return &priv->stats;
-}
-
-/**********************************************************************
- **********************************************************************/
-static void nlm_xlr_mac_set_multicast_list(struct net_device *dev)
-{
-	/* 
-	 * Clear out entire multicast table.  We do this by nuking
-	 * the entire hash table and all the direct matches except
-	 * the first one, which is used for our station address 
-	 */
-
-	/*
-	 * Clear the filter to say we don't want any multicasts.
-	 */
-
-	if (dev->flags & IFF_ALLMULTI) {
-		/* 
-		 * Enable ALL multicasts.  Do this by inverting the 
-		 * multicast enable bit. 
-		 */
-		return;
-	}
-
-	/* 
-	 * Progam new multicast entries.  For now, only use the
-	 * perfect filter.  In the future we'll need to use the
-	 * hash filter if the perfect filter overflows
-	 */
-}
-
-
-
-/**********************************************************************
- **********************************************************************/
-static int
-nlm_xlr_mac_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	int rc = 0;
-	switch (cmd) {
-	default:
-		rc = -EOPNOTSUPP;
-		break;
-	}
-
-	return rc;
-}
-
-/**********************************************************************
- **********************************************************************/
-static void nlm_xlr_mac_tx_timeout(struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-
-	spin_lock_irq(&priv->lock);
-
-	dev->trans_start = jiffies;
-	mac_stats_add(priv->stats.tx_errors, 1);
-
-	spin_unlock_irq(&priv->lock);
-
-	netif_tx_wake_all_queues(dev);
-	xlr_inc_counter(NETIF_START_Q);
-	port_inc_counter(priv->instance, PORT_STARTQ);
-
-	printk(KERN_WARNING "%s: Transmit timed out\n", dev->name);
-}
-
-/**********************************************************************
- **********************************************************************/
-static int nlm_xlr_mac_change_mtu(struct net_device *dev, int new_mtu)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	unsigned long flags;
-
-	if ((new_mtu > 1500) || (new_mtu < 64)) {
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	dev->mtu = new_mtu;
-
-	if (netif_running(dev)) {
-		/* Disable MAC TX/RX */
-		nlm_xlr_mac_set_enable(priv, 0);
-
-		/* Flush RX FR IN */
-		/* Flush TX IN */
-		nlm_xlr_mac_set_enable(priv, 1);
-	}
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-	return 0;
-}
-
-/**********************************************************************
- **********************************************************************/
-static int nlm_xlr_mac_fill_rxfr(struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	struct sk_buff *skb = 0;
-	unsigned long msgrng_flags;
-	int i;
-	int ret = 0;
-
-	dbg_msg("\n");
-	if (!priv->init_frin_desc) return ret;
-	priv->init_frin_desc = 0;	
-
-	if(!(MSGRNG_OWN(priv->cfg_flag)))
-		return ret; 
-	
-	for (i = 0; i < priv->num_desc; i++) {
-		skb = nlm_xlr_alloc_skb();
-		if (!skb) {
-			ret = -ENOMEM;
-			break;
-		}
-
-		skb->dev = dev;
-
-#ifdef CONFIG_NLMCOMMON_HW_BUFFER_MGMT
-		if (nlm_auto_buffer_mgmt) {
-			skb_shinfo(skb)->nlm_flags = 1;
-			skb_shinfo(skb)->nlm_owner = dev;
-			skb_shinfo(skb)->nlm_refill = mac_frin_replenish_one_msg;
-		}
-#endif /* CONFIG_NLMCOMMON_HW_BUFFER_MGMT */
-
-		/* Send the free Rx desc to the MAC */
-		msgrng_access_enable(msgrng_flags);
-		mac_put_skb_back_ptr(skb);
-		if (xlr_mac_send_fr(priv, virt_to_bus(skb->data), skb->len)) {
-			dev_kfree_skb(skb);
-			printk
-				("message_send failed!, unable to send free desc to mac\n");
-			ret = -EIO;
-			break;
-		}
-		msgrng_access_disable(msgrng_flags);
-	}
-
-	for (i = 0; i < MAC_FRIN_WORK_NUM; i++)
-		atomic_set(&priv->frin_to_be_sent[i], 0);
-	return ret;
-}
-
-
-/**********************************************************************
- **********************************************************************/
-static __inline__ void *nlm_xlr_config_spill(nlm_reg_t * mmio,
-					      int reg_start_0, int reg_start_1,
-					      int reg_size, int size)
-{
-	__u32 spill_size = CACHELINE_ALIGNED_ADDR(size);
-	void *spill = cacheline_aligned_kmalloc(spill_size, GFP_KERNEL);
-	__u64 phys_addr = 0;
-
-	if (!spill) {
-		panic("Unable to allocate memory for spill area!\n");
-	}
-	phys_addr = virt_to_phys(spill);
-	netlogic_write_reg(mmio, reg_start_0, (phys_addr >> 5) & 0xffffffff);
-	netlogic_write_reg(mmio, reg_start_1, (phys_addr >> 37) & 0x07);
-	netlogic_write_reg(mmio, reg_size, spill_size);
-
-	return spill;
-}
-
-static void nlm_xlr_config_spill_area(struct driver_data *priv)
-{
-	int max_frin_spill    = 0;
-	int max_frout_spill   = 0;
-	int max_class_0_spill = 0;
-	int max_class_1_spill = 0;
-	int max_class_2_spill = 0;
-	int max_class_3_spill = 0;
-
-	if(!priv->num_desc || !priv->spill_init)
-		return;
-
-	if(!(MSGRNG_OWN(priv->cfg_flag)))
-		return;
-
-	max_frin_threshold = (priv->num_desc/NR_CPUS);
-	if(max_frin_threshold)
-			max_frin_threshold -= 1;
-
-
-	/* 
-	 * This is new approach to set up spill sizes. TCP stack termination in
-	 * the NAPI mode requires spill area for FreeOut's of considerable size.
-	 * We set frout spill here always to 15K descriptors which traslates into
-	 * 15K * 8 bytes kernel memory alloc.
-	*/
-	max_frin_spill = priv->num_desc << 2;
-	max_frout_spill = XLR_FROUT_JUMBO_SPILL; /* 15K  */
-	max_class_0_spill = priv->num_desc;
-	max_class_1_spill = priv->num_desc;
-	max_class_2_spill = priv->num_desc;
-	max_class_3_spill = priv->num_desc;
-
-	priv->frin_spill =
-		nlm_xlr_config_spill(priv->mmio,
-				      R_REG_FRIN_SPILL_MEM_START_0,
-				      R_REG_FRIN_SPILL_MEM_START_1,
-				      R_REG_FRIN_SPILL_MEM_SIZE,
-				      max_frin_spill *
-				      sizeof(struct fr_desc));
-
-	priv->class_0_spill =
-		nlm_xlr_config_spill(priv->mmio,
-				      R_CLASS0_SPILL_MEM_START_0,
-				      R_CLASS0_SPILL_MEM_START_1,
-				      R_CLASS0_SPILL_MEM_SIZE,
-				      max_class_0_spill *
-				      sizeof(union rx_tx_desc));
-	priv->class_1_spill =
-		nlm_xlr_config_spill(priv->mmio,
-				      R_CLASS1_SPILL_MEM_START_0,
-				      R_CLASS1_SPILL_MEM_START_1,
-				      R_CLASS1_SPILL_MEM_SIZE,
-				      max_class_1_spill *
-				      sizeof(union rx_tx_desc));
-
-	priv->frout_spill =
-		nlm_xlr_config_spill(priv->mmio, R_FROUT_SPILL_MEM_START_0,
-				      R_FROUT_SPILL_MEM_START_1,
-				      R_FROUT_SPILL_MEM_SIZE,
-				      max_frout_spill *
-				      sizeof(struct fr_desc));
-
-	priv->class_2_spill =
-		nlm_xlr_config_spill(priv->mmio,
-				      R_CLASS2_SPILL_MEM_START_0,
-				      R_CLASS2_SPILL_MEM_START_1,
-				      R_CLASS2_SPILL_MEM_SIZE,
-				      max_class_2_spill *
-				      sizeof(union rx_tx_desc));
-	priv->class_3_spill =
-		nlm_xlr_config_spill(priv->mmio,
-				      R_CLASS3_SPILL_MEM_START_0,
-				      R_CLASS3_SPILL_MEM_START_1,
-				      R_CLASS3_SPILL_MEM_SIZE,
-				      max_class_3_spill *
-				      sizeof(union rx_tx_desc));
-}
-
-/*****************************************************************
- * Write the MAC address to the PHNX registers
- * All 4 addresses are the same for now
- *****************************************************************/
-static void xlr_mac_setup_hwaddr(struct driver_data *priv)
-{
-	struct net_device *dev = priv->dev;
-
-	netlogic_write_reg(priv->mmio, R_MAC_ADDR0,
-			  ((dev->dev_addr[5] << 24) | (dev->dev_addr[4] << 16)
-			   | (dev->dev_addr[3] << 8) | (dev->dev_addr[2]))
-		);
-
-	netlogic_write_reg(priv->mmio, R_MAC_ADDR0 + 1,
-			  ((dev->dev_addr[1] << 24) | (dev->
-						       dev_addr[0] << 16)));
-
-	netlogic_write_reg(priv->mmio, R_MAC_ADDR_MASK2, 0xffffffff);
-
-	netlogic_write_reg(priv->mmio, R_MAC_ADDR_MASK2 + 1, 0xffffffff);
-
-	netlogic_write_reg(priv->mmio, R_MAC_ADDR_MASK3, 0xffffffff);
-
-	netlogic_write_reg(priv->mmio, R_MAC_ADDR_MASK3 + 1, 0xffffffff);
-
-	netlogic_write_reg(priv->mmio, R_MAC_FILTER_CONFIG,
-				  (1 << O_MAC_FILTER_CONFIG__BROADCAST_EN) |
-				  (1 << O_MAC_FILTER_CONFIG__ALL_MCAST_EN) |
-				  (1 << O_MAC_FILTER_CONFIG__MAC_ADDR0_VALID)
-			);
-
-}
-
-/*****************************************************************
- * Read the MAC address from the PHNX registers
- * All 4 addresses are the same for now
- *****************************************************************/
-static void xlr_mac_get_hwaddr(struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-
-	dev->dev_addr[0] = xlr_base_mac_addr[0];
-	dev->dev_addr[1] = xlr_base_mac_addr[1];
-	dev->dev_addr[2] = xlr_base_mac_addr[2];
-	dev->dev_addr[3] = xlr_base_mac_addr[3];
-	dev->dev_addr[4] = xlr_base_mac_addr[4];
-	dev->dev_addr[5] = xlr_base_mac_addr[5] + priv->id;
-}
-
-/**********************************************************************
- * Set a new Ethernet address for the interface.
- **********************************************************************/
-static int nlm_xlr_set_mac_address(struct net_device *dev, void *addr) {
-    struct driver_data *priv = netdev_priv(dev);
-    struct sockaddr *p_sockaddr = (struct sockaddr *) addr;
-
-    memcpy(dev->dev_addr, p_sockaddr->sa_data, 6);
-    xlr_mac_setup_hwaddr(priv);
-    return 0;
-}
-
-/*****************************************************************
- * Mac Module Initialization
- *****************************************************************/
-static void mac_common_init(struct driver_data *priv)
-{
-	int i = 0, stid;
-	void (*handler)(int, int,int,int,struct msgrng_msg *, void *);
-
-
-	for (i = 0; i < MAC_FRIN_WORK_NUM; i++) {
-		if(mac_frin_replenish_work[i].func == 0) 
-			INIT_WORK(&mac_frin_replenish_work[i],
-				  mac_frin_replenish_wq);
-		if(mac_frin_replenish_task[i].func == 0)
-			tasklet_init(&mac_frin_replenish_task[i],
-				  mac_frin_replenish, 0UL);
-	}
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-	/* Cached pointer to station ID translation table, needed for NAPI */ 
-	if(is_xls())
-		rxstn_to_txstn_ptr = &xls_rxstn_to_txstn_map[0];
-	else
-		rxstn_to_txstn_ptr = &rxstn_to_txstn_map[0];
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-
-	if(priv->type == TYPE_GMAC) {
-		if (is_xls()) {
-			if(priv->instance <  NETLOGIC_GMAC_PORTS_PER_CTRL)
-				stid = TX_STN_GMAC0;
-			else
-				stid = TX_STN_GMAC1;
-		} else
-			stid = TX_STN_GMAC;
-	} else if(priv->type == TYPE_XGMAC) {
-		if(priv->instance == 0)
-			stid = TX_STN_XGS_0;
-		else
-			stid = TX_STN_XGS_1;
-	} else {
-		printk("Invalid type %d\n", priv->type);
-		return;
-	}
-
-	if((MSGRNG_OWN(priv->cfg_flag))) 
-		handler = nlm_xlr_mac_msgring_handler;
-	else 
-		handler = nlm_xlr_station_unowned_msgring_handler;
-
-	if (register_msgring_handler(stid, handler, NULL))
-			panic("Couldn't register msgring handler for TX_STN_GMAC0\n");
-
-	return;
-}
-
-
-
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-/*
- * Function covering only gmac/xgmac NAPI statistics
-*/
-static int
-xlr_napi_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data)
-{
-	int len = 0;
-	off_t begin = 0;
-	int cpu = 0;
-
-
-	if (nlm_msgring_napi) 
-        {
-		len += sprintf(page + len, "NAPI Poll Weight=%u\n",
-			       napi_weight);
-		len += sprintf(page + len, "         CPU          RX_COUNT\n");
-
-		for (cpu = 0; cpu < NR_CPUS; cpu++) {
-			if (!cpu_isset(cpu, cpu_online_map)) {
-				continue;
-			}
-			len += sprintf(page + len, "napi: cpu=%02d: %16lld\n", cpu, 
-								per_cpu(xlr_napi_rx_count, cpu));
-
-			if (!proc_pos_check(&begin, &len, off, count))
-				goto out;			 
-		}      
-
-		/* Clear on read */
-		for (cpu = 0; cpu < NR_CPUS; cpu++) {
-			per_cpu(xlr_napi_rx_count, cpu) = 0; 
-		}
-	}
-	*eof = 1;
-
-out:
-	*start = page + (off - begin);
-	len -= (off - begin);
-	if (len > count)
-		len = count;
-	if (len < 0)
-		len = 0;
-
-	return len;	
-}
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-static int __init
-nlm_napi_poll_weight(char *str)
-{
-	unsigned int wt = simple_strtoul(str, 0, 10);
-	if(wt < 1200) {
-		napi_weight = wt;
-	}
-	return 0;
-}
-
-early_param("nlm_napi_poll_weight", nlm_napi_poll_weight);
-
-static int
-xlr_mac_proc_read(char *page, char **start, off_t off,
-			     int count, int *eof, void *data)
-{
-	int len = 0;
-	off_t begin = 0;
-	int i = 0, cpu = 0;
-	struct net_device *dev = 0;
-	struct driver_data *priv = 0;
-
-
-	for(i=0; i<NETLOGIC_MAX_MACS; i++) {
-		dev = dev_mac[i];
-		if(dev == 0)
-			continue;
-
-		priv = netdev_priv(dev);
-		
-		for(cpu=0;cpu<32;cpu++) {
-		
-                        if (!cpu_isset(cpu, cpu_online_map))
-                          continue;
-		
-			len += sprintf(page + len, "per_cpu: %d %d %d %d %lx %lx %lx %lx\n", 
-				       i, cpu,
-				       user_mac ? user_mac->time.hi : user_mac_krnl_data.time.hi,
-				       user_mac ? user_mac->time.lo : user_mac_krnl_data.time.lo,
-				       priv->cpu_stats[cpu].tx_packets,
-				       priv->cpu_stats[cpu].txc_packets,
-				       priv->cpu_stats[cpu].rx_packets,
-				       priv->cpu_stats[cpu].interrupts);
-			if (!proc_pos_check(&begin, &len, off, count))
-				goto out;			       
-		}
-
-		len += sprintf(page + len,
-			       "per_port: %d %d %d %lx %lx %lx %lx\n",
-			       i,
-			       user_mac ? user_mac->time.hi : user_mac_krnl_data.time.hi,
-			       user_mac ? user_mac->time.lo : user_mac_krnl_data.time.lo,
-			       priv->stats.rx_packets, priv->stats.rx_bytes,
-			       priv->stats.tx_packets, priv->stats.tx_bytes);
-		if (!proc_pos_check(&begin, &len, off, count))
-			goto out;	     
-	}
-
-	*eof = 1;
-
-      out:
-	*start = page + (off - begin);
-	len -= (off - begin);
-	if (len > count)
-		len = count;
-	if (len < 0)
-		len = 0;
-
-	return len;	
-}
-
-
-
-#ifdef CONFIG_NLMCOMMON_HW_BUFFER_MGMT
-/*
- * Setup for XLR/XLS automatic hardware buffer management. 
-*/
-static int __init
-nlm_auto_buffer_mgmt_setup(char *str)
-{
-	if (str == NULL || !strcmp(str, "yes") || !strcmp(str, "y")) {
-		nlm_auto_buffer_mgmt = 1;
-		printk(KERN_ALERT "Enabling automatic hardware buffer management\n");
-	}
-	else if (!strcmp(str, "no") || !strcmp(str, "n")) {
-		nlm_auto_buffer_mgmt = 0;
-		printk(KERN_ALERT "Disabling automatic hardware buffer management\n");
-	}
-
-	return 0;
-}
-
-/* for compatibility we use "xlr_" prefix for the option */
-early_param("xlr_auto_buffer_mgmt", nlm_auto_buffer_mgmt_setup);
-#endif /* CONFIG_NLMCOMMON_HW_BUFFER_MGMT */
-
-
-
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-/*
- * This function is used upon the exit from NAPI poll to re-enable interrupts
-*/
-static void
-xlr_napi_enable_ints(void)
-{
-	unsigned int msgring_config;
-	unsigned long flags = 0, mflags = 0; 
-	struct napi_control_s *p = &napi_control[netlogic_cpu_id()];
-	unsigned long rcv_bmask; 
-	unsigned long this_thread_bmask = (1 << netlogic_thr_id());
-
-
-	msgrng_access_save(&p->xlr_napi_msgrng_lock, flags, mflags);
-	p->netrx_mask |= this_thread_bmask;
-
-
-	/* Read message ring status */
-	rcv_bmask = (~(msgrng_read_status() >> 24)) & 0xff;
-	rcv_bmask = ((rcv_bmask & 0xf) | (rcv_bmask >> 4));
-
-	rcv_bmask &= p->netrx_mask; 
-
-	if (rcv_bmask) {
-		/* rewrite the interrupt mask */
-		msgring_config = msgrng_read_config();
-		msgring_config |= (rcv_bmask << 8);
-		msgrng_write_config(msgring_config); 
-	}
-	else {
-
-		/* rewrite the interrupt mask */
-		msgring_config = msgrng_read_config();
-		msgring_config |= (this_thread_bmask << 8);
-		msgrng_write_config(msgring_config); 
-	}
-	msgrng_access_restore(&p->xlr_napi_msgrng_lock, flags, mflags);
-}
-
-
-/* called from msgring_process_rx_msgs() from on_chip.c  */
-void
-xlr_napi_rx_schedule(void)
-{
-	unsigned int msgring_config;
-	unsigned long flags = 0, mflags = 0; 
-	struct napi_struct *napi;
-	unsigned long rcv_bmask; // bit array: bmask[i] is 1 iff bucket[i] or bucket[i + 4] non-empty 
-	unsigned long this_thread_bmask; // non-zero if THIS thread has packets in its buckets
-	struct napi_control_s *p = &napi_control[netlogic_cpu_id()];
-
-	if (!xlr_napi_ready)
-		return;
-
-	/* rewrite the interrupt mask */
-	msgrng_access_save(&p->xlr_napi_msgrng_lock, flags, mflags);
-
-	/* Read message ring status */
-	rcv_bmask = (~(msgrng_read_status() >> 24)) & 0xff;
-	rcv_bmask = ((rcv_bmask & 0xf) | (rcv_bmask >> 4));
-
-	if (rcv_bmask == 0) {
-		msgrng_access_restore(&p->xlr_napi_msgrng_lock, flags, mflags);
-		write_64bit_cp0_eirr(1ULL << IRQ_MSGRING);
-		return;
-	}
-
-	this_thread_bmask = rcv_bmask & (1 << netlogic_thr_id());
-	p->netrx_mask &= ~this_thread_bmask;
-	rcv_bmask = rcv_bmask & p->netrx_mask; // & ~(1 << netlogic_thr_id());
-
-	msgring_config = msgrng_read_config();
-	msgring_config = (msgring_config & 0xfffff0ff) | (rcv_bmask << 8) ;
-
-	msgrng_write_config(msgring_config);
-
-	msgrng_access_restore(&p->xlr_napi_msgrng_lock, flags, mflags);
-  
-	/* Acknowledge interrupt in eirr */
-	write_64bit_cp0_eirr(1ULL << IRQ_MSGRING);
-
-	if (this_thread_bmask) {
-		/* schedule polling for this cpu using dummy_dev */
-		napi = &__get_cpu_var(xlr_napi_poll_struct);
-		napi_schedule(napi);
-	}
-}
-
-
-/*
- * Main NAPI poll loop
-*/
-int
-xlr_napi_poll(struct napi_struct *napi, int budget)
-{
-	int rx_pkts = 0;
-	xlr_napi_poll_upper(&xlr_napi_dummy_dev, budget);
-	rx_pkts = napi_poll_lower(&xlr_napi_dummy_dev, budget);
-
-	if(rx_pkts < budget)
-	{
-		napi_complete(napi);
-		/* enable message ring interrupts */
-		xlr_napi_enable_ints();
-	}
-	return rx_pkts;
-}
-
-
-/*
- * Setup for XLR/XLS msgring NAPI parameter. 
-*/
-static int __init
-nlm_msgring_napi_setup(char *str)
-{
-	if (str == NULL || !strcmp(str, "yes") || !strcmp(str, "y")) {
-		nlm_msgring_napi = 1;
-		nlm_on_chip_napi = 1;
-	}
-	else if (!strcmp(str, "no") || !strcmp(str, "n")) {
-		nlm_msgring_napi = 0;
-		nlm_on_chip_napi = 0;
-	}
-
-	return 0;
-}
-
-/* for compatibility we use "xlr_" prefix for the option */
-early_param("xlr_msgring_napi", nlm_msgring_napi_setup);
-
-
-/*
- * Setup for XLR/XLS msgring NAPI parameter. 
-*/
-static int __init
-nlm_deprecated_napi_setup(char *str)
-{
-	if (str == NULL || !strcmp(str, "yes") || !strcmp(str, "y")) {
-		nlm_msgring_napi = 1;
-		nlm_on_chip_napi = 1;
-	}
-	return 0;
-}
-
-/* Deprecated setup option for NAPI */
-early_param("xlr_napi", nlm_deprecated_napi_setup);
-
-
-
-/*
- * NAPI setup for non-networking on-chip devices. 
-*/
-static int __init
-nlm_on_chip_napi_setup(char *str)
-{
-	if (str == NULL || !strcmp(str, "yes") || !strcmp(str, "y")) {
-		if (nlm_msgring_napi == 0) {
-			printk("MSGRING_NAPI:*****************************************************************\n");
-			printk("MSGRING_NAPI:  Can't enable on_chip NAPI: enable xlr_msgring_napi first      *\n");
-			printk("MSGRING_NAPI:*****************************************************************\n");
-			nlm_on_chip_napi = 0;
-		} else {
-			nlm_on_chip_napi = 1;
-		}
-	}
-	else if (!strcmp(str, "no") || !strcmp(str, "n")) {
-		nlm_on_chip_napi = 0;
-	}
-
-	return 0;
-}
-
-/* for compatibility we use "xlr_" prefix for the option */
-early_param("xlr_on_chip_napi", nlm_on_chip_napi_setup);
-
-
-
-/*
- * Setup XLR/XLS NAPI subsystem 
-*/
-static int
-nlm_xlr_napi_setup(void)
-{
-	int i, cpu_count; 
-	struct napi_struct *napi; 
-	int weight_p = napi_weight; 
-
-	/* napi required msgring interrupt to be enabled, 
-	 * but it can be enabled only if both gmac and xgmac/spi4
-	 * are owned by linux 
-         */
-	if (xlr_hybrid_user_mac_xgmac())
-		return 0;
-
-	printk("MSGRING_NAPI: Initializing RMI GMAC/XGMAC NAPI subsystem\n");
-
-	msgring_int_type = 0x01;
-
-	atomic_set(&(xlr_napi_dummy_dev.refcnt), 1);
-	set_bit(__LINK_STATE_START, &xlr_napi_dummy_dev.state);
-
-	for (cpu_count = 0; cpu_count < NR_CPUS; cpu_count++) 
-	{
-		napi = &per_cpu(xlr_napi_poll_struct, cpu_count);
-		memset(napi, 0, sizeof(napi));
-		netif_napi_add(&xlr_napi_dummy_dev, napi, xlr_napi_poll, weight_p);
-		napi_enable(napi);
-	}
-
-	for (i = 0; i < NR_CPUS; i++) {
-		per_cpu(xlr_napi_rx_count, i) = 0; 
-	}
-
-	return 0;
-}
-
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-
-
-
-static int xlr_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	int mii_status;
-
-	if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI)){
-		cmd->supported = SUPPORTED_FIBRE|SUPPORTED_10000baseT_Full;
-		cmd->advertising = SUPPORTED_FIBRE|SUPPORTED_10000baseT_Full;
-		cmd->speed = SPEED_10000;
-		cmd->port = PORT_FIBRE;
-		cmd->duplex = DUPLEX_FULL;
-		cmd->phy_address = priv->instance;
-		cmd->autoneg = AUTONEG_DISABLE;
-		cmd->maxtxpkt = 0;
-		cmd->maxrxpkt = 0;
-
-	}else{
-
-		cmd->supported = SUPPORTED_10baseT_Full | 
-			SUPPORTED_10baseT_Half | 
-			SUPPORTED_100baseT_Full | SUPPORTED_100baseT_Half |
-			SUPPORTED_1000baseT_Full | SUPPORTED_MII |
-			SUPPORTED_Autoneg | SUPPORTED_TP;
-
-		cmd->advertising = priv->advertising;
-
-		mii_status = nlm_xlr_mac_mii_read(priv->phy.mii_addr, priv->phy.addr, MII_NCONFIG);
-		priv->speed = (mii_status >> 3) & 0x03;
-
-		cmd->speed = (priv->speed == xlr_mac_speed_1000) ? SPEED_1000 :
-		(priv->speed == xlr_mac_speed_100) ? SPEED_100: SPEED_10;
-
-		cmd->duplex = (mii_status >> 5) & 0x1;
-		cmd->port = PORT_TP;
-		cmd->phy_address = priv->instance;
-		cmd->transceiver = XCVR_INTERNAL;
-		cmd->autoneg = (~(mii_status >> 14)) & 0x1;
-		cmd->maxtxpkt = 0;
-		cmd->maxrxpkt = 0;
-	}
-
-	return 0;
-}
-static int xlr_enable_autoneg(struct net_device *dev, u32 adv)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	int mii_status;
-	u32 adv1, adv2;
-    unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	nlm_xlr_mac_set_enable(priv, 0);
-	/* advertising for 10/100 Mbps */
-	adv1 = nlm_xlr_mac_mii_read(priv->phy.mii_addr, priv->phy.addr, MII_ADVERTISE);
-	adv1 &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
-	/* advertising for 1000 Mbps */
-	adv2 = nlm_xlr_mac_mii_read(priv->phy.mii_addr, priv->phy.addr, 0x9);
-	adv2 &= ~(0x300);
-
-	if(adv & ADVERTISED_10baseT_Half)
-		adv1 |= ADVERTISE_10HALF;
-	if(adv & ADVERTISED_10baseT_Full)
-		adv1 |= ADVERTISE_10FULL;
-	if(adv & ADVERTISED_100baseT_Full)
-		adv1 |= ADVERTISE_100FULL;
-	if(adv & ADVERTISED_100baseT_Half)
-		adv1 |= ADVERTISE_100HALF;
-
-	if(adv & ADVERTISED_1000baseT_Full)
-		adv2 |= 0x200;
-	if(adv & ADVERTISED_1000baseT_Half)
-		adv2 |= 0x100;
-
-	/* Set the advertising parameters */
-	nlm_xlr_mac_mii_write(priv->phy.mii_addr, priv->phy.addr, MII_ADVERTISE, adv1);
-	nlm_xlr_mac_mii_write(priv->phy.mii_addr, priv->phy.addr, 0x9, adv2);
-
-	priv->advertising = adv1 | adv2;
-
-	mii_status = nlm_xlr_mac_mii_read(priv->phy.mii_addr, priv->phy.addr, MII_BMCR);
-	/* enable autoneg and force restart autoneg */
-	mii_status |= (BMCR_ANENABLE | BMCR_ANRESTART);
-	nlm_xlr_mac_mii_write(priv->phy.mii_addr, priv->phy.addr, MII_BMCR, mii_status);
-
-	nlm_xlr_mac_set_enable(priv, 1);
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-
-static int xlr_set_link_speed(struct net_device *dev, int speed, int duplex)
-{
-	u32 adv;
-	int ret =0;
-
-	switch(speed) {
-		case SPEED_10:
-			if ( duplex == DUPLEX_FULL )
-				adv = ADVERTISED_10baseT_Full;
-			else
-				adv = ADVERTISED_10baseT_Half;
-			break;
-		case SPEED_100:
-			if ( duplex == DUPLEX_FULL )
-				adv = ADVERTISED_100baseT_Full;
-			else
-				adv = ADVERTISED_100baseT_Half;
-			break;
-		case SPEED_1000:
-			if ( duplex == DUPLEX_FULL )
-				adv = ADVERTISED_1000baseT_Full;
-			else
-				adv = ADVERTISED_1000baseT_Half;
-			break;
-		default:
-			ret = -EINVAL;
-			return ret;
-	}
-	ret = xlr_enable_autoneg( dev,adv);
-	return ret;
-
-}
-
-static int xlr_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	int ret;
-	struct driver_data *priv = netdev_priv(dev);
-
-	if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI)){
-		return -EIO;
-	}
-	if (cmd->autoneg == AUTONEG_ENABLE) {
-		ret = xlr_enable_autoneg(dev, cmd->advertising);
-	}else {
-		ret = xlr_set_link_speed(dev, cmd->speed, cmd->duplex);
-	}
-	return ret;
-}
-
-static void xlr_get_drvinfo(struct net_device *dev, 
-				struct ethtool_drvinfo *info)
-{
-	strcpy(info->driver, DRV_NAME);
-	strcpy(info->version, DRV_VERSION);
-}
-
-static int xlr_get_regs_len(struct net_device *dev) 
-{
-	return NLM_ETHTOOL_REG_LEN;
-}
-static void xlr_get_regs(struct net_device *dev,
-				struct ethtool_regs *regs, void *p)
-{
-	u32 *data = (u32 *)p;
-	int i;
-	struct driver_data *priv = netdev_priv(dev);
-	unsigned long flags;
-
-	memset((void *)data, 0, NLM_ETHTOOL_REG_LEN);
-
-	spin_lock_irqsave(&priv->lock, flags);
-	for(i=0; i <= NLM_NUM_REG_DUMP; i++)
-		*(data + i) = netlogic_read_reg(priv->mmio,  R_TX_CONTROL + i);
-	spin_unlock_irqrestore(&priv->lock, flags);
-}
-static u32 xlr_get_msglevel(struct net_device *dev)
-{
-	return mac_debug;
-}
-static void xlr_set_msglevel(struct net_device *dev, u32 value)
-{
-	mac_debug = value;
-}
-
-static int xlr_nway_reset(struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	int mii_status;
-	unsigned long flags;
-	int ret = -EINVAL;
-
-   if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI))
-    return -EIO;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	mii_status = nlm_xlr_mac_mii_read(priv->phy.mii_addr, priv->phy.addr, MII_BMCR);
-	if(mii_status & BMCR_ANENABLE)
-	{
-		nlm_xlr_mac_mii_write(priv->phy.mii_addr, priv->phy.addr, 
-				MII_BMCR, BMCR_ANRESTART | mii_status);
-		ret = 0;
-	}
-	spin_unlock_irqrestore(&priv->lock, flags);
-	return ret;
-}
-static u32 xlr_get_link(struct net_device *dev)
-{
-	struct driver_data *priv = netdev_priv(dev);
-	int mii_status;
-	unsigned long flags;
-
-   if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI))
-    return -EIO;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	mii_status = nlm_xlr_mac_mii_read(priv->phy.mii_addr, priv->phy.addr, MII_BMSR);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	if(mii_status & BMSR_LSTATUS)
-		return 1;
-	return 0;
-}
-#define NLM_STATS_KEY_LEN  \
-		(sizeof(struct net_device_stats) / sizeof(unsigned long))
-static struct {
-	        const char string[ETH_GSTRING_LEN];
-} xlr_ethtool_stats_keys[NLM_STATS_KEY_LEN] = {
-	{ "rx_packets" },
-	{ "tx_packets" },
-	{ "rx_bytes" },
-	{ "tx_bytes" },
-	{ "rx_errors" },
-	{ "tx_errors" },
-	{ "rx_dropped" },
-	{ "tx_dropped" },
-	{ "multicast" },
-	{ "collisions" },
-	{ "rx_length_errors" },
-	{ "rx_over_errors" },
-	{ "rx_crc_errors" },
-	{ "rx_frame_errors" },
-	{ "rx_fifo_errors" },
-	{ "rx_missed_errors" },
-	{ "tx_aborted_errors" },
-	{ "tx_carrier_errors" },
-	{ "tx_fifo_errors" },
-	{ "tx_heartbeat_errors" },
-	{ "tx_window_errors" },
-	{ "rx_compressed" },
-	{ "tx_compressed" }
-};
-static int xlr_get_stats_count (struct net_device *dev)
-{
-	return NLM_STATS_KEY_LEN;
-}
-
-static void xlr_get_strings (struct net_device *dev, u32 stringset, u8 *buf)
-{
-	switch (stringset) {
-	case ETH_SS_STATS:
-		memcpy(buf, &xlr_ethtool_stats_keys, 
-				sizeof(xlr_ethtool_stats_keys));
-		break;
-	default:
-		printk(KERN_WARNING "%s: Invalid stringset %d\n", 
-				__FUNCTION__, stringset);
-		break;
-	}
-}
-
-static void xlr_get_mac_stats(struct net_device *dev, 
-					struct net_device_stats *stats)
-{
-	struct driver_data *priv = netdev_priv(dev);
-
-	stats->tx_errors = netlogic_read_reg(priv->mmio, TX_FCS_ERROR_COUNTER);
-	stats->rx_dropped = netlogic_read_reg(priv->mmio, 
-						RX_DROP_PACKET_COUNTER);
-	stats->tx_dropped = netlogic_read_reg(priv->mmio, TX_DROP_FRAME_COUNTER);
-
-	stats->multicast = netlogic_read_reg(priv->mmio, 
-						RX_MULTICAST_PACKET_COUNTER);
-	stats->collisions = netlogic_read_reg(priv->mmio, 
-						TX_TOTAL_COLLISION_COUNTER);
-
-	stats->rx_length_errors = netlogic_read_reg(priv->mmio, 
-						RX_FRAME_LENGTH_ERROR_COUNTER);
-	stats->rx_over_errors = netlogic_read_reg(priv->mmio, 
-						RX_DROP_PACKET_COUNTER);
-	stats->rx_crc_errors = netlogic_read_reg(priv->mmio, 
-						RX_FCS_ERROR_COUNTER);
-	stats->rx_frame_errors = netlogic_read_reg(priv->mmio, 
-						RX_ALIGNMENT_ERROR_COUNTER);
-
-	stats->rx_fifo_errors = netlogic_read_reg(priv->mmio,
-					    	RX_DROP_PACKET_COUNTER);
-	stats->rx_missed_errors = netlogic_read_reg(priv->mmio,
-					    	RX_CARRIER_SENSE_ERROR_COUNTER);
-
-	stats->rx_errors = (stats->rx_over_errors + stats->rx_crc_errors +
-			     stats->rx_frame_errors + stats->rx_fifo_errors +
-			     stats->rx_missed_errors);
-
-	stats->tx_aborted_errors = netlogic_read_reg(priv->mmio, 
-			TX_EXCESSIVE_COLLISION_PACKET_COUNTER);
-	stats->tx_carrier_errors = netlogic_read_reg(priv->mmio, 
-					TX_DROP_FRAME_COUNTER);
-	stats->tx_fifo_errors = netlogic_read_reg(priv->mmio, 
-					TX_DROP_FRAME_COUNTER);
-
-}
-
-static void xlr_get_ethtool_stats (struct net_device *dev,
-			struct ethtool_stats *estats, u64 *stats)
-{
-	int i;
-	struct driver_data *priv = netdev_priv(dev);
-	unsigned long flags;
-	unsigned long *tmp_stats;
-	
-	spin_lock_irqsave(&priv->lock, flags);
-	
-	xlr_get_mac_stats(dev, &priv->stats);
-	
-	
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	tmp_stats = (unsigned long *)&priv->stats;
-	for(i=0; i < NLM_STATS_KEY_LEN; i++) {
-		*stats = (u64)*tmp_stats;
-		stats++;
-		tmp_stats++;
-	}
-}
-
-static struct ethtool_ops xlr_ethtool_ops= {
-        .get_settings           = xlr_get_settings,
-        .set_settings           = xlr_set_settings,
-        .get_drvinfo            = xlr_get_drvinfo,
-        .get_regs_len           = xlr_get_regs_len,
-        .get_regs               = xlr_get_regs,
-        .get_msglevel           = xlr_get_msglevel,
-        .set_msglevel           = xlr_set_msglevel,
-        .nway_reset             = xlr_nway_reset,
-        .get_link               = xlr_get_link,
-        .get_strings            = xlr_get_strings,
-        .get_stats_count        = xlr_get_stats_count,
-        .get_ethtool_stats      = xlr_get_ethtool_stats,
-};
-
-void nlm_reset_gmac(nlm_reg_t *mmio)
-{
-    volatile uint32_t val;
-
-        /* Disable MAC RX */
-        val = netlogic_read_reg(mmio, R_MAC_CONFIG_1);
-        val &= ~0x4;
-        netlogic_write_reg(mmio, R_MAC_CONFIG_1, val);
-
-        /* Disable Core RX */
-        val = netlogic_read_reg(mmio, R_RX_CONTROL);
-        val &= ~0x1;
-        netlogic_write_reg(mmio, R_RX_CONTROL, val);
-
-        /* wait for rx to halt */
-        while(1) {
-            val = netlogic_read_reg(mmio, R_RX_CONTROL);
-            if(val & 0x2)
-                break;
-            mdelay(1);
-        }
-
-        /* Issue a soft reset */
-        val = netlogic_read_reg(mmio, R_RX_CONTROL);
-        val |= 0x4;
-        netlogic_write_reg(mmio, R_RX_CONTROL, val);
-           
-        /* wait for reset to complete */
-        while(1) {
-            val = netlogic_read_reg(mmio, R_RX_CONTROL);
-            if(val & 0x8)
-                break;
-            mdelay(1);
-        }
-
-        /* Clear the soft reset bit */
-        val = netlogic_read_reg(mmio, R_RX_CONTROL);
-        val &= ~0x4;
-        netlogic_write_reg(mmio, R_RX_CONTROL, val);
-}
-
-void nlm_reset_xaui(nlm_reg_t *mmio)
-{
-    volatile uint32_t val;
-
-    /* Disable Core RX */
-    val = netlogic_read_reg(mmio, R_RX_CONTROL);
-    val &= ~0x1;
-    netlogic_write_reg(mmio, R_RX_CONTROL, val);
-
-    /* wait for rx to halt */
-    while(1) {
-        val = netlogic_read_reg(mmio, R_RX_CONTROL);
-        if(val & 0x2)
-            break;
-        mdelay(1);
-    }
-
-    /* Issue a soft reset */
-    val = netlogic_read_reg(mmio, R_RX_CONTROL);
-    val |= 0x4;
-    netlogic_write_reg(mmio, R_RX_CONTROL, val);
-
-    /* wait for reset to complete */
-    while(1) {
-        val = netlogic_read_reg(mmio, R_RX_CONTROL);
-        if(val & 0x8)
-            break;
-        mdelay(1);
-    }
-
-    /* Clear the soft reset bit */
-    val = netlogic_read_reg(mmio, R_RX_CONTROL);
-    val &= ~0x4;
-    netlogic_write_reg(mmio, R_RX_CONTROL, val);
-}
-
-u16  nlm_select_tx_queue(struct net_device *dev, struct sk_buff *skb)
-{
-	return (u16)smp_processor_id();
-}
-
-
-static void setup_net_ops(struct net_device_ops *mac_ops)
-{
-	mac_ops->ndo_open = nlm_xlr_mac_open;
-	mac_ops->ndo_stop = nlm_xlr_mac_close;
-	mac_ops->ndo_get_stats = nlm_xlr_mac_get_stats;
-	mac_ops->ndo_set_multicast_list = nlm_xlr_mac_set_multicast_list;
-	mac_ops->ndo_set_mac_address = nlm_xlr_set_mac_address;
-	mac_ops->ndo_do_ioctl = nlm_xlr_mac_do_ioctl;
-	mac_ops->ndo_tx_timeout = nlm_xlr_mac_tx_timeout;
-	mac_ops->ndo_change_mtu = nlm_xlr_mac_change_mtu;
-	mac_ops->ndo_select_queue = nlm_select_tx_queue;
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-	if (nlm_msgring_napi) {
-		mac_ops->ndo_start_xmit = nlm_xlr_napi_mac_xmit;
-	}
-	else {
-		mac_ops->ndo_start_xmit = nlm_xlr_mac_xmit;
-	}
-#else
-	mac_ops->ndo_start_xmit = nlm_xlr_mac_xmit;
-
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-}
-
-int nlm_xlr_mac_init_module(void)
-{
-	struct net_device *dev = 0;
-	struct driver_data *priv = 0;
-	unsigned long mmio_start = 0;
-	int i = 0, num_desc = 0, num_desc_total = 0;
-	int ret = 0, port_type;
-	struct proc_dir_entry *entry;
-	struct port_cfg *port_cfg;
-	extern struct net_device_cfg xlr_net_dev_cfg;
-	struct net_device_cfg *net_cfg = &xlr_net_dev_cfg;
-    int port_xaui = 0;
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-
-	/* Run NAPI compatibility test */
-	if (!nlm_napi_compatibility_check()) {
-		nlm_msgring_napi = 0;
-		nlm_on_chip_napi = 0;
-	}
-
-	if (nlm_msgring_napi) {
-		nlm_xlr_napi_setup();
-	}
-	else {
-		printk("MSGRING_NAPI: NAPI is not enabled!\n");
-	}
-
-        /* Initialize spinlock protecting NAPI msgring_config access */
-        for (i = 0; i < NR_CPUS / 4; i++) {
-		spin_lock_init(&napi_control[i].xlr_napi_msgrng_lock);
-		napi_control[i].netrx_mask = 0xf;
-        }
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-        for (i = 0; i < NETLOGIC_MAX_MACS; i++) {
-		spin_lock_init(&pending_tx_lock[i]);
-	}
-
-	chip_is_xls = is_xls();
-
-	entry = create_proc_read_entry("nlm_mac_stats", 0 /* def mode */ ,
-				       nlm_root_proc /* parent */ ,
-				       xlr_mac_proc_read
-				       /* proc read function */ ,
-				       0	/* no client data */
-		);
-	if (!entry) {
-		printk("[%s]: Unable to create proc read entry for xlr_mac!\n",
-		       __FUNCTION__);
-	}	
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-	if (nlm_msgring_napi) {
-		entry = create_proc_read_entry("nlm_napi_stats", 0 /* def mode */ ,
-					       nlm_root_proc /* parent */ ,
-					       xlr_napi_proc_read
-					       /* proc read function */ ,
-					       0 /* no client data */
-		);
-		if (!entry) {
-			printk("[%s]: Unable to create proc read entry for xlr_napi!\n",
-				__FUNCTION__);
-		}	
-	}
-#endif /* CONFIG_NLMCOMMON_MSGRING_NAPI */
-	setup_net_ops(&nlm_mac_net_ops);
-
-	for (i = 0; i < NETLOGIC_MAX_MACS; i++) {
-
-		if(i < NETLOGIC_MAX_GMACS) {
-			port_cfg = &net_cfg->gmac_port[i];
-			port_type = TYPE_GMAC;
-            port_xaui = (port_cfg->phy_mode == PHY_MODE_XAUI);
-		} else if(net_cfg->xgs_type[i - NETLOGIC_MAX_GMACS] == TYPE_XGMAC) {
-			port_cfg = &net_cfg->xgs_port[i - NETLOGIC_MAX_GMACS];
-			port_type = TYPE_XGMAC;
-		} else
-			continue;
-
-		if(port_cfg->cfg_flag == 0)
-			continue;
-
-		dbg_msg("Registering xlr_mac[%d]\n", i);
-
-		dev = alloc_etherdev_mq(sizeof(struct driver_data), 32);
-		if (!dev) {
-			ret = -ENOMEM;
-			goto out;
-		}
-
-		priv = netdev_priv(dev);
-		priv->dev = dev;
-		priv->cfg_flag = port_cfg->cfg_flag;
-
-		priv->mmio = (nlm_reg_t *) port_cfg->mmio_addr;
-		if (!priv->mmio) {
-			dbg_panic
-				("Unable to ioremap MMIO region of size %x @ %lx\n",
-				 NETLOGIC_IO_SIZE, mmio_start);
-		}
-
-		dbg_msg(" priv->mmio=%p\n",	priv->mmio);
-
-		if(port_type == TYPE_GMAC && PORT_INIT(priv->cfg_flag)) {
-            if(port_xaui)
-                nlm_reset_xaui(priv->mmio);
-            else
-                nlm_reset_gmac(priv->mmio);
-        }
-
-		/* Initialize the net_device */
-		if (PORT_INT_ATTACH(priv->cfg_flag)) {
-			dev->irq = port_cfg->irqno;
-			if (request_irq(dev->irq, nlm_xlr_mac_int_handler,
-						IRQF_DISABLED, dev->name, dev)) {
-				ret = -EBUSY;
-				panic("Couldn't get mac interrupt line (%d)", dev->irq);
-			}
-		}
-
-		ether_setup(dev);
-
-		dev->base_addr = (long)priv->mmio;
-		dev->mem_end = (long)priv->mmio + NETLOGIC_IO_SIZE - 1;
-		dev->netdev_ops = &nlm_mac_net_ops;
-
-		dev->watchdog_timeo = (1000 * HZ);
-
-		dev->features |= NETIF_F_LLTX;
-
-		SET_ETHTOOL_OPS(dev,&xlr_ethtool_ops);
-		/* Initialize the device specific driver data */
-		spin_lock_init(&priv->lock);
-
-		priv->id = i;
-		priv->instance = port_cfg->instance;
-		priv->type = port_type;
-		if(port_cfg->num_desc) {
-			num_desc = port_cfg->num_desc;
-			priv->spill_init = 1;
-		} else
-			priv->spill_init = 0;
-
-		dev->tx_queue_len = (num_desc/32) - 1;
-		priv->num_desc = num_desc;
-		priv->config_pde = port_cfg->config_pde;
-
-		num_desc_total += num_desc;
-
-		/* Caching FRF and TX station IDs */
-  		priv->fr_stid = msgrng_stid_rfr(priv->instance, priv->type);
-  		priv->tx_stid = mac_fill_tx_stid(priv->instance, priv->type);
-
-		/* fill the phy info*/
-		priv->phy.addr 	   = port_cfg->phy_addr;
-		priv->phy.mode = port_cfg->phy_mode;
-		priv->phy.mii_addr = mac_addr_to_ptr(port_cfg->mii_addr);
-		priv->phy.pcs_addr = mac_addr_to_ptr(port_cfg->pcs_addr);
-		priv->phy.serdes_addr = mac_addr_to_ptr(port_cfg->serdes_addr);
-
-
-		xlr_mac_get_hwaddr(dev);
-
-		if(PORT_INIT(priv->cfg_flag)) {
-			if (priv->type == TYPE_GMAC) {
-                if(port_xaui)
-                    nlm_xlr_xaui_init(priv, port_cfg);
-                else
-                    nlm_xlr_gmac_init(priv, port_cfg);
-            }
-			else if(priv->type == TYPE_XGMAC) 
-				nlm_xlr_xgmac_init(priv, port_cfg);
-			
-            xlr_mac_setup_hwaddr(priv);
-		}
-
-		if(PORT_ATTACH(priv->cfg_flag))  {
-			ret = register_netdev(dev);
-			if (ret) {
-				dbg_panic("Unable to register net device\n");
-			}
-			else {
-				if (priv->type == TYPE_GMAC)
-					printk("GMAC_%d initialized as %s\n", priv->instance, priv->dev->name);
-				else if (priv->type == TYPE_XGMAC)
-					printk("XGMAC_%d initialized as %s\n", priv->instance, priv->dev->name);
-			}
-		}
-
-//		if(PORT_INIT(priv->cfg_flag)) 
-//			rmik_config_pde(priv->type, priv->instance, priv->mmio);
-
-/*		if(rmik_en) {
-			uint64_t pde_bkt_map = 0ULL;
-			pde_bkt_map = rmik_get_pde_bktmap(priv->type, priv->instance);
-			priv->frstid_rsvd = ((pde_bkt_map & free_back_stid_map) == 0ULL) ? 1 : 0;
-		} else
-*/
-		priv->frstid_rsvd = 1;
-
-
-		mac_common_init(priv);
-		nlm_xlr_mac_set_enable(priv, 0);
-
-		dbg_msg("%s: Phoenix Mac at 0x%p (mtu=%d)\n",
-			dev->name, priv->mmio, dev->mtu);
-
-		dev_mac_type[priv->type][priv->instance] = dev;
-		dev_mac[i] = dev;
-	}
-/*	
-	rmik_init_replenish_work(num_desc);
-	rmik_register_net_events();
-*/
-	dbg_msg("port_counters = %p\n", port_counters);
-	dbg_msg("pending_tx_lock = %p, pending_tx = %p\n", port_counters,
-		pending_tx);
-
-
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-        /* initialize cpu skb queues */
-        cpu_tx_queue_init();
-#endif /* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
-
- out:
-        if ( (xlr_board_atx_v() || xlr_board_atx_iv_b())) {
-            /* on atx-v and atx-iv-b read rgmii interrupt at least once */
-            dev = dev_mac_type[TYPE_GMAC][0];
-            if(dev != 0) {
-                priv = netdev_priv(dev);
-                nlm_xlr_mac_mii_read(priv->phy.mii_addr, 3, 26);
-            }
-        }
- 
-	for (i = 0; i < NETLOGIC_MAX_GMACS; i++) {
-		if(dev_mac[i] == 0)
-                       continue;
-
-		priv = netdev_priv(dev_mac[i]);
-		if (PORT_INIT(priv->cfg_flag)) 
-			xlr_mac_set_rx_mode(dev_mac[i]);
-
-        if (PORT_INT_ATTACH(priv->cfg_flag)) {
-            netlogic_write_reg(priv->mmio, R_INTMASK,
-                    (1<<O_INTMASK__TxIllegal)       |
-                    (((priv->instance&0x3)==0)<<O_INTMASK__MDInt)           |
-                    (1<<O_INTMASK__TxFetchError)    |
-                    (1<<O_INTMASK__P2PSpillEcc)     |
-                    (1<<O_INTMASK__TagFull)         |
-                    (1<<O_INTMASK__Underrun)        |
-                    (1<<O_INTMASK__Abort));
-        }
-	}
-	if (ret < 0) {
-		dbg_panic("Error, ret = %d\n", ret);
-	}
-	return ret;
-}
-
-/**********************************************************************
- **********************************************************************/
-void nlm_xlr_mac_exit_module(void)
-{
-	struct net_device *dev;
-	int idx;
-
-	for (idx = 0; idx < NETLOGIC_MAX_MACS; idx++) {
-		dev = dev_mac[idx];
-		if (dev == 0)
-			continue;
-
-		unregister_netdev(dev);
-		free_netdev(dev);
-	}
-}
-#ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
-
-int nlm_macreg_set(int inf, unsigned int reg, unsigned int val)
-{
-struct driver_data *priv = NULL;
-struct net_device *dev = NULL;
- 
-    dev = dev_mac[inf];
-
-    if (!dev) 
-         return -1;
- 
-   	priv = netdev_priv(dev);
-    netlogic_write_reg(priv->mmio, reg, netlogic_read_reg(priv->mmio, reg)|val);
-    return 0;
-}
-
-u32 nlm_macreg_get(int inf, unsigned int reg)
-{
-struct driver_data *priv = NULL;
-struct net_device *dev = NULL;
- 
-    dev = dev_mac[inf];
-
-    if (!dev) 
-         return -1;
- 
-    priv = netdev_priv(dev);
-    return netlogic_read_reg(priv->mmio, reg);
-}
-
-int nlm_mac_get_inf_idx(char *infname)
-{
-int i = 0;
-struct net_device *dev = NULL;
-u32  rc = -1; 
-  for( i= 0 ; i < NETLOGIC_MAX_MACS ; i++) {
-        if(!strncmp( infname, dev[i].name, sizeof(infname))) {
-            rc = i;
-           break;
-        }
-    }
-   return rc; 
-}
-
-int nlm_macreg_clr_set(int inf, u32 reg, u32 val, u32 mask)
-{
-struct driver_data *priv = NULL;
-struct net_device *dev = NULL;
-u32 curr_val = 0;
- 
-    dev = dev_mac[inf];
-
-    if (!dev) 
-         return -1;
- 
-   	priv = netdev_priv(dev);
-    curr_val = netlogic_read_reg(priv->mmio, reg) & (~mask);
-//    printk("reg %x curval %x reg %x\n", reg, curr_val, netlogic_read_reg(priv->mmio,reg));
-//    printk("wr reg %x curval %x val %x mask %x\n", reg, curr_val| (val& mask), val , mask);
-    netlogic_write_reg(priv->mmio, reg, curr_val|(val & mask));
-    
-    //printk("reg %x rdval %x\n", reg, netlogic_read_reg(priv->mmio,reg));
-    return 0;
-}
-void nlm_macreg_set_all(u32 reg, u32 val,u32 mask)
-{
-int i = 0;
-
-    for( i = 0; i < NETLOGIC_MAX_MACS; i++) {
-        nlm_macreg_clr_set(i, reg, val, mask);        
-        //nlm_macreg_set(i, reg, val);        
-    }
-}
-void nlm_macreg_clr_set_all(u32 reg, u32 val,u32 mask)
-{
-int i = 0;
-
-    for( i = 0; i < NETLOGIC_MAX_MACS; i++) {
-        nlm_macreg_clr_set(i, reg, val, mask);        
-//        nlm_macreg_set(i, reg, val);        
-    }
-}
-void dump_all_interface(unsigned int reg)
-{
-int i = 0;
-struct net_device *dev;
-struct driver_data *priv;
-u32 curr_val = 0; 
-       
-    for( i = 0; i < NETLOGIC_MAX_MACS; i++) {
-
-        dev = dev_mac[i];
-           if (!dev) 
-                continue; 
-     	priv = netdev_priv(dev);
-        curr_val = netlogic_read_reg(priv->mmio,reg);
-//        printk("interface %x    val %x name %s\n", priv->mmio,  curr_val, dev->name); 
-    }
-
-}
-void nlm_register_ptp_ts_fp(void(*fp)(u32, u32,ktime_t *, u32))
-{
-    printk("register ptp\n");
-    p_ptp_set_ts = fp;
-}
-void nlm_clr_ptp_ts_fp(void){
-    p_ptp_set_ts = NULL;
-}
-EXPORT_SYMBOL(nlm_macreg_set_all);
-EXPORT_SYMBOL(dump_all_interface);
-EXPORT_SYMBOL(nlm_register_ptp_ts_fp);
-#endif
-module_init(nlm_xlr_mac_init_module);
-module_exit(nlm_xlr_mac_exit_module);
-
-/*************************************************************************
- * TODO:
- *     o Currently, if Tx completes do not come back, Tx hangs for ever. Though it is good
- *       for debugging, there should be a timeout mechanism.
- *     o Right now, all cpu-threads across cpus are serialized for transmitting
- *       packets. However, message_send is "atomic", hence all of them should
- *       transmit without contending for the lock. some like per-cpu, per device lock 
- *       and handling tx complete on the cpu that did the transmit
- *     o use fetchadd for stat variable. currently, it not even atomic
- *************************************************************************/
diff --git a/drivers/net/xlr_pcix_boot.c b/drivers/net/xlr_pcix_boot.c
deleted file mode 100644
index 38000c3..0000000
--- a/drivers/net/xlr_pcix_boot.c
+++ /dev/null
@@ -1,330 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef CONFIG_NLM_COMMON
-#ifndef MODULE
-#define MODULE
-#endif
-#endif
-#ifndef __KERNEL__
-#define __KERNEL__
-#endif
-
-
-#include <linux/sched.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/compiler.h>
-#include <linux/init.h>
-
-#include <linux/ioport.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/rtnetlink.h>
-#include <linux/delay.h>
-#include <linux/ethtool.h>
-#include <linux/mii.h>
-#include <asm/io.h>
-#include <linux/completion.h>
-#include <linux/crc32.h>
-
-#ifdef CONFIG_NLM_COMMON
-#include <asm/netlogic/nlm_pcix_gen_host.h>
-#include <asm/netlogic/xlr_pcix_boot.h>
-#else
-#include "nlm_pcix_gen_host.h"
-#include "xlr_pcix_boot.h"
-#endif
-
-#define Message(a,b...) //printk("\nFun [%s]\t"a"\n",__FUNCTION__,##b);
-#define ErrorMsg(a,b...) printk("\nFun [%s]\t"a"\n",__FUNCTION__,##b);
-
-#define NLM_IOCTL_DRIVER "NLM_PCIX_BOOT_DRIVER"
-#define NLM_IMAGE_BUFF_LEN 1024
-static struct net_device_ops nlm_boot_net_ops;
-
-extern unsigned long nlm_common_get_shared_mem_base_host(void);
-static struct net_device *ndev;
-
-extern void nlm_common_pci_writeb(unsigned char data, void *addr);
-extern void nlm_common_pci_writel(unsigned int  data,unsigned int *addr);
-struct priv
-{
-				struct net_device *dev;
-				struct net_device_stats stats;
-				int port;
-				u32 nlm_common_tx_producer;
-				u32 nlm_common_pending_tx;
-				u32 nlm_common_rx_consumer;
-};
-
-static int kimage_nlm_common_open(struct net_device *);
-static int kimage_nlm_common_close(struct net_device *);
-
-static int nlm_ioctl_nlm_common_probe(void);
-static void nlm_nlm_common_remove(void);
-
-
-static int nlm_nlm_common_pcix_init(void);
-static void nlm_nlm_common_pcix_uninit(void);
-
-static unsigned volatile int *nlm_nlm_common_shared_mem_base;
-
-
-static int kimage_nlm_common_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-				Message("in kimage_nlm_common_xmit !! BLANK BLANK !! \n");
-				dev_kfree_skb(skb);
-				return 0;
-}
-
-
-
-static int kimage_nlm_common_close(struct net_device *dev)
-{
-				Message("in close !!! BLANK BLANK !!! \n");
-				return 0;
-
-}
-
-static int kimage_nlm_common_open(struct net_device *dev)
-{
-				Message("in open !!! BLANK BLANK !!! \n");
-				return 0;
-}
-
-
-static int kimage_nlm_common_ioctl(struct net_device *dev,struct ifreq *ifr, int cmd)
-{
-				u8 *ptr;
-				unsigned long result;
-				static unsigned char *kimage_loc ;
-				static int nlm_common_image_len;
-				int buff_len;
-				int argc;
-				int argv_len;
-				u8 *arg_buf, *dst;
-				int i;
-
-				switch (cmd){
-
-								case SIOCDEVPRIVATE+0x03:
-												kimage_loc = (unsigned char *)nlm_nlm_common_shared_mem_base +
-																PCIX_BOOT_FILE_START; //kernel image location;
-												nlm_common_image_len = 0;
-												return 0; 
-
-								case SIOCDEVPRIVATE+0x04:
-												// send argc + len + args
-
-												result = __copy_from_user((void *)&argc,
-																				(void *)ifr->ifr_data,4);
-												if(result > 0){
-																ErrorMsg("invalid address frm user space");			
-																return -1;
-												}	
-
-												result = __copy_from_user((void *)&argv_len,
-																				(void *)(ifr->ifr_data+4),4);
-												if(result > 0){
-																ErrorMsg("invalid address frm user space");
-																return -1;
-												}							
-
-												nlm_common_pci_writel(argc,
-														(uint32_t *)((u8 *)nlm_nlm_common_shared_mem_base + 
-														 			PCIX_BOOT_ARG_CNT_OFF));
-
-												nlm_common_pci_writel(argv_len,
-														(uint32_t *)((u8 *)nlm_nlm_common_shared_mem_base + 
-														 			PCIX_BOOT_ARGS_LEN_OFF));
-
-												arg_buf = kmalloc(argv_len, GFP_KERNEL);
-												if(arg_buf == NULL)
-													return -ENOMEM;
-
-												__copy_from_user((void *)arg_buf, 
-															(void *)(ifr->ifr_data+8), argv_len);
-
-												dst = ((u8 *)nlm_nlm_common_shared_mem_base + 
-																								PCIX_BOOT_ARGS_OFF);
-
-												for(i=0; i < argv_len; i++) {
-													nlm_common_pci_writeb(arg_buf[i], dst);
-													dst++;
-												}
-
-												return 0;
-
-								case SIOCDEVPRIVATE+0x02:
-
-												ptr = (u8 *)kmalloc(NLM_IMAGE_BUFF_LEN, GFP_KERNEL);
-												if (ptr == NULL){
-																ErrorMsg(KERN_ERR "Unable to allocate memory !!!\n");
-																return -ENOMEM;
-												}
-
-												result = __copy_from_user(ptr, ifr->ifr_data, 
-																				NLM_IMAGE_BUFF_LEN);
-												if (result > 0)
-																return -EIO;
-												buff_len = *((int *)ptr);
-												Message("Got %d bytes Chunk \n", buff_len);
-
-												for(i=0; i < buff_len; i++)
-													nlm_common_pci_writeb(ptr[i+4], kimage_loc+i);
-
-												kimage_loc += buff_len; 
-												nlm_common_image_len += buff_len;
-
-												kfree(ptr);
-												if (buff_len < (NLM_IMAGE_BUFF_LEN-4) ||
-																							 buff_len == 0){
-																Message("File Download \
-																				completed Total len %d\n", 
-																				nlm_common_image_len);
-																nlm_common_pci_writel(nlm_common_image_len, 
-																		((uint32_t *)nlm_nlm_common_shared_mem_base + 1));
-																nlm_common_pci_writel(0xa5a5a5a5,
-																		(uint32_t *) nlm_nlm_common_shared_mem_base);
-
-												}
-												return 0;
-
-								default:
-												return -EINVAL;
-
-				}
-				return -EINVAL;
-}
-
-
-
-static void nlm_nlm_common_remove(void)
-{
-				nlm_nlm_common_pcix_uninit();
-				return;
-}
-
-static void setup_net_ops(struct net_device *dev)
-{
-	nlm_boot_net_ops.ndo_open = kimage_nlm_common_open;
-	nlm_boot_net_ops.ndo_stop = kimage_nlm_common_close;
-	nlm_boot_net_ops.ndo_start_xmit = kimage_nlm_common_xmit;
-	nlm_boot_net_ops.ndo_do_ioctl = kimage_nlm_common_ioctl;
-	dev->netdev_ops = &nlm_boot_net_ops;
-}
-
-static int nlm_ioctl_nlm_common_probe(void)
-{
-				struct priv *priv = NULL;
-				int i;
-				int ret=0;
-				Message("\n%s Called\n",__FUNCTION__);
-
-				if(nlm_nlm_common_pcix_init()){
-								ErrorMsg("pcix_init failed");
-								return -EIO;
-				}
-
-				ndev = alloc_etherdev(sizeof(struct priv));
-				if(!ndev){
-								ret = -ENOMEM;
-								goto out;
-				}
-
-				priv = netdev_priv(ndev);
-				priv->dev = ndev;
-
-				setup_net_ops(ndev);
-
-				strcpy(ndev->name, "nlm_common_boot0");
-
-				for(i=0; i<6; i++)
-								ndev->dev_addr[i] = i;
-				printk("\"nlm_common_boot0\" Boot Over PCI - interface registered\n");
-				register_netdev(ndev);
-				return ret;
-out:
-				ErrorMsg("Returnin Error %d",ret);
-				return ret;  
-}
-
-/*  ioctl driver starts */
-#define NLM_VENDOR_ID 0x0182e
-#define NLM_DEVICE_ID 0x0
-
-
-int __init nlm_virt_driver_init_module(void)
-{
-#ifdef CONFIG_NLM_COMMON
-  if(nlm_get_pci_mode() == XLR_PCI_DEV_MODE){
-    Message("Xlr Is configured in Dev Mode - unloading xlr_pcix_boot");
-    return -ENODEV;
-  }
-#endif
-  if(nlm_common_get_shared_mem_base_host() == 0){
-    printk("\nLooks like device is not connected.\n");
-    return -ENODEV; 
-  }
-  Message("\n%s called\n",__FUNCTION__);
-	return nlm_ioctl_nlm_common_probe();
-}
-
-void __exit nlm_virt_driver_cleanup_module(void)
-{
-
-				nlm_nlm_common_remove();
-				return;
-}
-
-
-static int nlm_nlm_common_pcix_init(void)
-{
-				int err;
-
-				nlm_nlm_common_shared_mem_base = (uint32_t *)nlm_common_get_shared_mem_base_host();
-				Message("\n%s Called\n",__FUNCTION__);
-				if(nlm_nlm_common_shared_mem_base == NULL)
-				{
-								ErrorMsg("Shared MEM ioremap failed");
-								err = -ENODEV;
-								return err;
-				}
-				return 0;
-}
-
-/* This should be called only after successful return from nlm_nlm_common_pcix_init */
-static void nlm_nlm_common_pcix_uninit(void)
-{
-				unregister_netdev(ndev);
-				free_netdev(ndev);
-
-}
-
-
-module_init(nlm_virt_driver_init_module);
-module_exit(nlm_virt_driver_cleanup_module);
-MODULE_LICENSE("GPL");
diff --git a/drivers/net/xlr_rmik.c b/drivers/net/xlr_rmik.c
deleted file mode 100644
index 7aac0c8..0000000
--- a/drivers/net/xlr_rmik.c
+++ /dev/null
@@ -1,693 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/fcntl.h>
-#include <linux/in.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/inet.h>
-#include <linux/etherdevice.h>
-#include <linux/netdevice.h>
-#include <linux/inetdevice.h>
-#include <linux/skbuff.h>
-#include <linux/autoconf.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/cache.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/config_net.h>
-#include <asm/netlogic/xlr_mac.h>
-#include <asm/netlogic/xlr_rmik.h>
-
-#include <net/netevent.h>
-#include <net/neighbour.h>
-#include <linux/route.h>
-#include <net/ip_fib.h>
-
-
-extern struct net_device *dev_mac_type[][NETLOGIC_MAX_MACS];
-extern void mac_stats_update(int pkts, struct sk_buff *skb);
-extern struct net_device  *spi4_dev[];
-extern void nlm_nlm_common_mac_msgring_handler(int bucket, int size, int code,
-				  int stid, struct msgrng_msg *msg,
-				  void *data);
-
-static int rmik_net_events_reg = 0;
-struct nlm_cluster *nlm_pkt_pool = NULL;
-#define NLM_SPI4_MAX_PORTS 20
-#define NLM_SPI4_MAX_SLOTS 2
-
-void rmik_cpu_to_cpu_pkt_msgring_handler(int size, struct msgrng_msg *msg)
-{
-	unsigned long addr;
-	__u32 length;
-	int port, type, stid;
-	struct sk_buff *skb = NULL; 
-	int fbstid = 0x0;
-	nlm_physaddr_t physaddr;
-	struct net_device   *dev;
-	extern struct net_device_cfg xlr_net_dev_cfg;
-	struct port_cfg *port_cfg;
-	struct net_device_cfg *net_cfg = &xlr_net_dev_cfg;
-	struct nlm_event_packet_fw_msg *rx_pkt = nlm_addr_to_ptr(msg);
-
-	type =  rx_pkt->fwinfo.ptype;
-	fbstid = rx_pkt->fwinfo.fbstid;
-	port = rx_pkt->pktinfo.fields.fwport;
-	physaddr = msg->msg1 & 0xffffffffe0ULL;
-	addr = (unsigned long)bus_to_virt(physaddr);
-	length = rx_pkt->pktinfo.fields.length;
-
-	if(length == 0x0)  {
-		printk("Invalid length 0 packet received \n");
-		goto err_exit;
-	}
-		
-	/*
-	 * Do nothing during the boot.
-	 */
-	if (system_state != SYSTEM_RUNNING) {
-		printk("Invalid system state pkt received \n");
-		goto err_exit;
-	}
-
-#if 0
-	printk("nlm_nlm_common_dom_msgring_handler ingress port=%d type=%d fbstid=%d, msg=%llx:%llx\n", 
-				port, type, fbstid, msg->msg0, msg->msg1);
-#endif
-
-	switch(type) {
-		case NLM_GMAC0 :
-			dev = dev_mac_type[TYPE_GMAC][port];
-			port_cfg = &net_cfg->gmac_port[port];
-			stid = MSGRNG_STNID_GMAC0;
-			break; 
-		case NLM_GMAC1 :
-			dev = dev_mac_type[TYPE_GMAC][port + NETLOGIC_GMAC_PORTS_PER_CTRL];
-			port_cfg = &net_cfg->gmac_port[port + NETLOGIC_GMAC_PORTS_PER_CTRL];
-			stid = MSGRNG_STNID_GMAC1;
-			break; 
-		case NLM_XGS0  :
-			dev = dev_mac_type[TYPE_XGMAC][0];
-			if(spi4_dev[port] != NULL)
-				dev = spi4_dev[port];
-			stid = MSGRNG_STNID_XGS0FR;
-			port_cfg = &net_cfg->xgs_port[0];
-			break;
-		case NLM_XGS1  :
-			port = port + NLM_SPI4_MAX_PORTS / NLM_SPI4_MAX_SLOTS;
-			dev = dev_mac_type[TYPE_XGMAC][1];
-			if(spi4_dev[port] != NULL)
-				dev = spi4_dev[port];
-			stid = MSGRNG_STNID_XGS1FR;
-			port_cfg = &net_cfg->xgs_port[1];
-			break;
-		default:
-			printk("Unknown type\n");
-			goto err_exit;
-	}
-
-	if(dev == 0) {
-		printk("[%s] - no dev\n", __FUNCTION__);
-		goto err_exit;
-	}
-
-	if(MSGRNG_OWN(port_cfg->cfg_flag) == 0) {
-		/*
-		 * Allocate an skbuff, initialize it, and copy the data to it.
-		 */
-		skb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_ATOMIC);
-		if (!skb) {
-			printk("[%s] - no skbuff\n", __FUNCTION__);
-			goto err_exit;
-		}
-		skb->dev = dev;
-
-		length = length - (BYTE_OFFSET + MAC_CRC_LEN);
-		skb_put(skb, length);
-		memcpy(skb->data, (char *)addr + 2, length);
-
-		if(rmik_queue_pkt_mem(fbstid, physaddr) < 0)
-			nlm_nlm_common_drop_message_unowned(fbstid, physaddr, 1);
-
-		#if 0
-		{
-			int i = 0;
-			printk("[%s] Rx Packet: length=%d\n", dev->name, length);
-			for (i = 0; i < 64; i++) {
-				printk("%02x ", skb->data[i]);
-				if (i && (i % 16) == 0)
-					printk("\n");
-			}
-			printk("\n");
-		}
-		#endif
-
-		skb->protocol = eth_type_trans(skb, skb->dev);
-		/*
-		 * Increment the driver stats counters.
-		 */
-		mac_stats_update(1, skb);
-		/*
-		 * Queue the packet to the upper layer.
-		 */
-		netif_rx(skb);
-		return;
-	} else {
-		msg->msg0 = msg->msg1;
-		size = size - 1;
-		/* printk("calling mac msgring handler size=%d stid=%d\n", size, stid); */
-		return nlm_nlm_common_mac_msgring_handler(0 /* bucket ignored */, size, 0 /* code ignored */, stid, msg, NULL);
-	}
-
-	err_exit:
-		nlm_nlm_common_drop_message_unowned(fbstid, physaddr, 1);
-		if(skb != NULL)
-			kfree_skb(skb);
-	return;
-
-}
-
-void rmik_config_pde(int type, int instance, nlm_reg_t *base)
-{
-	uint32_t *pde_addr;
-	int rv;
-	int j, off, len;
-	uint64_t pde_bkt_map = 0ULL;
-
-	if(type == TYPE_GMAC) {
-		instance = instance < NETLOGIC_GMAC_PORTS_PER_CTRL ? 0 : NETLOGIC_GMAC_PORTS_PER_CTRL;
-		rv = fdt_get_gmac_pde_reginfo(instance, &pde_bkt_map);
-	} else if(type == TYPE_XGMAC)
-		rv = fdt_get_xgmac_pde_reginfo(instance, &pde_bkt_map);
-	else if(type == TYPE_SPI4)
-		rv = fdt_get_spi4_pde_reginfo(instance, &pde_bkt_map);
-	else
-		return ;
-		
-	if(rv == 0 )
-		return;
-	pde_addr = nlm_addr_to_ptr(rv);
-	while(1) {
-		base =  (nlm_reg_t *)(unsigned long)(int)((pde_addr[0] >> 12) << 12);
-        off = pde_addr[0] & 0xfff;
-        len =   pde_addr[1];
-
-
-		pde_addr = pde_addr + 2;
-		if(len == 0)
-			break;
-		for(j = 0; j < len; j++, off++) {
-			netlogic_write_reg(base, off, *pde_addr++);
-		}
-	}
-	return;
-}
-
-uint64_t rmik_get_pde_bktmap(int type, int instance)
-{
-	uint64_t pde_bkt_map = 0ULL;
-
-	return pde_bkt_map;
-
-	if(type == TYPE_GMAC) {
-		instance = instance < NETLOGIC_GMAC_PORTS_PER_CTRL ? 0 : NETLOGIC_GMAC_PORTS_PER_CTRL;
-		fdt_get_gmac_pde_reginfo(instance, &pde_bkt_map);
-	} else if(type == TYPE_XGMAC)
-		fdt_get_xgmac_pde_reginfo(instance, &pde_bkt_map);
-	else if(type == TYPE_SPI4)
-		fdt_get_spi4_pde_reginfo(instance, &pde_bkt_map);
-	
-	return pde_bkt_map;
-}
-
-
-struct work_struct rmik_replenish_work[NR_CPUS];
-uint64_t *rmik_replenish_data[NR_CPUS];
-atomic_t rmik_replenish_cnt[NR_CPUS];
-int rmik_schedule_thr = 4;
-#define RMIK_MAX_DESC_IN_QUEUE 64
-
-static void rmik_frin_replenish(struct work_struct *args /* ignored */ )
-{
-	int cpu;
-	atomic_t *rep_cnt;
-	unsigned long msgrng_flags;
-	int i, fbstid, cnt;
-	uint64_t *data, physaddr;
-
-	msgrng_access_enable(msgrng_flags);
-
-	cpu = hard_smp_processor_id();
-	rep_cnt =  &rmik_replenish_cnt[cpu];
-	data = rmik_replenish_data[cpu];
-
-	/* printk("[%d]rmik_frin_replenish[%d] \n", cpu, atomic_read(rep_cnt)); */
-
-	if ((cnt = atomic_read(rep_cnt)) < 0) {
-		printk("Error replenish cnt becomes negative\n");
-		msgrng_access_disable(msgrng_flags);
-		return;
-	}
-	if (cnt == 0) {
-		msgrng_access_disable(msgrng_flags);
-		return;
-	}
-
-
-	for(i = 0; i < (cnt * 2); i = i + 2) {
-		fbstid = data[i];
-		physaddr = data[i + 1];
-		nlm_nlm_common_drop_message_unowned(fbstid, physaddr, 0);
-	}
-	atomic_set(rep_cnt, 0);
-	msgrng_access_disable(msgrng_flags);
-}
-
-void rmik_init_replenish_work(int numdesc)
-{
-	int i;
-	if(numdesc > NR_CPUS)
-		rmik_schedule_thr = numdesc / NR_CPUS;
-	if(rmik_schedule_thr > 16)
-		rmik_schedule_thr = 16;
-
-	for(i = 0; i < NR_CPUS; i++) {
-		INIT_WORK(&rmik_replenish_work[i], rmik_frin_replenish);
-		rmik_replenish_data[i] = kmalloc(RMIK_MAX_DESC_IN_QUEUE * sizeof(uint64_t), GFP_KERNEL);
-		if(rmik_replenish_data[i] == NULL)
-			panic("Invalid mem in rmik replenish\n");
-	}
-	return;
-}
-
-int rmik_queue_pkt_mem(uint32_t fbstid, uint64_t physaddr)
-{
-	int cpu, i;
-	unsigned long msgrng_flags;
-	atomic_t *rep_cnt;
-	uint64_t *data;
-
-
-	msgrng_access_enable(msgrng_flags);
-	cpu = hard_smp_processor_id();
-    rep_cnt =  &rmik_replenish_cnt[cpu];
-
-	/* printk(" [cpu%d]rmik_queue_pkt_mem[cnt%d, fbid%d] \n", cpu, atomic_read(rep_cnt), fbstid);*/
-	data = rmik_replenish_data[cpu];
-	if(((data == NULL) || (i = atomic_read(rep_cnt)) >= RMIK_MAX_DESC_IN_QUEUE / 2)) {
-		msgrng_access_disable(msgrng_flags);
-		return -1;
-	}
-	data[i * 2] = fbstid;
-	data[i * 2 + 1] = physaddr;
-	atomic_inc(rep_cnt);
-	msgrng_access_disable(msgrng_flags);
-
-	if(atomic_read(rep_cnt) >= rmik_schedule_thr) {
-		if(rmik_replenish_work[cpu].func == NULL)
-			return -1;
-		schedule_work(&rmik_replenish_work[cpu]);
-	}
-	
-	return 0;
-}
-
-/*
- * Event handlers 
- */
-
-static int rmik_inetaddr_event(struct notifier_block *, unsigned long, void *);
-static int rmik_net_event(struct notifier_block *, unsigned long, void *);
-static struct notifier_block rmik_inetaddr_notifier = {
-	.notifier_call = rmik_inetaddr_event
-};
-
-static struct notifier_block rmik_net_notifier = {
-	.notifier_call = rmik_net_event
-};
-
-static int get_ptype_from_dev(struct net_device *netdev, int *ptype, int *instance, char *rname)
-{
-	int spi4_port_per_ctrl = NLM_SPI4_MAX_PORTS / NLM_SPI4_MAX_SLOTS;
-	int nettype, port;
-
-	for(nettype = 0; nettype < MAX_NET_TYPES; nettype++) {
-		if(nettype == TYPE_GMAC || nettype == TYPE_XGMAC) {
-			for(port = 0; port < NETLOGIC_MAX_MACS; port++) {
-				if(netdev == dev_mac_type[nettype][port])
-					goto found;
-			}
-		} else  {
-			for(port = 0; port < NLM_SPI4_MAX_PORTS; port++) {
-				if(netdev == spi4_dev[port]) 
-					goto found;
-			}
-		}
-	}
-	return -1;
-			
-
-found:
-	switch(nettype) {
-		case TYPE_GMAC :
-			if(port >= NETLOGIC_GMAC_PORTS_PER_CTRL)  {
-				*ptype = NLM_GMAC1;
-				*instance = port - NETLOGIC_GMAC_PORTS_PER_CTRL;
-				strcpy(rname, "gmac-block@1");
-			} else {
-				*ptype = NLM_GMAC0;
-				*instance = port;
-				strcpy(rname, "gmac-block@0");
-			}
-			break;
-		case TYPE_XGMAC: 
-			*instance = 0;
-			if(port == 0) {
-				*ptype = NLM_XGS0;
-				strcpy(rname, "xgmac@0");
-
-			} else {
-				*ptype = NLM_XGS1;
-				strcpy(rname, "xgmac@1");
-			}
-			break;
-		case TYPE_SPI4:
-			if(port < spi4_port_per_ctrl) {
-				*ptype = NLM_XGS0;
-				*instance = port;
-				strcpy(rname, "spi4@0");
-			} else {
-				*ptype = NLM_XGS1;
-				*instance = port - spi4_port_per_ctrl;
-				strcpy(rname, "spi4@1");
-			}
-			break;
-	}
-	return 0;
-}
-
-int send_interface_state_change(struct net_device *netdev, uint32_t myip, int msgtype)
-{
-	struct nlm_event_eth_ifc_msg *ifc;	
-	struct nlm_cluster *cl;
-	struct nlm_event_simple_msg smsg;
-	int dom, ptype, instance, i;
-	char rname[NLM_MAX_NAMELEN];
-	uint64_t dom_map;
-	uint64_t *ip_mac, tmac = 0;
-
-	if(get_ptype_from_dev(netdev, &ptype, &instance, rname) != 0)
-		return NOTIFY_DONE;
-
-
-	if(nlm_get_event_recipients(rname, &dom_map) < 0) 
-		return NOTIFY_DONE;
-	
-	/* No receivng domains */
-	if(dom_map == 0ULL)
-		return NOTIFY_DONE;
-	dom_map &= ~(1ULL << nlm_this_domain->id);
-
-	for(dom = 0; dom < NLM_MAX_DOMAINS; dom++) {
-		if(!((1ULL << dom) & dom_map))
-			continue;
-		if((cl = nlm_clpool_getref(dom, NLM_PKT_POOL_NAME)) == NULL) {
-			printk("No pool found for domain %d\n", dom);
-			nlm_send_pool_event(dom, NLM_EVENT_MSG_CL_POOL_NOT_FOUND, 0ULL);
-			continue;
-		}
-
-		if((ifc = nlm_cluster_alloc(cl, 0)) == NULL)  {
-			printk("Cluster alloc failed %d\n", dom);
-			nlm_send_pool_event(dom, NLM_EVENT_MSG_CL_POOL_EMPTY, 0ULL);
-			nlm_clpool_putref(cl);
-			continue;
-		}
-
-		memset(ifc, 0, sizeof(*ifc));
-		ifc->ptype = ptype;
-		ifc->port = instance;
-		ifc->count = 1;
-		ip_mac = nlm_addr_to_ptr(ifc->data);
-		ip_mac[0] = myip;
-		ip_mac[1] = 0ULL;
-		for(i = 5; i >= 0 ; i--) {
-			tmac = (uint64_t)(uint32_t)netdev->dev_addr[5 - i];
-			ip_mac[1] |= (tmac << (i * 8)); 
-		}
-
-		smsg.msgtype = msgtype;
-		smsg.domid = nlm_this_domain->id;
-		smsg.arg = nlm_ptr_to_addr(ifc);
-
-		if(nlm_send_event(dom, NLM_EVENT_VETH_INFO, sizeof(smsg),
-						nlm_addr_to_ptr(&smsg)) < 0) {
-			printk("Critical : Event failed to send for dom %d\n", dom);
-			nlm_cluster_free(cl, ifc);
-		}
-		nlm_clpool_putref(cl);
-	}
-	return NOTIFY_DONE;
-}
-
-struct nlm_event_eth_ifc_msg *update_arp_entry(struct net_device *netdev, 
-				uint32_t ipaddr, uint8_t *mac_addr, int msgtype)
-{
-	int i;
-	uint64_t *ip_mac, tmac;
-	struct nlm_cluster *cl;
-	struct nlm_event_eth_ifc_msg *ifc;	
-	struct nlm_event_simple_msg smsg;
-	int dom, ptype, instance;
-	char rname[NLM_MAX_NAMELEN];
-	uint64_t dom_map;
-
-	
-	if(get_ptype_from_dev(netdev, &ptype, &instance, rname) != 0)
-		return NOTIFY_DONE;
-
-
-	if(nlm_get_event_recipients(rname, &dom_map) < 0) 
-		return NOTIFY_DONE;
-	
-	/* No receivng domains */
-	if(dom_map == 0ULL)
-		return NOTIFY_DONE;
-	dom_map &= ~(1ULL << nlm_this_domain->id);
-
-	for(dom = 0; dom < NLM_MAX_DOMAINS; dom++) {
-		if(!((1ULL << dom) & dom_map))
-			continue;
-		if((cl = nlm_clpool_getref(dom, NLM_PKT_POOL_NAME)) == NULL) {
-			printk("No pool found for domain %d\n", dom);
-			nlm_send_pool_event(dom, NLM_EVENT_MSG_CL_POOL_NOT_FOUND, 0ULL);
-			continue;
-		}
-
-		if((ifc = nlm_cluster_alloc(cl, 0)) == NULL)  {
-			printk("Cluster alloc failed %d\n", dom);
-			nlm_send_pool_event(dom, NLM_EVENT_MSG_CL_POOL_EMPTY, 0ULL);
-			nlm_clpool_putref(cl);
-			continue;
-		}
-
-		memset(ifc, 0, sizeof(*ifc));
-		ifc->count = 1;
-		ifc->ptype = ptype;
-		ifc->port = instance;
-
-		ip_mac = nlm_addr_to_ptr(ifc->data);
-		ip_mac[0] = ipaddr;
-		ip_mac[1] = 0ULL;
-		for(i = 5; i >= 0 ; i--) {
-			tmac = (uint64_t)(uint32_t)mac_addr[5 - i];
-			ip_mac[1] |= (tmac << (i * 8)); 
-		}
-
-		smsg.msgtype = msgtype;
-		smsg.domid = nlm_this_domain->id;
-		smsg.arg = nlm_ptr_to_addr(ifc);
-
-
-		if(nlm_send_event(dom, NLM_EVENT_VETH_INFO, sizeof(smsg),
-					nlm_addr_to_ptr(&smsg)) < 0) {
-			printk("Critical : Event failed to send for dom %d\n", dom);
-			nlm_cluster_free(cl, ifc);
-		}
-		nlm_clpool_putref(cl);
-	}
-
-	return NOTIFY_DONE;
-}
-
-/**
- * rmik_inetaddr_event
- */
-static int rmik_inetaddr_event(struct notifier_block *notifier,
-		unsigned long event, void *ptr)
-{
-	struct in_ifaddr *ifa = ptr;
-	struct net_device *netdev;
-	unsigned int addr;
-	unsigned int mask;
-	       
-	if(!rmik_net_events_reg)
-		return NOTIFY_DONE;
-	
-	netdev = ifa->ifa_dev->dev;
-	addr = ntohl(ifa->ifa_address);
-	mask = ntohl(ifa->ifa_mask);
-
-	/*printk("rmik inetaddr_event: ip address " NIPQUAD_FMT
-			", netmask " NIPQUAD_FMT ".\n",
-			HIPQUAD(addr), HIPQUAD(mask)); */
-
-	switch (event) {
-		case NETDEV_DOWN:
-			/* printk("event:DOWN \n"); */
-			send_interface_state_change(netdev, addr, NLM_EVENT_MSG_IFC_DOWN);
-			return NOTIFY_OK;
-
-		case NETDEV_UP:
-			/*printk("event:UP \n"); */
-			send_interface_state_change(netdev, addr, NLM_EVENT_MSG_IFC_UP);
-			return NOTIFY_OK;
-
-		default:
-			break;
-	}
-	return NOTIFY_DONE;
-}
-
-
-/**
- * nes_net_event
- */
-static int rmik_net_event(struct notifier_block *notifier,
-		unsigned long event, void *ptr)
-{
-	struct neighbour *neigh = ptr;
-	struct net_device *netdev = neigh->dev;
-
-	if(!rmik_net_events_reg)
-		return NOTIFY_DONE;
-	
-	switch (event) {
-		case NETEVENT_NEIGH_UPDATE:
-			/* printk("Neighbour update\n");  */
-			if (neigh->nud_state & NUD_VALID) {
-				update_arp_entry(netdev, ntohl(*(__be32 *)neigh->primary_key), neigh->ha, NLM_EVENT_MSG_IFC_ARP_ADD);
-				return NOTIFY_OK;
-			} else {
-				update_arp_entry(netdev, ntohl(*(__be32 *)neigh->primary_key), neigh->ha, NLM_EVENT_MSG_IFC_ARP_DEL);
-				return NOTIFY_OK;
-			}
-			break;
-		default:
-			printk("NETEVENT_ %lu undefined\n", event);
-			break;
-	}
-
-	return NOTIFY_DONE;
-}
-
-static void create_pkt_pool(void)
-{
-	int num_units = 128;
-	static int pkt_pool_init_done = 0;
-
-	if(pkt_pool_init_done == 0) {
-		if(nlm_clpool_create(NLM_PKT_POOL_NAME, num_units, NLM_PKT_POOL_UNIT_SIZE, NLM_MALLOC_UNMAPPED) != 0) {
-			printk("Pktpool create failed\n");
-			return;
-		}
-		if((nlm_pkt_pool = nlm_clpool_getref(nlm_this_domain->id, NLM_PKT_POOL_NAME)) == NULL) {
-			printk("No pool found for domain %d\n", nlm_this_domain->id);
-		}
-		if(nlm_pkt_pool)
-			nlm_clpool_putref(nlm_pkt_pool);
-
-		pkt_pool_init_done = 1;
-	}
-}
-
-static void register_net_events(char *rname)
-{
-
-#if 0
-	nlm_atomic_t dom_map;
-	
-	if((nlm_get_event_recipients(rname, &dom_map) < 0) || (dom_map == 0)) 
-		return ;
-#endif
-	
-	if(rmik_net_events_reg == 0) {
-		rmik_net_events_reg = 1;
-		register_inetaddr_notifier(&rmik_inetaddr_notifier);
-		register_netevent_notifier(&rmik_net_notifier);
-	}
-
-	return;
-}
-
-void rmik_register_net_events(void)
-{
-	extern struct net_device_cfg xlr_net_dev_cfg;
-	struct net_device_cfg *net_cfg = &xlr_net_dev_cfg;
-
-	if (!rmik_en)
-		return;
-
-	create_pkt_pool();
-
-	if (rmik_net_events_reg == 0) {
-		if(net_cfg->gmac_port[0].cfg_flag != 0)
-			register_net_events("gmac-block@0");
-
-		if(net_cfg->gmac_port[NLM_GMAC_PORTS_PER_CTRL].cfg_flag != 0)
-			register_net_events("gmac-block@1");
-
-		if(net_cfg->xgs_port[0].cfg_flag != 0) {
-			if(net_cfg->xgs_type[0] == TYPE_SPI4)
-				register_net_events("spi4@0");
-			else
-				register_net_events("xgmac@0");
-		}
-
-		if(net_cfg->xgs_port[1].cfg_flag != 0) {
-			if(net_cfg->xgs_type[1] == TYPE_SPI4)
-				register_net_events("spi4@1");
-			else
-				register_net_events("xgmac@1");
-		}
-
-	}
-}
diff --git a/drivers/net/xlr_user_mac.c b/drivers/net/xlr_user_mac.c
deleted file mode 100644
index c255c44..0000000
--- a/drivers/net/xlr_user_mac.c
+++ /dev/null
@@ -1,1196 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
-#include <linux/poll.h>
-#include <linux/workqueue.h>
-#include <linux/proc_fs.h>
-#include <linux/cpumask.h>
-#include <linux/hugetlb.h>
-#include <linux/bootmem.h>
-
-#include <asm/uaccess.h>
-#include <asm/mman.h>
-#include <asm/atomic.h>
-#include <asm/smp.h>
-#include <asm/page.h>
-
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/devices.h>
-#include <asm/netlogic/xlr_mac.h>
-#include <asm/netlogic/xlr_user_mac.h>
-#include <asm/netlogic/gpio.h>
-#include <asm/netlogic/proc.h>
-#include <user/netlogic/xlr_user_mac.h>
-
-#include <asm/mach-netlogic/mmu.h>
-
-#define MB(x)	(x<<20)
-#define	KB(x)	(x<<10)
-#ifdef dbg_msg
-#undef dbg_msg
-#endif
-#define dbg_msg(fmt, args...) //printk(fmt, ##args)
-#define Message(a, b...) //printk("\nFunc[%s], Line[%d], "a"\n",__FUNCTION__,__LINE__,##b)
-
-/* this flag will be set by netlogic spi4 driver, it indicates
-   whether spi4 daughter cards are present on the board or not
-*/
-#ifdef CONFIG_NLMCOMMON_SPI4
-extern unsigned int g_spi4_card_flag;
-extern void spi4_enable_tx_rx(unsigned int  *mmio);
-extern void spi4_disable_tx_rx(unsigned int  *mmio);
-#else /* CONFIG_NLMCOMMON_SPI4 */
-static unsigned int g_spi4_card_flag;
-#endif /* CONFIG_NLMCOMMON_SPI4 */
-
-//#define USER_MAC_LOOPBACK
-
-extern void *nlm_common_psb_shm;
-extern unsigned long nlm_common_psb_shm_size;
-
-static unsigned long long nlm_common_psb_shm_paddr;
-static int user_mac_major;
-struct user_mac_data *user_mac;
-struct user_mac_kernal_data user_mac_krnl_data;
-/* use per cpu data structures for the Queues below */
-extern int xlr_hybrid;
-extern struct proc_dir_entry *nlm_root_proc;
-
-#define USER_MAC_TX_THRESHOLD 1
-
-#define MAC_CRC_LEN 4
-#define BYTE_OFFSET 2
-#define MAC_PREPAD_LEN 32
-
-#define MAC_DEV_NULL_BUCKET 127
-
-struct usermac_priv
-{
-	int num_desc;
-	int type;
-	nlm_reg_t *mmio;	
-	void*	frin_spill;
-	void*	frout_spill;
-	void*	class_0_spill;
-	void*	class_1_spill;
-	void*	class_2_spill;
-	void*	class_3_spill;
-};
-
-struct usermac_dev {
-	uint32_t gmac_list;
-	int xgmac_present;
-	int spi4_present;
-	struct usermac_priv priv[32];
-};
-
-static struct usermac_dev usermac_dev;
-static int hybrid_mem_init = 1;
-
-/*Hugetlb usermac data structures*/
-static struct page **page_array;
-static void *htlb_kvaddr = NULL;
-static phys_t htlb_kpaddr= 0ULL;
-static void user_mac_mem_init(void);
-
-
-static unsigned long long user_mac_vaddr_to_phys(void *addr)
-{
-	if(htlb_kvaddr){
-		return ((unsigned long)addr - (unsigned long)htlb_kvaddr + htlb_kpaddr);
-	}else{
-		return __pa(addr);
-	}
-}
-
-static __inline__ int user_mac_ptr2index(unsigned long long addr)
-{
-	int index = (addr - user_mac_vaddr_to_phys(user_mac->pkt_data)) / USER_MAC_PKT_BUF_SIZE;
-
-	if (index < 0 || index >= MAX_USER_MAC_PKTS) {
-		printk("[%s]: bad index=%d, addr=%llx, pkt_data=%p\n",
-		       __FUNCTION__, index, addr, &user_mac->pkt_data);
-		return -1;
-	}
-	return index;
-}
-
-#ifdef MAC_TX_DESC_ALIGNMENT
-#undef MAC_TX_DESC_ALIGNMENT
-#endif
-#define MAC_TX_DESC_ALIGNMENT (SMP_CACHE_BYTES + MAC_PREPAD_LEN - 1)
-
-#define CTRL_RES0           0
-#define CTRL_RES1           1
-#define CTRL_REG_FREE       2
-#define CTRL_CONT           4
-#define CTRL_EOP            5
-#define CTRL_START          6
-#define CTRL_SNGL           7
-
-static __inline__ int user_mac_send_frin_num_xgs_pkts(void)
-{
-	int num_xgmac_pkts = MAX_USER_MAC_FRIN_PKTS / 2.5;
-
-	return num_xgmac_pkts;
-}
-
-static __inline__ int user_mac_send_frin_num_gmac_pkts(void)
-{
-	return user_mac_send_frin_num_xgs_pkts() / 2;
-}
-
-static __inline__ int user_mac_send_frin_is_desc_gmac(int index)
-{
-	int start_index = 0, end_index = 0;
-
-	start_index = 0;
-	end_index = start_index + user_mac_send_frin_num_gmac_pkts();
-	return ( (index >= start_index) && (index < end_index) ) ? 1 : 0;
-}
-
-static __inline__ int user_mac_send_frin_is_desc_xgs0(int index)
-{
-	int start_index = 0, end_index = 0;
-
-	start_index = user_mac_send_frin_num_gmac_pkts();
-	end_index = start_index + user_mac_send_frin_num_xgs_pkts();
-	return ( (index >= start_index) && (index < end_index) ) ? 1 : 0;
-}
-
-static __inline__ int user_mac_send_frin_is_desc_xgs1(int index)
-{
-	int start_index = 0, end_index = 0;
-
-	start_index = user_mac_send_frin_num_gmac_pkts() + user_mac_send_frin_num_xgs_pkts();
-	end_index = start_index + user_mac_send_frin_num_xgs_pkts();
-	return ( (index >= start_index) && (index < end_index) ) ? 1 : 0;
-}
-
-static __inline__ int user_mac_send_frin_stid(int index)
-{
-	if (is_xls()) {
-		/* If only gmac-block 0 is active , Or only gmac-block1 is active */
-		if((usermac_dev.gmac_list & 0x0f) && (!(usermac_dev.gmac_list & 0xf0)))
-			return MSGRNG_STNID_GMAC0_FR;
-		else if((usermac_dev.gmac_list & 0xf0) && (!(usermac_dev.gmac_list & 0x0f)))
-			return MSGRNG_STNID_GMAC1_FR;
-		if((index >= 0) && (index < (MAX_USER_MAC_FRIN_PKTS / 2)))
-			return MSGRNG_STNID_GMAC0_FR;
-		return MSGRNG_STNID_GMAC1_FR;
-	}
-	/* xlr case */
-	if(usermac_dev.gmac_list & 0x0f) {
-		switch(usermac_dev.xgmac_present | usermac_dev.spi4_present) {
-			case 0x03:
-				if (user_mac_send_frin_is_desc_gmac(index)) return MSGRNG_STNID_GMACRFR_0;
-				if (user_mac_send_frin_is_desc_xgs0(index)) return MSGRNG_STNID_XMAC0RFR;
-				if (user_mac_send_frin_is_desc_xgs1(index)) return MSGRNG_STNID_XMAC1RFR;
-				return MSGRNG_STNID_GMACRFR_0;
-			case 0x01:
-				if((index >= 0) && (index < (MAX_USER_MAC_FRIN_PKTS / 4)))
-					return MSGRNG_STNID_GMACRFR_0;
-				return MSGRNG_STNID_XMAC0RFR;
-			case 0x02:
-				if((index >= 0) && (index < (MAX_USER_MAC_FRIN_PKTS / 4)))
-					return MSGRNG_STNID_GMACRFR_0;
-				return MSGRNG_STNID_XMAC1RFR;
-			default:
-				return MSGRNG_STNID_GMACRFR_0;
-		}
-	} else {
-		/* xgmac should be present, this function should not be called when
-                   all the gmac & xgmac stations are not owned by linux */
-		switch(usermac_dev.xgmac_present | usermac_dev.spi4_present) {
-			case 0x03:
-				if((index >= 0) && (index < (MAX_USER_MAC_FRIN_PKTS / 2)))
-					return MSGRNG_STNID_XMAC0RFR;
-				return MSGRNG_STNID_XMAC1RFR;
-			case 0x01:
-				return MSGRNG_STNID_XMAC0RFR;
-			case 0x02:
-				return MSGRNG_STNID_XMAC1RFR;
-			default:
-				return -1;
-
-
-		}
-	}
-}
-
-static void user_mac_send_frin(void)
-{
-	struct msgrng_msg msg;
-	struct packet_data *packet_data = user_mac->pkt_data;
-	int i = 0;
-	int cnt[4] = { 0, 0, 0, 0 };
-	uint64_t addr = 0;
-	unsigned long mflags = 0;
-	int stid = 0;
-	int host_gen_num_pkts = (MAX_USER_MAC_PKTS - MAX_USER_MAC_FRIN_PKTS) / 32;
-
-	if(usermac_dev.gmac_list == 0 && usermac_dev.xgmac_present == 0 &&
-			usermac_dev.spi4_present == 0)
-		return;
-
-	
-	msgrng_flags_save(mflags);
-
-	for (i = 0; i < MAX_USER_MAC_FRIN_PKTS; i++) {
-		addr = user_mac_vaddr_to_phys(&packet_data[i].data);
-		user_mac->pkt_desc[i].free = 0;
-
-		msg.msg0 = (uint64_t) addr & ~(SMP_CACHE_BYTES - 1);
-		msg.msg1 = msg.msg2 = msg.msg3 = 0;
-
-		stid = user_mac_send_frin_stid(i);
-
-		if (usermac_dev.spi4_present){
-            		if((stid == MSGRNG_STNID_XMAC0RFR) && (!(g_spi4_card_flag & 0x01))){
-                		/*spi4-0 card is not present*/
-						Message("SPI4-0 Card not present - %d index not send",i);
-                		continue;
-            		}
-            		else if((stid == MSGRNG_STNID_XMAC1RFR) && (!(g_spi4_card_flag & 0x02))){
-                		/*spi4-1 card is not present*/
-						Message("SPI4-1 Card not present - %d index not send",i);
-                		continue;
-            		}
-       	}
-
-        	do {
-            		if (!message_send_retry(1, MSGRNG_CODE_MAC, stid, &msg)){
-							if(stid == MSGRNG_STNID_XMAC0RFR){
-								Message("Index %d, Phys Addr [%#llx] sent to Station XGMAC0",i, (unsigned long long)(addr & ~(SMP_CACHE_BYTES - 1)));
-								cnt[2]++;
-							}else if(stid == MSGRNG_STNID_XMAC1RFR){
-								Message("Index %d, Phys Addr [%#llx] sent to Station XGMAC1",i,(unsigned long long)(addr & ~(SMP_CACHE_BYTES - 1)));
-								cnt[3]++;
-							}else if(stid == MSGRNG_STNID_GMACRFR_0){
-								Message("Index %d Phys Addr [%#llx] sent to Station GMAC0",i, (unsigned long long)(addr & ~(SMP_CACHE_BYTES - 1)));
-								cnt[0]++;
-							}else if(stid == MSGRNG_STNID_GMAC1_FR){
-								Message("Index %d Phys Addr [%#llx] sent to Station GMAC1",i, (unsigned long long)(addr & ~(SMP_CACHE_BYTES - 1)));
-								cnt[1]++;
-
-							}else{
-								Message("Index %d sent to unknown station!!! %d ",i,stid);
-							}
-						   	break;
-					}
-            		printk("[%s:%d]: retrying free_desc[%d] message send to stid=%d, [status gmac0=%d xmac0=%d xmac1=%d\n", 
-                    		__FUNCTION__,
-                    		__LINE__, i, stid, cnt[0], cnt[2], cnt[3]);
-        	} while(1);
-	
-        	xlr_inc_counter(USER_MAC_FRIN);
-    	}
-	msgrng_flags_restore(mflags);
-	printk("[%s]:...done[Free descriptors gmac0=%d gmac1=%d xgmac0=%d xgmac1=%d\n", __FUNCTION__,
-				cnt[0], cnt[1], cnt[2], cnt[3]);
-
-	for (i=0; i<32; i++) {
-		user_mac->host_pkt_next_free[i] =
-			MAX_USER_MAC_FRIN_PKTS + (i * host_gen_num_pkts);
-	}
-
-	for(i=MAX_USER_MAC_FRIN_PKTS; i<MAX_USER_MAC_PKTS; i++)
-		user_mac->pkt_desc[i].free = 1;
-
-	printk
-	    ("[%s]: packet_data[first].data=%llx, packet_data[last].data=%llx\n",
-	     __FUNCTION__, user_mac_vaddr_to_phys(&packet_data[0].data),
-	     user_mac_vaddr_to_phys(&packet_data[MAX_USER_MAC_PKTS - 1].data));
-}
-
-static void user_mac_send_frin_xgmac(void)
-{
-	struct msgrng_msg msg;
-	struct packet_data *packet_data = user_mac->pkt_data;
-	int i = 0;
-	unsigned long addr = 0, mflags = 0;
-	int stid = 0;
-	int cnt[2] = {0, 0 };
-	int host_gen_num_pkts = (MAX_USER_MAC_PKTS - MAX_USER_MAC_FRIN_PKTS) / 32;
-		
-	if(usermac_dev.xgmac_present == 0 && usermac_dev.spi4_present == 0)
-		return;
-
-	msgrng_flags_save(mflags);
-
-	for (i = 0; i < MAX_USER_MAC_FRIN_PKTS; i++) {
-		
-		stid = user_mac_send_frin_stid(i);
-	
-		if(stid == MSGRNG_STNID_XMAC0RFR)
-			cnt[0]++;
-		else if( stid == MSGRNG_STNID_XMAC1RFR)
-			cnt[1]++;
-		else
-			continue;
-		
-		addr = user_mac_vaddr_to_phys(&packet_data[i].data);
-		user_mac->pkt_desc[i].free = 0;
-
-		msg.msg0 = (uint64_t) addr & ~(SMP_CACHE_BYTES - 1);
-		msg.msg1 = msg.msg2 = msg.msg3 = 0;
-
-        	do {
-            		if (!message_send_retry(1, MSGRNG_CODE_MAC, stid, &msg)) break;
-            		printk("[%s:%d]: retrying free_desc[%d] message send to stid=%d\n", 
-                    		__FUNCTION__,
-                    		__LINE__, i, stid);
-        	} while(1);
-	
-        	xlr_inc_counter(USER_MAC_FRIN);
-    	}
-	msgrng_flags_restore(mflags);
-	printk("[%s]:...done, Free descriptors xgmac0=%d xgmac1=%d\n", __FUNCTION__, cnt[0], cnt[1]);
-
-	for (i=0; i<32; i++) {
-		user_mac->host_pkt_next_free[i] =
-			MAX_USER_MAC_FRIN_PKTS + (i * host_gen_num_pkts);
-	}
-
-	for(i=MAX_USER_MAC_FRIN_PKTS; i<MAX_USER_MAC_PKTS; i++)
-		user_mac->pkt_desc[i].free = 1;
-
-	printk
-	    ("[%s]: packet_data[first].data=%llx, packet_data[last].data=%llx\n",
-	     __FUNCTION__, user_mac_vaddr_to_phys(&packet_data[0].data),
-	     user_mac_vaddr_to_phys(&packet_data[MAX_USER_MAC_PKTS - 1].data));
-}
-
-void nlm_common_user_mac_update_time(void)
-{
-	if (user_mac) {
-		user_mac->time.lo++;
-		if (!user_mac->time.lo)
-			user_mac->time.hi++;
-	}else {
-		user_mac_krnl_data.time.lo++;
-		if (!user_mac_krnl_data.time.lo)
-			user_mac_krnl_data.time.hi++;
-	}
-		
-	
-}
-void nlm_common_user_mac_update_ktime(void)
-{
-    if(user_mac) {
-       user_mac->ktime = current_kernel_time(); 
-     } else {
-	user_mac_krnl_data.ktime = current_kernel_time();
-	}
-
-}
-static int user_mac_open(struct inode *inode, struct file *filp)
-{
-	//printk("user_mac_open() invoked\n");
-
-	filp->private_data = NULL;
-
-	return 0;
-}
-
-static int user_mac_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
-	unsigned long long shm_addr = nlm_common_psb_shm_paddr;
-	unsigned long shm_size = nlm_common_psb_shm_size;
-	unsigned long size = 0;
-	unsigned long vm_size = vma->vm_end - vma->vm_start;
-
-	dbg_msg
-	    ("[%s]: shm_addr=%lx, shm_size=%lx, offset = %lx, vm_start=%lx, vm_size=%lx, vm_flags=%lx, "
-	     "vm_page_prot=%lx\n", __FUNCTION__, shm_addr, shm_size, offset,
-	     vma->vm_start, vm_size, vma->vm_flags,
-	     pgprot_val(vma->vm_page_prot));
-
-	if (vma->vm_start != (unsigned long)NLM_USER_MAC_MMAP_VIRT_START)
-		return -EINVAL;
-
-	if (!shm_addr)
-		return -ENXIO;
-
-	if (offset >= shm_size)
-		return -ESPIPE;
-
-	if (vma->vm_flags & VM_LOCKED)
-		return -EPERM;
-
-	size = shm_size - offset;
-	if (vm_size > size)
-		return -ENOSPC;
-
-	vma->vm_flags |= (VM_RESERVED | VM_IO);
-
-	if (remap_pfn_range
-	    (vma, vma->vm_start, (shm_addr >> PAGE_SHIFT), size, vma->vm_page_prot))
-		return -EAGAIN;
-
-	return 0;
-}
-
-/*****************************************************************
- * Initialize GMAC
- *****************************************************************/
-static void nlm_usermac_config_pde(struct usermac_priv *priv)
-{
-	int i = 0, cpu = 0, bucket = 0;
-	__u64 bucket_map = 0;
-
-	for (i = 0; i < 32; i++) {
-		if (cpu_isset(i, cpu_online_map)) {
-			cpu = cpu_logical_map(i);
-			bucket = 4 + (((cpu >> 2) << 3) | (cpu & 0x03));
-			bucket_map |= (1ULL << bucket);
-			dbg_msg("i=%d, cpu=%d, bucket = %d, bucket_map=%llx\n",
-				i, cpu, bucket, bucket_map);
-		}
-	}
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_0, (bucket_map & 0xffffffff));
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_0 + 1,
-			  ((bucket_map >> 32) & 0xffffffff));
-
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_1, (bucket_map & 0xffffffff));
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_1 + 1,
-			  ((bucket_map >> 32) & 0xffffffff));
-
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_2, (bucket_map & 0xffffffff));
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_2 + 1,
-			  ((bucket_map >> 32) & 0xffffffff));
-
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_3, (bucket_map & 0xffffffff));
-	netlogic_write_reg(priv->mmio, R_PDE_CLASS_3 + 1,
-			  ((bucket_map >> 32) & 0xffffffff));
-}
-
-static void nlm_usermac_config_parser(struct usermac_priv *priv)
-{
-	/* Mark it as no classification 
-	 * The parser extract is gauranteed to be zero with no classfication
-	 */
-	
-	netlogic_write_reg(priv->mmio, R_L2TYPE_0, 0x01);
-	
-	/* configure the parser : L2 Type is configured in the bootloader */
-	/* extract IP: src, dest protocol */
-	netlogic_write_reg(priv->mmio, R_L3CTABLE,
-			  (9 << 20) | (1 << 19) | (1 << 18) | (0x01 << 16) |
-			  (0x0800 << 0));
-	netlogic_write_reg(priv->mmio, R_L3CTABLE + 1,
-			  (12 << 25) | (4 << 21) | (16 << 14) | (4 << 10));
-
-	if (xlr_user_mac_l4_extract()) {
-		/* extract TCP: src port, dest port */
-		netlogic_write_reg(priv->mmio, R_L4CTABLE, (6 << 0));
-		netlogic_write_reg(priv->mmio, R_L4CTABLE + 1,
-				  (0 << 21) | (2 << 17) | (2 << 11) | (2 << 7));
-		/* extract UDP: src port, dest port */
-		netlogic_write_reg(priv->mmio, R_L4CTABLE + 2, (17 << 0));
-		netlogic_write_reg(priv->mmio, R_L4CTABLE + 3,
-				  (0 << 21) | (2 << 17) | (2 << 11) | (2 << 7));
-	}
-}
-
-static void nlm_usermac_port_enable(struct usermac_priv *priv, int flag)
-{
-	uint32_t regval;
-	int tx_threshold = 1518;
-
-
-	netlogic_write_reg(priv->mmio, R_MAC_FILTER_CONFIG,
-		(1 << O_MAC_FILTER_CONFIG__BROADCAST_EN) |
-		(1 << O_MAC_FILTER_CONFIG__ALL_MCAST_EN) |
-		(1 << O_MAC_FILTER_CONFIG__ALL_UCAST_EN) |
-		(1 << O_MAC_FILTER_CONFIG__MAC_ADDR0_VALID));
-
-
-	if (flag) {
-
-		regval = netlogic_read_reg(priv->mmio, R_TX_CONTROL);
-		regval |= (1 << O_TX_CONTROL__TxEnable) |
-			(tx_threshold << O_TX_CONTROL__TxThreshold);
-
-		netlogic_write_reg(priv->mmio, R_TX_CONTROL, regval);
-
-		regval = netlogic_read_reg(priv->mmio, R_RX_CONTROL);
-		regval |= 1 << O_RX_CONTROL__RxEnable;
-		netlogic_write_reg(priv->mmio, R_RX_CONTROL, regval);
-
-#ifdef CONFIG_NLMCOMMON_SPI4
-		if(priv->type == TYPE_SPI4)
-			spi4_enable_tx_rx((uint32_t *)priv->mmio);
-#endif
-
-	
-	} else {
-
-		if(priv->type == TYPE_SPI4)
-			spi4_disable_tx_rx((uint32_t *)priv->mmio);
-
-		regval = netlogic_read_reg(priv->mmio, R_TX_CONTROL);
-		regval &= ~((1 << O_TX_CONTROL__TxEnable) |
-			    (tx_threshold << O_TX_CONTROL__TxThreshold));
-
-		netlogic_write_reg(priv->mmio, R_TX_CONTROL, regval);
-
-		regval = netlogic_read_reg(priv->mmio, R_RX_CONTROL);
-		regval &= ~(1 << O_RX_CONTROL__RxEnable);
-		netlogic_write_reg(priv->mmio, R_RX_CONTROL, regval);
-
-	}
-}
-
-#define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
-static __inline__ void *cacheline_aligned_kmalloc(int size, int gfp_mask)
-{
-	void *buf = kmalloc(size + SMP_CACHE_BYTES, gfp_mask);
-	if (buf)
-		buf =
-			(void
-			 *)(CACHELINE_ALIGNED_ADDR((unsigned long)buf +
-						   SMP_CACHE_BYTES));
-	return buf;
-}
-
-static __inline__ void *nlm_usermac_config_spill(nlm_reg_t * mmio,
-					      int reg_start_0, int reg_start_1,
-					      int reg_size, int size)
-{
-	__u32 spill_size = CACHELINE_ALIGNED_ADDR(size);
-	void *spill = cacheline_aligned_kmalloc(spill_size, GFP_KERNEL);
-	__u64 phys_addr = 0;
-
-	if (!spill) {
-		panic("Unable to allocate memory for spill area!\n");
-	}
-	phys_addr = user_mac_vaddr_to_phys(spill);
-	netlogic_write_reg(mmio, reg_start_0, (phys_addr >> 5) & 0xffffffff);
-	netlogic_write_reg(mmio, reg_start_1, (phys_addr >> 37) & 0x07);
-	netlogic_write_reg(mmio, reg_size, spill_size);
-
-	return spill;
-}
-
-static void nlm_usermac_config_spill_area(struct usermac_priv *priv)
-{
-	/* */
-	int max_frin_spill    = 0;
-	int max_frout_spill   = 0;
-	int max_class_0_spill = 0;
-	int max_class_1_spill = 0;
-	int max_class_2_spill = 0;
-	int max_class_3_spill = 0;
-
-	if(!priv->num_desc)
-		return;
-
-	max_frin_spill = priv->num_desc << 2;
-	max_frout_spill = priv->num_desc << 2;
-
-	max_class_0_spill = priv->num_desc;
-	max_class_1_spill = priv->num_desc;
-	max_class_2_spill = priv->num_desc;
-	max_class_3_spill = priv->num_desc;
-
-
-	priv->frin_spill =
-		nlm_usermac_config_spill(priv->mmio,
-				      R_REG_FRIN_SPILL_MEM_START_0,
-				      R_REG_FRIN_SPILL_MEM_START_1,
-				      R_REG_FRIN_SPILL_MEM_SIZE,
-				      max_frin_spill *
-				      sizeof(struct fr_desc));
-
-	priv->class_0_spill =
-		nlm_usermac_config_spill(priv->mmio,
-				      R_CLASS0_SPILL_MEM_START_0,
-				      R_CLASS0_SPILL_MEM_START_1,
-				      R_CLASS0_SPILL_MEM_SIZE,
-				      max_class_0_spill *
-				      sizeof(union rx_tx_desc));
-	priv->class_1_spill =
-		nlm_usermac_config_spill(priv->mmio,
-				      R_CLASS1_SPILL_MEM_START_0,
-				      R_CLASS1_SPILL_MEM_START_1,
-				      R_CLASS1_SPILL_MEM_SIZE,
-				      max_class_1_spill *
-				      sizeof(union rx_tx_desc));
-
-	priv->frout_spill =
-		nlm_usermac_config_spill(priv->mmio, R_FROUT_SPILL_MEM_START_0,
-				      R_FROUT_SPILL_MEM_START_1,
-				      R_FROUT_SPILL_MEM_SIZE,
-				      max_frout_spill *
-				      sizeof(struct fr_desc));
-
-	priv->class_2_spill =
-		nlm_usermac_config_spill(priv->mmio,
-				      R_CLASS2_SPILL_MEM_START_0,
-				      R_CLASS2_SPILL_MEM_START_1,
-				      R_CLASS2_SPILL_MEM_SIZE,
-				      max_class_2_spill *
-				      sizeof(union rx_tx_desc));
-	priv->class_3_spill =
-		nlm_usermac_config_spill(priv->mmio,
-				      R_CLASS3_SPILL_MEM_START_0,
-				      R_CLASS3_SPILL_MEM_START_1,
-				      R_CLASS3_SPILL_MEM_SIZE,
-				      max_class_3_spill *
-				      sizeof(union rx_tx_desc));
-}
-
-
-/*Translate user space vaddr to page*/
-static struct page *user_vaddr_to_page(unsigned long addr, unsigned long size)
-{
-	pgd_t *pgd;
-	pud_t *pud;
-	pmd_t *pmd;
-	pte_t *pte = NULL;
-	pte_t pteval;
-	unsigned long pfn = 0;
-	struct mm_struct *mm = current->mm;
-	struct vm_area_struct *vma = NULL;
-
-	/*Check whether address falls in user space or not*/
-	if(addr >= PAGE_OFFSET){
-		printk("\nInvalid Userspace address\n");
-		return NULL;
-	}
-	
-	/*Make sure addr doesn't overlap*/
-	if(addr > (addr+size)){
-		printk("\nAddress overlaps!!!\n");
-		return NULL;
-	}
-	
-	/*Make sure address is already present in VMA*/
-	vma = find_vma(mm, addr+size-1);
-	if(!vma){
-		printk("\nNo VMA found!!!\n");
-		return NULL;
-	}
-	
-	if(vma->vm_start > addr){
-		/*`addr` doesn't fall under vma*/
-		printk("\nAddress doesn't fall under vma!!\n");
-		printk("\nvma_start = %#lx, vma_end = %#lx\n",
-						vma->vm_start, vma->vm_end);
-		return NULL;
-	}
-
-#ifdef CONFIG_HUGETLBFS
-	if(!is_vm_hugetlb_page(vma))
-		return NULL;
-#else
-	return NULL;
-#endif
-	/*Acquire pagetable sem*/
-	down_read(&mm->mmap_sem);
-	pgd = pgd_offset(mm, addr);
-	if (!pgd_none(*pgd)){
-		pud = pud_offset(pgd, addr);
-		if (!pud_none(*pud)) {
-			pmd = pmd_offset(pud, addr);
-			if (!pmd_none(*pmd)){
-				pte = pte_offset_map(pmd, addr);
-			}
-		}
-	}
-	/*Release pagetable sem*/
-	up_read(&mm->mmap_sem);
-
-	if(!pte){
-		printk("\nHugepage is not allocated yet\n");
-		return NULL;
-	}
-	pteval = *pte;
-	if(pte_none(pteval)){
-		printk("\nPTE not allocated yet\n");
-		return NULL;
-	}
-	pfn = (pte_val(pteval) & 0xffffffffffULL) >> PAGE_SHIFT;
-	Message("User virt Addr [%#lx], PTE VAL [%#llx], pfn [%#lx]",
-					(unsigned long)addr, (unsigned long long)pte_val(pteval),
-					(unsigned long)pfn);
-	return pfn_to_page(pfn);
-}
-
-int user_mac_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
-		   unsigned long arg)
-{
-    extern struct net_device_cfg xlr_net_dev_cfg;
-    struct net_device_cfg *net_cfg = &xlr_net_dev_cfg;
-    extern cpumask_t phys_cpu_present_map;
-
-	switch (cmd) {
-	case USER_MAC_IOC_HUGETLB_SHM_VIRT_ADDR:{
-			__u64 *ptr = (__u64 *) arg;
-			__u64	user_vaddr;
-			__u64	user_vaddr_len;
-			int no_of_pages = 0;
-			int i = 0;
-
-			if(htlb_kvaddr)
-				/*Usermac memory already initialized*/
-				return 0;	
-			
-			copy_from_user(&user_vaddr, ptr, sizeof(*ptr));
-			copy_from_user(&user_vaddr_len, ptr+1, sizeof(*ptr));
-
-			if(user_vaddr_len < MB(8ULL)){
-				printk("\nCan't init usermac buffers with < 8MB buffer\n");
-				return -ENOMEM; 
-			}else{
-				no_of_pages = MB(8ULL)/KB(4);
-				page_array = (struct page **)kmalloc
-						(sizeof(struct page *)*(no_of_pages),GFP_KERNEL);
-				if(!page_array){
-					printk("\nCan't allocate memory for page_array\n");
-					return -ENOMEM;
-				}
-				Message("User Space Virtual ADdress [%#lx]",(unsigned long)user_vaddr);
-				for(i=0; i<no_of_pages; i++, user_vaddr+=KB(4)){
-					page_array[i] = 
-						user_vaddr_to_page((unsigned long)user_vaddr, KB(4));
-					if(!page_array[i]){
-						kfree(page_array);
-						printk("\nuser_vaddr_to_page returned NULL!!\n");
-						return -ENOMEM;
-					}
-				}
-				/*vmap this page range in kernel address space*/
-				htlb_kvaddr = vmap(page_array, no_of_pages, VM_MAP, PAGE_KERNEL);
-				if(!htlb_kvaddr){
-					printk("\nNot enough virtual address space available to map the hugepage in kernel\n");
-					kfree(page_array);
-					return -ENOMEM;
-				}
-				htlb_kpaddr = ((unsigned long long)vmalloc_to_pfn((const void *)htlb_kvaddr))<<PAGE_SHIFT;
-				Message("HugeTlb Physical Address [%#llx]",(unsigned long long)htlb_kpaddr);
-			}
-			nlm_common_psb_shm = htlb_kvaddr;
-			/*Init user mac descriptors now!!*/
-			user_mac_mem_init();
-		}
-		break;
-	case USER_MAC_IOC_EARLY_MEM_INIT:{
-			put_user((unsigned int)hybrid_mem_init, (unsigned int*)arg);
-		}
-		break;
-	case USER_MAC_IOC_GSHMPHYS:{
-			put_user((unsigned long long)nlm_common_psb_shm_paddr,(unsigned long long*)arg);
-		}
-		break;
-
-	case USER_MAC_IOC_GSHMVIRT:{
-			put_user((unsigned long long)(unsigned long)nlm_common_psb_shm,(unsigned long long *)arg);
-		}
-		break;
-
-	case USER_MAC_IOC_GSHMSIZE:{
-			put_user((unsigned int)nlm_common_psb_shm_size,(unsigned int*)arg);
-		}
-		break;
-
-	case USER_MAC_IOC_GMMAP_START:{
-			put_user((unsigned int)NLM_USER_MAC_MMAP_VIRT_START,(unsigned int*)arg);
-		}
-		break;
-
-	case USER_MAC_IOC_GREAD_REG:{
-			__u32 *ptr = (__u32 *) arg;
-			__u32 dev = 0, reg = 0, value = 0;
-			nlm_reg_t *mmio = 0;
-
-			get_user(dev, ptr + 0);
-			get_user(reg, ptr + 1);
-
-			if(dev < 31)
-				mmio = usermac_dev.priv[dev].mmio;
-			
-			if(mmio == NULL || (reg>(0x1000>>2))){
-				printk("[%s]: bad args, dev=0x%x, reg=0x%x\n",
-				       __FUNCTION__, dev, reg);
-				value = 0xdeadbeef;
-			}else {
-				printk("\nMMIO %#lx, REG %#lx\n",(unsigned long)mmio,(unsigned long)reg);
-				printk("\nReading @ Address %#lx-->%#x\n",
-						(unsigned long)&mmio[reg],
-						mmio[reg]);
-				value = netlogic_read_reg(mmio, reg);
-				dbg_msg	
-				    ("[%s]: dev=0x%x, reg=0x%x, value=0x%x\n",
-				     __FUNCTION__, dev, reg, value);
-			}
-			put_user(value, ptr + 2);
-		}
-		break;
-
-	case USER_MAC_IOC_SWRITE_REG:{
-			__u32 *ptr = (__u32 *) arg;
-			__u32 dev = 0, reg = 0, value = 0;
-			nlm_reg_t *mmio = 0;
-
-			get_user(dev, ptr + 0);
-			get_user(reg, ptr + 1);
-			get_user(value, ptr + 2);
-			if(dev < 31)
-				mmio = usermac_dev.priv[dev].mmio;
-			if(mmio == NULL || (reg>(0x1000>>2))){
-				printk("[%s]: bad args, dev=0x%x, reg=0x%x\n",
-				       __FUNCTION__, dev, reg);
-			} else{
-				dbg_msg
-				    ("[%s]: dev=0x%x, reg=0x%x, value=0x%x\n",
-				     __FUNCTION__, dev, reg, value);
-
-				netlogic_write_reg(mmio, reg, value);
-			}
-
-		}
-		break;
-
-	case USER_MAC_IOC_GPHYS_CPU_PRESENT_MAP:{
-			put_user((unsigned int)phys_cpu_present_map.bits[0],(unsigned int*)arg);
-		}
-		break;
-
-	case USER_MAC_IOC_GCPU_ONLINE_MAP:{
-			put_user((unsigned int)cpu_online_map.bits[0],(unsigned int*)arg);
-		}
-		break;
-	case USER_MAC_IOC_HYBRID_MODE_SETUP:{
-			if(xlr_hybrid_user_mac()){
-				if(net_cfg->xgs_type[0] == TYPE_XGMAC || net_cfg->xgs_type[1] == TYPE_XGMAC){
-					/*ATX-II*/
-					put_user((unsigned int)XLR_HYBRID_USER_MAC_GMAC_XGMAC,
-								   	(unsigned int*)arg);
-				}
-				else if(net_cfg->xgs_type[0] == TYPE_SPI4 || net_cfg->xgs_type[1] == TYPE_SPI4){
-					/*ATX-I*/
-					put_user((unsigned int)XLR_HYBRID_USER_MAC_GMAC_SPI4,
-								   	(unsigned int*)arg);
-				}
-				else{
-					/*All remaining XLR and XLS boards.*/
-					put_user((unsigned int)XLR_HYBRID_USER_MAC_GMAC,
-								   	(unsigned int*)arg);
-				}
-			}
-			else{
-				put_user((unsigned int)xlr_hybrid, (unsigned int*)arg);
-			}
-		}
-		break;
-	default:{
-			printk("ioctl(): invalid command=0x%x\n", cmd);
-			//return -EINVAL;
-			return 0;
-		}
-
-	}
-
-	return 0;
-}
-
-long user_mac_compat_ioctl(struct file *filp, unsigned int cmd,
-	       			unsigned long arg)
-{
-	unsigned long ret = -1;
-	lock_kernel();	
-	ret = user_mac_ioctl(NULL,filp,cmd,arg);
-	unlock_kernel();
-	if(ret){
-		printk("user_mac_ioctl returned with an error.\n");
-		return -ENOIOCTLCMD;
-	}
-	return ret;
-}
-
-  // called only when the reference count (maintained in inode) is zero
-static int user_mac_release(struct inode *inode, struct file *filp)
-{
-
-	return 0;
-}
-
-struct file_operations user_mac_fops = {
-	.mmap = user_mac_mmap,
-	.open = user_mac_open,
-	.ioctl = user_mac_ioctl,
-	.compat_ioctl = user_mac_compat_ioctl,
-	.release = user_mac_release,
-};
-
-static int proc_read_count;
-
-static int user_mac_proc_read(char *page, char **start, off_t off,
-			      int count, int *eof, void *data)
-{
-	int len = 0;
-	off_t begin = 0;
-	struct user_mac_time *time;
-	if (user_mac)
-		time = &user_mac->time;
-	else
-		time = &user_mac_krnl_data.time;
-
-	proc_read_count++;
-
-	len += sprintf(page + len,
-		       "\n*************** USER MAC STATISTICS ****************\n"
-		       "cpu_%d: proc_read_count = %d\n",
-		       smp_processor_id(), proc_read_count);
-	if (!proc_pos_check(&begin, &len, off, count))
-		goto out;
-
-	len +=
-	    sprintf(page + len,
-		    "\nshm_paddr=%llx, shm_size=%lx, mmap_virt_start=%x\n"
-		    "sizeof(user_mac_data)=0x%x\n", nlm_common_psb_shm_paddr,
-		    nlm_common_psb_shm_size, NLM_USER_MAC_MMAP_VIRT_START,
-		    (unsigned int)sizeof(struct user_mac_data));
-	if (!proc_pos_check(&begin, &len, off, count))
-		goto out;
-
-	len +=
-	    sprintf(page + len,
-		    "\noffsetof(time)=0x%x, time.hi=%u, time.lo=%u\n",
-		    (unsigned int)offsetof(struct user_mac_data, time), 
-			(unsigned int)time->hi,
-		    (unsigned int)time->lo);
-	if (!proc_pos_check(&begin, &len, off, count))
-		goto out;
-
-	len += sprintf(page + len, "\n");
-	if (!proc_pos_check(&begin, &len, off, count))
-		goto out;
-
-	*eof = 1;
-
-      out:
-	*start = page + (off - begin);
-	len -= (off - begin);
-	if (len > count)
-		len = count;
-	if (len < 0)
-		len = 0;
-
-	return len;
-}
-
-extern struct xlr_user_mac_config xlr_user_mac;
-
-static int __init xlr_user_mac_setup(char *str)
-{
-	if ( (strcmp(str, "=fast_syscall") == 0) || (strcmp(str, "fast_syscall") == 0)) {
-		xlr_user_mac.fast_syscall = 1;
-		printk("XLR: user_mac configured with fast syscalls\n");
-	} else {
-		printk("XLR: user_mac configured with unknown args \"%s\"\n", str);
-	}
-
-	return 1;
-}
-
-early_param("xlr_user_mac", xlr_user_mac_setup);
-
-static void user_mac_mem_init(void)
-{
-	int i = 0;
-	static int init_mem = 0;
-
-	if(init_mem){
-		printk("\nUser Mac Memory is already initialized\n");	
-		return;
-	}
-	
-	user_mac = (struct user_mac_data *)nlm_common_psb_shm;
-	if (!user_mac) {
-		printk("[%s]: Null Shared Memory Pointer?\n", __FUNCTION__);
-		printk("\nInvalid user mac shared memory !!\n");
-		return;
-	}
-	printk("\nUserMac Data structures Starts @ %#lx\n",(unsigned long)nlm_common_psb_shm);
-	if (sizeof(struct user_mac_data) > nlm_common_psb_shm_size) {
-		printk("[%s]: psb shared memory is too small: user_mac_data=0x%x, psb_shm_size=0x%lx\n", __FUNCTION__, (unsigned int)sizeof(struct user_mac_data),
-		     (unsigned long)nlm_common_psb_shm_size);
-		printk("User Mac Memory initialization failed!!\n");
-		return;
-	}
-
-	for(i=0;i<MAX_USER_MAC_PKTS;i++)
-		user_mac->pkt_desc[i].free = 1;
-
-	if(htlb_kpaddr){
-		nlm_common_psb_shm_paddr = htlb_kpaddr;
-	}else{
-		nlm_common_psb_shm_paddr = user_mac_vaddr_to_phys(nlm_common_psb_shm);
-	}
-
-	if (xlr_hybrid_user_mac()){
-		Message("Calling User Mac Send FRIN ");
-		user_mac_send_frin();
-	}
-	else if(xlr_hybrid_user_mac_xgmac())
-		user_mac_send_frin_xgmac();
-
-	for(i = 0; i < NETLOGIC_MAX_MACS; i++) {
-		if(usermac_dev.priv[i].mmio != 0)
-			nlm_usermac_port_enable(&usermac_dev.priv[i], 1);	
-	}
-	init_mem = 1;
-	return;
-}
-
-
-#ifdef CONFIG_HUGETLBFS
-static int __init xlr_hybrid_early_init(char *str)
-{
-	if(HPAGE_SIZE < MB(8)){
-		printk("Hugetlb user mac is not supported with < 8MB huge page size\n");
-		return 0;
-	}
-	if (strcmp(str,"no")==0){
-		hybrid_mem_init = 0;
-	}
-	return 0;
-}
-early_param("xlr_hybrid_early_init", xlr_hybrid_early_init);
-#endif
-
-static int user_mac_init(void)
-{
-	int i = 0, next = 0;
-	struct proc_dir_entry *entry;
-	extern struct net_device_cfg xlr_net_dev_cfg;
-	struct net_device_cfg *net_cfg = &xlr_net_dev_cfg;
-
-	usermac_dev.gmac_list = 0;
-	usermac_dev.xgmac_present = 0;
-	usermac_dev.spi4_present = 0;
-
-	if (xlr_hybrid_user_mac())	{
-		for(i = 0; i < NETLOGIC_MAX_GMACS; i++) {
-			if(net_cfg->gmac_port[i].mmio_addr == 0 || net_cfg->gmac_port[i].cfg_flag == 0)
-				continue;
-			usermac_dev.gmac_list |= (1 << i);
-			usermac_dev.priv[i].mmio = (void *)net_cfg->gmac_port[i].mmio_addr;
-			usermac_dev.priv[i].type = TYPE_GMAC;
-
-			/* Need to call only once, num_desc will be nonzero for only the first
-                           port of every gmac block */
-			if(net_cfg->gmac_port[i].num_desc != 0) { 
-				usermac_dev.priv[i].num_desc = MAX_USER_MAC_FRIN_PKTS;
-				nlm_usermac_config_spill_area(&usermac_dev.priv[i]);
-				nlm_usermac_config_parser(&usermac_dev.priv[i]);
-				nlm_usermac_config_pde(&usermac_dev.priv[i]);
-			}		
-			next = i + 1;
-		}
-		if(usermac_dev.gmac_list == 0) 
-			printk("Skipping usermac configuration on gmac ports..\n");
-	}
-
-	if (xlr_hybrid_user_mac() || xlr_hybrid_user_mac_xgmac())	{
-		for(i = 0; i < NETLOGIC_MAX_XGMACS; i++) {
-			if(net_cfg->xgs_port[i].mmio_addr == 0 || net_cfg->xgs_port[i].cfg_flag == 0)
-				continue;
-			if(net_cfg->xgs_type[i] == TYPE_XGMAC)
-				usermac_dev.xgmac_present |= (1  << i);
-			else
-				usermac_dev.spi4_present |= (1 << i);
-			usermac_dev.priv[next + i].mmio = (void *)net_cfg->xgs_port[i].mmio_addr;
-			usermac_dev.priv[next + i].type = net_cfg->xgs_type[i];
-			usermac_dev.priv[next + i].num_desc = MAX_USER_MAC_FRIN_PKTS;
-			nlm_usermac_config_spill_area(&usermac_dev.priv[next + i]);
-			nlm_usermac_config_parser(&usermac_dev.priv[next + i]);
-			nlm_usermac_config_pde(&usermac_dev.priv[next + i]);
-		}
-		if(usermac_dev.xgmac_present == 0 && usermac_dev.spi4_present == 0) 
-			printk("Skipping usermac configuration on xgmac ports..\n");
-	}
-
-	if(usermac_dev.gmac_list != 0 || usermac_dev.xgmac_present != 0 ||
-			usermac_dev.spi4_present != 0) {
-		user_mac_major =
-			register_chrdev(XLR_USER_MAC_MAJOR, NLM_USER_MAC_CHRDEV_NAME, &user_mac_fops);
-		if (user_mac_major < 0) {
-			printk("user_mac_init() register_chrdev() failed\n");
-			return user_mac_major;
-		}
-		printk("Registered user_mac driver: major=%d\n", XLR_USER_MAC_MAJOR);
-	}
-
-	entry = create_proc_read_entry(NLM_USER_MAC_CHRDEV_NAME, 0 /* def mode */ ,
-				       nlm_root_proc /* parent directory*/ ,
-                                       user_mac_proc_read
-				       /* proc read function */ ,
-				       0	/* no client data */
-		);
-
-	if (!entry) {
-		printk("[%s]: Unable to create proc read entry for %s!\n",
-		       __FUNCTION__, NLM_USER_MAC_CHRDEV_NAME);
-	}
-
-	if(hybrid_mem_init){
-		user_mac_mem_init();
-		return 0;
-	}
-	printk("Memory init for hybrid mode is not done.\n");
-	return 0;
-}
-
-static void user_mac_exit(void)
-{
-	unregister_chrdev(user_mac_major, NLM_USER_MAC_CHRDEV_NAME);
-}
-static int user_mac_mem(char *str)
-{
-
-	if ( !(xlr_hybrid_user_mac()) && !(xlr_hybrid_user_mac_xgmac()))
-		return 0;
-
-	nlm_common_psb_shm = alloc_bootmem_low( NLM_USER_MAC_SIZE );
-	nlm_common_psb_shm_size = NLM_USER_MAC_SIZE;
-	return 0;
-}
-
-module_init(user_mac_init);
-__setup("xlr_hybrid",user_mac_mem);
-module_exit(user_mac_exit);
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index af24a15..165274c 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -25,7 +25,6 @@ endif
 
 # Build the PCI MSI interrupt support
 obj-$(CONFIG_PCI_MSI) += msi.o
-obj-$(CONFIG_PCI_MSI_XLR) += msi.o
 
 # Build the Hypertransport interrupt support
 obj-$(CONFIG_HT_IRQ) += htirq.o
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2246a5c..b5d75a6 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -17,24 +17,6 @@
 
 static LIST_HEAD(pci_host_bridges);
 
-#ifdef CONFIG_NLM_XLR
-/* Hack! This file includes references to XLR
- * specific routines/defines. To be removed...
- * -------------------------------------------
- * The Global ht_start_busno variable (set in
- * pci-phoenix.c) is used here, as a reference
- * to programming the Seconday/Subordinate bus
- * nrs. during bridge scans...
- */
-extern int ht_start_busno;
-/*
- * for the is_xls routine.
- */
-#include <asm/netlogic/sim.h>
-extern void pcie_controller_init_done(void);
-extern int link0, link1, link2, link3;
-#endif
-
 /* Ugh.  Need to stop exporting this to modules. */
 LIST_HEAD(pci_root_buses);
 EXPORT_SYMBOL(pci_root_buses);
@@ -1391,14 +1373,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.dma_parms = &dev->dma_parms;
-#ifdef CONFIG_NLM_XLR
-    if(xlr_revision_c())
-	    dev->dev.coherent_dma_mask = DMA_BIT_MASK(31);
-    else
-	    dev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
-#else
 	dev->dev.coherent_dma_mask = 0xffffffffull;
-#endif
 
 	pci_set_dma_max_seg_size(dev, 65536);
 	pci_set_dma_seg_boundary(dev, 0xffffffff);
@@ -1706,13 +1681,6 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 			bus->is_added = 1;
 	}
 
-
-#ifdef CONFIG_NLM_XLR
-    /*link2 and link3 are always set to zero incase of xls-4xx/6xx*/
-    if ((is_xls()) && (!link0) && (!link1) && (!link2) && (!link3))
-        return max;
-#endif
-
 	for (pass=0; pass < 2; pass++)
 		list_for_each_entry(dev, &bus->devices, bus_list) {
 			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
diff --git a/drivers/pci/proc.c b/drivers/pci/proc.c
index c7a8a14..1b25fb1 100644
--- a/drivers/pci/proc.c
+++ b/drivers/pci/proc.c
@@ -401,7 +401,7 @@ int pci_proc_attach_device(struct pci_dev *dev)
 		return -EACCES;
 
 	if (!bus->procdir) {
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLMCOMMON
 		/* 
 		   create /proc entries in "%02x" format at all times.
 		   Otherwise, for HT, it will be created in "%04x:%02x" format
diff --git a/drivers/perfctr/Kconfig b/drivers/perfctr/Kconfig
deleted file mode 100644
index 0247e0a..0000000
--- a/drivers/perfctr/Kconfig
+++ /dev/null
@@ -1,64 +0,0 @@
-# $Id: Kconfig,v 1.1.2.1 2005-02-20 21:48:11 pboddupalli Exp $
-# Performance-monitoring counters driver configuration
-#
-
-menu "Performance-monitoring counters support"
-
-config PERFCTR
-	bool "Performance monitoring counters support"
-	help
-	  This driver provides access to the performance-monitoring counter
-	  registers available in some (but not all) modern processors.
-	  These special-purpose registers can be programmed to count low-level
-	  performance-related events which occur during program execution,
-	  such as cache misses, pipeline stalls, etc.
-
-	  You can safely say Y here, even if you intend to run the kernel
-	  on a processor without performance-monitoring counters.
-
-	  At <http://www.csd.uu.se/~mikpe/linux/perfctr/> you can find
-	  the corresponding user-space components, as well as other
-	  versions of this package. A mailing list is also available, at
-	  <http://lists.sourceforge.net/lists/listinfo/perfctr-devel>.
-
-config PERFCTR_INIT_TESTS
-	bool "Init-time hardware tests"
-	depends on PERFCTR
-	default y
-	help
-	  This option makes the driver perform additional hardware tests
-	  during initialisation, and log their results in the kernel's
-	  message buffer. For most supported processors, these tests simply
-	  measure the runtime overheads of performance counter operations.
-
-	  If you have a less well-known processor (one not listed in the
-	  etc/costs/ directory in the user-space package), you should enable
-	  this option and email the results to the perfctr developers.
-
-	  If unsure, say N.
-
-config PERFCTR_VIRTUAL
-	bool "Virtual performance counters support"
-	depends on PERFCTR
-	default y
-	help
-	  The processor's performance-monitoring counters are special-purpose
-	  global registers. This option adds support for virtual per-process
-	  performance-monitoring counters which only run when the process
-	  to which they belong is executing. This improves the accuracy of
-	  performance measurements by reducing "noise" from other processes.
-
-	  Say Y.
-
-config PERFCTR_INTERRUPT_SUPPORT
-	prompt "Performance counter overflow interrupt support" if PPC
-	bool
-	depends on PERFCTR
-	default y
-
-config PERFCTR_CPUS_FORBIDDEN_MASK
-	bool
-	depends on PERFCTR
-	default n
-
-endmenu
diff --git a/drivers/perfctr/Makefile b/drivers/perfctr/Makefile
deleted file mode 100644
index 2eb07b8..0000000
--- a/drivers/perfctr/Makefile
+++ /dev/null
@@ -1,25 +0,0 @@
-# $Id: Makefile,v 1.1.2.2 2006-06-06 20:28:30 pboddupalli Exp $
-# Makefile for the Performance-monitoring counters driver.
-
-ifeq ("$(CONFIG_PERFCTR)","y")
-
-# This also covers x86_64.
-perfctr-objs-$(CONFIG_X86) := x86.o
-tests-objs-$(CONFIG_X86) := x86_tests.o
-
-perfctr-objs-$(CONFIG_PPC32) := ppc.o
-tests-objs-$(CONFIG_PPC32) := ppc_tests.o
-
-perfctr-objs-$(CONFIG_MIPS) := mips.o
-tests-objs-$(CONFIG_MIPS) := mips_tests.o
-
-perfctr-objs-y += init.o
-perfctr-objs-$(CONFIG_PERFCTR_INIT_TESTS) += $(tests-objs-y)
-perfctr-objs-$(CONFIG_PERFCTR_VIRTUAL) += virtual.o
-
-perfctr-objs		:= $(perfctr-objs-y)
-obj-$(CONFIG_PERFCTR)	:= perfctr.o
-
-else
-obj-y := dummy-syscalls.o
-endif
diff --git a/drivers/perfctr/compat.h b/drivers/perfctr/compat.h
deleted file mode 100644
index 62cba3c..0000000
--- a/drivers/perfctr/compat.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* 
- * Performance-monitoring counters driver.
- * Compatibility definitions for 2.6 kernels.
- *
- * Copyright (C) 1999-2005  Mikael Pettersson
- */
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#include "compat24.h"
-#else
-
-#include "cpumask.h"
-
-#define EXPORT_SYMBOL_mmu_cr4_features	EXPORT_SYMBOL(mmu_cr4_features)
-#define EXPORT_SYMBOL___put_task_struct	EXPORT_SYMBOL(__put_task_struct)
-
-#define task_siglock(tsk)	((tsk)->sighand->siglock)
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4)	/* names changed in 2.6.4-rc2 */
-#define sysdev_register(dev)	sys_device_register((dev))
-#define sysdev_unregister(dev)	sys_device_unregister((dev))
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) /* remap_page_range() obsoleted in 2.6.10-rc1 */
-#include <linux/mm.h>
-static inline int
-remap_pfn_range(struct vm_area_struct *vma, unsigned long uvaddr,
-		unsigned long pfn, unsigned long size, pgprot_t prot)
-{
-	return remap_page_range(vma, uvaddr, pfn << PAGE_SHIFT, size, prot);
-}
-#endif
-
-#if !defined(DEFINE_SPINLOCK) /* added in 2.6.11-rc1 */
-#define DEFINE_SPINLOCK(x)	spinlock_t x = SPIN_LOCK_UNLOCKED
-#endif
-
-#endif
diff --git a/drivers/perfctr/cpumask.h b/drivers/perfctr/cpumask.h
deleted file mode 100644
index 2249db3..0000000
--- a/drivers/perfctr/cpumask.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/* $Id: cpumask.h,v 1.1.2.2 2005-03-02 04:57:49 pboddupalli Exp $
- * Performance-monitoring counters driver.
- * Partial simulation of cpumask_t on non-cpumask_t kernels.
- * Extension to allow inspecting a cpumask_t as array of ulong.
- * Appropriate definition of perfctr_cpus_forbidden_mask.
- *
- * Copyright (C) 2003-2004  Mikael Pettersson
- */
-
-/* 2.6.0-test4 changed set-of-CPUs values from ulong to cpumask_t */
-
-#include <linux/version.h>
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
-
-#if (!defined(PERFCTR_HAVE_CPUMASK_T) && !defined(HAVE_CPUMASK_T))
-typedef unsigned long cpumask_t;
-#endif
-
-/* RH/FC1 kernel 2.4.22-1.2115.nptl added cpumask_t, but with
-   an incomplete API and a broken cpus_and() [misspelled parameter
-   in its body]. Sigh.
-   Assume cpumask_t is unsigned long and use our own code. */
-#undef cpu_set
-#define cpu_set(cpu, map)	atomic_set_mask((1UL << (cpu)), &(map))
-#undef cpu_isset
-#define cpu_isset(cpu, map)	((map) & (1UL << (cpu)))
-#undef cpus_and
-#define cpus_and(dst,src1,src2)	do { (dst) = (src1) & (src2); } while(0)
-#undef cpus_clear
-#define cpus_clear(map)		do { (map) = 0UL; } while(0)
-#undef cpus_complement
-#define cpus_complement(map)	do { (map) = ~(map); } while(0)
-#undef cpus_empty
-#define cpus_empty(map)		((map) == 0UL)
-#undef cpus_equal
-#define cpus_equal(map1, map2)	((map1) == (map2))
-#undef cpus_addr
-#define cpus_addr(map)		(&(map))
-
-#undef CPU_MASK_NONE
-#define CPU_MASK_NONE		0UL
-
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,1))
-
-/* 2.6.1-rc1 introduced cpus_addr() */
-#ifdef CPU_ARRAY_SIZE
-#define cpus_addr(map)		((map).mask)
-#else
-#define cpus_addr(map)		(&(map))
-#endif
-
-#endif
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8) && !defined(cpus_andnot))
-#define cpus_andnot(dst, src1, src2) \
-do { \
-    cpumask_t _tmp2; \
-    _tmp2 = (src2); \
-    cpus_complement(_tmp2); \
-    cpus_and((dst), (src1), _tmp2); \
-} while(0)
-#endif
-
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)) && !defined(CONFIG_SMP))
-#undef cpu_online_map
-#define cpu_online_map	cpumask_of_cpu(0)
-#endif
-
-#ifdef CPU_ARRAY_SIZE
-#define PERFCTR_CPUMASK_NRLONGS	CPU_ARRAY_SIZE
-#else
-#define PERFCTR_CPUMASK_NRLONGS	1
-#endif
-
-/* CPUs in `perfctr_cpus_forbidden_mask' must not use the
-   performance-monitoring counters. TSC use is unrestricted.
-   This is needed to prevent resource conflicts on hyper-threaded P4s. */
-
-#ifdef CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK
-
-extern cpumask_t perfctr_cpus_forbidden_mask;
-#define perfctr_cpu_is_forbidden(cpu)	cpu_isset((cpu), perfctr_cpus_forbidden_mask)
-
-#else
-
-#define perfctr_cpus_forbidden_mask	CPU_MASK_NONE
-#define perfctr_cpu_is_forbidden(cpu)	0 /* cpu_isset() needs an lvalue :-( */
-
-#endif
diff --git a/drivers/perfctr/dummy-syscalls.c b/drivers/perfctr/dummy-syscalls.c
deleted file mode 100644
index 8af2ca6..0000000
--- a/drivers/perfctr/dummy-syscalls.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* $Id: dummy-syscalls.c,v 1.1.2.3 2007-10-31 17:34:40 kmurthy Exp $
- * Virtual per-process performance counters.
- *
- * Copyright (C) 1999-2004  Mikael Pettersson
- */
-#include <linux/init.h>
-#include <linux/compiler.h> /* for unlikely() in 2.4.18 and older */
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/ptrace.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/perfctr.h>
-
-#include <asm/io.h>
-#include <asm/uaccess.h>
-
-#include "cpumask.h"
-#include "virtual.h"
-#include "compat.h"
-
-/****************************************************************
- *								*
- * Virtual perfctr actual system calls.				*
- *								*
- ****************************************************************/
-
-/* tid is the actual task/thread id (ne pid, stored as ->pid),
-   pid/tgid is that 2.6 thread group id crap (stored as ->tgid) */
-
-asmlinkage long sys_vperfctr_open(int tid, int creat)
-{
-   printk ("PERFCTR not configured, unimplemented syscall\n");
-   return -EINVAL;
-}
-
-asmlinkage long sys_vperfctr_control(int fd,
-				     const struct vperfctr_control __user *argp,
-				     unsigned int argbytes)
-{
-   printk ("PERFCTR not configured, unimplemented syscall\n");
-   return -EINVAL;
-}
-
-asmlinkage long sys_vperfctr_unlink(int fd)
-{
-   printk ("PERFCTR not configured, unimplemented syscall\n");
-   return -EINVAL;
-}
-
-asmlinkage long sys_vperfctr_iresume(int fd)
-{
-   printk ("PERFCTR not configured, unimplemented syscall\n");
-   return -EINVAL;
-}
-
-asmlinkage long sys_vperfctr_read(int fd, unsigned int cmd, void __user *argp, unsigned int argbytes)
-{
-   printk ("PERFCTR not configured, unimplemented syscall\n");
-   return -EINVAL;
-}
diff --git a/drivers/perfctr/init.c b/drivers/perfctr/init.c
deleted file mode 100644
index ea5ac8f..0000000
--- a/drivers/perfctr/init.c
+++ /dev/null
@@ -1,194 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* $Id: init.c,v 1.1.2.7 2007-11-15 13:42:00 kmurthy Exp $
- * Performance-monitoring counters driver.
- * Top-level initialisation code.
- *
- * Copyright (C) 1999-2004  Mikael Pettersson
- */
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/device.h>
-#include <linux/sysctl.h>
-#include <linux/perfctr.h>
-
-#include <asm/uaccess.h>
-
-#include "cpumask.h"
-#include "virtual.h"
-#include "version.h"
-
-struct perfctr_info perfctr_info = {
-	.abi_version = PERFCTR_ABI_VERSION,
-	.driver_version = VERSION,
-};
-
-static ssize_t
-driver_version_show(struct class *class, char *buf)
-{
-	return sprintf(buf, "%s\n", perfctr_info.driver_version);
-}
-
-static ssize_t
-cpu_type_show(struct class *class, char *buf)
-{
-	return sprintf(buf, "%#x\n", perfctr_info.cpu_type);
-}
-
-static ssize_t
-cpu_features_show(struct class *class, char *buf)
-{
-	return sprintf(buf, "%#x\n", perfctr_info.cpu_features);
-}
-
-static ssize_t
-cpu_khz_show(struct class *class, char *buf)
-{
-	return sprintf(buf, "%u\n", perfctr_info.cpu_khz);
-}
-
-static ssize_t
-tsc_to_cpu_mult_show(struct class *class, char *buf)
-{
-	return sprintf(buf, "%u\n", perfctr_info.tsc_to_cpu_mult);
-}
-
-static ssize_t
-cpus_online_show(struct class *class, char *buf)
-{
-	int ret = cpumask_scnprintf(buf, PERFCTR_PAGE_SIZE-1, &cpu_online_map);
-	buf[ret++] = '\n';
-	return ret;
-}
-
-static ssize_t
-cpus_forbidden_show(struct class *class, char *buf)
-{
-#ifdef CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK
-	int ret = cpumask_scnprintf(buf, PERFCTR_PAGE_SIZE-1, perfctr_cpus_forbidden_mask);
-	buf[ret++] = '\n';
-	return ret;
-#endif
-	return 0;
-}
-
-static CLASS_ATTR(driver_version, 0444, driver_version_show, NULL);
-static CLASS_ATTR(cpu_type, 0444, cpu_type_show, NULL);
-static CLASS_ATTR(cpu_features, 0444, cpu_features_show, NULL);
-static CLASS_ATTR(cpu_khz, 0444, cpu_khz_show, NULL);
-static CLASS_ATTR(tsc_to_cpu_mult, 0444, tsc_to_cpu_mult_show, NULL);
-static CLASS_ATTR(cpus_online, 0444, cpus_online_show, NULL);
-static CLASS_ATTR(cpus_forbidden, 0444, cpus_forbidden_show, NULL);
-
-/* static struct class_attribute perfctr_class_attrs[] = {
-	__ATTR_RO(driver_version),
-	__ATTR_RO(cpu_type),
-	__ATTR_RO(cpu_features),
-	__ATTR_RO(cpu_khz),
-	__ATTR_RO(tsc_to_cpu_mult),
-	__ATTR_RO(cpus_online),
-	__ATTR_RO(cpus_forbidden),
-	__ATTR_NULL
-}; */
-
-static struct class perfctr_class = {
-	.name		= "perfctr",
-	// .class_attrs	= perfctr_class_attrs,
-};
-
-char *perfctr_cpu_name __initdata;
-
-static int __init perfctr_class_init(void)
-{
-	int err;
-
-	err = class_register(&perfctr_class);
-	if (err)
-		return err;
-
-	err |= class_create_file(&perfctr_class, &class_attr_driver_version);
-	err |= class_create_file(&perfctr_class, &class_attr_cpu_type);
-	err |= class_create_file(&perfctr_class, &class_attr_cpu_features);
-	err |= class_create_file(&perfctr_class, &class_attr_cpu_khz);
-	err |= class_create_file(&perfctr_class, &class_attr_tsc_to_cpu_mult);
-	err |= class_create_file(&perfctr_class, &class_attr_cpus_online);
-	err |= class_create_file(&perfctr_class, &class_attr_cpus_forbidden);
-
-	if (err)
-		class_unregister(&perfctr_class);
-	return err;
-}
-
-extern int	perfctr_cntmode;
-
-ctl_table  perfctr_cntmode_table[] = {
-    {
-        .ctl_name   	= PERFCTR_CNTMODE,
-		.procname   	= "cntmode",
-        .data       	= &perfctr_cntmode,
-        .maxlen     	= sizeof(int),
-        .mode       	= 0644,
-        .proc_handler   = &proc_dointvec,
-    },
-	{0}
-};
-
-ctl_table perfctr_sysctl_table[] = {
-	{
-		.ctl_name	= CTL_PERFCTR,
-		.procname	= "perfctr",
-		.mode		= 0555,
-		.child		= perfctr_cntmode_table,
-	},
-	{0}
-};
-
-static struct ctl_table_header *perfctr_sysctl_table_handle;
-
-static int __init perfctr_init(void)
-{
-	int err;
-
-	err = perfctr_cpu_init();
-	if (err) {
-		printk(KERN_INFO "perfctr: not supported by this processor\n");
-		return err;
-	}
-	err = vperfctr_init();
-	if (err)
-		return err;
-	err = perfctr_class_init();
-	if (err) {
-		printk(KERN_ERR "perfctr: class initialisation failed\n");
-		return err;
-	}
-	printk(KERN_INFO "perfctr: driver %s, cpu type %s at %u kHz\n",
-	       perfctr_info.driver_version,
-	       perfctr_cpu_name,
-	       perfctr_info.cpu_khz);
-
-	// code to create entries in the proc filesystem for perfctr count mode
-	if ( (perfctr_sysctl_table_handle = register_sysctl_table (perfctr_sysctl_table)) == NULL) {
-		printk (KERN_ERR "register_sysctl_table() for perfctr failed\n");
-		printk (KERN_INFO "perfctr count mode defaults to individual threads");
-	};
-
-	return 0;
-}
-
-static void __exit perfctr_exit(void)
-{
-	vperfctr_exit();
-	perfctr_cpu_exit();
-	unregister_sysctl_table(perfctr_sysctl_table_handle);
-}
-
-module_init(perfctr_init)
-module_exit(perfctr_exit)
diff --git a/drivers/perfctr/mips.c b/drivers/perfctr/mips.c
deleted file mode 100644
index 3f78ac3..0000000
--- a/drivers/perfctr/mips.c
+++ /dev/null
@@ -1,834 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* $Id: mips.c,v 1.1.2.9 2007-10-31 17:34:41 kmurthy Exp $
- * MIPS64 performance-monitoring counters driver.
- *
- * Copyright (C) 2004
- */
-#include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/fs.h>
-#include <linux/perfctr.h>
-#include <asm/time.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/perfctr.h>
-
-#include <asm/mipsregs.h>
-
-#include "mips_tests.h"
-
-// Support for lazy evntsel and perfctr control regiters updates.
-// good, I don't see any point in maintaing the values of the
-// counters.
-
-struct per_cpu_cache {    /* roughly a subset of perfctr_cpu_state */
-    union {
-        unsigned int id;    /* cache owner id */
-    } k1;
-
-    /* Physically indexed cache of control registers */
-    unsigned int ctrl_regs[2];
-};
-static DEFINE_PER_CPU(struct per_cpu_cache, per_cpu_cache);
-#define __get_cpu_cache(cpu) (&per_cpu(per_cpu_cache, cpu))
-#define get_cpu_cache()    (&__get_cpu_var(per_cpu_cache))
-
-/* Structure for counter snapshots, as 32-bit values. */
-struct perfctr_low_ctrs {
-    unsigned int tsc;
-    unsigned int pmc[2];
-};
-
-static int pm_type;
-
-static struct {
-	spinlock_t lock ____cacheline_aligned;
-	int current_thread;
-} pmc_resource[8];
-
-// Bits users shouldn't set in control registers
-// #define MIPS_XLR_PERFCTRL_RESERVED        0
-
-// returns a new id each time
-static unsigned int new_id(void)
-{
-    static spinlock_t lock = SPIN_LOCK_UNLOCKED;
-    static unsigned int counter;
-    int id;
-
-    spin_lock(&lock);
-    id = ++counter;
-    spin_unlock(&lock);
-    return id;
-}
-
-#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-
-static void perfctr_default_ihandler(unsigned long pc)
-{
-    // do nothing
-    return;
-}
-
-perfctr_ihandler_t perfctr_ihandler = perfctr_default_ihandler;
-
-void perfctr_cpu_set_ihandler(perfctr_ihandler_t ihandler)
-{
-    perfctr_ihandler = ihandler ? ihandler : perfctr_default_ihandler;
-}
-#else
-#define perfctr_cstatus_has_ictrs(cstatus)    0
-#endif
-
-#if defined(CONFIG_SMP) && defined(CONFIG_PERFCTR_INTERRUPT_SUPPORT)
-
-// to set the cpu on which the current thread is suspended
-// aids in telling if the control and PMC registers are warm
-
-static inline void
-set_isuspend_cpu(struct perfctr_cpu_state *state, int cpu)
-{
-    state->k1.isuspend_cpu = cpu;
-}
-
-static inline int
-is_isuspend_cpu(const struct perfctr_cpu_state *state, int cpu)
-{
-    return state->k1.isuspend_cpu == cpu;
-}
-
-static inline void clear_isuspend_cpu(struct perfctr_cpu_state *state)
-{
-    state->k1.isuspend_cpu = NR_CPUS;
-}
-
-#else
-static inline void set_isuspend_cpu(struct perfctr_cpu_state *state, int cpu) { }
-static inline int is_isuspend_cpu(const struct perfctr_cpu_state *state, int cpu) { return 1; }
-static inline void clear_isuspend_cpu(struct perfctr_cpu_state *state) { }
-#endif
-
-/****************************************************************
- *                                                                *
- * Driver procedures.                                            *
- *                                                                *
- ****************************************************************/
-
-/*
- * The MIPS familiy, currently only support for RMI XLR
- *
- * Common features
- * ---------------
- * - Per counter event selection data in subfields of control registers.
- * - Overflow interrupt support is present in all processors,
- * - The counter register available on a per-thread basis is used to
- *   to sample the TSC value  
- */
-
-inline unsigned int read_pmc(unsigned int pmc)
-{
-    switch (pmc) {
-        default: 
-        case 0:
-            return __read_32bit_c0_register($25, 1);
-        case 1:
-            return __read_32bit_c0_register($25, 3);
-    }
-}
-
-inline void write_pmc (unsigned int pmc, unsigned int value)
-{
-    switch (pmc) {
-        default: 
-        case 0:
-            __write_32bit_c0_register($25, 1, value);
-            break;
-        case 1:
-            __write_32bit_c0_register($25, 3, value);
-            break;
-    }
-}
-
-inline void write_pmctrl(unsigned int pmc, unsigned int value)
-{
-    switch (pmc) {
-        default: 
-        case 0:
-            __write_32bit_c0_register($25, 0, value);
-            break;
-        case 1:
-            __write_32bit_c0_register($25, 2, value);
-            break;
-    }
-}
-
-// when asked to read, we will have to read only if the thread
-// id in the control register corresponds to our's. What
-// do we do if the performance registers are configured to
-// record numbers for all the 4 threads. It would be better
-// if the user dictates whethere or not to pick the values.
-// provide a mechansim for the user to tell the same to the driver
-
-static void mips_read_counters(struct perfctr_cpu_state *state,
-                  struct perfctr_low_ctrs *ctrs)
-{
-    unsigned int cstatus, nrctrs, i;
-
-    cstatus = state->cstatus;
-    if (perfctr_cstatus_has_tsc(cstatus)) {
-        ctrs->tsc = read_c0_count();
-	}
-    nrctrs = perfctr_cstatus_nractrs(cstatus);
-    for(i = 0; i < nrctrs; ++i) {
-        unsigned int pmc = state->pmc[i].map;
-        ctrs->pmc[i] = read_pmc(pmc);
-    }
-}
-
-// The highest index of the event that one can specify
-
-/* static unsigned int pmc_max_event(unsigned int pmc)
-{
-    switch (pmc) {
-    default:
-    case 0:
-        return 63;
-    case 1:
-        return 63;
-    }
-} */
-
-static unsigned int get_nr_pmcs(void)
-{
-    switch (pm_type) {
-        case MIPS_XLR:
-            return 2;
-        default: /* MIPS_GENERIC, but silences gcc warning */
-            return 0;
-    }
-}
-
-static int mips_check_control(struct perfctr_cpu_state *state)
-{
-    unsigned int i, nractrs, nrctrs, pmc_mask, pmi_mask, pmc;
-    unsigned int nr_pmcs;
-
-    // ensuring that the total no of performance registers that
-    // are monitored are not more than available number
-    nr_pmcs = get_nr_pmcs();
-    nractrs = state->control.nractrs;
-    nrctrs = nractrs + state->control.nrictrs;    // we could have got this from cstatus. Isn't that so?
-    if ( (nrctrs < nractrs) || (nrctrs > nr_pmcs) )
-        return -EINVAL;
-
-    // ctrl_reg are the control registers, while .map contains
-    // the actual register number to use while reading and writing
-    pmc_mask = 0;
-    pmi_mask = 0;
-    // memset(ctrl_regs, 0, sizeof(ctrl_regs));
-
-    for(i = 0; i < nrctrs; ++i) {
-        pmc = state->control.pmc[i].map;    // for ppc, 0 <= pmc, the map value <= 5
-
-        // ok, here is where the user-specified values are being copied to the
-        // variables in the 'state' variable
-
-        state->pmc[i].map = pmc;
-
-        if (pmc >= nr_pmcs || (pmc_mask & (1<<pmc))) {
-            return -EINVAL;
-        }
-
-        pmc_mask |= (1<<pmc);
-        if (i >= nractrs) {
-            pmi_mask |= (1<<pmc);
-        }
-
-        // IMPORTANT: check that we haven't set the interrupt-enable bit for a-mode registers
-
-        // do some more sanity check that the user specifed valid control data
-        // if ( (ctrl_reg[pmc] & MIPS_XLR_EVNTSEL_RESERVED) != 0 )
-        //    return -EINVAL;
-
-        // what more sanity checks do we need ?
-    }
-
-    state->k1.id = new_id();
-
-    return 0;
-}
-
-#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-/* PRE: perfctr_cstatus_has_ictrs(state->cstatus) != 0 */
-/* PRE: counters frozen */
-
-// Suspend the collection of statistics in the performance registers
-// Both mips_isuspend() and mips_iresume() are for i-mode regs only
-
-static void mips_isuspend(struct perfctr_cpu_state *state)
-{
-    struct per_cpu_cache *cache;
-    unsigned int cstatus, nrctrs, i;
-    int cpu;
-
-    // it is on the cpu no 'cpu' that we suspended gathering statistics
-    cpu = smp_processor_id();
-
-    // what are we going to with the stored 'cpu' no? telling somone
-    // look this state was last suspended on cpu 'cpu'
-    set_isuspend_cpu(state, cpu); /* early to limit cpu's live range */
-
-    // what are we caching?
-    cache = __get_cpu_cache(cpu);
-    cstatus = state->cstatus;
-    nrctrs = perfctr_cstatus_nrctrs(cstatus);
-    for(i = perfctr_cstatus_nractrs(cstatus); i < nrctrs; ++i) {
-        unsigned int pmc, now;
-
-        pmc = state->pmc[i].map;
-
-        // instead of setting the freeze bits, just zero out the whole reg
-        cache->ctrl_regs[pmc] = 0;
-        write_pmctrl(pmc, cache->ctrl_regs[pmc]);
-
-        now = read_pmc(pmc);
-        state->pmc[i].sum += now - state->pmc[i].start;
-        state->pmc[i].start = now;
-    }
-    /* cache->k1.id is still == state->k1.id */
-
-    // sampled the i-mode registers
-}
-
-static void mips_iresume(const struct perfctr_cpu_state *state)
-{
-    struct per_cpu_cache *cache;
-    unsigned int cstatus, nrctrs, i;
-    int cpu;
-
-    cpu = smp_processor_id();
-    cache = __get_cpu_cache(cpu);
-
-    if (cache->k1.id == state->k1.id) {
-        // we need to do this and force reload of control registers
-        // to unfreeze control registers
-        cache->k1.id = 0; 
-
-        // if no one else was scheduled after we were suspended,
-        // the regiseters are still warm, actually hot and don't
-        // have to reload them. Is that right ?
-
-        // we are being rescheduled on the same processor
-        if (is_isuspend_cpu(state, cpu))
-            return; /* skip reload of PMCs */
-    }
-
-    // The CPU state wasn't ours.
-    // The counters must be frozen before being reinitialised,
-    // to prevent unexpected increments and missed overflows.
-
-    // At this point, only the i-mode registers are frozen. Is there
-    // any reason to freeze a-mode counters ?!
-
-    // All unused counters must be reset to a non-overflow state.
-    // accumulation mode registers are reset to zero, while the i-mode
-    // registers are being written from state->pmc[i].start. The field
-    // state->pmc[].start for i-mode registers was set to the values
-    // specified in the .ireset field in the function ...
-
-    cstatus = state->cstatus;
-    nrctrs = perfctr_cstatus_nrctrs(cstatus);
-    for(i = perfctr_cstatus_nractrs(cstatus); i < nrctrs; ++i) {
-        unsigned int map = state->pmc[i].map;
-
-        cache->ctrl_regs[map] = 0;
-        write_pmctrl(map, 0); // zero value
-        write_pmc(map, state->pmc[i].start);
-    }
-    // cache->k1.id remains != state->k1.id
-}
-#endif
-
-// this is invoked by the _resume() routine. If the id in the cache
-// equals to our id, it implies no one else touched the control
-// registers of this id and hence need not be written all over again
-// however this is not a good idea when control registers have to
-// be written to for some reason, such as when the control registers
-// have to unfrozen and so on. This is done by settind the id in the
-// cache to 0. The cache id is updated with the id of the verpfctr
-// id when a new state is schduled to collect statistics on this cpu
-
-int perfctr_cntmode = 0;
-
-static void mips_write_control(const struct perfctr_cpu_state *state)
-{
-    struct per_cpu_cache *cache;
-    unsigned int nrctrs, i;
-
-    // cache stores the information pertaining to one id. Under
-    // what conditions does that cache state remain intact? Can some
-    // processes tell that their statistics be not recorded. In such
-    // a case when a thread is rescheuldes on the same processpor
-    // without the intervening thread recording the statistics, then
-    // the cache will be hot
-
-    cache = get_cpu_cache();
-    if (cache->k1.id == state->k1.id) {
-        return;
-    }
-    nrctrs = perfctr_cstatus_nrctrs(state->cstatus);
-
-	preempt_disable();
-    for (i = 0; i < nrctrs; ++i) {
-        unsigned int ctrl_reg = state->control.pmc[i].ctrl_reg;
-        unsigned int pmc = state->pmc[i].map;    // assuming that the 'state' values have been
-                                                 // updated from control values specified by users
-        if (ctrl_reg != cache->ctrl_regs[pmc]) {
-			if (!perfctr_cntmode) {
-				MIPS_XLR_UNSET_CNT_ALL_THREADS(ctrl_reg);
-				MIPS_XLR_SET_THREADID(ctrl_reg, netlogic_thr_id());
-			}
-			else {
-				MIPS_XLR_SET_CNT_ALL_THREADS(ctrl_reg);
-			}
-            cache->ctrl_regs[pmc] = ctrl_reg;
-            write_pmctrl(pmc, ctrl_reg);
-        }
-    }
-    cache->k1.id = state->k1.id;
-	preempt_enable();
-}
-
-static void mips_clear_counters(void)
-{
-    switch (pm_type) {
-        case MIPS_XLR:
-            __write_32bit_c0_register($25, 0, 0);
-            __write_32bit_c0_register($25, 1, 0);
-            __write_32bit_c0_register($25, 2, 0);
-            __write_32bit_c0_register($25, 3, 0);
-        case MIPS_GENERIC:
-            ;
-    }
-}
-
-// Driver methods, internal and exported.
-
-static inline void perfctr_cpu_write_control(const struct perfctr_cpu_state *state)
-{
-    return mips_write_control(state);
-}
-
-static inline void perfctr_cpu_read_counters(struct perfctr_cpu_state *state,
-                      struct perfctr_low_ctrs *ctrs)
-{
-    return mips_read_counters(state, ctrs);
-}
-
-#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-static inline void perfctr_cpu_isuspend(struct perfctr_cpu_state *state)
-{
-    return mips_isuspend(state);
-}
-
-static inline void perfctr_cpu_iresume(const struct perfctr_cpu_state *state)
-{
-    return mips_iresume(state);
-}
-
-/* Call perfctr_cpu_ireload() just before perfctr_cpu_resume() to
-   bypass internal caching and force a reload if the I-mode PMCs. */
-void perfctr_cpu_ireload(struct perfctr_cpu_state *state)
-{
-#ifdef CONFIG_SMP
-    clear_isuspend_cpu(state);
-#else
-    get_cpu_cache()->k1.id = 0;
-#endif
-}
-
-/* PRE: the counters have been suspended and sampled by perfctr_cpu_suspend() */
-// the following overflow check is being done only for the i-mode registers
-// how is the overflow of a-mode registers handled ?
-inline unsigned int perfctr_cpu_identify_overflow(struct perfctr_cpu_state *state)
-{
-    unsigned int cstatus, nrctrs, i, pmc_mask;
-
-    cstatus = state->cstatus;
-    i = perfctr_cstatus_nractrs(cstatus);    // a-mode count
-    nrctrs = perfctr_cstatus_nrctrs(cstatus);
-
-    for(pmc_mask = 0; i < nrctrs; ++i) {
-
-        // Ok, reset the overflown i-mode counters
-
-        if ((int)state->pmc[i].start < 0) { /* MIPS-specific */
-            /* XXX: "+=" to correct for overshots */
-            state->pmc[i].start = state->control.pmc[i].ireset;
-            pmc_mask |= (1 << i);
-        }
-    }
-    return pmc_mask;
-}
-
-static inline int check_ireset(const struct perfctr_cpu_state *state)
-{
-    unsigned int nrctrs, i;
-
-    i = state->control.nractrs;
-    nrctrs = i + state->control.nrictrs;
-    for(; i < nrctrs; ++i) {
-        if (state->control.pmc[i].ireset < 0)    /* MIPS-specific */ {
-            return -EINVAL;
-        }
-    }
-    return 0;
-}
-
-// the start values have to be reset as we might have changed then in
-// _isuspend()
-static inline void setup_imode_start_values(struct perfctr_cpu_state *state)
-{
-    unsigned int cstatus, nrctrs, i;
-
-    cstatus = state->cstatus;
-    nrctrs = perfctr_cstatus_nrctrs(cstatus);
-    for(i = perfctr_cstatus_nractrs(cstatus); i < nrctrs; ++i)
-        state->pmc[i].start = state->control.pmc[i].ireset;
-}
-
-#else    /* CONFIG_PERFCTR_INTERRUPT_SUPPORT */
-static inline void perfctr_cpu_isuspend(struct perfctr_cpu_state *state) { }
-static inline void perfctr_cpu_iresume(const struct perfctr_cpu_state *state) { }
-static inline int check_ireset(const struct perfctr_cpu_state *state) { return 0; }
-static inline void setup_imode_start_values(struct perfctr_cpu_state *state) { }
-#endif    /* CONFIG_PERFCTR_INTERRUPT_SUPPORT */
-
-static int check_control(struct perfctr_cpu_state *state)
-{
-    return mips_check_control(state);
-}
-
-int perfctr_cpu_update_control(struct perfctr_cpu_state *state, int is_global)
-{
-    int err;
-
-    // since we updated the control, we invalidate the cpu id in the state
-    // so that we can force reload of control registers
-    clear_isuspend_cpu(state);
-    state->cstatus = 0;
-
-    /* disallow i-mode counters if we cannot catch the interrupts */
-    if (!(perfctr_info.cpu_features & PERFCTR_FEATURE_PCINT)
-        && state->control.nrictrs) {
-        
-        return -EPERM;
-    }
-
-    err = check_ireset(state);
-    if (err < 0) {
-        return err;
-    }
-    err = check_control(state); /* may initialise state->cstatus */
-    if (err < 0) {
-        return err;
-    }
-
-    // Ok, while the map values and the start values for i-mode counters
-    // are updated in the above function check_control() and the following
-    // function setup_imode_start_values(), the 'cstatus' values is set here
-
-    // how do u ensure that all i-mode registers are specified beyond a-mode
-    // registers
-    state->cstatus |= perfctr_mk_cstatus(state->control.tsc_on,
-                         state->control.nractrs,
-                         state->control.nrictrs);
-    setup_imode_start_values(state);
-    return 0;
-}
-
-inline void perfctr_cpu_suspend(struct perfctr_cpu_state *state)
-{
-    unsigned int i, cstatus, nractrs;
-    struct perfctr_low_ctrs now;
-	int   cpu_id;
-
-	cpu_id = hard_smp_processor_id() / 4;
-	spin_lock (&pmc_resource[cpu_id].lock);
-	if ( pmc_resource[cpu_id].current_thread != netlogic_thr_id() ) {
-		// printk (KERN_INFO "PMCounters do not belong to this process[%d]\n", current->pid);
-		spin_unlock (&pmc_resource[cpu_id].lock);
-		return;
-	}
-	pmc_resource[cpu_id].current_thread = -1;
-	spin_unlock (&pmc_resource[cpu_id].lock);
-
-    // To prevent polluting the numbers, can we freeze the counters
-    // here, as early as possible ?
-
-    if (perfctr_cstatus_has_ictrs(state->cstatus)) {
-        perfctr_cpu_isuspend(state);
-	}
-    perfctr_cpu_read_counters(state, &now);
-    cstatus = state->cstatus;
-    if (perfctr_cstatus_has_tsc(cstatus)) {
-        state->tsc_sum += now.tsc - state->tsc_start;
-    }
-    nractrs = perfctr_cstatus_nractrs(cstatus);
-    for(i = 0; i < nractrs; ++i) {
-        state->pmc[i].sum += now.pmc[i] - state->pmc[i].start;
-    }
-}
-
-inline void perfctr_cpu_resume(struct perfctr_cpu_state *state)
-{
-	int   cpu_id;
-
-	cpu_id = hard_smp_processor_id() / 4;
-	spin_lock (&pmc_resource[cpu_id].lock);
-	if ( pmc_resource[cpu_id].current_thread != -1 ) {
-		// printk (KERN_INFO "PMCounters unavailable for process %d\n", current->pid);
-		spin_unlock (&pmc_resource[cpu_id].lock);
-		return;
-	}
-	pmc_resource[cpu_id].current_thread = netlogic_thr_id();
-	spin_unlock (&pmc_resource[cpu_id].lock);
-
-    if (perfctr_cstatus_has_ictrs(state->cstatus)) {
-        perfctr_cpu_iresume(state);
-	}
-
-    // the counters are triggered, having been frozen in _iresume()
-    // that preceded this point. So, the model is to trigger the
-    // registere to collect the numbers and record the start state
-    // that completes the 'resume' process.
-
-    perfctr_cpu_write_control(state);
-    {
-        struct perfctr_low_ctrs now;
-        unsigned int i, cstatus, nrctrs;
-        perfctr_cpu_read_counters(state, &now);
-        cstatus = state->cstatus;
-
-        // the start state of the registers has to be recorded only
-        // in resume() and that is what is being done.
-
-        if (perfctr_cstatus_has_tsc(cstatus)) {
-            state->tsc_start = now.tsc;
-		}
-        nrctrs = perfctr_cstatus_nractrs(cstatus);
-        for (i = 0; i < nrctrs; ++i) {
-            state->pmc[i].start = now.pmc[i];
-		}
-    }
-    /* XXX: if (SMP && start.tsc == now.tsc) ++now.tsc; */
-}
-
-// Sampling only a-mode registers
-void perfctr_cpu_sample(struct perfctr_cpu_state *state)
-{
-    unsigned int i, cstatus, nractrs;
-    struct perfctr_low_ctrs now;
-	int   cpu_id;
-
-	cpu_id = hard_smp_processor_id() / 4;
-	spin_lock (&pmc_resource[cpu_id].lock);
-	if ( pmc_resource[cpu_id].current_thread != netlogic_thr_id() ) {
-		// printk (KERN_INFO "PMCounters do not belong to this process[%d]\n", current->pid);
-		spin_unlock (&pmc_resource[cpu_id].lock);
-		return;
-	}
-	spin_unlock (&pmc_resource[cpu_id].lock);
-
-    perfctr_cpu_read_counters(state, &now);        // reads only a-mode registers
-    cstatus = state->cstatus;
-    if (perfctr_cstatus_has_tsc(cstatus)) {
-        state->tsc_sum += now.tsc - state->tsc_start;
-        // one needs to update the start status as we continue to gather
-        // statistics without interruption
-        state->tsc_start = now.tsc;
-    }
-    nractrs = perfctr_cstatus_nractrs(cstatus);
-    for(i = 0; i < nractrs; ++i) {
-		
-        state->pmc[i].sum += now.pmc[i] - state->pmc[i].start;
-        state->pmc[i].start = now.pmc[i];
-    }
-}
-
-static void perfctr_cpu_clear_counters(void)
-{
-    struct per_cpu_cache *cache;
-
-    cache = get_cpu_cache();
-    memset(cache, 0, sizeof *cache);
-    cache->k1.id = -1;
-
-    mips_clear_counters();
-}
-
-/****************************************************************
- *                                                            *
- * Processor detection and initialisation procedures.        *
- *                                                            *
- ****************************************************************/
-
-cpumask_t perfctr_cpus_forbidden_mask;
-
-static inline void clear_perfctr_cpus_forbidden_mask(void)
-{
-#if !defined(perfctr_cpus_forbidden_mask)
-    cpus_clear(perfctr_cpus_forbidden_mask);
-#endif
-}
-
-static inline void set_perfctr_cpus_forbidden_mask(cpumask_t mask)
-{
-#if !defined(perfctr_cpus_forbidden_mask)
-    perfctr_cpus_forbidden_mask = mask;
-#endif
-}
-
-static void __init mips_setup_cpu_mask(void *forbidden)
-{
-    unsigned int logical_processor_id = hard_smp_processor_id();
-    if ((logical_processor_id % 4) != 0) {
-        // We rely on cpu_set() being atomic!
-        cpu_set(logical_processor_id, *(cpumask_t*)forbidden);
-    }
-}
-
-static int __init mips_smp_init(void)
-{
-    cpumask_t forbidden;
-    unsigned int cpu;
-
-    cpus_clear(forbidden);
-#ifdef CONFIG_SMP
-    smp_call_function(mips_setup_cpu_mask, &forbidden, 1);
-#endif
-    mips_setup_cpu_mask(&forbidden);
-    if (cpus_empty(forbidden))
-        return 0;
-    perfctr_cpus_forbidden_mask = forbidden;
-    for(cpu = 0; cpu < NR_CPUS; ++cpu)
-        if (cpu_isset(cpu, forbidden))
-            printk(" %u", cpu);
-        printk("\n");
-    return 0;
-}
-
-static void perfctr_cpu_clear_one(void *ignore)
-{
-    // cache too is also getting invalidated in the following routine
-    perfctr_cpu_clear_counters();
-}
-
-static int init_done;
-
-int __init perfctr_cpu_init(void)
-{
-    int i, err = 0;
-
-    preempt_disable();
-    
-    mips_smp_init();
-
-    // The  first two fields of the structure 'perfctr_info' are defined/assigned
-    // in the declaration itself
-    perfctr_info.cpu_type = pm_type = MIPS_XLR;
-    perfctr_info.cpu_features |= PERFCTR_FEATURE_PCINT;
-    perfctr_info.cpu_khz = mips_hpt_frequency;
-    perfctr_info.tsc_to_cpu_mult = 1;
-
-    /* for 2.7 versions only. This variable is not visible to users. */
-    perfctr_cpu_name = "MIPS_XLR";
-
-    perfctr_mips_init_tests();
-
-	// Init Spinlocks and the current thead of PMC registers
-	for (i = 0; i < 8; ++i) {
-		spin_lock_init(&pmc_resource[i].lock);
-		pmc_resource[i].current_thread = -1;
-	}
-
-	init_done = 1;
-    preempt_enable();
-    return err;
-}
-
-void __exit perfctr_cpu_exit(void)
-{
-}
-
-/****************************************************************
- *                                                                *
- * Hardware reservation.                                        *
- *                                                                *
- ****************************************************************/
-
-static DECLARE_MUTEX(mutex);
-static const char *current_service = 0;
-
-const char *perfctr_cpu_reserve(const char *service)
-{
-    const char *ret;
-	int i;
-
-    if (!init_done)
-        return "unsupported hardware";
-    down(&mutex);
-    ret = current_service;
-    if (ret)
-        goto out_up;
-    current_service = service;
-    on_each_cpu(perfctr_cpu_clear_one, NULL, 1);
-
-	// Ideally at this point of time, all the current thread values of
-	// pmc_resource must be -1
-	for (i = 0; i < 8; ++i) {
-		if (pmc_resource[i].current_thread != -1) {
-			printk (KERN_INFO "pmc_resource[%d].current_thread != -1\n", i);
-		}
-		pmc_resource[i].current_thread = -1;
-	}
-
-    perfctr_cpu_set_ihandler(NULL);
-    ret = NULL;
-out_up:
-    up(&mutex);
-    return ret;
-}
-
-void perfctr_cpu_release(const char *service)
-{
-	int i;
-
-    down(&mutex);
-    if (service != current_service) {
-        printk(KERN_ERR "%s: attempt by %s to release while reserved by %s\n", __FUNCTION__, service, current_service);
-        goto out_up;
-    } else {
-        /* power down the counters */
-        on_each_cpu(perfctr_cpu_clear_one, NULL, 1);
-        perfctr_cpu_set_ihandler(NULL);
-        current_service = 0;
-
-		// Ideally at this point of time, all the current thread values of
-		// pmc_resource must be -1
-		for (i = 0; i < 8; ++i) {
-			if (pmc_resource[i].current_thread != -1) {
-				printk (KERN_INFO "pmc_resource[%d].current_thread != -1\n", i);
-			}
-			pmc_resource[i].current_thread = -1;
-		}
-    }
-out_up:
-    up(&mutex);
-}
diff --git a/drivers/perfctr/mips.h b/drivers/perfctr/mips.h
deleted file mode 100644
index 111676d..0000000
--- a/drivers/perfctr/mips.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-#ifndef __PerfMonCtrs_MIPS_H
-#define __PerfMonCtrs_MIPS_H
-
-#define PMC_KERNEL_MODE		0x2
-#define PMC_SUP_MODE		0x4
-#define PMC_USERL_MODE		0x8
-
-#define PMC_SET_EVNTCNT_MODE(x, mode)		x |= mode
-#define PMC_UNSET_EVNTCNT_MODE(x, mode)		x &= ~mode
-
-#define PMC_ENABLE_ITRPT(x)				x |= 0x10
-#define PMC_DISABLE_ITRPT(x)			x &= ~0x10
-
-#define PMC_EVNTSEL_MASK			0x3f
-#define PMC_EVNTSEL_SHIFT			5
-#define PMC_SET_EVNT(x, event)		x |= ((event & PMC_EVNTSEL_MASK) << PMC_EVNTSEL_SHIFT)
-
-#define PMC_THREADID_MASK			0x03
-#define PMC_THREADID_SHIFT			11
-#define PMC_SET_THREADID(x, tid)	x |= ((tid & PMC_EVNTSEL_MASK) << PMC_EVNTSEL_SHIFT)
-
-#define PMC_SET_CNT_ALL_THREADS(x)		x |= 0x2000
-#define PMC_UNSET_CNT_ALL_THREADS(x)	x &= ~0x2000
-
-#define PMC_INSTRS_FETCHED			0
-#define PMC_INSTR_CACHE_MISSES		1
-
-#define PMC_INSTR_CACHE_PARITY_ERRS		6
-#define PMC_INSTR_MICRO_TLB_MISSES		8
-
-#define PMC_INSTRS_RETIRED			17
-#define PMC_BRANCH_INSTRS			18
-
-#define PMC_CYCLE_CNT				63
-
-#endif
diff --git a/drivers/perfctr/mips_tests.c b/drivers/perfctr/mips_tests.c
deleted file mode 100644
index 20fc192..0000000
--- a/drivers/perfctr/mips_tests.c
+++ /dev/null
@@ -1,217 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* $Id: mips_tests.c,v 1.1.2.6 2007-10-31 17:34:41 kmurthy Exp $
- * Performance-monitoring counters driver.
- * Optional PPC32-specific init-time tests.
- *
- * Copyright (C) 2004  Mikael Pettersson
- */
-#include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/fs.h>
-#include <linux/perfctr.h>
-#include <asm/processor.h>
-#include <asm/time.h>
-#include <asm/mipsregs.h>
-#include <asm/perfctr.h>
-#include "mips_tests.h"
-
-#define NITER	256
-#define X2(S)	S"; "S
-#define X8(S)	X2(X2(X2(S)))
-
-static void __init do_read_tsc(unsigned int unused)
-{
-	unsigned int i, dummy;
-	__asm__ __volatile__ (".set mips32\n\t");
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__(X8("mfc0 %0, $9, 0") : "=r" (dummy));
-	__asm__ __volatile__ (".set mips0\n\t");
-}
-
-static void __init do_read_pmc1(unsigned int unused)
-{
-	unsigned int i, dummy;
-	__asm__ __volatile__ (".set mips32\n\t");
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__(X8("mfc0 %0, $25, 1") : "=r" (dummy));
-	__asm__ __volatile__ (".set mips0\n\t");
-}
-
-static void __init do_read_pmc2(unsigned int unused)
-{
-	unsigned int i, dummy;
-	__asm__ __volatile__ (".set mips32\n\t");
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__(X8("mfc0 %0, $25, 3") : "=r" (dummy));
-	__asm__ __volatile__ (".set mips0\n\t");
-}
-
-static void __init do_read_ctrl1(unsigned int unused)
-{
-	unsigned int i, dummy;
-	__asm__ __volatile__ (".set mips32\n\t");
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__(X8("mfc0 %0, $25, 0") : "=r" (dummy));
-	__asm__ __volatile__ (".set mips0\n\t");
-}
-
-static void __init do_read_ctrl2(unsigned int unused)
-{
-	unsigned int i, dummy;
-	__asm__ __volatile__ (".set mips32\n\t");
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__(X8("mfc0 %0, $25, 2") : "=r" (dummy));
-	__asm__ __volatile__ (".set mips0\n\t");
-}
-
-static void __init do_write_pmc1(unsigned int arg)
-{
-	unsigned int i;
-	__asm__ __volatile__ (".set mips32\n\t");
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__(X8("mtc0 %z0, $25, 1") : : "Jr" ((unsigned int)arg));
-	__asm__ __volatile__ (".set mips0\n\t");
-}
-
-static void __init do_write_pmc2(unsigned int arg)
-{
-	unsigned int i;
-	__asm__ __volatile__ (".set mips32\n\t");
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__(X8("mtc0 %z0, $25, 3") : : "Jr" ((unsigned int)arg));
-	__asm__ __volatile__ (".set mips0\n\t");
-}
-
-static void __init do_write_ctrl1(unsigned int arg)
-{
-	unsigned int i;
-	__asm__ __volatile__ (".set mips32\n\t");
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__(X8("mtc0 %z0, $25, 0") : : "Jr" ((unsigned int)arg));
-	__asm__ __volatile__ (".set mips0\n\t");
-}
-
-static void __init do_write_ctrl2(unsigned int arg)
-{
-	unsigned int i;
-	__asm__ __volatile__ (".set mips32\n\t");
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__(X8("mtc0 %z0, $25, 2") : : "Jr" ((unsigned int)arg));
-	__asm__ __volatile__ (".set mips0\n\t");
-}
-
-static void __init do_empty_loop(unsigned int unused)
-{
-	unsigned i;
-	for(i = 0; i < NITER/8; ++i)
-		__asm__ __volatile__("" : : );
-}
-
-static unsigned __init run(void (*doit)(unsigned int), unsigned int arg)
-{
-	unsigned int start, stop;
-	start = __read_32bit_c0_register ($25, 1);
-	(*doit)(arg);	/* should take < 2^32 cycles to complete */
-	stop = __read_32bit_c0_register ($25, 1);
-	return (stop - start);
-}
-
-static void __init init_tests_message(void)
-{
-	printk(KERN_INFO "Please email the following PERFCTR INIT lines "
-	       "to mikpe@csd.uu.se\n"
-	       KERN_INFO "To remove this message, rebuild the driver "
-	       "with CONFIG_PERFCTR_INIT_TESTS=n\n");
-	printk(KERN_INFO "PERFCTR INIT: CPU clock %u kHz\n", perfctr_info.cpu_khz);
-}
-
-static void __init clear(void)
-{
-	__write_32bit_c0_register($25, 0, 0);
-	__write_32bit_c0_register($25, 1, 0);
-	__write_32bit_c0_register($25, 2, 0);
-	__write_32bit_c0_register($25, 3, 0);
-}
-
-static void __init measure_overheads(void)
-{
-	int i;
-	unsigned int loop, ticks[9];
-	const char *name[9];
-	unsigned int ctrl1, ctrl2;
-
-	/* PMC1 = "processor cycles", PMC2 = "completed instructions",
-	   not disabled in any mode, no interrupts */
-
-	clear();
-
-	//setup control register 1 and 2
-
-	ctrl1 = ctrl2 = 0;
-
-	ctrl1 |= MIPS_XLR_DOM_KERNEL | MIPS_XLR_DOM_USR;
-	MIPS_XLR_OVF_PMI_DABLE(ctrl1);
-	MIPS_XLR_SET_CNT_ALL_THREADS(ctrl1);
-	MIPS_XLR_SET_EVNT(ctrl1, 63); // CYCLE_CNT
-
-	ctrl2 |= MIPS_XLR_DOM_KERNEL | MIPS_XLR_DOM_USR;
-	MIPS_XLR_OVF_PMI_DABLE(ctrl2);
-	MIPS_XLR_SET_CNT_ALL_THREADS(ctrl2);
-	MIPS_XLR_SET_EVNT(ctrl2, 0); // INSTRS FETCHED
-
-	__write_32bit_c0_register($25, 0, ctrl1);
-	__write_32bit_c0_register($25, 2, ctrl2);
-
- 	name[0] = "read (tsc)";
-	ticks[0] = run(do_read_tsc, 0);
-
-	name[1] = "read (pmc0)";
-	ticks[1] = run(do_read_pmc1, 0);
-	name[2] = "read (pmc1)";
-	ticks[2] = run(do_read_pmc2, 0);
-
-	name[3] = "read (ctrl0)";
-	ticks[3] = run(do_read_ctrl1, 0);
-	name[4] = "read (ctrl1)";
-	ticks[4] = run(do_read_ctrl2, 0);
-
-	name[5] = "write (pmc1)";
-	ticks[5] = run(do_write_pmc1, 0);
-	name[6] = "write (pmc2)";
-	ticks[6] = run(do_write_pmc2, 0);
-
-	name[7] = "write (ctrl1)";
-	ticks[7] = run(do_write_ctrl1, ctrl1);
-	name[8] = "write (ctrl2)";
-	ticks[8] = run(do_write_ctrl2, ctrl2);
-
-	loop = run(do_empty_loop, 0);
-
-	clear();
-
-	init_tests_message();
-	printk(KERN_INFO "PERFCTR INIT: NITER == %u\n", NITER);
-	printk(KERN_INFO "PERFCTR INIT: loop overhead is %u cycles\n", loop);
-	for(i = 0; i < ARRAY_SIZE(ticks); ++i) {
-		unsigned int x;
-		if (!ticks[i])
-			continue;
-		x = ((ticks[i] - loop) * 10) / NITER;
-		printk(KERN_INFO "PERFCTR INIT: %s cost is %u.%u cycles (%u total)\n",
-		       name[i], x/10, x%10, ticks[i]);
-	}
-}
-
-void __init perfctr_mips_init_tests()
-{
-	preempt_disable();
-	measure_overheads();
-	preempt_enable();
-}
diff --git a/drivers/perfctr/mips_tests.h b/drivers/perfctr/mips_tests.h
deleted file mode 100644
index a5ffa1e..0000000
--- a/drivers/perfctr/mips_tests.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* $Id: mips_tests.h,v 1.1.2.3 2006-09-28 01:24:17 nphilips Exp $
- * Performance-monitoring counters driver.
- * Optional PPC32-specific init-time tests.
- *
- * Copyright (C) 2004  Mikael Pettersson
- */
-
-#ifdef CONFIG_PERFCTR_INIT_TESTS
-extern void perfctr_mips_init_tests(void);
-#else
-static inline void perfctr_mips_init_tests(void) { };
-#endif
diff --git a/drivers/perfctr/pmc.h b/drivers/perfctr/pmc.h
deleted file mode 100644
index d3da89b..0000000
--- a/drivers/perfctr/pmc.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-#ifndef __PERFCTR_PMC_H
-#define __PERFCTR_PMC_H
-
-#define PMC_KERNEL_MODE		0x2
-#define PMC_SUP_MODE		0x4
-#define PMC_USER_MODE		0x8
-
-#define PMC_SET_EVNTCNT_MODE(x, mode)		x |= mode
-#define PMC_UNSET_EVNTCNT_MODE(x, mode)		x &= ~mode
-
-#define PMC_ENABLE_ITRPT(x)					x |= 0x10
-#define PMC_DISABLE_ITRPT(x)				x &= ~0x10
-
-#define PMC_EVNTSEL_MASK			0x3f
-#define PMC_EVNTSEL_SHIFT			5
-#define PMC_SET_EVNT(x, event)		x |= ((event & PMC_EVNTSEL_MASK) << PMC_EVNTSEL_SHIFT)
-#define PMC_GET_EVNT(x)				((x >> PMC_EVNTSEL_SHIFT) & PMC_EVNTSEL_MASK)
-
-#define PMC_THREADID_MASK				0x03
-#define PMC_THREADID_SHIFT				11
-#define PMC_SET_THREADID(x, tid)		x |= ((tid & PMC_EVNTSEL_MASK) << PMC_EVNTSEL_SHIFT)
-
-#define PMC_SET_CNT_ALL_THREADS(x)		x |= 0x2000
-#define PMC_UNSET_CNT_ALL_THREADS(x)	x &= ~0x2000
-
-#endif
diff --git a/drivers/perfctr/version.h b/drivers/perfctr/version.h
deleted file mode 100644
index 0e3edbd..0000000
--- a/drivers/perfctr/version.h
+++ /dev/null
@@ -1,9 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-#define VERSION "2.7.9"
diff --git a/drivers/perfctr/virtual.c b/drivers/perfctr/virtual.c
deleted file mode 100644
index 2fd8fee..0000000
--- a/drivers/perfctr/virtual.c
+++ /dev/null
@@ -1,1356 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* $Id: virtual.c,v 1.1.2.8 2007-11-15 13:42:01 kmurthy Exp $
- * Virtual per-process performance counters.
- *
- * Copyright (C) 1999-2004  Mikael Pettersson
- */
-#include <linux/init.h>
-#include <linux/compiler.h>	/* for unlikely() in 2.4.18 and older */
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/ptrace.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/perfctr.h>
-#include <linux/nsproxy.h>
-
-#include <asm/io.h>
-#include <asm/uaccess.h>
-
-#include "cpumask.h"
-#include "virtual.h"
-#include "compat.h"
-
-// #define __DEBUG__ 1
-
-/****************************************************************
- * Data types and macros.					*
- ****************************************************************/
-
-struct vperfctr {
-	/* User-visible fields: (must be first for mmap()) */
-	struct perfctr_cpu_state cpu_state;
-	
-	/* Kernel-private fields: */
-	int si_signo;
-	atomic_t count;
-	spinlock_t owner_lock;
-	struct task_struct *owner;
-
-	/* sampling_timer and bad_cpus_allowed are frequently
-	   accessed, so they get to share a cache line 
-	*/
-	unsigned int sampling_timer ____cacheline_aligned;
-
-	#ifdef CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK
-	atomic_t bad_cpus_allowed;
-	#endif
-
-	#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-	unsigned int iresume_cstatus;
-	#endif
-
-	/* children_lock protects inheritance_id and children,
-	   when parent is not the one doing release_task() 
-	*/
-	spinlock_t children_lock;
-	unsigned long long inheritance_id;
-	struct perfctr_sum_ctrs children;
-
-	/* schedule_work() data for when an operation cannot be
-	   done in the current context due to locking rules 
-	*/
-	struct work_struct work;
-	struct task_struct *parent_tsk;
-};
-
-#define IS_RUNNING(perfctr)	perfctr_cstatus_enabled((perfctr)->cpu_state.cstatus)
-
-#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-
-static void vperfctr_ihandler(unsigned long pc);
-static inline void vperfctr_handle_overflow(struct task_struct*, struct vperfctr*);
-
-static inline void vperfctr_set_ihandler(void)
-{
-	perfctr_cpu_set_ihandler(vperfctr_ihandler);
-}
-
-static inline void vperfctr_clear_iresume_cstatus(struct vperfctr *perfctr)
-{
-	perfctr->iresume_cstatus = 0;
-}
-
-#else
-static inline void vperfctr_set_ihandler(void) { }
-static inline void vperfctr_clear_iresume_cstatus(struct vperfctr *perfctr) { }
-#endif
-
-#ifdef CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK
-
-static inline void vperfctr_init_bad_cpus_allowed(struct vperfctr *perfctr)
-{
-	atomic_set(&perfctr->bad_cpus_allowed, 0);
-}
-
-#else	/* !CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK */
-static inline void vperfctr_init_bad_cpus_allowed(struct vperfctr *perfctr) { }
-#endif	/* !CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK */
-
-/****************************************************************
- *																*
- * Resource management.											*
- *																*
- ****************************************************************/
-
-/* XXX: perhaps relax this to number of _live_ perfctrs */
-static DECLARE_MUTEX(nrctrs_mutex);
-static int nrctrs;
-static const char this_service[] = __FILE__;
-
-static int inc_nrctrs(void)
-{
-	const char *other;
-
-	other = NULL;
-	down(&nrctrs_mutex);
-	if (++nrctrs == 1) {
-		other = perfctr_cpu_reserve(this_service);
-		if (other)
-			nrctrs = 0;
-	}
-	up(&nrctrs_mutex);
-	if (other) {
-		printk(KERN_ERR __FILE__ ": cannot operate, perfctr hardware taken by '%s'\n", other);
-		return -EBUSY;
-	}
-	vperfctr_set_ihandler();
-	return 0;
-}
-
-static void dec_nrctrs(void)
-{
-	down(&nrctrs_mutex);
-	if (--nrctrs == 0)
-		perfctr_cpu_release(this_service);
-	up(&nrctrs_mutex);
-}
-
-/* Allocate a `struct vperfctr'. Claim and reserve
-   an entire page so that it can be mmap():ed. */
-static struct vperfctr *vperfctr_alloc(void)
-{
-	unsigned long page;
-
-	if (inc_nrctrs() != 0)
-		return ERR_PTR(-EBUSY);
-	page = get_zeroed_page(GFP_KERNEL);
-	if (!page) {
-		dec_nrctrs();
-		return ERR_PTR(-ENOMEM);
-	}
-	SetPageReserved(virt_to_page((void *)(page)));
-	return (struct vperfctr*) page;
-}
-
-static void vperfctr_free(struct vperfctr *perfctr)
-{
-	ClearPageReserved(virt_to_page(perfctr));
-	free_page((unsigned long)perfctr);
-	dec_nrctrs();
-}
-
-static struct vperfctr *get_empty_vperfctr(void)
-{
-	struct vperfctr *perfctr = vperfctr_alloc();
-	if (!IS_ERR(perfctr)) {
-		atomic_set(&perfctr->count, 1);
-		vperfctr_init_bad_cpus_allowed(perfctr);
-		spin_lock_init(&perfctr->owner_lock);
-		spin_lock_init(&perfctr->children_lock);
-	}
-	return perfctr;
-}
-
-static void put_vperfctr(struct vperfctr *perfctr)
-{
-	// returns true if the value after decrement is zero
-	if (atomic_dec_and_test(&perfctr->count))
-		vperfctr_free(perfctr);
-}
-
-static void scheduled_vperfctr_free(struct work_struct *work)
-{
-	struct vperfctr *perfctr =
-		container_of(work, struct vperfctr, work);
-	// printk ("vperfctr being released from %s\n", __FUNCTION__);
-	vperfctr_free((struct vperfctr*)perfctr);
-}
-
-static void schedule_put_vperfctr(struct vperfctr *perfctr)
-{
-	if (!atomic_dec_and_test(&perfctr->count))
-		return;
-	INIT_WORK(&perfctr->work, scheduled_vperfctr_free);
-	schedule_work(&perfctr->work);
-}
-
-static unsigned long long new_inheritance_id(void)
-{
-	static spinlock_t lock = SPIN_LOCK_UNLOCKED;
-	static unsigned long long counter;
-	unsigned long long id;
-
-	spin_lock(&lock);
-	id = ++counter;
-	spin_unlock(&lock);
-	return id;
-}
-
-/****************************************************************
- *								*
- * Basic counter operations.					*
- * These must all be called by the owner process only.		*
- * These must all be called with preemption disabled.		*
- *								*
- ****************************************************************/
-
-/* PRE: IS_RUNNING(perfctr)
- * Suspend the counters.
- */
-static inline void vperfctr_suspend(struct vperfctr *perfctr)
-{
-	perfctr_cpu_suspend(&perfctr->cpu_state);
-}
-
-static inline void vperfctr_reset_sampling_timer(struct vperfctr *perfctr)
-{
-	/* XXX: base the value on perfctr_info.cpu_khz instead! */
-	perfctr->sampling_timer = HZ/2;
-}
-
-/* PRE: perfctr == current->thread.perfctr && IS_RUNNING(perfctr)
- * Restart the counters.
- */
-static inline void vperfctr_resume(struct vperfctr *perfctr)
-{
-	perfctr_cpu_resume(&perfctr->cpu_state);
-	vperfctr_reset_sampling_timer(perfctr);
-}
-
-static inline void vperfctr_resume_with_overflow_check(struct vperfctr *perfctr)
-{
-#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-	if (perfctr_cpu_has_pending_interrupt(&perfctr->cpu_state)) {
-		vperfctr_handle_overflow(current, perfctr);
-		return;
-	}
-#endif
-	vperfctr_resume(perfctr);
-}
-
-/* Sample the counters but do not suspend them. */
-static inline void vperfctr_sample(struct vperfctr *perfctr)
-{
-	if (IS_RUNNING(perfctr)) {
-		// logical place to see if the counters are ours else return
-	
-		perfctr_cpu_sample(&perfctr->cpu_state);
-		vperfctr_reset_sampling_timer(perfctr);
-	}
-}
-
-#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-
-// PREEMPT note: called in IRQ context with preemption disabled.
-static void vperfctr_ihandler(unsigned long pc)
-{
-	struct task_struct *tsk = current;
-	struct vperfctr *perfctr;
-	unsigned int pmc, cstatus, now = 0;
-	int i;
-
-	perfctr = tsk->thread.perfctr;
-	if (!perfctr) {
-		return;
-	}
-	if (!perfctr_cstatus_has_ictrs(perfctr->cpu_state.cstatus)) {
-		return;
-	}
-
-	// if someone has really overflown then continue else return
-	// just read, don't freeze them
-	
-	cstatus = perfctr->cpu_state.cstatus;
-	for (i = perfctr_cstatus_nractrs(cstatus); (i < perfctr_cstatus_nrctrs(cstatus)) && ((int)now >= 0); ++i) {
-		pmc = perfctr->cpu_state.pmc[i].map;
-		now = read_pmc(pmc);
-	}
-	if ((int)now >= 0) {
-		return;
-	}
-
-	// Fine, we are suspending the counters and reading them. vperfctr_suspend() 
-	// in turn invokes _suspend() on i-mode ctrs (where they are frozen and read) 
-	// and a-mode counters (where they are just read)
-
-	vperfctr_suspend(perfctr);
-
-	// Ok, Signal to the userland is sent in the following routine. But before that
-	// the following routine calls vperfctr_resume() if the TSC counting is on.
-	// what happens in that resume is just the TSC value is read and stored in the
-	// 'start' state of the TSC
-
-	vperfctr_handle_overflow(tsk, perfctr);
-}
-
-static inline void vperfctr_handle_overflow(struct task_struct *tsk,
-				     struct vperfctr *perfctr)
-{
-	unsigned int pmc_mask;
-	siginfo_t si;
-	sigset_t old_blocked;
-
-	pmc_mask = perfctr_cpu_identify_overflow(&perfctr->cpu_state);
-	if (!pmc_mask) {
-		printk(KERN_ERR "%s: BUG! pid %d has unidentifiable overflow source\n", __FUNCTION__, tsk->pid);
-		return;
-	}
-	/* suspend a-mode and i-mode PMCs, leaving only TSC on */
-	/* XXX: some people also want to suspend the TSC */
-
-	// we are storing 'cpu_state.cstatus' in 'iresume_cstatus' because
-	// in vperfctr_resume, we only want to read the status of those
-	// In the following TSC is resumed and continues to collect the
-	// stats
-
-	// if 'perfctr->iresume_cstatus' is not updated below, vperfctr_iresume() fails
-	// as it thinks it was spuriously called inspite of absence of i-mode counters.
-	// vperfctr_iresume() -> ... -> do_vperfctr_iresume() is a different thread of
-	// execution from vperfctr_resume() -> ... -> vperfctr_iresume() -> __write_control() ->
-	// ...
-	perfctr->iresume_cstatus = perfctr->cpu_state.cstatus;
-
-	if (perfctr_cstatus_has_tsc(perfctr->iresume_cstatus)) {
-		perfctr->cpu_state.cstatus = perfctr_mk_cstatus(1, 0, 0);
-		vperfctr_resume(perfctr);
-	} 
-	else {
-		perfctr->cpu_state.cstatus = 0;
-	}
-
-	// the following siginfo_t structure helps the kernel in invoking
-	// the correct signal handler. Is that right ?
-	// what's the deal with si_errno? what does it say ? si_code ?
-
-	si.si_signo = perfctr->si_signo;
-	si.si_errno = 0;
-	si.si_code = SI_PMC_OVF;
-	si.si_pmc_ovf_mask = pmc_mask;
-
-	/* deliver signal without waking up the receiver */
-	spin_lock_irq(&tsk->sighand->siglock);
-	old_blocked = tsk->blocked;
-	sigaddset(&tsk->blocked, si.si_signo);
-	spin_unlock_irq(&tsk->sighand->siglock);
-
-	if (!send_sig_info(si.si_signo, &si, tsk)) {
-		send_sig(si.si_signo, tsk, 1);
-	}
-
-	spin_lock_irq(&tsk->sighand->siglock);
-	tsk->blocked = old_blocked;
-	recalc_sigpending();
-	spin_unlock_irq(&tsk->sighand->siglock);
-}
-
-#else
-static void vperfctr_ihandler(unsigned long pc) { };
-#endif
-
-
-/****************************************************************
- *								*
- * Process management operations.				*
- * These must all, with the exception of vperfctr_unlink()	*
- * and __vperfctr_set_cpus_allowed(), be called by the owner	*
- * process only.						*
- *								*
- ****************************************************************/
-
-/* do_fork() -> copy_process() -> copy_thread() -> __vperfctr_copy().
- * Inherit the parent's perfctr settings to the child.
- * PREEMPT note: do_fork() etc do not run with preemption disabled.
-*/
-void __vperfctr_copy(struct task_struct *child_tsk, struct pt_regs *regs)
-{
-	struct vperfctr *parent_perfctr;
-	struct vperfctr *child_perfctr;
-
-	/* Do not inherit perfctr settings to kernel-generated
-	   threads, like those created by kmod. */
-	child_perfctr = NULL;
-	if (!user_mode(regs)) {
-		goto out;
-	}
-
-	/* Allocation may sleep. Do it before the critical region. */
-	child_perfctr = get_empty_vperfctr();
-	if (IS_ERR(child_perfctr)) {
-		child_perfctr = NULL;
-		goto out;
-	}
-
-	/* Although we're executing in the parent, if it is scheduled
-	   then a remote monitor may attach and change the perfctr
-	   pointer or the object it points to. This may already have
-	   occurred when we get here, so the old copy of the pointer
-	   in the child cannot be trusted. */
-	preempt_disable();
-	parent_perfctr = current->thread.perfctr;
-	if (parent_perfctr) {
-		child_perfctr->cpu_state.control = parent_perfctr->cpu_state.control;
-		child_perfctr->si_signo = parent_perfctr->si_signo;
-		child_perfctr->inheritance_id = parent_perfctr->inheritance_id;
-	}
-	preempt_enable();
-	if (!parent_perfctr) {
-		put_vperfctr(child_perfctr);
-		child_perfctr = NULL;
-		goto out;
-	}
-	(void)perfctr_cpu_update_control(&child_perfctr->cpu_state, 0);
-	child_perfctr->owner = child_tsk;
- out:
-	child_tsk->thread.perfctr = child_perfctr;
-}
-
-/* Called from exit_thread() or do_vperfctr_unlink().
- * If the counters are running, stop them and sample their final values.
- * Mark the vperfctr object as dead.
- * Optionally detach the vperfctr object from its owner task.
- * PREEMPT note: exit_thread() does not run with preemption disabled.
- */
-
-// exit_thread() --> ... ; do_vperfctr_unlink() --> ...
-static void vperfctr_unlink(struct task_struct *owner, struct vperfctr *perfctr, int do_unlink)
-{
-	/* this synchronises with sys_vperfctr() */
-	spin_lock(&perfctr->owner_lock);
-	perfctr->owner = NULL;
-	spin_unlock(&perfctr->owner_lock);
-
-	/* perfctr suspend+detach must be atomic wrt process suspend */
-	/* this also synchronises with perfctr_set_cpus_allowed() */
-	task_lock(owner);
-	if (IS_RUNNING(perfctr) && owner == current)
-		vperfctr_suspend(perfctr);
-	if (do_unlink)
-		owner->thread.perfctr = NULL;
-	task_unlock(owner);
-
-	perfctr->cpu_state.cstatus = 0;
-	vperfctr_clear_iresume_cstatus(perfctr);
-	if (do_unlink)
-		put_vperfctr(perfctr);
-}
-
-// called from the _exit_thread() in arch/mips/kernel/process.c
-// this is called by tasks onselves. Since we specified '0' as the 3rd
-// argument for vperfctr_unlink(), only the stats are collected but the
-// the task structure itself is not freed
-
-void __vperfctr_exit(struct vperfctr *perfctr)
-{
-	vperfctr_unlink(current, perfctr, 0);
-}
-
-// release_task() is called during the deallocation of resources of
-// a zombie thread/process and not when a process/thread exits
-
-/* release_task() -> perfctr_release_task() -> __vperfctr_release().
- * A task is being released. If it inherited its perfctr settings
- * from its parent, then merge its final counts back into the parent.
- * Then unlink the child's perfctr.
- * PRE: caller has write_lock_irq(&tasklist_lock).
- * PREEMPT note: preemption is disabled due to tasklist_lock.
- */
-
-static void do_vperfctr_release(struct vperfctr *child_perfctr, struct task_struct *parent_tsk)
-{
-	struct vperfctr *parent_perfctr;
-	unsigned int cstatus, nrctrs, i;
-
-	parent_perfctr = parent_tsk->thread.perfctr;
-	if (parent_perfctr && child_perfctr) {
-		
-		// since more than one child can try to add to parent's
-		// counters, we need a lock
-
-		spin_lock(&parent_perfctr->children_lock);
-		if (parent_perfctr->inheritance_id == child_perfctr->inheritance_id) {
-			cstatus = parent_perfctr->cpu_state.cstatus;
-			if (perfctr_cstatus_has_tsc(cstatus))
-				parent_perfctr->children.tsc +=
-					child_perfctr->cpu_state.tsc_sum +
-					child_perfctr->children.tsc;
-			nrctrs = perfctr_cstatus_nrctrs(cstatus);
-			for(i = 0; i < nrctrs; ++i)
-				parent_perfctr->children.pmc[i] +=
-					child_perfctr->cpu_state.pmc[i].sum +
-					child_perfctr->children.pmc[i];
-		}
-		spin_unlock(&parent_perfctr->children_lock);
-	}
-
-	// now that we reaped the data from child's task structure
-	// the child's task structure can be freed. Only the child's
-	// vperfctr structure seems to be released. Is the 'task_struct'
-	// released in __vperfctr_release() itself? Doesn't seem so.
-	schedule_put_vperfctr(child_perfctr);
-}
-
-static void scheduled_release(struct work_struct *data)
-{
-	struct vperfctr *child_perfctr = 
-		container_of(data, struct vperfctr, work);
-	struct task_struct *parent_tsk = child_perfctr->parent_tsk;
-
-	// why are we getting a lock on the parent task structure ?
-	// of course, we incremented the reference count to parent's task_struct
-	task_lock(parent_tsk);
-	do_vperfctr_release(child_perfctr, parent_tsk);
-	task_unlock(parent_tsk);
-	
-	// good, the incremented reference count of the parent task is now
-	// decremented, now that we are done adding up our counts to that
-	// of the parent
-	put_task_struct(parent_tsk);
-}
-
-void __vperfctr_release(struct task_struct *child_tsk)
-{
-	struct task_struct *parent_tsk = child_tsk->parent;
-	struct vperfctr *child_perfctr = child_tsk->thread.perfctr;
-
-	// this is invoked either in the waitpid() or if there the parent is not
-	// interesting in its children. In the latter case, "parent_tsk != current"
-
-	// one releases oneself, when the parent is not interested in one's data
-	// but even then we would like to add our counters to those of the parent's
-	
-	// another step towards freeing the task_struct(ure).
-	child_tsk->thread.perfctr = NULL;
-
-	// if the parent is releasing the children's task structure, then it (the
-	// parent) can go ahead and add the children's vperfctr's values to the
-	// 'children' field in the parent's 'vperfctr' structure.
-	// So, am 'I' the parent of the task_structure I am attempting to release?
-	// When current == parent_tsk, the child's counts can be merged
-	// into the parent's immediately. This is the common case.
-
-	// printk ("%s, %d\n", __FUNCTION__, __LINE__);
-	if (child_perfctr == NULL) {
-		// printk("%s, %d, child_perfctr == NULL\n", __FUNCTION__, __LINE__);
-	}
-
-	if (parent_tsk == current)
-		do_vperfctr_release(child_perfctr, parent_tsk);
-	else {
-
-		/* When current != parent_tsk, the parent must be task_lock()ed
-		 * before its perfctr state can be accessed. task_lock() is illegal
-		 * here due to the write_lock_irq(&tasklist_lock) in release_task(),
-		 * so the operation is done via schedule_work(). Also, increment
-		 * the reference count of parent's task_struct so that it will not be
-		 * freed for good
-	     */
-
-		get_task_struct(parent_tsk);	// increments the reference count
-
-		INIT_WORK(&child_perfctr->work, scheduled_release);
-		child_perfctr->parent_tsk = parent_tsk;
-		schedule_work(&child_perfctr->work);
-	}
-}
-
-/* schedule() --> switch_to() --> .. --> __vperfctr_suspend().
- * If the counters are running, suspend them.
- * PREEMPT note: switch_to() runs with preemption disabled.
- */
-void __vperfctr_suspend(struct vperfctr *perfctr)
-{
-	if (IS_RUNNING(perfctr))
-		vperfctr_suspend(perfctr);
-}
-
-/* schedule() --> switch_to() --> .. --> __vperfctr_resume().
- * PRE: perfctr == current->thread.perfctr
- * If the counters are runnable, resume them.
- * PREEMPT note: switch_to() runs with preemption disabled.
- */
-void __vperfctr_resume(struct vperfctr *perfctr)
-{
-	if (IS_RUNNING(perfctr)) {
-		// logical place to add the functionality
-
-	// what exactly are we doing here ?
-#ifdef CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK
-		if (unlikely(atomic_read(&perfctr->bad_cpus_allowed)) &&
-		    perfctr_cstatus_nrctrs(perfctr->cpu_state.cstatus)) {
-			perfctr->cpu_state.cstatus = 0;
-			vperfctr_clear_iresume_cstatus(perfctr);
-			BUG_ON(current->state != TASK_RUNNING);
-			send_sig(SIGILL, current, 1);
-			return;
-		}
-#endif
-		vperfctr_resume_with_overflow_check(perfctr);
-	}
-}
-
-/* Called from update_one_process() [triggered by timer interrupt].
- * PRE: perfctr == current->thread.perfctr.
- * Sample the counters but do not suspend them.
- * Needed to avoid precision loss due to multiple counter
- * wraparounds between resume/suspend for CPU-bound processes.
- * PREEMPT note: called in IRQ context with preemption disabled.
- */
-void __vperfctr_sample(struct vperfctr *perfctr)
-{
-	if (--perfctr->sampling_timer == 0)
-		vperfctr_sample(perfctr);
-}
-
-#ifdef CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK
-/* Called from set_cpus_allowed().
- * PRE: current holds task_lock(owner)
- * PRE: owner->thread.perfctr == perfctr
- */
-void __vperfctr_set_cpus_allowed(struct task_struct *owner,
-				 struct vperfctr *perfctr,
-				 cpumask_t new_mask)
-{
-	if (cpus_intersects(new_mask, perfctr_cpus_forbidden_mask)) {
-		atomic_set(&perfctr->bad_cpus_allowed, 1);
-		if (printk_ratelimit())
-			printk(KERN_WARNING "perfctr: process %d (comm %s) issued unsafe"
-				" set_cpus_allowed() on process %d (comm %s)\n",
-			    	current->pid, current->comm, owner->pid, owner->comm);
-	} else
-		atomic_set(&perfctr->bad_cpus_allowed, 0);
-}
-#endif
-
-/****************************************************************
- *								*
- * Virtual perfctr system calls implementation.			*
- * These can be called by the owner process (tsk == current),	*
- * a monitor process which has the owner under ptrace ATTACH	*
- * control (tsk && tsk != current), or anyone with a handle to	*
- * an unlinked perfctr (!tsk).					*
- *								*
- ****************************************************************/
-
-static int do_vperfctr_control(struct vperfctr *perfctr,
-			       const struct vperfctr_control __user *argp,
-			       unsigned int argbytes,
-			       struct task_struct *tsk)
-{
-	struct vperfctr_control *control;
-	int err;
-	unsigned int next_cstatus;
-	unsigned int nrctrs, i;
-
-	if (!tsk) {
-		return -ESRCH;	/* attempt to update unlinked perfctr */
-	}
-
-	/* The control object can be large (over 300 bytes on i386),
-	   so kmalloc() it instead of storing it on the stack.
-	   We must use task-private storage to prevent racing with a
-	   monitor process attaching to us before the non-preemptible
-	   perfctr update step. Therefore we cannot store the copy
-	   in the perfctr object itself. */
-	control = kmalloc(sizeof(*control), GFP_USER);
-	if (!control) {
-		return -ENOMEM;
-	}
-
-	err = -EINVAL;
-	if (argbytes > sizeof *control) {
-		goto out_kfree;
-	}
-
-	err = -EFAULT;
-	if (copy_from_user(control, argp, argbytes)) {
-		goto out_kfree;
-	}
-
-	if (argbytes < sizeof *control)
-		memset((char*)control + argbytes, 0, sizeof *control - argbytes);
-
-	// figure out what is happening in the following 'if' loop
-
-	if (control->cpu_control.nractrs || control->cpu_control.nrictrs) {
-		cpumask_t old_mask, new_mask;
-
-		old_mask = tsk->cpus_allowed;
-		cpus_andnot(new_mask, old_mask, perfctr_cpus_forbidden_mask);
-
-		err = -EINVAL;
-		if (cpus_empty(new_mask)) {
-			goto out_kfree;
-		}
-		if (!cpus_equal(new_mask, old_mask))
-			set_cpus_allowed(tsk, new_mask);
-	}
-
-	/* PREEMPT note: preemption is disabled over the entire
-	   region since we're updating an active perfctr. */
-	preempt_disable();
-
-	// the task whose control register I am changing might actually be
-	// in suspended state. That can happen when the other is executing
-	// under the control of another task as in the case of debugging
-	// or ptrace. However, if the write_control is done for the current
-	// executing process, first suspend them and then do the update
-	// why are we resetting 'perfctr->cpu_state.cstatus' ?
-
-	if (IS_RUNNING(perfctr)) {
-		if (tsk == current)
-			vperfctr_suspend(perfctr);
-	
-		// not sure why we are zeroing out the following explicitly
-		perfctr->cpu_state.cstatus = 0;
-		vperfctr_clear_iresume_cstatus(perfctr);
-	}
-
-	// coying the user-specified control values to 'state'
-	perfctr->cpu_state.control = control->cpu_control;
-
-	/* remote access note: perfctr_cpu_update_control() is ok */
-	err = perfctr_cpu_update_control(&perfctr->cpu_state, 0);
-	if (err < 0) {
-		goto out;
-	}
-	next_cstatus = perfctr->cpu_state.cstatus;
-	if (!perfctr_cstatus_enabled(next_cstatus))
-		goto out;
-
-	/* XXX: validate si_signo? */
-	perfctr->si_signo = control->si_signo;
-
-	if (!perfctr_cstatus_has_tsc(next_cstatus))
-		perfctr->cpu_state.tsc_sum = 0;
-
-	nrctrs = perfctr_cstatus_nrctrs(next_cstatus);
-	for(i = 0; i < nrctrs; ++i)
-		if (!(control->preserve & (1<<i)))
-			perfctr->cpu_state.pmc[i].sum = 0;
-
-	// I am not sure why we are removing the inheritance just because
-	// we updated the control information. True, because the children might
-	// be performing something else. So, the control will have to be set
-	// before spawning any children
-
-	spin_lock(&perfctr->children_lock);
-	perfctr->inheritance_id = new_inheritance_id();
-	memset(&perfctr->children, 0, sizeof perfctr->children);
-	spin_unlock(&perfctr->children_lock);
-
-	if (tsk == current) {
-		vperfctr_resume(perfctr);
-	}
-
- out:
-	preempt_enable();
- out_kfree:
-	kfree(control);
-	return err;
-}
-
-static int do_vperfctr_iresume(struct vperfctr *perfctr, const struct task_struct *tsk)
-{
-#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
-	unsigned int iresume_cstatus;
-
-	if (!tsk)
-		return -ESRCH;	/* attempt to update unlinked perfctr */
-
-	iresume_cstatus = perfctr->iresume_cstatus;
-	if (!perfctr_cstatus_has_ictrs(iresume_cstatus)) {
-		return -EPERM;
-	}
-
-	/* PREEMPT note: preemption is disabled over the entire
-	   region because we're updating an active perfctr. */
-	preempt_disable();
-
-	// this is for resuming a task whose signal was handled prior to this call
-	// are the i-mode counters frozen before the overflow-signal is delivered
-	// yes, they are. in the suspend call invoked in the handler
-
-	// why exactly are we suspending the following? Makes sense ... if the
-	// counters are already running, then one should not just resume the task
-	// which will overwrite the PMC registers with old values. Nice. Under
-	// what condition do counters continue to count after the signal is delivered
-	// remember TSC was not suspend in the handler and continues to count
-
-	if (IS_RUNNING(perfctr) && tsk == current)
-		vperfctr_suspend(perfctr);
-
-	// setting the cstatus of 'cpu_state' back to what it was prior to its
-	// zeroing out in the interrupt handler
-	perfctr->cpu_state.cstatus = iresume_cstatus;
-	perfctr->iresume_cstatus = 0;
-
-	/* remote access note: perfctr_cpu_ireload() is ok */
-	// the following forces the reload of control registers that 
-	// unfreezes the i-mode registers
-	perfctr_cpu_ireload(&perfctr->cpu_state);
-
-	if (tsk == current)
-		vperfctr_resume(perfctr);
-
-	preempt_enable();
-
-	return 0;
-#else
-	return -ENOSYS;
-#endif
-}
-
-static int do_vperfctr_unlink(struct vperfctr *perfctr, struct task_struct *tsk)
-{
-	if (tsk)
-		vperfctr_unlink(tsk, perfctr, 1);
-	return 0;
-}
-
-// sys_vperfctr_read() -> this()
-static int do_vperfctr_read(struct vperfctr *perfctr,
-			    unsigned int cmd,
-			    void __user *argp,
-			    unsigned int argbytes,
-			    struct task_struct *tsk)
-{
-	union {
-		struct perfctr_sum_ctrs sum;
-		struct vperfctr_control control;
-		struct perfctr_sum_ctrs children;
-	} *tmp;
-	unsigned int tmpbytes;
-	int ret;
-
-	/* The state snapshot can be large, so kmalloc() it instead of storing it on the stack.
-	   We must use task-private storage to prevent racing with a monitor process attaching to 
-	   us during the preemptible copy_to_user() step. Therefore we cannot store the snapshot
-	   in the perfctr object itself. 
-    */
-	tmp = kmalloc(sizeof(*tmp), GFP_USER);
-	if (!tmp)
-		return -ENOMEM;
-
-	/* PREEMPT note: While we're reading our own control, another process may ptrace ATTACH 
-       to us and update our control. Disable preemption to ensure we get a consistent copy.
-	   Not needed for other cases since the perfctr is either unlinked or its owner is ptrace 
-       ATTACH suspended by us. 
-	*/
-	if (tsk == current)
-		preempt_disable();
-
-	switch (cmd) {
-    	case VPERFCTR_READ_SUM: {
-    		int j;
-    
-    		vperfctr_sample(perfctr);
-    		tmp->sum.tsc = perfctr->cpu_state.tsc_sum;
-    		for(j = 0; j < ARRAY_SIZE(tmp->sum.pmc); ++j)
-    			tmp->sum.pmc[j] = perfctr->cpu_state.pmc[j].sum;
-    		tmpbytes = sizeof(tmp->sum);
-    	}
-    	break;
-    	case VPERFCTR_READ_CONTROL:
-    		tmp->control.si_signo = perfctr->si_signo;
-    		tmp->control.cpu_control = perfctr->cpu_state.control;
-    		tmp->control.preserve = 0;
-    		tmpbytes = sizeof(tmp->control);
-    	break;
-    	case VPERFCTR_READ_CHILDREN:
-    		if (tsk)
-    			spin_lock(&perfctr->children_lock);
-    		tmp->children = perfctr->children;
-    		if (tsk)
-    			spin_unlock(&perfctr->children_lock);
-    		tmpbytes = sizeof(tmp->children);
-    	break;
-    	default:
-    		tmpbytes = 0;
-	}
-
-	if (tsk == current)
-		preempt_enable();
-
-	ret = -EINVAL;
-	if (tmpbytes > argbytes)
-		tmpbytes = argbytes;
-	if (tmpbytes > 0) {
-		ret = tmpbytes;
-		if (copy_to_user(argp, tmp, tmpbytes))
-			ret = -EFAULT;
-	}
-	kfree(tmp);
-	return ret;
-}
-
-/****************************************************************
- *																*
- * Virtual perfctr file operations.								*
- *																*
- ****************************************************************/
-
-static int vperfctr_mmap(struct file *filp, struct vm_area_struct *vma)
-{
-	struct vperfctr *perfctr;
-
-	/* Only allow read-only mapping of first page. */
-	// (pgprot_val(vma->vm_page_prot) & _PAGE_RW) ||
-
-	if ( ((vma->vm_end - vma->vm_start) != PERFCTR_PAGE_SIZE) || (vma->vm_pgoff != 0) ||
-	     (pgprot_val(vma->vm_page_prot) & _PAGE_WRITE) || (vma->vm_flags & (VM_WRITE | VM_MAYWRITE))
-       ) {
-		return -EPERM;
-	}
-	perfctr = filp->private_data;
-	if (!perfctr) {
-		return -EPERM;
-	}
-
-    return remap_pfn_range (vma, vma->vm_start, 
-		    (virt_to_phys(perfctr) >> PAGE_SHIFT),
-			PERFCTR_PAGE_SIZE, vma->vm_page_prot);
-}
-
-static int vperfctr_release(struct inode *inode, struct file *filp)
-{
-	struct vperfctr *perfctr = filp->private_data;
-	filp->private_data = NULL;
-
-	// printk("%s, %d\n", __FUNCTION__, __LINE__);
-	if (perfctr) {
-		// printk("%s, %d\n", __FUNCTION__, __LINE__);
-		put_vperfctr(perfctr);
-	}
-	return 0;
-}
-
-static struct file_operations vperfctr_file_ops = {
-	.mmap = vperfctr_mmap,
-	.release = vperfctr_release,
-};
-
-/****************************************************************
- *																*
- * File system for virtual perfctrs. Based on pipefs.			*
- *																*
- ****************************************************************/
-
-#define VPERFCTRFS_MAGIC (('V'<<24)|('P'<<16)|('M'<<8)|('C'))
-
-/* The code to set up a `struct file_system_type' for a pseudo fs
-   is unfortunately not the same in 2.4 and 2.6. */
-#include <linux/mount.h> /* needed for 2.6, included by fs.h in 2.4 */
-
-static struct vfsmount *vperfctr_mnt;
-static int 
-vperfctrfs_get_sb(struct file_system_type *fs_type,
-		  int flags, const char *dev_name, void *data,  
-		  struct vfsmount *mount)
-{
-	return get_sb_pseudo(fs_type, "vperfctr:", NULL, VPERFCTRFS_MAGIC,
-						mount);
-}
-
-static struct file_system_type vperfctrfs_type = {
-	.name		= "vperfctrfs",
-	.get_sb		= vperfctrfs_get_sb,
-	.kill_sb	= kill_anon_super,
-};
-
-/* XXX: check if s/vperfctr_mnt/vperfctrfs_type.kern_mnt/ would work */
-#define vperfctr_fs_init_done()	(vperfctr_mnt != NULL)
-
-static int __init vperfctrfs_init(void)
-{
-	int err = register_filesystem(&vperfctrfs_type);
-	if (!err) {
-		vperfctr_mnt = kern_mount(&vperfctrfs_type);
-		if (!IS_ERR(vperfctr_mnt))
-			return 0;
-		err = PTR_ERR(vperfctr_mnt);
-		unregister_filesystem(&vperfctrfs_type);
-		vperfctr_mnt = NULL;
-	}
-	return err;
-}
-
-static void __exit vperfctrfs_exit(void)
-{
-	unregister_filesystem(&vperfctrfs_type);
-	mntput(vperfctr_mnt);
-}
-
-static struct inode *vperfctr_get_inode(void)
-{
-	struct inode *inode;
-
-	inode = new_inode(vperfctr_mnt->mnt_sb);
-	if (!inode)
-		return NULL;
-	inode->i_fop = &vperfctr_file_ops;
-	inode->i_state = I_DIRTY;
-	inode->i_mode = S_IFCHR | S_IRUSR | S_IWUSR;
-	inode->i_uid = current->cred->fsuid;
-	inode->i_gid = current->cred->fsgid;
-	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-	return inode;
-}
-
-static int vperfctrfs_delete_dentry(struct dentry *dentry)
-{
-	return 1;
-}
-
-static struct dentry_operations vperfctrfs_dentry_operations = {
-	.d_delete	= vperfctrfs_delete_dentry,
-};
-
-static struct dentry *vperfctr_d_alloc_root(struct inode *inode)
-{
-	struct qstr this;
-	char name[32];
-	struct dentry *dentry;
-
-	sprintf(name, "[%lu]", inode->i_ino);
-	this.name = name;
-	this.len = strlen(name);
-	this.hash = inode->i_ino; /* will go */
-	dentry = d_alloc(vperfctr_mnt->mnt_sb->s_root, &this);
-	if (dentry) {
-		dentry->d_op = &vperfctrfs_dentry_operations;
-		d_add(dentry, inode);
-	}
-	return dentry;
-}
-
-static struct file *vperfctr_get_filp(void)
-{
-	struct file *filp;
-	struct inode *inode;
-	struct dentry *dentry;
-
-	filp = get_empty_filp();
-	if (!filp)
-		goto out;
-	inode = vperfctr_get_inode();
-	if (!inode)
-		goto out_filp;
-	dentry = vperfctr_d_alloc_root(inode);
-	if (!dentry)
-		goto out_inode;
-
-	filp->f_vfsmnt = mntget(vperfctr_mnt);
-	filp->f_dentry = dentry;
-	filp->f_mapping = dentry->d_inode->i_mapping;
-
-	filp->f_pos = 0;
-	filp->f_flags = 0;
-	filp->f_op = &vperfctr_file_ops; /* fops_get() if MODULE */
-	filp->f_mode = FMODE_READ;
-	filp->f_version = 0;
-
-	return filp;
-
- out_inode:
-	iput(inode);
- out_filp:
-	put_filp(filp);	/* doesn't run ->release() like fput() does */
- out:
-	return NULL;
-}
-
-/****************************************************************
- *								*
- * Virtual perfctr actual system calls.				*
- *								*
- ****************************************************************/
-
-/* tid is the actual task/thread id (ne pid, stored as ->pid),
-   pid/tgid is that 2.6 thread group id crap (stored as ->tgid) */
-asmlinkage long sys_vperfctr_open(int tid, int creat)
-{
-	struct file *filp;
-	struct task_struct *tsk;
-	struct vperfctr *perfctr;
-	int err;
-	int fd;
-
-	if (!vperfctr_fs_init_done())
-		return -ENODEV;
-	filp = vperfctr_get_filp();
-	if (!filp)
-		return -ENOMEM;
-	err = fd = get_unused_fd();
-	if (err < 0)
-		goto err_filp;
-	perfctr = NULL;
-	if (creat) {
-		perfctr = get_empty_vperfctr(); /* may sleep */
-		if (IS_ERR(perfctr)) {
-			err = PTR_ERR(perfctr);
-			goto err_fd;
-		}
-	}
-	tsk = current;
-
-	if (tid != 0 && tid != tsk->pid) { /* remote? */
-		// tasklist_lock is to access the linked list of task_struct structures exclusively
-		read_lock(&tasklist_lock);
-		//tsk = find_task_by_pid(tid);
-		tsk = find_task_by_pid_ns(tid, current->nsproxy->pid_ns);
-		if (tsk)
-			get_task_struct(tsk);
-		read_unlock(&tasklist_lock);
-		err = -ESRCH;
-		if (!tsk)
-			goto err_perfctr;
-		err = ptrace_check_attach(tsk, 0);
-		if (err < 0)
-			goto err_tsk;
-	}
-	if (creat) {
-		/* check+install must be atomic to prevent remote-control races */
-		task_lock(tsk);
-		if (!tsk->thread.perfctr) {
-			perfctr->owner = tsk;
-			tsk->thread.perfctr = perfctr;
-			err = 0;
-		} else
-			err = -EEXIST;
-		task_unlock(tsk);
-		if (err)
-			goto err_tsk;
-	} else {
-		perfctr = tsk->thread.perfctr;
-		/* XXX: Old API needed to allow NULL perfctr here.
-		   Do we want to keep or change that rule? */
-	}
-	filp->private_data = perfctr;
-	if (perfctr)
-		atomic_inc(&perfctr->count);
-	if (tsk != current)
-		put_task_struct(tsk);
-	#if 0
-	if (perfctr) {
-    	printk ("sys_vperfctr_open(): fd = %d, perfctr is NOT null\n", fd);
-	}
-	else {
-    	printk ("sys_vperfctr_open(): fd = %d, perfctr is null\n", fd);
-	}
-	#endif
-	fd_install(fd, filp);
-	return fd;
- err_tsk:
-	if (tsk != current)
-		put_task_struct(tsk);
- err_perfctr:
-	if (perfctr)	/* can only occur if creat != 0 */
-		put_vperfctr(perfctr);
- err_fd:
-	put_unused_fd(fd);
- err_filp:
-	fput(filp);
-	return err;
-}
-
-static struct vperfctr *fd_get_vperfctr(int fd)
-{
-	struct vperfctr *perfctr;
-	struct file *filp;
-	int err;
-
-	err = -EBADF;
-	filp = fget(fd);
-	if (!filp)
-		goto out;
-	err = -EINVAL;
-	if (filp->f_op != &vperfctr_file_ops)
-		goto out_filp;
-	perfctr = filp->private_data;
-	if (!perfctr)
-		goto out_filp;
-	atomic_inc(&perfctr->count);
-	fput(filp);
-	return perfctr;
- out_filp:
-	fput(filp);
- out:
-	return ERR_PTR(err);
-}
-
-static struct task_struct *vperfctr_get_tsk(struct vperfctr *perfctr)
-{
-	struct task_struct *tsk;
-
-	tsk = current;
-	if (perfctr != current->thread.perfctr) {
-		/* this synchronises with vperfctr_unlink() and itself */
-		spin_lock(&perfctr->owner_lock);
-		tsk = perfctr->owner;
-		if (tsk)
-			get_task_struct(tsk);
-		spin_unlock(&perfctr->owner_lock);
-		if (tsk) {
-			int ret = ptrace_check_attach(tsk, 0);
-			if (ret < 0) {
-				put_task_struct(tsk);
-				return ERR_PTR(ret);
-			}
-		}
-	}
-	return tsk;
-}
-
-static void vperfctr_put_tsk(struct task_struct *tsk)
-{
-	if (tsk && tsk != current)
-		put_task_struct(tsk);
-}
-
-asmlinkage long sys_vperfctr_control(int fd,
-				     const struct vperfctr_control __user *argp,
-				     unsigned int argbytes)
-{
-	struct vperfctr *perfctr;
-	struct task_struct *tsk;
-	int ret;
-
-	perfctr = fd_get_vperfctr(fd);
-	if (IS_ERR(perfctr)) {
-		printk ("sys_vperfctr_control(): fd: %d, perfctr == NULL\n", fd);
-		return PTR_ERR(perfctr);
-	}
-	tsk = vperfctr_get_tsk(perfctr);
-	if (IS_ERR(tsk)) {
-		ret = PTR_ERR(tsk);
-		goto out;
-	}
-
-	// About the arguments:
-	// perfctr: kernel-level 'struct vperfctr'
-	// argp: pointer to a user level 'struct vperfctr_control'
-    // argp: sizeof(struct vperfctr_control)
-	// tsk, the task_struct associated with 'perfctr'
-
-	ret = do_vperfctr_control(perfctr, argp, argbytes, tsk);
-	vperfctr_put_tsk(tsk);
- out:
-	put_vperfctr(perfctr);
-	return ret;
-}
-
-asmlinkage long sys_vperfctr_unlink(int fd)
-{
-	struct vperfctr *perfctr;
-	struct task_struct *tsk;
-	int ret;
-
-	perfctr = fd_get_vperfctr(fd);
-	if (IS_ERR(perfctr))
-		return PTR_ERR(perfctr);
-	tsk = vperfctr_get_tsk(perfctr);
-	if (IS_ERR(tsk)) {
-		ret = PTR_ERR(tsk);
-		goto out;
-	}
-
-	ret = do_vperfctr_unlink(perfctr, tsk);
-	vperfctr_put_tsk(tsk);
- out:
-	put_vperfctr(perfctr);
-	return ret;
-}
-
-asmlinkage long sys_vperfctr_iresume(int fd)
-{
-	struct vperfctr *perfctr;
-	struct task_struct *tsk;
-	int ret;
-
-
-	perfctr = fd_get_vperfctr(fd);
-	if (IS_ERR(perfctr)) {
-		return PTR_ERR(perfctr);
-	}
-
-	tsk = vperfctr_get_tsk(perfctr);
-	if (IS_ERR(tsk)) {
-		ret = PTR_ERR(tsk);
-		goto out;
-	}
-
-	ret = do_vperfctr_iresume(perfctr, tsk);
-
-	vperfctr_put_tsk(tsk);
- out:
-	put_vperfctr(perfctr);
-	return ret;
-}
-
-asmlinkage long sys_vperfctr_read(int fd, unsigned int cmd, void __user *argp, unsigned int argbytes)
-{
-	struct vperfctr *perfctr;
-	struct task_struct *tsk;
-	int ret;
-
-	perfctr = fd_get_vperfctr(fd);
-	if (IS_ERR(perfctr)) {
-		return PTR_ERR(perfctr);
-	}
-	tsk = vperfctr_get_tsk(perfctr);
-	if (IS_ERR(tsk)) {
-		ret = PTR_ERR(tsk);
-		goto out;
-	}
-
-	ret = do_vperfctr_read(perfctr, cmd, argp, argbytes, tsk);
-
-	vperfctr_put_tsk(tsk);
- out:
-	put_vperfctr(perfctr);
-	return ret;
-}
-
-/****************************************************************
- *								*
- * module_init/exit						*
- *								*
- ****************************************************************/
-
-int __init vperfctr_init(void)
-{
-	return vperfctrfs_init();
-}
-
-void __exit vperfctr_exit(void)
-{
-	vperfctrfs_exit();
-}
diff --git a/drivers/perfctr/virtual.h b/drivers/perfctr/virtual.h
deleted file mode 100644
index e80a206..0000000
--- a/drivers/perfctr/virtual.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* $Id: virtual.h,v 1.1.2.2 2006-09-28 01:24:17 nphilips Exp $
- * Virtual per-process performance counters.
- *
- * Copyright (C) 1999-2004  Mikael Pettersson
- */
-
-#ifdef CONFIG_PERFCTR_VIRTUAL
-extern int vperfctr_init(void);
-extern void vperfctr_exit(void);
-#else
-static inline int vperfctr_init(void) { return 0; }
-static inline void vperfctr_exit(void) { }
-#endif
diff --git a/drivers/rapidio/switches/Makefile b/drivers/rapidio/switches/Makefile
index 461eaae..c4d3acc 100644
--- a/drivers/rapidio/switches/Makefile
+++ b/drivers/rapidio/switches/Makefile
@@ -7,6 +7,3 @@ obj-$(CONFIG_RAPIDIO_CPS_XX)	+= idtcps.o
 obj-$(CONFIG_RAPIDIO_TSI568)	+= tsi568.o
 obj-$(CONFIG_RAPIDIO_TSI500)	+= tsi500.o
 obj-$(CONFIG_RAPIDIO_CPS_GEN2)	+= idt_gen2.o
-ifdef CONFIG_NLM_COMMON
-obj-$(CONFIG_RAPIDIO)	+= tsi578.o
-endif
diff --git a/drivers/rapidio/switches/tsi578.c b/drivers/rapidio/switches/tsi578.c
deleted file mode 100644
index 39af616..0000000
--- a/drivers/rapidio/switches/tsi578.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * RapidIO Tsi578 switch support
- *
- */
-
-#include <linux/rio.h>
-#include <linux/rio_drv.h>
-#include <linux/rio_ids.h>
-#include "../rio.h"
-#include <linux/delay.h>
-
-#ifdef NLM_SRIO_DEBUG 
-#define Message(a,b...) printk("\nFunction[%s]-Line[%d] \n"a"\n",__FUNCTION__,__LINE__,##b)
-#else
-#define Message(a,b...)
-#endif
-
-static int init_done = 0;
-static int
-tsi578_route_add_entry(struct rio_mport *mport, u16 destid, u8 hopcount, u16 table, u16 route_destid, u8 route_port)
-{
-	u32 offset0 = 0x70;
-	u32 offset1 = 0x74;
-    uint32_t data = 0;
-    Message("route_destid = %#x",route_destid);
-    Message("destid=%d, hopcount=%d, table=%d, route_port=%d",
-            destid,hopcount,table,route_port);
-
-    if(!init_done){
-        rio_mport_read_config_32(mport, 0xffff, 0, 0x10004, &data);
-        data = data & ~(1<<24);
-        rio_mport_write_config_32(mport, 0xffff, 0, 0x10004, data);
-        init_done = 1; 
-    }
-
-	if (table == 0xff) {
-        Message("Writing in to per port route table..");
-        Message("Writing @ Offset %#x and Offset %#x",offset0, offset1);
-        rio_mport_write_config_32(mport, destid, hopcount, offset0, 
-                                    route_destid);
-        rio_mport_write_config_32(mport, destid, hopcount, offset1, 
-                                    route_port);
-	}
-	return 0;
-}
-
-static int
-tsi578_route_get_entry(struct rio_mport *mport, u16 destid, u8 hopcount, u16 table, u16 route_destid, u8 *route_port)
-{
-	u32 offset0 = 0x70;
-	u32 offset1 = 0x74;
-    u32 result = 0;
-    Message("route_destid = %#x",route_destid);
-    Message("destid=%d, hopcount=%d, table=%d, route_port=%d",
-            destid,hopcount,table,route_port);
-
-    if(route_destid > 15)
-       return -1; 
-
-	if (table == 0xff) {
-        Message("Reading from switch..");
-	    rio_mport_write_config_32(mport, destid, hopcount, offset0, 
-                                    route_destid);
-	    rio_mport_read_config_32(mport, destid, hopcount, offset1, &result);
-        *route_port = (u8)result;
-	    return 0;
-	}
-    return -1;
-}
-
-DECLARE_RIO_ROUTE_OPS(RIO_VID_TUNDRA, RIO_DID_TSI578, tsi578_route_add_entry, tsi578_route_get_entry);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index df2ad93..c74ba7b 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -44,10 +44,6 @@
 
 #include "usb.h"
 
-#if defined(CONFIG_NLM_XLR) && defined(CONFIG_64BIT)
-extern int avail_mem_above_4G;
-#endif
-
 
 const char *usbcore_name = "usbcore";
 
@@ -945,10 +941,6 @@ int usb_disabled(void)
 }
 EXPORT_SYMBOL_GPL(usb_disabled);
 
-#ifdef CONFIG_NLM_COMMON
-extern int force_usb;
-#endif
-
 /*
  * Notifications of device and interface registration
  */
@@ -1014,19 +1006,6 @@ static void usb_debugfs_cleanup(void)
 static int __init usb_init(void)
 {
 	int retval;
-
-#if defined(CONFIG_NLM_XLR) && defined(CONFIG_64BIT)
-    if (avail_mem_above_4G && !force_usb) {
-        printk("------------------------------------------------\n");
-        printk("[USB]: Running 64-bit Linux with DRAM above 4G. \n");
-        printk("     : HW Support for DMA >32-bit Un-available. \n");
-        printk("     : Disabling USB, to force enable, use      \n");
-        printk("     : cmdline option 'forceusb'\n");
-        printk("------------------------------------------------\n");
-        nousb=1;
-    }
-#endif
-
 	if (nousb) {
 		pr_info("%s: USB support disabled\n", usbcore_name);
 		return 0;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 78c1a6b..987db27 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1,11 +1,3 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
 /*
  * Enhanced Host Controller Interface (EHCI) driver for USB.
  *
@@ -59,10 +51,6 @@ the header of the original work apply to this derived work.
 #include <asm/firmware.h>
 #endif
 
-#ifdef CONFIG_NLM_XLR
-#include <asm/netlogic/sim.h>
-#endif
-
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -1327,11 +1315,6 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
-#ifdef CONFIG_NLM_XLR
-#include "ehci-xls.c"
-#define  PLATFORM_DRIVER      ehci_xls_driver
-#endif
-
 #ifdef CONFIG_USB_W90X900_EHCI
 #include "ehci-w90x900.c"
 #define	PLATFORM_DRIVER		ehci_hcd_w90x900_driver
@@ -1446,10 +1429,6 @@ static int __init ehci_hcd_init(void)
 #endif
 
 #ifdef PLATFORM_DRIVER
-#ifdef CONFIG_NLM_XLR
-    /* On the XLS, use the internal USB Controller */
-    if (is_xls())
-#endif
 	retval = platform_driver_register(&PLATFORM_DRIVER);
 	if (retval < 0)
 		goto clean0;
@@ -1520,10 +1499,6 @@ static void __exit ehci_hcd_cleanup(void)
 	platform_driver_unregister(&OF_PLATFORM_DRIVER);
 #endif
 #ifdef PLATFORM_DRIVER
-#ifdef CONFIG_NLM_XLR
-    /* On the XLS, use the internal USB Controller */
-    if (is_xls())
-#endif 
 	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
 #ifdef PCI_DRIVER
diff --git a/drivers/usb/host/ehci-xls.c b/drivers/usb/host/ehci-xls.c
deleted file mode 100644
index 72f0819..0000000
--- a/drivers/usb/host/ehci-xls.c
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * EHCI HCD for Netlogic XLS processors.
- *
- * (C) Copyright 2011 Netlogic Microsystems Inc.
- *
- *  Based on various ehci-*.c drivers
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file COPYING in the main directory of this archive for
- * more details.
- */
-
-#include <linux/platform_device.h>
-
-static int ehci_xls_setup(struct usb_hcd *hcd)
-{
-	int	retval;
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-
-	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	/* data structure init */
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci_reset(ehci);
-
-	return retval;
-}
-
-int ehci_xls_probe_internal(const struct hc_driver *driver,
-	struct platform_device *pdev)
-{
-	struct usb_hcd  *hcd;
-	struct resource *res;
-	int retval, irq;
-
-	/* Get our IRQ from an earlier registered Platform Resource */
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "Found HC with no IRQ. Check %s setup!\n",
-				dev_name(&pdev->dev));
-		return -ENODEV;
-	}
-
-	/* Get our Memory Handle */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "Error: MMIO Handle %s setup!\n",
-				dev_name(&pdev->dev));
-		return -ENODEV;
-	}
-	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
-	if (!hcd) {
-		retval = -ENOMEM;
-		goto err1;
-	}
-
-	hcd->rsrc_start = res->start;
-	hcd->rsrc_len = resource_size(res);
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
-				driver->description)) {
-		dev_dbg(&pdev->dev, "controller already in use\n");
-		retval = -EBUSY;
-		goto err2;
-	}
-	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
-
-	if (hcd->regs == NULL) {
-		dev_dbg(&pdev->dev, "error mapping memory\n");
-		retval = -EFAULT;
-		goto err3;
-	}
-
-	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
-	if (retval != 0)
-		goto err4;
-	return retval;
-
-err4:
-	iounmap(hcd->regs);
-err3:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-err2:
-	usb_put_hcd(hcd);
-err1:
-	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev),
-			retval);
-	return retval;
-}
-
-static struct hc_driver ehci_xls_hc_driver = {
-	.description	= hcd_name,
-	.product_desc	= "XLS EHCI Host Controller",
-	.hcd_priv_size	= sizeof(struct ehci_hcd),
-	.irq		= ehci_irq,
-	.flags		= HCD_USB2 | HCD_MEMORY,
-	.reset		= ehci_xls_setup,
-	.start		= ehci_run,
-	.stop		= ehci_stop,
-	.shutdown	= ehci_shutdown,
-
-	.urb_enqueue	= ehci_urb_enqueue,
-	.urb_dequeue	= ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-	.endpoint_reset	= ehci_endpoint_reset,
-
-	.get_frame_number = ehci_get_frame,
-
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control	= ehci_hub_control,
-	.bus_suspend	= ehci_bus_suspend,
-	.bus_resume	= ehci_bus_resume,
-	.relinquish_port = ehci_relinquish_port,
-	.port_handed_over = ehci_port_handed_over,
-
-	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
-};
-
-static int ehci_xls_probe(struct platform_device *pdev)
-{
-	if (usb_disabled())
-		return -ENODEV;
-
-	return ehci_xls_probe_internal(&ehci_xls_hc_driver, pdev);
-}
-
-static int ehci_xls_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_remove_hcd(hcd);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-	return 0;
-}
-
-MODULE_ALIAS("ehci-xls");
-
-static struct platform_driver ehci_xls_driver = {
-	.probe		= ehci_xls_probe,
-	.remove		= ehci_xls_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-	.driver		= {
-		.name = "ehci-xls",
-	},
-};
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index e18f659..40d270e 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1,11 +1,3 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
 /*
  * Open Host Controller Interface (OHCI) driver for USB.
  *
@@ -894,18 +886,6 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 		(void) ohci_readl (ohci, &ohci->regs->control);
 	}
 
-	if (ints & OHCI_INTR_FNO) {
-		ohci_err (ohci, "OHCH frame number overflow\n");
-		ohci_writel (ohci, OHCI_INTR_FNO, &regs->intrstatus);
-		ohci_writel (ohci, OHCI_INTR_FNO, &regs->intrdisable);
-	}
-	
-	if (ints & OHCI_INTR_SO) {
-		ohci_err (ohci, "OHCH scheduling overrun`\n");
-		ohci_writel (ohci, OHCI_INTR_SO, &regs->intrstatus);
-		ohci_writel (ohci, OHCI_INTR_SO, &regs->intrdisable);
-	}	
-
 	return IRQ_HANDLED;
 }
 
@@ -1019,11 +999,6 @@ MODULE_LICENSE ("GPL");
 #define PCI_DRIVER		ohci_pci_driver
 #endif
 
-#ifdef CONFIG_NLM_XLR
-#include "ohci-xls.c"
-#define PLATFORM_DRIVER     ohci_xls_driver
-#endif
-
 #if defined(CONFIG_ARCH_SA1100) && defined(CONFIG_SA1111)
 #include "ohci-sa1111.c"
 #define SA1111_DRIVER		ohci_hcd_sa1111_driver
@@ -1190,10 +1165,6 @@ static int __init ohci_hcd_mod_init(void)
 #endif
 
 #ifdef PLATFORM_DRIVER
-#ifdef CONFIG_NLM_XLR
-    /* On the XLS, use the internal USB Controller */
-    if (is_xls())
-#endif
 	retval = platform_driver_register(&PLATFORM_DRIVER);
 	if (retval < 0)
 		goto error_platform;
@@ -1322,9 +1293,6 @@ static void __exit ohci_hcd_mod_exit(void)
 	platform_driver_unregister(&OF_PLATFORM_DRIVER);
 #endif
 #ifdef PLATFORM_DRIVER
-#ifdef CONFIG_NLM_XLR
-    if (is_xls())
-#endif
 	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
 #ifdef OMAP3_PLATFORM_DRIVER
diff --git a/drivers/usb/host/ohci-xls.c b/drivers/usb/host/ohci-xls.c
deleted file mode 100644
index a224786..0000000
--- a/drivers/usb/host/ohci-xls.c
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * OHCI HCD for Netlogic XLS processors.
- *
- * (C) Copyright 2011 Netlogic Microsystems Inc.
- *
- *  Based on ohci-au1xxx.c, and other Linux OHCI drivers.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file COPYING in the main directory of this archive for
- * more details.
- */
-
-#include <linux/platform_device.h>
-#include <linux/signal.h>
-
-static int ohci_xls_probe_internal(const struct hc_driver *driver,
-			struct platform_device *dev)
-{
-	struct resource *res;
-	struct usb_hcd *hcd;
-	int retval, irq;
-
-	/* Get our IRQ from an earlier registered Platform Resource */
-	irq = platform_get_irq(dev, 0);
-	if (irq < 0) {
-		dev_err(&dev->dev, "Found HC with no IRQ\n");
-		return -ENODEV;
-	}
-
-	/* Get our Memory Handle */
-	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&dev->dev, "MMIO Handle incorrect!\n");
-		return -ENODEV;
-	}
-
-	hcd = usb_create_hcd(driver, &dev->dev, "XLS");
-	if (!hcd) {
-		retval = -ENOMEM;
-		goto err1;
-	}
-	hcd->rsrc_start = res->start;
-	hcd->rsrc_len = resource_size(res);
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
-			driver->description)) {
-		dev_dbg(&dev->dev, "Controller already in use\n");
-		retval = -EBUSY;
-		goto err2;
-	}
-
-	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
-	if (hcd->regs == NULL) {
-		dev_dbg(&dev->dev, "error mapping memory\n");
-		retval = -EFAULT;
-		goto err3;
-	}
-
-	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
-	if (retval != 0)
-		goto err4;
-	return retval;
-
-err4:
-	iounmap(hcd->regs);
-err3:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-err2:
-	usb_put_hcd(hcd);
-err1:
-	dev_err(&dev->dev, "init fail, %d\n", retval);
-	return retval;
-}
-
-static int ohci_xls_reset(struct usb_hcd *hcd)
-{
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-
-	ohci_hcd_init(ohci);
-	return ohci_init(ohci);
-}
-
-static int __devinit ohci_xls_start(struct usb_hcd *hcd)
-{
-	struct ohci_hcd *ohci;
-	int ret;
-
-	ohci = hcd_to_ohci(hcd);
-	ret = ohci_run(ohci);
-	if (ret < 0) {
-		err("can't start %s", hcd->self.bus_name);
-		ohci_stop(hcd);
-		return ret;
-	}
-	return 0;
-}
-
-static struct hc_driver ohci_xls_hc_driver = {
-	.description	= hcd_name,
-	.product_desc	= "XLS OHCI Host Controller",
-	.hcd_priv_size	= sizeof(struct ohci_hcd),
-	.irq		= ohci_irq,
-	.flags		= HCD_MEMORY | HCD_USB11,
-	.reset		= ohci_xls_reset,
-	.start		= ohci_xls_start,
-	.stop		= ohci_stop,
-	.shutdown	= ohci_shutdown,
-	.urb_enqueue	= ohci_urb_enqueue,
-	.urb_dequeue	= ohci_urb_dequeue,
-	.endpoint_disable = ohci_endpoint_disable,
-	.get_frame_number = ohci_get_frame,
-	.hub_status_data = ohci_hub_status_data,
-	.hub_control	= ohci_hub_control,
-#ifdef CONFIG_PM
-	.bus_suspend	= ohci_bus_suspend,
-	.bus_resume	= ohci_bus_resume,
-#endif
-	.start_port_reset = ohci_start_port_reset,
-};
-
-static int ohci_xls_probe(struct platform_device *dev)
-{
-	int ret;
-
-	pr_debug("In ohci_xls_probe");
-	if (usb_disabled())
-		return -ENODEV;
-	ret = ohci_xls_probe_internal(&ohci_xls_hc_driver, dev);
-	return ret;
-}
-
-static int ohci_xls_remove(struct platform_device *dev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
-
-	usb_remove_hcd(hcd);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-	return 0;
-}
-
-static struct platform_driver ohci_xls_driver = {
-	.probe		= ohci_xls_probe,
-	.remove		= ohci_xls_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-	.driver		= {
-		.name	= "ohci-xls-0",
-		.owner	= THIS_MODULE,
-	},
-};
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 95d7df5..257acf3 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -1042,14 +1042,6 @@ config LANTIQ_WDT
 	help
 	  Hardware driver for the Lantiq SoC Watchdog Timer.
 
-config NLM_WATCHDOG
-        tristate "Netlogic XL* Hardware Watchdog"
-        depends on WATCHDOG && NLM_COMMON
-        help
-          Hardware driver for the XL* watchdog. This is a watchdog timer
-          that will reboot the machine after a 60 second timer expired
-          and no process has written to /dev/watchdog during that time.
-
 # PARISC Architecture
 
 # POWERPC Architecture
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 308c14f..e8f479a 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -129,7 +129,6 @@ obj-$(CONFIG_PNX833X_WDT) += pnx833x_wdt.o
 obj-$(CONFIG_SIBYTE_WDOG) += sb_wdog.o
 obj-$(CONFIG_AR7_WDT) += ar7_wdt.o
 obj-$(CONFIG_TXX9_WDT) += txx9wdt.o
-obj-$(CONFIG_NLM_WATCHDOG) += nlm_common_wdt.o
 obj-$(CONFIG_OCTEON_WDT) += octeon-wdt.o
 octeon-wdt-y := octeon-wdt-main.o octeon-wdt-nmi.o
 obj-$(CONFIG_LANTIQ_WDT) += lantiq_wdt.o
diff --git a/drivers/watchdog/phoenix_wdt.c b/drivers/watchdog/phoenix_wdt.c
deleted file mode 100644
index aabd924..0000000
--- a/drivers/watchdog/phoenix_wdt.c
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * drivers/char/watchdog/nlm_common_wdt.c
- *
- * Watchdog driver for RMI processors
- *
- * Adapted from the IXP4xx watchdog driver by Lennert Buytenhek.
- * The original version carries these notices:
- *
- * Author: Deepak Saxena <dsaxena@plexity.net>
- *
- * Copyright 2004 (c) MontaVista, Software, Inc.
- * Based on sa1100 driver, Copyright (C) 2000 Oleg Drokin <green@crimea.edu>
- *
- * This file is licensed under  the terms of the GNU General Public
- * License version 2. This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/miscdevice.h>
-#include <linux/watchdog.h>
-#include <linux/init.h>
-#include <linux/bitops.h>
-#include <linux/jiffies.h>
-#include <linux/reboot.h>
-
-#include <asm/uaccess.h>
-#include <asm/netlogic/sim.h>
-#include <linux/smp_lock.h>
-
-static int nowayout = WATCHDOG_NOWAYOUT;
-static unsigned int heartbeat = 60;	/* (secs) Default is 1 minute */
-static unsigned long nlm_common_wdt_status;
-
-#define	WDT_IN_USE		0
-#define	WDT_OK_TO_CLOSE		1
-
-static unsigned long nlm_common_wdt_tick_rate;
-
-static void
-nlm_common_wdt_enable(void)
-{
-        nlm_reg_t *mmio;
-	printk("[%s] -\n", __FUNCTION__);
-        mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
-
-        /* The WatchDog timer requires configuration before it can be used. The
-           WatchDog Max Value register contains the value of the counter that
-           will be reloaded every time it starts counting.
-           WatchDogMaxValue{0,1} = 0.1 * 66Mhz */
-
-        netlogic_write_reg(mmio, 0x08, heartbeat * 66666666);
-        netlogic_write_reg(mmio, 0x09, 0x00000000);
-
-        /* The Heartbeat Register maintains a record of which threads have
-           acknowledged with a heartbeat. The Heartbeat Mask register
-           quantifies which threads need to acknowledge. If all the required
-           Heartbeats are not received before the Timer reaches 0, an
-           interrupt will be generated.
-           WatchDogMask{0,1} = 0x00000000ffffffff */
-
-        netlogic_write_reg(mmio, 0x0a, smp_boot.online_map);
-        netlogic_write_reg(mmio, 0x0b, 0x00000000);
-
-        /* PIC_IRT_ENTRY_WATCHDOG = {Interrupt Delivery CPU Mask[31:0]=1
-                                     Valid[63]=1 Trigger[62]=0
-                                     Polarity[61]=0 NMI[39]=1
-                                     Scheduling[38]=1 Interrupt
-                                     Vector[35:32]=8} */
-
-        netlogic_write_reg(mmio, 0x40, 0x00000001); /* XXX: first cpu */
-        netlogic_write_reg(mmio, 0x80, 0x800000c8);
-
-        /* Watchdog Enable[0]=1 : */
-
-        netlogic_write_reg(mmio, 0x00, netlogic_read_reg(mmio, 0x00) | 1);
-}
-
-static void
-nlm_common_wdt_disable(void)
-{
-	nlm_reg_t *mmio;
-	printk("[%s] -\n", __FUNCTION__);
-	mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
-
-	/* Watchdog Enable[0]=1 : */
-
-	netlogic_write_reg(mmio, 0x00, netlogic_read_reg(mmio, 0x00) & ~1);
-}
-
-static void
-nlm_common_wdt_keepalive(void)
-{
-        nlm_reg_t *mmio;
-        printk("[%s] -\n", __FUNCTION__);
-        mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
-
-	/* ack the watchdog on the first cpu */
-
-	netlogic_write_reg(mmio, 0x0c, 1);
-
-	/* other cpu ack the watchdog in their timer interrupt handler */
-}
-
-static int
-nlm_common_wdt_open(struct inode *inode, struct file *file)
-{
-	printk("[%s] -\n", __FUNCTION__);
-
-	if (test_and_set_bit(WDT_IN_USE, &nlm_common_wdt_status))
-		return -EBUSY;
-
-	clear_bit(WDT_OK_TO_CLOSE, &nlm_common_wdt_status);
-
-	nlm_common_wdt_enable();
-
-	return nonseekable_open(inode, file);
-}
-
-static ssize_t
-nlm_common_wdt_write(struct file *file, const char *data, size_t len, loff_t *ppos)
-{
-	printk("[%s] - len %d\n", __FUNCTION__, len);
-
-	if (len) {
-		if (!nowayout) {
-			size_t i;
-
-			clear_bit(WDT_OK_TO_CLOSE, &nlm_common_wdt_status);
-
-			for (i = 0; i != len; i++) {
-				char c;
-
-				if (get_user(c, data + i))
-					return -EFAULT;
-				if (c == 'V')
-					set_bit(WDT_OK_TO_CLOSE, &nlm_common_wdt_status);
-			}
-		}
-		nlm_common_wdt_keepalive();
-	}
-
-	return len;
-}
-
-
-static struct watchdog_info ident = {
-	.options	= WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT |
-				WDIOF_KEEPALIVEPING,
-	.identity	= "RMI Watchdog",
-};
-
-int
-nlm_common_wdt_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-			unsigned long arg)
-{
-	int ret = -ENOTTY;
-	int time;
-
-	printk("[%s] - cmd %x arg %lx\n", __FUNCTION__, cmd, arg);
-	switch (cmd) {
-	case WDIOC_GETSUPPORT:
-		ret = copy_to_user((struct watchdog_info *)arg, &ident,
-				   sizeof(ident)) ? -EFAULT : 0;
-		break;
-
-	case WDIOC_GETSTATUS:
-		ret = put_user(0, (int *)arg);
-		break;
-
-	case WDIOC_GETBOOTSTATUS:
-		ret = put_user(0, (int *)arg);
-		break;
-
-	case WDIOC_SETTIMEOUT:
-		ret = get_user(time, (int *)arg);
-		if (ret)
-			break;
-
-		if (time <= 0 || time > 60) {
-			ret = -EINVAL;
-			break;
-		}
-
-		heartbeat = time;
-		nlm_common_wdt_keepalive();
-		/* Fall through */
-
-	case WDIOC_GETTIMEOUT:
-		ret = put_user(heartbeat, (int *)arg);
-		break;
-
-	case WDIOC_KEEPALIVE:
-		nlm_common_wdt_enable();
-		ret = 0;
-		break;
-	}
-
-	return ret;
-}
-
-long nlm_common_wdt_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	unsigned long ret = -1;
-  	lock_kernel();
-	ret = nlm_common_wdt_ioctl(NULL, filp, cmd, arg);
-	unlock_kernel();
-	if(ret){
-		printk("%s: ioctl error\n", __FUNCTION__);
-		return -EINVAL;
-	}
-	return ret;
-}
-
-static int
-nlm_common_wdt_release(struct inode *inode, struct file *file)
-{
-	printk("[%s] -\n", __FUNCTION__);
-
-	if (test_bit(WDT_OK_TO_CLOSE, &nlm_common_wdt_status)) {
-		nlm_common_wdt_disable();
-	} else {
-		printk(KERN_CRIT "WATCHDOG: Device closed unexpectedly - "
-					"timer will not stop\n");
-	}
-	clear_bit(WDT_IN_USE, &nlm_common_wdt_status);
-	clear_bit(WDT_OK_TO_CLOSE, &nlm_common_wdt_status);
-
-	return 0;
-}
-
-static int nlm_common_notify_sys(struct notifier_block *this, unsigned long code, void *unused)
-{
-        if (code == SYS_DOWN || code == SYS_HALT)
-                nlm_common_wdt_disable();         /* Turn the WDT off */
-
-        return NOTIFY_DONE;
-}
-
-static const struct file_operations nlm_common_wdt_fops =
-{
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.write		= nlm_common_wdt_write,
-	.ioctl		= nlm_common_wdt_ioctl,
-	.compat_ioctl   = nlm_common_wdt_compat_ioctl,
-	.open		= nlm_common_wdt_open,
-	.release	= nlm_common_wdt_release,
-};
-
-static struct miscdevice nlm_common_wdt_miscdev =
-{
-	.minor		= WATCHDOG_MINOR,
-	.name		= "watchdog",
-	.fops		= &nlm_common_wdt_fops,
-};
-
-static struct notifier_block nlm_common_notifier = {
-        .notifier_call = nlm_common_notify_sys,
-};
-
-static int __init nlm_common_wdt_init(void)
-{
-	int ret;
-	printk("[%s] -\n", __FUNCTION__);
-	nlm_common_wdt_tick_rate = HZ;
-        ret = register_reboot_notifier(&nlm_common_notifier);
-        if (ret) {
-                printk(KERN_ERR "cannot register reboot notifier (err=%d)\n",
-                        ret);
-                return ret;
-        }
-	return misc_register(&nlm_common_wdt_miscdev);
-}
-
-static void __exit nlm_common_wdt_exit(void)
-{
-	printk("[%s] -\n", __FUNCTION__);
-	misc_deregister(&nlm_common_wdt_miscdev);
-	unregister_reboot_notifier(&nlm_common_notifier);
-}
-
-module_init(nlm_common_wdt_init);
-module_exit(nlm_common_wdt_exit);
-
-MODULE_AUTHOR("RMI Corp.">);
-MODULE_DESCRIPTION("RMI Processors Watchdog");
-
-module_param(heartbeat, int, 0);
-MODULE_PARM_DESC(heartbeat, "Watchdog heartbeat in seconds (default 60s)");
-
-module_param(nowayout, int, 0);
-MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
-
-MODULE_LICENSE("GPL");
-MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
-
diff --git a/fs/dcookies.c b/fs/dcookies.c
index 0027c55..17c7799 100644
--- a/fs/dcookies.c
+++ b/fs/dcookies.c
@@ -209,51 +209,6 @@ asmlinkage long SyS_lookup_dcookie(u64 cookie64, long buf, long len)
 SYSCALL_ALIAS(sys_lookup_dcookie, SyS_lookup_dcookie);
 #endif
 
-#if defined (CONFIG_64BIT) && defined (CONFIG_NLM_COMMON)
-#if defined (CONFIG_MIPS32_O32) || defined (CONFIG_MIPS32_N32)
-#ifdef CONFIG_HAVE_SYSCALL_WRAPPERS
-compat_SyS_lookup_dcookie(u32 cookie_msb, u32 cookie_lsb,
-        compat_uptr_t buf, compat_size_t len)
-{
-    u64 cookie;
-    char __user *user_buf;
-    size_t size;
-
-    size = (size_t)len;
-
-    user_buf = compat_ptr(buf);
-
-#ifdef CONFIG_CPU_BIG_ENDIAN
-    cookie = (((u64)cookie_msb) << 32) | (u64)cookie_lsb;
-#else
-    cookie = (((u64)cookie_lsb) << 32) | (u64)cookie_msb;
-#endif
-
-    return SYSC_lookup_dcookie(cookie, user_buf, size);
-
-}
-SYSCALL_ALIAS(compat_sys_lookup_dcookie, compat_SyS_lookup_dcookie);
-#else
-compat_sys_lookup_dcookie(u32 cookie_msb, u32 cookie_lsb,
-        compat_uptr_t buf, compat_size_t len)
-{
-    u64 cookie;
-    char __user *user_buf;
-    size_t size;
-
-    size = (size_t)len;
-
-    user_buf = compat_ptr(buf);
-    cookie = (((u64)cookie_msb) << 32) | (u64)cookie_lsb;
-
-    return sys_lookup_dcookie(cookie, user_buf, size);
-
-}
-#endif
-#endif
-#endif
-
-
 static int dcookie_init(void)
 {
 	struct list_head * d;
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
index 1d5bc89..b92eadf 100644
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -51,8 +51,6 @@
 #define CRYPTO_ALG_DYING		0x00000040
 #define CRYPTO_ALG_ASYNC		0x00000080
 
-#define CRYPTO_ALG_HW                   0x00000100
-
 /*
  * Set this bit if and only if the algorithm requires another algorithm of
  * the same type to handle corner cases.
@@ -310,11 +308,6 @@ struct crypto_alg {
 	void (*cra_destroy)(struct crypto_alg *alg);
 	
 	struct module *cra_module;
-	struct crypto_alg *cra_helper; /* Only makes sense for hw algs. 
-					This is a pointer to sw implementation, 
-					it can be used as fallback 
-					implementation if hw one cannot handle 
-					particular request. */
 };
 
 /*
diff --git a/include/linux/libata.h b/include/linux/libata.h
index eb46f8e..6e887c7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -55,7 +55,7 @@
  */
 #undef ATA_DEBUG		/* debugging output */
 #undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
-#define ATA_IRQ_TRAP		/* define to ack screaming irqs */
+#undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
 #undef ATA_NDEBUG		/* define to disable quick runtime checks */
 
 
diff --git a/include/linux/linkage.h b/include/linux/linkage.h
index f10d848..807f1e5 100644
--- a/include/linux/linkage.h
+++ b/include/linux/linkage.h
@@ -54,13 +54,13 @@
 #ifdef __ASSEMBLY__
 
 #ifndef LINKER_SCRIPT
-#define ASM_ALIGN __ALIGN
-#define ASM_ALIGN_STR __ALIGN_STR
+#define ALIGN __ALIGN
+#define ALIGN_STR __ALIGN_STR
 
 #ifndef ENTRY
 #define ENTRY(name) \
   .globl name; \
-  ASM_ALIGN; \
+  ALIGN; \
   name:
 #endif
 #endif /* LINKER_SCRIPT */
diff --git a/include/linux/nlm_common_tb.h b/include/linux/nlm_common_tb.h
deleted file mode 100644
index ca3c0ce..0000000
--- a/include/linux/nlm_common_tb.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-#ifndef __USER_MIPS_NLM_PHNXTB_H
-#define __USER_MIPS_NLM_PHNXTB_H
-
-#include <asm/ioctl.h>
-
-/* Trace Buffer registers */
-
-#define    TB_REQMATCH_REGS         0x00
-#define    TB_REQMATCH_REG_1        0x00
-#define    TB_REQMATCH_REG_2        0x01
-#define    TB_RADDR_REGS            0x02
-#define    TB_RADDR_REG_1           0x02
-#define    TB_RADDR_REG_2           0x03
-#define    TB_CTRL_REG              0x04
-#define    TB_INIT_REG              0x05
-#define    TB_ACCESS_REG            0x06
-#define    TB_RDDATA_REGS           0x07
-#define    TB_WRDATA_REGS           0x0b
-#define    TB_STATUS_REG            0x0f
-
-// values
-#define    TB_REQMATCH_RCMD_WR             0x01
-#define    TB_REQMATCH_RCMD_RD             0x02
-#define    TB_REQMATCH_RCMD_RDEX           0x03
-#define    TB_REQMATCH_RCMD_UPGRD          0x04
-#define    TB_REQMATCH_RCMD_INV            0x05
-#define    TB_REQMATCH_RCMD_MASK           0x00000007
-#define    TB_SET_RCMD(reg, val)    \
-               reg |= (val & TB_REQMATCH_RCMD_MASK)
-#define    TB_GET_RCMD(reg) \
-               (reg & TB_REQMATCH_RCMD_MASK)
-
-// Node ID
-#define    TB_REQMATCH_RCONNID_SHIFT       4 
-#define    TB_REQMATCH_RCONNID_MASK        0x0000001f
-#define    TB_SET_RCONNID(reg, nodeId)     \
-                reg |= (nodeId & TB_REQMATCH_RCONNID_MASK) << TB_REQMATCH_RCONNID_SHIFT
-#define    TB_GET_RCONNID(reg) \
-                ((reg >> TB_REQMATCH_RCONNID_SHIFT) & TB_REQMATCH_RCONNID_MASK)
-
-// Transaction ID
-#define    TB_REQMATCH_RTHREADID_SHIFT     12
-#define    TB_REQMATCH_RTHREADID_MASK      0x0000008f
-#define    TB_SET_REQMATCH_RTHREADID(reg, transId)    \
-               reg |= (transId & TB_REQMATCH_RTHREADID_MASK) << TB_REQMATCH_RTHREADID_SHIFT
-#define    TB_GET_REQMATCH_RTHREADID(reg) \
-               ((reg >> TB_REQMATCH_RTHREADID_SHIFT) & TB_REQMATCH_RTHREADID_MASK)
-
-// Snoop Status
-#define    TB_REQMATCH_SSTAT
-#define    TB_REQMATCH_SSTAT_BRIDGE            0x00100000
-#define    TB_REQMATCH_SSTAT_L1TAG             0x00200000
-#define    TB_REQMATCH_SSTAT_L2CTAG            0x00400000
-#define    TB_REQMATCH_SSTAT_L2UCTAG           0x00800000
-
-#define    TB_SET_REQMATCH_SSTAT(x, val)       x |= val
-#define    TB_IS_SET_REQMATCH_SSTAT(x, val)    (x & val)
-
-// Cacheable?
-#define    TB_REQMATCH_RCACHE              0x01000000
-#define    TB_SET_REQMATCH_CACHEABLE(x)    x |=  TB_REQMATCH_RCACHE
-#define    TB_IS_REQMATCH_CACHEABLE(x)     (x & TB_REQMATCH_RCACHE)
-
-// Node ID of Hit
-#define    TB_REQMATCH_RSPHITID_MASK       0x0000001f
-#define    TB_SET_REQMATCH_RSPHITID(reg, hitNodeId)    \
-               reg |= (hitNodeId & TB_REQMATCH_RSPHITID_MASK)
-#define    TB_GET_REQMATCH_RSPHITID(reg) (reg & TB_REQMATCH_RSPHITID_MASK)
-
-// Snoop Result Status
-#define    TB_REQMATCH_SRSLT_CPUSHR            0x00000100
-#define    TB_REQMATCH_SRSLT_CPUMOD            0x00000200
-#define    TB_REQMATCH_SRSLT_L2SHR             0x00000400
-#define    TB_REQMATCH_SRSLT_L2MODE            0x00000800
-
-#define    TB_SET_REQMATCH_SRSLT(x, val)       x |= val
-#define    TB_IS_SET_REQMATCH_SRSLT(x,val)     (x & val)
-
-#define    TB_CTRL_RCMD                    0x0001
-#define    TB_CTRL_RCONNID                 0x0002
-#define    TB_CTRL_RTHREADID               0x0004
-#define    TB_CTRL_SSTAT                   0x0008
-#define    TB_CTRL_RCACHE                  0x0010
-#define    TB_CTRL_SRSPHITID               0x0020
-#define    TB_CTRL_SRSLT                   0x0040
-#define    TB_CTRL_RADDR                   0x0080
-#define    TB_CTRL_COLLMODE_MATCHONLY      0x0100
-
-#define    TB_SET_CTRL(x, flag)            x |= flag
-#define    TB_IS_SET_CTRL(x, flag)         (x & flag)
-
-#define    TB_CTRL_REQCNT_SHIFT            16
-#define    TB_CTRL_REQCNT_MASK             0x000000ff
-#define    TB_SET_CTRL_REQCNT(reg, cnt)    \
-               reg |= ((cnt & TB_CTRL_REQCNT_MASK) << TB_CTRL_REQCNT_SHIFT)
-#define    TB_GET_CTRL_REQCNT(reg) \
-               ((reg >> TB_CTRL_REQCNT_SHIFT) & TB_CTRL_REQCNT_MASK)
-
-#define    TB_CTRL_DISABLE                 0x01000000
-#define    TB_SET_CTRL_DISABLE(x)          x |= TB_CTRL_DISABLE
-#define    TB_IS_CTRL_DISABLED(x)          (x & TB_CTRL_DISABLE)
-
-#define    TB_EMPTY              0x01
-#define    TB_FULL               0x02
-#define    TB_COLLECTS_BMATCH    0x10
-#define    TB_COLLECTS_AMATCH    0x20
-#define    TB_STATUS_DONE        0x40
-#define    TB_DISABLED           0x80
-
-#define    TB_IS_EMPTY(x)              (x & TB_EMPTY)
-#define    TB_IS_FULL(x)               (x & TB_FULL)
-#define    TB_IS_COLLECTS_BMATCH(x)    (x & TB_COLLECTS_BMATCH)
-#define    TB_IS_COLLECTS_AMATCH(x)    (x & TB_COLLECTS_AMATCH)
-#define    TB_IS_STATUS_DONE(x) 	   (x & TB_STATUS_DONE)
-#define    TB_IS_DISABLED(x)           (x & TB_DISABLED)
-
-#define    TB_WRPTR_SHIFT        8
-#define    TB_WRPTR_MASK         0x000000ff
-#define    TB_GET_WRPTR(reg)     \
-               ((reg >> TB_WRPTR_SHIFT) & TB_WRPTR_MASK)
-
-#define    TB_RDPTR_SHIFT        16
-#define    TB_RDPTR_MASK         0x000000ff
-#define    TB_GET_RDPTR(reg)     \
-               ((reg >> TB_RDPTR_SHIFT) & TB_RDPTR_MASK)
-
-#define    TB_FIRST_MATCH_PTR_SHIFT    24
-#define    TB_FIRST_MATCH_PTR_MASK     0x000000ff
-#define    TB_GET_FIRST_MATCH_PTR(reg)     \
-               ((reg >> TB_FIRST_MATCH_PTR_SHIFT) & TB_FIRST_MATCH_PTR_MASK) 
-
-typedef struct tb_register {
-    int             type;
-    unsigned int    val;
-} tb_register_t;
-
-#define TB_IOC_MAGIC 241
-
-#define    TB_IOC_GTBREG    _IO(TB_IOC_MAGIC, 0)
-#define    TB_IOC_STBREG    _IO(TB_IOC_MAGIC, 1)
-#define    TB_IOC_REINIT    _IO(TB_IOC_MAGIC, 2)
-
-#endif
diff --git a/include/linux/perfctr.h b/include/linux/perfctr.h
deleted file mode 100644
index 672d266..0000000
--- a/include/linux/perfctr.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/* $Id: perfctr.h,v 1.1.2.4 2006-09-28 01:24:22 nphilips Exp $
- * Performance-Monitoring Counters driver
- *
- * Copyright (C) 1999-2004  Mikael Pettersson
- */
-#ifndef _LINUX_PERFCTR_H
-#define _LINUX_PERFCTR_H
-
-#ifdef CONFIG_PERFCTR	/* don't break archs without <asm/perfctr.h> */
-
-#include <asm/perfctr.h>
-
-// Ensure that the following constant doesn't conflict constants specified
-// for other entries in "/proc/sys"
-
-#define CTL_PERFCTR	171
-
-// Extend the following enum type if more entries have to be created under
-// "/proc/sys/perfctr"
-
-enum {
-	PERFCTR_CNTMODE = 1
-};
-
-struct perfctr_info {
-	unsigned int abi_version;
-	char driver_version[32];
-	unsigned int cpu_type;
-	unsigned int cpu_features;
-	unsigned int cpu_khz;
-	unsigned int tsc_to_cpu_mult;
-	unsigned int _reserved2;
-	unsigned int _reserved3;
-	unsigned int _reserved4;
-};
-
-struct perfctr_cpu_mask {
-	unsigned int nrwords;
-	unsigned int mask[1];	/* actually 'nrwords' */
-};
-
-/* abi_version values: Lower 16 bits contain the CPU data version, upper
-   16 bits contain the API version. Each half has a major version in its
-   upper 8 bits, and a minor version in its lower 8 bits. */
-#define PERFCTR_API_VERSION	0x0600	/* 6.0 */
-#define PERFCTR_ABI_VERSION	((PERFCTR_API_VERSION<<16)|PERFCTR_CPU_VERSION)
-
-/* cpu_features flag bits */
-#define PERFCTR_FEATURE_RDPMC	0x01
-#define PERFCTR_FEATURE_RDTSC	0x02
-#define PERFCTR_FEATURE_PCINT	0x04
-
-/* user's view of mmap:ed virtual perfctr */
-struct vperfctr_state {
-	struct perfctr_cpu_state cpu_state;
-};
-
-/* virtual perfctr control object */
-struct vperfctr_control {
-	int si_signo;
-	unsigned int preserve;
-	unsigned int _reserved1;
-	unsigned int _reserved2;
-	unsigned int _reserved3;
-	unsigned int _reserved4;
-	struct perfctr_cpu_control cpu_control;
-};
-
-/* commands for sys_vperfctr_read() */
-#define VPERFCTR_READ_SUM	0x01
-#define VPERFCTR_READ_CONTROL	0x02
-#define VPERFCTR_READ_CHILDREN	0x03
-
-#else
-struct perfctr_info;
-struct perfctr_cpu_mask;
-struct perfctr_sum_ctrs;
-struct vperfctr_control;
-#endif	/* CONFIG_PERFCTR */
-
-#ifdef __KERNEL__
-
-/*
- * The perfctr system calls.
- */
-asmlinkage long sys_vperfctr_open(int tid, int creat);
-asmlinkage long sys_vperfctr_control(int fd,
-				     const struct vperfctr_control __user *argp,
-				     unsigned int argbytes);
-asmlinkage long sys_vperfctr_unlink(int fd);
-asmlinkage long sys_vperfctr_iresume(int fd);
-asmlinkage long sys_vperfctr_read(int fd, unsigned int cmd, void __user *argp, unsigned int argbytes);
-
-extern struct perfctr_info perfctr_info;
-
-#ifdef CONFIG_PERFCTR_VIRTUAL
-
-/*
- * Virtual per-process performance-monitoring counters.
- */
-struct vperfctr;	/* opaque */
-
-/* process management operations */
-extern void __vperfctr_copy(struct task_struct*, struct pt_regs*);
-extern void __vperfctr_release(struct task_struct*);
-extern void __vperfctr_exit(struct vperfctr*);
-extern void __vperfctr_suspend(struct vperfctr*);
-extern void __vperfctr_resume(struct vperfctr*);
-extern void __vperfctr_sample(struct vperfctr*);
-extern void __vperfctr_set_cpus_allowed(struct task_struct*, struct vperfctr*, cpumask_t);
-
-static inline void perfctr_copy_task(struct task_struct *tsk, struct pt_regs *regs)
-{
-	if (tsk->thread.perfctr) {
-		__vperfctr_copy(tsk, regs);
-	}
-}
-
-static inline void perfctr_release_task(struct task_struct *tsk)
-{
-	if (tsk->thread.perfctr) {
-		__vperfctr_release(tsk);
-	}
-}
-
-static inline void perfctr_exit_thread(struct thread_struct *thread)
-{
-	struct vperfctr *perfctr;
-	perfctr = thread->perfctr;
-	if (perfctr) {
-		__vperfctr_exit(perfctr);
-	}
-}
-
-static inline void perfctr_suspend_thread(struct thread_struct *prev)
-{
-	struct vperfctr *perfctr;
-	perfctr = prev->perfctr;
-	if (perfctr) {
-		__vperfctr_suspend(perfctr);
-	}
-}
-
-static inline void perfctr_resume_thread(struct thread_struct *next)
-{
-	struct vperfctr *perfctr;
-	perfctr = next->perfctr;
-	if (perfctr) {
-		__vperfctr_resume(perfctr);
-	}
-}
-
-static inline void perfctr_sample_thread(struct thread_struct *thread)
-{
-	struct vperfctr *perfctr;
-	perfctr = thread->perfctr;
-	if (perfctr) {
-		__vperfctr_sample(perfctr);
-	}
-}
-
-static inline void perfctr_set_cpus_allowed(struct task_struct *p, cpumask_t new_mask)
-{
-#ifdef CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK
-	struct vperfctr *perfctr;
-
-	task_lock(p);
-	perfctr = p->thread.perfctr;
-	if (perfctr) {
-		__vperfctr_set_cpus_allowed(p, perfctr, new_mask);
-	}
-	task_unlock(p);
-#endif
-}
-
-#else	/* !CONFIG_PERFCTR_VIRTUAL */
-
-static inline void perfctr_copy_task(struct task_struct *p, struct pt_regs *r) { }
-static inline void perfctr_release_task(struct task_struct *p) { }
-static inline void perfctr_exit_thread(struct thread_struct *t) { }
-static inline void perfctr_suspend_thread(struct thread_struct *t) { }
-static inline void perfctr_resume_thread(struct thread_struct *t) { }
-static inline void perfctr_sample_thread(struct thread_struct *t) { }
-static inline void perfctr_set_cpus_allowed(struct task_struct *p, cpumask_t m) { }
-
-#endif	/* CONFIG_PERFCTR_VIRTUAL */
-
-#endif	/* __KERNEL__ */
-
-#endif	/* _LINUX_PERFCTR_H */
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index d683423..ec07237 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -566,13 +566,21 @@ extern struct sk_buff *build_skb(void *data);
 static inline struct sk_buff *alloc_skb(unsigned int size,
 					gfp_t priority)
 {
+#if defined(CONFIG_NLM_XLP) && defined(CONFIG_64BIT)
+	return __alloc_skb(size, priority | GFP_DMA, 0, NUMA_NO_NODE);
+#else
 	return __alloc_skb(size, priority, 0, NUMA_NO_NODE);
+#endif
 }
 
 static inline struct sk_buff *alloc_skb_fclone(unsigned int size,
 					       gfp_t priority)
 {
+#if defined(CONFIG_NLM_XLP) && defined(CONFIG_64BIT)
+	return __alloc_skb(size, priority | GFP_DMA, 1, NUMA_NO_NODE);
+#else
 	return __alloc_skb(size, priority, 1, NUMA_NO_NODE);
+#endif
 }
 
 extern void skb_recycle(struct sk_buff *skb);
@@ -1679,7 +1687,7 @@ static inline void __skb_queue_purge(struct sk_buff_head *list)
 static inline struct sk_buff *__dev_alloc_skb(unsigned int length,
 					      gfp_t gfp_mask)
 {
-#if defined(CONFIG_NLM_COMMON) && defined(CONFIG_64BIT)
+#if defined(CONFIG_NLM_XLP) && defined(CONFIG_64BIT)
 	struct sk_buff *skb = alloc_skb(length + NET_SKB_PAD, gfp_mask | GFP_DMA);
 #else
 	struct sk_buff *skb = alloc_skb(length + NET_SKB_PAD, gfp_mask);
@@ -1710,7 +1718,7 @@ extern struct sk_buff *__netdev_alloc_skb(struct net_device *dev,
 static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,
 		unsigned int length)
 {
-#if defined(CONFIG_NLM_COMMON) && defined(CONFIG_64BIT)
+#if defined(CONFIG_NLM_XLP) && defined(CONFIG_64BIT)
 	return __netdev_alloc_skb(dev, length, GFP_ATOMIC | GFP_DMA);
 #else
 	return __netdev_alloc_skb(dev, length, GFP_ATOMIC);
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 7ca1859..5f7309d 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -594,18 +594,7 @@ asmlinkage long sys_mkdir(const char __user *pathname, umode_t mode);
 asmlinkage long sys_chdir(const char __user *filename);
 asmlinkage long sys_fchdir(unsigned int fd);
 asmlinkage long sys_rmdir(const char __user *pathname);
-#if defined (CONFIG_64BIT) && defined (CONFIG_NLM_COMMON)
-#if defined (CONFIG_MIPS32_O32) || defined (CONFIG_MIPS32_N32)
-long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
-#include <asm/compat.h>
-asmlinkage long compat_sys_lookup_dcookie(u32 cookie_msb, u32 cookie_lsb,
-                                      compat_uptr_t buf, compat_size_t len);
-#else
 asmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
-#endif
-#else
-asmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
-#endif
 asmlinkage long sys_quotactl(unsigned int cmd, const char __user *special,
 				qid_t id, void __user *addr);
 asmlinkage long sys_getdents(unsigned int fd,
diff --git a/include/user/netlogic/nlm_common_msgring.h b/include/user/netlogic/nlm_common_msgring.h
deleted file mode 100644
index 5ed5080..0000000
--- a/include/user/netlogic/nlm_common_msgring.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef __USER_NLM_XLR_MSG_RNG_H
-#define __USER_NLM_XLR_MSG_RNG_H
-
-#include <asm/ioctl.h>
-
-struct msgring_msg_data {
-  int		size;
-  int           code;
-  int           stid;
-  int           rx_bucket;
-  unsigned int  msgs[8];
-};
-
-#define MSG_RNG_IOC_MAGIC 'M'
-
-#define    MSGRING_IOC_SSTNNO       _IOW(MSG_RNG_IOC_MAGIC, 0, unsigned int)
-#define    MSGRING_IOC_GSHMPHYS     _IOR(MSG_RNG_IOC_MAGIC, 1, unsigned int)
-#define    MSGRING_IOC_GSHMVIRT     _IOR(MSG_RNG_IOC_MAGIC, 2, unsigned int)
-#define    MSGRING_IOC_GMMAP_START  _IOR(MSG_RNG_IOC_MAGIC, 3, unsigned int)
-#define    MSGRING_IOC_SYSINIT      _IOR(MSG_RNG_IOC_MAGIC, 4, unsigned int)
-#define    MSGRING_IOC_SYSPHYS      _IOR(MSG_RNG_IOC_MAGIC, 5, unsigned int)
-#define    MSGRING_IOC_SYSCALL      _IOW(MSG_RNG_IOC_MAGIC, 6, unsigned int)
-
-#define NLM_MSGRING_CHRDEV_NAME "xlr_msgring_shm"
-
-#endif
diff --git a/include/user/netlogic/xlr_mmap.h b/include/user/netlogic/xlr_mmap.h
deleted file mode 100644
index 48d4bc6..0000000
--- a/include/user/netlogic/xlr_mmap.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef __USER_NLM_XLR_MMAP_H
-#define __USER_NLM_XLR_MMAP_H
-
-#include <asm/ioctl.h>
-
-
-#define NLM_MMAP_IOC_MAGIC 'N'
-
-#define    NLM_MMAP_IOC_GPHYS_START         _IOR(NLM_MMAP_IOC_MAGIC, 0, unsigned long)
-#define    NLM_MMAP_IOC_GPHYS_SIZE          _IOR(NLM_MMAP_IOC_MAGIC, 1, unsigned long)
-#define    NLM_MMAP_IOC_GVIRT_START         _IOR(NLM_MMAP_IOC_MAGIC, 2, unsigned long)
-
-#endif
diff --git a/include/user/netlogic/xlr_user_mac.h b/include/user/netlogic/xlr_user_mac.h
deleted file mode 100644
index 4e0fa9b..0000000
--- a/include/user/netlogic/xlr_user_mac.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef __USER_NLM_XLR_USER_MAC_H
-#define __USER_NLM_XLR_USER_MAC_H
-
-#include <asm/ioctl.h>
-
-#define USER_MAC_IOC_MAGIC 'M'
-
-#define    USER_MAC_IOC_GSHMPHYS            _IOR(USER_MAC_IOC_MAGIC, 1, unsigned int)
-#define    USER_MAC_IOC_GSHMVIRT            _IOR(USER_MAC_IOC_MAGIC, 2, unsigned int)
-#define    USER_MAC_IOC_GSHMSIZE            _IOR(USER_MAC_IOC_MAGIC, 3, unsigned int)
-#define    USER_MAC_IOC_GMMAP_START         _IOR(USER_MAC_IOC_MAGIC, 4, unsigned int)
-#define    USER_MAC_IOC_SWRITE_REG          _IOW(USER_MAC_IOC_MAGIC, 10, unsigned int)
-#define    USER_MAC_IOC_GREAD_REG           _IOR(USER_MAC_IOC_MAGIC, 11, unsigned int)
-#define    USER_MAC_IOC_SPERF               _IOW(USER_MAC_IOC_MAGIC, 12, unsigned int)
-#define    USER_MAC_IOC_GPHYS_CPU_PRESENT_MAP _IOR(USER_MAC_IOC_MAGIC, 13, unsigned int)
-#define    USER_MAC_IOC_GCPU_ONLINE_MAP     _IOR(USER_MAC_IOC_MAGIC, 14, unsigned int)
-#define    USER_MAC_IOC_HYBRID_MODE_SETUP   _IOR(USER_MAC_IOC_MAGIC, 15, unsigned int)
-#define    USER_MAC_IOC_HUGETLB_SHM_VIRT_ADDR _IOR(USER_MAC_IOC_MAGIC, 16, unsigned int)
-#define    USER_MAC_IOC_EARLY_MEM_INIT		_IOR(USER_MAC_IOC_MAGIC, 17, unsigned int)
-
-#define NLM_USER_MAC_CHRDEV_NAME "xlr_user_mac"
-
-#define MAX_USER_MAC_PKTS 3072
-#define MAX_USER_MAC_FRIN_PKTS (MAX_USER_MAC_PKTS - 256)
-#define USER_MAC_FIFO_SIZE 128
-#define USER_MAC_PKT_BUF_SIZE 1600
-
-struct packet_data {
-  unsigned char data[USER_MAC_PKT_BUF_SIZE];
-};
-
-struct packet_desc {
-  unsigned int offset;
-  int len;
-  int port;
-  int type;
-  int xgmac; //ignore in gmac. 1 xgmac loopback, 2, xgmac crossover
-  int device; //0 xgmac0, 1 xgmac1
-  int free;
-  unsigned char priv[48];
-  uint64_t priv_ptr;	//uint32_t *priv_ptr;
-};
-
-#define USER_MAC_TXQ_FREE 0
-#define USER_MAC_TXQ_TX 1
-#define USER_MAC_TXQ_HOST 2
-
-struct user_mac_time {
-  unsigned int hi;
-  unsigned int lo;
-};
-struct user_mac_data {
-  struct packet_data pkt_data[MAX_USER_MAC_PKTS];
-  struct packet_desc pkt_desc[MAX_USER_MAC_PKTS];
-  struct user_mac_time time;
-  struct timespec ktime;
-  int host_pkt_next_free[32];
-};
-
-/* copy all the user_mac_data which are accessed from the kernal to user_mac_kernal_data */
-struct user_mac_kernal_data {
-	struct user_mac_time time;
-	struct timespec ktime;
-};
-
-static __inline__ unsigned char *user_mac_host_pkt_alloc(struct user_mac_data *user_mac, int cpu)
-{
-	int num_pkts = (MAX_USER_MAC_PKTS - MAX_USER_MAC_FRIN_PKTS) / 32;
-	int start_index = MAX_USER_MAC_FRIN_PKTS + (cpu * num_pkts);
-	int next_free = user_mac->host_pkt_next_free[cpu];
-	int i=0;
-
-	if (next_free < start_index || next_free >= (start_index + num_pkts)) 
-		return NULL;
-	
-	for (i=next_free; i<(start_index+num_pkts) ;i++) {
-		if (user_mac->pkt_desc[i].free) {
-			user_mac->pkt_desc[i].free = 0;
-			user_mac->host_pkt_next_free[cpu] = i;
-			return user_mac->pkt_data[i].data;
-		}
-	}
-	
-	for (i=start_index; i<next_free; i++) {
-		if (user_mac->pkt_desc[i].free) {
-			user_mac->pkt_desc[i].free = 0;
-			user_mac->host_pkt_next_free[cpu] = i;
-			return user_mac->pkt_data[i].data;
-		}		
-	}
-
-	return NULL;
-}
-
-static __inline__ int user_mac_host_pkt_free(struct user_mac_data *user_mac, int index, int cpu)
-{
-	/* This function can be called from any cpu */
-	if (index < MAX_USER_MAC_FRIN_PKTS || index >= MAX_USER_MAC_PKTS)
-		return -1;
-	
-	if (user_mac->pkt_desc[index].free) return -1;
-
-	user_mac->pkt_desc[index].free = 1;
-
-	return 0;
-}
-
-#endif
diff --git a/kernel/pid.c b/kernel/pid.c
index b24888d..e1f7f31 100644
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -1,11 +1,3 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
 /*
  * Generic pidhash and scalable, time-bounded PID allocator
  *
@@ -553,13 +545,8 @@ struct pid *find_ge_pid(int nr, struct pid_namespace *ns)
 /*
  * The pid hash table is scaled according to the amount of memory in the
  * machine.  From a minimum of 16 slots up to 4096 slots at one gigabyte or
- * more. KGDB needs to know if this function has been called already,
- * since we might have entered KGDB very early.
+ * more.
  */
-#ifdef CONFIG_KGDB
-int pidhash_init_done;
-#endif
-
 void __init pidhash_init(void)
 {
 	unsigned int i, pidhash_size;
@@ -571,11 +558,6 @@ void __init pidhash_init(void)
 
 	for (i = 0; i < pidhash_size; i++)
 		INIT_HLIST_HEAD(&pid_hash[i]);
-
-#ifdef CONFIG_KGDB
-	pidhash_init_done = 1;
-#endif
-
 }
 
 void __init pidmap_init(void)
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 7e1bef5..daf4394 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -32,7 +32,6 @@ static int ptrace_trapping_sleep_fn(void *flags)
 	return 0;
 }
 
-
 /*
  * ptrace a task: make the debugger its new parent and
  * move it to the ptrace list.
@@ -548,7 +547,7 @@ int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long ds
 		this_len = (len > sizeof(buf)) ? sizeof(buf) : len;
 		if (copy_from_user(buf, src, this_len))
 			return -EFAULT;
-		retval = access_process_vm(tsk, (unsigned long)src, buf, this_len, 0);
+		retval = access_process_vm(tsk, dst, buf, this_len, 1);
 		if (!retval) {
 			if (copied)
 				break;
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index d1ca769..47bfa16 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -20,7 +20,6 @@ cond_syscall(sys_quotactl);
 cond_syscall(sys32_quotactl);
 cond_syscall(sys_acct);
 cond_syscall(sys_lookup_dcookie);
-cond_syscall(compat_sys_lookup_dcookie);
 cond_syscall(sys_swapon);
 cond_syscall(sys_swapoff);
 cond_syscall(sys_kexec_load);
diff --git a/net/core/dev.c b/net/core/dev.c
index 70940b7..373de32 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -1,10 +1,3 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
 /*
  * 	NET3	Protocol independent device support routines.
  *
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index fd816b9..bb0c468 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -933,7 +933,7 @@ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,
 	long off;
 	bool fastpath;
 
-#if defined (CONFIG_NLM_COMMON) && defined (CONFIG_64BIT)
+#if defined (CONFIG_NLM_XLP) && defined (CONFIG_64BIT)
 	gfp_mask |= GFP_DMA;
 #endif
 
diff --git a/net/ipv4/netfilter/ip_queue.c b/net/ipv4/netfilter/ip_queue.c
index 5460413..94d45e1 100644
--- a/net/ipv4/netfilter/ip_queue.c
+++ b/net/ipv4/netfilter/ip_queue.c
@@ -38,18 +38,12 @@
 #define NET_IPQ_QMAX 2088
 #define NET_IPQ_QMAX_NAME "ip_queue_maxlen"
 
-#undef  NLM_IPQ_DEBUG
-
 typedef int (*ipq_cmpfn)(struct nf_queue_entry *, unsigned long);
 
 static unsigned char copy_mode __read_mostly = IPQ_COPY_NONE;
 static unsigned int queue_maxlen __read_mostly = IPQ_QMAX_DEFAULT;
 static DEFINE_SPINLOCK(queue_lock);
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-static int peer_pid[NR_CPUS];
-#else
 static int peer_pid __read_mostly;
-#endif /* CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY */
 static unsigned int copy_range __read_mostly;
 static unsigned int queue_total;
 static unsigned int queue_dropped = 0;
@@ -96,30 +90,10 @@ static void __ipq_flush(ipq_cmpfn cmpfn, unsigned long data);
 static inline void
 __ipq_reset(void)
 {
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-	int i;
-	int total = 0;
-#ifdef NLM_IPQ_DEBUG
-	printk(KERN_ALERT "%s: Removing PID %d from core %d\n",
-			__FUNCTION__, peer_pid[smp_processor_id()], smp_processor_id());
-#endif
-	peer_pid[smp_processor_id()] = 0;
-
-	for (i = 0; i < NR_CPUS; i++) {
-		total |= peer_pid[i];
-	}
-
-	if (total == 0) {
-		net_disable_timestamp();
-		__ipq_set_mode(IPQ_COPY_NONE, 0);
-		__ipq_flush(NF_DROP, 0);
-	}
-#else
 	peer_pid = 0;
 	net_disable_timestamp();
 	__ipq_set_mode(IPQ_COPY_NONE, 0);
 	__ipq_flush(NULL, 0);
-#endif /* CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY */
 }
 
 static struct nf_queue_entry *
@@ -255,10 +229,6 @@ ipq_enqueue_packet(struct nf_queue_entry *entry, unsigned int queuenum)
 {
 	int status = -EINVAL;
 	struct sk_buff *nskb;
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-	int dst_cpu;
-	struct sk_buff *skb = entry->skb;
-#endif /* CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY */
 
 	if (copy_mode == IPQ_COPY_NONE)
 		return -EAGAIN;
@@ -269,12 +239,7 @@ ipq_enqueue_packet(struct nf_queue_entry *entry, unsigned int queuenum)
 
 	spin_lock_bh(&queue_lock);
 
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-	dst_cpu = smp_processor_id() + (skb->cb[sizeof(skb->cb) - 1] & 3);
-	if (!peer_pid[dst_cpu])
-#else
 	if (!peer_pid)
-#endif /* CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY */
 		goto err_out_free_nskb;
 
 	if (queue_total >= queue_maxlen) {
@@ -288,17 +253,7 @@ ipq_enqueue_packet(struct nf_queue_entry *entry, unsigned int queuenum)
 	}
 
 	/* netlink_unicast will either free the nskb or attach it to a socket */
-
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-#ifdef NLM_IPQ_DEBUG
-	printk(KERN_ALERT "%s: Sending packet from bucket: %d\n",
-			__FUNCTION__, skb->cb[sizeof(skb->cb) - 1]);
-#endif
-	status = netlink_unicast(ipqnl, nskb, peer_pid[dst_cpu], MSG_DONTWAIT);
-#else
 	status = netlink_unicast(ipqnl, nskb, peer_pid, MSG_DONTWAIT);
-#endif  /* CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY */
-
 	if (status < 0) {
 		queue_user_dropped++;
 		goto err_out_unlock;
@@ -481,25 +436,6 @@ __ipq_rcv_skb(struct sk_buff *skb)
 
 	spin_lock_bh(&queue_lock);
 
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-#ifdef NLM_IPQ_DEBUG
-	if (current->pid != pid)
-	{
-		printk(KERN_ALERT "%s: PID mismatch: current: %d, PID: %d, core %d\n",
-				__FUNCTION__, current->pid, pid, smp_processor_id());
-	}
-#endif /* NLM_IPQ_DEBUG */
-
-	if (!peer_pid[smp_processor_id()])
-	{
-		net_enable_timestamp();
-		peer_pid[smp_processor_id()] = pid;
-#ifdef  NLM_IPQ_DEBUG
-		printk(KERN_ALERT "%s: Setting PID %d for core %d\n",
-				__FUNCTION__, pid, smp_processor_id());
-#endif
-	}
-#else
 	if (peer_pid) {
 		if (peer_pid != pid) {
 			spin_unlock_bh(&queue_lock);
@@ -509,7 +445,6 @@ __ipq_rcv_skb(struct sk_buff *skb)
 		enable_timestamp = true;
 		peer_pid = pid;
 	}
-#endif  /* CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY */
 
 	spin_unlock_bh(&queue_lock);
 	if (enable_timestamp)
@@ -558,11 +493,7 @@ ipq_rcv_nl_event(struct notifier_block *this,
 
 	if (event == NETLINK_URELEASE && n->protocol == NETLINK_FIREWALL) {
 		spin_lock_bh(&queue_lock);
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-		if ((net_eq(n->net, &init_net)) && (n->pid == peer_pid[smp_processor_id()]))
-#else
 		if ((net_eq(n->net, &init_net)) && (n->pid == peer_pid))
-#endif
 			__ipq_reset();
 		spin_unlock_bh(&queue_lock);
 	}
@@ -591,32 +522,8 @@ static ctl_table ipq_table[] = {
 #ifdef CONFIG_PROC_FS
 static int ip_queue_show(struct seq_file *m, void *v)
 {
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-	int i;
-#endif /* CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY */
-
 	spin_lock_bh(&queue_lock);
 
-#ifdef CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY
-	seq_printf(m, "Peer PIDs: \n");
-	for (i = 0; i < NR_CPUS; i++)
-		seq_printf(m, "%d", peer_pid[i]);
-
-	seq_printf(m, "\n");
-	seq_printf(m,
-		      "Copy mode         : %hu\n"
-		      "Copy range        : %u\n"
-		      "Queue length      : %u\n"
-		      "Queue max. length : %u\n"
-		      "Queue dropped     : %u\n"
-		      "Netlink dropped   : %u\n",
-		      copy_mode,
-		      copy_range,
-		      queue_total,
-		      queue_maxlen,
-		      queue_dropped,
-		      queue_user_dropped);
-#else
 	seq_printf(m,
 		      "Peer PID          : %d\n"
 		      "Copy mode         : %hu\n"
@@ -632,7 +539,6 @@ static int ip_queue_show(struct seq_file *m, void *v)
 		      queue_maxlen,
 		      queue_dropped,
 		      queue_user_dropped);
-#endif  /* CONFIG_NLMCOMMON_IP_QUEUE_AFFINITY */
 
 	spin_unlock_bh(&queue_lock);
 	return 0;
-- 
1.7.0.4

