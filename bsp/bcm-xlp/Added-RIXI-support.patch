From f94c030a78db7b5d3b33c0c6d35ca917d0623bf5 Mon Sep 17 00:00:00 2001
From: Mehul <vmehul@netlogicmicro.com>
Date: Wed, 6 Oct 2010 11:27:36 +0530
Subject: [PATCH 228/761] Added RIXI support.

Based on Broadcom SDK 2.3.

Signed-off-by: Mehul <vmehul@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/cpu-features.h               |    3 +
 .../asm/mach-netlogic/cpu-feature-overrides.h      |   57 ++----------------
 arch/mips/include/asm/mipsregs.h                   |   12 ++++
 arch/mips/include/asm/pgtable-32.h                 |    4 ++
 arch/mips/include/asm/pgtable-64.h                 |   61 +++++---------------
 arch/mips/include/asm/pgtable-bits.h               |   19 ++++++
 arch/mips/mm/tlb-r4k.c                             |   12 ++++
 arch/mips/netlogic/Kconfig                         |    5 ++
 8 files changed, 76 insertions(+), 97 deletions(-)

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index e1e3e82..8f44734 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -101,6 +101,9 @@
 #ifndef kernel_uses_smartmips_rixi
 #define kernel_uses_smartmips_rixi 0
 #endif
+#ifndef kernel_uses_smartmips_rixi
+#define kernel_uses_smartmips_rixi 0
+#endif
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
 #endif
diff --git a/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h b/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h
index d193fb6..01e9a84 100644
--- a/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h
+++ b/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h
@@ -1,56 +1,9 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2011 Netlogic Microsystems
- * Copyright (C) 2003 Ralf Baechle
- */
-#ifndef __ASM_MACH_NETLOGIC_CPU_FEATURE_OVERRIDES_H
-#define __ASM_MACH_NETLOGIC_CPU_FEATURE_OVERRIDES_H
 
-#define cpu_has_4kex		1
-#define cpu_has_4k_cache	1
-#define cpu_has_watch		1
-#define cpu_has_mips16		0
-#define cpu_has_counter		1
-#define cpu_has_divec		1
-#define cpu_has_vce		0
-#define cpu_has_cache_cdex_p	0
-#define cpu_has_cache_cdex_s	0
-#define cpu_has_prefetch	1
-#define cpu_has_mcheck		1
-#define cpu_has_ejtag		1
+#ifndef __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H
 
-#define cpu_has_llsc		1
-#define cpu_has_vtag_icache	0
-#define cpu_has_ic_fills_f_dc	1
-#define cpu_has_dsp		0
-#define cpu_has_mipsmt		0
-#define cpu_icache_snoops_remote_store	1
-
-#define cpu_has_64bits		1
-
-#define cpu_has_mips32r1	1
-#define cpu_has_mips64r1	1
-
-#define cpu_has_inclusive_pcaches	0
-
-#define cpu_dcache_line_size()	32
-#define cpu_icache_line_size()	32
-
-#if defined(CONFIG_CPU_XLR)
-#define cpu_has_userlocal	0
-#define cpu_has_dc_aliases	0
-#define cpu_has_mips32r2	0
-#define cpu_has_mips64r2	0
-#elif defined(CONFIG_CPU_XLP)
-#define cpu_has_userlocal	1
-#define cpu_has_mips32r2	1
-#define cpu_has_mips64r2	1
-#define cpu_has_dc_aliases	1
-#else
-#error "Unknown Netlogic CPU"
+#ifdef CONFIG_NLM_RIXI
+#define kernel_uses_smartmips_rixi (cpu_data[0].cputype == CPU_XLP)
 #endif
 
-#endif /* __ASM_MACH_NETLOGIC_CPU_FEATURE_OVERRIDES_H */
+#endif  /* __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H */
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index 3483676..eca8b63 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -275,6 +275,15 @@ the header of the original work apply to this derived work.
 #define PG_ESP		(_ULCAST_(1) <<  28)
 
 /*
+ * PageGrain bits
+ */
+#define PG_RIE     (_ULCAST_(1) <<  31)
+#define PG_XIE     (_ULCAST_(1) <<  30)
+#define PG_ELPA        (_ULCAST_(1) <<  29)
+#define PG_ESP     (_ULCAST_(1) <<  28)
+
+
+/*
  * R4x00 interrupt enable / cause bits
  */
 #define IE_SW0          (_ULCAST_(1) <<  8)
@@ -859,6 +868,9 @@ do {									\
 #define read_c0_pagegrain()	__read_32bit_c0_register($5, 1)
 #define write_c0_pagegrain(val)	__write_32bit_c0_register($5, 1, val)
 
+#define read_c0_pagegrain()    __read_32bit_c0_register($5, 1)
+#define write_c0_pagegrain(val)    __write_32bit_c0_register($5, 1, val)
+
 #define read_c0_wired()		__read_32bit_c0_register($6, 0)
 #define write_c0_wired(val)	__write_32bit_c0_register($6, 0, val)
 
diff --git a/arch/mips/include/asm/pgtable-32.h b/arch/mips/include/asm/pgtable-32.h
index 1fd07e5..6bd1f89 100644
--- a/arch/mips/include/asm/pgtable-32.h
+++ b/arch/mips/include/asm/pgtable-32.h
@@ -116,7 +116,11 @@ pfn_pte(unsigned long pfn, pgprot_t prot)
 #define pte_pfn(x)		((unsigned long)((x).pte >> (PAGE_SHIFT + 2)))
 #define pfn_pte(pfn, prot)	__pte(((pfn) << (PAGE_SHIFT + 2)) | pgprot_val(prot))
 #else
+#ifdef CONFIG_NLM_XLP
+#define pte_pfn(x)     ((unsigned long)(((x).pte & ~((1ULL<<_PAGE_NO_READ_SHIFT)|(1ULL<<_PAGE_NO_EXEC_SHIFT))) >> _PFN_SHIFT
+#else
 #define pte_pfn(x)		((unsigned long)((x).pte >> _PFN_SHIFT))
+#endif
 #define pfn_pte(pfn, prot)	__pte(((unsigned long long)(pfn) << _PFN_SHIFT) | pgprot_val(prot))
 #endif
 #endif /* defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32) */
diff --git a/arch/mips/include/asm/pgtable-64.h b/arch/mips/include/asm/pgtable-64.h
index a7bdff4..60d35c6 100644
--- a/arch/mips/include/asm/pgtable-64.h
+++ b/arch/mips/include/asm/pgtable-64.h
@@ -16,11 +16,7 @@
 #include <asm/cachectl.h>
 #include <asm/fixmap.h>
 
-#ifdef CONFIG_PAGE_SIZE_64KB
-#include <asm-generic/pgtable-nopmd.h>
-#else
 #include <asm-generic/pgtable-nopud.h>
-#endif
 
 /*
  * Each address space has 2 4K pages as its page directory, giving 1024
@@ -41,20 +37,13 @@
  * fault address - VMALLOC_START.
  */
 
-
-/* PGDIR_SHIFT determines what a third-level page table entry can map */
-#ifdef __PAGETABLE_PMD_FOLDED
-#define PGDIR_SHIFT	(PAGE_SHIFT + PAGE_SHIFT + PTE_ORDER - 3)
-#else
-
 /* PMD_SHIFT determines the size of the area a second-level page table can map */
 #define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT + PTE_ORDER - 3))
 #define PMD_SIZE	(1UL << PMD_SHIFT)
 #define PMD_MASK	(~(PMD_SIZE-1))
 
-
+/* PGDIR_SHIFT determines what a third-level page table entry can map */
 #define PGDIR_SHIFT	(PMD_SHIFT + (PAGE_SHIFT + PMD_ORDER - 3))
-#endif
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
@@ -103,32 +92,26 @@
 #ifdef CONFIG_PAGE_SIZE_64KB
 #define PGD_ORDER		0
 #define PUD_ORDER		aieeee_attempt_to_allocate_pud
-#define PMD_ORDER		aieeee_attempt_to_allocate_pmd
+#define PMD_ORDER		0
 #define PTE_ORDER		0
 #endif
 
 #define PTRS_PER_PGD	((PAGE_SIZE << PGD_ORDER) / sizeof(pgd_t))
-#ifndef __PAGETABLE_PMD_FOLDED
 #define PTRS_PER_PMD	((PAGE_SIZE << PMD_ORDER) / sizeof(pmd_t))
-#endif
 #define PTRS_PER_PTE	((PAGE_SIZE << PTE_ORDER) / sizeof(pte_t))
 
-#if PGDIR_SIZE >= TASK_SIZE64
+#if PGDIR_SIZE >= TASK_SIZE
 #define USER_PTRS_PER_PGD       (1)
 #else
-#define USER_PTRS_PER_PGD	(TASK_SIZE64 / PGDIR_SIZE)
+#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
 #endif
 #define FIRST_USER_ADDRESS	0UL
 
-/*
- * TLB refill handlers also map the vmalloc area into xuseg.  Avoid
- * the first couple of pages so NULL pointer dereferences will still
- * reliably trap.
- */
 #if defined(CONFIG_MAPPED_KERNEL) && defined(CONFIG_KSEG2_LOWMEM)
-#define VMALLOC_START		0xe0000000
+extern unsigned long __vmalloc_start;
+#define VMALLOC_START		__vmalloc_start
 #else
-#define VMALLOC_START		(MAP_BASE + (2 * PAGE_SIZE))
+#define VMALLOC_START		MAP_BASE
 #endif
 
 #define VMALLOC_END	\
@@ -152,30 +135,15 @@
 
 #define pte_ERROR(e) \
 	printk("%s:%d: bad pte %016lx.\n", __FILE__, __LINE__, pte_val(e))
-#ifndef __PAGETABLE_PMD_FOLDED
 #define pmd_ERROR(e) \
 	printk("%s:%d: bad pmd %016lx.\n", __FILE__, __LINE__, pmd_val(e))
-#endif
 #define pgd_ERROR(e) \
 	printk("%s:%d: bad pgd %016lx.\n", __FILE__, __LINE__, pgd_val(e))
 
 extern pte_t invalid_pte_table[PTRS_PER_PTE];
 extern pte_t empty_bad_page_table[PTRS_PER_PTE];
-
-
-#ifndef __PAGETABLE_PMD_FOLDED
-/*
- * For 3-level pagetables we defines these ourselves, for 2-level the
- * definitions are supplied by <asm-generic/pgtable-nopmd.h>.
- */
-typedef struct { unsigned long pmd; } pmd_t;
-#define pmd_val(x)	((x).pmd)
-#define __pmd(x)	((pmd_t) { (x) } )
-
-
 extern pmd_t invalid_pmd_table[PTRS_PER_PMD];
 extern pmd_t empty_bad_pmd_table[PTRS_PER_PMD];
-#endif
 
 /*
  * Empty pgd/pmd entries point to the invalid_pte_table.
@@ -196,7 +164,6 @@ static inline void pmd_clear(pmd_t *pmdp)
 {
 	pmd_val(*pmdp) = ((unsigned long) invalid_pte_table);
 }
-#ifndef __PAGETABLE_PMD_FOLDED
 
 /*
  * Empty pud entries point to the invalid_pmd_table.
@@ -220,7 +187,6 @@ static inline void pud_clear(pud_t *pudp)
 {
 	pud_val(*pudp) = ((unsigned long) invalid_pmd_table);
 }
-#endif
 
 #define pte_page(x)		pfn_to_page(pte_pfn(x))
 
@@ -228,8 +194,12 @@ static inline void pud_clear(pud_t *pudp)
 #define pte_pfn(x)		((unsigned long)((x).pte >> (PAGE_SHIFT + 2)))
 #define pfn_pte(pfn, prot)	__pte(((pfn) << (PAGE_SHIFT + 2)) | pgprot_val(prot))
 #else
-#define pte_pfn(x)		((unsigned long)((x).pte >> _PFN_SHIFT))
-#define pfn_pte(pfn, prot)	__pte(((pfn) << _PFN_SHIFT) | pgprot_val(prot))
+#ifdef CONFIG_NLM_XLP
+#define pte_pfn(x)     ((unsigned long)(((x).pte & ~((1ULL<<_PAGE_NO_READ_SHIFT)|(1ULL<<_PAGE_NO_EXEC_SHIFT))) >> _PFN_SHIFT))
+#else
+#define pte_pfn(x)     ((unsigned long)((x).pte >> _PFN_SHIFT))
+#endif
+#define pfn_pte(pfn, prot) __pte(((pfn) << _PFN_SHIFT) | pgprot_val(prot))
 #endif
 
 #define __pgd_offset(address)	pgd_index(address)
@@ -245,7 +215,6 @@ static inline void pud_clear(pud_t *pudp)
 /* to find an entry in a page-table-directory */
 #define pgd_offset(mm, addr)	((mm)->pgd + pgd_index(addr))
 
-#ifndef __PAGETABLE_PMD_FOLDED
 static inline unsigned long pud_page_vaddr(pud_t pud)
 {
 	return pud_val(pud);
@@ -258,7 +227,6 @@ static inline pmd_t *pmd_offset(pud_t * pud, unsigned long address)
 {
 	return (pmd_t *) pud_page_vaddr(*pud) + pmd_index(address);
 }
-#endif
 
 /* Find an entry in the third-level page table.. */
 #define __pte_offset(address)						\
@@ -269,7 +237,10 @@ static inline pmd_t *pmd_offset(pud_t * pud, unsigned long address)
 	((pte_t *) pmd_page_vaddr(*(dir)) + __pte_offset(address))
 #define pte_offset_map(dir, address)					\
 	((pte_t *)page_address(pmd_page(*(dir))) + __pte_offset(address))
+#define pte_offset_map_nested(dir, address)				\
+	((pte_t *)page_address(pmd_page(*(dir))) + __pte_offset(address))
 #define pte_unmap(pte) ((void)(pte))
+#define pte_unmap_nested(pte) ((void)(pte))
 
 /*
  * Initialize a new pgd / pmd table with invalid pointers.
diff --git a/arch/mips/include/asm/pgtable-bits.h b/arch/mips/include/asm/pgtable-bits.h
index e022c27..08033cd 100644
--- a/arch/mips/include/asm/pgtable-bits.h
+++ b/arch/mips/include/asm/pgtable-bits.h
@@ -103,6 +103,20 @@
 #define _PAGE_HUGE		({BUG(); 1; })  /* Dummy value */
 #endif
 
+#ifdef CONFIG_NLM_XLP
+/*XLP has bit 57,56 in entrylo0/1 as RI:XI. We will use pte bits 63:62 to store
+ *ri:xi, after right shift by 6, these bits will come to proper position.
+*/
+/* Page cannot be executed */
+#define _PAGE_NO_EXEC_SHIFT    (kernel_uses_smartmips_rixi ? 62: _PAGE_HUGE_SHIFT)
+#define _PAGE_NO_EXEC      ({if (!kernel_uses_smartmips_rixi) BUG(); 1ULL << _PAGE_NO_EXEC_SHIFT; })
+/* Page cannot be read */
+#define _PAGE_NO_READ_SHIFT    (kernel_uses_smartmips_rixi ? 63: _PAGE_NO_EXEC_SHIFT)
+#define _PAGE_NO_READ      ({if (!kernel_uses_smartmips_rixi) BUG(); 1ULL << _PAGE_NO_READ_SHIFT; })
+
+#define _PAGE_GLOBAL_SHIFT 6
+
+#else
 /* Page cannot be executed */
 #define _PAGE_NO_EXEC_SHIFT	(kernel_uses_smartmips_rixi ? _PAGE_HUGE_SHIFT + 1 : _PAGE_HUGE_SHIFT)
 #define _PAGE_NO_EXEC		({if (!kernel_uses_smartmips_rixi) BUG(); 1 << _PAGE_NO_EXEC_SHIFT; })
@@ -112,6 +126,7 @@
 #define _PAGE_NO_READ		({if (!kernel_uses_smartmips_rixi) BUG(); 1 << _PAGE_NO_READ_SHIFT; })
 
 #define _PAGE_GLOBAL_SHIFT	(_PAGE_NO_READ_SHIFT + 1)
+#endif
 #define _PAGE_GLOBAL		(1 << _PAGE_GLOBAL_SHIFT)
 
 #define _PAGE_VALID_SHIFT	(_PAGE_GLOBAL_SHIFT + 1)
@@ -156,6 +171,9 @@
 static inline uint64_t pte_to_entrylo(unsigned long pte_val)
 {
 	if (kernel_uses_smartmips_rixi) {
+#ifdef CONFIG_NLM_XLP
+       return (pte_val >> _PAGE_GLOBAL_SHIFT);
+#else
 		int sa;
 #ifdef CONFIG_32BIT
 		sa = 31 - _PAGE_NO_READ_SHIFT;
@@ -169,6 +187,7 @@ static inline uint64_t pte_to_entrylo(unsigned long pte_val)
 		 */
 		return (pte_val >> _PAGE_GLOBAL_SHIFT) |
 			((pte_val & (_PAGE_NO_EXEC | _PAGE_NO_READ)) << sa);
+#endif
 	}
 
 	return pte_val >> _PAGE_GLOBAL_SHIFT;
diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c
index 8b2abbe..b280b4a 100644
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -602,6 +602,18 @@ void __cpuinit tlb_init(void)
 	write_c0_framemask(0);
 #endif
 
+   if (kernel_uses_smartmips_rixi) {
+       /*
+        * Enable the no read, no exec bits, and enable large virtual
+        * address.
+        */
+       u32 pg = PG_RIE | PG_XIE;
+#ifdef CONFIG_64BIT
+       pg |= PG_ELPA;
+#endif
+       write_c0_pagegrain(pg);
+   }
+
 	temp_tlb_entry = current_cpu_data.tlbsize - 1;
 
         /* From this point on the ARC firmware is dead.  */
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 544811f..bfcc46a 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -210,3 +210,8 @@ config NLM_ENABLE_COP2
 	default n
 	help
 	  This option enables cop2 access for both user and kernel space.
+
+config NLM_RIXI
+       bool "Enable Read Inhibit/ Execute Inhibit support"
+       depends on NLM_XLP && 64BIT
+       default n
-- 
1.7.10.4

