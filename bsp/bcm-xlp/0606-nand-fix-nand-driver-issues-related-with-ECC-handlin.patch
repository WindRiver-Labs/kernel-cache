From deec5626476b0b7b79ab532eea99c024b8614f2d Mon Sep 17 00:00:00 2001
From: Divya Sakthidharan <divyas@broadcom.com>
Date: Wed, 17 Oct 2012 12:03:22 +0530
Subject: [PATCH 606/762] nand: fix nand driver issues related with ECC handling

	o The fix here to avoid software overwrite of hardware ECC data

Based on Broadcom SDK 2.3.

Signed-off-by: Divya Sakthidharan <divyas@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/xlp_plat_nand.c |  168 +++++++++++++++++++++++++-------
 arch/mips/netlogic/xlp/xlp_plat_nand.h |    2 +-
 2 files changed, 133 insertions(+), 37 deletions(-)

diff --git a/arch/mips/netlogic/xlp/xlp_plat_nand.c b/arch/mips/netlogic/xlp/xlp_plat_nand.c
index 5ebcfd5..88fe61d 100644
--- a/arch/mips/netlogic/xlp/xlp_plat_nand.c
+++ b/arch/mips/netlogic/xlp/xlp_plat_nand.c
@@ -55,6 +55,21 @@ static int enable_hwecc = 1;
 #define NAND_DEV_CS		1
 #endif
 
+int debug_enable=0;
+#define printk_debug	if(debug_enable) printk
+
+/* The oobsize is the area visible to software, and software will read/write in this region.
+* If hardware ecc is enabled, since our implementation of write_page does not calculate
+* hardware ECC, the hardware ECC area should not be overwritten by software.
+*
+* In this particular case, let us foce the oobsize to be 0xc. The hardware will use
+* the area in from spare area offset 0xc to the end of spare area.
+*
+* Why 0xc? This is the minimum space the hardware ECC will not occupy based on the
+* calculation in onfi_init.
+*/
+
+#define XLP_HWECC_OOBSIZE       0xc
 	
 struct plat_nand_data {
 	struct nand_chip	chip;
@@ -249,6 +264,11 @@ void onfi_init(struct nand_chip *chip)
 
         spare_bytes_per_512 = state->spare_size/(state->page_size/512) ;
 
+       /* We may allocate too much space for ECC, but since u-boot uses
+	* the same alrogithm to allocate hardware ECC space. Let us
+	* keep it this way. Otherwise, the hardware ECC generated by
+	* linux won't work for u-boot.
+	*/
         if (spare_bytes_per_512 <= 4) {
                 ecc_bytes = 0 ;
                 ecc_bits  = 0 ;
@@ -276,15 +296,14 @@ void onfi_init(struct nand_chip *chip)
 	if(enable_hwecc)
 	{
 		nand_reg_write(0, NAND_ECC_CTRL, (ecc_val << 5));
-		val = nand_reg_read(0, NAND_ECC_CTRL);
-		printk("NAND_ECC_CTRL = %x, ecc_val = %x \n",val, (ecc_val << 5));
 		nand_reg_write(0, NAND_ECC_OFFSET, state->page_size + ecc_offset);
-		val = nand_reg_read(0, NAND_ECC_OFFSET);
-		printk("NAND_ECC_OFFSET = %x, ecc_offset_val = %x \n",val, (state->page_size + ecc_offset));
 	
-		val = nand_reg_read(0, NAND_CTRL);
-		printk("val = %x, page size = %x, block size = %x, addr cycle = %x \n",val,page_val,block_val,addr_val);
+        	if (ecc_offset < XLP_HWECC_OOBSIZE)
+                	printk("Warning: (file %s): adjust XLP_HWECC_OOBSIZE smaller for nand flash driver!\n",
+                        	__FILE__);
+		nand_reg_write(0, NAND_SPARE_SIZE, XLP_HWECC_OOBSIZE);
 
+		val = nand_reg_read(0, NAND_CTRL);
 		val |= (NAND_CTRL_ECC_EN(1)		|
 			NAND_CTRL_PAGE_SIZE(page_val)	|
 			NAND_CTRL_BLOCK_SIZE(block_val)	|
@@ -302,10 +321,11 @@ void onfi_init(struct nand_chip *chip)
 			chip->ecc.layout->eccpos[i] = ecc_offset + i;
 		}
 		chip->ecc.layout->oobfree[0].offset = 2 ;
-		chip->ecc.layout->oobfree[0].length = state->spare_size - chip->ecc.layout->eccbytes*chip->ecc.steps - 2;
+		chip->ecc.layout->oobfree[0].length = XLP_HWECC_OOBSIZE - 2;
 	}
 	else
 	{
+		nand_reg_write(0, NAND_SPARE_SIZE, state->spare_size);
 		val = nand_reg_read(0, NAND_CTRL);
 		val |= (NAND_CTRL_ECC_EN(0)		|
 			NAND_CTRL_PAGE_SIZE(page_val)	|
@@ -364,35 +384,90 @@ static void send_cmd(struct mtd_info *mtd,
         struct nand_chip *chip = mtd->priv;
         struct nand_state *state = chip->priv;
 	uint64_t val;
+	int node = 0;
+	int column2, len2;
 
-        nand_reg_write(0, NAND_DATA_SIZE, len);
-        nand_reg_write(0, NAND_DMA_CNT, len);
-
-	val = (page_addr >> (32 - (state->col_cyc * 8)));
-        nand_reg_write(0, NAND_ADDR1_L, val);
-	val = ( (page_addr << (state->col_cyc * 8) ) | column);
-        nand_reg_write(0, NAND_ADDR0_L, val) ;
-	val = virt_to_phys((void *) state->buf) + state->buf_ptr;
-        nand_reg_write(0, NAND_DMA_ADDR, val);
-	nand_reg_write(0, NAND_DMA_ADDR_H, (val >> 32));
-
-        if ( (command == NAND_READ_PAGE_CMD) ||
-             (command == NAND_READ_ID_CMD)   ||
-             (command == NAND_READ_PARAMETER_CMD) ) {
-                nand_reg_write(0, NAND_DMA_CTRL, (1 << 7) | (1 << 6) | (5 << 2));
-        } else {
-                nand_reg_write(0, NAND_DMA_CTRL, (1 << 7) | (0 << 6) | (5 << 2));
-        }
 
+	/* The hardware ECC will be generated if the size is mtd->writesize.
+	 * So if the write data is more than mtd->writesize, let us break it into two.
+	 * hardware ECC will be disabled for the second part.
+	 */
         if ((column + len) > mtd->writesize) {
-		val = nand_reg_read(0, NAND_CTRL);
-                nand_reg_write(0, NAND_CTRL, (val & ~NAND_CTRL_ECC_EN(1)));
+                if (mtd->writesize > 0) {
+                        /* initialized */
+                        column2 = mtd->writesize;
+                        len2 = column + len - mtd->writesize;
+                        len = mtd->writesize - column;
+		printk_debug("column2 = %x, len2 = %d, len = %d \n", column2, len2, len);
+                } else {
+                        /* not initialized yet, ECC has to be disabled as it has not been configured properly */
+                        column2 = column;
+                        len2 = len;
+                        len = 0;
+		printk_debug("column2 = %x, len2 = %d, len = %d \n", column2, len2, len);
+                }
+        } else {
+                column2 = 0;
+                len2 = 0;
         }
 
-        nand_reg_write(0, NAND_CMD, command | NAND_CMD_DMA_FLAG);
-        dma_wait(state->cs);
-	val = nand_reg_read(0, NAND_CTRL);
-        nand_reg_write(0, NAND_CTRL, (val | NAND_CTRL_ECC_EN(1)));
+	if (len > 0) {
+		printk_debug("state->buf_ptr = %d, len = %d \n", state->buf_ptr, len);
+        	nand_reg_write(node, NAND_DATA_SIZE, len);
+        	nand_reg_write(node, NAND_DMA_CNT, len);
+
+		val = (page_addr >> (32 - (state->col_cyc * 8)));
+        	nand_reg_write(node, NAND_ADDR0_H, val);
+		val = ( (page_addr << (state->col_cyc * 8) ) | column);
+        	nand_reg_write(node, NAND_ADDR0_L, val) ;
+		val = virt_to_phys((void *) state->buf) + state->buf_ptr;
+        	nand_reg_write(node, NAND_DMA_ADDR, val);
+		nand_reg_write(node, NAND_DMA_ADDR_H, (val >> 32));
+
+		printk_debug("test 0\n");
+
+        	if ( (command == NAND_READ_PAGE_CMD) ||
+             	     (command == NAND_READ_ID_CMD)   ||
+             	     (command == NAND_READ_PARAMETER_CMD) ) {
+                	nand_reg_write(node, NAND_DMA_CTRL, (1 << 7) | (1 << 6) | (5 << 2));
+        	} else {
+                	nand_reg_write(node, NAND_DMA_CTRL, (1 << 7) | (0 << 6) | (5 << 2));
+        	}
+
+		printk_debug("test 1\n");
+        	nand_reg_write(node, NAND_CMD, command | NAND_CMD_DMA_FLAG);
+        	dma_wait(state->cs);
+		printk_debug("len = %d \n", len);
+	}
+
+	if (len2 > 0) {
+        	nand_reg_write(node, NAND_DATA_SIZE, len2);
+        	nand_reg_write(node, NAND_DMA_CNT, len2);
+
+		val = (page_addr >> (32 - (state->col_cyc * 8)));
+        	nand_reg_write(node, NAND_ADDR0_H, val);
+		val = ( (page_addr << (state->col_cyc * 8) ) | column2);
+        	nand_reg_write(node, NAND_ADDR0_L, val) ;
+		val = virt_to_phys((void *) state->buf) + state->buf_ptr + len;
+        	nand_reg_write(node, NAND_DMA_ADDR, val);
+		nand_reg_write(node, NAND_DMA_ADDR_H, (val >> 32));
+
+        	if ( (command == NAND_READ_PAGE_CMD) ||
+             	     (command == NAND_READ_ID_CMD)   ||
+             	     (command == NAND_READ_PARAMETER_CMD) ) {
+                	nand_reg_write(node, NAND_DMA_CTRL, (1 << 7) | (1 << 6) | (5 << 2));
+        	} else {
+                	nand_reg_write(node, NAND_DMA_CTRL, (1 << 7) | (0 << 6) | (5 << 2));
+        	}
+
+		val = nand_reg_read(node, NAND_CTRL);
+               	nand_reg_write(node, NAND_CTRL, (val & ~NAND_CTRL_ECC_EN(1)));
+        	nand_reg_write(node, NAND_CMD, command | NAND_CMD_DMA_FLAG);
+        	dma_wait(state->cs);
+		val = nand_reg_read(node, NAND_CTRL);
+        	nand_reg_write(node, NAND_CTRL, (val | NAND_CTRL_ECC_EN(1))); 
+		printk_debug("len2 = %d \n", len2);
+	}
 
         state->last_cmd    = command;
 }
@@ -406,8 +481,8 @@ static void cmdfunc(struct mtd_info *mtd,
         struct nand_state *state = chip->priv;
         int len = 0 ;
         uint32_t val;
-
-        if (state->cs < 0)
+        
+	if (state->cs < 0)
                 return;
 
         switch (command) {
@@ -419,6 +494,7 @@ static void cmdfunc(struct mtd_info *mtd,
                 column += 256;
         case NAND_CMD_READ0:
                 state->buf_ptr = 0;
+		printk_debug("column = %x, page_addr = %x, mtd->writesize = %d \n", column, page_addr, mtd->writesize);
                 send_cmd(mtd,
                          NAND_READ_PAGE_CMD,
                          column,
@@ -543,6 +619,7 @@ static uint8_t read_byte(struct mtd_info *mtd)
         if (state->cs < 0)
                 return 0;
 
+	printk_debug("%s \n",__FUNCTION__);
         if (state->last_cmd == NAND_READ_STATUS_CMD) {
                 data = nand_reg_read(0, NAND_READ_STATUS);
                 dbp_print("Status: %x\n",data);
@@ -559,10 +636,11 @@ static void read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
         struct nand_chip *chip = mtd->priv;
         struct nand_state *state = chip->priv;
         int i;
-
-        if (state->cs < 0)
+        
+	if (state->cs < 0)
                 return;
 
+
         dbp_print("read_buf %p %d %d\n", buf, state->buf_ptr, len);
         for (i = 0; i < len; i++) {
                 buf[i] = state->buf[state->buf_ptr];
@@ -677,6 +755,15 @@ static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
         data->chip.cmdfunc	= cmdfunc ;
         data->chip.waitfunc	= waitfunc ;
 
+	
+	if (enable_hwecc)
+		data->mtd.oobsize = XLP_HWECC_OOBSIZE;
+	else
+		data->mtd.oobsize = 64;
+
+        data->chip.IO_ADDR_R = data->io_base;
+        data->chip.IO_ADDR_W = data->io_base;
+
 	if(enable_hwecc)
 	        data->chip.ecc.mode = NAND_ECC_HW;
 
@@ -689,11 +776,20 @@ static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
 	return 0;
 }
 
+/*
+ * Make the nand file system partition 0 sufficiently large to cover the
+ * range used by bootloaders.
+ *
+ * Currently (as of 09/2012), bootloader uses 12 blocks (x-loader, u-boot, u-boot env)
+ * and the maximum observed block size in use is 512KB. Make the first partition
+ * to be 16 blocks leaving some extra space in case bootloader needs more.
+ */
+
 static struct mtd_partition xlp_nand_partitions[] = {
         {
         .name = "NAND FS 0",
         .offset = 0,
-        .size = 8 * 64 * 2048,
+	.size = 16 * 128 * 4096
         },
         {
         .name = "NAND FS 1",
diff --git a/arch/mips/netlogic/xlp/xlp_plat_nand.h b/arch/mips/netlogic/xlp/xlp_plat_nand.h
index 1ad7ae2..c9b6f5d 100644
--- a/arch/mips/netlogic/xlp/xlp_plat_nand.h
+++ b/arch/mips/netlogic/xlp/xlp_plat_nand.h
@@ -36,7 +36,7 @@
 #define NAND_ADDR0_H		0x49
 #define NAND_ADDR1_L		0x48
 #define NAND_ADDR1_H		0x4A
-#define NAND_SPARE_SIZE		0x4B
+#define NAND_SPARE_SIZE		0x4C
 #define NAND_DMA_ADDR		0x59
 #define NAND_DMA_CNT		0x5A
 #define NAND_DMA_CTRL		0x5B
-- 
1.7.0.4

