From 008f104782cd6c1e6978b5ccfb6503e59dcaa4b0 Mon Sep 17 00:00:00 2001
From: Nebu Philips <nphilips@netlogicmicro.com>
Date: Sat, 20 Nov 2010 00:29:42 -0800
Subject: [PATCH 222/761] USB Changes to enable EHCI Driver over PCI
 Framework.

Based on Broadcom SDK 2.3.

Signed-off-by: Nebu Philips <nphilips@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp.h     |   24 +++
 arch/mips/include/asm/netlogic/xlp_usb.h |   42 ++++
 arch/mips/netlogic/xlp/Makefile          |    2 +-
 arch/mips/netlogic/xlp/platform.c        |  306 ++++++++++++++++++++++--------
 drivers/usb/host/Kconfig                 |   10 +-
 drivers/usb/host/Makefile                |    3 +
 drivers/usb/host/ehci-pci.c              |   78 +++++++-
 drivers/usb/host/ehci.h                  |    2 +-
 drivers/usb/host/ohci-hcd.c              |   18 +-
 drivers/usb/host/ohci-pci.c              |   80 +++++++-
 drivers/usb/host/ohci.h                  |    5 +
 11 files changed, 480 insertions(+), 90 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/xlp_usb.h

diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index 42e5195..9149917 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -43,6 +43,30 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_REVISION_A0 	0xc0010
 #define MAX_CPU_REV_LEN		100
 
+#define PCI_NETL_VENDOR         0x184E
+#define XLP_DEVID_DRAM          0x1001
+#define XLP_DEVID_PIC           0x1003
+#define XLP_DEVID_INTLA         0x1005
+#define XLP_DEVID_USBDEV        0x1006
+#define XLP_DEVID_EHCI          0x1007  
+#define XLP_DEVID_OHCI          0x1008
+#define XLP_DEVID_NAE           0x1009
+#define XLP_DEVID_POE           0x100A
+#define XLP_DEVID_CMS           0x100B
+#define XLP_DEVID_DTRE_RAID     0x100C
+#define XLP_DEVID_SAE           0x100D
+#define XLP_DEVID_RSAECC        0x100E
+#define XLP_DEVID_CPM           0x100F
+#define XLP_DEVID_UART          0x1010
+#define XLP_DEVID_I2C           0x1011
+#define XLP_DEVID_GPIO          0x1012
+#define XLP_DEVID_SYS           0x1013
+#define XLP_DEVID_JTAG          0x1014
+#define XLP_DEVID_NOR           0x1015
+#define XLP_DEVID_NAND          0x1016
+#define XLP_DEVID_SPI           0x1017
+#define XLP_DEVID_MMC           0x1018
+
 struct smp_boot_info_percpu {
   volatile unsigned long ready;
   volatile unsigned long sp;
diff --git a/arch/mips/include/asm/netlogic/xlp_usb.h b/arch/mips/include/asm/netlogic/xlp_usb.h
new file mode 100644
index 0000000..513147f
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/xlp_usb.h
@@ -0,0 +1,42 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+#ifndef __XLP_USB_H
+#define __XLP_USB_H
+
+static __inline__ int32_t usb_reg_read(int node, int func, int regidx)
+{
+	volatile uint64_t mmio;
+	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+	return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void usb_reg_write(int node, int func, int regidx, int32_t val)
+{
+	volatile uint64_t mmio;
+	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+	nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+#endif //__XLP_USB_H
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index cfbdfc8..b3ee2ec 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -3,7 +3,7 @@ EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogi
 
 obj-y                    	= setup.o nmi.o
 obj-y 				+= irq.o time.o on_chip.o mmu.o
-obj-$(CONFIG_NLM_XLP) 		+= platform-xlp.o
+obj-$(CONFIG_NLM_XLP) 		+= platform.o
 obj-$(CONFIG_SMP)       	+= smp.o
 
 ifeq ($(CONFIG_XEN),y)
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index 1f5e4cb..e26ffb3 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -1,36 +1,27 @@
-/*
- * Copyright 2003-2011 NetLogic Microsystems, Inc. (NetLogic). All rights
- * reserved.
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * COPYING in the main directory of this source tree, or the NetLogic
- * license below:
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY NETLOGIC ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
 
 #include <linux/dma-mapping.h>
 #include <linux/kernel.h>
@@ -44,65 +35,224 @@
 #include <linux/spinlock.h>
 
 #include <asm/time.h>
-#include <asm/addrspace.h>
-#include <asm/netlogic/haldefs.h>
-#include <asm/netlogic/xlp-hal/iomap.h>
-#include <asm/netlogic/xlp-hal/xlp.h>
-#include <asm/netlogic/xlp-hal/pic.h>
-#include <asm/netlogic/xlp-hal/uart.h>
-
-static unsigned int nlm_xlp_uart_in(struct uart_port *p, int offset)
-{
-	 return nlm_read_reg(p->iobase, offset);
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_usb.h>
+
+#define XLP_SOC_PCI_DRIVER "XLP SoC Driver"
+#define DEV_IRT_INFO		0x3D
+
+#define XLP_MAX_DEVICE		8
+#define XLP_MAX_FUNC		8
+#define MAX_DEV2DRV			10
+
+static u64 xlp_dev_dmamask = DMA_BIT_MASK(32);
+
+enum driverType{
+	PLAT_DRV = 0,
+	PCI_DRV	 = 1
+};
+
+struct dev2drv {
+	uint32_t 	devid;
+	uint8_t 	drvname[16];
+	uint8_t 	len;
+	uint8_t 	id;
+	uint8_t		drivetype;
+};
+
+unsigned int xlp_uart_in(struct uart_port *p, int offset) {
+
+	nlm_reg_t *mmio;
+	unsigned int value;
+
+	/* XLP uart does not need any mapping of regs 
+	 */
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	value = netlogic_read_reg(mmio, 0);
+
+	return value;
 }
 
-static void nlm_xlp_uart_out(struct uart_port *p, int offset, int value)
+void xlp_uart_out(struct uart_port *p, int offset, int value)
 {
-	nlm_write_reg(p->iobase, offset, value);
+	nlm_reg_t *mmio;
+
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	netlogic_write_reg(mmio, 0, value);
 }
 
-#define PORT(_irq)					\
-	{						\
-		.irq		= _irq,			\
-		.regshift	= 2,			\
-		.iotype		= UPIO_MEM32,		\
-		.flags		= (UPF_SKIP_TEST|UPF_FIXED_TYPE|\
-					UPF_BOOT_AUTOCONF),	\
-		.uartclk	= XLP_IO_CLK,		\
-		.type		= PORT_16550A,		\
-		.serial_in	= nlm_xlp_uart_in,	\
-		.serial_out	= nlm_xlp_uart_out,	\
-	}
+#define PORT(_base, _irq) 					\
+{                                       	\
+	.iobase         = _base,                \
+	.membase        = (void __iomem *)_base,\
+	.mapbase        = _base,                \
+	.irq            = _irq,                 \
+	.regshift       = 2,                    \
+	.iotype         = UPIO_NLM,             \
+	.flags          = (UPF_SKIP_TEST|UPF_FIXED_TYPE|UPF_BOOT_AUTOCONF),\
+	.uartclk        = 133333333,          	\
+	.type           = PORT_16550A,          \
+	.serial_in      = xlp_uart_in,      	\
+	.serial_out     = xlp_uart_out,     	\
+}
 
 static struct plat_serial8250_port xlp_uart_data[] = {
-	PORT(PIC_UART_0_IRQ),
-	PORT(PIC_UART_1_IRQ),
-	{},
+	PORT(DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_0_OFFSET, PIC_UART_0_IRQ),
+	PORT(DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_1_OFFSET, PIC_UART_1_IRQ),
 };
 
-static struct platform_device uart_device = {
-	.name		= "serial8250",
-	.id		= PLAT8250_DEV_PLATFORM,
-	.dev = {
-		.platform_data = xlp_uart_data,
-	},
+static void xlp_usb_hw_start(int ctrl_no)
+{
+	int val;
+
+	/* reset USB phy 
+	 */
+	val = usb_reg_read( 0, ctrl_no, XLP_USB_PHY0);
+
+	if(ctrl_no == 0)
+		val &= ~(USBPHYRESET | USBPHYPORTRESET0 | USBPHYPORTRESET1);
+	else if(ctrl_no == 3)
+		val &= ~(USBPHYRESET | USBPHYPORTRESET0 | USBPHYPORTRESET1);
+
+	usb_reg_write(0, ctrl_no, XLP_USB_PHY0, val);
+
+	udelay(2000);
+
+	val = usb_reg_read( 0, ctrl_no, XLP_USB_CTL0);
+	val &= ~(USBCONTROLLERRESET );
+	val |= 0x4;
+	usb_reg_write(0, ctrl_no, XLP_USB_CTL0, val);
+
+	return;
+}
+
+struct dev2drv dev2drv_table[MAX_DEV2DRV] = {
+	{XLP_DEVID_UART, "serial8250",	11,	0,	PLAT_DRV},
+	{XLP_DEVID_I2C,	 "i2c-xlp",		8,	0, 	PLAT_DRV},
+	{0x0, 			 "",			0,	0,	PLAT_DRV},
 };
 
-static int __init nlm_platform_uart_init(void)
+static int get_dev2drv(uint32_t x) 
 {
-	unsigned long mmio;
+	int i;
 
-	mmio = (unsigned long)nlm_get_uart_regbase(0, 0);
-	xlp_uart_data[0].iobase = mmio;
-	xlp_uart_data[0].membase = (void __iomem *)mmio;
-	xlp_uart_data[0].mapbase = mmio;
+	for(i=0; i<MAX_DEV2DRV; i++) {	
+		if(x == dev2drv_table[i].devid)
+			return i;
+	}
+	return i;
+}
 
-	mmio = (unsigned long)nlm_get_uart_regbase(0, 1);
-	xlp_uart_data[1].iobase = mmio;
-	xlp_uart_data[1].membase = (void __iomem *)mmio;
-	xlp_uart_data[1].mapbase = mmio;
+static int xlp_find_pci_dev(void)
+{
+	uint16_t i, j, id, idx = 0;
+	volatile uint64_t mmio;
+	uint32_t val, devid, vid, irt, irq;
+	struct platform_device* pplatdev;
+	struct resource* pres;
+	unsigned long flags = 0;
+
+	pres = (struct resource*) kmalloc(sizeof(struct resource) * 2, 
+			GFP_KERNEL);
+	if(!pres) {
+		printk("kmalloc struct resource failedi!\n");
+		return -ENOMEM;
+	}
 
-	return platform_device_register(&uart_device);
+	for (i=0; i<XLP_MAX_DEVICE; i++) {
+
+		for (j=0; j<XLP_MAX_FUNC; j++) {
+
+			mmio = nlm_hal_get_dev_base(0, 0, i, j);
+			val  = nlm_hal_read_32bit_reg(mmio, 0);
+
+			if(val != 0xFFFFFFFF) {
+
+				devid	= (val & 0xFFFF0000) >> 16;
+				vid 	= (val & 0xFFFF);
+				idx 	= get_dev2drv(devid);
+
+				if(idx >= 0 && idx < MAX_DEV2DRV) {
+
+					if(dev2drv_table[idx].drivetype == PLAT_DRV) {
+
+						id = dev2drv_table[idx].id;
+
+						if (devid == XLP_DEVID_EHCI) {
+							if(id == 1)
+								id = 3;
+						}
+
+						if( devid == XLP_DEVID_OHCI) {
+							if(id < 2)
+								id = id + 1;
+							else if (id >=2)
+								id = id + 2;
+						}
+
+						if (devid == XLP_DEVID_UART)
+							id += PLAT8250_DEV_PLATFORM;
+
+						pplatdev =  platform_device_alloc(
+								(const char*)dev2drv_table[idx].drvname, id);
+						if (!pplatdev) {
+							printk("platform_device_alloc  failed!\n");
+							continue;
+						}
+
+						if(devid == XLP_DEVID_UART) {
+							platform_device_add_data(pplatdev,
+								(const void*) &xlp_uart_data[dev2drv_table[idx].id], 
+								sizeof( struct plat_serial8250_port));	
+						}
+
+						dev2drv_table[idx].id = dev2drv_table[idx].id + 1;	
+
+						pres[0].start	= mmio;
+						pres[0].end		= mmio;
+						pres[0].flags	= IORESOURCE_MEM;
+
+						irt = (nlm_hal_read_32bit_reg(mmio, DEV_IRT_INFO) & 0xFFFF);
+						irq = nlm_hal_request_shared_irq(  irt & 0xFFFF);
+
+						pres[1].start	= irq;
+						pres[1].end		= irq;
+						pres[1].flags	= IORESOURCE_IRQ;
+
+						platform_device_add_resources(pplatdev, pres, 2);
+
+						pplatdev->dev.dma_mask	= &xlp_dev_dmamask;
+
+						pplatdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+
+						if (devid != XLP_DEVID_UART)
+							platform_device_add( pplatdev);
+					}
+				}
+			}
+		}
+	}
+	kfree(pres);
+	return 0;	
+}
+
+static int __init platform_devinit(void)
+{
+	xlp_find_pci_dev();
+	xlp_usb_hw_start(0);
+	xlp_usb_hw_start(3);
+
+	return 0;
+}
+
+static void __init platform_devexit(void)
+{
+	return;
 }
 
-arch_initcall(nlm_platform_uart_init);
+module_init(platform_devinit);
+module_exit(platform_devexit);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index c532b6e..08d0def 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -151,13 +151,13 @@ config USB_EHCI_BIG_ENDIAN_MMIO
 	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || \
 				    ARCH_IXP4XX || XPS_USB_HCD_XILINX || \
 				    PPC_MPC512x || CPU_CAVIUM_OCTEON || \
-				    PMC_MSP || SPARC_LEON)
+				    PMC_MSP || SPARC_LEON || NLM_XLP)
 	default y
 
 config USB_EHCI_BIG_ENDIAN_DESC
 	bool
 	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX || XPS_USB_HCD_XILINX || \
-				    PPC_MPC512x || PMC_MSP || SPARC_LEON)
+				    PPC_MPC512x || PMC_MSP || SPARC_LEON || NLM_XLP)
 	default y
 
 config XPS_USB_HCD_XILINX
@@ -482,17 +482,17 @@ config USB_EHCI_HCD_PLATFORM
 config USB_OHCI_BIG_ENDIAN_DESC
 	bool
 	depends on USB_OHCI_HCD
-	default n
+	default y 
 
 config USB_OHCI_BIG_ENDIAN_MMIO
 	bool
 	depends on USB_OHCI_HCD
-	default n
+	default y
 
 config USB_OHCI_LITTLE_ENDIAN
 	bool
 	depends on USB_OHCI_HCD
-	default n if STB03xxx || PPC_MPC52xx
+	default n if STB03xxx || PPC_MPC52xx || NLM_XLP
 	default y
 
 config USB_UHCI_HCD
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 0982bcc..98f4380 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -1,6 +1,9 @@
 #
 # Makefile for USB Host Controller Drivers
 #
+ifeq ($(CONFIG_NLM_XLP),y)
+	EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL
+endif
 
 ccflags-$(CONFIG_USB_DEBUG) := -DDEBUG
 
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 0909783..9c3688d 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -1,3 +1,11 @@
+/* **********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
+ * This is a derived work from software originally provided by the external
+ * entity identified below. The licensing terms and warranties specified in
+ * the header of the original work apply to this derived work.
+ *
+ * *****************************#NETL_1#********************************/
+
 /*
  * EHCI HCD (Host Controller Driver) PCI Bus Glue.
  *
@@ -25,6 +33,49 @@
 /* defined here to avoid adding to pci_ids.h for single instance use */
 #define PCI_DEVICE_ID_INTEL_CE4100_USB	0x2e70
 
+#ifdef CONFIG_NLM_XLP
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_usb.h>
+
+volatile uint64_t *ehci_regs;
+
+static void xlp_usb_hw_start(int ctrl_no)
+{
+	int val;
+
+	/* enable USB interrupts
+	 */
+	val = USB_CTRL_INTERRUPT_EN  | USB_OHCI_INTERRUPT_EN | USB_OHCI_INTERRUPT1_EN;
+	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN, val);
+
+	return;
+}
+
+int xlp_ehci_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int irq, irt, ctrl_no;
+
+	ctrl_no = dev->devfn & 0xF;
+
+	irt = usb_reg_read(0, ctrl_no, 0x3D) & 0xFFFF;
+	irq = nlm_hal_request_shared_irq(irt);
+
+	if (!irq) {
+		printk("Found HC with no IRQ.  Check BIOS/PCI %s setup!\n", 
+				pci_name(dev));
+		return -ENODEV;
+	}
+
+	dev->irq = irq;
+	xlp_usb_hw_start(ctrl_no);
+
+	return usb_hcd_pci_probe(dev, id);
+}
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /* called after powerup, by probe or system-pm "wakeup" */
@@ -66,6 +117,16 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 #endif
 		}
 		break;
+
+	case PCI_VENDOR_ID_NETLOGIC:
+		if (pdev->device == 0x1007) {
+#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
+			ehci->big_endian_mmio = 1;
+#else
+			ehci->big_endian_mmio = 0;
+#endif
+		}
+		break;
 	}
 
 	ehci->caps = hcd->regs;
@@ -529,10 +590,22 @@ static const struct hc_driver ehci_pci_hc_driver = {
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids [] = { {
+#ifdef CONFIG_NLM_XLP
+	{
+		.vendor		 = PCI_VENDOR_ID_NETLOGIC,
+		.device		 = XLP_DEVID_EHCI,
+		.subvendor	 = 0,
+		.subdevice	 = 0,
+		.class		 = PCI_CLASS_SERIAL_USB_EHCI,
+		.class_mask	 = ~0,
+		.driver_data =	(unsigned long) &ehci_pci_hc_driver,
+	},
+#else
 	/* handle any USB 2.0 EHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),
 	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
 	}, {
+#endif
 	PCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_HOST),
 	.driver_data = (unsigned long) &ehci_pci_hc_driver,
 	},
@@ -544,8 +617,11 @@ MODULE_DEVICE_TABLE(pci, pci_ids);
 static struct pci_driver ehci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-
+#ifdef CONFIG_NLM_XLP
+	.probe =	xlp_ehci_hcd_pci_probe,
+#else
 	.probe =	usb_hcd_pci_probe,
+#endif
 	.remove =	usb_hcd_pci_remove,
 	.shutdown = 	usb_hcd_pci_shutdown,
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 2694ed6..9bd7c82 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -639,7 +639,7 @@ ehci_port_speed(struct ehci_hcd *ehci, unsigned int portsc)
  * Big-endian read/write functions are arch-specific.
  * Other arches can be added if/when they're needed.
  */
-#if defined(CONFIG_ARM) && defined(CONFIG_ARCH_IXP4XX)
+#if defined(CONFIG_ARM) && defined(CONFIG_ARCH_IXP4XX) || defined(CONFIG_NLM_XLP)
 #define readl_be(addr)		__raw_readl((__force unsigned *)addr)
 #define writel_be(val, addr)	__raw_writel(val, (__force unsigned *)addr)
 #endif
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index cd1926f..e18f659 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -894,6 +894,18 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 		(void) ohci_readl (ohci, &ohci->regs->control);
 	}
 
+	if (ints & OHCI_INTR_FNO) {
+		ohci_err (ohci, "OHCH frame number overflow\n");
+		ohci_writel (ohci, OHCI_INTR_FNO, &regs->intrstatus);
+		ohci_writel (ohci, OHCI_INTR_FNO, &regs->intrdisable);
+	}
+	
+	if (ints & OHCI_INTR_SO) {
+		ohci_err (ohci, "OHCH scheduling overrun`\n");
+		ohci_writel (ohci, OHCI_INTR_SO, &regs->intrstatus);
+		ohci_writel (ohci, OHCI_INTR_SO, &regs->intrdisable);
+	}	
+
 	return IRQ_HANDLED;
 }
 
@@ -1007,7 +1019,7 @@ MODULE_LICENSE ("GPL");
 #define PCI_DRIVER		ohci_pci_driver
 #endif
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
 #include "ohci-xls.c"
 #define PLATFORM_DRIVER     ohci_xls_driver
 #endif
@@ -1178,7 +1190,7 @@ static int __init ohci_hcd_mod_init(void)
 #endif
 
 #ifdef PLATFORM_DRIVER
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
     /* On the XLS, use the internal USB Controller */
     if (is_xls())
 #endif
@@ -1310,7 +1322,7 @@ static void __exit ohci_hcd_mod_exit(void)
 	platform_driver_unregister(&OF_PLATFORM_DRIVER);
 #endif
 #ifdef PLATFORM_DRIVER
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
     if (is_xls())
 #endif
 	platform_driver_unregister(&PLATFORM_DRIVER);
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 1843bb6..efee824 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -1,3 +1,11 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
+ * This is a derived work from software originally provided by the external
+ * entity identified below. The licensing terms and warranties specified in
+ * the header of the original work apply to this derived work.
+ *
+ * *****************************#NETL_1#********************************/
+
 /*
  * OHCI HCD (Host Controller Driver) for USB.
  *
@@ -22,6 +30,61 @@
 #include <linux/io.h>
 
 
+#ifdef CONFIG_NLM_XLP
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_usb.h>
+
+static void xlp_usb_start_ohc(int ctrl_no)
+{
+	/* enable interrupts
+	 */
+	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN,
+			USB_CTRL_INTERRUPT_EN
+			| USB_OHCI_INTERRUPT_EN
+			| USB_OHCI_INTERRUPT12_EN
+			| USB_OHCI_INTERRUPT1_EN);
+	return;
+}
+
+static void xlp_usb_stop_ohc(int ctrl_no)
+{
+	int val;
+
+	val = usb_reg_read(0, ctrl_no, XLP_USB_INT_EN);
+	val &= ~(USB_CTRL_INTERRUPT_EN
+			| USB_OHCI_INTERRUPT_EN
+			| USB_OHCI_INTERRUPT12_EN
+			| USB_OHCI_INTERRUPT1_EN);
+	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN, val);
+
+	return;
+}
+
+int xlp_ohci_hcd_pci_probe(struct pci_dev *dev, 
+		const struct pci_device_id *id)
+{
+	int irq, irt, ctrl_no;
+
+	ctrl_no = dev->devfn & 0xF;
+
+	irt = usb_reg_read( 0, ctrl_no, 0x3D) & 0xFFFF;
+	irq = nlm_hal_request_shared_irq(irt);
+
+	if (!irq) {
+		printk("Found HC with no IRQ.  Check BIOS/PCI %s setup!\n", 
+				pci_name(dev));
+		return -ENODEV;
+	}
+
+	dev->irq = irq;
+	xlp_usb_start_ohc(ctrl_no);
+	return usb_hcd_pci_probe(dev, id);
+}
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 static int broken_suspend(struct usb_hcd *hcd)
@@ -394,10 +457,22 @@ static const struct hc_driver ohci_pci_hc_driver = {
 
 
 static const struct pci_device_id pci_ids [] = { {
+#ifdef CONFIG_NLM_XLP
+	{
+		.vendor         = PCI_VENDOR_ID_NETLOGIC,
+		.device         = XLP_DEVID_OHCI,
+		.subvendor      = 0,
+		.subdevice      = 0,
+		.class          = PCI_CLASS_SERIAL_USB_OHCI,
+		.class_mask     = ~0,
+		.driver_data =  (unsigned long) &ohci_pci_hc_driver,
+	},
+#else
 	/* handle any USB OHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
 	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
 	}, {
+#endif
 	/* The device in the ConneXT I/O hub has no class reg */
 	PCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_OHCI),
 	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
@@ -409,8 +484,11 @@ MODULE_DEVICE_TABLE (pci, pci_ids);
 static struct pci_driver ohci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-
+#ifdef CONFIG_NLM_XLP
+	.probe =    xlp_ohci_hcd_pci_probe,
+#else
 	.probe =	usb_hcd_pci_probe,
+#endif
 	.remove =	usb_hcd_pci_remove,
 	.shutdown =	usb_hcd_pci_shutdown,
 
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 1b19aea..fb9872f 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -557,6 +557,11 @@ static inline struct usb_hcd *ohci_to_hcd (const struct ohci_hcd *ohci)
  * Other arches can be added if/when they're needed.
  *
  */
+#if defined(CONFIG_NLM_XLP)
+#define readl_be(addr)          __raw_readl((__force unsigned *)addr)
+#define writel_be(val, addr)    __raw_writel(val, (__force unsigned *)addr)
+#endif
+
 static inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,
 					__hc32 __iomem * regs)
 {
-- 
1.7.10.4

