From 0a936f364e3610d3f6accfb68e9986b81fef440a Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthi.annadurai@broadcom.com>
Date: Thu, 19 Jul 2012 16:15:04 +0530
Subject: [PATCH 552/762] XLP base port: Multi-Node support.

1. Fixed toolchain prefix in nlm_xlp_evp_numa_defconfig
2. errata: refix the workaround where cross-node flash access is not permitted
o For multi-node, when linux booting, it is possible that the kernel init thread
(which runs the flash setup is enabled) may run on non-zero node. This will
cause booting failure as the cross-node flash access is not supported in XLP.
o This fix tries to restrict the kernel init thread to be on cpu 0 only for
device setup. After that, the restriction will be removed.

Based on Broadcom SDK 2.3.

Signed-off-by: Jayanthi A <jayanthi.annadurai@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/mmzone.h |    2 +-
 arch/mips/netlogic/xlp/numa.c                |   91 +----
 arch/mips/netlogic/xlp/setup.c               |  550 +++++++++++++++++---------
 init/main.c                                  |   17 +-
 4 files changed, 370 insertions(+), 290 deletions(-)

diff --git a/arch/mips/include/asm/mach-netlogic/mmzone.h b/arch/mips/include/asm/mach-netlogic/mmzone.h
index c494729..42b7c42 100644
--- a/arch/mips/include/asm/mach-netlogic/mmzone.h
+++ b/arch/mips/include/asm/mach-netlogic/mmzone.h
@@ -2,7 +2,7 @@
 #define _ASM_MACH_MMZONE_H
 
 #if defined(CONFIG_NEED_MULTIPLE_NODES) && defined(CONFIG_NUMA)
-
+#include <linux/mmzone.h>
 #include <linux/cpumask.h>
 
 #ifndef NLM_MAX_CPU_NODE
diff --git a/arch/mips/netlogic/xlp/numa.c b/arch/mips/netlogic/xlp/numa.c
index 37bc7aa..e03ee31 100644
--- a/arch/mips/netlogic/xlp/numa.c
+++ b/arch/mips/netlogic/xlp/numa.c
@@ -16,6 +16,7 @@
 #include <asm/bootinfo.h>
 #include <asm/mach-netlogic/mmu.h>
 #include <asm/netlogic/xlp.h>
+#include <asm/netlogic/iomap.h>
 
 extern unsigned long setup_zero_pages(void);
 
@@ -31,75 +32,16 @@ struct xlp_dram_mapping {
 	int node;
 };
 #define NLM_NODES_MAX_DRAM_REGION (NLM_MAX_DRAM_REGION * MAX_NUMNODES)
-static struct xlp_dram_mapping	dram_map[NLM_NODES_MAX_DRAM_REGION];
+extern struct xlp_dram_mapping	dram_map[NLM_NODES_MAX_DRAM_REGION];
+extern void nlm_get_dram_mapping(void);
 extern int hcpu_to_lcpu[];
 
-#define NLM_DRAM_BASE_REG_0	20
-#define NLM_DRAM_LIMIT_REG_0	28
-#define NLM_DRAM_NODEADDR_XLAT	36
-
-
-#define HDR_OFFSET	0x100
-#define BRIDGE  (0x00<<20) | (0x00<<15) | (0x00<<12)
-#define cpu_io_mmio(node,offset)  ((__u32 *)(DEFAULT_NETLOGIC_IO_BASE + \
-                         (node<<18) + (offset) + HDR_OFFSET))
-
 #if defined (CONFIG_64BIT) && defined (CONFIG_MAPPED_KERNEL)
 #define _low_virt_to_phys(addr) ((unsigned long)(addr) & ~CKSSEG)
 #endif
 
 static uint8_t _node_map_mem[MAX_NUMNODES][PAGE_SIZE];
 
-int is_xlp832_step_A_chip(void)
-{
-	uint32_t prid    = read_c0_prid();
-	uint32_t chip_id = (prid >> 8) & 0xff;
-	uint32_t rev_id  = prid & 0xff;
-
-	if (chip_id == CHIP_PROCESSOR_ID_XLP_8XX
-	    || chip_id == CHIP_PROCESSOR_ID_XLP_832) {
-		if (rev_id == XLP_REVISION_A0 || rev_id == XLP_REVISION_A1
-		    || rev_id == XLP_REVISION_A2)
-			return 1;
-	}
-
-	return 0;
-
-}
-
-static void read_node_bars(int node)
-{
-	int i, idx;
-	uint32_t *membase = cpu_io_mmio(node, BRIDGE);
-
-	for (i = 0; i < NLM_MAX_DRAM_REGION; i++) {
-		uint64_t base_reg  = *(membase + NLM_DRAM_BASE_REG_0  + i);
-		uint64_t limit_reg = *(membase + NLM_DRAM_LIMIT_REG_0 + i);
-		uint32_t node_reg = *(membase + NLM_DRAM_NODEADDR_XLAT + i);
-
-		if(((node_reg >> 1) & 0x3) != node) {
-			continue;
-		}
-		if(((limit_reg >> 12) << 20) == 0) {
-			continue;
-		}
-		idx = (node * NLM_MAX_DRAM_REGION) + i;
-		dram_map[idx].low_pfn = ((base_reg >> 12) << 20) >> PAGE_SHIFT;
-		dram_map[idx].high_pfn = 
-			((limit_reg >> 12) << 20) >> PAGE_SHIFT;
-		dram_map[idx].node = node;
-	}
-}
-
-static void nlm_get_dram_mapping(void)
-{
-	int  node;
-
-	for(node=0; node < MAX_NUMNODES; node++) {
-		read_node_bars(node);
-	}
-}
-
 extern cpumask_t fdt_cpumask;
 static void nlm_init_bootmem_node (unsigned long mapstart, unsigned long min_pfn, unsigned long max_pfn)
 {
@@ -367,33 +309,6 @@ void __init nlm_numa_bootmem_init(unsigned long reserved_end)
 	nlm_reserve_bootmem();
 }
 
-static int __init page_is_ram(unsigned long pagenr)
-{
-	int i;
-
-#if 0
-	for (i = 0; i < NLM_NODES_MAX_DRAM_REGION; i++) {
-		if (pagenr >= dram_map[i].low_pfn && 
-				pagenr <= dram_map[i].high_pfn) {
-			return 1;
-		}
-	}
-#endif
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		unsigned long start, end;
-
-		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
-			continue;
-
-		start = PFN_UP(boot_mem_map.map[i].addr);
-		end   = PFN_DOWN(boot_mem_map.map[i].addr
-				    + boot_mem_map.map[i].size);
-		if(pagenr >= start && pagenr <= end)
-			return 1;
-	}
-	return 0;
-}
-
 void __init paging_init(void)
 {
 	unsigned long zones_size[MAX_NR_ZONES] = {0, };
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index c04c61f..56db462 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -32,29 +32,36 @@
  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <linux/kernel.h>
-#include <linux/serial_8250.h>
-#include <linux/pm.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
 #include <linux/bootmem.h>
+#include <linux/init.h>
+#include <linux/pm.h>
 
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
 #include <asm/reboot.h>
 #include <asm/time.h>
-#include <asm/bootinfo.h>
-
-#include <asm/netlogic/xlp.h>
-
-#include <linux/of_fdt.h>
-#include <linux/of_platform.h>
-#include <linux/of_device.h>
-
-#include <asm/netlogic/haldefs.h>
-#include <asm/netlogic/common.h>
+#include <linux/interrupt.h>
+#include <asm/atomic.h>
+#include <asm/cacheflush.h>
 
+#include <asm/mipsregs.h>
+#include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/iomap.h>
-#include <asm/netlogic/xlp-hal/xlp.h>
-#include <asm/netlogic/xlp-hal/sys.h>
-
+#include <asm/netlogic/debug.h>
+#include <asm/netlogic/xlp.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <asm/mach-netlogic/mmu.h>
+#include <asm/netlogic/bootinfo.h>
 #include <asm/netlogic/cpumask.h>
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/xlp_irq.h>
 #include <asm/netlogic/phnx_loader.h>
 #include "../boot/ops.h"
 #include <asm/netlogic/hal/nlm_hal.h>
@@ -106,7 +113,7 @@ char cpu_model_info[MAX_CPU_REV_LEN] = {'X','L','P'};
 
 static unsigned int xlp_uart_portid = 0;
 
-char prop_buf[MAX_PROP_LEN];
+static char prop_buf[MAX_PROP_LEN];
 
 void *nlm_common_psb_shm = 0;
 unsigned long nlm_common_psb_shm_size = 0;
@@ -124,7 +131,6 @@ const char *DEFAULT_INITRD_BOOT_PARAMS = "rdinit=/sbin/init ";
 atomic_t cpus_rebooted = ATOMIC_INIT(0);
 #endif
 
-void parse_cmdline(void);
 unsigned long long nlm_common_tlb_stats[NR_CPUS] __cacheline_aligned;
 DEFINE_SPINLOCK(atomic_lock);
 
@@ -146,80 +152,207 @@ struct xlp_stack_pages xlp_stack_pages_temp
 __attribute__((__section__(".data.init_task"),
 	       __aligned__(THREAD_SIZE)));
 
-extern void prom_pre_boot_secondary_cpus(void *);
-
-
-/* used for command line parsing */
-uint32_t nlm_common_loader_kseg_start, nlm_common_loader_kseg_size;
-uint32_t nlm_common_loader_mask;
-/* Size of the shared memory b/w Linux userapp and rmios apps */
-uint32_t nlm_common_app_sh_mem_sz;
-unsigned long  nlm_common_app_shmem_start;
-
-/* xls chip family variables */
-int chip_is_xls6xx = 0;
-int chip_is_xls4xx = 0;
-int chip_is_xls2xx = 0;
-int chip_is_xls1xx = 0;
-int chip_is_xls = 0;
-int chip_is_xls_b0 = 0;
-int chip_is_xls6xx_b0 = 0;
-int chip_is_xls4xx_b0 = 0;
-EXPORT_SYMBOL(chip_is_xls6xx);
-EXPORT_SYMBOL(chip_is_xls4xx);
-EXPORT_SYMBOL(chip_is_xls2xx);
-EXPORT_SYMBOL(chip_is_xls1xx);
-EXPORT_SYMBOL(chip_is_xls);
-EXPORT_SYMBOL(chip_is_xls_b0);
-EXPORT_SYMBOL(chip_is_xls6xx_b0);
-EXPORT_SYMBOL(chip_is_xls4xx_b0);
-
-__u32 xlr_board_major_version = 0;
-__u32 xlr_board_minor_version = 0;
-
-int xlr_hybrid;
-int xlr_loader_support=0;
-int xlr_loader_sharedcore=0;
-int xlr_loader_own_gmac=0;
-int xlr_loader_own_dma=0;
-
-uint32_t xlr_linux_cpu_mask;
-int xlr_console_pci_con_dev = 0;
-int xlr_console_pci_con_baud = 0;
-int xlr_boot_over_nfs = 0;
-
-unsigned long long nlm_common_tlb_stats[NR_CPUS] __cacheline_aligned;
-
-/* default to uniprocessor */
-uint32_t nlm_coremask = 1, nlm_cpumask  = 1;
-int  nlm_threads_per_core = 1;
-extern u32 __dtb_start[];
+struct boot_mem_map boot_physaddr_info;
+struct xlp_dram_mapping {          
+                unsigned long low_pfn; 
+                unsigned long high_pfn;        
+                int node;   
+};        
+#define NLM_NODES_MAX_DRAM_REGION (NLM_MAX_DRAM_REGION * MAX_NUMNODES)      
+struct xlp_dram_mapping  dram_map[NLM_NODES_MAX_DRAM_REGION];        
+          
+#define NLM_DRAM_BASE_REG_0     20 
+#define NLM_DRAM_LIMIT_REG_0    28 
+#define NLM_DRAM_NODEADDR_XLAT  36 
+#define HDR_OFFSET      0x100      
+#define BRIDGE  (0x00<<20) | (0x00<<15) | (0x00<<12)        
+#define cpu_io_mmio_setup(node,offset)  ((__u32 *)(DEFAULT_NETLOGIC_IO_BASE + \
+                         (node<<18) + (offset) + HDR_OFFSET))    
 
 int nlm_common_get_pgprot(unsigned long address)
 {
-	return 0;
+	int i = 0;
+
+	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
+		__u64 start = 0, end = 0;
+		long type = 0;
+
+		start = boot_physaddr_info.map[i].addr;
+		end = start + boot_physaddr_info.map[i].size;
+		type = boot_physaddr_info.map[i].type;
+
+		if (address >= start && address < end) {
+			/* Uncached */
+			if (type == BOOT_MEM_RESERVED) return 1;
+			/* cached */
+			if (type == BOOT_MEM_RAM) return 0;
+		}
+	}
+
+	/* uncached */
+	return 1;
 }
 
 int valid_mmap_nlm_common_addr_range(unsigned long pfn)
 {
+	int i;
+	__u64 end=0;
+
+	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
+		end = boot_physaddr_info.map[i].addr + boot_physaddr_info.map[i].size;
+		end = end >> PAGE_SHIFT;
+		if (pfn <= (unsigned long)end)
+			return 1;
+	}
 	return 0;
 }
 
-static void nlm_linux_exit(void)
+void read_node_bars(int node)    
+{         
+        int i, idx;
+        uint32_t *membase = cpu_io_mmio_setup(node, BRIDGE);      
+          
+        for (i = 0; i < NLM_MAX_DRAM_REGION; i++) {
+                uint64_t base_reg  = *(membase + NLM_DRAM_BASE_REG_0  + i); 
+                uint64_t limit_reg = *(membase + NLM_DRAM_LIMIT_REG_0 + i); 
+                uint32_t node_reg = *(membase + NLM_DRAM_NODEADDR_XLAT + i);
+          
+                if(((node_reg >> 1) & 0x3) != node) {       
+                        continue;  
+                }  
+                if(((limit_reg >> 12) << 20) == 0) {        
+                        continue;  
+                }  
+
+                idx = (node * NLM_MAX_DRAM_REGION) + i;     
+                dram_map[idx].low_pfn = ((base_reg >> 12) << 20) >> PAGE_SHIFT;          
+                dram_map[idx].high_pfn =
+                        ((limit_reg >> 12) << 20) >> PAGE_SHIFT;
+                dram_map[idx].node = node;         
+          
+                if(dram_map[idx].high_pfn == dram_map[idx].low_pfn){
+                    continue;
+                }
+                boot_physaddr_info.map[boot_physaddr_info.nr_map].addr = dram_map[idx].low_pfn << PAGE_SHIFT;     
+                boot_physaddr_info.map[boot_physaddr_info.nr_map].size = 
+                        (dram_map[idx].high_pfn - dram_map[idx].low_pfn + (1<<(20-PAGE_SHIFT))) << PAGE_SHIFT;  
+                boot_physaddr_info.map[boot_physaddr_info.nr_map].type = BOOT_MEM_RAM;   
+                boot_physaddr_info.nr_map++;       
+        } 
+}         
+
+void nlm_get_dram_mapping(void)
+{
+        int  node;
+        boot_physaddr_info.nr_map = 0;
+
+        for(node=0; node < MAX_NUMNODES; node++) {
+                read_node_bars(node);
+        }
+}
+
+
+const char *get_system_type(void)
+{
+	return "Netlogic XLP SoC";
+}
+
+static void ptr_linux_exit(void)
+{
+	// trigger a chip reset
+	 nlm_hal_write_sys_reg(netlogic_node_id(), CHIP_RESET, 1);
+	 for ( ; ; )
+		  cpu_wait();
+}
+
+void __init bus_error_init(void)
 {
-	nlm_hal_write_sys_reg(netlogic_node_id(), CHIP_RESET, 1);
-	for ( ; ; )
-		cpu_wait();
 }
 
 void __init plat_mem_setup(void)
 {
-	panic_timeout	= 5;
-	_machine_restart = (void (*)(char *))nlm_linux_exit;
-	_machine_halt	= nlm_linux_exit;
-	pm_power_off	= nlm_linux_exit;
+	extern int panic_timeout;
+
+	panic_timeout 	 = 5;
+	_machine_restart = (void (*)(char *))ptr_linux_exit;
+	_machine_halt    = ptr_linux_exit;
+	pm_power_off 	 = ptr_linux_exit;
+	return;
+}
+
+struct nlm_common_name_value_struct {
+	char *name;
+	uint32_t *val;
+};
+
+static void prom_add_memory(uint64_t start, uint64_t size) __attribute__((unused));
+static void prom_add_memory(uint64_t start, uint64_t size)
+{
+	__u64 pref_backup = 512;
+
+	add_memory_region(
+			start, size - pref_backup, /* CHECK! */
+			BOOT_MEM_RAM);
+	return;
+}
+
+
+void __init nlm_nmi_setup (void)
+{
+	void *base;
+	extern char nlm_except_vec_nmi;
+
+	printk("Setting up NMI Handler \n");
+	base = (void *)(unsigned long)0xffffffffbfc00000ULL;
+	memcpy(base, &nlm_except_vec_nmi, 0x80);
+}
+
+/* setup early serial port driver */
+#ifdef CONFIG_SERIAL_8250
+#define UART_CLK 133333333
+
+static void __init nlm_early_serial_setup(int uart_id)
+{
+	struct uart_port s;
+	extern int __init early_serial_setup(struct uart_port *port);
+
+	memset(&s, 0, sizeof(s));
+	s.flags = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
+	s.iotype = UPIO_MEM32;
+	s.regshift = 2; /* registers are 4 bytes wide */
+	/* hardware int 4 - the serial int, is CPU int 6
+	 but poll for now */
+	s.uartclk = UART_CLK;
+	switch(uart_id){
+		default:
+		case 0:
+			s.irq = xlp_pic_irt_to_irq(XLP_PIC_IRT_UART(0));
+			s.membase = (unsigned char __iomem *)
+			(DEFAULT_NETLOGIC_IO_BASE + NETLOGIC_IO_UART_0_OFFSET);
+			s.mapbase = (DEFAULT_NETLOGIC_IO_BASE +
+					NETLOGIC_IO_UART_0_OFFSET);
+			s.line = 0;
+			break;
+		case 1:
+			s.irq = xlp_pic_irt_to_irq(XLP_PIC_IRT_UART(1));
+			s.membase = (unsigned char __iomem *)
+			(DEFAULT_NETLOGIC_IO_BASE + NETLOGIC_IO_UART_1_OFFSET);
+			s.mapbase = (DEFAULT_NETLOGIC_IO_BASE +
+					NETLOGIC_IO_UART_1_OFFSET);
+			s.line = 1;
+			break;
+	}
+	s.serial_in	= xlp_uart_in;
+	s.serial_out	= xlp_uart_out;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial setup failed!\n");
+	}
 }
+#else
+static void nlm_early_serial_setup(int uart_id) {}
+#endif /* CONFIG_SERIAL_8250 */
 
+extern struct plat_smp_ops nlm_smp_ops;
 struct loader_mem_info loader_mem_map[MAX_NUM_LOADER_MEM_BLK];
 
 #define MAX_CPUMASK_CELLS 4
@@ -243,9 +376,7 @@ int ipsec_async_vc = -1, ipsec_sync_vc = -1;
 static void parse_fdt_sae_vc_config(void)
 {
 	void *node;
-	void * valid_node;
 	int i;
-	int num_nodes = 1;
 	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
 	node = finddevice("/doms/dom@0/cpu");
 	if(node) {
@@ -255,9 +386,9 @@ static void parse_fdt_sae_vc_config(void)
 		if (getprop(node, "nae-fb-vc", &nae_fb_vc, 4) > 0)
                         nae_fb_vc = fdt32_to_cpu(nae_fb_vc);
 
-		if (getprop(node, "sae-rx-vc", &sae_rx_vc, 4) > 0)
+		if (getprop(node, "sae-rx-vc", &sae_rx_vc, 4) > 0) 
 			sae_rx_vc = fdt32_to_cpu(sae_rx_vc);
-
+		
 		if (getprop(node, "sae-rx-sync-vc", &sae_rx_sync_vc, 4) > 0)
 			sae_rx_sync_vc = fdt32_to_cpu(sae_rx_sync_vc);
 
@@ -266,17 +397,12 @@ static void parse_fdt_sae_vc_config(void)
 
 		if (getprop(node, "ipsec-sync-vc", &ipsec_sync_vc, 4) > 0)
 			ipsec_sync_vc = fdt32_to_cpu(ipsec_sync_vc);
-
-		valid_node  = finddevice("/soc/nodes");
-
-		if (getprop(valid_node, "num-nodes", &num_nodes, 4) > 0 )
-			num_nodes = fdt32_to_cpu(num_nodes);
-
-		for(i =0 ; i < num_nodes*NLM_MAX_CPU_PER_NODE; i++) {
+		
+		for(i =0 ; i < NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE; i++) {
 			if(nlm_cpu_vc_mask[i] & (1 << ipsec_sync_vc)) {
 				ipsec_sync_vc = -1;
 			}
-
+				 
 		}
 	}
 
@@ -289,6 +415,7 @@ EXPORT_SYMBOL(sae_rx_sync_vc);
 EXPORT_SYMBOL(ipsec_async_vc);
 EXPORT_SYMBOL(ipsec_sync_vc);
 
+
 static int __init fdt_process(void)
 {
 	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
@@ -572,56 +699,175 @@ noloadermask:
 	return 0;
 }
 
-#ifdef CONFIG_MAPPED_KERNEL
-#define secondary_cpus_bootup_func \
-	((unsigned long)prom_pre_boot_secondary_cpus - \
-	 (unsigned long)LOADADDR + (unsigned long)PHYSADDR)
+char* get_cpu_info(void)
+{
+	struct nlm_netl_proc_info cpu_info;
+	if (!nlm_hal_get_cpuinfo(&cpu_info)){
+		strcpy(cpu_model_info, cpu_info.cpu_info_str);
+	}else{
+		strcpy(cpu_model_info, "Unknown CPU");
+	}
+	return cpu_model_info;
+}
+
+#ifdef CONFIG_XEN
+extern void xen_init(void);
 #else
-#define secondary_cpus_bootup_func prom_pre_boot_secondary_cpus
+static void xen_init(void) {}
 #endif
 
-const char *get_system_type(void)
+#ifdef CONFIG_NUMA
+static void sort_mem_info(struct nlm_node_mem_info *info, unsigned long *spfn,
+	unsigned long *epfn)
 {
-	return "Netlogic XLP Series";
+	struct nlm_node_mem_frag *list = info->mem;
+	int i,j;
+
+	uint64_t start_pfn = 0;
+	uint64_t end_pfn = 0;
+
+	*spfn = *epfn = 0;
+	if(info->frags == 0)
+		return;
+
+	for(i=0; i < info->frags; i++) {
+		for (j = i; j < info->frags; j++) {
+			if (list[i].start_pfn > list[j].start_pfn) {
+				start_pfn = list[i].start_pfn;
+				end_pfn = list[i].end_pfn;
+				list[i].start_pfn = list[j].start_pfn;
+				list[i].end_pfn = list[j].end_pfn;
+				list[j].start_pfn = start_pfn;
+				list[j].end_pfn = end_pfn;
+			}
+		}
+	}
+	*spfn = list[0].start_pfn;
+	*epfn = list[info->frags-1].end_pfn;
 }
 
-void __init prom_free_prom_memory(void)
+void __init prom_meminit(void)
 {
-	/* Nothing yet */
+	int node=0;
+	unsigned long start_pfn, end_pfn;
+	struct nlm_mem_info *minfo;
+
+	/* sort the node_mem_map */
+	for(node=0; node < nlm_nodes; node++) {
+        	sort_mem_info(&node_mem_info[node], &start_pfn, &end_pfn);
+        	minfo = NODE_MEM_DATA(node);
+        	minfo->low_pfn = start_pfn;
+        	minfo->high_pfn = end_pfn;
+	}
 }
 
-void xlp_mmu_init(void)
+extern struct nlm_node_data __node_data_holder[];
+void __init build_node_cpu_map(void)
 {
-	/* enable extended TLB and Large Fixed TLB */
-	write_c0_config6(read_c0_config6() | 0x24);
+	int cpu, node,i;
+
+	/* kernel expects all node_data to initialized
+ 	 * If a node has its own memory, we will overwrite this pointer
+ 	 */
+	for(node=0; node < MAX_NUMNODES; node++) {
+		__node_data[node] = &__node_data_holder[node];
+	}
 
-	/* set page mask of Fixed TLB in config7 */
-	write_c0_config7(PM_DEFAULT_MASK >>
-		(13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
+	i=0;
+	for_each_cpu(cpu, &fdt_cpumask) {
+		node = hardcpu_to_node(cpu);
+		hcpu_to_lcpu[cpu] = i;
+		if(!node_online(node)) {
+			node_set_online(num_online_nodes());
+		}
+		i++;
+	}
+	printk("Number of online nodes = %d\n", num_online_nodes());
 }
+#endif
 
 void __init prom_init(void)
 {
+#ifdef CONFIG_NLM_ENABLE_COP2
+	unsigned int c0status;
+#endif
+
+#ifdef CONFIG_MAPPED_KERNEL
+	setup_mapped_kernel_tlbs(TRUE, TRUE);
+#endif
 
 	fdt_process();
-    	parse_cmdline();
 
-	xlp_mmu_init();
-	nlm_hal_init();
+#ifdef CONFIG_NUMA
+	build_node_cpu_map();
+#endif
 
+	xen_init();
 
 	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
+
 	/* FIXME: we should also remove it for xlp8xx a2, but we do not have interface function
 	 * for it yet. Once A1 is phased out in the field, this workaround code should be removed.
 	 */
 	xlp8xx_a01_workaround_needed = is_nlm_xlp8xx_ax();
 
-#ifdef CONFIG_SMP
-	/* update TLB size after waking up threads */
-	current_cpu_data.tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
+#ifdef CONFIG_NLM_ENABLE_COP2
+	// workaround. trap_init enables cop2. But this function gets called before trap_init
+	c0status = read_c0_status() | ST0_CU2;
+	write_c0_status(c0status);
+#endif
+	cpumask_clear(&smp_boot.online_map);
+	cpumask_set_cpu(hard_smp_processor_id(), &smp_boot.online_map);
+
+	board_nmi_handler_setup = nlm_nmi_setup;
+
+	on_chip_init();
+        nlm_get_dram_mapping();
+
+	/* setup early serial port driver */
+	nlm_early_serial_setup(xlp_uart_portid);
 
 	register_smp_ops(&nlm_smp_ops);
+
+	wakeup_secondary_cpus();
+}
+
+void prom_free_prom_memory(void)
+{
+	/* nothing to free */
+}
+
+#ifndef KSEG0
+#define KSEG0 0xffffffff80000000ULL
 #endif
+
+#define RING_BUFFER_BASE (511 << 20)
+#define RING_BUFFER_SIZE (8 << 10)
+static void outbyte_ring_buffer(char c)
+{
+	unsigned long base = RING_BUFFER_BASE + (hard_smp_processor_id() * RING_BUFFER_SIZE);
+	char *buf = (char *)KSEG0 + base;
+	static int idx = 0;
+
+	buf[idx] = c;
+	idx = (idx + 1) % (RING_BUFFER_SIZE);
+}
+
+void nlm_early_printk(const char *fmt, ...)
+{
+	char buf[256];
+	va_list args;
+	int r;
+	char *str = buf;
+
+	va_start(args, fmt);
+	r = vsnprintf(buf, 256, fmt, args);
+	va_end(args);
+
+	while (*str) {
+		outbyte_ring_buffer(*str);
+		str++;
+	}
 }
 
 #ifdef CONFIG_EARLY_PRINTK
@@ -650,90 +896,12 @@ void prom_putchar(char c)
 }
 #endif
 
-#ifdef CONFIG_BLK_DEV_INITRD
-extern unsigned long initrd_start, initrd_end;
-
-static int __init initrd_setup(char *str)
+static int __init nlm_proc_setup(void)
 {
-	char rdarg[64];
-	int idx;
-	char *tmp, *endptr;
-	unsigned long initrd_size;
-
-	/* Make a copy of the initrd argument so we can smash it up here */
-	for (idx = 0; idx < sizeof(rdarg)-1; idx++) {
-		if (!str[idx] || (str[idx] == ' ')) break;
-		rdarg[idx] = str[idx];
-	}
-
-	rdarg[idx] = 0;
-	str = rdarg;
-
-	/*
-	*Initrd location comes in the form "<hex size of ramdisk in bytes>@<location in memory>"
-	*  e.g. initrd=size@physaddr.
-	*/
-	for (tmp = str; *tmp != '@'; tmp++) {
-	       if (!*tmp) {
-			goto fail;
-		}
-	}
-	*tmp = 0;
-	tmp++;
-	if (!*tmp) {
-		goto fail;
-	}
-	initrd_size = simple_strtoul(str, &endptr, 16);
-	if (*endptr) {
-		 *(tmp-1) = '@';
-		 goto fail;
-	}
-	*(tmp-1) = '@';
-	initrd_start = simple_strtoul(tmp, &endptr, 16);
-
-
-#if defined(CONFIG_32BIT) && defined (CONFIG_MAPPED_KERNEL)
-	initrd_start = CKSEG2ADDR(initrd_start);
-#else
-	initrd_start = CKSEG1ADDR(initrd_start);
-#endif
+	nlm_root_proc = proc_mkdir("netlogic", 0);
+	if (!nlm_root_proc)
+		return -ENOMEM;
 
-	if (*endptr) {
-		goto fail;
-	}
-	initrd_end = initrd_start + initrd_size;
 	return 0;
-	fail:
-	printk("Bad initrd argument.  Disabling initrd\n");
-	initrd_start = 0;
-	initrd_end = 0;
-	return -1;
-}
-#endif
-
-/*
- * Init routine which accepts the variables from u-boot
- */
-void  __init parse_cmdline(void)
-{
-	char *ptr;
-	/* Need to find out early whether we've got an initrd.  So scan
-	the list looking now */
-	for (ptr = arcs_cmdline; *ptr; ptr++) {
-		while (*ptr == ' ') {
-			ptr++;
-		}
-		if (!strncmp(ptr, "initrd=", 7)) {
-#ifdef CONFIG_BLK_DEV_INITRD
-			initrd_setup(ptr+7);
-#else
-			printk("initrd is disabled in Kernel\n");
-#endif
-			break;
-		} else {
-			while (*ptr && (*ptr != ' ')) {
-				ptr++;
-			}
-		}
-	}
 }
+rootfs_initcall(nlm_proc_setup);
diff --git a/init/main.c b/init/main.c
index 8dedf56..6c45c22 100644
--- a/init/main.c
+++ b/init/main.c
@@ -880,20 +880,17 @@ static int __init kernel_init(void * unused)
 	sched_init_smp();
 
 #if defined(CONFIG_NLM_XLP) && defined(CONFIG_NUMA)
-	/* This is really a workaround for XLP A0/1/2 chips.
-	 * On these chips, PIC device specific registers cannot be accessed
+	/* On XLP Ax, PIC device specific registers cannot be accessed
 	 * cross different nodes. So the kernel_init has to run on node 0.
+	 * On XLP B0, the flash device cannot be accessed cross node, so flash
+	 * driver has to run on node 0.
 	 * For simplicity, just let is run on vcpu 0.
 	 */
 	{
-		extern int is_xlp832_step_A_chip(void);
-
-                if (is_xlp832_step_A_chip()) {
-			struct cpumask new_mask;
-			cpumask_clear(&new_mask);
-			cpumask_set_cpu(0, &new_mask);
-			set_cpus_allowed_ptr(current, &new_mask);
-		}
+		struct cpumask new_mask;
+		cpumask_clear(&new_mask);
+		cpumask_set_cpu(0, &new_mask);
+		set_cpus_allowed_ptr(current, &new_mask);
 	}
 #endif
 
-- 
1.7.0.4

