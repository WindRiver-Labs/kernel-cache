From 1162dc96e6b360be4fb60dfdba6d9406255b8a4b Mon Sep 17 00:00:00 2001
From: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Date: Tue, 18 May 2010 18:16:11 -0700
Subject: [PATCH 028/761] clean-up and enhance xen hypercall interface and
 functionality

(a) asm/xen/hypercall.h: clean-up of gp context switching code
                         addition of HYPERVISOR_set_callbacks()
(b) asm/xen/interface.h: remove commented out code
                         addition of new constants and datatypes
(c) arch/mips/xen/enlighten.c: call HYPERVISOR_set_callbacks()
                               to register __get_free_pages function

Based on Broadcom SDK 2.3.

Signed-off-by: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/xen/hypercall.h |   55 ++++++----
 arch/mips/include/asm/xen/interface.h |  193 ++++++++++++++++-----------------
 arch/mips/netlogic/xlp/bootinfo.c     |    1 -
 arch/mips/xen/enlighten.c             |   58 +++++-----
 4 files changed, 157 insertions(+), 150 deletions(-)

diff --git a/arch/mips/include/asm/xen/hypercall.h b/arch/mips/include/asm/xen/hypercall.h
index 8ff3ce7..387ffec 100644
--- a/arch/mips/include/asm/xen/hypercall.h
+++ b/arch/mips/include/asm/xen/hypercall.h
@@ -80,9 +80,11 @@
  * there aren't more than 5 arguments...)
  */
 
+DECLARE_PER_CPU(unsigned long, gpctx);
+
 extern struct { char _entry[32]; } hypercall_page[];
 
-#define save_gp(var) \
+#define load_gp(var) \
 ({ \
         __asm__ __volatile__ ( \
                 ".set push\n" \
@@ -93,7 +95,7 @@ extern struct { char _entry[32]; } hypercall_page[];
                 ); \
 })
 
-#define restore_gp(var) \
+#define store_gp(var) \
 ({ \
         __asm__ __volatile__ ( \
                 ".set push\n" \
@@ -105,7 +107,13 @@ extern struct { char _entry[32]; } hypercall_page[];
                 ); \
 })
 
-#define load_gp restore_gp
+#define switch_xen_linux_stacks() \
+({ \
+	load_gp(__get_cpu_var(gpctx)); \
+	store_gp((*(HYPERVISOR_shared_info->arch.xensp)) & ~(XEN_PAGE_SIZE - 1)); \
+})
+
+#define restore_linux_stack() store_gp(__get_cpu_var(gpctx))
 
 #if 0
 #define __HYPERCALL		"call hypercall_page+%c[offset]"
@@ -289,13 +297,26 @@ HYPERVISOR_set_callbacks(unsigned long event_selector,
 }
 #else  /* CONFIG_64BIT */
 static inline int
-HYPERVISOR_set_callbacks(unsigned long event_address,
-			unsigned long failsafe_address,
-			unsigned long syscall_address)
+HYPERVISOR_set_callbacks(unsigned long event, unsigned long callback_address)
 {
-	return _hypercall3(int, set_callbacks,
-			   event_address, failsafe_address,
-			   syscall_address);
+	int (*hc_set_callbacks)(unsigned long, unsigned long);
+	int retval = 0;
+	unsigned long *hc_offset = (unsigned long *)hypercall_page;
+	
+#if 0
+	unsigned long __gp;
+	unsigned long __current;
+#endif
+
+	hc_set_callbacks = (void *)(hc_offset[__HYPERVISOR_set_callbacks]);
+
+	switch_xen_linux_stacks();
+
+	retval = hc_set_callbacks(event, callback_address);
+
+	restore_linux_stack();
+
+	return retval;
 }
 #endif  /* CONFIG_{32,64}BIT */
 
@@ -401,10 +422,7 @@ HYPERVISOR_console_io(int cmd, int count, char *str)
 {
 	int (*hc_console_io)(int cmd, int count, char *str);
 	unsigned long long *hc_offset = (unsigned long long *)hypercall_page;
-	unsigned long __gp;
 	int retval;
-	unsigned long __current;
-	struct shared_info *shared_info;
 
 	hc_console_io = (void *)(hc_offset[__HYPERVISOR_console_io]);
 
@@ -418,20 +436,11 @@ HYPERVISOR_console_io(int cmd, int count, char *str)
 	 * 5. invoke hypercall
 	 * 6. restore gp
 	 */
-	save_gp(__gp);
-
-	/*
-	 * FIXME: set xen_shared_info to xen_start_info->shared_info
-	 */
-	shared_info = (struct shared_info *)xen_start_info->shared_info;
-
-	__current = *(shared_info->arch.xensp);
-
-	load_gp(__current & ~(XEN_PAGE_SIZE - 1));
+	switch_xen_linux_stacks();
 
 	retval = hc_console_io(cmd, count, str);
 
-	restore_gp(__gp);
+	restore_linux_stack();
 
 	return retval;
 }
diff --git a/arch/mips/include/asm/xen/interface.h b/arch/mips/include/asm/xen/interface.h
index d1d8c16..ae248296 100644
--- a/arch/mips/include/asm/xen/interface.h
+++ b/arch/mips/include/asm/xen/interface.h
@@ -1,13 +1,37 @@
 /******************************************************************************
- * arch-x86_32.h
+ * arch-mips/xen.h
+ * 
+ * Guest OS interface to mips Xen.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
  *
- * Guest OS interface to x86 Xen.
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
  *
- * Copyright (c) 2004, K A Fraser
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright (c) 2004-2006, K A Fraser
  */
 
-#ifndef _ASM_MIPS_XEN_INTERFACE_H
-#define _ASM_MIPS_XEN_INTERFACE_H
+#ifndef __XEN_PUBLIC_ARCH_MIPS_XEN_H__
+#define __XEN_PUBLIC_ARCH_MIPS_XEN_H__
+
+#define __XEN_LATEST_INTERFACE_VERSION__ 0x00030209
+
+#define __XEN_INTERFACE_VERSION__ __XEN_LATEST_INTERFACE_VERSION__
+
+#include <asm/sgidefs.h>
 
 #ifdef __XEN__
 #define __DEFINE_GUEST_HANDLE(name, type) \
@@ -18,53 +42,34 @@
 #endif
 
 #define DEFINE_GUEST_HANDLE_STRUCT(name) \
-	__DEFINE_GUEST_HANDLE(name, struct name)
+        __DEFINE_GUEST_HANDLE(name, struct name)
 #define DEFINE_GUEST_HANDLE(name) __DEFINE_GUEST_HANDLE(name, name)
 #define GUEST_HANDLE(name)        __guest_handle_ ## name
 
-#ifdef __XEN__
-#define set_xen_guest_handle(hnd, val)	do { (hnd).p = val; } while (0)
-#else
-#define set_xen_guest_handle(hnd, val)	do { (hnd) = val; } while (0)
+#ifdef __XEN_TOOLS__
+#define get_xen_guest_handle(val, hnd)  do { val = (hnd).p; } while (0)
 #endif
 
-#ifndef __ASSEMBLY__
-/* Guest handles for primitive C types. */
-__DEFINE_GUEST_HANDLE(uchar, unsigned char);
-__DEFINE_GUEST_HANDLE(uint,  unsigned int);
-__DEFINE_GUEST_HANDLE(ulong, unsigned long);
-DEFINE_GUEST_HANDLE(char);
-DEFINE_GUEST_HANDLE(int);
-DEFINE_GUEST_HANDLE(long);
-DEFINE_GUEST_HANDLE(void);
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+#include <asm/xen/xen-mips-32.h>
+#else
+#include <asm/xen/xen-mips-64.h>
 #endif
 
-#ifndef HYPERVISOR_VIRT_START
-#define HYPERVISOR_VIRT_START mk_unsigned_long(__HYPERVISOR_VIRT_START)
+#ifndef __ASSEMBLY__
+typedef unsigned long xen_pfn_t;
+#define PRI_xen_pfn "lx"
 #endif
 
-#define MACH2PHYS_VIRT_START  mk_unsigned_long(__MACH2PHYS_VIRT_START)
-#define MACH2PHYS_VIRT_END    mk_unsigned_long(__MACH2PHYS_VIRT_END)
-#define MACH2PHYS_NR_ENTRIES  ((MACH2PHYS_VIRT_END-MACH2PHYS_VIRT_START)>>__MACH2PHYS_SHIFT)
-
 /* Maximum number of virtual CPUs in multi-processor guests. */
 #define MAX_VIRT_CPUS 32
 
-/*
- * SEGMENT DESCRIPTOR TABLES
- */
-/*
- * A number of GDT entries are reserved by Xen. These are not situated at the
- * start of the GDT because some stupid OSes export hard-coded selector values
- * in their ABI. These hard-coded values are always near the start of the GDT,
- * so Xen places itself out of the way, at the far end of the GDT.
- */
-#define FIRST_RESERVED_GDT_PAGE  14
-#define FIRST_RESERVED_GDT_BYTE  (FIRST_RESERVED_GDT_PAGE * 4096)
-#define FIRST_RESERVED_GDT_ENTRY (FIRST_RESERVED_GDT_BYTE / 8)
+#ifndef __ASSEMBLY__
+
+typedef unsigned long xen_ulong_t;
 
 /*
- * Send an array of these to HYPERVISOR_set_trap_table()
+ * Send an array of these to HYPERVISOR_set_trap_table().
  * The privilege level specifies which modes may enter a trap via a software
  * interrupt. On x86/64, since rings 1 and 2 are unavailable, we allocate
  * privilege levels as follows:
@@ -73,85 +78,71 @@ DEFINE_GUEST_HANDLE(void);
  *  Level == 2: Kernel may enter
  *  Level == 3: Everyone may enter
  */
-#define TI_GET_DPL(_ti)		((_ti)->flags & 3)
-#define TI_GET_IF(_ti)		((_ti)->flags & 4)
-#define TI_SET_DPL(_ti, _dpl)	((_ti)->flags |= (_dpl))
-#define TI_SET_IF(_ti, _if)	((_ti)->flags |= ((!!(_if))<<2))
+#define TI_GET_DPL(_ti)      ((_ti)->flags & 3)
+#define TI_GET_IF(_ti)       ((_ti)->flags & 4)
+#define TI_SET_DPL(_ti,_dpl) ((_ti)->flags |= (_dpl))
+#define TI_SET_IF(_ti,_if)   ((_ti)->flags |= ((!!(_if))<<2))
 
-#ifndef __ASSEMBLY__
 struct trap_info {
     uint8_t       vector;  /* exception vector                              */
     uint8_t       flags;   /* 0-3: privilege level; 4: clear event enable?  */
     uint16_t      cs;      /* code selector                                 */
     unsigned long address; /* code offset                                   */
 };
-DEFINE_GUEST_HANDLE_STRUCT(trap_info);
+typedef struct trap_info trap_info_t;
+DEFINE_GUEST_HANDLE(trap_info_t);
+
+typedef uint64_t tsc_timestamp_t; /* RDTSC timestamp */
+
+/*
+ * The following is all CPU context. Note that the 
+ * fpu_ctxt block is filled  in by FXSAVE if the 
+ * CPU has feature FXSR; otherwise FSAVE is used.
+ *
+ * FIXME: this should be something similar to
+ *        the thread_context{} structure of the
+ *        task_struct, in the sense that it
+ *        would capture the entire cpu context
+ */
+struct vcpu_guest_context {
+
+};
+typedef struct vcpu_guest_context vcpu_guest_context_t;
+DEFINE_GUEST_HANDLE(vcpu_guest_context_t);
 
 struct arch_shared_info {
     unsigned long max_pfn;                  /* max pfn that appears in table */
+	unsigned long start_info_pfn;
     /* Frame containing list of mfns containing list of mfns containing p2m. */
-    unsigned long pfn_to_mfn_frame_list_list;
+    xen_pfn_t     pfn_to_mfn_frame_list_list;
     unsigned long nmi_reason;
+	unsigned long *xensp;
+    uint64_t pad[32];
 };
-#endif	/* !__ASSEMBLY__ */
 
-#ifdef CONFIG_X86_32
-#include "interface_32.h"
-#else
-#include "interface_64.h"
-#endif
+typedef struct arch_shared_info arch_shared_info_t;
 
-#ifndef __ASSEMBLY__
-/*
- * The following is all CPU context. Note that the fpu_ctxt block is filled
- * in by FXSAVE if the CPU has feature FXSR; otherwise FSAVE is used.
- */
-struct vcpu_guest_context {
-    /* FPU registers come first so they can be aligned for FXSAVE/FXRSTOR. */
-    struct { char x[512]; } fpu_ctxt;       /* User-level FPU registers     */
-#define VGCF_I387_VALID (1<<0)
-#define VGCF_HVM_GUEST  (1<<1)
-#define VGCF_IN_KERNEL  (1<<2)
-    unsigned long flags;                    /* VGCF_* flags                 */
-    struct cpu_user_regs user_regs;         /* User-level CPU registers     */
-    struct trap_info trap_ctxt[256];        /* Virtual IDT                  */
-    unsigned long ldt_base, ldt_ents;       /* LDT (linear address, # ents) */
-    unsigned long gdt_frames[16], gdt_ents; /* GDT (machine frames, # ents) */
-    unsigned long kernel_ss, kernel_sp;     /* Virtual TSS (only SS1/SP1)   */
-    /* NB. User pagetable on x86/64 is placed in ctrlreg[1]. */
-    unsigned long ctrlreg[8];               /* CR0-CR7 (control registers)  */
-    unsigned long debugreg[8];              /* DB0-DB7 (debug registers)    */
-#ifdef __i386__
-    unsigned long event_callback_cs;        /* CS:EIP of event callback     */
-    unsigned long event_callback_eip;
-    unsigned long failsafe_callback_cs;     /* CS:EIP of failsafe callback  */
-    unsigned long failsafe_callback_eip;
-#else
-    unsigned long event_callback_eip;
-    unsigned long failsafe_callback_eip;
-    unsigned long syscall_callback_eip;
-#endif
-    unsigned long vm_assist;                /* VMASST_TYPE_* bitmap */
-#ifdef __x86_64__
-    /* Segment base addresses. */
-    uint64_t      fs_base;
-    uint64_t      gs_base_kernel;
-    uint64_t      gs_base_user;
-#endif
-};
-DEFINE_GUEST_HANDLE_STRUCT(vcpu_guest_context);
-#endif	/* !__ASSEMBLY__ */
+typedef unsigned long xen_callback_t;
+
+#endif /* !__ASSEMBLY__ */
+
+/* Size of the shared_info area (this is not related to page size).  */
+#define XSI_SHIFT			14
+#define XSI_SIZE			(1 << XSI_SHIFT)
+
+#define XEN_PAGE_SHIFT 16
+#define XEN_PAGE_SIZE   (1 << XEN_PAGE_SHIFT)
 
 /*
- * Prefix forces emulation of some non-trapping instructions.
- * Currently only CPUID.
+ * Here we define more architecture-specific CALLBACK types
+ * Till we move to complete cpu virtualization, we need to
+ * register __get_free_pages() as a callback function for
+ * memory allocator/allocation. The following definitions
+ * have to be in sync with definitions in public/xen.h.
+ * Currently 7 events are defined and netl-specific events
+ * are set to begin @ 32 to accommodate additions to xen.h
  */
-#ifdef __ASSEMBLY__
-#define XEN_EMULATE_PREFIX .byte 0x0f,0x0b,0x78,0x65,0x6e ;
-#define XEN_CPUID          XEN_EMULATE_PREFIX cpuid
-#else
-#define XEN_EMULATE_PREFIX ".byte 0x0f,0x0b,0x78,0x65,0x6e ; "
-#define XEN_CPUID          XEN_EMULATE_PREFIX "cpuid"
-#endif
 
-#endif /* _ASM_MIPS_XEN_INTERFACE_H */
+#define CALLBACKTYPE_dom0_getfreepages    32
+
+#endif /* __XEN_PUBLIC_ARCH_MIPS_XEN_H__ */
diff --git a/arch/mips/netlogic/xlp/bootinfo.c b/arch/mips/netlogic/xlp/bootinfo.c
index 0df3f80..1e37d95 100644
--- a/arch/mips/netlogic/xlp/bootinfo.c
+++ b/arch/mips/netlogic/xlp/bootinfo.c
@@ -4,7 +4,6 @@
 #include <asm/bootinfo.h>
 #include <asm/netlogic/sim.h>
 #include <asm/netlogic/bootinfo.h>
-#include <xen/interface/xen.h>
 
 static int is_valid_prominfo(struct psb_info *info)
 {
diff --git a/arch/mips/xen/enlighten.c b/arch/mips/xen/enlighten.c
index b2ba959..9b780c1 100644
--- a/arch/mips/xen/enlighten.c
+++ b/arch/mips/xen/enlighten.c
@@ -47,6 +47,8 @@
 #include <asm/reboot.h>
 #include <asm/bootinfo.h>
 
+#include <linux/gfp.h>
+
 EXPORT_SYMBOL_GPL(hypercall_page);
 
 DEFINE_PER_CPU(struct vcpu_info *, xen_vcpu);
@@ -55,8 +57,8 @@ DEFINE_PER_CPU(struct vcpu_info, xen_vcpu_info);
 enum xen_domain_type xen_domain_type = XEN_NATIVE;
 EXPORT_SYMBOL_GPL(xen_domain_type);
 
-unsigned long *machine_to_phys_mapping = (void *)MACH2PHYS_VIRT_START;
-EXPORT_SYMBOL(machine_to_phys_mapping);
+/* unsigned long *machine_to_phys_mapping = (void *)MACH2PHYS_VIRT_START; */
+/* EXPORT_SYMBOL(machine_to_phys_mapping); */
 unsigned int   machine_to_phys_order;
 EXPORT_SYMBOL(machine_to_phys_order);
 
@@ -71,6 +73,14 @@ struct shared_info xen_dummy_shared_info;
  */
 struct shared_info *HYPERVISOR_shared_info = (void *)&xen_dummy_shared_info;
 
+DEFINE_PER_CPU(unsigned long, gpctx);
+
+unsigned long get_phys_to_machine(unsigned long pfn)
+{
+	return pfn;
+}
+EXPORT_SYMBOL_GPL(get_phys_to_machine);
+
 #if 0
 /*
  * Flag to determine whether vcpu info placement is available on all
@@ -139,17 +149,24 @@ static void __init xen_banner(void)
 
 //	printk(KERN_INFO "Booting paravirtualized kernel on Xen\n");
 
+#if 0
 	printk(KERN_INFO "Xen version: %d.%d%s%s%s\n",
 	       version >> 16, version & 0xffff, extra.extraversion,
 	       xen_feature(XENFEAT_mmu_pt_update_preserve_ad) ?
 			" (preserve-AD)" : "",
 	       xen_initial_domain() ? " (dom0)" : "");
+#else
+	printk(KERN_INFO "Xen version: %d.%d%s%s\n",
+	       version >> 16, version & 0xffff, extra.extraversion,
+	       xen_initial_domain() ? " (dom0)" : "");
+#endif
 }
 
 void xen_setup_shared_info(void)
 {
 	HYPERVISOR_shared_info =
-		(struct shared_info *)__va(xen_start_info->shared_info);
+		(struct shared_info *) xen_start_info->shared_info;
+//		(struct shared_info *)__va(xen_start_info->shared_info);
 
 #ifndef CONFIG_SMP
 	/* In UP this is as good a place as any to set up shared info */
@@ -242,34 +259,24 @@ struct setup_header {
 
 static struct setup_header boot_params_hdr;
 
-/* First C function to be called on Xen boot */
-asmlinkage void __init xen_start_kernel(void)
+static int __init xen_start_kernel(void)
 {
-	pgd_t *pgd;
-
-	xen_start_info = (struct start_info *)(unsigned long)(int)fw_arg3;
-	if (!xen_start_info)
-		return;
-
 	xen_domain_type = XEN_PV_DOMAIN;
 
-	BUG_ON(memcmp(xen_start_info->magic, "xen-3", 5) != 0);
+	printk("[%s@%d] magic=\"%s\"\n", __FUNCTION__, __LINE__, xen_start_info->magic);
+	BUG_ON(memcmp(xen_start_info->magic, "xen-3.0-mips", 5) != 0);
+
+	printk("[%s@%d]\n", __FUNCTION__, __LINE__);
+/* 	xen_setup_features(); */
 
-	xen_setup_features();
+	printk("[%s@%d] pt_base=%lx\n", __FUNCTION__, __LINE__, xen_start_info->pt_base);
 
-	pgd = (pgd_t *)xen_start_info->pt_base;
+	xen_setup_shared_info();
 
 	/* Don't do the full vcpu_info placement stuff until we have a
 	   possible map and a non-dummy shared_info. */
 	per_cpu(xen_vcpu, 0) = &HYPERVISOR_shared_info->vcpu_info[0];
 
-	local_irq_disable();
-	early_boot_irqs_off();
-
-	xen_raw_console_write("mapping kernel into physical memory\n");
-
-	init_mm.pgd = pgd;
-
 	/* Poke various useful things into boot_params */
 	boot_params_hdr.type_of_loader = (9 << 4) | 0;
 	boot_params_hdr.ramdisk_image = xen_start_info->mod_start
@@ -280,13 +287,14 @@ asmlinkage void __init xen_start_kernel(void)
 	xen_start_info->console.domU.mfn = 0;
 	xen_start_info->console.domU.evtchn = 0;
 
-	xen_raw_console_write("about to get started...\n");
-
 	_machine_halt = xen_machine_halt;
 	_machine_restart = xen_restart;
 
 	xen_banner();
 
-	/* Start the world */
-	start_kernel();
+	HYPERVISOR_set_callbacks(CALLBACKTYPE_dom0_getfreepages, (unsigned long)__get_free_pages);
+
+	return 0;
 }
+
+subsys_initcall(xen_start_kernel);
-- 
1.7.10.4

