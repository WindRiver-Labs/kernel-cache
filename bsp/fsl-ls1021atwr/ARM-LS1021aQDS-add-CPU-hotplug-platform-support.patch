From 529a4c67523c08fe40d16c23b82e7100a7deb423 Mon Sep 17 00:00:00 2001
From: Zhang Zhuoyu <Zhuoyu.Zhang@freescale.com>
Date: Tue, 21 Oct 2014 15:11:40 +0800
Subject: [PATCH 08/13] ARM:LS1021aQDS: add CPU hotplug platform support

This is only a CPU pseudo-hotplug, and incompatible with kexec mechanics.
As per the discussion with Russell King in opensource community, CPU hotplug
should reset the secondary core to be compatible with kexec.

"In the kexec case, when the secondary CPU wakeup, the code it is executing
can already been overwritten, which then means that the CPU ends up executing
some random code instead."

For LS102x platforms, resetting core can be realized, but come across cache
coherence problem which is still unresolved, we will submit another patch to
implement CPU hotplug by resetting core once cache coherence issue resloved.

Signed-off-by: Zhang Zhuoyu <Zhuoyu.Zhang@freescale.com>
[Xulin: Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>

(cherry picked from commit e02790ccef61e72cd84c64016c9ce0b0697f2251)
---
 arch/arm/mach-imx/common.h  |    4 +++
 arch/arm/mach-imx/hotplug.c |   57 +++++++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-imx/platsmp.c |    4 +++
 arch/arm/mach-imx/src.c     |   21 ++++++++++++++++
 4 files changed, 86 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index 3570ad0..b729477 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -92,6 +92,7 @@ void imx_print_silicon_rev(const char *cpu, int srev);
 void imx_enable_cpu(int cpu, bool enable);
 void imx_set_cpu_jump(int cpu, void *jump_addr);
 u32 imx_get_cpu_arg(int cpu);
+u32 ls1_get_cpu_arg(int cpu);
 void imx_set_cpu_arg(int cpu, u32 arg);
 #ifdef CONFIG_SMP
 void v7_secondary_startup(void);
@@ -119,6 +120,9 @@ int imx_mmdc_get_ddr_type(void);
 void imx_cpu_die(unsigned int cpu);
 int imx_cpu_kill(unsigned int cpu);
 
+void ls1021a_cpu_die(unsigned int cpu);
+int ls1021a_cpu_kill(unsigned int cpu);
+
 #ifdef CONFIG_SUSPEND
 void v7_cpu_resume(void);
 void imx6_suspend(void __iomem *ocram_vbase);
diff --git a/arch/arm/mach-imx/hotplug.c b/arch/arm/mach-imx/hotplug.c
index b35e99c..8500817 100644
--- a/arch/arm/mach-imx/hotplug.c
+++ b/arch/arm/mach-imx/hotplug.c
@@ -14,6 +14,9 @@
 #include <linux/jiffies.h>
 #include <asm/cp15.h>
 #include <asm/proc-fns.h>
+#include<asm/smp.h>
+#include<asm/smp_plat.h>
+#include<asm/cacheflush.h>
 
 #include "common.h"
 
@@ -38,6 +41,22 @@ static inline void cpu_enter_lowpower(void)
 	  : "cc");
 }
 
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile(
+	"	mrc     p15, 0, %0, c1, c0, 0\n"
+	"       orr     %0, %0, %1\n"
+	"       mcr     p15, 0, %0, c1, c0, 0\n"
+	"       mrc     p15, 0, %0, c1, c0, 1\n"
+	"       orr     %0, %0, %2\n"
+	"       mcr     p15, 0, %0, c1, c0, 1\n"
+	  : "=&r" (v)
+	  : "Ir" (CR_C), "Ir" (0x40)
+	  : "cc");
+}
+
 /*
  * platform-specific code to shutdown a CPU
  *
@@ -68,3 +87,41 @@ int imx_cpu_kill(unsigned int cpu)
 	imx_set_cpu_arg(cpu, 0);
 	return 1;
 }
+
+/*
+ * For LS102x platforms, shutdowning a CPU is not supported by hardware.
+ * So we just put the offline CPU into lower-power state here.
+ */
+void __ref ls1021a_cpu_die(unsigned int cpu)
+{
+	v7_exit_coherency_flush(louis);
+
+	/*we are ready to enter lower-power state*/
+	wfi();
+	/*
+	 * bring this CPU back into the world of cache
+	 * coherency, and then restore interrupts
+	 */
+	cpu_leave_lowpower();
+
+	/*
+	 * Do not return to the idle loop - jump back to the secondary
+	 * cpu initialisation.  There's some initialisation which needs
+	 * to be repeated to undo the effects of taking the CPU offline.
+	 */
+	__asm__("mov    sp, %0\n"
+	"       mov     fp, #0\n"
+	"       b       secondary_startup"
+		:
+		: "r" (task_stack_page(current) + THREAD_SIZE - 8));
+}
+
+int ls1021a_cpu_kill(unsigned int cpu)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(50);
+
+	while (!ls1_get_cpu_arg(cpu))
+		if (time_after(jiffies, timeout))
+			return 0;
+	return 1;
+}
diff --git a/arch/arm/mach-imx/platsmp.c b/arch/arm/mach-imx/platsmp.c
index cfac6de..4fc75c4 100644
--- a/arch/arm/mach-imx/platsmp.c
+++ b/arch/arm/mach-imx/platsmp.c
@@ -129,6 +129,10 @@ static void __init ls1021a_smp_prepare_cpus(unsigned int max_cpus)
 struct smp_operations  ls1021a_smp_ops __initdata = {
 	.smp_prepare_cpus	= ls1021a_smp_prepare_cpus,
 	.smp_boot_secondary	= ls1021a_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die                = ls1021a_cpu_die,
+	.cpu_kill               = ls1021a_cpu_kill,
+#endif
 };
 
 static int layerscape_smp_boot_secondary(unsigned int cpu,
diff --git a/arch/arm/mach-imx/src.c b/arch/arm/mach-imx/src.c
index 45f7f4e..1642bcf 100644
--- a/arch/arm/mach-imx/src.c
+++ b/arch/arm/mach-imx/src.c
@@ -30,6 +30,8 @@
 #define BP_SRC_SCR_CORE1_RST		14
 #define BP_SRC_SCR_CORE1_ENABLE		22
 
+#define CCSR_TWAITSR0         0x04C
+
 static void __iomem *src_base;
 static DEFINE_SPINLOCK(scr_lock);
 
@@ -115,6 +117,25 @@ void imx_set_cpu_arg(int cpu, u32 arg)
 	writel_relaxed(arg, src_base + SRC_GPR1 + cpu * 8 + 4);
 }
 
+u32 ls1_get_cpu_arg(int cpu)
+{
+       struct device_node *np;
+       void __iomem *ls1_rcpm_base;
+
+       np = of_find_compatible_node(NULL, NULL, "fsl,qoriq-rcpm-2.1");
+       if (!np) {
+               pr_err("%s(): Can not find the RCPM node.\n", __func__);
+               return -ENODEV;
+       }
+
+       ls1_rcpm_base = of_iomap(np, 0);
+       of_node_put(np);
+       WARN_ON(!ls1_rcpm_base);
+
+       cpu = cpu_logical_map(cpu);
+       return ioread32be(ls1_rcpm_base + CCSR_TWAITSR0) & (1 << cpu);
+}
+
 void __init imx_src_init(void)
 {
 	struct device_node *np;
-- 
1.7.5.4

