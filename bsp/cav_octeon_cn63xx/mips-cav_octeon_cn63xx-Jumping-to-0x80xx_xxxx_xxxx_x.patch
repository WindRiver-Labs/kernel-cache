From e504d1cea767a9c58ea0dc9bca9ccd510c0c6c2a Mon Sep 17 00:00:00 2001
From: Jin Yanjiang <yanjiang.jin@windriver.com>
Date: Wed, 14 Sep 2011 17:05:45 +0800
Subject: [PATCH] mips/cav_octeon_cn63xx: Jumping to 0x80xx_xxxx_xxxx_xxxx when KEXEC/KDUMP

When KEXEC/KDUMP, the 1st kernel would relocate some code segments
and then jump to them, which address is 0xa8xx_xxxx_xxxx_xxxx. That
works well for OCTEON and OCTEON plus (CN58XX/CN38XX, CN56XX/CN57XX),
while for OCTEON2 CN63XX the relocated codes couldn't be executed.
By debugging, I found that after relocating the codes to
0xa8xx_xxxx_xxxx_xxxx, jumping to 0x80xx_xxxx_xxxx_xxxx can fix this
issue. That 2 addresses are directly mapped to the same physical
address(don't pass the TLB).

Signed-off-by: Tian Le <le.tian@windriver.com>
Integrated-by: Jin Yanjiang <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/kexec.h      |    5 +++++
 arch/mips/kernel/machine_kexec.c   |    5 +++--
 arch/mips/kernel/relocate_kernel.S |    7 +++++++
 3 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/arch/mips/include/asm/kexec.h b/arch/mips/include/asm/kexec.h
index 54302d4..addcb9d 100644
--- a/arch/mips/include/asm/kexec.h
+++ b/arch/mips/include/asm/kexec.h
@@ -39,6 +39,11 @@ extern int (*_machine_kexec_prepare)(struct kimage *);
 extern void (*_machine_kexec_shutdown)(void);
 extern void (*_machine_crash_shutdown)(struct pt_regs *regs);
 extern void default_machine_crash_shutdown(struct pt_regs *regs);
+#ifdef CONFIG_CAVIUM_OCTEON2
+#define OCTEON_KEXEC_OFFSET    (0x2800000000000000)
+#else
+#define OCTEON_KEXEC_OFFSET    (0)
+#endif
 #ifdef CONFIG_SMP
 extern const unsigned char kexec_smp_wait[];
 extern unsigned long secondary_kexec_args[4];
diff --git a/arch/mips/kernel/machine_kexec.c b/arch/mips/kernel/machine_kexec.c
index cbdb9be..3a2d322 100644
--- a/arch/mips/kernel/machine_kexec.c
+++ b/arch/mips/kernel/machine_kexec.c
@@ -63,7 +63,8 @@ static void default_machine_smp_handle_restart(unsigned long reloc)
 {
 	/* All secondary cpus now may jump to kexec_wait cycle */
 	relocated_kexec_smp_wait =
-		(void *)(reloc + (kexec_smp_wait - relocate_new_kernel));
+		(void *)(reloc + (kexec_smp_wait - relocate_new_kernel)
+			- OCTEON_KEXEC_OFFSET);
 	smp_wmb();
 	atomic_set(&kexec_ready_to_reboot, 1);
 }
@@ -136,7 +137,7 @@ machine_kexec(struct kimage *image)
 		default_machine_smp_handle_restart(reboot_code_buffer);
 	}
 
-	((noretfun_t) reboot_code_buffer)();
+	((noretfun_t) (reboot_code_buffer - OCTEON_KEXEC_OFFSET))();
 }
 
 /*
diff --git a/arch/mips/kernel/relocate_kernel.S b/arch/mips/kernel/relocate_kernel.S
index 4324671..b409c62 100644
--- a/arch/mips/kernel/relocate_kernel.S
+++ b/arch/mips/kernel/relocate_kernel.S
@@ -14,6 +14,11 @@
 #include <asm/stackframe.h>
 #include <asm/addrspace.h>
 
+#ifdef CONFIG_CAVIUM_OCTEON2
+#define OCTEON_KEXEC_OFFSET    (0x2800000000000000)
+#else
+#define OCTEON_KEXEC_OFFSET    (0)
+#endif
 
 LEAF(relocate_new_kernel)
      PTR_L a0,    arg0
@@ -23,6 +28,7 @@ LEAF(relocate_new_kernel)
 
 	PTR_LA		s0, kexec_indirection_page
 	PTR_L		s1, kexec_start_address
+	LONG_SUB	s1, OCTEON_KEXEC_OFFSET
 
 process_entry:
 	PTR_L		s2, (s0)
@@ -130,6 +136,7 @@ LEAF(kexec_smp_wait)
     PTR_L        a2, s_arg2
     PTR_L        a3, s_arg3
     PTR_L        s1, kexec_start_address
+    LONG_SUB     s1, OCTEON_KEXEC_OFFSET
 
     /* Non-relocated address works for args and kexec_start_address ( old
      * kernel is not overwritten). But we need relocated address of
-- 
1.7.0.4

