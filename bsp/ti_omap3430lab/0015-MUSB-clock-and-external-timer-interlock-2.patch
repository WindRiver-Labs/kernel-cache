From b39dc47a311071adb352c32614e57e765d35663e Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Mon, 11 May 2009 22:06:18 +0800
Subject: [PATCH] MUSB clock and external timer interlock-2

commit ed039b969ac7c0f8fecbf1c1d72aab32e3b07d2a from
git://git.omapzoom.org/repo/omapkernel.git

This patch creates an interlock between the MUSB clock and an
external timer.  Prior to this patch, when the external timer
fired while MSUB was suspended, the musb_do_idle() routine would
crash on the first register access.

Signed-off-by: radzy <radzy@windriver.com>
[stanley: remove the procfs part because it doesn't apply wrlinux tree]
Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/usb/musb/musb_core.c |   14 +++++++++++++-
 drivers/usb/musb/musb_core.h |    3 +++
 drivers/usb/musb/omap2430.c  |   17 +++++++++++++++--
 3 files changed, 31 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 5c5bc1a..4d56812 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -956,6 +956,14 @@ static void musb_shutdown(struct platform_device *pdev)
 	struct musb	*musb = dev_to_musb(&pdev->dev);
 	unsigned long	flags;
 
+	if (musb->clk_suspend) {
+		if (musb->set_clock)
+			musb->set_clock(musb->clock, 1);
+		else
+			clk_enable(musb->clock);
+		musb->clk_suspend = 0;
+	}
+
 	spin_lock_irqsave(&musb->lock, flags);
 	musb_platform_disable(musb);
 	musb_generic_disable(musb);
@@ -965,7 +973,11 @@ static void musb_shutdown(struct platform_device *pdev)
 	}
 	spin_unlock_irqrestore(&musb->lock, flags);
 
-	/* FIXME power down */
+	/* power down */
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 0);
+	else
+		clk_disable(musb->clock);
 }
 
 
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 8222725..0654fbd 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -386,6 +386,9 @@ struct musb {
 	unsigned is_multipoint:1;
 	unsigned ignore_disconnect:1;	/* during bus resets */
 
+	/* clk_suspend means the clock is suspended */
+	unsigned		clk_suspend:1;
+
 #ifdef C_MP_TX
 	unsigned bulk_split:1;
 #define	can_bulk_split(musb,type) \
diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index be4e779..6de83b6 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -56,10 +56,19 @@ static void musb_do_idle(unsigned long _musb)
 	u8	power;
 	u8	devctl;
 
-	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-
 	spin_lock_irqsave(&musb->lock, flags);
 
+	/*
+	 * If the asynch timer fires when the device is
+	 * idle, we do nothing.
+	 */
+	if (musb->clk_suspend) {
+		spin_unlock_irqrestore(&musb->lock, flags);
+		return;
+	}
+
+	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+
 	switch (musb->xceiv.state) {
 	case OTG_STATE_A_WAIT_BCON:
 		devctl &= ~MUSB_DEVCTL_SESSION;
@@ -277,6 +286,8 @@ int musb_platform_suspend(struct musb *musb)
 	if (musb->xceiv.set_suspend)
 		musb->xceiv.set_suspend(&musb->xceiv, 1);
 
+	musb->clk_suspend = 1;
+
 	if (musb->set_clock)
 		musb->set_clock(musb->clock, 0);
 	else
@@ -300,6 +311,8 @@ static int musb_platform_resume(struct musb *musb)
 	else
 		clk_enable(musb->clock);
 
+	musb->clk_suspend = 0;
+
 	l = omap_readl(OTG_SYSCONFIG);
 	l &= ~ENABLEWAKEUP;	/* disable wakeup */
 	omap_writel(l, OTG_SYSCONFIG);
-- 
1.6.0.4

