From 4d9f7a71616cf3dc3696c78081dae42f79e0c413 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Mon, 11 May 2009 22:06:21 +0800
Subject: [PATCH] Fix omap usb hotplug problem

When a usb device is hotplugged in host mode, it can't be
recognized. The resolution is
1, Wakeup usb otg controller before wakeup twl4030 usb phy when a usb
   device is hotplugged in.
2, Restore usb otg controller's FIFO registers.
3, Set usb controller to A-device(host) when wake it up.

Some of this change was extracted from
commit dbae0a70 and commit 1b4154dc
of git://git.omapzoom.org/repo/omapkernel.git -- the parent
commit contained additional cleanups and changes that weren't
relevant to fixing the USB hot insertion/removal problem
being addressed here and so were dropped.

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/i2c/chips/twl4030-usb.c |   22 +++++
 drivers/usb/musb/Kconfig        |    2 +-
 drivers/usb/musb/musb_core.c    |   21 +++---
 drivers/usb/musb/musb_core.h    |    4 +
 drivers/usb/musb/omap2430.c     |  167 ++++++++++++++++++++++++++++++++++++---
 include/linux/i2c/twl4030.h     |    4 +
 6 files changed, 196 insertions(+), 24 deletions(-)

diff --git a/drivers/i2c/chips/twl4030-usb.c b/drivers/i2c/chips/twl4030-usb.c
index 3267191..49eb932 100644
--- a/drivers/i2c/chips/twl4030-usb.c
+++ b/drivers/i2c/chips/twl4030-usb.c
@@ -215,6 +215,9 @@
 
 /* In module TWL4030_MODULE_PM_MASTER */
 #define PROTECT_KEY			0x0E
+#define REG_STS_HW_CONDITIONS		0x0F
+#define STS_VBUS			(1 << 7)
+#define STS_USB				(1 << 2)
 
 /* In module TWL4030_MODULE_PM_RECEIVER */
 #define VUSB_DEDICATED1			0x7D
@@ -322,6 +325,8 @@ static inline int twl4030_usb_read(struct twl4030_usb *twl, u8 address)
 	return twl4030_readb(twl, TWL4030_MODULE_USB, address);
 }
 
+struct twl4030_usb *t2_transceiver;
+EXPORT_SYMBOL(t2_transceiver);
 /*-------------------------------------------------------------------------*/
 
 static inline int
@@ -456,6 +461,10 @@ static void twl4030_phy_resume(struct twl4030_usb *twl)
 	if (!twl->asleep)
 		return;
 
+	/* Restore context of MUSB from OFF mode */
+	if (t2_transceiver->link_context_restore_and_wakeup)
+		t2_transceiver->link_context_restore_and_wakeup();
+
 	twl4030_phy_power(twl, 1);
 	twl4030_i2c_access(twl, 1);
 	twl4030_usb_set_mode(twl, twl->usb_mode);
@@ -621,6 +630,17 @@ static int twl4030_set_host(struct otg_transceiver *x, struct usb_bus *host)
 	return 0;
 }
 
+int twl4030_usb_device_connected(void)
+{
+	u8 val;
+
+	/* check if USB connection is present */
+	twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &val,
+				REG_STS_HW_CONDITIONS);
+	return (val & (STS_VBUS | STS_USB));
+}
+EXPORT_SYMBOL(twl4030_usb_device_connected);
+
 static int __init twl4030_usb_probe(struct platform_device *pdev)
 {
 	struct twl4030_usb_data *pdata = pdev->dev.platform_data;
@@ -646,6 +666,8 @@ static int __init twl4030_usb_probe(struct platform_device *pdev)
 	twl->usb_mode		= pdata->usb_mode;
 	twl->asleep		= 1;
 
+	t2_transceiver = twl;
+	t2_transceiver->link_context_restore_and_wakeup = NULL;
 	/* init spinlock for workqueue */
 	spin_lock_init(&twl->lock);
 
diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index 4b9542b..bbfa01f 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -10,7 +10,7 @@ comment "Enable Host or Gadget support to see Inventra options"
 config USB_MUSB_HDRC
 	depends on (USB || USB_GADGET) && HAVE_CLK
 	depends on !SUPERH
-	select TWL4030_USB if MACH_OMAP_3430SDP
+	select TWL4030_USB if (MACH_OMAP_3430SDP || MACH_OMAP_LDP)
 	tristate 'Inventra Highspeed Dual Role Controller (TI, ...)'
 	help
 	  Say Y here if your system has a dual role high speed USB
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 4d56812..535357d 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -98,6 +98,7 @@
 #include <linux/kobject.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/i2c/twl4030.h>
 
 #ifdef	CONFIG_ARM
 #include <mach/hardware.h>
@@ -860,9 +861,9 @@ static irqreturn_t musb_stage2_irq(struct musb *musb, u8 int_usb,
 void musb_start(struct musb *musb)
 {
 	void __iomem	*regs = musb->mregs;
-	u8		devctl = musb_readb(regs, MUSB_DEVCTL);
+	u8		devctl;
 
-	DBG(2, "<== devctl %02x\n", devctl);
+	musb_context_restore_and_wakeup();
 
 	/*  Set INT enable registers, enable interrupts */
 	musb_writew(regs, MUSB_INTRTXE, musb->epmask);
@@ -2066,6 +2067,12 @@ bad_config:
 
 	}
 
+	/* Save Context of MUSB to recover from OFF mode */
+	musb_context_store_and_suspend(musb, 0);
+
+	/* Install MUSB context function in T2 driver */
+	t2_transceiver->link_context_restore_and_wakeup =
+			musb_context_restore_and_wakeup;
 	return 0;
 
 fail:
@@ -2171,10 +2178,7 @@ static int musb_suspend(struct platform_device *pdev, pm_message_t message)
 		 */
 	}
 
-	if (musb->set_clock)
-		musb->set_clock(musb->clock, 0);
-	else
-		clk_disable(musb->clock);
+	musb_context_store_and_suspend(musb, 1);
 	spin_unlock_irqrestore(&musb->lock, flags);
 	return 0;
 }
@@ -2189,10 +2193,7 @@ static int musb_resume(struct platform_device *pdev)
 
 	spin_lock_irqsave(&musb->lock, flags);
 
-	if (musb->set_clock)
-		musb->set_clock(musb->clock, 1);
-	else
-		clk_enable(musb->clock);
+	musb_context_restore_and_wakeup();
 
 	/* for static cmos like DaVinci, register values were preserved
 	 * unless for some reason the whole soc powered down and we're
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 0654fbd..2e4a714 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -101,6 +101,8 @@ struct musb_ep;
 #define MUSB_CONFIG_PROC_FS
 #endif
 
+extern int musb_context_store_and_suspend(struct musb *musb, int overwrite);
+extern void musb_context_restore_and_wakeup(void);
 /****************************** PERIPHERAL ROLE *****************************/
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
@@ -467,6 +469,8 @@ extern irqreturn_t musb_interrupt(struct musb *);
 
 extern void musb_platform_enable(struct musb *musb);
 extern void musb_platform_disable(struct musb *musb);
+extern int musb_platform_resume(struct musb *musb);
+extern int musb_platform_suspend(struct musb *musb);
 
 extern void musb_hnp_stop(struct musb *musb);
 
diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index ed461cf..d2d733b 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -33,6 +33,7 @@
 #include <linux/list.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/i2c/twl4030.h>
 
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
@@ -82,6 +83,8 @@ static void musb_do_idle(unsigned long _musb)
 			musb->xceiv.state = OTG_STATE_A_IDLE;
 			MUSB_HST_MODE(musb);
 		}
+		/* Keep MUSB suspended on Cable Detach */
+		musb_platform_suspend(musb);
 		break;
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	case OTG_STATE_A_SUSPEND:
@@ -228,7 +231,6 @@ static int omap_set_power(struct otg_transceiver *x, unsigned mA)
 	return 0;
 }
 
-static int musb_platform_resume(struct musb *musb);
 
 void musb_platform_set_mode(struct musb *musb, u8 musb_mode)
 {
@@ -301,9 +303,6 @@ int musb_platform_suspend(struct musb *musb)
 
 	musb_platform_force_idle(musb);
 
-	if (musb->xceiv.set_suspend)
-		musb->xceiv.set_suspend(&musb->xceiv, 1);
-
 	musb->clk_suspend = 1;
 
 	if (musb->set_clock)
@@ -314,16 +313,13 @@ int musb_platform_suspend(struct musb *musb)
 	return 0;
 }
 
-static int musb_platform_resume(struct musb *musb)
+int musb_platform_resume(struct musb *musb)
 {
 	u32 l;
 
 	if (!musb->clock)
 		return 0;
 
-	if (musb->xceiv.set_suspend)
-		musb->xceiv.set_suspend(&musb->xceiv, 0);
-
 	if (musb->set_clock)
 		musb->set_clock(musb->clock, 1);
 	else
@@ -331,25 +327,33 @@ static int musb_platform_resume(struct musb *musb)
 
 	musb->clk_suspend = 0;
 
-	l = omap_readl(OTG_SYSCONFIG);
-	l &= ~ENABLEWAKEUP;	/* disable wakeup */
-	omap_writel(l, OTG_SYSCONFIG);
-
 	l = omap_readl(OTG_FORCESTDBY);
 	l &= ~ENABLEFORCE;	/* disable MSTANDBY */
 	omap_writel(l, OTG_FORCESTDBY);
 
+	l = omap_readl(OTG_SYSCONFIG);
+	l |= SMARTSTDBY;        /* enable smart standby */
+	l &= ~AUTOIDLE;         /* disable auto idle */
+	omap_writel(l, OTG_SYSCONFIG);
+	l |= SMARTIDLE;
+	omap_writel(l, OTG_SYSCONFIG);
+	l |= AUTOIDLE;          /* enable auto idle */
+	omap_writel(l, OTG_SYSCONFIG);
+
 	return 0;
 }
 
 
 int musb_platform_exit(struct musb *musb)
 {
-
+	u32 l;
 	omap_vbus_power(musb, 0 /*off*/, 1);
 
 	musb_platform_suspend(musb);
 
+	l = omap_readl(OTG_SYSCONFIG);
+	l &= ~ENABLEWAKEUP; /* Disable Wakeup */
+	omap_writel(l, OTG_SYSCONFIG);
 	musb_platform_force_idle(musb);
 
 	clk_put(musb->clock);
@@ -357,3 +361,140 @@ int musb_platform_exit(struct musb *musb)
 
 	return 0;
 }
+
+struct musb_index_regs{
+	/* FIFO registers */
+	u8	rxfifosz;
+	u8	txfifosz;
+	u16	txfifoadd;
+	u16	rxfifoadd;
+};
+
+struct musb_context{
+	/* MUSB init context */
+	struct musb_index_regs 	index_regs[MUSB_C_NUM_EPS];
+};
+
+/* Global: MUSB Context data pointer */
+static struct musb_context *context_ptr = NULL;
+static struct musb *musb_ptr = NULL;
+static bool do_cold_plugging = 0;
+
+/* Context Save/Restore for OFF mode */
+int musb_context_store_and_suspend(struct musb *musb, int overwrite)
+{
+	u8 i;
+	u32 l;
+	DBG(1, "MUSB-Context-SAVE (Off mode support)\n");
+
+	/* Save MUSB Context only once */
+	if (!context_ptr || overwrite) {
+		if (!context_ptr) {
+			context_ptr = kzalloc(sizeof(struct musb_context),
+								GFP_KERNEL);
+			if (!context_ptr)
+				return -ENOMEM;
+		}
+
+		/* Save musb ptr */
+		musb_ptr = musb;
+
+		/* Save FIFO setup details */
+		for (i = 0; i < MUSB_C_NUM_EPS; i++) {
+			musb_writeb(musb_ptr->mregs, MUSB_INDEX, i);
+			context_ptr->index_regs[i].rxfifosz = musb_readb(musb_ptr->mregs, MUSB_RXFIFOSZ);
+			context_ptr->index_regs[i].txfifosz = musb_readb(musb_ptr->mregs, MUSB_TXFIFOSZ);
+			context_ptr->index_regs[i].txfifoadd = musb_readw(musb_ptr->mregs, MUSB_TXFIFOADD);
+			context_ptr->index_regs[i].rxfifoadd = musb_readw(musb_ptr->mregs, MUSB_RXFIFOADD);
+
+			DBG(3, "EP(%d) rxfifosz(%x) txfifosz(%x) "
+				"txfifoaddr(%x) rxfifoadd(%x)\n",
+					i,
+					context_ptr->index_regs[i].rxfifosz,
+					context_ptr->index_regs[i].txfifosz,
+					context_ptr->index_regs[i].txfifoadd,
+					context_ptr->index_regs[i].rxfifoadd);
+		}
+		DBG(1, "MUSB Context: FIFO END\n");
+	}
+
+	/* Keep system suspended and wakeup through T2 pres INT
+	 * For cold plugging case: do not suspend controller
+	 * If device is connected, do not suspend
+	 */
+
+	if (do_cold_plugging) {
+		do_cold_plugging = 0; /* For once only */
+	} else if (!twl4030_usb_device_connected()) {
+		/* Reset the controller and keep in default state on power-up */
+		l = omap_readl(OTG_SYSCONFIG);
+		l |= SOFTRST;
+		omap_writel(l, OTG_SYSCONFIG);
+
+		/* Keep USB suspended till cable is attached */
+		musb_platform_suspend(musb_ptr);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(musb_context_store_and_suspend);
+
+void musb_context_restore_and_wakeup(void)
+{
+	u8 i;
+	u32 l;
+
+	if (!context_ptr) {
+		/* T2 called us as a device was found connected */
+		/* Its cold plugging, so remember the state when MUSB is up */
+		do_cold_plugging = 1;
+		return;
+	}
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	if ((is_otg_enabled(musb_ptr) || is_peripheral_enabled(musb_ptr)) &&
+			(musb_ptr->gadget_driver == NULL)) {
+		/* The gadget driver is not yet loaded. Treat this as a case
+		 * of cold_plugging
+		 */
+		do_cold_plugging = 1;
+		return;
+	}
+#endif
+
+	DBG(1, "MUSB Restore Context: Start\n");
+
+	/* Ensure that I-CLK is on after OFF mode */
+	musb_platform_resume(musb_ptr);
+
+	/* Set System specific registers
+	 * Init controller
+	 */
+	l = omap_readl(OTG_SYSCONFIG);
+	l |= ENABLEWAKEUP;
+	omap_writel(l, OTG_SYSCONFIG);
+
+	l = omap_readl(OTG_INTERFSEL);
+	l |= ULPI_12PIN;
+	omap_writel(l, OTG_INTERFSEL);
+
+	musb_writew(musb_ptr->mregs, MUSB_DEVCTL,
+			MUSB_DEVCTL_VBUS | MUSB_DEVCTL_SESSION);
+
+	/* Restore: FIFO setup details */
+	for (i = 0; i < MUSB_C_NUM_EPS; i++) {
+		musb_writeb(musb_ptr->mregs, MUSB_INDEX, i);
+		musb_writeb(musb_ptr->mregs, MUSB_RXFIFOSZ,
+					context_ptr->index_regs[i].rxfifosz);
+		musb_writeb(musb_ptr->mregs, MUSB_TXFIFOSZ,
+					context_ptr->index_regs[i].txfifosz);
+		musb_writew(musb_ptr->mregs, MUSB_TXFIFOADD,
+					context_ptr->index_regs[i].txfifoadd);
+		musb_writew(musb_ptr->mregs, MUSB_RXFIFOADD,
+					context_ptr->index_regs[i].rxfifoadd);
+	}
+
+	DBG(1, "MUSB Restore Context: Done\n");
+	return;
+}
+EXPORT_SYMBOL(musb_context_restore_and_wakeup);
diff --git a/include/linux/i2c/twl4030.h b/include/linux/i2c/twl4030.h
index 477aa4c..e452f3e 100644
--- a/include/linux/i2c/twl4030.h
+++ b/include/linux/i2c/twl4030.h
@@ -362,6 +362,10 @@ struct twl4030_usb {
 	u8			linkstat;
 	u8			asleep;
 	bool			irq_enabled;
+	void (*link_context_restore_and_wakeup)(void);
 };
 
+extern struct twl4030_usb *t2_transceiver;
+extern int twl4030_usb_device_connected(void);
+
 #endif /* End of __TWL4030_H */
-- 
1.6.0.4

