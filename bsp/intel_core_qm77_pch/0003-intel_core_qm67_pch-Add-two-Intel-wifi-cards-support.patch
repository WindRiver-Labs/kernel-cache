From 49d577adbb4b246aca3ce29c20671545cafcbc4e Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Wed, 16 Nov 2011 10:32:12 +0800
Subject: [PATCH] intel_core_qm67_pch: Add two Intel wifi cards support

iwlwifi: Add the Intel 1030 and 6230 wifi cards support
[based on the mainline v2.6.36]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/wireless/iwlwifi/iwl-5000.c     |    8 +-
 drivers/net/wireless/iwlwifi/iwl-6000.c     |  144 +++++++++++++++++++++++++++
 drivers/net/wireless/iwlwifi/iwl-agn.c      |   33 ++++++-
 drivers/net/wireless/iwlwifi/iwl-commands.h |   99 ++++++++++++++++++
 drivers/net/wireless/iwlwifi/iwl-core.c     |    3 +-
 drivers/net/wireless/iwlwifi/iwl-core.h     |    6 +
 drivers/net/wireless/iwlwifi/iwl-dev.h      |    9 ++
 7 files changed, 295 insertions(+), 7 deletions(-)

diff --git a/drivers/net/wireless/iwlwifi/iwl-5000.c b/drivers/net/wireless/iwlwifi/iwl-5000.c
index c55f2c7..6223e6c 100644
--- a/drivers/net/wireless/iwlwifi/iwl-5000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-5000.c
@@ -1193,7 +1193,7 @@ int iwl5000_hw_valid_rtc_data_addr(u32 addr)
 		(addr < IWL50_RTC_DATA_UPPER_BOUND);
 }
 
-static int iwl5000_send_rxon_assoc(struct iwl_priv *priv)
+int iwl5000_send_rxon_assoc(struct iwl_priv *priv)
 {
 	int ret = 0;
 	struct iwl5000_rxon_assoc_cmd rxon_assoc;
@@ -1239,6 +1239,8 @@ static int iwl5000_send_rxon_assoc(struct iwl_priv *priv)
 
 	return ret;
 }
+EXPORT_SYMBOL(iwl5000_send_rxon_assoc);
+
 int  iwl5000_send_tx_power(struct iwl_priv *priv)
 {
 	struct iwl5000_tx_power_dbm_cmd tx_power_cmd;
@@ -1332,7 +1334,7 @@ int iwl5000_calc_rssi(struct iwl_priv *priv,
 	return max_rssi - agc - IWL49_RSSI_OFFSET;
 }
 
-static int iwl5000_send_tx_ant_config(struct iwl_priv *priv, u8 valid_tx_ant)
+int iwl5000_send_tx_ant_config(struct iwl_priv *priv, u8 valid_tx_ant)
 {
 	struct iwl_tx_ant_config_cmd tx_ant_cmd = {
 	  .valid = cpu_to_le32(valid_tx_ant),
@@ -1348,6 +1350,7 @@ static int iwl5000_send_tx_ant_config(struct iwl_priv *priv, u8 valid_tx_ant)
 		return -EOPNOTSUPP;
 	}
 }
+EXPORT_SYMBOL(iwl5000_send_tx_ant_config);
 
 
 #define IWL5000_UCODE_GET(item)						\
@@ -1425,6 +1428,7 @@ struct iwl_hcmd_ops iwl5000_hcmd = {
 	.commit_rxon = iwl_commit_rxon,
 	.set_rxon_chain = iwl_set_rxon_chain,
 	.set_tx_ant = iwl5000_send_tx_ant_config,
+	.send_bt_config = iwl_send_bt_config,
 };
 
 struct iwl_hcmd_utils_ops iwl5000_hcmd_utils = {
diff --git a/drivers/net/wireless/iwlwifi/iwl-6000.c b/drivers/net/wireless/iwlwifi/iwl-6000.c
index 5afc38d..197b5d2 100644
--- a/drivers/net/wireless/iwlwifi/iwl-6000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-6000.c
@@ -69,6 +69,10 @@
 #define _IWL6000G2A_MODULE_FIRMWARE(api) IWL6000G2A_FW_PRE #api ".ucode"
 #define IWL6000G2A_MODULE_FIRMWARE(api) _IWL6000G2A_MODULE_FIRMWARE(api)
 
+#define IWL6000G2B_FW_PRE "iwlwifi-6000g2b-"
+#define _IWL6000G2B_MODULE_FIRMWARE(api) IWL6000G2B_FW_PRE #api ".ucode"
+#define IWL6000G2B_MODULE_FIRMWARE(api) _IWL6000G2B_MODULE_FIRMWARE(api)
+
 static void iwl6000_set_ct_threshold(struct iwl_priv *priv)
 {
 	/* want Celsius */
@@ -115,6 +119,55 @@ static void iwl6000_nic_config(struct iwl_priv *priv)
 		priv->cfg->ops->lib->temp_ops.set_calib_version(priv);
 }
 
+static const __le32 iwl6000g2b_def_3w_lookup[12] = {
+	cpu_to_le32(0xaaaaaaaa),
+	cpu_to_le32(0xaaaaaaaa),
+	cpu_to_le32(0xaeaaaaaa),
+	cpu_to_le32(0xaaaaaaaa),
+	cpu_to_le32(0xcc00ff28),
+	cpu_to_le32(0x0000aaaa),
+	cpu_to_le32(0xcc00aaaa),
+	cpu_to_le32(0x0000aaaa),
+	cpu_to_le32(0xc0004000),
+	cpu_to_le32(0x00004000),
+	cpu_to_le32(0xf0005000),
+	cpu_to_le32(0xf0004000),
+};
+
+static void iwl6000g2b_send_bt_config(struct iwl_priv *priv)
+{
+	struct iwl6000g2b_bt_cmd bt_cmd = {
+		.prio_boost = IWL6000G2B_BT_PRIO_BOOST_DEFAULT,
+		.max_kill = IWL6000G2B_BT_MAX_KILL_DEFAULT,
+		.bt3_timer_t7_value = IWL6000G2B_BT3_T7_DEFAULT,
+		.kill_ack_mask = IWL6000G2B_BT_KILL_ACK_MASK_DEFAULT,
+		.kill_cts_mask = IWL6000G2B_BT_KILL_CTS_MASK_DEFAULT,
+		.bt3_prio_sample_time = IWL6000G2B_BT3_PRIO_SAMPLE_DEFAULT,
+		.bt3_timer_t2_value = IWL6000G2B_BT3_T2_DEFAULT,
+		.valid = IWL6000G2B_BT_VALID_ENABLE_FLAGS,
+	};
+
+	BUILD_BUG_ON(sizeof(iwl6000g2b_def_3w_lookup) !=
+			sizeof(bt_cmd.bt3_lookup_table));
+
+	if (!bt_coex_active) {
+		bt_cmd.flags = 0;
+	} else {
+		bt_cmd.flags = IWL6000G2B_BT_FLAG_CHANNEL_INHIBITION |
+		IWL6000G2B_BT_FLAG_COEX_MODE_3W <<
+		IWL6000G2B_BT_FLAG_COEX_MODE_SHIFT;
+		bt_cmd.valid |= IWL6000G2B_BT_ALL_VALID_MSK;
+	}
+
+	memcpy(bt_cmd.bt3_lookup_table, iwl6000g2b_def_3w_lookup,
+		sizeof(iwl6000g2b_def_3w_lookup));
+
+	IWL_DEBUG_INFO(priv, "BT coex %s\n",
+			bt_cmd.flags ? "active" : "disabled");
+	if (iwl_send_cmd_pdu(priv, REPLY_BT_CONFIG, sizeof(bt_cmd), &bt_cmd))
+		IWL_ERR(priv, "failed to send BT Coex Config\n");
+}
+
 static struct iwl_sensitivity_ranges iwl6000_sensitivity = {
 	.min_nrg_cck = 97,
 	.max_nrg_cck = 0, /* not used, set to 0 */
@@ -299,6 +352,22 @@ static const struct iwl_ops iwl6000_ops = {
 	.led = &iwlagn_led_ops,
 };
 
+static struct iwl_hcmd_ops iwl6000g2b_hcmd = {
+	.rxon_assoc = iwl5000_send_rxon_assoc,
+	.commit_rxon = iwl_commit_rxon,
+	.set_rxon_chain = iwl_set_rxon_chain,
+	.set_tx_ant = iwl5000_send_tx_ant_config,
+	.send_bt_config = iwl6000g2b_send_bt_config,
+};
+
+static const struct iwl_ops iwl6000g2b_ops = {
+	.ucode = &iwl5000_ucode,
+	.lib = &iwl6000_lib,
+	.hcmd = &iwl6000g2b_hcmd,
+	.utils = &iwl5000_hcmd_utils,
+	.led = &iwlagn_led_ops,
+};
+
 struct iwl_cfg iwl6000g2a_2agn_cfg = {
 	.name = "6000 Series 2x2 AGN Gen2a",
 	.fw_name_pre = IWL6000G2A_FW_PRE,
@@ -403,6 +472,80 @@ struct iwl_cfg iwl6000i_2abg_cfg = {
 	.monitor_recover_period = IWL_MONITORING_PERIOD,
 };
 
+struct iwl_cfg iwl6000g2b_2agn_cfg = {
+	.name = "6000 Series 2x2 AGN Gen2b",
+	.fw_name_pre = IWL6000G2B_FW_PRE,
+	.ucode_api_max = IWL6000G2_UCODE_API_MAX,
+	.ucode_api_min = IWL6000G2_UCODE_API_MIN,
+	.sku = IWL_SKU_A|IWL_SKU_G|IWL_SKU_N,
+	.ops = &iwl6000g2b_ops,
+	.eeprom_size = OTP_LOW_IMAGE_SIZE,
+	.eeprom_ver = EEPROM_6000G2_EEPROM_VERSION,
+	.eeprom_calib_ver = EEPROM_6000G2_TX_POWER_VERSION,
+	.num_of_queues = IWL50_NUM_QUEUES,
+	.num_of_ampdu_queues = IWL50_NUM_AMPDU_QUEUES,
+	.mod_params = &iwl50_mod_params,
+	.valid_tx_ant = ANT_AB,
+	.valid_rx_ant = ANT_AB,
+	.pll_cfg_val = 0,
+	.set_l0s = true,
+	.use_bsm = false,
+	.pa_type = IWL_PA_SYSTEM,
+	.max_ll_items = OTP_MAX_LL_ITEMS_6x00,
+	.shadow_ram_support = true,
+	.ht_greenfield_support = true,
+	.led_compensation = 51,
+	.use_rts_for_ht = true, /* use rts/cts protection */
+	.chain_noise_num_beacons = IWL_CAL_NUM_BEACONS,
+	.supports_idle = true,
+	.adv_thermal_throttle = true,
+	.support_ct_kill_exit = true,
+	.plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
+	.chain_noise_scale = 1000,
+	.monitor_recover_period = IWL_LONG_MONITORING_PERIOD,
+	.need_dc_calib = true,
+	.bt_statistics = true,
+	/* Due to bluetooth, we transmit 2.4 GHz probes only on antenna A */
+	.advanced_bt_coexist = true,
+};
+
+struct iwl_cfg iwl6000g2b_bgn_cfg = {
+	.name = "6000 Series 1x2 BGN Gen2b",
+	.fw_name_pre = IWL6000G2B_FW_PRE,
+	.ucode_api_max = IWL6000G2_UCODE_API_MAX,
+	.ucode_api_min = IWL6000G2_UCODE_API_MIN,
+	.sku = IWL_SKU_G|IWL_SKU_N,
+	.ops = &iwl6000g2b_ops,
+	.eeprom_size = OTP_LOW_IMAGE_SIZE,
+	.eeprom_ver = EEPROM_6000G2_EEPROM_VERSION,
+	.eeprom_calib_ver = EEPROM_6000G2_TX_POWER_VERSION,
+	.num_of_queues = IWL50_NUM_QUEUES,
+	.num_of_ampdu_queues = IWL50_NUM_AMPDU_QUEUES,
+	.mod_params = &iwl50_mod_params,
+	.valid_tx_ant = ANT_A,
+	.valid_rx_ant = ANT_AB,
+	.pll_cfg_val = 0,
+	.set_l0s = true,
+	.use_bsm = false,
+	.pa_type = IWL_PA_SYSTEM,
+	.max_ll_items = OTP_MAX_LL_ITEMS_6x00,
+	.shadow_ram_support = true,
+	.ht_greenfield_support = true,
+	.led_compensation = 51,
+	.use_rts_for_ht = true, /* use rts/cts protection */
+	.chain_noise_num_beacons = IWL_CAL_NUM_BEACONS,
+	.supports_idle = true,
+	.adv_thermal_throttle = true,
+	.support_ct_kill_exit = true,
+	.plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
+	.chain_noise_scale = 1000,
+	.monitor_recover_period = IWL_MONITORING_PERIOD,
+	.need_dc_calib = true,
+	.bt_statistics = true,
+	/* Due to bluetooth, we transmit 2.4 GHz probes only on antenna A */
+	.advanced_bt_coexist = true,
+};
+
 struct iwl_cfg iwl6000i_2bg_cfg = {
 	.name = "6000 Series 2x2 BG",
 	.fw_name_pre = IWL6000_FW_PRE,
@@ -540,3 +683,4 @@ struct iwl_cfg iwl6000_3agn_cfg = {
 MODULE_FIRMWARE(IWL6000_MODULE_FIRMWARE(IWL6000_UCODE_API_MAX));
 MODULE_FIRMWARE(IWL6050_MODULE_FIRMWARE(IWL6050_UCODE_API_MAX));
 MODULE_FIRMWARE(IWL6000G2A_MODULE_FIRMWARE(IWL6000G2_UCODE_API_MAX));
+MODULE_FIRMWARE(IWL6000G2B_MODULE_FIRMWARE(IWL6000G2_UCODE_API_MAX));
diff --git a/drivers/net/wireless/iwlwifi/iwl-agn.c b/drivers/net/wireless/iwlwifi/iwl-agn.c
index a39c3bf..a89cdb2 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn.c
@@ -2369,7 +2369,7 @@ static void iwl_alive_start(struct iwl_priv *priv)
 	}
 
 	/* Configure Bluetooth device coexistence support */
-	iwl_send_bt_config(priv);
+	priv->cfg->ops->hcmd->send_bt_config(priv);
 
 	iwl_reset_run_time_calib(priv);
 
@@ -2695,9 +2695,17 @@ static void iwl_bg_run_time_calib_work(struct work_struct *work)
 	}
 
 	if (priv->start_calib) {
-		iwl_chain_noise_calibration(priv, &priv->statistics);
-
-		iwl_sensitivity_calibration(priv, &priv->statistics);
+		if (priv->cfg->bt_statistics) {
+			iwl_chain_noise_calibration(priv,
+				(void *)&priv->statistics_bt);
+			iwl_sensitivity_calibration(priv,
+				(void *)&priv->statistics_bt);
+		} else {
+			iwl_chain_noise_calibration(priv,
+				(void *)&priv->statistics);
+			iwl_sensitivity_calibration(priv,
+				(void *)&priv->statistics);
+		}
 	}
 
 	mutex_unlock(&priv->mutex);
@@ -4121,6 +4129,23 @@ static DEFINE_PCI_DEVICE_TABLE(iwl_hw_card_ids) = {
 	{IWL_PCI_DEVICE(0x0085, 0x1311, iwl6000g2a_2agn_cfg)},
 	{IWL_PCI_DEVICE(0x0082, 0x1301, iwl6000g2a_2agn_cfg)},
 
+/* 6x00 Series Gen2b */
+	{IWL_PCI_DEVICE(0x008F, 0x5201, iwl6000g2b_2agn_cfg)},
+	{IWL_PCI_DEVICE(0x0090, 0x5211, iwl6000g2b_2agn_cfg)},
+	{IWL_PCI_DEVICE(0x008F, 0x5221, iwl6000g2b_2agn_cfg)},
+	{IWL_PCI_DEVICE(0x0090, 0x5211, iwl6000g2b_2agn_cfg)},
+	{IWL_PCI_DEVICE(0x0091, 0x5201, iwl6000g2b_2agn_cfg)},
+	{IWL_PCI_DEVICE(0x0091, 0x5221, iwl6000g2b_2agn_cfg)},
+	{IWL_PCI_DEVICE(0x008F, 0x5105, iwl6000g2b_bgn_cfg)},
+	{IWL_PCI_DEVICE(0x0090, 0x5115, iwl6000g2b_bgn_cfg)},
+	{IWL_PCI_DEVICE(0x008F, 0x5125, iwl6000g2b_bgn_cfg)},
+	{IWL_PCI_DEVICE(0x008A, 0x5301, iwl6000g2b_bgn_cfg)},
+	{IWL_PCI_DEVICE(0x008A, 0x5305, iwl6000g2b_bgn_cfg)},
+	{IWL_PCI_DEVICE(0x008A, 0x5321, iwl6000g2b_bgn_cfg)},
+	{IWL_PCI_DEVICE(0x008A, 0x5325, iwl6000g2b_bgn_cfg)},
+	{IWL_PCI_DEVICE(0x008B, 0x5311, iwl6000g2b_bgn_cfg)},
+	{IWL_PCI_DEVICE(0x008B, 0x5315, iwl6000g2b_bgn_cfg)},
+
 /* 6x50 WiFi/WiMax Series */
 	{IWL_PCI_DEVICE(0x0087, 0x1301, iwl6050_2agn_cfg)},
 	{IWL_PCI_DEVICE(0x0087, 0x1306, iwl6050_2abg_cfg)},
diff --git a/drivers/net/wireless/iwlwifi/iwl-commands.h b/drivers/net/wireless/iwlwifi/iwl-commands.h
index 846dc75..5fb2f3a 100644
--- a/drivers/net/wireless/iwlwifi/iwl-commands.h
+++ b/drivers/net/wireless/iwlwifi/iwl-commands.h
@@ -2288,6 +2288,52 @@ struct iwl_bt_cmd {
 	__le32 kill_cts_mask;
 } __attribute__ ((packed));
 
+#define IWL6000G2B_BT_FLAG_CHANNEL_INHIBITION   BIT(0)
+#define IWL6000G2B_BT_FLAG_COEX_MODE_SHIFT      3
+#define IWL6000G2B_BT_FLAG_COEX_MODE_3W         2
+#define IWL6000G2B_BT_PRIO_BOOST_DEFAULT        0x00
+#define IWL6000G2B_BT_MAX_KILL_DEFAULT          5
+#define IWL6000G2B_BT3_T7_DEFAULT               1
+#define IWL6000G2B_BT_KILL_ACK_MASK_DEFAULT     cpu_to_le32(0xffffffff)
+#define IWL6000G2B_BT_KILL_CTS_MASK_DEFAULT     cpu_to_le32(0xffffffff)
+#define IWL6000G2B_BT3_PRIO_SAMPLE_DEFAULT      2
+#define IWL6000G2B_BT3_T2_DEFAULT               0xc
+
+#define IWL6000G2B_BT_VALID_ENABLE_FLAGS        cpu_to_le16(BIT(0))
+#define IWL6000G2B_BT_VALID_BOOST               cpu_to_le16(BIT(1))
+#define IWL6000G2B_BT_VALID_MAX_KILL            cpu_to_le16(BIT(2))
+#define IWL6000G2B_BT_VALID_3W_TIMERS           cpu_to_le16(BIT(3))
+#define IWL6000G2B_BT_VALID_KILL_ACK_MASK       cpu_to_le16(BIT(4))
+#define IWL6000G2B_BT_VALID_KILL_CTS_MASK       cpu_to_le16(BIT(5))
+#define IWL6000G2B_BT_VALID_BT4_TIMES           cpu_to_le16(BIT(6))
+#define IWL6000G2B_BT_VALID_3W_LUT              cpu_to_le16(BIT(7))
+
+#define IWL6000G2B_BT_ALL_VALID_MSK     (IWL6000G2B_BT_VALID_ENABLE_FLAGS | \
+					IWL6000G2B_BT_VALID_BOOST | \
+					IWL6000G2B_BT_VALID_MAX_KILL | \
+					IWL6000G2B_BT_VALID_3W_TIMERS | \
+					IWL6000G2B_BT_VALID_KILL_ACK_MASK | \
+					IWL6000G2B_BT_VALID_KILL_CTS_MASK | \
+					IWL6000G2B_BT_VALID_BT4_TIMES | \
+					IWL6000G2B_BT_VALID_3W_LUT)
+
+struct iwl6000g2b_bt_cmd {
+	u8 flags;
+	u8 ledtime; /* unused */
+	u8 max_kill;
+	u8 bt3_timer_t7_value;
+	__le32 kill_ack_mask;
+	__le32 kill_cts_mask;
+	u8 bt3_prio_sample_time;
+	u8 bt3_timer_t2_value;
+	__le16 bt4_reaction_time; /* unused */
+	__le32 bt3_lookup_table[12];
+	__le16 bt4_decision_time; /* unused */
+	__le16 valid;
+	u8 prio_boost;
+	u8 reserved[3];
+};
+
 /******************************************************************************
  * (6)
  * Spectrum Management (802.11h) Commands, Responses, Notifications:
@@ -2964,6 +3010,19 @@ struct iwl39_statistics_general {
 	struct iwl39_statistics_div div;
 } __attribute__ ((packed));
 
+struct statistics_bt_activity {
+	/* Tx statistics */
+	__le32 hi_priority_tx_req_cnt;
+	__le32 hi_priority_tx_denied_cnt;
+	__le32 lo_priority_tx_req_cnt;
+	__le32 lo_priority_tx_denied_cnt;
+	/* Rx statistics */
+	__le32 hi_priority_rx_req_cnt;
+	__le32 hi_priority_rx_denied_cnt;
+	__le32 lo_priority_rx_req_cnt;
+	__le32 lo_priority_rx_denied_cnt;
+} __packed;
+
 struct statistics_rx_phy {
 	__le32 ina_cnt;
 	__le32 fina_cnt;
@@ -3035,6 +3094,13 @@ struct statistics_rx_non_phy {
 	__le32 beacon_energy_c;
 } __attribute__ ((packed));
 
+struct statistics_rx_non_phy_bt {
+	struct statistics_rx_non_phy common;
+	/* additional stats for bt */
+	__le32 num_bt_kills;
+	__le32 reserved[2];
+} __packed;
+
 struct statistics_rx {
 	struct statistics_rx_phy ofdm;
 	struct statistics_rx_phy cck;
@@ -3042,6 +3108,13 @@ struct statistics_rx {
 	struct statistics_rx_ht_phy ofdm_ht;
 } __attribute__ ((packed));
 
+struct statistics_rx_bt {
+	struct statistics_rx_phy ofdm;
+	struct statistics_rx_phy cck;
+	struct statistics_rx_non_phy_bt general;
+	struct statistics_rx_ht_phy ofdm_ht;
+} __packed;
+
 /**
  * struct statistics_tx_power - current tx power
  *
@@ -3119,6 +3192,14 @@ struct statistics_general {
 	__le32 reserved3;
 } __attribute__ ((packed));
 
+struct statistics_general_bt {
+	struct statistics_general common;
+	struct statistics_bt_activity activity;
+	__le32 reserved2;
+	__le32 reserved3;
+} __packed;
+
+
 #define UCODE_STATISTICS_CLEAR_MSK		(0x1 << 0)
 #define UCODE_STATISTICS_FREQUENCY_MSK		(0x1 << 1)
 #define UCODE_STATISTICS_NARROW_BAND_MSK	(0x1 << 2)
@@ -3176,6 +3257,13 @@ struct iwl_notif_statistics {
 	struct statistics_general general;
 } __attribute__ ((packed));
 
+struct iwl_bt_notif_statistics {
+	__le32 flag;
+	struct statistics_rx_bt rx;
+	struct statistics_tx tx;
+	struct statistics_general_bt general;
+} __packed;
+
 
 /*
  * MISSED_BEACONS_NOTIFICATION = 0xa2 (notification only, not a command)
@@ -3808,6 +3896,15 @@ struct iwl_coex_event_resp {
 } __attribute__ ((packed));
 
 
+struct iwl_bt_coex_profile_notif {
+	u8 uart_msg[8];
+	u8 bt_status; /* 0 - off, 1 - on */
+	u8 bt_traffic_load; /* 0 .. 3? */
+	u8 bt_ci_compliance; /* 0 - not complied, 1 - complied */
+	u8 reserved;
+} __attribute__((packed));
+
+
 /******************************************************************************
  * (13)
  * Union of all expected notifications/responses:
@@ -3842,10 +3939,12 @@ struct iwl_rx_packet {
 		struct iwl_sleep_notification sleep_notif;
 		struct iwl_spectrum_resp spectrum;
 		struct iwl_notif_statistics stats;
+		struct iwl_bt_notif_statistics stats_bt;
 		struct iwl_compressed_ba_resp compressed_ba;
 		struct iwl_missed_beacon_notif missed_beacon;
 		struct iwl_coex_medium_notification coex_medium_notif;
 		struct iwl_coex_event_resp coex_event;
+		struct iwl_bt_coex_profile_notif bt_coex_profile_notif;
 		__le32 status;
 		u8 raw[0];
 	} u;
diff --git a/drivers/net/wireless/iwlwifi/iwl-core.c b/drivers/net/wireless/iwlwifi/iwl-core.c
index a5a2de6..97ed240 100644
--- a/drivers/net/wireless/iwlwifi/iwl-core.c
+++ b/drivers/net/wireless/iwlwifi/iwl-core.c
@@ -64,7 +64,8 @@ MODULE_LICENSE("GPL");
  *
  * default: bt_coex_active = true (BT_COEX_ENABLE)
  */
-static bool bt_coex_active = true;
+bool bt_coex_active = true;
+EXPORT_SYMBOL_GPL(bt_coex_active);
 module_param(bt_coex_active, bool, S_IRUGO);
 MODULE_PARM_DESC(bt_coex_active, "enable wifi/bluetooth co-exist\n");
 
diff --git a/drivers/net/wireless/iwlwifi/iwl-core.h b/drivers/net/wireless/iwlwifi/iwl-core.h
index 0a3f974..f6a96c5 100644
--- a/drivers/net/wireless/iwlwifi/iwl-core.h
+++ b/drivers/net/wireless/iwlwifi/iwl-core.h
@@ -90,6 +90,7 @@ struct iwl_hcmd_ops {
 	int (*commit_rxon)(struct iwl_priv *priv);
 	void (*set_rxon_chain)(struct iwl_priv *priv);
 	int (*set_tx_ant)(struct iwl_priv *priv, u8 valid_tx_ant);
+	void (*send_bt_config)(struct iwl_priv *priv);
 };
 
 struct iwl_hcmd_utils_ops {
@@ -300,6 +301,8 @@ struct iwl_cfg {
 	/* timer period for monitor the driver queues */
 	u32 monitor_recover_period;
 	const bool need_dc_calib;
+	bool advanced_bt_coexist;
+	const bool bt_statistics;
 };
 
 /***************************
@@ -714,4 +717,7 @@ static inline const struct ieee80211_supported_band *iwl_get_hw_mode(
 {
 	return priv->hw->wiphy->bands[band];
 }
+
+extern bool bt_coex_active;
+
 #endif /* __iwl_core_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-dev.h b/drivers/net/wireless/iwlwifi/iwl-dev.h
index fecd4ce..85b5df9 100644
--- a/drivers/net/wireless/iwlwifi/iwl-dev.h
+++ b/drivers/net/wireless/iwlwifi/iwl-dev.h
@@ -61,6 +61,8 @@ extern struct iwl_cfg iwl6000g2a_2agn_cfg;
 extern struct iwl_cfg iwl6000i_2abg_cfg;
 extern struct iwl_cfg iwl6000i_2bg_cfg;
 extern struct iwl_cfg iwl6000_3agn_cfg;
+extern struct iwl_cfg iwl6000g2b_2agn_cfg;
+extern struct iwl_cfg iwl6000g2b_bgn_cfg;
 extern struct iwl_cfg iwl6050_2agn_cfg;
 extern struct iwl_cfg iwl6050_2abg_cfg;
 extern struct iwl_cfg iwl1000_bgn_cfg;
@@ -106,6 +108,8 @@ extern void iwl5000_rx_handler_setup(struct iwl_priv *priv);
 extern int iwl5000_hw_valid_rtc_data_addr(u32 addr);
 extern int iwl5000_send_tx_power(struct iwl_priv *priv);
 extern void iwl5000_temperature(struct iwl_priv *priv);
+extern int iwl5000_send_rxon_assoc(struct iwl_priv *priv);
+extern int iwl5000_send_tx_ant_config(struct iwl_priv *priv, u8 valid_tx_ant);
 
 /* CT-KILL constants */
 #define CT_KILL_THRESHOLD_LEGACY   110 /* in Celsius */
@@ -1104,6 +1108,7 @@ struct iwl_event_log {
 
 /* timer constants use to monitor and recover stuck tx queues in mSecs */
 #define IWL_MONITORING_PERIOD  (1000)
+#define IWL_LONG_MONITORING_PERIOD      (5000)
 #define IWL_ONE_HUNDRED_MSECS   (100)
 #define IWL_SIXTY_SECS          (60000)
 
@@ -1289,10 +1294,14 @@ struct iwl_priv {
 	u8 phy_calib_chain_noise_gain_cmd;
 
 	struct iwl_notif_statistics statistics;
+	struct iwl_bt_notif_statistics statistics_bt;
 #ifdef CONFIG_IWLWIFI_DEBUG
 	struct iwl_notif_statistics accum_statistics;
 	struct iwl_notif_statistics delta_statistics;
 	struct iwl_notif_statistics max_delta;
+	struct iwl_bt_notif_statistics accum_statistics_bt;
+	struct iwl_bt_notif_statistics delta_statistics_bt;
+	struct iwl_bt_notif_statistics max_delta_bt;
 #endif
 
 	/* context information */
-- 
1.7.0.4

