From 072c42e7bd5ccbd6deb79f6abefdaf9719a15ef3 Mon Sep 17 00:00:00 2001
From: Zhenyu Wang <zhenyuw@linux.intel.com>
Date: Thu, 7 Apr 2011 18:06:20 +0800
Subject: [PATCH 3/3] drm/i915: Enable DisplayPort audio

upstream: a9756bb5

This will turn on DP audio output by checking monitor's audio
capability.

Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
[ickle: rebase onto recent changes and rearranged for clarity]
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

[Resolve context conflicts]

Integrated-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/gpu/drm/i915/intel_dp.c |   59 +++++++++++++++++++++++++++------------
 1 files changed, 41 insertions(+), 18 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index 189339f..b4b97c1 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -1305,34 +1305,23 @@ ironlake_dp_detect(struct drm_connector *connector)
 	status = connector_status_disconnected;
 	if (intel_dp_aux_native_read(intel_encoder,
 				     0x000, dp_priv->dpcd,
-				     sizeof (dp_priv->dpcd)) == sizeof (dp_priv->dpcd))
-	{
+				     sizeof(dp_priv->dpcd))
+	    == sizeof(dp_priv->dpcd)) {
 		if (dp_priv->dpcd[0] != 0)
 			status = connector_status_connected;
 	}
 	return status;
 }
 
-/**
- * Uses CRT_HOTPLUG_EN and CRT_HOTPLUG_STAT to detect DP connection.
- *
- * \return true if DP port is connected.
- * \return false if DP port is disconnected.
- */
 static enum drm_connector_status
-intel_dp_detect(struct drm_connector *connector)
+g4x_dp_detect(struct drm_connector *connector)
 {
 	struct intel_encoder *intel_encoder = to_intel_encoder(connector);
 	struct drm_device *dev = intel_encoder->base.dev;
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_dp_priv *dp_priv = intel_encoder->dev_priv;
-	uint32_t temp, bit;
 	enum drm_connector_status status;
-
-	dp_priv->has_audio = false;
-
-	if (HAS_PCH_SPLIT(dev))
-		return ironlake_dp_detect(connector);
+	uint32_t temp, bit;
 
 	switch (dp_priv->output_reg) {
 	case DP_B:
@@ -1354,14 +1343,48 @@ intel_dp_detect(struct drm_connector *connector)
 		return connector_status_disconnected;
 
 	status = connector_status_disconnected;
-	if (intel_dp_aux_native_read(intel_encoder,
-				     0x000, dp_priv->dpcd,
+	if (intel_dp_aux_native_read(intel_encoder, 0x000, dp_priv->dpcd,
 				     sizeof (dp_priv->dpcd)) == sizeof (dp_priv->dpcd))
 	{
 		if (dp_priv->dpcd[0] != 0)
 			status = connector_status_connected;
 	}
-	return status;
+
+	return bit;
+}
+
+/**
+ * Uses CRT_HOTPLUG_EN and CRT_HOTPLUG_STAT to detect DP connection.
+ *
+ * \return true if DP port is connected.
+ * \return false if DP port is disconnected.
+ */
+static enum drm_connector_status
+intel_dp_detect(struct drm_connector *connector)
+{
+	struct intel_encoder *intel_encoder = to_intel_encoder(connector);
+	struct drm_device *dev = intel_encoder->base.dev;
+	struct intel_dp_priv *dp_priv = intel_encoder->dev_priv;
+	enum drm_connector_status status;
+	struct edid *edid = NULL;
+
+	dp_priv->has_audio = false;
+
+	if (HAS_PCH_SPLIT(dev))
+		status = ironlake_dp_detect(connector);
+	else
+		status = g4x_dp_detect(connector);
+	if (status != connector_status_connected)
+		return status;
+
+	edid = drm_get_edid(connector, &dp_priv->adapter);
+	if (edid) {
+		dp_priv->has_audio = drm_detect_monitor_audio(edid);
+		connector->display_info.raw_edid = NULL;
+		kfree(edid);
+	}
+
+	return connector_status_connected;
 }
 
 static int intel_dp_get_modes(struct drm_connector *connector)
-- 
1.7.0.4

