From d898e4690a9a090122f4a74838aef4e1d46960b5 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 10 Nov 2011 11:47:36 +0800
Subject: [PATCH 2/2] staging: mei: Update the MEI driver

Update the MEI driver to the latest vendor drop
version of 7.1.20.25.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/mei/Makefile            |    2 +-
 drivers/staging/mei/backport/backport.c |   40 ++
 drivers/staging/mei/backport/backport.h |   50 +++
 drivers/staging/mei/backport/uuid.h     |   70 ++++
 drivers/staging/mei/build.h             |   36 ++
 drivers/staging/mei/hw.h                |  396 +++++++++++++-----
 drivers/staging/mei/init.c              |  406 +++++++++++--------
 drivers/staging/mei/interface.c         |  160 +++++---
 drivers/staging/mei/interface.h         |   87 ++++-
 drivers/staging/mei/interrupt.c         |  678 ++++++++++++++++---------------
 drivers/staging/mei/iorw.c              |  368 +++++++++--------
 drivers/staging/mei/main.c              |  634 +++++++++++++++++------------
 drivers/staging/mei/mei.h               |  226 +++++++----
 drivers/staging/mei/mei_dev.h           |  425 -------------------
 drivers/staging/mei/mei_version.h       |    3 +-
 drivers/staging/mei/wd.c                |  188 ---------
 16 files changed, 1955 insertions(+), 1814 deletions(-)
 create mode 100755 drivers/staging/mei/backport/backport.c
 create mode 100755 drivers/staging/mei/backport/backport.h
 create mode 100755 drivers/staging/mei/backport/uuid.h
 create mode 100755 drivers/staging/mei/build.h
 delete mode 100644 drivers/staging/mei/mei_dev.h
 delete mode 100644 drivers/staging/mei/wd.c

diff --git a/drivers/staging/mei/Makefile b/drivers/staging/mei/Makefile
index 57168db..3d46128 100644
--- a/drivers/staging/mei/Makefile
+++ b/drivers/staging/mei/Makefile
@@ -8,4 +8,4 @@ mei-objs += interrupt.o
 mei-objs += interface.o
 mei-objs += iorw.o
 mei-objs += main.o
-mei-objs += wd.o
+mei-objs += backport/backport.o
diff --git a/drivers/staging/mei/backport/backport.c b/drivers/staging/mei/backport/backport.c
new file mode 100755
index 0000000..0c3cb61
--- /dev/null
+++ b/drivers/staging/mei/backport/backport.c
@@ -0,0 +1,40 @@
+/*
+ *
+ * Intel Management Engine Interface (Intel MEI) Linux driver
+ * Copyright (c) 2003-2011, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/bitmap.h>
+#include "backport.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+void bitmap_set(unsigned long *map, int start, int nr)
+{
+	unsigned long *p = map + BIT_WORD(start);
+	const int size = start + nr;
+	int bits_to_set = BITS_PER_LONG - (start % BITS_PER_LONG);
+	unsigned long mask_to_set = BITMAP_FIRST_WORD_MASK(start);
+
+	while (nr - bits_to_set >= 0) {
+		*p |= mask_to_set;
+		 nr -= bits_to_set;
+		 bits_to_set = BITS_PER_LONG;
+		 mask_to_set = ~0UL;
+		 p++;
+	 }
+	if (nr) {
+		mask_to_set &= BITMAP_LAST_WORD_MASK(size);
+		*p |= mask_to_set;
+	}
+}
+#endif
diff --git a/drivers/staging/mei/backport/backport.h b/drivers/staging/mei/backport/backport.h
new file mode 100755
index 0000000..5a69095
--- /dev/null
+++ b/drivers/staging/mei/backport/backport.h
@@ -0,0 +1,50 @@
+/*
+ *
+ * Intel Management Engine Interface (Intel MEI) Linux driver
+ * Copyright (c) 2003-2011, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#ifndef _MEI_BACKPORT_H_
+#define _MEI_BACKPORT_H_
+
+#include <linux/version.h>
+#include <linux/err.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+#include <linux/uuid.h>
+#else
+#include "uuid.h"
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+
+/* Bit map operations */
+/* taken from lib/bitmap.h - linux kernel 2.6.38 */
+#define BITMAP_FIRST_WORD_MASK(start) (~0UL << ((start) % BITS_PER_LONG))
+void bitmap_set(unsigned long *map, int start, int nr);
+
+/*** Error Handling ***/
+/* Taken from include/linux/err.h - linux kernel 2.6.38*/
+static inline long __must_check IS_ERR_OR_NULL(const void *ptr)
+{
+	return !ptr || IS_ERR_VALUE((unsigned long)ptr);
+}
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 34)
+#define for_each_set_bit for_each_bit
+#endif
+
+
+#endif
diff --git a/drivers/staging/mei/backport/uuid.h b/drivers/staging/mei/backport/uuid.h
new file mode 100755
index 0000000..5b7efbf
--- /dev/null
+++ b/drivers/staging/mei/backport/uuid.h
@@ -0,0 +1,70 @@
+/*
+ * UUID/GUID definition
+ *
+ * Copyright (C) 2010, Intel Corp.
+ *	Huang Ying <ying.huang@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LINUX_UUID_H_
+#define _LINUX_UUID_H_
+
+#include <linux/types.h>
+#include <linux/string.h>
+
+typedef struct {
+	__u8 b[16];
+} uuid_le;
+
+typedef struct {
+	__u8 b[16];
+} uuid_be;
+
+#define UUID_LE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)		\
+((uuid_le)								\
+{{ (a) & 0xff, ((a) >> 8) & 0xff, ((a) >> 16) & 0xff, ((a) >> 24) & 0xff, \
+   (b) & 0xff, ((b) >> 8) & 0xff,					\
+   (c) & 0xff, ((c) >> 8) & 0xff,					\
+   (d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) }})
+
+#define UUID_BE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)		\
+((uuid_be)								\
+{{ ((a) >> 24) & 0xff, ((a) >> 16) & 0xff, ((a) >> 8) & 0xff, (a) & 0xff, \
+   ((b) >> 8) & 0xff, (b) & 0xff,					\
+   ((c) >> 8) & 0xff, (c) & 0xff,					\
+   (d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) }})
+
+#define NULL_UUID_LE							\
+	UUID_LE(0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00,	\
+		0x00, 0x00, 0x00, 0x00)
+
+#define NULL_UUID_BE							\
+	UUID_BE(0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00,	\
+		0x00, 0x00, 0x00, 0x00)
+
+static inline int uuid_le_cmp(const uuid_le u1, const uuid_le u2)
+{
+	return memcmp(&u1, &u2, sizeof(uuid_le));
+}
+
+static inline int uuid_be_cmp(const uuid_be u1, const uuid_be u2)
+{
+	return memcmp(&u1, &u2, sizeof(uuid_be));
+}
+
+extern void uuid_le_gen(uuid_le *u);
+extern void uuid_be_gen(uuid_be *u);
+
+#endif
diff --git a/drivers/staging/mei/build.h b/drivers/staging/mei/build.h
new file mode 100755
index 0000000..a9c5976
--- /dev/null
+++ b/drivers/staging/mei/build.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright (C) 2011 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ *  - Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  - Neither the name of Intel Corporation. nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corporation. OR THE CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************/
+
+#ifndef __BUILD_H__
+#define __BUILD_H__
+
+#define VER_BUILD                  25
+
+#endif
diff --git a/drivers/staging/mei/hw.h b/drivers/staging/mei/hw.h
index 9b9008c..e9a9a4c 100644
--- a/drivers/staging/mei/hw.h
+++ b/drivers/staging/mei/hw.h
@@ -14,72 +14,23 @@
  *
  */
 
-#ifndef _MEI_HW_TYPES_H_
-#define _MEI_HW_TYPES_H_
+#ifndef _MEI_DATA_STRUCTURES_H_
+#define _MEI_DATA_STRUCTURES_H_
 
-#include <linux/uuid.h>
+#include <linux/io.h>
+#include <linux/wait.h>
+#include <linux/version.h>
+#include "backport/backport.h"
 
-/*
- * Timeouts
- */
-#define MEI_INTEROP_TIMEOUT    (HZ * 7)
-#define MEI_CONNECT_TIMEOUT		3	/* at least 2 seconds */
-
-#define CONNECT_TIMEOUT        15	/* HPS definition */
-#define INIT_CLIENTS_TIMEOUT   15	/* HPS definition */
-
-#define IAMTHIF_STALL_TIMER		12	/* seconds */
-#define IAMTHIF_READ_TIMER		10000	/* ms */
 
-/*
- * Internal Clients Number
- */
-#define MEI_WD_HOST_CLIENT_ID          1
-#define MEI_IAMTHIF_HOST_CLIENT_ID     2
+#define MEI_FC_MESSAGE_RESERVED_LENGTH           5
 
 /*
- * MEI device IDs
+ * Number of queue lists used by this driver
  */
-#define    MEI_DEV_ID_82946GZ	0x2974  /* 82946GZ/GL */
-#define    MEI_DEV_ID_82G35	0x2984  /* 82G35 Express */
-#define    MEI_DEV_ID_82Q965	0x2994  /* 82Q963/Q965 */
-#define    MEI_DEV_ID_82G965	0x29A4  /* 82P965/G965 */
-
-#define    MEI_DEV_ID_82GM965	0x2A04  /* Mobile PM965/GM965 */
-#define    MEI_DEV_ID_82GME965	0x2A14  /* Mobile GME965/GLE960 */
-
-#define    MEI_DEV_ID_ICH9_82Q35 0x29B4  /* 82Q35 Express */
-#define    MEI_DEV_ID_ICH9_82G33 0x29C4  /* 82G33/G31/P35/P31 Express */
-#define    MEI_DEV_ID_ICH9_82Q33 0x29D4  /* 82Q33 Express */
-#define    MEI_DEV_ID_ICH9_82X38 0x29E4  /* 82X38/X48 Express */
-#define    MEI_DEV_ID_ICH9_3200  0x29F4  /* 3200/3210 Server */
-
-#define    MEI_DEV_ID_ICH9_6	0x28B4  /* Bearlake */
-#define    MEI_DEV_ID_ICH9_7	0x28C4  /* Bearlake */
-#define    MEI_DEV_ID_ICH9_8	0x28D4  /* Bearlake */
-#define    MEI_DEV_ID_ICH9_9    0x28E4  /* Bearlake */
-#define    MEI_DEV_ID_ICH9_10	0x28F4  /* Bearlake */
-
-#define    MEI_DEV_ID_ICH9M_1	0x2A44  /* Cantiga */
-#define    MEI_DEV_ID_ICH9M_2	0x2A54  /* Cantiga */
-#define    MEI_DEV_ID_ICH9M_3	0x2A64  /* Cantiga */
-#define    MEI_DEV_ID_ICH9M_4	0x2A74  /* Cantiga */
-
-#define    MEI_DEV_ID_ICH10_1	0x2E04  /* Eaglelake */
-#define    MEI_DEV_ID_ICH10_2	0x2E14  /* Eaglelake */
-#define    MEI_DEV_ID_ICH10_3	0x2E24  /* Eaglelake */
-#define    MEI_DEV_ID_ICH10_4	0x2E34  /* Eaglelake */
-
-#define    MEI_DEV_ID_IBXPK_1	0x3B64  /* Calpella */
-#define    MEI_DEV_ID_IBXPK_2	0x3B65  /* Calpella */
-
-#define    MEI_DEV_ID_CPT_1	0x1C3A    /* Cougerpoint */
-#define    MEI_DEV_ID_PBG_1	0x1D3A    /* PBG */
-
-#define    MEI_DEV_ID_PPT_1	0x1E3A    /* Pantherpoint PPT */
-#define    MEI_DEV_ID_PPT_2	0x1CBA    /* Pantherpoint PPT */
-#define    MEI_DEV_ID_PPT_3	0x1DBA    /* Pantherpoint PPT */
+#define MEI_IO_LISTS_NUMBER        7
 
+#define MEI_CLIENTS_MAX 255
 
 /*
  * MEI HW Section
@@ -134,71 +85,133 @@ access to ME_CBD */
 /* ME Interrupt Enable HRA - host read only access to ME_IE */
 #define ME_IE_HRA         0x00000001
 
+#define MEI_MINORS_BASE	1
+#define MEI_MINORS_COUNT	1
+
+#define  MEI_MINOR_NUMBER	1
+#define  MEI_MAX_OPEN_HANDLE_COUNT	253
+
 /*
- * MEI Version
+ * time to wait for MEI to become ready after init
  */
-#define HBM_MINOR_VERSION                   0
-#define HBM_MAJOR_VERSION                   1
-#define HBM_TIMEOUT                         1	/* 1 second */
+#define MEI_INTEROP_TIMEOUT    (HZ * 7)
 
 /*
- * MEI Bus Message Command IDs
+ * watch dog definition
  */
-#define HOST_START_REQ_CMD                  0x01
-#define HOST_START_RES_CMD                  0x81
+#define MEI_WATCHDOG_DATA_SIZE         16
+#define MEI_START_WD_DATA_SIZE         20
+#define MEI_WD_PARAMS_SIZE             4
+#define MEI_WD_STATE_INDEPENDENCE_MSG_SENT       (1 << 0)
 
-#define HOST_STOP_REQ_CMD                   0x02
-#define HOST_STOP_RES_CMD                   0x82
+#define MEI_WD_HOST_CLIENT_ID          1
+#define MEI_IAMTHIF_HOST_CLIENT_ID     2
 
-#define ME_STOP_REQ_CMD                     0x03
 
-#define HOST_ENUM_REQ_CMD                   0x04
-#define HOST_ENUM_RES_CMD                   0x84
+/* File state */
+enum file_state {
+	MEI_FILE_INITIALIZING = 0,
+	MEI_FILE_CONNECTING,
+	MEI_FILE_CONNECTED,
+	MEI_FILE_DISCONNECTING,
+	MEI_FILE_DISCONNECTED
+};
 
-#define HOST_CLIENT_PROPERTIES_REQ_CMD      0x05
-#define HOST_CLIENT_PROPERTIES_RES_CMD      0x85
+/* MEI device states */
+enum mei_states {
+	MEI_INITIALIZING = 0,
+	MEI_INIT_CLIENTS,
+	MEI_ENABLED,
+	MEI_RESETING,
+	MEI_DISABLED,
+	MEI_RECOVERING_FROM_RESET,
+	MEI_POWER_DOWN,
+	MEI_POWER_UP
+};
 
-#define CLIENT_CONNECT_REQ_CMD              0x06
-#define CLIENT_CONNECT_RES_CMD              0x86
+/* init clients  states*/
+enum mei_init_clients_states {
+	MEI_START_MESSAGE = 0,
+	MEI_ENUM_CLIENTS_MESSAGE,
+	MEI_CLIENT_PROPERTIES_MESSAGE
+};
 
-#define CLIENT_DISCONNECT_REQ_CMD           0x07
-#define CLIENT_DISCONNECT_RES_CMD           0x87
+enum iamthif_states {
+	MEI_IAMTHIF_IDLE,
+	MEI_IAMTHIF_WRITING,
+	MEI_IAMTHIF_FLOW_CONTROL,
+	MEI_IAMTHIF_READING,
+	MEI_IAMTHIF_READ_COMPLETE
+};
 
-#define MEI_FLOW_CONTROL_CMD               0x08
+enum mei_file_transaction_states {
+	MEI_IDLE,
+	MEI_WRITING,
+	MEI_WRITE_COMPLETE,
+	MEI_FLOW_CONTROL,
+	MEI_READING,
+	MEI_READ_COMPLETE
+};
 
-/*
- * MEI Stop Reason
- * used by hbm_host_stop_request.reason
- */
-enum mei_stop_reason_types {
-	DRIVER_STOP_REQUEST = 0x00,
-	DEVICE_D1_ENTRY = 0x01,
-	DEVICE_D2_ENTRY = 0x02,
-	DEVICE_D3_ENTRY = 0x03,
-	SYSTEM_S1_ENTRY = 0x04,
-	SYSTEM_S2_ENTRY = 0x05,
-	SYSTEM_S3_ENTRY = 0x06,
-	SYSTEM_S4_ENTRY = 0x07,
-	SYSTEM_S5_ENTRY = 0x08
+/* MEI CB */
+enum mei_cb_major_types {
+	MEI_READ = 0,
+	MEI_WRITE,
+	MEI_IOCTL,
+	MEI_OPEN,
+	MEI_CLOSE
 };
 
 /*
- * Client Connect Status
- * used by hbm_client_connect_response.status
+ * Intel MEI user data struct
  */
-enum client_connect_status_types {
-	CCS_SUCCESS = 0x00,
-	CCS_NOT_FOUND = 0x01,
-	CCS_ALREADY_STARTED = 0x02,
-	CCS_OUT_OF_RESOURCES = 0x03,
-	CCS_MESSAGE_SMALL = 0x04
+struct mei_message_data {
+	u32 size;
+	char *data;
+} __packed;
+
+
+
+#define MEI_CONNECT_TIMEOUT	3	/* at least 2 seconds */
+#define IAMTHIF_STALL_TIMER	12	/* seconds */
+#define IAMTHIF_READ_TIMER	10000	/* ms */
+
+struct mei_cb_private {
+	struct list_head cb_list;
+	enum mei_cb_major_types major_file_operations;
+	void *file_private;
+	struct mei_message_data request_buffer;
+	struct mei_message_data response_buffer;
+	unsigned long information;
+	unsigned long read_time;
+	struct file *file_object;
 };
 
-/*
- * Client Disconnect Status
- */
-enum client_disconnect_status_types {
-	CDS_SUCCESS = 0x00
+/* Private file struct */
+struct mei_file_private {
+	struct list_head link;
+	struct file *file;
+	enum file_state state;
+	wait_queue_head_t tx_wait;
+	wait_queue_head_t rx_wait;
+	wait_queue_head_t wait;
+	int read_pending;
+	int status;
+	/* ID of client connected */
+	u8 host_client_id;
+	u8 me_client_id;
+	u8 mei_flow_ctrl_creds;
+	u8 timer_count;
+	enum mei_file_transaction_states reading_state;
+	enum mei_file_transaction_states writing_state;
+	int sm_state;
+	struct mei_cb_private *read_cb;
+};
+
+struct io_mei_list {
+	struct mei_cb_private mei_cb;
+	int status;
+	struct mei_device *device_extension;
 };
 
 /*
@@ -314,8 +327,6 @@ struct hbm_client_disconnect_request {
 	u8 reserved[1];
 } __packed;
 
-#define MEI_FC_MESSAGE_RESERVED_LENGTH           5
-
 struct hbm_flow_control {
 	struct hbm_cmd cmd;
 	u8 me_addr;
@@ -329,5 +340,174 @@ struct mei_me_client {
 	u8 mei_flow_ctrl_creds;
 } __packed;
 
+/* MEI private device struct */
+struct mei_device {
+	struct pci_dev *pdev;	/* pointer to pci device struct */
+	/*
+	 * lists of queues
+	 */
+	 /* array of pointers to aio lists */
+	struct io_mei_list *io_list_array[MEI_IO_LISTS_NUMBER];
+	struct io_mei_list read_list;		/* driver read queue */
+	struct io_mei_list write_list;		/* driver write queue */
+	struct io_mei_list write_waiting_list;	/* write waiting queue */
+	struct io_mei_list ctrl_wr_list;	/* managed write IOCTL list */
+	struct io_mei_list ctrl_rd_list;	/* managed read IOCTL list */
+	struct io_mei_list amthi_cmd_list;	/* amthi list for cmd waiting */
+
+	/* driver managed amthi list for reading completed amthi cmd data */
+	struct io_mei_list amthi_read_complete_list;
+	/*
+	 * list of files
+	 */
+	struct list_head file_list;
+	/*
+	 * memory of device
+	 */
+	unsigned int mem_base;
+	unsigned int mem_length;
+	void __iomem *mem_addr;
+	/*
+	 * lock for the device
+	 */
+	struct mutex device_lock; /* device lock */
+	int recvd_msg;
+	struct delayed_work wd_work;	/* watch dog deleye work */
+	/*
+	 * hw states of host and fw(ME)
+	 */
+	u32 host_hw_state;
+	u32 me_hw_state;
+	/*
+	 * waiting queue for receive message from FW
+	 */
+	wait_queue_head_t wait_recvd_msg;
+	wait_queue_head_t wait_stop_wd;
+
+	/*
+	 * mei device  states
+	 */
+	enum mei_states mei_state;
+	enum mei_init_clients_states init_clients_state;
+	u16 init_clients_timer;
+	int stop;
+
+	u32 extra_write_index;
+	u32 rd_msg_buf[128];	/* used for control messages */
+	u32 wr_msg_buf[128];	/* used for control messages */
+	u32 ext_msg_buf[8];	/* for control responses */
+	u32 rd_msg_hdr;
+
+	struct hbm_version version;
+
+	int mei_host_buffer_is_empty;
+	struct mei_file_private wd_file_ext;
+	struct mei_me_client *me_clients; /* Note: memory has to be allocated */
+	DECLARE_BITMAP(me_clients_map, MEI_CLIENTS_MAX);
+	DECLARE_BITMAP(host_clients_map, MEI_CLIENTS_MAX);
+	u8 num_mei_me_clients;
+	u8 me_client_presentation_num;
+	u8 me_client_index;
+
+	int wd_pending;
+	int wd_stopped;
+	u16 wd_timeout;	/* seconds ((wd_data[1] << 8) + wd_data[0]) */
+	unsigned char wd_data[MEI_START_WD_DATA_SIZE];
+
+
+	u16 wd_due_counter;
+	int wd_bypass;	/* if 1, don't refresh watchdog ME client */
+
+	struct file *iamthif_file_object;
+	struct mei_file_private iamthif_file_ext;
+	int iamthif_ioctl;
+	int iamthif_canceled;
+	int iamthif_mtu;
+	unsigned long iamthif_timer;
+	u32 iamthif_stall_timer;
+	unsigned char *iamthif_msg_buf; /* Note: memory has to be allocated */
+	u32 iamthif_msg_buf_size;
+	u32 iamthif_msg_buf_index;
+	int iamthif_flow_control_pending;
+	enum iamthif_states iamthif_state;
+	struct mei_cb_private *iamthif_current_cb;
+
+	u8 write_hang;
+	int need_reset;
+	long open_handle_count;
+
+};
+
+/**
+ * mei_reg_read - Reads 32bit data from the mei device
+ *
+ * @dev: the device structure
+ * @offset: offset from which to read the data
+ *
+ * returns the byte read.
+ */
+static inline u32 mei_reg_read(struct mei_device *dev,
+				unsigned long offset)
+{
+	return ioread32(dev->mem_addr + offset);
+}
+
+/**
+ * mei_reg_write - Writes 32bit data to the mei device
+ *
+ * @dev: the device structure
+ * @offset: offset from which to write the data
+ * @value: the byte to write
+ */
+static inline void mei_reg_write(struct mei_device *dev,
+				unsigned long offset, u32 value)
+{
+	iowrite32(value, dev->mem_addr + offset);
+}
+
+/**
+ * mei_hcsr_read - Reads 32bit data from the host CSR
+ *
+ * @dev: the device structure
+ *
+ * returns the byte read.
+ */
+static inline u32 mei_hcsr_read(struct mei_device *dev)
+{
+	return mei_reg_read(dev, H_CSR);
+}
+
+/**
+ * mei_mecsr_read - Reads 32bit data from the ME CSR
+ *
+ * @dev: the device structure
+ *
+ * returns ME_CSR_HA register value (u32)
+ */
+static inline u32 mei_mecsr_read(struct mei_device *dev)
+{
+	return mei_reg_read(dev, ME_CSR_HA);
+}
+
+/**
+ * get_me_cb_rw - Reads 32bit data from the mei ME_CB_RW register
+ *
+ * @dev: the device structure
+ *
+ * returns ME_CB_RW register value (u32)
+ */
+static inline u32 mei_mecbrw_read(struct mei_device *dev)
+{
+	return mei_reg_read(dev, ME_CB_RW);
+}
+
+
+/*
+ * mei interface function prototypes
+ */
+void mei_hcsr_set(struct mei_device *dev);
+void mei_csr_clear_his(struct mei_device *dev);
 
-#endif
+void mei_enable_interrupts(struct mei_device *dev);
+void mei_disable_interrupts(struct mei_device *dev);
+#endif /* _MEI_DATA_STRUCTURES_H_ */
diff --git a/drivers/staging/mei/init.c b/drivers/staging/mei/init.c
index 0fa8216..4b0645a 100644
--- a/drivers/staging/mei/init.c
+++ b/drivers/staging/mei/init.c
@@ -17,40 +17,91 @@
 #include <linux/pci.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
-#include <linux/delay.h>
+#include <linux/moduleparam.h>
 
-#include "mei_dev.h"
 #include "hw.h"
 #include "interface.h"
 #include "mei.h"
 
+/*
+ * MEI Watchdog Module Parameters
+ */
+static u16 watchdog_timeout = AMT_WD_VALUE;
+module_param(watchdog_timeout, ushort, 0);
+MODULE_PARM_DESC(watchdog_timeout,
+		"Intel(R) AMT Watchdog timeout value in seconds. (default="
+					__MODULE_STRING(AMT_WD_VALUE)
+					", disable=0)");
+
+const u8 mei_start_wd_params[] = { 0x02, 0x12, 0x13, 0x10 };
+const u8 mei_stop_wd_params[] = { 0x02, 0x02, 0x14, 0x10 };
+
+const u8 mei_wd_state_independence_msg[3][4] = {
+	{0x05, 0x02, 0x51, 0x10},
+	{0x05, 0x02, 0x52, 0x10},
+	{0x07, 0x02, 0x01, 0x10}
+};
+
+/* UUIDs for AMT F/W clients */
+const uuid_le mei_wd_guid = UUID_LE(0x05B79A6F, 0x4628, 0x4D7F, 0x89,
+						0x9D, 0xA9, 0x15, 0x14, 0xCB,
+						0x32, 0xAB);
+
 const uuid_le mei_amthi_guid  = UUID_LE(0x12f80028, 0xb4b7, 0x4b2d, 0xac,
 						0xa8, 0x46, 0xe0, 0xff, 0x65,
 						0x81, 0x4c);
 
 /**
- * mei_io_list_init - Sets up a queue list.
+ * mei_initialize_list - Sets up a queue list.
  *
- * @list: An instance io list structure
+ * @list: An instance of our list structure
  * @dev: the device structure
  */
-void mei_io_list_init(struct mei_io_list *list)
+void mei_initialize_list(struct io_mei_list *list,
+			  struct mei_device *dev)
 {
 	/* initialize our queue list */
 	INIT_LIST_HEAD(&list->mei_cb.cb_list);
 	list->status = 0;
+	list->device_extension = dev;
+}
+
+/**
+ * mei_flush_queues - flushes queue lists belonging to file_ext.
+ *
+ * @dev: the device structure
+ * @file_ext: private data of the file object
+ */
+void mei_flush_queues(struct mei_device *dev,
+		       struct mei_file_private *file_ext)
+{
+	int i;
+
+	if (!dev || !file_ext)
+		return;
+
+	for (i = 0; i < MEI_IO_LISTS_NUMBER; i++) {
+		dev_dbg(&dev->pdev->dev, "remove list entry belonging to file_ext\n");
+		mei_flush_list(dev->io_list_array[i], file_ext);
+	}
 }
 
+
 /**
- * mei_io_list_flush - removes list entry belonging to cl.
+ * mei_flush_list - removes list entry belonging to file_ext.
  *
  * @list:  An instance of our list structure
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  */
-void mei_io_list_flush(struct mei_io_list *list, struct mei_cl *cl)
+void mei_flush_list(struct io_mei_list *list,
+		struct mei_file_private *file_ext)
 {
-	struct mei_cl_cb *cb_pos = NULL;
-	struct mei_cl_cb *cb_next = NULL;
+	struct mei_file_private *file_ext_tmp;
+	struct mei_cb_private *priv_cb_pos = NULL;
+	struct mei_cb_private *priv_cb_next = NULL;
+
+	if (!list || !file_ext)
+		return;
 
 	if (list->status != 0)
 		return;
@@ -58,39 +109,17 @@ void mei_io_list_flush(struct mei_io_list *list, struct mei_cl *cl)
 	if (list_empty(&list->mei_cb.cb_list))
 		return;
 
-	list_for_each_entry_safe(cb_pos, cb_next,
+	list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 				 &list->mei_cb.cb_list, cb_list) {
-		if (cb_pos) {
-			struct mei_cl *cl_tmp;
-			cl_tmp = (struct mei_cl *)cb_pos->file_private;
-			if (mei_cl_cmp_id(cl, cl_tmp))
-				list_del(&cb_pos->cb_list);
+		if (priv_cb_pos) {
+			file_ext_tmp = (struct mei_file_private *)
+				priv_cb_pos->file_private;
+			if (file_ext_tmp &&
+			    mei_fe_same_id(file_ext, file_ext_tmp))
+				list_del(&priv_cb_pos->cb_list);
 		}
 	}
 }
-/**
- * mei_cl_flush_queues - flushes queue lists belonging to cl.
- *
- * @dev: the device structure
- * @cl: private data of the file object
- */
-int mei_cl_flush_queues(struct mei_cl *cl)
-{
-	if (!cl || !cl->dev)
-		return -EINVAL;
-
-	dev_dbg(&cl->dev->pdev->dev, "remove list entry belonging to cl\n");
-	mei_io_list_flush(&cl->dev->read_list, cl);
-	mei_io_list_flush(&cl->dev->write_list, cl);
-	mei_io_list_flush(&cl->dev->write_waiting_list, cl);
-	mei_io_list_flush(&cl->dev->ctrl_wr_list, cl);
-	mei_io_list_flush(&cl->dev->ctrl_rd_list, cl);
-	mei_io_list_flush(&cl->dev->amthi_cmd_list, cl);
-	mei_io_list_flush(&cl->dev->amthi_read_complete_list, cl);
-	return 0;
-}
-
-
 
 /**
  * mei_reset_iamthif_params - initializes mei device iamthif
@@ -103,8 +132,9 @@ static void mei_reset_iamthif_params(struct mei_device *dev)
 	dev->iamthif_current_cb = NULL;
 	dev->iamthif_msg_buf_size = 0;
 	dev->iamthif_msg_buf_index = 0;
-	dev->iamthif_canceled = false;
-	dev->iamthif_ioctl = false;
+	dev->iamthif_canceled = 0;
+	dev->iamthif_file_ext.file = NULL;
+	dev->iamthif_ioctl = 0;
 	dev->iamthif_state = MEI_IAMTHIF_IDLE;
 	dev->iamthif_timer = 0;
 }
@@ -116,8 +146,9 @@ static void mei_reset_iamthif_params(struct mei_device *dev)
  *
  * returns The mei_device_device pointer on success, NULL on failure.
  */
-struct mei_device *mei_device_init(struct pci_dev *pdev)
+struct mei_device *init_mei_device(struct pci_dev *pdev)
 {
+	int i;
 	struct mei_device *dev;
 
 	dev = kzalloc(sizeof(struct mei_device), GFP_KERNEL);
@@ -125,23 +156,23 @@ struct mei_device *mei_device_init(struct pci_dev *pdev)
 		return NULL;
 
 	/* setup our list array */
+	dev->io_list_array[0] = &dev->read_list;
+	dev->io_list_array[1] = &dev->write_list;
+	dev->io_list_array[2] = &dev->write_waiting_list;
+	dev->io_list_array[3] = &dev->ctrl_wr_list;
+	dev->io_list_array[4] = &dev->ctrl_rd_list;
+	dev->io_list_array[5] = &dev->amthi_cmd_list;
+	dev->io_list_array[6] = &dev->amthi_read_complete_list;
 	INIT_LIST_HEAD(&dev->file_list);
-	INIT_LIST_HEAD(&dev->wd_cl.link);
-	INIT_LIST_HEAD(&dev->iamthif_cl.link);
+	INIT_LIST_HEAD(&dev->wd_file_ext.link);
+	INIT_LIST_HEAD(&dev->iamthif_file_ext.link);
 	mutex_init(&dev->device_lock);
 	init_waitqueue_head(&dev->wait_recvd_msg);
 	init_waitqueue_head(&dev->wait_stop_wd);
 	dev->mei_state = MEI_INITIALIZING;
 	dev->iamthif_state = MEI_IAMTHIF_IDLE;
-
-
-	mei_io_list_init(&dev->read_list);
-	mei_io_list_init(&dev->write_list);
-	mei_io_list_init(&dev->write_waiting_list);
-	mei_io_list_init(&dev->ctrl_wr_list);
-	mei_io_list_init(&dev->ctrl_rd_list);
-	mei_io_list_init(&dev->amthi_cmd_list);
-	mei_io_list_init(&dev->amthi_read_complete_list);
+	for (i = 0; i < MEI_IO_LISTS_NUMBER; i++)
+		mei_initialize_list(dev->io_list_array[i], dev);
 	dev->pdev = pdev;
 	return dev;
 }
@@ -169,7 +200,7 @@ int mei_hw_init(struct mei_device *dev)
 	if ((dev->host_hw_state & H_IS) == H_IS)
 		mei_reg_write(dev, H_CSR, dev->host_hw_state);
 
-	dev->recvd_msg = false;
+	dev->recvd_msg = 0;
 	dev_dbg(&dev->pdev->dev, "reset in start the mei device.\n");
 
 	mei_reset(dev, 1);
@@ -185,41 +216,40 @@ int mei_hw_init(struct mei_device *dev)
 		mutex_lock(&dev->device_lock);
 	}
 
-	if (err <= 0 && !dev->recvd_msg) {
+	if (!err && !dev->recvd_msg) {
 		dev->mei_state = MEI_DISABLED;
 		dev_dbg(&dev->pdev->dev,
-			"wait_event_interruptible_timeout failed"
-			"on wait for ME to turn on ME_RDY.\n");
-		ret = -ENODEV;
-		goto out;
-	}
-
-	if (!(((dev->host_hw_state & H_RDY) == H_RDY) &&
-	      ((dev->me_hw_state & ME_RDY_HRA) == ME_RDY_HRA))) {
-		dev->mei_state = MEI_DISABLED;
-		dev_dbg(&dev->pdev->dev,
-			"host_hw_state = 0x%08x, me_hw_state = 0x%08x.\n",
-			dev->host_hw_state, dev->me_hw_state);
-
-		if (!(dev->host_hw_state & H_RDY))
-			dev_dbg(&dev->pdev->dev, "host turn off H_RDY.\n");
-
-		if (!(dev->me_hw_state & ME_RDY_HRA))
-			dev_dbg(&dev->pdev->dev, "ME turn off ME_RDY.\n");
-
-		printk(KERN_ERR "mei: link layer initialization failed.\n");
+				"wait_event_interruptible_timeout failed"
+				"on wait for ME to turn on ME_RDY.\n");
 		ret = -ENODEV;
 		goto out;
+	} else {
+		if (!(((dev->host_hw_state & H_RDY) == H_RDY) &&
+		      ((dev->me_hw_state & ME_RDY_HRA) == ME_RDY_HRA))) {
+			dev->mei_state = MEI_DISABLED;
+			dev_dbg(&dev->pdev->dev, "host_hw_state = 0x%08x, me_hw_state = 0x%08x.\n",
+			    dev->host_hw_state,
+			    dev->me_hw_state);
+
+			if (!(dev->host_hw_state & H_RDY) != H_RDY)
+				dev_dbg(&dev->pdev->dev, "host turn off H_RDY.\n");
+
+			if (!(dev->me_hw_state & ME_RDY_HRA) != ME_RDY_HRA)
+				dev_dbg(&dev->pdev->dev, "ME turn off ME_RDY.\n");
+
+			printk(KERN_ERR
+			       "mei: link layer initialization failed.\n");
+			ret = -ENODEV;
+			goto out;
+		}
 	}
-
 	if (dev->version.major_version != HBM_MAJOR_VERSION ||
 	    dev->version.minor_version != HBM_MINOR_VERSION) {
 		dev_dbg(&dev->pdev->dev, "MEI start failed.\n");
 		ret = -ENODEV;
 		goto out;
 	}
-
-	dev->recvd_msg = false;
+	dev->recvd_msg = 0;
 	dev_dbg(&dev->pdev->dev, "host_hw_state = 0x%08x, me_hw_state = 0x%08x.\n",
 	    dev->host_hw_state, dev->me_hw_state);
 	dev_dbg(&dev->pdev->dev, "ME turn on ME_RDY and host turn on H_RDY.\n");
@@ -256,14 +286,14 @@ static void mei_hw_reset(struct mei_device *dev, int interrupts_enabled)
  */
 void mei_reset(struct mei_device *dev, int interrupts_enabled)
 {
-	struct mei_cl *cl_pos = NULL;
-	struct mei_cl *cl_next = NULL;
-	struct mei_cl_cb *cb_pos = NULL;
-	struct mei_cl_cb *cb_next = NULL;
+	struct mei_file_private *file_pos = NULL;
+	struct mei_file_private *file_next = NULL;
+	struct mei_cb_private *priv_cb_pos = NULL;
+	struct mei_cb_private *priv_cb_next = NULL;
 	bool unexpected;
 
 	if (dev->mei_state == MEI_RECOVERING_FROM_RESET) {
-		dev->need_reset = true;
+		dev->need_reset = 1;
 		return;
 	}
 
@@ -287,37 +317,37 @@ void mei_reset(struct mei_device *dev, int interrupts_enabled)
 	dev_dbg(&dev->pdev->dev, "currently saved host_hw_state = 0x%08x.\n",
 	    dev->host_hw_state);
 
-	dev->need_reset = false;
+	dev->need_reset = 0;
 
 	if (dev->mei_state != MEI_INITIALIZING) {
 		if (dev->mei_state != MEI_DISABLED &&
 		    dev->mei_state != MEI_POWER_DOWN)
 			dev->mei_state = MEI_RESETING;
 
-		list_for_each_entry_safe(cl_pos,
-				cl_next, &dev->file_list, link) {
-			cl_pos->state = MEI_FILE_DISCONNECTED;
-			cl_pos->mei_flow_ctrl_creds = 0;
-			cl_pos->read_cb = NULL;
-			cl_pos->timer_count = 0;
+		list_for_each_entry_safe(file_pos,
+				file_next, &dev->file_list, link) {
+			file_pos->state = MEI_FILE_DISCONNECTED;
+			file_pos->mei_flow_ctrl_creds = 0;
+			file_pos->read_cb = NULL;
+			file_pos->timer_count = 0;
 		}
 		/* remove entry if already in list */
 		dev_dbg(&dev->pdev->dev, "list del iamthif and wd file list.\n");
 		mei_remove_client_from_file_list(dev,
-				dev->wd_cl.host_client_id);
+				dev->wd_file_ext.host_client_id);
 
 		mei_remove_client_from_file_list(dev,
-				dev->iamthif_cl.host_client_id);
+				dev->iamthif_file_ext.host_client_id);
 
 		mei_reset_iamthif_params(dev);
 		dev->wd_due_counter = 0;
 		dev->extra_write_index = 0;
 	}
 
-	dev->me_clients_num = 0;
+	dev->num_mei_me_clients = 0;
 	dev->rd_msg_hdr = 0;
-	dev->stop = false;
-	dev->wd_pending = false;
+	dev->stop = 0;
+	dev->wd_pending = 0;
 
 	/* update the state of the registers after reset */
 	dev->host_hw_state = mei_hcsr_read(dev);
@@ -330,21 +360,21 @@ void mei_reset(struct mei_device *dev, int interrupts_enabled)
 		dev_warn(&dev->pdev->dev, "unexpected reset.\n");
 
 	/* Wake up all readings so they can be interrupted */
-	list_for_each_entry_safe(cl_pos, cl_next, &dev->file_list, link) {
-		if (waitqueue_active(&cl_pos->rx_wait)) {
+	list_for_each_entry_safe(file_pos, file_next, &dev->file_list, link) {
+		if (waitqueue_active(&file_pos->rx_wait)) {
 			dev_dbg(&dev->pdev->dev, "Waking up client!\n");
-			wake_up_interruptible(&cl_pos->rx_wait);
+			wake_up_interruptible(&file_pos->rx_wait);
 		}
 	}
 	/* remove all waiting requests */
 	if (dev->write_list.status == 0 &&
 		!list_empty(&dev->write_list.mei_cb.cb_list)) {
-		list_for_each_entry_safe(cb_pos, cb_next,
+		list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 				&dev->write_list.mei_cb.cb_list, cb_list) {
-			if (cb_pos) {
-				list_del(&cb_pos->cb_list);
-				mei_free_cb_private(cb_pos);
-				cb_pos = NULL;
+			if (priv_cb_pos) {
+				list_del(&priv_cb_pos->cb_list);
+				mei_free_cb_private(priv_cb_pos);
+				priv_cb_pos = NULL;
 			}
 		}
 	}
@@ -359,7 +389,7 @@ void mei_reset(struct mei_device *dev, int interrupts_enabled)
  *
  * returns none.
  */
-void mei_host_start_message(struct mei_device *dev)
+void host_start_message(struct mei_device *dev)
 {
 	struct mei_msg_hdr *mei_hdr;
 	struct hbm_host_version_request *host_start_req;
@@ -378,7 +408,7 @@ void mei_host_start_message(struct mei_device *dev)
 	host_start_req->cmd.cmd = HOST_START_REQ_CMD;
 	host_start_req->host_version.major_version = HBM_MAJOR_VERSION;
 	host_start_req->host_version.minor_version = HBM_MINOR_VERSION;
-	dev->recvd_msg = false;
+	dev->recvd_msg = 0;
 	if (!mei_write_message(dev, mei_hdr,
 				       (unsigned char *) (host_start_req),
 				       mei_hdr->length)) {
@@ -398,7 +428,7 @@ void mei_host_start_message(struct mei_device *dev)
  *
  * returns none.
  */
-void mei_host_enum_clients_message(struct mei_device *dev)
+void host_enum_clients_message(struct mei_device *dev)
 {
 	struct mei_msg_hdr *mei_hdr;
 	struct hbm_host_enum_request *host_enum_req;
@@ -433,16 +463,16 @@ void mei_host_enum_clients_message(struct mei_device *dev)
  *
  * returns none.
  */
-void mei_allocate_me_clients_storage(struct mei_device *dev)
+void allocate_me_clients_storage(struct mei_device *dev)
 {
 	struct mei_me_client *clients;
 	int b;
 
 	/* count how many ME clients we have */
 	for_each_set_bit(b, dev->me_clients_map, MEI_CLIENTS_MAX)
-		dev->me_clients_num++;
+		dev->num_mei_me_clients++;
 
-	if (dev->me_clients_num <= 0)
+	if (dev->num_mei_me_clients <= 0)
 		return ;
 
 
@@ -450,10 +480,10 @@ void mei_allocate_me_clients_storage(struct mei_device *dev)
 		kfree(dev->me_clients);
 		dev->me_clients = NULL;
 	}
-	dev_dbg(&dev->pdev->dev, "memory allocation for ME clients size=%zd.\n",
-		dev->me_clients_num * sizeof(struct mei_me_client));
+	dev_dbg(&dev->pdev->dev, "memory allocation for ME clients size=%lx.\n",
+		dev->num_mei_me_clients * sizeof(struct mei_me_client));
 	/* allocate storage for ME clients representation */
-	clients = kcalloc(dev->me_clients_num,
+	clients = kcalloc(dev->num_mei_me_clients,
 			sizeof(struct mei_me_client), GFP_KERNEL);
 	if (!clients) {
 		dev_dbg(&dev->pdev->dev, "memory allocation for ME clients failed.\n");
@@ -471,7 +501,7 @@ void mei_allocate_me_clients_storage(struct mei_device *dev)
  *
  * returns none.
  */
-void mei_host_client_properties(struct mei_device *dev)
+void host_client_properties(struct mei_device *dev)
 {
 	struct mei_msg_hdr *mei_header;
 	struct hbm_props_request *host_cli_req;
@@ -517,11 +547,12 @@ void mei_host_client_properties(struct mei_device *dev)
 	 * with associated host client
 	 */
 	bitmap_zero(dev->host_clients_map, MEI_CLIENTS_MAX);
+	dev->write_hang = -1;
 	dev->open_handle_count = 0;
 	bitmap_set(dev->host_clients_map, 0, 3);
 	dev->mei_state = MEI_ENABLED;
 
-	mei_wd_host_init(dev);
+	host_init_wd(dev);
 	return;
 }
 
@@ -531,23 +562,24 @@ void mei_host_client_properties(struct mei_device *dev)
  * @priv: private file structure to be initialized
  * @file: the file structure
  */
-void mei_cl_init(struct mei_cl *priv, struct mei_device *dev)
+static void mei_init_file_private(struct mei_file_private *priv,
+				   struct file *file)
 {
-	memset(priv, 0, sizeof(struct mei_cl));
+	memset(priv, 0, sizeof(struct mei_file_private));
 	init_waitqueue_head(&priv->wait);
 	init_waitqueue_head(&priv->rx_wait);
 	init_waitqueue_head(&priv->tx_wait);
 	INIT_LIST_HEAD(&priv->link);
 	priv->reading_state = MEI_IDLE;
 	priv->writing_state = MEI_IDLE;
-	priv->dev = dev;
 }
 
-int mei_find_me_client_index(const struct mei_device *dev, uuid_le cuuid)
+int mei_find_me_client_index(const struct mei_device *dev,
+							uuid_le cuuid)
 {
 	int i, res = -1;
 
-	for (i = 0; i < dev->me_clients_num; ++i)
+	for (i = 0; i < dev->num_mei_me_clients; ++i)
 		if (uuid_le_cmp(cuuid,
 				dev->me_clients[i].props.protocol_name) == 0) {
 			res = i;
@@ -568,7 +600,8 @@ int mei_find_me_client_index(const struct mei_device *dev, uuid_le cuuid)
  *
  * returns ME client index
  */
-u8 mei_find_me_client_update_filext(struct mei_device *dev, struct mei_cl *priv,
+static u8 mei_find_me_client_update_filext(struct mei_device *dev,
+				struct mei_file_private *priv,
 				const uuid_le *cguid, u8 client_id)
 {
 	int i;
@@ -591,23 +624,71 @@ u8 mei_find_me_client_update_filext(struct mei_device *dev, struct mei_cl *priv,
 }
 
 /**
+ * host_init_wd - mei initialization wd.
+ *
+ * @dev: the device structure
+ */
+void host_init_wd(struct mei_device *dev)
+{
+	mei_init_file_private(&dev->wd_file_ext, NULL);
+
+	/* look for WD client and connect to it */
+	dev->wd_file_ext.state = MEI_FILE_DISCONNECTED;
+	dev->wd_timeout = 0;
+
+	if (watchdog_timeout > 0) {
+		/* AMT mode */
+		dev->wd_timeout = watchdog_timeout;
+		dev_dbg(&dev->pdev->dev,
+				"dev->wd_timeout=%d.\n", dev->wd_timeout);
+		memcpy(dev->wd_data, mei_start_wd_params, MEI_WD_PARAMS_SIZE);
+		memcpy(dev->wd_data + MEI_WD_PARAMS_SIZE,
+			   &dev->wd_timeout, sizeof(u16));
+
+		/* find ME WD client */
+		mei_find_me_client_update_filext(dev, &dev->wd_file_ext,
+					&mei_wd_guid, MEI_WD_HOST_CLIENT_ID);
+
+		dev_dbg(&dev->pdev->dev, "check wd_file_ext\n");
+		if (MEI_FILE_CONNECTING == dev->wd_file_ext.state) {
+			if (!mei_connect(dev, &dev->wd_file_ext)) {
+				dev_dbg(&dev->pdev->dev, "Failed to connect to WD client\n");
+				dev->wd_file_ext.state = MEI_FILE_DISCONNECTED;
+				dev->wd_file_ext.host_client_id = 0;
+				host_init_iamthif(dev) ;
+			} else {
+				dev->wd_file_ext.timer_count = CONNECT_TIMEOUT;
+			}
+		} else {
+			dev_dbg(&dev->pdev->dev, "Failed to find WD client\n");
+			host_init_iamthif(dev) ;
+		}
+	} else {
+		dev->wd_bypass = 1;
+		dev_dbg(&dev->pdev->dev, "WD requested to be disabled\n");
+		host_init_iamthif(dev) ;
+	}
+}
+
+
+/**
  * host_init_iamthif - mei initialization iamthif client.
  *
  * @dev: the device structure
  *
  */
-void mei_host_init_iamthif(struct mei_device *dev)
+void host_init_iamthif(struct mei_device *dev)
 {
 	u8 i;
 	unsigned char *msg_buf;
 
-	mei_cl_init(&dev->iamthif_cl, dev);
-	dev->iamthif_cl.state = MEI_FILE_DISCONNECTED;
+	mei_init_file_private(&dev->iamthif_file_ext, NULL);
+	dev->iamthif_file_ext.state = MEI_FILE_DISCONNECTED;
 
 	/* find ME amthi client */
-	i = mei_find_me_client_update_filext(dev, &dev->iamthif_cl,
+	i = mei_find_me_client_update_filext(dev, &dev->iamthif_file_ext,
 			    &mei_amthi_guid, MEI_IAMTHIF_HOST_CLIENT_ID);
-	if (dev->iamthif_cl.state != MEI_FILE_CONNECTING) {
+	if (dev->iamthif_file_ext.state != MEI_FILE_CONNECTING) {
 		dev_dbg(&dev->pdev->dev, "failed to find iamthif client.\n");
 		return;
 	}
@@ -636,12 +717,12 @@ void mei_host_init_iamthif(struct mei_device *dev)
 
 	dev->iamthif_msg_buf = msg_buf;
 
-	if (!mei_connect(dev, &dev->iamthif_cl)) {
+	if (!mei_connect(dev, &dev->iamthif_file_ext)) {
 		dev_dbg(&dev->pdev->dev, "Failed to connect to AMTHI client\n");
-		dev->iamthif_cl.state = MEI_FILE_DISCONNECTED;
-		dev->iamthif_cl.host_client_id = 0;
+		dev->iamthif_file_ext.state = MEI_FILE_DISCONNECTED;
+		dev->iamthif_file_ext.host_client_id = 0;
 	} else {
-		dev->iamthif_cl.timer_count = CONNECT_TIMEOUT;
+		dev->iamthif_file_ext.timer_count = CONNECT_TIMEOUT;
 	}
 }
 
@@ -651,17 +732,17 @@ void mei_host_init_iamthif(struct mei_device *dev)
  *
  * returns  The allocated file or NULL on failure
  */
-struct mei_cl *mei_cl_allocate(struct mei_device *dev)
+struct mei_file_private *mei_alloc_file_private(struct file *file)
 {
-	struct mei_cl *cl;
+	struct mei_file_private *priv;
 
-	cl = kmalloc(sizeof(struct mei_cl), GFP_KERNEL);
-	if (!cl)
+	priv = kmalloc(sizeof(struct mei_file_private), GFP_KERNEL);
+	if (!priv)
 		return NULL;
 
-	mei_cl_init(cl, dev);
+	mei_init_file_private(priv, file);
 
-	return cl;
+	return priv;
 }
 
 
@@ -670,36 +751,37 @@ struct mei_cl *mei_cl_allocate(struct mei_device *dev)
  * mei_disconnect_host_client - sends disconnect message to fw from host client.
  *
  * @dev: the device structure
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  *
  * Locking: called under "dev->device_lock" lock
  *
  * returns 0 on success, <0 on failure.
  */
-int mei_disconnect_host_client(struct mei_device *dev, struct mei_cl *cl)
+int mei_disconnect_host_client(struct mei_device *dev,
+				struct mei_file_private *file_ext)
 {
 	int rets, err;
 	long timeout = 15;	/* 15 seconds */
-	struct mei_cl_cb *cb;
+	struct mei_cb_private *priv_cb;
 
-	if (!dev || !cl)
+	if (!dev || !file_ext)
 		return -ENODEV;
 
-	if (cl->state != MEI_FILE_DISCONNECTING)
+	if (file_ext->state != MEI_FILE_DISCONNECTING)
 		return 0;
 
-	cb = kzalloc(sizeof(struct mei_cl_cb), GFP_KERNEL);
-	if (!cb)
+	priv_cb = kzalloc(sizeof(struct mei_cb_private), GFP_KERNEL);
+	if (!priv_cb)
 		return -ENOMEM;
 
-	INIT_LIST_HEAD(&cb->cb_list);
-	cb->file_private = cl;
-	cb->major_file_operations = MEI_CLOSE;
+	INIT_LIST_HEAD(&priv_cb->cb_list);
+	priv_cb->file_private = file_ext;
+	priv_cb->major_file_operations = MEI_CLOSE;
 	if (dev->mei_host_buffer_is_empty) {
-		dev->mei_host_buffer_is_empty = false;
-		if (mei_disconnect(dev, cl)) {
+		dev->mei_host_buffer_is_empty = 0;
+		if (mei_disconnect(dev, file_ext)) {
 			mdelay(10); /* Wait for hardware disconnection ready */
-			list_add_tail(&cb->cb_list,
+			list_add_tail(&priv_cb->cb_list,
 				&dev->ctrl_rd_list.mei_cb.cb_list);
 		} else {
 			rets = -ENODEV;
@@ -708,22 +790,22 @@ int mei_disconnect_host_client(struct mei_device *dev, struct mei_cl *cl)
 		}
 	} else {
 		dev_dbg(&dev->pdev->dev, "add disconnect cb to control write list\n");
-		list_add_tail(&cb->cb_list,
+		list_add_tail(&priv_cb->cb_list,
 				&dev->ctrl_wr_list.mei_cb.cb_list);
 	}
 	mutex_unlock(&dev->device_lock);
 
 	err = wait_event_timeout(dev->wait_recvd_msg,
-		 (MEI_FILE_DISCONNECTED == cl->state),
+		 (MEI_FILE_DISCONNECTED == file_ext->state),
 		 timeout * HZ);
 
 	mutex_lock(&dev->device_lock);
-	if (MEI_FILE_DISCONNECTED == cl->state) {
+	if (MEI_FILE_DISCONNECTED == file_ext->state) {
 		rets = 0;
 		dev_dbg(&dev->pdev->dev, "successfully disconnected from FW client.\n");
 	} else {
 		rets = -ENODEV;
-		if (MEI_FILE_DISCONNECTED != cl->state)
+		if (MEI_FILE_DISCONNECTED != file_ext->state)
 			dev_dbg(&dev->pdev->dev, "wrong status client disconnect.\n");
 
 		if (err)
@@ -734,10 +816,10 @@ int mei_disconnect_host_client(struct mei_device *dev, struct mei_cl *cl)
 		dev_dbg(&dev->pdev->dev, "failed to disconnect from FW client.\n");
 	}
 
-	mei_io_list_flush(&dev->ctrl_rd_list, cl);
-	mei_io_list_flush(&dev->ctrl_wr_list, cl);
+	mei_flush_list(&dev->ctrl_rd_list, file_ext);
+	mei_flush_list(&dev->ctrl_wr_list, file_ext);
 free:
-	mei_free_cb_private(cb);
+	mei_free_cb_private(priv_cb);
 	return rets;
 }
 
@@ -751,14 +833,14 @@ free:
 void mei_remove_client_from_file_list(struct mei_device *dev,
 				       u8 host_client_id)
 {
-	struct mei_cl *cl_pos = NULL;
-	struct mei_cl *cl_next = NULL;
-	list_for_each_entry_safe(cl_pos, cl_next, &dev->file_list, link) {
-		if (host_client_id == cl_pos->host_client_id) {
+	struct mei_file_private *file_pos = NULL;
+	struct mei_file_private *file_next = NULL;
+	list_for_each_entry_safe(file_pos, file_next, &dev->file_list, link) {
+		if (host_client_id == file_pos->host_client_id) {
 			dev_dbg(&dev->pdev->dev, "remove host client = %d, ME client = %d\n",
-					cl_pos->host_client_id,
-					cl_pos->me_client_id);
-			list_del_init(&cl_pos->link);
+					file_pos->host_client_id,
+					file_pos->me_client_id);
+			list_del_init(&file_pos->link);
 			break;
 		}
 	}
diff --git a/drivers/staging/mei/interface.c b/drivers/staging/mei/interface.c
index cfec92d..0712b6f 100644
--- a/drivers/staging/mei/interface.c
+++ b/drivers/staging/mei/interface.c
@@ -15,7 +15,6 @@
  */
 
 #include <linux/pci.h>
-#include "mei_dev.h"
 #include "mei.h"
 #include "interface.h"
 
@@ -101,7 +100,7 @@ int mei_host_buffer_is_empty(struct mei_device *dev)
  *
  * returns -1(ESLOTS_OVERFLOW) if overflow, otherwise empty slots count
  */
-int mei_count_empty_write_slots(struct mei_device *dev)
+s32 mei_count_empty_write_slots(struct mei_device *dev)
 {
 	unsigned char buffer_depth, filled_slots, empty_slots;
 
@@ -110,11 +109,12 @@ int mei_count_empty_write_slots(struct mei_device *dev)
 	filled_slots = _host_get_filled_slots(dev);
 	empty_slots = buffer_depth - filled_slots;
 
-	/* check for overflow */
-	if (filled_slots > buffer_depth)
+	if (filled_slots > buffer_depth) {
+		/* overflow */
 		return -EOVERFLOW;
+	}
 
-	return empty_slots;
+	return (s32) empty_slots;
 }
 
 /**
@@ -179,6 +179,7 @@ int mei_write_message(struct mei_device *dev,
 	if ((dev->me_hw_state & ME_RDY_HRA) != ME_RDY_HRA)
 		return 0;
 
+	dev->write_hang = 0;
 	return 1;
 }
 
@@ -189,7 +190,7 @@ int mei_write_message(struct mei_device *dev,
  *
  * returns -1(ESLOTS_OVERFLOW) if overflow, otherwise filled slots count
  */
-int mei_count_full_read_slots(struct mei_device *dev)
+s32 mei_count_full_read_slots(struct mei_device *dev)
 {
 	char read_ptr, write_ptr;
 	unsigned char buffer_depth, filled_slots;
@@ -200,12 +201,13 @@ int mei_count_full_read_slots(struct mei_device *dev)
 	write_ptr = (char) ((dev->me_hw_state & ME_CBWP_HRA) >> 16);
 	filled_slots = (unsigned char) (write_ptr - read_ptr);
 
-	/* check for overflow */
-	if (filled_slots > buffer_depth)
+	if (filled_slots > buffer_depth) {
+		/* overflow */
 		return -EOVERFLOW;
+	}
 
 	dev_dbg(&dev->pdev->dev, "filled_slots =%08x\n", filled_slots);
-	return (int)filled_slots;
+	return (s32) filled_slots;
 }
 
 /**
@@ -245,81 +247,78 @@ void mei_read_slots(struct mei_device *dev,
  * mei_flow_ctrl_creds - checks flow_control credentials.
  *
  * @dev: the device structure
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  *
  * returns 1 if mei_flow_ctrl_creds >0, 0 - otherwise.
- *	-ENOENT if mei_cl is not present
- *	-EINVAL if single_recv_buf == 0
  */
-int mei_flow_ctrl_creds(struct mei_device *dev, struct mei_cl *cl)
+int mei_flow_ctrl_creds(struct mei_device *dev,
+				   struct mei_file_private *file_ext)
 {
 	int i;
 
-	if (!dev->me_clients_num)
+	if (!dev->num_mei_me_clients)
+		return 0;
+
+	if (file_ext == NULL)
 		return 0;
 
-	if (cl->mei_flow_ctrl_creds > 0)
+	if (file_ext->mei_flow_ctrl_creds > 0)
 		return 1;
 
-	for (i = 0; i < dev->me_clients_num; i++) {
-		struct mei_me_client  *me_cl = &dev->me_clients[i];
-		if (me_cl->client_id == cl->me_client_id) {
-			if (me_cl->mei_flow_ctrl_creds) {
-				if (WARN_ON(me_cl->props.single_recv_buf == 0))
-					return -EINVAL;
+	for (i = 0; i < dev->num_mei_me_clients; i++) {
+		if (dev->me_clients[i].client_id == file_ext->me_client_id) {
+			if (dev->me_clients[i].mei_flow_ctrl_creds > 0) {
+				BUG_ON(dev->me_clients[i].props.single_recv_buf
+					 == 0);
 				return 1;
-			} else {
-				return 0;
 			}
+			return 0;
 		}
 	}
-	return -ENOENT;
+	BUG();
+	return 0;
 }
 
 /**
  * mei_flow_ctrl_reduce - reduces flow_control.
  *
  * @dev: the device structure
- * @cl: private data of the file object
- * @returns
- *	0 on success
- *	-ENOENT when me client is not found
- *	-EINVAL wehn ctrl credits are <= 0
+ * @file_ext: private data of the file object
  */
-int mei_flow_ctrl_reduce(struct mei_device *dev, struct mei_cl *cl)
+void mei_flow_ctrl_reduce(struct mei_device *dev,
+			 struct mei_file_private *file_ext)
 {
 	int i;
 
-	if (!dev->me_clients_num)
-		return -ENOENT;
+	if (!dev->num_mei_me_clients)
+		return;
 
-	for (i = 0; i < dev->me_clients_num; i++) {
-		struct mei_me_client  *me_cl = &dev->me_clients[i];
-		if (me_cl->client_id == cl->me_client_id) {
-			if (me_cl->props.single_recv_buf != 0) {
-				if (WARN_ON(me_cl->mei_flow_ctrl_creds <= 0))
-					return -EINVAL;
+	for (i = 0; i < dev->num_mei_me_clients; i++) {
+		if (dev->me_clients[i].client_id == file_ext->me_client_id) {
+			if (dev->me_clients[i].props.single_recv_buf != 0) {
+				BUG_ON(dev->me_clients[i].mei_flow_ctrl_creds
+						<= 0);
 				dev->me_clients[i].mei_flow_ctrl_creds--;
 			} else {
-				if (WARN_ON(cl->mei_flow_ctrl_creds <= 0))
-					return -EINVAL;
-				cl->mei_flow_ctrl_creds--;
+				BUG_ON(file_ext->mei_flow_ctrl_creds <= 0);
+				file_ext->mei_flow_ctrl_creds--;
 			}
-			return 0;
+			return;
 		}
 	}
-	return -ENOENT;
+	BUG();
 }
 
 /**
  * mei_send_flow_control - sends flow control to fw.
  *
  * @dev: the device structure
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  *
  * returns 1 if success, 0 - otherwise.
  */
-int mei_send_flow_control(struct mei_device *dev, struct mei_cl *cl)
+int mei_send_flow_control(struct mei_device *dev,
+				 struct mei_file_private *file_ext)
 {
 	struct mei_msg_hdr *mei_hdr;
 	struct hbm_flow_control *mei_flow_control;
@@ -333,13 +332,13 @@ int mei_send_flow_control(struct mei_device *dev, struct mei_cl *cl)
 
 	mei_flow_control = (struct hbm_flow_control *) &dev->wr_msg_buf[1];
 	memset(mei_flow_control, 0, sizeof(mei_flow_control));
-	mei_flow_control->host_addr = cl->host_client_id;
-	mei_flow_control->me_addr = cl->me_client_id;
+	mei_flow_control->host_addr = file_ext->host_client_id;
+	mei_flow_control->me_addr = file_ext->me_client_id;
 	mei_flow_control->cmd.cmd = MEI_FLOW_CONTROL_CMD;
 	memset(mei_flow_control->reserved, 0,
 			sizeof(mei_flow_control->reserved));
 	dev_dbg(&dev->pdev->dev, "sending flow control host client = %d, ME client = %d\n",
-	    cl->host_client_id, cl->me_client_id);
+	    file_ext->host_client_id, file_ext->me_client_id);
 	if (!mei_write_message(dev, mei_hdr,
 				(unsigned char *) mei_flow_control,
 				sizeof(struct hbm_flow_control)))
@@ -354,20 +353,20 @@ int mei_send_flow_control(struct mei_device *dev, struct mei_cl *cl)
  *    client with the same client id is connected.
  *
  * @dev: the device structure
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  *
  * returns 1 if other client is connected, 0 - otherwise.
  */
 int mei_other_client_is_connecting(struct mei_device *dev,
-				struct mei_cl *cl)
+		struct mei_file_private *file_ext)
 {
-	struct mei_cl *cl_pos = NULL;
-	struct mei_cl *cl_next = NULL;
+	struct mei_file_private *file_pos = NULL;
+	struct mei_file_private *file_next = NULL;
 
-	list_for_each_entry_safe(cl_pos, cl_next, &dev->file_list, link) {
-		if ((cl_pos->state == MEI_FILE_CONNECTING) &&
-			(cl_pos != cl) &&
-			cl->me_client_id == cl_pos->me_client_id)
+	list_for_each_entry_safe(file_pos, file_next, &dev->file_list, link) {
+		if ((file_pos->state == MEI_FILE_CONNECTING) &&
+			(file_pos != file_ext) &&
+			file_ext->me_client_id == file_pos->me_client_id)
 			return 1;
 
 	}
@@ -375,14 +374,46 @@ int mei_other_client_is_connecting(struct mei_device *dev,
 }
 
 /**
+ * mei_send_wd - sends watch dog message to fw.
+ *
+ * @dev: the device structure
+ *
+ * returns 1 if success, 0 - otherwise.
+ */
+int mei_send_wd(struct mei_device *dev)
+{
+	struct mei_msg_hdr *mei_hdr;
+
+	mei_hdr = (struct mei_msg_hdr *) &dev->wr_msg_buf[0];
+	mei_hdr->host_addr = dev->wd_file_ext.host_client_id;
+	mei_hdr->me_addr = dev->wd_file_ext.me_client_id;
+	mei_hdr->msg_complete = 1;
+	mei_hdr->reserved = 0;
+
+	if (!memcmp(dev->wd_data, mei_start_wd_params, MEI_WD_PARAMS_SIZE)) {
+		mei_hdr->length = MEI_START_WD_DATA_SIZE;
+	} else {
+		BUG_ON(memcmp(dev->wd_data, mei_stop_wd_params,
+			MEI_WD_PARAMS_SIZE));
+		mei_hdr->length = MEI_WD_PARAMS_SIZE;
+	}
+
+	if (!mei_write_message(dev, mei_hdr, dev->wd_data, mei_hdr->length))
+		return 0;
+
+	return 1;
+}
+
+/**
  * mei_disconnect - sends disconnect message to fw.
  *
  * @dev: the device structure
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  *
  * returns 1 if success, 0 - otherwise.
  */
-int mei_disconnect(struct mei_device *dev, struct mei_cl *cl)
+int mei_disconnect(struct mei_device *dev,
+			  struct mei_file_private *file_ext)
 {
 	struct mei_msg_hdr *mei_hdr;
 	struct hbm_client_disconnect_request *mei_cli_disconnect;
@@ -397,8 +428,8 @@ int mei_disconnect(struct mei_device *dev, struct mei_cl *cl)
 	mei_cli_disconnect =
 	    (struct hbm_client_disconnect_request *) &dev->wr_msg_buf[1];
 	memset(mei_cli_disconnect, 0, sizeof(mei_cli_disconnect));
-	mei_cli_disconnect->host_addr = cl->host_client_id;
-	mei_cli_disconnect->me_addr = cl->me_client_id;
+	mei_cli_disconnect->host_addr = file_ext->host_client_id;
+	mei_cli_disconnect->me_addr = file_ext->me_client_id;
 	mei_cli_disconnect->cmd.cmd = CLIENT_DISCONNECT_REQ_CMD;
 	mei_cli_disconnect->reserved[0] = 0;
 
@@ -414,11 +445,12 @@ int mei_disconnect(struct mei_device *dev, struct mei_cl *cl)
  * mei_connect - sends connect message to fw.
  *
  * @dev: the device structure
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  *
  * returns 1 if success, 0 - otherwise.
  */
-int mei_connect(struct mei_device *dev, struct mei_cl *cl)
+int mei_connect(struct mei_device *dev,
+		       struct mei_file_private *file_ext)
 {
 	struct mei_msg_hdr *mei_hdr;
 	struct hbm_client_connect_request *mei_cli_connect;
@@ -432,8 +464,8 @@ int mei_connect(struct mei_device *dev, struct mei_cl *cl)
 
 	mei_cli_connect =
 	    (struct hbm_client_connect_request *) &dev->wr_msg_buf[1];
-	mei_cli_connect->host_addr = cl->host_client_id;
-	mei_cli_connect->me_addr = cl->me_client_id;
+	mei_cli_connect->host_addr = file_ext->host_client_id;
+	mei_cli_connect->me_addr = file_ext->me_client_id;
 	mei_cli_connect->cmd.cmd = CLIENT_CONNECT_REQ_CMD;
 	mei_cli_connect->reserved = 0;
 
diff --git a/drivers/staging/mei/interface.h b/drivers/staging/mei/interface.h
index d0bf5cf..e1b90f7 100644
--- a/drivers/staging/mei/interface.h
+++ b/drivers/staging/mei/interface.h
@@ -19,8 +19,35 @@
 #ifndef _MEI_INTERFACE_H_
 #define _MEI_INTERFACE_H_
 
-#include "mei.h"
-#include "mei_dev.h"
+#include "hw.h"
+
+
+#define HBM_MINOR_VERSION                   0
+#define HBM_MAJOR_VERSION                   1
+#define HBM_TIMEOUT                         1	/* 1 second */
+
+
+#define HOST_START_REQ_CMD                  0x01
+#define HOST_START_RES_CMD                  0x81
+
+#define HOST_STOP_REQ_CMD                   0x02
+#define HOST_STOP_RES_CMD                   0x82
+
+#define ME_STOP_REQ_CMD                     0x03
+
+#define HOST_ENUM_REQ_CMD                   0x04
+#define HOST_ENUM_RES_CMD                   0x84
+
+#define HOST_CLIENT_PROPERTIES_REQ_CMD      0x05
+#define HOST_CLIENT_PROPERTIES_RES_CMD      0x85
+
+#define CLIENT_CONNECT_REQ_CMD              0x06
+#define CLIENT_CONNECT_RES_CMD              0x86
+
+#define CLIENT_DISCONNECT_REQ_CMD           0x07
+#define CLIENT_DISCONNECT_RES_CMD           0x87
+
+#define MEI_FLOW_CONTROL_CMD               0x08
 
 
 #define AMT_WD_VALUE 120	/* seconds */
@@ -30,6 +57,35 @@
 #define MEI_WD_PARAMS_SIZE             4
 
 
+enum mei_stop_reason_types {
+	DRIVER_STOP_REQUEST = 0x00,
+	DEVICE_D1_ENTRY = 0x01,
+	DEVICE_D2_ENTRY = 0x02,
+	DEVICE_D3_ENTRY = 0x03,
+	SYSTEM_S1_ENTRY = 0x04,
+	SYSTEM_S2_ENTRY = 0x05,
+	SYSTEM_S3_ENTRY = 0x06,
+	SYSTEM_S4_ENTRY = 0x07,
+	SYSTEM_S5_ENTRY = 0x08
+};
+
+enum me_stop_reason_types {
+	FW_UPDATE = 0x00
+};
+
+enum client_connect_status_types {
+	CCS_SUCCESS = 0x00,
+	CCS_NOT_FOUND = 0x01,
+	CCS_ALREADY_STARTED = 0x02,
+	CCS_OUT_OF_RESOURCES = 0x03,
+	CCS_MESSAGE_SMALL = 0x04
+};
+
+enum client_disconnect_status_types {
+	CDS_SUCCESS = 0x00
+};
+
+
 void mei_read_slots(struct mei_device *dev,
 		     unsigned char *buffer, unsigned long buffer_length);
 
@@ -40,23 +96,26 @@ int mei_write_message(struct mei_device *dev,
 
 int mei_host_buffer_is_empty(struct mei_device *dev);
 
-int mei_count_full_read_slots(struct mei_device *dev);
+s32 mei_count_full_read_slots(struct mei_device *dev);
 
-int mei_count_empty_write_slots(struct mei_device *dev);
+s32 mei_count_empty_write_slots(struct mei_device *dev);
 
-int mei_flow_ctrl_creds(struct mei_device *dev, struct mei_cl *cl);
+int mei_flow_ctrl_creds(struct mei_device *dev,
+				   struct mei_file_private *file_ext);
 
-int mei_wd_send(struct mei_device *dev);
-int mei_wd_stop(struct mei_device *dev, bool preserve);
-void mei_wd_host_init(struct mei_device *dev);
-void mei_wd_start_setup(struct mei_device *dev);
+int mei_send_wd(struct mei_device *dev);
 
-int mei_flow_ctrl_reduce(struct mei_device *dev, struct mei_cl *cl);
+void mei_flow_ctrl_reduce(struct mei_device *dev,
+			 struct mei_file_private *file_ext);
 
-int mei_send_flow_control(struct mei_device *dev, struct mei_cl *cl);
+int mei_send_flow_control(struct mei_device *dev,
+				 struct mei_file_private *file_ext);
 
-int mei_disconnect(struct mei_device *dev, struct mei_cl *cl);
-int mei_other_client_is_connecting(struct mei_device *dev, struct mei_cl *cl);
-int mei_connect(struct mei_device *dev, struct mei_cl *cl);
+int mei_disconnect(struct mei_device *dev,
+			  struct mei_file_private *file_ext);
+int mei_other_client_is_connecting(struct mei_device *dev,
+				     struct mei_file_private *file_ext);
+int mei_connect(struct mei_device *dev,
+		       struct mei_file_private *file_ext);
 
 #endif /* _MEI_INTERFACE_H_ */
diff --git a/drivers/staging/mei/interrupt.c b/drivers/staging/mei/interrupt.c
index 9cb186b..394726b 100644
--- a/drivers/staging/mei/interrupt.c
+++ b/drivers/staging/mei/interrupt.c
@@ -21,7 +21,6 @@
 #include <linux/fs.h>
 #include <linux/jiffies.h>
 
-#include "mei_dev.h"
 #include "mei.h"
 #include "hw.h"
 #include "interface.h"
@@ -52,23 +51,24 @@ irqreturn_t mei_interrupt_quick_handler(int irq, void *dev_id)
 /**
  * _mei_cmpl - processes completed operation.
  *
- * @cl: private data of the file object.
- * @cb_pos: callback block.
+ * @file_ext: private data of the file object.
+ * @priv_cb_pos: callback block.
  */
-static void _mei_cmpl(struct mei_cl *cl, struct mei_cl_cb *cb_pos)
+static void _mei_cmpl(struct mei_file_private *file_ext,
+				struct mei_cb_private *priv_cb_pos)
 {
-	if (cb_pos->major_file_operations == MEI_WRITE) {
-		mei_free_cb_private(cb_pos);
-		cb_pos = NULL;
-		cl->writing_state = MEI_WRITE_COMPLETE;
-		if (waitqueue_active(&cl->tx_wait))
-			wake_up_interruptible(&cl->tx_wait);
-
-	} else if (cb_pos->major_file_operations == MEI_READ &&
-			MEI_READING == cl->reading_state) {
-		cl->reading_state = MEI_READ_COMPLETE;
-		if (waitqueue_active(&cl->rx_wait))
-			wake_up_interruptible(&cl->rx_wait);
+	if (priv_cb_pos->major_file_operations == MEI_WRITE) {
+		mei_free_cb_private(priv_cb_pos);
+		priv_cb_pos = NULL;
+		file_ext->writing_state = MEI_WRITE_COMPLETE;
+		if (waitqueue_active(&file_ext->tx_wait))
+			wake_up_interruptible(&file_ext->tx_wait);
+
+	} else if (priv_cb_pos->major_file_operations == MEI_READ &&
+			MEI_READING == file_ext->reading_state) {
+		file_ext->reading_state = MEI_READ_COMPLETE;
+		if (waitqueue_active(&file_ext->rx_wait))
+			wake_up_interruptible(&file_ext->rx_wait);
 
 	}
 }
@@ -77,28 +77,28 @@ static void _mei_cmpl(struct mei_cl *cl, struct mei_cl_cb *cb_pos)
  * _mei_cmpl_iamthif - processes completed iamthif operation.
  *
  * @dev: the device structure.
- * @cb_pos: callback block.
+ * @priv_cb_pos: callback block.
  */
-static void _mei_cmpl_iamthif(struct mei_device *dev, struct mei_cl_cb *cb_pos)
+static void _mei_cmpl_iamthif(struct mei_device *dev,
+				struct mei_cb_private *priv_cb_pos)
 {
 	if (dev->iamthif_canceled != 1) {
 		dev->iamthif_state = MEI_IAMTHIF_READ_COMPLETE;
 		dev->iamthif_stall_timer = 0;
-		memcpy(cb_pos->response_buffer.data,
+		memcpy(priv_cb_pos->response_buffer.data,
 				dev->iamthif_msg_buf,
 				dev->iamthif_msg_buf_index);
-		list_add_tail(&cb_pos->cb_list,
+		list_add_tail(&priv_cb_pos->cb_list,
 				&dev->amthi_read_complete_list.mei_cb.cb_list);
 		dev_dbg(&dev->pdev->dev, "amthi read completed.\n");
 		dev->iamthif_timer = jiffies;
-		dev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n",
-				dev->iamthif_timer);
+		dev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n", dev->iamthif_timer);
 	} else {
-		mei_run_next_iamthif_cmd(dev);
+		run_next_iamthif_cmd(dev);
 	}
 
 	dev_dbg(&dev->pdev->dev, "completing amthi call back.\n");
-	wake_up_interruptible(&dev->iamthif_cl.wait);
+	wake_up_interruptible(&dev->iamthif_file_ext.wait);
 }
 
 
@@ -112,15 +112,15 @@ static void _mei_cmpl_iamthif(struct mei_device *dev, struct mei_cl_cb *cb_pos)
  *
  * returns 0 on success, <0 on failure.
  */
-static int mei_irq_thread_read_amthi_message(struct mei_io_list *complete_list,
+static int mei_irq_thread_read_amthi_message(struct io_mei_list *complete_list,
 		struct mei_device *dev,
 		struct mei_msg_hdr *mei_hdr)
 {
-	struct mei_cl *cl;
-	struct mei_cl_cb *cb;
+	struct mei_file_private *file_ext;
+	struct mei_cb_private *priv_cb;
 	unsigned char *buffer;
 
-	BUG_ON(mei_hdr->me_addr != dev->iamthif_cl.me_client_id);
+	BUG_ON(mei_hdr->me_addr != dev->iamthif_file_ext.me_client_id);
 	BUG_ON(dev->iamthif_state != MEI_IAMTHIF_READING);
 
 	buffer = (unsigned char *) (dev->iamthif_msg_buf +
@@ -142,21 +142,21 @@ static int mei_irq_thread_read_amthi_message(struct mei_io_list *complete_list,
 	if (!dev->iamthif_current_cb)
 		return -ENODEV;
 
-	cb = dev->iamthif_current_cb;
+	priv_cb = dev->iamthif_current_cb;
 	dev->iamthif_current_cb = NULL;
 
-	cl = (struct mei_cl *)cb->file_private;
-	if (!cl)
+	file_ext = (struct mei_file_private *)priv_cb->file_private;
+	if (!file_ext)
 		return -ENODEV;
 
 	dev->iamthif_stall_timer = 0;
-	cb->information =	dev->iamthif_msg_buf_index;
-	cb->read_time = jiffies;
-	if (dev->iamthif_ioctl && cl == &dev->iamthif_cl) {
+	priv_cb->information =	dev->iamthif_msg_buf_index;
+	priv_cb->read_time = jiffies;
+	if (dev->iamthif_ioctl && file_ext == &dev->iamthif_file_ext) {
 		/* found the iamthif cb */
 		dev_dbg(&dev->pdev->dev, "complete the amthi read cb.\n ");
 		dev_dbg(&dev->pdev->dev, "add the amthi read cb to complete.\n ");
-		list_add_tail(&cb->cb_list,
+		list_add_tail(&priv_cb->cb_list,
 						&complete_list->mei_cb.cb_list);
 	}
 	return 0;
@@ -165,18 +165,18 @@ static int mei_irq_thread_read_amthi_message(struct mei_io_list *complete_list,
 /**
  * _mei_irq_thread_state_ok - checks if mei header matches file private data
  *
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  * @mei_hdr: header of mei client message
  *
  * returns !=0 if matches, 0 if no match.
  */
-static int _mei_irq_thread_state_ok(struct mei_cl *cl,
-				struct mei_msg_hdr *mei_hdr)
+static int _mei_irq_thread_state_ok(struct mei_file_private *file_ext,
+					struct mei_msg_hdr *mei_hdr)
 {
-	return (cl->host_client_id == mei_hdr->host_addr &&
-		cl->me_client_id == mei_hdr->me_addr &&
-		cl->state == MEI_FILE_CONNECTED &&
-		MEI_READ_COMPLETE != cl->reading_state);
+	return (file_ext->host_client_id == mei_hdr->host_addr &&
+		file_ext->me_client_id == mei_hdr->me_addr &&
+		file_ext->state == MEI_FILE_CONNECTED &&
+		MEI_READ_COMPLETE != file_ext->reading_state);
 }
 
 /**
@@ -189,57 +189,58 @@ static int _mei_irq_thread_state_ok(struct mei_cl *cl,
  *
  * returns 0 on success, <0 on failure.
  */
-static int mei_irq_thread_read_client_message(struct mei_io_list *complete_list,
+static int mei_irq_thread_read_client_message(struct io_mei_list *complete_list,
 		struct mei_device *dev,
 		struct mei_msg_hdr *mei_hdr)
 {
-	struct mei_cl *cl;
-	struct mei_cl_cb *cb_pos = NULL, *cb_next = NULL;
-	unsigned char *buffer = NULL;
+	struct mei_file_private *file_ext;
+	struct mei_cb_private *priv_cb_pos = NULL, *priv_cb_next = NULL;
+	unsigned char *buffer;
 
 	dev_dbg(&dev->pdev->dev, "start client msg\n");
 	if (!(dev->read_list.status == 0 &&
 	      !list_empty(&dev->read_list.mei_cb.cb_list)))
 		goto quit;
 
-	list_for_each_entry_safe(cb_pos, cb_next,
+	list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 			&dev->read_list.mei_cb.cb_list, cb_list) {
-		cl = (struct mei_cl *)cb_pos->file_private;
-		if (cl && _mei_irq_thread_state_ok(cl, mei_hdr)) {
-			cl->reading_state = MEI_READING;
+		file_ext = (struct mei_file_private *)priv_cb_pos->file_private;
+		if (file_ext && _mei_irq_thread_state_ok(file_ext, mei_hdr)) {
+			file_ext->reading_state = MEI_READING;
 			buffer = (unsigned char *)
-				(cb_pos->response_buffer.data +
-				cb_pos->information);
-			BUG_ON(cb_pos->response_buffer.size <
+				(priv_cb_pos->response_buffer.data +
+				priv_cb_pos->information);
+			BUG_ON(priv_cb_pos->response_buffer.size <
 					mei_hdr->length +
-					cb_pos->information);
+					priv_cb_pos->information);
 
-			if (cb_pos->response_buffer.size <
-					mei_hdr->length + cb_pos->information) {
+			if (priv_cb_pos->response_buffer.size <
+					mei_hdr->length +
+					priv_cb_pos->information) {
 				dev_dbg(&dev->pdev->dev, "message overflow.\n");
-				list_del(&cb_pos->cb_list);
+				list_del(&priv_cb_pos->cb_list);
 				return -ENOMEM;
 			}
 			if (buffer)
 				mei_read_slots(dev, buffer, mei_hdr->length);
 
-			cb_pos->information += mei_hdr->length;
+			priv_cb_pos->information += mei_hdr->length;
 			if (mei_hdr->msg_complete) {
-				cl->status = 0;
-				list_del(&cb_pos->cb_list);
+				file_ext->status = 0;
+				list_del(&priv_cb_pos->cb_list);
 				dev_dbg(&dev->pdev->dev,
 					"completed read host client = %d,"
 					"ME client = %d, "
 					"data length = %lu\n",
-					cl->host_client_id,
-					cl->me_client_id,
-					cb_pos->information);
-
-				*(cb_pos->response_buffer.data +
-					cb_pos->information) = '\0';
-				dev_dbg(&dev->pdev->dev, "cb_pos->res_buffer - %s\n",
-					cb_pos->response_buffer.data);
-				list_add_tail(&cb_pos->cb_list,
+					file_ext->host_client_id,
+					file_ext->me_client_id,
+					priv_cb_pos->information);
+
+				*(priv_cb_pos->response_buffer.data +
+					priv_cb_pos->information) = '\0';
+				dev_dbg(&dev->pdev->dev, "priv_cb_pos->res_buffer - %s\n",
+					priv_cb_pos->response_buffer.data);
+				list_add_tail(&priv_cb_pos->cb_list,
 					&complete_list->mei_cb.cb_list);
 			}
 
@@ -275,14 +276,15 @@ static int _mei_irq_thread_iamthif_read(struct mei_device *dev, s32 *slots)
 			+ sizeof(struct hbm_flow_control))) {
 		*slots -= (sizeof(struct mei_msg_hdr) +
 				sizeof(struct hbm_flow_control) + 3) / 4;
-		if (!mei_send_flow_control(dev, &dev->iamthif_cl)) {
+		if (!mei_send_flow_control(dev, &dev->iamthif_file_ext)) {
 			dev_dbg(&dev->pdev->dev, "iamthif flow control failed\n");
 		} else {
 			dev_dbg(&dev->pdev->dev, "iamthif flow control success\n");
 			dev->iamthif_state = MEI_IAMTHIF_READING;
-			dev->iamthif_flow_control_pending = false;
+			dev->iamthif_flow_control_pending = 0;
 			dev->iamthif_msg_buf_index = 0;
 			dev->iamthif_msg_buf_size = 0;
+			pr_debug("Settings AMTHI STALL Timer = %d\n", IAMTHIF_STALL_TIMER);
 			dev->iamthif_stall_timer = IAMTHIF_STALL_TIMER;
 			dev->mei_host_buffer_is_empty =
 					mei_host_buffer_is_empty(dev);
@@ -298,35 +300,35 @@ static int _mei_irq_thread_iamthif_read(struct mei_device *dev, s32 *slots)
  *
  * @dev: the device structure.
  * @slots: free slots.
- * @cb_pos: callback block.
- * @cl: private data of the file object.
+ * @priv_cb_pos: callback block.
+ * @file_ext: private data of the file object.
  * @cmpl_list: complete list.
  *
  * returns 0, OK; otherwise, error.
  */
-static int _mei_irq_thread_close(struct mei_device *dev, s32 *slots,
-				struct mei_cl_cb *cb_pos,
-				struct mei_cl *cl,
-				struct mei_io_list *cmpl_list)
+static int _mei_irq_thread_close(struct mei_device *dev,	s32 *slots,
+			struct mei_cb_private *priv_cb_pos,
+			struct mei_file_private *file_ext,
+			struct io_mei_list *cmpl_list)
 {
 	if ((*slots * sizeof(u32)) >= (sizeof(struct mei_msg_hdr) +
 			sizeof(struct hbm_client_disconnect_request))) {
 		*slots -= (sizeof(struct mei_msg_hdr) +
 			sizeof(struct hbm_client_disconnect_request) + 3) / 4;
 
-		if (!mei_disconnect(dev, cl)) {
-			cl->status = 0;
-			cb_pos->information = 0;
-			list_move_tail(&cb_pos->cb_list,
+		if (!mei_disconnect(dev, file_ext)) {
+			file_ext->status = 0;
+			priv_cb_pos->information = 0;
+			list_move_tail(&priv_cb_pos->cb_list,
 					&cmpl_list->mei_cb.cb_list);
 			return -EMSGSIZE;
 		} else {
-			cl->state = MEI_FILE_DISCONNECTING;
-			cl->status = 0;
-			cb_pos->information = 0;
-			list_move_tail(&cb_pos->cb_list,
+			file_ext->state = MEI_FILE_DISCONNECTING;
+			file_ext->status = 0;
+			priv_cb_pos->information = 0;
+			list_move_tail(&priv_cb_pos->cb_list,
 					&dev->ctrl_rd_list.mei_cb.cb_list);
-			cl->timer_count = MEI_CONNECT_TIMEOUT;
+			file_ext->timer_count = MEI_CONNECT_TIMEOUT;
 		}
 	} else {
 		/* return the cancel routine */
@@ -340,25 +342,25 @@ static int _mei_irq_thread_close(struct mei_device *dev, s32 *slots,
  * is_treat_specially_client - checks if the message belongs
  * to the file private data.
  *
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  * @rs: connect response bus message
  *
  */
-static bool is_treat_specially_client(struct mei_cl *cl,
+static bool is_treat_specially_client(struct mei_file_private *file_ext,
 		struct hbm_client_connect_response *rs)
 {
 
-	if (cl->host_client_id == rs->host_addr &&
-	    cl->me_client_id == rs->me_addr) {
+	if (file_ext->host_client_id == rs->host_addr &&
+	    file_ext->me_client_id == rs->me_addr) {
 		if (!rs->status) {
-			cl->state = MEI_FILE_CONNECTED;
-			cl->status = 0;
+			file_ext->state = MEI_FILE_CONNECTED;
+			file_ext->status = 0;
 
 		} else {
-			cl->state = MEI_FILE_DISCONNECTED;
-			cl->status = -ENODEV;
+			file_ext->state = MEI_FILE_DISCONNECTED;
+			file_ext->status = -ENODEV;
 		}
-		cl->timer_count = 0;
+		file_ext->timer_count = 0;
 
 		return true;
 	}
@@ -375,8 +377,10 @@ static void mei_client_connect_response(struct mei_device *dev,
 		struct hbm_client_connect_response *rs)
 {
 
-	struct mei_cl *cl;
-	struct mei_cl_cb *cb_pos = NULL, *cb_next = NULL;
+	struct mei_file_private *file_ext;
+	struct mei_cb_private *priv_cb_pos = NULL, *priv_cb_next = NULL;
+
+	BUG_ON(rs == NULL);
 
 	dev_dbg(&dev->pdev->dev,
 			"connect_response:\n"
@@ -389,35 +393,37 @@ static void mei_client_connect_response(struct mei_device *dev,
 
 	/* if WD or iamthif client treat specially */
 
-	if (is_treat_specially_client(&(dev->wd_cl), rs)) {
-		dev_dbg(&dev->pdev->dev, "dev->wd_timeout =%d.\n",
+	if (is_treat_specially_client(&(dev->wd_file_ext), rs)) {
+		dev_dbg(&dev->pdev->dev,
+				"dev->wd_timeout =%d.\n",
 				dev->wd_timeout);
 
 		dev->wd_due_counter = (dev->wd_timeout) ? 1 : 0;
 
 		dev_dbg(&dev->pdev->dev, "successfully connected to WD client.\n");
-		mei_host_init_iamthif(dev);
+		host_init_iamthif(dev);
 		return;
 	}
 
-	if (is_treat_specially_client(&(dev->iamthif_cl), rs)) {
+	if (is_treat_specially_client(&(dev->iamthif_file_ext), rs)) {
 		dev->iamthif_state = MEI_IAMTHIF_IDLE;
 		return;
 	}
 	if (!dev->ctrl_rd_list.status &&
 	    !list_empty(&dev->ctrl_rd_list.mei_cb.cb_list)) {
-		list_for_each_entry_safe(cb_pos, cb_next,
+		list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 			&dev->ctrl_rd_list.mei_cb.cb_list, cb_list) {
-			cl = (struct mei_cl *)cb_pos->file_private;
-			if (!cl) {
-				list_del(&cb_pos->cb_list);
+			file_ext = (struct mei_file_private *)
+					priv_cb_pos->file_private;
+			if (!file_ext) {
+				list_del(&priv_cb_pos->cb_list);
 				return;
 			}
-			if (MEI_IOCTL == cb_pos->major_file_operations) {
-				if (is_treat_specially_client(cl, rs)) {
-					list_del(&cb_pos->cb_list);
-					cl->status = 0;
-					cl->timer_count = 0;
+			if (MEI_IOCTL == priv_cb_pos->major_file_operations) {
+				if (is_treat_specially_client(file_ext, rs)) {
+					list_del(&priv_cb_pos->cb_list);
+					file_ext->status = 0;
+					file_ext->timer_count = 0;
 					break;
 				}
 			}
@@ -434,8 +440,10 @@ static void mei_client_connect_response(struct mei_device *dev,
 static void mei_client_disconnect_response(struct mei_device *dev,
 					struct hbm_client_connect_response *rs)
 {
-	struct mei_cl *cl;
-	struct mei_cl_cb *cb_pos = NULL, *cb_next = NULL;
+	struct mei_file_private *file_ext;
+	struct mei_cb_private *priv_cb_pos = NULL, *priv_cb_next = NULL;
+
+	BUG_ON(rs == NULL);
 
 	dev_dbg(&dev->pdev->dev,
 			"disconnect_response:\n"
@@ -448,25 +456,26 @@ static void mei_client_disconnect_response(struct mei_device *dev,
 
 	if (!dev->ctrl_rd_list.status &&
 	    !list_empty(&dev->ctrl_rd_list.mei_cb.cb_list)) {
-		list_for_each_entry_safe(cb_pos, cb_next,
+		list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 				&dev->ctrl_rd_list.mei_cb.cb_list, cb_list) {
-			cl = (struct mei_cl *)cb_pos->file_private;
+			file_ext = (struct mei_file_private *)
+				priv_cb_pos->file_private;
 
-			if (!cl) {
-				list_del(&cb_pos->cb_list);
+			if (!file_ext) {
+				list_del(&priv_cb_pos->cb_list);
 				return;
 			}
 
 			dev_dbg(&dev->pdev->dev, "list_for_each_entry_safe in ctrl_rd_list.\n");
-			if (cl->host_client_id == rs->host_addr &&
-			    cl->me_client_id == rs->me_addr) {
+			if (file_ext->host_client_id == rs->host_addr &&
+			    file_ext->me_client_id == rs->me_addr) {
 
-				list_del(&cb_pos->cb_list);
+				list_del(&priv_cb_pos->cb_list);
 				if (!rs->status)
-					cl->state = MEI_FILE_DISCONNECTED;
+					file_ext->state = MEI_FILE_DISCONNECTED;
 
-				cl->status = 0;
-				cl->timer_count = 0;
+				file_ext->status = 0;
+				file_ext->timer_count = 0;
 				break;
 			}
 		}
@@ -481,10 +490,11 @@ static void mei_client_disconnect_response(struct mei_device *dev,
  *
  * returns  !=0, same; 0,not.
  */
-static int same_flow_addr(struct mei_cl *cl, struct hbm_flow_control *flow)
+static int same_flow_addr(struct mei_file_private *file,
+			  struct hbm_flow_control *flow)
 {
-	return (cl->host_client_id == flow->host_addr &&
-		cl->me_client_id == flow->me_addr);
+	return (file->host_client_id == flow->host_addr &&
+		file->me_client_id == flow->me_addr);
 }
 
 /**
@@ -499,7 +509,7 @@ static void add_single_flow_creds(struct mei_device *dev,
 	struct mei_me_client *client;
 	int i;
 
-	for (i = 0; i < dev->me_clients_num; i++) {
+	for (i = 0; i < dev->num_mei_me_clients; i++) {
 		client = &dev->me_clients[i];
 		if (client && flow->me_addr == client->client_id) {
 			if (client->props.single_recv_buf) {
@@ -524,31 +534,31 @@ static void add_single_flow_creds(struct mei_device *dev,
 static void mei_client_flow_control_response(struct mei_device *dev,
 		struct hbm_flow_control *flow_control)
 {
-	struct mei_cl *cl_pos = NULL;
-	struct mei_cl *cl_next = NULL;
+	struct mei_file_private *file_pos = NULL;
+	struct mei_file_private *file_next = NULL;
 
 	if (!flow_control->host_addr) {
 		/* single receive buffer */
 		add_single_flow_creds(dev, flow_control);
 	} else {
 		/* normal connection */
-		list_for_each_entry_safe(cl_pos, cl_next,
+		list_for_each_entry_safe(file_pos, file_next,
 				&dev->file_list, link) {
 			dev_dbg(&dev->pdev->dev, "list_for_each_entry_safe in file_list\n");
 
-			dev_dbg(&dev->pdev->dev, "cl of host client %d ME client %d.\n",
-			    cl_pos->host_client_id,
-			    cl_pos->me_client_id);
+			dev_dbg(&dev->pdev->dev, "file_ext of host client %d ME client %d.\n",
+			    file_pos->host_client_id,
+			    file_pos->me_client_id);
 			dev_dbg(&dev->pdev->dev, "flow ctrl msg for host %d ME %d.\n",
 			    flow_control->host_addr,
 			    flow_control->me_addr);
-			if (same_flow_addr(cl_pos, flow_control)) {
+			if (same_flow_addr(file_pos, flow_control)) {
 				dev_dbg(&dev->pdev->dev, "recv ctrl msg for host  %d ME %d.\n",
 				    flow_control->host_addr,
 				    flow_control->me_addr);
-				cl_pos->mei_flow_ctrl_creds++;
+				file_pos->mei_flow_ctrl_creds++;
 				dev_dbg(&dev->pdev->dev, "flow control credentials = %d.\n",
-				    cl_pos->mei_flow_ctrl_creds);
+				    file_pos->mei_flow_ctrl_creds);
 				break;
 			}
 		}
@@ -563,11 +573,11 @@ static void mei_client_flow_control_response(struct mei_device *dev,
  *
  * returns !=0, same; 0,not.
  */
-static int same_disconn_addr(struct mei_cl *cl,
+static int same_disconn_addr(struct mei_file_private *file,
 			     struct hbm_client_disconnect_request *disconn)
 {
-	return (cl->host_client_id == disconn->host_addr &&
-		cl->me_client_id == disconn->me_addr);
+	return (file->host_client_id == disconn->host_addr &&
+		file->me_client_id == disconn->me_addr);
 }
 
 /**
@@ -581,20 +591,20 @@ static void mei_client_disconnect_request(struct mei_device *dev,
 {
 	struct mei_msg_hdr *mei_hdr;
 	struct hbm_client_connect_response *disconnect_res;
-	struct mei_cl *cl_pos = NULL;
-	struct mei_cl *cl_next = NULL;
+	struct mei_file_private *file_pos = NULL;
+	struct mei_file_private *file_next = NULL;
 
-	list_for_each_entry_safe(cl_pos, cl_next, &dev->file_list, link) {
-		if (same_disconn_addr(cl_pos, disconnect_req)) {
+	list_for_each_entry_safe(file_pos, file_next, &dev->file_list, link) {
+		if (same_disconn_addr(file_pos, disconnect_req)) {
 			dev_dbg(&dev->pdev->dev, "disconnect request host client %d ME client %d.\n",
 					disconnect_req->host_addr,
 					disconnect_req->me_addr);
-			cl_pos->state = MEI_FILE_DISCONNECTED;
-			cl_pos->timer_count = 0;
-			if (cl_pos == &dev->wd_cl) {
+			file_pos->state = MEI_FILE_DISCONNECTED;
+			file_pos->timer_count = 0;
+			if (file_pos == &dev->wd_file_ext) {
 				dev->wd_due_counter = 0;
-				dev->wd_pending = false;
-			} else if (cl_pos == &dev->iamthif_cl)
+				dev->wd_pending = 0;
+			} else if (file_pos == &dev->iamthif_file_ext)
 				dev->iamthif_timer = 0;
 
 			/* prepare disconnect response */
@@ -610,8 +620,8 @@ static void mei_client_disconnect_request(struct mei_device *dev,
 			disconnect_res =
 				(struct hbm_client_connect_response *)
 				&dev->ext_msg_buf[1];
-			disconnect_res->host_addr = cl_pos->host_client_id;
-			disconnect_res->me_addr = cl_pos->me_client_id;
+			disconnect_res->host_addr = file_pos->host_client_id;
+			disconnect_res->me_addr = file_pos->me_client_id;
 			*(u8 *) (&disconnect_res->cmd) =
 				CLIENT_DISCONNECT_RES_CMD;
 			disconnect_res->status = 0;
@@ -659,9 +669,8 @@ static void mei_irq_thread_read_bus_message(struct mei_device *dev,
 			if (dev->mei_state == MEI_INIT_CLIENTS &&
 			    dev->init_clients_state == MEI_START_MESSAGE) {
 				dev->init_clients_timer = 0;
-				mei_host_enum_clients_message(dev);
+				host_enum_clients_message(dev);
 			} else {
-				dev->recvd_msg = false;
 				dev_dbg(&dev->pdev->dev, "IMEI reset due to received host start response bus message.\n");
 				mei_reset(dev, 1);
 				return;
@@ -690,7 +699,7 @@ static void mei_irq_thread_read_bus_message(struct mei_device *dev,
 			return;
 		}
 
-		dev->recvd_msg = true;
+		dev->recvd_msg = 1;
 		dev_dbg(&dev->pdev->dev, "host start response message received.\n");
 		break;
 
@@ -734,7 +743,7 @@ static void mei_irq_thread_read_bus_message(struct mei_device *dev,
 					MEI_CLIENT_PROPERTIES_MESSAGE) {
 				dev->me_client_index++;
 				dev->me_client_presentation_num++;
-				mei_host_client_properties(dev);
+				host_client_properties(dev);
 			} else {
 				dev_dbg(&dev->pdev->dev, "reset due to received host client properties response bus message");
 				mei_reset(dev, 1);
@@ -755,10 +764,10 @@ static void mei_irq_thread_read_bus_message(struct mei_device *dev,
 				dev->init_clients_timer = 0;
 				dev->me_client_presentation_num = 0;
 				dev->me_client_index = 0;
-				mei_allocate_me_clients_storage(dev);
+				allocate_me_clients_storage(dev);
 				dev->init_clients_state =
 					MEI_CLIENT_PROPERTIES_MESSAGE;
-				mei_host_client_properties(dev);
+				host_client_properties(dev);
 		} else {
 			dev_dbg(&dev->pdev->dev, "reset due to received host enumeration clients response bus message.\n");
 			mei_reset(dev, 1);
@@ -810,34 +819,34 @@ static void mei_irq_thread_read_bus_message(struct mei_device *dev,
  *
  * @dev: the device structure.
  * @slots: free slots.
- * @cb_pos: callback block.
- * @cl: private data of the file object.
+ * @priv_cb_pos: callback block.
+ * @file_ext: private data of the file object.
  * @cmpl_list: complete list.
  *
  * returns 0, OK; otherwise, error.
  */
 static int _mei_irq_thread_read(struct mei_device *dev,	s32 *slots,
-			struct mei_cl_cb *cb_pos,
-			struct mei_cl *cl,
-			struct mei_io_list *cmpl_list)
+			struct mei_cb_private *priv_cb_pos,
+			struct mei_file_private *file_ext,
+			struct io_mei_list *cmpl_list)
 {
 	if ((*slots * sizeof(u32)) >= (sizeof(struct mei_msg_hdr) +
 			sizeof(struct hbm_flow_control))) {
 		*slots -= (sizeof(struct mei_msg_hdr) +
 			sizeof(struct hbm_flow_control) + 3) / 4;
-		if (!mei_send_flow_control(dev, cl)) {
-			cl->status = -ENODEV;
-			cb_pos->information = 0;
-			list_move_tail(&cb_pos->cb_list,
+		if (!mei_send_flow_control(dev, file_ext)) {
+			file_ext->status = -ENODEV;
+			priv_cb_pos->information = 0;
+			list_move_tail(&priv_cb_pos->cb_list,
 					&cmpl_list->mei_cb.cb_list);
 			return -ENODEV;
 		} else {
-			list_move_tail(&cb_pos->cb_list,
+			list_move_tail(&priv_cb_pos->cb_list,
 					&dev->read_list.mei_cb.cb_list);
 		}
 	} else {
 		/* return the cancel routine */
-		list_del(&cb_pos->cb_list);
+		list_del(&priv_cb_pos->cb_list);
 		return -EBADMSG;
 	}
 
@@ -850,35 +859,35 @@ static int _mei_irq_thread_read(struct mei_device *dev,	s32 *slots,
  *
  * @dev: the device structure.
  * @slots: free slots.
- * @cb_pos: callback block.
- * @cl: private data of the file object.
+ * @priv_cb_pos: callback block.
+ * @file_ext: private data of the file object.
  * @cmpl_list: complete list.
  *
  * returns 0, OK; otherwise, error.
  */
-static int _mei_irq_thread_ioctl(struct mei_device *dev, s32 *slots,
-			struct mei_cl_cb *cb_pos,
-			struct mei_cl *cl,
-			struct mei_io_list *cmpl_list)
+static int _mei_irq_thread_ioctl(struct mei_device *dev,	s32 *slots,
+			struct mei_cb_private *priv_cb_pos,
+			struct mei_file_private *file_ext,
+			struct io_mei_list *cmpl_list)
 {
 	if ((*slots * sizeof(u32)) >= (sizeof(struct mei_msg_hdr) +
 			sizeof(struct hbm_client_connect_request))) {
-		cl->state = MEI_FILE_CONNECTING;
+		file_ext->state = MEI_FILE_CONNECTING;
 		*slots -= (sizeof(struct mei_msg_hdr) +
 			sizeof(struct hbm_client_connect_request) + 3) / 4;
-		if (!mei_connect(dev, cl)) {
-			cl->status = -ENODEV;
-			cb_pos->information = 0;
-			list_del(&cb_pos->cb_list);
+		if (!mei_connect(dev, file_ext)) {
+			file_ext->status = -ENODEV;
+			priv_cb_pos->information = 0;
+			list_del(&priv_cb_pos->cb_list);
 			return -ENODEV;
 		} else {
-			list_move_tail(&cb_pos->cb_list,
+			list_move_tail(&priv_cb_pos->cb_list,
 				&dev->ctrl_rd_list.mei_cb.cb_list);
-			cl->timer_count = MEI_CONNECT_TIMEOUT;
+			file_ext->timer_count = MEI_CONNECT_TIMEOUT;
 		}
 	} else {
 		/* return the cancel routine */
-		list_del(&cb_pos->cb_list);
+		list_del(&priv_cb_pos->cb_list);
 		return -EBADMSG;
 	}
 
@@ -890,61 +899,60 @@ static int _mei_irq_thread_ioctl(struct mei_device *dev, s32 *slots,
  *
  * @dev: the device structure.
  * @slots: free slots.
- * @cb_pos: callback block.
- * @cl: private data of the file object.
+ * @priv_cb_pos: callback block.
+ * @file_ext: private data of the file object.
  * @cmpl_list: complete list.
  *
  * returns 0, OK; otherwise, error.
  */
 static int _mei_irq_thread_cmpl(struct mei_device *dev,	s32 *slots,
-			struct mei_cl_cb *cb_pos,
-			struct mei_cl *cl,
-			struct mei_io_list *cmpl_list)
+			struct mei_cb_private *priv_cb_pos,
+			struct mei_file_private *file_ext,
+			struct io_mei_list *cmpl_list)
 {
 	struct mei_msg_hdr *mei_hdr;
 
 	if ((*slots * sizeof(u32)) >= (sizeof(struct mei_msg_hdr) +
-			(cb_pos->request_buffer.size -
-			cb_pos->information))) {
+			(priv_cb_pos->request_buffer.size -
+			priv_cb_pos->information))) {
 		mei_hdr = (struct mei_msg_hdr *) &dev->wr_msg_buf[0];
-		mei_hdr->host_addr = cl->host_client_id;
-		mei_hdr->me_addr = cl->me_client_id;
-		mei_hdr->length = cb_pos->request_buffer.size -
-					cb_pos->information;
+		mei_hdr->host_addr = file_ext->host_client_id;
+		mei_hdr->me_addr = file_ext->me_client_id;
+		mei_hdr->length = priv_cb_pos->request_buffer.size -
+					priv_cb_pos->information;
 		mei_hdr->msg_complete = 1;
 		mei_hdr->reserved = 0;
-		dev_dbg(&dev->pdev->dev, "cb_pos->request_buffer.size =%d"
+		dev_dbg(&dev->pdev->dev, "priv_cb_pos->request_buffer.size =%d"
 			"mei_hdr->msg_complete = %d\n",
-				cb_pos->request_buffer.size,
+				priv_cb_pos->request_buffer.size,
 				mei_hdr->msg_complete);
-		dev_dbg(&dev->pdev->dev, "cb_pos->information  =%lu\n",
-				cb_pos->information);
+		dev_dbg(&dev->pdev->dev, "priv_cb_pos->information  =%lu\n",
+				priv_cb_pos->information);
 		dev_dbg(&dev->pdev->dev, "mei_hdr->length  =%d\n",
 				mei_hdr->length);
 		*slots -= (sizeof(struct mei_msg_hdr) +
 				mei_hdr->length + 3) / 4;
 		if (!mei_write_message(dev, mei_hdr,
 				(unsigned char *)
-				(cb_pos->request_buffer.data +
-				cb_pos->information),
+				(priv_cb_pos->request_buffer.data +
+				priv_cb_pos->information),
 				mei_hdr->length)) {
-			cl->status = -ENODEV;
-			list_move_tail(&cb_pos->cb_list,
+			file_ext->status = -ENODEV;
+			list_move_tail(&priv_cb_pos->cb_list,
 				&cmpl_list->mei_cb.cb_list);
 			return -ENODEV;
 		} else {
-			if (mei_flow_ctrl_reduce(dev, cl))
-				return -ENODEV;
-			cl->status = 0;
-			cb_pos->information += mei_hdr->length;
-			list_move_tail(&cb_pos->cb_list,
+			mei_flow_ctrl_reduce(dev, file_ext);
+			file_ext->status = 0;
+			priv_cb_pos->information += mei_hdr->length;
+			list_move_tail(&priv_cb_pos->cb_list,
 				&dev->write_waiting_list.mei_cb.cb_list);
 		}
 	} else if (*slots == ((dev->host_hw_state & H_CBD) >> 24)) {
 		/* buffer is still empty */
 		mei_hdr = (struct mei_msg_hdr *) &dev->wr_msg_buf[0];
-		mei_hdr->host_addr = cl->host_client_id;
-		mei_hdr->me_addr = cl->me_client_id;
+		mei_hdr->host_addr = file_ext->host_client_id;
+		mei_hdr->me_addr = file_ext->me_client_id;
 		mei_hdr->length =
 			(*slots * sizeof(u32)) - sizeof(struct mei_msg_hdr);
 		mei_hdr->msg_complete = 0;
@@ -954,22 +962,22 @@ static int _mei_irq_thread_cmpl(struct mei_device *dev,	s32 *slots,
 				mei_hdr->length + 3) / 4;
 		if (!mei_write_message(dev, mei_hdr,
 					(unsigned char *)
-					(cb_pos->request_buffer.data +
-					cb_pos->information),
+					(priv_cb_pos->request_buffer.data +
+					priv_cb_pos->information),
 					mei_hdr->length)) {
-			cl->status = -ENODEV;
-			list_move_tail(&cb_pos->cb_list,
+			file_ext->status = -ENODEV;
+			list_move_tail(&priv_cb_pos->cb_list,
 				&cmpl_list->mei_cb.cb_list);
 			return -ENODEV;
 		} else {
-			cb_pos->information += mei_hdr->length;
+			priv_cb_pos->information += mei_hdr->length;
 			dev_dbg(&dev->pdev->dev,
-					"cb_pos->request_buffer.size =%d"
+					"priv_cb_pos->request_buffer.size =%d"
 					" mei_hdr->msg_complete = %d\n",
-					cb_pos->request_buffer.size,
+					priv_cb_pos->request_buffer.size,
 					mei_hdr->msg_complete);
-			dev_dbg(&dev->pdev->dev, "cb_pos->information  =%lu\n",
-					cb_pos->information);
+			dev_dbg(&dev->pdev->dev, "priv_cb_pos->information  =%lu\n",
+					priv_cb_pos->information);
 			dev_dbg(&dev->pdev->dev, "mei_hdr->length  =%d\n",
 					mei_hdr->length);
 		}
@@ -986,16 +994,16 @@ static int _mei_irq_thread_cmpl(struct mei_device *dev,	s32 *slots,
  *
  * @dev: the device structure.
  * @slots: free slots.
- * @cb_pos: callback block.
- * @cl: private data of the file object.
+ * @priv_cb_pos: callback block.
+ * @file_ext: private data of the file object.
  * @cmpl_list: complete list.
  *
  * returns 0, OK; otherwise, error.
  */
 static int _mei_irq_thread_cmpl_iamthif(struct mei_device *dev, s32 *slots,
-			struct mei_cl_cb *cb_pos,
-			struct mei_cl *cl,
-			struct mei_io_list *cmpl_list)
+			struct mei_cb_private *priv_cb_pos,
+			struct mei_file_private *file_ext,
+			struct io_mei_list *cmpl_list)
 {
 	struct mei_msg_hdr *mei_hdr;
 
@@ -1003,8 +1011,8 @@ static int _mei_irq_thread_cmpl_iamthif(struct mei_device *dev, s32 *slots,
 			dev->iamthif_msg_buf_size -
 			dev->iamthif_msg_buf_index)) {
 		mei_hdr = (struct mei_msg_hdr *) &dev->wr_msg_buf[0];
-		mei_hdr->host_addr = cl->host_client_id;
-		mei_hdr->me_addr = cl->me_client_id;
+		mei_hdr->host_addr = file_ext->host_client_id;
+		mei_hdr->me_addr = file_ext->me_client_id;
 		mei_hdr->length = dev->iamthif_msg_buf_size -
 			dev->iamthif_msg_buf_index;
 		mei_hdr->msg_complete = 1;
@@ -1018,28 +1026,27 @@ static int _mei_irq_thread_cmpl_iamthif(struct mei_device *dev, s32 *slots,
 					dev->iamthif_msg_buf_index),
 					mei_hdr->length)) {
 			dev->iamthif_state = MEI_IAMTHIF_IDLE;
-			cl->status = -ENODEV;
-			list_del(&cb_pos->cb_list);
+			file_ext->status = -ENODEV;
+			list_del(&priv_cb_pos->cb_list);
 			return -ENODEV;
 		} else {
-			if (mei_flow_ctrl_reduce(dev, cl))
-				return -ENODEV;
+			mei_flow_ctrl_reduce(dev, file_ext);
 			dev->iamthif_msg_buf_index += mei_hdr->length;
-			cb_pos->information = dev->iamthif_msg_buf_index;
-			cl->status = 0;
+			priv_cb_pos->information = dev->iamthif_msg_buf_index;
+			file_ext->status = 0;
 			dev->iamthif_state = MEI_IAMTHIF_FLOW_CONTROL;
-			dev->iamthif_flow_control_pending = true;
+			dev->iamthif_flow_control_pending = 1;
 			/* save iamthif cb sent to amthi client */
-			dev->iamthif_current_cb = cb_pos;
-			list_move_tail(&cb_pos->cb_list,
+			dev->iamthif_current_cb = priv_cb_pos;
+			list_move_tail(&priv_cb_pos->cb_list,
 				&dev->write_waiting_list.mei_cb.cb_list);
 
 		}
 	} else if (*slots == ((dev->host_hw_state & H_CBD) >> 24)) {
 			/* buffer is still empty */
 		mei_hdr = (struct mei_msg_hdr *) &dev->wr_msg_buf[0];
-		mei_hdr->host_addr = cl->host_client_id;
-		mei_hdr->me_addr = cl->me_client_id;
+		mei_hdr->host_addr = file_ext->host_client_id;
+		mei_hdr->me_addr = file_ext->me_client_id;
 		mei_hdr->length =
 			(*slots * sizeof(u32)) - sizeof(struct mei_msg_hdr);
 		mei_hdr->msg_complete = 0;
@@ -1052,8 +1059,8 @@ static int _mei_irq_thread_cmpl_iamthif(struct mei_device *dev, s32 *slots,
 					(dev->iamthif_msg_buf +
 					dev->iamthif_msg_buf_index),
 					mei_hdr->length)) {
-			cl->status = -ENODEV;
-			list_del(&cb_pos->cb_list);
+			file_ext->status = -ENODEV;
+			list_del(&priv_cb_pos->cb_list);
 		} else {
 			dev->iamthif_msg_buf_index += mei_hdr->length;
 		}
@@ -1075,13 +1082,13 @@ static int _mei_irq_thread_cmpl_iamthif(struct mei_device *dev, s32 *slots,
  *
  * returns 0 on success, <0 on failure.
  */
-static int mei_irq_thread_read_handler(struct mei_io_list *cmpl_list,
+static int mei_irq_thread_read_handler(struct io_mei_list *cmpl_list,
 		struct mei_device *dev,
 		s32 *slots)
 {
 	struct mei_msg_hdr *mei_hdr;
-	struct mei_cl *cl_pos = NULL;
-	struct mei_cl *cl_next = NULL;
+	struct mei_file_private *file_pos = NULL;
+	struct mei_file_private *file_next = NULL;
 	int ret = 0;
 
 	if (!dev->rd_msg_hdr) {
@@ -1100,19 +1107,19 @@ static int mei_irq_thread_read_handler(struct mei_io_list *cmpl_list,
 	}
 
 	if (mei_hdr->host_addr || mei_hdr->me_addr) {
-		list_for_each_entry_safe(cl_pos, cl_next,
-					&dev->file_list, link) {
+		list_for_each_entry_safe(file_pos, file_next,
+				&dev->file_list, link) {
 			dev_dbg(&dev->pdev->dev,
 					"list_for_each_entry_safe read host"
 					" client = %d, ME client = %d\n",
-					cl_pos->host_client_id,
-					cl_pos->me_client_id);
-			if (cl_pos->host_client_id == mei_hdr->host_addr &&
-			    cl_pos->me_client_id == mei_hdr->me_addr)
+					file_pos->host_client_id,
+					file_pos->me_client_id);
+			if (file_pos->host_client_id == mei_hdr->host_addr &&
+			    file_pos->me_client_id == mei_hdr->me_addr)
 				break;
 		}
 
-		if (&cl_pos->link == &dev->file_list) {
+		if (&file_pos->link == &dev->file_list) {
 			dev_dbg(&dev->pdev->dev, "corrupted message header\n");
 			ret = -EBADMSG;
 			goto end;
@@ -1132,8 +1139,8 @@ static int mei_irq_thread_read_handler(struct mei_io_list *cmpl_list,
 		dev_dbg(&dev->pdev->dev, "call mei_irq_thread_read_bus_message.\n");
 		mei_irq_thread_read_bus_message(dev, mei_hdr);
 		dev_dbg(&dev->pdev->dev, "end mei_irq_thread_read_bus_message.\n");
-	} else if (mei_hdr->host_addr == dev->iamthif_cl.host_client_id &&
-		   (MEI_FILE_CONNECTED == dev->iamthif_cl.state) &&
+	} else if (mei_hdr->host_addr == dev->iamthif_file_ext.host_client_id &&
+		   (MEI_FILE_CONNECTED == dev->iamthif_file_ext.state) &&
 		   (dev->iamthif_state == MEI_IAMTHIF_READING)) {
 		dev_dbg(&dev->pdev->dev, "call mei_irq_thread_read_iamthif_message.\n");
 		dev_dbg(&dev->pdev->dev, "mei_hdr->length =%d\n",
@@ -1178,44 +1185,46 @@ end:
  *
  * returns 0 on success, <0 on failure.
  */
-static int mei_irq_thread_write_handler(struct mei_io_list *cmpl_list,
+static int mei_irq_thread_write_handler(struct io_mei_list *cmpl_list,
 		struct mei_device *dev,
 		s32 *slots)
 {
 
-	struct mei_cl *cl;
-	struct mei_cl_cb *cb_pos = NULL, *cb_next = NULL;
-	struct mei_io_list *list;
+	struct mei_file_private *file_ext;
+	struct mei_cb_private *priv_cb_pos = NULL, *priv_cb_next = NULL;
+	struct io_mei_list *list;
 	int ret;
 
 	if (!mei_host_buffer_is_empty(dev)) {
 		dev_dbg(&dev->pdev->dev, "host buffer is not empty.\n");
 		return 0;
 	}
+	dev->write_hang = -1;
 	*slots = mei_count_empty_write_slots(dev);
 	/* complete all waiting for write CB */
 	dev_dbg(&dev->pdev->dev, "complete all waiting for write cb.\n");
 
 	list = &dev->write_waiting_list;
 	if (!list->status && !list_empty(&list->mei_cb.cb_list)) {
-		list_for_each_entry_safe(cb_pos, cb_next,
+		list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 				&list->mei_cb.cb_list, cb_list) {
-			cl = (struct mei_cl *)cb_pos->file_private;
-			if (cl) {
-				cl->status = 0;
-				list_del(&cb_pos->cb_list);
-				if (MEI_WRITING == cl->writing_state &&
-				   (cb_pos->major_file_operations ==
+			file_ext = (struct mei_file_private *)
+					priv_cb_pos->file_private;
+			if (file_ext) {
+				file_ext->status = 0;
+				list_del(&priv_cb_pos->cb_list);
+				if (MEI_WRITING == file_ext->writing_state &&
+				   (priv_cb_pos->major_file_operations ==
 						MEI_WRITE) &&
-				   (cl != &dev->iamthif_cl)) {
+				   (file_ext != &dev->iamthif_file_ext)) {
 					dev_dbg(&dev->pdev->dev,
 						"MEI WRITE COMPLETE\n");
-					cl->writing_state =
+					file_ext->writing_state =
 							MEI_WRITE_COMPLETE;
-					list_add_tail(&cb_pos->cb_list,
+					list_add_tail(&priv_cb_pos->cb_list,
 						&cmpl_list->mei_cb.cb_list);
 				}
-				if (cl == &dev->iamthif_cl) {
+				if (file_ext == &dev->iamthif_file_ext) {
 					dev_dbg(&dev->pdev->dev, "check iamthif flow control.\n");
 					if (dev->iamthif_flow_control_pending) {
 						ret =
@@ -1231,7 +1240,7 @@ static int mei_irq_thread_write_handler(struct mei_io_list *cmpl_list,
 	}
 
 	if (dev->stop && !dev->wd_pending) {
-		dev->wd_stopped = true;
+		dev->wd_stopped = 1;
 		wake_up_interruptible(&dev->wait_stop_wd);
 		return 0;
 	}
@@ -1248,14 +1257,13 @@ static int mei_irq_thread_write_handler(struct mei_io_list *cmpl_list,
 	}
 	if (dev->mei_state == MEI_ENABLED) {
 		if (dev->wd_pending &&
-			mei_flow_ctrl_creds(dev, &dev->wd_cl) > 0) {
-			if (mei_wd_send(dev))
+		    mei_flow_ctrl_creds(dev, &dev->wd_file_ext)) {
+			if (!mei_send_wd(dev))
 				dev_dbg(&dev->pdev->dev, "wd send failed.\n");
 			else
-				if (mei_flow_ctrl_reduce(dev, &dev->wd_cl))
-					return -ENODEV;
+				mei_flow_ctrl_reduce(dev, &dev->wd_file_ext);
 
-			dev->wd_pending = false;
+			dev->wd_pending = 0;
 
 			if (dev->wd_timeout) {
 				*slots -= (sizeof(struct mei_msg_hdr) +
@@ -1276,19 +1284,20 @@ static int mei_irq_thread_write_handler(struct mei_io_list *cmpl_list,
 	if (!dev->ctrl_wr_list.status) {
 		/* complete control write list CB */
 		dev_dbg(&dev->pdev->dev, "complete control write list cb.\n");
-		list_for_each_entry_safe(cb_pos, cb_next,
+		list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 				&dev->ctrl_wr_list.mei_cb.cb_list, cb_list) {
-			cl = (struct mei_cl *)
-				cb_pos->file_private;
-			if (!cl) {
-				list_del(&cb_pos->cb_list);
+			file_ext = (struct mei_file_private *)
+				priv_cb_pos->file_private;
+			if (!file_ext) {
+				list_del(&priv_cb_pos->cb_list);
 				return -ENODEV;
 			}
-			switch (cb_pos->major_file_operations) {
+			switch (priv_cb_pos->major_file_operations) {
 			case MEI_CLOSE:
 				/* send disconnect message */
 				ret = _mei_irq_thread_close(dev, slots,
-						     cb_pos, cl, cmpl_list);
+						     priv_cb_pos,
+						     file_ext, cmpl_list);
 				if (ret)
 					return ret;
 
@@ -1296,7 +1305,8 @@ static int mei_irq_thread_write_handler(struct mei_io_list *cmpl_list,
 			case MEI_READ:
 				/* send flow control message */
 				ret = _mei_irq_thread_read(dev, slots,
-						    cb_pos, cl, cmpl_list);
+						    priv_cb_pos,
+						    file_ext, cmpl_list);
 				if (ret)
 					return ret;
 
@@ -1304,10 +1314,11 @@ static int mei_irq_thread_write_handler(struct mei_io_list *cmpl_list,
 			case MEI_IOCTL:
 				/* connect message */
 				if (!mei_other_client_is_connecting(dev,
-						cl))
+						file_ext))
 					continue;
 				ret = _mei_irq_thread_ioctl(dev, slots,
-						     cb_pos, cl, cmpl_list);
+						     priv_cb_pos,
+						     file_ext, cmpl_list);
 				if (ret)
 					return ret;
 
@@ -1323,43 +1334,45 @@ static int mei_irq_thread_write_handler(struct mei_io_list *cmpl_list,
 	if (!dev->write_list.status &&
 	    !list_empty(&dev->write_list.mei_cb.cb_list)) {
 		dev_dbg(&dev->pdev->dev, "complete write list cb.\n");
-		list_for_each_entry_safe(cb_pos, cb_next,
+		list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 				&dev->write_list.mei_cb.cb_list, cb_list) {
-			cl = (struct mei_cl *)cb_pos->file_private;
+			file_ext = (struct mei_file_private *)
+					priv_cb_pos->file_private;
 
-			if (cl) {
-				if (cl != &dev->iamthif_cl) {
+			if (file_ext) {
+				if (file_ext != &dev->iamthif_file_ext) {
 					if (!mei_flow_ctrl_creds(dev,
-						cl)) {
+						file_ext)) {
 						dev_dbg(&dev->pdev->dev,
 							"No flow control"
 						    " credentials for client"
 						    " %d, not sending.\n",
-						    cl->host_client_id);
+						    file_ext->host_client_id);
 						continue;
 					}
 					ret = _mei_irq_thread_cmpl(dev, slots,
-							    cb_pos,
-							    cl, cmpl_list);
+							    priv_cb_pos,
+							    file_ext,
+							    cmpl_list);
 					if (ret)
 						return ret;
 
-				} else if (cl == &dev->iamthif_cl) {
+				} else if (file_ext == &dev->iamthif_file_ext) {
 					/* IAMTHIF IOCTL */
 					dev_dbg(&dev->pdev->dev, "complete amthi write cb.\n");
 					if (!mei_flow_ctrl_creds(dev,
-							cl)) {
+							file_ext)) {
 						dev_dbg(&dev->pdev->dev,
 							"No flow control"
 						    " credentials for amthi"
 						    " client %d.\n",
-						    cl->host_client_id);
+						    file_ext->host_client_id);
 						continue;
 					}
 					ret = _mei_irq_thread_cmpl_iamthif(dev,
 								slots,
-								cb_pos,
-								cl,
+								priv_cb_pos,
+								file_ext,
 								cmpl_list);
 					if (ret)
 						return ret;
@@ -1384,11 +1397,11 @@ static int mei_irq_thread_write_handler(struct mei_io_list *cmpl_list,
 void mei_wd_timer(struct work_struct *work)
 {
 	unsigned long timeout;
-	struct mei_cl *cl_pos = NULL;
-	struct mei_cl *cl_next = NULL;
-	struct list_head *amthi_complete_list = NULL;
-	struct mei_cl_cb  *cb_pos = NULL;
-	struct mei_cl_cb  *cb_next = NULL;
+	struct mei_file_private *file_pos = NULL;
+	struct mei_file_private *file_next = NULL;
+
+	struct mei_cb_private *priv_cb_pos = NULL;
+	struct mei_cb_private *priv_cb_next = NULL;
 
 	struct mei_device *dev = container_of(work,
 					struct mei_device, wd_work.work);
@@ -1408,9 +1421,9 @@ void mei_wd_timer(struct work_struct *work)
 		goto out;
 	}
 	/*** connect/disconnect timeouts ***/
-	list_for_each_entry_safe(cl_pos, cl_next, &dev->file_list, link) {
-		if (cl_pos->timer_count) {
-			if (--cl_pos->timer_count == 0) {
+	list_for_each_entry_safe(file_pos, file_next, &dev->file_list, link) {
+		if (file_pos->timer_count) {
+			if (--file_pos->timer_count == 0) {
 				dev_dbg(&dev->pdev->dev, "HECI reset due to connect/disconnect timeout.\n");
 				mei_reset(dev, 1);
 				goto out;
@@ -1418,22 +1431,22 @@ void mei_wd_timer(struct work_struct *work)
 		}
 	}
 
-	if (dev->wd_cl.state != MEI_FILE_CONNECTED)
+	if (dev->wd_file_ext.state != MEI_FILE_CONNECTED)
 		goto out;
 
 	/* Watchdog */
 	if (dev->wd_due_counter && !dev->wd_bypass) {
 		if (--dev->wd_due_counter == 0) {
 			if (dev->mei_host_buffer_is_empty &&
-			    mei_flow_ctrl_creds(dev, &dev->wd_cl) > 0) {
-				dev->mei_host_buffer_is_empty = false;
+			    mei_flow_ctrl_creds(dev, &dev->wd_file_ext)) {
+				dev->mei_host_buffer_is_empty = 0;
 				dev_dbg(&dev->pdev->dev, "send watchdog.\n");
-
-				if (mei_wd_send(dev))
+				if (!mei_send_wd(dev)) {
 					dev_dbg(&dev->pdev->dev, "wd send failed.\n");
-				else
-					if (mei_flow_ctrl_reduce(dev, &dev->wd_cl))
-						goto out;
+				} else {
+					mei_flow_ctrl_reduce(dev,
+							 &dev->wd_file_ext);
+				}
 
 				if (dev->wd_timeout)
 					dev->wd_due_counter = 2;
@@ -1441,7 +1454,7 @@ void mei_wd_timer(struct work_struct *work)
 					dev->wd_due_counter = 0;
 
 			} else
-				dev->wd_pending = true;
+				dev->wd_pending = 1;
 
 		}
 	}
@@ -1451,8 +1464,8 @@ void mei_wd_timer(struct work_struct *work)
 			mei_reset(dev, 1);
 			dev->iamthif_msg_buf_size = 0;
 			dev->iamthif_msg_buf_index = 0;
-			dev->iamthif_canceled = false;
-			dev->iamthif_ioctl = true;
+			dev->iamthif_canceled = 0;
+			dev->iamthif_ioctl = 1;
 			dev->iamthif_state = MEI_IAMTHIF_IDLE;
 			dev->iamthif_timer = 0;
 
@@ -1461,7 +1474,7 @@ void mei_wd_timer(struct work_struct *work)
 
 			dev->iamthif_file_object = NULL;
 			dev->iamthif_current_cb = NULL;
-			mei_run_next_iamthif_cmd(dev);
+			run_next_iamthif_cmd(dev);
 		}
 	}
 
@@ -1470,8 +1483,7 @@ void mei_wd_timer(struct work_struct *work)
 		timeout = dev->iamthif_timer +
 				msecs_to_jiffies(IAMTHIF_READ_TIMER);
 
-		dev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n",
-				dev->iamthif_timer);
+		dev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n", dev->iamthif_timer);
 		dev_dbg(&dev->pdev->dev, "timeout = %ld\n", timeout);
 		dev_dbg(&dev->pdev->dev, "jiffies = %ld\n", jiffies);
 		if (time_after(jiffies, timeout)) {
@@ -1482,20 +1494,18 @@ void mei_wd_timer(struct work_struct *work)
 
 			dev_dbg(&dev->pdev->dev, "freeing AMTHI for other requests\n");
 
-			amthi_complete_list = &dev->amthi_read_complete_list.
-					mei_cb.cb_list;
-
-			if (!list_empty(amthi_complete_list)) {
+			if (!list_empty(&dev->amthi_read_complete_list.mei_cb.cb_list)) {
 
-				list_for_each_entry_safe(cb_pos, cb_next,
-							amthi_complete_list,
-							cb_list) {
+				list_for_each_entry_safe(priv_cb_pos,
+									priv_cb_next,
+									&dev->amthi_read_complete_list.mei_cb.cb_list,
+									cb_list) {
 
-					cl_pos = cb_pos->file_object->private_data;
+					file_pos = priv_cb_pos->file_object->private_data;
 
 					/* Finding the AMTHI entry. */
-					if (cl_pos ==	&dev->iamthif_cl)
-						list_del(&cb_pos->cb_list);
+					if (file_pos ==	&dev->iamthif_file_ext)
+						list_del(&priv_cb_pos->cb_list);
 				}
 			}
 			if (dev->iamthif_current_cb)
@@ -1505,7 +1515,7 @@ void mei_wd_timer(struct work_struct *work)
 			dev->iamthif_file_object = NULL;
 			dev->iamthif_current_cb = NULL;
 			dev->iamthif_timer = 0;
-			mei_run_next_iamthif_cmd(dev);
+			run_next_iamthif_cmd(dev);
 
 		}
 	}
@@ -1527,9 +1537,9 @@ out:
 irqreturn_t mei_interrupt_thread_handler(int irq, void *dev_id)
 {
 	struct mei_device *dev = (struct mei_device *) dev_id;
-	struct mei_io_list complete_list;
-	struct mei_cl_cb *cb_pos = NULL, *cb_next = NULL;
-	struct mei_cl *cl;
+	struct io_mei_list complete_list;
+	struct mei_cb_private *cb_pos = NULL, *cb_next = NULL;
+	struct mei_file_private *file_ext;
 	s32 slots;
 	int rets;
 	bool  bus_message_received;
@@ -1538,7 +1548,7 @@ irqreturn_t mei_interrupt_thread_handler(int irq, void *dev_id)
 	dev_dbg(&dev->pdev->dev, "function called after ISR to handle the interrupt processing.\n");
 	/* initialize our complete list */
 	mutex_lock(&dev->device_lock);
-	mei_io_list_init(&complete_list);
+	mei_initialize_list(&complete_list, dev);
 	dev->host_hw_state = mei_hcsr_read(dev);
 	dev->me_hw_state = mei_mecsr_read(dev);
 
@@ -1563,7 +1573,7 @@ irqreturn_t mei_interrupt_thread_handler(int irq, void *dev_id)
 			/* link is established
 			 * start sending messages.
 			 */
-			mei_host_start_message(dev);
+			host_start_message(dev);
 			mutex_unlock(&dev->device_lock);
 			return IRQ_HANDLED;
 		} else {
@@ -1607,14 +1617,14 @@ end:
 
 	list_for_each_entry_safe(cb_pos, cb_next,
 			&complete_list.mei_cb.cb_list, cb_list) {
-		cl = (struct mei_cl *)cb_pos->file_private;
+		file_ext = (struct mei_file_private *)cb_pos->file_private;
 		list_del(&cb_pos->cb_list);
-		if (cl) {
-			if (cl != &dev->iamthif_cl) {
+		if (file_ext) {
+			if (file_ext != &dev->iamthif_file_ext) {
 				dev_dbg(&dev->pdev->dev, "completing call back.\n");
-				_mei_cmpl(cl, cb_pos);
+				_mei_cmpl(file_ext, cb_pos);
 				cb_pos = NULL;
-			} else if (cl == &dev->iamthif_cl) {
+			} else if (file_ext == &dev->iamthif_file_ext) {
 				_mei_cmpl_iamthif(dev, cb_pos);
 			}
 		}
diff --git a/drivers/staging/mei/iorw.c b/drivers/staging/mei/iorw.c
index 8a61d12..d92eec3 100644
--- a/drivers/staging/mei/iorw.c
+++ b/drivers/staging/mei/iorw.c
@@ -28,12 +28,9 @@
 #include <linux/list.h>
 #include <linux/delay.h>
 #include <linux/sched.h>
-#include <linux/uuid.h>
 #include <linux/jiffies.h>
-#include <linux/uaccess.h>
 
-
-#include "mei_dev.h"
+#include "backport/backport.h"
 #include "hw.h"
 #include "mei.h"
 #include "interface.h"
@@ -41,10 +38,12 @@
 
 
 
+
 /**
  * mei_ioctl_connect_client - the connect to fw client IOCTL function
  *
  * @dev: the device structure
+ * @if_num:  minor number
  * @data: IOCTL connect data, input and output parameters
  * @file: private data of the file object
  *
@@ -52,125 +51,127 @@
  *
  * returns 0 on success, <0 on failure.
  */
-int mei_ioctl_connect_client(struct file *file,
-			struct mei_connect_client_data *data)
+int mei_ioctl_connect_client(struct mei_device *dev, int if_num,
+					struct mei_connect_client_data *data,
+					struct file *file)
 {
-	struct mei_device *dev;
-	struct mei_cl_cb *cb;
+	struct mei_cb_private *priv_cb = NULL;
 	struct mei_client *client;
-	struct mei_cl *cl;
-	struct mei_cl *cl_pos = NULL;
-	struct mei_cl *cl_next = NULL;
+	struct mei_file_private *file_ext;
+	struct mei_file_private *file_pos = NULL;
+	struct mei_file_private *file_next = NULL;
 	long timeout = CONNECT_TIMEOUT;
 	int i;
 	int err;
 	int rets;
 
-	cl = file->private_data;
-	if (WARN_ON(!cl || !cl->dev))
+	if (if_num != MEI_MINOR_NUMBER || !dev || !file)
 		return -ENODEV;
 
-	dev = cl->dev;
-
 	dev_dbg(&dev->pdev->dev, "mei_ioctl_connect_client() Entry\n");
 
+	file_ext = file->private_data;
 
 	/* buffered ioctl cb */
-	cb = kzalloc(sizeof(struct mei_cl_cb), GFP_KERNEL);
-	if (!cb) {
+	priv_cb = kzalloc(sizeof(struct mei_cb_private), GFP_KERNEL);
+	if (!priv_cb) {
 		rets = -ENOMEM;
 		goto end;
 	}
-	INIT_LIST_HEAD(&cb->cb_list);
+	INIT_LIST_HEAD(&priv_cb->cb_list);
 
-	cb->major_file_operations = MEI_IOCTL;
+	priv_cb->major_file_operations = MEI_IOCTL;
 
 	if (dev->mei_state != MEI_ENABLED) {
 		rets = -ENODEV;
 		goto end;
 	}
-	if (cl->state != MEI_FILE_INITIALIZING &&
-	    cl->state != MEI_FILE_DISCONNECTED) {
+	if (file_ext->state != MEI_FILE_INITIALIZING &&
+	    file_ext->state != MEI_FILE_DISCONNECTED) {
 		rets = -EBUSY;
 		goto end;
 	}
 
 	/* find ME client we're trying to connect to */
-	i = mei_find_me_client_index(dev, data->in_client_uuid);
-	if (i >= 0 && !dev->me_clients[i].props.fixed_address) {
-		cl->me_client_id = dev->me_clients[i].client_id;
-		cl->state = MEI_FILE_CONNECTING;
+	i = mei_find_me_client_index(dev, data->d.in_client_uuid);
+	if (i >= 0 &&
+		!dev->me_clients[i].props.fixed_address) {
+		file_ext->me_client_id = dev->me_clients[i].client_id;
+		file_ext->state = MEI_FILE_CONNECTING;
+
 	}
 
-	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
-			cl->me_client_id);
-	dev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",
+	dev_dbg(&dev->pdev->dev,
+			"Connect to FW Client ID = %d\n",
+			file_ext->me_client_id);
+	dev_dbg(&dev->pdev->dev,
+			"FW Client - Protocol Version = %d\n",
 			dev->me_clients[i].props.protocol_version);
-	dev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",
+	dev_dbg(&dev->pdev->dev,
+			"FW Client - Max Msg Len = %d\n",
 			dev->me_clients[i].props.max_msg_length);
 
 	/* if we're connecting to amthi client so we will use the exist
 	 * connection
 	 */
-	if (uuid_le_cmp(data->in_client_uuid, mei_amthi_guid) == 0) {
+	if (uuid_le_cmp(data->d.in_client_uuid, mei_amthi_guid) == 0) {
 		dev_dbg(&dev->pdev->dev, "FW Client is amthi\n");
-		if (dev->iamthif_cl.state != MEI_FILE_CONNECTED) {
+		if (dev->iamthif_file_ext.state != MEI_FILE_CONNECTED) {
 			rets = -ENODEV;
 			goto end;
 		}
-		clear_bit(cl->host_client_id, dev->host_clients_map);
-		list_for_each_entry_safe(cl_pos, cl_next,
+		clear_bit(file_ext->host_client_id, dev->host_clients_map);
+		list_for_each_entry_safe(file_pos, file_next,
 					 &dev->file_list, link) {
-			if (mei_cl_cmp_id(cl, cl_pos)) {
+			if (mei_fe_same_id(file_ext, file_pos)) {
 				dev_dbg(&dev->pdev->dev,
 					"remove file private data node host"
 				    " client = %d, ME client = %d.\n",
-				    cl_pos->host_client_id,
-				    cl_pos->me_client_id);
-				list_del(&cl_pos->link);
+				    file_pos->host_client_id,
+				    file_pos->me_client_id);
+				list_del(&file_pos->link);
 			}
 
 		}
 		dev_dbg(&dev->pdev->dev, "free file private data memory.\n");
-		kfree(cl);
+		kfree(file_ext);
 
-		cl = NULL;
-		file->private_data = &dev->iamthif_cl;
+		file_ext = NULL;
+		file->private_data = &dev->iamthif_file_ext;
 
-		client = &data->out_client_properties;
+		client = &data->d.out_client_properties;
 		client->max_msg_length =
 			dev->me_clients[i].props.max_msg_length;
 		client->protocol_version =
 			dev->me_clients[i].props.protocol_version;
-		rets = dev->iamthif_cl.status;
+		rets = dev->iamthif_file_ext.status;
 
 		goto end;
 	}
-
-	if (cl->state != MEI_FILE_CONNECTING) {
+	if (file_ext->state != MEI_FILE_CONNECTING) {
 		rets = -ENODEV;
 		goto end;
 	}
 
 
 	/* prepare the output buffer */
-	client = &data->out_client_properties;
+	client = &data->d.out_client_properties;
 	client->max_msg_length = dev->me_clients[i].props.max_msg_length;
 	client->protocol_version = dev->me_clients[i].props.protocol_version;
 	dev_dbg(&dev->pdev->dev, "Can connect?\n");
 	if (dev->mei_host_buffer_is_empty
-	    && !mei_other_client_is_connecting(dev, cl)) {
+	    && !mei_other_client_is_connecting(dev, file_ext)) {
 		dev_dbg(&dev->pdev->dev, "Sending Connect Message\n");
-		dev->mei_host_buffer_is_empty = false;
-		if (!mei_connect(dev, cl)) {
+		dev->mei_host_buffer_is_empty = 0;
+		if (!mei_connect(dev, file_ext)) {
 			dev_dbg(&dev->pdev->dev, "Sending connect message - failed\n");
 			rets = -ENODEV;
 			goto end;
 		} else {
 			dev_dbg(&dev->pdev->dev, "Sending connect message - succeeded\n");
-			cl->timer_count = MEI_CONNECT_TIMEOUT;
-			cb->file_private = cl;
-			list_add_tail(&cb->cb_list,
+			file_ext->timer_count = MEI_CONNECT_TIMEOUT;
+			priv_cb->file_private = file_ext;
+			list_add_tail(&priv_cb->cb_list,
 				      &dev->ctrl_rd_list.mei_cb.
 				      cb_list);
 		}
@@ -178,40 +179,42 @@ int mei_ioctl_connect_client(struct file *file,
 
 	} else {
 		dev_dbg(&dev->pdev->dev, "Queuing the connect request due to device busy\n");
-		cb->file_private = cl;
+		priv_cb->file_private = file_ext;
 		dev_dbg(&dev->pdev->dev, "add connect cb to control write list.\n");
-		list_add_tail(&cb->cb_list,
+		list_add_tail(&priv_cb->cb_list,
 			      &dev->ctrl_wr_list.mei_cb.cb_list);
 	}
 	mutex_unlock(&dev->device_lock);
 	err = wait_event_timeout(dev->wait_recvd_msg,
-			(MEI_FILE_CONNECTED == cl->state ||
-			 MEI_FILE_DISCONNECTED == cl->state),
+			(MEI_FILE_CONNECTED == file_ext->state ||
+			 MEI_FILE_DISCONNECTED == file_ext->state),
 			timeout * HZ);
 
 	mutex_lock(&dev->device_lock);
-	if (MEI_FILE_CONNECTED == cl->state) {
+	if (MEI_FILE_CONNECTED == file_ext->state) {
 		dev_dbg(&dev->pdev->dev, "successfully connected to FW client.\n");
-		rets = cl->status;
+		rets = file_ext->status;
 		goto end;
 	} else {
-		dev_dbg(&dev->pdev->dev, "failed to connect to FW client.cl->state = %d.\n",
-		    cl->state);
+		dev_dbg(&dev->pdev->dev, "failed to connect to FW client.file_ext->state = %d.\n",
+		    file_ext->state);
 		if (!err) {
 			dev_dbg(&dev->pdev->dev,
 				"wait_event_interruptible_timeout failed on client"
-				" connect message fw response message.\n");
+			    " connect message fw response message.\n");
 		}
 		rets = -EFAULT;
 
-		mei_io_list_flush(&dev->ctrl_rd_list, cl);
-		mei_io_list_flush(&dev->ctrl_wr_list, cl);
+		if (priv_cb) {
+			mei_flush_list(&dev->ctrl_rd_list, file_ext);
+			mei_flush_list(&dev->ctrl_wr_list, file_ext);
+		}
 		goto end;
 	}
 	rets = 0;
 end:
 	dev_dbg(&dev->pdev->dev, "free connect cb memory.");
-	kfree(cb);
+	kfree(priv_cb);
 	return rets;
 }
 
@@ -223,22 +226,24 @@ end:
  *
  * returns   returned a list entry on success, NULL on failure.
  */
-struct mei_cl_cb *find_amthi_read_list_entry(
+struct mei_cb_private *find_amthi_read_list_entry(
 		struct mei_device *dev,
 		struct file *file)
 {
-	struct mei_cl *cl_temp;
-	struct mei_cl_cb *cb_pos = NULL;
-	struct mei_cl_cb *cb_next = NULL;
+	struct mei_file_private *file_ext_temp;
+	struct mei_cb_private *priv_cb_pos = NULL;
+	struct mei_cb_private *priv_cb_next = NULL;
 
 	if (!dev->amthi_read_complete_list.status &&
 	    !list_empty(&dev->amthi_read_complete_list.mei_cb.cb_list)) {
-		list_for_each_entry_safe(cb_pos, cb_next,
+		list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 		    &dev->amthi_read_complete_list.mei_cb.cb_list, cb_list) {
-			cl_temp = (struct mei_cl *)cb_pos->file_private;
-			if (cl_temp && cl_temp == &dev->iamthif_cl &&
-				cb_pos->file_object == file)
-				return cb_pos;
+			file_ext_temp = (struct mei_file_private *)
+					priv_cb_pos->file_private;
+			if (file_ext_temp &&
+			    file_ext_temp == &dev->iamthif_file_ext &&
+			    priv_cb_pos->file_object == file)
+				return priv_cb_pos;
 		}
 	}
 	return NULL;
@@ -261,50 +266,54 @@ struct mei_cl_cb *find_amthi_read_list_entry(
  *  zero if no data to read,
  *  negative on failure.
  */
-int amthi_read(struct mei_device *dev, struct file *file,
+int amthi_read(struct mei_device *dev, int if_num, struct file *file,
 	      char __user *ubuf, size_t length, loff_t *offset)
 {
 	int rets;
 	int wait_ret;
-	struct mei_cl_cb *cb = NULL;
-	struct mei_cl *cl = file->private_data;
-	unsigned long timeout;
+	struct mei_cb_private *priv_cb = NULL;
+	struct mei_file_private *file_ext = file->private_data;
 	int i;
+	unsigned long timeout;
+
+
+	if (if_num != MEI_MINOR_NUMBER || !dev)
+		return -ENODEV;
 
 	/* Only Posible if we are in timeout */
-	if (!cl || cl != &dev->iamthif_cl) {
+	if (!file_ext || file_ext != &dev->iamthif_file_ext) {
 		dev_dbg(&dev->pdev->dev, "bad file ext.\n");
 		return -ETIMEDOUT;
 	}
 
-	for (i = 0; i < dev->me_clients_num; i++) {
+	for (i = 0; i < dev->num_mei_me_clients; i++) {
 		if (dev->me_clients[i].client_id ==
-		    dev->iamthif_cl.me_client_id)
+		    dev->iamthif_file_ext.me_client_id)
 			break;
 	}
 
-	if (i == dev->me_clients_num) {
+	BUG_ON(dev->me_clients[i].client_id != file_ext->me_client_id);
+	if (i == dev->num_mei_me_clients ||
+	    dev->me_clients[i].client_id != dev->iamthif_file_ext.me_client_id) {
 		dev_dbg(&dev->pdev->dev, "amthi client not found.\n");
 		return -ENODEV;
 	}
-	if (WARN_ON(dev->me_clients[i].client_id != cl->me_client_id))
-		return -ENODEV;
 
 	dev_dbg(&dev->pdev->dev, "checking amthi data\n");
-	cb = find_amthi_read_list_entry(dev, file);
+	priv_cb = find_amthi_read_list_entry(dev, file);
 
 	/* Check for if we can block or not*/
-	if (cb == NULL && file->f_flags & O_NONBLOCK)
+	if (priv_cb == NULL && file->f_flags & O_NONBLOCK)
 		return -EAGAIN;
 
 
 	dev_dbg(&dev->pdev->dev, "waiting for amthi data\n");
-	while (cb == NULL) {
+	while (priv_cb == NULL) {
 		/* unlock the Mutex */
 		mutex_unlock(&dev->device_lock);
 
-		wait_ret = wait_event_interruptible(dev->iamthif_cl.wait,
-			(cb = find_amthi_read_list_entry(dev, file)));
+		wait_ret = wait_event_interruptible(dev->iamthif_file_ext.wait,
+			(priv_cb = find_amthi_read_list_entry(dev, file)));
 
 		if (wait_ret)
 			return -ERESTARTSYS;
@@ -319,8 +328,8 @@ int amthi_read(struct mei_device *dev, struct file *file,
 	dev_dbg(&dev->pdev->dev, "Got amthi data\n");
 	dev->iamthif_timer = 0;
 
-	if (cb) {
-		timeout = cb->read_time +
+	if (priv_cb) {
+		timeout = priv_cb->read_time +
 					msecs_to_jiffies(IAMTHIF_READ_TIMER);
 		dev_dbg(&dev->pdev->dev, "amthi timeout = %lud\n",
 				timeout);
@@ -328,18 +337,18 @@ int amthi_read(struct mei_device *dev, struct file *file,
 		if  (time_after(jiffies, timeout)) {
 			dev_dbg(&dev->pdev->dev, "amthi Time out\n");
 			/* 15 sec for the message has expired */
-			list_del(&cb->cb_list);
+			list_del(&priv_cb->cb_list);
 			rets = -ETIMEDOUT;
 			goto free;
 		}
 	}
 	/* if the whole message will fit remove it from the list */
-	if (cb->information >= *offset &&
-	    length >= (cb->information - *offset))
-		list_del(&cb->cb_list);
-	else if (cb->information > 0 && cb->information <= *offset) {
+	if (priv_cb->information >= *offset &&
+	    length >= (priv_cb->information - *offset))
+		list_del(&priv_cb->cb_list);
+	else if (priv_cb->information > 0 && priv_cb->information <= *offset) {
 		/* end of the message has been reached */
-		list_del(&cb->cb_list);
+		list_del(&priv_cb->cb_list);
 		rets = 0;
 		goto free;
 	}
@@ -347,22 +356,22 @@ int amthi_read(struct mei_device *dev, struct file *file,
 		 * remove message from deletion list
 		 */
 
-	dev_dbg(&dev->pdev->dev, "amthi cb->response_buffer size - %d\n",
-	    cb->response_buffer.size);
-	dev_dbg(&dev->pdev->dev, "amthi cb->information - %lu\n",
-	    cb->information);
+	dev_dbg(&dev->pdev->dev, "amthi priv_cb->response_buffer size - %d\n",
+	    priv_cb->response_buffer.size);
+	dev_dbg(&dev->pdev->dev, "amthi priv_cb->information - %lu\n",
+	    priv_cb->information);
 
 	/* length is being turncated to PAGE_SIZE, however,
 	 * the information may be longer */
-	length = min_t(size_t, length, (cb->information - *offset));
+	length = min_t(size_t, length, (priv_cb->information - *offset));
 
 	if (copy_to_user(ubuf,
-			 cb->response_buffer.data + *offset,
+			 priv_cb->response_buffer.data + *offset,
 			 length))
 		rets = -EFAULT;
 	else {
 		rets = length;
-		if ((*offset + length) < cb->information) {
+		if ((*offset + length) < priv_cb->information) {
 			*offset += length;
 			goto out;
 		}
@@ -370,7 +379,7 @@ int amthi_read(struct mei_device *dev, struct file *file,
 free:
 	dev_dbg(&dev->pdev->dev, "free amthi cb memory.\n");
 	*offset = 0;
-	mei_free_cb_private(cb);
+	mei_free_cb_private(priv_cb);
 out:
 	return rets;
 }
@@ -380,80 +389,82 @@ out:
  *
  * @dev: the device structure
  * @if_num:  minor number
- * @cl: private data of the file object
+ * @file_ext: private data of the file object
  *
  * returns 0 on success, <0 on failure.
  */
-int mei_start_read(struct mei_device *dev, struct mei_cl *cl)
+int mei_start_read(struct mei_device *dev, int if_num,
+		    struct mei_file_private *file_ext)
 {
-	struct mei_cl_cb *cb;
+	struct mei_cb_private *priv_cb;
 	int rets = 0;
 	int i;
 
-	if (cl->state != MEI_FILE_CONNECTED)
+	if (if_num != MEI_MINOR_NUMBER || !dev || !file_ext) {
+		dev_dbg(&dev->pdev->dev, "received wrong function input param.\n");
+		return -ENODEV;
+	}
+
+	if (file_ext->state != MEI_FILE_CONNECTED)
 		return -ENODEV;
 
 	if (dev->mei_state != MEI_ENABLED)
 		return -ENODEV;
 
 	dev_dbg(&dev->pdev->dev, "check if read is pending.\n");
-	if (cl->read_pending || cl->read_cb) {
+	if (file_ext->read_pending || file_ext->read_cb) {
 		dev_dbg(&dev->pdev->dev, "read is pending.\n");
 		return -EBUSY;
 	}
 
-	cb = kzalloc(sizeof(struct mei_cl_cb), GFP_KERNEL);
-	if (!cb)
+	priv_cb = kzalloc(sizeof(struct mei_cb_private), GFP_KERNEL);
+	if (!priv_cb)
 		return -ENOMEM;
 
 	dev_dbg(&dev->pdev->dev, "allocation call back successful. host client = %d, ME client = %d\n",
-		cl->host_client_id, cl->me_client_id);
+		file_ext->host_client_id, file_ext->me_client_id);
 
-	for (i = 0; i < dev->me_clients_num; i++) {
-		if (dev->me_clients[i].client_id == cl->me_client_id)
+	for (i = 0; i < dev->num_mei_me_clients; i++) {
+		if (dev->me_clients[i].client_id == file_ext->me_client_id)
 			break;
 
 	}
 
-	if (WARN_ON(dev->me_clients[i].client_id != cl->me_client_id)) {
-		rets = -ENODEV;
-		goto unlock;
-	}
-
-	if (i == dev->me_clients_num) {
+	BUG_ON(dev->me_clients[i].client_id != file_ext->me_client_id);
+	if (i == dev->num_mei_me_clients) {
 		rets = -ENODEV;
 		goto unlock;
 	}
 
-	cb->response_buffer.size = dev->me_clients[i].props.max_msg_length;
-	cb->response_buffer.data =
-	    kmalloc(cb->response_buffer.size, GFP_KERNEL);
-	if (!cb->response_buffer.data) {
+	priv_cb->response_buffer.size = dev->me_clients[i].props.max_msg_length;
+	priv_cb->response_buffer.data =
+	    kmalloc(priv_cb->response_buffer.size, GFP_KERNEL);
+	if (!priv_cb->response_buffer.data) {
 		rets = -ENOMEM;
 		goto unlock;
 	}
 	dev_dbg(&dev->pdev->dev, "allocation call back data success.\n");
-	cb->major_file_operations = MEI_READ;
+	priv_cb->major_file_operations = MEI_READ;
 	/* make sure information is zero before we start */
-	cb->information = 0;
-	cb->file_private = (void *) cl;
-	cl->read_cb = cb;
+	priv_cb->information = 0;
+	priv_cb->file_private = (void *) file_ext;
+	file_ext->read_cb = priv_cb;
 	if (dev->mei_host_buffer_is_empty) {
-		dev->mei_host_buffer_is_empty = false;
-		if (!mei_send_flow_control(dev, cl)) {
+		dev->mei_host_buffer_is_empty = 0;
+		if (!mei_send_flow_control(dev, file_ext)) {
 			rets = -ENODEV;
 			goto unlock;
 		} else {
-			list_add_tail(&cb->cb_list,
+			list_add_tail(&priv_cb->cb_list,
 				      &dev->read_list.mei_cb.cb_list);
 		}
 	} else {
-		list_add_tail(&cb->cb_list,
+		list_add_tail(&priv_cb->cb_list,
 			      &dev->ctrl_wr_list.mei_cb.cb_list);
 	}
 	return rets;
 unlock:
-	mei_free_cb_private(cb);
+	mei_free_cb_private(priv_cb);
 	return rets;
 }
 
@@ -461,37 +472,33 @@ unlock:
  * amthi_write - write iamthif data to amthi client
  *
  * @dev: the device structure
- * @cb: mei call back struct
+ * @priv_cb: mei call back struct
  *
  * returns 0 on success, <0 on failure.
  */
-int amthi_write(struct mei_device *dev, struct mei_cl_cb *cb)
+int amthi_write(struct mei_device *dev,
+	       struct mei_cb_private *priv_cb)
 {
 	struct mei_msg_hdr mei_hdr;
-	int ret;
 
-	if (!dev || !cb)
+	if (!dev || !priv_cb)
 		return -ENODEV;
 
 	dev_dbg(&dev->pdev->dev, "write data to amthi client.\n");
 
 	dev->iamthif_state = MEI_IAMTHIF_WRITING;
-	dev->iamthif_current_cb = cb;
-	dev->iamthif_file_object = cb->file_object;
-	dev->iamthif_canceled = false;
-	dev->iamthif_ioctl = true;
-	dev->iamthif_msg_buf_size = cb->request_buffer.size;
-	memcpy(dev->iamthif_msg_buf, cb->request_buffer.data,
-	    cb->request_buffer.size);
-
-	ret = mei_flow_ctrl_creds(dev, &dev->iamthif_cl);
-	if (ret < 0)
-		return ret;
-
-	if (ret && dev->mei_host_buffer_is_empty) {
-		ret = 0;
-		dev->mei_host_buffer_is_empty = false;
-		if (cb->request_buffer.size >
+	dev->iamthif_current_cb = priv_cb;
+	dev->iamthif_file_object = priv_cb->file_object;
+	dev->iamthif_canceled = 0;
+	dev->iamthif_ioctl = 1;
+	dev->iamthif_msg_buf_size = priv_cb->request_buffer.size;
+	memcpy(dev->iamthif_msg_buf, priv_cb->request_buffer.data,
+	    priv_cb->request_buffer.size);
+
+	if (mei_flow_ctrl_creds(dev, &dev->iamthif_file_ext) &&
+	    dev->mei_host_buffer_is_empty) {
+		dev->mei_host_buffer_is_empty = 0;
+		if (priv_cb->request_buffer.size >
 			(((dev->host_hw_state & H_CBD) >> 24) * sizeof(u32))
 				-sizeof(struct mei_msg_hdr)) {
 			mei_hdr.length =
@@ -499,12 +506,12 @@ int amthi_write(struct mei_device *dev, struct mei_cl_cb *cb)
 			    sizeof(u32)) - sizeof(struct mei_msg_hdr);
 			mei_hdr.msg_complete = 0;
 		} else {
-			mei_hdr.length = cb->request_buffer.size;
+			mei_hdr.length = priv_cb->request_buffer.size;
 			mei_hdr.msg_complete = 1;
 		}
 
-		mei_hdr.host_addr = dev->iamthif_cl.host_client_id;
-		mei_hdr.me_addr = dev->iamthif_cl.me_client_id;
+		mei_hdr.host_addr = dev->iamthif_file_ext.host_client_id;
+		mei_hdr.me_addr = dev->iamthif_file_ext.me_client_id;
 		mei_hdr.reserved = 0;
 		dev->iamthif_msg_buf_index += mei_hdr.length;
 		if (!mei_write_message(dev, &mei_hdr,
@@ -513,19 +520,18 @@ int amthi_write(struct mei_device *dev, struct mei_cl_cb *cb)
 			return -ENODEV;
 
 		if (mei_hdr.msg_complete) {
-			if (mei_flow_ctrl_reduce(dev, &dev->iamthif_cl))
-				return -ENODEV;
-			dev->iamthif_flow_control_pending = true;
+			mei_flow_ctrl_reduce(dev, &dev->iamthif_file_ext);
+			dev->iamthif_flow_control_pending = 1;
 			dev->iamthif_state = MEI_IAMTHIF_FLOW_CONTROL;
 			dev_dbg(&dev->pdev->dev, "add amthi cb to write waiting list\n");
-			dev->iamthif_current_cb = cb;
-			dev->iamthif_file_object = cb->file_object;
-			list_add_tail(&cb->cb_list,
+			dev->iamthif_current_cb = priv_cb;
+			dev->iamthif_file_object = priv_cb->file_object;
+			list_add_tail(&priv_cb->cb_list,
 				      &dev->write_waiting_list.mei_cb.cb_list);
 		} else {
 			dev_dbg(&dev->pdev->dev, "message does not complete, "
 					"so add amthi cb to write list.\n");
-			list_add_tail(&cb->cb_list,
+			list_add_tail(&priv_cb->cb_list,
 				      &dev->write_list.mei_cb.cb_list);
 		}
 	} else {
@@ -534,7 +540,7 @@ int amthi_write(struct mei_device *dev, struct mei_cl_cb *cb)
 
 		dev_dbg(&dev->pdev->dev, "No flow control credentials, "
 				"so add iamthif cb to write list.\n");
-		list_add_tail(&cb->cb_list,
+		list_add_tail(&priv_cb->cb_list,
 			      &dev->write_list.mei_cb.cb_list);
 	}
 	return 0;
@@ -547,11 +553,11 @@ int amthi_write(struct mei_device *dev, struct mei_cl_cb *cb)
  *
  * returns 0 on success, <0 on failure.
  */
-void mei_run_next_iamthif_cmd(struct mei_device *dev)
+void run_next_iamthif_cmd(struct mei_device *dev)
 {
-	struct mei_cl *cl_tmp;
-	struct mei_cl_cb *cb_pos = NULL;
-	struct mei_cl_cb *cb_next = NULL;
+	struct mei_file_private *file_ext_tmp;
+	struct mei_cb_private *priv_cb_pos = NULL;
+	struct mei_cb_private *priv_cb_next = NULL;
 	int status;
 
 	if (!dev)
@@ -559,8 +565,8 @@ void mei_run_next_iamthif_cmd(struct mei_device *dev)
 
 	dev->iamthif_msg_buf_size = 0;
 	dev->iamthif_msg_buf_index = 0;
-	dev->iamthif_canceled = false;
-	dev->iamthif_ioctl = true;
+	dev->iamthif_canceled = 0;
+	dev->iamthif_ioctl = 1;
 	dev->iamthif_state = MEI_IAMTHIF_IDLE;
 	dev->iamthif_timer = 0;
 	dev->iamthif_file_object = NULL;
@@ -569,13 +575,15 @@ void mei_run_next_iamthif_cmd(struct mei_device *dev)
 	    !list_empty(&dev->amthi_cmd_list.mei_cb.cb_list)) {
 		dev_dbg(&dev->pdev->dev, "complete amthi cmd_list cb.\n");
 
-		list_for_each_entry_safe(cb_pos, cb_next,
+		list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
 		    &dev->amthi_cmd_list.mei_cb.cb_list, cb_list) {
-			list_del(&cb_pos->cb_list);
-			cl_tmp = (struct mei_cl *)cb_pos->file_private;
+			list_del(&priv_cb_pos->cb_list);
+			file_ext_tmp = (struct mei_file_private *)
+					priv_cb_pos->file_private;
 
-			if (cl_tmp && cl_tmp == &dev->iamthif_cl) {
-				status = amthi_write(dev, cb_pos);
+			if (file_ext_tmp &&
+			    file_ext_tmp == &dev->iamthif_file_ext) {
+				status = amthi_write(dev, priv_cb_pos);
 				if (status) {
 					dev_dbg(&dev->pdev->dev,
 						"amthi write failed status = %d\n",
@@ -591,14 +599,14 @@ void mei_run_next_iamthif_cmd(struct mei_device *dev)
 /**
  * mei_free_cb_private - free mei_cb_private related memory
  *
- * @cb: mei callback struct
+ * @priv_cb: mei callback struct
  */
-void mei_free_cb_private(struct mei_cl_cb *cb)
+void mei_free_cb_private(struct mei_cb_private *priv_cb)
 {
-	if (cb == NULL)
+	if (priv_cb == NULL)
 		return;
 
-	kfree(cb->request_buffer.data);
-	kfree(cb->response_buffer.data);
-	kfree(cb);
+	kfree(priv_cb->request_buffer.data);
+	kfree(priv_cb->response_buffer.data);
+	kfree(priv_cb);
 }
diff --git a/drivers/staging/mei/main.c b/drivers/staging/mei/main.c
index de8825f..6321ac0 100644
--- a/drivers/staging/mei/main.c
+++ b/drivers/staging/mei/main.c
@@ -14,6 +14,8 @@
  *
  */
 
+
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/kernel.h>
@@ -28,13 +30,12 @@
 #include <linux/init.h>
 #include <linux/ioctl.h>
 #include <linux/cdev.h>
+#include <linux/version.h>
 #include <linux/sched.h>
-#include <linux/uuid.h>
 #include <linux/compat.h>
 #include <linux/jiffies.h>
-#include <linux/interrupt.h>
 
-#include "mei_dev.h"
+#include "backport/backport.h"
 #include "mei.h"
 #include "interface.h"
 #include "mei_version.h"
@@ -139,7 +140,7 @@ static int __devinit mei_probe(struct pci_dev *pdev,
 		goto disable_device;
 	}
 	/* allocates and initializes the mei dev structure */
-	dev = mei_device_init(pdev);
+	dev = init_mei_device(pdev);
 	if (!dev) {
 		err = -ENOMEM;
 		goto release_regions;
@@ -172,9 +173,7 @@ static int __devinit mei_probe(struct pci_dev *pdev,
 	schedule_delayed_work(&dev->wd_work, HZ);
 
 	mutex_unlock(&mei_mutex);
-
-	pr_debug("mei: Driver initialization successful.\n");
-
+	printk(KERN_INFO "mei: Driver initialization successful.\n");
 	return 0;
 
 release_irq:
@@ -184,7 +183,7 @@ release_irq:
 	flush_scheduled_work();
 	free_irq(pdev->irq, dev);
 unmap_memory:
-	pci_iounmap(pdev, dev->mem_addr);
+	iounmap(dev->mem_addr);
 free_device:
 	kfree(dev);
 release_regions:
@@ -217,27 +216,59 @@ static void __devexit mei_remove(struct pci_dev *pdev)
 		return;
 
 	mutex_lock(&dev->device_lock);
+	cancel_delayed_work(&dev->wd_work);
+	if (dev->wd_file_ext.state == MEI_FILE_CONNECTED && dev->wd_timeout) {
+		dev->wd_timeout = 0;
+		dev->wd_due_counter = 0;
+		memcpy(dev->wd_data, mei_stop_wd_params, MEI_WD_PARAMS_SIZE);
+		dev->stop = 1;
+		if (dev->mei_host_buffer_is_empty &&
+		    mei_flow_ctrl_creds(dev, &dev->wd_file_ext)) {
+			dev->mei_host_buffer_is_empty = 0;
+
+			if (!mei_send_wd(dev))
+				dev_dbg(&pdev->dev, "send stop WD failed\n");
+			else
+				mei_flow_ctrl_reduce(dev, &dev->wd_file_ext);
+
+			dev->wd_pending = 0;
+		} else {
+			dev->wd_pending = 1;
+		}
+		dev->wd_stopped = 0;
+		mutex_unlock(&dev->device_lock);
 
-	mei_wd_stop(dev, false);
+		wait_event_interruptible_timeout(dev->wait_stop_wd,
+				(dev->wd_stopped), 10 * HZ);
+		mutex_lock(&dev->device_lock);
+		if (!dev->wd_stopped)
+			dev_dbg(&pdev->dev, "stop wd failed to complete.\n");
+		else
+			dev_dbg(&pdev->dev, "stop wd complete.\n");
+
+	}
 
 	mei_device = NULL;
 
-	if (dev->iamthif_cl.state == MEI_FILE_CONNECTED) {
-		dev->iamthif_cl.state = MEI_FILE_DISCONNECTING;
-		mei_disconnect_host_client(dev, &dev->iamthif_cl);
+	if (dev->iamthif_file_ext.state == MEI_FILE_CONNECTED) {
+		dev->iamthif_file_ext.state = MEI_FILE_DISCONNECTING;
+		mei_disconnect_host_client(dev, &dev->iamthif_file_ext);
 	}
-	if (dev->wd_cl.state == MEI_FILE_CONNECTED) {
-		dev->wd_cl.state = MEI_FILE_DISCONNECTING;
-		mei_disconnect_host_client(dev, &dev->wd_cl);
+	if (dev->wd_file_ext.state == MEI_FILE_CONNECTED) {
+		dev->wd_file_ext.state = MEI_FILE_DISCONNECTING;
+		mei_disconnect_host_client(dev, &dev->wd_file_ext);
 	}
 
 	/* remove entry if already in list */
 	dev_dbg(&pdev->dev, "list del iamthif and wd file list.\n");
-	mei_remove_client_from_file_list(dev, dev->wd_cl.host_client_id);
-	mei_remove_client_from_file_list(dev, dev->iamthif_cl.host_client_id);
+	mei_remove_client_from_file_list(dev, dev->wd_file_ext.
+					  host_client_id);
+	mei_remove_client_from_file_list(dev,
+			dev->iamthif_file_ext.host_client_id);
 
 	dev->iamthif_current_cb = NULL;
-	dev->me_clients_num = 0;
+	dev->iamthif_file_ext.file = NULL;
+	dev->num_mei_me_clients = 0;
 
 	mutex_unlock(&dev->device_lock);
 
@@ -250,7 +281,7 @@ static void __devexit mei_remove(struct pci_dev *pdev)
 	pci_set_drvdata(pdev, NULL);
 
 	if (dev->mem_addr)
-		pci_iounmap(pdev, dev->mem_addr);
+		iounmap(dev->mem_addr);
 
 	kfree(dev);
 
@@ -274,27 +305,29 @@ static void __devexit mei_remove(struct pci_dev *pdev)
 static bool mei_clear_list(struct mei_device *dev,
 		struct file *file, struct list_head *mei_cb_list)
 {
-	struct mei_cl_cb *cb_pos = NULL;
-	struct mei_cl_cb *cb_next = NULL;
+	struct mei_cb_private *priv_cb_pos = NULL;
+	struct mei_cb_private *priv_cb_next = NULL;
 	struct file *file_temp;
 	bool removed = false;
 
 	/* list all list member */
-	list_for_each_entry_safe(cb_pos, cb_next, mei_cb_list, cb_list) {
-		file_temp = (struct file *)cb_pos->file_object;
+	list_for_each_entry_safe(priv_cb_pos, priv_cb_next,
+				 mei_cb_list, cb_list) {
+		file_temp = (struct file *)priv_cb_pos->file_object;
 		/* check if list member associated with a file */
 		if (file_temp == file) {
 			/* remove member from the list */
-			list_del(&cb_pos->cb_list);
+			list_del(&priv_cb_pos->cb_list);
 			/* check if cb equal to current iamthif cb */
-			if (dev->iamthif_current_cb == cb_pos) {
+			if (dev->iamthif_current_cb == priv_cb_pos) {
 				dev->iamthif_current_cb = NULL;
 				/* send flow control to iamthif client */
-				mei_send_flow_control(dev, &dev->iamthif_cl);
+				mei_send_flow_control(dev,
+						       &dev->iamthif_file_ext);
 			}
 			/* free all allocated buffers */
-			mei_free_cb_private(cb_pos);
-			cb_pos = NULL;
+			mei_free_cb_private(priv_cb_pos);
+			priv_cb_pos = NULL;
 			removed = true;
 		}
 	}
@@ -327,7 +360,8 @@ static bool mei_clear_lists(struct mei_device *dev, struct file *file)
 	if (mei_clear_list(dev, file, &dev->ctrl_wr_list.mei_cb.cb_list))
 		removed = true;
 
-	if (mei_clear_list(dev, file, &dev->write_waiting_list.mei_cb.cb_list))
+	if (mei_clear_list(dev, file,
+			    &dev->write_waiting_list.mei_cb.cb_list))
 		removed = true;
 
 	if (mei_clear_list(dev, file, &dev->write_list.mei_cb.cb_list))
@@ -353,24 +387,29 @@ static bool mei_clear_lists(struct mei_device *dev, struct file *file)
  *
  * returns cb on success, NULL on error
  */
-static struct mei_cl_cb *find_read_list_entry(
+static struct mei_cb_private *find_read_list_entry(
 		struct mei_device *dev,
-		struct mei_cl *cl)
+		struct mei_file_private *file_ext)
 {
-	struct mei_cl_cb *cb_pos = NULL;
-	struct mei_cl_cb *cb_next = NULL;
+	struct mei_cb_private *priv_cb_pos = NULL;
+	struct mei_cb_private *priv_cb_next = NULL;
+	struct mei_file_private *file_ext_list_temp;
 
 	if (!dev->read_list.status &&
 	    !list_empty(&dev->read_list.mei_cb.cb_list)) {
 
 		dev_dbg(&dev->pdev->dev, "remove read_list CB\n");
-		list_for_each_entry_safe(cb_pos, cb_next,
+		list_for_each_entry_safe(priv_cb_pos,
+				priv_cb_next,
 				&dev->read_list.mei_cb.cb_list, cb_list) {
-			struct mei_cl *cl_temp;
-			cl_temp = (struct mei_cl *)cb_pos->file_private;
 
-			if (mei_cl_cmp_id(cl, cl_temp))
-				return cb_pos;
+			file_ext_list_temp = (struct mei_file_private *)
+				priv_cb_pos->file_private;
+
+			if (file_ext_list_temp &&
+			    mei_fe_same_id(file_ext, file_ext_list_temp))
+				return priv_cb_pos;
+
 		}
 	}
 	return NULL;
@@ -386,7 +425,7 @@ static struct mei_cl_cb *find_read_list_entry(
  */
 static int mei_open(struct inode *inode, struct file *file)
 {
-	struct mei_cl *cl;
+	struct mei_file_private *file_ext;
 	int if_num = iminor(inode), err;
 	struct mei_device *dev;
 
@@ -400,8 +439,8 @@ static int mei_open(struct inode *inode, struct file *file)
 
 	mutex_lock(&dev->device_lock);
 	err = -ENOMEM;
-	cl = mei_cl_allocate(dev);
-	if (!cl)
+	file_ext = mei_alloc_file_private(file);
+	if (!file_ext)
 		goto out;
 
 	err = -ENODEV;
@@ -414,28 +453,28 @@ static int mei_open(struct inode *inode, struct file *file)
 	if (dev->open_handle_count >= MEI_MAX_OPEN_HANDLE_COUNT)
 		goto out_unlock;
 
-	cl->host_client_id = find_first_zero_bit(dev->host_clients_map,
+	file_ext->host_client_id = find_first_zero_bit(dev->host_clients_map,
 							MEI_CLIENTS_MAX);
-	if (cl->host_client_id > MEI_CLIENTS_MAX)
+	if (file_ext->host_client_id > MEI_CLIENTS_MAX)
 		goto out_unlock;
 
-	dev_dbg(&dev->pdev->dev, "client_id = %d\n", cl->host_client_id);
+	dev_dbg(&dev->pdev->dev, "client_id = %d\n", file_ext->host_client_id);
 
 	dev->open_handle_count++;
-	list_add_tail(&cl->link, &dev->file_list);
+	list_add_tail(&file_ext->link, &dev->file_list);
 
-	set_bit(cl->host_client_id, dev->host_clients_map);
-	cl->state = MEI_FILE_INITIALIZING;
-	cl->sm_state = 0;
+	set_bit(file_ext->host_client_id, dev->host_clients_map);
+	file_ext->state = MEI_FILE_INITIALIZING;
+	file_ext->sm_state = 0;
 
-	file->private_data = cl;
+	file->private_data = file_ext;
 	mutex_unlock(&dev->device_lock);
 
 	return 0;
 
 out_unlock:
 	mutex_unlock(&dev->device_lock);
-	kfree(cl);
+	kfree(file_ext);
 out:
 	return err;
 }
@@ -450,59 +489,62 @@ out:
  */
 static int mei_release(struct inode *inode, struct file *file)
 {
-	struct mei_cl *cl = file->private_data;
-	struct mei_cl_cb *cb;
+	struct mei_file_private *file_ext = file->private_data;
+	struct mei_cb_private *priv_cb;
 	struct mei_device *dev;
+	int if_num = iminor(inode);
 	int rets = 0;
 
-	if (WARN_ON(!cl || !cl->dev))
+	if (!mei_device)
 		return -ENODEV;
 
-	dev = cl->dev;
+	dev = pci_get_drvdata(mei_device);
+	if (if_num != MEI_MINOR_NUMBER || !dev || !file_ext)
+		return -ENODEV;
 
 	mutex_lock(&dev->device_lock);
-	if (cl != &dev->iamthif_cl) {
-		if (cl->state == MEI_FILE_CONNECTED) {
-			cl->state = MEI_FILE_DISCONNECTING;
+	if (file_ext != &dev->iamthif_file_ext) {
+		if (file_ext->state == MEI_FILE_CONNECTED) {
+			file_ext->state = MEI_FILE_DISCONNECTING;
 			dev_dbg(&dev->pdev->dev,
 				"disconnecting client host client = %d, "
 			    "ME client = %d\n",
-			    cl->host_client_id,
-			    cl->me_client_id);
-			rets = mei_disconnect_host_client(dev, cl);
+			    file_ext->host_client_id,
+			    file_ext->me_client_id);
+			rets = mei_disconnect_host_client(dev, file_ext);
 		}
-		mei_cl_flush_queues(cl);
+		mei_flush_queues(dev, file_ext);
 		dev_dbg(&dev->pdev->dev, "remove client host client = %d, ME client = %d\n",
-		    cl->host_client_id,
-		    cl->me_client_id);
+		    file_ext->host_client_id,
+		    file_ext->me_client_id);
 
 		if (dev->open_handle_count > 0) {
-			clear_bit(cl->host_client_id,
+			clear_bit(file_ext->host_client_id,
 				  dev->host_clients_map);
 			dev->open_handle_count--;
 		}
-		mei_remove_client_from_file_list(dev, cl->host_client_id);
+		mei_remove_client_from_file_list(dev, file_ext->host_client_id);
 
 		/* free read cb */
-		cb = NULL;
-		if (cl->read_cb) {
-			cb = find_read_list_entry(dev, cl);
+		priv_cb = NULL;
+		if (file_ext->read_cb) {
+			priv_cb = find_read_list_entry(dev, file_ext);
 			/* Remove entry from read list */
-			if (cb)
-				list_del(&cb->cb_list);
+			if (priv_cb)
+				list_del(&priv_cb->cb_list);
 
-			cb = cl->read_cb;
-			cl->read_cb = NULL;
+			priv_cb = file_ext->read_cb;
+			file_ext->read_cb = NULL;
 		}
 
 		file->private_data = NULL;
 
-		if (cb) {
-			mei_free_cb_private(cb);
-			cb = NULL;
+		if (priv_cb) {
+			mei_free_cb_private(priv_cb);
+			priv_cb = NULL;
 		}
 
-		kfree(cl);
+		kfree(file_ext);
 	} else {
 		if (dev->open_handle_count > 0)
 			dev->open_handle_count--;
@@ -512,10 +554,10 @@ static int mei_release(struct inode *inode, struct file *file)
 
 			dev_dbg(&dev->pdev->dev, "amthi canceled iamthif state %d\n",
 			    dev->iamthif_state);
-			dev->iamthif_canceled = true;
+			dev->iamthif_canceled = 1;
 			if (dev->iamthif_state == MEI_IAMTHIF_READ_COMPLETE) {
 				dev_dbg(&dev->pdev->dev, "run next amthi iamthif cb\n");
-				mei_run_next_iamthif_cmd(dev);
+				run_next_iamthif_cmd(dev);
 			}
 		}
 
@@ -541,19 +583,21 @@ static int mei_release(struct inode *inode, struct file *file)
 static ssize_t mei_read(struct file *file, char __user *ubuf,
 			 size_t length, loff_t *offset)
 {
-	struct mei_cl *cl = file->private_data;
-	struct mei_cl_cb *cb_pos = NULL;
-	struct mei_cl_cb *cb = NULL;
-	struct mei_device *dev;
 	int i;
 	int rets;
 	int err;
+	int if_num = iminor(file->f_dentry->d_inode);
+	struct mei_file_private *file_ext = file->private_data;
+	struct mei_cb_private *priv_cb_pos = NULL;
+	struct mei_cb_private *priv_cb = NULL;
+	struct mei_device *dev;
 
-
-	if (WARN_ON(!cl || !cl->dev))
+	if (!mei_device)
 		return -ENODEV;
 
-	dev = cl->dev;
+	dev = pci_get_drvdata(mei_device);
+	if (if_num != MEI_MINOR_NUMBER || !dev || !file_ext)
+		return -ENODEV;
 
 	mutex_lock(&dev->device_lock);
 	if (dev->mei_state != MEI_ENABLED) {
@@ -561,35 +605,35 @@ static ssize_t mei_read(struct file *file, char __user *ubuf,
 		goto out;
 	}
 
-	if ((cl->sm_state & MEI_WD_STATE_INDEPENDENCE_MSG_SENT) == 0) {
+	if ((file_ext->sm_state & MEI_WD_STATE_INDEPENDENCE_MSG_SENT) == 0) {
 		/* Do not allow to read watchdog client */
 		i = mei_find_me_client_index(dev, mei_wd_guid);
 		if (i >= 0) {
 			struct mei_me_client *me_client = &dev->me_clients[i];
 
-			if (cl->me_client_id == me_client->client_id) {
+			if (file_ext->me_client_id == me_client->client_id) {
 				rets = -EBADF;
 				goto out;
 			}
 		}
 	} else {
-		cl->sm_state &= ~MEI_WD_STATE_INDEPENDENCE_MSG_SENT;
+		file_ext->sm_state &= ~MEI_WD_STATE_INDEPENDENCE_MSG_SENT;
 	}
 
-	if (cl == &dev->iamthif_cl) {
-		rets = amthi_read(dev, file, ubuf, length, offset);
+	if (file_ext == &dev->iamthif_file_ext) {
+		rets = amthi_read(dev, if_num, file, ubuf, length, offset);
 		goto out;
 	}
 
-	if (cl->read_cb && cl->read_cb->information > *offset) {
-		cb = cl->read_cb;
+	if (file_ext->read_cb && file_ext->read_cb->information > *offset) {
+		priv_cb = file_ext->read_cb;
 		goto copy_buffer;
-	} else if (cl->read_cb && cl->read_cb->information > 0 &&
-		   cl->read_cb->information <= *offset) {
-		cb = cl->read_cb;
+	} else if (file_ext->read_cb && file_ext->read_cb->information > 0 &&
+		   file_ext->read_cb->information <= *offset) {
+		priv_cb = file_ext->read_cb;
 		rets = 0;
 		goto free;
-	} else if ((!cl->read_cb || !cl->read_cb->information) &&
+	} else if ((!file_ext->read_cb || !file_ext->read_cb->information) &&
 		    *offset > 0) {
 		/*Offset needs to be cleaned for contingous reads*/
 		*offset = 0;
@@ -597,16 +641,17 @@ static ssize_t mei_read(struct file *file, char __user *ubuf,
 		goto out;
 	}
 
-	err = mei_start_read(dev, cl);
-	if (err && err != -EBUSY) {
+	err = mei_start_read(dev, if_num, file_ext);
+	if (err != 0 && err != -EBUSY) {
 		dev_dbg(&dev->pdev->dev,
-			"mei start read failure with status = %d\n", err);
+				"mei start read failure with status = %d\n",
+				err);
 		rets = err;
 		goto out;
 	}
 
-	if (MEI_READ_COMPLETE != cl->reading_state &&
-			!waitqueue_active(&cl->rx_wait)) {
+	if (MEI_READ_COMPLETE != file_ext->reading_state &&
+			!waitqueue_active(&file_ext->rx_wait)) {
 		if (file->f_flags & O_NONBLOCK) {
 			rets = -EAGAIN;
 			goto out;
@@ -614,52 +659,52 @@ static ssize_t mei_read(struct file *file, char __user *ubuf,
 
 		mutex_unlock(&dev->device_lock);
 
-		if (wait_event_interruptible(cl->rx_wait,
-			(MEI_READ_COMPLETE == cl->reading_state ||
-			 MEI_FILE_INITIALIZING == cl->state ||
-			 MEI_FILE_DISCONNECTED == cl->state ||
-			 MEI_FILE_DISCONNECTING == cl->state))) {
+		if (wait_event_interruptible(file_ext->rx_wait,
+			(MEI_READ_COMPLETE == file_ext->reading_state ||
+			 MEI_FILE_INITIALIZING == file_ext->state ||
+			 MEI_FILE_DISCONNECTED == file_ext->state ||
+			 MEI_FILE_DISCONNECTING == file_ext->state))) {
 			if (signal_pending(current))
 				return -EINTR;
 			return -ERESTARTSYS;
 		}
 
 		mutex_lock(&dev->device_lock);
-		if (MEI_FILE_INITIALIZING == cl->state ||
-		    MEI_FILE_DISCONNECTED == cl->state ||
-		    MEI_FILE_DISCONNECTING == cl->state) {
+		if (MEI_FILE_INITIALIZING == file_ext->state ||
+		    MEI_FILE_DISCONNECTED == file_ext->state ||
+		    MEI_FILE_DISCONNECTING == file_ext->state) {
 			rets = -EBUSY;
 			goto out;
 		}
 	}
 
-	cb = cl->read_cb;
+	priv_cb = file_ext->read_cb;
 
-	if (!cb) {
+	if (!priv_cb) {
 		rets = -ENODEV;
 		goto out;
 	}
-	if (cl->reading_state != MEI_READ_COMPLETE) {
+	if (file_ext->reading_state != MEI_READ_COMPLETE) {
 		rets = 0;
 		goto out;
 	}
 	/* now copy the data to user space */
 copy_buffer:
-	dev_dbg(&dev->pdev->dev, "cb->response_buffer size - %d\n",
-	    cb->response_buffer.size);
-	dev_dbg(&dev->pdev->dev, "cb->information - %lu\n",
-	    cb->information);
-	if (length == 0 || ubuf == NULL || *offset > cb->information) {
+	dev_dbg(&dev->pdev->dev, "priv_cb->response_buffer size - %d\n",
+	    priv_cb->response_buffer.size);
+	dev_dbg(&dev->pdev->dev, "priv_cb->information - %lu\n",
+	    priv_cb->information);
+	if (length == 0 || ubuf == NULL || *offset > priv_cb->information) {
 		rets = -EMSGSIZE;
 		goto free;
 	}
 
 	/* length is being turncated to PAGE_SIZE, however, */
 	/* information size may be longer */
-	length = min_t(size_t, length, (cb->information - *offset));
+	length = min_t(size_t, length, (priv_cb->information - *offset));
 
 	if (copy_to_user(ubuf,
-			 cb->response_buffer.data + *offset,
+			 priv_cb->response_buffer.data + *offset,
 			 length)) {
 		rets = -EFAULT;
 		goto free;
@@ -667,18 +712,18 @@ copy_buffer:
 
 	rets = length;
 	*offset += length;
-	if ((unsigned long)*offset < cb->information)
+	if ((unsigned long)*offset < priv_cb->information)
 		goto out;
 
 free:
-	cb_pos = find_read_list_entry(dev, cl);
+	priv_cb_pos = find_read_list_entry(dev, file_ext);
 	/* Remove entry from read list */
-	if (cb_pos)
-		list_del(&cb_pos->cb_list);
-	mei_free_cb_private(cb);
-	cl->reading_state = MEI_IDLE;
-	cl->read_cb = NULL;
-	cl->read_pending = 0;
+	if (priv_cb_pos)
+		list_del(&priv_cb_pos->cb_list);
+	mei_free_cb_private(priv_cb);
+	file_ext->reading_state = MEI_IDLE;
+	file_ext->read_cb = NULL;
+	file_ext->read_pending = 0;
 out:
 	dev_dbg(&dev->pdev->dev, "end mei read rets= %d\n", rets);
 	mutex_unlock(&dev->device_lock);
@@ -698,18 +743,22 @@ out:
 static ssize_t mei_write(struct file *file, const char __user *ubuf,
 			  size_t length, loff_t *offset)
 {
-	struct mei_cl *cl = file->private_data;
-	struct mei_cl_cb *write_cb = NULL;
+	struct mei_file_private *file_ext = file->private_data;
+	struct mei_cb_private *priv_write_cb = NULL;
 	struct mei_msg_hdr mei_hdr;
 	struct mei_device *dev;
 	unsigned long timeout = 0;
+	int if_num = iminor(file->f_dentry->d_inode);
 	int rets;
 	int i;
 
-	if (WARN_ON(!cl || !cl->dev))
+	if (!mei_device)
 		return -ENODEV;
 
-	dev = cl->dev;
+	dev = pci_get_drvdata(mei_device);
+
+	if (if_num != MEI_MINOR_NUMBER || !dev || !file_ext)
+		return -ENODEV;
 
 	mutex_lock(&dev->device_lock);
 
@@ -718,74 +767,74 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 		return -ENODEV;
 	}
 
-	if (cl == &dev->iamthif_cl) {
-		write_cb = find_amthi_read_list_entry(dev, file);
+	if (file_ext == &dev->iamthif_file_ext) {
+		priv_write_cb = find_amthi_read_list_entry(dev, file);
 
-		if (write_cb) {
-			timeout = write_cb->read_time +
+		if (priv_write_cb) {
+			timeout = priv_write_cb->read_time +
 					msecs_to_jiffies(IAMTHIF_READ_TIMER);
 
 			if (time_after(jiffies, timeout) ||
-				 cl->reading_state == MEI_READ_COMPLETE) {
+				 file_ext->reading_state == MEI_READ_COMPLETE) {
 					*offset = 0;
-					list_del(&write_cb->cb_list);
-					mei_free_cb_private(write_cb);
-					write_cb = NULL;
+					list_del(&priv_write_cb->cb_list);
+					mei_free_cb_private(priv_write_cb);
+					priv_write_cb = NULL;
 			}
 		}
 	}
 
 	/* free entry used in read */
-	if (cl->reading_state == MEI_READ_COMPLETE) {
+	if (file_ext->reading_state == MEI_READ_COMPLETE) {
 		*offset = 0;
-		write_cb = find_read_list_entry(dev, cl);
-		if (write_cb) {
-			list_del(&write_cb->cb_list);
-			mei_free_cb_private(write_cb);
-			write_cb = NULL;
-			cl->reading_state = MEI_IDLE;
-			cl->read_cb = NULL;
-			cl->read_pending = 0;
+		priv_write_cb = find_read_list_entry(dev, file_ext);
+		if (priv_write_cb) {
+			list_del(&priv_write_cb->cb_list);
+			mei_free_cb_private(priv_write_cb);
+			priv_write_cb = NULL;
+			file_ext->reading_state = MEI_IDLE;
+			file_ext->read_cb = NULL;
+			file_ext->read_pending = 0;
 		}
-	} else if (cl->reading_state == MEI_IDLE &&
-		   !cl->read_pending)
+	} else if (file_ext->reading_state == MEI_IDLE &&
+		   !file_ext->read_pending)
 		*offset = 0;
 
 
-	write_cb = kzalloc(sizeof(struct mei_cl_cb), GFP_KERNEL);
-	if (!write_cb) {
+	priv_write_cb = kzalloc(sizeof(struct mei_cb_private), GFP_KERNEL);
+	if (!priv_write_cb) {
 		mutex_unlock(&dev->device_lock);
 		return -ENOMEM;
 	}
 
-	write_cb->file_object = file;
-	write_cb->file_private = cl;
-	write_cb->request_buffer.data = kmalloc(length, GFP_KERNEL);
+	priv_write_cb->file_object = file;
+	priv_write_cb->file_private = file_ext;
+	priv_write_cb->request_buffer.data = kmalloc(length, GFP_KERNEL);
 	rets = -ENOMEM;
-	if (!write_cb->request_buffer.data)
+	if (!priv_write_cb->request_buffer.data)
 		goto unlock_dev;
 
 	dev_dbg(&dev->pdev->dev, "length =%d\n", (int) length);
 
 	rets = -EFAULT;
-	if (copy_from_user(write_cb->request_buffer.data, ubuf, length))
+	if (copy_from_user(priv_write_cb->request_buffer.data, ubuf, length))
 		goto unlock_dev;
 
-	cl->sm_state = 0;
+	file_ext->sm_state = 0;
 	if (length == 4 &&
 	    ((memcmp(mei_wd_state_independence_msg[0],
-				 write_cb->request_buffer.data, 4) == 0) ||
+				 priv_write_cb->request_buffer.data, 4) == 0) ||
 	     (memcmp(mei_wd_state_independence_msg[1],
-				 write_cb->request_buffer.data, 4) == 0) ||
+				 priv_write_cb->request_buffer.data, 4) == 0) ||
 	     (memcmp(mei_wd_state_independence_msg[2],
-				 write_cb->request_buffer.data, 4) == 0)))
-		cl->sm_state |= MEI_WD_STATE_INDEPENDENCE_MSG_SENT;
+				 priv_write_cb->request_buffer.data, 4) == 0)))
+		file_ext->sm_state |= MEI_WD_STATE_INDEPENDENCE_MSG_SENT;
 
-	INIT_LIST_HEAD(&write_cb->cb_list);
-	if (cl == &dev->iamthif_cl) {
-		write_cb->response_buffer.data =
+	INIT_LIST_HEAD(&priv_write_cb->cb_list);
+	if (file_ext == &dev->iamthif_file_ext) {
+		priv_write_cb->response_buffer.data =
 		    kmalloc(dev->iamthif_mtu, GFP_KERNEL);
-		if (!write_cb->response_buffer.data) {
+		if (!priv_write_cb->response_buffer.data) {
 			rets = -ENOMEM;
 			goto unlock_dev;
 		}
@@ -793,19 +842,16 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 			rets = -ENODEV;
 			goto unlock_dev;
 		}
-		for (i = 0; i < dev->me_clients_num; i++) {
+		for (i = 0; i < dev->num_mei_me_clients; i++) {
 			if (dev->me_clients[i].client_id ==
-				dev->iamthif_cl.me_client_id)
+				dev->iamthif_file_ext.me_client_id)
 				break;
 		}
 
-		if (WARN_ON(dev->me_clients[i].client_id != cl->me_client_id)) {
-			rets = -ENODEV;
-			goto unlock_dev;
-		}
-		if (i == dev->me_clients_num ||
+		BUG_ON(dev->me_clients[i].client_id != file_ext->me_client_id);
+		if (i == dev->num_mei_me_clients ||
 		    (dev->me_clients[i].client_id !=
-		      dev->iamthif_cl.me_client_id)) {
+		      dev->iamthif_file_ext.me_client_id)) {
 			rets = -ENODEV;
 			goto unlock_dev;
 		} else if (length > dev->me_clients[i].props.max_msg_length ||
@@ -814,11 +860,11 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 			goto unlock_dev;
 		}
 
-		write_cb->response_buffer.size = dev->iamthif_mtu;
-		write_cb->major_file_operations = MEI_IOCTL;
-		write_cb->information = 0;
-		write_cb->request_buffer.size = length;
-		if (dev->iamthif_cl.state != MEI_FILE_CONNECTED) {
+		priv_write_cb->response_buffer.size = dev->iamthif_mtu;
+		priv_write_cb->major_file_operations = MEI_IOCTL;
+		priv_write_cb->information = 0;
+		priv_write_cb->request_buffer.size = length;
+		if (dev->iamthif_file_ext.state != MEI_FILE_CONNECTED) {
 			rets = -ENODEV;
 			goto unlock_dev;
 		}
@@ -828,12 +874,12 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 			dev_dbg(&dev->pdev->dev, "amthi_state = %d\n",
 					(int) dev->iamthif_state);
 			dev_dbg(&dev->pdev->dev, "add amthi cb to amthi cmd waiting list\n");
-			list_add_tail(&write_cb->cb_list,
+			list_add_tail(&priv_write_cb->cb_list,
 					&dev->amthi_cmd_list.mei_cb.cb_list);
 			rets = length;
 		} else {
 			dev_dbg(&dev->pdev->dev, "call amthi write\n");
-			rets = amthi_write(dev, write_cb);
+			rets = amthi_write(dev, priv_write_cb);
 
 			if (rets) {
 				dev_dbg(&dev->pdev->dev, "amthi write failed with status = %d\n",
@@ -846,31 +892,28 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 		return rets;
 	}
 
-	write_cb->major_file_operations = MEI_WRITE;
+	priv_write_cb->major_file_operations = MEI_WRITE;
 	/* make sure information is zero before we start */
 
-	write_cb->information = 0;
-	write_cb->request_buffer.size = length;
+	priv_write_cb->information = 0;
+	priv_write_cb->request_buffer.size = length;
 
 	dev_dbg(&dev->pdev->dev, "host client = %d, ME client = %d\n",
-	    cl->host_client_id, cl->me_client_id);
-	if (cl->state != MEI_FILE_CONNECTED) {
+	    file_ext->host_client_id, file_ext->me_client_id);
+	if (file_ext->state != MEI_FILE_CONNECTED) {
 		rets = -ENODEV;
 		dev_dbg(&dev->pdev->dev, "host client = %d,  is not connected to ME client = %d",
-		    cl->host_client_id,
-		    cl->me_client_id);
+		    file_ext->host_client_id,
+		    file_ext->me_client_id);
 		goto unlock_dev;
 	}
-	for (i = 0; i < dev->me_clients_num; i++) {
+	for (i = 0; i < dev->num_mei_me_clients; i++) {
 		if (dev->me_clients[i].client_id ==
-		    cl->me_client_id)
+		    file_ext->me_client_id)
 			break;
 	}
-	if (WARN_ON(dev->me_clients[i].client_id != cl->me_client_id)) {
-		rets = -ENODEV;
-		goto unlock_dev;
-	}
-	if (i == dev->me_clients_num) {
+	BUG_ON(dev->me_clients[i].client_id != file_ext->me_client_id);
+	if (i == dev->num_mei_me_clients) {
 		rets = -ENODEV;
 		goto unlock_dev;
 	}
@@ -878,15 +921,11 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 		rets = -EINVAL;
 		goto unlock_dev;
 	}
-	write_cb->file_private = cl;
+	priv_write_cb->file_private = file_ext;
 
-	rets = mei_flow_ctrl_creds(dev, cl);
-	if (rets < 0)
-		goto unlock_dev;
-
-	if (rets && dev->mei_host_buffer_is_empty) {
-		rets = 0;
-		dev->mei_host_buffer_is_empty = false;
+	if (mei_flow_ctrl_creds(dev, file_ext) &&
+		dev->mei_host_buffer_is_empty) {
+		dev->mei_host_buffer_is_empty = 0;
 		if (length > ((((dev->host_hw_state & H_CBD) >> 24) *
 			sizeof(u32)) - sizeof(struct mei_msg_hdr))) {
 
@@ -899,36 +938,33 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 			mei_hdr.length = length;
 			mei_hdr.msg_complete = 1;
 		}
-		mei_hdr.host_addr = cl->host_client_id;
-		mei_hdr.me_addr = cl->me_client_id;
+		mei_hdr.host_addr = file_ext->host_client_id;
+		mei_hdr.me_addr = file_ext->me_client_id;
 		mei_hdr.reserved = 0;
 		dev_dbg(&dev->pdev->dev, "call mei_write_message header=%08x.\n",
 		    *((u32 *) &mei_hdr));
 		if (!mei_write_message(dev, &mei_hdr,
-			(unsigned char *) (write_cb->request_buffer.data),
+			(unsigned char *) (priv_write_cb->request_buffer.data),
 			mei_hdr.length)) {
 			rets = -ENODEV;
 			goto unlock_dev;
 		}
-		cl->writing_state = MEI_WRITING;
-		write_cb->information = mei_hdr.length;
+		file_ext->writing_state = MEI_WRITING;
+		priv_write_cb->information = mei_hdr.length;
 		if (mei_hdr.msg_complete) {
-			if (mei_flow_ctrl_reduce(dev, cl)) {
-				rets = -ENODEV;
-				goto unlock_dev;
-			}
-			list_add_tail(&write_cb->cb_list,
+			mei_flow_ctrl_reduce(dev, file_ext);
+			list_add_tail(&priv_write_cb->cb_list,
 				      &dev->write_waiting_list.mei_cb.cb_list);
 		} else {
-			list_add_tail(&write_cb->cb_list,
+			list_add_tail(&priv_write_cb->cb_list,
 				      &dev->write_list.mei_cb.cb_list);
 		}
 
 	} else {
 
-		write_cb->information = 0;
-		cl->writing_state = MEI_WRITING;
-		list_add_tail(&write_cb->cb_list,
+		priv_write_cb->information = 0;
+		file_ext->writing_state = MEI_WRITING;
+		list_add_tail(&priv_write_cb->cb_list,
 			      &dev->write_list.mei_cb.cb_list);
 	}
 	mutex_unlock(&dev->device_lock);
@@ -936,7 +972,7 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 
 unlock_dev:
 	mutex_unlock(&dev->device_lock);
-	mei_free_cb_private(write_cb);
+	mei_free_cb_private(priv_write_cb);
 	return rets;
 }
 
@@ -950,60 +986,79 @@ unlock_dev:
  *
  * returns 0 on success , <0 on error
  */
-static long mei_ioctl(struct file *file, unsigned int cmd, unsigned long data)
+static long mei_ioctl(struct file *file,
+		      unsigned int cmd, unsigned long data)
 {
+	struct inode *inode;
+	struct mei_file_private *file_ext = file->private_data;
+	int rets;
+	int if_num;
 	struct mei_device *dev;
-	struct mei_cl *cl = file->private_data;
+
+	/* User Data */
 	struct mei_connect_client_data *connect_data = NULL;
-	int rets;
 
-	if (cmd != IOCTL_MEI_CONNECT_CLIENT)
-		return -EINVAL;
+	/* Fix in order to use unlocked_ioctl for suppoer kernel >= 2.6.36 */
+	inode = file->f_dentry->d_inode;
+	if_num = iminor(inode);
 
-	if (WARN_ON(!cl || !cl->dev))
+	if (!mei_device)
 		return -ENODEV;
 
-	dev = cl->dev;
-
-	dev_dbg(&dev->pdev->dev, "IOCTL cmd = 0x%x", cmd);
+	dev = pci_get_drvdata(mei_device);
+	if (if_num != MEI_MINOR_NUMBER || !dev || !file_ext)
+		return -ENODEV;
 
 	mutex_lock(&dev->device_lock);
 	if (dev->mei_state != MEI_ENABLED) {
 		rets = -ENODEV;
-		goto out;
+		goto Err_free_lock;
 	}
 
-	dev_dbg(&dev->pdev->dev, ": IOCTL_MEI_CONNECT_CLIENT.\n");
+	dev_dbg(&dev->pdev->dev, "IOCTL cmd = 0x%x", cmd);
 
-	connect_data = kzalloc(sizeof(struct mei_connect_client_data),
-							GFP_KERNEL);
-	if (!connect_data) {
-		rets = -ENOMEM;
-		goto out;
-	}
-	dev_dbg(&dev->pdev->dev, "copy connect data from user\n");
-	if (copy_from_user(connect_data, (char __user *)data,
-				sizeof(struct mei_connect_client_data))) {
-		dev_dbg(&dev->pdev->dev, "failed to copy data from userland\n");
-		rets = -EFAULT;
-		goto out;
-	}
-	rets = mei_ioctl_connect_client(file, connect_data);
+	switch (cmd) {
+	case IOCTL_MEI_CONNECT_CLIENT:
+		dev_dbg(&dev->pdev->dev, ": IOCTL_MEI_CONNECT_CLIENT.\n");
 
-	/* if all is ok, copying the data back to user. */
-	if (rets)
-		goto out;
+		connect_data = kzalloc(sizeof(struct mei_connect_client_data),
+								GFP_KERNEL);
 
-	dev_dbg(&dev->pdev->dev, "copy connect data to user\n");
-	if (copy_to_user((char __user *)data, connect_data,
+		dev_dbg(&dev->pdev->dev, "copy connect data from user\n");
+		if (copy_from_user(connect_data,
+				(char __user *)data,
 				sizeof(struct mei_connect_client_data))) {
-		dev_dbg(&dev->pdev->dev, "failed to copy data to userland\n");
-		rets = -EFAULT;
-		goto out;
+			dev_dbg(&dev->pdev->dev, "failed to copy data from userland\n");
+			rets = -EFAULT;
+			goto Err_free_mem;
+		}
+		rets = mei_ioctl_connect_client(dev, if_num,
+								connect_data,
+								file);
+
+		dev_dbg(&dev->pdev->dev, "copy connect data to user\n");
+		/* if all is ok, copying the data back to user. */
+		if (!rets) {
+			if (copy_to_user((char __user *)data,
+				connect_data,
+				sizeof(struct mei_connect_client_data))) {
+				dev_dbg(&dev->pdev->dev, "failed to copy data to userland\n");
+				rets = -EFAULT;
+				goto Err_free_mem;
+			}
+		}
+
+		break;
+
+	default:
+		rets = -EINVAL;
+		break;
 	}
 
-out:
+Err_free_mem:
 	kfree(connect_data);
+
+Err_free_lock:
 	mutex_unlock(&dev->device_lock);
 	return rets;
 }
@@ -1036,14 +1091,18 @@ static long mei_compat_ioctl(struct file *file,
  */
 static unsigned int mei_poll(struct file *file, poll_table *wait)
 {
-	struct mei_cl *cl = file->private_data;
+	struct mei_file_private *file_ext = file->private_data;
 	struct mei_device *dev;
+	int if_num = iminor(file->f_dentry->d_inode);
 	unsigned int mask = 0;
 
-	if (WARN_ON(!cl || !cl->dev))
+	if (!mei_device)
 		return mask;
 
-	dev = cl->dev;
+	dev = pci_get_drvdata(mei_device);
+
+	if (if_num != MEI_MINOR_NUMBER || !dev || !file_ext)
+		return mask;
 
 	mutex_lock(&dev->device_lock);
 
@@ -1051,23 +1110,23 @@ static unsigned int mei_poll(struct file *file, poll_table *wait)
 		goto out;
 
 
-	if (cl == &dev->iamthif_cl) {
+	if (file_ext == &dev->iamthif_file_ext) {
 		mutex_unlock(&dev->device_lock);
-		poll_wait(file, &dev->iamthif_cl.wait, wait);
+		poll_wait(file, &dev->iamthif_file_ext.wait, wait);
 		mutex_lock(&dev->device_lock);
 		if (dev->iamthif_state == MEI_IAMTHIF_READ_COMPLETE &&
 			dev->iamthif_file_object == file) {
 			mask |= (POLLIN | POLLRDNORM);
 			dev_dbg(&dev->pdev->dev, "run next amthi cb\n");
-			mei_run_next_iamthif_cmd(dev);
+			run_next_iamthif_cmd(dev);
 		}
 		goto out;
 	}
 
 	mutex_unlock(&dev->device_lock);
-	poll_wait(file, &cl->tx_wait, wait);
+	poll_wait(file, &file_ext->tx_wait, wait);
 	mutex_lock(&dev->device_lock);
-	if (MEI_WRITE_COMPLETE == cl->writing_state)
+	if (MEI_WRITE_COMPLETE == file_ext->writing_state)
 		mask |= (POLLIN | POLLRDNORM);
 
 out:
@@ -1080,13 +1139,46 @@ static int mei_pci_suspend(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);
 	struct mei_device *dev = pci_get_drvdata(pdev);
-	int err;
+	int err = 0;
 
 	if (!dev)
 		return -ENODEV;
 	mutex_lock(&dev->device_lock);
 	/* Stop watchdog if exists */
-	err = mei_wd_stop(dev, true);
+	cancel_delayed_work(&dev->wd_work);
+	if (dev->wd_file_ext.state == MEI_FILE_CONNECTED && dev->wd_timeout) {
+		u16 wd_timeout = dev->wd_timeout;
+		dev->wd_timeout = 0;
+		dev->wd_due_counter = 0;
+		memcpy(dev->wd_data, mei_stop_wd_params, MEI_WD_PARAMS_SIZE);
+		dev->stop = 1;
+		if (dev->mei_host_buffer_is_empty &&
+		    mei_flow_ctrl_creds(dev, &dev->wd_file_ext)) {
+			dev->mei_host_buffer_is_empty = 0;
+			if (!mei_send_wd(dev))
+				dev_dbg(&dev->pdev->dev, "send stop WD failed\n");
+			else
+				mei_flow_ctrl_reduce(dev, &dev->wd_file_ext);
+
+			dev->wd_pending = 0;
+		} else {
+			dev->wd_pending = 1;
+		}
+		dev->wd_stopped = 0;
+
+		mutex_unlock(&dev->device_lock);
+		err = wait_event_interruptible_timeout(dev->wait_stop_wd,
+						       (dev->wd_stopped),
+						       10 * HZ);
+		mutex_lock(&dev->device_lock);
+		if (!dev->wd_stopped)
+			dev_dbg(&dev->pdev->dev, "stop wd failed to complete.\n");
+		else {
+			dev_dbg(&dev->pdev->dev, "stop wd complete %d.\n", err);
+			err = 0;
+		}
+		dev->wd_timeout = wd_timeout;
+	}
 	/* Set new mei state */
 	if (dev->mei_state == MEI_ENABLED ||
 	    dev->mei_state == MEI_RECOVERING_FROM_RESET) {
@@ -1129,16 +1221,22 @@ static int mei_pci_resume(struct device *device)
 
 	/* Start watchdog if stopped in suspend */
 	if (dev->wd_timeout) {
-		mei_wd_start_setup(dev);
+
+		memcpy(dev->wd_data, mei_start_wd_params,
+			MEI_WD_PARAMS_SIZE);
+		memcpy(dev->wd_data + MEI_WD_PARAMS_SIZE,
+			&dev->wd_timeout, sizeof(u16));
 		dev->wd_due_counter = 1;
+
 		schedule_delayed_work(&dev->wd_work, HZ);
+
 	}
 	return err;
 }
 static SIMPLE_DEV_PM_OPS(mei_pm_ops, mei_pci_suspend, mei_pci_resume);
 #define MEI_PM_OPS	(&mei_pm_ops)
 #else
-#define MEI_PM_OPS	NULL
+#define MIE_PM_OPS	NULL
 #endif /* CONFIG_PM */
 /*
  *  PCI driver structure
@@ -1289,8 +1387,8 @@ static int __init mei_init_module(void)
 {
 	int ret;
 
-	pr_debug("mei: %s - version %s\n",
-		mei_driver_string, mei_driver_version);
+	printk(KERN_INFO "mei: %s - version %s\n", mei_driver_string,
+			mei_driver_version);
 	/* init pci module */
 	ret = pci_register_driver(&mei_driver);
 	if (ret < 0) {
@@ -1326,11 +1424,11 @@ module_init(mei_init_module);
  */
 static void __exit mei_exit_module(void)
 {
+	pci_unregister_driver(&mei_driver);
 	mei_sysfs_device_remove();
 	mei_unregister_cdev();
-	pci_unregister_driver(&mei_driver);
 
-	pr_debug("mei: Driver unloaded successfully.\n");
+	printk(KERN_INFO "mei: Driver unloaded successfully.\n");
 }
 
 module_exit(mei_exit_module);
diff --git a/drivers/staging/mei/mei.h b/drivers/staging/mei/mei.h
index 6da7c4f..99e4eb1 100644
--- a/drivers/staging/mei/mei.h
+++ b/drivers/staging/mei/mei.h
@@ -1,68 +1,25 @@
 /*
-
-  Intel Management Engine Interface (Intel MEI) Linux driver
-  Intel MEI Interface Header
-
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2003-2011 Intel Corporation. All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-	  Intel Corporation.
-	  linux-mei@linux.intel.com
-	  http://www.intel.com
-
-
-  BSD LICENSE
-
-  Copyright(c) 2003-2011 Intel Corporation. All rights reserved.
-  All rights reserved.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
+ *
+ * Intel Management Engine Interface (Intel MEI) Linux driver
+ * Copyright (c) 2003-2011, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
 
 
-#ifndef _LINUX_MEI_H
-#define _LINUX_MEI_H
+#ifndef _MEI_H_
+#define _MEI_H_
 
-#include <linux/uuid.h>
+#include <linux/interrupt.h>
+#include "hw.h"
 
 /*
  * This IOCTL is used to associate the current file descriptor with a
@@ -72,7 +29,7 @@
  * Only in close() (file_operation release()) the communication between
  * the clients is disconnected
  *
- * The IOCTL argument is a struct with a union the contains
+ * The IOCTL argument is a struct with a union that contains
  * the input parameter and the output parameter for this IOCTL.
  *
  * The input parameter is UUID of the FW Client.
@@ -87,10 +44,10 @@
  * Intel MEI client information struct
  */
 struct mei_client {
-	__u32 max_msg_length;
-	__u8 protocol_version;
-	__u8 reserved[3];
-};
+	u32 max_msg_length;
+	u8 protocol_version;
+	u8 reserved[3];
+} __packed;
 
 /*
  * IOCTL Connect Client Data structure
@@ -99,7 +56,138 @@ struct mei_connect_client_data {
 	union {
 		uuid_le in_client_uuid;
 		struct mei_client out_client_properties;
-	};
-};
+	} d;
+} __packed;
+
+
+#define CONNECT_TIMEOUT        15	/* HPS definition */
+#define INIT_CLIENTS_TIMEOUT   15	/* HPS definition */
+
+extern const uuid_le mei_amthi_guid;
+extern const uuid_le mei_wd_guid;
+extern const u8 mei_start_wd_params[];
+extern const u8 mei_stop_wd_params[];
+extern const u8 mei_wd_state_independence_msg[3][4];
+
+
+/*
+ * mei device ID
+ */
+#define    MEI_DEV_ID_82946GZ	0x2974  /* 82946GZ/GL */
+#define    MEI_DEV_ID_82G35	0x2984  /* 82G35 Express */
+#define    MEI_DEV_ID_82Q965	0x2994  /* 82Q963/Q965 */
+#define    MEI_DEV_ID_82G965	0x29A4  /* 82P965/G965 */
+
+#define    MEI_DEV_ID_82GM965	0x2A04  /* Mobile PM965/GM965 */
+#define    MEI_DEV_ID_82GME965	0x2A14  /* Mobile GME965/GLE960 */
+
+#define    MEI_DEV_ID_ICH9_82Q35 0x29B4  /* 82Q35 Express */
+#define    MEI_DEV_ID_ICH9_82G33 0x29C4  /* 82G33/G31/P35/P31 Express */
+#define    MEI_DEV_ID_ICH9_82Q33 0x29D4  /* 82Q33 Express */
+#define    MEI_DEV_ID_ICH9_82X38 0x29E4  /* 82X38/X48 Express */
+#define    MEI_DEV_ID_ICH9_3200  0x29F4  /* 3200/3210 Server */
 
-#endif /* _LINUX_MEI_H  */
+#define    MEI_DEV_ID_ICH9_6	0x28B4  /* Bearlake */
+#define    MEI_DEV_ID_ICH9_7	0x28C4  /* Bearlake */
+#define    MEI_DEV_ID_ICH9_8	0x28D4  /* Bearlake */
+#define    MEI_DEV_ID_ICH9_9    0x28E4  /* Bearlake */
+#define    MEI_DEV_ID_ICH9_10	0x28F4  /* Bearlake */
+
+#define    MEI_DEV_ID_ICH9M_1	0x2A44  /* Cantiga */
+#define    MEI_DEV_ID_ICH9M_2	0x2A54  /* Cantiga */
+#define    MEI_DEV_ID_ICH9M_3	0x2A64  /* Cantiga */
+#define    MEI_DEV_ID_ICH9M_4	0x2A74  /* Cantiga */
+
+#define    MEI_DEV_ID_ICH10_1	0x2E04  /* Eaglelake */
+#define    MEI_DEV_ID_ICH10_2	0x2E14  /* Eaglelake */
+#define    MEI_DEV_ID_ICH10_3	0x2E24  /* Eaglelake */
+#define    MEI_DEV_ID_ICH10_4	0x2E34  /* Eaglelake */
+
+#define    MEI_DEV_ID_IBXPK_1	0x3B64  /* Calpella */
+#define    MEI_DEV_ID_IBXPK_2	0x3B65  /* Calpella */
+
+#define    MEI_DEV_ID_CPT_1	0x1C3A    /* Cougerpoint */
+#define    MEI_DEV_ID_PBG_1	0x1D3A    /* PBG */
+
+#define    MEI_DEV_ID_PPT_1	0x1E3A    /* Pantherpoint PPT */
+#define    MEI_DEV_ID_PPT_2	0x1CBA    /* Pantherpoint PPT */
+#define    MEI_DEV_ID_PPT_3	0x1DBA    /* Pantherpoint PPT */
+
+
+/*
+ * mei init function prototypes
+ */
+struct mei_device *init_mei_device(struct pci_dev *pdev);
+void mei_reset(struct mei_device *dev, int interrupts);
+int mei_hw_init(struct mei_device *dev);
+int mei_task_initialize_clients(void *data);
+int mei_initialize_clients(struct mei_device *dev);
+struct mei_file_private *mei_alloc_file_private(struct file *file);
+int mei_disconnect_host_client(struct mei_device *dev,
+				struct mei_file_private *file_ext);
+void mei_initialize_list(struct io_mei_list *list,
+			  struct mei_device *dev);
+void mei_flush_list(struct io_mei_list *list,
+		     struct mei_file_private *file_ext);
+void mei_flush_queues(struct mei_device *dev,
+		       struct mei_file_private *file_ext);
+
+void mei_remove_client_from_file_list(struct mei_device *dev,
+				       u8 host_client_id);
+void host_start_message(struct mei_device *dev);
+void host_enum_clients_message(struct mei_device *dev);
+void allocate_me_clients_storage(struct mei_device *dev);
+void host_client_properties(struct mei_device *dev);
+void host_init_wd(struct mei_device *dev);
+void host_init_iamthif(struct mei_device *dev);
+
+/*
+ *  interrupt functions prototype
+ */
+irqreturn_t mei_interrupt_quick_handler(int irq, void *dev_id);
+irqreturn_t  mei_interrupt_thread_handler(int irq, void *dev_id);
+void mei_wd_timer(struct work_struct *work);
+
+/*
+ *  input output function prototype
+ */
+int mei_ioctl_connect_client(struct mei_device *dev, int if_num,
+					struct mei_connect_client_data *data,
+					struct file *file);
+
+int mei_start_read(struct mei_device *dev, int if_num,
+		    struct mei_file_private *file_ext);
+
+int amthi_write(struct mei_device *dev,
+	       struct mei_cb_private *priv_cb);
+
+int amthi_read(struct mei_device *dev, int if_num, struct file *file,
+	      char __user *ubuf, size_t length, loff_t *offset);
+
+struct mei_cb_private *find_amthi_read_list_entry(
+			struct mei_device *dev,
+			struct file *file);
+
+void run_next_iamthif_cmd(struct mei_device *dev);
+
+void mei_free_cb_private(struct mei_cb_private *priv_cb);
+
+int mei_find_me_client_index(const struct mei_device *dev,
+								uuid_le cuuid);
+
+
+/**
+ * mei_fe_same_id - tells if file private data have same id
+ *
+ * @fe1: private data of 1. file object
+ * @fe2: private data of 2. file object
+ *
+ * returns !=0 - if ids are the same, 0 - if differ.
+ */
+static inline int mei_fe_same_id(const struct mei_file_private *fe1,
+				  const struct mei_file_private *fe2)
+{
+	return ((fe1->host_client_id == fe2->host_client_id)
+		&& (fe1->me_client_id == fe2->me_client_id));
+}
+#endif /* _MEI_H_ */
diff --git a/drivers/staging/mei/mei_dev.h b/drivers/staging/mei/mei_dev.h
deleted file mode 100644
index d7bc10c..0000000
--- a/drivers/staging/mei/mei_dev.h
+++ /dev/null
@@ -1,425 +0,0 @@
-/*
- *
- * Intel Management Engine Interface (Intel MEI) Linux driver
- * Copyright (c) 2003-2011, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#ifndef _MEI_DEV_H_
-#define _MEI_DEV_H_
-
-#include <linux/types.h>
-#include "mei.h"
-#include "hw.h"
-
-/*
- * MEI Char Driver Minors
- */
-#define MEI_MINORS_BASE	1
-#define MEI_MINORS_COUNT	1
-#define MEI_MINOR_NUMBER	1
-
-/*
- * watch dog definition
- */
-#define MEI_WATCHDOG_DATA_SIZE         16
-#define MEI_START_WD_DATA_SIZE         20
-#define MEI_WD_PARAMS_SIZE             4
-#define MEI_WD_STATE_INDEPENDENCE_MSG_SENT       (1 << 0)
-
-/*
- * AMTHI Client UUID
- */
-extern const uuid_le mei_amthi_guid;
-
-/*
- * Watchdog Client UUID
- */
-extern const uuid_le mei_wd_guid;
-
-/*
- * Watchdog independence state message
- */
-extern const u8 mei_wd_state_independence_msg[3][4];
-
-/*
- * Number of File descriptors/handles
- * that can be opened to the driver.
- *
- * Limit to 253: 255 Total Clients
- * minus internal client for AMTHI
- * minus internal client for Watchdog
- */
-#define  MEI_MAX_OPEN_HANDLE_COUNT	253
-
-/*
- * Number of Maximum MEI Clients
- */
-#define MEI_CLIENTS_MAX 255
-
-/* File state */
-enum file_state {
-	MEI_FILE_INITIALIZING = 0,
-	MEI_FILE_CONNECTING,
-	MEI_FILE_CONNECTED,
-	MEI_FILE_DISCONNECTING,
-	MEI_FILE_DISCONNECTED
-};
-
-/* MEI device states */
-enum mei_states {
-	MEI_INITIALIZING = 0,
-	MEI_INIT_CLIENTS,
-	MEI_ENABLED,
-	MEI_RESETING,
-	MEI_DISABLED,
-	MEI_RECOVERING_FROM_RESET,
-	MEI_POWER_DOWN,
-	MEI_POWER_UP
-};
-
-/* init clients  states*/
-enum mei_init_clients_states {
-	MEI_START_MESSAGE = 0,
-	MEI_ENUM_CLIENTS_MESSAGE,
-	MEI_CLIENT_PROPERTIES_MESSAGE
-};
-
-enum iamthif_states {
-	MEI_IAMTHIF_IDLE,
-	MEI_IAMTHIF_WRITING,
-	MEI_IAMTHIF_FLOW_CONTROL,
-	MEI_IAMTHIF_READING,
-	MEI_IAMTHIF_READ_COMPLETE
-};
-
-enum mei_file_transaction_states {
-	MEI_IDLE,
-	MEI_WRITING,
-	MEI_WRITE_COMPLETE,
-	MEI_FLOW_CONTROL,
-	MEI_READING,
-	MEI_READ_COMPLETE
-};
-
-/* MEI CB */
-enum mei_cb_major_types {
-	MEI_READ = 0,
-	MEI_WRITE,
-	MEI_IOCTL,
-	MEI_OPEN,
-	MEI_CLOSE
-};
-
-/*
- * Intel MEI message data struct
- */
-struct mei_message_data {
-	u32 size;
-	char *data;
-} __packed;
-
-
-struct mei_cl_cb {
-	struct list_head cb_list;
-	enum mei_cb_major_types major_file_operations;
-	void *file_private;
-	struct mei_message_data request_buffer;
-	struct mei_message_data response_buffer;
-	unsigned long information;
-	unsigned long read_time;
-	struct file *file_object;
-};
-
-/* MEI client instance carried as file->pirvate_data*/
-struct mei_cl {
-	struct list_head link;
-	struct mei_device *dev;
-	enum file_state state;
-	wait_queue_head_t tx_wait;
-	wait_queue_head_t rx_wait;
-	wait_queue_head_t wait;
-	int read_pending;
-	int status;
-	/* ID of client connected */
-	u8 host_client_id;
-	u8 me_client_id;
-	u8 mei_flow_ctrl_creds;
-	u8 timer_count;
-	enum mei_file_transaction_states reading_state;
-	enum mei_file_transaction_states writing_state;
-	int sm_state;
-	struct mei_cl_cb *read_cb;
-};
-
-struct mei_io_list {
-	struct mei_cl_cb mei_cb;
-	int status;
-};
-
-/* MEI private device struct */
-struct mei_device {
-	struct pci_dev *pdev;	/* pointer to pci device struct */
-	/*
-	 * lists of queues
-	 */
-	 /* array of pointers to aio lists */
-	struct mei_io_list read_list;		/* driver read queue */
-	struct mei_io_list write_list;		/* driver write queue */
-	struct mei_io_list write_waiting_list;	/* write waiting queue */
-	struct mei_io_list ctrl_wr_list;	/* managed write IOCTL list */
-	struct mei_io_list ctrl_rd_list;	/* managed read IOCTL list */
-	struct mei_io_list amthi_cmd_list;	/* amthi list for cmd waiting */
-
-	/* driver managed amthi list for reading completed amthi cmd data */
-	struct mei_io_list amthi_read_complete_list;
-	/*
-	 * list of files
-	 */
-	struct list_head file_list;
-	long open_handle_count;
-	/*
-	 * memory of device
-	 */
-	unsigned int mem_base;
-	unsigned int mem_length;
-	void __iomem *mem_addr;
-	/*
-	 * lock for the device
-	 */
-	struct mutex device_lock; /* device lock */
-	struct delayed_work wd_work;	/* watch dog deleye work */
-	bool recvd_msg;
-	/*
-	 * hw states of host and fw(ME)
-	 */
-	u32 host_hw_state;
-	u32 me_hw_state;
-	/*
-	 * waiting queue for receive message from FW
-	 */
-	wait_queue_head_t wait_recvd_msg;
-	wait_queue_head_t wait_stop_wd;
-
-	/*
-	 * mei device  states
-	 */
-	enum mei_states mei_state;
-	enum mei_init_clients_states init_clients_state;
-	u16 init_clients_timer;
-	bool stop;
-	bool need_reset;
-
-	u32 extra_write_index;
-	u32 rd_msg_buf[128];	/* used for control messages */
-	u32 wr_msg_buf[128];	/* used for control messages */
-	u32 ext_msg_buf[8];	/* for control responses */
-	u32 rd_msg_hdr;
-
-	struct hbm_version version;
-
-	struct mei_me_client *me_clients; /* Note: memory has to be allocated */
-	DECLARE_BITMAP(me_clients_map, MEI_CLIENTS_MAX);
-	DECLARE_BITMAP(host_clients_map, MEI_CLIENTS_MAX);
-	u8 me_clients_num;
-	u8 me_client_presentation_num;
-	u8 me_client_index;
-	bool mei_host_buffer_is_empty;
-
-	struct mei_cl wd_cl;
-	bool wd_pending;
-	bool wd_stopped;
-	bool wd_bypass;	/* if false, don't refresh watchdog ME client */
-	u16 wd_timeout;	/* seconds ((wd_data[1] << 8) + wd_data[0]) */
-	u16 wd_due_counter;
-	unsigned char wd_data[MEI_START_WD_DATA_SIZE];
-
-
-
-	struct file *iamthif_file_object;
-	struct mei_cl iamthif_cl;
-	struct mei_cl_cb *iamthif_current_cb;
-	int iamthif_mtu;
-	unsigned long iamthif_timer;
-	u32 iamthif_stall_timer;
-	unsigned char *iamthif_msg_buf; /* Note: memory has to be allocated */
-	u32 iamthif_msg_buf_size;
-	u32 iamthif_msg_buf_index;
-	enum iamthif_states iamthif_state;
-	bool iamthif_flow_control_pending;
-	bool iamthif_ioctl;
-	bool iamthif_canceled;
-};
-
-
-/*
- * mei init function prototypes
- */
-struct mei_device *mei_device_init(struct pci_dev *pdev);
-void mei_reset(struct mei_device *dev, int interrupts);
-int mei_hw_init(struct mei_device *dev);
-int mei_task_initialize_clients(void *data);
-int mei_initialize_clients(struct mei_device *dev);
-int mei_disconnect_host_client(struct mei_device *dev, struct mei_cl *cl);
-void mei_remove_client_from_file_list(struct mei_device *dev, u8 host_client_id);
-void mei_host_init_iamthif(struct mei_device *dev);
-void mei_allocate_me_clients_storage(struct mei_device *dev);
-
-
-u8 mei_find_me_client_update_filext(struct mei_device *dev,
-				struct mei_cl *priv,
-				const uuid_le *cguid, u8 client_id);
-
-/*
- * MEI IO List Functions
- */
-void mei_io_list_init(struct mei_io_list *list);
-void mei_io_list_flush(struct mei_io_list *list, struct mei_cl *cl);
-
-/*
- * MEI ME Client Functions
- */
-
-struct mei_cl *mei_cl_allocate(struct mei_device *dev);
-void mei_cl_init(struct mei_cl *cl, struct mei_device *dev);
-int mei_cl_flush_queues(struct mei_cl *cl);
-/**
- * mei_cl_cmp_id - tells if file private data have same id
- *
- * @fe1: private data of 1. file object
- * @fe2: private data of 2. file object
- *
- * returns true  - if ids are the same and not NULL
- */
-static inline bool mei_cl_cmp_id(const struct mei_cl *cl1,
-				const struct mei_cl *cl2)
-{
-	return cl1 && cl2 &&
-		(cl1->host_client_id == cl2->host_client_id) &&
-		(cl1->me_client_id == cl2->me_client_id);
-}
-
-
-
-/*
- * MEI Host Client Functions
- */
-void mei_host_start_message(struct mei_device *dev);
-void mei_host_enum_clients_message(struct mei_device *dev);
-void mei_host_client_properties(struct mei_device *dev);
-
-/*
- *  MEI interrupt functions prototype
- */
-irqreturn_t mei_interrupt_quick_handler(int irq, void *dev_id);
-irqreturn_t mei_interrupt_thread_handler(int irq, void *dev_id);
-void mei_wd_timer(struct work_struct *work);
-
-/*
- *  MEI input output function prototype
- */
-int mei_ioctl_connect_client(struct file *file,
-			struct mei_connect_client_data *data);
-
-int mei_start_read(struct mei_device *dev, struct mei_cl *cl);
-
-int amthi_write(struct mei_device *dev, struct mei_cl_cb *priv_cb);
-
-int amthi_read(struct mei_device *dev, struct file *file,
-	      char __user *ubuf, size_t length, loff_t *offset);
-
-struct mei_cl_cb *find_amthi_read_list_entry(struct mei_device *dev,
-						struct file *file);
-
-void mei_run_next_iamthif_cmd(struct mei_device *dev);
-
-void mei_free_cb_private(struct mei_cl_cb *priv_cb);
-
-int mei_find_me_client_index(const struct mei_device *dev, uuid_le cuuid);
-
-/*
- * Register Access Function
- */
-
-/**
- * mei_reg_read - Reads 32bit data from the mei device
- *
- * @dev: the device structure
- * @offset: offset from which to read the data
- *
- * returns the byte read.
- */
-static inline u32 mei_reg_read(struct mei_device *dev, unsigned long offset)
-{
-	return ioread32(dev->mem_addr + offset);
-}
-
-/**
- * mei_reg_write - Writes 32bit data to the mei device
- *
- * @dev: the device structure
- * @offset: offset from which to write the data
- * @value: the byte to write
- */
-static inline void mei_reg_write(struct mei_device *dev,
-				unsigned long offset, u32 value)
-{
-	iowrite32(value, dev->mem_addr + offset);
-}
-
-/**
- * mei_hcsr_read - Reads 32bit data from the host CSR
- *
- * @dev: the device structure
- *
- * returns the byte read.
- */
-static inline u32 mei_hcsr_read(struct mei_device *dev)
-{
-	return mei_reg_read(dev, H_CSR);
-}
-
-/**
- * mei_mecsr_read - Reads 32bit data from the ME CSR
- *
- * @dev: the device structure
- *
- * returns ME_CSR_HA register value (u32)
- */
-static inline u32 mei_mecsr_read(struct mei_device *dev)
-{
-	return mei_reg_read(dev, ME_CSR_HA);
-}
-
-/**
- * get_me_cb_rw - Reads 32bit data from the mei ME_CB_RW register
- *
- * @dev: the device structure
- *
- * returns ME_CB_RW register value (u32)
- */
-static inline u32 mei_mecbrw_read(struct mei_device *dev)
-{
-	return mei_reg_read(dev, ME_CB_RW);
-}
-
-
-/*
- * mei interface function prototypes
- */
-void mei_hcsr_set(struct mei_device *dev);
-void mei_csr_clear_his(struct mei_device *dev);
-
-void mei_enable_interrupts(struct mei_device *dev);
-void mei_disable_interrupts(struct mei_device *dev);
-
-#endif
diff --git a/drivers/staging/mei/mei_version.h b/drivers/staging/mei/mei_version.h
index 075bad8..12b4abf 100644
--- a/drivers/staging/mei/mei_version.h
+++ b/drivers/staging/mei/mei_version.h
@@ -18,10 +18,11 @@
 #ifndef MEI_VERSION_H
 #define MEI_VERSION_H
 
+#include "build.h"
+
 #define MAJOR_VERSION		7
 #define MINOR_VERSION		1
 #define QUICK_FIX_NUMBER	20
-#define VER_BUILD		1
 
 #define MEI_DRV_VER1 __stringify(MAJOR_VERSION) "." __stringify(MINOR_VERSION)
 #define MEI_DRV_VER2 __stringify(QUICK_FIX_NUMBER) "." __stringify(VER_BUILD)
diff --git a/drivers/staging/mei/wd.c b/drivers/staging/mei/wd.c
deleted file mode 100644
index 42f04ef..0000000
--- a/drivers/staging/mei/wd.c
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- *
- * Intel Management Engine Interface (Intel MEI) Linux driver
- * Copyright (c) 2003-2011, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/device.h>
-#include <linux/pci.h>
-#include <linux/sched.h>
-
-#include "mei_dev.h"
-#include "hw.h"
-#include "interface.h"
-#include "mei.h"
-
-/*
- * MEI Watchdog Module Parameters
- */
-static u16 watchdog_timeout = AMT_WD_VALUE;
-module_param(watchdog_timeout, ushort, 0);
-MODULE_PARM_DESC(watchdog_timeout,
-		"Intel(R) AMT Watchdog timeout value in seconds. (default="
-					__MODULE_STRING(AMT_WD_VALUE)
-					", disable=0)");
-
-static const u8 mei_start_wd_params[] = { 0x02, 0x12, 0x13, 0x10 };
-static const u8 mei_stop_wd_params[] = { 0x02, 0x02, 0x14, 0x10 };
-
-const u8 mei_wd_state_independence_msg[3][4] = {
-	{0x05, 0x02, 0x51, 0x10},
-	{0x05, 0x02, 0x52, 0x10},
-	{0x07, 0x02, 0x01, 0x10}
-};
-
-/* UUIDs for AMT F/W clients */
-const uuid_le mei_wd_guid = UUID_LE(0x05B79A6F, 0x4628, 0x4D7F, 0x89,
-						0x9D, 0xA9, 0x15, 0x14, 0xCB,
-						0x32, 0xAB);
-
-
-void mei_wd_start_setup(struct mei_device *dev)
-{
-	dev_dbg(&dev->pdev->dev, "dev->wd_timeout=%d.\n", dev->wd_timeout);
-	memcpy(dev->wd_data, mei_start_wd_params, MEI_WD_PARAMS_SIZE);
-	memcpy(dev->wd_data + MEI_WD_PARAMS_SIZE,
-		&dev->wd_timeout, sizeof(u16));
-}
-
-/**
- * host_init_wd - mei initialization wd.
- *
- * @dev: the device structure
- */
-void mei_wd_host_init(struct mei_device *dev)
-{
-	mei_cl_init(&dev->wd_cl, dev);
-
-	/* look for WD client and connect to it */
-	dev->wd_cl.state = MEI_FILE_DISCONNECTED;
-	dev->wd_timeout = watchdog_timeout;
-
-	if (dev->wd_timeout > 0) {
-		mei_wd_start_setup(dev);
-		/* find ME WD client */
-		mei_find_me_client_update_filext(dev, &dev->wd_cl,
-					&mei_wd_guid, MEI_WD_HOST_CLIENT_ID);
-
-		dev_dbg(&dev->pdev->dev, "check wd_cl\n");
-		if (MEI_FILE_CONNECTING == dev->wd_cl.state) {
-			if (!mei_connect(dev, &dev->wd_cl)) {
-				dev_dbg(&dev->pdev->dev, "Failed to connect to WD client\n");
-				dev->wd_cl.state = MEI_FILE_DISCONNECTED;
-				dev->wd_cl.host_client_id = 0;
-				mei_host_init_iamthif(dev) ;
-			} else {
-				dev->wd_cl.timer_count = CONNECT_TIMEOUT;
-			}
-		} else {
-			dev_dbg(&dev->pdev->dev, "Failed to find WD client\n");
-			mei_host_init_iamthif(dev) ;
-		}
-	} else {
-		dev->wd_bypass = true;
-		dev_dbg(&dev->pdev->dev, "WD requested to be disabled\n");
-		mei_host_init_iamthif(dev) ;
-	}
-}
-
-/**
- * mei_wd_send - sends watch dog message to fw.
- *
- * @dev: the device structure
- *
- * returns 0 if success,
- *	-EIO when message send fails
- *	-EINVAL when invalid message is to be sent
- */
-int mei_wd_send(struct mei_device *dev)
-{
-	struct mei_msg_hdr *mei_hdr;
-
-	mei_hdr = (struct mei_msg_hdr *) &dev->wr_msg_buf[0];
-	mei_hdr->host_addr = dev->wd_cl.host_client_id;
-	mei_hdr->me_addr = dev->wd_cl.me_client_id;
-	mei_hdr->msg_complete = 1;
-	mei_hdr->reserved = 0;
-
-	if (!memcmp(dev->wd_data, mei_start_wd_params, MEI_WD_PARAMS_SIZE))
-		mei_hdr->length = MEI_START_WD_DATA_SIZE;
-	else if (!memcmp(dev->wd_data, mei_stop_wd_params, MEI_WD_PARAMS_SIZE))
-		mei_hdr->length = MEI_WD_PARAMS_SIZE;
-	else
-		return -EINVAL;
-
-	if (mei_write_message(dev, mei_hdr, dev->wd_data, mei_hdr->length))
-		return 0;
-	return -EIO;
-}
-
-int mei_wd_stop(struct mei_device *dev, bool preserve)
-{
-	int ret;
-	u16 wd_timeout = dev->wd_timeout;
-
-	cancel_delayed_work(&dev->wd_work);
-	if (dev->wd_cl.state != MEI_FILE_CONNECTED || !dev->wd_timeout)
-		return 0;
-
-	dev->wd_timeout = 0;
-	dev->wd_due_counter = 0;
-	memcpy(dev->wd_data, mei_stop_wd_params, MEI_WD_PARAMS_SIZE);
-	dev->stop = true;
-
-	ret = mei_flow_ctrl_creds(dev, &dev->wd_cl);
-	if (ret < 0)
-		goto out;
-
-	if (ret && dev->mei_host_buffer_is_empty) {
-		ret = 0;
-		dev->mei_host_buffer_is_empty = false;
-
-		if (!mei_wd_send(dev)) {
-			ret = mei_flow_ctrl_reduce(dev, &dev->wd_cl);
-			if (ret)
-				goto out;
-		} else {
-			dev_dbg(&dev->pdev->dev, "send stop WD failed\n");
-		}
-
-		dev->wd_pending = false;
-	} else {
-		dev->wd_pending = true;
-	}
-	dev->wd_stopped = false;
-	mutex_unlock(&dev->device_lock);
-
-	ret = wait_event_interruptible_timeout(dev->wait_stop_wd,
-					dev->wd_stopped, 10 * HZ);
-	mutex_lock(&dev->device_lock);
-	if (dev->wd_stopped) {
-		dev_dbg(&dev->pdev->dev, "stop wd complete ret=%d.\n", ret);
-		ret = 0;
-	} else {
-		if (!ret)
-			ret = -ETIMEDOUT;
-		dev_warn(&dev->pdev->dev,
-			"stop wd failed to complete ret=%d.\n", ret);
-	}
-
-	if (preserve)
-		dev->wd_timeout = wd_timeout;
-
-out:
-	return ret;
-}
-
-- 
1.7.0.4

