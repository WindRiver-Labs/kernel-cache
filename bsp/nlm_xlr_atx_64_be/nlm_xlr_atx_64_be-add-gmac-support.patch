From 2c30cd1e2ad205b5a8b3b6acab351ee561f9d8af Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 21 May 2010 13:07:28 +0800
Subject: [PATCH 26/47] nlm_xlr_atx_64_be: add gmac support

Extracted from RMI SDK 1.7.0.

On-chip GMAC support.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/include/asm/rmi/config_net.h |  118 ++++++++++++++++
 arch/mips/rmi/ptr/Makefile             |    2 +-
 arch/mips/rmi/ptr/config_net.c         |  241 ++++++++++++++++++++++++++++++++
 3 files changed, 360 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/include/asm/rmi/config_net.h
 create mode 100644 arch/mips/rmi/ptr/config_net.c

diff --git a/arch/mips/include/asm/rmi/config_net.h b/arch/mips/include/asm/rmi/config_net.h
new file mode 100644
index 0000000..d0cf860
--- /dev/null
+++ b/arch/mips/include/asm/rmi/config_net.h
@@ -0,0 +1,118 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_NET_H
+#define _ASM_RMI_NET_H
+
+#include <asm/rmi/msgring.h>
+
+#define PHOENIX_MAX_GMACS 8
+#define PHOENIX_MAX_XGMACS 2
+#define PHOENIX_MAX_XAUIS 2
+
+#define PHOENIX_GMAC_PORTS_PER_CTRL 4
+
+#define PHOENIX_MAX_MACS (PHOENIX_MAX_GMACS + PHOENIX_MAX_XGMACS)
+
+enum config_flags { PHNX_PORT_INIT = 1, 
+					PHNX_PORT_ATTACH = 2, 
+					PHNX_INT_ATTACH = 4, 
+					PHNX_MSGRNG_OWN = 8, 
+					PHNX_PORT_EN = 0x10 };
+
+#define PORT_OWN_LINUX  ( PHNX_PORT_INIT | PHNX_PORT_ATTACH | PHNX_INT_ATTACH | PHNX_MSGRNG_OWN | PHNX_PORT_EN )
+
+/* 	PORT_INIT  : GMAC/XGMAC IP initialization will be done. 
+	Port will be disabled after the initialization. 
+	Glue logic(spill, packet descriptors will not be initialized 
+
+	PORT_ATTACH : Eth interface will be attached to Linux 
+
+	INT_ATTACH : GMAC/XGMAC MDIO interrupt will be attached to Linux
+
+	MSGRNG_OWN : Glue logic(spill, packet descriptors will be initialized by linux
+
+	PORT_EN : Option to enable the port
+*/
+
+
+struct port_cfg {
+	/* port number */
+	int instance;
+
+	/* See enum config_flags */
+	uint32_t cfg_flag;
+
+	/* Interrupt Request number */
+	int irqno; 
+
+	/* number of descriptors configured */
+	int num_desc; 
+
+	/* pointer to the bucket config */
+	bucket_t *bucket;
+
+	/* pointer to the credit config */
+	struct stn_cc *credit;
+
+	/* driver should configure the pde */
+	int config_pde;
+
+	unsigned long mmio_addr; /* config address */
+	uint32_t phy_addr; /* phy id */
+	int phy_mode; /* sgmii or rgmii */
+	unsigned long mii_addr; /* mdio addr */
+	unsigned long pcs_addr; /* only for sgmii ports */
+	unsigned long serdes_addr; /* only for sgmii ports */
+};
+
+struct net_device_cfg {
+	struct port_cfg gmac_port[PHOENIX_MAX_GMACS];
+	int xgs_type[PHOENIX_MAX_XGMACS];
+	struct port_cfg xgs_port[PHOENIX_MAX_XGMACS];
+};
+
+
+enum net_types { TYPE_GMAC = 0, TYPE_XGMAC, TYPE_SPI4, MAX_NET_TYPES };
+enum phy_modes { PHY_MODE_SGMII	= 1, PHY_MODE_RGMII = 2, 
+    PHY_MODE_SELECTABLE = 4, PHY_MODE_XAUI=8};
+
+extern int phnx_get_phy_info(int instance, int mode, unsigned long *mii_addr, 
+					unsigned long *pcs_addr, unsigned long *serdes_addr);
+
+#define PORT_INIT(x) (x & PHNX_PORT_INIT)
+#define PORT_ATTACH(x) (x & PHNX_PORT_ATTACH)
+#define PORT_INT_ATTACH(x) (x & PHNX_INT_ATTACH)
+#define MSGRNG_OWN(x) (x & PHNX_MSGRNG_OWN)
+#define PORT_EN(x) (x & PHNX_PORT_EN)
+
+#endif
+
+
diff --git a/arch/mips/rmi/ptr/Makefile b/arch/mips/rmi/ptr/Makefile
index 195bd41..45d50fb 100644
--- a/arch/mips/rmi/ptr/Makefile
+++ b/arch/mips/rmi/ptr/Makefile
@@ -1,4 +1,4 @@
-obj-y			= setup.o reset.o
+obj-y			= setup.o reset.o config_net.o
 
 obj-$(CONFIG_EARLY_PRINTK) += serial.o
 obj-$(CONFIG_SERIAL_8250) += serial.o
diff --git a/arch/mips/rmi/ptr/config_net.c b/arch/mips/rmi/ptr/config_net.c
new file mode 100644
index 0000000..8203d63
--- /dev/null
+++ b/arch/mips/rmi/ptr/config_net.c
@@ -0,0 +1,241 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+/*
+ * Setup code for RMI's XLR-based boards
+ */
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/socket.h>
+#include <linux/errno.h>
+#include <asm/rmi/sim.h>
+#include <asm/rmi/config_net.h>
+#include <asm/rmi/phoenix_mac.h>
+#include <asm/rmi/gpio.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/pic.h>
+
+struct net_device_cfg phnx_net_dev_cfg;
+extern unsigned long phoenix_io_base;
+extern void rmi_dev_config_net(void);
+
+static uint32_t gmac_offsets[] =
+    { PHOENIX_IO_GMAC_0_OFFSET, PHOENIX_IO_GMAC_1_OFFSET,
+	PHOENIX_IO_GMAC_2_OFFSET, PHOENIX_IO_GMAC_3_OFFSET
+};
+
+static uint32_t gmac_irqs[] = { PIC_GMAC_0_IRQ, PIC_GMAC_1_IRQ,
+	PIC_GMAC_2_IRQ, PIC_GMAC_3_IRQ
+};
+
+static uint32_t xgmac_offsets[] =
+    { PHOENIX_IO_XGMAC_0_OFFSET, PHOENIX_IO_XGMAC_1_OFFSET };
+static uint32_t spi4_offsets[] =
+    { PHOENIX_IO_SPI4_0_OFFSET, PHOENIX_IO_SPI4_1_OFFSET };
+static uint32_t xgs_irqs[] = { PIC_XGS_0_IRQ, PIC_XGS_1_IRQ };
+
+
+#define MAX_NUM_DESC		512
+#define PHNX_BASE(x) (phoenix_io_base + x)
+
+int phnx_is_mac_active(int instance, int type, int *mode)
+{
+	*mode = PHY_MODE_RGMII;
+
+	if (type == TYPE_GMAC) {
+		/* On XLR gmac4 to gmac7 are unavailable */
+		if (instance >= 4)
+			return 0;
+
+		/* On ATX-II, gmac 0 and gmac 1 are not available */
+		if (xlr_board_atx_ii() && !xlr_board_atx_ii_b()) {
+			if (instance < 2)
+				return 0;
+		}
+
+		/* On ATX-IV-B and ATX-V, gmac 3 is not available */
+		if ((xlr_board_atx_v() || xlr_board_atx_iv_b())) {
+			if (instance > 2)
+				return 0;
+		}
+
+		return 1;
+
+	} else if (type == TYPE_XGMAC) {
+		/* On ATX-II and ATX IIB 2 xgmac is  available */
+		if (xlr_board_atx_ii() || xlr_board_atx_ii_b())
+			return 1;
+		return 0;
+
+	} else if (type == TYPE_SPI4) {
+		if (xlr_board_atx_i())
+			return 1;
+		return 0;
+	}
+
+	return 0;
+}
+
+int phnx_get_phy_info(int instance, int mode, unsigned long *mii_addr,
+		      unsigned long *pcs_addr, unsigned long *serdes_addr)
+{
+	*pcs_addr = 0x0;
+	*serdes_addr = 0x0;
+	*mii_addr = PHNX_BASE(gmac_offsets[0]);
+
+	return instance;
+}
+
+void config_net_init(void)
+{
+
+	struct net_device_cfg *net_dev = &phnx_net_dev_cfg;
+	int i, mode, gmac_pblock = 0;
+	int num_desc = MAX_NUM_DESC;
+
+	for (i = 0; i < PHOENIX_MAX_GMACS; i++) {
+		/* general config for gmac */
+		net_dev->gmac_port[i].instance = i;
+		net_dev->gmac_port[i].irqno = gmac_irqs[i];
+		net_dev->gmac_port[i].config_pde = 1;
+		/* chip specific config for gmac */
+		if (phnx_is_mac_active(i, TYPE_GMAC, &mode) == 1) {
+			net_dev->gmac_port[i].mmio_addr =
+			    PHNX_BASE(gmac_offsets[i]);
+			net_dev->gmac_port[i].cfg_flag = PORT_OWN_LINUX;
+
+			if (xlr_board_atx_vii() && i == 4)
+				/*atx-vii board workaround for mdio-1 */
+				net_dev->gmac_port[i].cfg_flag =
+				    PORT_OWN_LINUX & ~(PHNX_INT_ATTACH);
+
+			if (i >= gmac_pblock) {
+				net_dev->gmac_port[i].num_desc = num_desc;
+					net_dev->gmac_port[i].bucket =
+					    &bucket_sizes.
+					    bucket[MSGRNG_STNID_GMAC];
+					net_dev->gmac_port[i].credit =
+					    &cc_table_gmac;
+				gmac_pblock += PHOENIX_GMAC_PORTS_PER_CTRL;
+			}
+
+			net_dev->gmac_port[i].phy_mode = mode;
+
+			net_dev->gmac_port[i].phy_addr =
+			    phnx_get_phy_info(i,
+					      net_dev->gmac_port[i].
+					      phy_mode,
+					      &net_dev->gmac_port[i].
+					      mii_addr,
+					      &net_dev->gmac_port[i].
+					      pcs_addr,
+					      &net_dev->gmac_port[i].
+					      serdes_addr);
+
+		}
+	}
+
+	/* general config for xgmac */
+	for (i = 0; i < PHOENIX_MAX_XGMACS; i++) {
+		net_dev->xgs_port[i].instance = i;
+		net_dev->xgs_port[i].irqno = xgs_irqs[i];
+		net_dev->xgs_port[i].config_pde = 1;
+
+		if (phnx_is_mac_active(i, TYPE_XGMAC, &mode) == 1) {
+			net_dev->xgs_port[i].mmio_addr =
+			    PHNX_BASE(xgmac_offsets[i]);
+			net_dev->xgs_port[i].cfg_flag = PORT_OWN_LINUX;
+			net_dev->xgs_port[i].num_desc = num_desc;
+			net_dev->xgs_type[i] = TYPE_XGMAC;
+
+		} else if (phnx_is_mac_active(i, TYPE_SPI4, &mode) == 1) {
+			net_dev->xgs_port[i].mmio_addr =
+			    PHNX_BASE(spi4_offsets[i]);
+			net_dev->xgs_port[i].cfg_flag = PORT_OWN_LINUX;
+			net_dev->xgs_port[i].num_desc = num_desc;
+			net_dev->xgs_type[i] = TYPE_SPI4;
+		}
+		/* as descriptors are discontinues we need to pass the 
+		   full list */
+		net_dev->xgs_port[i].bucket = &bucket_sizes.bucket[0];
+		if (i == 0)
+			net_dev->xgs_port[i].credit = &cc_table_xgs_0;
+		else
+			net_dev->xgs_port[i].credit = &cc_table_xgs_1;
+	}
+
+	/* Modify the basic configurations with the options 
+	   supported in Linux */
+	/* usermac support */
+	if (xlr_hybrid_user_mac()) {
+		for (i = 0; i < PHOENIX_MAX_GMACS; i++) {
+			if (net_dev->gmac_port[i].mmio_addr == 0)
+				continue;
+			net_dev->gmac_port[i].cfg_flag = PHNX_PORT_INIT;
+		}
+	}
+	if (xlr_hybrid_user_mac() || xlr_hybrid_user_mac_xgmac()) {
+		for (i = 0; i < PHOENIX_MAX_XGMACS; i++) {
+			if (net_dev->xgs_port[i].mmio_addr == 0)
+				continue;
+			net_dev->xgs_port[i].cfg_flag = PHNX_PORT_INIT;
+		}
+	}
+	return;
+}
+
+static int __init xlr_mac_desc_setup(char *str)
+{
+	int desc = simple_strtoul(str, 0, 10);
+	struct net_device_cfg *net_dev = &phnx_net_dev_cfg;
+	int i;
+
+	printk("[%s]: str = \"%s\", desc=%d\n", __FUNCTION__, str, desc);
+	if (desc == 0)
+		return 1;
+
+	for (i = 0; i < PHOENIX_MAX_GMACS; i++) {
+		if (net_dev->gmac_port[i].num_desc != 0)
+			net_dev->gmac_port[i].num_desc = desc;
+	}
+
+	for (i = 0; i < PHOENIX_MAX_XGMACS; i++) {
+		if (net_dev->xgs_port[i].num_desc != 0)
+			net_dev->xgs_port[i].num_desc = desc;
+	}
+
+	return 1;
+}
+
+__setup("xlr_mac_desc=", xlr_mac_desc_setup);
-- 
1.7.0.4

