From f804b2123d1ce533b02e192ab0eb854efe94c431 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Wed, 1 Dec 2010 15:46:21 +0800
Subject: [PATCH 22/47] nlm_xlr_atx_64_be: Add serial port support

The early printk support: prom_putchar() and the serial port driver are
added in.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/Kconfig            |    1 +
 arch/mips/rmi/ptr/Makefile   |    3 +
 arch/mips/rmi/ptr/serial.c   |  101 ++++++++++++++++++++++++++++++++++++++++++
 drivers/serial/8250.c        |    5 ++
 drivers/serial/serial_core.c |    2 +
 include/linux/serial_8250.h  |    1 +
 include/linux/serial_core.h  |    1 +
 7 files changed, 114 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/rmi/ptr/serial.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 5980fb7..1736693 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -688,6 +688,7 @@ config RMI_PTR
 	select SMP
 	select BOOT_ELF32
 	select RMI_PHOENIX
+	select SYS_HAS_EARLY_PRINTK
 	select SYS_HAS_CPU_PHOENIX
 	select SYS_SUPPORTS_SMP
 	select HW_HAS_PCI
diff --git a/arch/mips/rmi/ptr/Makefile b/arch/mips/rmi/ptr/Makefile
index 1d1fa3a..195bd41 100644
--- a/arch/mips/rmi/ptr/Makefile
+++ b/arch/mips/rmi/ptr/Makefile
@@ -1,5 +1,8 @@
 obj-y			= setup.o reset.o
 
+obj-$(CONFIG_EARLY_PRINTK) += serial.o
+obj-$(CONFIG_SERIAL_8250) += serial.o
+
 obj-$(CONFIG_SMP)      += smp.o smpboot.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff --git a/arch/mips/rmi/ptr/serial.c b/arch/mips/rmi/ptr/serial.c
new file mode 100644
index 0000000..c7686af
--- /dev/null
+++ b/arch/mips/rmi/ptr/serial.c
@@ -0,0 +1,101 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2010 Wind River Systems,
+ * Author: Wu Zhangjin <zhangjin.wu@windriver.com>
+ */
+
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include <asm/rmi/pic.h>
+
+#ifdef CONFIG_EARLY_PRINTK
+void prom_putchar(char c)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_UART_0_OFFSET);
+
+	while (phoenix_read_reg(mmio, 0x5) == 0)
+		;
+	phoenix_write_reg(mmio, 0x0, c);
+}
+#endif
+
+#ifdef CONFIG_SERIAL_8250
+static unsigned int phoenix_uart_in(struct uart_port *p, int offset)
+{
+	phoenix_reg_t *mmio;
+	unsigned int value;
+
+	/* XLR uart does not need any mapping of regs */
+	offset = offset << p->regshift;
+	mmio = (phoenix_reg_t *)(p->membase + offset);
+	value = phoenix_read_reg(mmio, 0);
+
+	/* See XLR/XLS errata */
+	if (offset == UART_MSR)
+		value ^= 0xF0;
+	else if (offset == UART_MCR)
+		value ^= 0x3;
+
+	return value;
+
+}
+
+static void phoenix_uart_out(struct uart_port *p, int offset, int value)
+{
+	phoenix_reg_t *mmio;
+
+	/* See XLR/XLS errata */
+	if (offset == UART_MSR)
+		value ^= 0xF0;
+	else if (offset == UART_MCR)
+		value ^= 0x3;
+
+	/* XLR uart does not need any mapping of regs */
+	offset = offset << p->regshift;
+	mmio = (phoenix_reg_t *)(p->membase + offset);
+	phoenix_write_reg(mmio, 0, value);
+}
+
+#define PORT(_base, _irq) {				\
+	.iobase		= _base,			\
+	.membase	= (void __iomem *)_base,	\
+	.mapbase	= _base,			\
+	.irq		= _irq,				\
+	.regshift	= 2,				\
+	.iotype		= UPIO_XLR,			\
+	.flags		= (UPF_SKIP_TEST|UPF_FIXED_TYPE|UPF_BOOT_AUTOCONF),\
+	.uartclk	= 66666666,			\
+	.type		= PORT_16550A,			\
+	.serial_in	= phoenix_uart_in,		\
+	.serial_out	= phoenix_uart_out,		\
+}
+
+static struct plat_serial8250_port uart_data[] = {
+	PORT(DEFAULT_PHOENIX_IO_BASE+PHOENIX_IO_UART_0_OFFSET, PIC_UART_0_IRQ),
+	PORT(DEFAULT_PHOENIX_IO_BASE+PHOENIX_IO_UART_1_OFFSET, PIC_UART_1_IRQ),
+	{},
+};
+
+static struct platform_device uart_device = {
+	.name		= "serial8250",
+	.id		= PLAT8250_DEV_XLR,
+	.dev = {
+		.platform_data = uart_data,
+	},
+};
+
+
+static int __init phoenix_uart_init(void)
+{
+	return platform_device_register(&uart_device);
+}
+
+arch_initcall(phoenix_uart_init);
+
+#endif /* CONFIG_SERIAL_8250 */
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 8f1eeeb..a3ad363 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -668,6 +668,10 @@ static void set_io_from_upio(struct uart_port *p)
 		p->serial_out = dwapb_serial_out;
 		break;
 
+	case UPIO_XLR:
+		/* serial_in and serial_out are set in uart_port */
+		break;
+
 	default:
 		p->serial_in = io_serial_in;
 		p->serial_out = io_serial_out;
@@ -691,6 +695,7 @@ serial_out_sync(struct uart_8250_port *up, int offset, int value)
 	switch (p->iotype) {
 	case UPIO_MEM:
 	case UPIO_MEM32:
+	case UPIO_XLR:
 #ifdef CONFIG_SERIAL_8250_AU1X00
 	case UPIO_AU:
 #endif
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 255cc26..0d9dbb4 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -2160,6 +2160,7 @@ uart_report_port(struct uart_driver *drv, struct uart_port *port)
 	case UPIO_MEM32:
 	case UPIO_AU:
 	case UPIO_TSI:
+	case UPIO_XLR:
 	case UPIO_DWAPB:
 		if (port->mapbase == 0)
 			snprintf(address, sizeof(address),
@@ -2601,6 +2602,7 @@ int uart_match_port(struct uart_port *port1, struct uart_port *port2)
 	case UPIO_MEM32:
 	case UPIO_AU:
 	case UPIO_TSI:
+	case UPIO_XLR:
 	case UPIO_DWAPB:
 		if (port1->mapbase == 0 && port2->mapbase == 0)
 			return (port1->membase == port2->membase);
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index 550b2d1..f790a5c 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -51,6 +51,7 @@ enum {
 	PLAT8250_DEV_MCA,
 	PLAT8250_DEV_AU1X00,
 	PLAT8250_DEV_SM501,
+	PLAT8250_DEV_XLR,
 };
 
 /*
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 989125a..71cdfc5 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -289,6 +289,7 @@ struct uart_port {
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
 #define UPIO_DWAPB		(6)			/* DesignWare APB UART */
 #define UPIO_RM9000		(7)			/* RM9000 type IO */
+#define UPIO_XLR		(8)			/* Netlogic XLR */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */
-- 
1.7.0.4

