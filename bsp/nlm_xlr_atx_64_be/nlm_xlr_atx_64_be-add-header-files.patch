From d221d23536e01aaa516070755dc312107a391102 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 May 2010 23:57:28 +0800
Subject: [PATCH 18/47] nlm_xlr_atx_64_be: add header files

XLR platform specific header files.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
[ Removes the broken specific atomic implementation
  Replace the hardcoded dm{f,t}c0, ldaddw, m{f,t}cr,swapw instructions
  Replace the specific preempt_{disable,enable} by the generic one. ]
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/include/asm/addrspace.h                |    4 +
 arch/mips/include/asm/asmmacro.h                 |   25 ++
 arch/mips/include/asm/hazards.h                  |    2 +
 arch/mips/include/asm/mach-rmi/war.h             |   24 ++
 arch/mips/include/asm/rmi/atx_cpld.h             |   64 +++
 arch/mips/include/asm/rmi/debug.h                |  117 ++++++
 arch/mips/include/asm/rmi/devices.h              |   46 +++
 arch/mips/include/asm/rmi/gpio.h                 |   77 ++++
 arch/mips/include/asm/rmi/interrupt.h            |   55 +++
 arch/mips/include/asm/rmi/io.h                   |   56 +++
 arch/mips/include/asm/rmi/iomap.h                |  220 ++++++++++
 arch/mips/include/asm/rmi/memory-exclusion.h     |   38 ++
 arch/mips/include/asm/rmi/mips-exts.h            |  466 ++++++++++++++++++++++
 arch/mips/include/asm/rmi/perf_ctr.h             |   72 ++++
 arch/mips/include/asm/rmi/phnx_user_mac.h        |   61 +++
 arch/mips/include/asm/rmi/phoenix_flash_pcmcia.h |  116 ++++++
 arch/mips/include/asm/rmi/phoenix_ide.h          |   62 +++
 arch/mips/include/asm/rmi/proc.h                 |   51 +++
 arch/mips/include/asm/rmi/rmi_pcix_gen_dev.h     |  124 ++++++
 arch/mips/include/asm/rmi/rmi_rw_lock.h          |  221 ++++++++++
 arch/mips/include/asm/rmi/sim.h                  |  324 +++++++++++++++
 arch/mips/include/asm/rmi/utils.h                |   88 ++++
 include/linux/libata.h                           |    2 +-
 include/linux/syscalls.h                         |   11 +
 24 files changed, 2325 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/include/asm/mach-rmi/war.h
 create mode 100644 arch/mips/include/asm/rmi/atx_cpld.h
 create mode 100644 arch/mips/include/asm/rmi/debug.h
 create mode 100644 arch/mips/include/asm/rmi/devices.h
 create mode 100644 arch/mips/include/asm/rmi/gpio.h
 create mode 100644 arch/mips/include/asm/rmi/interrupt.h
 create mode 100644 arch/mips/include/asm/rmi/io.h
 create mode 100644 arch/mips/include/asm/rmi/iomap.h
 create mode 100644 arch/mips/include/asm/rmi/memory-exclusion.h
 create mode 100644 arch/mips/include/asm/rmi/mips-exts.h
 create mode 100644 arch/mips/include/asm/rmi/perf_ctr.h
 create mode 100644 arch/mips/include/asm/rmi/phnx_user_mac.h
 create mode 100644 arch/mips/include/asm/rmi/phoenix_flash_pcmcia.h
 create mode 100644 arch/mips/include/asm/rmi/phoenix_ide.h
 create mode 100644 arch/mips/include/asm/rmi/proc.h
 create mode 100644 arch/mips/include/asm/rmi/rmi_pcix_gen_dev.h
 create mode 100644 arch/mips/include/asm/rmi/rmi_rw_lock.h
 create mode 100644 arch/mips/include/asm/rmi/sim.h
 create mode 100644 arch/mips/include/asm/rmi/utils.h

diff --git a/arch/mips/include/asm/addrspace.h b/arch/mips/include/asm/addrspace.h
index 569f80a..9b5e0a7 100644
--- a/arch/mips/include/asm/addrspace.h
+++ b/arch/mips/include/asm/addrspace.h
@@ -134,7 +134,11 @@
  * the region, 3 bits for the CCA mode.  This leaves 59 bits of which the
  * R8000 implements most with its 48-bit physical address space.
  */
+#ifdef CONFIG_CPU_PHOENIX
+#define TO_PHYS_MASK	_CONST64_(0x000000ffffffffff)	/* 2^^40 - 1 */
+#else
 #define TO_PHYS_MASK	_CONST64_(0x07ffffffffffffff)	/* 2^^59 - 1 */
+#endif
 
 #ifndef CONFIG_CPU_R8000
 
diff --git a/arch/mips/include/asm/asmmacro.h b/arch/mips/include/asm/asmmacro.h
index a8434c2..ccccecd 100644
--- a/arch/mips/include/asm/asmmacro.h
+++ b/arch/mips/include/asm/asmmacro.h
@@ -23,6 +23,27 @@
 #include <asm/mipsmtregs.h>
 #endif
 
+#ifdef CONFIG_PREEMPT
+
+.macro __preempt_disable
+lw  t0, TI_PRE_COUNT($28);
+addiu t0, 1;
+sw t0, TI_PRE_COUNT($28);
+.endm
+
+.macro __preempt_enable
+lw  t0, TI_PRE_COUNT($28)
+subu t0, 1
+sw t0, TI_PRE_COUNT($28)
+.endm
+
+#else
+
+#define __preempt_disable
+#define __preempt_enable
+
+#endif
+
 #ifdef CONFIG_MIPS_MT_SMTC
 	.macro	local_irq_enable reg=t0
 	mfc0	\reg, CP0_TCSTATUS
@@ -50,17 +71,21 @@
 	.endm
 #else
 	.macro	local_irq_enable reg=t0
+	__preempt_disable
 	mfc0	\reg, CP0_STATUS
 	ori	\reg, \reg, 1
 	mtc0	\reg, CP0_STATUS
+	__preempt_enable
 	irq_enable_hazard
 	.endm
 
 	.macro	local_irq_disable reg=t0
+	__preempt_disable
 	mfc0	\reg, CP0_STATUS
 	ori	\reg, \reg, 1
 	xori	\reg, \reg, 1
 	mtc0	\reg, CP0_STATUS
+	__preempt_enable
 	irq_disable_hazard
 	.endm
 #endif /* CONFIG_MIPS_MT_SMTC */
diff --git a/arch/mips/include/asm/hazards.h b/arch/mips/include/asm/hazards.h
index 0eaf77f..1eb0415 100644
--- a/arch/mips/include/asm/hazards.h
+++ b/arch/mips/include/asm/hazards.h
@@ -234,6 +234,8 @@ ASMMACRO(irq_disable_hazard,
 ASMMACRO(back_to_back_c0_hazard,
 	 _ssnop; _ssnop; _ssnop;
 	)
+ASMMACRO(tlbw_eret_hazard,
+	)
 #define instruction_hazard() do { } while (0)
 
 #endif
diff --git a/arch/mips/include/asm/mach-rmi/war.h b/arch/mips/include/asm/mach-rmi/war.h
new file mode 100644
index 0000000..8c1050d
--- /dev/null
+++ b/arch/mips/include/asm/mach-rmi/war.h
@@ -0,0 +1,24 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_RMI_WAR_H
+#define __ASM_MIPS_MACH_RMI_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+#endif /* __ASM_MIPS_MACH_RMI_WAR_H */
diff --git a/arch/mips/include/asm/rmi/atx_cpld.h b/arch/mips/include/asm/rmi/atx_cpld.h
new file mode 100644
index 0000000..e9361f4
--- /dev/null
+++ b/arch/mips/include/asm/rmi/atx_cpld.h
@@ -0,0 +1,64 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_ATX_CPLD_H
+#define _ASM_RMI_ATX_CPLD_H
+
+/*
+	 * bit_0 : xgs0 phy reset
+	 * bit_1 : xgs1 phy reset
+	 * bit_2 : HT reset
+	 * bit_3 : RTC reset
+	 * bit_4 : gmac phy soft reset
+	 * bit_5 : gmac phy hard reset
+	 * bit_6 : board reset
+	 * bit_7 : reserved
+*/
+#define ATX_CPLD_RESET_1   2
+
+/*
+ *  bit_0_2 : reserved
+ *  bit_3 : turn off xpak_0 tx
+ *  bit_4 : turn off xpak_1 tx
+ *  bit_5 : HT stop (active low)
+ *  bit_6 : flash program enable
+ *  bit_7 : compact flash io mode
+ */
+#define ATX_CPLD_MISC_CTRL 8
+
+/*
+ * bit_0 : reset tcam 
+ * bit_1 : reset xpak_0 module
+ * bit_2 : reset xpak_1 module
+ * bit_3_7 : reserved
+ */
+#define ATX_CPLD_RESET_2   9
+
+#endif /* _ASM_RMI_ATX_CPLD_H */
diff --git a/arch/mips/include/asm/rmi/debug.h b/arch/mips/include/asm/rmi/debug.h
new file mode 100644
index 0000000..7924f22
--- /dev/null
+++ b/arch/mips/include/asm/rmi/debug.h
@@ -0,0 +1,117 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_DEBUG_H
+#define _ASM_RMI_DEBUG_H
+
+/*Enable below macro to enable net stats. */
+//#define CONFIG_RMI_STATS
+extern void prom_printf(char *fmt, ...);
+#include <linux/threads.h>
+#include <asm/atomic.h>
+
+enum {
+  //cacheline 0
+  MSGRNG_INT,
+  MSGRNG_PIC_INT,
+  MSGRNG_MSG,
+  MSGRNG_EXIT_STATUS,
+  MSGRNG_MSG_CYCLES,
+  //cacheline 1
+  NETIF_TX = 8,
+  NETIF_RX,
+  NETIF_TX_COMPLETE,
+  NETIF_TX_COMPLETE_TX,
+  NETIF_RX_CYCLES,
+  NETIF_TX_COMPLETE_CYCLES,
+  NETIF_TX_CYCLES,
+  NETIF_TIMER_START_Q,
+  //NETIF_REG_FRIN,
+  //NETIF_INT_REG,
+  //cacheline 2
+  REPLENISH_ENTER = 16,
+  REPLENISH_ENTER_COUNT,
+  REPLENISH_CPU,
+  REPLENISH_FRIN,
+  REPLENISH_CYCLES,
+  NETIF_STACK_TX,
+  NETIF_START_Q,
+  NETIF_STOP_Q,
+  //cacheline 3
+  USER_MAC_START = 24,
+  USER_MAC_INT   = 24,
+  USER_MAC_TX_COMPLETE,
+  USER_MAC_RX,
+  USER_MAC_POLL,
+  USER_MAC_TX,
+  USER_MAC_TX_FAIL,
+  USER_MAC_TX_COUNT,
+  USER_MAC_FRIN,
+  //cacheline 4
+  USER_MAC_TX_FAIL_GMAC_CREDITS = 32,
+  USER_MAC_DO_PAGE_FAULT,
+  USER_MAC_UPDATE_TLB,
+  USER_MAC_UPDATE_TLB_PFN0,
+  USER_MAC_UPDATE_TLB_PFN1,
+  
+  PHNX_MAX_COUNTERS = 40
+};
+extern atomic_t phnx_counters[NR_CPUS][PHNX_MAX_COUNTERS];
+extern __u32 msgrng_msg_cycles;
+
+#ifdef CONFIG_RMI_STATS 
+#define phnx_inc_counter(x) atomic_inc(&phnx_counters[0][(x)])
+#define phnx_dec_counter(x) atomic_dec(&phnx_counters[0][(x)])
+#define phnx_set_counter(x, value) atomic_set(&phnx_counters[0][(x)], (value))
+#define phnx_get_counter(x) atomic_read(&phnx_counters[0][(x)])
+#else
+#define phnx_inc_counter(x) //atomic_inc(&phnx_counters[0][(x)])
+#define phnx_dec_counter(x) //atomic_dec(&phnx_counters[0][(x)])
+#define phnx_set_counter(x, value) //atomic_set(&phnx_counters[0][(x)], (value))
+#define phnx_get_counter(x) //atomic_read(&phnx_counters[0][(x)])
+#endif
+#if 0
+#define dbg_msg(fmt, args...) printk("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+
+#define dbg_panic(fmt, args...) panic("[%s@%d|:%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__, smp_processor_id(), ##args)
+
+#define prom_dbg_msg(fmt, args...) prom_printf("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+#else
+#define dbg_msg(fmt, args...)
+
+#define dbg_panic(fmt, args...) panic(fmt, ##args)
+
+#define prom_dbg_msg(fmt, args...) printk(fmt, ##args)
+#endif
+
+#endif
diff --git a/arch/mips/include/asm/rmi/devices.h b/arch/mips/include/asm/rmi/devices.h
new file mode 100644
index 0000000..329dba6
--- /dev/null
+++ b/arch/mips/include/asm/rmi/devices.h
@@ -0,0 +1,46 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_DEVICES_H
+#define _ASM_RMI_DEVICES_H
+
+#define XLR_VIRT_UART_MAJOR       239
+#define XLR_TB_MAJOR              240
+#define XLR_USER_MAC_MAJOR        241
+#define XLR_CRYPTO_MAJOR          242
+
+#define BTLBDEV_MAJOR             243
+
+#define XLR_MSGRING_SHM_MAJOR     244
+#define XLR_APP_LOADER_MAJOR      245
+#define XLR_CONSOLE_OVER_PCI_MAJOR	  246
+#define XLR_DEBUGGER_MAJOR              247
+
+#endif
diff --git a/arch/mips/include/asm/rmi/gpio.h b/arch/mips/include/asm/rmi/gpio.h
new file mode 100644
index 0000000..27169af
--- /dev/null
+++ b/arch/mips/include/asm/rmi/gpio.h
@@ -0,0 +1,77 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_GPIO_H
+#define _ASM_RMI_GPIO_H
+
+#include <asm/rmi/iomap.h>
+
+#define PHOENIX_GPIO_INT_EN_REG 0
+#define PHOENIX_GPIO_INPUT_INVERSION_REG 1
+#define PHOENIX_GPIO_IO_DIR_REG 2
+#define PHOENIX_GPIO_IO_DATA_WR_REG 3
+#define PHOENIX_GPIO_IO_DATA_RD_REG 4
+
+#define PHOENIX_GPIO_SWRESET_REG 8
+
+#define PHOENIX_GPIO_DRAM1_CNTRL_REG 9
+#define PHOENIX_GPIO_DRAM1_RATIO_REG 10
+#define PHOENIX_GPIO_DRAM1_RESET_REG 11
+#define PHOENIX_GPIO_DRAM1_STATUS_REG 12
+
+#define PHOENIX_GPIO_DRAM2_CNTRL_REG 13
+#define PHOENIX_GPIO_DRAM2_RATIO_REG 14
+#define PHOENIX_GPIO_DRAM2_RESET_REG 15
+#define PHOENIX_GPIO_DRAM2_STATUS_REG 16
+
+#define PHOENIX_GPIO_PWRON_RESET_CFG_REG 21
+
+#define PHOENIX_GPIO_BIST_ALL_GO_STATUS_REG 24
+#define PHOENIX_GPIO_BIST_CPU_GO_STATUS_REG 25
+#define PHOENIX_GPIO_BIST_DEV_GO_STATUS_REG 26
+
+#define PHOENIX_GPIO_FUSE_BANK_REG 35
+
+#define PHOENIX_GPIO_CPU_RESET_REG 40
+
+#define PHOENIX_GPIO_RNG_REG 43
+
+#define PHOENIX_PWRON_RESET_PCMCIA_BOOT 17
+
+#define PHOENIX_GPIO_LED_BITMAP 0x1700000
+#define PHOENIX_GPIO_LED_0_SHIFT 20
+#define PHOENIX_GPIO_LED_1_SHIFT 24
+
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_RESET 0x01
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_HARD_RESET 0x02
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_SOFT_RESET 0x03
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_MAIN 0x04
+
+#endif
diff --git a/arch/mips/include/asm/rmi/interrupt.h b/arch/mips/include/asm/rmi/interrupt.h
new file mode 100644
index 0000000..5e44062
--- /dev/null
+++ b/arch/mips/include/asm/rmi/interrupt.h
@@ -0,0 +1,55 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_INTERRUPT_H
+#define _ASM_RMI_INTERRUPT_H
+
+#include <asm/rmi/pic.h>
+
+/* Defines for the IRQ numbers */
+
+#define IRQ_DUMMY_UART           2
+#define IRQ_IPI_SMP_FUNCTION     3
+#define IRQ_IPI_SMP_RESCHEDULE   4
+#define IRQ_REMOTE_DEBUG         5
+#define IRQ_MSGRING              6
+#define IRQ_TIMER                7
+#define IRQ_IPI_SMP_KGDB   		50
+#define IRQ_IPI_OPROFILE        51
+
+#define IRQ_IPI_CRF_MGMT_IPI	45 /* */
+#define IRQ_IPI_CRF_EVENTQ_IPI 46 
+
+
+#define SMP_CALL_KGDB_HOOK 	8
+#define SMP_OPROFILE_IPI        16
+
+
+#endif
diff --git a/arch/mips/include/asm/rmi/io.h b/arch/mips/include/asm/rmi/io.h
new file mode 100644
index 0000000..2bb85b4
--- /dev/null
+++ b/arch/mips/include/asm/rmi/io.h
@@ -0,0 +1,56 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_IO_H
+#define _ASM_RMI_IO_H
+
+#define RMI_UNCACHED_START 0x10000000UL
+#define RMI_UNCACHED_END 0x20000000UL
+
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+
+#define __raw_writeb(v,a)       (*(volatile unsigned char  *)(a) = (v))
+#define __raw_writew(v,a)       (*(volatile unsigned short *)(a) = (v))
+#define __raw_writel(v,a)       (*(volatile unsigned int   *)(a) = (v))
+
+#define __raw_readb(a)          (*(volatile unsigned char  *)(a))
+#define __raw_readw(a)          (*(volatile unsigned short *)(a))
+#define __raw_readl(a)          (*(volatile unsigned int   *)(a))
+
+#define ioread8(p)  ({ unsigned int __v = __raw_readb(p); __v; })
+#define ioread16(p) ({ unsigned int __v = le16_to_cpu(__raw_readw(p)); __v; })
+#define ioread32(p) ({ unsigned int __v = le32_to_cpu(__raw_readl(p)); __v; })
+
+#define iowrite8(v,p)   __raw_writeb(v, p)
+#define iowrite16(v,p)  __raw_writew(cpu_to_le16(v), p)
+#define iowrite32(v,p)  __raw_writel(cpu_to_le32(v), p)
+
+#endif
diff --git a/arch/mips/include/asm/rmi/iomap.h b/arch/mips/include/asm/rmi/iomap.h
new file mode 100644
index 0000000..68822c1
--- /dev/null
+++ b/arch/mips/include/asm/rmi/iomap.h
@@ -0,0 +1,220 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RFI_IO_H
+#define _ASM_RFI_IO_H
+
+#define DEFAULT_PHOENIX_IO_BASE 0xffffffffbef00000ULL
+#define PHOENIX_IO_SIZE                   0x1000
+
+#define PHOENIX_IO_BRIDGE_OFFSET          0x00000
+
+#define PHOENIX_IO_DDR2_CHN0_OFFSET       0x01000
+#define PHOENIX_IO_DDR2_CHN1_OFFSET       0x02000
+#define PHOENIX_IO_DDR2_CHN2_OFFSET       0x03000
+#define PHOENIX_IO_DDR2_CHN3_OFFSET       0x04000
+
+#define PHOENIX_IO_RLD2_CHN0_OFFSET       0x05000
+#define PHOENIX_IO_RLD2_CHN1_OFFSET       0x06000
+
+#define PHOENIX_IO_SRAM_OFFSET            0x07000
+
+#define PHOENIX_IO_PIC_OFFSET             0x08000
+#define PHOENIX_IO_PCIX_OFFSET            0x09000
+#define PHOENIX_IO_HT_OFFSET              0x0A000
+
+#define PHOENIX_IO_SECURITY_OFFSET        0x0B000
+
+#define PHOENIX_IO_GMAC_0_OFFSET          0x0C000
+#define PHOENIX_IO_GMAC_1_OFFSET          0x0D000
+#define PHOENIX_IO_GMAC_2_OFFSET          0x0E000
+#define PHOENIX_IO_GMAC_3_OFFSET          0x0F000
+
+#define PHOENIX_IO_SPI4_0_OFFSET          0x10000
+#define PHOENIX_IO_XGMAC_0_OFFSET         0x11000
+#define PHOENIX_IO_SPI4_1_OFFSET          0x12000
+#define PHOENIX_IO_XGMAC_1_OFFSET         0x13000
+
+#define PHOENIX_IO_UART_0_OFFSET          0x14000
+#define PHOENIX_IO_UART_1_OFFSET          0x15000
+
+#define PHOENIX_IO_I2C_0_OFFSET           0x16000
+#define PHOENIX_IO_I2C_1_OFFSET           0x17000
+
+#define PHOENIX_IO_GPIO_OFFSET            0x18000
+
+#define PHOENIX_IO_FLASH_OFFSET           0x19000
+
+#define PHOENIX_IO_TB_OFFSET           	  0x1C000
+
+#define PHOENIX_CPLD_OFFSET               0xffffffffbd840000ULL
+
+/* Base Address (Virtual) of the PCI Config address space
+ * For now, choose 256M phys in kseg1 = 0xA0000000 + (1<<28)
+ * Config space spans 256 (num of buses) * 256 (num functions) * 256 bytes
+ * ie 1<<24 = 16M
+ */ 
+#define DEFAULT_PCI_CONFIG_BASE         0x18000000
+#define DEFAULT_HT_TYPE0_CFG_BASE       0x16000000
+#define DEFAULT_HT_TYPE1_CFG_BASE       0x17000000
+
+#ifndef __ASSEMBLY__
+
+#include <linux/preempt.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+typedef volatile __u32 phoenix_reg_t;
+extern unsigned long phoenix_io_base;
+
+#define phoenix_io_mmio(offset) ((phoenix_reg_t *)(phoenix_io_base+(offset)))
+
+#ifdef RMI_BRIDGE_WKAROUND
+#include "rmi_rw_lock.h"
+extern rmi_rwlock_t *rmi_bridge_lock;
+extern int rmi_enable_br_wrkaround;
+
+static inline uint32_t rmi_br_read_lock(void)
+{
+    uint32_t ret = 0;
+	if(rmi_enable_br_wrkaround){
+         preempt_disable();
+		 ret = rmi_read_lock_irq_save(rmi_bridge_lock);
+         preempt_enable();
+    }
+	return ret;
+}
+static inline void rmi_br_read_unlock(unsigned int flags)
+{
+	if(rmi_enable_br_wrkaround){
+        preempt_disable();
+		rmi_read_unlock_irq_restore(rmi_bridge_lock, flags);
+        preempt_enable();
+    }
+}
+
+static inline uint32_t rmi_br_write_lock(void)
+{
+    uint32_t ret = 0;
+	if(rmi_enable_br_wrkaround){
+        preempt_disable();
+		ret = rmi_write_lock_irq_save(rmi_bridge_lock);
+        preempt_enable();
+    }
+	return ret;
+}
+
+static inline void rmi_br_write_unlock(unsigned int flags)
+{
+	if(rmi_enable_br_wrkaround){
+        preempt_disable();
+		rmi_write_unlock_irq_restore(rmi_bridge_lock, flags);
+        preempt_enable();
+    }
+}
+
+static inline uint32_t rmi_read_reg_locked(phoenix_reg_t *base, 
+		unsigned int offset) 	
+{
+	unsigned int flags, val;
+
+	flags = rmi_br_read_lock();
+	val = (be32_to_cpu((base)[(offset)])); 
+	rmi_br_read_unlock(flags);
+
+	return val;
+}
+static inline uint32_t rmi_read_reg_le_locked(phoenix_reg_t *base, 
+		unsigned int offset) 	
+{
+	unsigned int flags, val;
+	flags = rmi_br_read_lock();
+	val = (le32_to_cpu((base)[(offset)])); 
+	rmi_br_read_unlock(flags);
+
+	return val;
+}
+static inline void rmi_write_reg_locked(phoenix_reg_t *base, 
+		 unsigned int offset,  unsigned int value)
+{
+	unsigned int flags;
+	flags = rmi_br_write_lock();
+	((base)[(offset)] = cpu_to_be32((value)));
+	rmi_br_write_unlock(flags);
+}
+
+static inline void rmi_write_reg_le_locked(phoenix_reg_t *base, 
+		 unsigned int offset,  unsigned int value)
+{
+	unsigned int flags;
+	flags = rmi_br_write_lock();
+	((base)[(offset)] = cpu_to_le32((value)));
+	rmi_br_write_unlock(flags);
+}
+
+#define phoenix_read_reg(base, offset) rmi_read_reg_locked(base, offset)
+#define phoenix_write_reg(base, offset, value) \
+	rmi_write_reg_locked(base, offset, value)
+
+#define phoenix_read_reg_le32(base, offset) \
+	rmi_read_reg_le_locked(base, offset)
+#define phoenix_write_reg_le32(base, offset, value) \
+	rmi_write_reg_le_locked(base, offset, value)
+#else
+static inline uint32_t rmi_br_read_lock(void) 
+{
+	return 0;
+}
+
+static inline void rmi_br_read_unlock(unsigned int flags)
+{
+}
+
+static inline uint32_t rmi_br_write_lock(void)
+{
+	return 0;
+}
+
+static inline void rmi_br_write_unlock(unsigned int flags)
+{
+}
+#define phoenix_read_reg(base, offset) (be32_to_cpu((base)[(offset)]))
+#define phoenix_write_reg(base, offset, value) ((base)[(offset)] = cpu_to_be32((value)))
+
+#define phoenix_read_reg_le32(base, offset) (le32_to_cpu((base)[(offset)]))
+#define phoenix_write_reg_le32(base, offset, value) \
+	((base)[(offset)] = cpu_to_le32((value)))
+
+#endif
+extern void on_chip_init(void);
+
+#endif
+
+#endif
diff --git a/arch/mips/include/asm/rmi/memory-exclusion.h b/arch/mips/include/asm/rmi/memory-exclusion.h
new file mode 100644
index 0000000..2a21502
--- /dev/null
+++ b/arch/mips/include/asm/rmi/memory-exclusion.h
@@ -0,0 +1,38 @@
+/***********************************************************************
+Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_2#**********************************/
+
+#ifndef PHNX_MEMORY_EXCLUSION
+#define PHNX_MEMORY_EXCLUSION
+
+#define PHNX_RMIOS_TCPIP_START  (8<<20)
+#define PHNX_RMIOS_TCPIP_END    (96<<20)
+
+#define PHNX_RMIOS_IPSEC_START  (1<<20)
+#define PHNX_RMIOS_IPSEC_END    (51<<20)
+
+#define PHNX_RMIOS_LIB_START    (16<<20)
+#define PHNX_RMIOS_LIB_END	(51<<20)
+
+#endif
diff --git a/arch/mips/include/asm/rmi/mips-exts.h b/arch/mips/include/asm/rmi/mips-exts.h
new file mode 100644
index 0000000..d6df5cd
--- /dev/null
+++ b/arch/mips/include/asm/rmi/mips-exts.h
@@ -0,0 +1,466 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_MIPS_EXTS_H
+#define _ASM_RMI_MIPS_EXTS_H
+
+#define PHOENIX_OSS_SEL_TLB_STATS 0
+#define PHOENIX_OSS_SEL_UNUSED 1
+#define PHOENIX_OSS_SEL_PAGEMASK 2
+#define PHOENIX_OSS_SEL_VADDR 3
+#define PHOENIX_OSS_SEL_PFN0 4
+#define PHOENIX_OSS_SEL_PFN1 5
+#define PHOENIX_OSS_SEL_K0 6
+#define PHOENIX_OSS_SEL_K1 7
+
+#define OS_SCRATCH_REG0	22, 0
+#define OS_SCRATCH_REG1	22, 1
+#define OS_SCRATCH_REG2	22, 2
+#define OS_SCRATCH_REG3	22, 3
+#define OS_SCRATCH_REG4	22, 4
+#define OS_SCRATCH_REG5	22, 5
+#define OS_SCRATCH_REG6	22, 6
+#define OS_SCRATCH_REG7	22, 7
+
+#define OS_KGDB_SCRATCH_REG6	$22, 6
+#define OS_KGDB_SCRATCH_REG7	$22, 7
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/rmi/interrupt.h>
+
+/* Scratch registers used */
+#define RMI_TLB_STATS_SCRATCH_REG_SEL  2
+#define RMI_HTLB_PMASK_SCRATCH_REG_SEL 3
+#define RMI_CRF_PERF0_SCRATCH_REG_SEL  4
+#define RMI_CRF_PERF1_SCRATCH_REG_SEL  5
+
+
+#define DMFC0_AT_EIRR 0x40214806
+#define DMFC0_AT_EIMR 0x40214807
+#define DMTC0_AT_EIRR 0x40a14806
+#define DMTC0_AT_EIMR 0x40a14807
+
+/* functions to write to and read from the extended
+ * cp0 registers.
+ * EIRR : Extended Interrupt Request Register
+ *        cp0 register 9 sel 6
+ *        bits 0...7 are same as cause register 8...15
+ * EIMR : Extended Interrupt Mask Register
+ *        cp0 register 9 sel 7
+ *        bits 0...7 are same as status register 8...15
+ */
+
+static inline __u64 read_64bit_cp0_eirr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips64\n"
+			"dmfc0 $1, $9, 6\n\t"
+			".set mips4\n"
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline __u64 read_64bit_cp0_eimr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips64\n"
+			"dmfc0 $1, $9, 7\n\t"
+			".set mips4\n"
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline void write_64bit_cp0_eirr(__u64 value)
+{
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+
+	".set mips64\n"
+	"dmtc0 $1, $9, 6\n\t"
+	".set mips4\n"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}
+
+static inline void write_64bit_cp0_eimr(__u64 value)
+{
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+
+	".set mips64\n"
+	"dmtc0 $1, $9, 7\n\t"
+	".set mips4\n"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}
+
+static __inline__ int ldadd_w(unsigned int value, volatile int *addr)
+{
+	unsigned long res;
+  __asm__ __volatile__(
+		       ".set push\n"
+		       ".set noreorder\n"
+		       "move $8, %2\n"
+		       "move $9, %3\n"
+		       "ldaddw %2, %3\n"
+		       "move %0, $8\n"
+		       ".set pop\n"
+		       :"=r"(res), "+m"(*addr)
+		       : "r" (value), "r"((unsigned long)addr)
+		       : "$8", "$9"
+		       );
+  return res;
+}
+
+static __inline__ void ldadd_w_no_read(int value, volatile int *addr)
+{
+	unsigned long res;
+  __asm__ __volatile__(
+                       ".set push\n"
+                       ".set noreorder\n"
+                       "move $8, %2\n"
+                       "move $9, %3\n"
+                       "ldaddw $8, $9\n"
+                       //"move %0, $8\n"
+                       ".set pop\n"
+                       :"=r"(res), "+m"(*addr)
+                       : "r" (value), "r"((unsigned long)addr)
+                       : "$8", "$9"
+                       );
+}
+
+static __inline__ unsigned int ldadd_wu(unsigned int value, volatile unsigned int *addr)
+{
+	unsigned long res;
+  __asm__ __volatile__(
+		       ".set push\n"
+		       ".set noreorder\n"
+		       "move $8, %2\n"
+		       "move $9, %3\n"
+		       "ldaddwu $8, $9\n"
+		       "move %0, $8\n"
+		       ".set pop\n"
+		       :"=r"(res), "+m"(*addr)
+		       : "r"(value), "r"((unsigned long)addr)
+		       : "$8", "$9"
+		       );
+  return res;
+}
+
+static __inline__ void ldadd_wu_no_read(unsigned int value,
+					volatile unsigned int *addr)
+{
+	unsigned long res;
+  __asm__ __volatile__(
+                       ".set push\n"
+                       ".set noreorder\n"
+                       "move $8, %2\n"
+                       "move $9, %3\n"
+                       "ldaddwu $8, $9\n"
+                       //"move %0, $8\n"
+                       ".set pop\n"
+                       :"=r"(res), "+m"(*addr)
+                       : "r"(value), "r"((unsigned long)addr)
+                       : "$8", "$9"
+                       );
+}
+
+
+
+#if 0
+#define read_64bit_cp2_register(source)                         \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define write_64bit_cp2_register(register,value)                \
+        __asm__ __volatile__(                                   \
+        "mtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+        : : "r" (value));
+
+#define read_64bit_cp2_register_sel(source, sel)                \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc2\t%0,"STR(source)", %1\n\t"                        \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define write_64bit_cp2_register_sel(register,value,sel)        \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mtc2\t%0,"STR(register)",%1\n\t"		        \
+	"nop\n\t"  					        \
+	".set\tpop"						\
+        : : "r" (value), "i"(sel));
+
+#endif
+
+#define phoenix_id()                                            \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+			/* read_c0_config7() */			\
+                       "mfc0 $8, $16, 7\n"                     \
+		       "srl  $8, $8, 10\n"                      \
+		       "andi %0, $8, 0x3f\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+#define phoenix_cpu_id()                                        \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+			/* read_c0_config7() */			\
+                       "mfc0 $8, $16, 7\n"                     \
+		       "srl  $8, $8, 4\n"                       \
+		       "andi %0, $8, 0x7\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+#define phoenix_thr_id()                                        \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+			/* read_c0_config7() */			\
+                       "mfc0 $8, $16, 7\n"                     \
+		       "andi %0, $8, 0x03\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+static __inline__ int hard_smp_processor_id(void)
+{
+  return (phoenix_cpu_id() << 2) + phoenix_thr_id();
+}
+
+#define phoenix_cpu_to_thrid(cpu) (phys_proc_id[(cpu)] >> 2)
+#define phoenix_cpu_to_cpuid(cpu) (phys_proc_id[(cpu)] & 0x3)
+
+#define CPU_BLOCKID_IFU      0
+#define CPU_BLOCKID_ICU      1
+#define CPU_BLOCKID_IEU      2
+#define CPU_BLOCKID_LSU      3
+#define CPU_BLOCKID_MMU      4
+#define CPU_BLOCKID_PRF      5
+
+#define LSU_CERRLOG_REGID    9
+
+static __inline__ unsigned int read_32bit_phnx_ctrl_reg(int block, int reg)
+{
+  unsigned int __res;
+
+  __asm__ __volatile__(
+		       ".set\tpush\n\t"
+		       ".set\tnoreorder\n\t"
+		       "move $9, %1\n"
+ 		       "mfcr\t$8, $9\n\t" 
+		       "move %0, $8\n"
+		       ".set\tpop"
+		       : "=r" (__res) : "r"((block<<8)|reg)
+		       : "$8", "$9"
+		       );
+  return __res;
+}
+
+static __inline__ void write_32bit_phnx_ctrl_reg(int block, int reg, unsigned int value)
+{
+  __asm__ __volatile__(
+		       ".set\tpush\n\t"
+		       ".set\tnoreorder\n\t"
+		       "move $8, %0\n"
+		       "move $9, %1\n"
+ 		       "mtcr\t$8, $9\n\t" 
+		       ".set\tpop"
+		       :
+		       : "r" (value), "r"((block<<8)|reg)
+		       : "$8", "$9"
+		       );
+}
+
+static __inline__ unsigned long long read_64bit_phnx_ctrl_reg(int block, int reg)
+{
+	unsigned int high, low;
+
+	__asm__ __volatile__(
+		".set\tmips64\n\t"
+		"move    $9, %2\n"
+		".set\tmips0\n\t"
+		"mfcr    $8, $9\n"
+		".set\tmips64\n\t"
+		"dsrl32  %0, $8, 0\n\t"
+		"dsll32  $8, $8, 0\n\t"
+		"dsrl32  %1, $8, 0\n\t"
+		".set mips0"
+		: "=r" (high), "=r"(low)
+		: "r"((block<<8)|reg)
+		: "$8", "$9"
+		);
+
+	return ( (((unsigned long long)high)<<32) | low);
+}
+
+static __inline__ void write_64bit_phnx_ctrl_reg(int block, int reg,unsigned long long value)
+{
+	__u32 low, high;
+	high = value >> 32;
+	low = value & 0xffffffff;
+
+	__asm__ __volatile__(
+		".set push\n"
+		".set noreorder\n"
+		".set mips4\n\t"
+		/* Set up "rs" */
+		"move $9, %0\n"
+
+		/* Store 64 bit value in "rt" */
+		"dsll32 $10, %1, 0  \n\t"
+		"dsll32 $8, %2, 0  \n\t"
+		"dsrl32 $8, $8, 0  \n\t"
+		"or     $8, $10, $8 \n\t"
+
+		".set mips0\n\t"
+		"mtcr $8, $9\n\t"
+		".set mips4\n\t"
+
+		".set pop\n"
+
+		:  /* No outputs */
+		: "r"((block<<8)|reg), "r" (high), "r" (low)
+		: "$8", "$9", "$10"
+		);
+}
+
+typedef struct { volatile int value; } phnx_atomic_t;
+
+static __inline__ int phnx_test_and_set(phnx_atomic_t *lock)
+{
+  int oldval = 0;
+
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			"move $9, %2\n"
+			"li $8, 1\n"
+			"swapw $8, $9\n"
+			"move %1, $8\n"
+			".set pop\n"
+			: "+m" (lock->value), "=r" (oldval)
+			: "r" ((unsigned long)&lock->value)
+			: "$8", "$9"
+			);
+  return (oldval == 0 ? 1/*success*/ : 0/*failure*/);
+}
+
+#define rmi_write_os_scratch_2(val)	__write_64bit_c0_register($22, 2, val)
+#define rmi_read_os_scratch_2()	__read_64bit_c0_register($22, 2)
+
+#define rmi_write_os_scratch_3(val)	__write_64bit_c0_register($22, 3, val)
+#define rmi_read_os_scratch_3()	__read_64bit_c0_register($22, 3)
+#endif
+
+#endif /* _ASM_RMI_MIPS_EXTS_H */
diff --git a/arch/mips/include/asm/rmi/perf_ctr.h b/arch/mips/include/asm/rmi/perf_ctr.h
new file mode 100644
index 0000000..0dd108f
--- /dev/null
+++ b/arch/mips/include/asm/rmi/perf_ctr.h
@@ -0,0 +1,72 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __ASM_RMI_PERF_CTR_H
+#define __ASM_RMI_PERF_CTR_H
+
+#include <asm/mipsregs.h>
+
+#define CP0_PERF_CTR  $25
+
+/* Subset of perf ctr events */
+
+#define PERF_CTR_INSTR_FETCHED           0
+#define PERF_CTR_ICACHE_MISSES           1
+#define PERF_CTR_SLEEP_CYCLES           12
+#define PERF_CTR_INSTR_RETIRED          17
+#define PERF_CTR_BRJMP_INSTR            20
+#define PERF_CTR_BRJMP_FLUSH            21
+#define PERF_CTR_REPLAYFLUSH            27
+#define PERF_CTR_REPLAYFLUSH_LDUSE      28
+#define PERF_CTR_L1_HIT                 38
+#define PERF_CTR_L1_REF                 39
+#define PERF_CTR_SNOOP_UPGRADE_FAIL     47
+#define PERF_CTR_SNOOP_TRANSFERS        48
+#define PERF_CTR_SNOOP_HITS             49
+#define PERF_CTR_SNOOP_OPS              50
+#define PERF_CTR_CYCLES                 63
+
+/* 2 sets of counters are supported across all threads of a core */
+#define PERF_CTR_EVENT0        0
+#define PERF_CTR_EVENT0_VALUE  1
+#define PERF_CTR_EVENT1        2
+#define PERF_CTR_EVENT1_VALUE  3
+
+#define PERF_CTR_DEFAULT 0x0f /* disable int, enable counting in all modes */
+
+#define perf_ctr_start(ctr, event, global, thr) __write_32bit_c0_register($25, ctr, ((PERF_CTR_DEFAULT)|((global)<<13)|((thr)<<11)|((event)<<5)) ) 
+
+#define perf_ctr_stop(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_reset(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_read(ctr) __read_32bit_c0_register($25, ctr)
+
+#endif /* __ASM_RMI_PERF_CTR_H */
diff --git a/arch/mips/include/asm/rmi/phnx_user_mac.h b/arch/mips/include/asm/rmi/phnx_user_mac.h
new file mode 100644
index 0000000..57a7209
--- /dev/null
+++ b/arch/mips/include/asm/rmi/phnx_user_mac.h
@@ -0,0 +1,61 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PHNX_USER_MAC_H
+#define _ASM_RMI_PHNX_USER_MAC_H
+
+#define PHNX_USER_MAC_MMAP_VIRT_START 0x60000000
+#define PHNX_USER_MAC_SIZE            0x800000
+
+#ifndef __ASSEMBLY__
+#include <asm/rmi/sim.h>
+
+extern void phoenix_user_mac_update_time(void);
+
+struct xlr_user_mac_config {
+	int l4_extract;
+	int fast_syscall;
+};
+
+extern struct xlr_user_mac_config xlr_user_mac;
+
+static __inline__ int xlr_user_mac_l4_extract(void)
+{
+	return xlr_hybrid_user_mac() ? xlr_user_mac.l4_extract  : 0;
+}
+
+static __inline__ int xlr_user_mac_fast_syscall(void)
+{
+	return xlr_hybrid_user_mac() && (xlr_user_mac.fast_syscall == 1);
+}
+
+#endif
+
+#endif
diff --git a/arch/mips/include/asm/rmi/phoenix_flash_pcmcia.h b/arch/mips/include/asm/rmi/phoenix_flash_pcmcia.h
new file mode 100644
index 0000000..e2f9f36
--- /dev/null
+++ b/arch/mips/include/asm/rmi/phoenix_flash_pcmcia.h
@@ -0,0 +1,116 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _FLASH_PCMCIA_H_
+#define _FLASH_PCMCIA_H_
+
+#define R_FLASH_PCMCIA_BASE_ADDR                    0x0
+#define   O_BASE_ADDR__base_addr                    0
+#define   W_BASE_ADDR__base_addr                    16
+#define R_FLASH_PCMCIA_BASE_ADDR_MASK               0x1
+#define   O_BASE_ADDR_MASK__base_amask              0
+#define   W_BASE_ADDR_MASK__base_amask              16
+#define R_FLASH_PCMCIA_DEV_PARM                     0x2
+#define   O_DEV_PARM__burst_mode_en                 0
+#define   O_DEV_PARM__burst_mode                    1
+#define   W_DEV_PARM__burst_mode                    3
+#define   O_DEV_PARM__wait_en                       4
+#define   O_DEV_PARM__wait_pol                      5
+#define   O_DEV_PARM__mx_addr                       6
+#define   O_DEV_PARM__dwidth                        7
+#define   W_DEV_PARM__dwidth                        2
+#define   O_DEV_PARM__pcmcia_en                     9
+#define   O_DEV_PARM__genif_en                      10
+#define   O_DEV_PARM__genparity_en                  11
+#define   O_DEV_PARM__genparity_type                12
+#define   O_DEV_PARM__adv_type                      13
+#define R_FLASH_TIMING_PARM_0                       0x3
+#define   O_FLASH_TIMING_PARM_0__ale_width          0
+#define   W_FLASH_TIMING_PARM_0__ale_width          3
+#define   O_FLASH_TIMING_PARM_0__ale_to_cs          3
+#define   W_FLASH_TIMING_PARM_0__ale_to_cs          3
+#define   O_FLASH_TIMING_PARM_0__cs_width           6
+#define   W_FLASH_TIMING_PARM_0__cs_width           5
+#define   O_FLASH_TIMING_PARM_0__wait_to_data       11
+#define   W_FLASH_TIMING_PARM_0__wait_to_data       5
+#define   O_FLASH_TIMING_PARM_0__cs_to_oe           16
+#define   W_FLASH_TIMING_PARM_0__cs_to_oe           3
+#define   O_FLASH_TIMING_PARM_0__cs_to_we           19
+#define   W_FLASH_TIMING_PARM_0__cs_to_we           3
+#define   O_FLASH_TIMING_PARM_0__oe_to_cs           22
+#define   W_FLASH_TIMING_PARM_0__oe_to_cs           2
+#define   O_FLASH_TIMING_PARM_0__we_to_cs           24
+#define   W_FLASH_TIMING_PARM_0__we_to_cs           4
+#define   O_FLASH_TIMING_PARM_0__cs_to_cs           28
+#define   W_FLASH_TIMING_PARM_0__cs_to_cs           4
+#define R_FLASH_TIMING_PARM_1                       0x4
+#define   O_FLASH_TIMING_PARM_1__oe_width           0
+#define   W_FLASH_TIMING_PARM_1__oe_width           6
+#define   O_FLASH_TIMING_PARM_1__we_width           6
+#define   W_FLASH_TIMING_PARM_1__we_width           6
+#define   O_FLASH_TIMING_PARM_1__wait_timeout       12
+#define   W_FLASH_TIMING_PARM_1__wait_timeout       15
+#define R_PCMCIA_CONFIG                             0x5
+#define   O_PCMCIA_CONFIG__pcmcia_en                0
+#define   O_PCMCIA_CONFIG__reg_access               1
+#define   O_PCMCIA_CONFIG__reset                    2
+#define   O_PCMCIA_CONFIG__cdmask                   4
+#define   O_PCMCIA_CONFIG__wpmask                   5
+#define   O_PCMCIA_CONFIG__rdymask                  6
+#define   O_PCMCIA_CONFIG__rybymask                 7
+#define R_PCMCIA_STATUS                             0x6
+#define   O_PCMCIA_STATUS__bvd1_sts                 0
+#define   O_PCMCIA_STATUS__bvd2_sts                 1
+#define   O_PCMCIA_STATUS__cd1_sts                  2
+#define   O_PCMCIA_STATUS__cd2_sts                  3
+#define   O_PCMCIA_STATUS__vs1_sts                  4
+#define   O_PCMCIA_STATUS__vs2_sts                  5
+#define   O_PCMCIA_STATUS__wp_sts                   6
+#define   O_PCMCIA_STATUS__rdy_sts                  7
+#define   O_PCMCIA_STATUS__ryby_sts                 8
+#define   O_PCMCIA_STATUS__cd_intr                  9
+#define   O_PCMCIA_STATUS__wp_intr                  10
+#define   O_PCMCIA_STATUS__rdy_intr                 11
+#define   O_PCMCIA_STATUS__illegal_addr_intrpt      12
+#define   O_PCMCIA_STATUS__mutl_cs_intrpt           13
+#define   O_PCMCIA_STATUS__wait_timeout_intrpt      14
+#define   O_PCMCIA_STATUS__ryby_intrpt              16
+#define   O_PCMCIA_STATUS__werr_intrpt              17
+#define   O_PCMCIA_STATUS__illegal_pcmcia_intrpt    18
+#define R_GENERIC_REGION_STATUS                     0x7
+#define   O_GENERIC_REGION_STATUS__cs_err_intrpt    0
+#define   W_GENERIC_REGION_STATUS__cs_err_intrpt    8
+#define R_GENERIC_ERROR_ADDR                        0x8
+#define   O_GENERIC_ERROR_ADDR__err_addr            0
+#define   W_GENERIC_ERROR_ADDR__err_addr            32
+
+
+#endif /* _FLASH_PCMCIA_H_ */
+
diff --git a/arch/mips/include/asm/rmi/phoenix_ide.h b/arch/mips/include/asm/rmi/phoenix_ide.h
new file mode 100644
index 0000000..0582057
--- /dev/null
+++ b/arch/mips/include/asm/rmi/phoenix_ide.h
@@ -0,0 +1,62 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __ASM_PHOENIX_H
+#define __ASM_PHOENIX_H
+
+
+#define  CONFIG_PHOENIX 1
+
+#ifdef CONFIG_PHOENIX
+#define PHOENIX_BOARD_NAME "PHOENIX -ATX1"
+#define PHOENIX_HAVE_PCMCIA 0
+#define PHOENIX_HAVE_IDE    1
+#endif
+
+
+#ifdef PHOENIX_HAVE_IDE
+#define IDE_CS          6
+#define IDE_PHYS        0x1D000000
+#define K_GPIO_GB_IDE   4
+#define K_GPIO_PC_READY 11 
+#define K_INT_GPIO_0    32 
+#define K_INT_GB_IDE    (K_INT_GPIO_0 + K_GPIO_GB_IDE)
+#endif
+
+#ifdef PHOENIX_HAVE_PCMCIA
+#define PCMCIA_CS       4
+#define PCMCIA_PHYS     0x11000000
+#define K_INT_PC_READY  (K_INT_GPIO_0 + K_GPIO_PC_READY)
+#endif
+
+
+#define IOADDR(a) (UNCAC_BASE + (a))
+
+#endif /* __ASM_PHOENIX_H */
diff --git a/arch/mips/include/asm/rmi/proc.h b/arch/mips/include/asm/rmi/proc.h
new file mode 100644
index 0000000..d69b18c
--- /dev/null
+++ b/arch/mips/include/asm/rmi/proc.h
@@ -0,0 +1,51 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PROC_H
+#define _ASM_RMI_PROC_H
+
+#include <linux/types.h>
+
+static __inline__ int proc_pos_check(off_t * begin, int *len, off_t off,
+				     int count)
+{
+	off_t pos = *begin + *len;
+
+	if (pos < off) {
+		*len = 0;
+		*begin = pos;
+	}
+	if (pos > off + count)
+		return 0;
+
+	return 1;
+}
+
+#endif
diff --git a/arch/mips/include/asm/rmi/rmi_pcix_gen_dev.h b/arch/mips/include/asm/rmi/rmi_pcix_gen_dev.h
new file mode 100644
index 0000000..af2ad0f
--- /dev/null
+++ b/arch/mips/include/asm/rmi/rmi_pcix_gen_dev.h
@@ -0,0 +1,124 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __PHNX_PCIX_DEVICE_H__
+#define __PHNX_PCIX_DEVICE_H__
+
+#include <asm/types.h>
+#include <linux/cache.h>
+
+#ifdef PHOENIX_LITTLE_ENDIAN
+#define PCIX_REG_BASE 64
+#else
+#define PCIX_REG_BASE (512 + 64)
+#endif
+
+/*Define this macro if device supports MAILBOX interrupt.*/
+//#define XLR_MAILBOX_IS_SUPPORTED 1
+
+/*Define this macro if host is MSI capable.*/
+//#define XLR_MSI_IS_SUPPORTED 1
+
+#define XLR_PCI_HOST_MODE 0x1
+#define XLR_PCI_DEV_MODE 0x2
+#define PCIX_INTRPT_CONTROL_REG ( PCIX_REG_BASE + 15)
+#define PCIX_PHOENIX_CONTROL_REG ( PCIX_REG_BASE + 14)
+#define PCIX_INTRPT_STATUS_REG ( PCIX_REG_BASE + 16)
+#define PCIX_HOST_MODE_CTRL_STATUS_REG ( PCIX_REG_BASE + 35)
+#define PCIX_DEVICE_MODE_ADDR_MAPPER ( PCIX_REG_BASE + 36)
+#define PCIX_DEVMODE_TBL_BAR0_REG                   (PCIX_REG_BASE + 44)
+#define PCIX_DEVMODE_TBL_BAR1_REG                   (PCIX_REG_BASE + 45)
+#define PCIX_DEVMODE_TBL_BAR2_REG                   (PCIX_REG_BASE + 46)
+#define PCIX_DEVMODE_TBL_BAR3_REG                   (PCIX_REG_BASE + 47)
+
+#define PHNX_MAX_IRQS_SUPPORTED 16
+
+#define phnx_host_to_pci(addr) ((uint64_t)(addr) | 0x8000000000UL)
+
+#define CACHELINE_ALIGNED_ADDR(addr) \
+			(((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
+
+
+int xlr_get_pci_mode(void);
+void phnx_interrupt_host(void);
+// DEVICE SIDE
+#ifdef XLR_MAILBOX_IS_SUPPORTED
+typedef int (*mailbox_handler)(void *, struct pt_regs *);
+int phnx_request_mailbox_handler(mailbox_handler, void *, int *);
+int phnx_disable_mailbox_intr(int *);
+int phnx_enable_mailbox_intr(int *);
+int phnx_free_mailbox_handler(int *);
+#endif
+
+
+/*****************************************************************************************************************/
+/**********************************SHARED    MEMORY***************************************************************/
+/*****************************************************************************************************************/
+// DURING BOOT ONLY
+
+#define PHNX_BOOT_SHARED_MEM_BASE 0x1000
+#define PHNX_BOOT_SHARED_MEM_SIZE (32 * 1024 * 1024)
+
+
+// AFTER BOOTIN WHOLE SHARED MEMORY IS CLAIMED BY THE GENERIC PCI DRIVER 
+#define PHNX_GENERIC_SHARED_MEM_BASE (20*1024*1024)
+#define PHNX_GENERIC_SHARED_MEM_SIZE (10*1024*1024)
+
+#define PHNX_PCIX_SHARED_MEM_START (0x8000000+PHNX_GENERIC_SHARED_MEM_BASE)
+#define PHNX_PCIX_SHARED_MEM_END (PHNX_PCIX_SHARED_MEM_START+PHNX_GENERIC_SHARED_MEM_SIZE)
+// All The Shared Address must be unique for each driver. Confliction of Address Space can cause unpredictable result. Shared Space Must be in sync with that of host driver.
+
+
+// SHARED SPACE BETWEEN MAC DRIVERS
+#define PHNX_MAC_SHARED_MEM_BASE PHNX_GENERIC_SHARED_MEM_BASE
+#define PHNX_MAC_SHARED_MEM_SIZE (1 * 1024 * 1024)
+
+
+// SHARED SPACE BETWEEN CONSOLE DRIVERS
+#define PHNX_CONSOLE_OVER_PCI_SHARED_MEM_BASE \
+	         (PHNX_MAC_SHARED_MEM_BASE + PHNX_MAC_SHARED_MEM_SIZE)
+#define PHNX_CONSOLE_OVER_PCI_SHARED_MEM_SIZE (9 * 1024)
+
+// SHARED space for DMA
+#define PHNX_DMA_MEM_BASE \
+			(PHNX_CONSOLE_OVER_PCI_SHARED_MEM_BASE + \
+	 		PHNX_CONSOLE_OVER_PCI_SHARED_MEM_SIZE)
+#define PHNX_DMA_MEM_SIZE 1024
+
+// SHARED SPACE BETWEEN IP OVER PCI DRIVER...
+#define PHNX_IP_OVER_PCI_MEM_BASE \
+			(PHNX_DMA_MEM_BASE + PHNX_DMA_MEM_SIZE)
+#define PHNX_IP_OVER_PCI_MEM_SIZE (8*512+8*512+1024) 
+
+// SHARED SPACE BETWEEN SECURITY DRIVER... xxxx
+//
+//
+
+#endif
diff --git a/arch/mips/include/asm/rmi/rmi_rw_lock.h b/arch/mips/include/asm/rmi/rmi_rw_lock.h
new file mode 100644
index 0000000..e83c18b
--- /dev/null
+++ b/arch/mips/include/asm/rmi/rmi_rw_lock.h
@@ -0,0 +1,221 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+#ifndef __RMI_RW_LOCK_H_
+#define __RMI_RW_LOCK_H_
+
+#define RMI_MAX_CPUS 32
+typedef struct {
+	volatile unsigned int lock;
+	unsigned int read_cpus[RMI_MAX_CPUS]; /* cpus that hold rd lock */
+	int write_cpu; /* CPU that is currently holding wr lock */
+} rmi_rwlock_t;
+
+#define rmi_sync() __asm__ __volatile__("sync": : :"memory")
+__asm__ (
+		".macro\trmi_local_irq_save result\n\t"
+		".set\tpush\n\t"
+		".set\treorder\n\t"
+		".set\tnoat\n\t"
+		"mfc0\t\\result, $12\n\t"
+		"ori\t$1, \\result, 1\n\t"
+		"xori\t$1, 1\n\t"
+		".set\tnoreorder\n\t"
+		"mtc0\t$1, $12\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		".set\tpop\n\t"
+		".endm");
+
+__asm__(".macro\trmi_local_irq_restore flags\n\t"
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		"mfc0\t$1, $12\n\t"
+		"andi\t\\flags, 1\n\t"
+		"ori\t$1, 1\n\t"
+		"xori\t$1, 1\n\t"
+		"or\t\\flags, $1\n\t"
+		"mtc0\t\\flags, $12\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		".set\tat\n\t"
+		".set\treorder\n\t"
+		".endm");
+
+
+#define rmi_local_irq_save(x)		\
+	__asm__ __volatile__(           \
+		"rmi_local_irq_save\t%0"                                    \
+		: "=r" (x)		\
+		: /* no inputs */	\
+		: "memory")
+
+
+#define rmi_local_irq_restore(flags)		\
+	do {                           		\
+		unsigned long __tmp1;  		\
+		__asm__ __volatile__(  		\
+		"rmi_local_irq_restore\t%0"        	\
+		: "=r" (__tmp1)                 \
+		: "0" (flags)                   \
+		: "memory");                    \
+	} while(0)
+
+
+#define rmi_processor_id() 				\
+	({ int __res;                                   \
+	 __asm__ __volatile__(                          \
+		 ".set\tmips32\n\t"                     \
+		 "mfc0\t%0, $15, 1\n\t"           	\
+		 "andi\t%0, 0x1f\n\t"			\
+		 ".set\tmips0\n\t"                      \
+		 : "=r" (__res));                       \
+	 __res;                                         \
+	 })
+
+
+static inline unsigned int rmi_read_lock_irq_save(rmi_rwlock_t *rw)
+{
+	unsigned int temp;
+	unsigned int cpu;
+	unsigned int flags;
+
+	rmi_local_irq_save(flags);
+	cpu = rmi_processor_id();
+
+		__asm__ __volatile__(
+		"	.set	noreorder	\n"
+		"1:	ll	%1, %2		\n"
+		"	bltz	%1, 2f		\n"
+		"	 addu	%1, 1		\n"
+		"	sc	%1, %0		\n"
+		"	beqz	%1, 1b		\n"
+		"	 nop			\n"
+		"	.subsection 2		\n"
+		"2:	ll	%1, %2		\n"
+		"	bltz	%1, 2b		\n"
+		"	 addu	%1, 1		\n"
+		"	b	1b		\n"
+		"	 nop			\n"
+		"	.previous		\n"
+		"	.set	reorder		\n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+
+		rw->read_cpus[cpu] = 1;
+		rmi_sync();
+
+		return flags;
+}
+
+static inline void rmi_read_unlock_irq_restore(rmi_rwlock_t *rw, 
+			unsigned int flags)
+{
+	unsigned int temp;
+	unsigned int cpu;
+
+	cpu = rmi_processor_id();
+
+	rmi_sync();
+	__asm__ __volatile__(
+		"       .set    noreorder       			\n"
+		"1:     ll      %1, %2                                  \n"
+		"       sub     %1, 1                                   \n"
+		"       sc      %1, %0                                  \n"
+		"       beqz    %1, 2f                                  \n"
+		"        nop                                            \n"
+		"       .subsection 2                                   \n"
+		"2:     b       1b                                      \n"
+		"        nop                                            \n"
+		"       .previous                                       \n"
+		"       .set    reorder                                 \n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+	rw->read_cpus[cpu] = 0;
+	rmi_local_irq_restore(flags);
+
+}
+
+static inline unsigned int rmi_write_lock_irq_save(rmi_rwlock_t *rw)
+{
+	unsigned int temp;
+	unsigned int cpu;
+	unsigned int flags;
+
+	rmi_local_irq_save(flags);
+	cpu = rmi_processor_id();
+
+	__asm__ __volatile__(
+		"       .set    noreorder       			\n"
+		"1:     ll      %1, %2                                  \n"
+		"       bnez    %1, 2f                                  \n"
+		"        lui    %1, 0x8000                              \n"
+		"       sc      %1, %0                                  \n"
+		"       beqz    %1, 2f                                  \n"
+		"        nop                                            \n"
+		"       .subsection 2                                   \n"
+		"2:     ll      %1, %2                                  \n"
+		"       bnez    %1, 2b                                  \n"
+		"        lui    %1, 0x8000                              \n"
+		"       b       1b                                      \n"
+		"        nop                                            \n"
+		"       .previous                                       \n"
+		"       .set    reorder                                 \n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+
+	rw->write_cpu = cpu;
+	rmi_sync();
+	
+	return flags;
+
+}
+
+
+static inline void rmi_write_unlock_irq_restore(rmi_rwlock_t *rw, 
+						unsigned int flags)
+{
+	rmi_sync();
+
+	__asm__ __volatile__(
+		"       sw      $0, %0                                  \n"
+		: "=m" (rw->lock)
+		: "m" (rw->lock)
+		: "memory");
+	rw->write_cpu = -1;
+	rmi_local_irq_restore(flags);
+}
+
+
+#endif
diff --git a/arch/mips/include/asm/rmi/sim.h b/arch/mips/include/asm/rmi/sim.h
new file mode 100644
index 0000000..8f8ed15
--- /dev/null
+++ b/arch/mips/include/asm/rmi/sim.h
@@ -0,0 +1,324 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_SIM_H
+#define _ASM_SIM_H
+
+#include <linux/types.h>
+#include <asm/cpu.h>
+#include <asm/mipsregs.h>
+
+#define PSB_INFO_VERSION 0x0001
+
+struct psb_info {
+	uint64_t boot_level;
+	uint64_t io_base;
+	uint64_t output_device;
+	uint64_t uart_print;
+	uint64_t led_output;
+	uint64_t init;
+	uint64_t exit;
+	uint64_t warm_reset;
+	uint64_t wakeup;
+	uint64_t thread_online_map;
+	uint64_t master_reentry_sp;
+	uint64_t master_reentry_gp;
+	uint64_t master_reentry_fn;
+	uint64_t slave_reentry_fn;
+	uint64_t magic_dword;
+	uint64_t uart_putchar;
+	uint64_t size;
+	uint64_t uart_getchar;
+	uint64_t nmi_handler;
+	uint64_t psb_version;
+	uint64_t mac_addr;
+	uint64_t cpu_frequency;
+	uint64_t board_version;
+	uint64_t malloc;
+	uint64_t free;
+	uint64_t global_shmem_addr;
+	uint64_t global_shmem_size;
+	uint64_t psb_os_cpu_map;
+	uint64_t userapp_cpu_map;
+	uint64_t wakeup_os;
+	uint64_t psb_mem_map;
+	uint64_t board_major_version;
+	uint64_t board_minor_version;
+	uint64_t board_manf_revision;
+	uint64_t board_serial_number;
+	uint64_t psb_physaddr_map;
+	uint64_t xlr_loaderip_config;
+	uint64_t bldr_envp;
+	uint64_t avail_mem_map;
+};
+
+
+enum {
+        PHOENIX_IO_SPACE = 0x10,
+        PCIX_IO_SPACE,
+        PCIX_CFG_SPACE,
+        PCIX_MEMORY_SPACE,
+        HT_IO_SPACE,
+        HT_CFG_SPACE,
+        HT_MEMORY_SPACE,
+        SRAM_SPACE,
+        FLASH_CONTROLLER_SPACE
+};
+
+extern struct psb_info *prom_info;
+
+#define MAX_ENV_BUF 0x00020000 // 128 KB = One sector of Intel flash.
+struct environment
+{
+        unsigned int crc;
+        unsigned char envbuf[MAX_ENV_BUF - 20]; // 4 bytes for CRC and 16 bytes reserved.
+        unsigned char reserved[16];
+};
+
+#define RMI_PHOENIX_BOARD_ARIZONA_I   1
+#define RMI_PHOENIX_BOARD_ARIZONA_II  2
+#define RMI_PHOENIX_BOARD_ARIZONA_III 3
+#define RMI_PHOENIX_BOARD_ARIZONA_IV  4
+#define RMI_PHOENIX_BOARD_ARIZONA_V   5
+#define RMI_PHOENIX_BOARD_ARIZONA_VI   6  /* XLS boards */
+#define RMI_PHOENIX_BOARD_ARIZONA_VII 7 /*XLS 2xx boards*/
+#define RMI_PHOENIX_BOARD_ARIZONA_VIII 8 /*XLS LTE boards*/
+#define RMI_PHOENIX_BOARD_ARIZONA_XI 11
+#define RMI_PHOENIX_BOARD_ARIZONA_XII  12
+
+struct smp_boot_info_percpu {
+  volatile unsigned long ready;
+  volatile unsigned long sp;
+  volatile unsigned long gp;
+  volatile unsigned long fn;
+};
+
+struct smp_boot_info {
+  struct smp_boot_info_percpu boot_info[32];
+  __u32 online_map;
+};
+
+extern struct smp_boot_info smp_boot;
+extern void prom_boot_cpus_secondary(void *);
+
+extern __u32 xlr_board_major_version;
+extern __u32 xlr_board_minor_version;
+
+#define XLR_REVISION_A0 0xc0000
+#define XLR_REVISION_A1 0xc0001
+#define XLR_REVISION_B0 0xc0002
+#define XLR_REVISION_B1 0xc0003
+#define XLR_REVISION_B2 0xc0004
+#define XLR_REVISION_C0 0xc0005
+#define XLR_REVISION_C1 0xc0006
+#define XLR_REVISION_C2 0xc0007
+#define XLR_REVISION_C3 0xc0008
+#define XLR_REVISION_C4 0xc0009
+
+static __inline__ unsigned int xlr_revision(void)
+{
+	return read_c0_prid() & 0xff00ff;
+}
+
+static __inline__ int xlr_revision_a0(void)
+{
+	return xlr_revision() == XLR_REVISION_A0;
+}
+
+static __inline__ int xlr_revision_b0(void)
+{
+	return xlr_revision() == XLR_REVISION_B0;
+}
+
+static __inline__ int xlr_revision_b1(void)
+{
+        return xlr_revision() == XLR_REVISION_B1;
+}
+
+static __inline__ int xlr_revision_c(void)
+{
+    uint32_t prid = read_c0_prid();
+    if(prid>=XLR_REVISION_C0 && prid<=XLR_REVISION_C4)
+        return 1;        
+    return 0; 
+}
+
+static __inline__ int xlr_board_atx_i(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_I;
+}
+
+static __inline__ int xlr_board_atx_ii(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_II;
+}
+
+static __inline__ int xlr_board_atx_ii_b(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_II)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_iii(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III;
+}
+
+static __inline__ int xlr_board_atx_iv(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_IV)
+		&& (xlr_board_minor_version == 0);
+}
+
+static __inline__ int xlr_board_atx_iv_b(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_IV)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_v(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_V;
+}
+
+static __inline__ int xlr_board_atx_iii_256(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III)
+		&& (xlr_board_minor_version == 0);
+}
+
+static __inline__ int xlr_board_atx_iii_512(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_v_512(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_V)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_vi(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_VI);
+}
+
+static __inline__ int xlr_board_atx_vii(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_VII);
+}
+
+static __inline__ int xlr_board_atx_viii(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_VIII);
+}
+
+static __inline__ int xlr_board_atx_xi(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_XI);
+}
+
+static __inline__ int xlr_board_atx_xii(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_XII);
+}
+
+static __inline__ int xlr_board_atx_xaui_rework(void)
+{
+	if ((xlr_board_atx_xi() || xlr_board_atx_xii()) &&
+			(xlr_board_minor_version == 4))
+		return 1;
+	else
+		return 0;
+}
+
+
+#define XLR_HYBRID_NONE              0
+#define XLR_HYBRID_USER_MAC          1
+#define XLR_HYBRID_RMIOS_IPSEC       2
+#define XLR_HYBRID_RMIOS_TCPIP_STACK 3
+#define XLR_HYBRID_USER_MAC_GMAC     4
+#define XLR_HYBRID_USER_MAC_XGMAC    5
+#define XLR_HYBRID_USER_MAC_SPI4     6
+#define XLR_HYBRID_USER_MAC_GMAC_XGMAC    7
+#define XLR_HYBRID_USER_MAC_GMAC_SPI4     8
+
+extern int xlr_hybrid;
+
+static __inline__ int xlr_hybrid_user_mac(void)
+{
+	return xlr_hybrid == XLR_HYBRID_USER_MAC;
+}
+
+static __inline__ int xlr_hybrid_user_mac_xgmac(void)
+{
+	return (xlr_hybrid == XLR_HYBRID_USER_MAC_XGMAC || 
+		xlr_hybrid == XLR_HYBRID_USER_MAC_SPI4);
+}
+
+static __inline__ int xlr_hybrid_rmios_tcpip_stack(void)
+{
+        return xlr_hybrid == XLR_HYBRID_RMIOS_TCPIP_STACK;
+}
+
+static __inline__ int xlr_hybrid_rmios_ipsec(void)
+{
+	return xlr_hybrid == XLR_HYBRID_RMIOS_IPSEC;
+}
+
+static __inline__ int xlr_hybrid_none(void)
+{
+	return xlr_hybrid == XLR_HYBRID_NONE;
+}
+
+struct boot_mem_map_entry *psb_get_physaddr_base_address(unsigned long type);
+
+
+#define CHIP_PROCESSOR_ID_XLR_B_308   0x06
+#define CHIP_PROCESSOR_ID_XLR_B_508   0x07
+#define CHIP_PROCESSOR_ID_XLR_B_516   0x08
+#define CHIP_PROCESSOR_ID_XLR_B_532   0x09
+#define CHIP_PROCESSOR_ID_XLR_B_716   0x0a
+#define CHIP_PROCESSOR_ID_XLR_B_732   0x0b
+
+#define CHIP_PROCESSOR_ID_XLR_C_308   0x0F
+#define CHIP_PROCESSOR_ID_XLR_C_508   0x0b
+#define CHIP_PROCESSOR_ID_XLR_C_516   0x0a
+#define CHIP_PROCESSOR_ID_XLR_C_532   0x08
+#define CHIP_PROCESSOR_ID_XLR_C_716   0x02
+#define CHIP_PROCESSOR_ID_XLR_C_732   0x00
+
+#define NR_CORES 8
+#define NR_CPUS_PER_CORE 4
+#define RMI_MAX_ARGS 64
+#define RMI_MAX_ENVS 32
+
+#endif /* _ASM_SIM_H */
diff --git a/arch/mips/include/asm/rmi/utils.h b/arch/mips/include/asm/rmi/utils.h
new file mode 100644
index 0000000..82e9639
--- /dev/null
+++ b/arch/mips/include/asm/rmi/utils.h
@@ -0,0 +1,88 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifdef CONFIG_64BIT
+#define LLX_FMT "lx"
+#define LLD_FMT "ld"
+#define LLU_FMT "lu"
+#else
+#define LLX_FMT "llx"
+#define LLD_FMT "lld"
+#define LLU_FMT "llu"
+#endif
+
+#define find_32bit_1st_one_bit(source)    \
+({ unsigned int __res;                    \
+    __asm__ __volatile__(                 \
+	".set\tpush\n\t"                  \
+	".set\tnoreorder\n\t"             \
+        ".set\tmips32\n\t"                \
+	"move\t$8,%1\n\t"                 \
+	"clz\t%0,$8\n\t"                  \
+	".set\tpop"                       \
+	: "=r"(__res): "r"(source): "$8");   \
+    __res;})
+
+#define find_32bit_1st_zero_bit(source)   \
+({ unsigned int __res;                    \
+    __asm__ __volatile__(                 \
+	".set\tpush\n\t"                  \
+	".set\tnoreorder\n\t"             \
+        ".set\tmips32\n\t"                \
+	"move\t$8,%1\n\t"                 \
+	"clo\t%0,$8\n\t"                  \
+	".set\tpop"                       \
+	: "=r"(__res): "r"(source): "$8" );      \
+    __res;})
+
+#define find_64bit_1st_one_bit(source)    \
+({ unsigned int __res;                    \
+    __asm__ __volatile__(                 \
+	".set\tpush\n\t"                  \
+	".set\tnoreorder\n\t"             \
+        ".set\tmips32\n\t"                \
+	"move\t$8,%1\n\t"                 \
+	"dclz\t%0,$8\n\t"                 \
+	".set\tpop"                       \
+	: "=r"(__res): "r"(source): "$8" );      \
+    __res;})
+
+#define find_64bit_1st_zero_bit(source)    \
+({ unsigned int __res;                    \
+    __asm__ __volatile__(                 \
+	".set\tpush\n\t"                  \
+	".set\tnoreorder\n\t"             \
+        ".set\tmips32\n\t"                \
+	"move\t$8,%1\n\t"                 \
+	"dclo\t%0,$8\n\t"                 \
+	".set\tpop"                       \
+	: "=r"(__res): "r"(source): "$8" );      \
+    __res;})
+
diff --git a/include/linux/libata.h b/include/linux/libata.h
index 79878c2..39cd46c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -54,7 +54,7 @@
  */
 #undef ATA_DEBUG		/* debugging output */
 #undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
-#undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
+#define ATA_IRQ_TRAP		/* define to ack screaming irqs */
 #undef ATA_NDEBUG		/* define to disable quick runtime checks */
 
 
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 057929b..e0ce81b 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -603,7 +603,18 @@ asmlinkage long sys_mkdir(const char __user *pathname, int mode);
 asmlinkage long sys_chdir(const char __user *filename);
 asmlinkage long sys_fchdir(unsigned int fd);
 asmlinkage long sys_rmdir(const char __user *pathname);
+#if defined (CONFIG_64BIT) && defined (CONFIG_RMI_PHOENIX)
+#if defined (CONFIG_MIPS32_O32) || defined (CONFIG_MIPS32_N32)
+long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
+#include <asm/compat.h>
+asmlinkage long compat_sys_lookup_dcookie(u32 cookie_msb, u32 cookie_lsb,
+                                      compat_uptr_t buf, compat_size_t len);
+#else
 asmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
+#endif
+#else
+asmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
+#endif
 asmlinkage long sys_quotactl(unsigned int cmd, const char __user *special,
 				qid_t id, void __user *addr);
 asmlinkage long sys_getdents(unsigned int fd,
-- 
1.7.0.4

