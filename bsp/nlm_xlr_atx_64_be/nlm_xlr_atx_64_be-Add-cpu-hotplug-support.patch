From daeba3a6553b5f7d9cbe324474676dea19112986 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 3 Mar 2011 18:52:37 +0800
Subject: [PATCH 47/47] nlm_xlr_atx_64_be: Add cpu hotplug support

This brings us the cpu hotplug support.

It mainly implements or enhances the necessary interfaces proposed in
Documentation/cpu-hotplug.txt, such interfaces include:

cpu offline:

  o cpu_disable

    Called by _cpu_down() to clear cpu_online_map & cpu_callin_map,
    disable all interrupts, and flush cache & tlb.

  o cpu_die

    Called by _cpu_down() to Wait for cpu die(ready to be 0)

  o play_dead

    Called by cpu_idle() to make cpu die(set ready to 0): Enter into
    a loop till it is waked up by user-space /sys interface
    (till ready is set to 1).

cpu online:

  o boot_secondary

    Called by __cpu_up to re-activate the cpu and make it exit from the
    loop of play_dead() and re-init the cpu via calling the following
    functions orderly: ptr_smp_boot -> smp_bootstrap -> start_secondary
    -> init_secondary -> smp_finish. The interrupts will be re-enabled
    in init_secondary and smp_finish.

The top-level functions for offline and online is cpu_down() and
cpu_up() respectively, they are called in drivers/base/cpu.c when 0 or 1
is written to the /sys interface: /sys/devices/system/cpu/cpuX/online

Signed-off-by: Ralf Baechle <ralf.baechle@windriver.com>
Signed-off-by: Shan Hai <shan.hai@windriver.com>
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/Kconfig               |    1 +
 arch/mips/rmi/phoenix/irq.c     |   58 +++++++++++++++++++++
 arch/mips/rmi/phoenix/on_chip.c |    5 ++
 arch/mips/rmi/ptr/smp.c         |  105 +++++++++++++++++++++++++++++++++++++++
 4 files changed, 169 insertions(+), 0 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 7098939..f5ac8be 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -698,6 +698,7 @@ config RMI_PTR
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_HIGHMEM
 	select SYS_SUPPORTS_ZBOOT
+	select SYS_SUPPORTS_HOTPLUG_CPU
 	select DMA_COHERENT
 	select CEVT_R4K
 	select CSRC_R4K
diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
index 0672e64..de4be2f 100644
--- a/arch/mips/rmi/phoenix/irq.c
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -507,3 +507,61 @@ void pic_init(void)
 							      i));
 	}
 }
+
+#ifdef CONFIG_HOTPLUG_CPU
+
+extern uint32_t phoenix_smp_logical_to_hw_mask(const cpumask_t *mask);
+extern void on_chip_turnon_msgring(void);
+extern void on_chip_shutoff_msgring(void);
+
+void fixup_irqs(unsigned int cpu, int flag)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned int irq;
+	cpumask_t mask0 = cpumask_of_cpu(0);
+	cpumask_t mycpu = cpumask_of_cpu(cpu);
+	uint32_t hw0_mask, my_mask, hw_mask;
+	unsigned long flags;
+
+	hw0_mask = phoenix_smp_logical_to_hw_mask(&mask0);
+	my_mask = phoenix_smp_logical_to_hw_mask(&mycpu);
+	pr_debug("%s: cpu = %d, hw0_mask = 0x%x, my_mask = 0x%x\n",
+		__func__, cpu, hw0_mask,  my_mask);
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	/* PIC interrupts */
+	for (irq = 0; irq < 63; irq++) {
+		if (!PIC_IRQ_IS_IRT(irq))
+			continue;
+
+		hw_mask = phoenix_read_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE);
+		pr_debug("%s: read: irq = %d, hw_mask = 0x%x\n", __func__, irq, hw_mask);
+		if (!hw_mask)
+			continue;
+
+		if (flag)
+			hw_mask |= my_mask;
+		else
+			hw_mask &= ~my_mask;
+		if (!hw_mask)
+			hw_mask |= hw0_mask;
+		pr_info("%s: write: irq = %d, hw_mask = 0x%x\n", __func__, irq, hw_mask);
+		phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE, hw_mask);
+	}
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+
+	/* Non-PIC interrupts */
+	if (flag) {
+		pr_debug("%s: turn on msgring\n", __func__);
+		on_chip_turnon_msgring();
+	} else {
+		pr_debug("%s: turn off msgring\n", __func__);
+		on_chip_shutoff_msgring();
+		/* clear all pending interrupts */
+		write_64bit_cp0_eirr(0xffffffffffffffff);
+		/* Mask out all interrupts */
+		write_64bit_cp0_eimr(0);
+	}
+}
+#endif
diff --git a/arch/mips/rmi/phoenix/on_chip.c b/arch/mips/rmi/phoenix/on_chip.c
index de5388b..6e24d6d 100644
--- a/arch/mips/rmi/phoenix/on_chip.c
+++ b/arch/mips/rmi/phoenix/on_chip.c
@@ -655,6 +655,11 @@ void on_chip_shutoff_msgring(void)
 
 extern void pic_init(void);
 
+void on_chip_turnon_msgring(void)
+{
+	enable_msgring_int(NULL);
+}
+
 void on_chip_init(void)
 {
 	cpu_logical_map(0) = hard_smp_processor_id();
diff --git a/arch/mips/rmi/ptr/smp.c b/arch/mips/rmi/ptr/smp.c
index 7f37f37..8de31e1 100644
--- a/arch/mips/rmi/ptr/smp.c
+++ b/arch/mips/rmi/ptr/smp.c
@@ -31,6 +31,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/smp.h>
+#include <linux/cpu.h>
 
 #include <asm/asm.h>
 #include <asm/mmu_context.h>
@@ -86,9 +87,55 @@ static void __cpuinit rmi_init_secondary(void)
 	/* Time init for this cpu is done in mips_clockevent_init() */
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+extern void fixup_irqs(unsigned int cpu, int flag);
+static DEFINE_SPINLOCK(smp_reserve_lock);
+static atomic_t __cpuinitdata cpu_hotplug_flag = ATOMIC_INIT(0);
+
+static int __cpuinit rmi_cpu_callback(struct notifier_block *nfb,
+	unsigned long action, void *hcpu)
+{
+	unsigned int cpu = (unsigned long)hcpu;
+
+	switch (action) {
+	case CPU_ONLINE:
+		pr_info("Cpu %d online\n", cpu);
+		break;
+	case CPU_DEAD:
+		pr_info("Cpu %d offline\n", cpu);
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block __cpuinitdata rmi_cpu_notifier = {
+	.notifier_call = rmi_cpu_callback,
+};
+
+static int __cpuinit register_rmi_notifier(void)
+{
+	register_hotcpu_notifier(&rmi_cpu_notifier);
+
+	return 0;
+}
+
+late_initcall(register_rmi_notifier);
+
+#endif	/* CONFIG_HOTPLUG_CPU */
+
 void rmi_smp_finish(void)
 {
 	phoenix_msgring_cpu_init();
+
+#ifdef CONFIG_HOTPLUG_CPU
+	if (atomic_read(&cpu_hotplug_flag)) {
+		spin_lock_irq(&smp_reserve_lock);
+		/* Enable IRQs on the cpu */
+		fixup_irqs(smp_processor_id(), 1);
+		spin_unlock_irq(&smp_reserve_lock);
+	}
+#endif
 }
 
 void rmi_cpus_done(void)
@@ -193,6 +240,60 @@ void rmi_prepare_cpus(unsigned int max_cpus)
 {
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+
+static int rmi_cpu_disable(void)
+{
+	unsigned int cpu = smp_processor_id();
+
+	atomic_set(&cpu_hotplug_flag, 1);
+
+	if (cpu == 0)
+		return -EBUSY;
+
+	spin_lock(&smp_reserve_lock);
+
+	cpu_clear(cpu, cpu_online_map);
+	cpu_clear(cpu, cpu_callin_map);
+
+	local_irq_disable();
+	fixup_irqs(cpu, 0);
+	local_irq_enable();
+
+	flush_cache_all();
+	local_flush_tlb_all();
+
+	spin_unlock(&smp_reserve_lock);
+
+	return 0;
+}
+
+static void rmi_cpu_die(unsigned int logical_cpu)
+{
+	int cpu = cpu_logical_map(logical_cpu);
+
+	while (smp_boot.boot_info[cpu].ready)
+		cpu_relax();
+}
+
+void play_dead(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct smp_boot_info_percpu *bic;
+
+	bic = smp_boot.boot_info + cpu;
+	idle_task_exit();
+	bic->ready = 0;
+
+	local_irq_disable();
+	while (!bic->ready)
+		cpu_relax();
+
+	ptr_smp_boot(bic->fn, bic->sp, bic->gp);
+}
+#endif /* CONFIG_HOTPLUG_CPU */
+
+
 struct plat_smp_ops rmi_smp_ops = {
 	.send_ipi_single = rmi_send_ipi_single,
 	.send_ipi_mask = rmi_send_ipi_mask,
@@ -202,6 +303,10 @@ struct plat_smp_ops rmi_smp_ops = {
 	.boot_secondary = rmi_boot_secondary,
 	.smp_setup = rmi_smp_setup,
 	.prepare_cpus = rmi_prepare_cpus,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_disable = rmi_cpu_disable,
+	.cpu_die = rmi_cpu_die,
+#endif
 };
 
 void prom_boot_cpus_secondary(void *args)
-- 
1.7.0.4

