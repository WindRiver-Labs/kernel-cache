From 5f2ce9b92d6293173135d7d107980bf2d6c67d0c Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 May 2010 23:57:28 +0800
Subject: [PATCH 08/47] nlm_xlr_atx_64_be: add cache error handler

Extracted from RMI SDK 1.7.0.

On XLR, cache error is not only caused by cache ecc/parity checking but
also come from bridge's error reporting. Something like misconfigured
BARS or accessing to a physical address region that is not mapped to any
device in the bridge are all reported as cache errors by bridge.

It need to check if it is really a cache error or a "bus error" and take
action appropriately. For now, treat it as a cache error

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/mm/Makefile       |    2 +
 arch/mips/mm/cerr-phoenix.c |  172 +++++++++++++++++++++++++++++++++++++++++++
 arch/mips/mm/cex-phoenix.S  |   60 +++++++++++++++
 3 files changed, 234 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/mm/cerr-phoenix.c
 create mode 100644 arch/mips/mm/cex-phoenix.S

diff --git a/arch/mips/mm/Makefile b/arch/mips/mm/Makefile
index f0e4355..ff4156e 100644
--- a/arch/mips/mm/Makefile
+++ b/arch/mips/mm/Makefile
@@ -29,6 +29,8 @@ obj-$(CONFIG_CPU_TX39XX)	+= c-tx39.o tlb-r3k.o
 obj-$(CONFIG_CPU_TX49XX)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_VR41XX)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= c-octeon.o cex-oct.o tlb-r4k.o
+obj-$(CONFIG_CPU_PHOENIX)	+= c-phoenix.o tlb-r4k.o \
+				cex-phoenix.o cerr-phoenix.o
 
 obj-$(CONFIG_IP22_CPU_SCACHE)	+= sc-ip22.o
 obj-$(CONFIG_R5000_CPU_SCACHE)  += sc-r5k.o
diff --git a/arch/mips/mm/cerr-phoenix.c b/arch/mips/mm/cerr-phoenix.c
new file mode 100644
index 0000000..1290aac
--- /dev/null
+++ b/arch/mips/mm/cerr-phoenix.c
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/smp.h>
+#include <asm/system.h>
+
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/mips-exts.h>
+
+unsigned char phoenix_cerr_stack[8192];
+volatile int phoenix_cerr_lock;
+
+static inline void cerr_cpu_halt(void)
+{
+	for (;;) {
+		__asm__ __volatile__(
+			".set mips64\n"
+			"1: wait\n"
+			"   b 1b\n"
+			"   nop\n"
+		);
+	}
+}
+
+#define UART_RHR 0
+#define UART_THR 0
+#define UART_IER 1
+#define UART_IIR 2
+#define UART_FCR 2
+#define UART_LCR 3
+#define UART_MCR 4
+#define UART_LSR 5
+#define UART_MSR 6
+
+static void cerr_outbyte(char ch)
+{
+	volatile uint32_t *mmio = phoenix_io_mmio(PHOENIX_IO_UART_0_OFFSET);
+	int lsr;
+	for (;;) {
+
+		lsr = be32_to_cpu(mmio[UART_LSR]);
+
+		/* Tx Fifo empty */
+		if (lsr & 0x20) {
+			mmio[UART_THR] = cpu_to_be32((int)ch);
+			break;
+		}
+	}
+}
+
+static char cerr_printk_buf[2048];
+static void cerr_printk(const char *fmt, ...)
+{
+	va_list args;
+	int len;
+	int i = 0;
+
+	va_start(args, fmt);
+	len = vsnprintf(cerr_printk_buf, sizeof(cerr_printk_buf), fmt, args);
+	va_end(args);
+
+	for (i = 0; i <= len; i++) {
+
+		if (cerr_printk_buf[i] == 0)
+			continue;
+
+		if (cerr_printk_buf[i] == '\n')
+			cerr_outbyte('\r');
+
+		cerr_outbyte(cerr_printk_buf[i]);
+	}
+
+}
+
+static char *bridge_aerr_intr_devstat[] = {
+	[0] = "cpu 0",
+	[1] = "cpu 1",
+	[2] = "cpu 2",
+	[3] = "cpu 3",
+	[4] = "cpu 4",
+	[5] = "cpu 5",
+	[6] = "cpu 6",
+	[7] = "cpu 7",
+
+	[8] = "L2",
+	[9] = "XGS 0",
+	[10] = "XGS 1",
+	[11] = "GMAC",
+	[12] = "SEC",
+	[13] = "PCIX",
+	[14] = "HT",
+	[15] = "DMA",
+};
+
+static void print_cerr_info(void)
+{
+	__u64 cerr_cpu_log = 0;
+	int i = 0;
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_BRIDGE_OFFSET);
+	__u32 tmp = 0;
+
+	cerr_printk("Bridge: Phys Addr = 0x%010llx, Device_AERR = 0x%08x\n",
+		(((__u64)phoenix_read_reg(mmio, 39)<<5) | ((__u64)phoenix_read_reg(mmio, 40)<<37)),
+		phoenix_read_reg(mmio, 41));
+
+	cerr_printk("Bridge: The devices reporting AERR are:\n");
+	tmp = phoenix_read_reg(mmio, 41);
+	for (i = 0; i < 16; i++)
+		if (tmp & (1<<i))
+			cerr_printk("\t%s\n", bridge_aerr_intr_devstat[i]);
+
+	cerr_cpu_log =
+		read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
+	cerr_printk("CPU: (XLR specific) Cache Error log = 0x%016llx, Phy Addr = 0x%010llx\n",
+		cerr_cpu_log, ((cerr_cpu_log >> 10) & 0xffffffffffULL) << 3);
+}
+
+/*
+ * On XLR/XLP, errors reported by bridge (like misconfigured BARS etc)
+ * are also reported as cache errors. Need to check if it is really a
+ * cache error or a "bus error" and take action appropriately.
+ *
+ * For now, treat it as a cache error
+ */
+
+asmlinkage void phoenix_cache_error(void)
+{
+	local_irq_disable();
+
+	/* let the first cpu in */
+	while (phoenix_cerr_lock)
+		;
+	phoenix_cerr_lock = 1;
+
+	cerr_printk("*********************************************\n");
+	cerr_printk("cpu_%d received a bus/cache error\n", hard_smp_processor_id());
+	cerr_printk("*********************************************\n");
+
+	print_cerr_info();
+
+	cerr_printk("CPU: epc = 0x%lx, errorepc = 0x%lx, cacheerr = 0x%08x\n",
+			read_c0_epc(), read_c0_errorepc(), read_c0_cacheerr());
+
+	cerr_printk("Can not handle bus/cache error - Halting cpu\n");
+
+	cerr_cpu_halt();
+}
diff --git a/arch/mips/mm/cex-phoenix.S b/arch/mips/mm/cex-phoenix.S
new file mode 100644
index 0000000..715c41b
--- /dev/null
+++ b/arch/mips/mm/cex-phoenix.S
@@ -0,0 +1,60 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995 - 1999 Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ *
+ * Cache error handler
+ */
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/stackframe.h>
+
+/*
+ * Game over.  Go to the button.  Press gently.  Swear where allowed by
+ * legislation.
+ */
+	LEAF(except_vec2_generic)
+	.set	noreorder
+	.set	noat
+	.set    mips0
+	/*
+	 * This is a very bad place to be.  Our cache error
+	 * detection has triggered.  If we have write-back data
+	 * in the cache, we may not be able to recover.  As a
+	 * first-order desperate measure, turn off KSEG0 cacheing.
+	 */
+	mfc0	k0,CP0_CONFIG
+	li	k1,~CONF_CM_CMASK
+	and	k0,k0,k1
+	ori	k0,k0,CONF_CM_UNCACHED
+	mtc0	k0,CP0_CONFIG
+	/* Give it a few cycles to sink in... */
+	nop
+	nop
+	nop
+
+	/* If some other cpu is already in the handler just wait... */
+	PTR_LA	k0, phoenix_cerr_lock
+1:	lw	k1, 0(k0)
+	bnez	k1, 1b
+	nop
+
+	/* Switch stack to a new one */
+	PTR_LA	sp, phoenix_cerr_stack
+	li	k1, 8192 - 64
+	PTR_ADDU	sp, sp, k1
+
+	/* Set up first argument - pt_regs */
+	move	a0, sp
+	/* Read the cache error log reg in the cpu */
+	li	k1, 0x309
+	mfcr	k0, k1
+	move	a1, k0
+
+	j	phoenix_cache_error
+	 nop
+	END(except_vec2_generic)
-- 
1.7.0.4

