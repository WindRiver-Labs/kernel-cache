From 703b28e923f14f17fa6347807ced6b4a8f63563e Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Mon, 10 Jan 2011 11:23:43 +0800
Subject: [PATCH 43/47] nlm_xlr_atx_64_be: Read detailed memory information from bootloader

Extracted from RMI SDK 1.7.0.

The detailed memory information has been passed from bootloader, the
kernel must read it, parse it for futher memory handling.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/rmi/ptr/setup.c |  265 ++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 262 insertions(+), 3 deletions(-)

diff --git a/arch/mips/rmi/ptr/setup.c b/arch/mips/rmi/ptr/setup.c
index 03c941e..6169a4f 100644
--- a/arch/mips/rmi/ptr/setup.c
+++ b/arch/mips/rmi/ptr/setup.c
@@ -74,6 +74,9 @@ extern void config_net_init(void);
 extern struct xlr_user_mac_config xlr_user_mac;
 __u8 phoenix_base_mac_addr[6];
 
+/*Environment Vairables*/
+struct environment xlr_bldr_env;
+
 __u32 xlr_board_major_version = RMI_PHOENIX_BOARD_ARIZONA_I;
 __u32 xlr_board_minor_version;
 
@@ -115,6 +118,25 @@ static struct physmap_info {
 
 struct boot_mem_map boot_physaddr_info;
 
+#define MAX_EXCLUDE 16
+struct boot_mem_map_exclude_region {
+	uint64_t start;
+	uint64_t end;
+};
+
+/* The below regions should be in ascending order of the starting physical addresses */
+static struct boot_mem_map_exclude_region dynamic_exclude_regions[] = {
+	[0] = {0, 0},	/* PCI Shared Mem Or RMIOS Lib Memory */
+	[1] = {0, 0},	/* PCI Shared Mem Or RMIOS Lib Memory */
+	[2] = {0, 0},	/* Loader KSEG0 region */
+	[3] = {0, 0},	/* Loader KUSEG region Block 1 */
+	[4] = {0, 0},	/* Loader KUSEG region Block 2 or Hybrid Mode exclusion */
+	[5] = {0, 0},	/* Loader KUSEG region Block 3 or Hybrid Mode exclusion */
+	[6] = {0, 0},	/* Loader KUSEG region Block 4 or Hybrid Mode exclusion */
+	[7] = {0, 0},	/* Hybrid Mode exclusion */
+	[8] = {0, 0},	/* END of the list - MUST be the last entry always */
+};
+
 static char *get_psb_physmap_name(int type)
 {
 	int i = 0;
@@ -271,7 +293,6 @@ void prom_parse_args(int argc, char *argv[])
 	int i, j;
 	int ret;
 
-	/* Check if loader support needs to be enabled */
 	for (i = 1; i < argc; i++) {
 		if (argv && argv[i]) {
 			if (strcmp(argv[i], "root=/dev/nfs") == 0) {
@@ -295,6 +316,67 @@ void prom_parse_args(int argc, char *argv[])
 	}
 }
 
+/* The below regions should be in ascending order of the starting physical addresses */
+
+static struct boot_mem_map_exclude_region _exclude_regions[2][MAX_EXCLUDE + 2];
+
+static struct boot_mem_map_exclude_region *exclude_regions = _exclude_regions[1];
+
+static struct boot_mem_map_exclude_region static_exclude_regions[] = {
+	[0] = {0, 0},	/* END of the list - MUST be the last entry always */
+};
+
+
+void sort_dynamic_exclude_region(void)
+{
+	int i = 0;
+	int j = 0;
+	int max = 0;
+	struct boot_mem_map_exclude_region *list = dynamic_exclude_regions;
+
+	uint64_t start = 0;
+	uint64_t end = 0;
+
+	while (list[max].start != 0)
+		max++;
+
+	for (i = 0; i < max; i++) {
+		for (j = i; j < max; j++) {
+			if (list[i].start > list[j].start) {
+				start = list[i].start;
+				end = list[i].end;
+				list[i].start = list[j].start;
+				list[i].end = list[j].end;
+				list[j].start = start;
+				list[j].end = end;
+			}
+		}
+	}
+}
+
+static int merge_exclude_regions(struct boot_mem_map_exclude_region *,
+				 struct boot_mem_map_exclude_region *);
+
+void prom_update_exclude_region(void)
+{
+	int i;
+
+	sort_dynamic_exclude_region();
+
+	exclude_regions = _exclude_regions[0];
+
+	merge_exclude_regions(exclude_regions, static_exclude_regions);
+	merge_exclude_regions(exclude_regions, dynamic_exclude_regions);
+
+	pr_info("Final exclude regions ----->\n");
+	for (i = 0; exclude_regions[i].start; i++) {
+		pr_info("%d: Start 0x%llx End 0x%llx\n", i,
+			exclude_regions[i].start, exclude_regions[i].end);
+	}
+}
+
+struct boot_mem_map prom_map;
+
 #ifdef CONFIG_KEXEC
 /* In the case of kexec, these are needed to be passed to the next kernel.
  * The bootloader's memory gets overwritten, so we have to keep another copy
@@ -307,17 +389,129 @@ struct boot_mem_map psb_mem_map_copy;
 struct boot_mem_map avail_mem_map_copy;
 struct boot_mem_map *avail_mem_map_copy_ptr = NULL;
 #endif
+int use_default_phymem;	/* by default, it is 0 */
+
+void read_prom_memory(void)
+{
+	struct boot_mem_map *map;
+
+	/* sanity check prom_info and it's mem_map fields */
+	if (!prom_info
+	    || (!prom_info->psb_mem_map && !prom_info->avail_mem_map))
+		goto use_default;
+
+	/* copy the mem_map from bootloader */
+	if (sizeof(*prom_info) <= prom_info->size
+	    && prom_info->avail_mem_map)
+		map =
+		    (struct boot_mem_map *) ((unsigned long) prom_info->
+					     avail_mem_map);
+	else
+		map =
+		    (struct boot_mem_map *) ((unsigned long) prom_info->
+					     psb_mem_map);
+
+	if (!(map->nr_map > 0 && map->nr_map <= 32))
+		goto use_default;
+	memcpy(&prom_map, map, sizeof(struct boot_mem_map));
+
+#ifdef CONFIG_KEXEC
+	/* keep what's needed for a possible kexec call */
+	memcpy(&psb_mem_map_copy, (void *)prom_info->psb_mem_map, sizeof(struct boot_mem_map));
+	if (prom_info->avail_mem_map) {
+		memcpy(&avail_mem_map_copy, map, sizeof(struct boot_mem_map));
+		avail_mem_map_copy_ptr = &avail_mem_map_copy;
+	}
+#endif
+
+	return;
+
+use_default:
+	use_default_phymem = 1;
+	return;
+}
 
 #define DEF_PHYMEM_START_ADDR 0x100000
 #define DEF_PHYMEM_SIZE 0x0ff00000
 
 static void prom_add_memory(void)
 {
+	int i = 0, j = 0;
+	__u64 start = 0, end = 0, exc_start = 0, exc_end = 0;
 	__u64 pref_backup = 512;
 
-	pr_info("Using default physical memory map: 255m@1m\n");
+	if (use_default_phymem)
+		goto use_default;
+
+	prom_update_exclude_region();
+
+	/*
+	 * TODO: Need to remove this brain damaged hack. The bootloader passed
+	 * memory map should indicate the bootloader memory as available.
+	 */
+	if (prom_map.map[0].size == 0x0c000000)
+		prom_map.map[0].size = 0x0ff00000;
+
+	for (i = 0; i < prom_map.nr_map; i++) {
+		start = prom_map.map[i].addr;
+		end = prom_map.map[i].addr + prom_map.map[i].size;
+
+		for (j = 0; j < MAX_EXCLUDE; j++) {
+			exc_start = exclude_regions[j].start;
+			exc_end = exclude_regions[j].end;
 
-	add_memory_region(DEF_PHYMEM_START_ADDR, DEF_PHYMEM_SIZE - pref_backup, (long) BOOT_MEM_RAM);
+			if ((exc_start == 0) && (exc_end == 0))	/* Empty slot */
+				continue;
+
+			if (exc_start >= start && exc_start < end) {
+				if (exc_start == start) {
+					/* Continuous exclude */
+					start = exc_end;
+					continue;
+				}
+				if (prom_map.map[i].type == BOOT_MEM_RAM) {
+					/*
+					 * memcpy/__copy_user prefetch, which
+					 * will cause a bus error for
+					 * KSEG/KUSEG addrs not backed by RAM.
+					 * Hence, reserve some padding for the
+					 * prefetch distance.
+					 */
+					if (exc_start - start >
+					    pref_backup) {
+						add_memory_region(start,
+								  exc_start
+								  - start -
+								  pref_backup,
+								  (long)
+								  prom_map.
+								  map[i].
+								  type);
+					}
+					start = exc_end;
+				}
+			} else if ((exc_start < start)
+				   && (exc_end > start)) {
+				/* Overlapping excludes */
+				start = exc_end;
+			}
+		}
+		if (start != end)
+			if (prom_map.map[i].type == BOOT_MEM_RAM) {
+				if (end - start > pref_backup)
+					add_memory_region(start,
+							  end - start -
+							  pref_backup,
+							  (long) prom_map.
+							  map[i].type);
+			}
+	}
+
+	return;
+
+use_default:
+	pr_info("Using default physical memory map\n");
+	add_memory_region(DEF_PHYMEM_START_ADDR, DEF_PHYMEM_SIZE - pref_backup, (long) BOOT_MEM_RAM);	/* 255m@1m */
 }
 
 static void psb_print_physmap(void)
@@ -473,11 +667,18 @@ void __init prom_init(void)
 		goto parse_args;
 	}
 
+	/*Copy Environment variable */
+	if (prom_info->bldr_envp)
+		memcpy(&xlr_bldr_env,
+		       (void *) (unsigned long) prom_info->bldr_envp,
+		       sizeof(xlr_bldr_env));
+
 	xlr_board_major_version = prom_info->board_major_version;
 	xlr_board_minor_version = prom_info->board_minor_version;
 	pr_info("board version: major = %d, minor = %d\n", xlr_board_major_version, xlr_board_minor_version);
 
 	prom_parse_args(argc, n_argv);
+	read_prom_memory();
 
 	psb_print_physmap();
 
@@ -562,6 +763,64 @@ void prom_free_prom_memory(void)
 	/* nothing to free */
 }
 
+void static add_region(struct boot_mem_map_exclude_region *x, int *k,
+		       uint64_t start, uint64_t end)
+{
+	if (*k > MAX_EXCLUDE) {
+		pr_info("No of exclude regions = %d; Cannot add more\n",
+		       MAX_EXCLUDE);
+		return;
+	}
+
+	if (start < x[*k - 1].end)
+		return;
+
+	x[*k].start = start;
+	x[*k].end = end;
+	++*k;
+}
+
+static int merge_exclude_regions(struct boot_mem_map_exclude_region *x,
+				 struct boot_mem_map_exclude_region *y)
+{
+	static int _index;
+	int i, j, k;
+
+	i = 0;
+	j = 0;
+	k = 1;
+
+	while (x[i].start != 0 && y[j].start != 0) {
+		if (x[i].start < y[j].start) {
+			add_region(_exclude_regions[_index], &k,
+				   x[i].start, x[i].end);
+			++i;
+		} else {
+			add_region(_exclude_regions[_index], &k,
+				   y[j].start, y[j].end);
+			++j;
+		}
+	}
+
+	if (x[i].start == 0) {
+		while (y[j].start) {
+			add_region(_exclude_regions[_index], &k,
+				   y[j].start, y[j].end);
+			++j;
+		}
+	} else if (y[j].start == 0) {
+		while (x[i].start) {
+			add_region(_exclude_regions[_index], &k,
+				   x[i].start, x[i].end);
+			++i;
+		}
+	}
+
+	exclude_regions = &_exclude_regions[_index][1];
+	_index = _index ? 0 : 1;
+
+	return 0;
+}
 
 static int __init rmi_proc_setup(void)
 {
-- 
1.7.0.4

