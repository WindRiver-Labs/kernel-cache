From e051abab01cc4f7004e9920c9cc51ffa5db5702f Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 May 2010 23:57:28 +0800
Subject: [PATCH 04/47] nlm_xlr_atx_64_be: add timer support

Extracted from RMI SDK 1.7.0.

Add the timer interrupt support

There are 8 timers in XLR's on-chip Programmable Interrupt Controller.
All 16 vCPUs use mips compare/count as its timer interrupt source.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/rmi/phoenix/Makefile |    2 +-
 arch/mips/rmi/phoenix/time.c   |  109 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 110 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/rmi/phoenix/time.c

diff --git a/arch/mips/rmi/phoenix/Makefile b/arch/mips/rmi/phoenix/Makefile
index 6fdd2a1..187cd6c 100644
--- a/arch/mips/rmi/phoenix/Makefile
+++ b/arch/mips/rmi/phoenix/Makefile
@@ -1,3 +1,3 @@
-obj-y := irq.o cpu.o
+obj-y := irq.o cpu.o time.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff --git a/arch/mips/rmi/phoenix/time.c b/arch/mips/rmi/phoenix/time.c
new file mode 100644
index 0000000..f31f41b
--- /dev/null
+++ b/arch/mips/rmi/phoenix/time.c
@@ -0,0 +1,109 @@
+/*
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+
+#include <asm/irq.h>
+#include <asm/ptrace.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+#include <asm/rmi/interrupt.h>
+
+extern spinlock_t phnx_pic_lock;
+
+#ifndef CONFIG_PHOENIX_MAC
+void phoenix_user_mac_update_time(void) { }
+void phoenix_user_mac_update_ktime(void) { }
+#else
+extern void phoenix_user_mac_update_time(void);
+extern void phoenix_user_mac_update_ktime(void);
+#endif
+
+void phoenix_timer_interrupt(struct pt_regs *regs, int irq)
+{
+	int cpu = smp_processor_id();
+
+	if (irq != IRQ_TIMER) {
+		pr_err("cpu_%d: bad timer irq = %x\n", cpu, irq);
+		BUG();
+	}
+
+	do_IRQ(irq);
+
+	if (cpu == 0) {
+		phoenix_user_mac_update_time();
+		phoenix_user_mac_update_ktime();
+	}
+}
+
+/*
+ * PIC clock at 66Mhz takes more than 60 secs to come to 0 from max. So
+ * 32bit counter is sufficient
+ */
+#define PIC_FREE_RUNNING_TIMER_MAX_VAL 0xffffffff
+
+cycle_t xlr_hpt_read(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	uint32_t counter = 0;
+
+	counter = phoenix_read_reg(mmio, PIC_TIMER_6_COUNTER_0);
+
+	return (cycle_t)(PIC_FREE_RUNNING_TIMER_MAX_VAL - counter);
+}
+EXPORT_SYMBOL(xlr_hpt_read);
+
+int read_current_timer(unsigned long *timer_val)
+{
+	*timer_val = xlr_hpt_read();
+	return 0;
+}
+
+void phoenix_timer_setup(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags = 0;
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	/* Use PIC Timer 6 as a free running counter */
+	phoenix_write_reg(mmio, PIC_TIMER_6_MAXVAL_0, 0xffffffff);
+	phoenix_write_reg(mmio, PIC_TIMER_6_MAXVAL_1, 0xffffffff);
+	/* we Don't need interrupts */
+	phoenix_write_reg(mmio, PIC_IRT_0_TIMER_6, 0);
+	phoenix_write_reg(mmio, PIC_IRT_1_TIMER_6,
+			(1<<31)|(0<<30)|(1<<6)|(PIC_TIMER_6_IRQ));
+	pic_update_control(1<<(8 + 6));
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
-- 
1.7.0.4

