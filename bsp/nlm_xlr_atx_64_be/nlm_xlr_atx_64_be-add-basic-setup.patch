From 916a4dd2f95124784be33fcfa1362d21c54b1703 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Mon, 6 Dec 2010 18:42:35 +0800
Subject: [PATCH 15/47] nlm_xlr_atx_64_be: add basic setup

Extracted from RMI SDK 1.7.0.

mainly copy configuration from bootloader and parse it for board setup

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/include/asm/bootinfo.h |    8 +
 arch/mips/kernel/setup.c         |    2 +-
 arch/mips/rmi/Kconfig            |   30 ++
 arch/mips/rmi/ptr/Makefile       |    3 +-
 arch/mips/rmi/ptr/setup.c        |  540 ++++++++++++++++++++++++++++++++++++++
 5 files changed, 580 insertions(+), 3 deletions(-)
 create mode 100644 arch/mips/rmi/Kconfig
 create mode 100644 arch/mips/rmi/ptr/setup.c

diff --git a/arch/mips/include/asm/bootinfo.h b/arch/mips/include/asm/bootinfo.h
index 2d27b1f..27777fb 100644
--- a/arch/mips/include/asm/bootinfo.h
+++ b/arch/mips/include/asm/bootinfo.h
@@ -90,7 +90,15 @@ struct boot_mem_map {
 	struct boot_mem_map_entry {
 		phys_t addr;	/* start of memory segment */
 		phys_t size;	/* size of memory segment */
+/*
+ * kernel get boot_mem_map from bootloader, so data structure need to
+ * consistent with bootloader.
+ */
+#ifdef CONFIG_RMI_PHOENIX
+		uint32_t type;		/* type of memory segment */
+#else
 		long type;		/* type of memory segment */
+#endif
 	} map[BOOT_MEM_MAP_MAX];
 };
 
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 9ddb844..f389446 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -127,7 +127,7 @@ static void __init print_memory_map(void)
 			printk(KERN_CONT "(reserved)\n");
 			break;
 		default:
-			printk(KERN_CONT "type %lu\n", boot_mem_map.map[i].type);
+			printk(KERN_CONT "type %u\n", boot_mem_map.map[i].type);
 			break;
 		}
 	}
diff --git a/arch/mips/rmi/Kconfig b/arch/mips/rmi/Kconfig
new file mode 100644
index 0000000..1f57aed
--- /dev/null
+++ b/arch/mips/rmi/Kconfig
@@ -0,0 +1,30 @@
+config RMI_PHOENIX
+	bool
+	select 64BIT_PHYS_ADDR
+
+config PHOENIX_MAC
+	bool "Enable On-Chip Networking support"
+
+config PHOENIX_MSGRING_NAPI
+	bool "XLR/XLS message ring NAPI"
+	depends on PHOENIX_MAC
+	default y
+	help
+	  NAPI is a new driver API designed to reduce CPU and interrupt load
+	  when the driver is receiving lots of packets. This option enables
+	  NAPI implementation for XLR/XLS message ring receive path.
+
+	  See <file:Documentation/networking/NAPI_HOWTO.txt> for more
+	  information.
+
+	  If in doubt, say N.
+
+config RMI_PHOENIX_LOAD_ADDRESS
+	hex "RMI Linux kernel start address"
+	depends on RMI_PHOENIX
+	default "0xffffffff83400000"
+	help
+	  This is start address for the linux kernel. Default value
+	  should be good for most of the applications unless specified
+	  explicitly: e.g. running RMI ToE requires kernel to be linked
+	  at address 0xffffffff86000000.
diff --git a/arch/mips/rmi/ptr/Makefile b/arch/mips/rmi/ptr/Makefile
index dec1234..6d79cfa 100644
--- a/arch/mips/rmi/ptr/Makefile
+++ b/arch/mips/rmi/ptr/Makefile
@@ -1,6 +1,5 @@
+obj-y			= setup.o
 obj-$(CONFIG_SMP)      += smp.o smpboot.o
 
 EXTRA_AFLAGS := $(CFLAGS)
 EXTRA_CFLAGS += -I$(srctree)/include/asm/rmi
-
-
diff --git a/arch/mips/rmi/ptr/setup.c b/arch/mips/rmi/ptr/setup.c
new file mode 100644
index 0000000..ca0fd6f
--- /dev/null
+++ b/arch/mips/rmi/ptr/setup.c
@@ -0,0 +1,540 @@
+/*
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/*
+ * Setup code for RMI's XLR-based boards
+ */
+
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/atomic.h>
+#include <asm/cacheflush.h>
+#include <asm/mipsregs.h>
+#include <asm/bootinfo.h>
+
+#include <asm/rmi/sim.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/msgring.h>
+
+#include <asm/rmi/phnx_user_mac.h>
+#include <asm/rmi/rmi_pcix_gen_dev.h>
+#include <asm/rmi/memory-exclusion.h>
+
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+
+#ifdef RMI_BRIDGE_WKAROUND
+#include <asm/rmi/rmi_rw_lock.h>
+rmi_rwlock_t *rmi_bridge_lock;
+EXPORT_SYMBOL(rmi_bridge_lock);
+int rmi_enable_br_wrkaround;
+EXPORT_SYMBOL(rmi_enable_br_wrkaround);
+struct proc_dir_entry *rmi_root_proc;
+EXPORT_SYMBOL(rmi_root_proc);
+#endif
+
+extern void config_net_init(void);
+extern struct xlr_user_mac_config xlr_user_mac;
+__u8 phoenix_base_mac_addr[6];
+
+__u32 xlr_board_major_version = RMI_PHOENIX_BOARD_ARIZONA_I;
+__u32 xlr_board_minor_version;
+
+struct psb_info *prom_info;
+struct psb_info prom_info_copy;	/* Bootloader prom_info is saved here */
+
+static struct psb_info default_prom_info = {
+	.boot_level = 2,
+	.io_base = DEFAULT_PHOENIX_IO_BASE,
+	.output_device = 2,
+	.thread_online_map = 0x01,
+	.magic_dword = (((__u64) 0x900dbeef << 32) | PSB_INFO_VERSION),
+	.size = sizeof(struct psb_info),
+	.mac_addr = 0x000102030405ULL,
+	.cpu_frequency = 1200000000,
+	.board_version = 1,
+	.board_major_version = 1,
+	.board_minor_version = 0,
+};
+
+static struct physmap_info {
+	int type;
+	char *name;
+} psb_physmap_info[] = {
+	{
+	0x01, "Memory"}, {
+	0x02, " *** HOLE ***"}, {
+	0x10, "Phoenix IO Space"}, {
+	0x11, "PCIX IO Space"}, {
+	0x12, "PCIX CFG Space"}, {
+	0x13, "PCIX Memory Space"}, {
+	0x14, "HT IO Space"}, {
+	0x15, "HT CFG Space"}, {
+	0x16, "HT Memory Space"}, {
+	0x17, "SRAM (QDR) Space"}, {
+	0x18, "Flash Controller Space"}, {
+	0xff, "Unknown type"}
+};
+
+struct boot_mem_map boot_physaddr_info;
+
+static char *get_psb_physmap_name(int type)
+{
+	int i = 0;
+	int tsize = sizeof(psb_physmap_info) / sizeof(struct physmap_info);
+
+	for (i = 0; i < tsize; i++) {
+		if ((psb_physmap_info[i].type == type) ||
+		    (psb_physmap_info[i].type == 0xff))
+			return psb_physmap_info[i].name;
+	}
+	return "Unknown type";
+}
+
+static int sanity_check_prom_info(struct psb_info *info)
+{
+	if (!prom_info)
+		return 0;
+
+	if ((prom_info->magic_dword & 0xffffffffULL) != 0x900dbeef)
+		return 0;
+	if ((prom_info->magic_dword >> 32) != PSB_INFO_VERSION)
+		return 0;
+
+	return 1;
+}
+
+const char *DEFAULT_CONSOLE_BOOT_PARAMS = "console=ttyS0,38400 ";
+const char *DEFAULT_INITRD_BOOT_PARAMS = "rdinit=/sbin/init ";
+
+const char *get_system_type(void)
+{
+	return "RMI XLR";
+}
+
+void prom_reconfigure_thr_resources(void)
+{
+	unsigned int mmu_setup = 0;
+	int value = 0;
+	__u32 online_map = prom_info->thread_online_map;
+	__u32 thr_mask = online_map >> (phoenix_cpu_id() << 2);
+	int i = 0, count = 0;
+	int dis_contig = 0;
+
+	if (phoenix_thr_id() == 0) {
+		for (i = 0; i < 4; i++) {
+			if (thr_mask & (1 << i)) {
+				if (i != count)
+					dis_contig = 1;
+				count++;
+			}
+		}
+		switch (count) {
+		case 1:
+			value = 0x00;
+			break;
+		case 2:
+			value = 0x02;
+			break;
+		default:
+			value = 0x03;
+			break;
+		}
+		if (dis_contig)
+			value = 0x3;
+
+		mmu_setup = read_32bit_phnx_ctrl_reg(4, 0);
+		mmu_setup = mmu_setup & ~0x06;
+		mmu_setup |= (value << 1);
+
+		write_32bit_phnx_ctrl_reg(4, 0, mmu_setup);
+	}
+}
+
+void *phoenix_psb_shm;
+unsigned long phoenix_psb_shm_size;
+
+int xlr_hybrid;
+
+uint32_t xlr_linux_cpu_mask;
+static int xlr_boot_over_nfs;
+
+#define DEFAULT_LINUX_CPU_MASK 0x1
+
+static void xlr_initialize_setups(void)
+{
+	xlr_hybrid = XLR_HYBRID_NONE;
+	xlr_linux_cpu_mask = DEFAULT_LINUX_CPU_MASK;
+
+	xlr_user_mac.l4_extract = 0;
+	xlr_user_mac.fast_syscall = 1;
+	/* default mac addr */
+	phoenix_base_mac_addr[0] = 0x00;
+	phoenix_base_mac_addr[1] = 0x01;
+	phoenix_base_mac_addr[2] = 0x02;
+	phoenix_base_mac_addr[3] = 0x03;
+	phoenix_base_mac_addr[4] = 0x04;
+	phoenix_base_mac_addr[5] = 0x05;
+}
+
+unsigned int __cpuinit get_c0_compare_int(void)
+{
+	return IRQ_TIMER;
+}
+
+void plat_time_init(void)
+{
+	extern void phoenix_timer_setup(void);
+	/* only needed for use cpu counter timer interrupt source */
+	mips_hpt_frequency = (unsigned int) prom_info->cpu_frequency;
+
+	phoenix_timer_setup();
+	pr_info("mips_hpt_frequency = %u\n", mips_hpt_frequency);
+}
+
+#define BOOT_LOADER_REGION_SZ 0x04000000
+#define LOADER_KSEG_END 0x10000000
+
+/* arg -> arg passed by user
+   name - pointer to the start of name=value string
+   base - conversion base
+   res - converted number is stored here
+	NOTE: returned value is a 32 bit number always
+
+   Returns 0 on success, -1 otherwise
+   */
+static int get_name_value(char *arg, char *name, int base, uint32_t * res)
+{
+	char *ptr = strstr(arg, name);
+
+	if (ptr == NULL)
+		return -1;
+
+	ptr = strrchr(ptr, '=');
+	pr_debug("ptr after strrchr = %s\n", ptr);
+	ptr++;
+
+	*res = (uint32_t) simple_strtol(ptr, (char **) NULL, base);
+
+	return 0;
+}
+
+struct phnx_name_value_struct {
+	char *name;
+	uint32_t *val;
+};
+
+static struct phnx_name_value_struct phnx_name_value_args[] = {
+	{"linux_cpu_mask=", &xlr_linux_cpu_mask},
+	{NULL, NULL}
+};
+
+void prom_parse_args(int argc, char *argv[])
+{
+	int i, j;
+	int ret;
+
+	/* Check if loader support needs to be enabled */
+	for (i = 1; i < argc; i++) {
+		if (argv && argv[i]) {
+			if (strcmp(argv[i], "root=/dev/nfs") == 0) {
+				xlr_boot_over_nfs = 1;
+			} else {
+				j = 0;
+				while (phnx_name_value_args[j].name !=
+				       NULL) {
+					ret =
+					    get_name_value(argv[i],
+							   phnx_name_value_args
+							   [j].name, 16,
+							   phnx_name_value_args
+							   [j].val);
+					if (ret == 0)
+						break;
+					j++;
+				}
+			}
+		}
+	}
+}
+
+#define DEF_PHYMEM_START_ADDR 0x100000
+#define DEF_PHYMEM_SIZE 0x0ff00000
+
+static void prom_add_memory(void)
+{
+	__u64 pref_backup = 512;
+
+	pr_info("Using default physical memory map: 255m@1m\n");
+
+	add_memory_region(DEF_PHYMEM_START_ADDR, DEF_PHYMEM_SIZE - pref_backup, (long) BOOT_MEM_RAM);
+}
+
+static void psb_print_physmap(void)
+{
+	char *name;
+	int max, i = 0;
+	struct boot_mem_map *physaddr_map =
+	    (struct boot_mem_map *) ((unsigned long) prom_info->
+				     psb_physaddr_map);
+
+
+	if (physaddr_map == NULL)
+		return;
+
+	max = physaddr_map->nr_map;
+
+	pr_info("Physical Address Map\n");
+	for (i = 0; i < max; i++) {
+		name = get_psb_physmap_name(physaddr_map->map[i].type);
+
+		pr_info("\t%010llx --> %010llx ( %s )\n",
+			     (unsigned long long) physaddr_map->map[i].
+			     addr,
+			     (unsigned long long) (physaddr_map->map[i].
+						   addr +
+						   physaddr_map->map[i].
+						   size - 1), name);
+	}
+}
+
+static void save_physaddr_info(void)
+{
+	struct boot_mem_map *physaddr_map =
+	    (struct boot_mem_map *) ((unsigned long) prom_info->
+				     psb_physaddr_map);
+
+	if (physaddr_map == NULL)
+		return;
+
+	memcpy(&boot_physaddr_info, physaddr_map,
+	       sizeof(struct boot_mem_map));
+}
+
+extern void (*board_nmi_handler_setup) (void);
+
+void __init rmi_nmi_setup(void)
+{
+	/* setup nmi handler only if KGDB is enabled */
+}
+
+extern void prom_pre_boot_secondary_cpus(void *);
+extern struct plat_smp_ops rmi_smp_ops;
+
+/*
+ * prom_init is called just after the cpu type is determined, from setup_arch()
+ */
+void __init prom_init(void)
+{
+	int i = 0;
+	int argc = (int) fw_arg0;
+	long temp;
+	char **argv;
+	char **envp;
+	int t_argc = argc;
+	char *n_argv[RMI_MAX_ARGS] = { NULL };
+	char *n_envp[RMI_MAX_ENVS] = { NULL };
+	struct psb_info *t_prom_info;
+	int32_t *t_argv;
+
+	void (*wakeup) (void *, void *, __u32);
+
+	pr_info("%s print something very earlier ... \n", __func__);
+
+	temp = (int) fw_arg1;
+	argv = (char **) temp;
+
+	temp = (int) fw_arg2;
+	envp = (char **) temp;
+
+	xlr_initialize_setups();
+
+	prom_info = &prom_info_copy;
+	temp = (int) fw_arg3;
+	prom_info = &prom_info_copy;
+	t_prom_info = (struct psb_info *) temp;
+	memcpy((void *) prom_info, (void *) t_prom_info,
+	       sizeof(struct psb_info));
+
+#ifdef RMI_BRIDGE_WKAROUND
+	if (prom_info->global_shmem_size == 0x1000) {
+		rmi_bridge_lock = (rmi_rwlock_t *) (unsigned long)
+		    (prom_info->global_shmem_addr + 0);
+		rmi_enable_br_wrkaround = 1;
+		pr_info("Enabling Bridge Workaround \n");
+	}
+#endif
+
+	/* Get the right 64bit pointers from bootloader args */
+
+	t_argv = (int32_t *) argv;
+	for (i = 0; i < t_argc; i++, t_argv++) {
+		n_argv[i] =
+		    (char *) (unsigned long) (*t_argv);
+	}
+
+	argc = t_argc;
+
+	/* Get the right env pointers */
+	if (envp != NULL) {
+		int32_t *t_envp;
+		t_envp = (int32_t *) envp;
+		for (i = 0; *t_envp; i++) {
+			n_envp[i] =
+			    (char *) (unsigned long) (*t_envp);
+			t_envp++;
+		}
+	}
+
+	if (!sanity_check_prom_info(prom_info)) {
+		pr_info("Sanity Check failed on prom_info @ %p\n",
+		       prom_info);
+		if (prom_info) {
+			pr_info
+			    ("sizeof(psb_info) = %d, psb_info_version = %x, "
+			     "prom_info->magic_dword = %llx, prom_info->size = %llx\n",
+			     (unsigned int) sizeof(struct psb_info),
+			     PSB_INFO_VERSION,
+			     (unsigned long long) prom_info->magic_dword,
+			     (unsigned long long) prom_info->size);
+		}
+		prom_info = &default_prom_info;
+		goto parse_args;
+	}
+
+	xlr_board_major_version = prom_info->board_major_version;
+	xlr_board_minor_version = prom_info->board_minor_version;
+	pr_info("board version: major = %d, minor = %d\n", xlr_board_major_version, xlr_board_minor_version);
+
+	prom_parse_args(argc, n_argv);
+
+	psb_print_physmap();
+
+	save_physaddr_info();
+
+	prom_add_memory();
+
+	/* update the phoenix mac addr */
+	phoenix_base_mac_addr[0] = (prom_info->mac_addr >> 40) & 0xff;
+	phoenix_base_mac_addr[1] = (prom_info->mac_addr >> 32) & 0xff;
+	phoenix_base_mac_addr[2] = (prom_info->mac_addr >> 24) & 0xff;
+	phoenix_base_mac_addr[3] = (prom_info->mac_addr >> 16) & 0xff;
+	phoenix_base_mac_addr[4] = (prom_info->mac_addr >> 8) & 0xff;
+	phoenix_base_mac_addr[5] = (prom_info->mac_addr >> 0) & 0xff;
+
+	/* pull all the cpus out of the bootloader and force them to spin in
+	 * prom_pre_boot_secondary_cpus
+	 */
+	wakeup =
+	    ((void (*)(void *, void *, __u32)) (unsigned long)
+	     (prom_info->wakeup));
+
+	smp_boot.online_map = (1 << hard_smp_processor_id());
+
+	if (wakeup != 0x0)
+		wakeup(prom_pre_boot_secondary_cpus, 0,
+		       (__u32) prom_info->
+		       thread_online_map & (~smp_boot.online_map));
+
+parse_args:
+
+	for (i = 1; i < argc; i++) {
+		if (n_argv[i]) {
+			strcat(arcs_cmdline, n_argv[i]);
+			strcat(arcs_cmdline, " ");
+		} else
+			pr_info("bad args, i=%d\n", i);
+	}
+	strcat(arcs_cmdline, " ");
+
+	if ((strstr(arcs_cmdline, "console=")) == NULL)
+		strcat(arcs_cmdline, DEFAULT_CONSOLE_BOOT_PARAMS);
+	strcat(arcs_cmdline, " ");
+
+#ifdef CONFIG_ROOT_NFS
+	if (!xlr_boot_over_nfs)
+		strcat(arcs_cmdline, DEFAULT_INITRD_BOOT_PARAMS);
+#else
+	strcat(arcs_cmdline, DEFAULT_INITRD_BOOT_PARAMS);
+#endif
+	strcat(arcs_cmdline, " ");
+
+	for (i = 0; n_envp[i]; i++) {
+		if (strcmp(n_envp[i], "") == 0)
+			break;
+	}
+	pr_info("%s register smp ops \n", __func__);
+
+#ifdef CONFIG_PHOENIX_MAC
+	pr_info("MAC ADDR BASE: %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       phoenix_base_mac_addr[0], phoenix_base_mac_addr[1],
+	       phoenix_base_mac_addr[2], phoenix_base_mac_addr[3],
+	       phoenix_base_mac_addr[4], phoenix_base_mac_addr[5]);
+
+	config_net_init();
+#endif
+	board_nmi_handler_setup = rmi_nmi_setup;
+
+	on_chip_init();
+	prom_reconfigure_thr_resources();
+
+	register_smp_ops(&rmi_smp_ops);
+
+	pr_info("%s register smp ops \n", __func__);
+}
+
+void prom_free_prom_memory(void)
+{
+	/* nothing to free */
+}
+
+
+static int __init rmi_proc_setup(void)
+{
+
+	rmi_root_proc = proc_mkdir("rmi", 0);
+
+	if (!rmi_root_proc)
+		return -ENOMEM;
+
+	return 0;
+}
+
+rootfs_initcall(rmi_proc_setup);
-- 
1.7.0.4

