From a0b1f6bb0e0fb54b51a1519b0e0e407aa7656e64 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 21 May 2010 13:07:28 +0800
Subject: [PATCH 32/47] nlm_xlr_atx_64_be: add network buffer recycling via hardware support

Extracted from RMI SDK 1.7.0.

Experimental addition to GMAC functionality allowing "recycling" of
packet buffers by requesting HW to queue free elements upon Tx-complete
back to the Rx free list.

This type of performance ehancement is important to forwarder-like
applications where fast path should stay as lean as possible.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/rmi/Kconfig     |   14 ++++
 drivers/net/phoenix_mac.c |  157 +++++++++++++++++++++++++++++++++++++++++++++
 include/linux/skbuff.h    |   18 +++++
 net/core/skbuff.c         |   14 ++++
 4 files changed, 203 insertions(+), 0 deletions(-)

diff --git a/arch/mips/rmi/Kconfig b/arch/mips/rmi/Kconfig
index 1f57aed..1bc5fe8 100644
--- a/arch/mips/rmi/Kconfig
+++ b/arch/mips/rmi/Kconfig
@@ -19,6 +19,20 @@ config PHOENIX_MSGRING_NAPI
 
 	  If in doubt, say N.
 
+config PHOENIX_HW_BUFFER_MGMT
+	bool "Enable support for network buffer recycling via hardware"
+	depends on RMI_PHOENIX
+	default y
+	help
+	  Experimental addition to GMAC functionality allowing "recycling" of 
+	  packet buffers by requesting HW to queue free elements upon Tx-complete 
+	  back to the Rx free list.
+	  This type of performance ehancement is important to forwarder-like
+	  applications where fast path should stay as lean as possible.
+
+	  If in doubt, say N.
+
+
 config RMI_PHOENIX_LOAD_ADDRESS
 	hex "RMI Linux kernel start address"
 	depends on RMI_PHOENIX
diff --git a/drivers/net/phoenix_mac.c b/drivers/net/phoenix_mac.c
index cff8a98..7b995d5 100644
--- a/drivers/net/phoenix_mac.c
+++ b/drivers/net/phoenix_mac.c
@@ -334,6 +334,9 @@ extern struct user_mac_data *user_mac;
 static int rmi_phnx_napi_setup(void);
 #endif
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+static int setup_auto_free(struct sk_buff *skb, int type, struct msgrng_msg *msg);
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 /* global flag for automatic hardware buffer management, disabled by default */
 int rmi_auto_buffer_mgmt = 0;
@@ -710,6 +713,18 @@ static int mac_frin_send_skb(struct net_device *dev, struct sk_buff *skb)
 	unsigned long msgrng_flags = 0;
 	struct driver_data *priv;
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+	if (rmi_auto_buffer_mgmt) {
+		/* Put skb under automatic buffer management */
+		skb_shinfo(skb)->rmi_flags = 1;
+		skb_shinfo(skb)->rmi_owner = dev;
+		skb_shinfo(skb)->rmi_refill = mac_frin_replenish_one_msg;
+	} else {
+		skb_shinfo(skb)->rmi_flags = 0;
+		skb_shinfo(skb)->rmi_owner = NULL;
+		skb_shinfo(skb)->rmi_refill = NULL;
+	}
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 	priv = netdev_priv(dev);
 
@@ -758,6 +773,96 @@ static int mac_frin_replenish_one_msg(struct net_device *dev)
 
 
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+/*
+ * This helper macro resets SKB data pointers for reuse
+ * as free-in buffer
+*/
+#define skb_reset_ptrs(skb) \
+do { \
+	struct skb_shared_info *shinfo; \
+	\
+	shinfo = skb_shinfo(skb); \
+	\
+	\
+	/* Now reinitialize old skb, cut & paste from dev_alloc_skb */ \
+	memset(skb, 0, offsetof(struct sk_buff, tail)); \
+	skb->data = skb->head;  \
+	skb_reset_tail_pointer(skb);\
+	\
+	atomic_set(&shinfo->dataref, 1); \
+	shinfo->nr_frags  = 0; \
+	shinfo->gso_size = 0; \
+	shinfo->gso_segs = 0; \
+	shinfo->gso_type = 0; \
+	shinfo->ip6_frag_id = 0; \
+	shinfo->frag_list = NULL; \
+} while (0)
+
+
+/*
+ * If we are in the HW buffer management case we handler frames with rx errors
+ * via this function
+*/
+static void 
+discard_rx_frame(struct net_device *dev, struct sk_buff *skb, int cpu)
+{
+	/* Reset all fields to 0, reset data pointers */
+	skb_reset_ptrs(skb);
+
+	mac_frin_send_skb(dev, skb); 
+}
+
+
+/*
+ *  Prepare SKB for automatic memory management operation (buffer recycling)
+ *
+ *  Return: 0 -- recycling is not possible
+ *          1 -- SKB set up for recycling successfully
+*/
+static int
+setup_auto_free(struct sk_buff *skb, int type, struct msgrng_msg *msg)
+{
+	struct driver_data *priv;
+	struct skb_shared_info *shinfo;
+	int fr_stid, offset;
+
+	shinfo = skb_shinfo(skb);
+	if (!shinfo->rmi_flags)
+		return 0;
+
+	if (atomic_read(&skb->users) != 1) {
+		printk(KERN_ALERT "%s: Can't recycle because of users count\n", __FUNCTION__);
+		return 0;
+	}
+
+	if (skb->cloned || atomic_read(&(skb_shinfo(skb)->dataref)) != 1) {
+		printk(KERN_EMERG "%s: Can't recycle because of cloned or dataref\n", __FUNCTION__);
+		return 0;
+	}
+
+	skb_dst_drop(skb);
+
+	/* Reset all fields to 0, reset data pointers */
+	skb_reset_ptrs(skb);
+
+	offset = (((unsigned long)skb->data + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1));
+	skb_reserve(skb, (offset - (unsigned long)skb->data));
+
+	priv = netdev_priv(skb_shinfo(skb)->rmi_owner);
+	fr_stid = priv->fr_stid;
+
+	mac_put_skb_back_ptr(skb);
+
+	msg->msg1 = ( ((uint64_t) 1 << 63) |
+		      ((uint64_t) fr_stid << 54) |
+		      ((uint64_t) 0 << 40) |
+		      ((uint64_t)virt_to_phys(skb->data) & 0xffffffffffULL)
+		    );
+	return 1;
+}
+
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 
 
@@ -1538,6 +1643,11 @@ static inline int mac_make_desc_b0_tx(struct msgrng_msg *msg,
 		     ((uint64_t) len << 40) | ((uint64_t) addr)
 	    );
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+        if (rmi_auto_buffer_mgmt && setup_auto_free(skb, priv->type, msg))
+		return tx_stid;
+	else 
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 	{
 		msg->msg1 = (((uint64_t) 1 << 63) |
 			     ((uint64_t) fr_stid << 54) |
@@ -2324,6 +2434,24 @@ void rmi_phnx_mac_msgring_handler(int bucket, int size, int code,
 				  int stid, struct msgrng_msg *msg,
 				  void *data /* ignored */ )
 {
+#ifndef CONFIG_PHOENIX_HW_BUFFER_MGMT
+/* 
+ * Special helper macro to handle Rx errors within this interrupt handler
+ * macro is used locally in this function only
+ *
+ * NB: the alternative case when HW buffer management is on is handled by a 
+ * larger function defined above
+*/
+#define discard_rx_frame(dev, skb, cpu) \
+do { \
+	if (atomic_inc_return(&priv->frin_to_be_sent[cpu]) > \
+				MAC_FRIN_TO_BE_SENT_THRESHOLD) { \
+		tasklet_schedule(&mac_frin_replenish_task[cpu]); \
+	} \
+	dev_kfree_skb_irq(skb); \
+} while (0)
+
+#endif /* !CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 	unsigned long addr = 0;
 	__u32 length = 0;
@@ -2927,6 +3055,13 @@ static int rmi_phnx_mac_fill_rxfr(struct net_device *dev)
 
 		skb->dev = dev;
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+		if (rmi_auto_buffer_mgmt) {
+			skb_shinfo(skb)->rmi_flags = 1;
+			skb_shinfo(skb)->rmi_owner = dev;
+			skb_shinfo(skb)->rmi_refill = mac_frin_replenish_one_msg;
+		}
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 		/* Send the free Rx desc to the MAC */
 		msgrng_access_enable(msgrng_flags);
@@ -3162,6 +3297,28 @@ static void mac_common_init(struct driver_data *priv)
 }
 
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+/*
+ * Setup for XLR/XLS automatic hardware buffer management. 
+*/
+static int __init
+rmi_auto_buffer_mgmt_setup(char *str)
+{
+	if (str == NULL || !strcmp(str, "yes") || !strcmp(str, "y")) {
+		rmi_auto_buffer_mgmt = 1;
+		printk(KERN_ALERT "Enabling automatic hardware buffer management\n");
+	}
+	else if (!strcmp(str, "no") || !strcmp(str, "n")) {
+		rmi_auto_buffer_mgmt = 0;
+		printk(KERN_ALERT "Disabling automatic hardware buffer management\n");
+	}
+
+	return 0;
+}
+
+/* for compatibility we use "xlr_" prefix for the option */
+early_param("xlr_auto_buffer_mgmt", rmi_auto_buffer_mgmt_setup);
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 
 #ifdef CONFIG_PHOENIX_MSGRING_NAPI
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index b15cd1d..5b3f059 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -194,6 +194,24 @@ struct skb_shared_info {
 	unsigned short	gso_segs;
 	unsigned short  gso_type;
 	__be32          ip6_frag_id;
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+	/* Several fileds to track SKB's which utilize automatic buffer 
+	 * management:
+	 *
+	 * @rmi_flags: Non-zero means that this data buffer intends to use FMN
+	 * features to return data back to originating device's free pool. 
+	 * If more flags added later, we will transition to bit-scale 
+	 * representation for semantics of this field.
+	 *
+	 * @rmi_owner: pointer to the device which owns this data buffer
+	 *
+	 * @rmi_refill: function to create new data buffers (e.g. to replace
+	 * one to be freed for some reason).
+	*/
+	unsigned int      rmi_flags;
+	struct net_device *rmi_owner;
+	int               (*rmi_refill)(struct net_device *dev);
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 	union skb_shared_tx tx_flags;
 	struct sk_buff	*frag_list;
 	struct skb_shared_hwtstamps hwtstamps;
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 26d4b36..41b1ac8 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -220,6 +220,11 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 	shinfo->gso_segs = 0;
 	shinfo->gso_type = 0;
 	shinfo->ip6_frag_id = 0;
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+	shinfo->rmi_flags = 0;
+	shinfo->rmi_owner = NULL;
+	shinfo->rmi_refill = NULL;
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 	shinfo->tx_flags.flags = 0;
 	skb_frag_list_init(skb);
 	memset(&shinfo->hwtstamps, 0, sizeof(shinfo->hwtstamps));
@@ -443,6 +448,11 @@ static void skb_release_data(struct sk_buff *skb)
 		}
 #endif
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+		if (skb_shinfo(skb)->rmi_flags && skb_shinfo(skb)->rmi_refill)
+			skb_shinfo(skb)->rmi_refill(skb_shinfo(skb)->rmi_owner);
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
+
 		kfree(skb->head);
 	}
 }
@@ -898,6 +908,10 @@ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,
 #endif
 	long off;
 
+#if defined (CONFIG_RMI_PHOENIX) && defined (CONFIG_64BIT)
+	gfp_mask |= GFP_DMA;
+#endif
+
 	BUG_ON(nhead < 0);
 
 	if (skb_shared(skb))
-- 
1.7.0.4

