From 8b9feb5f4e9a6b303f52c1e22330e7568fdaea42 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 21 May 2010 13:07:28 +0800
Subject: [PATCH 23/47] nlm_xlr_atx_64_be: add pcix support

Extracted from RMI SDK 1.7.0.

This adds the on-chip pcix controller support.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
[ Standard the io operations to avoid touching the drivers
  Remove the HT and PCIE support for our boards don't have them. ]
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/include/asm/rmi/iomap.h |    4 +
 arch/mips/include/asm/rmi/pci.h   |   38 +++++
 arch/mips/pci/Makefile            |    1 +
 arch/mips/pci/pci-phoenix.c       |  291 +++++++++++++++++++++++++++++++++++++
 4 files changed, 334 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/include/asm/rmi/pci.h
 create mode 100644 arch/mips/pci/pci-phoenix.c

diff --git a/arch/mips/include/asm/rmi/iomap.h b/arch/mips/include/asm/rmi/iomap.h
index 68822c1..029e6d1 100644
--- a/arch/mips/include/asm/rmi/iomap.h
+++ b/arch/mips/include/asm/rmi/iomap.h
@@ -85,6 +85,10 @@
 #define DEFAULT_HT_TYPE0_CFG_BASE       0x16000000
 #define DEFAULT_HT_TYPE1_CFG_BASE       0x17000000
 
+/* 16MB PCI IO @ 0x1000_0000 */
+#define DEFAULT_PCI_IO_BASE             0x10000000UL
+#define DEFAULT_PCI_IO_SIZE             0x00100000UL
+
 #ifndef __ASSEMBLY__
 
 #include <linux/preempt.h>
diff --git a/arch/mips/include/asm/rmi/pci.h b/arch/mips/include/asm/rmi/pci.h
new file mode 100644
index 0000000..1634f5c
--- /dev/null
+++ b/arch/mips/include/asm/rmi/pci.h
@@ -0,0 +1,38 @@
+/*
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+
+#ifndef _ASM_RMI_PCI_H
+#define _ASM_RMI_PCI_H
+
+#define RMI_PCI_VENDOR_ID            0xfecc
+#define RMI_PCI_UART_DEV_ID          2
+#define RMI_PCI_DUMMY_MAC_DEV_ID     16
+
+#endif
diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index c9209ca..cc09f89 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_TOSHIBA_RBTX4927)	+= fixup-rbtx4927.o
 obj-$(CONFIG_TOSHIBA_RBTX4938)	+= fixup-rbtx4938.o
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
+obj-$(CONFIG_RMI_PHOENIX)  	+= pci-phoenix.o
 obj-$(CONFIG_WR_PPMC)		+= fixup-wrppmc.o
 obj-$(CONFIG_MIKROTIK_RB532)	+= pci-rc32434.o ops-rc32434.o fixup-rc32434.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= pci-octeon.o pcie-octeon.o
diff --git a/arch/mips/pci/pci-phoenix.c b/arch/mips/pci/pci-phoenix.c
new file mode 100644
index 0000000..70a61bc
--- /dev/null
+++ b/arch/mips/pci/pci-phoenix.c
@@ -0,0 +1,291 @@
+/*
+  Copyright (C) 2010 Wind River Systems, Inc.
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/ide.h>
+
+#include <asm/io.h>
+
+#include <asm/rmi/interrupt.h>
+#include <asm/rmi/pci.h>
+#include <asm/rmi/io.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/sim.h>
+#include <asm/rmi/mips-exts.h>
+
+#define LSU_CFG0_REGID		0
+#define LSU_CERRLOG_REGID	9
+#define LSU_CERROVF_REGID	10
+#define LSU_CERRINT_REGID	11
+
+#define pci_cfg_offset(bus, devfn, where)	\
+	((((bus)->number - pci_start_busno) << 16) + ((devfn) << 8) + (where))
+
+static int pci_start_busno;
+static int pci_start_bus_fixed;
+static void *pci_config_base;
+static void *pci_io_base;
+
+static inline void disable_and_clear_cache_error(void)
+{
+	uint64_t lsu_cfg0 =
+	    read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID);
+	lsu_cfg0 = lsu_cfg0 & ~0x2e;
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID,
+				  lsu_cfg0);
+	/* Clear cache error log */
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID, 0);
+}
+
+static inline void clear_and_enable_cache_error(void)
+{
+	uint64_t lsu_cfg0 = 0;
+
+	/* first clear the cache error logging register */
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID, 0);
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERROVF_REGID, 0);
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRINT_REGID, 0);
+
+	lsu_cfg0 =
+	    read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID);
+	lsu_cfg0 = lsu_cfg0 | 0x2e;
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID,
+				  lsu_cfg0);
+}
+
+static inline __u32 pci_cfg_read_32bit(__u32 addr)
+{
+	__u32 temp = 0;
+	__u32 *p = (__u32 *) (pci_config_base + (addr & ~3));
+	__u64 cerr_cpu_log = 0;
+
+	disable_and_clear_cache_error();
+
+	temp = cpu_to_le32(*p);
+
+	/* Read cache err log */
+	cerr_cpu_log =
+	    read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
+	if (cerr_cpu_log) {
+		/* Device doesn't exist. */
+		temp = ~0x0;
+	}
+	clear_and_enable_cache_error();
+	return temp;
+}
+
+static inline void pci_cfg_write_32bit(__u32 addr, __u32 data)
+{
+	unsigned int *p = (unsigned int *) (pci_config_base + (addr & ~3));
+	*p = cpu_to_le32(data);
+}
+
+static int phoenix_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+			int where, int size, u32 *val)
+{
+	__u32 data = 0;
+
+	/* Keep track of where the PCIX
+	 * bus numbering starts from..
+	 */
+	if (!pci_start_bus_fixed) {
+		pci_start_busno = (int) (bus->number);
+		pci_start_bus_fixed = 1;
+	}
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = pci_cfg_read_32bit(pci_cfg_offset(bus, devfn, where));
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int phoenix_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 val)
+{
+	__u32 cfgaddr = pci_cfg_offset(bus, devfn, where);
+	__u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = pci_cfg_read_32bit(cfgaddr);
+
+	if (size == 1)
+		data = (data & ~(0xff << ((where & 3) << 3))) |
+		    (val << ((where & 3) << 3));
+	else if (size == 2)
+		data = (data & ~(0xffff << ((where & 3) << 3))) |
+		    (val << ((where & 3) << 3));
+	else
+		data = val;
+
+	pci_cfg_write_32bit(cfgaddr, data);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops phoenix_pci_ops = {
+	.read = phoenix_pcibios_read,
+	.write = phoenix_pcibios_write
+};
+
+/*
+ * XLR PCIX Controller
+ */
+static struct resource phoenix_mem_resource = {
+	.name = "PHOENIX PCI MEM",
+	.start = 0xd0000000UL,	/* 256MB PCI mem @ 0xd000_0000 */
+	.end = 0xdfffffffUL,
+	.flags = IORESOURCE_MEM,
+};
+
+/*
+ * 16MB PCI IO @ 0x1000_0000
+ *
+ * 0x1000_0000 is the physical address, the ioremapped virtual address
+ * is pci_controller.io_map_base + phoenix_io_resource.start
+ */
+
+static struct resource phoenix_io_resource = {
+	.name = "PHOENIX IO MEM",
+	.start = 0x00000000UL,
+	.end = DEFAULT_PCI_IO_SIZE - 1,
+	.flags = IORESOURCE_IO,
+};
+
+struct pci_controller phoenix_controller = {
+	.index = 0,
+	.pci_ops = &phoenix_pci_ops,
+	.mem_resource = &phoenix_mem_resource,
+	.io_resource = &phoenix_io_resource,
+	.io_offset = 0x00000000UL,
+	.mem_offset = 0x00000000UL
+};
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return PIC_PCIX_IRQ;
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+/* Enabled by default */
+static int __initdata xlr_nopci;
+
+static int __init xlr_nopci_setup(char *str)
+{
+	/* Disable PCI/X/E; disables HT also */
+	xlr_nopci = 1;
+	return 1;
+}
+
+__setup("xlr_nopci", xlr_nopci_setup);
+
+
+static int __init pcibios_init(void)
+{
+	unsigned long phys, size;
+
+	if (xlr_nopci) {
+		pr_info
+		    ("PCI disabled by boot arguments  - skipping.\n");
+		return 0;
+	}
+
+	if (xlr_board_atx_iii() || xlr_board_atx_v())
+		return 0;
+
+	/* PSB assigns PCI resources */
+	pci_probe_only = 1;
+
+	/* Map the PCIX CFG space */
+	pci_config_base = ioremap(DEFAULT_PCI_CONFIG_BASE, (32 << 20));
+	if (!pci_config_base) {
+		pr_err("Unable to map PCI config space!\n");
+		return 1;
+	}
+
+	/*
+	 * To ensure the generic in{b,w,l} and out{b,w,l} works, we set
+	 * the io_map_base as pci_io_base, and let the start address be
+	 * the virtual address.
+	 */
+	phys = DEFAULT_PCI_IO_BASE;
+	size = DEFAULT_PCI_IO_SIZE;
+	pci_io_base = ioremap(phys, size);
+	if (!pci_io_base)
+		pr_err("[%s]: Unable to IO-Remap phys=%lx, size=%lx\n",
+			__func__, phys, size);
+	else
+		pr_info("[%s]: IO-Remapped phys=%lx, size=%lx to vaddr=%p\n",
+			__func__, phys, size, pci_io_base);
+
+	pci_start_bus_fixed = 0;
+
+	/* IO Range for 16MB from where the MEM Range Ends */
+	ioport_resource.start = 0;
+	ioport_resource.end = ~0;
+
+	set_io_port_base((unsigned long)pci_io_base);
+	phoenix_controller.io_map_base = mips_io_port_base;
+
+	pr_info("Registering XLR/XLS PCIX Controller.\n");
+
+	register_pci_controller(&phoenix_controller);
+	return 0;
+}
+
+arch_initcall(pcibios_init);
+
+struct pci_fixup pcibios_fixups[] = {
+	{0}
+};
-- 
1.7.0.4

