From 2d25b085e5ae33d95ccd6e4253ec0341e66e54a6 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Mon, 10 Jan 2011 16:07:21 +0800
Subject: [PATCH 44/47] nlm_xlr_atx_64_be: Use an actual "physical memory map" to __uncached_access

Extracted from RMI SDK 1.7.0.

After getting the detailed memory map from bootloader, the
__uncached_access() function can use an actual "physical memory map".

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/rmi/phoenix/memory.c |   10 ++++------
 arch/mips/rmi/ptr/setup.c      |   26 ++++++++++++++++++++++++++
 2 files changed, 30 insertions(+), 6 deletions(-)

diff --git a/arch/mips/rmi/phoenix/memory.c b/arch/mips/rmi/phoenix/memory.c
index 09ff294..e47609b 100644
--- a/arch/mips/rmi/phoenix/memory.c
+++ b/arch/mips/rmi/phoenix/memory.c
@@ -19,17 +19,15 @@ void __init plat_mem_setup(void)
 
 int __uncached_access(struct file *file, unsigned long addr)
 {
+	/* Defined in arch/mips/rmi/ptr/setup.c */
+	extern int phnx_get_pgprot(unsigned long address);
+
 	if (file->f_flags & O_DSYNC)
 		return 1;
 
 	/*
 	 * Return 1 if uncached(IO) and return 0(MEM) if cached access
 	 * is required.
-	 *
-	 * TODO: We need a actual "physical memory map" to implement
-	 * this fully.  For now, treat anything in 256MB to 512MB as
-	 * uncached access
 	 */
-
-	return ((addr >= RMI_UNCACHED_START) && (addr < RMI_UNCACHED_END));
+	return phnx_get_pgprot(addr);
 }
diff --git a/arch/mips/rmi/ptr/setup.c b/arch/mips/rmi/ptr/setup.c
index 6169a4f..f459ed2 100644
--- a/arch/mips/rmi/ptr/setup.c
+++ b/arch/mips/rmi/ptr/setup.c
@@ -150,6 +150,32 @@ static char *get_psb_physmap_name(int type)
 	return "Unknown type";
 }
 
+/* returns 1 for IO and 0 for mem 1 for not found */
+int phnx_get_pgprot(unsigned long address)
+{
+	int i;
+	__u64 start = 0, end = 0;
+	char *name = NULL;
+
+	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
+		start = boot_physaddr_info.map[i].addr;
+		end =
+		    boot_physaddr_info.map[i].addr +
+		    boot_physaddr_info.map[i].size;
+		if ((address >= start) && (address < end)) {
+			name =
+			    get_psb_physmap_name(boot_physaddr_info.map[i].
+						 type);
+			if (!(strcmp(name, "Memory")))
+				return 0;
+			else
+				return 1;
+		}
+
+	}
+	return 1;
+}
+
 static int sanity_check_prom_info(struct psb_info *info)
 {
 	if (!prom_info)
-- 
1.7.0.4

