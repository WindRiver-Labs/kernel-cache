From 9aef82e380bfc1312379cf17f003ff2c8ba677f1 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 May 2010 23:57:28 +0800
Subject: [PATCH 03/47] nlm_xlr_atx_64_be: add pic/irq support

Extracted from RMI SDK 1.7.0.

Phoenix PIC support.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/include/asm/rmi/pic.h |  211 ++++++++++++++++++++
 arch/mips/rmi/phoenix/Makefile  |    3 +
 arch/mips/rmi/phoenix/irq.c     |  406 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 620 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/include/asm/rmi/pic.h
 create mode 100644 arch/mips/rmi/phoenix/Makefile
 create mode 100644 arch/mips/rmi/phoenix/irq.c

diff --git a/arch/mips/include/asm/rmi/pic.h b/arch/mips/include/asm/rmi/pic.h
new file mode 100644
index 0000000..ad84840
--- /dev/null
+++ b/arch/mips/include/asm/rmi/pic.h
@@ -0,0 +1,211 @@
+/*
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+
+#ifndef _ASM_RMI_PIC_H
+#define _ASM_RMI_PIC_H
+
+#include <asm/rmi/iomap.h>
+
+#define PIC_CLKS_PER_SEC 66666666ULL
+#define PIC_IRT_WD_INDEX	0
+#define PIC_IRT_TIMER_0_INDEX	1
+#define PIC_IRT_TIMER_1_INDEX	2
+#define PIC_IRT_TIMER_2_INDEX	3
+#define PIC_IRT_TIMER_3_INDEX	4
+#define PIC_IRT_TIMER_4_INDEX	5
+#define PIC_IRT_TIMER_5_INDEX	6
+#define PIC_IRT_TIMER_6_INDEX	7
+#define PIC_IRT_TIMER_7_INDEX	8
+#define PIC_IRT_CLOCK_INDEX	PIC_IRT_TIMER_7_INDEX
+#define PIC_IRT_UART_0_INDEX	9
+#define PIC_IRT_UART_1_INDEX	10
+#define PIC_IRT_I2C_0_INDEX	11
+#define PIC_IRT_I2C_1_INDEX	12
+#define PIC_IRT_PCMCIA_INDEX	13
+#define PIC_IRT_GPIO_INDEX	14
+#define PIC_IRT_HYPER_INDEX	15
+#define PIC_IRT_PCIX_INDEX	16
+#define PIC_IRT_GMAC0_INDEX	17
+#define PIC_IRT_GMAC1_INDEX	18
+#define PIC_IRT_GMAC2_INDEX	19
+#define PIC_IRT_GMAC3_INDEX	20
+#define PIC_IRT_XGS0_INDEX	21
+#define PIC_IRT_XGS1_INDEX	22
+#define PIC_IRT_HYPER_FATAL_INDEX	23
+#define PIC_IRT_PCIX_FATAL_INDEX	24
+#define PIC_IRT_BRIDGE_AERR_INDEX	25
+#define PIC_IRT_BRIDGE_BERR_INDEX	26
+#define PIC_IRT_BRIDGE_TB_XLR_INDEX	27
+#define PIC_IRT_BRIDGE_AERR_NMI_INDEX	28
+#define PIC_NUM_IRTS			32
+
+#define PIC_SYS_TIMER_MAXVAL_0_BASE	0x100
+#define PIC_SYS_TIMER_MAXVAL_1_BASE	0x110
+
+#define PIC_SYS_TIMER_0_BASE	0x120
+#define PIC_SYS_TIMER_1_BASE	0x130
+
+#define PIC_CLOCK_TIMER	7
+
+#define PIC_CTRL	0x00
+#define PIC_IPI		0x04
+#define PIC_INT_ACK	0x06
+
+#define WD_MAX_VAL_0	0x08
+#define WD_MAX_VAL_1	0x09
+#define WD_MASK_0	0x0a
+#define WD_MASK_1	0x0b
+#define WD_HEARBEAT_0	0x0c
+#define WD_HEARBEAT_1	0x0d
+
+#define PIC_IRT_0_BASE	0x40
+#define PIC_IRT_1_BASE	0x80
+
+#define PIC_IRT_0_WD		(PIC_IRT_0_BASE   + PIC_IRT_WD_INDEX)
+#define PIC_IRT_1_WD		(PIC_IRT_1_BASE   + PIC_IRT_WD_INDEX)
+#define PIC_IRT_0_TIMER_0	(PIC_IRT_0_BASE + PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_1_TIMER_0	(PIC_IRT_1_BASE + PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_0_TIMER_1	(PIC_IRT_0_BASE + PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_1_TIMER_1	(PIC_IRT_1_BASE + PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_0_TIMER_2	(PIC_IRT_0_BASE + PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_1_TIMER_2	(PIC_IRT_1_BASE + PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_0_TIMER_3	(PIC_IRT_0_BASE + PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_1_TIMER_3	(PIC_IRT_1_BASE + PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_0_TIMER_4	(PIC_IRT_0_BASE + PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_1_TIMER_4	(PIC_IRT_1_BASE + PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_0_TIMER_5	(PIC_IRT_0_BASE + PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_1_TIMER_5	(PIC_IRT_1_BASE + PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_0_TIMER_6	(PIC_IRT_0_BASE + PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_1_TIMER_6	(PIC_IRT_1_BASE + PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_0_TIMER_7	(PIC_IRT_0_BASE + PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_1_TIMER_7	(PIC_IRT_1_BASE + PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_0_CLOCK		(PIC_IRT_0_TIMER_7)
+#define PIC_IRT_1_CLOCK		(PIC_IRT_1_TIMER_7)
+#define PIC_IRT_0_UART_0	(PIC_IRT_0_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_1_UART_0	(PIC_IRT_1_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_0_UART_1	(PIC_IRT_0_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_1_UART_1	(PIC_IRT_1_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_0_I2C_0		(PIC_IRT_0_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_1_I2C_0		(PIC_IRT_1_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_0_I2C_1		(PIC_IRT_0_BASE + PIC_IRT_I2C_1_INDEX)
+#define PIC_IRT_1_I2C_1		(PIC_IRT_1_BASE + PIC_IRT_I2C_1_INDEX)
+
+#define PIC_TIMER_0_MAXVAL_0	(PIC_SYS_TIMER_MAXVAL_0_BASE + 0)
+#define PIC_TIMER_0_MAXVAL_1	(PIC_SYS_TIMER_MAXVAL_1_BASE + 0)
+#define PIC_TIMER_0_COUNTER_0	(PIC_SYS_TIMER_0_BASE + 0)
+#define PIC_TIMER_0_COUNTER_1	(PIC_SYS_TIMER_1_BASE + 0)
+#define PIC_TIMER_7_MAXVAL_0	(PIC_SYS_TIMER_MAXVAL_0_BASE + 7)
+#define PIC_TIMER_7_MAXVAL_1	(PIC_SYS_TIMER_MAXVAL_1_BASE + 7)
+#define PIC_TIMER_7_COUNTER_0	(PIC_SYS_TIMER_0_BASE + 7)
+#define PIC_TIMER_7_COUNTER_1	(PIC_SYS_TIMER_1_BASE + 7)
+#define PIC_TIMER_6_MAXVAL_0	(PIC_SYS_TIMER_MAXVAL_0_BASE + 6)
+#define PIC_TIMER_6_MAXVAL_1	(PIC_SYS_TIMER_MAXVAL_1_BASE + 6)
+#define PIC_TIMER_6_COUNTER_0	(PIC_SYS_TIMER_0_BASE + 6)
+#define PIC_TIMER_6_COUNTER_1	(PIC_SYS_TIMER_1_BASE + 6)
+
+#define PIC_IRQ_BASE		8
+#define PIC_IRT_FIRST_IRQ	PIC_IRQ_BASE
+#define PIC_WD_IRQ	(PIC_IRQ_BASE + PIC_IRT_WD_INDEX)
+#define PIC_TIMER_0_IRQ	(PIC_IRQ_BASE + PIC_IRT_TIMER_0_INDEX)
+#define PIC_TIMER_1_IRQ	(PIC_IRQ_BASE + PIC_IRT_TIMER_1_INDEX)
+#define PIC_TIMER_2_IRQ	(PIC_IRQ_BASE + PIC_IRT_TIMER_2_INDEX)
+#define PIC_TIMER_3_IRQ	(PIC_IRQ_BASE + PIC_IRT_TIMER_3_INDEX)
+#define PIC_TIMER_4_IRQ	(PIC_IRQ_BASE + PIC_IRT_TIMER_4_INDEX)
+#define PIC_TIMER_5_IRQ	(PIC_IRQ_BASE + PIC_IRT_TIMER_5_INDEX)
+#define PIC_TIMER_6_IRQ	(PIC_IRQ_BASE + PIC_IRT_TIMER_6_INDEX)
+#define PIC_TIMER_7_IRQ	(PIC_IRQ_BASE + PIC_IRT_TIMER_7_INDEX)
+#define PIC_CLOCK_IRQ	(PIC_TIMER_7_IRQ)
+#define PIC_UART_0_IRQ	(PIC_IRQ_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_UART_1_IRQ	(PIC_IRQ_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_I2C_0_IRQ	(PIC_IRQ_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_I2C_1_IRQ	(PIC_IRQ_BASE + PIC_IRT_I2C_1_INDEX)
+#define PIC_PCMCIA_IRQ	(PIC_IRQ_BASE + PIC_IRT_PCMCIA_INDEX)
+#define PIC_GPIO_IRQ	(PIC_IRQ_BASE + PIC_IRT_GPIO_INDEX)
+#define PIC_HYPER_IRQ	(PIC_IRQ_BASE + PIC_IRT_HYPER_INDEX)
+#define PIC_PCIX_IRQ	(PIC_IRQ_BASE + PIC_IRT_PCIX_INDEX)
+#define PIC_GMAC_0_IRQ	(PIC_IRQ_BASE + PIC_IRT_GMAC0_INDEX)
+#define PIC_GMAC_1_IRQ	(PIC_IRQ_BASE + PIC_IRT_GMAC1_INDEX)
+#define PIC_GMAC_2_IRQ	(PIC_IRQ_BASE + PIC_IRT_GMAC2_INDEX)
+#define PIC_GMAC_3_IRQ	(PIC_IRQ_BASE + PIC_IRT_GMAC3_INDEX)
+#define PIC_XGS_0_IRQ	(PIC_IRQ_BASE + PIC_IRT_XGS0_INDEX)
+#define PIC_XGS_1_IRQ	(PIC_IRQ_BASE + PIC_IRT_XGS1_INDEX)
+#define PIC_HYPER_FATAL_IRQ	(PIC_IRQ_BASE + PIC_IRT_HYPER_FATAL_INDEX)
+#define PIC_PCIX_FATAL_IRQ	(PIC_IRQ_BASE + PIC_IRT_PCIX_FATAL_INDEX)
+#define PIC_BRIDGE_AERR_IRQ	(PIC_IRQ_BASE + PIC_IRT_BRIDGE_AERR_INDEX)
+#define PIC_BRIDGE_BERR_IRQ	(PIC_IRQ_BASE + PIC_IRT_BRIDGE_BERR_INDEX)
+#define PIC_BRIDGE_TB_XLR_IRQ	(PIC_IRQ_BASE + PIC_IRT_BRIDGE_TB_XLR_INDEX)
+#define PIC_BRIDGE_AERR_NMI_IRQ	(PIC_IRQ_BASE + PIC_IRT_BRIDGE_AERR_NMI_INDEX)
+#define PIC_IRT_LAST_XLR_IRQ	PIC_BRIDGE_AERR_NMI_IRQ
+
+#ifndef __ASSEMBLY__
+static inline void pic_send_ipi(__u32 ipi)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_write_reg(mmio, PIC_IPI, ipi);
+}
+
+static inline __u32 pic_read_control(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	return phoenix_read_reg(mmio, PIC_CTRL);
+}
+
+static inline void pic_write_control(__u32 ctrl)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_write_reg(mmio, PIC_CTRL, ctrl);
+}
+static inline void pic_update_control(__u32 ctrl)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_write_reg(mmio, PIC_CTRL, (ctrl | phoenix_read_reg(mmio, PIC_CTRL)));
+}
+
+#define PIC_IRQ_IS_EDGE_TRIGGERED(irq) \
+	(((irq) >= PIC_TIMER_0_IRQ) && ((irq) <= PIC_TIMER_7_IRQ))
+
+#define PIC_IRQ_IS_IRT(irq) \
+	(((irq) >= PIC_IRT_FIRST_IRQ) && ((irq) <= PIC_IRT_LAST_XLR_IRQ))
+
+#define PIC_IRT_LAST_IRQ() PIC_IRT_LAST_XLR_IRQ
+#define PIC_BRIDGE_TB_IRQ() PIC_BRIDGE_TB_XLR_IRQ
+
+struct pt_regs;
+extern void phoenix_ipi_handler(int irq, struct pt_regs *regs);
+extern void phnx_msgring_int_handler(unsigned int irq, struct pt_regs *regs);
+
+struct pic_tmask {
+	unsigned int mask;
+	int set;
+	int valid;
+};
+#endif	/* __ASSEMBLY__ */
+
+#endif	/* _ASM_RMI_PIC_H */
diff --git a/arch/mips/rmi/phoenix/Makefile b/arch/mips/rmi/phoenix/Makefile
new file mode 100644
index 0000000..6fdd2a1
--- /dev/null
+++ b/arch/mips/rmi/phoenix/Makefile
@@ -0,0 +1,3 @@
+obj-y := irq.o cpu.o
+
+EXTRA_AFLAGS := $(CFLAGS)
diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
new file mode 100644
index 0000000..dc6b2a6
--- /dev/null
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -0,0 +1,406 @@
+/*
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel_stat.h>
+#include <linux/cpumask.h>
+
+#include <asm/kgdb.h>
+
+#include <asm/rmi/sim.h>
+#include <asm/rmi/pic.h>
+#include <asm/rmi/interrupt.h>
+#include <asm/rmi/mips-exts.h>
+
+/*
+ * These are the routines that handle all the low level interrupt stuff.
+ * Actions handled here are: initialization of the interrupt map,
+ * requesting of interrupt lines by handlers, dispatching if interrupts
+ * to handlers, probing for interrupt lines.
+ */
+
+__u64 phnx_irq_mask;
+DEFINE_SPINLOCK(phnx_pic_lock);
+
+struct pic_tmask pic_tmask[PIC_NUM_IRTS];
+
+static void pic_unmask(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+	uint32_t thread_mask = (1 << cpu_logical_map(0));
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	if (pic_tmask[irq - PIC_IRQ_BASE].set == 0)
+		phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE,
+				  thread_mask);
+
+	pic_tmask[irq - PIC_IRQ_BASE].valid = 1;
+	/*
+	 * What happens if this irq was previously not ack'ed?
+	 * Assume, that doesn't happen?
+	 */
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+
+	/*
+	 * By default all the interrupts are initialized as level
+	 * senstive - fix for the PCMCIA flash
+	 */
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE,
+			  reg | (1 << 6) | (1 << 30) | (1 << 31) | irq);
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
+
+static void pic_ack(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_reg_t *pci_mmio = phoenix_io_mmio(PHOENIX_IO_PCIX_OFFSET);
+
+	unsigned long i, flags;
+	phoenix_reg_t reg;
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return;
+
+	/* Interrupt (level sensitive ) acknowledge method for the PCMCIA flash */
+	if (irq == PIC_PCMCIA_IRQ) {
+		reg = *(unsigned char *)(unsigned long)(0xffffffffBD0001f7ULL);
+		reg = *(unsigned int *)(unsigned long)(0xffffffffBEF19180ULL);
+
+		for (i = 0; i < 0x100; i++)
+			;
+		*(unsigned int *)(unsigned long)(0xffffffffBEF19180ULL) = reg;
+
+		for (i = 0; i < 0x1000; i++)
+			;
+		reg = *(unsigned int *)(unsigned long)(0xffffffffBEF19180ULL);
+	}
+
+	/* Deal with All PCI-Interrupts.. Brigde ACK */
+	if (irq == PIC_PCIX_IRQ)
+		phoenix_read_reg(pci_mmio, (0x140 >> 2));
+
+	/*
+	 * If edge triggered IRQ, ack it immediately, else when the device
+	 * interrupt condition is cleared, we may lose interrupts
+	 */
+	if (PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+		phoenix_write_reg(mmio, PIC_INT_ACK,
+				  (1 << (irq - PIC_IRQ_BASE)));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+}
+
+static void pic_end(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return;
+
+	/* If level triggered, ack it after the device condition is cleared */
+	if (!PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+		phoenix_write_reg(mmio, PIC_INT_ACK,
+				  (1 << (irq - PIC_IRQ_BASE)));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+}
+
+static void pic_shutdown(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	/*
+	 * What happens if this irq is currently pending an ack?
+	 * Assume, that doesn't happen?
+	 */
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE,
+			  (reg & ~(1 << 31)));
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
+
+static int pic_set_affinity(unsigned int irq, const struct cpumask *mask)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	uint32_t physmap = 0, logmap = 0, i;
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return -1;
+
+	/* Set affinity comes with logical cpu ids, move this to physical cpu ids */
+	for (i = 0; i < NR_CPUS; i++) {
+		if ((1 << i) & (uint32_t) mask->bits[0]) {
+			logmap |= (1 << i);
+			physmap |= (1 << cpu_logical_map(i));
+		}
+	}
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE, physmap);
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+
+	return 0;
+}
+
+static struct irq_chip phnx_pic = {
+	.name = "Phoenix-PIC",
+	.unmask = pic_unmask,
+	.mask = pic_shutdown,
+	.ack = pic_ack,
+	.eoi = pic_end,
+	.set_affinity = pic_set_affinity
+};
+
+static void rsvd_pic_handler_1_1(unsigned int irq)
+{
+	if (irq < PIC_IRQ_BASE)
+		return;
+	pr_debug("Requesting a reserved irq (%d)??", irq);
+}
+
+static void rsvd_pic_handler_1(unsigned int irq)
+{
+	if (irq < PIC_IRQ_BASE)
+		return;
+	pr_debug("handler called for a reserved irq (%d)\n", irq);
+}
+
+static int rsvd_pic_handler_2(unsigned int irq, const struct cpumask *mask)
+{
+	if (irq < PIC_IRQ_BASE)
+		return -1;
+	pr_debug("handler called for a reserved irq (%d)\n", irq);
+	return 0;
+}
+
+struct irq_chip phnx_rsvd_pic_irq_timer = {
+	.name = "Count-Compare",
+	.unmask = rsvd_pic_handler_1_1,
+	.mask = rsvd_pic_handler_1,
+	.ack = rsvd_pic_handler_1,
+	.end = rsvd_pic_handler_1,
+	.set_affinity = rsvd_pic_handler_2
+};
+
+struct irq_chip phnx_rsvd_pic = {
+	.name = "Phoenix-RSVD-PIC",
+	.unmask = rsvd_pic_handler_1_1,
+	.mask = rsvd_pic_handler_1,
+	.ack = rsvd_pic_handler_1,
+	.end = rsvd_pic_handler_1,
+	.set_affinity = rsvd_pic_handler_2
+};
+
+static irqreturn_t phnx_rsvd_irq_handler(int irq, void *dev_id)
+{
+	if (irq == IRQ_TIMER)
+		return IRQ_HANDLED;
+	pr_debug("handler for reserved irq %d\n", irq);
+	return IRQ_NONE;
+}
+
+struct irqaction phnx_rsvd_action = {
+	.handler = phnx_rsvd_irq_handler,
+	.flags = 0,
+	.name = "phnx_rsvd_action",
+	.dev_id = 0,
+	.next = 0
+};
+
+extern int noirqdebug;
+
+void handle_xlr_irq(unsigned int irq, struct irq_desc *desc)
+{
+	irqreturn_t action_ret;
+
+	kstat_incr_irqs_this_cpu(irq, desc);
+
+	if (desc->chip->ack)
+		desc->chip->ack(irq);
+
+	if (unlikely(!desc->action || (desc->status & IRQ_DISABLED)))
+		goto out;
+
+	action_ret = handle_IRQ_event(irq, desc->action);
+	if (!noirqdebug)
+		note_interrupt(irq, desc, action_ret);
+
+ out:
+	if (desc->chip->eoi)
+		desc->chip->eoi(irq);
+}
+
+void __init init_phoenix_irqs(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++)
+		set_irq_chip_and_handler(i, &phnx_pic, handle_xlr_irq);
+
+#ifdef CONFIG_REMOTE_DEBUG
+	irq_desc[IRQ_REMOTE_DEBUG].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_REMOTE_DEBUG].action = phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL << IRQ_REMOTE_DEBUG);
+#endif
+
+#ifdef CONFIG_SMP
+	irq_desc[IRQ_IPI_SMP_FUNCTION].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_FUNCTION].action = &phnx_rsvd_action;
+
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &phnx_rsvd_action;
+
+	phnx_irq_mask |=
+	    ((1ULL << IRQ_IPI_SMP_FUNCTION) | (1ULL << IRQ_IPI_SMP_RESCHEDULE));
+#endif				/* CONFIG_SMP */
+
+	irq_desc[IRQ_TIMER].chip = &phnx_rsvd_pic_irq_timer;
+	irq_desc[IRQ_TIMER].action = NULL;
+	phnx_irq_mask |= (1ULL << IRQ_TIMER);
+
+	/* The driver installs a handler so, don't reserve it */
+	phnx_irq_mask |= (1ULL << IRQ_DUMMY_UART);
+
+	/*
+	 * unmask all PIC related interrupts. If no handler is installed
+	 * by the drivers, it'll just ack the interrupt and return
+	 */
+	for (i = PIC_IRT_FIRST_IRQ; i <= PIC_IRT_LAST_IRQ(); i++)
+		phnx_irq_mask |= (1ULL << i);
+
+#ifdef CONFIG_KGDB
+	phnx_irq_mask |= (1ULL << IRQ_IPI_SMP_KGDB);
+#endif
+
+}
+
+void do_phnx_IRQ(unsigned int irq, struct pt_regs *regs)
+{
+#ifdef CONFIG_SMP
+	if (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE) {
+		phoenix_ipi_handler(irq, regs);
+		return;
+	}
+#endif				/* CONFIG_SMP */
+	do_IRQ(irq);
+}
+
+void __cpuinit rmi_smp_irq_init(void)
+{
+	/* set interrupt mask for non-zero cpus */
+	write_64bit_cp0_eimr(phnx_irq_mask | (1 << IRQ_TIMER));
+
+}
+
+void __init arch_init_irq(void)
+{
+#ifdef CONFIG_KGDB
+	if (kgdb_early_setup)
+		return;
+#endif
+
+	/*
+	 * TODO: Initialize the irq registers on the PIC to route
+	 * interrupts to appropriate pins
+	 */
+
+	/* Initialize the irq descriptors */
+	init_phoenix_irqs();
+
+	write_64bit_cp0_eimr(phnx_irq_mask);
+}
+
+extern void phoenix_timer_interrupt(struct pt_regs *regs, int irq);
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	struct pt_regs *pt_regs = current_thread_info()->regs;
+	uint64_t eirr = read_64bit_cp0_eirr() & read_64bit_cp0_eimr();
+	int i = 0;
+
+	if (!eirr)
+		return;
+
+	if (eirr & (1 << IRQ_TIMER)) {
+		phoenix_timer_interrupt(pt_regs, IRQ_TIMER);
+		return;
+	}
+
+	/*TODO use dcltz: optimize below code */
+	for (i = 63; i != -1; i--) {
+		if (eirr & (1ULL << i))
+			break;
+	}
+
+	if (i == -1) {
+		pr_err("no interrupt !!\n");
+		return;
+	}
+
+	/*ack eirr */
+	write_64bit_cp0_eirr(1ULL << i);
+	do_phnx_IRQ(i, pt_regs);
+}
+
+void pic_init(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	uint32_t thread_mask = (1 << hard_smp_processor_id());
+	int i;
+
+	for (i = 0; i < PIC_NUM_IRTS; i++) {
+		int level = PIC_IRQ_IS_EDGE_TRIGGERED(i);
+
+		phoenix_write_reg(mmio, PIC_IRT_0_BASE + i, thread_mask);
+		phoenix_write_reg(mmio, PIC_INT_ACK, (1 << i));
+		phoenix_write_reg(mmio, PIC_IRT_1_BASE + i,
+				  (level << 30) | (1 << 6) | (PIC_IRQ_BASE +
+							      i));
+	}
+}
-- 
1.7.0.4

