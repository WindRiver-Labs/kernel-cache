From 4e5e4b192404fb0a2049125b08e01be76ef049d4 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 21 May 2010 13:07:28 +0800
Subject: [PATCH 25/47] nlm_xlr_atx_64_be: add msgring driver

Extracted from RMI SDK 1.7.0.

RMI XLR Fast Message Network driver. It's a character device for
supplying an interface to access the FMN.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/include/asm/rmi/msgring.h  |  689 +++++++++++++++++++++++++++++
 drivers/char/Makefile                |    1 +
 drivers/char/phnx_msgring.c          |  802 ++++++++++++++++++++++++++++++++++
 drivers/char/phnx_msgring_debugger.c |  119 +++++
 4 files changed, 1611 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/include/asm/rmi/msgring.h
 create mode 100644 drivers/char/phnx_msgring.c
 create mode 100644 drivers/char/phnx_msgring_debugger.c

diff --git a/arch/mips/include/asm/rmi/msgring.h b/arch/mips/include/asm/rmi/msgring.h
new file mode 100644
index 0000000..8caf9f3
--- /dev/null
+++ b/arch/mips/include/asm/rmi/msgring.h
@@ -0,0 +1,689 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_MSG_RING_H
+#define _ASM_RMI_MSG_RING_H
+
+#include <linux/types.h>
+
+#include <asm/asm.h>
+#include <asm/rmi/debug.h>
+#include <asm/rmi/mips-exts.h>
+
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#define find_msb_one_bit(source)							\
+({ uint64_t __res;											\
+	__asm__ __volatile__(                                   \
+	".set\tpush\n\t"										\
+	".set\tnoreorder\n\t"									\
+	"dlco\t$8, %1\n\t"                                      \
+	".set\tpop"												\
+	: "=r" (__res): "r" (source): "$8"                      \
+	);                                                      \
+	__res;})
+
+#define read_32bit_cp2_register(source)                         \
+({ int __res;                                                   \
+	__asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+	"mfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+	: "=r" (__res));                                        \
+	__res;})
+
+#define write_32bit_cp2_register(register,value)                \
+	__asm__ __volatile__(                                   \
+	"mtc2\t%0,"STR(register)"\n\t"				\
+		"nop"							\
+	: : "r" (value));
+
+#define read_32bit_cp2_register_sel(source, sel)                \
+({ int __res;                                                   \
+	__asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set mips32\n\t"                                       \
+	"mfc2\t%0,"STR(source)", %1\n\t"                        \
+	".set\tpop"						\
+	: "=r" (__res) : "i" (sel) );                           \
+	__res;})
+
+#define write_32bit_cp2_register_sel(reg, value, sel)           \
+	__asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set mips32\n\t"                                       \
+	"mtc2\t%0,"STR(reg)", %1\n\t"                           \
+	".set\tpop"						\
+	: : "r" (value), "i" (sel) );
+
+#define MSGRNG_TX_BUF_REG $0
+#define MSGRNG_RX_BUF_REG $1
+
+#define MSGRNG_MSG_STATUS_REG $2
+#define MSGRNG_MSG_CONFIG_REG $3
+
+#define MSGRNG_MSG_BUCKSIZE_REG $4
+
+#define MSGRNG_CC_0_REG  $16
+#define MSGRNG_CC_1_REG  $17
+#define MSGRNG_CC_2_REG  $18
+#define MSGRNG_CC_3_REG  $19
+#define MSGRNG_CC_4_REG  $20
+#define MSGRNG_CC_5_REG  $21
+#define MSGRNG_CC_6_REG  $22
+#define MSGRNG_CC_7_REG  $23
+#define MSGRNG_CC_8_REG  $24
+#define MSGRNG_CC_9_REG  $25
+#define MSGRNG_CC_10_REG $26
+#define MSGRNG_CC_11_REG $27
+#define MSGRNG_CC_12_REG $28
+#define MSGRNG_CC_13_REG $29
+#define MSGRNG_CC_14_REG $30
+#define MSGRNG_CC_15_REG $31
+
+#define msgrng_read_status() read_32bit_cp2_register(MSGRNG_MSG_STATUS_REG)
+
+#define msgrng_read_config() read_32bit_cp2_register(MSGRNG_MSG_CONFIG_REG)
+#define msgrng_write_config(value) write_32bit_cp2_register(MSGRNG_MSG_CONFIG_REG, value)
+
+#define msgrng_read_bucksize(bucket) read_32bit_cp2_register_sel(MSGRNG_MSG_BUCKSIZE_REG, bucket)
+#define msgrng_write_bucksize(bucket, value) write_32bit_cp2_register_sel(MSGRNG_MSG_BUCKSIZE_REG, value, bucket)
+
+#define msgrng_read_cc(reg, pri) read_32bit_cp2_register_sel(reg, pri)
+#define msgrng_write_cc(reg, value, pri) write_32bit_cp2_register_sel(reg, value, pri)
+
+#ifndef _ABI64
+#define read_64bit_cp2_register_sel(source, sel)			\
+({									\
+	unsigned int high, low;						\
+									\
+		__asm__ __volatile__(					\
+			".set\tmips64\n\t"				\
+			"dmfc2\t$8, "STR(source)","STR(sel)"\n\t"		\
+			"dsrl32\t%0, $8, 0\n\t"			        \
+			"dsll32\t$8, $8, 0\n\t"                         \
+			"dsrl32\t%1, $8, 0\n\t"                         \
+			".set\tmips0"					\
+			: "=r" (high), "=r"(low): "i"(sel) : "$8");	\
+	( (((unsigned long long)high)<<32) | low);					\
+})
+
+#define write_64bit_cp2_register_sel(source, val, sel)			\
+do {									\
+		unsigned int high = val>>32;                                       \
+		unsigned int low  = val & 0xffffffff;                              \
+		__asm__ __volatile__(					\
+			".set\tmips64\n\t"				\
+			"dsll32 $8, %1, 0\n"                            \
+			"dsll32 $9, %0, 0\n"                            \
+			"dsrl32 $8, $8, 0\n"                            \
+			"or		$8, $8, $9\n"				\
+			"dmtc2\t$8, "STR(source)", %2\n\t"		\
+			".set\tmips0"					\
+			: : "r" (high), "r" (low), "i"(sel): "$8", "$9");		\
+} while (0)
+
+#else
+#define read_64bit_cp2_register(source)                         \
+({ unsigned long long __res;                                    \
+	__asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+	".set\tmips64\n\t"                                      \
+	"dmfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+	: "=r" (__res));                                        \
+	__res;})
+
+#define write_64bit_cp2_register(register,value)                \
+	__asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+	"dmtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+	".set\tpop"						\
+	: : "r" (value));
+
+#define read_64bit_cp2_register_sel(source, sel)                \
+({ unsigned long long __res;                                    \
+	__asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set mips64\n\t"                                       \
+	"dmfc2\t%0,"STR(source)", %1\n\t"                        \
+	".set\tpop"						\
+	: "=r" (__res) : "i" (sel) );                           \
+	__res;})
+
+#define write_64bit_cp2_register_sel(reg, value, sel)           \
+	__asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set mips64\n\t"                                       \
+	"dmtc2\t%0,"STR(reg)", %1\n\t"                           \
+	".set\tpop"						\
+	: : "r" (value), "i" (sel) );
+#endif
+
+#define msgrng_load_rx_msg0() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 0)
+#define msgrng_load_rx_msg1() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 1)
+#define msgrng_load_rx_msg2() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 2)
+#define msgrng_load_rx_msg3() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 3)
+
+#define msgrng_load_tx_msg0(value) write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 0)
+#define msgrng_load_tx_msg1(value) write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 1)
+#define msgrng_load_tx_msg2(value) write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 2)
+#define msgrng_load_tx_msg3(value) write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 3)
+
+/* Station IDs */
+#define MSGRNG_STNID_CPU0  0x00
+#define MSGRNG_STNID_CPU1  0x08
+#define MSGRNG_STNID_CPU2  0x10
+#define MSGRNG_STNID_CPU3  0x18
+#define MSGRNG_STNID_CPU4  0x20
+#define MSGRNG_STNID_CPU5  0x28
+#define MSGRNG_STNID_CPU6  0x30
+#define MSGRNG_STNID_CPU7  0x38
+
+#define MSGRING_STNID_DEVICES 64
+#define MSGRNG_STNID_XGS0_TX 64
+#define MSGRNG_STNID_XMAC0_00_TX 64
+#define MSGRNG_STNID_XMAC0_01_TX 65
+#define MSGRNG_STNID_XMAC0_02_TX 66
+#define MSGRNG_STNID_XMAC0_03_TX 67
+#define MSGRNG_STNID_XMAC0_04_TX 68
+#define MSGRNG_STNID_XMAC0_05_TX 69
+#define MSGRNG_STNID_XMAC0_06_TX 70
+#define MSGRNG_STNID_XMAC0_07_TX 71
+#define MSGRNG_STNID_XMAC0_08_TX 72
+#define MSGRNG_STNID_XMAC0_09_TX 73
+#define MSGRNG_STNID_XMAC0_10_TX 74
+#define MSGRNG_STNID_XMAC0_11_TX 75
+#define MSGRNG_STNID_XMAC0_12_TX 76
+#define MSGRNG_STNID_XMAC0_13_TX 77
+#define MSGRNG_STNID_XMAC0_14_TX 78
+#define MSGRNG_STNID_XMAC0_15_TX 79
+
+#define MSGRNG_STNID_XGS1_TX 80
+#define MSGRNG_STNID_XMAC1_00_TX 80
+#define MSGRNG_STNID_XMAC1_01_TX 81
+#define MSGRNG_STNID_XMAC1_02_TX 82
+#define MSGRNG_STNID_XMAC1_03_TX 83
+#define MSGRNG_STNID_XMAC1_04_TX 84
+#define MSGRNG_STNID_XMAC1_05_TX 85
+#define MSGRNG_STNID_XMAC1_06_TX 86
+#define MSGRNG_STNID_XMAC1_07_TX 87
+#define MSGRNG_STNID_XMAC1_08_TX 88
+#define MSGRNG_STNID_XMAC1_09_TX 89
+#define MSGRNG_STNID_XMAC1_10_TX 90
+#define MSGRNG_STNID_XMAC1_11_TX 91
+#define MSGRNG_STNID_XMAC1_12_TX 92
+#define MSGRNG_STNID_XMAC1_13_TX 93
+#define MSGRNG_STNID_XMAC1_14_TX 94
+#define MSGRNG_STNID_XMAC1_15_TX 95
+
+#define MSGRNG_STNID_GMAC 96
+#define MSGRNG_STNID_GMACRFR_0  97
+#define MSGRNG_STNID_GMACTX0  98
+#define MSGRNG_STNID_GMACTX1  99
+#define MSGRNG_STNID_GMACTX2  100
+#define MSGRNG_STNID_GMACTX3  101
+#define MSGRNG_STNID_GMACRFR_1  103
+
+#define MSGRNG_STNID_DMA      104
+#define MSGRNG_STNID_DMA_0    104
+#define MSGRNG_STNID_DMA_1    105
+#define MSGRNG_STNID_DMA_2    106
+#define MSGRNG_STNID_DMA_3    107
+
+#define MSGRNG_STNID_XGS0FR 112
+#define MSGRNG_STNID_XMAC0RFR 113
+
+#define MSGRNG_STNID_XGS1FR 114
+#define MSGRNG_STNID_XMAC1RFR 115
+
+#define MSGRNG_STNID_SEC 120
+#define MSGRNG_STNID_SEC0 120
+#define MSGRNG_STNID_SEC1 121
+#define MSGRNG_STNID_SEC2 122
+#define MSGRNG_STNID_SEC3 123
+#define MSGRNG_STNID_PK0  124
+
+#define MSGRNG_STNID_GMAC1      80
+#define MSGRNG_STNID_GMAC1_FR   81
+#define MSGRNG_STNID_GMAC1_TX0  82
+#define MSGRNG_STNID_GMAC1_TX1  83
+#define MSGRNG_STNID_GMAC1_TX2  84
+#define MSGRNG_STNID_GMAC1_TX3  85
+#define MSGRNG_STNID_GMAC0      96
+#define MSGRNG_STNID_GMAC0_FR   97
+#define MSGRNG_STNID_GMAC0_TX0  98
+#define MSGRNG_STNID_GMAC0_TX1  99
+#define MSGRNG_STNID_GMAC0_TX2  100
+#define MSGRNG_STNID_GMAC0_TX3  101
+#define MSGRNG_STNID_CMP_0      108
+#define MSGRNG_STNID_CMP_1      109
+#define MSGRNG_STNID_CMP_2      110
+#define MSGRNG_STNID_CMP_3      111
+#define MSGRNG_STNID_PCIE_0     116
+#define MSGRNG_STNID_PCIE_1     117
+#define MSGRNG_STNID_PCIE_2     118
+#define MSGRNG_STNID_PCIE_3     119
+#define MSGRNG_STNID_XLS_PK0    121
+
+#define MSGRNG_CODE_DEVICE         0
+#define MSGRNG_CODE_MAC            MSGRNG_CODE_DEVICE
+#define MSGRNG_CODE_XGMAC          MSGRNG_CODE_DEVICE
+#define MSGRNG_CODE_SPI4           MSGRNG_CODE_DEVICE
+#define MSGRNG_CODE_SEC            MSGRNG_CODE_DEVICE
+#define MSGRNG_CODE_BOOT_WAKEUP    200
+
+static inline int msgrng_xgmac_stid_rfr(int id)
+{
+	return !id ? MSGRNG_STNID_XMAC0RFR : MSGRNG_STNID_XMAC1RFR;
+}
+
+static inline int msgrng_xgmac_stid_tx(int id)
+{
+	return !id ? MSGRNG_STNID_XMAC0_00_TX : MSGRNG_STNID_XMAC1_00_TX;
+}
+
+static inline int msgrng_gmac_stid_rfr(int id)
+{
+	if (id & 0x4)
+		return (MSGRNG_STNID_GMAC1_FR);
+	return (MSGRNG_STNID_GMACRFR_0);
+}
+
+static inline int msgrng_gmac_stid_rfr_split_mode(int id)
+{
+	return ((id>>1)?MSGRNG_STNID_GMACRFR_1:MSGRNG_STNID_GMACRFR_0);
+}
+
+static inline int msgrng_gmac_stid_tx(int id)
+{
+	if (id & 0x4)
+		return (MSGRNG_STNID_GMAC1_TX0 + (id & 0x3));
+	return (MSGRNG_STNID_GMACTX0 + id);
+}
+
+static inline int msgrng_gmac0_stid_rfr(int id)
+{
+	return (MSGRNG_STNID_GMAC0_FR);
+}
+
+static inline int msgrng_gmac0_stid_tx(int id)
+{
+	return (MSGRNG_STNID_GMAC0_TX0 + id);
+}
+
+static inline int msgrng_gmac1_stid_rfr(int id)
+{
+	return (MSGRNG_STNID_GMAC1_FR);
+}
+
+static inline int msgrng_gmac1_stid_tx(int id)
+{
+	return (MSGRNG_STNID_GMAC1_TX0 + (id & 0x3));
+}
+
+static inline void msgrng_send(unsigned int stid)
+{
+  __asm__ volatile (
+		    ".set push\n"
+		    ".set noreorder\n"
+		    "sync\n"
+		    "move  $8, %0\n"
+		    /* "msgsnd %0\n" */
+		    "c2 0x80001\n"
+		    ".set pop\n"
+		    : : "r" (stid) : "$8"
+		    );
+}
+
+static inline void msgrng_receive(unsigned int pri)
+{
+  __asm__ volatile (
+		    ".set push\n"
+		    ".set noreorder\n"
+		    "move $8, %0\n"
+		    /* "msgld %0\n" */
+		    "c2   0x80002\n"
+		    ".set pop\n"
+		    : : "r" (pri) : "$8"
+		    );
+}
+
+static inline void msgrng_wait(unsigned int mask)
+{
+  __asm__ volatile (
+		    ".set push\n"
+		    ".set noreorder\n"
+		    /* "msgwait %0\n" */
+		    "move $8, %0\n"
+		    /*to ensure msgwait picks up the right bucket */
+		    ""STR(PTR_ADDU)" $8, $8, $0\n"
+		    "c2   0x80003\n"
+		    ".set pop\n"
+		    : :"r" (mask) : "$8"
+		    );
+}
+
+#define msgrng_enable(flags)                \
+do {                                        \
+  preempt_disable(); \
+  __asm__ volatile (                        \
+		    ".set push\n\t"                 \
+		    ".set reorder\n\t"              \
+		    ".set noat\n\t"                 \
+		    "mfc0 %0, $12\n\t"              \
+		    "li  $8, 0x40000001\n\t"        \
+		    "or  $1, %0, $8\n\t"            \
+		    "xori $1, 1\n\t"                \
+		    ".set noreorder\n\t"            \
+		    "mtc0 $1, $12\n\t"              \
+		    ".set\tpop\n\t"                 \
+		    : "=r" (flags)                  \
+		    :                               \
+		    : "$8"                          \
+		    );                              \
+  preempt_enable(); \
+} while (0)
+
+#define msgrng_disable(flags) __asm__ volatile (    \
+                 "mtc0 %0, $12" : : "r" (flags))
+
+#define msgrng_flags_save(flags) msgrng_enable(flags)
+#define msgrng_flags_restore(flags) msgrng_disable(flags)
+
+struct msgrng_msg {
+  __u64 msg0;
+  __u64 msg1;
+  __u64 msg2;
+  __u64 msg3;
+};
+
+static inline void message_send_block_fast(int size, unsigned int code, unsigned int stid,
+                                         unsigned long long msg0, unsigned long long msg1,
+					 unsigned long long msg2, unsigned long long msg3)
+{
+  __asm__ __volatile__ (".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        "dmtc2 %1, "STR(MSGRNG_TX_BUF_REG)", 0\n"
+                        "dmtc2 %2, "STR(MSGRNG_TX_BUF_REG)", 1\n"
+                        "dmtc2 %3, "STR(MSGRNG_TX_BUF_REG)", 2\n"
+                        "dmtc2 %4, "STR(MSGRNG_TX_BUF_REG)", 3\n"
+						"sync\n"
+                        "move $8, %0\n"
+                        "1: c2 0x80001\n"
+                        "mfc2 $8, "STR(MSGRNG_MSG_STATUS_REG)"\n"
+                        "andi $8, $8, 0x6\n"
+                        "bnez $8, 1b\n"
+                        "move $8, %0\n"
+                        ".set pop\n"
+                        :
+                        : "r"(((size-1)<<16)|(code<<8)|stid), "r" (msg0), "r" (msg1), "r"(msg2), "r"(msg3)
+                        : "$8"
+                        );
+}
+
+#define message_receive_fast(bucket, size, code, stid, msg0, msg1, msg2, msg3)      \
+        ( { unsigned int _status=0, _tmp=0;                     \
+           msgrng_receive(bucket);                              \
+           while ( (_status=msgrng_read_status()) & 0x08) ;     \
+           _tmp = _status & 0x30;                               \
+           if (likely(!_tmp)) {                                 \
+                 (size)=((_status & 0xc0)>>6)+1;                \
+                 (code)=(_status & 0xff00)>>8;                  \
+                 (stid)=(_status & 0x7f0000)>>16;               \
+                 (msg0)=msgrng_load_rx_msg0();                  \
+                 (msg1)=msgrng_load_rx_msg1();                  \
+                 (msg2)=msgrng_load_rx_msg2();                  \
+                 (msg3)=msgrng_load_rx_msg3();                  \
+                 _tmp=0;                                        \
+                }                                               \
+           _tmp;                                                \
+        } )
+
+static __inline__ int message_send(unsigned int size, unsigned int code,
+				   unsigned int stid, struct msgrng_msg *msg)
+{
+	unsigned int dest = 0;
+	unsigned long long status=0;
+	int i=0;
+
+	msgrng_load_tx_msg0(msg->msg0);
+	msgrng_load_tx_msg1(msg->msg1);
+	msgrng_load_tx_msg2(msg->msg2);
+	msgrng_load_tx_msg3(msg->msg3);
+
+	dest = ((size-1)<<16)|(code<<8)|(stid);
+
+	dbg_msg("Sending msg<%Lx,%Lx,%Lx,%Lx> to dest = %x\n",
+	msg->msg0, msg->msg1, msg->msg2, msg->msg3, dest);
+
+	for(i=0;i<16;i++) {
+		msgrng_send(dest);
+		status = msgrng_read_status();
+		dbg_msg("status = %Lx\n", status);
+
+		if (status & 0x6)
+			continue;
+		else break;
+	}
+	if (i==16) {
+		if (dest == 0x61)
+			dbg_msg("Processor %x: Unable to send msg to %llx\n", processor_id(), dest);
+		return status & 0x6;
+	}
+	return msgrng_read_status() & 0x06;
+}
+
+static __inline__ int message_send_retry(unsigned int size, unsigned int code,
+					 unsigned int stid,
+					 struct msgrng_msg *msg)
+{
+  int res = 0;
+  int retry = 0;
+
+	for(;;) {
+		res = message_send(size, code, stid, msg);
+		/* retry a pending fail */
+		if (res & 0x02) continue;
+		/* credit fail */
+		if (res & 0x04) retry++;
+		else break;
+		if (retry == 4) return res & 0x06;
+	}
+
+	return 0;
+}
+
+static __inline__ int message_receive(int pri, int *size, int *code, int *src_id,
+					struct msgrng_msg *msg)
+{
+  int res = message_receive_fast(pri, *size, *code, *src_id, msg->msg0, msg->msg1, msg->msg2, msg->msg3);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  if (!res) {
+	dbg_msg("Received msg <%llx, %llx, %llx, %llx> <%d,%d,%d>\n",
+		msg->msg0, msg->msg1, msg->msg2, msg->msg3,
+		*size, *code, *src_id);
+  }
+#endif
+
+  return res;
+}
+
+#define MSGRNG_STN_RX_QSIZE 256
+
+typedef unsigned short bucket_t;
+#define MAX_NUM_MSGRNG_STN_CC   128
+#define MAX_NUM_GMAC_STNS 8
+#define MAX_NUM_XGMAC_STNS 18
+#define NR_STNS_PER_CORE 8
+
+struct stn_cc {
+	bucket_t counters[16][8];
+};
+
+struct bucket_size {
+	bucket_t bucket[MAX_NUM_MSGRNG_STN_CC];
+};
+
+extern struct bucket_size bucket_sizes;
+
+extern struct stn_cc cc_table_cpu_0;
+extern struct stn_cc cc_table_cpu_1;
+extern struct stn_cc cc_table_cpu_2;
+extern struct stn_cc cc_table_cpu_3;
+extern struct stn_cc cc_table_cpu_4;
+extern struct stn_cc cc_table_cpu_5;
+extern struct stn_cc cc_table_cpu_6;
+extern struct stn_cc cc_table_cpu_7;
+extern struct stn_cc cc_table_xgs_0;
+extern struct stn_cc cc_table_xgs_1;
+extern struct stn_cc cc_table_gmac;
+extern struct stn_cc cc_table_dma;
+extern struct stn_cc cc_table_sec;
+
+extern struct bucket_size xls_bucket_sizes;
+extern struct stn_cc xls_cc_table_cpu_0;
+extern struct stn_cc xls_cc_table_cpu_1;
+extern struct stn_cc xls_cc_table_cpu_2;
+extern struct stn_cc xls_cc_table_cpu_3;
+extern struct stn_cc xls_cc_table_gmac0;
+extern struct stn_cc xls_cc_table_gmac1;
+extern struct stn_cc xls_cc_table_cmp;
+extern struct stn_cc xls_cc_table_pcie;
+extern struct stn_cc xls_cc_table_dma;
+extern struct stn_cc xls_cc_table_sec;
+
+extern struct bucket_size shared_bucket_sizes;
+
+extern struct stn_cc shared_cc_table_cpu_0;
+extern struct stn_cc shared_cc_table_cpu_1;
+extern struct stn_cc shared_cc_table_cpu_2;
+extern struct stn_cc shared_cc_table_cpu_3;
+extern struct stn_cc shared_cc_table_cpu_4;
+extern struct stn_cc shared_cc_table_cpu_5;
+extern struct stn_cc shared_cc_table_cpu_6;
+extern struct stn_cc shared_cc_table_cpu_7;
+extern struct stn_cc shared_cc_table_gmac;
+extern struct stn_cc shared_cc_table_dma;
+
+#define msgrng_access_save(lock, iflags, mflags) do {        \
+	spin_lock_irqsave(lock, iflags);                           \
+	msgrng_flags_save(mflags);                                 \
+}while(0)
+
+#define msgrng_access_restore(lock, iflags, mflags) do {     \
+	msgrng_flags_restore(mflags);                              \
+	spin_unlock_irqrestore(lock, iflags);                      \
+}while(0)
+
+#define msgrng_access_enable(mflags) do {   \
+	preempt_disable();                        \
+	msgrng_flags_save(mflags);                \
+} while(0)
+
+#define msgrng_access_disable(mflags) do {   \
+	msgrng_flags_restore(mflags);              \
+	preempt_enable();                          \
+} while(0)
+
+enum {
+  TX_STN_CPU_0,
+  TX_STN_CPU_1,
+  TX_STN_CPU_2,
+  TX_STN_CPU_3,
+  TX_STN_CPU_4,
+  TX_STN_CPU_5,
+  TX_STN_CPU_6,
+  TX_STN_CPU_7,
+  TX_STN_GMAC,
+  TX_STN_DMA,
+  TX_STN_XGS_0,
+  TX_STN_XGS_1,
+  TX_STN_SEC,
+  TX_STN_GMAC0,
+  TX_STN_GMAC1,
+  TX_STN_CMP,
+  TX_STN_PCIE,
+  TX_STN_INVALID,
+  MAX_TX_STNS
+};
+
+extern int register_msgring_handler(int major,
+				    void (*action)(int, int,int,int,struct msgrng_msg *, void *),
+				    void *dev_ctx);
+
+extern void phoenix_msgring_cpu_init(void);
+
+extern void phnx_msgring_config(void);
+
+#define cpu_to_msgring_bucket(cpu) ((((cpu) >> 2)<<3)|((cpu) & 0x03))
+
+/* PR: We need to make the following entrities visible across the kernel */
+#define CPU_BASE_BUCKET(x)   (((x)>>2)<<3)
+
+#define THR_LO_BUCKETID (phoenix_thr_id() & 3)
+#define THR_HI_BUCKETID (THR_LO_BUCKETID + 4)
+
+#define THIS_THR_LO_BUCKET cpu_to_msgring_bucket(hard_smp_processor_id())
+#define THIS_THR_HI_BUCKET (THIS_THR_LO_BUCKET)
+
+#define THR_LO_BKT_STATUS_MASK (1U << THR_LO_BUCKETID)
+#define THR_HI_BKT_STATUS_MASK (1U << THR_HI_BUCKETID)
+
+struct msgrng_msg;
+
+struct tx_stn_handler {
+	void (*action)(int, int, int, int, struct msgrng_msg *, void *);
+	void *dev_id;
+};
+
+struct tx_stn {
+	struct tx_stn_handler handler;
+};
+
+extern struct tx_stn tx_stns[];
+extern int rxstn_to_txstn_map[];
+extern int xls_rxstn_to_txstn_map[];
+
+extern int rmik_queue_pkt_mem(uint32_t fbstid, uint64_t physaddr);
+extern void rmik_init_replenish_work(int);
+extern void rmi_phnx_drop_message_unowned(int fbid, uint64_t physaddr, int cop_en);
+#endif
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 571b891..2f7c99e 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -33,6 +33,7 @@ obj-$(CONFIG_MOXA_INTELLIO)	+= moxa.o
 obj-$(CONFIG_A2232)		+= ser_a2232.o generic_serial.o
 obj-$(CONFIG_ATARI_DSP56K)	+= dsp56k.o
 obj-$(CONFIG_MOXA_SMARTIO)	+= mxser.o
+obj-$(CONFIG_RMI_PHOENIX) += phnx_msgring.o phnx_msgring_debugger.o
 obj-$(CONFIG_COMPUTONE)		+= ip2/
 obj-$(CONFIG_RISCOM8)		+= riscom8.o
 obj-$(CONFIG_ISI)		+= isicom.o
diff --git a/drivers/char/phnx_msgring.c b/drivers/char/phnx_msgring.c
new file mode 100644
index 0000000..7545218
--- /dev/null
+++ b/drivers/char/phnx_msgring.c
@@ -0,0 +1,802 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include <asm/uaccess.h>
+#include <asm/mman.h>
+#include <asm/ioctl.h>
+
+#include <asm/rmi/pic.h>
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/sim.h>
+#include <asm/rmi/devices.h>
+#include <asm/rmi/phnx_user_mac.h>
+
+struct msgring_msg_data {
+	int	size;
+	int	code;
+	int	stid;
+	int	rx_bucket;
+	unsigned int msgs[8];
+};
+
+#define MSG_RNG_IOC_MAGIC 'M'
+#define PHNX_MSGRING_CHRDEV_NAME "xlr_msgring_shm"
+
+#define MSGRING_IOC_SSTNNO _IOW(MSG_RNG_IOC_MAGIC, 0, unsigned int)
+#define MSGRING_IOC_GSHMPHYS _IOR(MSG_RNG_IOC_MAGIC, 1, unsigned int)
+#define MSGRING_IOC_GSHMVIRT _IOR(MSG_RNG_IOC_MAGIC, 2, unsigned int)
+#define MSGRING_IOC_GMMAP_START _IOR(MSG_RNG_IOC_MAGIC, 3, unsigned int)
+#define MSGRING_IOC_SYSINIT _IOR(MSG_RNG_IOC_MAGIC, 4, unsigned int)
+#define MSGRING_IOC_SYSPHYS _IOR(MSG_RNG_IOC_MAGIC, 5, unsigned int)
+#define MSGRING_IOC_SYSCALL _IOW(MSG_RNG_IOC_MAGIC, 6, unsigned int)
+
+#define MAX_MSG_FIFOS 12
+#define MSG_FIFO_SIZE 1024
+#define MSG_FIFO_MASK (MSG_FIFO_SIZE-1)
+
+enum LEVEL {
+	LOG_EMERG = 0,
+	LOG_ALERT,
+	LOG_CRIT,
+	LOG_ERR,
+	LOG_WARNING,
+	LOG_NOTICE,
+	LOG_INFO,
+	LOG_DEBUG
+};
+
+#define PRINTK_ERR(FMT, ...) do { \
+	if (msgring_debug_level >= LOG_ERR) \
+		pr_err(FMT, ## __VA_ARGS__); \
+} while(0)
+
+#define PRINTK_INFO(FMT, ...) do { \
+	if (msgring_debug_level >= LOG_INFO) { \
+		pr_info(FMT, ## __VA_ARGS__); \
+	} \
+} while(0)
+
+typedef enum syscall_id_s {
+	SYSCALL_exec,
+	SYSCALL_socketcall,
+	SYSCALL_open,
+	SYSCALL_write,
+	SYSCALL_read,
+	SYSCALL_close,
+	SYSCALL_ioctl,
+	SYSCALL_select,
+	SYSCALL_exit,
+	SYSCALL_interrupt,
+	SYSCALL_max
+} SYSCALL_ID;
+
+typedef struct syscall {
+	wait_queue_head_t sleep;
+	int done;
+	void *process;
+	int pid;
+	SYSCALL_ID id;
+	int err;
+	int _errno;
+	int num;
+	int src_id;
+	void *trace;
+	union {
+		struct {
+			int call;
+		} socketcall;
+	} u;
+} SYSCALL;
+
+extern char *saved_command_line;
+extern int msgring_debug_level;
+
+extern void *phoenix_psb_shm;
+extern unsigned long phoenix_psb_shm_size;
+
+static int msgring_major;
+
+struct fifo {
+	struct msgring_msg_data *data;
+	int size;
+	int head;
+	int tail;
+	spinlock_t lock;
+	wait_queue_head_t wq;
+};
+
+static void fifo_init(struct fifo *fifo, int fifo_size)
+{
+	void *ptr =
+	    kmalloc(fifo_size * sizeof(struct msgring_msg_data),
+		    GFP_KERNEL);
+
+	if (!ptr)
+		panic("[%s]: Unable to allocate memory for Tx Fifos\n",
+		      __func__);
+
+	fifo->data = ptr;
+	fifo->head = fifo->tail = 0;
+	fifo->size = fifo_size;
+	spin_lock_init(&fifo->lock);
+}
+
+/* TODO: Change all modulos to boolean arithmetic */
+inline int fifo_next_index(volatile struct fifo *fifo, int index)
+{
+	return (index + 1) & MSG_FIFO_MASK;
+}
+
+inline int fifo_next_head(volatile struct fifo *fifo)
+{
+	return (fifo->head + 1) & MSG_FIFO_MASK;
+}
+
+inline int fifo_next_tail(volatile struct fifo *fifo)
+{
+	return (fifo->tail + 1) & MSG_FIFO_MASK;
+}
+
+inline int fifo_empty(volatile struct fifo *fifo)
+{
+	return (fifo->head == fifo->tail);
+}
+
+static inline int fifo_full(volatile struct fifo *fifo)
+{
+	return (fifo_next_tail(fifo) == fifo->head);
+}
+
+static inline int fifo_count(volatile struct fifo *fifo)
+{
+	if (fifo->head <= fifo->tail)
+		return fifo->tail - fifo->head;
+	else
+		return (fifo->size - fifo->head) + fifo->tail;
+}
+
+static inline int fifo_dequeue(volatile struct fifo *fifo,
+				   struct msgring_msg_data *data)
+{
+	if (fifo_empty(fifo))
+		return 0;
+
+	*data = fifo->data[fifo->head];
+	fifo->head = fifo_next_head(fifo);
+
+	return 1;
+}
+
+static inline int fifo_enqueue(volatile struct fifo *fifo,
+				   struct msgring_msg_data *data)
+{
+	int cnt = 0;
+	while (fifo_full(fifo))
+		++cnt;
+	if (cnt > 10000)
+		PRINTK_ERR("%s:%d fifo queue full cnt=%d.\n", __func__,
+			   __LINE__, cnt);
+
+	fifo->data[fifo->tail] = *data;
+	fifo->tail = fifo_next_tail(fifo);
+
+	return 1;
+}
+
+#define PRINT_RMI_FIFO_DATA(p) do { \
+	PRINTK_INFO("%s:%d fifo=%p fifo size=%d head=%d tail=%d.\n", __func__, \
+		 __LINE__, p, p->size, p->head, p->tail); \
+} while(0)
+
+static struct fifo msg_fifos[MAX_MSG_FIFOS];
+
+#ifdef CONFIG_PHOENIX_MAC
+extern void rmi_phnx_rmios_msgring_handler(int bucket, int size, int code,
+					   int stid,
+					   struct msgrng_msg *msg,
+					   void *data /* ignored */ );
+#else				/* CONFIG_PHOENIX_MAC */
+void rmi_phnx_rmios_msgring_handler(int bucket, int size, int code,
+				    int stid, struct msgrng_msg *msg,
+				    void *data /* ignored */ )
+{
+}
+#endif				/* CONFIG_PHOENIX_MAC */
+extern void rmi_phnx_mac_msgring_handler(int bucket, int size, int code,
+					 int stid, struct msgrng_msg *msg,
+					 void *data /* ignored */ );
+static void rmi_phnx_syscall_msgring_handler(int bucket, int size,
+					     int code, int stid,
+					     struct msgrng_msg *msg,
+					     void *data /* ignored */ );
+
+void phnx_msgring_drv_int_handler(int bucket, int size, int code, int stid,
+				  struct msgrng_msg *msg,
+				  void *data /* ignored */ )
+{
+	volatile struct fifo *msg_fifo = 0;
+	struct msgring_msg_data msg_data;
+	int ret = 0;
+	int tx_stid = MAX_MSG_FIFOS;
+
+	if (stid < MSGRING_STNID_DEVICES)
+		tx_stid = stid >> 3;
+	else {
+		if (stid == 96)
+			tx_stid = 8 + (msg->msg1 & 0x0f);
+		else {
+			printk("[%s]: illegal tx_stid = %d, stid=%d\n",
+			       __func__, tx_stid, stid);
+			return;
+		}
+	}
+
+	msg_fifo = &msg_fifos[tx_stid];
+
+	msg_data.size = size;
+	msg_data.code = code;
+	msg_data.rx_bucket = bucket;
+	msg_data.stid = stid;
+	msg_data.msgs[0] = (msg->msg0 & 0xffffffff);
+	msg_data.msgs[1] = (msg->msg0 >> 32);
+	msg_data.msgs[2] = (msg->msg1 & 0xffffffff);
+	msg_data.msgs[3] = (msg->msg1 >> 32);
+	msg_data.msgs[4] = (msg->msg2 & 0xffffffff);
+	msg_data.msgs[5] = (msg->msg2 >> 32);
+	msg_data.msgs[6] = (msg->msg3 & 0xffffffff);
+	msg_data.msgs[7] = (msg->msg3 >> 32);
+
+	PRINTK_INFO("%s:%d adding message to txid=%d fifo:%p\n",
+		    __func__, __LINE__, tx_stid, msg_fifo);
+	spin_lock((spinlock_t *) (&msg_fifo->lock));
+	ret = fifo_enqueue(msg_fifo, &msg_data);
+	spin_unlock((spinlock_t *) (&msg_fifo->lock));
+
+	/* wake up any readers */
+	wake_up_interruptible((wait_queue_head_t *) & msg_fifo->wq);
+
+	if (!ret) {
+		PRINTK_ERR
+		    ("[%s]: Unable to queue message from %d tx_stid (stid=%d)\n",
+		     __func__, tx_stid, stid);
+	}
+
+}
+
+static int msgring_open(struct inode *inode, struct file *filp)
+{
+	filp->private_data = NULL;
+
+	return 0;
+}
+
+static DECLARE_WAIT_QUEUE_HEAD(msgring_read_wait);
+static DECLARE_WAIT_QUEUE_HEAD(msgring_write_wait);
+
+static unsigned int msgring_poll(struct file *filp,
+				 struct poll_table_struct *wait)
+{
+	unsigned int mask;
+	volatile struct fifo *msg_fifo = NULL;
+	int count = 0;
+	unsigned long flags;
+
+	if (!filp->private_data)
+		return -EINVAL;
+
+	msg_fifo = filp->private_data;
+
+	mask = 0;
+
+	spin_lock_irqsave((spinlock_t *) & msg_fifo->lock, flags);
+	count = fifo_count(msg_fifo);
+	spin_unlock_irqrestore((spinlock_t *) & msg_fifo->lock, flags);
+
+	if (!count) {
+		poll_wait(filp, (wait_queue_head_t *) & msg_fifo->wq,
+			  wait);
+
+		spin_lock_irqsave((spinlock_t *) & msg_fifo->lock, flags);
+		count = fifo_count(msg_fifo);
+		spin_unlock_irqrestore((spinlock_t *) & msg_fifo->lock,
+				       flags);
+	}
+	/* if there is data in the read buffer */
+	if (count > 0) {
+		PRINT_RMI_FIFO_DATA(msg_fifo);
+		mask |= POLLIN | POLLRDNORM;
+	} else {
+		PRINT_RMI_FIFO_DATA(msg_fifo);
+		PRINTK_INFO("%s:%d count=%d\n", __func__, __LINE__,
+			    count);
+	}
+
+	/* mark it writable always! */
+	mask |= POLLOUT | POLLWRNORM;
+
+	return mask;
+}
+
+/*
+ * offset: the offset in the file
+ * count : no of bytes to read
+ * buf   : start location (in user space) to which to copy the contents
+ * filp  : pointer to 'struct file'  of the file
+*/
+static ssize_t msgring_read(struct file *filp, char __user * buf,
+			    size_t count, loff_t * offset)
+{
+	volatile struct fifo *msg_fifo = NULL;
+	int msg_size = sizeof(struct msgring_msg_data);
+	struct msgring_msg_data msg;
+	int ret = 0;
+	unsigned long flags;
+
+	if (!filp->private_data)
+		return -EINVAL;
+
+	if (count < msg_size)
+		return -EINVAL;
+
+	msg_fifo = filp->private_data;
+
+	/*
+	 * we don't care about the passed file offset, but will update it
+	 * with the no of bytes read
+	*/
+retry:
+	spin_lock_irqsave((spinlock_t *) & msg_fifo->lock, flags);
+	ret = fifo_dequeue(msg_fifo, &msg);
+	spin_unlock_irqrestore((spinlock_t *) & msg_fifo->lock, flags);
+
+	if (!ret) {
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		if (wait_event_interruptible
+		    ((((struct fifo *) (msg_fifo))->wq),
+		     fifo_count(msg_fifo)))
+			return -ERESTARTSYS;
+		goto retry;
+	}
+
+	PRINTK_INFO("%s:%d reading message from fifo:%p\n", __func__,
+		    __LINE__, msg_fifo);
+	if (__copy_to_user(buf, &msg, count))
+		return -EFAULT;
+
+	filp->f_pos += count;
+	return count;
+}
+
+static ssize_t msgring_write(struct file *filp, const char __user * buf,
+			     size_t count, loff_t * off)
+{
+	struct msgring_msg_data *umsg_data = NULL;
+	int msg_size = sizeof(struct msgring_msg_data);
+	struct msgrng_msg msg;
+	int size = 0, code = 0, stid = 0;
+	unsigned long mflags = 0;
+	struct msgring_msg_data msg_data;
+
+	if (count < msg_size)
+		return -EINVAL;
+
+	umsg_data = (struct msgring_msg_data *) buf;
+
+	__copy_from_user(&size, &umsg_data->size, 4);
+	__copy_from_user(&code, &umsg_data->code, 4);
+	__copy_from_user(&stid, &umsg_data->stid, 4);
+
+	__copy_from_user(&msg_data.msgs[0], &umsg_data->msgs[0], 4);
+	__copy_from_user(&msg_data.msgs[1], &umsg_data->msgs[1], 4);
+	__copy_from_user(&msg_data.msgs[2], &umsg_data->msgs[2], 4);
+	__copy_from_user(&msg_data.msgs[3], &umsg_data->msgs[3], 4);
+	__copy_from_user(&msg_data.msgs[4], &umsg_data->msgs[4], 4);
+	__copy_from_user(&msg_data.msgs[5], &umsg_data->msgs[5], 4);
+	__copy_from_user(&msg_data.msgs[6], &umsg_data->msgs[6], 4);
+	__copy_from_user(&msg_data.msgs[7], &umsg_data->msgs[7], 4);
+
+	msg.msg0 =
+	    ((__u64) msg_data.msgs[1] << 32) | ((__u64) msg_data.msgs[0]);
+	msg.msg1 =
+	    ((__u64) msg_data.msgs[3] << 32) | ((__u64) msg_data.msgs[2]);
+	msg.msg2 =
+	    ((__u64) msg_data.msgs[5] << 32) | ((__u64) msg_data.msgs[4]);
+	msg.msg3 =
+	    ((__u64) msg_data.msgs[7] << 32) | ((__u64) msg_data.msgs[6]);
+
+	__sync();
+
+	msgrng_flags_save(mflags);
+
+	if (message_send_retry(size, code, stid, &msg)) {
+		printk("Failed to send message!\n");
+		msgrng_flags_restore(mflags);
+		return -EAGAIN;
+	}
+
+	msgrng_flags_restore(mflags);
+
+
+	return msg_size;
+}
+
+static int msgring_mmap_syscall(struct file *file,
+				struct vm_area_struct *vma)
+{
+	unsigned long addr = __pa(file->private_data);
+	unsigned long size = vma->vm_end - vma->vm_start;
+
+	if (vma->vm_flags & VM_LOCKED)
+		return -EPERM;
+	vma->vm_flags |= (VM_RESERVED | VM_IO);
+	if (remap_pfn_range
+	    (vma, vma->vm_start, (addr >> PAGE_SHIFT), size,
+	     vma->vm_page_prot))
+		return -EAGAIN;
+	return 0;
+}
+
+static int msgring_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long shm_addr = __pa(phoenix_psb_shm);
+	unsigned long shm_size = phoenix_psb_shm_size;
+	unsigned long size = 0;
+	unsigned long vm_size = vma->vm_end - vma->vm_start;
+
+	if (file->private_data != 0 &&
+	    ((char *) file->private_data < (char *) &msg_fifos[0] ||
+	     (char *) file->private_data >
+	     (char *) &msg_fifos[MAX_MSG_FIFOS]))
+		return msgring_mmap_syscall(file, vma);
+
+	if (vma->vm_start != (unsigned long) PHNX_USER_MAC_MMAP_VIRT_START)
+		return -EINVAL;
+
+	if (!shm_addr)
+		return -ENXIO;
+
+	if (offset >= shm_size)
+		return -ESPIPE;
+
+	if (vma->vm_flags & VM_LOCKED)
+		return -EPERM;
+
+	size = shm_size - offset;
+	if (vm_size > size)
+		return -ENOSPC;
+
+	vma->vm_flags |= (VM_RESERVED | VM_IO);
+
+	if (remap_pfn_range
+	    (vma, vma->vm_start, (shm_addr >> PAGE_SHIFT), size,
+	     vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+static DEFINE_PER_CPU(spinlock_t, msgring_lock) = SPIN_LOCK_UNLOCKED;
+static int cpu_spread[16];
+
+static int send_syscall(SYSCALL * syscall, int arg)
+{
+	struct msgrng_msg msg;
+	unsigned long mflags = 0;
+	int cpu, dst_stid, src_stid;
+	int ret;
+
+	cpu = hard_smp_processor_id();
+	src_stid = (((cpu >> 2) << 3) | (cpu & 0x3));
+	if (smp_boot.online_map == 0xff)
+		dst_stid =
+		    16 + src_stid + (((cpu_spread[cpu]++ % 3) & 0x3) << 4);
+	else if (smp_boot.online_map == 0xf) {
+		dst_stid = 8 + src_stid;
+	} else
+		dst_stid = 32 + src_stid;
+	msg.msg0 = (1ULL << 63) | ((uint64_t) src_stid << 40) |
+	    ((uint64_t) arg << 32) | (uint32_t) (unsigned long) syscall;
+	msg.msg1 = msg.msg2 = msg.msg3 = 0;
+	spin_lock(&__get_cpu_var(msgring_lock));
+	msgrng_flags_save(mflags);
+	ret = message_send_retry(1, 0, dst_stid, &msg);
+	msgrng_flags_restore(mflags);
+	spin_unlock(&__get_cpu_var(msgring_lock));
+
+	return ret;
+}
+
+static int msgring_ioctl(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg)
+{
+	unsigned long shm_vaddr = (unsigned long) phoenix_psb_shm;
+	/* assume it is in kseg0, for now */
+	unsigned long shm_paddr = __pa(phoenix_psb_shm);
+
+	switch (cmd) {
+
+	case MSGRING_IOC_SSTNNO: {
+			int tx_stn = arg;
+			if (tx_stn >= MAX_MSG_FIFOS) {
+				pr_err("[%s]: illegal tx stn id=%d\n",
+				       __func__, tx_stn);
+				return -EINVAL;
+			}
+			filp->private_data = &msg_fifos[tx_stn];
+			PRINTK_INFO
+			    ("%s:%d registering tx_stn=%d fifo=%p\n",
+			     __func__, __LINE__, tx_stn,
+			     filp->private_data);
+			msg_fifos[tx_stn].head = msg_fifos[tx_stn].tail =
+			    0;
+		} break;
+
+	case MSGRING_IOC_GSHMPHYS: {
+			*(unsigned int *) arg = shm_paddr;
+		} break;
+
+	case MSGRING_IOC_GSHMVIRT: {
+			*(unsigned int *) arg = shm_vaddr;
+		} break;
+
+	case MSGRING_IOC_GMMAP_START: {
+			*(unsigned int *) arg =
+			    (unsigned int) PHNX_USER_MAC_MMAP_VIRT_START;
+		} break;
+
+	case MSGRING_IOC_SYSINIT: {
+			/* allocate the socket interfacxe */
+			SYSCALL *syscall;
+
+			/* allocate the syscall interface */
+			syscall = kmalloc(arg, GFP_KERNEL);
+			if (!syscall) {
+				printk("syscall: no memory\n");
+				return -ENOMEM;
+			}
+			init_waitqueue_head(&syscall->sleep);
+			syscall->process = 0;
+			syscall->pid = current->pid;
+			filp->private_data = syscall;
+		} break;
+
+	case MSGRING_IOC_SYSPHYS:
+		*(unsigned int *) arg =
+		    (unsigned int) (unsigned long) filp->private_data;
+		break;
+
+	case MSGRING_IOC_SYSCALL: {
+			SYSCALL *syscall;
+			DEFINE_WAIT(wait);
+			int not_sent;
+
+			/* send a system call */
+			syscall = filp->private_data;
+			syscall->done = 0;
+			syscall->num++;
+			syscall->trace = 0;
+			not_sent = send_syscall(syscall, arg);
+
+			/* wait for the answer */
+			if (syscall->done) {
+				if (syscall->id == 10)	/*SYSCALL_memcpy */
+					return 100;
+				/* the system call was acknowledged */
+				break;
+			}
+
+			do {
+				prepare_to_wait(&syscall->sleep, &wait,
+						TASK_INTERRUPTIBLE);
+				schedule_timeout(1);
+				if (not_sent)
+					/* we have not yet sent the system call */
+					not_sent =
+					    send_syscall(syscall, arg);
+			} while (!signal_pending(current)
+				 && !syscall->done);
+			finish_wait(&syscall->sleep, &wait);
+			if (syscall->done) {
+				if (syscall->id == 10)	/* SYSCALL_memcpy */
+					return 100;
+
+				/*
+				 * the system call was acknowledged, stop, because rmios will not
+				 * reply to an interrupt when it is idle
+				*/
+				break;
+			}
+			if (not_sent)
+				/*
+				 * the system call was not sent and the process caught a signal,
+				 * stop, because rmios will not reply to an interrupt when it is
+				 * idle
+				*/
+				return -EINTR;
+			not_sent =
+			    send_syscall(syscall, SYSCALL_interrupt);
+			if (syscall->done)
+				/*
+				 * the interrupt was acknowledged wither by a system call response
+				 * or by an interrupt response
+				*/
+				return -EINTR;
+			do {
+				prepare_to_wait(&syscall->sleep, &wait,
+						TASK_UNINTERRUPTIBLE);
+				schedule_timeout(1);
+				if (not_sent)
+					/* we have not yet sent the interrupt */
+					not_sent =
+					    send_syscall(syscall,
+							 SYSCALL_interrupt);
+			} while (!syscall->done);
+			finish_wait(&syscall->sleep, &wait);
+			/*
+			 * the interrupt was acknowledged wither by a system call response
+			 * or by an interrupt response
+			*/
+			return -EINTR;
+		} break;
+
+	default:
+			pr_err("ioctl(): invalid command\n");
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static long msgring_compat_ioctl(struct file *filp, unsigned int cmd,
+				 unsigned long arg)
+{
+	unsigned long ret = -1;
+	lock_kernel();
+	ret = msgring_ioctl(NULL, filp, cmd, arg);
+	unlock_kernel();
+	if (ret) {
+		pr_err("msgring_ioctl returned with an error %lx", ret);
+		return -ENOIOCTLCMD;
+	}
+	return ret;
+}
+
+static void rmi_phnx_syscall_msgring_handler(int bucket, int size,
+					     int code, int stid,
+					     struct msgrng_msg *msg,
+					     void *data /* ignored */ )
+{
+	SYSCALL *syscall;
+	syscall = (SYSCALL *) (unsigned long) msg->msg0;
+	if (msg->msg0 & (1ULL << 62))
+		syscall->done = 2;
+	else
+		syscall->done = 1;
+	wake_up_interruptible(&syscall->sleep);
+}
+
+/* called only when the reference count (maintained in inode) is zero */
+static int msgring_release(struct inode *inode, struct file *filp)
+{
+	if (filp->private_data != 0 &&
+	    ((char *) filp->private_data < (char *) &msg_fifos[0] ||
+	     (char *) filp->private_data >
+	     (char *) &msg_fifos[MAX_MSG_FIFOS])) {
+		SYSCALL *syscall;
+		syscall = filp->private_data;
+		if (syscall->process) {
+			int sig =
+			    test_tsk_thread_flag(current, TIF_SIGPENDING);
+			if (sig)
+				clear_tsk_thread_flag(current,
+						      TIF_SIGPENDING);
+			msgring_ioctl(inode, filp, MSGRING_IOC_SYSCALL,
+				      SYSCALL_exit);
+			if (sig)
+				set_tsk_thread_flag(current,
+						    TIF_SIGPENDING);
+		}
+		kfree(filp->private_data);
+		filp->private_data = 0;
+	}
+	return 0;
+}
+
+static struct file_operations msgring_fops = {
+      .owner = THIS_MODULE,
+      .read = msgring_read,
+      .write = msgring_write,
+      .mmap = msgring_mmap,
+      .open = msgring_open,
+      .ioctl = msgring_ioctl,
+      .poll = msgring_poll,
+      .release = msgring_release,
+      .compat_ioctl = msgring_compat_ioctl,
+};
+
+/* msgring_init(): invoked as part of the kernel bootup process */
+static int msgring_init(void)
+{
+	int err;
+	int i = 0;
+
+	/* Intitialize 8 FIFO queues for each of the 8 cpu stations */
+	for (i = 0; i < MAX_MSG_FIFOS; ++i) {
+
+		fifo_init(&msg_fifos[i], MSG_FIFO_SIZE);
+		init_waitqueue_head(&msg_fifos[i].wq);
+
+		if (i > 7)
+			continue;
+
+		err =
+		    register_msgring_handler(TX_STN_CPU_0 + i,
+					     phnx_msgring_drv_int_handler,
+					     NULL);
+		if (err) {
+			/* should we panic or just return an error message */
+			panic
+			    ("In %s at line %d: unable to register handler for msgring stations for stn %d\n",
+			     __FILE__, __LINE__, i);
+		}
+	}
+
+	msgring_major =
+	    register_chrdev(XLR_MSGRING_SHM_MAJOR,
+			    PHNX_MSGRING_CHRDEV_NAME, &msgring_fops);
+	if (msgring_major < 0) {
+		printk("msgring_init() register_chrdev() failed\n");
+		return msgring_major;
+	}
+	msgring_major = XLR_MSGRING_SHM_MAJOR;
+	printk("Registered phoenix msgring driver: major=%d\n",
+	       msgring_major);
+
+	return 0;
+}
+
+static void msgring_exit(void)
+{
+	unregister_chrdev(msgring_major, PHNX_MSGRING_CHRDEV_NAME);
+}
+
+module_init(msgring_init);
+module_exit(msgring_exit);
diff --git a/drivers/char/phnx_msgring_debugger.c b/drivers/char/phnx_msgring_debugger.c
new file mode 100644
index 0000000..9899801
--- /dev/null
+++ b/drivers/char/phnx_msgring_debugger.c
@@ -0,0 +1,119 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+
+
+struct proc_dir_entry *msgring_debug;
+struct proc_dir_entry *msgring_dbglevel;
+
+static int initstatus;
+
+int msgring_debug_level = 3;
+EXPORT_SYMBOL(msgring_debug_level);
+extern struct proc_dir_entry *rmi_root_proc;
+
+#define MAX_DEBUG_LEVEL 128
+
+static int msgring_debug_read(char *page, char **start, off_t off,
+			      int count, int *eof, void *data)
+{
+	int ret = 0;
+	if (off > 0) {
+		*eof = 1;
+		return 0;
+	}
+
+	if (!initstatus)
+		ret = sprintf(page, "%d", msgring_debug_level);
+	return ret;
+}
+
+static int msgring_debug_write(struct file *filp, const char __user * buf,
+			       unsigned long count, void *data)
+{
+	int ret = 0;
+	int level = 0;
+	if (!initstatus) {
+		char scratch[10];
+		if (count < sizeof(scratch)) {
+			__copy_from_user(&scratch, buf, count);
+			scratch[count] = '\0';
+			level = simple_strtol(scratch, NULL, 0);
+			if (level < 0 || level > MAX_DEBUG_LEVEL) {
+				ret = -EINVAL;
+			} else {
+				msgring_debug_level = level;
+				ret = count;
+			}
+		} else {
+			ret = -ENOSPC;
+		}
+	}
+	return ret;
+}
+
+
+static int msgring_debug_init(void)
+{
+	msgring_debug = proc_mkdir("msgring_debug", rmi_root_proc);
+	if (!msgring_debug) {
+		printk(KERN_ERR "unable to create /proc/msgring_debug.\n");
+		initstatus = -ENOMEM;
+	}
+
+	if (!initstatus) {
+		msgring_dbglevel =
+		    create_proc_entry("level", 0644, msgring_debug);
+		if (!msgring_dbglevel) {
+			printk(KERN_ERR
+			       "unable to create proc entry: /proc/msgring_debug/level.\n");
+			initstatus = -ENOMEM;
+			remove_proc_entry("msgring_debug", rmi_root_proc);
+		} else {
+			msgring_dbglevel->read_proc = msgring_debug_read;
+			msgring_dbglevel->write_proc = msgring_debug_write;
+		}
+	}
+	return initstatus;
+}
+
+static void msgring_debug_exit(void)
+{
+	if (!initstatus) {
+		remove_proc_entry("level", msgring_debug);
+		remove_proc_entry("msgring_debug", rmi_root_proc);
+	}
+}
+
+module_init(msgring_debug_init);
+module_exit(msgring_debug_exit);
-- 
1.7.0.4

