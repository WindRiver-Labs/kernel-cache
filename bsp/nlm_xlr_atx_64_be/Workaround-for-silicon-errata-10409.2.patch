From 5f6287c969961e24e3e11660ea2b3c8b45c65834 Mon Sep 17 00:00:00 2001
From: Zhang Xiao <xiao.zhang@windriver.com>
Date: Fri, 22 Jul 2011 16:42:03 +0800
Subject: [PATCH] Workaround for silicon errata 10409.2

The XLR System (Memory) Bridge does not always handle simultaneous register
load (i.e., register read) accesses correctly. Port the workaround
from vendor's silicon errata 10409.2. It changes the use of rmi_bridge_lock
from a multiple reader/single writer lock to a true mutex. The old code did not
prevent simultaneous read access by multiple cores.

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 arch/mips/include/asm/rmi/iomap.h |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/mips/include/asm/rmi/iomap.h b/arch/mips/include/asm/rmi/iomap.h
index d695ee7..5fe598f 100644
--- a/arch/mips/include/asm/rmi/iomap.h
+++ b/arch/mips/include/asm/rmi/iomap.h
@@ -111,7 +111,7 @@ static inline uint32_t rmi_br_read_lock(void)
     uint32_t ret = 0;
 	if(rmi_enable_br_wrkaround){
          preempt_disable();
-		 ret = rmi_read_lock_irq_save(rmi_bridge_lock);
+		 ret = rmi_write_lock_irq_save(rmi_bridge_lock);
          preempt_enable();
     }
 	return ret;
@@ -120,7 +120,7 @@ static inline void rmi_br_read_unlock(unsigned int flags)
 {
 	if(rmi_enable_br_wrkaround){
         preempt_disable();
-		rmi_read_unlock_irq_restore(rmi_bridge_lock, flags);
+		rmi_write_unlock_irq_restore(rmi_bridge_lock, flags);
         preempt_enable();
     }
 }
-- 
1.7.0.4

