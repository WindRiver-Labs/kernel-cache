From 21c218c6b56b5baace15c47472c7d2304c3b3a8a Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Thu, 29 Aug 2013 15:31:00 +0800
Subject: [PATCH 20/66] mfd: add wcd9xxx mfd support

Extracted from git tree
git://codeaurora.org/quic/le/kernel/msm M9615AAAARNLZA1502277

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 drivers/mfd/Kconfig                           |   78 ++
 drivers/mfd/Makefile                          |    9 +
 drivers/mfd/pm8018-core.c                     |  674 +++++++++++
 drivers/mfd/pm8xxx-batt-alarm.c               |  806 ++++++++++++++
 drivers/mfd/pm8xxx-debug.c                    |  216 ++++
 drivers/mfd/pm8xxx-irq.c                      |  157 ++-
 drivers/mfd/pm8xxx-misc.c                     | 1256 +++++++++++++++++++++
 drivers/mfd/pm8xxx-pwm.c                      | 1471 +++++++++++++++++++++++++
 drivers/mfd/pm8xxx-spk.c                      |  303 +++++
 drivers/mfd/wcd9xxx-core.c                    | 1168 ++++++++++++++++++++
 drivers/mfd/wcd9xxx-irq.c                     |  307 +++++
 drivers/mfd/wcd9xxx-slimslave.c               |  583 ++++++++++
 include/linux/mfd/pm8xxx/batt-alarm.h         |  200 ++++
 include/linux/mfd/pm8xxx/ccadc.h              |   83 ++
 include/linux/mfd/pm8xxx/core.h               |   96 ++-
 include/linux/mfd/pm8xxx/gpio.h               |  162 +++
 include/linux/mfd/pm8xxx/irq.h                |   13 +-
 include/linux/mfd/pm8xxx/misc.h               |  284 +++++
 include/linux/mfd/pm8xxx/mpp.h                |  263 +++++
 include/linux/mfd/pm8xxx/nfc.h                |   79 ++
 include/linux/mfd/pm8xxx/pm8018.h             |   79 ++
 include/linux/mfd/pm8xxx/pm8038.h             |   89 ++
 include/linux/mfd/pm8xxx/pm8821-irq.h         |   45 +
 include/linux/mfd/pm8xxx/pm8821.h             |   48 +
 include/linux/mfd/pm8xxx/pm8921-bms.h         |  255 +++++
 include/linux/mfd/pm8xxx/pm8921-charger.h     |  358 ++++++
 include/linux/mfd/pm8xxx/pm8921.h             |  120 ++-
 include/linux/mfd/pm8xxx/pm8xxx-adc.h         |  604 ++++++++++
 include/linux/mfd/pm8xxx/pwm.h                |  169 +++
 include/linux/mfd/pm8xxx/regulator.h          |  271 +++++
 include/linux/mfd/pm8xxx/rtc.h                |    3 +-
 include/linux/mfd/pm8xxx/spk.h                |   55 +
 include/linux/mfd/pm8xxx/tm.h                 |   42 +
 include/linux/mfd/pm8xxx/upl.h                |   65 ++
 include/linux/mfd/pm8xxx/vibrator.h           |   39 +
 include/linux/mfd/pmic8058.h                  |  133 +++
 include/linux/mfd/pmic8901.h                  |   49 +
 include/linux/mfd/wcd9xxx/Kbuild              |    2 +
 include/linux/mfd/wcd9xxx/core.h              |  191 ++++
 include/linux/mfd/wcd9xxx/pdata.h             |  153 +++
 include/linux/mfd/wcd9xxx/wcd9304_registers.h |  807 ++++++++++++++
 include/linux/mfd/wcd9xxx/wcd9310_registers.h | 1117 +++++++++++++++++++
 include/linux/mfd/wcd9xxx/wcd9xxx-slimslave.h |  105 ++
 include/linux/mfd/wcd9xxx/wcd9xxx_registers.h |   42 +
 44 files changed, 12997 insertions(+), 52 deletions(-)
 create mode 100644 drivers/mfd/pm8018-core.c
 create mode 100644 drivers/mfd/pm8xxx-batt-alarm.c
 create mode 100644 drivers/mfd/pm8xxx-debug.c
 create mode 100644 drivers/mfd/pm8xxx-misc.c
 create mode 100644 drivers/mfd/pm8xxx-pwm.c
 create mode 100644 drivers/mfd/pm8xxx-spk.c
 create mode 100644 drivers/mfd/wcd9xxx-core.c
 create mode 100644 drivers/mfd/wcd9xxx-irq.c
 create mode 100644 drivers/mfd/wcd9xxx-slimslave.c
 create mode 100644 include/linux/mfd/pm8xxx/batt-alarm.h
 create mode 100644 include/linux/mfd/pm8xxx/ccadc.h
 create mode 100644 include/linux/mfd/pm8xxx/gpio.h
 create mode 100644 include/linux/mfd/pm8xxx/misc.h
 create mode 100644 include/linux/mfd/pm8xxx/mpp.h
 create mode 100644 include/linux/mfd/pm8xxx/nfc.h
 create mode 100644 include/linux/mfd/pm8xxx/pm8018.h
 create mode 100644 include/linux/mfd/pm8xxx/pm8038.h
 create mode 100644 include/linux/mfd/pm8xxx/pm8821-irq.h
 create mode 100644 include/linux/mfd/pm8xxx/pm8821.h
 create mode 100644 include/linux/mfd/pm8xxx/pm8921-bms.h
 create mode 100644 include/linux/mfd/pm8xxx/pm8921-charger.h
 create mode 100644 include/linux/mfd/pm8xxx/pm8xxx-adc.h
 create mode 100644 include/linux/mfd/pm8xxx/pwm.h
 create mode 100644 include/linux/mfd/pm8xxx/regulator.h
 create mode 100644 include/linux/mfd/pm8xxx/spk.h
 create mode 100644 include/linux/mfd/pm8xxx/tm.h
 create mode 100644 include/linux/mfd/pm8xxx/upl.h
 create mode 100644 include/linux/mfd/pm8xxx/vibrator.h
 create mode 100644 include/linux/mfd/pmic8058.h
 create mode 100644 include/linux/mfd/pmic8901.h
 create mode 100644 include/linux/mfd/wcd9xxx/Kbuild
 create mode 100644 include/linux/mfd/wcd9xxx/core.h
 create mode 100644 include/linux/mfd/wcd9xxx/pdata.h
 create mode 100644 include/linux/mfd/wcd9xxx/wcd9304_registers.h
 create mode 100644 include/linux/mfd/wcd9xxx/wcd9310_registers.h
 create mode 100644 include/linux/mfd/wcd9xxx/wcd9xxx-slimslave.h
 create mode 100644 include/linux/mfd/wcd9xxx/wcd9xxx_registers.h

diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 554ad25..21b0765 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -822,6 +822,20 @@ config MFD_PM8921_CORE
 	  Say M here if you want to include support for PM8921 chip as a module.
 	  This will build a module called "pm8921-core".
 
+config MFD_PM8018_CORE
+	tristate "Qualcomm PM8018 PMIC chip"
+	depends on MSM_SSBI
+	select MFD_CORE
+	select MFD_PM8XXX
+	help
+	  If you say yes to this option, support will be included for the
+	  built-in PM8018 PMIC chip.
+
+	  This is required if your board has a PM8018 and uses its features,
+	  such as: MPPs, GPIOs, regulators, interrupts, and PWM.
+
+	  Say M here if you want to include support for PM8018 chip as a module.
+	  This will build a module called "pm8018-core".
 config MFD_PM8XXX_IRQ
 	bool "Support for Qualcomm PM8xxx IRQ features"
 	depends on MFD_PM8XXX
@@ -832,6 +846,70 @@ config MFD_PM8XXX_IRQ
 	  This is required to use certain other PM 8xxx features, such as GPIO
 	  and MPP.
 
+config MFD_PM8XXX_DEBUG
+	tristate "Qualcomm PM8xxx debugfs support"
+	depends on MFD_PM8XXX && DEBUG_FS
+	default y if MFD_PM8XXX
+	help
+	  This driver provides a debugfs interface to the SSBI registers on
+	  Qualcomm PM 8xxx PMIC chips.  It allows for reads and writes to
+	  arbitrary addresses.  Writes are blocking so values are guaranteed to
+	  be set into hardware registers upon return.
+
+config MFD_PM8XXX_PWM
+	tristate "Support for Qualcomm PM8xxx PWM feature"
+	depends on MFD_PM8XXX
+	default y if MFD_PM8XXX
+	help
+	  This is the Pulse Width Modulation (PWM) driver for Qualcomm
+	  PM 8xxx PMIC chips. It can drive 8 channels of PWM output, and
+	  has a lookup table with size of 64 to be shared by any of the
+	  8 channels.
+
+config MFD_PM8XXX_MISC
+	tristate "Support for Qualcomm PM8xxx miscellaneous APIs"
+	depends on MFD_PM8XXX
+	default y if MFD_PM8XXX
+	help
+	  This driver implements several miscellaneous APIs that may be needed
+	  in order to control the PM8XXX PMIC chip.
+
+config MFD_PM8XXX_SPK
+	tristate "Support for Qualcomm PM8xxx speaker APIs"
+	depends on MFD_PM8XXX
+	help
+	  This driver implements several external speaker amplifier APIs that
+	  may be needed in order to control the PM8XXX PMIC chip.
+
+config MFD_PM8XXX_BATT_ALARM
+	tristate "Support for Qualcomm PM8xxx battery voltage alarm"
+	depends on MFD_PM8XXX
+	help
+	  This driver provides a means monitor battery under and over-voltage
+	  conditions.  An upper and/or lower threshold can be specified for
+	  normal operation.  A wakeable interrupt is triggered when the battery
+	  voltage leaves the accepatable range which then calls a notifier call
+	  chain.
+
+config WCD9304_CODEC
+        tristate "WCD9304 Codec"
+        select SLIMBUS
+        select MFD_CORE
+        default n
+        help
+          Enables the WCD9304 core driver. The core driver provides
+          read/write capability to registers which are part of the
+          WCD9304 core and gives the ability to use the WCD9304 codec.
+
+config WCD9310_CODEC
+        tristate "WCD9310 Codec"
+        select SLIMBUS
+        select MFD_CORE
+        default n
+        help
+          Enables the WCD9310 core driver. The core driver provides
+          read/write capability to registers which are part of the
+          WCD9310 core and gives the ability to use the WCD9310 codec.
 config TPS65911_COMPARATOR
 	tristate
 
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 53b594b..b933922 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -64,6 +64,9 @@ obj-$(CONFIG_MCP_SA11X0)	+= mcp-sa11x0.o
 obj-$(CONFIG_MCP_UCB1200)	+= ucb1x00-core.o
 obj-$(CONFIG_MCP_UCB1200_TS)	+= ucb1x00-ts.o
 
+obj-$(CONFIG_WCD9310_CODEC)       += wcd9xxx-core.o wcd9xxx-irq.o wcd9xxx-slimslave.o
+obj-$(CONFIG_WCD9304_CODEC)       += wcd9xxx-core.o wcd9xxx-irq.o wcd9xxx-slimslave.o
+
 ifeq ($(CONFIG_SA1100_ASSABET),y)
 obj-$(CONFIG_MCP_UCB1200)	+= ucb1x00-assabet.o
 endif
@@ -108,7 +111,13 @@ obj-$(CONFIG_MFD_WL1273_CORE)	+= wl1273-core.o
 obj-$(CONFIG_MFD_CS5535)	+= cs5535-mfd.o
 obj-$(CONFIG_MFD_OMAP_USB_HOST)	+= omap-usb-host.o
 obj-$(CONFIG_MFD_PM8921_CORE) 	+= pm8921-core.o
+obj-$(CONFIG_MFD_PM8018_CORE) 	+= pm8018-core.o
 obj-$(CONFIG_MFD_PM8XXX_IRQ) 	+= pm8xxx-irq.o
+obj-$(CONFIG_MFD_PM8XXX_DEBUG) 	+= pm8xxx-debug.o
+obj-$(CONFIG_MFD_PM8XXX_PWM) 	+= pm8xxx-pwm.o
+obj-$(CONFIG_MFD_PM8XXX_MISC) 	+= pm8xxx-misc.o
+obj-$(CONFIG_MFD_PM8XXX_SPK) 	+= pm8xxx-spk.o
+obj-$(CONFIG_MFD_PM8XXX_BATT_ALARM) 	+= pm8xxx-batt-alarm.o
 obj-$(CONFIG_TPS65911_COMPARATOR)	+= tps65911-comparator.o
 obj-$(CONFIG_MFD_TPS65090)	+= tps65090.o
 obj-$(CONFIG_MFD_AAT2870_CORE)	+= aat2870-core.o
diff --git a/drivers/mfd/pm8018-core.c b/drivers/mfd/pm8018-core.c
new file mode 100644
index 0000000..31cb2a2
--- /dev/null
+++ b/drivers/mfd/pm8018-core.c
@@ -0,0 +1,674 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/err.h>
+#include <linux/msm_ssbi.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/pm8xxx/pm8018.h>
+#include <linux/mfd/pm8xxx/core.h>
+#include <linux/mfd/pm8xxx/regulator.h>
+#include <linux/leds-pm8xxx.h>
+
+
+/* PMIC PM8018 SSBI Addresses */
+#define REG_HWREV		0x002  /* PMIC4 revision */
+#define REG_HWREV_2		0x0E8  /* PMIC4 revision 2 */
+
+#define REG_MPP_BASE		0x050
+#define REG_IRQ_BASE		0x1BB
+
+#define REG_RTC_BASE		0x11D
+
+#define REG_TEMP_ALARM_CTRL	0x01B
+#define REG_TEMP_ALARM_PWM	0x09B
+
+
+#define PM8018_VERSION_MASK	0xFFF0
+#define PM8018_VERSION_VALUE	0x08F0
+#define PM8018_REVISION_MASK	0x000F
+
+#define REG_PM8018_PON_CNTRL_3	0x01D
+#define PM8018_RESTART_REASON_MASK	0x07
+
+#define SINGLE_IRQ_RESOURCE(_name, _irq) \
+{ \
+	.name	= _name, \
+	.start	= _irq, \
+	.end	= _irq, \
+	.flags	= IORESOURCE_IRQ, \
+}
+
+struct pm8018 {
+	struct device					*dev;
+	struct pm_irq_chip				*irq_chip;
+	struct mfd_cell					*mfd_regulators;
+	struct pm8xxx_regulator_core_platform_data	*regulator_cdata;
+	u32						rev_registers;
+};
+
+static int pm8018_readb(const struct device *dev, u16 addr, u8 *val)
+{
+	const struct pm8xxx_drvdata *pm8018_drvdata = dev_get_drvdata(dev);
+	const struct pm8018 *pmic = pm8018_drvdata->pm_chip_data;
+
+	return msm_ssbi_read(pmic->dev->parent, addr, val, 1);
+}
+
+static int pm8018_writeb(const struct device *dev, u16 addr, u8 val)
+{
+	const struct pm8xxx_drvdata *pm8018_drvdata = dev_get_drvdata(dev);
+	const struct pm8018 *pmic = pm8018_drvdata->pm_chip_data;
+
+	return msm_ssbi_write(pmic->dev->parent, addr, &val, 1);
+}
+
+static int pm8018_read_buf(const struct device *dev, u16 addr, u8 *buf,
+									int cnt)
+{
+	const struct pm8xxx_drvdata *pm8018_drvdata = dev_get_drvdata(dev);
+	const struct pm8018 *pmic = pm8018_drvdata->pm_chip_data;
+
+	return msm_ssbi_read(pmic->dev->parent, addr, buf, cnt);
+}
+
+static int pm8018_write_buf(const struct device *dev, u16 addr, u8 *buf,
+									int cnt)
+{
+	const struct pm8xxx_drvdata *pm8018_drvdata = dev_get_drvdata(dev);
+	const struct pm8018 *pmic = pm8018_drvdata->pm_chip_data;
+
+	return msm_ssbi_write(pmic->dev->parent, addr, buf, cnt);
+}
+
+static int pm8018_read_irq_stat(const struct device *dev, int irq)
+{
+	const struct pm8xxx_drvdata *pm8018_drvdata = dev_get_drvdata(dev);
+	const struct pm8018 *pmic = pm8018_drvdata->pm_chip_data;
+
+	return pm8xxx_get_irq_stat(pmic->irq_chip, irq);
+}
+
+static enum pm8xxx_version pm8018_get_version(const struct device *dev)
+{
+	const struct pm8xxx_drvdata *pm8018_drvdata = dev_get_drvdata(dev);
+	const struct pm8018 *pmic = pm8018_drvdata->pm_chip_data;
+	enum pm8xxx_version version = -ENODEV;
+
+	if ((pmic->rev_registers & PM8018_VERSION_MASK) == PM8018_VERSION_VALUE)
+		version = PM8XXX_VERSION_8018;
+
+	return version;
+}
+
+static int pm8018_get_revision(const struct device *dev)
+{
+	const struct pm8xxx_drvdata *pm8018_drvdata = dev_get_drvdata(dev);
+	const struct pm8018 *pmic = pm8018_drvdata->pm_chip_data;
+
+	return pmic->rev_registers & PM8018_REVISION_MASK;
+}
+
+static struct pm8xxx_drvdata pm8018_drvdata = {
+	.pmic_readb		= pm8018_readb,
+	.pmic_writeb		= pm8018_writeb,
+	.pmic_read_buf		= pm8018_read_buf,
+	.pmic_write_buf		= pm8018_write_buf,
+	.pmic_read_irq_stat	= pm8018_read_irq_stat,
+	.pmic_get_version	= pm8018_get_version,
+	.pmic_get_revision	= pm8018_get_revision,
+};
+
+static const struct resource gpio_cell_resources[] __devinitconst = {
+	[0] = {
+		.start = PM8018_IRQ_BLOCK_BIT(PM8018_GPIO_BLOCK_START, 0),
+		.end   = PM8018_IRQ_BLOCK_BIT(PM8018_GPIO_BLOCK_START, 0)
+			+ PM8018_NR_GPIOS - 1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct mfd_cell gpio_cell __devinitdata = {
+	.name		= PM8XXX_GPIO_DEV_NAME,
+	.id		= -1,
+	.resources	= gpio_cell_resources,
+	.num_resources	= ARRAY_SIZE(gpio_cell_resources),
+};
+
+static const struct resource adc_cell_resources[] __devinitconst = {
+	SINGLE_IRQ_RESOURCE(NULL, PM8018_ADC_EOC_USR_IRQ),
+	SINGLE_IRQ_RESOURCE(NULL, PM8018_ADC_BATT_TEMP_WARM_IRQ),
+	SINGLE_IRQ_RESOURCE(NULL, PM8018_ADC_BATT_TEMP_COLD_IRQ),
+};
+
+static struct mfd_cell adc_cell __devinitdata = {
+	.name		= PM8XXX_ADC_DEV_NAME,
+	.id		= -1,
+	.resources	= adc_cell_resources,
+	.num_resources	= ARRAY_SIZE(adc_cell_resources),
+};
+
+static const struct resource mpp_cell_resources[] __devinitconst = {
+	{
+		.start	= PM8018_IRQ_BLOCK_BIT(PM8018_MPP_BLOCK_START, 0),
+		.end	= PM8018_IRQ_BLOCK_BIT(PM8018_MPP_BLOCK_START, 0)
+			  + PM8018_NR_MPPS - 1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mfd_cell mpp_cell __devinitdata = {
+	.name		= PM8XXX_MPP_DEV_NAME,
+	.id		= -1,
+	.resources	= mpp_cell_resources,
+	.num_resources	= ARRAY_SIZE(mpp_cell_resources),
+};
+
+static const struct resource rtc_cell_resources[] __devinitconst = {
+	[0] = SINGLE_IRQ_RESOURCE(NULL, PM8018_RTC_ALARM_IRQ),
+	[1] = {
+		.name   = "pmic_rtc_base",
+		.start  = REG_RTC_BASE,
+		.end    = REG_RTC_BASE,
+		.flags  = IORESOURCE_IO,
+	},
+};
+
+static struct mfd_cell rtc_cell __devinitdata = {
+	.name           = PM8XXX_RTC_DEV_NAME,
+	.id             = -1,
+	.resources      = rtc_cell_resources,
+	.num_resources  = ARRAY_SIZE(rtc_cell_resources),
+};
+
+static const struct resource resources_pwrkey[] __devinitconst = {
+	SINGLE_IRQ_RESOURCE(NULL, PM8018_PWRKEY_REL_IRQ),
+	SINGLE_IRQ_RESOURCE(NULL, PM8018_PWRKEY_PRESS_IRQ),
+};
+
+static struct mfd_cell pwrkey_cell __devinitdata = {
+	.name		= PM8XXX_PWRKEY_DEV_NAME,
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(resources_pwrkey),
+	.resources	= resources_pwrkey,
+};
+
+static struct mfd_cell misc_cell __devinitdata = {
+	.name           = PM8XXX_MISC_DEV_NAME,
+	.id             = -1,
+};
+
+static struct mfd_cell debugfs_cell __devinitdata = {
+	.name		= "pm8xxx-debug",
+	.id		= -1,
+	.platform_data	= "pm8018-dbg",
+	.pdata_size	= sizeof("pm8018-dbg"),
+};
+
+static struct mfd_cell pwm_cell __devinitdata = {
+	.name           = PM8XXX_PWM_DEV_NAME,
+	.id             = -1,
+};
+
+static struct mfd_cell leds_cell __devinitdata = {
+	.name		= PM8XXX_LEDS_DEV_NAME,
+	.id		= -1,
+};
+
+static const struct resource thermal_alarm_cell_resources[] __devinitconst = {
+	SINGLE_IRQ_RESOURCE("pm8018_tempstat_irq", PM8018_TEMPSTAT_IRQ),
+	SINGLE_IRQ_RESOURCE("pm8018_overtemp_irq", PM8018_OVERTEMP_IRQ),
+};
+
+static struct pm8xxx_tm_core_data thermal_alarm_cdata = {
+	.adc_channel =			CHANNEL_DIE_TEMP,
+	.adc_type =			PM8XXX_TM_ADC_PM8XXX_ADC,
+	.reg_addr_temp_alarm_ctrl =	REG_TEMP_ALARM_CTRL,
+	.reg_addr_temp_alarm_pwm =	REG_TEMP_ALARM_PWM,
+	.tm_name =			"pm8018_tz",
+	.irq_name_temp_stat =		"pm8018_tempstat_irq",
+	.irq_name_over_temp =		"pm8018_overtemp_irq",
+};
+
+static struct mfd_cell thermal_alarm_cell __devinitdata = {
+	.name		= PM8XXX_TM_DEV_NAME,
+	.id		= -1,
+	.resources	= thermal_alarm_cell_resources,
+	.num_resources	= ARRAY_SIZE(thermal_alarm_cell_resources),
+	.platform_data	= &thermal_alarm_cdata,
+	.pdata_size	= sizeof(struct pm8xxx_tm_core_data),
+};
+
+static struct pm8xxx_vreg regulator_data[] = {
+	/*   name	     pc_name	    ctrl   test   hpm_min */
+	PLDO("8018_l2",      "8018_l2_pc",  0x0B0, 0x0B1, LDO_50),
+	PLDO("8018_l3",      "8018_l3_pc",  0x0B2, 0x0B3, LDO_50),
+	PLDO("8018_l4",      "8018_l4_pc",  0x0B4, 0x0B5, LDO_300),
+	PLDO("8018_l5",      "8018_l5_pc",  0x0B6, 0x0B7, LDO_150),
+	PLDO("8018_l6",      "8018_l6_pc",  0x0B8, 0x0B9, LDO_150),
+	PLDO("8018_l7",      "8018_l7_pc",  0x0BA, 0x0BB, LDO_300),
+	NLDO("8018_l8",      "8018_l8_pc",  0x0BC, 0x0BD, LDO_150),
+	NLDO1200("8018_l9",		    0x0BE, 0x0BF, LDO_1200),
+	NLDO1200("8018_l10",		    0x0C0, 0x0C1, LDO_1200),
+	NLDO1200("8018_l11",		    0x0C2, 0x0C3, LDO_1200),
+	NLDO1200("8018_l12",		    0x0C4, 0x0C5, LDO_1200),
+	PLDO("8018_l13",     "8018_l13_pc", 0x0C8, 0x0C9, LDO_50),
+	PLDO("8018_l14",     "8018_l14_pc", 0x0CA, 0x0CB, LDO_50),
+
+	/*   name	pc_name       ctrl   test2  clk    sleep  hpm_min */
+	SMPS("8018_s1", "8018_s1_pc", 0x1D0, 0x1D5, 0x009, 0x1D2, SMPS_1500),
+	SMPS("8018_s2", "8018_s2_pc", 0x1D8, 0x1DD, 0x00A, 0x1DA, SMPS_1500),
+	SMPS("8018_s3", "8018_s3_pc", 0x1E0, 0x1E5, 0x00B, 0x1E2, SMPS_1500),
+	SMPS("8018_s4", "8018_s4_pc", 0x1E8, 0x1ED, 0x00C, 0x1EA, SMPS_1500),
+	SMPS("8018_s5", "8018_s5_pc", 0x1F0, 0x1F5, 0x00D, 0x1F2, SMPS_1500),
+
+	/* name		     pc_name	     ctrl   test */
+	VS("8018_lvs1",      "8018_lvs1_pc", 0x060, 0x061),
+};
+
+#define MAX_NAME_COMPARISON_LEN 32
+
+static int __devinit match_regulator(
+	struct pm8xxx_regulator_core_platform_data *core_data, const char *name)
+{
+	int found = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(regulator_data); i++) {
+		if (regulator_data[i].rdesc.name
+		    && strncmp(regulator_data[i].rdesc.name, name,
+				MAX_NAME_COMPARISON_LEN) == 0) {
+			core_data->is_pin_controlled = false;
+			core_data->vreg = &regulator_data[i];
+			found = 1;
+			break;
+		} else if (regulator_data[i].rdesc_pc.name
+			   && strncmp(regulator_data[i].rdesc_pc.name, name,
+				MAX_NAME_COMPARISON_LEN) == 0) {
+			core_data->is_pin_controlled = true;
+			core_data->vreg = &regulator_data[i];
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		pr_err("could not find a match for regulator: %s\n", name);
+
+	return found;
+}
+
+static int __devinit
+pm8018_add_regulators(const struct pm8018_platform_data *pdata,
+		      struct pm8018 *pmic, int irq_base)
+{
+	int ret = 0;
+	struct mfd_cell *mfd_regulators;
+	struct pm8xxx_regulator_core_platform_data *cdata;
+	int i;
+
+	/* Add one device for each regulator used by the board. */
+	mfd_regulators = kzalloc(sizeof(struct mfd_cell)
+				 * (pdata->num_regulators), GFP_KERNEL);
+	if (!mfd_regulators) {
+		pr_err("Cannot allocate %d bytes for pm8018 regulator "
+			"mfd cells\n", sizeof(struct mfd_cell)
+					* (pdata->num_regulators));
+		return -ENOMEM;
+	}
+	cdata = kzalloc(sizeof(struct pm8xxx_regulator_core_platform_data)
+			* pdata->num_regulators, GFP_KERNEL);
+	if (!cdata) {
+		pr_err("Cannot allocate %d bytes for pm8018 regulator "
+			"core data\n", pdata->num_regulators
+			  * sizeof(struct pm8xxx_regulator_core_platform_data));
+		kfree(mfd_regulators);
+		return -ENOMEM;
+	}
+	for (i = 0; i < ARRAY_SIZE(regulator_data); i++)
+		mutex_init(&regulator_data[i].pc_lock);
+
+	for (i = 0; i < pdata->num_regulators; i++) {
+		if (!pdata->regulator_pdatas[i].init_data.constraints.name) {
+			pr_err("name missing for regulator %d\n", i);
+			ret = -EINVAL;
+			goto bail;
+		}
+		if (!match_regulator(&cdata[i],
+		      pdata->regulator_pdatas[i].init_data.constraints.name)) {
+			ret = -ENODEV;
+			goto bail;
+		}
+		cdata[i].pdata = &(pdata->regulator_pdatas[i]);
+		mfd_regulators[i].name = PM8XXX_REGULATOR_DEV_NAME;
+		mfd_regulators[i].id = cdata[i].pdata->id;
+		mfd_regulators[i].platform_data = &cdata[i];
+		mfd_regulators[i].pdata_size =
+			sizeof(struct pm8xxx_regulator_core_platform_data);
+	}
+	ret = mfd_add_devices(pmic->dev, 0, mfd_regulators,
+			pdata->num_regulators, NULL, irq_base);
+	if (ret)
+		goto bail;
+
+	pmic->mfd_regulators = mfd_regulators;
+	pmic->regulator_cdata = cdata;
+	return ret;
+
+bail:
+	for (i = 0; i < ARRAY_SIZE(regulator_data); i++)
+		mutex_destroy(&regulator_data[i].pc_lock);
+	kfree(mfd_regulators);
+	kfree(cdata);
+	return ret;
+}
+
+static int __devinit
+pm8018_add_subdevices(const struct pm8018_platform_data *pdata,
+		      struct pm8018 *pmic)
+{
+	int ret = 0, irq_base = 0;
+	struct pm_irq_chip *irq_chip;
+
+	if (pdata->irq_pdata) {
+		pdata->irq_pdata->irq_cdata.nirqs = PM8018_NR_IRQS;
+		pdata->irq_pdata->irq_cdata.base_addr = REG_IRQ_BASE;
+		irq_base = pdata->irq_pdata->irq_base;
+		irq_chip = pm8xxx_irq_init(pmic->dev, pdata->irq_pdata);
+
+		if (IS_ERR(irq_chip)) {
+			pr_err("Failed to init interrupts ret=%ld\n",
+					PTR_ERR(irq_chip));
+			return PTR_ERR(irq_chip);
+		}
+		pmic->irq_chip = irq_chip;
+	}
+
+	if (pdata->gpio_pdata) {
+		pdata->gpio_pdata->gpio_cdata.ngpios = PM8018_NR_GPIOS;
+		gpio_cell.platform_data = pdata->gpio_pdata;
+		gpio_cell.pdata_size = sizeof(struct pm8xxx_gpio_platform_data);
+		ret = mfd_add_devices(pmic->dev, 0, &gpio_cell, 1,
+					NULL, irq_base);
+		if (ret) {
+			pr_err("Failed to add  gpio subdevice ret=%d\n", ret);
+			goto bail;
+		}
+	}
+
+	if (pdata->mpp_pdata) {
+		pdata->mpp_pdata->core_data.nmpps = PM8018_NR_MPPS;
+		pdata->mpp_pdata->core_data.base_addr = REG_MPP_BASE;
+		mpp_cell.platform_data = pdata->mpp_pdata;
+		mpp_cell.pdata_size = sizeof(struct pm8xxx_mpp_platform_data);
+		ret = mfd_add_devices(pmic->dev, 0, &mpp_cell, 1, NULL,
+					irq_base);
+		if (ret) {
+			pr_err("Failed to add mpp subdevice ret=%d\n", ret);
+			goto bail;
+		}
+	}
+
+	if (pdata->rtc_pdata) {
+		rtc_cell.platform_data = pdata->rtc_pdata;
+		rtc_cell.pdata_size = sizeof(struct pm8xxx_rtc_platform_data);
+		ret = mfd_add_devices(pmic->dev, 0, &rtc_cell, 1, NULL,
+				irq_base);
+		if (ret) {
+			pr_err("Failed to add rtc subdevice ret=%d\n", ret);
+			goto bail;
+		}
+	}
+
+	if (pdata->pwrkey_pdata) {
+		pwrkey_cell.platform_data = pdata->pwrkey_pdata;
+		pwrkey_cell.pdata_size =
+			sizeof(struct pm8xxx_pwrkey_platform_data);
+		ret = mfd_add_devices(pmic->dev, 0, &pwrkey_cell, 1, NULL,
+					irq_base);
+		if (ret) {
+			pr_err("Failed to add pwrkey subdevice ret=%d\n", ret);
+			goto bail;
+		}
+	}
+
+	if (pdata->misc_pdata) {
+		misc_cell.platform_data = pdata->misc_pdata;
+		misc_cell.pdata_size = sizeof(struct pm8xxx_misc_platform_data);
+		ret = mfd_add_devices(pmic->dev, 0, &misc_cell, 1, NULL,
+				      irq_base);
+		if (ret) {
+			pr_err("Failed to add  misc subdevice ret=%d\n", ret);
+			goto bail;
+		}
+	}
+
+	if (pdata->adc_pdata) {
+		adc_cell.platform_data = pdata->adc_pdata;
+		adc_cell.pdata_size = sizeof(struct pm8xxx_adc_platform_data);
+		ret = mfd_add_devices(pmic->dev, 0, &adc_cell, 1, NULL,
+				      irq_base);
+		if (ret) {
+			pr_err("Failed to add adc subdevice ret=%d\n", ret);
+		}
+	}
+
+	if (pdata->leds_pdata) {
+		leds_cell.platform_data = pdata->leds_pdata;
+		leds_cell.pdata_size = sizeof(struct pm8xxx_led_platform_data);
+		ret = mfd_add_devices(pmic->dev, 0, &leds_cell, 1, NULL, 0);
+		if (ret) {
+			pr_err("Failed to add leds subdevice ret=%d\n", ret);
+			goto bail;
+		}
+	}
+
+	ret = mfd_add_devices(pmic->dev, 0, &debugfs_cell, 1, NULL, irq_base);
+	if (ret) {
+		pr_err("Failed to add debugfs subdevice ret=%d\n", ret);
+		goto bail;
+	}
+
+	ret = mfd_add_devices(pmic->dev, 0, &pwm_cell, 1, NULL, 0);
+	if (ret) {
+		pr_err("Failed to add pwm subdevice ret=%d\n", ret);
+		goto bail;
+	}
+
+	if (pdata->num_regulators > 0 && pdata->regulator_pdatas) {
+		ret = pm8018_add_regulators(pdata, pmic, irq_base);
+		if (ret) {
+			pr_err("Failed to add regulator subdevices ret=%d\n",
+				ret);
+			goto bail;
+		}
+	}
+
+	ret = mfd_add_devices(pmic->dev, 0, &thermal_alarm_cell, 1, NULL,
+				irq_base);
+	if (ret) {
+		pr_err("Failed to add thermal alarm subdevice, ret=%d\n", ret);
+		goto bail;
+	}
+
+	return 0;
+bail:
+	if (pmic->irq_chip) {
+		pm8xxx_irq_exit(pmic->irq_chip);
+		pmic->irq_chip = NULL;
+	}
+	return ret;
+}
+
+static const char * const pm8018_restart_reason[] = {
+	[0] = "Unknown",
+	[1] = "Triggered from CBL (external charger)",
+	[2] = "Triggered from KPD (power key press)",
+	[3] = "Triggered from CHG (usb charger insertion)",
+	[4] = "Triggered from SMPL (sudden momentary power loss)",
+	[5] = "Triggered from RTC (real time clock)",
+	[6] = "Triggered by Hard Reset",
+	[7] = "Triggered by General Purpose Trigger",
+};
+
+static const char * const pm8018_rev_names[] = {
+	[PM8XXX_REVISION_8018_TEST]	= "test",
+	[PM8XXX_REVISION_8018_1p0]	= "1.0",
+	[PM8XXX_REVISION_8018_2p0]	= "2.0",
+	[PM8XXX_REVISION_8018_2p1]	= "2.1",
+};
+
+static int __devinit pm8018_probe(struct platform_device *pdev)
+{
+	const struct pm8018_platform_data *pdata = pdev->dev.platform_data;
+	const char *revision_name = "unknown";
+	struct pm8018 *pmic;
+	enum pm8xxx_version version;
+	int revision;
+	int rc;
+	u8 val;
+
+	if (!pdata) {
+		pr_err("missing platform data\n");
+		return -EINVAL;
+	}
+
+	pmic = kzalloc(sizeof(struct pm8018), GFP_KERNEL);
+	if (!pmic) {
+		pr_err("Cannot alloc pm8018 struct\n");
+		return -ENOMEM;
+	}
+
+	/* Read PMIC chip revision */
+	rc = msm_ssbi_read(pdev->dev.parent, REG_HWREV, &val, sizeof(val));
+	if (rc) {
+		pr_err("Failed to read hw rev 1 reg %d:rc=%d\n", REG_HWREV, rc);
+		goto err_read_rev;
+	}
+	pr_info("PMIC revision 1: %02X\n", val);
+	pmic->rev_registers = val;
+
+	/* Read PMIC chip revision 2 */
+	rc = msm_ssbi_read(pdev->dev.parent, REG_HWREV_2, &val, sizeof(val));
+	if (rc) {
+		pr_err("Failed to read hw rev 2 reg %d:rc=%d\n", REG_HWREV_2,
+			rc);
+		goto err_read_rev;
+	}
+	pr_info("PMIC revision 2: %02X\n", val);
+	pmic->rev_registers |= val << BITS_PER_BYTE;
+
+	pmic->dev = &pdev->dev;
+	pm8018_drvdata.pm_chip_data = pmic;
+	platform_set_drvdata(pdev, &pm8018_drvdata);
+
+	/* Print out human readable version and revision names. */
+	version = pm8xxx_get_version(pmic->dev);
+	if (version == PM8XXX_VERSION_8018) {
+		revision = pm8xxx_get_revision(pmic->dev);
+		if (revision >= 0 && revision < ARRAY_SIZE(pm8018_rev_names))
+			revision_name = pm8018_rev_names[revision];
+		pr_info("PMIC version: PM8018 rev %s\n", revision_name);
+	} else {
+		WARN_ON(version != PM8XXX_VERSION_8018);
+	}
+	/* Log human readable restart reason */
+	rc = msm_ssbi_read(pdev->dev.parent, REG_PM8018_PON_CNTRL_3, &val, 1);
+	if (rc) {
+		pr_err("Cannot read restart reason rc=%d\n", rc);
+		goto err_read_rev;
+	}
+	val &= PM8018_RESTART_REASON_MASK;
+	pr_info("PMIC Restart Reason: %s\n", pm8018_restart_reason[val]);
+
+	rc = pm8018_add_subdevices(pdata, pmic);
+	if (rc) {
+		pr_err("Cannot add subdevices rc=%d\n", rc);
+		goto err;
+	}
+
+	/* gpio might not work if no irq device is found */
+	WARN_ON(pmic->irq_chip == NULL);
+
+	return 0;
+
+err:
+	mfd_remove_devices(pmic->dev);
+	platform_set_drvdata(pdev, NULL);
+	kfree(pmic->mfd_regulators);
+	kfree(pmic->regulator_cdata);
+err_read_rev:
+	kfree(pmic);
+	return rc;
+}
+
+static int __devexit pm8018_remove(struct platform_device *pdev)
+{
+	struct pm8xxx_drvdata *drvdata;
+	struct pm8018 *pmic = NULL;
+	int i;
+
+	drvdata = platform_get_drvdata(pdev);
+	if (drvdata)
+		pmic = drvdata->pm_chip_data;
+	if (pmic) {
+		if (pmic->dev)
+			mfd_remove_devices(pmic->dev);
+		if (pmic->irq_chip) {
+			pm8xxx_irq_exit(pmic->irq_chip);
+			pmic->irq_chip = NULL;
+		}
+		if (pmic->mfd_regulators) {
+			for (i = 0; i < ARRAY_SIZE(regulator_data); i++)
+				mutex_destroy(&regulator_data[i].pc_lock);
+		}
+		kfree(pmic->mfd_regulators);
+		kfree(pmic->regulator_cdata);
+		kfree(pmic);
+	}
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver pm8018_driver = {
+	.probe		= pm8018_probe,
+	.remove		= __devexit_p(pm8018_remove),
+	.driver		= {
+		.name	= PM8018_CORE_DEV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init pm8018_init(void)
+{
+	return platform_driver_register(&pm8018_driver);
+}
+postcore_initcall(pm8018_init);
+
+static void __exit pm8018_exit(void)
+{
+	platform_driver_unregister(&pm8018_driver);
+}
+module_exit(pm8018_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("PMIC 8018 core driver");
+MODULE_VERSION("1.0");
+MODULE_ALIAS("platform:" PM8018_CORE_DEV_NAME);
diff --git a/drivers/mfd/pm8xxx-batt-alarm.c b/drivers/mfd/pm8xxx-batt-alarm.c
new file mode 100644
index 0000000..88aab98
--- /dev/null
+++ b/drivers/mfd/pm8xxx-batt-alarm.c
@@ -0,0 +1,806 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+ * Qualcomm PMIC PM8xxx Battery Alarm driver
+ *
+ */
+
+#define pr_fmt(fmt)	"%s: " fmt, __func__
+
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mfd/pm8xxx/core.h>
+#include <linux/mfd/pm8xxx/batt-alarm.h>
+
+/* Available voltage threshold values */
+#define THRESHOLD_MIN_MV		2500
+#define THRESHOLD_MAX_MV		5675
+#define THRESHOLD_STEP_MV		25
+
+/* Register bit definitions */
+
+/* Threshold register */
+#define THRESHOLD_UPPER_MASK		0xF0
+#define THRESHOLD_LOWER_MASK		0x0F
+#define THRESHOLD_UPPER_SHIFT		4
+#define THRESHOLD_LOWER_SHIFT		0
+
+/* CTRL 1 register */
+#define CTRL1_BATT_ALARM_ENABLE_MASK	0x80
+#define CTRL1_BATT_ALARM_ENABLE		0x80
+#define CTRL1_BATT_ALARM_DISABLE	0x00
+#define CTRL1_HOLD_TIME_MASK		0x70
+#define CTRL1_STATUS_UPPER_MASK		0x02
+#define CTRL1_STATUS_LOWER_MASK		0x01
+#define CTRL1_HOLD_TIME_SHIFT		4
+#define CTRL1_HOLD_TIME_MIN		0
+#define CTRL1_HOLD_TIME_MAX		7
+
+/* CTRL 2 register */
+#define CTRL2_COMP_UPPER_DISABLE_MASK	0x80
+#define CTRL2_COMP_UPPER_ENABLE		0x00
+#define CTRL2_COMP_UPPER_DISABLE	0x80
+#define CTRL2_COMP_LOWER_DISABLE_MASK	0x40
+#define CTRL2_COMP_LOWER_ENABLE		0x00
+#define CTRL2_COMP_LOWER_DISABLE	0x40
+#define CTRL2_FINE_STEP_UPPER_MASK	0x30
+#define CTRL2_RANGE_EXT_UPPER_MASK	0x08
+#define CTRL2_FINE_STEP_LOWER_MASK	0x06
+#define CTRL2_RANGE_EXT_LOWER_MASK	0x01
+#define CTRL2_FINE_STEP_UPPER_SHIFT	4
+#define CTRL2_FINE_STEP_LOWER_SHIFT	1
+
+/* PWM control register */
+#define PWM_CTRL_ALARM_EN_MASK		0xC0
+#define PWM_CTRL_ALARM_EN_NEVER		0x00
+#define PWM_CTRL_ALARM_EN_TCXO		0x40
+#define PWM_CTRL_ALARM_EN_PWM		0x80
+#define PWM_CTRL_ALARM_EN_ALWAYS	0xC0
+#define PWM_CTRL_PRE_MASK		0x38
+#define PWM_CTRL_DIV_MASK		0x07
+#define PWM_CTRL_PRE_SHIFT		3
+#define PWM_CTRL_DIV_SHIFT		0
+#define PWM_CTRL_PRE_MIN		0
+#define PWM_CTRL_PRE_MAX		7
+#define PWM_CTRL_DIV_MIN		1
+#define PWM_CTRL_DIV_MAX		7
+
+/* PWM control input range */
+#define PWM_CTRL_PRE_INPUT_MIN		2
+#define PWM_CTRL_PRE_INPUT_MAX		9
+#define PWM_CTRL_DIV_INPUT_MIN		2
+#define PWM_CTRL_DIV_INPUT_MAX		8
+
+/* Available voltage threshold values */
+#define THRESHOLD_BASIC_MIN_MV		2800
+#define THRESHOLD_EXT_MIN_MV		4400
+
+/*
+ * Default values used during initialization:
+ * Slowest PWM rate to ensure minimal status jittering when crossing thresholds.
+ * Largest hold time also helps reduce status value jittering.  Comparators
+ * are disabled by default and must be turned on by calling
+ * pm8xxx_batt_alarm_state_set.
+ */
+#define DEFAULT_THRESHOLD_LOWER		3200
+#define DEFAULT_THRESHOLD_UPPER		4300
+#define DEFAULT_HOLD_TIME		PM8XXX_BATT_ALARM_HOLD_TIME_16_MS
+#define DEFAULT_USE_PWM			1
+#define DEFAULT_PWM_SCALER		9
+#define DEFAULT_PWM_DIVIDER		8
+#define DEFAULT_LOWER_ENABLE		0
+#define DEFAULT_UPPER_ENABLE		0
+
+struct pm8xxx_batt_alarm_chip {
+	struct pm8xxx_batt_alarm_core_data	cdata;
+	struct srcu_notifier_head		irq_notifier_list;
+	struct work_struct			irq_work;
+	struct device				*dev;
+	struct mutex				lock;
+	unsigned int				irq;
+	int					notifier_count;
+	u8					reg_threshold;
+	u8					reg_ctrl1;
+	u8					reg_ctrl2;
+	u8					reg_pwm_ctrl;
+};
+static struct pm8xxx_batt_alarm_chip *the_battalarm;
+
+static int pm8xxx_reg_write(struct pm8xxx_batt_alarm_chip *chip, u16 addr,
+				u8 val, u8 mask, u8 *reg_save)
+{
+	int rc = 0;
+	u8 reg;
+
+	reg = (*reg_save & ~mask) | (val & mask);
+	if (reg != *reg_save)
+		rc = pm8xxx_writeb(chip->dev->parent, addr, reg);
+	if (rc)
+		pr_err("pm8xxx_writeb failed; addr=%03X, rc=%d\n", addr, rc);
+	else
+		*reg_save = reg;
+	return rc;
+}
+
+/**
+ * pm8xxx_batt_alarm_enable - enable one of the battery voltage threshold
+ *			      comparators
+ * @comparator:	selects which comparator to enable
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_enable(enum pm8xxx_batt_alarm_comparator comparator)
+{
+	struct pm8xxx_batt_alarm_chip *chip = the_battalarm;
+	int rc;
+	u8 val_ctrl2 = 0, mask_ctrl2 = 0;
+
+	if (!chip) {
+		pr_err("no battery alarm device found.\n");
+		return -ENODEV;
+	}
+
+	if (comparator < 0 || comparator > PM8XXX_BATT_ALARM_UPPER_COMPARATOR) {
+		pr_err("invalid comparator ID number: %d\n", comparator);
+		return -EINVAL;
+	}
+
+	if (comparator == PM8XXX_BATT_ALARM_LOWER_COMPARATOR) {
+		val_ctrl2 = CTRL2_COMP_LOWER_ENABLE;
+		mask_ctrl2 = CTRL2_COMP_LOWER_DISABLE_MASK;
+	} else {
+		val_ctrl2 = CTRL2_COMP_UPPER_ENABLE;
+		mask_ctrl2 = CTRL2_COMP_UPPER_DISABLE_MASK;
+	}
+
+	mutex_lock(&chip->lock);
+
+	/* Enable the battery alarm block. */
+	rc = pm8xxx_reg_write(chip, chip->cdata.reg_addr_ctrl1,
+				CTRL1_BATT_ALARM_ENABLE,
+				CTRL1_BATT_ALARM_ENABLE_MASK, &chip->reg_ctrl1);
+	if (rc)
+		goto bail;
+
+	/* Enable the individual comparators. */
+	rc = pm8xxx_reg_write(chip, chip->cdata.reg_addr_ctrl2, val_ctrl2,
+				mask_ctrl2, &chip->reg_ctrl2);
+
+bail:
+	mutex_unlock(&chip->lock);
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_batt_alarm_enable);
+
+/**
+ * pm8xxx_batt_alarm_disable - disable one of the battery voltage threshold
+ *			       comparators
+ * @comparator:	selects which comparator to disable
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_disable(enum pm8xxx_batt_alarm_comparator comparator)
+{
+	struct pm8xxx_batt_alarm_chip *chip = the_battalarm;
+	int rc;
+	u8 val_ctrl1 = 0, val_ctrl2 = 0, mask_ctrl2 = 0;
+
+	if (!chip) {
+		pr_err("no battery alarm device found.\n");
+		return -ENODEV;
+	}
+
+	if (comparator < 0 || comparator > PM8XXX_BATT_ALARM_UPPER_COMPARATOR) {
+		pr_err("invalid comparator ID number: %d\n", comparator);
+		return -EINVAL;
+	}
+
+	if (comparator == PM8XXX_BATT_ALARM_LOWER_COMPARATOR) {
+		val_ctrl2 = CTRL2_COMP_LOWER_DISABLE;
+		mask_ctrl2 = CTRL2_COMP_LOWER_DISABLE_MASK;
+	} else {
+		val_ctrl2 = CTRL2_COMP_UPPER_DISABLE;
+		mask_ctrl2 = CTRL2_COMP_UPPER_DISABLE_MASK;
+	}
+
+	mutex_lock(&chip->lock);
+
+	/* Disable the specified comparator. */
+	rc = pm8xxx_reg_write(chip, chip->cdata.reg_addr_ctrl2, val_ctrl2,
+				mask_ctrl2, &chip->reg_ctrl2);
+	if (rc)
+		goto bail;
+
+	/* Disable the battery alarm block if both comparators are disabled. */
+	val_ctrl2 = chip->reg_ctrl2
+	      & (CTRL2_COMP_LOWER_DISABLE_MASK | CTRL2_COMP_UPPER_DISABLE_MASK);
+	if (val_ctrl2 == (CTRL2_COMP_LOWER_DISABLE | CTRL2_COMP_UPPER_DISABLE))
+		val_ctrl1 = CTRL1_BATT_ALARM_DISABLE;
+	else
+		val_ctrl1 = CTRL1_BATT_ALARM_ENABLE;
+
+	rc = pm8xxx_reg_write(chip, chip->cdata.reg_addr_ctrl1, val_ctrl1,
+				CTRL1_BATT_ALARM_ENABLE_MASK, &chip->reg_ctrl1);
+
+bail:
+	mutex_unlock(&chip->lock);
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_batt_alarm_disable);
+
+/**
+ * pm8xxx_batt_alarm_threshold_set - set the lower and upper alarm thresholds
+ * @comparator:		selects which comparator to set the threshold of
+ * @threshold_mV:	battery voltage threshold in millivolts
+ *			set points = 2500-5675 mV in 25 mV steps
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_threshold_set(
+	enum pm8xxx_batt_alarm_comparator comparator, int threshold_mV)
+{
+	struct pm8xxx_batt_alarm_chip *chip = the_battalarm;
+	int step, fine_step, rc;
+	u8 val_threshold = 0, val_ctrl2 = 0;
+	int threshold_mask, threshold_shift, range_ext_mask, fine_step_mask;
+	int fine_step_shift;
+
+	if (!chip) {
+		pr_err("no battery alarm device found.\n");
+		return -ENXIO;
+	}
+
+	if (comparator < 0 || comparator > PM8XXX_BATT_ALARM_UPPER_COMPARATOR) {
+		pr_err("invalid comparator ID number: %d\n", comparator);
+		return -EINVAL;
+	}
+
+	if (threshold_mV < THRESHOLD_MIN_MV
+	    || threshold_mV > THRESHOLD_MAX_MV) {
+		pr_err("threshold value, %d mV, is outside of allowable "
+			"range: [%d, %d] mV\n", threshold_mV,
+			THRESHOLD_MIN_MV, THRESHOLD_MAX_MV);
+		return -EINVAL;
+	}
+
+	if (comparator == PM8XXX_BATT_ALARM_LOWER_COMPARATOR) {
+		threshold_mask = THRESHOLD_LOWER_MASK;
+		threshold_shift = THRESHOLD_LOWER_SHIFT;
+		range_ext_mask = CTRL2_RANGE_EXT_LOWER_MASK;
+		fine_step_mask = CTRL2_FINE_STEP_LOWER_MASK;
+		fine_step_shift = CTRL2_FINE_STEP_LOWER_SHIFT;
+	} else {
+		threshold_mask = THRESHOLD_UPPER_MASK;
+		threshold_shift = THRESHOLD_UPPER_SHIFT;
+		range_ext_mask = CTRL2_RANGE_EXT_UPPER_MASK;
+		fine_step_mask = CTRL2_FINE_STEP_UPPER_MASK;
+		fine_step_shift = CTRL2_FINE_STEP_UPPER_SHIFT;
+	}
+
+	/* Determine register settings to achieve the threshold. */
+	if (threshold_mV < THRESHOLD_BASIC_MIN_MV) {
+		/* Extended low range */
+		val_ctrl2 |= range_ext_mask;
+
+		step = (threshold_mV - THRESHOLD_MIN_MV) / THRESHOLD_STEP_MV;
+
+		fine_step = step & 0x3;
+		/* Extended low range is for steps 0 to 2 */
+		step >>= 2;
+	} else if (threshold_mV >= THRESHOLD_EXT_MIN_MV) {
+		/* Extended high range */
+		val_ctrl2 |= range_ext_mask;
+
+		step = (threshold_mV - THRESHOLD_EXT_MIN_MV)
+			/ THRESHOLD_STEP_MV;
+
+		fine_step = step & 0x3;
+		/* Extended high range is for steps 3 to 15 */
+		step = (step >> 2) + 3;
+	} else {
+		/* Basic range */
+		step = (threshold_mV - THRESHOLD_BASIC_MIN_MV)
+			/ THRESHOLD_STEP_MV;
+
+		fine_step = step & 0x3;
+		step >>= 2;
+	}
+	val_threshold |= step << threshold_shift;
+	val_ctrl2 |= (fine_step << fine_step_shift) & fine_step_mask;
+
+	mutex_lock(&chip->lock);
+	rc = pm8xxx_reg_write(chip, chip->cdata.reg_addr_threshold,
+			val_threshold, threshold_mask, &chip->reg_threshold);
+	if (rc)
+		goto bail;
+
+	rc = pm8xxx_reg_write(chip, chip->cdata.reg_addr_ctrl2, val_ctrl2,
+			range_ext_mask | fine_step_mask, &chip->reg_ctrl2);
+
+bail:
+	mutex_unlock(&chip->lock);
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_batt_alarm_threshold_set);
+
+/**
+ * pm8xxx_batt_alarm_status_read - get status of both threshold comparators
+ *
+ * RETURNS:	< 0	   = error
+ *		  0	   = battery voltage ok
+ *		BIT(0) set = battery voltage below lower threshold
+ *		BIT(1) set = battery voltage above upper threshold
+ */
+int pm8xxx_batt_alarm_status_read(void)
+{
+	struct pm8xxx_batt_alarm_chip *chip = the_battalarm;
+	int status, rc;
+
+	if (!chip) {
+		pr_err("no battery alarm device found.\n");
+		return -ENXIO;
+	}
+
+	mutex_lock(&chip->lock);
+	rc = pm8xxx_readb(chip->dev->parent, chip->cdata.reg_addr_ctrl1,
+			  &chip->reg_ctrl1);
+
+	status = ((chip->reg_ctrl1 & CTRL1_STATUS_LOWER_MASK)
+			? PM8XXX_BATT_ALARM_STATUS_BELOW_LOWER : 0)
+		| ((chip->reg_ctrl1 & CTRL1_STATUS_UPPER_MASK)
+			? PM8XXX_BATT_ALARM_STATUS_ABOVE_UPPER : 0);
+	mutex_unlock(&chip->lock);
+
+	if (rc) {
+		pr_err("pm8xxx_readb failed, rc=%d\n", rc);
+		return rc;
+	}
+
+	return status;
+}
+EXPORT_SYMBOL(pm8xxx_batt_alarm_status_read);
+
+/**
+ * pm8xxx_batt_alarm_hold_time_set - set hold time of interrupt output *
+ * @hold_time:	amount of time that battery voltage must remain outside of the
+ *		threshold range before the battery alarm interrupt triggers
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_hold_time_set(enum pm8xxx_batt_alarm_hold_time hold_time)
+{
+	struct pm8xxx_batt_alarm_chip *chip = the_battalarm;
+	int rc;
+	u8 reg_ctrl1 = 0;
+
+	if (!chip) {
+		pr_err("no battery alarm device found.\n");
+		return -ENXIO;
+	}
+
+	if (hold_time < CTRL1_HOLD_TIME_MIN
+	    || hold_time > CTRL1_HOLD_TIME_MAX) {
+
+		pr_err("hold time, %d, is outside of allowable range: "
+			"[%d, %d]\n", hold_time, CTRL1_HOLD_TIME_MIN,
+			CTRL1_HOLD_TIME_MAX);
+		return -EINVAL;
+	}
+
+	reg_ctrl1 = hold_time << CTRL1_HOLD_TIME_SHIFT;
+
+	mutex_lock(&chip->lock);
+	rc = pm8xxx_reg_write(chip, chip->cdata.reg_addr_ctrl1, reg_ctrl1,
+			      CTRL1_HOLD_TIME_MASK, &chip->reg_ctrl1);
+	mutex_unlock(&chip->lock);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_batt_alarm_hold_time_set);
+
+/**
+ * pm8xxx_batt_alarm_pwm_rate_set - set battery alarm update rate *
+ * @use_pwm:		1 = use PWM update rate, 0 = comparators always active
+ * @clock_scaler:	PWM clock scaler = 2 to 9
+ * @clock_divider:	PWM clock divider = 2 to 8
+ *
+ * This function sets the rate at which the battery alarm module enables
+ * the threshold comparators.  The rate is determined by the following equation:
+ *
+ * f_update = (1024 Hz) / (clock_divider * (2 ^ clock_scaler))
+ *
+ * Thus, the update rate can range from 0.25 Hz to 128 Hz.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_pwm_rate_set(int use_pwm, int clock_scaler,
+				   int clock_divider)
+{
+	struct pm8xxx_batt_alarm_chip *chip = the_battalarm;
+	int rc;
+	u8 reg_pwm_ctrl = 0, mask = 0;
+
+	if (!chip) {
+		pr_err("no battery alarm device found.\n");
+		return -ENXIO;
+	}
+
+	if (use_pwm && (clock_scaler < PWM_CTRL_PRE_INPUT_MIN
+	    || clock_scaler > PWM_CTRL_PRE_INPUT_MAX)) {
+		pr_err("PWM clock scaler, %d, is outside of allowable range: "
+			"[%d, %d]\n", clock_scaler, PWM_CTRL_PRE_INPUT_MIN,
+			PWM_CTRL_PRE_INPUT_MAX);
+		return -EINVAL;
+	}
+
+	if (use_pwm && (clock_divider < PWM_CTRL_DIV_INPUT_MIN
+	    || clock_divider > PWM_CTRL_DIV_INPUT_MAX)) {
+		pr_err("PWM clock divider, %d, is outside of allowable range: "
+			"[%d, %d]\n", clock_divider, PWM_CTRL_DIV_INPUT_MIN,
+			PWM_CTRL_DIV_INPUT_MAX);
+		return -EINVAL;
+	}
+
+	if (!use_pwm) {
+		/* Turn off PWM control and always enable. */
+		reg_pwm_ctrl = PWM_CTRL_ALARM_EN_ALWAYS;
+		mask = PWM_CTRL_ALARM_EN_MASK;
+	} else {
+		/* Use PWM control. */
+		reg_pwm_ctrl = PWM_CTRL_ALARM_EN_PWM;
+		mask = PWM_CTRL_ALARM_EN_MASK | PWM_CTRL_PRE_MASK
+			| PWM_CTRL_DIV_MASK;
+
+		clock_scaler -= PWM_CTRL_PRE_INPUT_MIN - PWM_CTRL_PRE_MIN;
+		clock_divider -= PWM_CTRL_DIV_INPUT_MIN - PWM_CTRL_DIV_MIN;
+
+		reg_pwm_ctrl |= (clock_scaler << PWM_CTRL_PRE_SHIFT)
+				& PWM_CTRL_PRE_MASK;
+		reg_pwm_ctrl |= (clock_divider << PWM_CTRL_DIV_SHIFT)
+				& PWM_CTRL_DIV_MASK;
+	}
+
+	mutex_lock(&chip->lock);
+	rc = pm8xxx_reg_write(chip, chip->cdata.reg_addr_pwm_ctrl, reg_pwm_ctrl,
+			      mask, &chip->reg_pwm_ctrl);
+	mutex_unlock(&chip->lock);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_batt_alarm_pwm_rate_set);
+
+/*
+ * Handle the BATT_ALARM interrupt:
+ * Battery voltage is above or below threshold range.
+ */
+static irqreturn_t pm8xxx_batt_alarm_isr(int irq, void *data)
+{
+	struct pm8xxx_batt_alarm_chip *chip = data;
+
+	disable_irq_nosync(chip->irq);
+	schedule_work(&chip->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static void pm8xxx_batt_alarm_isr_work(struct work_struct *work)
+{
+	struct pm8xxx_batt_alarm_chip *chip
+		= container_of(work, struct pm8xxx_batt_alarm_chip, irq_work);
+	int status;
+
+	if (!chip)
+		return;
+
+	status = pm8xxx_batt_alarm_status_read();
+
+	if (status < 0)
+		pr_err("failed to read status, rc=%d\n", status);
+	else
+		srcu_notifier_call_chain(&chip->irq_notifier_list,
+						status, NULL);
+
+	enable_irq(chip->irq);
+}
+
+/**
+ * pm8xxx_batt_alarm_register_notifier - register a notifier to run when a
+ *	battery voltage change interrupt fires
+ * @nb:	notifier block containing callback function to register
+ *
+ * nb->notifier_call must point to a function of this form -
+ * int (*notifier_call)(struct notifier_block *nb, unsigned long status,
+ *			void *unused);
+ * "status" will receive the battery alarm status; "unused" will be NULL.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_register_notifier(struct notifier_block *nb)
+{
+	struct pm8xxx_batt_alarm_chip *chip = the_battalarm;
+	int rc;
+
+	if (!chip) {
+		pr_err("no battery alarm device found.\n");
+		return -ENXIO;
+	}
+
+	rc = srcu_notifier_chain_register(&chip->irq_notifier_list, nb);
+	mutex_lock(&chip->lock);
+	if (rc == 0) {
+		if (chip->notifier_count == 0) {
+			enable_irq(chip->irq);
+			rc = irq_set_irq_wake(chip->irq, 1);
+		}
+
+		chip->notifier_count++;
+	}
+
+	mutex_unlock(&chip->lock);
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_batt_alarm_register_notifier);
+
+/**
+ * pm8xxx_batt_alarm_unregister_notifier - unregister a notifier that is run
+ *	when a battery voltage change interrupt fires
+ * @nb:	notifier block containing callback function to unregister
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_unregister_notifier(struct notifier_block *nb)
+{
+	struct pm8xxx_batt_alarm_chip *chip = the_battalarm;
+	int rc;
+
+	if (!chip) {
+		pr_err("no battery alarm device found.\n");
+		return -ENXIO;
+	}
+
+	rc = srcu_notifier_chain_unregister(&chip->irq_notifier_list, nb);
+	if (rc == 0) {
+		mutex_lock(&chip->lock);
+
+		chip->notifier_count--;
+
+		if (chip->notifier_count == 0) {
+			rc = irq_set_irq_wake(chip->irq, 0);
+			disable_irq(chip->irq);
+		}
+
+		WARN_ON(chip->notifier_count < 0);
+
+		mutex_unlock(&chip->lock);
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_batt_alarm_unregister_notifier);
+
+static int pm8xxx_batt_alarm_reg_init(struct pm8xxx_batt_alarm_chip *chip)
+{
+	int rc = 0;
+
+	/* save the current register states */
+	rc = pm8xxx_readb(chip->dev->parent, chip->cdata.reg_addr_threshold,
+			  &chip->reg_threshold);
+	if (rc)
+		goto bail;
+
+	rc = pm8xxx_readb(chip->dev->parent, chip->cdata.reg_addr_ctrl1,
+			  &chip->reg_ctrl1);
+	if (rc)
+		goto bail;
+
+	rc = pm8xxx_readb(chip->dev->parent, chip->cdata.reg_addr_ctrl2,
+			  &chip->reg_ctrl2);
+	if (rc)
+		goto bail;
+
+	rc = pm8xxx_readb(chip->dev->parent, chip->cdata.reg_addr_pwm_ctrl,
+			  &chip->reg_pwm_ctrl);
+	if (rc)
+		goto bail;
+
+bail:
+	if (rc)
+		pr_err("pm8xxx_readb failed; initial register states "
+			"unknown, rc=%d\n", rc);
+	return rc;
+}
+
+/* TODO: should this default setting function be removed? */
+static int pm8xxx_batt_alarm_config_defaults(void)
+{
+	int rc = 0;
+
+	/* Use default values when no platform data is provided. */
+	rc = pm8xxx_batt_alarm_threshold_set(PM8XXX_BATT_ALARM_LOWER_COMPARATOR,
+		DEFAULT_THRESHOLD_LOWER);
+	if (rc) {
+		pr_err("threshold_set failed, rc=%d\n", rc);
+		goto done;
+	}
+
+	rc = pm8xxx_batt_alarm_threshold_set(PM8XXX_BATT_ALARM_UPPER_COMPARATOR,
+		DEFAULT_THRESHOLD_UPPER);
+	if (rc) {
+		pr_err("threshold_set failed, rc=%d\n", rc);
+		goto done;
+	}
+
+	rc = pm8xxx_batt_alarm_hold_time_set(DEFAULT_HOLD_TIME);
+	if (rc) {
+		pr_err("hold_time_set failed, rc=%d\n", rc);
+		goto done;
+	}
+
+	rc = pm8xxx_batt_alarm_pwm_rate_set(DEFAULT_USE_PWM,
+			DEFAULT_PWM_SCALER, DEFAULT_PWM_DIVIDER);
+	if (rc) {
+		pr_err("pwm_rate_set failed, rc=%d\n", rc);
+		goto done;
+	}
+
+	rc = pm8xxx_batt_alarm_disable(PM8XXX_BATT_ALARM_LOWER_COMPARATOR);
+	if (rc) {
+		pr_err("disable lower failed, rc=%d\n", rc);
+		goto done;
+	}
+
+	rc = pm8xxx_batt_alarm_disable(PM8XXX_BATT_ALARM_UPPER_COMPARATOR);
+	if (rc) {
+		pr_err("disable upper failed, rc=%d\n", rc);
+		goto done;
+	}
+
+done:
+	return rc;
+}
+
+static int __devinit pm8xxx_batt_alarm_probe(struct platform_device *pdev)
+{
+	const struct pm8xxx_batt_alarm_core_data *cdata
+			= pdev->dev.platform_data;
+	struct pm8xxx_batt_alarm_chip *chip;
+	struct resource *res;
+	int rc;
+
+	if (the_battalarm) {
+		pr_err("A PMIC battery alarm device has already probed.\n");
+		return -ENODEV;
+	}
+
+	if (!cdata) {
+		pr_err("missing core data\n");
+		return -EINVAL;
+	}
+
+	if (!cdata->irq_name) {
+		pr_err("missing IRQ name\n");
+		return -EINVAL;
+	}
+
+	chip = kzalloc(sizeof(struct pm8xxx_batt_alarm_chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pr_err("kzalloc() failed.\n");
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_IRQ,
+		cdata->irq_name);
+	if (res) {
+		chip->irq = res->start;
+	} else {
+		pr_err("Battery alarm IRQ not specified\n");
+		rc = -EINVAL;
+		goto err_free_chip;
+	}
+
+	chip->dev = &pdev->dev;
+	memcpy(&(chip->cdata), cdata,
+		sizeof(struct pm8xxx_batt_alarm_core_data));
+
+	srcu_init_notifier_head(&chip->irq_notifier_list);
+
+	chip->notifier_count = 0;
+	mutex_init(&chip->lock);
+
+	the_battalarm = chip;
+
+	rc = pm8xxx_batt_alarm_reg_init(chip);
+	if (rc)
+		goto err_free_mutex;
+
+	rc = pm8xxx_batt_alarm_config_defaults();
+	if (rc)
+		goto err_free_mutex;
+
+	INIT_WORK(&chip->irq_work, pm8xxx_batt_alarm_isr_work);
+
+/* TODO: Is it best to trigger on both edges? Should this be configurable? */
+	rc = request_irq(chip->irq, pm8xxx_batt_alarm_isr,
+		IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, cdata->irq_name,
+		chip);
+	if (rc < 0) {
+		pr_err("request_irq(%d) failed, rc=%d\n", chip->irq, rc);
+		goto err_cancel_work;
+	}
+
+	/* Disable the IRQ until a notifier is registered. */
+	disable_irq(chip->irq);
+
+	platform_set_drvdata(pdev, chip);
+
+	return 0;
+
+err_cancel_work:
+	cancel_work_sync(&chip->irq_work);
+err_free_mutex:
+	mutex_destroy(&chip->lock);
+	srcu_cleanup_notifier_head(&chip->irq_notifier_list);
+err_free_chip:
+	kfree(chip);
+	the_battalarm = NULL;
+
+	return rc;
+}
+
+static int __devexit pm8xxx_batt_alarm_remove(struct platform_device *pdev)
+{
+	struct pm8xxx_batt_alarm_chip *chip = platform_get_drvdata(pdev);
+
+	if (chip) {
+		platform_set_drvdata(pdev, NULL);
+		irq_set_irq_wake(chip->irq, 0);
+		free_irq(chip->irq, chip);
+		cancel_work_sync(&chip->irq_work);
+		srcu_cleanup_notifier_head(&chip->irq_notifier_list);
+		mutex_destroy(&chip->lock);
+		kfree(chip);
+		the_battalarm = NULL;
+	}
+
+	return 0;
+}
+
+static struct platform_driver pm8xxx_batt_alarm_driver = {
+	.probe	= pm8xxx_batt_alarm_probe,
+	.remove	= __devexit_p(pm8xxx_batt_alarm_remove),
+	.driver	= {
+		.name = PM8XXX_BATT_ALARM_DEV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init pm8xxx_batt_alarm_init(void)
+{
+	return platform_driver_register(&pm8xxx_batt_alarm_driver);
+}
+
+static void __exit pm8xxx_batt_alarm_exit(void)
+{
+	platform_driver_unregister(&pm8xxx_batt_alarm_driver);
+}
+
+module_init(pm8xxx_batt_alarm_init);
+module_exit(pm8xxx_batt_alarm_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("PMIC PM8xxx Battery Alarm");
+MODULE_VERSION("1.0");
+MODULE_ALIAS("platform:" PM8XXX_BATT_ALARM_DEV_NAME);
diff --git a/drivers/mfd/pm8xxx-debug.c b/drivers/mfd/pm8xxx-debug.c
new file mode 100644
index 0000000..6431edd
--- /dev/null
+++ b/drivers/mfd/pm8xxx-debug.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/mfd/pm8xxx/core.h>
+#include <linux/debugfs.h>
+
+#define PM8XXX_DEBUG_DEV_NAME "pm8xxx-debug"
+
+struct pm8xxx_debug_device {
+	struct mutex		debug_mutex;
+	struct device		*parent;
+	struct dentry		*dir;
+	int			addr;
+};
+
+static bool pm8xxx_debug_addr_is_valid(int addr)
+{
+	if (addr < 0 || addr > 0x3FF) {
+		pr_err("PMIC register address is invalid: %d\n", addr);
+		return false;
+	}
+	return true;
+}
+
+static int pm8xxx_debug_data_set(void *data, u64 val)
+{
+	struct pm8xxx_debug_device *debugdev = data;
+	u8 reg = val;
+	int rc;
+
+	mutex_lock(&debugdev->debug_mutex);
+
+	if (pm8xxx_debug_addr_is_valid(debugdev->addr)) {
+		rc = pm8xxx_writeb(debugdev->parent, debugdev->addr, reg);
+
+		if (rc)
+			pr_err("pm8xxx_writeb(0x%03X)=0x%02X failed: rc=%d\n",
+				debugdev->addr, reg, rc);
+	}
+
+	mutex_unlock(&debugdev->debug_mutex);
+	return 0;
+}
+
+static int pm8xxx_debug_data_get(void *data, u64 *val)
+{
+	struct pm8xxx_debug_device *debugdev = data;
+	int rc;
+	u8 reg;
+
+	mutex_lock(&debugdev->debug_mutex);
+
+	if (pm8xxx_debug_addr_is_valid(debugdev->addr)) {
+		rc = pm8xxx_readb(debugdev->parent, debugdev->addr, &reg);
+
+		if (rc)
+			pr_err("pm8xxx_readb(0x%03X) failed: rc=%d\n",
+				debugdev->addr, rc);
+		else
+			*val = reg;
+	}
+
+	mutex_unlock(&debugdev->debug_mutex);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_data_fops, pm8xxx_debug_data_get,
+			pm8xxx_debug_data_set, "0x%02llX\n");
+
+static int pm8xxx_debug_addr_set(void *data, u64 val)
+{
+	struct pm8xxx_debug_device *debugdev = data;
+
+	if (pm8xxx_debug_addr_is_valid(val)) {
+		mutex_lock(&debugdev->debug_mutex);
+		debugdev->addr = val;
+		mutex_unlock(&debugdev->debug_mutex);
+	}
+
+	return 0;
+}
+
+static int pm8xxx_debug_addr_get(void *data, u64 *val)
+{
+	struct pm8xxx_debug_device *debugdev = data;
+
+	mutex_lock(&debugdev->debug_mutex);
+
+	if (pm8xxx_debug_addr_is_valid(debugdev->addr))
+		*val = debugdev->addr;
+
+	mutex_unlock(&debugdev->debug_mutex);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_addr_fops, pm8xxx_debug_addr_get,
+			pm8xxx_debug_addr_set, "0x%03llX\n");
+
+static int __devinit pm8xxx_debug_probe(struct platform_device *pdev)
+{
+	char *name = pdev->dev.platform_data;
+	struct pm8xxx_debug_device *debugdev;
+	struct dentry *dir;
+	struct dentry *temp;
+	int rc;
+
+	if (name == NULL) {
+		pr_err("debugfs directory name must be specified in "
+			"platform_data pointer\n");
+		return -EINVAL;
+	}
+
+	debugdev = kzalloc(sizeof(struct pm8xxx_debug_device), GFP_KERNEL);
+	if (debugdev == NULL) {
+		pr_err("kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	debugdev->parent = pdev->dev.parent;
+	debugdev->addr = -1;
+
+	dir = debugfs_create_dir(name, NULL);
+	if (dir == NULL || IS_ERR(dir)) {
+		pr_err("debugfs_create_dir failed: rc=%ld\n", PTR_ERR(dir));
+		rc = PTR_ERR(dir);
+		goto dir_error;
+	}
+
+	temp = debugfs_create_file("addr", S_IRUSR | S_IWUSR, dir, debugdev,
+				   &debug_addr_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		rc = PTR_ERR(temp);
+		goto file_error;
+	}
+
+	temp = debugfs_create_file("data", S_IRUSR | S_IWUSR, dir, debugdev,
+				   &debug_data_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		rc = PTR_ERR(temp);
+		goto file_error;
+	}
+
+	mutex_init(&debugdev->debug_mutex);
+
+	debugdev->dir = dir;
+	platform_set_drvdata(pdev, debugdev);
+
+	return 0;
+
+file_error:
+	debugfs_remove_recursive(dir);
+dir_error:
+	kfree(debugdev);
+
+	return rc;
+}
+
+static int __devexit pm8xxx_debug_remove(struct platform_device *pdev)
+{
+	struct pm8xxx_debug_device *debugdev = platform_get_drvdata(pdev);
+
+	if (debugdev) {
+		debugfs_remove_recursive(debugdev->dir);
+		mutex_destroy(&debugdev->debug_mutex);
+		kfree(debugdev);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver pm8xxx_debug_driver = {
+	.probe		= pm8xxx_debug_probe,
+	.remove		= __devexit_p(pm8xxx_debug_remove),
+	.driver		= {
+		.name	= PM8XXX_DEBUG_DEV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init pm8xxx_debug_init(void)
+{
+	return platform_driver_register(&pm8xxx_debug_driver);
+}
+subsys_initcall(pm8xxx_debug_init);
+
+static void __exit pm8xxx_debug_exit(void)
+{
+	platform_driver_unregister(&pm8xxx_debug_driver);
+}
+module_exit(pm8xxx_debug_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("PM8XXX Debug driver");
+MODULE_VERSION("1.0");
+MODULE_ALIAS("platform:" PM8XXX_DEBUG_DEV_NAME);
diff --git a/drivers/mfd/pm8xxx-irq.c b/drivers/mfd/pm8xxx-irq.c
index d452dd0..999b53f 100644
--- a/drivers/mfd/pm8xxx-irq.c
+++ b/drivers/mfd/pm8xxx-irq.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,6 +13,7 @@
 
 #define pr_fmt(fmt)	"%s: " fmt, __func__
 
+#include <linux/export.h>
 #include <linux/err.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
@@ -24,17 +25,15 @@
 
 /* PMIC8xxx IRQ */
 
-#define	SSBI_REG_ADDR_IRQ_BASE		0x1BB
-
-#define	SSBI_REG_ADDR_IRQ_ROOT		(SSBI_REG_ADDR_IRQ_BASE + 0)
-#define	SSBI_REG_ADDR_IRQ_M_STATUS1	(SSBI_REG_ADDR_IRQ_BASE + 1)
-#define	SSBI_REG_ADDR_IRQ_M_STATUS2	(SSBI_REG_ADDR_IRQ_BASE + 2)
-#define	SSBI_REG_ADDR_IRQ_M_STATUS3	(SSBI_REG_ADDR_IRQ_BASE + 3)
-#define	SSBI_REG_ADDR_IRQ_M_STATUS4	(SSBI_REG_ADDR_IRQ_BASE + 4)
-#define	SSBI_REG_ADDR_IRQ_BLK_SEL	(SSBI_REG_ADDR_IRQ_BASE + 5)
-#define	SSBI_REG_ADDR_IRQ_IT_STATUS	(SSBI_REG_ADDR_IRQ_BASE + 6)
-#define	SSBI_REG_ADDR_IRQ_CONFIG	(SSBI_REG_ADDR_IRQ_BASE + 7)
-#define	SSBI_REG_ADDR_IRQ_RT_STATUS	(SSBI_REG_ADDR_IRQ_BASE + 8)
+#define SSBI_REG_ADDR_IRQ_ROOT(base)		(base + 0)
+#define SSBI_REG_ADDR_IRQ_M_STATUS1(base)	(base + 1)
+#define SSBI_REG_ADDR_IRQ_M_STATUS2(base)	(base + 2)
+#define SSBI_REG_ADDR_IRQ_M_STATUS3(base)	(base + 3)
+#define SSBI_REG_ADDR_IRQ_M_STATUS4(base)	(base + 4)
+#define SSBI_REG_ADDR_IRQ_BLK_SEL(base)		(base + 5)
+#define SSBI_REG_ADDR_IRQ_IT_STATUS(base)	(base + 6)
+#define SSBI_REG_ADDR_IRQ_CONFIG(base)		(base + 7)
+#define SSBI_REG_ADDR_IRQ_RT_STATUS(base)	(base + 8)
 
 #define	PM_IRQF_LVL_SEL			0x01	/* level select */
 #define	PM_IRQF_MASK_FE			0x02	/* mask falling edge */
@@ -50,6 +49,7 @@
 struct pm_irq_chip {
 	struct device		*dev;
 	spinlock_t		pm_irq_lock;
+	unsigned int		base_addr;
 	unsigned int		devirq;
 	unsigned int		irq_base;
 	unsigned int		num_irqs;
@@ -60,13 +60,14 @@ struct pm_irq_chip {
 
 static int pm8xxx_read_root_irq(const struct pm_irq_chip *chip, u8 *rp)
 {
-	return pm8xxx_readb(chip->dev, SSBI_REG_ADDR_IRQ_ROOT, rp);
+	return pm8xxx_readb(chip->dev,
+			SSBI_REG_ADDR_IRQ_ROOT(chip->base_addr), rp);
 }
 
 static int pm8xxx_read_master_irq(const struct pm_irq_chip *chip, u8 m, u8 *bp)
 {
 	return pm8xxx_readb(chip->dev,
-			SSBI_REG_ADDR_IRQ_M_STATUS1 + m, bp);
+			SSBI_REG_ADDR_IRQ_M_STATUS1(chip->base_addr) + m, bp);
 }
 
 static int pm8xxx_read_block_irq(struct pm_irq_chip *chip, u8 bp, u8 *ip)
@@ -74,13 +75,15 @@ static int pm8xxx_read_block_irq(struct pm_irq_chip *chip, u8 bp, u8 *ip)
 	int	rc;
 
 	spin_lock(&chip->pm_irq_lock);
-	rc = pm8xxx_writeb(chip->dev, SSBI_REG_ADDR_IRQ_BLK_SEL, bp);
+	rc = pm8xxx_writeb(chip->dev,
+			SSBI_REG_ADDR_IRQ_BLK_SEL(chip->base_addr), bp);
 	if (rc) {
 		pr_err("Failed Selecting Block %d rc=%d\n", bp, rc);
 		goto bail;
 	}
 
-	rc = pm8xxx_readb(chip->dev, SSBI_REG_ADDR_IRQ_IT_STATUS, ip);
+	rc = pm8xxx_readb(chip->dev,
+			SSBI_REG_ADDR_IRQ_IT_STATUS(chip->base_addr), ip);
 	if (rc)
 		pr_err("Failed Reading Status rc=%d\n", rc);
 bail:
@@ -88,19 +91,51 @@ bail:
 	return rc;
 }
 
-static int pm8xxx_config_irq(struct pm_irq_chip *chip, u8 bp, u8 cp)
+static int pm8xxx_read_config_irq(struct pm_irq_chip *chip, u8 bp, u8 cp, u8 *r)
 {
 	int	rc;
 
 	spin_lock(&chip->pm_irq_lock);
-	rc = pm8xxx_writeb(chip->dev, SSBI_REG_ADDR_IRQ_BLK_SEL, bp);
+	rc = pm8xxx_writeb(chip->dev,
+			SSBI_REG_ADDR_IRQ_BLK_SEL(chip->base_addr), bp);
 	if (rc) {
 		pr_err("Failed Selecting Block %d rc=%d\n", bp, rc);
 		goto bail;
 	}
 
+	cp &= ~PM_IRQF_WRITE;
+	rc = pm8xxx_writeb(chip->dev,
+			SSBI_REG_ADDR_IRQ_CONFIG(chip->base_addr), cp);
+	if (rc)
+		pr_err("Failed Configuring IRQ rc=%d\n", rc);
+
+	rc = pm8xxx_readb(chip->dev,
+			SSBI_REG_ADDR_IRQ_CONFIG(chip->base_addr), r);
+	if (rc)
+		pr_err("Failed reading IRQ rc=%d\n", rc);
+bail:
+	spin_unlock(&chip->pm_irq_lock);
+	return rc;
+}
+
+static int pm8xxx_write_config_irq(struct pm_irq_chip *chip, u8 bp, u8 cp)
+{
+	int	rc;
+
+	spin_lock(&chip->pm_irq_lock);
+	rc = pm8xxx_writeb(chip->dev,
+			SSBI_REG_ADDR_IRQ_BLK_SEL(chip->base_addr), bp);
+	if (rc) {
+		pr_err("Failed Selecting Block %d rc=%d\n", bp, rc);
+		goto bail;
+	}
+	/*
+	 * Set the write bit here as this could be a unrequested irq
+	 * whose PM_IRQF_WRITE bit is not set
+	 */
 	cp |= PM_IRQF_WRITE;
-	rc = pm8xxx_writeb(chip->dev, SSBI_REG_ADDR_IRQ_CONFIG, cp);
+	rc = pm8xxx_writeb(chip->dev,
+			SSBI_REG_ADDR_IRQ_CONFIG(chip->base_addr), cp);
 	if (rc)
 		pr_err("Failed Configuring IRQ rc=%d\n", rc);
 bail:
@@ -157,17 +192,16 @@ static int pm8xxx_irq_master_handler(struct pm_irq_chip *chip, int master)
 	return ret;
 }
 
-static void pm8xxx_irq_handler(unsigned int irq, struct irq_desc *desc)
+static irqreturn_t pm8xxx_irq_handler(int irq, void *data)
 {
-	struct pm_irq_chip *chip = irq_desc_get_handler_data(desc);
-	struct irq_chip *irq_chip = irq_desc_get_chip(desc);
+	struct pm_irq_chip *chip = data;
 	u8	root;
 	int	i, ret, masters = 0;
 
 	ret = pm8xxx_read_root_irq(chip, &root);
 	if (ret) {
 		pr_err("Can't read root status ret=%d\n", ret);
-		return;
+		return IRQ_HANDLED;
 	}
 
 	/* on pm8xxx series masters start from bit 1 of the root */
@@ -178,7 +212,27 @@ static void pm8xxx_irq_handler(unsigned int irq, struct irq_desc *desc)
 		if (masters & (1 << i))
 			pm8xxx_irq_master_handler(chip, i);
 
-	irq_chip->irq_ack(&desc->irq_data);
+	return IRQ_HANDLED;
+}
+
+static void pm8xxx_irq_mask(struct irq_data *d)
+{
+	struct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);
+	unsigned int pmirq = d->irq - chip->irq_base;
+	int	master, irq_bit;
+	u8	block, config;
+
+	block = pmirq / 8;
+	master = block / 8;
+	irq_bit = pmirq % 8;
+
+	if (chip->config[pmirq] == 0) {
+		pr_warn("masking rogue irq=%d pmirq=%d\n", d->irq, pmirq);
+		chip->config[pmirq] = irq_bit << PM_IRQF_BITS_SHIFT;
+	}
+
+	config = chip->config[pmirq] | PM_IRQF_MASK_ALL;
+	pm8xxx_write_config_irq(chip, block, config);
 }
 
 static void pm8xxx_irq_mask_ack(struct irq_data *d)
@@ -192,8 +246,13 @@ static void pm8xxx_irq_mask_ack(struct irq_data *d)
 	master = block / 8;
 	irq_bit = pmirq % 8;
 
+	if (chip->config[pmirq] == 0) {
+		pr_warn("mask acking rogue irq=%d pmirq=%d\n", d->irq, pmirq);
+		chip->config[pmirq] = irq_bit << PM_IRQF_BITS_SHIFT;
+	}
+
 	config = chip->config[pmirq] | PM_IRQF_MASK_ALL | PM_IRQF_CLR;
-	pm8xxx_config_irq(chip, block, config);
+	pm8xxx_write_config_irq(chip, block, config);
 }
 
 static void pm8xxx_irq_unmask(struct irq_data *d)
@@ -201,14 +260,17 @@ static void pm8xxx_irq_unmask(struct irq_data *d)
 	struct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);
 	unsigned int pmirq = d->irq - chip->irq_base;
 	int	master, irq_bit;
-	u8	block, config;
+	u8	block, config, hw_conf;
 
 	block = pmirq / 8;
 	master = block / 8;
 	irq_bit = pmirq % 8;
 
 	config = chip->config[pmirq];
-	pm8xxx_config_irq(chip, block, config);
+	pm8xxx_read_config_irq(chip, block, config, &hw_conf);
+	/* check if it is masked */
+	if ((hw_conf & PM_IRQF_MASK_ALL) == PM_IRQF_MASK_ALL)
+		pm8xxx_write_config_irq(chip, block, config);
 }
 
 static int pm8xxx_irq_set_type(struct irq_data *d, unsigned int flow_type)
@@ -238,8 +300,14 @@ static int pm8xxx_irq_set_type(struct irq_data *d, unsigned int flow_type)
 			chip->config[pmirq] &= ~PM_IRQF_MASK_FE;
 	}
 
+	/*
+	 * The PM_IRQF_WRITE flag serves as an indication that this interrupt
+	 * been requested
+	 */
+	chip->config[pmirq] |= PM_IRQF_WRITE;
+
 	config = chip->config[pmirq] | PM_IRQF_CLR;
-	return pm8xxx_config_irq(chip, block, config);
+	return pm8xxx_write_config_irq(chip, block, config);
 }
 
 static int pm8xxx_irq_set_wake(struct irq_data *d, unsigned int on)
@@ -247,12 +315,21 @@ static int pm8xxx_irq_set_wake(struct irq_data *d, unsigned int on)
 	return 0;
 }
 
+static int pm8xxx_irq_read_line(struct irq_data *d)
+{
+	struct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);
+
+	return pm8xxx_get_irq_stat(chip, d->irq);
+}
+
 static struct irq_chip pm8xxx_irq_chip = {
 	.name		= "pm8xxx",
+	.irq_mask	= pm8xxx_irq_mask,
 	.irq_mask_ack	= pm8xxx_irq_mask_ack,
 	.irq_unmask	= pm8xxx_irq_unmask,
 	.irq_set_type	= pm8xxx_irq_set_type,
 	.irq_set_wake	= pm8xxx_irq_set_wake,
+	.irq_read_line	= pm8xxx_irq_read_line,
 	.flags		= IRQCHIP_MASK_ON_SUSPEND,
 };
 
@@ -286,14 +363,16 @@ int pm8xxx_get_irq_stat(struct pm_irq_chip *chip, int irq)
 
 	spin_lock_irqsave(&chip->pm_irq_lock, flags);
 
-	rc = pm8xxx_writeb(chip->dev, SSBI_REG_ADDR_IRQ_BLK_SEL, block);
+	rc = pm8xxx_writeb(chip->dev,
+			SSBI_REG_ADDR_IRQ_BLK_SEL(chip->base_addr), block);
 	if (rc) {
 		pr_err("Failed Selecting block irq=%d pmirq=%d blk=%d rc=%d\n",
 			irq, pmirq, block, rc);
 		goto bail_out;
 	}
 
-	rc = pm8xxx_readb(chip->dev, SSBI_REG_ADDR_IRQ_RT_STATUS, &bits);
+	rc = pm8xxx_readb(chip->dev,
+			SSBI_REG_ADDR_IRQ_RT_STATUS(chip->base_addr), &bits);
 	if (rc) {
 		pr_err("Failed Configuring irq=%d pmirq=%d blk=%d rc=%d\n",
 			irq, pmirq, block, rc);
@@ -339,6 +418,7 @@ struct pm_irq_chip *  __devinit pm8xxx_irq_init(struct device *dev,
 	chip->devirq = devirq;
 	chip->irq_base = pdata->irq_base;
 	chip->num_irqs = pdata->irq_cdata.nirqs;
+	chip->base_addr = pdata->irq_cdata.base_addr;
 	chip->num_blocks = DIV_ROUND_UP(chip->num_irqs, 8);
 	chip->num_masters = DIV_ROUND_UP(chip->num_blocks, 8);
 	spin_lock_init(&chip->pm_irq_lock);
@@ -355,15 +435,22 @@ struct pm_irq_chip *  __devinit pm8xxx_irq_init(struct device *dev,
 #endif
 	}
 
-	irq_set_irq_type(devirq, pdata->irq_trigger_flag);
-	irq_set_handler_data(devirq, chip);
-	irq_set_chained_handler(devirq, pm8xxx_irq_handler);
-	set_irq_wake(devirq, 1);
+	if (devirq != 0) {
+		rc = request_irq(devirq, pm8xxx_irq_handler,
+				pdata->irq_trigger_flag,
+				"pm8xxx_usr_irq", chip);
+		if (rc) {
+			pr_err("failed to request_irq for %d rc=%d\n",
+								devirq, rc);
+		} else {
+			irq_set_irq_wake(devirq, 1);
+		}
+	}
 
 	return chip;
 }
 
-int __devexit pm8xxx_irq_exit(struct pm_irq_chip *chip)
+int pm8xxx_irq_exit(struct pm_irq_chip *chip)
 {
 	irq_set_chained_handler(chip->devirq, NULL);
 	kfree(chip);
diff --git a/drivers/mfd/pm8xxx-misc.c b/drivers/mfd/pm8xxx-misc.c
new file mode 100644
index 0000000..00032f1
--- /dev/null
+++ b/drivers/mfd/pm8xxx-misc.c
@@ -0,0 +1,1256 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/mfd/pm8xxx/core.h>
+#include <linux/mfd/pm8xxx/misc.h>
+
+/* PON CTRL 1 register */
+#define REG_PM8XXX_PON_CTRL_1			0x01C
+
+#define PON_CTRL_1_PULL_UP_MASK			0xE0
+#define PON_CTRL_1_USB_PWR_EN			0x10
+
+#define PON_CTRL_1_WD_EN_MASK			0x08
+#define PON_CTRL_1_WD_EN_RESET			0x08
+#define PON_CTRL_1_WD_EN_PWR_OFF		0x00
+
+/* PON CNTL registers */
+#define REG_PM8058_PON_CNTL_4			0x098
+#define REG_PM8901_PON_CNTL_4			0x099
+#define REG_PM8018_PON_CNTL_4			0x01E
+#define REG_PM8921_PON_CNTL_4			0x01E
+#define REG_PM8058_PON_CNTL_5			0x07B
+#define REG_PM8901_PON_CNTL_5			0x09A
+#define REG_PM8018_PON_CNTL_5			0x01F
+#define REG_PM8921_PON_CNTL_5			0x01F
+
+#define PON_CTRL_4_RESET_EN_MASK		0x01
+#define PON_CTRL_4_SHUTDOWN_ON_RESET		0x0
+#define PON_CTRL_4_RESTART_ON_RESET		0x1
+#define PON_CTRL_5_HARD_RESET_EN_MASK		0x08
+#define PON_CTRL_5_HARD_RESET_EN		0x08
+#define PON_CTRL_5_HARD_RESET_DIS		0x00
+
+/* Regulator master enable addresses */
+#define REG_PM8058_VREG_EN_MSM			0x018
+#define REG_PM8058_VREG_EN_GRP_5_4		0x1C8
+
+/* Regulator control registers for shutdown/reset */
+#define REG_PM8058_S0_CTRL			0x004
+#define REG_PM8058_S1_CTRL			0x005
+#define REG_PM8058_S3_CTRL			0x111
+#define REG_PM8058_L21_CTRL			0x120
+#define REG_PM8058_L22_CTRL			0x121
+
+#define PM8058_REGULATOR_ENABLE_MASK		0x80
+#define PM8058_REGULATOR_ENABLE			0x80
+#define PM8058_REGULATOR_DISABLE		0x00
+#define PM8058_REGULATOR_PULL_DOWN_MASK		0x40
+#define PM8058_REGULATOR_PULL_DOWN_EN		0x40
+
+/* Buck CTRL register */
+#define PM8058_SMPS_LEGACY_VREF_SEL		0x20
+#define PM8058_SMPS_LEGACY_VPROG_MASK		0x1F
+#define PM8058_SMPS_ADVANCED_BAND_MASK		0xC0
+#define PM8058_SMPS_ADVANCED_BAND_SHIFT		6
+#define PM8058_SMPS_ADVANCED_VPROG_MASK		0x3F
+
+/* Buck TEST2 registers for shutdown/reset */
+#define REG_PM8058_S0_TEST2			0x084
+#define REG_PM8058_S1_TEST2			0x085
+#define REG_PM8058_S3_TEST2			0x11A
+
+#define PM8058_REGULATOR_BANK_WRITE		0x80
+#define PM8058_REGULATOR_BANK_MASK		0x70
+#define PM8058_REGULATOR_BANK_SHIFT		4
+#define PM8058_REGULATOR_BANK_SEL(n)	((n) << PM8058_REGULATOR_BANK_SHIFT)
+
+/* Buck TEST2 register bank 1 */
+#define PM8058_SMPS_LEGACY_VLOW_SEL		0x01
+
+/* Buck TEST2 register bank 7 */
+#define PM8058_SMPS_ADVANCED_MODE_MASK		0x02
+#define PM8058_SMPS_ADVANCED_MODE		0x02
+#define PM8058_SMPS_LEGACY_MODE			0x00
+
+/* SLEEP CTRL register */
+#define REG_PM8058_SLEEP_CTRL			0x02B
+#define REG_PM8921_SLEEP_CTRL			0x10A
+#define REG_PM8018_SLEEP_CTRL			0x10A
+
+#define SLEEP_CTRL_SMPL_EN_MASK			0x04
+#define SLEEP_CTRL_SMPL_EN_RESET		0x04
+#define SLEEP_CTRL_SMPL_EN_PWR_OFF		0x00
+
+#define SLEEP_CTRL_SMPL_SEL_MASK		0x03
+#define SLEEP_CTRL_SMPL_SEL_MIN			0
+#define SLEEP_CTRL_SMPL_SEL_MAX			3
+
+/* FTS regulator PMR registers */
+#define REG_PM8901_REGULATOR_S1_PMR		0xA7
+#define REG_PM8901_REGULATOR_S2_PMR		0xA8
+#define REG_PM8901_REGULATOR_S3_PMR		0xA9
+#define REG_PM8901_REGULATOR_S4_PMR		0xAA
+
+#define PM8901_REGULATOR_PMR_STATE_MASK		0x60
+#define PM8901_REGULATOR_PMR_STATE_OFF		0x20
+
+/* COINCELL CHG registers */
+#define REG_PM8058_COIN_CHG			0x02F
+#define REG_PM8921_COIN_CHG			0x09C
+#define REG_PM8018_COIN_CHG			0x09C
+
+#define COINCELL_RESISTOR_SHIFT			0x2
+
+/* GP TEST register */
+#define REG_PM8XXX_GP_TEST_1			0x07A
+
+/* Stay on configuration */
+#define PM8XXX_STAY_ON_CFG			0x92
+
+/* GPIO UART MUX CTRL registers */
+#define REG_PM8XXX_GPIO_MUX_CTRL		0x1CC
+
+#define UART_PATH_SEL_MASK			0x60
+#define UART_PATH_SEL_SHIFT			0x5
+
+#define USB_ID_PU_EN_MASK			0x10	/* PM8921 family only */
+#define USB_ID_PU_EN_SHIFT			4
+
+/* Shutdown/restart delays to allow for LDO 7/dVdd regulator load settling. */
+#define PM8901_DELAY_AFTER_REG_DISABLE_MS	4
+#define PM8901_DELAY_BEFORE_SHUTDOWN_MS		8
+
+#define REG_PM8XXX_XO_CNTRL_2	0x114
+#define MP3_1_MASK	0xE0
+#define MP3_2_MASK	0x1C
+#define MP3_1_SHIFT	5
+#define MP3_2_SHIFT	2
+
+#define REG_HSED_BIAS0_CNTL2		0xA1
+#define REG_HSED_BIAS1_CNTL2		0x135
+#define REG_HSED_BIAS2_CNTL2		0x138
+#define HSED_EN_MASK			0xC0
+
+struct pm8xxx_misc_chip {
+	struct list_head			link;
+	struct pm8xxx_misc_platform_data	pdata;
+	struct device				*dev;
+	enum pm8xxx_version			version;
+	u64					osc_halt_count;
+};
+
+static LIST_HEAD(pm8xxx_misc_chips);
+static DEFINE_SPINLOCK(pm8xxx_misc_chips_lock);
+
+static int pm8xxx_misc_masked_write(struct pm8xxx_misc_chip *chip, u16 addr,
+				    u8 mask, u8 val)
+{
+	int rc;
+	u8 reg;
+
+	rc = pm8xxx_readb(chip->dev->parent, addr, &reg);
+	if (rc) {
+		pr_err("pm8xxx_readb(0x%03X) failed, rc=%d\n", addr, rc);
+		return rc;
+	}
+	reg &= ~mask;
+	reg |= val & mask;
+	rc = pm8xxx_writeb(chip->dev->parent, addr, reg);
+	if (rc)
+		pr_err("pm8xxx_writeb(0x%03X)=0x%02X failed, rc=%d\n", addr,
+			reg, rc);
+	return rc;
+}
+
+/*
+ * Set an SMPS regulator to be disabled in its CTRL register, but enabled
+ * in the master enable register.  Also set it's pull down enable bit.
+ * Take care to make sure that the output voltage doesn't change if switching
+ * from advanced mode to legacy mode.
+ */
+static int
+__pm8058_disable_smps_locally_set_pull_down(struct pm8xxx_misc_chip *chip,
+	u16 ctrl_addr, u16 test2_addr, u16 master_enable_addr,
+	u8 master_enable_bit)
+{
+	int rc = 0;
+	u8 vref_sel, vlow_sel, band, vprog, bank, reg;
+
+	bank = PM8058_REGULATOR_BANK_SEL(7);
+	rc = pm8xxx_writeb(chip->dev->parent, test2_addr, bank);
+	if (rc) {
+		pr_err("%s: pm8xxx_writeb(0x%03X) failed: rc=%d\n", __func__,
+			test2_addr, rc);
+		goto done;
+	}
+
+	rc = pm8xxx_readb(chip->dev->parent, test2_addr, &reg);
+	if (rc) {
+		pr_err("%s: FAIL pm8xxx_readb(0x%03X): rc=%d\n",
+		       __func__, test2_addr, rc);
+		goto done;
+	}
+
+	/* Check if in advanced mode. */
+	if ((reg & PM8058_SMPS_ADVANCED_MODE_MASK) ==
+					PM8058_SMPS_ADVANCED_MODE) {
+		/* Determine current output voltage. */
+		rc = pm8xxx_readb(chip->dev->parent, ctrl_addr, &reg);
+		if (rc) {
+			pr_err("%s: FAIL pm8xxx_readb(0x%03X): rc=%d\n",
+			       __func__, ctrl_addr, rc);
+			goto done;
+		}
+
+		band = (reg & PM8058_SMPS_ADVANCED_BAND_MASK)
+			>> PM8058_SMPS_ADVANCED_BAND_SHIFT;
+		switch (band) {
+		case 3:
+			vref_sel = 0;
+			vlow_sel = 0;
+			break;
+		case 2:
+			vref_sel = PM8058_SMPS_LEGACY_VREF_SEL;
+			vlow_sel = 0;
+			break;
+		case 1:
+			vref_sel = PM8058_SMPS_LEGACY_VREF_SEL;
+			vlow_sel = PM8058_SMPS_LEGACY_VLOW_SEL;
+			break;
+		default:
+			pr_err("%s: regulator already disabled\n", __func__);
+			return -EPERM;
+		}
+		vprog = (reg & PM8058_SMPS_ADVANCED_VPROG_MASK);
+		/* Round up if fine step is in use. */
+		vprog = (vprog + 1) >> 1;
+		if (vprog > PM8058_SMPS_LEGACY_VPROG_MASK)
+			vprog = PM8058_SMPS_LEGACY_VPROG_MASK;
+
+		/* Set VLOW_SEL bit. */
+		bank = PM8058_REGULATOR_BANK_SEL(1);
+		rc = pm8xxx_writeb(chip->dev->parent, test2_addr, bank);
+		if (rc) {
+			pr_err("%s: FAIL pm8xxx_writeb(0x%03X): rc=%d\n",
+			       __func__, test2_addr, rc);
+			goto done;
+		}
+
+		rc = pm8xxx_misc_masked_write(chip, test2_addr,
+			PM8058_REGULATOR_BANK_WRITE | PM8058_REGULATOR_BANK_MASK
+				| PM8058_SMPS_LEGACY_VLOW_SEL,
+			PM8058_REGULATOR_BANK_WRITE |
+			PM8058_REGULATOR_BANK_SEL(1) | vlow_sel);
+		if (rc)
+			goto done;
+
+		/* Switch to legacy mode */
+		bank = PM8058_REGULATOR_BANK_SEL(7);
+		rc = pm8xxx_writeb(chip->dev->parent, test2_addr, bank);
+		if (rc) {
+			pr_err("%s: FAIL pm8xxx_writeb(0x%03X): rc=%d\n",
+					__func__, test2_addr, rc);
+			goto done;
+		}
+		rc = pm8xxx_misc_masked_write(chip, test2_addr,
+				PM8058_REGULATOR_BANK_WRITE |
+				PM8058_REGULATOR_BANK_MASK |
+				PM8058_SMPS_ADVANCED_MODE_MASK,
+				PM8058_REGULATOR_BANK_WRITE |
+				PM8058_REGULATOR_BANK_SEL(7) |
+				PM8058_SMPS_LEGACY_MODE);
+		if (rc)
+			goto done;
+
+		/* Enable locally, enable pull down, keep voltage the same. */
+		rc = pm8xxx_misc_masked_write(chip, ctrl_addr,
+			PM8058_REGULATOR_ENABLE_MASK |
+			PM8058_REGULATOR_PULL_DOWN_MASK |
+			PM8058_SMPS_LEGACY_VREF_SEL |
+			PM8058_SMPS_LEGACY_VPROG_MASK,
+			PM8058_REGULATOR_ENABLE | PM8058_REGULATOR_PULL_DOWN_EN
+				| vref_sel | vprog);
+		if (rc)
+			goto done;
+	}
+
+	/* Enable in master control register. */
+	rc = pm8xxx_misc_masked_write(chip, master_enable_addr,
+			master_enable_bit, master_enable_bit);
+	if (rc)
+		goto done;
+
+	/* Disable locally and enable pull down. */
+	rc = pm8xxx_misc_masked_write(chip, ctrl_addr,
+		PM8058_REGULATOR_ENABLE_MASK | PM8058_REGULATOR_PULL_DOWN_MASK,
+		PM8058_REGULATOR_DISABLE | PM8058_REGULATOR_PULL_DOWN_EN);
+
+done:
+	return rc;
+}
+
+static int
+__pm8058_disable_ldo_locally_set_pull_down(struct pm8xxx_misc_chip *chip,
+		u16 ctrl_addr, u16 master_enable_addr, u8 master_enable_bit)
+{
+	int rc;
+
+	/* Enable LDO in master control register. */
+	rc = pm8xxx_misc_masked_write(chip, master_enable_addr,
+			master_enable_bit, master_enable_bit);
+	if (rc)
+		goto done;
+
+	/* Disable LDO in CTRL register and set pull down */
+	rc = pm8xxx_misc_masked_write(chip, ctrl_addr,
+		PM8058_REGULATOR_ENABLE_MASK | PM8058_REGULATOR_PULL_DOWN_MASK,
+		PM8058_REGULATOR_DISABLE | PM8058_REGULATOR_PULL_DOWN_EN);
+
+done:
+	return rc;
+}
+
+static int __pm8018_reset_pwr_off(struct pm8xxx_misc_chip *chip, int reset)
+{
+	int rc;
+
+	/* Enable SMPL if resetting is desired. */
+	rc = pm8xxx_misc_masked_write(chip, REG_PM8018_SLEEP_CTRL,
+	       SLEEP_CTRL_SMPL_EN_MASK,
+	       (reset ? SLEEP_CTRL_SMPL_EN_RESET : SLEEP_CTRL_SMPL_EN_PWR_OFF));
+	if (rc) {
+		pr_err("pm8xxx_misc_masked_write failed, rc=%d\n", rc);
+		return rc;
+	}
+
+	/*
+	 * Select action to perform (reset or shutdown) when PS_HOLD goes low.
+	 * Also ensure that KPD, CBL0, and CBL1 pull ups are enabled and that
+	 * USB charging is enabled.
+	 */
+	rc = pm8xxx_misc_masked_write(chip, REG_PM8XXX_PON_CTRL_1,
+		PON_CTRL_1_PULL_UP_MASK | PON_CTRL_1_USB_PWR_EN
+		| PON_CTRL_1_WD_EN_MASK,
+		PON_CTRL_1_PULL_UP_MASK | PON_CTRL_1_USB_PWR_EN
+		| (reset ? PON_CTRL_1_WD_EN_RESET : PON_CTRL_1_WD_EN_PWR_OFF));
+	if (rc)
+		pr_err("pm8xxx_misc_masked_write failed, rc=%d\n", rc);
+
+	return rc;
+}
+
+static int __pm8058_reset_pwr_off(struct pm8xxx_misc_chip *chip, int reset)
+{
+	int rc;
+
+	/* When shutting down, enable active pulldowns on important rails. */
+	if (!reset) {
+		/* Disable SMPS's 0,1,3 locally and set pulldown enable bits. */
+		__pm8058_disable_smps_locally_set_pull_down(chip,
+			REG_PM8058_S0_CTRL, REG_PM8058_S0_TEST2,
+			REG_PM8058_VREG_EN_MSM, BIT(7));
+		__pm8058_disable_smps_locally_set_pull_down(chip,
+			REG_PM8058_S1_CTRL, REG_PM8058_S1_TEST2,
+			REG_PM8058_VREG_EN_MSM, BIT(6));
+		__pm8058_disable_smps_locally_set_pull_down(chip,
+			REG_PM8058_S3_CTRL, REG_PM8058_S3_TEST2,
+			REG_PM8058_VREG_EN_GRP_5_4, BIT(7) | BIT(4));
+		/* Disable LDO 21 locally and set pulldown enable bit. */
+		__pm8058_disable_ldo_locally_set_pull_down(chip,
+			REG_PM8058_L21_CTRL, REG_PM8058_VREG_EN_GRP_5_4,
+			BIT(1));
+	}
+
+	/*
+	 * Fix-up: Set regulator LDO22 to 1.225 V in high power mode. Leave its
+	 * pull-down state intact. This ensures a safe shutdown.
+	 */
+	rc = pm8xxx_misc_masked_write(chip, REG_PM8058_L22_CTRL, 0xBF, 0x93);
+	if (rc) {
+		pr_err("pm8xxx_misc_masked_write failed, rc=%d\n", rc);
+		goto read_write_err;
+	}
+
+	/* Enable SMPL if resetting is desired. */
+	rc = pm8xxx_misc_masked_write(chip, REG_PM8058_SLEEP_CTRL,
+	       SLEEP_CTRL_SMPL_EN_MASK,
+	       (reset ? SLEEP_CTRL_SMPL_EN_RESET : SLEEP_CTRL_SMPL_EN_PWR_OFF));
+	if (rc) {
+		pr_err("pm8xxx_misc_masked_write failed, rc=%d\n", rc);
+		goto read_write_err;
+	}
+
+	/*
+	 * Select action to perform (reset or shutdown) when PS_HOLD goes low.
+	 * Also ensure that KPD, CBL0, and CBL1 pull ups are enabled and that
+	 * USB charging is enabled.
+	 */
+	rc = pm8xxx_misc_masked_write(chip, REG_PM8XXX_PON_CTRL_1,
+		PON_CTRL_1_PULL_UP_MASK | PON_CTRL_1_USB_PWR_EN
+		| PON_CTRL_1_WD_EN_MASK,
+		PON_CTRL_1_PULL_UP_MASK | PON_CTRL_1_USB_PWR_EN
+		| (reset ? PON_CTRL_1_WD_EN_RESET : PON_CTRL_1_WD_EN_PWR_OFF));
+	if (rc) {
+		pr_err("pm8xxx_misc_masked_write failed, rc=%d\n", rc);
+		goto read_write_err;
+	}
+
+read_write_err:
+	return rc;
+}
+
+static int __pm8901_reset_pwr_off(struct pm8xxx_misc_chip *chip, int reset)
+{
+	int rc = 0, i;
+	u8 pmr_addr[4] = {
+		REG_PM8901_REGULATOR_S2_PMR,
+		REG_PM8901_REGULATOR_S3_PMR,
+		REG_PM8901_REGULATOR_S4_PMR,
+		REG_PM8901_REGULATOR_S1_PMR,
+	};
+
+	/* Fix-up: Turn off regulators S1, S2, S3, S4 when shutting down. */
+	if (!reset) {
+		for (i = 0; i < 4; i++) {
+			rc = pm8xxx_misc_masked_write(chip, pmr_addr[i],
+				PM8901_REGULATOR_PMR_STATE_MASK,
+				PM8901_REGULATOR_PMR_STATE_OFF);
+			if (rc) {
+				pr_err("pm8xxx_misc_masked_write failed, "
+					"rc=%d\n", rc);
+				goto read_write_err;
+			}
+			mdelay(PM8901_DELAY_AFTER_REG_DISABLE_MS);
+		}
+	}
+
+read_write_err:
+	mdelay(PM8901_DELAY_BEFORE_SHUTDOWN_MS);
+	return rc;
+}
+
+static int __pm8921_reset_pwr_off(struct pm8xxx_misc_chip *chip, int reset)
+{
+	int rc;
+
+	/* Enable SMPL if resetting is desired. */
+	rc = pm8xxx_misc_masked_write(chip, REG_PM8921_SLEEP_CTRL,
+	       SLEEP_CTRL_SMPL_EN_MASK,
+	       (reset ? SLEEP_CTRL_SMPL_EN_RESET : SLEEP_CTRL_SMPL_EN_PWR_OFF));
+	if (rc) {
+		pr_err("pm8xxx_misc_masked_write failed, rc=%d\n", rc);
+		goto read_write_err;
+	}
+
+	/*
+	 * Select action to perform (reset or shutdown) when PS_HOLD goes low.
+	 * Also ensure that KPD, CBL0, and CBL1 pull ups are enabled and that
+	 * USB charging is enabled.
+	 */
+	rc = pm8xxx_misc_masked_write(chip, REG_PM8XXX_PON_CTRL_1,
+		PON_CTRL_1_PULL_UP_MASK | PON_CTRL_1_USB_PWR_EN
+		| PON_CTRL_1_WD_EN_MASK,
+		PON_CTRL_1_PULL_UP_MASK | PON_CTRL_1_USB_PWR_EN
+		| (reset ? PON_CTRL_1_WD_EN_RESET : PON_CTRL_1_WD_EN_PWR_OFF));
+	if (rc) {
+		pr_err("pm8xxx_misc_masked_write failed, rc=%d\n", rc);
+		goto read_write_err;
+	}
+
+read_write_err:
+	return rc;
+}
+
+/**
+ * pm8xxx_reset_pwr_off - switch all PM8XXX PMIC chips attached to the system to
+ *			  either reset or shutdown when they are turned off
+ * @reset: 0 = shudown the PMICs, 1 = shutdown and then restart the PMICs
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_reset_pwr_off(int reset)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8018:
+			rc = __pm8018_reset_pwr_off(chip, reset);
+			break;
+		case PM8XXX_VERSION_8058:
+			rc = __pm8058_reset_pwr_off(chip, reset);
+			break;
+		case PM8XXX_VERSION_8901:
+			rc = __pm8901_reset_pwr_off(chip, reset);
+			break;
+		case PM8XXX_VERSION_8038:
+		case PM8XXX_VERSION_8917:
+		case PM8XXX_VERSION_8921:
+			rc = __pm8921_reset_pwr_off(chip, reset);
+			break;
+		default:
+			/* PMIC doesn't have reset_pwr_off; do nothing. */
+			break;
+		}
+		if (rc) {
+			pr_err("reset_pwr_off failed, rc=%d\n", rc);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pm8xxx_reset_pwr_off);
+
+/**
+ * pm8xxx_smpl_control - enables/disables SMPL detection
+ * @enable: 0 = shutdown PMIC on power loss, 1 = reset PMIC on power loss
+ *
+ * This function enables or disables the Sudden Momentary Power Loss detection
+ * module.  If SMPL detection is enabled, then when a sufficiently long power
+ * loss event occurs, the PMIC will automatically reset itself.  If SMPL
+ * detection is disabled, then the PMIC will shutdown when power loss occurs.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_smpl_control(int enable)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8018:
+			rc = pm8xxx_misc_masked_write(chip,
+				REG_PM8018_SLEEP_CTRL, SLEEP_CTRL_SMPL_EN_MASK,
+				(enable ? SLEEP_CTRL_SMPL_EN_RESET
+					   : SLEEP_CTRL_SMPL_EN_PWR_OFF));
+			break;
+		case PM8XXX_VERSION_8058:
+			rc = pm8xxx_misc_masked_write(chip,
+				REG_PM8058_SLEEP_CTRL, SLEEP_CTRL_SMPL_EN_MASK,
+				(enable ? SLEEP_CTRL_SMPL_EN_RESET
+					   : SLEEP_CTRL_SMPL_EN_PWR_OFF));
+			break;
+		case PM8XXX_VERSION_8921:
+			rc = pm8xxx_misc_masked_write(chip,
+				REG_PM8921_SLEEP_CTRL, SLEEP_CTRL_SMPL_EN_MASK,
+				(enable ? SLEEP_CTRL_SMPL_EN_RESET
+					   : SLEEP_CTRL_SMPL_EN_PWR_OFF));
+			break;
+		default:
+			/* PMIC doesn't have reset_pwr_off; do nothing. */
+			break;
+		}
+		if (rc) {
+			pr_err("setting smpl control failed, rc=%d\n", rc);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_smpl_control);
+
+
+/**
+ * pm8xxx_smpl_set_delay - sets the SMPL detection time delay
+ * @delay: enum value corresponding to delay time
+ *
+ * This function sets the time delay of the SMPL detection module.  If power
+ * is reapplied within this interval, then the PMIC reset automatically.  The
+ * SMPL detection module must be enabled for this delay time to take effect.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_smpl_set_delay(enum pm8xxx_smpl_delay delay)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = 0;
+
+	if (delay < SLEEP_CTRL_SMPL_SEL_MIN
+	    || delay > SLEEP_CTRL_SMPL_SEL_MAX) {
+		pr_err("%s: invalid delay specified: %d\n", __func__, delay);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8018:
+			rc = pm8xxx_misc_masked_write(chip,
+				REG_PM8018_SLEEP_CTRL, SLEEP_CTRL_SMPL_SEL_MASK,
+				delay);
+			break;
+		case PM8XXX_VERSION_8058:
+			rc = pm8xxx_misc_masked_write(chip,
+				REG_PM8058_SLEEP_CTRL, SLEEP_CTRL_SMPL_SEL_MASK,
+				delay);
+			break;
+		case PM8XXX_VERSION_8921:
+			rc = pm8xxx_misc_masked_write(chip,
+				REG_PM8921_SLEEP_CTRL, SLEEP_CTRL_SMPL_SEL_MASK,
+				delay);
+			break;
+		default:
+			/* PMIC doesn't have reset_pwr_off; do nothing. */
+			break;
+		}
+		if (rc) {
+			pr_err("setting smpl delay failed, rc=%d\n", rc);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_smpl_set_delay);
+
+/**
+ * pm8xxx_coincell_chg_config - Disables or enables the coincell charger, and
+ *				configures its voltage and resistor settings.
+ * @chg_config:			Holds both voltage and resistor values, and a
+ *				switch to change the state of charger.
+ *				If state is to disable the charger then
+ *				both voltage and resistor are disregarded.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_coincell_chg_config(struct pm8xxx_coincell_chg *chg_config)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	u8 reg = 0, voltage, resistor;
+	int rc = 0;
+
+	if (chg_config == NULL) {
+		pr_err("chg_config is NULL\n");
+		return -EINVAL;
+	}
+
+	voltage = chg_config->voltage;
+	resistor = chg_config->resistor;
+
+	if (resistor < PM8XXX_COINCELL_RESISTOR_2100_OHMS ||
+			resistor > PM8XXX_COINCELL_RESISTOR_800_OHMS) {
+		pr_err("Invalid resistor value provided\n");
+		return -EINVAL;
+	}
+
+	if (voltage < PM8XXX_COINCELL_VOLTAGE_3p2V ||
+		(voltage > PM8XXX_COINCELL_VOLTAGE_3p0V &&
+			voltage != PM8XXX_COINCELL_VOLTAGE_2p5V)) {
+		pr_err("Invalid voltage value provided\n");
+		return -EINVAL;
+	}
+
+	if (chg_config->state == PM8XXX_COINCELL_CHG_DISABLE) {
+		reg = 0;
+	} else {
+		reg |= voltage;
+		reg |= (resistor << COINCELL_RESISTOR_SHIFT);
+	}
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8018:
+			rc = pm8xxx_writeb(chip->dev->parent,
+					REG_PM8018_COIN_CHG, reg);
+			break;
+		case PM8XXX_VERSION_8058:
+			rc = pm8xxx_writeb(chip->dev->parent,
+					REG_PM8058_COIN_CHG, reg);
+			break;
+		case PM8XXX_VERSION_8921:
+			rc = pm8xxx_writeb(chip->dev->parent,
+					REG_PM8921_COIN_CHG, reg);
+			break;
+		default:
+			/* PMIC doesn't have reset_pwr_off; do nothing. */
+			break;
+		}
+		if (rc) {
+			pr_err("coincell chg. config failed, rc=%d\n", rc);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_coincell_chg_config);
+
+/**
+ * pm8xxx_watchdog_reset_control - enables/disables watchdog reset detection
+ * @enable: 0 = shutdown when PS_HOLD goes low, 1 = reset when PS_HOLD goes low
+ *
+ * This function enables or disables the PMIC watchdog reset detection feature.
+ * If watchdog reset detection is enabled, then the PMIC will reset itself
+ * when PS_HOLD goes low.  If it is not enabled, then the PMIC will shutdown
+ * when PS_HOLD goes low.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_watchdog_reset_control(int enable)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8018:
+		case PM8XXX_VERSION_8058:
+		case PM8XXX_VERSION_8921:
+			rc = pm8xxx_misc_masked_write(chip,
+				REG_PM8XXX_PON_CTRL_1, PON_CTRL_1_WD_EN_MASK,
+				(enable ? PON_CTRL_1_WD_EN_RESET
+					   : PON_CTRL_1_WD_EN_PWR_OFF));
+			break;
+		default:
+			/* WD reset control not supported */
+			break;
+		}
+		if (rc) {
+			pr_err("setting WD reset control failed, rc=%d\n", rc);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_watchdog_reset_control);
+
+/**
+ * pm8xxx_stay_on - enables stay_on feature
+ *
+ * PMIC stay-on feature allows PMIC to ignore MSM PS_HOLD=low
+ * signal so that some special functions like debugging could be
+ * performed.
+ *
+ * This feature should not be used in any product release.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_stay_on(void)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8018:
+		case PM8XXX_VERSION_8058:
+		case PM8XXX_VERSION_8921:
+			rc = pm8xxx_writeb(chip->dev->parent,
+				REG_PM8XXX_GP_TEST_1, PM8XXX_STAY_ON_CFG);
+			break;
+		default:
+			/* stay on not supported */
+			break;
+		}
+		if (rc) {
+			pr_err("stay_on failed failed, rc=%d\n", rc);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_stay_on);
+
+static int
+__pm8xxx_hard_reset_config(struct pm8xxx_misc_chip *chip,
+		enum pm8xxx_pon_config config, u16 pon4_addr, u16 pon5_addr)
+{
+	int rc = 0;
+
+	switch (config) {
+	case PM8XXX_DISABLE_HARD_RESET:
+		rc = pm8xxx_misc_masked_write(chip, pon5_addr,
+				PON_CTRL_5_HARD_RESET_EN_MASK,
+				PON_CTRL_5_HARD_RESET_DIS);
+		break;
+	case PM8XXX_SHUTDOWN_ON_HARD_RESET:
+		rc = pm8xxx_misc_masked_write(chip, pon5_addr,
+				PON_CTRL_5_HARD_RESET_EN_MASK,
+				PON_CTRL_5_HARD_RESET_EN);
+		if (!rc) {
+			rc = pm8xxx_misc_masked_write(chip, pon4_addr,
+					PON_CTRL_4_RESET_EN_MASK,
+					PON_CTRL_4_SHUTDOWN_ON_RESET);
+		}
+		break;
+	case PM8XXX_RESTART_ON_HARD_RESET:
+		rc = pm8xxx_misc_masked_write(chip, pon5_addr,
+				PON_CTRL_5_HARD_RESET_EN_MASK,
+				PON_CTRL_5_HARD_RESET_EN);
+		if (!rc) {
+			rc = pm8xxx_misc_masked_write(chip, pon4_addr,
+					PON_CTRL_4_RESET_EN_MASK,
+					PON_CTRL_4_RESTART_ON_RESET);
+		}
+		break;
+	default:
+		rc = -EINVAL;
+		break;
+	}
+	return rc;
+}
+
+/**
+ * pm8xxx_hard_reset_config - Allows different reset configurations
+ *
+ * config = PM8XXX_DISABLE_HARD_RESET to disable hard reset
+ *	  = PM8XXX_SHUTDOWN_ON_HARD_RESET to turn off the system on hard reset
+ *	  = PM8XXX_RESTART_ON_HARD_RESET to restart the system on hard reset
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_hard_reset_config(enum pm8xxx_pon_config config)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8018:
+			__pm8xxx_hard_reset_config(chip, config,
+				REG_PM8018_PON_CNTL_4, REG_PM8018_PON_CNTL_5);
+			break;
+		case PM8XXX_VERSION_8058:
+			__pm8xxx_hard_reset_config(chip, config,
+				REG_PM8058_PON_CNTL_4, REG_PM8058_PON_CNTL_5);
+			break;
+		case PM8XXX_VERSION_8901:
+			__pm8xxx_hard_reset_config(chip, config,
+				REG_PM8901_PON_CNTL_4, REG_PM8901_PON_CNTL_5);
+			break;
+		case PM8XXX_VERSION_8921:
+			__pm8xxx_hard_reset_config(chip, config,
+				REG_PM8921_PON_CNTL_4, REG_PM8921_PON_CNTL_5);
+			break;
+		default:
+			/* hard reset config. no supported */
+			break;
+		}
+		if (rc) {
+			pr_err("hard reset config. failed, rc=%d\n", rc);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_hard_reset_config);
+
+/* Handle the OSC_HALT interrupt: 32 kHz XTAL oscillator has stopped. */
+static irqreturn_t pm8xxx_osc_halt_isr(int irq, void *data)
+{
+	struct pm8xxx_misc_chip *chip = data;
+	u64 count = 0;
+
+	if (chip) {
+		chip->osc_halt_count++;
+		count = chip->osc_halt_count;
+	}
+
+	pr_crit("%s: OSC_HALT interrupt has triggered, 32 kHz XTAL oscillator"
+				" has halted (%llu)!\n", __func__, count);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * pm8xxx_uart_gpio_mux_ctrl - Mux configuration to select the UART
+ *
+ * @uart_path_sel: Input argument to select either UART1/2/3
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_uart_gpio_mux_ctrl(enum pm8xxx_uart_path_sel uart_path_sel)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8018:
+		case PM8XXX_VERSION_8058:
+		case PM8XXX_VERSION_8921:
+			rc = pm8xxx_misc_masked_write(chip,
+				REG_PM8XXX_GPIO_MUX_CTRL, UART_PATH_SEL_MASK,
+				uart_path_sel << UART_PATH_SEL_SHIFT);
+			break;
+		default:
+			/* Functionality not supported */
+			break;
+		}
+		if (rc) {
+			pr_err("uart_gpio_mux_ctrl failed, rc=%d\n", rc);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_uart_gpio_mux_ctrl);
+
+/**
+ * pm8xxx_usb_id_pullup - Control a pullup for USB ID
+ *
+ * @enable: enable (1) or disable (0) the pullup
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_usb_id_pullup(int enable)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = -ENXIO;
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8921:
+		case PM8XXX_VERSION_8922:
+		case PM8XXX_VERSION_8917:
+		case PM8XXX_VERSION_8038:
+			rc = pm8xxx_misc_masked_write(chip,
+				REG_PM8XXX_GPIO_MUX_CTRL, USB_ID_PU_EN_MASK,
+				enable << USB_ID_PU_EN_SHIFT);
+
+			if (rc)
+				pr_err("Fail: reg=%x, rc=%d\n",
+				       REG_PM8XXX_GPIO_MUX_CTRL, rc);
+			break;
+		default:
+			/* Functionality not supported */
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_usb_id_pullup);
+
+static int __pm8901_preload_dVdd(struct pm8xxx_misc_chip *chip)
+{
+	int rc;
+
+	/* dVdd preloading is not needed for PMIC PM8901 rev 2.3 and beyond. */
+	if (pm8xxx_get_revision(chip->dev->parent) >= PM8XXX_REVISION_8901_2p3)
+		return 0;
+
+	rc = pm8xxx_writeb(chip->dev->parent, 0x0BD, 0x0F);
+	if (rc)
+		pr_err("pm8xxx_writeb failed for 0x0BD, rc=%d\n", rc);
+
+	rc = pm8xxx_writeb(chip->dev->parent, 0x001, 0xB4);
+	if (rc)
+		pr_err("pm8xxx_writeb failed for 0x001, rc=%d\n", rc);
+
+	pr_info("dVdd preloaded\n");
+
+	return rc;
+}
+
+/**
+ * pm8xxx_preload_dVdd - preload the dVdd regulator during off state.
+ *
+ * This can help to reduce fluctuations in the dVdd voltage during startup
+ * at the cost of additional off state current draw.
+ *
+ * This API should only be called if dVdd startup issues are suspected.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_preload_dVdd(void)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8901:
+			rc = __pm8901_preload_dVdd(chip);
+			break;
+		default:
+			/* PMIC doesn't have preload_dVdd; do nothing. */
+			break;
+		}
+		if (rc) {
+			pr_err("preload_dVdd failed, rc=%d\n", rc);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pm8xxx_preload_dVdd);
+
+int pm8xxx_aux_clk_control(enum pm8xxx_aux_clk_id clk_id,
+				enum pm8xxx_aux_clk_div divider, bool enable)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	u8 clk_mask = 0, value = 0;
+
+	if (clk_id == CLK_MP3_1) {
+		clk_mask = MP3_1_MASK;
+		value = divider << MP3_1_SHIFT;
+	} else if (clk_id == CLK_MP3_2) {
+		clk_mask = MP3_2_MASK;
+		value = divider << MP3_2_SHIFT;
+	} else {
+		pr_err("Invalid clock id of %d\n", clk_id);
+		return -EINVAL;
+	}
+	if (!enable)
+		value = 0;
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8038:
+		case PM8XXX_VERSION_8921:
+			pm8xxx_misc_masked_write(chip,
+					REG_PM8XXX_XO_CNTRL_2, clk_mask, value);
+			break;
+		default:
+			/* Functionality not supported */
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pm8xxx_aux_clk_control);
+
+int pm8xxx_hsed_bias_control(enum pm8xxx_hsed_bias bias, bool enable)
+{
+	struct pm8xxx_misc_chip *chip;
+	unsigned long flags;
+	int rc = 0;
+	u16 addr;
+
+	switch (bias) {
+	case PM8XXX_HSED_BIAS0:
+		addr = REG_HSED_BIAS0_CNTL2;
+		break;
+	case PM8XXX_HSED_BIAS1:
+		addr = REG_HSED_BIAS1_CNTL2;
+		break;
+	case PM8XXX_HSED_BIAS2:
+		addr = REG_HSED_BIAS2_CNTL2;
+		break;
+	default:
+		pr_err("Invalid BIAS line\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+
+	/* Loop over all attached PMICs and call specific functions for them. */
+	list_for_each_entry(chip, &pm8xxx_misc_chips, link) {
+		switch (chip->version) {
+		case PM8XXX_VERSION_8058:
+		case PM8XXX_VERSION_8921:
+			rc = pm8xxx_misc_masked_write(chip, addr,
+				HSED_EN_MASK, enable ? HSED_EN_MASK : 0);
+			if (rc < 0)
+				pr_err("Enable HSED BIAS failed rc=%d\n", rc);
+			break;
+		default:
+			/* Functionality not supported */
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_hsed_bias_control);
+
+static int __devinit pm8xxx_misc_probe(struct platform_device *pdev)
+{
+	const struct pm8xxx_misc_platform_data *pdata = pdev->dev.platform_data;
+	struct pm8xxx_misc_chip *chip;
+	struct pm8xxx_misc_chip *sibling;
+	struct list_head *prev;
+	unsigned long flags;
+	int rc = 0, irq;
+
+	if (!pdata) {
+		pr_err("missing platform data\n");
+		return -EINVAL;
+	}
+
+	chip = kzalloc(sizeof(struct pm8xxx_misc_chip), GFP_KERNEL);
+	if (!chip) {
+		pr_err("Cannot allocate %d bytes\n",
+			sizeof(struct pm8xxx_misc_chip));
+		return -ENOMEM;
+	}
+
+	chip->dev = &pdev->dev;
+	chip->version = pm8xxx_get_version(chip->dev->parent);
+	memcpy(&(chip->pdata), pdata, sizeof(struct pm8xxx_misc_platform_data));
+
+	irq = platform_get_irq_byname(pdev, "pm8xxx_osc_halt_irq");
+	if (irq > 0) {
+		rc = request_any_context_irq(irq, pm8xxx_osc_halt_isr,
+				 IRQF_TRIGGER_RISING | IRQF_DISABLED,
+				 "pm8xxx_osc_halt_irq", chip);
+		if (rc < 0) {
+			pr_err("%s: request_any_context_irq(%d) FAIL: %d\n",
+							 __func__, irq, rc);
+			goto fail_irq;
+		}
+	}
+
+	/* Insert PMICs in priority order (lowest value first). */
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+	prev = &pm8xxx_misc_chips;
+	list_for_each_entry(sibling, &pm8xxx_misc_chips, link) {
+		if (chip->pdata.priority < sibling->pdata.priority)
+			break;
+		else
+			prev = &sibling->link;
+	}
+	list_add(&chip->link, prev);
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	platform_set_drvdata(pdev, chip);
+
+	return rc;
+
+fail_irq:
+	platform_set_drvdata(pdev, NULL);
+	kfree(chip);
+	return rc;
+}
+
+static int __devexit pm8xxx_misc_remove(struct platform_device *pdev)
+{
+	struct pm8xxx_misc_chip *chip = platform_get_drvdata(pdev);
+	unsigned long flags;
+	int irq = platform_get_irq_byname(pdev, "pm8xxx_osc_halt_irq");
+	if (irq > 0)
+		free_irq(irq, chip);
+
+	spin_lock_irqsave(&pm8xxx_misc_chips_lock, flags);
+	list_del(&chip->link);
+	spin_unlock_irqrestore(&pm8xxx_misc_chips_lock, flags);
+
+	platform_set_drvdata(pdev, NULL);
+	kfree(chip);
+
+	return 0;
+}
+
+static struct platform_driver pm8xxx_misc_driver = {
+	.probe	= pm8xxx_misc_probe,
+	.remove	= __devexit_p(pm8xxx_misc_remove),
+	.driver	= {
+		.name	= PM8XXX_MISC_DEV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init pm8xxx_misc_init(void)
+{
+	return platform_driver_register(&pm8xxx_misc_driver);
+}
+postcore_initcall(pm8xxx_misc_init);
+
+static void __exit pm8xxx_misc_exit(void)
+{
+	platform_driver_unregister(&pm8xxx_misc_driver);
+}
+module_exit(pm8xxx_misc_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("PMIC 8XXX misc driver");
+MODULE_VERSION("1.0");
+MODULE_ALIAS("platform:" PM8XXX_MISC_DEV_NAME);
diff --git a/drivers/mfd/pm8xxx-pwm.c b/drivers/mfd/pm8xxx-pwm.c
new file mode 100644
index 0000000..6f6369b
--- /dev/null
+++ b/drivers/mfd/pm8xxx-pwm.c
@@ -0,0 +1,1471 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+ * Qualcomm PM8XXX Pulse Width Modulation (PWM) driver
+ *
+ * The HW module is also called LPG (Light Pulse Generator).
+ */
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/debugfs.h>
+#include <linux/mfd/pm8xxx/core.h>
+#include <linux/mfd/pm8xxx/pwm.h>
+
+#define PM8XXX_PWM_CHANNELS		3
+
+/*
+ * For the lack of better term to distinguish functional
+ * differences, hereby, LPG version 0 (V0, v0) denotes
+ * PM8058/8921, and version 1 (V1, v1) denotes
+ * PM8922/8038.
+ */
+#define PM8XXX_LPG_V0_PWM_CHANNELS	8
+#define PM8XXX_LPG_V1_PWM_CHANNELS	6
+#define PM8XXX_LPG_CTL_REGS		7
+
+/* PM8XXX PWM */
+#define SSBI_REG_ADDR_PWM1_CTRL1	0x88
+#define SSBI_REG_ADDR_PWM1_CTRL2	0x89
+#define SSBI_REG_ADDR_PWM_CTL(id, base) (id == 0 ? base : (base + (id << 1)))
+#define SSBI_REG_ADDR_PWM_CTL1(id)	SSBI_REG_ADDR_PWM_CTL(id, \
+						SSBI_REG_ADDR_PWM1_CTRL1)
+#define SSBI_REG_ADDR_PWM_CTL2(id)	SSBI_REG_ADDR_PWM_CTL(id, \
+						SSBI_REG_ADDR_PWM1_CTRL2)
+
+#define PM8XXX_PWM_CLK_SEL_SHIFT	6
+#define PM8XXX_PWM_CLK_SEL_MASK		0xC0
+#define PM8XXX_PWM_PREDIVIDE_SHIFT	5
+#define PM8XXX_PWM_PREDIVIDE_MASK	0x20
+#define PM8XXX_PWM_M_SHIFT		2
+#define PM8XXX_PWM_M_MASK		0x1C
+#define PM8XXX_PWM_SIZE_SHIFT		1
+#define PM8XXX_PWM_SIZE_MASK		0x02
+#define PM8XXX_PWM_VALUE_BIT0		0x01
+#define PM8XXX_PWM_DISABLE		0x3F
+
+/* PM8XXX LPG PWM */
+#define SSBI_REG_ADDR_LPG_CTL_BASE	0x13C
+#define SSBI_REG_ADDR_LPG_CTL(n)	(SSBI_REG_ADDR_LPG_CTL_BASE + (n))
+#define SSBI_REG_ADDR_LPG_BANK_SEL	0x143
+#define SSBI_REG_ADDR_LPG_BANK_EN	0x144
+#define SSBI_REG_ADDR_LPG_LUT_CFG0	0x145
+#define SSBI_REG_ADDR_LPG_LUT_CFG1	0x146
+#define SSBI_REG_ADDR_LPG_TEST		0x147
+
+/* LPG Control 0 */
+#define PM8XXX_PWM_1KHZ_COUNT_MASK	0xF0
+#define PM8XXX_PWM_1KHZ_COUNT_SHIFT	4
+
+#define PM8XXX_PWM_1KHZ_COUNT_MAX	15
+
+#define PM8XXX_PWM_OUTPUT_EN		0x08
+#define PM8XXX_PWM_PWM_EN		0x04
+#define PM8XXX_PWM_RAMP_GEN_EN		0x02
+#define PM8XXX_PWM_RAMP_START		0x01
+
+#define PM8XXX_PWM_PWM_START		(PM8XXX_PWM_OUTPUT_EN \
+					| PM8XXX_PWM_PWM_EN)
+#define PM8XXX_PWM_RAMP_GEN_START	(PM8XXX_PWM_RAMP_GEN_EN \
+					| PM8XXX_PWM_RAMP_START)
+
+/* LPG Control 1 */
+#define PM8XXX_PWM_REVERSE_EN		0x80
+#define PM8XXX_PWM_BYPASS_LUT		0x40
+#define PM8XXX_PWM_HIGH_INDEX_MASK	0x3F
+
+/* LPG Control 2 */
+#define PM8XXX_PWM_LOOP_EN		0x80
+#define PM8XXX_PWM_RAMP_UP		0x40
+#define PM8XXX_PWM_LOW_INDEX_MASK	0x3F
+
+/* LPG Control 3 */
+#define PM8XXX_PWM_VALUE_BIT7_0		0xFF
+#define PM8XXX_PWM_VALUE_BIT5_0		0x3F
+
+/* LPG Control 4 */
+#define PM8XXX_PWM_VALUE_BIT8		0x80
+
+#define PM8XXX_LPG_PWM_CLK_SEL_MASK	0x60
+#define PM8XXX_LPG_PWM_CLK_SEL_SHIFT	5
+
+#define PM8XXX_PWM_CLK_SEL_NO		0
+#define PM8XXX_PWM_CLK_SEL_1KHZ		1
+#define PM8XXX_PWM_CLK_SEL_32KHZ	2
+#define PM8XXX_PWM_CLK_SEL_19P2MHZ	3
+
+#define PM8XXX_LPG_PWM_PREDIVIDE_MASK	0x18
+#define PM8XXX_LPG_PWM_PREDIVIDE_SHIFT	3
+
+#define PM8XXX_PWM_PREDIVIDE_2		0
+#define PM8XXX_PWM_PREDIVIDE_3		1
+#define PM8XXX_PWM_PREDIVIDE_5		2
+#define PM8XXX_PWM_PREDIVIDE_6		3
+
+#define PM8XXX_LPG_PWM_M_MASK		0x07
+#define PM8XXX_PWM_M_MIN		0
+#define PM8XXX_PWM_M_MAX		7
+
+/* LPG Control 5 */
+#define PM8XXX_PWM_PAUSE_COUNT_HI_MASK		0xFC
+#define PM8XXX_PWM_PAUSE_COUNT_HI_SHIFT		2
+
+#define PM8XXX_PWM_PAUSE_ENABLE_HIGH		0x02
+#define PM8XXX_PWM_SIZE_9_BIT			0x01
+
+/* LPG Control 6 */
+#define PM8XXX_PWM_PAUSE_COUNT_LO_MASK		0xFC
+#define PM8XXX_PWM_PAUSE_COUNT_LO_SHIFT		2
+
+#define PM8XXX_PWM_PAUSE_ENABLE_LOW		0x02
+#define PM8XXX_PWM_RESERVED			0x01
+
+#define PM8XXX_PWM_PAUSE_COUNT_MAX		56 /* < 2^6 = 64 */
+
+/* LPG LUT_CFG1 */
+#define PM8XXX_PWM_LUT_READ			0x40
+
+/* TEST */
+#define PM8XXX_PWM_DTEST_MASK		0x38
+#define PM8XXX_PWM_DTEST_SHIFT		3
+#define PM8XXX_PWM_DTEST_BANK_MASK	0x07
+
+/*
+ * PWM Frequency = Clock Frequency / (N * T)
+ *	or
+ * PWM Period = Clock Period * (N * T)
+ *	where
+ * N = 2^9 or 2^6 for 9-bit or 6-bit PWM size
+ * T = Pre-divide * 2^m, where m = 0..7 (exponent)
+ *
+ * This is the formula to figure out m for the best pre-divide and clock:
+ * (PWM Period / N) = (Pre-divide * Clock Period) * 2^m
+ */
+#define NUM_CLOCKS	3
+
+#define NSEC_1024HZ	(NSEC_PER_SEC / 1024)
+#define NSEC_32768HZ	(NSEC_PER_SEC / 32768)
+#define NSEC_19P2MHZ	(NSEC_PER_SEC / 19200000)
+
+#define NUM_LPG_PRE_DIVIDE	4
+#define NUM_PWM_PRE_DIVIDE	2
+
+#define PRE_DIVIDE_1		1	/* v1 */
+#define PRE_DIVIDE_2		2
+#define PRE_DIVIDE_3		3
+#define PRE_DIVIDE_5		5
+#define PRE_DIVIDE_6		6
+
+static unsigned int pt_t[NUM_LPG_PRE_DIVIDE][NUM_CLOCKS] = {
+	{	PRE_DIVIDE_2 * NSEC_1024HZ,
+		PRE_DIVIDE_2 * NSEC_32768HZ,
+		PRE_DIVIDE_2 * NSEC_19P2MHZ,
+	},
+	{	PRE_DIVIDE_3 * NSEC_1024HZ,
+		PRE_DIVIDE_3 * NSEC_32768HZ,
+		PRE_DIVIDE_3 * NSEC_19P2MHZ,
+	},
+	{	PRE_DIVIDE_5 * NSEC_1024HZ,
+		PRE_DIVIDE_5 * NSEC_32768HZ,
+		PRE_DIVIDE_5 * NSEC_19P2MHZ,
+	},
+	{	PRE_DIVIDE_6 * NSEC_1024HZ,
+		PRE_DIVIDE_6 * NSEC_32768HZ,
+		PRE_DIVIDE_6 * NSEC_19P2MHZ,
+	},
+};
+
+/* Private data */
+struct pm8xxx_pwm_chip;
+
+struct pwm_device {
+	int			pwm_id;		/* = bank/channel id */
+	int			in_use;
+	const char		*label;
+	struct pm8xxx_pwm_period	period;
+	int			pwm_value;
+	int			pwm_period;
+	int			pwm_duty;
+	u8			pwm_lpg_ctl[PM8XXX_LPG_CTL_REGS];
+	u8			pwm_ctl1;
+	u8			pwm_ctl2;
+	int			irq;
+	struct pm8xxx_pwm_chip	*chip;
+	int			bypass_lut;
+	int			dtest_mode_supported;
+};
+
+struct pm8xxx_pwm_chip {
+	struct pwm_device		*pwm_dev;
+	u8				pwm_channels;
+	u8				pwm_total_pre_divs;
+	u8				bank_mask;
+	struct mutex			pwm_mutex;
+	struct device			*dev;
+	bool				is_lpg_supported;
+};
+
+static struct pm8xxx_pwm_chip	*pwm_chip;
+
+struct pm8xxx_pwm_lut {
+	/* LUT parameters */
+	int	lut_duty_ms;
+	int	lut_lo_index;
+	int	lut_hi_index;
+	int	lut_pause_hi;
+	int	lut_pause_lo;
+	int	flags;
+};
+
+static const u16 duty_msec[PM8XXX_PWM_1KHZ_COUNT_MAX + 1] = {
+	0, 1, 2, 3, 4, 6, 8, 16, 18, 24, 32, 36, 64, 128, 256, 512
+};
+
+static const u16 pause_count[PM8XXX_PWM_PAUSE_COUNT_MAX + 1] = {
+	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
+	23, 28, 31, 42, 47, 56, 63, 83, 94, 111, 125, 167, 188, 222, 250, 333,
+	375, 500, 667, 750, 800, 900, 1000, 1100,
+	1200, 1300, 1400, 1500, 1600, 1800, 2000, 2500,
+	3000, 3500, 4000, 4500, 5000, 5500, 6000, 6500,
+	7000
+};
+
+/* Internal functions */
+static void pm8xxx_pwm_save(u8 *u8p, u8 mask, u8 val)
+{
+	*u8p &= ~mask;
+	*u8p |= val & mask;
+}
+
+static int pm8xxx_pwm_bank_enable(struct pwm_device *pwm, int enable)
+{
+	int	rc;
+	u8	reg;
+	struct pm8xxx_pwm_chip	*chip;
+
+	chip = pwm->chip;
+
+	if (enable)
+		reg = chip->bank_mask | (1 << pwm->pwm_id);
+	else
+		reg = chip->bank_mask & ~(1 << pwm->pwm_id);
+
+	rc = pm8xxx_writeb(chip->dev->parent, SSBI_REG_ADDR_LPG_BANK_EN, reg);
+	if (rc) {
+		pr_err("pm8xxx_writeb(): rc=%d (Enable LPG Bank)\n", rc);
+		return rc;
+	}
+	chip->bank_mask = reg;
+
+	return 0;
+}
+
+static int pm8xxx_pwm_bank_sel(struct pwm_device *pwm)
+{
+	int	rc;
+
+	rc = pm8xxx_writeb(pwm->chip->dev->parent, SSBI_REG_ADDR_LPG_BANK_SEL,
+			   pwm->pwm_id);
+	if (rc)
+		pr_err("pm8xxx_writeb(): rc=%d (Select PWM Bank)\n", rc);
+	return rc;
+}
+
+static int pm8xxx_pwm_start(struct pwm_device *pwm, int start, int ramp_start)
+{
+	int	rc;
+	u8	reg;
+
+	if (start) {
+		reg = pwm->pwm_lpg_ctl[0] | PM8XXX_PWM_PWM_START;
+		if (ramp_start)
+			reg |= PM8XXX_PWM_RAMP_GEN_START;
+		else
+			reg &= ~PM8XXX_PWM_RAMP_GEN_START;
+	} else {
+		reg = pwm->pwm_lpg_ctl[0] & ~PM8XXX_PWM_PWM_START;
+		reg &= ~PM8XXX_PWM_RAMP_GEN_START;
+	}
+
+	rc = pm8xxx_writeb(pwm->chip->dev->parent, SSBI_REG_ADDR_LPG_CTL(0),
+			   reg);
+	if (rc)
+		pr_err("pm8xxx_writeb(): rc=%d (Enable PWM Ctl 0)\n", rc);
+	else
+		pwm->pwm_lpg_ctl[0] = reg;
+	return rc;
+}
+
+static int pm8xxx_pwm_disable(struct pwm_device *pwm)
+{
+	int	rc;
+	u8	reg;
+
+	reg = pwm->pwm_ctl1 & PM8XXX_PWM_DISABLE;
+
+	rc = pm8xxx_writeb(pwm->chip->dev->parent,
+			SSBI_REG_ADDR_PWM_CTL1(pwm->pwm_id), reg);
+
+	if (rc)
+		pr_err("pm8xxx_writeb(): rc=%d (Disable PWM Ctl %d)\n", rc,
+								pwm->pwm_id);
+	return rc;
+}
+
+static int pm8xxx_pwm_enable(struct pwm_device *pwm)
+{
+	/**
+	 * A kind of best Effort: Just write the clock information that
+	 * we have in the register.
+	 */
+	int	rc;
+
+	rc = pm8xxx_writeb(pwm->chip->dev->parent,
+			SSBI_REG_ADDR_PWM_CTL1(pwm->pwm_id), pwm->pwm_ctl1);
+
+	if (rc)
+		pr_err("pm8xxx_writeb(): rc=%d (Enable PWM Ctl %d)\n", rc,
+								pwm->pwm_id);
+	return rc;
+}
+
+static void pm8xxx_pwm_calc_period(unsigned int period_us,
+				   struct pm8xxx_pwm_period *period)
+{
+	int	n, m, clk, div;
+	int	best_m, best_div, best_clk;
+	unsigned int	last_err, cur_err, min_err;
+	unsigned int	tmp_p, period_n;
+
+	/* PWM Period / N */
+	if (period_us < ((unsigned)(-1) / NSEC_PER_USEC)) {
+		period_n = (period_us * NSEC_PER_USEC) >> 6;
+		n = 6;
+	} else {
+		period_n = (period_us >> 9) * NSEC_PER_USEC;
+		n = 9;
+	}
+
+	min_err = last_err = (unsigned)(-1);
+	best_m = 0;
+	best_clk = 0;
+	best_div = 0;
+	for (clk = 0; clk < NUM_CLOCKS; clk++) {
+		for (div = 0; div < pwm_chip->pwm_total_pre_divs; div++) {
+			/* period_n = (PWM Period / N) */
+			/* tmp_p = (Pre-divide * Clock Period) * 2^m */
+			tmp_p = pt_t[div][clk];
+			for (m = 0; m <= PM8XXX_PWM_M_MAX; m++) {
+				if (period_n > tmp_p)
+					cur_err = period_n - tmp_p;
+				else
+					cur_err = tmp_p - period_n;
+
+				if (cur_err < min_err) {
+					min_err = cur_err;
+					best_m = m;
+					best_clk = clk;
+					best_div = div;
+				}
+
+				if (m && cur_err > last_err)
+					/* Break for bigger cur_err */
+					break;
+
+				last_err = cur_err;
+				tmp_p <<= 1;
+			}
+		}
+	}
+
+	/* Use higher resolution */
+	if (best_m >= 3 && n == 6) {
+		n += 3;
+		best_m -= 3;
+	}
+
+	period->pwm_size = n;
+	period->clk = best_clk;
+	period->pre_div = best_div;
+	period->pre_div_exp = best_m;
+}
+
+static void pm8xxx_pwm_calc_pwm_value(struct pwm_device *pwm,
+				      unsigned int period_us,
+				      unsigned int duty_us)
+{
+	unsigned int max_pwm_value, tmp;
+
+	/* Figure out pwm_value with overflow handling */
+	tmp = 1 << (sizeof(tmp) * 8 - pwm->period.pwm_size);
+	if (duty_us < tmp) {
+		tmp = duty_us << pwm->period.pwm_size;
+		pwm->pwm_value = tmp / period_us;
+	} else {
+		tmp = period_us >> pwm->period.pwm_size;
+		pwm->pwm_value = duty_us / tmp;
+	}
+	max_pwm_value = (1 << pwm->period.pwm_size) - 1;
+	if (pwm->pwm_value > max_pwm_value)
+		pwm->pwm_value = max_pwm_value;
+}
+
+static int pm8xxx_pwm_change_table(struct pwm_device *pwm, int duty_pct[],
+				   int start_idx, int len, int raw_value)
+{
+	unsigned int pwm_value, max_pwm_value;
+	u8	cfg0, cfg1;
+	int	i, pwm_size;
+	int	rc = 0;
+
+	pwm_size = (pwm->pwm_lpg_ctl[5] & PM8XXX_PWM_SIZE_9_BIT) ? 9 : 6;
+	max_pwm_value = (1 << pwm_size) - 1;
+	for (i = 0; i < len; i++) {
+		if (raw_value)
+			pwm_value = duty_pct[i];
+		else
+			pwm_value = (duty_pct[i] << pwm_size) / 100;
+
+		if (pwm_value > max_pwm_value)
+			pwm_value = max_pwm_value;
+		cfg0 = pwm_value;
+		cfg1 = (pwm_value >> 1) & 0x80;
+		cfg1 |= start_idx + i;
+
+		rc = pm8xxx_writeb(pwm->chip->dev->parent,
+				   SSBI_REG_ADDR_LPG_LUT_CFG0, cfg0);
+		if (rc)
+			break;
+
+		rc = pm8xxx_writeb(pwm->chip->dev->parent,
+				   SSBI_REG_ADDR_LPG_LUT_CFG1, cfg1);
+		if (rc)
+			break;
+	}
+	return rc;
+}
+
+static void pm8xxx_pwm_save_index(struct pwm_device *pwm,
+				   int low_idx, int high_idx, int flags)
+{
+	pwm->pwm_lpg_ctl[1] = high_idx & PM8XXX_PWM_HIGH_INDEX_MASK;
+	pwm->pwm_lpg_ctl[2] = low_idx & PM8XXX_PWM_LOW_INDEX_MASK;
+
+	if (flags & PM_PWM_LUT_REVERSE)
+		pwm->pwm_lpg_ctl[1] |= PM8XXX_PWM_REVERSE_EN;
+	if (flags & PM_PWM_LUT_RAMP_UP)
+		pwm->pwm_lpg_ctl[2] |= PM8XXX_PWM_RAMP_UP;
+	if (flags & PM_PWM_LUT_LOOP)
+		pwm->pwm_lpg_ctl[2] |= PM8XXX_PWM_LOOP_EN;
+}
+
+static void pm8xxx_pwm_save_period(struct pwm_device *pwm)
+{
+	u8	mask, val;
+
+	if (pwm_chip->is_lpg_supported) {
+		val = ((pwm->period.clk + 1) << PM8XXX_LPG_PWM_CLK_SEL_SHIFT)
+			& PM8XXX_LPG_PWM_CLK_SEL_MASK;
+		val |= (pwm->period.pre_div << PM8XXX_LPG_PWM_PREDIVIDE_SHIFT)
+			& PM8XXX_LPG_PWM_PREDIVIDE_MASK;
+		val |= pwm->period.pre_div_exp & PM8XXX_LPG_PWM_M_MASK;
+		mask = PM8XXX_LPG_PWM_CLK_SEL_MASK |
+			PM8XXX_LPG_PWM_PREDIVIDE_MASK | PM8XXX_LPG_PWM_M_MASK;
+		pm8xxx_pwm_save(&pwm->pwm_lpg_ctl[4], mask, val);
+
+		val = (pwm->period.pwm_size > 6) ? PM8XXX_PWM_SIZE_9_BIT : 0;
+		mask = PM8XXX_PWM_SIZE_9_BIT;
+		pm8xxx_pwm_save(&pwm->pwm_lpg_ctl[5], mask, val);
+	} else {
+		val = ((pwm->period.clk + 1) << PM8XXX_PWM_CLK_SEL_SHIFT)
+			& PM8XXX_PWM_CLK_SEL_MASK;
+		val |= (pwm->period.pre_div << PM8XXX_PWM_PREDIVIDE_SHIFT)
+			& PM8XXX_PWM_PREDIVIDE_MASK;
+		val |= (pwm->period.pre_div_exp << PM8XXX_PWM_M_SHIFT)
+				& PM8XXX_PWM_M_MASK;
+		val |= (((pwm->period.pwm_size > 6) ? PM8XXX_PWM_SIZE_9_BIT : 0)
+			<< PM8XXX_PWM_SIZE_SHIFT) & PM8XXX_PWM_SIZE_MASK;
+
+		mask = PM8XXX_PWM_CLK_SEL_MASK | PM8XXX_PWM_PREDIVIDE_MASK |
+			PM8XXX_PWM_M_MASK | PM8XXX_PWM_SIZE_MASK;
+		pm8xxx_pwm_save(&pwm->pwm_ctl1, mask, val);
+	}
+}
+
+static void pm8xxx_pwm_save_pwm_value(struct pwm_device *pwm)
+{
+	u8	mask, val;
+
+	if (pwm_chip->is_lpg_supported) {
+		val = (pwm->period.pwm_size > 6) ? (pwm->pwm_value >> 1) : 0;
+		pwm->pwm_lpg_ctl[3] = pwm->pwm_value;
+		mask = PM8XXX_PWM_VALUE_BIT8;
+		pm8xxx_pwm_save(&pwm->pwm_lpg_ctl[4], mask, val);
+	} else {
+		val = (pwm->period.pwm_size > 6) ? (pwm->pwm_value >> 8) : 0;
+		pwm->pwm_ctl2 = pwm->pwm_value;
+		mask = PM8XXX_PWM_VALUE_BIT0;
+		pm8xxx_pwm_save(&pwm->pwm_ctl1, mask, val);
+	}
+}
+
+static void pm8xxx_pwm_save_duty_time(struct pwm_device *pwm,
+				      struct pm8xxx_pwm_lut *lut)
+{
+	int	i;
+	u8	mask, val;
+
+	/* Linear search for duty time */
+	for (i = 0; i < PM8XXX_PWM_1KHZ_COUNT_MAX; i++) {
+		if (duty_msec[i] >= lut->lut_duty_ms)
+			break;
+	}
+	val = i << PM8XXX_PWM_1KHZ_COUNT_SHIFT;
+
+	mask = PM8XXX_PWM_1KHZ_COUNT_MASK;
+	pm8xxx_pwm_save(&pwm->pwm_lpg_ctl[0], mask, val);
+}
+
+static void pm8xxx_pwm_save_pause(struct pwm_device *pwm,
+				  struct pm8xxx_pwm_lut *lut)
+{
+	int	i, pause_cnt, time_cnt;
+	u8	mask, val;
+
+	time_cnt = (pwm->pwm_lpg_ctl[0] & PM8XXX_PWM_1KHZ_COUNT_MASK)
+				>> PM8XXX_PWM_1KHZ_COUNT_SHIFT;
+	if (lut->flags & PM_PWM_LUT_PAUSE_HI_EN) {
+		pause_cnt = (lut->lut_pause_hi + duty_msec[time_cnt] / 2)
+				/ duty_msec[time_cnt];
+		/* Linear search for pause time */
+		for (i = 0; i < PM8XXX_PWM_PAUSE_COUNT_MAX; i++) {
+			if (pause_count[i] >= pause_cnt)
+				break;
+		}
+		val = (i << PM8XXX_PWM_PAUSE_COUNT_HI_SHIFT) &
+			PM8XXX_PWM_PAUSE_COUNT_HI_MASK;
+		val |= PM8XXX_PWM_PAUSE_ENABLE_HIGH;
+	} else {
+		val = 0;
+	}
+
+	mask = PM8XXX_PWM_PAUSE_COUNT_HI_MASK | PM8XXX_PWM_PAUSE_ENABLE_HIGH;
+	pm8xxx_pwm_save(&pwm->pwm_lpg_ctl[5], mask, val);
+
+	if (lut->flags & PM_PWM_LUT_PAUSE_LO_EN) {
+		/* Linear search for pause time */
+		pause_cnt = (lut->lut_pause_lo + duty_msec[time_cnt] / 2)
+				/ duty_msec[time_cnt];
+		for (i = 0; i < PM8XXX_PWM_PAUSE_COUNT_MAX; i++) {
+			if (pause_count[i] >= pause_cnt)
+				break;
+		}
+		val = (i << PM8XXX_PWM_PAUSE_COUNT_LO_SHIFT) &
+			PM8XXX_PWM_PAUSE_COUNT_LO_MASK;
+		val |= PM8XXX_PWM_PAUSE_ENABLE_LOW;
+	} else {
+		val = 0;
+	}
+
+	mask = PM8XXX_PWM_PAUSE_COUNT_LO_MASK | PM8XXX_PWM_PAUSE_ENABLE_LOW;
+	pm8xxx_pwm_save(&pwm->pwm_lpg_ctl[6], mask, val);
+}
+
+static int pm8xxx_pwm_write(struct pwm_device *pwm)
+{
+	int rc = 0;
+
+	rc = pm8xxx_writeb(pwm->chip->dev->parent,
+			   SSBI_REG_ADDR_PWM_CTL1(pwm->pwm_id),
+			   pwm->pwm_ctl1);
+	if (rc) {
+		pr_err("pm8xxx_writeb() failed: rc=%d (PWM Ctl1[%d])\n",
+							rc, pwm->pwm_id);
+		return rc;
+	}
+
+	rc = pm8xxx_writeb(pwm->chip->dev->parent,
+			   SSBI_REG_ADDR_PWM_CTL2(pwm->pwm_id),
+			   pwm->pwm_ctl2);
+	if (rc) {
+		pr_err("pm8xxx_writeb() failed: rc=%d (PWM Ctl2[%d])\n",
+							rc, pwm->pwm_id);
+		return rc;
+	}
+
+	return rc;
+}
+
+static int pm8xxx_lpg_pwm_write(struct pwm_device *pwm, int start, int end)
+{
+	int	i, rc;
+
+	/* Write in reverse way so 0 would be the last */
+	for (i = end - 1; i >= start; i--) {
+		rc = pm8xxx_writeb(pwm->chip->dev->parent,
+				   SSBI_REG_ADDR_LPG_CTL(i),
+				   pwm->pwm_lpg_ctl[i]);
+		if (rc) {
+			pr_err("pm8xxx_writeb(): rc=%d (PWM Ctl[%d])\n", rc, i);
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int pm8xxx_pwm_change_lut(struct pwm_device *pwm,
+				 struct pm8xxx_pwm_lut *lut)
+{
+	int	rc;
+
+	pm8xxx_pwm_save_index(pwm, lut->lut_lo_index,
+			     lut->lut_hi_index, lut->flags);
+	pm8xxx_pwm_save_duty_time(pwm, lut);
+	pm8xxx_pwm_save_pause(pwm, lut);
+	pm8xxx_pwm_save(&pwm->pwm_lpg_ctl[1], PM8XXX_PWM_BYPASS_LUT, 0);
+
+	pm8xxx_pwm_bank_sel(pwm);
+	rc = pm8xxx_lpg_pwm_write(pwm, 0, 7);
+
+	return rc;
+}
+
+static int pm8xxx_pwm_set_dtest(struct pwm_device *pwm, int enable)
+{
+	int	rc;
+	u8	reg;
+
+	reg = pwm->pwm_id & PM8XXX_PWM_DTEST_BANK_MASK;
+
+	if (enable) {
+		/* Observe LPG_OUT on DTEST1*/
+		reg |= (1 << PM8XXX_PWM_DTEST_SHIFT) &
+				PM8XXX_PWM_DTEST_MASK;
+	}
+
+	rc = pm8xxx_writeb(pwm->chip->dev->parent,
+			SSBI_REG_ADDR_LPG_TEST, reg);
+	if (rc)
+		pr_err("pm8xxx_write(DTEST=0x%x) failed: rc=%d\n",
+							reg, rc);
+
+	return rc;
+}
+
+/* APIs */
+/**
+ * pwm_request - request a PWM device
+ * @pwm_id: PWM id or channel
+ * @label: the label to identify the user
+ */
+struct pwm_device *pwm_request(int pwm_id, const char *label)
+{
+	struct pwm_device	*pwm;
+
+	if (pwm_chip == NULL) {
+		pr_err("No pwm_chip\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	if (pwm_id >= pwm_chip->pwm_channels || pwm_id < 0) {
+		pr_err("Invalid pwm_id: %d with %s\n",
+		       pwm_id, label ? label : ".");
+		return ERR_PTR(-EINVAL);
+	}
+
+	mutex_lock(&pwm_chip->pwm_mutex);
+	pwm = &pwm_chip->pwm_dev[pwm_id];
+	if (!pwm->in_use) {
+		pwm->in_use = 1;
+		pwm->label = label;
+	} else {
+		pwm = ERR_PTR(-EBUSY);
+	}
+	mutex_unlock(&pwm_chip->pwm_mutex);
+
+	return pwm;
+}
+EXPORT_SYMBOL_GPL(pwm_request);
+
+/**
+ * pwm_free - free a PWM device
+ * @pwm: the PWM device
+ */
+void pwm_free(struct pwm_device *pwm)
+{
+	if (pwm == NULL || IS_ERR(pwm) || pwm->chip == NULL) {
+		pr_err("Invalid pwm handle\n");
+		return;
+	}
+
+	mutex_lock(&pwm->chip->pwm_mutex);
+	if (pwm->in_use) {
+		if (pwm_chip->is_lpg_supported) {
+			pm8xxx_pwm_bank_sel(pwm);
+			pm8xxx_pwm_start(pwm, 0, 0);
+		} else {
+			pm8xxx_pwm_disable(pwm);
+		}
+		pwm->in_use = 0;
+		pwm->label = NULL;
+	}
+	if (pwm_chip->is_lpg_supported)
+		pm8xxx_pwm_bank_enable(pwm, 0);
+	mutex_unlock(&pwm->chip->pwm_mutex);
+}
+EXPORT_SYMBOL_GPL(pwm_free);
+
+/**
+ * pwm_config - change a PWM device configuration
+ * @pwm: the PWM device
+ * @period_us: period in microseconds
+ * @duty_us: duty cycle in microseconds
+ */
+int pwm_config(struct pwm_device *pwm, int duty_us, int period_us)
+{
+	struct pm8xxx_pwm_period *period;
+	int	rc = 0;
+
+	if (pwm == NULL || IS_ERR(pwm) ||
+		duty_us > period_us ||
+		(unsigned)period_us > PM8XXX_PWM_PERIOD_MAX ||
+		(unsigned)period_us < PM8XXX_PWM_PERIOD_MIN) {
+		pr_err("Invalid pwm handle or parameters\n");
+		return -EINVAL;
+	}
+	if (pwm->chip == NULL) {
+		pr_err("No pwm_chip\n");
+		return -ENODEV;
+	}
+
+	period = &pwm->period;
+
+	mutex_lock(&pwm->chip->pwm_mutex);
+
+	if (!pwm->in_use) {
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+
+	if (pwm->pwm_period != period_us) {
+		pm8xxx_pwm_calc_period(period_us, period);
+		pm8xxx_pwm_save_period(pwm);
+		pwm->pwm_period = period_us;
+	}
+
+	pm8xxx_pwm_calc_pwm_value(pwm, period_us, duty_us);
+	pm8xxx_pwm_save_pwm_value(pwm);
+
+	if (pwm_chip->is_lpg_supported) {
+		pm8xxx_pwm_save(&pwm->pwm_lpg_ctl[1],
+				PM8XXX_PWM_BYPASS_LUT, PM8XXX_PWM_BYPASS_LUT);
+
+		pm8xxx_pwm_bank_sel(pwm);
+		rc = pm8xxx_lpg_pwm_write(pwm, 1, 6);
+	} else {
+		rc = pm8xxx_pwm_write(pwm);
+	}
+
+	pr_debug("duty/period=%u/%u usec: pwm_value=%d (of %d)\n",
+		 (unsigned)duty_us, (unsigned)period_us,
+		 pwm->pwm_value, 1 << period->pwm_size);
+
+out_unlock:
+	mutex_unlock(&pwm->chip->pwm_mutex);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pwm_config);
+
+/**
+ * pwm_enable - start a PWM output toggling
+ * @pwm: the PWM device
+ */
+int pwm_enable(struct pwm_device *pwm)
+{
+	int	rc = 0;
+
+	if (pwm == NULL || IS_ERR(pwm)) {
+		pr_err("Invalid pwm handle\n");
+		return -EINVAL;
+	}
+	if (pwm->chip == NULL) {
+		pr_err("No pwm_chip\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&pwm->chip->pwm_mutex);
+	if (!pwm->in_use) {
+		pr_err("pwm_id: %d: stale handle?\n", pwm->pwm_id);
+		rc = -EINVAL;
+	} else {
+		if (pwm_chip->is_lpg_supported) {
+			if (pwm->dtest_mode_supported)
+				pm8xxx_pwm_set_dtest(pwm, 1);
+			rc = pm8xxx_pwm_bank_enable(pwm, 1);
+			pm8xxx_pwm_bank_sel(pwm);
+			pm8xxx_pwm_start(pwm, 1, 0);
+		} else {
+			pm8xxx_pwm_enable(pwm);
+		}
+	}
+	mutex_unlock(&pwm->chip->pwm_mutex);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pwm_enable);
+
+/**
+ * pwm_disable - stop a PWM output toggling
+ * @pwm: the PWM device
+ */
+void pwm_disable(struct pwm_device *pwm)
+{
+	if (pwm == NULL || IS_ERR(pwm) || pwm->chip == NULL) {
+		pr_err("Invalid pwm handle or no pwm_chip\n");
+		return;
+	}
+
+	mutex_lock(&pwm->chip->pwm_mutex);
+	if (pwm->in_use) {
+		if (pwm_chip->is_lpg_supported) {
+			if (pwm->dtest_mode_supported)
+				pm8xxx_pwm_set_dtest(pwm, 0);
+			pm8xxx_pwm_bank_sel(pwm);
+			pm8xxx_pwm_start(pwm, 0, 0);
+			pm8xxx_pwm_bank_enable(pwm, 0);
+		} else {
+			pm8xxx_pwm_disable(pwm);
+		}
+	}
+	mutex_unlock(&pwm->chip->pwm_mutex);
+}
+EXPORT_SYMBOL_GPL(pwm_disable);
+
+/**
+ * pm8xxx_pwm_config_period - change PWM period
+ *
+ * @pwm: the PWM device
+ * @pwm_p: period in struct pm8xxx_pwm_period
+ */
+int pm8xxx_pwm_config_period(struct pwm_device *pwm,
+			     struct pm8xxx_pwm_period *period)
+{
+	int			rc;
+
+	if (pwm == NULL || IS_ERR(pwm) || period == NULL)
+		return -EINVAL;
+	if (pwm->chip == NULL)
+		return -ENODEV;
+
+	mutex_lock(&pwm->chip->pwm_mutex);
+
+	if (!pwm->in_use) {
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+
+	pwm->period.pwm_size = period->pwm_size;
+	pwm->period.clk = period->clk;
+	pwm->period.pre_div = period->pre_div;
+	pwm->period.pre_div_exp = period->pre_div_exp;
+
+	pm8xxx_pwm_save_period(pwm);
+
+	if (pwm_chip->is_lpg_supported) {
+		pm8xxx_pwm_bank_sel(pwm);
+		rc = pm8xxx_lpg_pwm_write(pwm, 4, 6);
+	} else {
+		rc = pm8xxx_pwm_write(pwm);
+	}
+
+
+out_unlock:
+	mutex_unlock(&pwm->chip->pwm_mutex);
+	return rc;
+}
+EXPORT_SYMBOL(pm8xxx_pwm_config_period);
+
+/**
+ * pm8xxx_pwm_config_pwm_value - change a PWM device configuration
+ * @pwm: the PWM device
+ * @pwm_value: the duty cycle in raw PWM value (< 2^pwm_size)
+ */
+int pm8xxx_pwm_config_pwm_value(struct pwm_device *pwm, int pwm_value)
+{
+	int	rc = 0;
+
+	if (pwm == NULL || IS_ERR(pwm))
+		return -EINVAL;
+	if (pwm->chip == NULL)
+		return -ENODEV;
+
+	mutex_lock(&pwm->chip->pwm_mutex);
+
+	if (!pwm->in_use || !pwm->pwm_period) {
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+
+	if (pwm->pwm_value == pwm_value)
+		goto out_unlock;
+
+	pwm->pwm_value = pwm_value;
+
+	pm8xxx_pwm_save_pwm_value(pwm);
+
+	if (pwm_chip->is_lpg_supported) {
+		pm8xxx_pwm_save(&pwm->pwm_lpg_ctl[1],
+				PM8XXX_PWM_BYPASS_LUT, PM8XXX_PWM_BYPASS_LUT);
+		pm8xxx_pwm_bank_sel(pwm);
+		rc = pm8xxx_lpg_pwm_write(pwm, 1, 6);
+	} else {
+		rc = pm8xxx_pwm_write(pwm);
+	}
+
+	if (rc)
+		pr_err("[%d]: pm8xxx_pwm_write: rc=%d\n", pwm->pwm_id, rc);
+
+out_unlock:
+	mutex_unlock(&pwm->chip->pwm_mutex);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pm8xxx_pwm_config_pwm_value);
+
+/**
+ * pm8xxx_pwm_lut_config - change a PWM device configuration to use LUT
+ * @pwm: the PWM device
+ * @period_us: period in microseconds
+ * @duty_pct: arrary of duty cycles in percent, like 20, 50.
+ * @duty_time_ms: time for each duty cycle in milliseconds
+ * @start_idx: start index in lookup table from 0 to MAX-1
+ * @idx_len: number of index
+ * @pause_lo: pause time in milliseconds at low index
+ * @pause_hi: pause time in milliseconds at high index
+ * @flags: control flags
+ */
+int pm8xxx_pwm_lut_config(struct pwm_device *pwm, int period_us,
+			  int duty_pct[], int duty_time_ms, int start_idx,
+			  int idx_len, int pause_lo, int pause_hi, int flags)
+{
+	struct pm8xxx_pwm_lut	lut;
+	struct pm8xxx_pwm_period *period;
+	int	len;
+	int	rc;
+
+	if (pwm == NULL || IS_ERR(pwm) || !idx_len) {
+		pr_err("Invalid pwm handle or idx_len=0\n");
+		return -EINVAL;
+	}
+	if (duty_pct == NULL && !(flags & PM_PWM_LUT_NO_TABLE)) {
+		pr_err("Invalid duty_pct with flag\n");
+		return -EINVAL;
+	}
+	if (pwm->chip == NULL) {
+		pr_err("No pwm_chip\n");
+		return -ENODEV;
+	}
+
+	if (pwm->chip->is_lpg_supported == 0) {
+		pr_err("LPG module isn't supported\n");
+		return -EINVAL;
+	}
+
+	if (idx_len >= PM_PWM_LUT_SIZE && start_idx) {
+		pr_err("Wrong LUT size or index\n");
+		return -EINVAL;
+	}
+	if ((start_idx + idx_len) > PM_PWM_LUT_SIZE) {
+		pr_err("Exceed LUT limit\n");
+		return -EINVAL;
+	}
+	if ((unsigned)period_us > PM8XXX_PWM_PERIOD_MAX ||
+		(unsigned)period_us < PM8XXX_PWM_PERIOD_MIN) {
+		pr_err("Period out of range\n");
+		return -EINVAL;
+	}
+
+	period = &pwm->period;
+	mutex_lock(&pwm->chip->pwm_mutex);
+
+	if (!pwm->in_use) {
+		pr_err("pwm_id: %d: stale handle?\n", pwm->pwm_id);
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+
+	if (pwm->pwm_period != period_us) {
+		pm8xxx_pwm_calc_period(period_us, period);
+		pm8xxx_pwm_save_period(pwm);
+		pwm->pwm_period = period_us;
+	}
+
+	len = (idx_len > PM_PWM_LUT_SIZE) ? PM_PWM_LUT_SIZE : idx_len;
+
+	if (flags & PM_PWM_LUT_NO_TABLE)
+		goto after_table_write;
+
+	rc = pm8xxx_pwm_change_table(pwm, duty_pct, start_idx, len, 0);
+	if (rc) {
+		pr_err("pm8xxx_pwm_change_table: rc=%d\n", rc);
+		goto out_unlock;
+	}
+
+after_table_write:
+	lut.lut_duty_ms = duty_time_ms;
+	lut.lut_lo_index = start_idx;
+	lut.lut_hi_index = start_idx + len - 1;
+	lut.lut_pause_lo = pause_lo;
+	lut.lut_pause_hi = pause_hi;
+	lut.flags = flags;
+	pwm->bypass_lut = 0;
+
+	rc = pm8xxx_pwm_change_lut(pwm, &lut);
+
+out_unlock:
+	mutex_unlock(&pwm->chip->pwm_mutex);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pm8xxx_pwm_lut_config);
+
+/**
+ * pm8xxx_pwm_lut_enable - control a PWM device to start/stop LUT ramp
+ * @pwm: the PWM device
+ * @start: to start (1), or stop (0)
+ */
+int pm8xxx_pwm_lut_enable(struct pwm_device *pwm, int start)
+{
+	if (pwm == NULL || IS_ERR(pwm)) {
+		pr_err("Invalid pwm handle\n");
+		return -EINVAL;
+	}
+	if (pwm->chip == NULL) {
+		pr_err("No pwm_chip\n");
+		return -ENODEV;
+	}
+	if (pwm->chip->is_lpg_supported == 0) {
+		pr_err("LPG module isn't supported\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&pwm->chip->pwm_mutex);
+	if (start) {
+		if (pwm->dtest_mode_supported)
+			pm8xxx_pwm_set_dtest(pwm, 1);
+
+		pm8xxx_pwm_bank_enable(pwm, 1);
+
+		pm8xxx_pwm_bank_sel(pwm);
+		pm8xxx_pwm_start(pwm, 1, 1);
+	} else {
+		if (pwm->dtest_mode_supported)
+			pm8xxx_pwm_set_dtest(pwm, 0);
+
+		pm8xxx_pwm_bank_sel(pwm);
+		pm8xxx_pwm_start(pwm, 0, 0);
+
+		pm8xxx_pwm_bank_enable(pwm, 0);
+	}
+	mutex_unlock(&pwm->chip->pwm_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pm8xxx_pwm_lut_enable);
+
+#if defined(CONFIG_DEBUG_FS)
+
+struct pm8xxx_pwm_dbg_device;
+
+struct pm8xxx_pwm_user {
+	int				pwm_id;
+	struct pwm_device		*pwm;
+	int				period;
+	int				duty_cycle;
+	int				enable;
+	struct pm8xxx_pwm_dbg_device	*dbgdev;
+};
+
+struct pm8xxx_pwm_dbg_device {
+	struct mutex		dbg_mutex;
+	struct device		*dev;
+	struct dentry		*dent;
+
+	struct pm8xxx_pwm_user	*user;
+};
+
+static struct pm8xxx_pwm_dbg_device *pmic_dbg_device;
+
+static int dbg_pwm_check_period(int period)
+{
+	if (period < PM8XXX_PWM_PERIOD_MIN || period > PM8XXX_PWM_PERIOD_MAX) {
+		pr_err("period is invalid: %d\n", period);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int dbg_pwm_check_duty_cycle(int duty_cycle, const char *func_name)
+{
+	if (duty_cycle <= 0 || duty_cycle > 100) {
+		pr_err("%s: duty_cycle is invalid: %d\n",
+		      func_name, duty_cycle);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void dbg_pwm_check_handle(struct pm8xxx_pwm_user *puser)
+{
+	struct pwm_device *tmp;
+
+	if (puser->pwm == NULL) {
+		tmp = pwm_request(puser->pwm_id, "pwm-dbg");
+		if (PTR_ERR(puser->pwm)) {
+			pr_err("pwm_request: err=%ld\n", PTR_ERR(puser->pwm));
+			puser->pwm = NULL;
+		} else {
+			pr_debug("[id=%d] pwm_request ok\n", puser->pwm_id);
+			puser->pwm = tmp;
+		}
+	}
+}
+
+static int dbg_pwm_enable_set(void *data, u64 val)
+{
+	struct pm8xxx_pwm_user	  *puser = data;
+	struct pm8xxx_pwm_dbg_device    *dbgdev = puser->dbgdev;
+	int     rc;
+
+	mutex_lock(&dbgdev->dbg_mutex);
+	rc = dbg_pwm_check_duty_cycle(puser->duty_cycle, __func__);
+	if (!rc) {
+		puser->enable = val;
+		dbg_pwm_check_handle(puser);
+		if (puser->pwm) {
+			if (puser->enable)
+				pwm_enable(puser->pwm);
+			else
+				pwm_disable(puser->pwm);
+		}
+	}
+	mutex_unlock(&dbgdev->dbg_mutex);
+	return 0;
+}
+
+static int dbg_pwm_enable_get(void *data, u64 *val)
+{
+	struct pm8xxx_pwm_user	  *puser = data;
+	struct pm8xxx_pwm_dbg_device    *dbgdev = puser->dbgdev;
+
+	mutex_lock(&dbgdev->dbg_mutex);
+	*val = puser->enable;
+	mutex_unlock(&dbgdev->dbg_mutex);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(dbg_pwm_enable_fops,
+			dbg_pwm_enable_get, dbg_pwm_enable_set,
+			"%lld\n");
+
+static int dbg_pwm_duty_cycle_set(void *data, u64 val)
+{
+	struct pm8xxx_pwm_user	  *puser = data;
+	struct pm8xxx_pwm_dbg_device    *dbgdev = puser->dbgdev;
+	int     rc;
+
+	mutex_lock(&dbgdev->dbg_mutex);
+	rc = dbg_pwm_check_duty_cycle(val, __func__);
+	if (!rc) {
+		puser->duty_cycle = val;
+		dbg_pwm_check_handle(puser);
+		if (puser->pwm) {
+			int     duty_us;
+
+			duty_us = puser->duty_cycle * puser->period / 100;
+			pwm_config(puser->pwm, duty_us, puser->period);
+		}
+	}
+	mutex_unlock(&dbgdev->dbg_mutex);
+	return 0;
+}
+
+static int dbg_pwm_duty_cycle_get(void *data, u64 *val)
+{
+	struct pm8xxx_pwm_user	  *puser = data;
+	struct pm8xxx_pwm_dbg_device    *dbgdev = puser->dbgdev;
+
+	mutex_lock(&dbgdev->dbg_mutex);
+	*val = puser->duty_cycle;
+	mutex_unlock(&dbgdev->dbg_mutex);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(dbg_pwm_duty_cycle_fops,
+			dbg_pwm_duty_cycle_get, dbg_pwm_duty_cycle_set,
+			"%lld\n");
+
+static int dbg_pwm_period_set(void *data, u64 val)
+{
+	struct pm8xxx_pwm_user	  *puser = data;
+	struct pm8xxx_pwm_dbg_device    *dbgdev = puser->dbgdev;
+	int     rc;
+
+	mutex_lock(&dbgdev->dbg_mutex);
+	rc = dbg_pwm_check_period(val);
+	if (!rc)
+		puser->period = val;
+	mutex_unlock(&dbgdev->dbg_mutex);
+	return 0;
+}
+
+static int dbg_pwm_period_get(void *data, u64 *val)
+{
+	struct pm8xxx_pwm_user	  *puser = data;
+	struct pm8xxx_pwm_dbg_device    *dbgdev = puser->dbgdev;
+
+	mutex_lock(&dbgdev->dbg_mutex);
+	*val = puser->period;
+	mutex_unlock(&dbgdev->dbg_mutex);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(dbg_pwm_period_fops,
+			dbg_pwm_period_get, dbg_pwm_period_set, "%lld\n");
+
+static int __devinit pm8xxx_pwm_dbg_probe(struct device *dev)
+{
+	struct pm8xxx_pwm_dbg_device    *dbgdev;
+	struct dentry		   *dent;
+	struct dentry		   *temp;
+	struct pm8xxx_pwm_user	  *puser;
+	int			     i;
+	int rc = 0;
+
+	if (dev == NULL) {
+		pr_err("no parent data passed in.\n");
+		return -EINVAL;
+	}
+
+	dbgdev = kzalloc(sizeof *dbgdev, GFP_KERNEL);
+	if (dbgdev == NULL) {
+		pr_err("kzalloc() failed.\n");
+		return -ENOMEM;
+	}
+
+	dbgdev->user = kcalloc(pwm_chip->pwm_channels,
+				sizeof(struct pm8xxx_pwm_user), GFP_KERNEL);
+	if (dbgdev->user == NULL) {
+		pr_err("kcalloc() failed.\n");
+		rc = -ENOMEM;
+		goto user_error;
+	}
+
+	mutex_init(&dbgdev->dbg_mutex);
+
+	dbgdev->dev = dev;
+
+	dent = debugfs_create_dir("pm8xxx-pwm-dbg", NULL);
+	if (dent == NULL || IS_ERR(dent)) {
+		pr_err("ERR debugfs_create_dir: dent=%p\n", dent);
+		rc = -ENOMEM;
+		goto dir_error;
+	}
+
+	dbgdev->dent = dent;
+
+	for (i = 0; i < pwm_chip->pwm_channels; i++) {
+		char pwm_ch[] = "0";
+
+		pwm_ch[0] = '0' + i;
+		dent = debugfs_create_dir(pwm_ch, dbgdev->dent);
+		if (dent == NULL || IS_ERR(dent)) {
+			pr_err("ERR: pwm=%d: dir: dent=%p\n", i, dent);
+			rc = -ENOMEM;
+			goto debug_error;
+		}
+
+		puser = &dbgdev->user[i];
+		puser->dbgdev = dbgdev;
+		puser->pwm_id = i;
+		temp = debugfs_create_file("period", S_IRUGO | S_IWUSR,
+				dent, puser, &dbg_pwm_period_fops);
+		if (temp == NULL || IS_ERR(temp)) {
+			pr_err("ERR: pwm=%d: period: dent=%p\n", i, dent);
+			rc = -ENOMEM;
+			goto debug_error;
+		}
+
+		temp = debugfs_create_file("duty-cycle", S_IRUGO | S_IWUSR,
+				dent, puser, &dbg_pwm_duty_cycle_fops);
+		if (temp == NULL || IS_ERR(temp)) {
+			pr_err("ERR: pwm=%d: duty-cycle: dent=%p\n", i, dent);
+			rc = -ENOMEM;
+			goto debug_error;
+		}
+
+		temp = debugfs_create_file("enable", S_IRUGO | S_IWUSR,
+				dent, puser, &dbg_pwm_enable_fops);
+		if (temp == NULL || IS_ERR(temp)) {
+			pr_err("ERR: pwm=%d: enable: dent=%p\n", i, dent);
+			rc = -ENOMEM;
+			goto debug_error;
+		}
+	}
+
+	pmic_dbg_device = dbgdev;
+
+	return 0;
+
+debug_error:
+	debugfs_remove_recursive(dbgdev->dent);
+dir_error:
+	kfree(dbgdev->user);
+user_error:
+	kfree(dbgdev);
+	return rc;
+}
+
+static int __devexit pm8xxx_pwm_dbg_remove(void)
+{
+	if (pmic_dbg_device) {
+		kfree(pmic_dbg_device->user);
+		debugfs_remove_recursive(pmic_dbg_device->dent);
+		kfree(pmic_dbg_device);
+	}
+	return 0;
+}
+
+#else
+
+static int __devinit pm8xxx_pwm_dbg_probe(struct device *dev)
+{
+	return 0;
+}
+
+static int __devexit pm8xxx_pwm_dbg_remove(void)
+{
+	return 0;
+}
+
+#endif
+
+static int __devinit pm8xxx_pwm_probe(struct platform_device *pdev)
+{
+	const struct pm8xxx_pwm_platform_data *pdata = pdev->dev.platform_data;
+	struct pm8xxx_pwm_chip	*chip;
+	int	i, dtest_channel;
+	enum pm8xxx_version version;
+
+	chip = kzalloc(sizeof *chip, GFP_KERNEL);
+	if (chip == NULL) {
+		pr_err("kzalloc() failed.\n");
+		return -ENOMEM;
+	}
+
+	if (pdata != NULL)
+		dtest_channel = pdata->dtest_channel;
+	else
+		dtest_channel = -1;
+
+	mutex_init(&chip->pwm_mutex);
+
+	chip->dev = &pdev->dev;
+	pwm_chip = chip;
+
+	version = pm8xxx_get_version(chip->dev->parent);
+
+	if (version == PM8XXX_VERSION_8921 ||
+			version == PM8XXX_VERSION_8058 ||
+			version == PM8XXX_VERSION_8922 ||
+			version == PM8XXX_VERSION_8038) {
+		chip->is_lpg_supported = 1;
+	}
+	if (chip->is_lpg_supported) {
+		if (version == PM8XXX_VERSION_8922 ||
+				version == PM8XXX_VERSION_8038) {
+			for (i = 0; i < NUM_CLOCKS; i++)
+				pt_t[0][i] /= PRE_DIVIDE_2;
+			chip->pwm_channels = PM8XXX_LPG_V1_PWM_CHANNELS;
+		} else {
+			chip->pwm_channels = PM8XXX_LPG_V0_PWM_CHANNELS;
+		}
+		chip->pwm_total_pre_divs = NUM_LPG_PRE_DIVIDE;
+	} else {
+		chip->pwm_channels = PM8XXX_PWM_CHANNELS;
+		chip->pwm_total_pre_divs = NUM_PWM_PRE_DIVIDE;
+	}
+
+	chip->pwm_dev = kcalloc(chip->pwm_channels, sizeof(struct pwm_device),
+								GFP_KERNEL);
+	if (chip->pwm_dev == NULL) {
+		pr_err("kcalloc() failed.\n");
+		mutex_destroy(&chip->pwm_mutex);
+		kfree(chip);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < chip->pwm_channels; i++) {
+		chip->pwm_dev[i].pwm_id = i;
+		chip->pwm_dev[i].chip = chip;
+		if (i == dtest_channel)
+			chip->pwm_dev[i].dtest_mode_supported = 1;
+	}
+
+	platform_set_drvdata(pdev, chip);
+
+	if (pm8xxx_pwm_dbg_probe(&pdev->dev) < 0)
+		pr_err("could not set up debugfs\n");
+
+	pr_notice("OK\n");
+	return 0;
+}
+
+static int __devexit pm8xxx_pwm_remove(struct platform_device *pdev)
+{
+	struct pm8xxx_pwm_chip	*chip = dev_get_drvdata(pdev->dev.parent);
+
+	pm8xxx_pwm_dbg_remove();
+	kfree(chip->pwm_dev);
+	mutex_destroy(&chip->pwm_mutex);
+	platform_set_drvdata(pdev, NULL);
+	kfree(chip);
+	return 0;
+}
+
+static struct platform_driver pm8xxx_pwm_driver = {
+	.probe		= pm8xxx_pwm_probe,
+	.remove		= __devexit_p(pm8xxx_pwm_remove),
+	.driver		= {
+		.name = PM8XXX_PWM_DEV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init pm8xxx_pwm_init(void)
+{
+	return platform_driver_register(&pm8xxx_pwm_driver);
+}
+
+static void __exit pm8xxx_pwm_exit(void)
+{
+	platform_driver_unregister(&pm8xxx_pwm_driver);
+}
+
+subsys_initcall(pm8xxx_pwm_init);
+module_exit(pm8xxx_pwm_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("PM8XXX PWM driver");
+MODULE_VERSION("1.0");
+MODULE_ALIAS("platform:" PM8XXX_PWM_DEV_NAME);
diff --git a/drivers/mfd/pm8xxx-spk.c b/drivers/mfd/pm8xxx-spk.c
new file mode 100644
index 0000000..89fc53a
--- /dev/null
+++ b/drivers/mfd/pm8xxx-spk.c
@@ -0,0 +1,303 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+#include <linux/debugfs.h>
+#include <linux/mfd/pm8xxx/core.h>
+#include <linux/mfd/pm8xxx/spk.h>
+
+#define PM8XXX_SPK_CTL1_REG_OFF		0
+#define PM8XXX_SPK_CTL2_REG_OFF		1
+#define PM8XXX_SPK_CTL3_REG_OFF		2
+#define PM8XXX_SPK_CTL4_REG_OFF		3
+#define PM8XXX_SPK_TEST_REG_1_OFF	4
+#define PM8XXX_SPK_TEST_REG_2_OFF	5
+
+#define PM8XXX_SPK_BANK_SEL		4
+#define PM8XXX_SPK_BANK_WRITE		0x80
+#define PM8XXX_SPK_BANK_VAL_MASK	0xF
+
+#define BOOST_6DB_GAIN_EN_MASK		0x8
+#define VSEL_LD0_1P1			0x0
+#define VSEL_LD0_1P2			0x2
+#define VSEL_LD0_1P0			0x4
+
+#define PWM_EN_MASK			0xF
+#define PM8XXX_SPK_TEST_REG_1_BANKS	8
+#define PM8XXX_SPK_TEST_REG_2_BANKS	2
+
+#define PM8XXX_SPK_GAIN			0x5
+#define PM8XXX_ADD_EN			0x1
+
+struct pm8xxx_spk_chip {
+	struct list_head                        link;
+	struct pm8xxx_spk_platform_data		pdata;
+	struct device                           *dev;
+	enum pm8xxx_version                     version;
+	struct mutex				spk_mutex;
+	u16					base;
+	u16					end;
+};
+
+static struct pm8xxx_spk_chip *the_spk_chip;
+
+static inline bool spk_defined(void)
+{
+	if (the_spk_chip == NULL || IS_ERR(the_spk_chip))
+		return false;
+	return true;
+}
+
+static int pm8xxx_spk_bank_write(u16 reg, u16 bank, u8 val)
+{
+	int rc = 0;
+	u8 bank_val = PM8XXX_SPK_BANK_WRITE | (bank << PM8XXX_SPK_BANK_SEL);
+
+	bank_val |= (val & PM8XXX_SPK_BANK_VAL_MASK);
+	mutex_lock(&the_spk_chip->spk_mutex);
+	rc = pm8xxx_writeb(the_spk_chip->dev->parent, reg, bank_val);
+	if (rc)
+		pr_err("pm8xxx_writeb(): rc=%d\n", rc);
+	mutex_unlock(&the_spk_chip->spk_mutex);
+	return rc;
+}
+
+
+static int pm8xxx_spk_read(u16 addr)
+{
+	int rc = 0;
+	u8 val = 0;
+
+	mutex_lock(&the_spk_chip->spk_mutex);
+	rc = pm8xxx_readb(the_spk_chip->dev->parent,
+			the_spk_chip->base + addr, &val);
+	if (rc) {
+		pr_err("pm8xxx_spk_readb() failed: rc=%d\n", rc);
+		val = rc;
+	}
+	mutex_unlock(&the_spk_chip->spk_mutex);
+
+	return val;
+}
+
+static int pm8xxx_spk_write(u16 addr, u8 val)
+{
+	int rc = 0;
+
+	mutex_lock(&the_spk_chip->spk_mutex);
+	rc = pm8xxx_writeb(the_spk_chip->dev->parent,
+			the_spk_chip->base + addr, val);
+	if (rc)
+		pr_err("pm8xxx_writeb() failed: rc=%d\n", rc);
+	mutex_unlock(&the_spk_chip->spk_mutex);
+	return rc;
+}
+
+int pm8xxx_spk_mute(bool mute)
+{
+	u8 val = 0;
+	int ret = 0;
+	if (spk_defined() == false) {
+		pr_err("Invalid spk handle or no spk_chip\n");
+		return -ENODEV;
+	}
+
+	val = pm8xxx_spk_read(PM8XXX_SPK_CTL1_REG_OFF);
+	if (val < 0)
+		return val;
+	val |= mute << 2;
+	ret = pm8xxx_spk_write(PM8XXX_SPK_CTL1_REG_OFF, val);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pm8xxx_spk_mute);
+
+int pm8xxx_spk_gain(u8 gain)
+{
+	u8 val;
+	int ret = 0;
+
+	if (spk_defined() == false) {
+		pr_err("Invalid spk handle or no spk_chip\n");
+		return -ENODEV;
+	}
+
+	val = pm8xxx_spk_read(PM8XXX_SPK_CTL1_REG_OFF);
+	if (val < 0)
+		return val;
+	val = (gain << 4) | (val & 0xF);
+	ret = pm8xxx_spk_write(PM8XXX_SPK_CTL1_REG_OFF, val);
+	if (!ret) {
+		pm8xxx_spk_bank_write(the_spk_chip->base
+			+ PM8XXX_SPK_TEST_REG_1_OFF,
+			0, BOOST_6DB_GAIN_EN_MASK | VSEL_LD0_1P2);
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pm8xxx_spk_gain);
+
+int pm8xxx_spk_enable(int enable)
+{
+	int val = 0;
+	u16 addr;
+	int ret = 0;
+
+	if (spk_defined() == false) {
+		pr_err("Invalid spk handle or no spk_chip\n");
+		return -ENODEV;
+	}
+
+	addr = the_spk_chip->base + PM8XXX_SPK_TEST_REG_1_OFF;
+	val = pm8xxx_spk_read(PM8XXX_SPK_CTL1_REG_OFF);
+	if (val < 0)
+		return val;
+	if (enable)
+		val |= (1 << 3);
+	else
+		val &= ~(1 << 3);
+	ret = pm8xxx_spk_write(PM8XXX_SPK_CTL1_REG_OFF, val);
+	if (!ret)
+		ret = pm8xxx_spk_bank_write(addr, 6, PWM_EN_MASK);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pm8xxx_spk_enable);
+
+static int pm8xxx_spk_config(void)
+{
+	u16 addr;
+	int ret = 0;
+
+	if (spk_defined() == false) {
+		pr_err("Invalid spk handle or no spk_chip\n");
+		return -ENODEV;
+	}
+
+	addr = the_spk_chip->base + PM8XXX_SPK_TEST_REG_1_OFF;
+	ret = pm8xxx_spk_bank_write(addr, 6, PWM_EN_MASK & 0);
+	if (!ret)
+		ret = pm8xxx_spk_gain(PM8XXX_SPK_GAIN);
+	return ret;
+}
+
+static int __devinit pm8xxx_spk_probe(struct platform_device *pdev)
+{
+	const struct pm8xxx_spk_platform_data *pdata = pdev->dev.platform_data;
+	int ret = 0;
+	u8 value = 0;
+
+	if (!pdata) {
+		pr_err("missing platform data\n");
+		return -EINVAL;
+	}
+
+	the_spk_chip = kzalloc(sizeof(struct pm8xxx_spk_chip), GFP_KERNEL);
+	if (the_spk_chip == NULL) {
+		pr_err("kzalloc() failed.\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&the_spk_chip->spk_mutex);
+
+	the_spk_chip->dev = &pdev->dev;
+	the_spk_chip->version = pm8xxx_get_version(the_spk_chip->dev->parent);
+	switch (pm8xxx_get_version(the_spk_chip->dev->parent)) {
+	case PM8XXX_VERSION_8038:
+		break;
+	default:
+		ret = -ENODEV;
+		goto err_handle;
+	}
+
+	memcpy(&(the_spk_chip->pdata), pdata,
+			sizeof(struct pm8xxx_spk_platform_data));
+
+	the_spk_chip->base = pdev->resource[0].start;
+	the_spk_chip->end = pdev->resource[0].end;
+
+	if (the_spk_chip->pdata.spk_add_enable) {
+		int val;
+		val = pm8xxx_spk_read(PM8XXX_SPK_CTL1_REG_OFF);
+		if (val < 0) {
+			ret = val;
+			goto err_handle;
+		}
+		val |= (the_spk_chip->pdata.spk_add_enable & PM8XXX_ADD_EN);
+		ret = pm8xxx_spk_write(PM8XXX_SPK_CTL1_REG_OFF, val);
+		if (ret < 0)
+			goto err_handle;
+	}
+	value = ((the_spk_chip->pdata.cd_ng_threshold << 5) |
+		the_spk_chip->pdata.cd_nf_preamp_bias << 3);
+	pr_debug("Setting SPK_CTL2_REG = %02x\n", value);
+	pm8xxx_spk_write(PM8XXX_SPK_CTL2_REG_OFF, value);
+
+	value = ((the_spk_chip->pdata.cd_ng_hold << 5) |
+		(the_spk_chip->pdata.cd_ng_max_atten << 1) |
+		the_spk_chip->pdata.noise_mute);
+	pr_debug("Setting SPK_CTL3_REG = %02x\n", value);
+	pm8xxx_spk_write(PM8XXX_SPK_CTL3_REG_OFF, value);
+
+	value = ((the_spk_chip->pdata.cd_ng_decay_rate << 5) |
+		(the_spk_chip->pdata.cd_ng_attack_rate << 3) |
+		the_spk_chip->pdata.cd_delay << 2);
+	pr_debug("Setting SPK_CTL4_REG = %02x\n", value);
+	pm8xxx_spk_write(PM8XXX_SPK_CTL4_REG_OFF, value);
+
+	return pm8xxx_spk_config();
+err_handle:
+	pr_err("pm8xxx_spk_probe failed."
+			"Audio unavailable on speaker.\n");
+	mutex_destroy(&the_spk_chip->spk_mutex);
+	kfree(the_spk_chip);
+	return ret;
+}
+
+static int __devexit pm8xxx_spk_remove(struct platform_device *pdev)
+{
+	if (spk_defined() == false) {
+		pr_err("Invalid spk handle or no spk_chip\n");
+		return -ENODEV;
+	}
+	mutex_destroy(&the_spk_chip->spk_mutex);
+	kfree(the_spk_chip);
+	return 0;
+}
+
+static struct platform_driver pm8xxx_spk_driver = {
+	.probe		= pm8xxx_spk_probe,
+	.remove		= __devexit_p(pm8xxx_spk_remove),
+	.driver		= {
+		.name = PM8XXX_SPK_DEV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init pm8xxx_spk_init(void)
+{
+	return platform_driver_register(&pm8xxx_spk_driver);
+}
+subsys_initcall(pm8xxx_spk_init);
+
+static void __exit pm8xxx_spk_exit(void)
+{
+	platform_driver_unregister(&pm8xxx_spk_driver);
+}
+module_exit(pm8xxx_spk_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("PM8XXX SPK driver");
+MODULE_ALIAS("platform:" PM8XXX_SPK_DEV_NAME);
diff --git a/drivers/mfd/wcd9xxx-core.c b/drivers/mfd/wcd9xxx-core.c
new file mode 100644
index 0000000..1ea8ce5
--- /dev/null
+++ b/drivers/mfd/wcd9xxx-core.c
@@ -0,0 +1,1168 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/wcd9xxx/wcd9xxx-slimslave.h>
+#include <linux/mfd/wcd9xxx/core.h>
+#include <linux/mfd/wcd9xxx/pdata.h>
+#include <linux/mfd/wcd9xxx/wcd9xxx_registers.h>
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/debugfs.h>
+#include <linux/regulator/consumer.h>
+#include <linux/i2c.h>
+#include <sound/soc.h>
+
+#define WCD9XXX_SLIM_GLA_MAX_RETRIES 5
+#define WCD9XXX_REGISTER_START_OFFSET 0x800
+#define WCD9XXX_SLIM_RW_MAX_TRIES 3
+
+#define MAX_WCD9XXX_DEVICE	4
+#define WCD9XXX_I2C_MODE	0x03
+
+struct wcd9xxx_i2c {
+	struct i2c_client *client;
+	struct i2c_msg xfer_msg[2];
+	struct mutex xfer_lock;
+	int mod_id;
+};
+
+struct wcd9xxx_i2c wcd9xxx_modules[MAX_WCD9XXX_DEVICE];
+static int wcd9xxx_intf = -1;
+
+static int wcd9xxx_read(struct wcd9xxx *wcd9xxx, unsigned short reg,
+		       int bytes, void *dest, bool interface_reg)
+{
+	int ret;
+	u8 *buf = dest;
+
+	if (bytes <= 0) {
+		dev_err(wcd9xxx->dev, "Invalid byte read length %d\n", bytes);
+		return -EINVAL;
+	}
+
+	ret = wcd9xxx->read_dev(wcd9xxx, reg, bytes, dest, interface_reg);
+	if (ret < 0) {
+		dev_err(wcd9xxx->dev, "Codec read failed\n");
+		return ret;
+	} else
+		dev_dbg(wcd9xxx->dev, "Read 0x%02x from 0x%x\n",
+			 *buf, reg);
+
+	return 0;
+}
+int wcd9xxx_reg_read(struct wcd9xxx *wcd9xxx, unsigned short reg)
+{
+	u8 val;
+	int ret;
+
+	mutex_lock(&wcd9xxx->io_lock);
+	ret = wcd9xxx_read(wcd9xxx, reg, 1, &val, false);
+	mutex_unlock(&wcd9xxx->io_lock);
+
+	if (ret < 0)
+		return ret;
+	else
+		return val;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_reg_read);
+
+static int wcd9xxx_write(struct wcd9xxx *wcd9xxx, unsigned short reg,
+			int bytes, void *src, bool interface_reg)
+{
+	u8 *buf = src;
+
+	if (bytes <= 0) {
+		pr_err("%s: Error, invalid write length\n", __func__);
+		return -EINVAL;
+	}
+
+	dev_dbg(wcd9xxx->dev, "Write %02x to 0x%x\n",
+		 *buf, reg);
+
+	return wcd9xxx->write_dev(wcd9xxx, reg, bytes, src, interface_reg);
+}
+
+int wcd9xxx_reg_write(struct wcd9xxx *wcd9xxx, unsigned short reg,
+		     u8 val)
+{
+	int ret;
+
+	mutex_lock(&wcd9xxx->io_lock);
+	ret = wcd9xxx_write(wcd9xxx, reg, 1, &val, false);
+	mutex_unlock(&wcd9xxx->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_reg_write);
+
+static u8 wcd9xxx_pgd_la;
+static u8 wcd9xxx_inf_la;
+
+int wcd9xxx_interface_reg_read(struct wcd9xxx *wcd9xxx, unsigned short reg)
+{
+	u8 val;
+	int ret;
+
+	mutex_lock(&wcd9xxx->io_lock);
+	ret = wcd9xxx_read(wcd9xxx, reg, 1, &val, true);
+	mutex_unlock(&wcd9xxx->io_lock);
+
+	if (ret < 0)
+		return ret;
+	else
+		return val;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_interface_reg_read);
+
+int wcd9xxx_interface_reg_write(struct wcd9xxx *wcd9xxx, unsigned short reg,
+		     u8 val)
+{
+	int ret;
+
+	mutex_lock(&wcd9xxx->io_lock);
+	ret = wcd9xxx_write(wcd9xxx, reg, 1, &val, true);
+	mutex_unlock(&wcd9xxx->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_interface_reg_write);
+
+int wcd9xxx_bulk_read(struct wcd9xxx *wcd9xxx, unsigned short reg,
+		     int count, u8 *buf)
+{
+	int ret;
+
+	mutex_lock(&wcd9xxx->io_lock);
+
+	ret = wcd9xxx_read(wcd9xxx, reg, count, buf, false);
+
+	mutex_unlock(&wcd9xxx->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_bulk_read);
+
+int wcd9xxx_bulk_write(struct wcd9xxx *wcd9xxx, unsigned short reg,
+		     int count, u8 *buf)
+{
+	int ret;
+
+	mutex_lock(&wcd9xxx->io_lock);
+
+	ret = wcd9xxx_write(wcd9xxx, reg, count, buf, false);
+
+	mutex_unlock(&wcd9xxx->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_bulk_write);
+
+static int wcd9xxx_slim_read_device(struct wcd9xxx *wcd9xxx, unsigned short reg,
+				int bytes, void *dest, bool interface)
+{
+	int ret;
+	struct slim_ele_access msg;
+	int slim_read_tries = WCD9XXX_SLIM_RW_MAX_TRIES;
+	msg.start_offset = WCD9XXX_REGISTER_START_OFFSET + reg;
+	msg.num_bytes = bytes;
+	msg.comp = NULL;
+
+	while (1) {
+		mutex_lock(&wcd9xxx->xfer_lock);
+		ret = slim_request_val_element(interface ?
+			       wcd9xxx->slim_slave : wcd9xxx->slim,
+			       &msg, dest, bytes);
+		mutex_unlock(&wcd9xxx->xfer_lock);
+		if (likely(ret == 0) || (--slim_read_tries == 0))
+			break;
+		usleep_range(5000, 5000);
+	}
+
+	if (ret)
+		pr_err("%s: Error, Codec read failed (%d)\n", __func__, ret);
+
+	return ret;
+}
+/* Interface specifies whether the write is to the interface or general
+ * registers.
+ */
+static int wcd9xxx_slim_write_device(struct wcd9xxx *wcd9xxx,
+		unsigned short reg, int bytes, void *src, bool interface)
+{
+	int ret;
+	struct slim_ele_access msg;
+	int slim_write_tries = WCD9XXX_SLIM_RW_MAX_TRIES;
+	msg.start_offset = WCD9XXX_REGISTER_START_OFFSET + reg;
+	msg.num_bytes = bytes;
+	msg.comp = NULL;
+
+	while (1) {
+		mutex_lock(&wcd9xxx->xfer_lock);
+		ret = slim_change_val_element(interface ?
+			      wcd9xxx->slim_slave : wcd9xxx->slim,
+			      &msg, src, bytes);
+		mutex_unlock(&wcd9xxx->xfer_lock);
+		if (likely(ret == 0) || (--slim_write_tries == 0))
+			break;
+		usleep_range(5000, 5000);
+	}
+
+	if (ret)
+		pr_err("%s: Error, Codec write failed (%d)\n", __func__, ret);
+
+	return ret;
+}
+
+static struct mfd_cell tabla1x_devs[] = {
+	{
+		.name = "tabla1x_codec",
+	},
+};
+
+static struct mfd_cell tabla_devs[] = {
+	{
+		.name = "tabla_codec",
+	},
+};
+
+static struct mfd_cell sitar_devs[] = {
+	{
+		.name = "sitar_codec",
+	},
+};
+
+static void wcd9xxx_bring_up(struct wcd9xxx *wcd9xxx)
+{
+	wcd9xxx_reg_write(wcd9xxx, WCD9XXX_A_LEAKAGE_CTL, 0x4);
+	wcd9xxx_reg_write(wcd9xxx, WCD9XXX_A_CDC_CTL, 0);
+	usleep_range(5000, 5000);
+	wcd9xxx_reg_write(wcd9xxx, WCD9XXX_A_CDC_CTL, 3);
+	wcd9xxx_reg_write(wcd9xxx, WCD9XXX_A_LEAKAGE_CTL, 3);
+}
+
+static void wcd9xxx_bring_down(struct wcd9xxx *wcd9xxx)
+{
+	wcd9xxx_reg_write(wcd9xxx, WCD9XXX_A_LEAKAGE_CTL, 0x7);
+	wcd9xxx_reg_write(wcd9xxx, WCD9XXX_A_LEAKAGE_CTL, 0x6);
+	wcd9xxx_reg_write(wcd9xxx, WCD9XXX_A_LEAKAGE_CTL, 0xe);
+	wcd9xxx_reg_write(wcd9xxx, WCD9XXX_A_LEAKAGE_CTL, 0x8);
+}
+
+static int wcd9xxx_reset(struct wcd9xxx *wcd9xxx)
+{
+	int ret;
+
+	if (wcd9xxx->reset_gpio) {
+		ret = gpio_request(wcd9xxx->reset_gpio, "CDC_RESET");
+		if (ret) {
+			pr_err("%s: Failed to request gpio %d\n", __func__,
+				wcd9xxx->reset_gpio);
+			wcd9xxx->reset_gpio = 0;
+			return ret;
+		}
+
+		gpio_direction_output(wcd9xxx->reset_gpio, 1);
+		msleep(20);
+		gpio_direction_output(wcd9xxx->reset_gpio, 0);
+		msleep(20);
+		gpio_direction_output(wcd9xxx->reset_gpio, 1);
+		msleep(20);
+	}
+	return 0;
+}
+
+static void wcd9xxx_free_reset(struct wcd9xxx *wcd9xxx)
+{
+	if (wcd9xxx->reset_gpio) {
+		gpio_free(wcd9xxx->reset_gpio);
+		wcd9xxx->reset_gpio = 0;
+	}
+}
+
+static int wcd9xxx_device_init(struct wcd9xxx *wcd9xxx, int irq)
+{
+	int ret;
+	u8 idbyte_0, idbyte_1, idbyte_2, idbyte_3;
+	struct mfd_cell *wcd9xxx_dev = NULL;
+	int wcd9xxx_dev_size = 0;
+
+	mutex_init(&wcd9xxx->io_lock);
+	mutex_init(&wcd9xxx->xfer_lock);
+
+	mutex_init(&wcd9xxx->pm_lock);
+	wcd9xxx->wlock_holders = 0;
+	wcd9xxx->pm_state = WCD9XXX_PM_SLEEPABLE;
+	init_waitqueue_head(&wcd9xxx->pm_wq);
+	wake_lock_init(&wcd9xxx->wlock, WAKE_LOCK_IDLE, "wcd9310-irq");
+
+	dev_set_drvdata(wcd9xxx->dev, wcd9xxx);
+
+	wcd9xxx_bring_up(wcd9xxx);
+
+	ret = wcd9xxx_irq_init(wcd9xxx);
+	if (ret) {
+		pr_err("IRQ initialization failed\n");
+		goto err;
+	}
+
+	idbyte_0 = wcd9xxx_reg_read(wcd9xxx, WCD9XXX_A_CHIP_ID_BYTE_0);
+	idbyte_1 = wcd9xxx_reg_read(wcd9xxx, WCD9XXX_A_CHIP_ID_BYTE_1);
+	idbyte_2 = wcd9xxx_reg_read(wcd9xxx, WCD9XXX_A_CHIP_ID_BYTE_2);
+	idbyte_3 = wcd9xxx_reg_read(wcd9xxx, WCD9XXX_A_CHIP_ID_BYTE_3);
+
+	wcd9xxx->version = wcd9xxx_reg_read(wcd9xxx,
+			WCD9XXX_A_CHIP_VERSION) & 0x1F;
+	pr_info("%s : Codec version %u initialized\n",
+		__func__, wcd9xxx->version);
+	pr_info("idbyte_0[%08x] idbyte_1[%08x] idbyte_2[%08x] idbyte_3[%08x]\n",
+			idbyte_0, idbyte_1, idbyte_2, idbyte_3);
+
+	if (wcd9xxx->slim != NULL) {
+		if (!strncmp(wcd9xxx->slim->name, "tabla", 5)) {
+			if (TABLA_IS_1_X(wcd9xxx->version)) {
+				wcd9xxx_dev = tabla1x_devs;
+				wcd9xxx_dev_size = ARRAY_SIZE(tabla1x_devs);
+			} else {
+				wcd9xxx_dev = tabla_devs;
+				wcd9xxx_dev_size = ARRAY_SIZE(tabla_devs);
+			}
+		} else {
+			wcd9xxx_dev = sitar_devs;
+			wcd9xxx_dev_size = ARRAY_SIZE(sitar_devs);
+		}
+	} else {
+		/* Need to add here check for Tabla.
+		 * For now the read of version takes
+		 * care of now only tabla.
+		 */
+		pr_debug("%s : Read codec version using I2C\n",	__func__);
+		if (TABLA_IS_1_X(wcd9xxx->version)) {
+			wcd9xxx_dev = tabla1x_devs;
+			wcd9xxx_dev_size = ARRAY_SIZE(tabla1x_devs);
+		} else if (TABLA_IS_2_0(wcd9xxx->version)) {
+			wcd9xxx_dev = tabla_devs;
+			wcd9xxx_dev_size = ARRAY_SIZE(tabla_devs);
+		} else {
+			wcd9xxx_dev = sitar_devs;
+			wcd9xxx_dev_size = ARRAY_SIZE(sitar_devs);
+		}
+	}
+
+	ret = mfd_add_devices(wcd9xxx->dev, -1,
+		      wcd9xxx_dev, wcd9xxx_dev_size,
+		      NULL, 0);
+	if (ret != 0) {
+		dev_err(wcd9xxx->dev, "Failed to add children: %d\n", ret);
+		goto err_irq;
+	}
+	return ret;
+err_irq:
+	wcd9xxx_irq_exit(wcd9xxx);
+err:
+	wcd9xxx_bring_down(wcd9xxx);
+	wake_lock_destroy(&wcd9xxx->wlock);
+	mutex_destroy(&wcd9xxx->pm_lock);
+	mutex_destroy(&wcd9xxx->io_lock);
+	mutex_destroy(&wcd9xxx->xfer_lock);
+	return ret;
+}
+
+static void wcd9xxx_device_exit(struct wcd9xxx *wcd9xxx)
+{
+	wcd9xxx_irq_exit(wcd9xxx);
+	wcd9xxx_bring_down(wcd9xxx);
+	wcd9xxx_free_reset(wcd9xxx);
+	mutex_destroy(&wcd9xxx->pm_lock);
+	wake_lock_destroy(&wcd9xxx->wlock);
+	mutex_destroy(&wcd9xxx->io_lock);
+	mutex_destroy(&wcd9xxx->xfer_lock);
+	if (wcd9xxx_intf == WCD9XXX_INTERFACE_TYPE_SLIMBUS)
+		slim_remove_device(wcd9xxx->slim_slave);
+	kfree(wcd9xxx);
+}
+
+
+#ifdef CONFIG_DEBUG_FS
+struct wcd9xxx *debugCodec;
+
+static struct dentry *debugfs_wcd9xxx_dent;
+static struct dentry *debugfs_peek;
+static struct dentry *debugfs_poke;
+
+static unsigned char read_data;
+
+static int codec_debug_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static int get_parameters(char *buf, long int *param1, int num_of_par)
+{
+	char *token;
+	int base, cnt;
+
+	token = strsep(&buf, " ");
+
+	for (cnt = 0; cnt < num_of_par; cnt++) {
+		if (token != NULL) {
+			if ((token[1] == 'x') || (token[1] == 'X'))
+				base = 16;
+			else
+				base = 10;
+
+			if (strict_strtoul(token, base, &param1[cnt]) != 0)
+				return -EINVAL;
+
+			token = strsep(&buf, " ");
+		} else
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static ssize_t codec_debug_read(struct file *file, char __user *ubuf,
+				size_t count, loff_t *ppos)
+{
+	char lbuf[8];
+
+	snprintf(lbuf, sizeof(lbuf), "0x%x\n", read_data);
+	return simple_read_from_buffer(ubuf, count, ppos, lbuf,
+		strnlen(lbuf, 7));
+}
+
+
+static ssize_t codec_debug_write(struct file *filp,
+	const char __user *ubuf, size_t cnt, loff_t *ppos)
+{
+	char *access_str = filp->private_data;
+	char lbuf[32];
+	int rc;
+	long int param[5];
+
+	if (cnt > sizeof(lbuf) - 1)
+		return -EINVAL;
+
+	rc = copy_from_user(lbuf, ubuf, cnt);
+	if (rc)
+		return -EFAULT;
+
+	lbuf[cnt] = '\0';
+
+	if (!strncmp(access_str, "poke", 6)) {
+		/* write */
+		rc = get_parameters(lbuf, param, 2);
+		if ((param[0] <= 0x3FF) && (param[1] <= 0xFF) &&
+			(rc == 0))
+			wcd9xxx_interface_reg_write(debugCodec, param[0],
+				param[1]);
+		else
+			rc = -EINVAL;
+	} else if (!strncmp(access_str, "peek", 6)) {
+		/* read */
+		rc = get_parameters(lbuf, param, 1);
+		if ((param[0] <= 0x3FF) && (rc == 0))
+			read_data = wcd9xxx_interface_reg_read(debugCodec,
+				param[0]);
+		else
+			rc = -EINVAL;
+	}
+
+	if (rc == 0)
+		rc = cnt;
+	else
+		pr_err("%s: rc = %d\n", __func__, rc);
+
+	return rc;
+}
+
+static const struct file_operations codec_debug_ops = {
+	.open = codec_debug_open,
+	.write = codec_debug_write,
+	.read = codec_debug_read
+};
+#endif
+
+static int wcd9xxx_enable_supplies(struct wcd9xxx *wcd9xxx,
+				struct wcd9xxx_pdata *pdata)
+{
+	int ret;
+	int i;
+	wcd9xxx->supplies = kzalloc(sizeof(struct regulator_bulk_data) *
+				   ARRAY_SIZE(pdata->regulator),
+				   GFP_KERNEL);
+	if (!wcd9xxx->supplies) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pdata->regulator); i++)
+		wcd9xxx->supplies[i].supply = pdata->regulator[i].name;
+
+	ret = regulator_bulk_get(wcd9xxx->dev, ARRAY_SIZE(pdata->regulator),
+				 wcd9xxx->supplies);
+	if (ret != 0) {
+		dev_err(wcd9xxx->dev, "Failed to get supplies: err = %d\n",
+							ret);
+		goto err_supplies;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pdata->regulator); i++) {
+		ret = regulator_set_voltage(wcd9xxx->supplies[i].consumer,
+			pdata->regulator[i].min_uV, pdata->regulator[i].max_uV);
+		if (ret) {
+			pr_err("%s: Setting regulator voltage failed for "
+				"regulator %s err = %d\n", __func__,
+				wcd9xxx->supplies[i].supply, ret);
+			goto err_get;
+		}
+
+		ret = regulator_set_optimum_mode(wcd9xxx->supplies[i].consumer,
+			pdata->regulator[i].optimum_uA);
+		if (ret < 0) {
+			pr_err("%s: Setting regulator optimum mode failed for "
+				"regulator %s err = %d\n", __func__,
+				wcd9xxx->supplies[i].supply, ret);
+			goto err_get;
+		}
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pdata->regulator),
+				    wcd9xxx->supplies);
+	if (ret != 0) {
+		dev_err(wcd9xxx->dev, "Failed to enable supplies: err = %d\n",
+				ret);
+		goto err_configure;
+	}
+	return ret;
+
+err_configure:
+	for (i = 0; i < ARRAY_SIZE(pdata->regulator); i++) {
+		regulator_set_voltage(wcd9xxx->supplies[i].consumer, 0,
+			pdata->regulator[i].max_uV);
+		regulator_set_optimum_mode(wcd9xxx->supplies[i].consumer, 0);
+	}
+err_get:
+	regulator_bulk_free(ARRAY_SIZE(pdata->regulator), wcd9xxx->supplies);
+err_supplies:
+	kfree(wcd9xxx->supplies);
+err:
+	return ret;
+}
+
+static void wcd9xxx_disable_supplies(struct wcd9xxx *wcd9xxx,
+				     struct wcd9xxx_pdata *pdata)
+{
+	int i;
+
+	regulator_bulk_disable(ARRAY_SIZE(pdata->regulator),
+				    wcd9xxx->supplies);
+	for (i = 0; i < ARRAY_SIZE(pdata->regulator); i++) {
+		regulator_set_voltage(wcd9xxx->supplies[i].consumer, 0,
+			pdata->regulator[i].max_uV);
+		regulator_set_optimum_mode(wcd9xxx->supplies[i].consumer, 0);
+	}
+	regulator_bulk_free(ARRAY_SIZE(pdata->regulator), wcd9xxx->supplies);
+	kfree(wcd9xxx->supplies);
+}
+
+int wcd9xxx_get_intf_type(void)
+{
+	return wcd9xxx_intf;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_get_intf_type);
+
+struct wcd9xxx_i2c *get_i2c_wcd9xxx_device_info(u16 reg)
+{
+	u16 mask = 0x0f00;
+	int value = 0;
+	struct wcd9xxx_i2c *wcd9xxx = NULL;
+	value = ((reg & mask) >> 8) & 0x000f;
+	switch (value) {
+	case 0:
+		wcd9xxx = &wcd9xxx_modules[0];
+		break;
+	case 1:
+		wcd9xxx = &wcd9xxx_modules[1];
+		break;
+	case 2:
+		wcd9xxx = &wcd9xxx_modules[2];
+		break;
+	case 3:
+		wcd9xxx = &wcd9xxx_modules[3];
+		break;
+	default:
+		break;
+	}
+	return wcd9xxx;
+}
+
+int wcd9xxx_i2c_write_device(u16 reg, u8 *value,
+				u32 bytes)
+{
+
+	struct i2c_msg *msg;
+	int ret = 0;
+	u8 reg_addr = 0;
+	u8 data[bytes + 1];
+	struct wcd9xxx_i2c *wcd9xxx;
+
+	wcd9xxx = get_i2c_wcd9xxx_device_info(reg);
+	if (wcd9xxx == NULL || wcd9xxx->client == NULL) {
+		pr_err("failed to get device info\n");
+		return -ENODEV;
+	}
+	reg_addr = (u8)reg;
+	msg = &wcd9xxx->xfer_msg[0];
+	msg->addr = wcd9xxx->client->addr;
+	msg->len = bytes + 1;
+	msg->flags = 0;
+	data[0] = reg;
+	data[1] = *value;
+	msg->buf = data;
+	ret = i2c_transfer(wcd9xxx->client->adapter, wcd9xxx->xfer_msg, 1);
+	/* Try again if the write fails */
+	if (ret != 1) {
+		ret = i2c_transfer(wcd9xxx->client->adapter,
+						wcd9xxx->xfer_msg, 1);
+		if (ret != 1) {
+			pr_err("failed to write the device\n");
+			return ret;
+		}
+	}
+	pr_debug("write sucess register = %x val = %x\n", reg, data[1]);
+	return 0;
+}
+
+
+int wcd9xxx_i2c_read_device(unsigned short reg,
+				  int bytes, unsigned char *dest)
+{
+	struct i2c_msg *msg;
+	int ret = 0;
+	u8 reg_addr = 0;
+	struct wcd9xxx_i2c *wcd9xxx;
+	u8 i = 0;
+
+	wcd9xxx = get_i2c_wcd9xxx_device_info(reg);
+	if (wcd9xxx == NULL || wcd9xxx->client == NULL) {
+		pr_err("failed to get device info\n");
+		return -ENODEV;
+	}
+	for (i = 0; i < bytes; i++) {
+		reg_addr = (u8)reg++;
+		msg = &wcd9xxx->xfer_msg[0];
+		msg->addr = wcd9xxx->client->addr;
+		msg->len = 1;
+		msg->flags = 0;
+		msg->buf = &reg_addr;
+
+		msg = &wcd9xxx->xfer_msg[1];
+		msg->addr = wcd9xxx->client->addr;
+		msg->len = 1;
+		msg->flags = I2C_M_RD;
+		msg->buf = dest++;
+		ret = i2c_transfer(wcd9xxx->client->adapter,
+				wcd9xxx->xfer_msg, 2);
+
+		/* Try again if read fails first time */
+		if (ret != 2) {
+			ret = i2c_transfer(wcd9xxx->client->adapter,
+							wcd9xxx->xfer_msg, 2);
+			if (ret != 2) {
+				pr_err("failed to read wcd9xxx register\n");
+				return ret;
+			}
+		}
+	}
+	return 0;
+}
+
+int wcd9xxx_i2c_read(struct wcd9xxx *wcd9xxx, unsigned short reg,
+			int bytes, void *dest, bool interface_reg)
+{
+	return wcd9xxx_i2c_read_device(reg, bytes, dest);
+}
+
+int wcd9xxx_i2c_write(struct wcd9xxx *wcd9xxx, unsigned short reg,
+			 int bytes, void *src, bool interface_reg)
+{
+	return wcd9xxx_i2c_write_device(reg, src, bytes);
+}
+
+static int __devinit wcd9xxx_i2c_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct wcd9xxx *wcd9xxx;
+	struct wcd9xxx_pdata *pdata = client->dev.platform_data;
+	int val = 0;
+	int ret = 0;
+	static int device_id;
+
+	if (wcd9xxx_intf == WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
+		pr_info("tabla card is already detected in slimbus mode\n");
+		return -ENODEV;
+	}
+	if (device_id > 0) {
+		wcd9xxx_modules[device_id++].client = client;
+		pr_info("probe for other slaves devices of tabla\n");
+		return ret;
+	}
+
+	wcd9xxx = kzalloc(sizeof(struct wcd9xxx), GFP_KERNEL);
+	if (wcd9xxx == NULL) {
+		pr_err("%s: error, allocation failed\n", __func__);
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	if (!pdata) {
+		dev_dbg(&client->dev, "no platform data?\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+	if (i2c_check_functionality(client->adapter, I2C_FUNC_I2C) == 0) {
+		dev_dbg(&client->dev, "can't talk I2C?\n");
+		ret = -EIO;
+		goto fail;
+	}
+	dev_set_drvdata(&client->dev, wcd9xxx);
+	wcd9xxx->dev = &client->dev;
+	wcd9xxx->reset_gpio = pdata->reset_gpio;
+	ret = wcd9xxx_enable_supplies(wcd9xxx, pdata);
+	if (ret) {
+		pr_err("%s: Fail to enable Codec supplies\n", __func__);
+		goto err_codec;
+	}
+
+	usleep_range(5, 5);
+	ret = wcd9xxx_reset(wcd9xxx);
+	if (ret) {
+		pr_err("%s: Resetting Codec failed\n", __func__);
+		goto err_supplies;
+	}
+	wcd9xxx_modules[device_id++].client = client;
+
+	wcd9xxx->read_dev = wcd9xxx_i2c_read;
+	wcd9xxx->write_dev = wcd9xxx_i2c_write;
+	wcd9xxx->irq = pdata->irq;
+	wcd9xxx->irq_base = pdata->irq_base;
+
+	/*read the tabla status before initializing the device type*/
+	ret = wcd9xxx_read(wcd9xxx, WCD9XXX_A_CHIP_STATUS, 1, &val, 0);
+	if ((ret < 0) || (val != WCD9XXX_I2C_MODE)) {
+		pr_err("failed to read the wcd9xxx status\n");
+		goto err_device_init;
+	}
+
+	ret = wcd9xxx_device_init(wcd9xxx, wcd9xxx->irq);
+	if (ret) {
+		pr_err("%s: error, initializing device failed\n", __func__);
+		goto err_device_init;
+	}
+	wcd9xxx_intf = WCD9XXX_INTERFACE_TYPE_I2C;
+
+	return ret;
+err_device_init:
+	wcd9xxx_free_reset(wcd9xxx);
+err_supplies:
+	wcd9xxx_disable_supplies(wcd9xxx, pdata);
+err_codec:
+	kfree(wcd9xxx);
+fail:
+	return ret;
+}
+
+static int __devexit wcd9xxx_i2c_remove(struct i2c_client *client)
+{
+	struct wcd9xxx *wcd9xxx;
+	struct wcd9xxx_pdata *pdata = client->dev.platform_data;
+	pr_debug("exit\n");
+	wcd9xxx = dev_get_drvdata(&client->dev);
+	wcd9xxx_disable_supplies(wcd9xxx, pdata);
+	wcd9xxx_device_exit(wcd9xxx);
+	return 0;
+}
+
+static int wcd9xxx_slim_probe(struct slim_device *slim)
+{
+	struct wcd9xxx *wcd9xxx;
+	struct wcd9xxx_pdata *pdata;
+	int ret = 0;
+	int sgla_retry_cnt;
+
+	dev_info(&slim->dev, "Initialized slim device %s\n", slim->name);
+	pdata = slim->dev.platform_data;
+
+	if (!pdata) {
+		dev_err(&slim->dev, "Error, no platform data\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	wcd9xxx = kzalloc(sizeof(struct wcd9xxx), GFP_KERNEL);
+	if (wcd9xxx == NULL) {
+		pr_err("%s: error, allocation failed\n", __func__);
+		ret = -ENOMEM;
+		goto err;
+	}
+	if (!slim->ctrl) {
+		pr_err("Error, no SLIMBUS control data\n");
+		ret = -EINVAL;
+		goto err_codec;
+	}
+	wcd9xxx->slim = slim;
+	slim_set_clientdata(slim, wcd9xxx);
+	wcd9xxx->reset_gpio = pdata->reset_gpio;
+	wcd9xxx->dev = &slim->dev;
+
+	ret = wcd9xxx_enable_supplies(wcd9xxx, pdata);
+	if (ret)
+		goto err_codec;
+	usleep_range(5, 5);
+
+	ret = wcd9xxx_reset(wcd9xxx);
+	if (ret) {
+		pr_err("%s: Resetting Codec failed\n", __func__);
+		goto err_supplies;
+	}
+
+	ret = slim_get_logical_addr(wcd9xxx->slim, wcd9xxx->slim->e_addr,
+		ARRAY_SIZE(wcd9xxx->slim->e_addr), &wcd9xxx->slim->laddr);
+	if (ret) {
+		pr_err("fail to get slimbus logical address %d\n", ret);
+		goto err_reset;
+	}
+	wcd9xxx->read_dev = wcd9xxx_slim_read_device;
+	wcd9xxx->write_dev = wcd9xxx_slim_write_device;
+	wcd9xxx->irq = pdata->irq;
+	wcd9xxx->irq_base = pdata->irq_base;
+	wcd9xxx_pgd_la = wcd9xxx->slim->laddr;
+
+	if (pdata->num_irqs < TABLA_NUM_IRQS) {
+		pr_err("%s: Error, not enough interrupt lines allocated\n",
+			__func__);
+		goto err_reset;
+	}
+
+	wcd9xxx->slim_slave = &pdata->slimbus_slave_device;
+
+	ret = slim_add_device(slim->ctrl, wcd9xxx->slim_slave);
+	if (ret) {
+		pr_err("%s: error, adding SLIMBUS device failed\n", __func__);
+		goto err_reset;
+	}
+
+	sgla_retry_cnt = 0;
+
+	while (1) {
+		ret = slim_get_logical_addr(wcd9xxx->slim_slave,
+			wcd9xxx->slim_slave->e_addr,
+			ARRAY_SIZE(wcd9xxx->slim_slave->e_addr),
+			&wcd9xxx->slim_slave->laddr);
+		if (ret) {
+			if (sgla_retry_cnt++ < WCD9XXX_SLIM_GLA_MAX_RETRIES) {
+				/* Give SLIMBUS slave time to report present
+				   and be ready.
+				 */
+				usleep_range(1000, 1000);
+				pr_debug("%s: retry slim_get_logical_addr()\n",
+					__func__);
+				continue;
+			}
+			pr_err("fail to get slimbus slave logical address"
+				" %d\n", ret);
+			goto err_slim_add;
+		}
+		break;
+	}
+	wcd9xxx_inf_la = wcd9xxx->slim_slave->laddr;
+	wcd9xxx_intf = WCD9XXX_INTERFACE_TYPE_SLIMBUS;
+
+	ret = wcd9xxx_device_init(wcd9xxx, wcd9xxx->irq);
+	if (ret) {
+		pr_err("%s: error, initializing device failed\n", __func__);
+		goto err_slim_add;
+	}
+	wcd9xxx_init_slimslave(wcd9xxx, wcd9xxx_pgd_la);
+#ifdef CONFIG_DEBUG_FS
+	debugCodec = wcd9xxx;
+
+	debugfs_wcd9xxx_dent = debugfs_create_dir
+		("wcd9310_slimbus_interface_device", 0);
+	if (!IS_ERR(debugfs_wcd9xxx_dent)) {
+		debugfs_peek = debugfs_create_file("peek",
+		S_IFREG | S_IRUGO, debugfs_wcd9xxx_dent,
+		(void *) "peek", &codec_debug_ops);
+
+		debugfs_poke = debugfs_create_file("poke",
+		S_IFREG | S_IRUGO, debugfs_wcd9xxx_dent,
+		(void *) "poke", &codec_debug_ops);
+	}
+#endif
+
+	return ret;
+
+err_slim_add:
+	slim_remove_device(wcd9xxx->slim_slave);
+err_reset:
+	wcd9xxx_free_reset(wcd9xxx);
+err_supplies:
+	wcd9xxx_disable_supplies(wcd9xxx, pdata);
+err_codec:
+	kfree(wcd9xxx);
+err:
+	return ret;
+}
+static int wcd9xxx_slim_remove(struct slim_device *pdev)
+{
+	struct wcd9xxx *wcd9xxx;
+	struct wcd9xxx_pdata *pdata = pdev->dev.platform_data;
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(debugfs_peek);
+	debugfs_remove(debugfs_poke);
+	debugfs_remove(debugfs_wcd9xxx_dent);
+#endif
+	wcd9xxx = slim_get_devicedata(pdev);
+	wcd9xxx_deinit_slimslave(wcd9xxx);
+	slim_remove_device(wcd9xxx->slim_slave);
+	wcd9xxx_disable_supplies(wcd9xxx, pdata);
+	wcd9xxx_device_exit(wcd9xxx);
+	return 0;
+}
+
+static int wcd9xxx_resume(struct wcd9xxx *wcd9xxx)
+{
+	int ret = 0;
+
+	pr_debug("%s: enter\n", __func__);
+	mutex_lock(&wcd9xxx->pm_lock);
+	if (wcd9xxx->pm_state == WCD9XXX_PM_ASLEEP) {
+		pr_debug("%s: resuming system, state %d, wlock %d\n", __func__,
+			 wcd9xxx->pm_state, wcd9xxx->wlock_holders);
+		wcd9xxx->pm_state = WCD9XXX_PM_SLEEPABLE;
+	} else {
+		pr_warn("%s: system is already awake, state %d wlock %d\n",
+			__func__, wcd9xxx->pm_state, wcd9xxx->wlock_holders);
+	}
+	mutex_unlock(&wcd9xxx->pm_lock);
+	wake_up_all(&wcd9xxx->pm_wq);
+
+	return ret;
+}
+
+static int wcd9xxx_slim_resume(struct slim_device *sldev)
+{
+	struct wcd9xxx *wcd9xxx = slim_get_devicedata(sldev);
+	return wcd9xxx_resume(wcd9xxx);
+}
+
+static int wcd9xxx_i2c_resume(struct i2c_client *i2cdev)
+{
+	struct wcd9xxx *wcd9xxx = dev_get_drvdata(&i2cdev->dev);
+	if (wcd9xxx)
+		return wcd9xxx_resume(wcd9xxx);
+	else
+		return 0;
+}
+
+static int wcd9xxx_suspend(struct wcd9xxx *wcd9xxx, pm_message_t pmesg)
+{
+	int ret = 0;
+
+	pr_debug("%s: enter\n", __func__);
+	/* wake_lock() can be called after this suspend chain call started.
+	 * thus suspend can be called while wlock is being held */
+	mutex_lock(&wcd9xxx->pm_lock);
+	if (wcd9xxx->pm_state == WCD9XXX_PM_SLEEPABLE) {
+		pr_debug("%s: suspending system, state %d, wlock %d\n",
+			 __func__, wcd9xxx->pm_state, wcd9xxx->wlock_holders);
+		wcd9xxx->pm_state = WCD9XXX_PM_ASLEEP;
+	} else if (wcd9xxx->pm_state == WCD9XXX_PM_AWAKE) {
+		/* unlock to wait for pm_state == WCD9XXX_PM_SLEEPABLE
+		 * then set to WCD9XXX_PM_ASLEEP */
+		pr_debug("%s: waiting to suspend system, state %d, wlock %d\n",
+			 __func__, wcd9xxx->pm_state, wcd9xxx->wlock_holders);
+		mutex_unlock(&wcd9xxx->pm_lock);
+		if (!(wait_event_timeout(wcd9xxx->pm_wq,
+					 wcd9xxx_pm_cmpxchg(wcd9xxx,
+						  WCD9XXX_PM_SLEEPABLE,
+						  WCD9XXX_PM_ASLEEP) ==
+							WCD9XXX_PM_SLEEPABLE,
+					 HZ))) {
+			pr_debug("%s: suspend failed state %d, wlock %d\n",
+				 __func__, wcd9xxx->pm_state,
+				 wcd9xxx->wlock_holders);
+			ret = -EBUSY;
+		} else {
+			pr_debug("%s: done, state %d, wlock %d\n", __func__,
+				 wcd9xxx->pm_state, wcd9xxx->wlock_holders);
+		}
+		mutex_lock(&wcd9xxx->pm_lock);
+	} else if (wcd9xxx->pm_state == WCD9XXX_PM_ASLEEP) {
+		pr_warn("%s: system is already suspended, state %d, wlock %dn",
+			__func__, wcd9xxx->pm_state, wcd9xxx->wlock_holders);
+	}
+	mutex_unlock(&wcd9xxx->pm_lock);
+
+	return ret;
+}
+
+static int wcd9xxx_slim_suspend(struct slim_device *sldev, pm_message_t pmesg)
+{
+	struct wcd9xxx *wcd9xxx = slim_get_devicedata(sldev);
+	return wcd9xxx_suspend(wcd9xxx, pmesg);
+}
+
+static int wcd9xxx_i2c_suspend(struct i2c_client *i2cdev, pm_message_t pmesg)
+{
+	struct wcd9xxx *wcd9xxx = dev_get_drvdata(&i2cdev->dev);
+	if (wcd9xxx)
+		return wcd9xxx_suspend(wcd9xxx, pmesg);
+	else
+		return 0;
+}
+
+static const struct slim_device_id sitar_slimtest_id[] = {
+	{"sitar-slim", 0},
+	{}
+};
+static struct slim_driver sitar_slim_driver = {
+	.driver = {
+		.name = "sitar-slim",
+		.owner = THIS_MODULE,
+	},
+	.probe = wcd9xxx_slim_probe,
+	.remove = wcd9xxx_slim_remove,
+	.id_table = sitar_slimtest_id,
+	.resume = wcd9xxx_slim_resume,
+	.suspend = wcd9xxx_slim_suspend,
+};
+
+static const struct slim_device_id sitar1p1_slimtest_id[] = {
+	{"sitar1p1-slim", 0},
+	{}
+};
+static struct slim_driver sitar1p1_slim_driver = {
+	.driver = {
+		.name = "sitar1p1-slim",
+		.owner = THIS_MODULE,
+	},
+	.probe = wcd9xxx_slim_probe,
+	.remove = wcd9xxx_slim_remove,
+	.id_table = sitar1p1_slimtest_id,
+	.resume = wcd9xxx_slim_resume,
+	.suspend = wcd9xxx_slim_suspend,
+};
+
+static const struct slim_device_id slimtest_id[] = {
+	{"tabla-slim", 0},
+	{}
+};
+
+static struct slim_driver tabla_slim_driver = {
+	.driver = {
+		.name = "tabla-slim",
+		.owner = THIS_MODULE,
+	},
+	.probe = wcd9xxx_slim_probe,
+	.remove = wcd9xxx_slim_remove,
+	.id_table = slimtest_id,
+	.resume = wcd9xxx_slim_resume,
+	.suspend = wcd9xxx_slim_suspend,
+};
+
+static const struct slim_device_id slimtest2x_id[] = {
+	{"tabla2x-slim", 0},
+	{}
+};
+
+static struct slim_driver tabla2x_slim_driver = {
+	.driver = {
+		.name = "tabla2x-slim",
+		.owner = THIS_MODULE,
+	},
+	.probe = wcd9xxx_slim_probe,
+	.remove = wcd9xxx_slim_remove,
+	.id_table = slimtest2x_id,
+	.resume = wcd9xxx_slim_resume,
+	.suspend = wcd9xxx_slim_suspend,
+};
+
+#define TABLA_I2C_TOP_LEVEL 0
+#define TABLA_I2C_ANALOG       1
+#define TABLA_I2C_DIGITAL_1    2
+#define TABLA_I2C_DIGITAL_2    3
+
+static struct i2c_device_id tabla_id_table[] = {
+	{"tabla top level", TABLA_I2C_TOP_LEVEL},
+	{"tabla analog", TABLA_I2C_TOP_LEVEL},
+	{"tabla digital1", TABLA_I2C_TOP_LEVEL},
+	{"tabla digital2", TABLA_I2C_TOP_LEVEL},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, tabla_id_table);
+
+static struct i2c_driver tabla_i2c_driver = {
+	.driver                 = {
+		.owner          =       THIS_MODULE,
+		.name           =       "tabla-i2c-core",
+	},
+	.id_table               =       tabla_id_table,
+	.probe                  =       wcd9xxx_i2c_probe,
+	.remove                 =       __devexit_p(wcd9xxx_i2c_remove),
+	.resume	= wcd9xxx_i2c_resume,
+	.suspend = wcd9xxx_i2c_suspend,
+};
+
+static int __init wcd9xxx_init(void)
+{
+	int ret1, ret2, ret3, ret4, ret5;
+
+	ret1 = slim_driver_register(&tabla_slim_driver);
+	if (ret1 != 0)
+		pr_err("Failed to register tabla SB driver: %d\n", ret1);
+
+	ret2 = slim_driver_register(&tabla2x_slim_driver);
+	if (ret2 != 0)
+		pr_err("Failed to register tabla2x SB driver: %d\n", ret2);
+
+	ret3 = i2c_add_driver(&tabla_i2c_driver);
+	if (ret3 != 0)
+		pr_err("failed to add the I2C driver\n");
+
+	ret4 = slim_driver_register(&sitar_slim_driver);
+	if (ret4 != 0)
+		pr_err("Failed to register sitar SB driver: %d\n", ret4);
+
+	ret5 = slim_driver_register(&sitar1p1_slim_driver);
+	if (ret5 != 0)
+		pr_err("Failed to register sitar SB driver: %d\n", ret5);
+
+	return (ret1 && ret2 && ret3 && ret4 && ret5) ? -1 : 0;
+}
+module_init(wcd9xxx_init);
+
+static void __exit wcd9xxx_exit(void)
+{
+}
+module_exit(wcd9xxx_exit);
+
+MODULE_DESCRIPTION("Codec core driver");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mfd/wcd9xxx-irq.c b/drivers/mfd/wcd9xxx-irq.c
new file mode 100644
index 0000000..a9bae85
--- /dev/null
+++ b/drivers/mfd/wcd9xxx-irq.c
@@ -0,0 +1,307 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/irq.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/wcd9xxx/core.h>
+#include <linux/mfd/wcd9xxx/wcd9xxx_registers.h>
+#include <linux/mfd/wcd9xxx/wcd9310_registers.h>
+#include <linux/interrupt.h>
+
+#define BYTE_BIT_MASK(nr)		(1UL << ((nr) % BITS_PER_BYTE))
+#define BIT_BYTE(nr)			((nr) / BITS_PER_BYTE)
+
+struct wcd9xxx_irq {
+	bool level;
+};
+
+static struct wcd9xxx_irq wcd9xxx_irqs[TABLA_NUM_IRQS] = {
+	[0] = { .level = 1},
+/* All other wcd9xxx interrupts are edge triggered */
+};
+
+static inline int irq_to_wcd9xxx_irq(struct wcd9xxx *wcd9xxx, int irq)
+{
+	return irq - wcd9xxx->irq_base;
+}
+
+static void wcd9xxx_irq_lock(struct irq_data *data)
+{
+	struct wcd9xxx *wcd9xxx = irq_data_get_irq_chip_data(data);
+	mutex_lock(&wcd9xxx->irq_lock);
+}
+
+static void wcd9xxx_irq_sync_unlock(struct irq_data *data)
+{
+	struct wcd9xxx *wcd9xxx = irq_data_get_irq_chip_data(data);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(wcd9xxx->irq_masks_cur); i++) {
+		/* If there's been a change in the mask write it back
+		 * to the hardware.
+		 */
+		if (wcd9xxx->irq_masks_cur[i] != wcd9xxx->irq_masks_cache[i]) {
+			wcd9xxx->irq_masks_cache[i] = wcd9xxx->irq_masks_cur[i];
+			wcd9xxx_reg_write(wcd9xxx, TABLA_A_INTR_MASK0+i,
+				wcd9xxx->irq_masks_cur[i]);
+		}
+	}
+
+	mutex_unlock(&wcd9xxx->irq_lock);
+}
+
+static void wcd9xxx_irq_enable(struct irq_data *data)
+{
+	struct wcd9xxx *wcd9xxx = irq_data_get_irq_chip_data(data);
+	int wcd9xxx_irq = irq_to_wcd9xxx_irq(wcd9xxx, data->irq);
+	wcd9xxx->irq_masks_cur[BIT_BYTE(wcd9xxx_irq)] &=
+		~(BYTE_BIT_MASK(wcd9xxx_irq));
+}
+
+static void wcd9xxx_irq_disable(struct irq_data *data)
+{
+	struct wcd9xxx *wcd9xxx = irq_data_get_irq_chip_data(data);
+	int wcd9xxx_irq = irq_to_wcd9xxx_irq(wcd9xxx, data->irq);
+	wcd9xxx->irq_masks_cur[BIT_BYTE(wcd9xxx_irq)]
+			|= BYTE_BIT_MASK(wcd9xxx_irq);
+}
+
+static struct irq_chip wcd9xxx_irq_chip = {
+	.name = "wcd9xxx",
+	.irq_bus_lock = wcd9xxx_irq_lock,
+	.irq_bus_sync_unlock = wcd9xxx_irq_sync_unlock,
+	.irq_disable = wcd9xxx_irq_disable,
+	.irq_enable = wcd9xxx_irq_enable,
+};
+
+enum wcd9xxx_pm_state wcd9xxx_pm_cmpxchg(struct wcd9xxx *wcd9xxx,
+		enum wcd9xxx_pm_state o,
+		enum wcd9xxx_pm_state n)
+{
+	enum wcd9xxx_pm_state old;
+	mutex_lock(&wcd9xxx->pm_lock);
+	old = wcd9xxx->pm_state;
+	if (old == o)
+		wcd9xxx->pm_state = n;
+	mutex_unlock(&wcd9xxx->pm_lock);
+	return old;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_pm_cmpxchg);
+
+bool wcd9xxx_lock_sleep(struct wcd9xxx *wcd9xxx)
+{
+	enum wcd9xxx_pm_state os;
+
+	/* wcd9xxx_{lock/unlock}_sleep will be called by wcd9xxx_irq_thread
+	 * and its subroutines only motly.
+	 * but btn0_lpress_fn is not wcd9xxx_irq_thread's subroutine and
+	 * it can race with wcd9xxx_irq_thread.
+	 * so need to embrace wlock_holders with mutex.
+	 */
+	mutex_lock(&wcd9xxx->pm_lock);
+	if (wcd9xxx->wlock_holders++ == 0) {
+		pr_debug("%s: holding wake lock\n", __func__);
+		wake_lock(&wcd9xxx->wlock);
+	}
+	mutex_unlock(&wcd9xxx->pm_lock);
+	if (!wait_event_timeout(wcd9xxx->pm_wq,
+			((os = wcd9xxx_pm_cmpxchg(wcd9xxx, WCD9XXX_PM_SLEEPABLE,
+						WCD9XXX_PM_AWAKE)) ==
+						    WCD9XXX_PM_SLEEPABLE ||
+			 (os == WCD9XXX_PM_AWAKE)),
+			5 * HZ)) {
+		pr_err("%s: system didn't resume within 5000ms, state %d, "
+		       "wlock %d\n", __func__, wcd9xxx->pm_state,
+		       wcd9xxx->wlock_holders);
+		WARN_ON(1);
+		wcd9xxx_unlock_sleep(wcd9xxx);
+		return false;
+	}
+	wake_up_all(&wcd9xxx->pm_wq);
+	return true;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_lock_sleep);
+
+void wcd9xxx_unlock_sleep(struct wcd9xxx *wcd9xxx)
+{
+	mutex_lock(&wcd9xxx->pm_lock);
+	if (--wcd9xxx->wlock_holders == 0) {
+		wcd9xxx->pm_state = WCD9XXX_PM_SLEEPABLE;
+		pr_debug("%s: releasing wake lock\n", __func__);
+		wake_unlock(&wcd9xxx->wlock);
+	}
+	mutex_unlock(&wcd9xxx->pm_lock);
+	wake_up_all(&wcd9xxx->pm_wq);
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_unlock_sleep);
+
+static void wcd9xxx_irq_dispatch(struct wcd9xxx *wcd9xxx, int irqbit)
+{
+	if ((irqbit <= TABLA_IRQ_MBHC_INSERTION) &&
+	    (irqbit >= TABLA_IRQ_MBHC_REMOVAL)) {
+		wcd9xxx_reg_write(wcd9xxx, TABLA_A_INTR_CLEAR0 +
+				  BIT_BYTE(irqbit), BYTE_BIT_MASK(irqbit));
+		if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C)
+			wcd9xxx_reg_write(wcd9xxx, TABLA_A_INTR_MODE, 0x02);
+		handle_nested_irq(wcd9xxx->irq_base + irqbit);
+	} else {
+		handle_nested_irq(wcd9xxx->irq_base + irqbit);
+		wcd9xxx_reg_write(wcd9xxx, TABLA_A_INTR_CLEAR0 +
+				  BIT_BYTE(irqbit), BYTE_BIT_MASK(irqbit));
+		if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C)
+			wcd9xxx_reg_write(wcd9xxx, TABLA_A_INTR_MODE, 0x02);
+	}
+}
+
+static irqreturn_t wcd9xxx_irq_thread(int irq, void *data)
+{
+	int ret;
+	struct wcd9xxx *wcd9xxx = data;
+	u8 status[WCD9XXX_NUM_IRQ_REGS];
+	int i;
+
+	if (unlikely(wcd9xxx_lock_sleep(wcd9xxx) == false)) {
+		dev_err(wcd9xxx->dev, "Failed to hold suspend\n");
+		return IRQ_NONE;
+	}
+	ret = wcd9xxx_bulk_read(wcd9xxx, TABLA_A_INTR_STATUS0,
+			       WCD9XXX_NUM_IRQ_REGS, status);
+	if (ret < 0) {
+		dev_err(wcd9xxx->dev, "Failed to read interrupt status: %d\n",
+			ret);
+		wcd9xxx_unlock_sleep(wcd9xxx);
+		return IRQ_NONE;
+	}
+	/* Apply masking */
+	for (i = 0; i < WCD9XXX_NUM_IRQ_REGS; i++)
+		status[i] &= ~wcd9xxx->irq_masks_cur[i];
+
+	/* Find out which interrupt was triggered and call that interrupt's
+	 * handler function
+	 */
+	if (status[BIT_BYTE(TABLA_IRQ_SLIMBUS)] &
+	    BYTE_BIT_MASK(TABLA_IRQ_SLIMBUS))
+		wcd9xxx_irq_dispatch(wcd9xxx, TABLA_IRQ_SLIMBUS);
+
+	/* Since codec has only one hardware irq line which is shared by
+	 * codec's different internal interrupts, so it's possible master irq
+	 * handler dispatches multiple nested irq handlers after breaking
+	 * order.  Dispatch MBHC interrupts order to follow MBHC state
+	 * machine's order */
+	for (i = TABLA_IRQ_MBHC_INSERTION; i >= TABLA_IRQ_MBHC_REMOVAL; i--) {
+		if (status[BIT_BYTE(i)] & BYTE_BIT_MASK(i))
+			wcd9xxx_irq_dispatch(wcd9xxx, i);
+	}
+	for (i = TABLA_IRQ_BG_PRECHARGE; i < TABLA_NUM_IRQS; i++) {
+		if (status[BIT_BYTE(i)] & BYTE_BIT_MASK(i))
+			wcd9xxx_irq_dispatch(wcd9xxx, i);
+	}
+	wcd9xxx_unlock_sleep(wcd9xxx);
+
+	return IRQ_HANDLED;
+}
+
+int wcd9xxx_irq_init(struct wcd9xxx *wcd9xxx)
+{
+	int ret;
+	unsigned int i, cur_irq;
+
+	mutex_init(&wcd9xxx->irq_lock);
+
+	if (!wcd9xxx->irq) {
+		dev_warn(wcd9xxx->dev,
+			 "No interrupt specified, no interrupts\n");
+		wcd9xxx->irq_base = 0;
+		return 0;
+	}
+
+	if (!wcd9xxx->irq_base) {
+		dev_err(wcd9xxx->dev,
+			"No interrupt base specified, no interrupts\n");
+		return 0;
+	}
+	/* Mask the individual interrupt sources */
+	for (i = 0, cur_irq = wcd9xxx->irq_base; i < TABLA_NUM_IRQS; i++,
+		cur_irq++) {
+
+		irq_set_chip_data(cur_irq, wcd9xxx);
+
+		if (wcd9xxx_irqs[i].level)
+			irq_set_chip_and_handler(cur_irq, &wcd9xxx_irq_chip,
+					 handle_level_irq);
+		else
+			irq_set_chip_and_handler(cur_irq, &wcd9xxx_irq_chip,
+					 handle_edge_irq);
+
+		irq_set_nested_thread(cur_irq, 1);
+
+		/* ARM needs us to explicitly flag the IRQ as valid
+		 * and will set them noprobe when we do so. */
+#ifdef CONFIG_ARM
+		set_irq_flags(cur_irq, IRQF_VALID);
+#else
+		set_irq_noprobe(cur_irq);
+#endif
+
+		wcd9xxx->irq_masks_cur[BIT_BYTE(i)] |= BYTE_BIT_MASK(i);
+		wcd9xxx->irq_masks_cache[BIT_BYTE(i)] |= BYTE_BIT_MASK(i);
+		wcd9xxx->irq_level[BIT_BYTE(i)] |= wcd9xxx_irqs[i].level <<
+			(i % BITS_PER_BYTE);
+	}
+	for (i = 0; i < WCD9XXX_NUM_IRQ_REGS; i++) {
+		/* Initialize interrupt mask and level registers */
+		wcd9xxx_reg_write(wcd9xxx, TABLA_A_INTR_LEVEL0 + i,
+			wcd9xxx->irq_level[i]);
+		wcd9xxx_reg_write(wcd9xxx, TABLA_A_INTR_MASK0 + i,
+			wcd9xxx->irq_masks_cur[i]);
+	}
+
+	ret = request_threaded_irq(wcd9xxx->irq, NULL, wcd9xxx_irq_thread,
+				   IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+				   "wcd9xxx", wcd9xxx);
+	if (ret != 0)
+		dev_err(wcd9xxx->dev, "Failed to request IRQ %d: %d\n",
+			wcd9xxx->irq, ret);
+	else {
+		ret = enable_irq_wake(wcd9xxx->irq);
+		if (ret == 0) {
+			ret = device_init_wakeup(wcd9xxx->dev, 1);
+			if (ret) {
+				dev_err(wcd9xxx->dev, "Failed to init device"
+					"wakeup : %d\n", ret);
+				disable_irq_wake(wcd9xxx->irq);
+			}
+		} else
+			dev_err(wcd9xxx->dev, "Failed to set wake interrupt on"
+				" IRQ %d: %d\n", wcd9xxx->irq, ret);
+		if (ret)
+			free_irq(wcd9xxx->irq, wcd9xxx);
+	}
+
+	if (ret)
+		mutex_destroy(&wcd9xxx->irq_lock);
+
+	return ret;
+}
+
+void wcd9xxx_irq_exit(struct wcd9xxx *wcd9xxx)
+{
+	if (wcd9xxx->irq) {
+		disable_irq_wake(wcd9xxx->irq);
+		free_irq(wcd9xxx->irq, wcd9xxx);
+		device_init_wakeup(wcd9xxx->dev, 0);
+	}
+	mutex_destroy(&wcd9xxx->irq_lock);
+}
diff --git a/drivers/mfd/wcd9xxx-slimslave.c b/drivers/mfd/wcd9xxx-slimslave.c
new file mode 100644
index 0000000..421145a
--- /dev/null
+++ b/drivers/mfd/wcd9xxx-slimslave.c
@@ -0,0 +1,583 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/mfd/wcd9xxx/wcd9xxx-slimslave.h>
+
+struct wcd9xxx_slim_sch_rx {
+	u32 sph;
+	u32 ch_num;
+	u16 ch_h;
+	u16 grph;
+};
+
+struct wcd9xxx_slim_sch_tx {
+	u32 sph;
+	u32 ch_num;
+	u16 ch_h;
+	u16 grph;
+};
+
+struct wcd9xxx_slim_sch {
+	struct wcd9xxx_slim_sch_rx rx[SLIM_MAX_RX_PORTS];
+	struct wcd9xxx_slim_sch_tx tx[SLIM_MAX_TX_PORTS];
+};
+
+static struct wcd9xxx_slim_sch sh_ch;
+
+static int wcd9xxx_alloc_slim_sh_ch_rx(struct wcd9xxx *wcd9xxx,
+					u8 wcd9xxx_pgd_la);
+static int wcd9xxx_alloc_slim_sh_ch_tx(struct wcd9xxx *wcd9xxx,
+					u8 wcd9xxx_pgd_la);
+static int wcd9xxx_dealloc_slim_sh_ch_rx(struct wcd9xxx *wcd9xxx);
+static int wcd9xxx_dealloc_slim_sh_ch_tx(struct wcd9xxx *wcd9xxx);
+
+int wcd9xxx_init_slimslave(struct wcd9xxx *wcd9xxx, u8 wcd9xxx_pgd_la)
+{
+	int ret = 0;
+
+	ret = wcd9xxx_alloc_slim_sh_ch_rx(wcd9xxx, wcd9xxx_pgd_la);
+	if (ret) {
+		pr_err("%s: Failed to alloc rx slimbus shared channels\n",
+								__func__);
+		goto rx_err;
+	}
+	ret = wcd9xxx_alloc_slim_sh_ch_tx(wcd9xxx, wcd9xxx_pgd_la);
+	if (ret) {
+		pr_err("%s: Failed to alloc tx slimbus shared channels\n",
+								__func__);
+		goto tx_err;
+	}
+	return 0;
+tx_err:
+	wcd9xxx_dealloc_slim_sh_ch_rx(wcd9xxx);
+rx_err:
+	return ret;
+}
+
+
+int wcd9xxx_deinit_slimslave(struct wcd9xxx *wcd9xxx)
+{
+	int ret = 0;
+	ret = wcd9xxx_dealloc_slim_sh_ch_rx(wcd9xxx);
+	if (ret < 0) {
+		pr_err("%s: fail to dealloc rx slim ports\n", __func__);
+		goto err;
+	}
+	ret = wcd9xxx_dealloc_slim_sh_ch_tx(wcd9xxx);
+	if (ret < 0) {
+		pr_err("%s: fail to dealloc tx slim ports\n", __func__);
+		goto err;
+	}
+err:
+	return ret;
+}
+
+int wcd9xxx_get_channel(struct wcd9xxx *wcd9xxx,
+		unsigned int *rx_ch,
+		unsigned int *tx_ch)
+{
+	int ch_idx = 0;
+	struct wcd9xxx_slim_sch_rx *rx = sh_ch.rx;
+	struct wcd9xxx_slim_sch_tx *tx = sh_ch.tx;
+
+	for (ch_idx = 0; ch_idx < SLIM_MAX_RX_PORTS; ch_idx++)
+		rx_ch[ch_idx] = rx[ch_idx].ch_num;
+	for (ch_idx = 0; ch_idx < SLIM_MAX_TX_PORTS; ch_idx++)
+		tx_ch[ch_idx] = tx[ch_idx].ch_num;
+	return 0;
+}
+
+static int wcd9xxx_alloc_slim_sh_ch_rx(struct wcd9xxx *wcd9xxx,
+			u8 wcd9xxx_pgd_la)
+{
+	int ret = 0;
+	u8 ch_idx ;
+	u16 slave_port_id = 0;
+	struct wcd9xxx_slim_sch_rx *rx = sh_ch.rx;
+
+	/*
+	 * DSP requires channel number to be between 128 and 255.
+	 */
+	pr_debug("%s: pgd_la[%d]\n", __func__, wcd9xxx_pgd_la);
+	for (ch_idx = 0; ch_idx < SLIM_MAX_RX_PORTS; ch_idx++) {
+		slave_port_id = (ch_idx + 1 +
+				SB_PGD_OFFSET_OF_RX_SLAVE_DEV_PORTS);
+		rx[ch_idx].ch_num = slave_port_id + BASE_CH_NUM;
+		ret = slim_get_slaveport(wcd9xxx_pgd_la, slave_port_id,
+					&rx[ch_idx].sph, SLIM_SINK);
+		if (ret < 0) {
+			pr_err("%s: slave port failure id[%d] ret[%d]\n",
+					__func__, slave_port_id, ret);
+			goto err;
+		}
+
+		ret = slim_query_ch(wcd9xxx->slim, rx[ch_idx].ch_num,
+							&rx[ch_idx].ch_h);
+		if (ret < 0) {
+			pr_err("%s: slim_query_ch failed ch-num[%d] ret[%d]\n",
+					__func__, rx[ch_idx].ch_num, ret);
+			goto err;
+		}
+	}
+err:
+	return ret;
+}
+
+static int wcd9xxx_alloc_slim_sh_ch_tx(struct wcd9xxx *wcd9xxx,
+			u8 wcd9xxx_pgd_la)
+{
+	int ret = 0;
+	u8 ch_idx ;
+	struct wcd9xxx_slim_sch_tx *tx = sh_ch.tx;
+	u16 slave_port_id = 0;
+
+	pr_debug("%s: pgd_la[%d]\n", __func__, wcd9xxx_pgd_la);
+	/* DSP requires channel number to be between 128 and 255. For RX port
+	 * use channel numbers from 138 to 144, for TX port
+	 * use channel numbers from 128 to 137
+	 */
+	for (ch_idx = 0; ch_idx < SLIM_MAX_TX_PORTS; ch_idx++) {
+		slave_port_id = ch_idx;
+		tx[ch_idx].ch_num = slave_port_id + BASE_CH_NUM;
+		ret = slim_get_slaveport(wcd9xxx_pgd_la, slave_port_id,
+					&tx[ch_idx].sph, SLIM_SRC);
+		if (ret < 0) {
+			pr_err("%s: slave port failure id[%d] ret[%d]\n",
+					__func__, slave_port_id, ret);
+			goto err;
+		}
+		ret = slim_query_ch(wcd9xxx->slim, tx[ch_idx].ch_num,
+							&tx[ch_idx].ch_h);
+		if (ret < 0) {
+			pr_err("%s: slim_query_ch failed ch-num[%d] ret[%d]\n",
+					__func__, tx[ch_idx].ch_num, ret);
+			goto err;
+		}
+	}
+err:
+	return ret;
+}
+
+static int wcd9xxx_dealloc_slim_sh_ch_rx(struct wcd9xxx *wcd9xxx)
+{
+	int idx = 0;
+	int ret = 0;
+	struct wcd9xxx_slim_sch_rx *rx = sh_ch.rx;
+	/* slim_dealloc_ch */
+	for (idx = 0; idx < SLIM_MAX_RX_PORTS; idx++) {
+		ret = slim_dealloc_ch(wcd9xxx->slim, rx[idx].ch_h);
+		if (ret < 0) {
+			pr_err("%s: slim_dealloc_ch fail ret[%d] ch_h[%d]\n",
+				__func__, ret, rx[idx].ch_h);
+		}
+	}
+	memset(sh_ch.rx, 0, sizeof(sh_ch.rx));
+	return ret;
+}
+
+static int wcd9xxx_dealloc_slim_sh_ch_tx(struct wcd9xxx *wcd9xxx)
+{
+	int idx = 0;
+	int ret = 0;
+	struct wcd9xxx_slim_sch_tx *tx = sh_ch.tx;
+	/* slim_dealloc_ch */
+	for (idx = 0; idx < SLIM_MAX_TX_PORTS; idx++) {
+		ret = slim_dealloc_ch(wcd9xxx->slim, tx[idx].ch_h);
+		if (ret < 0) {
+			pr_err("%s: slim_dealloc_ch fail ret[%d] ch_h[%d]\n",
+				__func__, ret, tx[idx].ch_h);
+		}
+	}
+	memset(sh_ch.tx, 0, sizeof(sh_ch.tx));
+	return ret;
+}
+
+/* Enable slimbus slave device for RX path */
+int wcd9xxx_cfg_slim_sch_rx(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int ch_cnt, unsigned int rate)
+{
+	u8 i = 0;
+	u16 grph;
+	u32 sph[SLIM_MAX_RX_PORTS] = {0};
+	u16 ch_h[SLIM_MAX_RX_PORTS] = {0};
+	u16 slave_port_id;
+	u8  payload_rx = 0, wm_payload = 0;
+	int ret, idx = 0;
+	unsigned short  multi_chan_cfg_reg_addr;
+	struct wcd9xxx_slim_sch_rx *rx = sh_ch.rx;
+	struct slim_ch prop;
+
+	/* Configure slave interface device */
+	pr_debug("%s: ch_cnt[%d] rate=%d\n", __func__, ch_cnt, rate);
+
+	for (i = 0; i < ch_cnt; i++) {
+		idx = (ch_num[i] - BASE_CH_NUM -
+			SB_PGD_OFFSET_OF_RX_SLAVE_DEV_PORTS - 1);
+		ch_h[i] = rx[idx].ch_h;
+		sph[i] = rx[idx].sph;
+		slave_port_id = idx + 1;
+		if ((slave_port_id > SB_PGD_MAX_NUMBER_OF_RX_SLAVE_DEV_PORTS) ||
+			(slave_port_id == 0)) {
+			pr_err("Slimbus: invalid slave port id: %d",
+							slave_port_id);
+			ret = -EINVAL;
+			goto err;
+		}
+		slave_port_id += SB_PGD_OFFSET_OF_RX_SLAVE_DEV_PORTS;
+		/* look for the valid port range and chose the
+		 * payload accordingly
+		 */
+		if ((slave_port_id >
+				SB_PGD_TX_PORT_MULTI_CHANNEL_1_END_PORT_ID) &&
+			(slave_port_id <=
+			 SB_PGD_RX_PORT_MULTI_CHANNEL_0_END_PORT_ID)) {
+				payload_rx = payload_rx  |
+				(1 <<
+				(slave_port_id -
+				SB_PGD_RX_PORT_MULTI_CHANNEL_0_START_PORT_ID));
+		} else {
+			ret = -EINVAL;
+			goto err;
+		}
+		multi_chan_cfg_reg_addr =
+				SB_PGD_RX_PORT_MULTI_CHANNEL_0(slave_port_id);
+		/* write to interface device */
+		ret = wcd9xxx_interface_reg_write(wcd9xxx,
+				multi_chan_cfg_reg_addr,
+				payload_rx);
+		if (ret < 0) {
+			pr_err("%s:Intf-dev fail reg[%d] payload[%d] ret[%d]\n",
+							__func__,
+							multi_chan_cfg_reg_addr,
+							payload_rx, ret);
+			goto err;
+		}
+		/* configure the slave port for water mark and enable*/
+		wm_payload = (SLAVE_PORT_WATER_MARK_VALUE <<
+				SLAVE_PORT_WATER_MARK_SHIFT) +
+				SLAVE_PORT_ENABLE;
+		ret = wcd9xxx_interface_reg_write(wcd9xxx,
+				SB_PGD_PORT_CFG_BYTE_ADDR(slave_port_id),
+				wm_payload);
+		if (ret < 0) {
+			pr_err("%s:watermark set failure for port[%d] ret[%d]",
+						__func__, slave_port_id, ret);
+		}
+	}
+
+	/* slim_define_ch api */
+	prop.prot = SLIM_AUTO_ISO;
+	prop.baser = SLIM_RATE_4000HZ;
+	prop.dataf = SLIM_CH_DATAF_NOT_DEFINED;
+	prop.auxf = SLIM_CH_AUXF_NOT_APPLICABLE;
+	prop.ratem = (rate/4000);
+	prop.sampleszbits = 16;
+
+	ret = slim_define_ch(wcd9xxx->slim, &prop, ch_h, ch_cnt,
+					true, &grph);
+	if (ret < 0) {
+		pr_err("%s: slim_define_ch failed ret[%d]\n",
+					__func__, ret);
+		goto err;
+	}
+	for (i = 0; i < ch_cnt; i++) {
+		ret = slim_connect_sink(wcd9xxx->slim, &sph[i],
+							1, ch_h[i]);
+		if (ret < 0) {
+			pr_err("%s: slim_connect_sink failed ret[%d]\n",
+						__func__, ret);
+			goto err_close_slim_sch;
+		}
+	}
+	/* slim_control_ch */
+	ret = slim_control_ch(wcd9xxx->slim, grph, SLIM_CH_ACTIVATE,
+					true);
+	if (ret < 0) {
+		pr_err("%s: slim_control_ch failed ret[%d]\n",
+				__func__, ret);
+		goto err_close_slim_sch;
+	}
+	for (i = 0; i < ch_cnt; i++) {
+		idx = (ch_num[i] - BASE_CH_NUM -
+				SB_PGD_OFFSET_OF_RX_SLAVE_DEV_PORTS - 1);
+		rx[idx].grph = grph;
+	}
+	return 0;
+
+err_close_slim_sch:
+	/*  release all acquired handles */
+	wcd9xxx_close_slim_sch_rx(wcd9xxx, ch_num, ch_cnt);
+err:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_cfg_slim_sch_rx);
+
+/* Enable slimbus slave device for RX path */
+int wcd9xxx_cfg_slim_sch_tx(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int ch_cnt, unsigned int rate)
+{
+	u8 i = 0;
+	u8  payload_tx_0 = 0, payload_tx_1 = 0, wm_payload = 0;
+	u16 grph;
+	u32 sph[SLIM_MAX_TX_PORTS] = {0};
+	u16 ch_h[SLIM_MAX_TX_PORTS] = {0};
+	u16 idx = 0, slave_port_id;
+	int ret = 0;
+	unsigned short  multi_chan_cfg_reg_addr;
+
+	struct wcd9xxx_slim_sch_tx *tx = sh_ch.tx;
+	struct slim_ch prop;
+
+	pr_debug("%s: ch_cnt[%d] rate[%d]\n", __func__, ch_cnt, rate);
+	for (i = 0; i < ch_cnt; i++) {
+		idx = (ch_num[i] - BASE_CH_NUM);
+		ch_h[i] = tx[idx].ch_h;
+		sph[i] = tx[idx].sph;
+		slave_port_id = idx ;
+		if (slave_port_id > SB_PGD_MAX_NUMBER_OF_TX_SLAVE_DEV_PORTS) {
+			pr_err("SLIMbus: invalid slave port id: %d",
+							slave_port_id);
+			ret = -EINVAL;
+			goto err;
+		}
+		/* look for the valid port range and chose the
+		 *  payload accordingly
+		 */
+		if (slave_port_id <=
+			SB_PGD_TX_PORT_MULTI_CHANNEL_0_END_PORT_ID) {
+			payload_tx_0 = payload_tx_0 | (1 << slave_port_id);
+		} else if (slave_port_id <=
+				SB_PGD_TX_PORT_MULTI_CHANNEL_1_END_PORT_ID) {
+				payload_tx_1 = payload_tx_1 |
+				(1 <<
+				(slave_port_id -
+				SB_PGD_TX_PORT_MULTI_CHANNEL_1_START_PORT_ID));
+		} else {
+			ret = -EINVAL;
+			goto err;
+		}
+		multi_chan_cfg_reg_addr =
+				SB_PGD_TX_PORT_MULTI_CHANNEL_0(slave_port_id);
+		/* write to interface device */
+		ret = wcd9xxx_interface_reg_write(wcd9xxx,
+				multi_chan_cfg_reg_addr,
+				payload_tx_0);
+		if (ret < 0) {
+			pr_err("%s:Intf-dev fail reg[%d] payload[%d] ret[%d]\n",
+								__func__,
+						multi_chan_cfg_reg_addr,
+						payload_tx_0, ret);
+			goto err;
+		}
+		multi_chan_cfg_reg_addr =
+				SB_PGD_TX_PORT_MULTI_CHANNEL_1(slave_port_id);
+		/* ports 8,9 */
+		ret = wcd9xxx_interface_reg_write(wcd9xxx,
+				multi_chan_cfg_reg_addr,
+				payload_tx_1);
+		if (ret < 0) {
+			pr_err("%s:Intf-dev fail reg[%d] payload[%d] ret[%d]\n",
+								__func__,
+						multi_chan_cfg_reg_addr,
+						payload_tx_1, ret);
+			goto err;
+		}
+		/* configure the slave port for water mark and enable*/
+		wm_payload = (SLAVE_PORT_WATER_MARK_VALUE <<
+				SLAVE_PORT_WATER_MARK_SHIFT) +
+				SLAVE_PORT_ENABLE;
+		ret = wcd9xxx_interface_reg_write(wcd9xxx,
+				SB_PGD_PORT_CFG_BYTE_ADDR(slave_port_id),
+				wm_payload);
+		if (ret < 0) {
+			pr_err("%s:watermark set failure for port[%d] ret[%d]",
+						__func__,
+						slave_port_id, ret);
+		}
+	}
+
+	/* slim_define_ch api */
+	prop.prot = SLIM_AUTO_ISO;
+	prop.baser = SLIM_RATE_4000HZ;
+	prop.dataf = SLIM_CH_DATAF_NOT_DEFINED;
+	prop.auxf = SLIM_CH_AUXF_NOT_APPLICABLE;
+	prop.ratem = (rate/4000);
+	prop.sampleszbits = 16;
+	ret = slim_define_ch(wcd9xxx->slim, &prop, ch_h, ch_cnt,
+					true, &grph);
+	if (ret < 0) {
+		pr_err("%s: slim_define_ch failed ret[%d]\n",
+					__func__, ret);
+		goto err;
+	}
+	for (i = 0; i < ch_cnt; i++) {
+		ret = slim_connect_src(wcd9xxx->slim, sph[i],
+							ch_h[i]);
+		if (ret < 0) {
+			pr_err("%s: slim_connect_src failed ret[%d]\n",
+						__func__, ret);
+			goto err;
+		}
+	}
+	/* slim_control_ch */
+	ret = slim_control_ch(wcd9xxx->slim, grph, SLIM_CH_ACTIVATE,
+					true);
+	if (ret < 0) {
+		pr_err("%s: slim_control_ch failed ret[%d]\n",
+				__func__, ret);
+		goto err;
+	}
+	for (i = 0; i < ch_cnt; i++) {
+		idx = (ch_num[i] - BASE_CH_NUM);
+		tx[idx].grph = grph;
+	}
+	return 0;
+err:
+	/* release all acquired handles */
+	wcd9xxx_close_slim_sch_tx(wcd9xxx, ch_num, ch_cnt);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_cfg_slim_sch_tx);
+
+int wcd9xxx_close_slim_sch_rx(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int ch_cnt)
+{
+	u16 grph = 0;
+	int i = 0 , idx = 0;
+	int ret = 0;
+	struct wcd9xxx_slim_sch_rx *rx = sh_ch.rx;
+
+	pr_debug("%s: ch_cnt[%d]\n", __func__, ch_cnt);
+	for (i = 0; i < ch_cnt; i++) {
+		idx = (ch_num[i] - BASE_CH_NUM -
+			SB_PGD_OFFSET_OF_RX_SLAVE_DEV_PORTS - 1);
+		if (idx < 0) {
+			pr_err("%s: Error:-Invalid index found = %d\n",
+				__func__, idx);
+			ret = -EINVAL;
+			goto err;
+		}
+		grph = rx[idx].grph;
+	}
+
+	/* slim_control_ch (REMOVE) */
+	ret = slim_control_ch(wcd9xxx->slim, grph, SLIM_CH_REMOVE, true);
+	if (ret < 0) {
+		pr_err("%s: slim_control_ch failed ret[%d]\n",
+				__func__, ret);
+		goto err;
+	}
+	for (i = 0; i < ch_cnt; i++) {
+		idx = (ch_num[i] - BASE_CH_NUM -
+				SB_PGD_OFFSET_OF_RX_SLAVE_DEV_PORTS - 1);
+		rx[idx].grph = 0;
+	}
+err:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_close_slim_sch_rx);
+
+int wcd9xxx_close_slim_sch_tx(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int ch_cnt)
+{
+	u16 grph = 0;
+	int ret = 0;
+	int i = 0 , idx = 0;
+	struct wcd9xxx_slim_sch_tx *tx = sh_ch.tx;
+
+	pr_debug("%s: ch_cnt[%d]\n", __func__, ch_cnt);
+	for (i = 0; i < ch_cnt; i++) {
+		idx = (ch_num[i] - BASE_CH_NUM);
+		if (idx < 0) {
+			pr_err("%s: Error:- Invalid index found = %d\n",
+				__func__, idx);
+			ret = -EINVAL;
+			goto err;
+		}
+		grph = tx[idx].grph;
+	}
+	/* slim_control_ch (REMOVE) */
+	ret = slim_control_ch(wcd9xxx->slim, grph, SLIM_CH_REMOVE, true);
+	if (ret < 0) {
+		pr_err("%s: slim_control_ch failed ret[%d]\n",
+				__func__, ret);
+		goto err;
+	}
+	for (i = 0; i < ch_cnt; i++) {
+		idx = (ch_num[i] - BASE_CH_NUM);
+		tx[idx].grph = 0;
+	}
+err:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_close_slim_sch_tx);
+
+int wcd9xxx_get_slave_port(unsigned int ch_num)
+{
+	int ret = 0;
+
+	pr_debug("%s: ch_num[%d]\n", __func__, ch_num);
+	ret = (ch_num - BASE_CH_NUM);
+	if (ret < 0) {
+		pr_err("%s: Error:- Invalid slave port found = %d\n",
+			__func__, ret);
+		return -EINVAL;
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_get_slave_port);
+
+int wcd9xxx_disconnect_port(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int ch_cnt, unsigned int rx_tx)
+{
+	u32 sph[SLIM_MAX_TX_PORTS] = {0};
+	int i = 0 , idx = 0;
+	int ret = 0;
+	struct wcd9xxx_slim_sch_rx *rx = sh_ch.rx;
+	struct wcd9xxx_slim_sch_tx *tx = sh_ch.tx;
+
+	pr_debug("%s: ch_cnt[%d], rx_tx flag = %d\n", __func__, ch_cnt, rx_tx);
+	for (i = 0; i < ch_cnt; i++) {
+		/* rx_tx will be 1 for rx, 0 for tx */
+		if (rx_tx) {
+			idx = (ch_num[i] - BASE_CH_NUM -
+				SB_PGD_OFFSET_OF_RX_SLAVE_DEV_PORTS - 1);
+			if (idx < 0) {
+				pr_err("%s: Invalid index found for RX = %d\n",
+					__func__, idx);
+				ret = -EINVAL;
+				goto err;
+			}
+			sph[i] = rx[idx].sph;
+		} else {
+			idx = (ch_num[i] - BASE_CH_NUM);
+			if (idx < 0) {
+				pr_err("%s:Invalid index found for TX = %d\n",
+					__func__, idx);
+				ret = -EINVAL;
+				goto err;
+			}
+			sph[i] = tx[idx].sph;
+		}
+	}
+
+	/* slim_disconnect_port */
+	ret = slim_disconnect_ports(wcd9xxx->slim, sph, ch_cnt);
+	if (ret < 0) {
+		pr_err("%s: slim_disconnect_ports failed ret[%d]\n",
+			__func__, ret);
+	}
+err:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_disconnect_port);
diff --git a/include/linux/mfd/pm8xxx/batt-alarm.h b/include/linux/mfd/pm8xxx/batt-alarm.h
new file mode 100644
index 0000000..989e44d
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/batt-alarm.h
@@ -0,0 +1,200 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+ * Qualcomm PMIC PM8xxx Battery Alarm driver
+ *
+ */
+#ifndef __MFD_PM8XXX_BATT_ALARM_H__
+#define __MFD_PM8XXX_BATT_ALARM_H__
+
+#include <linux/bitops.h>
+#include <linux/errno.h>
+
+#define PM8XXX_BATT_ALARM_DEV_NAME	"pm8xxx-batt-alarm"
+
+/**
+ * enum pm8xxx_batt_alarm_core_data - PMIC core specific core passed into the
+ *	batter alarm driver as platform data
+ * @irq_name:
+ * @reg_addr_batt_alarm_threshold:	PMIC threshold register address
+ * @reg_addr_batt_alarm_ctrl1:		PMIC control 1 register address
+ * @reg_addr_batt_alarm_ctrl2:		PMIC control 2 register address
+ * @reg_addr_batt_alarm_pwm_ctrl:	PMIC PWM control register address
+ */
+struct pm8xxx_batt_alarm_core_data {
+	char	*irq_name;
+	u16	reg_addr_threshold;
+	u16	reg_addr_ctrl1;
+	u16	reg_addr_ctrl2;
+	u16	reg_addr_pwm_ctrl;
+};
+
+/**
+ * enum pm8xxx_batt_alarm_comparator - battery alarm comparator ID values
+ */
+enum pm8xxx_batt_alarm_comparator {
+	PM8XXX_BATT_ALARM_LOWER_COMPARATOR,
+	PM8XXX_BATT_ALARM_UPPER_COMPARATOR,
+};
+
+/**
+ * enum pm8xxx_batt_alarm_hold_time - hold time required for out of range
+ *	battery voltage needed to trigger a status change.  Enum names denote
+ *	hold time in milliseconds.
+ */
+enum pm8xxx_batt_alarm_hold_time {
+	PM8XXX_BATT_ALARM_HOLD_TIME_0p125_MS = 0,
+	PM8XXX_BATT_ALARM_HOLD_TIME_0p25_MS,
+	PM8XXX_BATT_ALARM_HOLD_TIME_0p5_MS,
+	PM8XXX_BATT_ALARM_HOLD_TIME_1_MS,
+	PM8XXX_BATT_ALARM_HOLD_TIME_2_MS,
+	PM8XXX_BATT_ALARM_HOLD_TIME_4_MS,
+	PM8XXX_BATT_ALARM_HOLD_TIME_8_MS,
+	PM8XXX_BATT_ALARM_HOLD_TIME_16_MS,
+};
+
+/*
+ * Bits that are set in the return value of pm8xxx_batt_alarm_status_read
+ * to indicate crossing of the upper or lower threshold.
+ */
+#define PM8XXX_BATT_ALARM_STATUS_BELOW_LOWER	BIT(0)
+#define PM8XXX_BATT_ALARM_STATUS_ABOVE_UPPER	BIT(1)
+
+#if defined(CONFIG_MFD_PM8XXX_BATT_ALARM) \
+	|| defined(CONFIG_MFD_PM8XXX_BATT_ALARM_MODULE)
+
+/**
+ * pm8xxx_batt_alarm_enable - enable one of the battery voltage threshold
+ *			      comparators
+ * @comparator:	selects which comparator to enable
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_enable(enum pm8xxx_batt_alarm_comparator comparator);
+
+/**
+ * pm8xxx_batt_alarm_disable - disable one of the battery voltage threshold
+ *			       comparators
+ * @comparator:	selects which comparator to disable
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_disable(enum pm8xxx_batt_alarm_comparator comparator);
+
+
+/**
+ * pm8xxx_batt_alarm_threshold_set - set the lower and upper alarm thresholds
+ * @comparator:		selects which comparator to set the threshold of
+ * @threshold_mV:	battery voltage threshold in millivolts
+ *			set points = 2500-5675 mV in 25 mV steps
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_threshold_set(
+	enum pm8xxx_batt_alarm_comparator comparator, int threshold_mV);
+
+/**
+ * pm8xxx_batt_alarm_status_read - get status of both threshold comparators
+ *
+ * RETURNS:	< 0	   = error
+ *		  0	   = battery voltage ok
+ *		BIT(0) set = battery voltage below lower threshold
+ *		BIT(1) set = battery voltage above upper threshold
+ */
+int pm8xxx_batt_alarm_status_read(void);
+
+/**
+ * pm8xxx_batt_alarm_register_notifier - register a notifier to run when a
+ *	battery voltage change interrupt fires
+ * @nb:	notifier block containing callback function to register
+ *
+ * nb->notifier_call must point to a function of this form -
+ * int (*notifier_call)(struct notifier_block *nb, unsigned long status,
+ *			void *unused);
+ * "status" will receive the battery alarm status; "unused" will be NULL.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_register_notifier(struct notifier_block *nb);
+
+/**
+ * pm8xxx_batt_alarm_unregister_notifier - unregister a notifier that is run
+ *	when a battery voltage change interrupt fires
+ * @nb:	notifier block containing callback function to unregister
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_unregister_notifier(struct notifier_block *nb);
+
+/**
+ * pm8xxx_batt_alarm_hold_time_set - set hold time of interrupt output *
+ * @hold_time:	amount of time that battery voltage must remain outside of the
+ *		threshold range before the battery alarm interrupt triggers
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_hold_time_set(enum pm8xxx_batt_alarm_hold_time hold_time);
+
+/**
+ * pm8xxx_batt_alarm_pwm_rate_set - set battery alarm update rate *
+ * @use_pwm:		1 = use PWM update rate, 0 = comparators always active
+ * @clock_scaler:	PWM clock scaler = 2 to 9
+ * @clock_divider:	PWM clock divider = 2 to 8
+ *
+ * This function sets the rate at which the battery alarm module enables
+ * the threshold comparators.  The rate is determined by the following equation:
+ *
+ * f_update = (1024 Hz) / (clock_divider * (2 ^ clock_scaler))
+ *
+ * Thus, the update rate can range from 0.25 Hz to 128 Hz.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_batt_alarm_pwm_rate_set(int use_pwm, int clock_scaler,
+				   int clock_divider);
+#else
+
+static inline int
+pm8xxx_batt_alarm_enable(enum pm8xxx_batt_alarm_comparator comparator)
+{ return -ENODEV; }
+
+static inline int
+pm8xxx_batt_alarm_disable(enum pm8xxx_batt_alarm_comparator comparator)
+{ return -ENODEV; }
+
+static inline int
+pm8xxx_batt_alarm_threshold_set(enum pm8xxx_batt_alarm_comparator comparator,
+				int threshold_mV)
+{ return -ENODEV; }
+
+static inline int pm8xxx_batt_alarm_status_read(void)
+{ return -ENODEV; }
+
+static inline int pm8xxx_batt_alarm_register_notifier(struct notifier_block *nb)
+{ return -ENODEV; }
+
+static inline int
+pm8xxx_batt_alarm_unregister_notifier(struct notifier_block *nb)
+{ return -ENODEV; }
+
+static inline int
+pm8xxx_batt_alarm_hold_time_set(enum pm8xxx_batt_alarm_hold_time hold_time)
+{ return -ENODEV; }
+
+static inline int
+pm8xxx_batt_alarm_pwm_rate_set(int use_pwm, int clock_scaler, int clock_divider)
+{ return -ENODEV; }
+
+#endif
+
+
+#endif /* __MFD_PM8XXX_BATT_ALARM_H__ */
diff --git a/include/linux/mfd/pm8xxx/ccadc.h b/include/linux/mfd/pm8xxx/ccadc.h
new file mode 100644
index 0000000..7e6074f
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/ccadc.h
@@ -0,0 +1,83 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PMIC8XXX_CCADC_H__
+#define __PMIC8XXX_CCADC_H__
+
+#include <linux/mfd/pm8xxx/core.h>
+
+#define PM8XXX_CCADC_DEV_NAME "pm8xxx-ccadc"
+
+/**
+ * struct pm8xxx_ccadc_platform_data -
+ * @r_sense:		sense resistor value in (mOhms)
+ * @calib_delay_ms:	how often should the adc calculate gain and offset
+ */
+struct pm8xxx_ccadc_platform_data {
+	int		r_sense;
+	unsigned int	calib_delay_ms;
+};
+
+#define CCADC_READING_RESOLUTION_N	542535
+#define CCADC_READING_RESOLUTION_D	100000
+
+static inline s64 pm8xxx_ccadc_reading_to_microvolt(int revision, s64 cc)
+{
+	return div_s64(cc * CCADC_READING_RESOLUTION_N,
+					CCADC_READING_RESOLUTION_D);
+}
+
+#if defined(CONFIG_PM8XXX_CCADC) || defined(CONFIG_PM8XXX_CCADC_MODULE)
+/**
+ * pm8xxx_cc_adjust_for_gain - the function to adjust the voltage read from
+ *			ccadc for gain compensation
+ * @v:	the voltage which needs to be gain compensated in microVolts
+ *
+ *
+ * RETURNS: gain compensated voltage
+ */
+s64 pm8xxx_cc_adjust_for_gain(s64 uv);
+
+/**
+ * pm8xxx_calib_ccadc - calibration for ccadc. This will calculate gain
+ *			and offset and reprogram them in the appropriate
+ *			registers
+ */
+void pm8xxx_calib_ccadc(void);
+
+/**
+ * pm8xxx_ccadc_get_battery_current - return the battery current based on vsense
+ *				resitor in microamperes
+ * @result:	The pointer where the voltage will be updated. A -ve
+ *		result means that the current is flowing in
+ *		the battery - during battery charging
+ *
+ * RETURNS:	Error code if there was a problem reading vsense, Zero otherwise
+ *		The result won't be updated in case of an error.
+ *
+ */
+int pm8xxx_ccadc_get_battery_current(int *bat_current);
+#else
+static inline s64 pm8xxx_cc_adjust_for_gain(s64 uv)
+{
+	return -ENXIO;
+}
+static inline void pm8xxx_calib_ccadc(void)
+{
+}
+static inline int pm8xxx_ccadc_get_battery_current(int *bat_current)
+{
+	return -ENXIO;
+}
+#endif
+
+#endif /* __PMIC8XXX_CCADC_H__ */
diff --git a/include/linux/mfd/pm8xxx/core.h b/include/linux/mfd/pm8xxx/core.h
index bd2f4f6..6e754b82 100644
--- a/include/linux/mfd/pm8xxx/core.h
+++ b/include/linux/mfd/pm8xxx/core.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -20,15 +20,75 @@
 
 #include <linux/mfd/core.h>
 
+enum pm8xxx_version {
+	PM8XXX_VERSION_8058,
+	PM8XXX_VERSION_8901,
+	PM8XXX_VERSION_8921,
+	PM8XXX_VERSION_8821,
+	PM8XXX_VERSION_8018,
+	PM8XXX_VERSION_8922,
+	PM8XXX_VERSION_8038,
+	PM8XXX_VERSION_8917,
+};
+
+/* PMIC version specific silicon revisions */
+#define PM8XXX_REVISION_8058_TEST	0
+#define PM8XXX_REVISION_8058_1p0	1
+#define PM8XXX_REVISION_8058_2p0	2
+#define PM8XXX_REVISION_8058_2p1	3
+
+#define PM8XXX_REVISION_8901_TEST	0
+#define PM8XXX_REVISION_8901_1p0	1
+#define PM8XXX_REVISION_8901_1p1	2
+#define PM8XXX_REVISION_8901_2p0	3
+#define PM8XXX_REVISION_8901_2p1	4
+#define PM8XXX_REVISION_8901_2p2	5
+#define PM8XXX_REVISION_8901_2p3	6
+
+#define PM8XXX_REVISION_8921_TEST	0
+#define PM8XXX_REVISION_8921_1p0	1
+#define PM8XXX_REVISION_8921_1p1	2
+#define PM8XXX_REVISION_8921_2p0	3
+#define PM8XXX_REVISION_8921_3p0	4
+#define PM8XXX_REVISION_8921_3p1	5
+
+#define PM8XXX_REVISION_8821_TEST	0
+#define PM8XXX_REVISION_8821_1p0	1
+#define PM8XXX_REVISION_8821_2p0	2
+#define PM8XXX_REVISION_8821_2p1	3
+
+#define PM8XXX_REVISION_8018_TEST	0
+#define PM8XXX_REVISION_8018_1p0	1
+#define PM8XXX_REVISION_8018_2p0	2
+#define PM8XXX_REVISION_8018_2p1	3
+
+#define PM8XXX_REVISION_8922_TEST	0
+#define PM8XXX_REVISION_8922_1p0	1
+#define PM8XXX_REVISION_8922_1p1	2
+#define PM8XXX_REVISION_8922_2p0	3
+
+#define PM8XXX_REVISION_8038_TEST	0
+#define PM8XXX_REVISION_8038_1p0	1
+#define PM8XXX_REVISION_8038_2p0	2
+#define PM8XXX_REVISION_8038_2p1	3
+
+#define PM8XXX_REVISION_8917_TEST	0
+#define PM8XXX_REVISION_8917_1p0	1
+
 struct pm8xxx_drvdata {
-	int	(*pmic_readb) (const struct device *dev, u16 addr, u8 *val);
-	int	(*pmic_writeb) (const struct device *dev, u16 addr, u8 val);
-	int	(*pmic_read_buf) (const struct device *dev, u16 addr, u8 *buf,
-									int n);
-	int	(*pmic_write_buf) (const struct device *dev, u16 addr, u8 *buf,
-									int n);
-	int	(*pmic_read_irq_stat) (const struct device *dev, int irq);
-	void	*pm_chip_data;
+	int			(*pmic_readb) (const struct device *dev,
+						u16 addr, u8 *val);
+	int			(*pmic_writeb) (const struct device *dev,
+						u16 addr, u8 val);
+	int			(*pmic_read_buf) (const struct device *dev,
+						u16 addr, u8 *buf, int n);
+	int			(*pmic_write_buf) (const struct device *dev,
+						u16 addr, u8 *buf, int n);
+	int			(*pmic_read_irq_stat) (const struct device *dev,
+						int irq);
+	enum pm8xxx_version	(*pmic_get_version) (const struct device *dev);
+	int			(*pmic_get_revision) (const struct device *dev);
+	void			*pm_chip_data;
 };
 
 static inline int pm8xxx_readb(const struct device *dev, u16 addr, u8 *val)
@@ -78,4 +138,22 @@ static inline int pm8xxx_read_irq_stat(const struct device *dev, int irq)
 	return dd->pmic_read_irq_stat(dev, irq);
 }
 
+static inline enum pm8xxx_version pm8xxx_get_version(const struct device *dev)
+{
+	struct pm8xxx_drvdata *dd = dev_get_drvdata(dev);
+
+	if (!dd)
+		return -EINVAL;
+	return dd->pmic_get_version(dev);
+}
+
+static inline int pm8xxx_get_revision(const struct device *dev)
+{
+	struct pm8xxx_drvdata *dd = dev_get_drvdata(dev);
+
+	if (!dd)
+		return -EINVAL;
+	return dd->pmic_get_revision(dev);
+}
+
 #endif
diff --git a/include/linux/mfd/pm8xxx/gpio.h b/include/linux/mfd/pm8xxx/gpio.h
new file mode 100644
index 0000000..333d13f
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/gpio.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Qualcomm PMIC8XXX gpio driver header file
+ *
+ */
+
+#ifndef __PM8XXX_GPIO_H
+#define __PM8XXX_GPIO_H
+
+#include <linux/errno.h>
+
+#define PM8XXX_GPIO_DEV_NAME	"pm8xxx-gpio"
+
+struct pm8xxx_gpio_core_data {
+	int	ngpios;
+};
+
+struct pm8xxx_gpio_platform_data {
+	struct pm8xxx_gpio_core_data	gpio_cdata;
+	int				gpio_base;
+};
+
+/* GPIO parameters */
+/* direction */
+#define	PM_GPIO_DIR_OUT			0x01
+#define	PM_GPIO_DIR_IN			0x02
+#define	PM_GPIO_DIR_BOTH		(PM_GPIO_DIR_OUT | PM_GPIO_DIR_IN)
+
+/* output_buffer */
+#define	PM_GPIO_OUT_BUF_OPEN_DRAIN	1
+#define	PM_GPIO_OUT_BUF_CMOS		0
+
+/* pull */
+#define	PM_GPIO_PULL_UP_30		0
+#define	PM_GPIO_PULL_UP_1P5		1
+#define	PM_GPIO_PULL_UP_31P5		2
+#define	PM_GPIO_PULL_UP_1P5_30		3
+#define	PM_GPIO_PULL_DN			4
+#define	PM_GPIO_PULL_NO			5
+
+/* vin_sel: Voltage Input Select */
+#define	PM_GPIO_VIN_VPH			0 /* 3v ~ 4.4v */
+#define	PM_GPIO_VIN_BB			1 /* ~3.3v */
+#define	PM_GPIO_VIN_S4			2 /* 1.8v */
+#define	PM_GPIO_VIN_L15			3
+#define	PM_GPIO_VIN_L4			4
+#define	PM_GPIO_VIN_L3			5
+#define	PM_GPIO_VIN_L17			6
+
+/* vin_sel: Voltage Input select on PM8058 */
+#define PM8058_GPIO_VIN_VPH		0
+#define PM8058_GPIO_VIN_BB		1
+#define PM8058_GPIO_VIN_S3		2
+#define PM8058_GPIO_VIN_L3		3
+#define PM8058_GPIO_VIN_L7		4
+#define PM8058_GPIO_VIN_L6		5
+#define PM8058_GPIO_VIN_L5		6
+#define PM8058_GPIO_VIN_L2		7
+
+/* vin_sel: Voltage Input Select on PM8038*/
+#define PM8038_GPIO_VIN_VPH		0
+#define PM8038_GPIO_VIN_BB		1
+#define PM8038_GPIO_VIN_L11		2
+#define PM8038_GPIO_VIN_L15		3
+#define PM8038_GPIO_VIN_L4		4
+#define PM8038_GPIO_VIN_L3		5
+#define PM8038_GPIO_VIN_L17		6
+
+/* vin_sel: Voltage Input Select on PM8018*/
+#define PM8018_GPIO_VIN_L4		0
+#define PM8018_GPIO_VIN_L14		1
+#define PM8018_GPIO_VIN_S3		2
+#define PM8018_GPIO_VIN_L6		3
+#define PM8018_GPIO_VIN_L2		4
+#define PM8018_GPIO_VIN_L5		5
+#define PM8018_GPIO_VIN_L8		6
+#define PM8018_GPIO_VIN_VPH		7
+
+/* out_strength */
+#define	PM_GPIO_STRENGTH_NO		0
+#define	PM_GPIO_STRENGTH_HIGH		1
+#define	PM_GPIO_STRENGTH_MED		2
+#define	PM_GPIO_STRENGTH_LOW		3
+
+/* function */
+#define	PM_GPIO_FUNC_NORMAL		0
+#define	PM_GPIO_FUNC_PAIRED		1
+#define	PM_GPIO_FUNC_1			2
+#define	PM_GPIO_FUNC_2			3
+#define	PM_GPIO_DTEST1			4
+#define	PM_GPIO_DTEST2			5
+#define	PM_GPIO_DTEST3			6
+#define	PM_GPIO_DTEST4			7
+
+/**
+ * struct pm_gpio - structure to specify gpio configurtion values
+ * @direction:		indicates whether the gpio should be input, output, or
+ *			both. Should be of the type PM_GPIO_DIR_*
+ * @output_buffer:	indicates gpio should be configured as CMOS or open
+ *			drain. Should be of the type PM_GPIO_OUT_BUF_*
+ * @output_value:	The gpio output value of the gpio line - 0 or 1
+ * @pull:		Indicates whether a pull up or pull down should be
+ *			applied. If a pullup is required the current strength
+ *			needs to be specified. Current values of 30uA, 1.5uA,
+ *			31.5uA, 1.5uA with 30uA boost are supported. This value
+ *			should be one of the PM_GPIO_PULL_*
+ * @vin_sel:		specifies the voltage level when the output is set to 1.
+ *			For an input gpio specifies the voltage level at which
+ *			the input is interpreted as a logical 1.
+ * @out_strength:	the amount of current supplied for an output gpio,
+ *			should be of the type PM_GPIO_STRENGTH_*
+ * @function:		choose alternate function for the gpio. Certain gpios
+ *			can be paired (shorted) with each other. Some gpio pin
+ *			can act as alternate functions. This parameter should
+ *			be of type PM_GPIO_FUNC_*
+ * @inv_int_pol:	Invert polarity before feeding the line to the interrupt
+ *			module in pmic. This feature will almost be never used
+ *			since the pm8xxx interrupt block can detect both edges
+ *			and both levels.
+ * @disable_pin:	Disable the gpio by configuring it as high impedance.
+ */
+struct pm_gpio {
+	int		direction;
+	int		output_buffer;
+	int		output_value;
+	int		pull;
+	int		vin_sel;
+	int		out_strength;
+	int		function;
+	int		inv_int_pol;
+	int		disable_pin;
+};
+
+#if defined(CONFIG_GPIO_PM8XXX) || defined(CONFIG_GPIO_PM8XXX_MODULE)
+/**
+ * pm8xxx_gpio_config - configure a gpio controlled by a pm8xxx chip
+ * @gpio: gpio number to configure
+ * @param: configuration values
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_gpio_config(int gpio, struct pm_gpio *param);
+#else
+static inline int pm8xxx_gpio_config(int gpio, struct pm_gpio *param)
+{
+	return -ENXIO;
+}
+#endif
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/irq.h b/include/linux/mfd/pm8xxx/irq.h
index 4b21769..9ae6fd4 100644
--- a/include/linux/mfd/pm8xxx/irq.h
+++ b/include/linux/mfd/pm8xxx/irq.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -24,6 +24,7 @@
 struct pm8xxx_irq_core_data {
 	u32		rev;
 	int		nirqs;
+	unsigned int	base_addr;
 };
 
 struct pm8xxx_irq_platform_data {
@@ -31,27 +32,27 @@ struct pm8xxx_irq_platform_data {
 	struct pm8xxx_irq_core_data	irq_cdata;
 	int				devirq;
 	int				irq_trigger_flag;
+	int				dev_id;
 };
 
 struct pm_irq_chip;
 
 #ifdef CONFIG_MFD_PM8XXX_IRQ
 int pm8xxx_get_irq_stat(struct pm_irq_chip *chip, int irq);
-struct pm_irq_chip * __devinit pm8xxx_irq_init(struct device *dev,
+struct pm_irq_chip *pm8xxx_irq_init(struct device *dev,
 				const struct pm8xxx_irq_platform_data *pdata);
-int __devexit pm8xxx_irq_exit(struct pm_irq_chip *chip);
+int pm8xxx_irq_exit(struct pm_irq_chip *chip);
 #else
 static inline int pm8xxx_get_irq_stat(struct pm_irq_chip *chip, int irq)
 {
 	return -ENXIO;
 }
-static inline struct pm_irq_chip * __devinit pm8xxx_irq_init(
-				const struct device *dev,
+static inline struct pm_irq_chip *pm8xxx_irq_init(const struct device *dev,
 				const struct pm8xxx_irq_platform_data *pdata)
 {
 	return ERR_PTR(-ENXIO);
 }
-static inline int __devexit pm8xxx_irq_exit(struct pm_irq_chip *chip)
+static inline int pm8xxx_irq_exit(struct pm_irq_chip *chip)
 {
 	return -ENXIO;
 }
diff --git a/include/linux/mfd/pm8xxx/misc.h b/include/linux/mfd/pm8xxx/misc.h
new file mode 100644
index 0000000..fa97ba9
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/misc.h
@@ -0,0 +1,284 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MFD_PM8XXX_MISC_H__
+#define __MFD_PM8XXX_MISC_H__
+
+#include <linux/err.h>
+
+#define PM8XXX_MISC_DEV_NAME	"pm8xxx-misc"
+
+/**
+ * struct pm8xxx_misc_platform_data - PM8xxx misc driver platform data
+ * @priority:	PMIC prority level in a multi-PMIC system. Lower value means
+ *		greater priority. Actions are performed from highest to lowest
+ *		priority PMIC.
+ */
+struct pm8xxx_misc_platform_data {
+	int	priority;
+};
+
+enum pm8xxx_uart_path_sel {
+	UART_NONE,
+	UART_TX1_RX1,
+	UART_TX2_RX2,
+	UART_TX3_RX3,
+};
+
+enum pm8xxx_coincell_chg_voltage {
+	PM8XXX_COINCELL_VOLTAGE_3p2V = 1,
+	PM8XXX_COINCELL_VOLTAGE_3p1V,
+	PM8XXX_COINCELL_VOLTAGE_3p0V,
+	PM8XXX_COINCELL_VOLTAGE_2p5V = 16
+};
+
+enum pm8xxx_coincell_chg_resistor {
+	PM8XXX_COINCELL_RESISTOR_2100_OHMS,
+	PM8XXX_COINCELL_RESISTOR_1700_OHMS,
+	PM8XXX_COINCELL_RESISTOR_1200_OHMS,
+	PM8XXX_COINCELL_RESISTOR_800_OHMS
+};
+
+enum pm8xxx_coincell_chg_state {
+	PM8XXX_COINCELL_CHG_DISABLE,
+	PM8XXX_COINCELL_CHG_ENABLE
+};
+
+struct pm8xxx_coincell_chg {
+	enum pm8xxx_coincell_chg_state		state;
+	enum pm8xxx_coincell_chg_voltage	voltage;
+	enum pm8xxx_coincell_chg_resistor	resistor;
+};
+
+enum pm8xxx_smpl_delay {
+	PM8XXX_SMPL_DELAY_0p5,
+	PM8XXX_SMPL_DELAY_1p0,
+	PM8XXX_SMPL_DELAY_1p5,
+	PM8XXX_SMPL_DELAY_2p0,
+};
+
+enum pm8xxx_pon_config {
+	PM8XXX_DISABLE_HARD_RESET = 0,
+	PM8XXX_SHUTDOWN_ON_HARD_RESET,
+	PM8XXX_RESTART_ON_HARD_RESET,
+};
+
+enum pm8xxx_aux_clk_id {
+	CLK_MP3_1,
+	CLK_MP3_2,
+};
+
+enum pm8xxx_aux_clk_div {
+	XO_DIV_NONE,
+	XO_DIV_1,
+	XO_DIV_2,
+	XO_DIV_4,
+	XO_DIV_8,
+	XO_DIV_16,
+	XO_DIV_32,
+	XO_DIV_64,
+};
+
+enum pm8xxx_hsed_bias {
+	PM8XXX_HSED_BIAS0,
+	PM8XXX_HSED_BIAS1,
+	PM8XXX_HSED_BIAS2,
+};
+
+#if defined(CONFIG_MFD_PM8XXX_MISC) || defined(CONFIG_MFD_PM8XXX_MISC_MODULE)
+
+/**
+ * pm8xxx_reset_pwr_off - switch all PM8XXX PMIC chips attached to the system to
+ *			  either reset or shutdown when they are turned off
+ * @reset: 0 = shudown the PMICs, 1 = shutdown and then restart the PMICs
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_reset_pwr_off(int reset);
+
+int pm8xxx_uart_gpio_mux_ctrl(enum pm8xxx_uart_path_sel uart_path_sel);
+
+/**
+ * pm8xxx_coincell_chg_config - Disables or enables the coincell charger, and
+ *				configures its voltage and resistor settings.
+ * @chg_config:			Holds both voltage and resistor values, and a
+ *				switch to change the state of charger.
+ *				If state is to disable the charger then
+ *				both voltage and resistor are disregarded.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_coincell_chg_config(struct pm8xxx_coincell_chg *chg_config);
+
+/**
+ * pm8xxx_smpl_control - enables/disables SMPL detection
+ * @enable: 0 = shutdown PMIC on power loss, 1 = reset PMIC on power loss
+ *
+ * This function enables or disables the Sudden Momentary Power Loss detection
+ * module.  If SMPL detection is enabled, then when a sufficiently long power
+ * loss event occurs, the PMIC will automatically reset itself.  If SMPL
+ * detection is disabled, then the PMIC will shutdown when power loss occurs.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_smpl_control(int enable);
+
+/**
+ * pm8xxx_smpl_set_delay - sets the SMPL detection time delay
+ * @delay: enum value corresponding to delay time
+ *
+ * This function sets the time delay of the SMPL detection module.  If power
+ * is reapplied within this interval, then the PMIC reset automatically.  The
+ * SMPL detection module must be enabled for this delay time to take effect.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_smpl_set_delay(enum pm8xxx_smpl_delay delay);
+
+/**
+ * pm8xxx_watchdog_reset_control - enables/disables watchdog reset detection
+ * @enable: 0 = shutdown when PS_HOLD goes low, 1 = reset when PS_HOLD goes low
+ *
+ * This function enables or disables the PMIC watchdog reset detection feature.
+ * If watchdog reset detection is enabled, then the PMIC will reset itself
+ * when PS_HOLD goes low.  If it is not enabled, then the PMIC will shutdown
+ * when PS_HOLD goes low.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_watchdog_reset_control(int enable);
+
+/**
+ * pm8xxx_hard_reset_config - Allows different reset configurations
+ *
+ * config = DISABLE_HARD_RESET to disable hard reset
+ *	  = SHUTDOWN_ON_HARD_RESET to turn off the system on hard reset
+ *	  = RESTART_ON_HARD_RESET to restart the system on hard reset
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_hard_reset_config(enum pm8xxx_pon_config config);
+
+/**
+ * pm8xxx_stay_on - enables stay_on feature
+ *
+ * PMIC stay-on feature allows PMIC to ignore MSM PS_HOLD=low
+ * signal so that some special functions like debugging could be
+ * performed.
+ *
+ * This feature should not be used in any product release.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_stay_on(void);
+
+/**
+ * pm8xxx_preload_dVdd - preload the dVdd regulator during off state.
+ *
+ * This can help to reduce fluctuations in the dVdd voltage during startup
+ * at the cost of additional off state current draw.
+ *
+ * This API should only be called if dVdd startup issues are suspected.
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_preload_dVdd(void);
+
+/**
+ * pm8xxx_usb_id_pullup - Control a pullup for USB ID
+ *
+ * @enable: enable (1) or disable (0) the pullup
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_usb_id_pullup(int enable);
+
+/**
+ * pm8xxx_aux_clk_control - Control an auxiliary clock
+ * @clk_id: ID of clock to be programmed, registers of XO_CNTRL2
+ * @divider: divisor to use when configuring desired clock
+ * @enable: enable (1) the designated clock with the supplied division,
+ *		or disable (0) the designated clock
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_aux_clk_control(enum pm8xxx_aux_clk_id clk_id,
+				enum pm8xxx_aux_clk_div divider,
+				bool enable);
+
+/**
+ * pm8xxx_hsed_bias_control - Control the HSED_BIAS signal
+ * @bias: the bias line to be controlled (of the 3)
+ * @enable: enable/disable the bias line
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_hsed_bias_control(enum pm8xxx_hsed_bias bias, bool enable);
+#else
+
+static inline int pm8xxx_reset_pwr_off(int reset)
+{
+	return -ENODEV;
+}
+static inline int
+pm8xxx_uart_gpio_mux_ctrl(enum pm8xxx_uart_path_sel uart_path_sel)
+{
+	return -ENODEV;
+}
+static inline int
+pm8xxx_coincell_chg_config(struct pm8xxx_coincell_chg *chg_config)
+{
+	return -ENODEV;
+}
+static inline int pm8xxx_smpl_set_delay(enum pm8xxx_smpl_delay delay)
+{
+	return -ENODEV;
+}
+static inline int pm8xxx_smpl_control(int enable)
+{
+	return -ENODEV;
+}
+static inline int pm8xxx_watchdog_reset_control(int enable)
+{
+	return -ENODEV;
+}
+static inline int pm8xxx_hard_reset_config(enum pm8xxx_pon_config config)
+{
+	return -ENODEV;
+}
+static inline int pm8xxx_stay_on(void)
+{
+	return -ENODEV;
+}
+static inline int pm8xxx_preload_dVdd(void)
+{
+	return -ENODEV;
+}
+static inline int pm8xxx_usb_id_pullup(int enable)
+{
+	return -ENODEV;
+}
+static inline int pm8xxx_aux_clk_control(enum pm8xxx_aux_clk_id clk_id,
+			enum pm8xxx_aux_clk_div divider, bool enable)
+{
+	return -ENODEV;
+}
+static inline int pm8xxx_hsed_bias_control(enum pm8xxx_hsed_bias bias,
+							bool enable)
+{
+	return -ENODEV;
+}
+
+#endif
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/mpp.h b/include/linux/mfd/pm8xxx/mpp.h
new file mode 100644
index 0000000..f40499d
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/mpp.h
@@ -0,0 +1,263 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PM8XXX_MPP_H
+#define __PM8XXX_MPP_H
+
+#include <linux/errno.h>
+
+#define PM8XXX_MPP_DEV_NAME	"pm8xxx-mpp"
+
+struct pm8xxx_mpp_core_data {
+	int	base_addr;
+	int	nmpps;
+};
+
+struct pm8xxx_mpp_platform_data {
+	struct pm8xxx_mpp_core_data	core_data;
+	int				mpp_base;
+};
+
+/**
+ * struct pm8xxx_mpp_config_data - structure to specify mpp configuration values
+ * @type:	MPP type which determines the overall MPP function (i.e. digital
+ *		in/out/bi, analog in/out, current sink, or test).  It should be
+ *		set to the value of one of PM8XXX_MPP_TYPE_D_*.
+ * @level:	meaning depends upon MPP type specified
+ * @control:	meaning depends upon MPP type specified
+ *
+ * Usage of level argument:
+ * 1. type = PM8XXX_MPP_TYPE_D_INPUT, PM8XXX_MPP_TYPE_D_OUTPUT,
+ *	     PM8XXX_MPP_TYPE_D_BI_DIR, or PM8XXX_MPP_TYPE_DTEST_OUTPUT -
+ *
+ *	level specifies that digital logic level to use for the MPP.  It should
+ *	be set to the value of one of PM8XXX_MPP_DIG_LEVEL_*.  Actual regulator
+ *	connections for these level choices are PMIC chip specific.
+ *
+ * 2. type = PM8XXX_MPP_TYPE_A_INPUT -
+ *
+ *	level specifies where in the PMIC chip the analog input value should
+ *	be routed to.  It should be set to the value of one of
+ *	PM8XXX_MPP_AIN_AMUX_*.
+ *
+ * 3. type = PM8XXX_MPP_TYPE_A_OUTPUT -
+ *
+ *	level specifies the output analog voltage reference level.  It should
+ *	be set to the value of one of PM8XXX_MPP_AOUT_LVL_*.
+ *
+ * 4. type = PM8XXX_MPP_TYPE_SINK or PM8XXX_MPP_TYPE_DTEST_SINK -
+ *
+ *	level specifies the output current level.  It should be set to the value
+ *	of one of PM8XXX_MPP_CS_OUT_*.
+ *
+ * Usage of control argument:
+ * 1. type = PM8XXX_MPP_TYPE_D_INPUT -
+ *
+ *	control specifies how the digital input should be routed in the chip.
+ *	It should be set to the value of one of PM8XXX_MPP_DIN_TO_*.
+ *
+ * 2. type = PM8XXX_MPP_TYPE_D_OUTPUT -
+ *
+ *	control specifies the digital output value.  It should be set to the
+ *	value of one of PM8XXX_MPP_DOUT_CTRL_*.
+ *
+ * 3. type = PM8XXX_MPP_TYPE_D_BI_DIR -
+ *
+ *	control specifies the pullup resistor value.  It should be set to the
+ *	value of one of PM8XXX_MPP_BI_PULLUP_*.
+ *
+ * 4. type = PM8XXX_MPP_TYPE_A_INPUT -
+ *
+ *	control is unused; a value of 0 is sufficient.
+ *
+ * 5. type = PM8XXX_MPP_TYPE_A_OUTPUT -
+ *
+ *	control specifies if analog output is enabled.  It should be set to the
+ *	value of one of PM8XXX_MPP_AOUT_CTRL_*.
+ *
+ * 6. type = PM8XXX_MPP_TYPE_SINK -
+ *
+ *	control specifies if current sinking is enabled.  It should be set to
+ *	the value of one of PM8XXX_MPP_CS_CTRL_*.
+ *
+ * 7. type = PM8XXX_MPP_TYPE_DTEST_SINK -
+ *
+ *	control specifies if current sinking is enabled.  It should be set to
+ *	the value of one of PM8XXX_MPP_DTEST_CS_CTRL_*.
+ *
+ * 8. type = PM8XXX_MPP_TYPE_DTEST_OUTPUT -
+ *
+ *	control specifies which DTEST bus value to output.  It should be set to
+ *	the value of one of PM8XXX_MPP_DTEST_*.
+ */
+struct pm8xxx_mpp_config_data {
+	unsigned	type;
+	unsigned	level;
+	unsigned	control;
+};
+
+/* API */
+#if defined(CONFIG_GPIO_PM8XXX_MPP) || defined(CONFIG_GPIO_PM8XXX_MPP_MODULE)
+
+/**
+ * pm8xxx_mpp_config() - configure control options of a multi-purpose pin (MPP)
+ * @mpp:	global GPIO number corresponding to the MPP
+ * @config:	configuration to set for this MPP
+ * Context: can sleep
+ *
+ * RETURNS: an appropriate -ERRNO error value on error, or zero for success.
+ */
+int pm8xxx_mpp_config(unsigned mpp, struct pm8xxx_mpp_config_data *config);
+
+#else
+
+static inline int pm8xxx_mpp_config(unsigned mpp,
+				    struct pm8xxx_mpp_config_data *config)
+{
+	return -ENXIO;
+}
+
+#endif
+
+/* MPP Type: type */
+#define	PM8XXX_MPP_TYPE_D_INPUT		0
+#define	PM8XXX_MPP_TYPE_D_OUTPUT	1
+#define	PM8XXX_MPP_TYPE_D_BI_DIR	2
+#define	PM8XXX_MPP_TYPE_A_INPUT		3
+#define	PM8XXX_MPP_TYPE_A_OUTPUT	4
+#define	PM8XXX_MPP_TYPE_SINK		5
+#define	PM8XXX_MPP_TYPE_DTEST_SINK	6
+#define	PM8XXX_MPP_TYPE_DTEST_OUTPUT	7
+
+/* Digital Input/Output: level */
+#define	PM8XXX_MPP_DIG_LEVEL_VIO_0	0
+#define	PM8XXX_MPP_DIG_LEVEL_VIO_1	1
+#define	PM8XXX_MPP_DIG_LEVEL_VIO_2	2
+#define	PM8XXX_MPP_DIG_LEVEL_VIO_3	3
+#define	PM8XXX_MPP_DIG_LEVEL_VIO_4	4
+#define	PM8XXX_MPP_DIG_LEVEL_VIO_5	5
+#define	PM8XXX_MPP_DIG_LEVEL_VIO_6	6
+#define	PM8XXX_MPP_DIG_LEVEL_VIO_7	7
+
+/* Digital Input/Output: level [PM8058] */
+#define	PM8058_MPP_DIG_LEVEL_VPH	0
+#define	PM8058_MPP_DIG_LEVEL_S3		1
+#define	PM8058_MPP_DIG_LEVEL_L2		2
+#define	PM8058_MPP_DIG_LEVEL_L3		3
+
+/* Digital Input/Output: level [PM8901] */
+#define	PM8901_MPP_DIG_LEVEL_MSMIO	0
+#define	PM8901_MPP_DIG_LEVEL_DIG	1
+#define	PM8901_MPP_DIG_LEVEL_L5		2
+#define	PM8901_MPP_DIG_LEVEL_S4		3
+#define	PM8901_MPP_DIG_LEVEL_VPH	4
+
+/* Digital Input/Output: level [PM8921] */
+#define	PM8921_MPP_DIG_LEVEL_S4		1
+#define	PM8921_MPP_DIG_LEVEL_L15	3
+#define	PM8921_MPP_DIG_LEVEL_L17	4
+#define	PM8921_MPP_DIG_LEVEL_VPH	7
+
+/* Digital Input/Output: level [PM8821] */
+#define	PM8821_MPP_DIG_LEVEL_1P8	1
+#define	PM8821_MPP_DIG_LEVEL_VPH	7
+
+/* Digital Input/Output: level [PM8018] */
+#define	PM8018_MPP_DIG_LEVEL_L4		0
+#define	PM8018_MPP_DIG_LEVEL_L14	1
+#define	PM8018_MPP_DIG_LEVEL_S3		2
+#define	PM8018_MPP_DIG_LEVEL_L6		3
+#define	PM8018_MPP_DIG_LEVEL_L2		4
+#define	PM8018_MPP_DIG_LEVEL_L5		5
+#define	PM8018_MPP_DIG_LEVEL_VPH	7
+
+/* Digital Input/Output: level [PM8038] */
+#define	PM8038_MPP_DIG_LEVEL_L20	0
+#define	PM8038_MPP_DIG_LEVEL_L11	1
+#define	PM8038_MPP_DIG_LEVEL_L5		2
+#define	PM8038_MPP_DIG_LEVEL_L15	3
+#define	PM8038_MPP_DIG_LEVEL_L17	4
+#define	PM8038_MPP_DIG_LEVEL_VPH	7
+
+/* Digital Input: control */
+#define	PM8XXX_MPP_DIN_TO_INT		0
+#define	PM8XXX_MPP_DIN_TO_DBUS1		1
+#define	PM8XXX_MPP_DIN_TO_DBUS2		2
+#define	PM8XXX_MPP_DIN_TO_DBUS3		3
+
+/* Digital Output: control */
+#define	PM8XXX_MPP_DOUT_CTRL_LOW	0
+#define	PM8XXX_MPP_DOUT_CTRL_HIGH	1
+#define	PM8XXX_MPP_DOUT_CTRL_MPP	2
+#define	PM8XXX_MPP_DOUT_CTRL_INV_MPP	3
+
+/* Bidirectional: control */
+#define	PM8XXX_MPP_BI_PULLUP_1KOHM	0
+#define	PM8XXX_MPP_BI_PULLUP_OPEN	1
+#define	PM8XXX_MPP_BI_PULLUP_10KOHM	2
+#define	PM8XXX_MPP_BI_PULLUP_30KOHM	3
+
+/* Analog Input: level */
+#define	PM8XXX_MPP_AIN_AMUX_CH5		0
+#define	PM8XXX_MPP_AIN_AMUX_CH6		1
+#define	PM8XXX_MPP_AIN_AMUX_CH7		2
+#define	PM8XXX_MPP_AIN_AMUX_CH8		3
+#define	PM8XXX_MPP_AIN_AMUX_CH9		4
+#define	PM8XXX_MPP_AIN_AMUX_ABUS1	5
+#define	PM8XXX_MPP_AIN_AMUX_ABUS2	6
+#define	PM8XXX_MPP_AIN_AMUX_ABUS3	7
+
+/* Analog Output: level */
+#define	PM8XXX_MPP_AOUT_LVL_1V25	0
+#define	PM8XXX_MPP_AOUT_LVL_1V25_2	1
+#define	PM8XXX_MPP_AOUT_LVL_0V625	2
+#define	PM8XXX_MPP_AOUT_LVL_0V3125	3
+#define	PM8XXX_MPP_AOUT_LVL_MPP		4
+#define	PM8XXX_MPP_AOUT_LVL_ABUS1	5
+#define	PM8XXX_MPP_AOUT_LVL_ABUS2	6
+#define	PM8XXX_MPP_AOUT_LVL_ABUS3	7
+
+/* Analog Output: control */
+#define	PM8XXX_MPP_AOUT_CTRL_DISABLE		0
+#define	PM8XXX_MPP_AOUT_CTRL_ENABLE		1
+#define	PM8XXX_MPP_AOUT_CTRL_MPP_HIGH_EN	2
+#define	PM8XXX_MPP_AOUT_CTRL_MPP_LOW_EN		3
+
+/* Current Sink: level */
+#define	PM8XXX_MPP_CS_OUT_5MA		0
+#define	PM8XXX_MPP_CS_OUT_10MA		1
+#define	PM8XXX_MPP_CS_OUT_15MA		2
+#define	PM8XXX_MPP_CS_OUT_20MA		3
+#define	PM8XXX_MPP_CS_OUT_25MA		4
+#define	PM8XXX_MPP_CS_OUT_30MA		5
+#define	PM8XXX_MPP_CS_OUT_35MA		6
+#define	PM8XXX_MPP_CS_OUT_40MA		7
+
+/* Current Sink: control */
+#define	PM8XXX_MPP_CS_CTRL_DISABLE	0
+#define	PM8XXX_MPP_CS_CTRL_ENABLE	1
+#define	PM8XXX_MPP_CS_CTRL_MPP_HIGH_EN	2
+#define	PM8XXX_MPP_CS_CTRL_MPP_LOW_EN	3
+
+/* DTEST Current Sink: control */
+#define	PM8XXX_MPP_DTEST_CS_CTRL_EN1	0
+#define	PM8XXX_MPP_DTEST_CS_CTRL_EN2	1
+#define	PM8XXX_MPP_DTEST_CS_CTRL_EN3	2
+#define	PM8XXX_MPP_DTEST_CS_CTRL_EN4	3
+
+/* DTEST Digital Output: control */
+#define	PM8XXX_MPP_DTEST_DBUS1		0
+#define	PM8XXX_MPP_DTEST_DBUS2		1
+#define	PM8XXX_MPP_DTEST_DBUS3		2
+#define	PM8XXX_MPP_DTEST_DBUS4		3
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/nfc.h b/include/linux/mfd/pm8xxx/nfc.h
new file mode 100644
index 0000000..e4a495d
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/nfc.h
@@ -0,0 +1,79 @@
+/* Copyright (c) 2010,2011 The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __PM8XXX_NFC_H__
+#define __PM8XXX_NFC_H__
+
+struct pm8xxx_nfc_device;
+
+#define PM8XXX_NFC_DEV_NAME		"pm8xxx-nfc"
+
+/* masks, flags and status */
+#define	PM_NFC_VDDLDO_MON_LEVEL		0x0003
+#define	PM_NFC_VPH_PWR_EN		0x0008
+#define	PM_NFC_EXT_VDDLDO_EN		0x0010
+#define	PM_NFC_EN			0x0020
+#define	PM_NFC_LDO_EN			0x0040
+#define	PM_NFC_SUPPORT_EN		0x0080
+
+#define	PM_NFC_EXT_EN_HIGH		0x0100
+#define	PM_NFC_MBG_EN_HIGH		0x0200
+#define	PM_NFC_VDDLDO_OK_HIGH		0x0400
+#define	PM_NFC_DTEST1_MODE		0x2000
+#define	PM_NFC_ATEST_EN			0x4000
+#define	PM_NFC_VDDLDO_MON_EN		0x8000
+
+#define	PM_NFC_CTRL_REQ			(PM_NFC_SUPPORT_EN |\
+					PM_NFC_LDO_EN |\
+					PM_NFC_EN |\
+					PM_NFC_EXT_VDDLDO_EN |\
+					PM_NFC_VPH_PWR_EN |\
+					PM_NFC_VDDLDO_MON_LEVEL)
+
+#define	PM_NFC_TEST_REQ			(PM_NFC_VDDLDO_MON_EN |\
+					PM_NFC_DTEST1_MODE |\
+					PM_NFC_ATEST_EN)
+
+#define	PM_NFC_TEST_STATUS		(PM_NFC_EXT_EN_HIGH |\
+					PM_NFC_MBG_EN_HIGH |\
+					PM_NFC_VDDLDO_OK_HIGH)
+
+/*
+ * pm8xxx_nfc_request - request a handle to access NFC device
+ */
+struct pm8xxx_nfc_device *pm8xxx_nfc_request(void);
+
+/*
+ * pm8xxx_nfc_config - configure NFC signals
+ *
+ * @nfcdev: the NFC device
+ * @mask: signal mask to configure
+ * @flags: control flags
+ */
+int pm8xxx_nfc_config(struct pm8xxx_nfc_device *nfcdev, u32 mask, u32 flags);
+
+/*
+ * pm8xxx_nfc_get_status - get NFC status
+ *
+ * @nfcdev: the NFC device
+ * @mask: of status mask to read
+ * @status: pointer to the status variable
+ */
+int pm8xxx_nfc_get_status(struct pm8xxx_nfc_device *nfcdev,
+			  u32 mask, u32 *status);
+
+/*
+ * pm8xxx_nfc_free - free the NFC device
+ */
+void pm8xxx_nfc_free(struct pm8xxx_nfc_device *nfcdev);
+
+#endif /* __PM8XXX_NFC_H__ */
diff --git a/include/linux/mfd/pm8xxx/pm8018.h b/include/linux/mfd/pm8xxx/pm8018.h
new file mode 100644
index 0000000..002623c
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/pm8018.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+ * Qualcomm PMIC 8018 driver header file
+ *
+ */
+
+#ifndef __MFD_PM8018_H
+#define __MFD_PM8018_H
+
+#include <linux/device.h>
+#include <linux/mfd/pm8xxx/irq.h>
+#include <linux/mfd/pm8xxx/gpio.h>
+#include <linux/mfd/pm8xxx/mpp.h>
+#include <linux/mfd/pm8xxx/rtc.h>
+#include <linux/mfd/pm8xxx/tm.h>
+#include <linux/input/pmic8xxx-pwrkey.h>
+#include <linux/mfd/pm8xxx/misc.h>
+#include <linux/regulator/pm8xxx-regulator.h>
+#include <linux/mfd/pm8xxx/pm8xxx-adc.h>
+#include <linux/mfd/pm8xxx/pwm.h>
+#include <linux/leds-pm8xxx.h>
+
+#define PM8018_CORE_DEV_NAME "pm8018-core"
+
+#define PM8018_NR_IRQS		256
+
+#define PM8018_NR_GPIOS		6
+
+#define PM8018_NR_MPPS		6
+
+#define PM8018_GPIO_BLOCK_START	24
+#define PM8018_MPP_BLOCK_START	16
+#define PM8018_IRQ_BLOCK_BIT(block, bit) ((block) * 8 + (bit))
+
+/* GPIOs and MPPs [1,N] */
+#define PM8018_GPIO_IRQ(base, gpio)	((base) + \
+		PM8018_IRQ_BLOCK_BIT(PM8018_GPIO_BLOCK_START, (gpio)-1))
+#define PM8018_MPP_IRQ(base, mpp)	((base) + \
+		PM8018_IRQ_BLOCK_BIT(PM8018_MPP_BLOCK_START, (mpp)-1))
+
+/* PMIC Interrupts */
+#define PM8018_RTC_ALARM_IRQ		PM8018_IRQ_BLOCK_BIT(4, 7)
+
+#define PM8018_PWRKEY_REL_IRQ		PM8018_IRQ_BLOCK_BIT(6, 2)
+#define PM8018_PWRKEY_PRESS_IRQ		PM8018_IRQ_BLOCK_BIT(6, 3)
+#define PM8018_ADC_EOC_USR_IRQ		PM8018_IRQ_BLOCK_BIT(9, 6)
+#define PM8018_ADC_BATT_TEMP_WARM_IRQ	PM8018_IRQ_BLOCK_BIT(9, 1)
+#define PM8018_ADC_BATT_TEMP_COLD_IRQ	PM8018_IRQ_BLOCK_BIT(9, 0)
+
+#define PM8018_OVERTEMP_IRQ		PM8018_IRQ_BLOCK_BIT(4, 2)
+#define PM8018_TEMPSTAT_IRQ		PM8018_IRQ_BLOCK_BIT(6, 7)
+
+#define PM8018_LVS1_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(13, 0)
+
+struct pm8018_platform_data {
+	struct pm8xxx_irq_platform_data		*irq_pdata;
+	struct pm8xxx_gpio_platform_data	*gpio_pdata;
+	struct pm8xxx_mpp_platform_data		*mpp_pdata;
+	struct pm8xxx_rtc_platform_data         *rtc_pdata;
+	struct pm8xxx_pwrkey_platform_data	*pwrkey_pdata;
+	struct pm8xxx_misc_platform_data	*misc_pdata;
+	struct pm8xxx_regulator_platform_data	*regulator_pdatas;
+	struct pm8xxx_adc_platform_data		*adc_pdata;
+	int					num_regulators;
+	struct pm8xxx_led_platform_data		*leds_pdata;
+};
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/pm8038.h b/include/linux/mfd/pm8xxx/pm8038.h
new file mode 100644
index 0000000..0ee74f0
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/pm8038.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+ * Qualcomm PMIC 8038 driver header file
+ *
+ */
+
+#ifndef __MFD_PM8038_H
+#define __MFD_PM8038_H
+
+#include <linux/device.h>
+#include <linux/mfd/pm8xxx/irq.h>
+#include <linux/mfd/pm8xxx/gpio.h>
+#include <linux/mfd/pm8xxx/mpp.h>
+#include <linux/mfd/pm8xxx/pwm.h>
+#include <linux/mfd/pm8xxx/rtc.h>
+#include <linux/input/pmic8xxx-pwrkey.h>
+#include <linux/mfd/pm8xxx/misc.h>
+#include <linux/regulator/pm8xxx-regulator.h>
+#include <linux/mfd/pm8xxx/pm8xxx-adc.h>
+#include <linux/mfd/pm8xxx/pm8921-charger.h>
+#include <linux/mfd/pm8xxx/pm8921-bms.h>
+#include <linux/leds-pm8xxx.h>
+#include <linux/mfd/pm8xxx/ccadc.h>
+#include <linux/mfd/pm8xxx/spk.h>
+#include <linux/mfd/pm8xxx/tm.h>
+
+#define PM8038_CORE_DEV_NAME "pm8038-core"
+
+#define PM8038_NR_IRQS		256
+#define PM8038_NR_GPIOS		12
+#define PM8038_NR_MPPS		6
+
+#define PM8038_GPIO_BLOCK_START	24
+#define PM8038_MPP_BLOCK_START	16
+
+#define PM8038_IRQ_BLOCK_BIT(block, bit) ((block) * 8 + (bit))
+
+/* GPIO and MPPs [1,N] */
+#define PM8038_GPIO_IRQ(base, gpio)	((base) + \
+		PM8038_IRQ_BLOCK_BIT(PM8038_GPIO_BLOCK_START, (gpio)-1))
+#define PM8038_MPP_IRQ(base, mpp)	((base) + \
+		PM8038_IRQ_BLOCK_BIT(PM8038_MPP_BLOCK_START, (mpp)-1))
+
+/* PMIC Interrupts */
+#define PM8038_RTC_ALARM_IRQ		PM8038_IRQ_BLOCK_BIT(4, 7)
+#define PM8038_PWRKEY_REL_IRQ		PM8038_IRQ_BLOCK_BIT(6, 2)
+#define PM8038_PWRKEY_PRESS_IRQ		PM8038_IRQ_BLOCK_BIT(6, 3)
+#define PM8038_KEYPAD_IRQ		PM8038_IRQ_BLOCK_BIT(9, 2)
+#define PM8038_KEYSTUCK_IRQ		PM8038_IRQ_BLOCK_BIT(9, 3)
+#define PM8038_ADC_EOC_USR_IRQ		PM8038_IRQ_BLOCK_BIT(9, 6)
+#define PM8038_ADC_BATT_TEMP_WARM_IRQ	PM8038_IRQ_BLOCK_BIT(9, 1)
+#define PM8038_ADC_BATT_TEMP_COLD_IRQ	PM8038_IRQ_BLOCK_BIT(9, 0)
+#define PM8038_USB_ID_IN_IRQ(base)	(base + PM8921_IRQ_BLOCK_BIT(6, 1))
+
+#define PM8038_RESOUT_IRQ		PM8038_IRQ_BLOCK_BIT(6, 4)
+
+#define PM8038_OVERTEMP_IRQ		PM8038_IRQ_BLOCK_BIT(4, 2)
+#define PM8038_TEMPSTAT_IRQ		PM8038_IRQ_BLOCK_BIT(6, 7)
+
+struct pm8038_platform_data {
+	int					irq_base;
+	struct pm8xxx_gpio_platform_data	*gpio_pdata;
+	struct pm8xxx_irq_platform_data		*irq_pdata;
+	struct pm8xxx_mpp_platform_data		*mpp_pdata;
+	struct pm8xxx_rtc_platform_data         *rtc_pdata;
+	struct pm8xxx_pwrkey_platform_data	*pwrkey_pdata;
+	struct pm8xxx_misc_platform_data	*misc_pdata;
+	struct pm8xxx_regulator_platform_data	*regulator_pdatas;
+	int					num_regulators;
+	struct pm8921_charger_platform_data	*charger_pdata;
+	struct pm8921_bms_platform_data		*bms_pdata;
+	struct pm8xxx_adc_platform_data		*adc_pdata;
+	struct pm8xxx_led_platform_data		*leds_pdata;
+	struct pm8xxx_ccadc_platform_data	*ccadc_pdata;
+	struct pm8xxx_spk_platform_data		*spk_pdata;
+};
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/pm8821-irq.h b/include/linux/mfd/pm8xxx/pm8821-irq.h
new file mode 100644
index 0000000..4d9b8b8
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/pm8821-irq.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+ * Qualcomm PMIC irq 8821 driver header file
+ *
+ */
+
+#ifndef __MFD_PM8821_IRQ_H
+#define __MFD_PM8821_IRQ_H
+
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/mfd/pm8xxx/irq.h>
+
+#ifdef CONFIG_MFD_PM8821_IRQ
+int pm8821_get_irq_stat(struct pm_irq_chip *chip, int irq);
+struct pm_irq_chip *pm8821_irq_init(struct device *dev,
+				const struct pm8xxx_irq_platform_data *pdata);
+int pm8821_irq_exit(struct pm_irq_chip *chip);
+#else
+static inline int pm8821_get_irq_stat(struct pm_irq_chip *chip, int irq)
+{
+	return -ENXIO;
+}
+static inline struct pm_irq_chip *pm8821_irq_init(const struct device *dev,
+				const struct pm8xxx_irq_platform_data *pdata)
+{
+	return ERR_PTR(-ENXIO);
+}
+static inline int pm8821_irq_exit(struct pm_irq_chip *chip)
+{
+	return -ENXIO;
+}
+#endif /* CONFIG_MFD_PM8821_IRQ */
+#endif /* __MFD_PM8821_IRQ_H */
diff --git a/include/linux/mfd/pm8xxx/pm8821.h b/include/linux/mfd/pm8xxx/pm8821.h
new file mode 100644
index 0000000..1398c64
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/pm8821.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+ * Qualcomm PMIC 8821 driver header file
+ *
+ */
+
+#ifndef __MFD_PM8821_H
+#define __MFD_PM8821_H
+
+#include <linux/device.h>
+#include <linux/mfd/pm8xxx/irq.h>
+#include <linux/mfd/pm8xxx/mpp.h>
+
+#define PM8821_NR_IRQS		(64)
+#define PM8821_NR_MPPS		(4)
+
+#define PM8821_MPP_BLOCK_START	(4)
+
+/*
+ * Block 0 does not exist in PM8821 IRQ SSBI address space,
+ * IRQ0 is assigned to bit0 of block1
+ */
+#define PM8821_IRQ_BLOCK_BIT(block, bit) ((block-1) * 8 + (bit))
+
+/* MPPs [1,N] */
+#define PM8821_MPP_IRQ(base, mpp)	((base) + \
+		PM8821_IRQ_BLOCK_BIT(PM8821_MPP_BLOCK_START, (mpp)-1))
+
+/* PMIC Interrupts */
+
+struct pm8821_platform_data {
+	int					irq_base;
+	struct pm8xxx_irq_platform_data		*irq_pdata;
+	struct pm8xxx_mpp_platform_data		*mpp_pdata;
+};
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/pm8921-bms.h b/include/linux/mfd/pm8xxx/pm8921-bms.h
new file mode 100644
index 0000000..9cd5a35
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/pm8921-bms.h
@@ -0,0 +1,255 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PM8XXX_BMS_H
+#define __PM8XXX_BMS_H
+
+#include <linux/errno.h>
+
+#define PM8921_BMS_DEV_NAME	"pm8921-bms"
+
+#define FCC_CC_COLS		5
+#define FCC_TEMP_COLS		8
+
+#define PC_CC_ROWS             29
+#define PC_CC_COLS             13
+
+#define PC_TEMP_ROWS		29
+#define PC_TEMP_COLS		8
+
+#define MAX_SINGLE_LUT_COLS	20
+
+struct single_row_lut {
+	int x[MAX_SINGLE_LUT_COLS];
+	int y[MAX_SINGLE_LUT_COLS];
+	int cols;
+};
+
+/**
+ * struct sf_lut -
+ * @rows:	number of percent charge entries should be <= PC_CC_ROWS
+ * @cols:	number of charge cycle entries should be <= PC_CC_COLS
+ * @row_entries:	the charge cycles/temperature at which sf data
+ *			is available in the table.
+ *		The charge cycles must be in increasing order from 0 to rows.
+ * @percent:	the percent charge at which sf data is available in the table
+ *		The  percentcharge must be in decreasing order from 0 to cols.
+ * @sf:		the scaling factor data
+ */
+struct sf_lut {
+	int rows;
+	int cols;
+	int row_entries[PC_CC_COLS];
+	int percent[PC_CC_ROWS];
+	int sf[PC_CC_ROWS][PC_CC_COLS];
+};
+
+/**
+ * struct pc_temp_ocv_lut -
+ * @rows:	number of percent charge entries should be <= PC_TEMP_ROWS
+ * @cols:	number of temperature entries should be <= PC_TEMP_COLS
+ * @temp:	the temperatures at which ocv data is available in the table
+ *		The temperatures must be in increasing order from 0 to rows.
+ * @percent:	the percent charge at which ocv data is available in the table
+ *		The  percentcharge must be in decreasing order from 0 to cols.
+ * @ocv:	the open circuit voltage
+ */
+struct pc_temp_ocv_lut {
+	int rows;
+	int cols;
+	int temp[PC_TEMP_COLS];
+	int percent[PC_TEMP_ROWS];
+	int ocv[PC_TEMP_ROWS][PC_TEMP_COLS];
+};
+
+/**
+ * struct pm8921_bms_battery_data -
+ * @fcc:		full charge capacity (mAmpHour)
+ * @fcc_temp_lut:	table to get fcc at a given temp
+ * @pc_temp_ocv_lut:	table to get percent charge given batt temp and cycles
+ * @pc_sf_lut:		table to get percent charge scaling factor given cycles
+ *			and percent charge
+ * @rbatt_sf_lut:	table to get battery resistance scaling factor given
+ *			temperature and percent charge
+ * @default_rbatt_mohm:	the default value of battery resistance to use when
+ *			readings from bms are not available.
+ * @delta_rbatt_mohm:	the resistance to be added towards lower soc to
+ *			compensate for battery capacitance.
+ */
+struct pm8921_bms_battery_data {
+	unsigned int		fcc;
+	struct single_row_lut	*fcc_temp_lut;
+	struct single_row_lut	*fcc_sf_lut;
+	struct pc_temp_ocv_lut	*pc_temp_ocv_lut;
+	struct sf_lut		*pc_sf_lut;
+	struct sf_lut		*rbatt_sf_lut;
+	int			default_rbatt_mohm;
+	int			delta_rbatt_mohm;
+};
+
+struct pm8xxx_bms_core_data {
+	unsigned int	batt_temp_channel;
+	unsigned int	vbat_channel;
+	unsigned int	ref625mv_channel;
+	unsigned int	ref1p25v_channel;
+	unsigned int	batt_id_channel;
+};
+
+enum battery_type {
+	BATT_UNKNOWN = 0,
+	BATT_PALLADIUM,
+	BATT_DESAY,
+};
+
+/**
+ * struct pm8921_bms_platform_data -
+ * @batt_type:		allows to force chose battery calibration data
+ * @r_sense:		sense resistor value in (mOhms)
+ * @i_test:		current at which the unusable charger cutoff is to be
+ *			calculated or the peak system current (mA)
+ * @v_cutoff:		the loaded voltage at which the battery
+ *			is considered empty(mV)
+ * @enable_fcc_learning:	if set the driver will learn full charge
+ *				capacity of the battery upon end of charge
+ */
+struct pm8921_bms_platform_data {
+	struct pm8xxx_bms_core_data	bms_cdata;
+	enum battery_type		battery_type;
+	unsigned int			r_sense;
+	unsigned int			i_test;
+	unsigned int			v_cutoff;
+	unsigned int			max_voltage_uv;
+	unsigned int			rconn_mohm;
+	int				enable_fcc_learning;
+	int				shutdown_soc_valid_limit;
+	int				ignore_shutdown_soc;
+	int				adjust_soc_low_threshold;
+	int				chg_term_ua;
+};
+
+#if defined(CONFIG_PM8921_BMS) || defined(CONFIG_PM8921_BMS_MODULE)
+extern struct pm8921_bms_battery_data  palladium_1500_data;
+extern struct pm8921_bms_battery_data  desay_5200_data;
+/**
+ * pm8921_bms_get_vsense_avg - return the voltage across the sense
+ *				resitor in microvolts
+ * @result:	The pointer where the voltage will be updated. A -ve
+ *		result means that the current is flowing in
+ *		the battery - during battery charging
+ *
+ * RETURNS:	Error code if there was a problem reading vsense, Zero otherwise
+ *		The result won't be updated in case of an error.
+ *
+ *
+ */
+int pm8921_bms_get_vsense_avg(int *result);
+
+/**
+ * pm8921_bms_get_battery_current - return the battery current based on vsense
+ *				resitor in microamperes
+ * @result:	The pointer where the voltage will be updated. A -ve
+ *		result means that the current is flowing in
+ *		the battery - during battery charging
+ *
+ * RETURNS:	Error code if there was a problem reading vsense, Zero otherwise
+ *		The result won't be updated in case of an error.
+ *
+ */
+int pm8921_bms_get_battery_current(int *result);
+
+/**
+ * pm8921_bms_get_percent_charge - returns the current battery charge in percent
+ *
+ */
+int pm8921_bms_get_percent_charge(void);
+
+/**
+ * pm8921_bms_get_fcc - returns fcc in mAh of the battery depending on its age
+ *			and temperature
+ *
+ */
+int pm8921_bms_get_fcc(void);
+
+/**
+ * pm8921_bms_charging_began - function to notify the bms driver that charging
+ *				has started. Used by the bms driver to keep
+ *				track of chargecycles
+ */
+void pm8921_bms_charging_began(void);
+/**
+ * pm8921_bms_charging_end - function to notify the bms driver that charging
+ *				has stopped. Used by the bms driver to keep
+ *				track of chargecycles
+ */
+void pm8921_bms_charging_end(int is_battery_full);
+
+void pm8921_bms_calibrate_hkadc(void);
+/**
+ * pm8921_bms_get_simultaneous_battery_voltage_and_current
+ *		- function to take simultaneous vbat and vsense readings
+ *		  this puts the bms in override mode but keeps coulumb couting
+ *		  on. Useful when ir compensation needs to be implemented
+ */
+int pm8921_bms_get_simultaneous_battery_voltage_and_current(int *ibat_ua,
+								int *vbat_uv);
+/**
+ * pm8921_bms_get_rbatt - function to get the battery resistance in mOhm.
+ */
+int pm8921_bms_get_rbatt(void);
+/**
+ * pm8921_bms_invalidate_shutdown_soc - function to notify the bms driver that
+ *					the battery was replaced between reboot
+ *					and so it should not use the shutdown
+ *					soc stored in a coincell backed register
+ */
+void pm8921_bms_invalidate_shutdown_soc(void);
+#else
+static inline int pm8921_bms_get_vsense_avg(int *result)
+{
+	return -ENXIO;
+}
+static inline int pm8921_bms_get_battery_current(int *result)
+{
+	return -ENXIO;
+}
+static inline int pm8921_bms_get_percent_charge(void)
+{
+	return -ENXIO;
+}
+static inline int pm8921_bms_get_fcc(void)
+{
+	return -ENXIO;
+}
+static inline void pm8921_bms_charging_began(void)
+{
+}
+static inline void pm8921_bms_charging_end(int is_battery_full)
+{
+}
+static inline void pm8921_bms_calibrate_hkadc(void)
+{
+}
+static inline int pm8921_bms_get_simultaneous_battery_voltage_and_current(
+						int *ibat_ua, int *vbat_uv)
+{
+	return -ENXIO;
+}
+static inline int pm8921_bms_get_rbatt(void)
+{
+	return -EINVAL;
+}
+static inline void pm8921_bms_invalidate_shutdown_soc(void)
+{
+}
+#endif
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/pm8921-charger.h b/include/linux/mfd/pm8xxx/pm8921-charger.h
new file mode 100644
index 0000000..a1409f0
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/pm8921-charger.h
@@ -0,0 +1,358 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PM8XXX_CHARGER_H
+#define __PM8XXX_CHARGER_H
+
+#include <linux/errno.h>
+#include <linux/power_supply.h>
+
+#define PM8921_CHARGER_DEV_NAME	"pm8921-charger"
+
+struct pm8xxx_charger_core_data {
+	unsigned int	vbat_channel;
+	unsigned int	batt_temp_channel;
+	unsigned int	batt_id_channel;
+};
+
+enum pm8921_chg_cold_thr {
+	PM_SMBC_BATT_TEMP_COLD_THR__LOW,
+	PM_SMBC_BATT_TEMP_COLD_THR__HIGH
+};
+
+enum pm8921_chg_hot_thr	{
+	PM_SMBC_BATT_TEMP_HOT_THR__LOW,
+	PM_SMBC_BATT_TEMP_HOT_THR__HIGH
+};
+
+enum pm8921_usb_ov_threshold {
+	PM_USB_OV_5P5V,
+	PM_USB_OV_6V,
+	PM_USB_OV_6P5V,
+	PM_USB_OV_7V,
+};
+
+enum pm8921_usb_debounce_time {
+	PM_USB_BYPASS_DEBOUNCER,
+	PM_USB_DEBOUNCE_20P5MS,
+	PM_USB_DEBOUNCE_40P5MS,
+	PM_USB_DEBOUNCE_80P5MS,
+};
+
+enum pm8921_chg_led_src_config {
+	LED_SRC_GND,
+	LED_SRC_VPH_PWR,
+	LED_SRC_5V,
+	LED_SRC_MIN_VPH_5V,
+	LED_SRC_BYPASS,
+};
+
+/**
+ * struct pm8921_charger_platform_data -
+ * @safety_time:	max charging time in minutes incl. fast and trkl
+ *			valid range 4 to 512 min. PON default 120 min
+ * @ttrkl_time:		max trckl charging time in minutes
+ *			valid range 1 to 64 mins. PON default 15 min
+ * @update_time:	how often the userland be updated of the charging (msec)
+ * @max_voltage:	the max voltage (mV) the battery should be charged up to
+ * @min_voltage:	the voltage (mV) where charging method switches from
+ *			trickle to fast. This is also the minimum voltage the
+ *			system operates at
+ * @resume_voltage_delta:	the (mV) drop to wait for before resume charging
+ *				after the battery has been fully charged
+ * @term_current:	the charger current (mA) at which EOC happens
+ * @cool_temp:		the temperature (degC) at which the battery is
+ *			considered cool charging current and voltage is reduced.
+ *			Use INT_MIN to indicate not valid.
+ * @warm_temp:		the temperature (degC) at which the battery is
+ *			considered warm charging current and voltage is reduced
+ *			Use INT_MIN to indicate not valid.
+ * @temp_check_period:	The polling interval in seconds to check battery
+ *			temeperature if it has gone to cool or warm temperature
+ *			area
+ * @max_bat_chg_current:	Max charge current of the battery in mA
+ *				Usually 70% of full charge capacity
+ * @cool_bat_chg_current:	chg current (mA) when the battery is cool
+ * @warm_bat_chg_current:	chg current (mA)  when the battery is warm
+ * @cool_bat_voltage:		chg voltage (mV) when the battery is cool
+ * @warm_bat_voltage:		chg voltage (mV) when the battery is warm
+ * @get_batt_capacity_percent:
+ *			a board specific function to return battery
+ *			capacity. If null - a default one will be used
+ * @trkl_voltage:	the trkl voltage in (mV) below which hw controlled
+ *			 trkl charging happens with linear charger
+ * @weak_voltage:	the weak voltage (mV) below which hw controlled
+ *			trkl charging happens with switching mode charger
+ * @trkl_current:	the trkl current in (mA) to use for trkl charging phase
+ * @weak_current:	the weak current in (mA) to use for weak charging phase
+ * @vin_min:		the input voltage regulation point (mV) - if the
+ *			voltage falls below this, the charger reduces charge
+ *			current or stop charging temporarily
+ * @thermal_mitigation: the array of charge currents to use as temperature
+ *			increases
+ * @thermal_levels:	the number of thermal mitigation levels supported
+ * @cold_thr:		if high battery will be cold when VBAT_THERM goes above
+ *			80% of VREF_THERM (typically 1.8volts), if low the
+ *			battery will be considered cold if VBAT_THERM goes above
+ *			70% of VREF_THERM. Hardware defaults to low.
+ * @hot_thr:		if high the battery will be considered hot when the
+ *			VBAT_THERM goes below 35% of VREF_THERM, if low the
+ *			battery will be considered hot when VBAT_THERM goes
+ *			below 25% of VREF_THERM. Hardware defaults to low.
+ * @rconn_mohm:		resistance in milliOhm from the vbat sense to ground
+ *			with the battery terminals shorted. This indicates
+ *			resistance of the pads, connectors, battery terminals
+ *			and rsense.
+ * @led_src_config:	Power source for anode of charger indicator LED.
+ */
+struct pm8921_charger_platform_data {
+	struct pm8xxx_charger_core_data	charger_cdata;
+	unsigned int			safety_time;
+	unsigned int			ttrkl_time;
+	unsigned int			update_time;
+	unsigned int			max_voltage;
+	unsigned int			min_voltage;
+	unsigned int			resume_voltage_delta;
+	unsigned int			term_current;
+	int				cool_temp;
+	int				warm_temp;
+	unsigned int			temp_check_period;
+	unsigned int			max_bat_chg_current;
+	unsigned int			cool_bat_chg_current;
+	unsigned int			warm_bat_chg_current;
+	unsigned int			cool_bat_voltage;
+	unsigned int			warm_bat_voltage;
+	unsigned int			(*get_batt_capacity_percent) (void);
+	int64_t				batt_id_min;
+	int64_t				batt_id_max;
+	bool				keep_btm_on_suspend;
+	int				trkl_voltage;
+	int				weak_voltage;
+	int				trkl_current;
+	int				weak_current;
+	int				vin_min;
+	int				*thermal_mitigation;
+	int				thermal_levels;
+	enum pm8921_chg_cold_thr	cold_thr;
+	enum pm8921_chg_hot_thr		hot_thr;
+	int				rconn_mohm;
+	enum pm8921_chg_led_src_config	led_src_config;
+};
+
+enum pm8921_charger_source {
+	PM8921_CHG_SRC_NONE,
+	PM8921_CHG_SRC_USB,
+	PM8921_CHG_SRC_DC,
+};
+
+#if defined(CONFIG_PM8921_CHARGER) || defined(CONFIG_PM8921_CHARGER_MODULE)
+void pm8921_charger_vbus_draw(unsigned int mA);
+int pm8921_charger_register_vbus_sn(void (*callback)(int));
+void pm8921_charger_unregister_vbus_sn(void (*callback)(int));
+/**
+ * pm8921_charger_enable -
+ *
+ * @enable: 1 means enable charging, 0 means disable
+ *
+ * Enable/Disable battery charging current, the device will still draw current
+ * from the charging source
+ */
+int pm8921_charger_enable(bool enable);
+
+/**
+ * pm8921_is_usb_chg_plugged_in - is usb plugged in
+ *
+ * if usb is under voltage or over voltage this will return false
+ */
+int pm8921_is_usb_chg_plugged_in(void);
+
+/**
+ * pm8921_is_dc_chg_plugged_in - is dc plugged in
+ *
+ * if dc is under voltage or over voltage this will return false
+ */
+int pm8921_is_dc_chg_plugged_in(void);
+
+/**
+ * pm8921_is_battery_present -
+ *
+ * returns if the pmic sees the battery present
+ */
+int pm8921_is_battery_present(void);
+
+/**
+ * pm8921_set_max_battery_charge_current - set max battery chg current
+ *
+ * @ma: max charge current in milliAmperes
+ */
+int pm8921_set_max_battery_charge_current(int ma);
+
+/**
+ * pm8921_disable_input_current_limt - disable input current limit
+ *
+ * @disable: disable input curren_limit limit
+ *
+ * Disabling the charge current limit causes current
+ * current limits to have no monitoring. An adequate charger
+ * capable of supplying high current while sustaining VIN_MIN
+ * is required if input current limiting is disabled.
+ */
+int pm8921_disable_input_current_limit(bool disable);
+
+/**
+ * pm8921_set_usb_power_supply_type - set USB supply type
+ *
+ * @type: power_supply_type enum
+ *
+ * This api lets one set a specific usb power_supply_type.
+ * USB drivers can distinguish between types of USB connections
+ * and set the appropriate type for the USB supply.
+ */
+
+int pm8921_set_usb_power_supply_type(enum power_supply_type type);
+
+/**
+ * pm8921_disable_source_current - disable drawing current from source
+ * @disable: true to disable current drawing from source false otherwise
+ *
+ * This function will stop all charging activities and disable any current
+ * drawn from the charger. The battery provides the system current.
+ */
+int pm8921_disable_source_current(bool disable);
+
+/**
+ * pm8921_regulate_input_voltage -
+ * @voltage: voltage in millivolts to regulate
+ *		allowable values are from 4300mV to 6500mV
+ */
+int pm8921_regulate_input_voltage(int voltage);
+/**
+ * pm8921_is_battery_charging -
+ * @source: when the battery is charging the source is updated to reflect which
+ *		charger, usb or dc, is charging the battery.
+ *
+ * RETURNS: bool, whether the battery is being charged or not
+ */
+bool pm8921_is_battery_charging(int *source);
+
+/**
+ * pm8921_batt_temperature - get battery temp in degC
+ *
+ */
+int pm8921_batt_temperature(void);
+/**
+ * pm8921_usb_ovp_set_threshold -
+ * Set the usb threshold as defined in by
+ * enum usb_ov_threshold
+ */
+int pm8921_usb_ovp_set_threshold(enum pm8921_usb_ov_threshold ov);
+
+/**
+ * pm8921_usb_ovp_set_hystersis -
+ * @ms: the debounce time enum
+ *
+ * Sets the debounce time for usb insertion/removal detection
+ *
+ */
+int pm8921_usb_ovp_set_hystersis(enum pm8921_usb_debounce_time ms);
+
+/**
+ * pm8921_usb_ovp_disable -
+ *
+ * when disabled there is no over voltage protection. The usb voltage is
+ * fed to the pmic as is. This should be disabled only when there is
+ * over voltage protection circuitry present outside the pmic chip.
+ *
+ */
+int pm8921_usb_ovp_disable(int disable);
+/**
+ * pm8921_is_batfet_closed - battery fet status
+ *
+ * Returns 1 if batfet is closed 0 if open. On configurations without
+ * batfet this will return 0.
+ */
+int pm8921_is_batfet_closed(void);
+#else
+static inline void pm8921_charger_vbus_draw(unsigned int mA)
+{
+}
+static inline int pm8921_charger_register_vbus_sn(void (*callback)(int))
+{
+	return -ENXIO;
+}
+static inline void pm8921_charger_unregister_vbus_sn(void (*callback)(int))
+{
+}
+static inline int pm8921_charger_enable(bool enable)
+{
+	return -ENXIO;
+}
+static inline int pm8921_is_usb_chg_plugged_in(void)
+{
+	return -ENXIO;
+}
+static inline int pm8921_is_dc_chg_plugged_in(void)
+{
+	return -ENXIO;
+}
+static inline int pm8921_is_battery_present(void)
+{
+	return -ENXIO;
+}
+static inline int pm8921_disable_input_current_limit(bool disable)
+{
+	return -ENXIO;
+}
+static inline int pm8921_set_usb_power_supply_type(enum power_supply_type type)
+{
+	return -ENXIO;
+}
+static inline int pm8921_set_max_battery_charge_current(int ma)
+{
+	return -ENXIO;
+}
+static inline int pm8921_disable_source_current(bool disable)
+{
+	return -ENXIO;
+}
+static inline int pm8921_regulate_input_voltage(int voltage)
+{
+	return -ENXIO;
+}
+static inline bool pm8921_is_battery_charging(int *source)
+{
+	*source = PM8921_CHG_SRC_NONE;
+	return 0;
+}
+static inline int pm8921_batt_temperature(void)
+{
+	return -ENXIO;
+}
+static inline int pm8921_usb_ovp_set_threshold(enum pm8921_usb_ov_threshold ov)
+{
+	return -ENXIO;
+}
+static inline int pm8921_usb_ovp_set_hystersis(enum pm8921_usb_debounce_time ms)
+{
+	return -ENXIO;
+}
+static inline int pm8921_usb_ovp_disable(int disable)
+{
+	return -ENXIO;
+}
+static inline int pm8921_is_batfet_closed(void)
+{
+	return 1;
+}
+#endif
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/pm8921.h b/include/linux/mfd/pm8xxx/pm8921.h
index 00fa3de..830ed30 100644
--- a/include/linux/mfd/pm8xxx/pm8921.h
+++ b/include/linux/mfd/pm8xxx/pm8921.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -18,13 +18,131 @@
 #ifndef __MFD_PM8921_H
 #define __MFD_PM8921_H
 
+#include <linux/device.h>
 #include <linux/mfd/pm8xxx/irq.h>
+#include <linux/mfd/pm8xxx/gpio.h>
+#include <linux/mfd/pm8xxx/mpp.h>
+#include <linux/mfd/pm8xxx/rtc.h>
+#include <linux/mfd/pm8xxx/pwm.h>
+#include <linux/mfd/pm8xxx/misc.h>
+#include <linux/mfd/pm8xxx/tm.h>
+#include <linux/mfd/pm8xxx/batt-alarm.h>
+#include <linux/input/pmic8xxx-pwrkey.h>
+#include <linux/input/pmic8xxx-keypad.h>
+#include <linux/regulator/pm8xxx-regulator.h>
+#include <linux/mfd/pm8xxx/pm8921-charger.h>
+#include <linux/mfd/pm8xxx/pm8xxx-adc.h>
+#include <linux/mfd/pm8xxx/pm8921-bms.h>
+#include <linux/leds-pm8xxx.h>
+#include <linux/mfd/pm8xxx/vibrator.h>
+#include <linux/mfd/pm8xxx/ccadc.h>
 
 #define PM8921_NR_IRQS		256
 
+#define PM8921_NR_GPIOS		44
+#define PM8917_NR_GPIOS		38
+
+#define PM8921_NR_MPPS		12
+#define PM8917_NR_MPPS		10
+
+#define PM8921_GPIO_BLOCK_START	24
+#define PM8921_MPP_BLOCK_START	16
+#define PM8921_IRQ_BLOCK_BIT(block, bit) ((block) * 8 + (bit))
+
+/* GPIOs and MPPs [1,N] */
+#define PM8921_GPIO_IRQ(base, gpio)	((base) + \
+		PM8921_IRQ_BLOCK_BIT(PM8921_GPIO_BLOCK_START, (gpio)-1))
+#define PM8921_MPP_IRQ(base, mpp)	((base) + \
+		PM8921_IRQ_BLOCK_BIT(PM8921_MPP_BLOCK_START, (mpp)-1))
+
+/* PMIC Interrupts */
+#define PM8921_RTC_ALARM_IRQ		PM8921_IRQ_BLOCK_BIT(4, 7)
+#define PM8921_BATT_ALARM_IRQ		PM8921_IRQ_BLOCK_BIT(5, 6)
+#define PM8921_PWRKEY_REL_IRQ		PM8921_IRQ_BLOCK_BIT(6, 2)
+#define PM8921_PWRKEY_PRESS_IRQ		PM8921_IRQ_BLOCK_BIT(6, 3)
+#define PM8921_KEYPAD_IRQ		PM8921_IRQ_BLOCK_BIT(9, 2)
+#define PM8921_KEYSTUCK_IRQ		PM8921_IRQ_BLOCK_BIT(9, 3)
+#define PM8921_ADC_EOC_USR_IRQ		PM8921_IRQ_BLOCK_BIT(9, 6)
+#define PM8921_ADC_BATT_TEMP_WARM_IRQ	PM8921_IRQ_BLOCK_BIT(9, 1)
+#define PM8921_ADC_BATT_TEMP_COLD_IRQ	PM8921_IRQ_BLOCK_BIT(9, 0)
+#define PM8921_USB_ID_IN_IRQ(base)	(base + PM8921_IRQ_BLOCK_BIT(6, 1))
+
+#define PM8921_USBIN_VALID_IRQ		PM8921_IRQ_BLOCK_BIT(1, 7)
+#define PM8921_USBIN_OV_IRQ		PM8921_IRQ_BLOCK_BIT(1, 6)
+#define PM8921_BATT_INSERTED_IRQ	PM8921_IRQ_BLOCK_BIT(1, 5)
+#define PM8921_VBATDET_LOW_IRQ		PM8921_IRQ_BLOCK_BIT(1, 4)
+#define PM8921_USBIN_UV_IRQ		PM8921_IRQ_BLOCK_BIT(1, 3)
+#define PM8921_VBAT_OV_IRQ		PM8921_IRQ_BLOCK_BIT(1, 2)
+#define PM8921_CHGWDOG_IRQ		PM8921_IRQ_BLOCK_BIT(1, 1)
+#define PM8921_VCP_IRQ			PM8921_IRQ_BLOCK_BIT(1, 0)
+#define PM8921_ATCDONE_IRQ		PM8921_IRQ_BLOCK_BIT(2, 7)
+#define PM8921_ATCFAIL_IRQ		PM8921_IRQ_BLOCK_BIT(2, 6)
+#define PM8921_CHGDONE_IRQ		PM8921_IRQ_BLOCK_BIT(2, 5)
+#define PM8921_CHGFAIL_IRQ		PM8921_IRQ_BLOCK_BIT(2, 4)
+#define PM8921_CHGSTATE_IRQ		PM8921_IRQ_BLOCK_BIT(2, 3)
+#define PM8921_LOOP_CHANGE_IRQ		PM8921_IRQ_BLOCK_BIT(2, 2)
+#define PM8921_FASTCHG_IRQ		PM8921_IRQ_BLOCK_BIT(2, 1)
+#define PM8921_TRKLCHG_IRQ		PM8921_IRQ_BLOCK_BIT(2, 0)
+#define PM8921_BATT_REMOVED_IRQ		PM8921_IRQ_BLOCK_BIT(3, 7)
+#define PM8921_BATTTEMP_HOT_IRQ		PM8921_IRQ_BLOCK_BIT(3, 6)
+#define PM8921_CHGHOT_IRQ		PM8921_IRQ_BLOCK_BIT(3, 5)
+#define PM8921_BATTTEMP_COLD_IRQ	PM8921_IRQ_BLOCK_BIT(3, 4)
+#define PM8921_CHG_GONE_IRQ		PM8921_IRQ_BLOCK_BIT(3, 3)
+#define PM8921_BAT_TEMP_OK_IRQ		PM8921_IRQ_BLOCK_BIT(3, 2)
+#define PM8921_COARSE_DET_LOW_IRQ	PM8921_IRQ_BLOCK_BIT(3, 1)
+#define PM8921_VDD_LOOP_IRQ		PM8921_IRQ_BLOCK_BIT(3, 0)
+#define PM8921_VREG_OV_IRQ		PM8921_IRQ_BLOCK_BIT(5, 7)
+#define PM8921_VBATDET_IRQ		PM8921_IRQ_BLOCK_BIT(5, 5)
+#define PM8921_BATFET_IRQ		PM8921_IRQ_BLOCK_BIT(5, 4)
+#define PM8921_PSI_IRQ			PM8921_IRQ_BLOCK_BIT(5, 3)
+#define PM8921_DCIN_VALID_IRQ		PM8921_IRQ_BLOCK_BIT(5, 2)
+#define PM8921_DCIN_OV_IRQ		PM8921_IRQ_BLOCK_BIT(5, 1)
+#define PM8921_DCIN_UV_IRQ		PM8921_IRQ_BLOCK_BIT(5, 0)
+
+#define PM8921_BMS_SBI_WRITE_OK		PM8921_IRQ_BLOCK_BIT(15, 7)
+#define PM8921_BMS_CC_THR		PM8921_IRQ_BLOCK_BIT(15, 6)
+#define PM8921_BMS_VSENSE_THR		PM8921_IRQ_BLOCK_BIT(15, 5)
+#define PM8921_BMS_VSENSE_FOR_R		PM8921_IRQ_BLOCK_BIT(15, 4)
+#define PM8921_BMS_OCV_FOR_R		PM8921_IRQ_BLOCK_BIT(15, 3)
+#define PM8921_BMS_GOOD_OCV		PM8921_IRQ_BLOCK_BIT(15, 2)
+#define PM8921_BMS_VSENSE_AVG		PM8921_IRQ_BLOCK_BIT(15, 1)
+#define PM8921_BMS_CCADC_EOC		PM8921_IRQ_BLOCK_BIT(15, 0)
+
+#define PM8921_OVERTEMP_IRQ		PM8921_IRQ_BLOCK_BIT(4, 2)
+#define PM8921_TEMPSTAT_IRQ		PM8921_IRQ_BLOCK_BIT(6, 7)
+#define PM8921_RESOUT_IRQ		PM8921_IRQ_BLOCK_BIT(6, 4)
+
+#define PM8921_USB_OTG_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(6, 0)
+#define PM8921_LVS7_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(13, 7)
+#define PM8921_LVS6_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(13, 6)
+#define PM8921_LVS5_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(13, 5)
+#define PM8921_LVS4_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(13, 4)
+#define PM8921_LVS3_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(13, 3)
+#define PM8921_LVS2_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(13, 2)
+#define PM8921_LVS1_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(13, 1)
+#define PM8921_HDMI_MVS_OCP_IRQ		PM8921_IRQ_BLOCK_BIT(13, 0)
+
+/* PMIC I/O Resources */
+#define PM8921_RTC_BASE 0x11D
+
 struct pm8921_platform_data {
 	int					irq_base;
 	struct pm8xxx_irq_platform_data		*irq_pdata;
+	struct pm8xxx_gpio_platform_data	*gpio_pdata;
+	struct pm8xxx_mpp_platform_data		*mpp_pdata;
+	struct pm8xxx_rtc_platform_data         *rtc_pdata;
+	struct pm8xxx_pwrkey_platform_data	*pwrkey_pdata;
+	struct pm8xxx_keypad_platform_data	*keypad_pdata;
+	struct pm8921_charger_platform_data	*charger_pdata;
+	struct pm8921_bms_platform_data		*bms_pdata;
+	struct pm8xxx_misc_platform_data	*misc_pdata;
+	struct pm8xxx_regulator_platform_data	*regulator_pdatas;
+	int					num_regulators;
+	struct pm8xxx_adc_platform_data		*adc_pdata;
+	struct pm8xxx_led_platform_data		*leds_pdata;
+	struct pm8xxx_vibrator_platform_data	*vibrator_pdata;
+	struct pm8xxx_ccadc_platform_data	*ccadc_pdata;
+	struct pm8xxx_pwm_platform_data		*pwm_pdata;
 };
 
 #endif
diff --git a/include/linux/mfd/pm8xxx/pm8xxx-adc.h b/include/linux/mfd/pm8xxx/pm8xxx-adc.h
new file mode 100644
index 0000000..f40633a
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/pm8xxx-adc.h
@@ -0,0 +1,604 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+ * Qualcomm PMIC 8921/8018 ADC driver header file
+ *
+ */
+
+#ifndef __PM8XXX_ADC_H
+#define __PM8XXX_ADC_H
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+
+/**
+ * enum pm8xxx_adc_channels - PM8XXX AMUX arbiter channels
+ * %CHANNEL_VCOIN: Backup voltage for certain register set
+ * %CHANNEL_VBAT: Battery voltage
+ * %CHANNEL_DCIN: Charger input voltage without internal OVP
+ * %CHANNEL_ICHG: Charge-current monitor
+ * %CHANNEL_VPH_PWR: Main system power
+ * %CHANNEL_IBAT: Battery charge current
+ * %CHANNEL_MPP_1: 16:1 pre-mux unity scale MPP input
+ * %CHANNEL_MPP_2: 16:1 pre-mux 1/3 scale MPP input
+ * %CHANNEL_BATT_THERM: Battery temperature
+ * %CHANNEL_BATT_ID: Battery detection
+ * %CHANNEL_USBIN: Charger input voltage with internal OVP
+ * %CHANNEL_DIE_TEMP: Pmic_die temperature
+ * %CHANNEL_625MV: 625mv reference channel
+ * %CHANNEL_125V: 1.25v reference channel
+ * %CHANNEL_CHG_TEMP: Charger temperature
+ * %CHANNEL_MUXOFF: Channel to reduce input load on the mux
+ * %CHANNEL_NONE: Do not use this channel
+ */
+enum pm8xxx_adc_channels {
+	CHANNEL_VCOIN = 0,
+	CHANNEL_VBAT,
+	CHANNEL_DCIN,
+	CHANNEL_ICHG,
+	CHANNEL_VPH_PWR,
+	CHANNEL_IBAT,
+	CHANNEL_MPP_1,
+	CHANNEL_MPP_2,
+	CHANNEL_BATT_THERM,
+	/* PM8018 ADC Arbiter uses a single channel on AMUX8
+	 * to read either Batt_id or Batt_therm.
+	 */
+	CHANNEL_BATT_ID_THERM = CHANNEL_BATT_THERM,
+	CHANNEL_BATT_ID,
+	CHANNEL_USBIN,
+	CHANNEL_DIE_TEMP,
+	CHANNEL_625MV,
+	CHANNEL_125V,
+	CHANNEL_CHG_TEMP,
+	CHANNEL_MUXOFF,
+	CHANNEL_NONE,
+	ADC_MPP_1_ATEST_8 = 20,
+	ADC_MPP_1_USB_SNS_DIV20,
+	ADC_MPP_1_DCIN_SNS_DIV20,
+	ADC_MPP_1_AMUX3,
+	ADC_MPP_1_AMUX4,
+	ADC_MPP_1_AMUX5,
+	ADC_MPP_1_AMUX6,
+	ADC_MPP_1_AMUX7,
+	ADC_MPP_1_AMUX8,
+	ADC_MPP_1_ATEST_1,
+	ADC_MPP_1_ATEST_2,
+	ADC_MPP_1_ATEST_3,
+	ADC_MPP_1_ATEST_4,
+	ADC_MPP_1_ATEST_5,
+	ADC_MPP_1_ATEST_6,
+	ADC_MPP_1_ATEST_7,
+	ADC_MPP_2_ATEST_8 = 40,
+	ADC_MPP_2_USB_SNS_DIV20,
+	ADC_MPP_2_DCIN_SNS_DIV20,
+	ADC_MPP_2_AMUX3,
+	ADC_MPP_2_AMUX4,
+	ADC_MPP_2_AMUX5,
+	ADC_MPP_2_AMUX6,
+	ADC_MPP_2_AMUX7,
+	ADC_MPP_2_AMUX8,
+	ADC_MPP_2_ATEST_1,
+	ADC_MPP_2_ATEST_2,
+	ADC_MPP_2_ATEST_3,
+	ADC_MPP_2_ATEST_4,
+	ADC_MPP_2_ATEST_5,
+	ADC_MPP_2_ATEST_6,
+	ADC_MPP_2_ATEST_7,
+	ADC_CHANNEL_MAX_NUM,
+};
+
+#define PM8XXX_ADC_PMIC_0	0x0
+
+#define PM8XXX_CHANNEL_ADC_625_UV	625000
+#define PM8XXX_CHANNEL_MPP_SCALE1_IDX	20
+#define PM8XXX_CHANNEL_MPP_SCALE3_IDX	40
+
+#define PM8XXX_AMUX_MPP_3	0x3
+#define PM8XXX_AMUX_MPP_4	0x4
+#define PM8XXX_AMUX_MPP_5	0x5
+#define PM8XXX_AMUX_MPP_6	0x6
+#define PM8XXX_AMUX_MPP_7	0x7
+#define PM8XXX_AMUX_MPP_8	0x8
+
+#define PM8XXX_ADC_DEV_NAME	"pm8xxx-adc"
+
+/**
+ * enum pm8xxx_adc_decimation_type - Sampling rate supported
+ * %ADC_DECIMATION_TYPE1: 512
+ * %ADC_DECIMATION_TYPE2: 1K
+ * %ADC_DECIMATION_TYPE3: 2K
+ * %ADC_DECIMATION_TYPE4: 4k
+ * %ADC_DECIMATION_NONE: Do not use this Sampling type
+ *
+ * The Sampling rate is specific to each channel of the PM8XXX ADC arbiter.
+ */
+enum pm8xxx_adc_decimation_type {
+	ADC_DECIMATION_TYPE1 = 0,
+	ADC_DECIMATION_TYPE2,
+	ADC_DECIMATION_TYPE3,
+	ADC_DECIMATION_TYPE4,
+	ADC_DECIMATION_NONE,
+};
+
+/**
+ * enum pm8xxx_adc_calib_type - PM8XXX ADC Calibration type
+ * %ADC_CALIB_ABSOLUTE: Use 625mV and 1.25V reference channels
+ * %ADC_CALIB_RATIOMETRIC: Use reference Voltage/GND
+ * %ADC_CALIB_CONFIG_NONE: Do not use this calibration type
+ *
+ * Use the input reference voltage depending on the calibration type
+ * to calcluate the offset and gain parameters. The calibration is
+ * specific to each channel of the PM8XXX ADC.
+ */
+enum pm8xxx_adc_calib_type {
+	ADC_CALIB_ABSOLUTE = 0,
+	ADC_CALIB_RATIOMETRIC,
+	ADC_CALIB_NONE,
+};
+
+/**
+ * enum pm8xxx_adc_channel_scaling_param - pre-scaling AMUX ratio
+ * %CHAN_PATH_SCALING1: ratio of {1, 1}
+ * %CHAN_PATH_SCALING2: ratio of {1, 3}
+ * %CHAN_PATH_SCALING3: ratio of {1, 4}
+ * %CHAN_PATH_SCALING4: ratio of {1, 6}
+ * %CHAN_PATH_NONE: Do not use this pre-scaling ratio type
+ *
+ * The pre-scaling is applied for signals to be within the voltage range
+ * of the ADC.
+ */
+enum pm8xxx_adc_channel_scaling_param {
+	CHAN_PATH_SCALING1 = 0,
+	CHAN_PATH_SCALING2,
+	CHAN_PATH_SCALING3,
+	CHAN_PATH_SCALING4,
+	CHAN_PATH_SCALING_NONE,
+};
+
+/**
+ * enum pm8xxx_adc_amux_input_rsv - HK/XOADC reference voltage
+ * %AMUX_RSV0: XO_IN/XOADC_GND
+ * %AMUX_RSV1: PMIC_IN/XOADC_GND
+ * %AMUX_RSV2: PMIC_IN/BMS_CSP
+ * %AMUX_RSV3: not used
+ * %AMUX_RSV4: XOADC_GND/XOADC_GND
+ * %AMUX_RSV5: XOADC_VREF/XOADC_GND
+ * %AMUX_NONE: Do not use this input reference voltage selection
+ */
+enum pm8xxx_adc_amux_input_rsv {
+	AMUX_RSV0 = 0,
+	AMUX_RSV1,
+	AMUX_RSV2,
+	AMUX_RSV3,
+	AMUX_RSV4,
+	AMUX_RSV5,
+	AMUX_NONE,
+};
+
+/**
+ * enum pm8xxx_adc_premux_mpp_scale_type - 16:1 pre-mux scale ratio
+ * %PREMUX_MPP_SCALE_0: No scaling to the input signal
+ * %PREMUX_MPP_SCALE_1: Unity scaling selected by the user for MPP input
+ * %PREMUX_MPP_SCALE_1_DIV3: 1/3 pre-scale to the input MPP signal
+ * %PREMUX_MPP_NONE: Do not use this pre-scale mpp type
+ */
+enum pm8xxx_adc_premux_mpp_scale_type {
+	PREMUX_MPP_SCALE_0 = 0,
+	PREMUX_MPP_SCALE_1,
+	PREMUX_MPP_SCALE_1_DIV3,
+	PREMUX_MPP_NONE,
+};
+
+/**
+ * enum pm8xxx_adc_scale_fn_type - Scaling function for pm8921 pre calibrated
+ *				   digital data relative to ADC reference
+ * %ADC_SCALE_DEFAULT: Default scaling to convert raw adc code to voltage
+ * %ADC_SCALE_BATT_THERM: Conversion to temperature based on btm parameters
+ * %ADC_SCALE_PMIC_THERM: Returns result in milli degree's Centigrade
+ * %ADC_SCALE_XTERN_CHGR_CUR: Returns current across 0.1 ohm resistor
+ * %ADC_SCALE_XOTHERM: Returns XO thermistor voltage in degree's Centigrade
+ * %ADC_SCALE_NONE: Do not use this scaling type
+ */
+enum pm8xxx_adc_scale_fn_type {
+	ADC_SCALE_DEFAULT = 0,
+	ADC_SCALE_BATT_THERM,
+	ADC_SCALE_PA_THERM,
+	ADC_SCALE_PMIC_THERM,
+	ADC_SCALE_XOTHERM,
+	ADC_SCALE_NONE,
+};
+
+/**
+ * struct pm8xxx_adc_linear_graph - Represent ADC characteristics
+ * @dy: Numerator slope to calculate the gain
+ * @dx: Denominator slope to calculate the gain
+ * @adc_vref: A/D word of the voltage reference used for the channel
+ * @adc_gnd: A/D word of the ground reference used for the channel
+ *
+ * Each ADC device has different offset and gain parameters which are computed
+ * to calibrate the device.
+ */
+struct pm8xxx_adc_linear_graph {
+	int64_t dy;
+	int64_t dx;
+	int64_t adc_vref;
+	int64_t adc_gnd;
+};
+
+/**
+ * struct pm8xxx_adc_map_pt - Map the graph representation for ADC channel
+ * @x: Represent the ADC digitized code
+ * @y: Represent the physical data which can be temperature, voltage,
+ *     resistance
+ */
+struct pm8xxx_adc_map_pt {
+	int32_t x;
+	int32_t y;
+};
+
+/**
+ * struct pm8xxx_adc_scaling_ratio - Represent scaling ratio for adc input
+ * @num: Numerator scaling parameter
+ * @den: Denominator scaling parameter
+ */
+struct pm8xxx_adc_scaling_ratio {
+	int32_t num;
+	int32_t den;
+};
+
+/**
+ * struct pm8xxx_adc_properties - Represent the ADC properties
+ * @adc_reference: Reference voltage for PM8XXX ADC
+ * @bitresolution: ADC bit resolution for PM8XXX ADC
+ * @biploar: Polarity for PM8XXX ADC
+ */
+struct pm8xxx_adc_properties {
+	uint32_t	adc_vdd_reference;
+	uint32_t	bitresolution;
+	bool		bipolar;
+};
+
+/**
+ * struct pm8xxx_adc_chan_properties - Represent channel properties of the ADC
+ * @offset_gain_numerator: The inverse numerator of the gain applied to the
+ *			   input channel
+ * @offset_gain_denominator: The inverse denominator of the gain applied to the
+ *			     input channel
+ * @adc_graph: ADC graph for the channel of struct type pm8xxx_adc_linear_graph
+ */
+struct pm8xxx_adc_chan_properties {
+	uint32_t			offset_gain_numerator;
+	uint32_t			offset_gain_denominator;
+	struct pm8xxx_adc_linear_graph	adc_graph[2];
+};
+
+/**
+ * struct pm8xxx_adc_chan_result - Represent the result of the PM8XXX ADC
+ * @chan: The channel number of the requested conversion
+ * @adc_code: The pre-calibrated digital output of a given ADC relative to the
+ *	      the ADC reference
+ * @measurement: In units specific for a given ADC; most ADC uses reference
+ *		 voltage but some ADC uses reference current. This measurement
+ *		 here is a number relative to a reference of a given ADC
+ * @physical: The data meaningful for each individual channel whether it is
+ *	      voltage, current, temperature, etc.
+ *	      All voltage units are represented in micro - volts.
+ *	      -Battery temperature units are represented as 0.1 DegC
+ *	      -PA Therm temperature units are represented as DegC
+ *	      -PMIC Die temperature units are represented as 0.001 DegC
+ */
+struct pm8xxx_adc_chan_result {
+	uint32_t	chan;
+	int32_t		adc_code;
+	int64_t		measurement;
+	int64_t		physical;
+};
+
+#if defined(CONFIG_SENSORS_PM8XXX_ADC)					\
+			|| defined(CONFIG_SENSORS_PM8XXX_ADC_MODULE)
+/**
+ * pm8xxx_adc_scale_default() - Scales the pre-calibrated digital output
+ *		of an ADC to the ADC reference and compensates for the
+ *		gain and offset.
+ * @adc_code:	pre-calibrated digital ouput of the ADC.
+ * @adc_prop:	adc properties of the pm8xxx adc such as bit resolution,
+ *		reference voltage.
+ * @chan_prop:	individual channel properties to compensate the i/p scaling,
+ *		slope and offset.
+ * @chan_rslt:	Physical result to be stored.
+ */
+int32_t pm8xxx_adc_scale_default(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt);
+/**
+ * pm8xxx_adc_scale_tdkntcg_therm() - Scales the pre-calibrated digital output
+ *		of an ADC to the ADC reference and compensates for the
+ *		gain and offset. Returns the temperature of the xo therm in mili
+		degC.
+ * @adc_code:	pre-calibrated digital ouput of the ADC.
+ * @adc_prop:	adc properties of the pm8xxx adc such as bit resolution,
+ *		reference voltage.
+ * @chan_prop:	individual channel properties to compensate the i/p scaling,
+ *		slope and offset.
+ * @chan_rslt:	physical result to be stored.
+ */
+int32_t pm8xxx_adc_tdkntcg_therm(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt);
+/**
+ * pm8xxx_adc_scale_batt_therm() - Scales the pre-calibrated digital output
+ *		of an ADC to the ADC reference and compensates for the
+ *		gain and offset. Returns the temperature in degC.
+ * @adc_code:	pre-calibrated digital ouput of the ADC.
+ * @adc_prop:	adc properties of the pm8xxx adc such as bit resolution,
+ *		reference voltage.
+ * @chan_prop:	individual channel properties to compensate the i/p scaling,
+ *		slope and offset.
+ * @chan_rslt:	physical result to be stored.
+ */
+int32_t pm8xxx_adc_scale_batt_therm(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt);
+/**
+ * pm8xxx_adc_scale_pa_therm() - Scales the pre-calibrated digital output
+ *		of an ADC to the ADC reference and compensates for the
+ *		gain and offset. Returns the temperature in degC.
+ * @adc_code:	pre-calibrated digital ouput of the ADC.
+ * @adc_prop:	adc properties of the pm8xxx adc such as bit resolution,
+ *		reference voltage.
+ * @chan_prop:	individual channel properties to compensate the i/p scaling,
+ *		slope and offset.
+ * @chan_rslt:	physical result to be stored.
+ */
+int32_t pm8xxx_adc_scale_pa_therm(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt);
+/**
+ * pm8xxx_adc_scale_pmic_therm() - Scales the pre-calibrated digital output
+ *		of an ADC to the ADC reference and compensates for the
+ *		gain and offset. Performs the AMUX out as 2mv/K and returns
+ *		the temperature in mili degC.
+ * @adc_code:	pre-calibrated digital ouput of the ADC.
+ * @adc_prop:	adc properties of the pm8xxx adc such as bit resolution,
+ *		reference voltage.
+ * @chan_prop:	individual channel properties to compensate the i/p scaling,
+ *		slope and offset.
+ * @chan_rslt:	physical result to be stored.
+ */
+int32_t pm8xxx_adc_scale_pmic_therm(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt);
+/**
+ * pm8xxx_adc_scale_batt_id() - Scales the pre-calibrated digital output
+ *		of an ADC to the ADC reference and compensates for the
+ *		gain and offset.
+ * @adc_code:	pre-calibrated digital ouput of the ADC.
+ * @adc_prop:	adc properties of the pm8xxx adc such as bit resolution,
+ *		reference voltage.
+ * @chan_prop:	individual channel properties to compensate the i/p scaling,
+ *		slope and offset.
+ * @chan_rslt:	physical result to be stored.
+ */
+int32_t pm8xxx_adc_scale_batt_id(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt);
+#else
+static inline int32_t pm8xxx_adc_scale_default(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt)
+{ return -ENXIO; }
+static inline int32_t pm8xxx_adc_tdkntcg_therm(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt)
+{ return -ENXIO; }
+static inline int32_t pm8xxx_adc_scale_batt_therm(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt)
+{ return -ENXIO; }
+static inline int32_t pm8xxx_adc_scale_pa_therm(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt)
+{ return -ENXIO; }
+static inline int32_t pm8xxx_adc_scale_pmic_therm(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt)
+{ return -ENXIO; }
+static inline int32_t pm8xxx_adc_scale_batt_id(int32_t adc_code,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop,
+			struct pm8xxx_adc_chan_result *chan_rslt)
+{ return -ENXIO; }
+#endif
+
+/**
+ * struct pm8xxx_adc_scale_fn - Scaling function prototype
+ * @chan: Function pointer to one of the scaling functions
+ *	which takes the adc properties, channel properties,
+ *	and returns the physical result
+ */
+struct pm8xxx_adc_scale_fn {
+	int32_t (*chan) (int32_t,
+		const struct pm8xxx_adc_properties *,
+		const struct pm8xxx_adc_chan_properties *,
+		struct pm8xxx_adc_chan_result *);
+};
+
+/**
+ * struct pm8xxx_adc_amux - AMUX properties for individual channel
+ * @name: Channel name
+ * @channel_name: Channel in integer used from pm8xxx_adc_channels
+ * @chan_path_prescaling: Channel scaling performed on the input signal
+ * @adc_rsv: Input reference Voltage/GND selection to the ADC
+ * @adc_decimation: Sampling rate desired for the channel
+ * adc_scale_fn: Scaling function to convert to the data meaningful for
+ *		 each individual channel whether it is voltage, current,
+ *		 temperature, etc and compensates the channel properties
+ */
+struct pm8xxx_adc_amux {
+	char					*name;
+	enum pm8xxx_adc_channels		channel_name;
+	enum pm8xxx_adc_channel_scaling_param	chan_path_prescaling;
+	enum pm8xxx_adc_amux_input_rsv		adc_rsv;
+	enum pm8xxx_adc_decimation_type		adc_decimation;
+	enum pm8xxx_adc_scale_fn_type		adc_scale_fn;
+};
+
+/**
+ * struct pm8xxx_adc_arb_btm_param - PM8XXX ADC BTM parameters to set threshold
+ *				     temperature for client notification
+ * @low_thr_temp: low temperature threshold request for notification
+ * @high_thr_temp: high temperature threshold request for notification
+ * @low_thr_voltage: low temperature converted to voltage by arbiter driver
+ * @high_thr_voltage: high temperature converted to voltage by arbiter driver
+ * @interval: Interval period to check for temperature notification
+ * @btm_warm_fn: Remote function call for warm threshold.
+ * @btm_cool_fn: Remote function call for cold threshold.
+ *
+ * BTM client passes the parameters to be set for the
+ * temperature threshold notifications. The client is
+ * responsible for setting the new threshold
+ * levels once the thresholds are reached
+ */
+struct pm8xxx_adc_arb_btm_param {
+	int32_t		low_thr_temp;
+	int32_t		high_thr_temp;
+	uint64_t	low_thr_voltage;
+	uint64_t	high_thr_voltage;
+	int32_t		interval;
+	void		(*btm_warm_fn) (bool);
+	void		(*btm_cool_fn) (bool);
+};
+
+int32_t pm8xxx_adc_batt_scaler(struct pm8xxx_adc_arb_btm_param *,
+			const struct pm8xxx_adc_properties *adc_prop,
+			const struct pm8xxx_adc_chan_properties *chan_prop);
+/**
+ * struct pm8xxx_adc_platform_data - PM8XXX ADC platform data
+ * @adc_prop: ADC specific parameters, voltage and channel setup
+ * @adc_channel: Channel properties of the ADC arbiter
+ * @adc_num_board_channel: Number of channels added in the board file
+ * @adc_mpp_base: PM8XXX MPP0 base passed from board file. This is used
+ *		  to offset the PM8XXX MPP passed to configure the
+ *		  the MPP to AMUX mapping.
+ */
+struct pm8xxx_adc_platform_data {
+	struct pm8xxx_adc_properties	*adc_prop;
+	struct pm8xxx_adc_amux		*adc_channel;
+	uint32_t			adc_num_board_channel;
+	uint32_t			adc_mpp_base;
+};
+
+/* Public API */
+#if defined(CONFIG_SENSORS_PM8XXX_ADC)				\
+			|| defined(CONFIG_SENSORS_PM8XXX_ADC_MODULE)
+/**
+ * pm8xxx_adc_read() - Performs ADC read on the channel.
+ * @channel:	Input channel to perform the ADC read.
+ * @result:	Structure pointer of type adc_chan_result
+ *		in which the ADC read results are stored.
+ */
+uint32_t pm8xxx_adc_read(enum pm8xxx_adc_channels channel,
+				struct pm8xxx_adc_chan_result *result);
+/**
+ * pm8xxx_adc_mpp_config_read() - Configure's the PM8XXX MPP
+ * to AMUX6 and performs an ADC read.
+ *
+ * On PM8921 ADC the MPP needs to first be configured
+ * as an analog input to the AMUX pre-mux channel before
+ * issuing a read request. PM8921 MPP 8 is mapped to AMUX8
+ * and is common between remote processor's.
+ *
+ * On PM8018 ADC the MPP is directly connected to the AMUX
+ * pre-mux. Therefore clients of the PM8018 MPP do not need
+ * to configure the MPP as an analog input to the pre-mux.
+ * Clients can directly issue request on the pre-mux AMUX
+ * channel to read the ADC on the MPP. Clients can directly
+ * call the pm8xxx_adc_read().
+ * @mpp_num	PM8XXX MPP number to configure to AMUX6.
+ * @channel:	Input channel to perform the ADC read.
+ *		a) 'ADC_MPP_1_AMUX6' if the input voltage is less than 1.8V
+ *		b) 'ADC_MPP_2_AMUX6' if the input voltage is greater then 1.8V
+ *		the input voltage is pre-divided by 3 and passed to the ADC.
+ *		The appropriate scaling function needs to be selected to let
+ *		the driver know a post scaling is required before returning
+ *		the result.
+ * @result:	Structure pointer of type adc_chan_result
+ *		in which the ADC read results are stored.
+ */
+uint32_t pm8xxx_adc_mpp_config_read(uint32_t mpp_num,
+				enum pm8xxx_adc_channels channel,
+				struct pm8xxx_adc_chan_result *result);
+/**
+ * pm8xxx_adc_btm_start() - Configure the BTM registers and start
+			monitoring the BATT_THERM channel for
+			threshold warm/cold temperature set
+			by the Battery client. The btm_start
+			api is to be used after calling the
+			pm8xxx_btm_configure() api which sets
+			the temperature thresholds, interval
+			and functions to call when warm/cold
+			events are triggered.
+ * @param:	none.
+ */
+uint32_t pm8xxx_adc_btm_start(void);
+
+/**
+ * pm8xxx_adc_btm_end() - Configures the BTM registers to stop
+ *			monitoring the BATT_THERM channel for
+ *			warm/cold events and disables the
+ *			interval timer.
+ * @param:	none.
+ */
+uint32_t pm8xxx_adc_btm_end(void);
+
+/**
+ * pm8xxx_adc_btm_configure() - Configures the BATT_THERM channel
+ *			parameters for warm/cold thresholds.
+ *			Sets the interval timer for perfoming
+ *			reading the temperature done by the HW.
+ * @btm_param:		Structure pointer of type adc_arb_btm_param *
+ *			which client provides for threshold warm/cold,
+ *			interval and functions to call when warm/cold
+ *			events are triggered.
+ */
+uint32_t pm8xxx_adc_btm_configure(struct pm8xxx_adc_arb_btm_param *);
+#else
+static inline uint32_t pm8xxx_adc_read(uint32_t channel,
+				struct pm8xxx_adc_chan_result *result)
+{ return -ENXIO; }
+static inline uint32_t pm8xxx_adc_mpp_config_read(uint32_t mpp_num,
+				enum pm8xxx_adc_channels channel,
+				struct pm8xxx_adc_chan_result *result)
+{ return -ENXIO; }
+static inline uint32_t pm8xxx_adc_btm_start(void)
+{ return -ENXIO; }
+static inline uint32_t pm8xxx_adc_btm_end(void)
+{ return -ENXIO; }
+static inline uint32_t pm8xxx_adc_btm_configure(
+		struct pm8xxx_adc_arb_btm_param *param)
+{ return -ENXIO; }
+#endif
+
+#endif /* PM8XXX_ADC_H */
diff --git a/include/linux/mfd/pm8xxx/pwm.h b/include/linux/mfd/pm8xxx/pwm.h
new file mode 100644
index 0000000..6d95e3a
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/pwm.h
@@ -0,0 +1,169 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PM8XXX_PWM_H__
+#define __PM8XXX_PWM_H__
+
+#include <linux/pwm.h>
+
+#define PM8XXX_PWM_DEV_NAME	"pm8xxx-pwm"
+
+#define PM8XXX_PWM_PERIOD_MIN	7 /* usec: 19.2M, n=6, m=0, pre=2 */
+#define PM8XXX_PWM_PERIOD_MAX	(384 * USEC_PER_SEC) /* 1K, n=9, m=7, pre=6 */
+#define PM_PWM_LUT_SIZE			64
+#define PM_PWM_LUT_DUTY_TIME_MAX	512	/* ms */
+#define PM_PWM_LUT_PAUSE_MAX		(7000 * PM_PWM_LUT_DUTY_TIME_MAX)
+
+/* Flags for Look Up Table */
+#define PM_PWM_LUT_LOOP		0x01
+#define PM_PWM_LUT_RAMP_UP	0x02
+#define PM_PWM_LUT_REVERSE	0x04
+#define PM_PWM_LUT_PAUSE_HI_EN	0x10
+#define PM_PWM_LUT_PAUSE_LO_EN	0x20
+
+#define PM_PWM_LUT_NO_TABLE	0x100
+
+/**
+ * PWM frequency/period control
+ *
+ * PWM Frequency = ClockFrequency / (N * T)
+ *   or
+ * PWM Period = Clock Period * (N * T)
+ *   where
+ * N = 2^9 or 2^6 for 9-bit or 6-bit PWM size
+ * T = Pre-divide * 2^m, m = 0..7 (exponent)
+ *
+ */
+
+enum pm_pwm_size {
+	PM_PWM_SIZE_6BIT =	6,
+	PM_PWM_SIZE_9BIT =	9,
+};
+
+enum pm_pwm_clk {
+	PM_PWM_CLK_1KHZ,
+	PM_PWM_CLK_32KHZ,
+	PM_PWM_CLK_19P2MHZ,
+};
+
+enum pm_pwm_pre_div {
+	PM_PWM_PDIV_2,
+	PM_PWM_PDIV_3,
+	PM_PWM_PDIV_5,
+	PM_PWM_PDIV_6,
+};
+
+/**
+ * struct pm8xxx_pwm_period - PWM period structure
+ * @pwm_size: enum pm_pwm_size
+ * @clk: enum pm_pwm_clk
+ * @pre_div: enum pm_pwm_pre_div
+ * @pre_div_exp: exponent of 2 as part of pre-divider: 0..7
+ */
+struct pm8xxx_pwm_period {
+	enum pm_pwm_size	pwm_size;
+	enum pm_pwm_clk		clk;
+	enum pm_pwm_pre_div	pre_div;
+	int			pre_div_exp;
+};
+
+/**
+ * struct pm8xxx_pwm_duty_cycles - PWM duty cycle info
+ * duty_pcts - pointer to an array of duty percentage for a pwm period
+ * num_duty_pcts - total entries in duty_pcts array
+ * duty_ms - duty cycle time in ms
+ * start_idx - index in the LUT
+ */
+struct pm8xxx_pwm_duty_cycles {
+	int *duty_pcts;
+	int num_duty_pcts;
+	int duty_ms;
+	int start_idx;
+};
+
+/**
+ * struct pm8xxx_pwm_platform_data - PWM platform data
+ * dtest_channel - Enable LPG DTEST mode for this LPG channel
+ */
+struct pm8xxx_pwm_platform_data {
+	int dtest_channel;
+};
+
+/**
+ * pm8xxx_pwm_config_period - change PWM period
+ *
+ * @pwm: the PWM device
+ * @pwm_p: period in struct pm8xxx_pwm_period
+ */
+int pm8xxx_pwm_config_period(struct pwm_device *pwm,
+			     struct pm8xxx_pwm_period *pwm_p);
+
+/**
+ * pm8xxx_pwm_config_pwm_value - change a PWM device configuration
+ * @pwm: the PWM device
+ * @pwm_value: the duty cycle in raw PWM value (< 2^pwm_size)
+ */
+int pm8xxx_pwm_config_pwm_value(struct pwm_device *pwm, int pwm_value);
+
+/**
+ * pm8xxx_pwm_lut_config - change a PWM device configuration to use LUT
+ * @pwm: the PWM device
+ * @period_us: period in micro second
+ * @duty_pct: arrary of duty cycles in percent, like 20, 50.
+ * @duty_time_ms: time for each duty cycle in millisecond
+ * @start_idx: start index in lookup table from 0 to MAX-1
+ * @idx_len: number of index
+ * @pause_lo: pause time in millisecond at low index
+ * @pause_hi: pause time in millisecond at high index
+ * @flags: control flags
+ */
+int pm8xxx_pwm_lut_config(struct pwm_device *pwm, int period_us,
+			  int duty_pct[], int duty_time_ms, int start_idx,
+			  int len, int pause_lo, int pause_hi, int flags);
+
+/**
+ * pm8xxx_pwm_lut_enable - control a PWM device to start/stop LUT ramp
+ * @pwm: the PWM device
+ * @start: to start (1), or stop (0)
+ */
+int pm8xxx_pwm_lut_enable(struct pwm_device *pwm, int start);
+
+/* Standard APIs supported */
+/**
+ * pwm_request - request a PWM device
+ * @pwm_id: PWM id or channel
+ * @label: the label to identify the user
+ */
+
+/**
+ * pwm_free - free a PWM device
+ * @pwm: the PWM device
+ */
+
+/**
+ * pwm_config - change a PWM device configuration
+ * @pwm: the PWM device
+ * @period_us: period in microsecond
+ * @duty_us: duty cycle in microsecond
+ */
+
+/**
+ * pwm_enable - start a PWM output toggling
+ * @pwm: the PWM device
+ */
+
+/**
+ * pwm_disable - stop a PWM output toggling
+ * @pwm: the PWM device
+ */
+
+#endif /* __PM8XXX_PWM_H__ */
diff --git a/include/linux/mfd/pm8xxx/regulator.h b/include/linux/mfd/pm8xxx/regulator.h
new file mode 100644
index 0000000..31c2684
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/regulator.h
@@ -0,0 +1,271 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MFD_PM8XXX_REGULATOR_H__
+#define __MFD_PM8XXX_REGULATOR_H__
+
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/pm8xxx-regulator.h>
+
+/**
+ * enum pm8xxx_regulator_type - possible PM8XXX voltage regulator types
+ * %PM8XXX_REGULATOR_TYPE_PLDO:		PMOS low drop-out linear regulator
+ * %PM8XXX_REGULATOR_TYPE_NLDO:		NMOS low drop-out linear regulator
+ * %PM8XXX_REGULATOR_TYPE_NLDO1200:	NMOS low drop-out linear regulator
+ *					capable of supplying up to 1200 mA
+ * %PM8XXX_REGULATOR_TYPE_SMPS:		switched-mode power supply (buck)
+ * %PM8XXX_REGULATOR_TYPE_FTSMPS:	fast transient switched-mode power
+ *					supply (buck)
+ * %PM8XXX_REGULATOR_TYPE_VS:		voltage switch capable of sourcing 100mA
+ * %PM8XXX_REGULATOR_TYPE_VS300:	voltage switch capable of sourcing 300mA
+ * %PM8XXX_REGULATOR_TYPE_NCP:		negative charge pump
+ * %PM8XXX_REGULATOR_TYPE_BOOST:	boost regulator
+ * %PM8XXX_REGULATOR_TYPE_MAX:		used internally for error checking; not
+ *					a valid regulator type.
+ *
+ * Each of these has a different register control interface.
+ */
+enum pm8xxx_regulator_type {
+	PM8XXX_REGULATOR_TYPE_PLDO,
+	PM8XXX_REGULATOR_TYPE_NLDO,
+	PM8XXX_REGULATOR_TYPE_NLDO1200,
+	PM8XXX_REGULATOR_TYPE_SMPS,
+	PM8XXX_REGULATOR_TYPE_FTSMPS,
+	PM8XXX_REGULATOR_TYPE_VS,
+	PM8XXX_REGULATOR_TYPE_VS300,
+	PM8XXX_REGULATOR_TYPE_NCP,
+	PM8XXX_REGULATOR_TYPE_BOOST,
+	PM8XXX_REGULATOR_TYPE_MAX,
+};
+
+/**
+ * struct pm8xxx_vreg - regulator configuration and state data used by the
+ *		pm8xxx-regulator driver
+ * @rdesc:		regulator description
+ * @rdesc_pc:		pin control regulator description. rdesc_pc.name == NULL
+ *			implies that there is no pin control version of this
+ *			regulator.
+ * @type:		regulator type
+ * @hpm_min_load:	minimum load in uA that will result in the regulator
+ *			being set to high power mode
+ * @ctrl_addr:		control register SSBI address
+ * @test_addr:		test register SSBI address (not needed for all types)
+ * @clk_ctrl_addr:	clock control register SSBI address (only used by SMPS
+ *			type regulators)
+ * @sleep_ctrl_addr:	sleep control register SSBI address (only used by SMPS
+ *			type regulators)
+ * @pfm_ctrl_addr:	pulse-frequency modulation control register SSBI address
+ *			(only used by FTSMPS type regulators)
+ * @pwr_cnfg_addr:	power configuration register SSBI address (only used by
+ *			FTSMPS type regulators)
+ * @pdata:		this platform data struct is filled based using the
+ *			platform data pointed to in a core platform data struct
+ * @rdev:		pointer to regulator device which is created with
+ *			regulator_register
+ * @rdev_pc:		pointer to pin controlled regulator device which is
+ *			created with regulator_register
+ * @dev:		pointer to pm8xxx-regulator device
+ * @dev_pc:		pointer to pin control pm8xxx-regulator device
+ * @pc_lock:		mutex lock to handle sharing between pin controlled and
+ *			non-pin controlled versions of a given regulator.  Note,
+ *			this lock must be initialized in the PMIC core driver.)
+ * @save_uV:		current regulator voltage in uV
+ * @mode:		current mode of the regulator
+ * @write_count:	number of SSBI writes that have taken place for this
+ *			regulator. This is used for debug printing to determine
+ *			if a given operation is redundant.
+ * @prev_write_count:	number of SSBI writes that have taken place for this
+ *			regulator at the start of an operation. This is used for
+ *			debug printing to determine if a given operation is
+ *			redundant.
+ * @is_enabled:		true if the regulator is currently enabled, false if not
+ * @is_enabled_pc:	true if the pin controlled version of the regulator is
+ *			currently enabled (i.e. pin control is active), false if
+ *			not
+ * @test_reg:		last value read from or written to each of the banks of
+ *			the test register
+ * @ctrl_reg:		last value read from or written to the control register
+ * @clk_ctrl_reg:	last value read from or written to the clock control
+ *			register
+ * @sleep_ctrl_reg:	last value read from or written to the sleep control
+ *			register
+ * @pfm_ctrl_reg:	last value read from or written to the PFM control
+ *			register
+ * @pwr_cnfg_reg:	last value read from or written to the power
+ *			configuration register
+ *
+ * This data structure should only need to be instantiated in a PMIC core driver
+ * It is used to specify PMIC specific as opposed to board specific
+ * configuration data.  It is also used to hold all state variables needed by
+ * the pm8xxx-regulator driver as these variables need to be shared between
+ * pin controlled and non-pin controlled versions of a given regulator, which
+ * are probed separately.
+ */
+struct pm8xxx_vreg {
+	/* Configuration data */
+	struct regulator_desc			rdesc;
+	struct regulator_desc			rdesc_pc;
+	enum pm8xxx_regulator_type		type;
+	const int				hpm_min_load;
+	const u16				ctrl_addr;
+	const u16				test_addr;
+	const u16				clk_ctrl_addr;
+	const u16				sleep_ctrl_addr;
+	const u16				pfm_ctrl_addr;
+	const u16				pwr_cnfg_addr;
+	/* State data */
+	struct pm8xxx_regulator_platform_data	pdata;
+	struct regulator_dev			*rdev;
+	struct regulator_dev			*rdev_pc;
+	struct device				*dev;
+	struct device				*dev_pc;
+	struct mutex				pc_lock;
+	int					save_uV;
+	int					mode;
+	u32					write_count;
+	u32					prev_write_count;
+	bool					is_enabled;
+	bool					is_enabled_pc;
+	u8				test_reg[REGULATOR_TEST_BANKS_MAX];
+	u8					ctrl_reg;
+	u8					clk_ctrl_reg;
+	u8					sleep_ctrl_reg;
+	u8					pfm_ctrl_reg;
+	u8					pwr_cnfg_reg;
+};
+
+/**
+ * struct pm8xxx_regulator_core_platform_data - platform data specified in a
+ *		PMIC core driver and utilized in the pm8xxx-regulator driver
+* @vreg:		pointer to pm8xxx_vreg data structure that may be shared
+*			between pin controlled and non-pin controlled versions
+*			of a given regulator.  Note that this data must persist
+*			as long as the regulator device is in use.
+* @pdata:		pointer to platform data passed in from a board file
+* @is_pin_controlled:	true if the regulator driver represents the pin control
+*			portion of a regulator, false if not.
+*
+* This data structure should only be needed in a PMIC core driver.
+*/
+struct pm8xxx_regulator_core_platform_data {
+	struct pm8xxx_vreg			*vreg;
+	struct pm8xxx_regulator_platform_data	*pdata;
+	bool					is_pin_controlled;
+};
+
+/* Helper macros */
+#define PLDO(_name, _pc_name, _ctrl_addr, _test_addr, _hpm_min_load) \
+	{ \
+		.type		= PM8XXX_REGULATOR_TYPE_PLDO, \
+		.ctrl_addr	= _ctrl_addr, \
+		.test_addr	= _test_addr, \
+		.hpm_min_load	= PM8XXX_VREG_##_hpm_min_load##_HPM_MIN_LOAD, \
+		.rdesc.name	= _name, \
+		.rdesc_pc.name	= _pc_name, \
+		.write_count	= 0, \
+		.prev_write_count = -1, \
+	}
+
+#define NLDO(_name, _pc_name, _ctrl_addr, _test_addr, _hpm_min_load) \
+	{ \
+		.type		= PM8XXX_REGULATOR_TYPE_NLDO, \
+		.ctrl_addr	= _ctrl_addr, \
+		.test_addr	= _test_addr, \
+		.hpm_min_load	= PM8XXX_VREG_##_hpm_min_load##_HPM_MIN_LOAD, \
+		.rdesc.name	= _name, \
+		.rdesc_pc.name	= _pc_name, \
+		.write_count	= 0, \
+		.prev_write_count = -1, \
+	}
+
+#define NLDO1200(_name, _ctrl_addr, _test_addr, _hpm_min_load) \
+	{ \
+		.type		= PM8XXX_REGULATOR_TYPE_NLDO1200, \
+		.ctrl_addr	= _ctrl_addr, \
+		.test_addr	= _test_addr, \
+		.hpm_min_load	= PM8XXX_VREG_##_hpm_min_load##_HPM_MIN_LOAD, \
+		.rdesc.name	= _name, \
+		.write_count	= 0, \
+		.prev_write_count = -1, \
+	}
+
+#define SMPS(_name, _pc_name, _ctrl_addr, _test_addr, _clk_ctrl_addr, \
+	     _sleep_ctrl_addr, _hpm_min_load) \
+	{ \
+		.type		= PM8XXX_REGULATOR_TYPE_SMPS, \
+		.ctrl_addr	= _ctrl_addr, \
+		.test_addr	= _test_addr, \
+		.clk_ctrl_addr	= _clk_ctrl_addr, \
+		.sleep_ctrl_addr = _sleep_ctrl_addr, \
+		.hpm_min_load	= PM8XXX_VREG_##_hpm_min_load##_HPM_MIN_LOAD, \
+		.rdesc.name	= _name, \
+		.rdesc_pc.name	= _pc_name, \
+		.write_count	= 0, \
+		.prev_write_count = -1, \
+	}
+
+#define FTSMPS(_name, _pwm_ctrl_addr, _fts_cnfg1_addr, _pfm_ctrl_addr, \
+	       _pwr_cnfg_addr, _hpm_min_load) \
+	{ \
+		.type		= PM8XXX_REGULATOR_TYPE_FTSMPS, \
+		.ctrl_addr	= _pwm_ctrl_addr, \
+		.test_addr	= _fts_cnfg1_addr, \
+		.pfm_ctrl_addr = _pfm_ctrl_addr, \
+		.pwr_cnfg_addr = _pwr_cnfg_addr, \
+		.hpm_min_load	= PM8XXX_VREG_##_hpm_min_load##_HPM_MIN_LOAD, \
+		.rdesc.name	= _name, \
+		.write_count	= 0, \
+		.prev_write_count = -1, \
+	}
+
+#define VS(_name, _pc_name, _ctrl_addr, _test_addr) \
+	{ \
+		.type		= PM8XXX_REGULATOR_TYPE_VS, \
+		.ctrl_addr	= _ctrl_addr, \
+		.test_addr	= _test_addr, \
+		.rdesc.name	= _name, \
+		.rdesc_pc.name	= _pc_name, \
+		.write_count	= 0, \
+		.prev_write_count = -1, \
+	}
+
+#define VS300(_name, _ctrl_addr, _test_addr) \
+	{ \
+		.type		= PM8XXX_REGULATOR_TYPE_VS300, \
+		.ctrl_addr	= _ctrl_addr, \
+		.test_addr	= _test_addr, \
+		.rdesc.name	= _name, \
+		.write_count	= 0, \
+		.prev_write_count = -1, \
+	}
+
+#define NCP(_name, _ctrl_addr) \
+	{ \
+		.type		= PM8XXX_REGULATOR_TYPE_NCP, \
+		.ctrl_addr	= _ctrl_addr, \
+		.rdesc.name	= _name, \
+		.write_count	= 0, \
+		.prev_write_count = -1, \
+	}
+
+#define BOOST(_name, _ctrl_addr) \
+	{ \
+		.type		= PM8XXX_REGULATOR_TYPE_BOOST, \
+		.ctrl_addr	= _ctrl_addr, \
+		.rdesc.name	= _name, \
+		.write_count	= 0, \
+		.prev_write_count = -1, \
+	}
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/rtc.h b/include/linux/mfd/pm8xxx/rtc.h
index 14f1983..2ce37a0 100644
--- a/include/linux/mfd/pm8xxx/rtc.h
+++ b/include/linux/mfd/pm8xxx/rtc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -20,6 +20,7 @@
  */
 struct pm8xxx_rtc_platform_data {
 	bool rtc_write_enable;
+	bool rtc_alarm_powerup;
 };
 
 #endif /* __RTC_PM8XXX_H__ */
diff --git a/include/linux/mfd/pm8xxx/spk.h b/include/linux/mfd/pm8xxx/spk.h
new file mode 100644
index 0000000..9835b85
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/spk.h
@@ -0,0 +1,55 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPK_PM8XXX_H__
+#define __SPK_PM8XXX_H__
+
+#define PM8XXX_SPK_DEV_NAME     "pm8xxx-spk"
+
+/**
+ * struct pm8xxx_spk_pdata - SPK driver platform data
+ * @spk_add_enable: variable stating SPK secondary input adding capability
+ */
+struct pm8xxx_spk_platform_data {
+	bool spk_add_enable;
+	int cd_ng_threshold;
+	int cd_nf_preamp_bias;
+	int cd_ng_hold;
+	int cd_ng_max_atten;
+	int noise_mute;
+	int cd_ng_decay_rate;
+	int cd_ng_attack_rate;
+	int cd_delay;
+};
+
+/*
+ * pm8xxx_spk_mute - mute/unmute speaker pamp
+ *
+ * @mute: bool value for mute
+ */
+int pm8xxx_spk_mute(bool mute);
+
+/*
+ * pm8xxx_spk_gain - Set Speaker gain
+ *
+ * @gain: Speaker gain
+ */
+int pm8xxx_spk_gain(u8 gain);
+
+/*
+ * pm8xxx_spk_enable - Enable/Disable Speaker
+ *
+ * @enable: bool enable/disable Speaker
+ */
+int pm8xxx_spk_enable(int enable);
+
+#endif /* __SPK_PM8XXX_H__ */
diff --git a/include/linux/mfd/pm8xxx/tm.h b/include/linux/mfd/pm8xxx/tm.h
new file mode 100644
index 0000000..56b306e
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/tm.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Qualcomm PMIC PM8xxx Thermal Manager driver
+ */
+
+#ifndef __PM8XXX_TM_H
+#define __PM8XXX_TM_H
+
+#include <linux/errno.h>
+
+#define PM8XXX_TM_DEV_NAME	"pm8xxx-tm"
+
+enum pm8xxx_tm_adc_type {
+	PM8XXX_TM_ADC_NONE,	/* Estimates temp based on overload level. */
+	PM8XXX_TM_ADC_PM8058_ADC,
+	PM8XXX_TM_ADC_PM8XXX_ADC,
+};
+
+struct pm8xxx_tm_core_data {
+	int				adc_channel;
+	unsigned long			default_no_adc_temp;
+	enum pm8xxx_tm_adc_type		adc_type;
+	u16				reg_addr_temp_alarm_ctrl;
+	u16				reg_addr_temp_alarm_pwm;
+	char				*tm_name;
+	char				*irq_name_temp_stat;
+	char				*irq_name_over_temp;
+};
+
+#endif
diff --git a/include/linux/mfd/pm8xxx/upl.h b/include/linux/mfd/pm8xxx/upl.h
new file mode 100644
index 0000000..6a315ab
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/upl.h
@@ -0,0 +1,65 @@
+/* Copyright (c) 2010,2011 The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __PM8XXX_UPL_H__
+#define __PM8XXX_UPL_H__
+
+struct pm8xxx_upl_device;
+
+#define PM8XXX_UPL_DEV_NAME		"pm8xxx-upl"
+
+/* control masks and flags */
+#define PM8XXX_UPL_MOD_ENABLE_MASK	(0x10)
+#define PM8XXX_UPL_MOD_ENABLE		(0x10)
+#define PM8XXX_UPL_MOD_DISABLE		(0x00)
+
+#define PM8XXX_UPL_OUT_DTEST_MASK	(0xE0)
+#define PM8XXX_UPL_OUT_GPIO_ONLY	(0x00)
+#define PM8XXX_UPL_OUT_DTEST_1		(0x80)
+#define PM8XXX_UPL_OUT_DTEST_2		(0xA0)
+#define PM8XXX_UPL_OUT_DTEST_3		(0xC0)
+#define PM8XXX_UPL_OUT_DTEST_4		(0xE0)
+
+#define PM8XXX_UPL_IN_A_MASK		(0x01)
+#define PM8XXX_UPL_IN_A_GPIO		(0x00)
+#define PM8XXX_UPL_IN_A_DTEST		(0x01)
+#define PM8XXX_UPL_IN_B_MASK		(0x02)
+#define PM8XXX_UPL_IN_B_GPIO		(0x00)
+#define PM8XXX_UPL_IN_B_DTEST		(0x02)
+#define PM8XXX_UPL_IN_C_MASK		(0x04)
+#define PM8XXX_UPL_IN_C_GPIO		(0x00)
+#define PM8XXX_UPL_IN_C_DTEST		(0x04)
+#define PM8XXX_UPL_IN_D_MASK		(0x08)
+#define PM8XXX_UPL_IN_D_GPIO		(0x00)
+#define PM8XXX_UPL_IN_D_DTEST		(0x08)
+
+/*
+ * pm8xxx_upl_request - request a handle to access UPL device
+ */
+struct pm8xxx_upl_device *pm8xxx_upl_request(void);
+
+int pm8xxx_upl_read_truthtable(struct pm8xxx_upl_device *upldev,
+				u16 *truthtable);
+
+int pm8xxx_upl_write_truthtable(struct pm8xxx_upl_device *upldev,
+				u16 truthtable);
+
+/*
+ * pm8xxx_upl_config - configure UPL I/O settings and UPL enable/disable
+ *
+ * @upldev: the UPL device
+ * @mask: setting mask to configure
+ * @flags: setting flags
+ */
+int pm8xxx_upl_config(struct pm8xxx_upl_device *upldev, u32 mask, u32 flags);
+
+#endif /* __PM8XXX_UPL_H__ */
diff --git a/include/linux/mfd/pm8xxx/vibrator.h b/include/linux/mfd/pm8xxx/vibrator.h
new file mode 100644
index 0000000..3594bb0
--- /dev/null
+++ b/include/linux/mfd/pm8xxx/vibrator.h
@@ -0,0 +1,39 @@
+/* Copyright (c) 2010-2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PMIC8XXX_VIBRATOR_H__
+#define __PMIC8XXX_VIBRATOR_H__
+
+#define PM8XXX_VIBRATOR_DEV_NAME "pm8xxx-vib"
+
+enum pm8xxx_vib_en_mode {
+	PM8XXX_VIB_MANUAL,
+	PM8XXX_VIB_DTEST1,
+	PM8XXX_VIB_DTEST2,
+	PM8XXX_VIB_DTEST3
+};
+
+struct pm8xxx_vib_config {
+	u16			drive_mV;
+	u8			active_low;
+	enum pm8xxx_vib_en_mode	enable_mode;
+};
+
+struct pm8xxx_vibrator_platform_data {
+	int initial_vibrate_ms;
+	int max_timeout_ms;
+	int level_mV;
+};
+
+int pm8xxx_vibrator_config(struct pm8xxx_vib_config *vib_config);
+
+#endif /* __PMIC8XXX_VIBRATOR_H__ */
diff --git a/include/linux/mfd/pmic8058.h b/include/linux/mfd/pmic8058.h
new file mode 100644
index 0000000..19e783f
--- /dev/null
+++ b/include/linux/mfd/pmic8058.h
@@ -0,0 +1,133 @@
+/* Copyright (c) 2009-2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/*
+ * Qualcomm PMIC8058 driver header file
+ *
+ */
+
+#ifndef __MFD_PMIC8058_H__
+#define __MFD_PMIC8058_H__
+
+#include <linux/irq.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/pm8xxx/irq.h>
+#include <linux/mfd/pm8xxx/gpio.h>
+#include <linux/mfd/pm8xxx/mpp.h>
+#include <linux/mfd/pm8xxx/rtc.h>
+#include <linux/input/pmic8xxx-pwrkey.h>
+#include <linux/input/pmic8xxx-keypad.h>
+#include <linux/mfd/pm8xxx/vibrator.h>
+#include <linux/mfd/pm8xxx/nfc.h>
+#include <linux/mfd/pm8xxx/upl.h>
+#include <linux/mfd/pm8xxx/misc.h>
+#include <linux/mfd/pm8xxx/batt-alarm.h>
+#include <linux/leds-pmic8058.h>
+#include <linux/pmic8058-othc.h>
+#include <linux/mfd/pm8xxx/tm.h>
+#include <linux/pmic8058-xoadc.h>
+#include <linux/regulator/pmic8058-regulator.h>
+#include <linux/regulator/pm8058-xo.h>
+#include <linux/pwm.h>
+#include <linux/pmic8058-pwm.h>
+
+#define PM8058_GPIOS		40
+#define PM8058_MPPS		12
+
+#define PM8058_GPIO_BLOCK_START	24
+#define PM8058_MPP_BLOCK_START	16
+
+#define PM8058_NR_IRQS		256
+
+#define PM8058_IRQ_BLOCK_BIT(block, bit) ((block) * 8 + (bit))
+
+/* MPPs and GPIOs [0,N) */
+#define PM8058_MPP_IRQ(base, mpp)	((base) + \
+					PM8058_IRQ_BLOCK_BIT(16, (mpp)))
+#define PM8058_GPIO_IRQ(base, gpio)	((base) + \
+					PM8058_IRQ_BLOCK_BIT(24, (gpio)))
+
+/* PM8058 IRQ's */
+#define PM8058_VCP_IRQ			PM8058_IRQ_BLOCK_BIT(1, 0)
+#define PM8058_CHGILIM_IRQ		PM8058_IRQ_BLOCK_BIT(1, 3)
+#define PM8058_VBATDET_LOW_IRQ		PM8058_IRQ_BLOCK_BIT(1, 4)
+#define PM8058_BATT_REPLACE_IRQ		PM8058_IRQ_BLOCK_BIT(1, 5)
+#define PM8058_CHGINVAL_IRQ		PM8058_IRQ_BLOCK_BIT(1, 6)
+#define PM8058_CHGVAL_IRQ		PM8058_IRQ_BLOCK_BIT(1, 7)
+#define PM8058_CHG_END_IRQ		PM8058_IRQ_BLOCK_BIT(2, 0)
+#define PM8058_FASTCHG_IRQ		PM8058_IRQ_BLOCK_BIT(2, 1)
+#define PM8058_CHGSTATE_IRQ		PM8058_IRQ_BLOCK_BIT(2, 3)
+#define PM8058_AUTO_CHGFAIL_IRQ		PM8058_IRQ_BLOCK_BIT(2, 4)
+#define PM8058_AUTO_CHGDONE_IRQ		PM8058_IRQ_BLOCK_BIT(2, 5)
+#define PM8058_ATCFAIL_IRQ		PM8058_IRQ_BLOCK_BIT(2, 6)
+#define PM8058_ATC_DONE_IRQ		PM8058_IRQ_BLOCK_BIT(2, 7)
+#define PM8058_OVP_OK_IRQ		PM8058_IRQ_BLOCK_BIT(3, 0)
+#define PM8058_COARSE_DET_OVP_IRQ	PM8058_IRQ_BLOCK_BIT(3, 1)
+#define PM8058_VCPMAJOR_IRQ		PM8058_IRQ_BLOCK_BIT(3, 2)
+#define PM8058_CHG_GONE_IRQ		PM8058_IRQ_BLOCK_BIT(3, 3)
+#define PM8058_CHGTLIMIT_IRQ		PM8058_IRQ_BLOCK_BIT(3, 4)
+#define PM8058_CHGHOT_IRQ		PM8058_IRQ_BLOCK_BIT(3, 5)
+#define PM8058_BATTTEMP_IRQ		PM8058_IRQ_BLOCK_BIT(3, 6)
+#define PM8058_BATTCONNECT_IRQ		PM8058_IRQ_BLOCK_BIT(3, 7)
+#define PM8058_BATFET_IRQ		PM8058_IRQ_BLOCK_BIT(5, 4)
+#define PM8058_VBATDET_IRQ		PM8058_IRQ_BLOCK_BIT(5, 5)
+#define PM8058_VBAT_IRQ			PM8058_IRQ_BLOCK_BIT(5, 6)
+
+#define PM8058_RTC_IRQ			PM8058_IRQ_BLOCK_BIT(6, 5)
+#define PM8058_RTC_ALARM_IRQ		PM8058_IRQ_BLOCK_BIT(4, 7)
+#define PM8058_PWRKEY_REL_IRQ		PM8058_IRQ_BLOCK_BIT(6, 2)
+#define PM8058_PWRKEY_PRESS_IRQ		PM8058_IRQ_BLOCK_BIT(6, 3)
+#define PM8058_KEYPAD_IRQ		PM8058_IRQ_BLOCK_BIT(9, 2)
+#define PM8058_KEYSTUCK_IRQ		PM8058_IRQ_BLOCK_BIT(9, 3)
+#define PM8058_BATT_ALARM_IRQ		PM8058_IRQ_BLOCK_BIT(5, 6)
+#define PM8058_SW_0_IRQ			PM8058_IRQ_BLOCK_BIT(7, 1)
+#define PM8058_IR_0_IRQ			PM8058_IRQ_BLOCK_BIT(7, 0)
+#define PM8058_SW_1_IRQ			PM8058_IRQ_BLOCK_BIT(7, 3)
+#define PM8058_IR_1_IRQ			PM8058_IRQ_BLOCK_BIT(7, 2)
+#define PM8058_SW_2_IRQ			PM8058_IRQ_BLOCK_BIT(7, 5)
+#define PM8058_IR_2_IRQ			PM8058_IRQ_BLOCK_BIT(7, 4)
+#define PM8058_TEMPSTAT_IRQ		PM8058_IRQ_BLOCK_BIT(6, 7)
+#define PM8058_OVERTEMP_IRQ		PM8058_IRQ_BLOCK_BIT(4, 2)
+#define PM8058_ADC_IRQ			PM8058_IRQ_BLOCK_BIT(9, 4)
+#define PM8058_OSCHALT_IRQ		PM8058_IRQ_BLOCK_BIT(4, 6)
+#define PM8058_CBLPWR_IRQ		PM8058_IRQ_BLOCK_BIT(4, 3)
+#define PM8058_RESOUT_IRQ		PM8058_IRQ_BLOCK_BIT(6, 4)
+
+struct pmic8058_charger_data {
+	unsigned int max_source_current;
+	int charger_type;
+	bool charger_data_valid;
+};
+
+struct pm8058_platform_data {
+	struct pm8xxx_mpp_platform_data		*mpp_pdata;
+	struct pm8xxx_keypad_platform_data      *keypad_pdata;
+	struct pm8xxx_gpio_platform_data	*gpio_pdata;
+	struct pm8xxx_irq_platform_data		*irq_pdata;
+	struct pm8xxx_rtc_platform_data		*rtc_pdata;
+	struct pm8xxx_pwrkey_platform_data	*pwrkey_pdata;
+	struct pm8xxx_vibrator_platform_data	*vibrator_pdata;
+	struct pm8xxx_misc_platform_data	*misc_pdata;
+	struct pmic8058_leds_platform_data	*leds_pdata;
+	struct pmic8058_othc_config_pdata	*othc0_pdata;
+	struct pmic8058_othc_config_pdata	*othc1_pdata;
+	struct pmic8058_othc_config_pdata	*othc2_pdata;
+	struct xoadc_platform_data		*xoadc_pdata;
+	struct pm8058_pwm_pdata			*pwm_pdata;
+	struct pm8058_vreg_pdata		*regulator_pdatas;
+	int					num_regulators;
+	struct pm8058_xo_pdata			*xo_buffer_pdata;
+	int					num_xo_buffers;
+	struct pmic8058_charger_data		*charger_pdata;
+};
+
+#endif  /* __MFD_PMIC8058_H__ */
diff --git a/include/linux/mfd/pmic8901.h b/include/linux/mfd/pmic8901.h
new file mode 100644
index 0000000..bf64bec
--- /dev/null
+++ b/include/linux/mfd/pmic8901.h
@@ -0,0 +1,49 @@
+/* Copyright (c) 2010-2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __PMIC8901_H__
+#define __PMIC8901_H__
+/*
+ * Qualcomm PMIC8901 driver header file
+ *
+ */
+
+#include <linux/irq.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/pm8xxx/irq.h>
+#include <linux/mfd/pm8xxx/mpp.h>
+#include <linux/mfd/pm8xxx/tm.h>
+#include <linux/regulator/pmic8901-regulator.h>
+#include <linux/mfd/pm8xxx/misc.h>
+
+#define PM8901_IRQ_BLOCK_BIT(block, bit) ((block) * 8 + (bit))
+
+#define PM8901_NR_IRQS			72
+
+/* PM8901 MPP */
+#define PM8901_MPP_BLOCK_START		6
+#define PM8901_MPPS			4
+
+/* PM8901 IRQs */
+#define PM8901_MPP_IRQ(mpp)		PM8901_IRQ_BLOCK_BIT(6, (mpp))
+#define PM8901_TEMPSTAT_IRQ		PM8901_IRQ_BLOCK_BIT(6, 4)
+#define PM8901_OVERTEMP_IRQ		PM8901_IRQ_BLOCK_BIT(6, 5)
+
+struct pm8901_platform_data {
+	struct pm8xxx_irq_platform_data		*irq_pdata;
+	struct pm8xxx_mpp_platform_data		*mpp_pdata;
+	struct pm8xxx_misc_platform_data	*misc_pdata;
+	struct pm8901_vreg_pdata		*regulator_pdatas;
+	int					num_regulators;
+};
+
+#endif /* __PMIC8901_H__ */
diff --git a/include/linux/mfd/wcd9xxx/Kbuild b/include/linux/mfd/wcd9xxx/Kbuild
new file mode 100644
index 0000000..acfab6e
--- /dev/null
+++ b/include/linux/mfd/wcd9xxx/Kbuild
@@ -0,0 +1,2 @@
+header-y += wcd9xxx_registers.h
+header-y += wcd9310_registers.h
diff --git a/include/linux/mfd/wcd9xxx/core.h b/include/linux/mfd/wcd9xxx/core.h
new file mode 100644
index 0000000..4c1c955
--- /dev/null
+++ b/include/linux/mfd/wcd9xxx/core.h
@@ -0,0 +1,191 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MFD_TABLA_CORE_H__
+#define __MFD_TABLA_CORE_H__
+
+#include <linux/interrupt.h>
+#include <linux/wakelock.h>
+
+#define WCD9XXX_NUM_IRQ_REGS 3
+
+#define WCD9XXX_SLIM_NUM_PORT_REG 3
+
+#define WCD9XXX_INTERFACE_TYPE_SLIMBUS	0x00
+#define WCD9XXX_INTERFACE_TYPE_I2C	0x01
+
+#define TABLA_VERSION_1_0	0
+#define TABLA_VERSION_1_1	1
+#define TABLA_VERSION_2_0	2
+#define TABLA_IS_1_X(ver) \
+	(((ver == TABLA_VERSION_1_0) || (ver == TABLA_VERSION_1_1)) ? 1 : 0)
+#define TABLA_IS_2_0(ver) ((ver == TABLA_VERSION_2_0) ? 1 : 0)
+
+#define SITAR_VERSION_1P0 0
+#define SITAR_VERSION_1P1 1
+#define SITAR_IS_1P0(ver) \
+	((ver == SITAR_VERSION_1P0) ? 1 : 0)
+#define SITAR_IS_1P1(ver) \
+	((ver == SITAR_VERSION_1P1) ? 1 : 0)
+
+enum {
+	TABLA_IRQ_SLIMBUS = 0,
+	TABLA_IRQ_MBHC_REMOVAL,
+	TABLA_IRQ_MBHC_SHORT_TERM,
+	TABLA_IRQ_MBHC_PRESS,
+	TABLA_IRQ_MBHC_RELEASE,
+	TABLA_IRQ_MBHC_POTENTIAL,
+	TABLA_IRQ_MBHC_INSERTION,
+	TABLA_IRQ_BG_PRECHARGE,
+	TABLA_IRQ_PA1_STARTUP,
+	TABLA_IRQ_PA2_STARTUP,
+	TABLA_IRQ_PA3_STARTUP,
+	TABLA_IRQ_PA4_STARTUP,
+	TABLA_IRQ_PA5_STARTUP,
+	TABLA_IRQ_MICBIAS1_PRECHARGE,
+	TABLA_IRQ_MICBIAS2_PRECHARGE,
+	TABLA_IRQ_MICBIAS3_PRECHARGE,
+	TABLA_IRQ_HPH_PA_OCPL_FAULT,
+	TABLA_IRQ_HPH_PA_OCPR_FAULT,
+	TABLA_IRQ_EAR_PA_OCPL_FAULT,
+	TABLA_IRQ_HPH_L_PA_STARTUP,
+	TABLA_IRQ_HPH_R_PA_STARTUP,
+	TABLA_IRQ_EAR_PA_STARTUP,
+	TABLA_NUM_IRQS,
+};
+
+enum {
+	SITAR_IRQ_SLIMBUS = 0,
+	SITAR_IRQ_MBHC_REMOVAL,
+	SITAR_IRQ_MBHC_SHORT_TERM,
+	SITAR_IRQ_MBHC_PRESS,
+	SITAR_IRQ_MBHC_RELEASE,
+	SITAR_IRQ_MBHC_POTENTIAL,
+	SITAR_IRQ_MBHC_INSERTION,
+	SITAR_IRQ_BG_PRECHARGE,
+	SITAR_IRQ_PA1_STARTUP,
+	SITAR_IRQ_PA2_STARTUP,
+	SITAR_IRQ_PA3_STARTUP,
+	SITAR_IRQ_PA4_STARTUP,
+	SITAR_IRQ_PA5_STARTUP,
+	SITAR_IRQ_MICBIAS1_PRECHARGE,
+	SITAR_IRQ_MICBIAS2_PRECHARGE,
+	SITAR_IRQ_MICBIAS3_PRECHARGE,
+	SITAR_IRQ_HPH_PA_OCPL_FAULT,
+	SITAR_IRQ_HPH_PA_OCPR_FAULT,
+	SITAR_IRQ_EAR_PA_OCPL_FAULT,
+	SITAR_IRQ_HPH_L_PA_STARTUP,
+	SITAR_IRQ_HPH_R_PA_STARTUP,
+	SITAR_IRQ_EAR_PA_STARTUP,
+	SITAR_NUM_IRQS,
+};
+
+
+enum wcd9xxx_pm_state {
+	WCD9XXX_PM_SLEEPABLE,
+	WCD9XXX_PM_AWAKE,
+	WCD9XXX_PM_ASLEEP,
+};
+
+struct wcd9xxx {
+	struct device *dev;
+	struct slim_device *slim;
+	struct slim_device *slim_slave;
+	struct mutex io_lock;
+	struct mutex xfer_lock;
+	struct mutex irq_lock;
+	u8 version;
+
+	unsigned int irq_base;
+	unsigned int irq;
+	u8 irq_masks_cur[WCD9XXX_NUM_IRQ_REGS];
+	u8 irq_masks_cache[WCD9XXX_NUM_IRQ_REGS];
+	u8 irq_level[WCD9XXX_NUM_IRQ_REGS];
+
+	int reset_gpio;
+
+	int (*read_dev)(struct wcd9xxx *wcd9xxx, unsigned short reg,
+			int bytes, void *dest, bool interface_reg);
+	int (*write_dev)(struct wcd9xxx *wcd9xxx, unsigned short reg,
+			 int bytes, void *src, bool interface_reg);
+
+	struct regulator_bulk_data *supplies;
+
+	enum wcd9xxx_pm_state pm_state;
+	struct mutex pm_lock;
+	/* pm_wq notifies change of pm_state */
+	wait_queue_head_t pm_wq;
+	struct wake_lock wlock;
+	int wlock_holders;
+
+	int num_rx_port;
+	int num_tx_port;
+};
+
+int wcd9xxx_reg_read(struct wcd9xxx *wcd9xxx, unsigned short reg);
+int wcd9xxx_reg_write(struct wcd9xxx *wcd9xxx, unsigned short reg,
+		u8 val);
+int wcd9xxx_interface_reg_read(struct wcd9xxx *wcd9xxx, unsigned short reg);
+int wcd9xxx_interface_reg_write(struct wcd9xxx *wcd9xxx, unsigned short reg,
+		u8 val);
+int wcd9xxx_bulk_read(struct wcd9xxx *wcd9xxx, unsigned short reg,
+			int count, u8 *buf);
+int wcd9xxx_bulk_write(struct wcd9xxx *wcd9xxx, unsigned short reg,
+			int count, u8 *buf);
+int wcd9xxx_irq_init(struct wcd9xxx *wcd9xxx);
+void wcd9xxx_irq_exit(struct wcd9xxx *wcd9xxx);
+int wcd9xxx_get_logical_addresses(u8 *pgd_la, u8 *inf_la);
+int wcd9xxx_get_intf_type(void);
+
+bool wcd9xxx_lock_sleep(struct wcd9xxx *wcd9xxx);
+void wcd9xxx_unlock_sleep(struct wcd9xxx *wcd9xxx);
+enum wcd9xxx_pm_state wcd9xxx_pm_cmpxchg(struct wcd9xxx *wcd9xxx,
+				enum wcd9xxx_pm_state o,
+				enum wcd9xxx_pm_state n);
+
+static inline int wcd9xxx_request_irq(struct wcd9xxx *wcd9xxx, int irq,
+				     irq_handler_t handler, const char *name,
+				     void *data)
+{
+	if (!wcd9xxx->irq_base)
+		return -EINVAL;
+	return request_threaded_irq(wcd9xxx->irq_base + irq, NULL, handler,
+				    IRQF_TRIGGER_RISING, name,
+				    data);
+}
+static inline void wcd9xxx_free_irq(struct wcd9xxx *wcd9xxx,
+				int irq, void *data)
+{
+	if (!wcd9xxx->irq_base)
+		return;
+	free_irq(wcd9xxx->irq_base + irq, data);
+}
+static inline void wcd9xxx_enable_irq(struct wcd9xxx *wcd9xxx, int irq)
+{
+	if (!wcd9xxx->irq_base)
+		return;
+	enable_irq(wcd9xxx->irq_base + irq);
+}
+static inline void wcd9xxx_disable_irq(struct wcd9xxx *wcd9xxx, int irq)
+{
+	if (!wcd9xxx->irq_base)
+		return;
+	disable_irq_nosync(wcd9xxx->irq_base + irq);
+}
+static inline void wcd9xxx_disable_irq_sync(struct wcd9xxx *wcd9xxx, int irq)
+{
+	if (!wcd9xxx->irq_base)
+		return;
+	disable_irq(wcd9xxx->irq_base + irq);
+}
+
+#endif
diff --git a/include/linux/mfd/wcd9xxx/pdata.h b/include/linux/mfd/wcd9xxx/pdata.h
new file mode 100644
index 0000000..c29a75d
--- /dev/null
+++ b/include/linux/mfd/wcd9xxx/pdata.h
@@ -0,0 +1,153 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MFD_TABLA_PDATA_H__
+
+#define __MFD_TABLA_PDATA_H__
+
+#include <linux/slimbus/slimbus.h>
+
+#define MICBIAS_EXT_BYP_CAP 0x00
+#define MICBIAS_NO_EXT_BYP_CAP 0x01
+
+#define SITAR_LDOH_1P95_V 0x0
+#define SITAR_LDOH_2P35_V 0x1
+#define SITAR_LDOH_2P75_V 0x2
+#define SITAR_LDOH_2P85_V 0x3
+
+#define SITAR_CFILT1_SEL 0x0
+#define SITAR_CFILT2_SEL 0x1
+#define SITAR_CFILT3_SEL 0x2
+
+#define TABLA_LDOH_1P95_V 0x0
+#define TABLA_LDOH_2P35_V 0x1
+#define TABLA_LDOH_2P75_V 0x2
+#define TABLA_LDOH_2P85_V 0x3
+
+#define TABLA_CFILT1_SEL 0x0
+#define TABLA_CFILT2_SEL 0x1
+#define TABLA_CFILT3_SEL 0x2
+
+#define MAX_AMIC_CHANNEL 7
+
+#define TABLA_OCP_300_MA 0x0
+#define TABLA_OCP_350_MA 0x2
+#define TABLA_OCP_365_MA 0x3
+#define TABLA_OCP_150_MA 0x4
+#define TABLA_OCP_190_MA 0x6
+#define TABLA_OCP_220_MA 0x7
+
+#define TABLA_DCYCLE_255  0x0
+#define TABLA_DCYCLE_511  0x1
+#define TABLA_DCYCLE_767  0x2
+#define TABLA_DCYCLE_1023 0x3
+#define TABLA_DCYCLE_1279 0x4
+#define TABLA_DCYCLE_1535 0x5
+#define TABLA_DCYCLE_1791 0x6
+#define TABLA_DCYCLE_2047 0x7
+#define TABLA_DCYCLE_2303 0x8
+#define TABLA_DCYCLE_2559 0x9
+#define TABLA_DCYCLE_2815 0xA
+#define TABLA_DCYCLE_3071 0xB
+#define TABLA_DCYCLE_3327 0xC
+#define TABLA_DCYCLE_3583 0xD
+#define TABLA_DCYCLE_3839 0xE
+#define TABLA_DCYCLE_4095 0xF
+
+struct wcd9xxx_amic {
+	/*legacy mode, txfe_enable and txfe_buff take 7 input
+	 * each bit represent the channel / TXFE number
+	 * and numbered as below
+	 * bit 0 = channel 1 / TXFE1_ENABLE / TXFE1_BUFF
+	 * bit 1 = channel 2 / TXFE2_ENABLE / TXFE2_BUFF
+	 * ...
+	 * bit 7 = channel 7 / TXFE7_ENABLE / TXFE7_BUFF
+	 */
+	u8 legacy_mode:MAX_AMIC_CHANNEL;
+	u8 txfe_enable:MAX_AMIC_CHANNEL;
+	u8 txfe_buff:MAX_AMIC_CHANNEL;
+	u8 use_pdata:MAX_AMIC_CHANNEL;
+};
+
+/* Each micbias can be assigned to one of three cfilters
+ * Vbatt_min >= .15V + ldoh_v
+ * ldoh_v >= .15v + cfiltx_mv
+ * If ldoh_v = 1.95 160 mv < cfiltx_mv < 1800 mv
+ * If ldoh_v = 2.35 200 mv < cfiltx_mv < 2200 mv
+ * If ldoh_v = 2.75 240 mv < cfiltx_mv < 2600 mv
+ * If ldoh_v = 2.85 250 mv < cfiltx_mv < 2700 mv
+ */
+
+struct wcd9xxx_micbias_setting {
+	u8 ldoh_v;
+	u32 cfilt1_mv; /* in mv */
+	u32 cfilt2_mv; /* in mv */
+	u32 cfilt3_mv; /* in mv */
+	/* Different WCD9xxx series codecs may not
+	 * have 4 mic biases. If a codec has fewer
+	 * mic biases, some of these properties will
+	 * not be used.
+	 */
+	u8 bias1_cfilt_sel;
+	u8 bias2_cfilt_sel;
+	u8 bias3_cfilt_sel;
+	u8 bias4_cfilt_sel;
+	u8 bias1_cap_mode;
+	u8 bias2_cap_mode;
+	u8 bias3_cap_mode;
+	u8 bias4_cap_mode;
+};
+
+struct wcd9xxx_ocp_setting {
+	unsigned int	use_pdata:1; /* 0 - use sys default as recommended */
+	unsigned int	num_attempts:4; /* up to 15 attempts */
+	unsigned int	run_time:4; /* in duty cycle */
+	unsigned int	wait_time:4; /* in duty cycle */
+	unsigned int	hph_ocp_limit:3; /* Headphone OCP current limit */
+};
+
+#define MAX_REGULATOR	6
+/*
+ *      format : TABLA_<POWER_SUPPLY_PIN_NAME>_CUR_MAX
+ *
+ *      <POWER_SUPPLY_PIN_NAME> from Tabla objective spec
+*/
+
+#define  WCD9XXX_CDC_VDDA_CP_CUR_MAX      500000
+#define  WCD9XXX_CDC_VDDA_RX_CUR_MAX      20000
+#define  WCD9XXX_CDC_VDDA_TX_CUR_MAX      20000
+#define  WCD9XXX_VDDIO_CDC_CUR_MAX        5000
+
+#define  WCD9XXX_VDDD_CDC_D_CUR_MAX       5000
+#define  WCD9XXX_VDDD_CDC_A_CUR_MAX       5000
+
+struct wcd9xxx_regulator {
+	const char *name;
+	int min_uV;
+	int max_uV;
+	int optimum_uA;
+	struct regulator *regulator;
+};
+
+struct wcd9xxx_pdata {
+	int irq;
+	int irq_base;
+	int num_irqs;
+	int reset_gpio;
+	struct wcd9xxx_amic amic_settings;
+	struct slim_device slimbus_slave_device;
+	struct wcd9xxx_micbias_setting micbias;
+	struct wcd9xxx_ocp_setting ocp;
+	struct wcd9xxx_regulator regulator[MAX_REGULATOR];
+};
+
+#endif
diff --git a/include/linux/mfd/wcd9xxx/wcd9304_registers.h b/include/linux/mfd/wcd9xxx/wcd9304_registers.h
new file mode 100644
index 0000000..b8b42fa
--- /dev/null
+++ b/include/linux/mfd/wcd9xxx/wcd9304_registers.h
@@ -0,0 +1,807 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef SITAR_CODEC_DIGITAL_H
+#define SITAR_CODEC_DIGITAL_H
+
+#define SITAR_A_PIN_CTL_OE0			(0x10)
+#define SITAR_A_PIN_CTL_OE0__POR			(0x00000000)
+#define SITAR_A_PIN_CTL_OE1			(0x11)
+#define SITAR_A_PIN_CTL_OE1__POR			(0x00000000)
+#define SITAR_A_PIN_CTL_DATA0			(0x12)
+#define SITAR_A_PIN_CTL_DATA0__POR			(0x00000000)
+#define SITAR_A_PIN_CTL_DATA1			(0x13)
+#define SITAR_A_PIN_CTL_DATA1__POR			(0x00000000)
+#define SITAR_A_HDRIVE_GENERIC			(0x18)
+#define SITAR_A_HDRIVE_GENERIC__POR			(0x00000000)
+#define SITAR_A_HDRIVE_OVERRIDE			(0x19)
+#define SITAR_A_HDRIVE_OVERRIDE__POR			(0x00000008)
+#define SITAR_A_ANA_CSR_WAIT_STATE			(0x20)
+#define SITAR_A_ANA_CSR_WAIT_STATE__POR			(0x00000044)
+#define SITAR_A_PROCESS_MONITOR_CTL0			(0x40)
+#define SITAR_A_PROCESS_MONITOR_CTL0__POR			(0x00000080)
+#define SITAR_A_PROCESS_MONITOR_CTL1			(0x41)
+#define SITAR_A_PROCESS_MONITOR_CTL1__POR			(0x00000000)
+#define SITAR_A_PROCESS_MONITOR_CTL2			(0x42)
+#define SITAR_A_PROCESS_MONITOR_CTL2__POR			(0x00000000)
+#define SITAR_A_PROCESS_MONITOR_CTL3			(0x43)
+#define SITAR_A_PROCESS_MONITOR_CTL3__POR			(0x00000001)
+#define SITAR_A_QFUSE_CTL			(0x48)
+#define SITAR_A_QFUSE_CTL__POR			(0x00000000)
+#define SITAR_A_QFUSE_STATUS			(0x49)
+#define SITAR_A_QFUSE_STATUS__POR			(0x00000000)
+#define SITAR_A_QFUSE_DATA_OUT0			(0x4A)
+#define SITAR_A_QFUSE_DATA_OUT0__POR			(0x00000000)
+#define SITAR_A_QFUSE_DATA_OUT1			(0x4B)
+#define SITAR_A_QFUSE_DATA_OUT1__POR			(0x00000000)
+#define SITAR_A_QFUSE_DATA_OUT2			(0x4C)
+#define SITAR_A_QFUSE_DATA_OUT2__POR			(0x00000000)
+#define SITAR_A_QFUSE_DATA_OUT3			(0x4D)
+#define SITAR_A_QFUSE_DATA_OUT3__POR			(0x00000000)
+#define SITAR_A_QFUSE_DATA_OUT4			(0x4E)
+#define SITAR_A_QFUSE_DATA_OUT4__POR			(0x00000000)
+#define SITAR_A_QFUSE_DATA_OUT5			(0x4F)
+#define SITAR_A_QFUSE_DATA_OUT5__POR			(0x00000000)
+#define SITAR_A_QFUSE_DATA_OUT6			(0x50)
+#define SITAR_A_QFUSE_DATA_OUT6__POR			(0x00000000)
+#define SITAR_A_QFUSE_DATA_OUT7			(0x51)
+#define SITAR_A_QFUSE_DATA_OUT7__POR			(0x00000000)
+#define SITAR_A_CDC_CTL			(0x80)
+#define SITAR_A_CDC_CTL__POR			(0x00000000)
+#define SITAR_A_LEAKAGE_CTL			(0x88)
+#define SITAR_A_LEAKAGE_CTL__POR			(0x00000004)
+#define SITAR_A_INTR_MODE			(0x90)
+#define SITAR_A_INTR_MODE__POR			(0x00000000)
+#define SITAR_A_INTR_MASK0			(0x94)
+#define SITAR_A_INTR_MASK0__POR			(0x000000ff)
+#define SITAR_A_INTR_MASK1			(0x95)
+#define SITAR_A_INTR_MASK1__POR			(0x000000ff)
+#define SITAR_A_INTR_MASK2			(0x96)
+#define SITAR_A_INTR_MASK2__POR			(0x000000ff)
+#define SITAR_A_INTR_STATUS0			(0x98)
+#define SITAR_A_INTR_STATUS0__POR			(0x00000000)
+#define SITAR_A_INTR_STATUS1			(0x99)
+#define SITAR_A_INTR_STATUS1__POR			(0x00000000)
+#define SITAR_A_INTR_STATUS2			(0x9A)
+#define SITAR_A_INTR_STATUS2__POR			(0x00000000)
+#define SITAR_A_INTR_CLEAR0			(0x9C)
+#define SITAR_A_INTR_CLEAR0__POR			(0x00000000)
+#define SITAR_A_INTR_CLEAR1			(0x9D)
+#define SITAR_A_INTR_CLEAR1__POR			(0x00000000)
+#define SITAR_A_INTR_CLEAR2			(0x9E)
+#define SITAR_A_INTR_CLEAR2__POR			(0x00000000)
+#define SITAR_A_INTR_LEVEL0			(0xA0)
+#define SITAR_A_INTR_LEVEL0__POR			(0x00000001)
+#define SITAR_A_INTR_LEVEL1			(0xA1)
+#define SITAR_A_INTR_LEVEL1__POR			(0x00000000)
+#define SITAR_A_INTR_LEVEL2			(0xA2)
+#define SITAR_A_INTR_LEVEL2__POR			(0x00000000)
+#define SITAR_A_INTR_TEST0			(0xA4)
+#define SITAR_A_INTR_TEST0__POR			(0x00000000)
+#define SITAR_A_INTR_TEST1			(0xA5)
+#define SITAR_A_INTR_TEST1__POR			(0x00000000)
+#define SITAR_A_INTR_TEST2			(0xA6)
+#define SITAR_A_INTR_TEST2__POR			(0x00000000)
+#define SITAR_A_INTR_SET0			(0xA8)
+#define SITAR_A_INTR_SET0__POR			(0x00000000)
+#define SITAR_A_INTR_SET1			(0xA9)
+#define SITAR_A_INTR_SET1__POR			(0x00000000)
+#define SITAR_A_INTR_SET2			(0xAA)
+#define SITAR_A_INTR_SET2__POR			(0x00000000)
+#define SITAR_A_CDC_TX_I2S_SCK_MODE			(0xC0)
+#define SITAR_A_CDC_TX_I2S_SCK_MODE__POR			(0x00000000)
+#define SITAR_A_CDC_TX_I2S_WS_MODE			(0xC1)
+#define SITAR_A_CDC_TX_I2S_WS_MODE__POR			(0x00000000)
+#define SITAR_A_CDC_DMIC_DATA0_MODE			(0xC4)
+#define SITAR_A_CDC_DMIC_DATA0_MODE__POR			(0x00000000)
+#define SITAR_A_CDC_DMIC_CLK0_MODE			(0xC5)
+#define SITAR_A_CDC_DMIC_CLK0_MODE__POR			(0x00000000)
+#define SITAR_A_CDC_DMIC_DATA1_MODE			(0xC6)
+#define SITAR_A_CDC_DMIC_DATA1_MODE__POR			(0x00000000)
+#define SITAR_A_CDC_DMIC_CLK1_MODE			(0xC7)
+#define SITAR_A_CDC_DMIC_CLK1_MODE__POR			(0x00000000)
+#define SITAR_A_CDC_TX_I2S_SD0_MODE			(0xC8)
+#define SITAR_A_CDC_TX_I2S_SD0_MODE__POR			(0x00000000)
+#define SITAR_A_CDC_INTR_MODE			(0xC9)
+#define SITAR_A_CDC_INTR_MODE__POR			(0x00000000)
+#define SITAR_A_CDC_RX_I2S_SD0_MODE			(0xCA)
+#define SITAR_A_CDC_RX_I2S_SD0_MODE__POR			(0x00000000)
+#define SITAR_A_CDC_RX_I2S_SD1_MODE			(0xCB)
+#define SITAR_A_CDC_RX_I2S_SD1_MODE__POR			(0x00000000)
+#define SITAR_A_BIAS_REF_CTL			(0x100)
+#define SITAR_A_BIAS_REF_CTL__POR			(0x0000001c)
+#define SITAR_A_BIAS_CENTRAL_BG_CTL			(0x101)
+#define SITAR_A_BIAS_CENTRAL_BG_CTL__POR			(0x00000050)
+#define SITAR_A_BIAS_PRECHRG_CTL			(0x102)
+#define SITAR_A_BIAS_PRECHRG_CTL__POR			(0x00000007)
+#define SITAR_A_BIAS_CURR_CTL_1			(0x103)
+#define SITAR_A_BIAS_CURR_CTL_1__POR			(0x00000052)
+#define SITAR_A_BIAS_CURR_CTL_2			(0x104)
+#define SITAR_A_BIAS_CURR_CTL_2__POR			(0x00000000)
+#define SITAR_A_BIAS_OSC_BG_CTL			(0x105)
+#define SITAR_A_BIAS_OSC_BG_CTL__POR			(0x00000016)
+#define SITAR_A_CLK_BUFF_EN1			(0x108)
+#define SITAR_A_CLK_BUFF_EN1__POR			(0x00000004)
+#define SITAR_A_CLK_BUFF_EN2			(0x109)
+#define SITAR_A_CLK_BUFF_EN2__POR			(0x00000002)
+#define SITAR_A_LDO_H_MODE_1			(0x110)
+#define SITAR_A_LDO_H_MODE_1__POR			(0x00000065)
+#define SITAR_A_LDO_H_MODE_2			(0x111)
+#define SITAR_A_LDO_H_MODE_2__POR			(0x000000a8)
+#define SITAR_A_LDO_H_LOOP_CTL			(0x112)
+#define SITAR_A_LDO_H_LOOP_CTL__POR			(0x0000006b)
+#define SITAR_A_LDO_H_COMP_1			(0x113)
+#define SITAR_A_LDO_H_COMP_1__POR			(0x00000084)
+#define SITAR_A_LDO_H_COMP_2			(0x114)
+#define SITAR_A_LDO_H_COMP_2__POR			(0x000000e0)
+#define SITAR_A_LDO_H_BIAS_1			(0x115)
+#define SITAR_A_LDO_H_BIAS_1__POR			(0x0000006d)
+#define SITAR_A_LDO_H_BIAS_2			(0x116)
+#define SITAR_A_LDO_H_BIAS_2__POR			(0x000000a5)
+#define SITAR_A_LDO_H_BIAS_3			(0x117)
+#define SITAR_A_LDO_H_BIAS_3__POR			(0x00000060)
+#define SITAR_A_MICB_CFILT_1_CTL			(0x128)
+#define SITAR_A_MICB_CFILT_1_CTL__POR			(0x00000040)
+#define SITAR_A_MICB_CFILT_1_VAL			(0x129)
+#define SITAR_A_MICB_CFILT_1_VAL__POR			(0x00000080)
+#define SITAR_A_MICB_CFILT_1_PRECHRG			(0x12A)
+#define SITAR_A_MICB_CFILT_1_PRECHRG__POR			(0x00000038)
+#define SITAR_A_MICB_1_CTL			(0x12B)
+#define SITAR_A_MICB_1_CTL__POR			(0x00000016)
+#define SITAR_A_MICB_1_INT_RBIAS			(0x12C)
+#define SITAR_A_MICB_1_INT_RBIAS__POR			(0x00000024)
+#define SITAR_A_MICB_1_MBHC			(0x12D)
+#define SITAR_A_MICB_1_MBHC__POR			(0x00000001)
+#define SITAR_A_MICB_CFILT_2_CTL			(0x12E)
+#define SITAR_A_MICB_CFILT_2_CTL__POR			(0x00000040)
+#define SITAR_A_MICB_CFILT_2_VAL			(0x12F)
+#define SITAR_A_MICB_CFILT_2_VAL__POR			(0x00000080)
+#define SITAR_A_MICB_CFILT_2_PRECHRG			(0x130)
+#define SITAR_A_MICB_CFILT_2_PRECHRG__POR			(0x00000038)
+#define SITAR_A_MICB_2_CTL			(0x131)
+#define SITAR_A_MICB_2_CTL__POR			(0x00000016)
+#define SITAR_A_MICB_2_INT_RBIAS			(0x132)
+#define SITAR_A_MICB_2_INT_RBIAS__POR			(0x00000024)
+#define SITAR_A_MICB_2_MBHC			(0x133)
+#define SITAR_A_MICB_2_MBHC__POR			(0x00000002)
+#define SITAR_A_TX_COM_BIAS			(0x14C)
+#define SITAR_A_TX_COM_BIAS__POR			(0x000000e0)
+#define SITAR_A_MBHC_SCALING_MUX_1			(0x14E)
+#define SITAR_A_MBHC_SCALING_MUX_1__POR			(0x00000000)
+#define SITAR_A_MBHC_SCALING_MUX_2			(0x14F)
+#define SITAR_A_MBHC_SCALING_MUX_2__POR			(0x00000080)
+#define SITAR_A_TX_SUP_SWITCH_CTRL_1			(0x151)
+#define SITAR_A_TX_SUP_SWITCH_CTRL_1__POR			(0x00000000)
+#define SITAR_A_TX_SUP_SWITCH_CTRL_2			(0x152)
+#define SITAR_A_TX_SUP_SWITCH_CTRL_2__POR			(0x00000080)
+#define SITAR_A_TX_1_2_EN			(0x153)
+#define SITAR_A_TX_1_2_EN__POR			(0x00000000)
+#define SITAR_A_TX_1_2_TEST_EN			(0x154)
+#define SITAR_A_TX_1_2_TEST_EN__POR			(0x000000cc)
+#define SITAR_A_TX_1_2_ADC_CH1			(0x155)
+#define SITAR_A_TX_1_2_ADC_CH1__POR			(0x00000044)
+#define SITAR_A_TX_1_2_ADC_CH2			(0x156)
+#define SITAR_A_TX_1_2_ADC_CH2__POR			(0x00000044)
+#define SITAR_A_TX_1_2_ATEST_REFCTRL			(0x157)
+#define SITAR_A_TX_1_2_ATEST_REFCTRL__POR			(0x00000000)
+#define SITAR_A_TX_1_2_TEST_CTL			(0x158)
+#define SITAR_A_TX_1_2_TEST_CTL__POR			(0x00000038)
+#define SITAR_A_TX_1_2_TEST_BLOCK_EN			(0x159)
+#define SITAR_A_TX_1_2_TEST_BLOCK_EN__POR			(0x000000fc)
+#define SITAR_A_TX_1_2_TXFE_CLKDIV			(0x15A)
+#define SITAR_A_TX_1_2_TXFE_CLKDIV__POR			(0x000000ee)
+#define SITAR_A_TX_1_2_SAR_ERR_CH1			(0x15B)
+#define SITAR_A_TX_1_2_SAR_ERR_CH1__POR			(0x00000000)
+#define SITAR_A_TX_1_2_SAR_ERR_CH2			(0x15C)
+#define SITAR_A_TX_1_2_SAR_ERR_CH2__POR			(0x00000000)
+#define SITAR_A_TX_3_EN			(0x15D)
+#define SITAR_A_TX_3_EN__POR			(0x00000000)
+#define SITAR_A_TX_3_TEST_EN			(0x15E)
+#define SITAR_A_TX_3_TEST_EN__POR			(0x000000cc)
+#define SITAR_A_TX_3_ADC			(0x15F)
+#define SITAR_A_TX_3_ADC__POR			(0x00000044)
+#define SITAR_A_TX_3_MBHC_ATEST_REFCTRL			(0x161)
+#define SITAR_A_TX_3_MBHC_ATEST_REFCTRL__POR			(0x00000000)
+#define SITAR_A_TX_3_TEST_CTL			(0x162)
+#define SITAR_A_TX_3_TEST_CTL__POR			(0x00000038)
+#define SITAR_A_TX_3_TEST_BLOCK_EN			(0x163)
+#define SITAR_A_TX_3_TEST_BLOCK_EN__POR			(0x000000fc)
+#define SITAR_A_TX_3_TXFE_CKDIV			(0x164)
+#define SITAR_A_TX_3_TXFE_CKDIV__POR			(0x000000ee)
+#define SITAR_A_TX_3_SAR_ERR			(0x165)
+#define SITAR_A_TX_3_SAR_ERR__POR			(0x00000000)
+#define SITAR_A_TX_4_MBHC_EN			(0x171)
+#define SITAR_A_TX_4_MBHC_EN__POR			(0x0000000c)
+#define SITAR_A_TX_4_MBHC_ADC			(0x173)
+#define SITAR_A_TX_4_MBHC_ADC__POR			(0x00000044)
+#define SITAR_A_TX_4_MBHC_TEST_CTL			(0x174)
+#define SITAR_A_TX_4_MBHC_TEST_CTL__POR			(0x00000038)
+#define SITAR_A_TX_4_MBHC_SAR_ERR			(0x175)
+#define SITAR_A_TX_4_MBHC_SAR_ERR__POR			(0x00000000)
+#define SITAR_A_TX_4_TXFE_CLKDIV			(0x176)
+#define SITAR_A_TX_4_TXFE_CLKDIV__POR			(0x0000001c)
+#define SITAR_A_AUX_COM_CTL			(0x180)
+#define SITAR_A_AUX_COM_CTL__POR			(0x00000034)
+#define SITAR_A_AUX_COM_ATEST			(0x181)
+#define SITAR_A_AUX_COM_ATEST__POR			(0x00000000)
+#define SITAR_A_AUX_L_EN			(0x182)
+#define SITAR_A_AUX_L_EN__POR			(0x00000000)
+#define SITAR_A_AUX_L_GAIN			(0x183)
+#define SITAR_A_AUX_L_GAIN__POR			(0x0000001f)
+#define SITAR_A_AUX_L_PA_CONN			(0x184)
+#define SITAR_A_AUX_L_PA_CONN__POR			(0x00000000)
+#define SITAR_A_AUX_L_PA_CONN_INV			(0x185)
+#define SITAR_A_AUX_L_PA_CONN_INV__POR			(0x00000000)
+#define SITAR_A_AUX_R_EN			(0x186)
+#define SITAR_A_AUX_R_EN__POR			(0x00000000)
+#define SITAR_A_AUX_R_GAIN			(0x187)
+#define SITAR_A_AUX_R_GAIN__POR			(0x0000001f)
+#define SITAR_A_AUX_R_PA_CONN			(0x188)
+#define SITAR_A_AUX_R_PA_CONN__POR			(0x00000000)
+#define SITAR_A_AUX_R_PA_CONN_INV			(0x189)
+#define SITAR_A_AUX_R_PA_CONN_INV__POR			(0x00000000)
+#define SITAR_A_CP_EN			(0x192)
+#define SITAR_A_CP_EN__POR			(0x000000e6)
+#define SITAR_A_CP_CLK			(0x193)
+#define SITAR_A_CP_CLK__POR			(0x00000029)
+#define SITAR_A_CP_STATIC			(0x194)
+#define SITAR_A_CP_STATIC__POR			(0x00000010)
+#define SITAR_A_CP_DCC1			(0x195)
+#define SITAR_A_CP_DCC1__POR			(0x00000052)
+#define SITAR_A_CP_DCC3			(0x196)
+#define SITAR_A_CP_DCC3__POR			(0x00000001)
+#define SITAR_A_CP_ATEST			(0x197)
+#define SITAR_A_CP_ATEST__POR			(0x00000000)
+#define SITAR_A_CP_DTEST			(0x198)
+#define SITAR_A_CP_DTEST__POR			(0x00000000)
+#define SITAR_A_RX_COM_TIMER_DIV			(0x19E)
+#define SITAR_A_RX_COM_TIMER_DIV__POR			(0x000000e8)
+#define SITAR_A_RX_COM_OCP_CTL			(0x19F)
+#define SITAR_A_RX_COM_OCP_CTL__POR			(0x0000001f)
+#define SITAR_A_RX_COM_OCP_COUNT			(0x1A0)
+#define SITAR_A_RX_COM_OCP_COUNT__POR			(0x00000077)
+#define SITAR_A_RX_COM_DAC_CTL			(0x1A1)
+#define SITAR_A_RX_COM_DAC_CTL__POR			(0x00000000)
+#define SITAR_A_RX_COM_BIAS			(0x1A2)
+#define SITAR_A_RX_COM_BIAS__POR			(0x00000000)
+#define SITAR_A_RX_HPH_BIAS_PA			(0x1A6)
+#define SITAR_A_RX_HPH_BIAS_PA__POR			(0x00000057)
+#define SITAR_A_RX_HPH_BIAS_LDO			(0x1A7)
+#define SITAR_A_RX_HPH_BIAS_LDO__POR			(0x00000056)
+#define SITAR_A_RX_HPH_BIAS_CNP			(0x1A8)
+#define SITAR_A_RX_HPH_BIAS_CNP__POR			(0x0000008a)
+#define SITAR_A_RX_HPH_BIAS_WG			(0x1A9)
+#define SITAR_A_RX_HPH_BIAS_WG__POR			(0x00000060)
+#define SITAR_A_RX_HPH_OCP_CTL			(0x1AA)
+#define SITAR_A_RX_HPH_OCP_CTL__POR			(0x000000e8)
+#define SITAR_A_RX_HPH_CNP_EN			(0x1AB)
+#define SITAR_A_RX_HPH_CNP_EN__POR			(0x00000080)
+#define SITAR_A_RX_HPH_CNP_WG_CTL			(0x1AC)
+#define SITAR_A_RX_HPH_CNP_WG_CTL__POR			(0x000000dc)
+#define SITAR_A_RX_HPH_CNP_WG_TIME			(0x1AD)
+#define SITAR_A_RX_HPH_CNP_WG_TIME__POR			(0x00000028)
+#define SITAR_A_RX_HPH_L_GAIN			(0x1AE)
+#define SITAR_A_RX_HPH_L_GAIN__POR			(0x00000000)
+#define SITAR_A_RX_HPH_L_TEST			(0x1AF)
+#define SITAR_A_RX_HPH_L_TEST__POR			(0x00000001)
+#define SITAR_A_RX_HPH_L_PA_CTL			(0x1B0)
+#define SITAR_A_RX_HPH_L_PA_CTL__POR			(0x00000040)
+#define SITAR_A_RX_HPH_L_DAC_CTL			(0x1B1)
+#define SITAR_A_RX_HPH_L_DAC_CTL__POR			(0x00000000)
+#define SITAR_A_RX_HPH_L_ATEST			(0x1B2)
+#define SITAR_A_RX_HPH_L_ATEST__POR			(0x00000000)
+#define SITAR_A_RX_HPH_L_STATUS			(0x1B3)
+#define SITAR_A_RX_HPH_L_STATUS__POR			(0x00000004)
+#define SITAR_A_RX_HPH_R_GAIN			(0x1B4)
+#define SITAR_A_RX_HPH_R_GAIN__POR			(0x00000000)
+#define SITAR_A_RX_HPH_R_TEST			(0x1B5)
+#define SITAR_A_RX_HPH_R_TEST__POR			(0x00000001)
+#define SITAR_A_RX_HPH_R_PA_CTL			(0x1B6)
+#define SITAR_A_RX_HPH_R_PA_CTL__POR			(0x00000040)
+#define SITAR_A_RX_HPH_R_DAC_CTL			(0x1B7)
+#define SITAR_A_RX_HPH_R_DAC_CTL__POR			(0x00000000)
+#define SITAR_A_RX_HPH_R_ATEST			(0x1B8)
+#define SITAR_A_RX_HPH_R_ATEST__POR			(0x00000000)
+#define SITAR_A_RX_HPH_R_STATUS			(0x1B9)
+#define SITAR_A_RX_HPH_R_STATUS__POR			(0x00000004)
+#define SITAR_A_RX_EAR_BIAS_PA			(0x1BA)
+#define SITAR_A_RX_EAR_BIAS_PA__POR			(0x000000a6)
+#define SITAR_A_RX_EAR_BIAS_CMBUFF			(0x1BB)
+#define SITAR_A_RX_EAR_BIAS_CMBUFF__POR			(0x000000a0)
+#define SITAR_A_RX_EAR_EN			(0x1BC)
+#define SITAR_A_RX_EAR_EN__POR			(0x00000000)
+#define SITAR_A_RX_EAR_GAIN			(0x1BD)
+#define SITAR_A_RX_EAR_GAIN__POR			(0x00000002)
+#define SITAR_A_RX_EAR_CMBUFF			(0x1BE)
+#define SITAR_A_RX_EAR_CMBUFF__POR			(0x00000004)
+#define SITAR_A_RX_EAR_ICTL			(0x1BF)
+#define SITAR_A_RX_EAR_ICTL__POR			(0x00000040)
+#define SITAR_A_RX_EAR_CCOMP			(0x1C0)
+#define SITAR_A_RX_EAR_CCOMP__POR			(0x00000008)
+#define SITAR_A_RX_EAR_VCM			(0x1C1)
+#define SITAR_A_RX_EAR_VCM__POR			(0x00000003)
+#define SITAR_A_RX_EAR_CNP			(0x1C2)
+#define SITAR_A_RX_EAR_CNP__POR			(0x000000f2)
+#define SITAR_A_RX_EAR_ATEST			(0x1C3)
+#define SITAR_A_RX_EAR_ATEST__POR			(0x00000000)
+#define SITAR_A_RX_EAR_STATUS			(0x1C5)
+#define SITAR_A_RX_EAR_STATUS__POR			(0x00000004)
+#define SITAR_A_RX_LINE_BIAS_PA			(0x1C6)
+#define SITAR_A_RX_LINE_BIAS_PA__POR			(0x000000aa)
+#define SITAR_A_RX_LINE_BIAS_LDO			(0x1C7)
+#define SITAR_A_RX_LINE_BIAS_LDO__POR			(0x00000086)
+#define SITAR_A_RX_LINE_BIAS_CNP1			(0x1C8)
+#define SITAR_A_RX_LINE_BIAS_CNP1__POR			(0x00000060)
+#define SITAR_A_RX_LINE_COM			(0x1C9)
+#define SITAR_A_RX_LINE_COM__POR			(0x00000000)
+#define SITAR_A_RX_LINE_CNP_EN			(0x1CA)
+#define SITAR_A_RX_LINE_CNP_EN__POR			(0x00000080)
+#define SITAR_A_RX_LINE_CNP_WG_CTL			(0x1CB)
+#define SITAR_A_RX_LINE_CNP_WG_CTL__POR			(0x000000dc)
+#define SITAR_A_RX_LINE_CNP_WG_TIME			(0x1CC)
+#define SITAR_A_RX_LINE_CNP_WG_TIME__POR			(0x00000028)
+#define SITAR_A_RX_LINE_1_GAIN			(0x1CD)
+#define SITAR_A_RX_LINE_1_GAIN__POR			(0x00000000)
+#define SITAR_A_RX_LINE_1_TEST			(0x1CE)
+#define SITAR_A_RX_LINE_1_TEST__POR			(0x00000001)
+#define SITAR_A_RX_LINE_1_DAC_CTL			(0x1CF)
+#define SITAR_A_RX_LINE_1_DAC_CTL__POR			(0x00000000)
+#define SITAR_A_RX_LINE_1_STATUS			(0x1D0)
+#define SITAR_A_RX_LINE_1_STATUS__POR			(0x00000004)
+#define SITAR_A_RX_LINE_2_GAIN			(0x1D1)
+#define SITAR_A_RX_LINE_2_GAIN__POR			(0x00000000)
+#define SITAR_A_RX_LINE_2_TEST			(0x1D2)
+#define SITAR_A_RX_LINE_2_TEST__POR			(0x00000001)
+#define SITAR_A_RX_LINE_2_DAC_CTL			(0x1D3)
+#define SITAR_A_RX_LINE_2_DAC_CTL__POR			(0x00000000)
+#define SITAR_A_RX_LINE_2_STATUS			(0x1D4)
+#define SITAR_A_RX_LINE_2_STATUS__POR			(0x00000004)
+#define SITAR_A_RX_LINE_BIAS_CNP2			(0x1E1)
+#define SITAR_A_RX_LINE_BIAS_CNP2__POR			(0x0000008a)
+#define SITAR_A_RX_LINE_OCP_CTL			(0x1E2)
+#define SITAR_A_RX_LINE_OCP_CTL__POR			(0x000000e8)
+#define SITAR_A_RX_LINE_1_PA_CTL			(0x1E3)
+#define SITAR_A_RX_LINE_1_PA_CTL__POR			(0x00000040)
+#define SITAR_A_RX_LINE_2_PA_CTL			(0x1E4)
+#define SITAR_A_RX_LINE_2_PA_CTL__POR			(0x00000040)
+#define SITAR_A_RX_LINE_CNP_DBG			(0x1EC)
+#define SITAR_A_RX_LINE_CNP_DBG__POR			(0x00000000)
+#define SITAR_A_MBHC_HPH			(0x1ED)
+#define SITAR_A_MBHC_HPH__POR			(0x00000048)
+#define SITAR_A_RC_OSC_FREQ			(0x1F7)
+#define SITAR_A_RC_OSC_FREQ__POR			(0x00000046)
+#define SITAR_A_RC_OSC_TEST			(0x1F8)
+#define SITAR_A_RC_OSC_TEST__POR			(0x0000000a)
+#define SITAR_A_RC_OSC_STATUS			(0x1F9)
+#define SITAR_A_RC_OSC_STATUS__POR			(0x0000001c)
+#define SITAR_A_RC_OSC_TUNER			(0x1FA)
+#define SITAR_A_RC_OSC_TUNER__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_CTL			(0x200)
+#define SITAR_A_CDC_ANC1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_SHIFT			(0x201)
+#define SITAR_A_CDC_ANC1_SHIFT__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_IIR_B1_CTL			(0x202)
+#define SITAR_A_CDC_ANC1_IIR_B1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_IIR_B2_CTL			(0x203)
+#define SITAR_A_CDC_ANC1_IIR_B2_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_IIR_B3_CTL			(0x204)
+#define SITAR_A_CDC_ANC1_IIR_B3_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_IIR_B4_CTL			(0x205)
+#define SITAR_A_CDC_ANC1_IIR_B4_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_LPF_B1_CTL			(0x206)
+#define SITAR_A_CDC_ANC1_LPF_B1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_LPF_B2_CTL			(0x207)
+#define SITAR_A_CDC_ANC1_LPF_B2_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_LPF_B3_CTL			(0x208)
+#define SITAR_A_CDC_ANC1_LPF_B3_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_SPARE			(0x209)
+#define SITAR_A_CDC_ANC1_SPARE__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_SMLPF_CTL			(0x20A)
+#define SITAR_A_CDC_ANC1_SMLPF_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_ANC1_DCFLT_CTL			(0x20B)
+#define SITAR_A_CDC_ANC1_DCFLT_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_TX1_VOL_CTL_TIMER			(0x220)
+#define SITAR_A_CDC_TX1_VOL_CTL_TIMER__POR			(0x00000000)
+#define SITAR_A_CDC_TX1_VOL_CTL_GAIN			(0x221)
+#define SITAR_A_CDC_TX1_VOL_CTL_GAIN__POR			(0x00000000)
+#define SITAR_A_CDC_TX2_VOL_CTL_GAIN			(0x229)
+#define SITAR_A_CDC_TX2_VOL_CTL_GAIN__POR			   (0x00000000)
+#define SITAR_A_CDC_TX3_VOL_CTL_GAIN			(0x231)
+#define SITAR_A_CDC_TX3_VOL_CTL_GAIN__POR			   (0x00000000)
+#define SITAR_A_CDC_TX4_VOL_CTL_GAIN			(0x239)
+#define SITAR_A_CDC_TX4_VOL_CTL_GAIN__POR			   (0x00000000)
+#define SITAR_A_CDC_TX5_VOL_CTL_GAIN			(0x241)
+#define SITAR_A_CDC_TX5_VOL_CTL_GAIN__POR			   (0x00000000)
+#define SITAR_A_CDC_TX1_VOL_CTL_CFG			 (0x222)
+#define SITAR_A_CDC_TX1_VOL_CTL_CFG__POR			    (0x00000000)
+#define SITAR_A_CDC_TX2_VOL_CTL_CFG			 (0x22A)
+#define SITAR_A_CDC_TX2_VOL_CTL_CFG__POR			    (0x00000000)
+#define SITAR_A_CDC_TX3_VOL_CTL_CFG			 (0x232)
+#define SITAR_A_CDC_TX3_VOL_CTL_CFG__POR			    (0x00000000)
+#define SITAR_A_CDC_TX4_VOL_CTL_CFG			 (0x23A)
+#define SITAR_A_CDC_TX4_VOL_CTL_CFG__POR			    (0x00000000)
+
+#define SITAR_A_CDC_TX1_MUX_CTL			(0x223)
+#define SITAR_A_CDC_TX1_MUX_CTL__POR			(0x00000008)
+#define SITAR_A_CDC_TX1_CLK_FS_CTL                      (0x00000224)
+#define SITAR_A_CDC_TX1_CLK_FS_CTL__POR                 (0x00000003)
+#define SITAR_A_CDC_TX2_CLK_FS_CTL                      (0x0000022C)
+#define SITAR_A_CDC_TX2_CLK_FS_CTL__POR                 (0x00000003)
+#define SITAR_A_CDC_TX3_CLK_FS_CTL                      (0x00000234)
+#define SITAR_A_CDC_TX3_CLK_FS_CTL__POR                 (0x00000003)
+#define SITAR_A_CDC_TX4_CLK_FS_CTL                      (0x0000023C)
+#define SITAR_A_CDC_TX4_CLK_FS_CTL__POR                 (0x00000003)
+#define SITAR_A_CDC_TX1_DMIC_CTL			(0x225)
+#define SITAR_A_CDC_TX1_DMIC_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_TX2_MUX_CTL                 (0x22B)
+#define SITAR_A_CDC_TX2_MUX_CTL__POR			(0x00000008)
+#define SITAR_A_CDC_TX3_MUX_CTL                 (0x233)
+#define SITAR_A_CDC_TX3_MUX_CTL__POR			(0x00000008)
+#define SITAR_A_CDC_TX4_MUX_CTL                 (0x23B)
+#define SITAR_A_CDC_TX4_MUX_CTL__POR			(0x00000008)
+#define SITAR_A_CDC_TX5_MUX_CTL                 (0x243)
+#define SITAR_A_CDC_TX5_MUX_CTL__POR			(0x00000008)
+
+#define SITAR_A_CDC_SRC1_PDA_CFG			(0x2A0)
+#define SITAR_A_CDC_SRC1_PDA_CFG__POR			(0x00000000)
+#define SITAR_A_CDC_SRC1_FS_CTL			(0x2A1)
+#define SITAR_A_CDC_SRC1_FS_CTL__POR			(0x0000001b)
+
+#define SITAR_A_CDC_RX1_B1_CTL                  (0x000002B0)
+#define SITAR_A_CDC_RX1_B1_CTL__POR			 (0x00000000)
+#define SITAR_A_CDC_RX2_B1_CTL                  (0x000002B8)
+#define SITAR_A_CDC_RX2_B1_CTL__POR			 (0x00000000)
+#define SITAR_A_CDC_RX3_B1_CTL                  (0x000002C0)
+#define SITAR_A_CDC_RX3_B1_CTL__POR			 (0x00000000)
+
+#define SITAR_A_CDC_RX1_B2_CTL                  (0x000002B1)
+#define SITAR_A_CDC_RX1_B2_CTL__POR			 (0x00000000)
+#define SITAR_A_CDC_RX2_B2_CTL                  (0x000002B9)
+#define SITAR_A_CDC_RX2_B2_CTL__POR			 (0x00000000)
+#define SITAR_A_CDC_RX3_B2_CTL                  (0x000002C1)
+#define SITAR_A_CDC_RX3_B2_CTL__POR			 (0x00000000)
+
+#define SITAR_A_CDC_RX1_B3_CTL                  (0x000002B2)
+#define SITAR_A_CDC_RX1_B3_CTL__POR			 (0x00000000)
+#define SITAR_A_CDC_RX2_B3_CTL                  (0x000002BA)
+#define SITAR_A_CDC_RX2_B3_CTL__POR			 (0x00000000)
+#define SITAR_A_CDC_RX3_B3_CTL                  (0x000002C2)
+#define SITAR_A_CDC_RX3_B3_CTL__POR			 (0x00000000)
+
+#define SITAR_A_CDC_RX1_B4_CTL                  (0x000002B3)
+#define SITAR_A_CDC_RX1_B4_CTL__POR			 (0x00000000)
+#define SITAR_A_CDC_RX2_B4_CTL                  (0x000002BB)
+#define SITAR_A_CDC_RX2_B4_CTL__POR			 (0x00000000)
+#define SITAR_A_CDC_RX3_B4_CTL                  (0x000002C3)
+#define SITAR_A_CDC_RX3_B4_CTL__POR			 (0x00000000)
+
+#define SITAR_A_CDC_RX1_B5_CTL                  (0x000002B4)
+#define SITAR_A_CDC_RX1_B5_CTL__POR			 (0x00000078)
+#define SITAR_A_CDC_RX2_B5_CTL                  (0x000002BC)
+#define SITAR_A_CDC_RX2_B5_CTL__POR			 (0x00000078)
+#define SITAR_A_CDC_RX3_B5_CTL                  (0x000002C4)
+#define SITAR_A_CDC_RX3_B5_CTL__POR			 (0x00000078)
+
+#define SITAR_A_CDC_RX1_B6_CTL                  (0x000002B5)
+#define SITAR_A_CDC_RX1_B6_CTL__POR			 (0x00000080)
+#define SITAR_A_CDC_RX2_B6_CTL                  (0x000002BD)
+#define SITAR_A_CDC_RX2_B6_CTL__POR			 (0x00000080)
+#define SITAR_A_CDC_RX3_B6_CTL                  (0x000002C5)
+#define SITAR_A_CDC_RX3_B6_CTL__POR			 (0x00000080)
+
+
+#define SITAR_A_CDC_RX1_VOL_CTL_B1_CTL			(0x2B6)
+#define SITAR_A_CDC_RX1_VOL_CTL_B1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_RX1_VOL_CTL_B2_CTL			(0x2B7)
+#define SITAR_A_CDC_RX1_VOL_CTL_B2_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_RX2_VOL_CTL_B2_CTL                  (0x2BF)
+#define SITAR_A_CDC_RX2_VOL_CTL_B2_CTL__POR                     (0x00000000)
+#define SITAR_A_CDC_RX3_VOL_CTL_B2_CTL			(0x2C7)
+#define SITAR_A_CDC_RX3_VOL_CTL_B2_CTL__POR                     (0x00000000)
+
+#define SITAR_A_CDC_CLK_ANC_RESET_CTL			(0x300)
+#define SITAR_A_CDC_CLK_ANC_RESET_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_RX_RESET_CTL			(0x301)
+#define SITAR_A_CDC_CLK_RX_RESET_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_TX_RESET_B1_CTL			(0x302)
+#define SITAR_A_CDC_CLK_TX_RESET_B1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_TX_RESET_B2_CTL			(0x303)
+#define SITAR_A_CDC_CLK_TX_RESET_B2_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_DMIC_CTL			(0x304)
+#define SITAR_A_CDC_CLK_DMIC_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_RX_I2S_CTL			(0x305)
+#define SITAR_A_CDC_CLK_RX_I2S_CTL__POR			(0x00000003)
+#define SITAR_A_CDC_CLK_TX_I2S_CTL			(0x306)
+#define SITAR_A_CDC_CLK_TX_I2S_CTL__POR			(0x00000003)
+#define SITAR_A_CDC_CLK_OTHR_RESET_CTL			(0x307)
+#define SITAR_A_CDC_CLK_OTHR_RESET_CTL__POR			(0x00000010)
+#define SITAR_A_CDC_CLK_TX_CLK_EN_B1_CTL			(0x308)
+#define SITAR_A_CDC_CLK_TX_CLK_EN_B1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_OTHR_CTL			(0x30A)
+#define SITAR_A_CDC_CLK_OTHR_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_RDAC_CLK_EN_CTL			(0x30B)
+#define SITAR_A_CDC_CLK_RDAC_CLK_EN_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_ANC_CLK_EN_CTL			(0x30C)
+#define SITAR_A_CDC_CLK_ANC_CLK_EN_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_RX_B1_CTL			(0x30D)
+#define SITAR_A_CDC_CLK_RX_B1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_RX_B2_CTL			(0x30E)
+#define SITAR_A_CDC_CLK_RX_B2_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_MCLK_CTL			(0x30F)
+#define SITAR_A_CDC_CLK_MCLK_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_PDM_CTL			(0x310)
+#define SITAR_A_CDC_CLK_PDM_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_SD_CTL			(0x311)
+#define SITAR_A_CDC_CLK_SD_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLK_LP_CTL			(0x312)
+#define SITAR_A_CDC_CLK_LP_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CLSG_FREQ_THRESH_B1_CTL			(0x320)
+#define SITAR_A_CDC_CLSG_FREQ_THRESH_B1_CTL__POR	(0x00000007)
+#define SITAR_A_CDC_CLSG_FREQ_THRESH_B2_CTL		(0x321)
+#define SITAR_A_CDC_CLSG_FREQ_THRESH_B2_CTL__POR	(0x00000013)
+#define SITAR_A_CDC_CLSG_FREQ_THRESH_B3_CTL		(0x322)
+#define SITAR_A_CDC_CLSG_FREQ_THRESH_B3_CTL__POR	(0x0000001b)
+#define SITAR_A_CDC_CLSG_FREQ_THRESH_B4_CTL		(0x323)
+#define SITAR_A_CDC_CLSG_FREQ_THRESH_B4_CTL__POR	(0x0000007f)
+#define SITAR_A_CDC_CLSG_GAIN_THRESH_CTL		(0x324)
+#define SITAR_A_CDC_CLSG_GAIN_THRESH_CTL__POR		(0x00000026)
+#define SITAR_A_CDC_CLSG_TIMER_B1_CFG			(0x325)
+#define SITAR_A_CDC_CLSG_TIMER_B1_CFG__POR		(0x0000000a)
+#define SITAR_A_CDC_CLSG_TIMER_B2_CFG			(0x326)
+#define SITAR_A_CDC_CLSG_TIMER_B2_CFG__POR		(0x00000000)
+#define SITAR_A_CDC_CLSG_CTL			(0x327)
+#define SITAR_A_CDC_CLSG_CTL__POR			(0x00000013)
+#define SITAR_A_CDC_IIR1_GAIN_B1_CTL			(0x340)
+#define SITAR_A_CDC_IIR1_GAIN_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_GAIN_B2_CTL			(0x341)
+#define SITAR_A_CDC_IIR1_GAIN_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_GAIN_B3_CTL			(0x342)
+#define SITAR_A_CDC_IIR1_GAIN_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_GAIN_B4_CTL			(0x343)
+#define SITAR_A_CDC_IIR1_GAIN_B4_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_GAIN_B5_CTL			(0x344)
+#define SITAR_A_CDC_IIR1_GAIN_B5_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_GAIN_B6_CTL			(0x345)
+#define SITAR_A_CDC_IIR1_GAIN_B6_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_GAIN_B7_CTL			(0x346)
+#define SITAR_A_CDC_IIR1_GAIN_B7_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_GAIN_B8_CTL			(0x347)
+#define SITAR_A_CDC_IIR1_GAIN_B8_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_CTL				(0x348)
+#define SITAR_A_CDC_IIR1_CTL__POR			(0x00000040)
+#define SITAR_A_CDC_IIR1_GAIN_TIMER_CTL			(0x349)
+#define SITAR_A_CDC_IIR1_GAIN_TIMER_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_COEF_B1_CTL			(0x34A)
+#define SITAR_A_CDC_IIR1_COEF_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_COEF_B2_CTL			(0x34B)
+#define SITAR_A_CDC_IIR1_COEF_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_COEF_B3_CTL			(0x34C)
+#define SITAR_A_CDC_IIR1_COEF_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_COEF_B4_CTL			(0x34D)
+#define SITAR_A_CDC_IIR1_COEF_B4_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR1_COEF_B5_CTL			(0x34E)
+#define SITAR_A_CDC_IIR1_COEF_B5_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_GAIN_B1_CTL			(0x350)
+#define SITAR_A_CDC_IIR2_GAIN_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_GAIN_B2_CTL			(0x351)
+#define SITAR_A_CDC_IIR2_GAIN_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_GAIN_B3_CTL			(0x352)
+#define SITAR_A_CDC_IIR2_GAIN_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_GAIN_B4_CTL			(0x353)
+#define SITAR_A_CDC_IIR2_GAIN_B4_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_GAIN_B5_CTL			(0x354)
+#define SITAR_A_CDC_IIR2_GAIN_B5_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_GAIN_B6_CTL			(0x355)
+#define SITAR_A_CDC_IIR2_GAIN_B6_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_GAIN_B7_CTL			(0x356)
+#define SITAR_A_CDC_IIR2_GAIN_B7_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_GAIN_B8_CTL			(0x357)
+#define SITAR_A_CDC_IIR2_GAIN_B8_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_CTL				(0x358)
+#define SITAR_A_CDC_IIR2_CTL__POR			(0x00000040)
+#define SITAR_A_CDC_IIR2_GAIN_TIMER_CTL			(0x359)
+#define SITAR_A_CDC_IIR2_GAIN_TIMER_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_COEF_B1_CTL			(0x35A)
+#define SITAR_A_CDC_IIR2_COEF_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_COEF_B2_CTL			(0x35B)
+#define SITAR_A_CDC_IIR2_COEF_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_COEF_B3_CTL			(0x35C)
+#define SITAR_A_CDC_IIR2_COEF_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_COEF_B4_CTL			(0x35D)
+#define SITAR_A_CDC_IIR2_COEF_B4_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_IIR2_COEF_B5_CTL			(0x35E)
+#define SITAR_A_CDC_IIR2_COEF_B5_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_TOP_GAIN_UPDATE			(0x360)
+#define SITAR_A_CDC_TOP_GAIN_UPDATE__POR		(0x00000000)
+#define SITAR_A_CDC_TOP_RDAC_DOUT_CTL			(0x361)
+#define SITAR_A_CDC_TOP_RDAC_DOUT_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_DEBUG_B1_CTL			(0x368)
+#define SITAR_A_CDC_DEBUG_B1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_DEBUG_B2_CTL			(0x369)
+#define SITAR_A_CDC_DEBUG_B2_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_DEBUG_B3_CTL			(0x36A)
+#define SITAR_A_CDC_DEBUG_B3_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_DEBUG_B4_CTL			(0x36B)
+#define SITAR_A_CDC_DEBUG_B4_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_DEBUG_B5_CTL			(0x36C)
+#define SITAR_A_CDC_DEBUG_B5_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_DEBUG_B6_CTL			(0x36D)
+#define SITAR_A_CDC_DEBUG_B6_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_DEBUG_B7_CTL			(0x36E)
+#define SITAR_A_CDC_DEBUG_B7_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_COMP1_B1_CTL			(0x370)
+#define SITAR_A_CDC_COMP1_B1_CTL__POR			(0x00000030)
+#define SITAR_A_CDC_COMP1_B2_CTL			(0x371)
+#define SITAR_A_CDC_COMP1_B2_CTL__POR			(0x000000b5)
+#define SITAR_A_CDC_COMP1_B3_CTL			(0x372)
+#define SITAR_A_CDC_COMP1_B3_CTL__POR			(0x00000028)
+#define SITAR_A_CDC_COMP1_B4_CTL			(0x373)
+#define SITAR_A_CDC_COMP1_B4_CTL__POR			(0x0000003c)
+#define SITAR_A_CDC_COMP1_B5_CTL			(0x374)
+#define SITAR_A_CDC_COMP1_B5_CTL__POR			(0x0000001f)
+#define SITAR_A_CDC_COMP1_B6_CTL			(0x375)
+#define SITAR_A_CDC_COMP1_B6_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_COMP1_SHUT_DOWN_STATUS		(0x376)
+#define SITAR_A_CDC_COMP1_SHUT_DOWN_STATUS__POR		(0x00000003)
+#define SITAR_A_CDC_COMP1_FS_CFG			(0x377)
+#define SITAR_A_CDC_COMP1_FS_CFG__POR			(0x0000001b)
+#define SITAR_A_CDC_CONN_RX1_B1_CTL			(0x380)
+#define SITAR_A_CDC_CONN_RX1_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX1_B2_CTL			(0x381)
+#define SITAR_A_CDC_CONN_RX1_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX1_B3_CTL			(0x382)
+#define SITAR_A_CDC_CONN_RX1_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX2_B1_CTL			(0x383)
+#define SITAR_A_CDC_CONN_RX2_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX2_B2_CTL			(0x384)
+#define SITAR_A_CDC_CONN_RX2_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX2_B3_CTL			(0x385)
+#define SITAR_A_CDC_CONN_RX2_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX3_B1_CTL			(0x386)
+#define SITAR_A_CDC_CONN_RX3_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX3_B2_CTL			(0x387)
+#define SITAR_A_CDC_CONN_RX3_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX3_B3_CTL			(0x388)
+#define SITAR_A_CDC_CONN_RX3_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_ANC_B1_CTL			(0x391)
+#define SITAR_A_CDC_CONN_ANC_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_ANC_B2_CTL			(0x392)
+#define SITAR_A_CDC_CONN_ANC_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_TX_B1_CTL			(0x393)
+#define SITAR_A_CDC_CONN_TX_B1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CONN_TX_B2_CTL			(0x394)
+#define SITAR_A_CDC_CONN_TX_B2_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CONN_EQ1_B1_CTL			(0x397)
+#define SITAR_A_CDC_CONN_EQ1_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_EQ1_B2_CTL			(0x398)
+#define SITAR_A_CDC_CONN_EQ1_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_EQ1_B3_CTL			(0x399)
+#define SITAR_A_CDC_CONN_EQ1_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_EQ1_B4_CTL			(0x39A)
+#define SITAR_A_CDC_CONN_EQ1_B4_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_EQ2_B1_CTL			(0x39B)
+#define SITAR_A_CDC_CONN_EQ2_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_EQ2_B2_CTL			(0x39C)
+#define SITAR_A_CDC_CONN_EQ2_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_EQ2_B3_CTL			(0x39D)
+#define SITAR_A_CDC_CONN_EQ2_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_EQ2_B4_CTL			(0x39E)
+#define SITAR_A_CDC_CONN_EQ2_B4_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_SRC1_B1_CTL			(0x39F)
+#define SITAR_A_CDC_CONN_SRC1_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_SRC1_B2_CTL			(0x3A0)
+#define SITAR_A_CDC_CONN_SRC1_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_SRC2_B1_CTL			(0x3A1)
+#define SITAR_A_CDC_CONN_SRC2_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_SRC2_B2_CTL			(0x3A2)
+#define SITAR_A_CDC_CONN_SRC2_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_TX_SB_B1_CTL			(0x3A3)
+#define SITAR_A_CDC_CONN_TX_SB_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_TX_SB_B2_CTL			(0x3A4)
+#define SITAR_A_CDC_CONN_TX_SB_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_TX_SB_B3_CTL			(0x3A5)
+#define SITAR_A_CDC_CONN_TX_SB_B3_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_TX_SB_B4_CTL			(0x3A6)
+#define SITAR_A_CDC_CONN_TX_SB_B4_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_TX_SB_B5_CTL			(0x3A7)
+#define SITAR_A_CDC_CONN_TX_SB_B5_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX_SB_B1_CTL			(0x3AE)
+#define SITAR_A_CDC_CONN_RX_SB_B1_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_RX_SB_B2_CTL			(0x3AF)
+#define SITAR_A_CDC_CONN_RX_SB_B2_CTL__POR		(0x00000000)
+#define SITAR_A_CDC_CONN_CLSG_CTL			(0x3B0)
+#define SITAR_A_CDC_CONN_CLSG_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_CONN_SPARE			(0x3B1)
+#define SITAR_A_CDC_CONN_SPARE__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_EN_CTL			(0x3C0)
+#define SITAR_A_CDC_MBHC_EN_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_FIR_B1_CFG			(0x3C1)
+#define SITAR_A_CDC_MBHC_FIR_B1_CFG__POR		(0x00000000)
+#define SITAR_A_CDC_MBHC_FIR_B2_CFG			(0x3C2)
+#define SITAR_A_CDC_MBHC_FIR_B2_CFG__POR		(0x00000006)
+#define SITAR_A_CDC_MBHC_TIMER_B1_CTL			(0x3C3)
+#define SITAR_A_CDC_MBHC_TIMER_B1_CTL__POR		(0x00000003)
+#define SITAR_A_CDC_MBHC_TIMER_B2_CTL			(0x3C4)
+#define SITAR_A_CDC_MBHC_TIMER_B2_CTL__POR		(0x00000009)
+#define SITAR_A_CDC_MBHC_TIMER_B3_CTL			(0x3C5)
+#define SITAR_A_CDC_MBHC_TIMER_B3_CTL__POR		(0x0000001e)
+#define SITAR_A_CDC_MBHC_TIMER_B4_CTL			(0x3C6)
+#define SITAR_A_CDC_MBHC_TIMER_B4_CTL__POR		(0x00000045)
+#define SITAR_A_CDC_MBHC_TIMER_B5_CTL			(0x3C7)
+#define SITAR_A_CDC_MBHC_TIMER_B5_CTL__POR		(0x00000004)
+#define SITAR_A_CDC_MBHC_TIMER_B6_CTL			(0x3C8)
+#define SITAR_A_CDC_MBHC_TIMER_B6_CTL__POR		(0x00000078)
+#define SITAR_A_CDC_MBHC_B1_STATUS			(0x3C9)
+#define SITAR_A_CDC_MBHC_B1_STATUS__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_B2_STATUS			(0x3CA)
+#define SITAR_A_CDC_MBHC_B2_STATUS__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_B3_STATUS			(0x3CB)
+#define SITAR_A_CDC_MBHC_B3_STATUS__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_B4_STATUS			(0x3CC)
+#define SITAR_A_CDC_MBHC_B4_STATUS__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_B5_STATUS			(0x3CD)
+#define SITAR_A_CDC_MBHC_B5_STATUS__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_B1_CTL			(0x3CE)
+#define SITAR_A_CDC_MBHC_B1_CTL__POR			(0x000000c0)
+#define SITAR_A_CDC_MBHC_B2_CTL			(0x3CF)
+#define SITAR_A_CDC_MBHC_B2_CTL__POR			(0x0000005d)
+#define SITAR_A_CDC_MBHC_VOLT_B1_CTL			(0x3D0)
+#define SITAR_A_CDC_MBHC_VOLT_B1_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_VOLT_B2_CTL			(0x3D1)
+#define SITAR_A_CDC_MBHC_VOLT_B2_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_VOLT_B3_CTL			(0x3D2)
+#define SITAR_A_CDC_MBHC_VOLT_B3_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_VOLT_B4_CTL			(0x3D3)
+#define SITAR_A_CDC_MBHC_VOLT_B4_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_VOLT_B5_CTL			(0x3D4)
+#define SITAR_A_CDC_MBHC_VOLT_B5_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_VOLT_B6_CTL			(0x3D5)
+#define SITAR_A_CDC_MBHC_VOLT_B6_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_VOLT_B7_CTL			(0x3D6)
+#define SITAR_A_CDC_MBHC_VOLT_B7_CTL__POR			(0x000000ff)
+#define SITAR_A_CDC_MBHC_VOLT_B8_CTL			(0x3D7)
+#define SITAR_A_CDC_MBHC_VOLT_B8_CTL__POR			(0x00000007)
+#define SITAR_A_CDC_MBHC_VOLT_B9_CTL			(0x3D8)
+#define SITAR_A_CDC_MBHC_VOLT_B9_CTL__POR			(0x000000ff)
+#define SITAR_A_CDC_MBHC_VOLT_B10_CTL			(0x3D9)
+#define SITAR_A_CDC_MBHC_VOLT_B10_CTL__POR			(0x0000007f)
+#define SITAR_A_CDC_MBHC_VOLT_B11_CTL			(0x3DA)
+#define SITAR_A_CDC_MBHC_VOLT_B11_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_VOLT_B12_CTL			(0x3DB)
+#define SITAR_A_CDC_MBHC_VOLT_B12_CTL__POR			(0x00000080)
+#define SITAR_A_CDC_MBHC_CLK_CTL			(0x3DC)
+#define SITAR_A_CDC_MBHC_CLK_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_INT_CTL			(0x3DD)
+#define SITAR_A_CDC_MBHC_INT_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_DEBUG_CTL			(0x3DE)
+#define SITAR_A_CDC_MBHC_DEBUG_CTL__POR			(0x00000000)
+#define SITAR_A_CDC_MBHC_SPARE			(0x3DF)
+#define SITAR_A_CDC_MBHC_SPARE__POR			(0x00000000)
+/* SLIMBUS Slave Registers */
+#define SITAR_SLIM_PGD_PORT_INT_EN0			 (0x30)
+#define SITAR_SLIM_PGD_PORT_INT_STATUS0                 (0x34)
+#define SITAR_SLIM_PGD_PORT_INT_CLR0			(0x38)
+#define SITAR_SLIM_PGD_PORT_INT_SOURCE0                 (0x60)
+
+/* Macros for Packing Register Writes into a U32 */
+#define SITAR_PACKED_REG_SIZE sizeof(u32)
+
+#define SITAR_CODEC_PACK_ENTRY(reg, mask, val) ((val & 0xff)|\
+	((mask & 0xff) << 8)|((reg & 0xffff) << 16))
+
+#define SITAR_CODEC_UNPACK_ENTRY(packed, reg, mask, val) \
+	do { \
+		((reg) = ((packed >> 16) & (0xffff))); \
+		((mask) = ((packed >> 8) & (0xff))); \
+		((val) = ((packed) & (0xff))); \
+	} while (0);
+#endif
diff --git a/include/linux/mfd/wcd9xxx/wcd9310_registers.h b/include/linux/mfd/wcd9xxx/wcd9310_registers.h
new file mode 100644
index 0000000..e0809e77
--- /dev/null
+++ b/include/linux/mfd/wcd9xxx/wcd9310_registers.h
@@ -0,0 +1,1117 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef TABLA_CODEC_DIGITAL_H
+
+#define TABLA_CODEC_DIGITAL_H
+#include <linux/mfd/wcd9xxx/wcd9xxx_registers.h>
+
+#define TABLA_A_CHIP_CTL			WCD9XXX_A_CHIP_CTL
+#define TABLA_A_CHIP_CTL__POR			WCD9XXX_A_CHIP_CTL__POR
+#define TABLA_A_CHIP_STATUS			WCD9XXX_A_CHIP_STATUS
+#define TABLA_A_CHIP_STATUS__POR		WCD9XXX_A_CHIP_STATUS__POR
+#define TABLA_A_CHIP_ID_BYTE_0			WCD9XXX_A_CHIP_ID_BYTE_0
+#define TABLA_A_CHIP_ID_BYTE_0__POR		WCD9XXX_A_CHIP_ID_BYTE_0__POR
+#define TABLA_A_CHIP_ID_BYTE_1			WCD9XXX_A_CHIP_ID_BYTE_1
+#define TABLA_A_CHIP_ID_BYTE_1__POR		WCD9XXX_A_CHIP_ID_BYTE_1__POR
+#define TABLA_A_CHIP_ID_BYTE_2			WCD9XXX_A_CHIP_ID_BYTE_2
+#define TABLA_A_CHIP_ID_BYTE_2__POR		WCD9XXX_A_CHIP_ID_BYTE_2__POR
+#define TABLA_A_CHIP_ID_BYTE_3			WCD9XXX_A_CHIP_ID_BYTE_3
+#define TABLA_A_CHIP_ID_BYTE_3__POR		WCD9XXX_A_CHIP_ID_BYTE_3__POR
+#define TABLA_A_CHIP_VERSION			WCD9XXX_A_CHIP_VERSION
+#define TABLA_A_CHIP_VERSION__POR		WCD9XXX_A_CHIP_VERSION__POR
+#define TABLA_A_SB_VERSION			WCD9XXX_A_SB_VERSION
+#define TABLA_A_SB_VERSION__POR			WCD9XXX_A_SB_VERSION__POR
+#define TABLA_A_SLAVE_ID_1			WCD9XXX_A_SLAVE_ID_1
+#define TABLA_A_SLAVE_ID_1__POR			WCD9XXX_A_SLAVE_ID_1__POR
+#define TABLA_A_SLAVE_ID_2			WCD9XXX_A_SLAVE_ID_2
+#define TABLA_A_SLAVE_ID_2__POR			WCD9XXX_A_SLAVE_ID_2__POR
+#define TABLA_A_SLAVE_ID_3			WCD9XXX_A_SLAVE_ID_3
+#define TABLA_A_SLAVE_ID_3__POR			WCD9XXX_A_SLAVE_ID_3__POR
+#define TABLA_A_PIN_CTL_OE0			(0x10)
+#define TABLA_A_PIN_CTL_OE0__POR			(0x00000000)
+#define TABLA_A_PIN_CTL_OE1			(0x11)
+#define TABLA_A_PIN_CTL_OE1__POR			(0x00000000)
+#define TABLA_A_PIN_CTL_DATA0			(0x12)
+#define TABLA_A_PIN_CTL_DATA0__POR			(0x00000000)
+#define TABLA_A_PIN_CTL_DATA1			(0x13)
+#define TABLA_A_PIN_CTL_DATA1__POR			(0x00000000)
+#define TABLA_A_HDRIVE_GENERIC			(0x18)
+#define TABLA_A_HDRIVE_GENERIC__POR			(0x00000000)
+#define TABLA_A_HDRIVE_OVERRIDE			(0x19)
+#define TABLA_A_HDRIVE_OVERRIDE__POR			(0x00000008)
+#define TABLA_A_ANA_CSR_WAIT_STATE			(0x20)
+#define TABLA_A_ANA_CSR_WAIT_STATE__POR			(0x00000044)
+#define TABLA_A_PROCESS_MONITOR_CTL0			(0x40)
+#define TABLA_A_PROCESS_MONITOR_CTL0__POR			(0x00000080)
+#define TABLA_A_PROCESS_MONITOR_CTL1			(0x41)
+#define TABLA_A_PROCESS_MONITOR_CTL1__POR			(0x00000000)
+#define TABLA_A_PROCESS_MONITOR_CTL2			(0x42)
+#define TABLA_A_PROCESS_MONITOR_CTL2__POR			(0x00000000)
+#define TABLA_A_PROCESS_MONITOR_CTL3			(0x43)
+#define TABLA_A_PROCESS_MONITOR_CTL3__POR			(0x00000001)
+#define TABLA_A_QFUSE_CTL			(0x48)
+#define TABLA_A_QFUSE_CTL__POR			(0x00000000)
+#define TABLA_A_QFUSE_STATUS			(0x49)
+#define TABLA_A_QFUSE_STATUS__POR			(0x00000000)
+#define TABLA_A_QFUSE_DATA_OUT0			(0x4A)
+#define TABLA_A_QFUSE_DATA_OUT0__POR			(0x00000000)
+#define TABLA_A_QFUSE_DATA_OUT1			(0x4B)
+#define TABLA_A_QFUSE_DATA_OUT1__POR			(0x00000000)
+#define TABLA_A_QFUSE_DATA_OUT2			(0x4C)
+#define TABLA_A_QFUSE_DATA_OUT2__POR			(0x00000000)
+#define TABLA_A_QFUSE_DATA_OUT3			(0x4D)
+#define TABLA_A_QFUSE_DATA_OUT3__POR			(0x00000000)
+#define TABLA_A_CDC_CTL				WCD9XXX_A_CDC_CTL
+#define TABLA_A_CDC_CTL__POR			WCD9XXX_A_CDC_CTL__POR
+#define TABLA_A_LEAKAGE_CTL			WCD9XXX_A_LEAKAGE_CTL
+#define TABLA_A_LEAKAGE_CTL__POR		WCD9XXX_A_LEAKAGE_CTL__POR
+#define TABLA_A_INTR_MODE			(0x90)
+#define TABLA_A_INTR_MODE__POR			(0x00000000)
+#define TABLA_A_INTR_MASK0			(0x94)
+#define TABLA_A_INTR_MASK0__POR			(0x000000ff)
+#define TABLA_A_INTR_MASK1			(0x95)
+#define TABLA_A_INTR_MASK1__POR			(0x000000ff)
+#define TABLA_A_INTR_MASK2			(0x96)
+#define TABLA_A_INTR_MASK2__POR			(0x000000ff)
+#define TABLA_A_INTR_STATUS0			(0x98)
+#define TABLA_A_INTR_STATUS0__POR			(0x00000000)
+#define TABLA_A_INTR_STATUS1			(0x99)
+#define TABLA_A_INTR_STATUS1__POR			(0x00000000)
+#define TABLA_A_INTR_STATUS2			(0x9A)
+#define TABLA_A_INTR_STATUS2__POR			(0x00000000)
+#define TABLA_A_INTR_CLEAR0			(0x9C)
+#define TABLA_A_INTR_CLEAR0__POR			(0x00000000)
+#define TABLA_A_INTR_CLEAR1			(0x9D)
+#define TABLA_A_INTR_CLEAR1__POR			(0x00000000)
+#define TABLA_A_INTR_CLEAR2			(0x9E)
+#define TABLA_A_INTR_CLEAR2__POR			(0x00000000)
+#define TABLA_A_INTR_LEVEL0			(0xA0)
+#define TABLA_A_INTR_LEVEL0__POR			(0x00000001)
+#define TABLA_A_INTR_LEVEL1			(0xA1)
+#define TABLA_A_INTR_LEVEL1__POR			(0x00000000)
+#define TABLA_A_INTR_LEVEL2			(0xA2)
+#define TABLA_A_INTR_LEVEL2__POR			(0x00000000)
+#define TABLA_A_INTR_TEST0			(0xA4)
+#define TABLA_A_INTR_TEST0__POR			(0x00000000)
+#define TABLA_A_INTR_TEST1			(0xA5)
+#define TABLA_A_INTR_TEST1__POR			(0x00000000)
+#define TABLA_A_INTR_TEST2			(0xA6)
+#define TABLA_A_INTR_TEST2__POR			(0x00000000)
+#define TABLA_A_INTR_SET0			(0xA8)
+#define TABLA_A_INTR_SET0__POR			(0x00000000)
+#define TABLA_A_INTR_SET1			(0xA9)
+#define TABLA_A_INTR_SET1__POR			(0x00000000)
+#define TABLA_A_INTR_SET2			(0xAA)
+#define TABLA_A_INTR_SET2__POR			(0x00000000)
+#define TABLA_A_CDC_TX_I2S_SCK_MODE			(0xC0)
+#define TABLA_A_CDC_TX_I2S_SCK_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_TX_I2S_WS_MODE			(0xC1)
+#define TABLA_A_CDC_TX_I2S_WS_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_DMIC_DATA0_MODE			(0xC4)
+#define TABLA_A_CDC_DMIC_DATA0_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_DMIC_CLK0_MODE			(0xC5)
+#define TABLA_A_CDC_DMIC_CLK0_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_DMIC_DATA1_MODE			(0xC6)
+#define TABLA_A_CDC_DMIC_DATA1_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_DMIC_CLK1_MODE			(0xC7)
+#define TABLA_A_CDC_DMIC_CLK1_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_RX_I2S_SCK_MODE			(0xC8)
+#define TABLA_A_CDC_RX_I2S_SCK_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_RX_I2S_WS_MODE			(0xC9)
+#define TABLA_A_CDC_RX_I2S_WS_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_DMIC_DATA2_MODE			(0xCA)
+#define TABLA_A_CDC_DMIC_DATA2_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_DMIC_CLK2_MODE			(0xCB)
+#define TABLA_A_CDC_DMIC_CLK2_MODE__POR			(0x00000000)
+#define TABLA_A_CDC_INTR_MODE			(0xCC)
+#define TABLA_A_CDC_INTR_MODE__POR			(0x00000000)
+#define TABLA_A_BIAS_REF_CTL			(0x0100)
+#define TABLA_A_BIAS_REF_CTL__POR			(0x0000001C)
+#define TABLA_A_BIAS_CENTRAL_BG_CTL			(0x0101)
+#define TABLA_A_BIAS_CENTRAL_BG_CTL__POR			(0x00000050)
+#define TABLA_A_BIAS_PRECHRG_CTL			(0x0102)
+#define TABLA_A_BIAS_PRECHRG_CTL__POR			(0x00000007)
+#define TABLA_A_BIAS_CURR_CTL_1			(0x0103)
+#define TABLA_A_BIAS_CURR_CTL_1__POR			(0x00000052)
+#define TABLA_A_BIAS_CURR_CTL_2			(0x0104)
+#define TABLA_A_BIAS_CURR_CTL_2__POR			(0x00000000)
+#define TABLA_A_BIAS_CONFIG_MODE_BG_CTL			(0x0105)
+#define TABLA_A_BIAS_CONFIG_MODE_BG_CTL__POR			(0x00000016)
+#define TABLA_A_BIAS_BG_STATUS			(0x0106)
+#define TABLA_A_BIAS_BG_STATUS__POR			(0x00000000)
+#define TABLA_A_CLK_BUFF_EN1			(0x0108)
+#define TABLA_A_CLK_BUFF_EN1__POR			(0x00000004)
+#define TABLA_A_CLK_BUFF_EN2			(0x0109)
+#define TABLA_A_CLK_BUFF_EN2__POR			(0x00000002)
+#define TABLA_A_LDO_H_MODE_1			(0x0110)
+#define TABLA_A_LDO_H_MODE_1__POR			(0x00000065)
+#define TABLA_A_LDO_H_MODE_2			(0x0111)
+#define TABLA_A_LDO_H_MODE_2__POR			(0x000000A8)
+#define TABLA_A_LDO_H_LOOP_CTL			(0x0112)
+#define TABLA_A_LDO_H_LOOP_CTL__POR			(0x0000006B)
+#define TABLA_A_LDO_H_COMP_1			(0x0113)
+#define TABLA_A_LDO_H_COMP_1__POR			(0x00000084)
+#define TABLA_A_LDO_H_COMP_2			(0x0114)
+#define TABLA_A_LDO_H_COMP_2__POR			(0x000000E0)
+#define TABLA_A_LDO_H_BIAS_1			(0x0115)
+#define TABLA_A_LDO_H_BIAS_1__POR			(0x0000006D)
+#define TABLA_A_LDO_H_BIAS_2			(0x0116)
+#define TABLA_A_LDO_H_BIAS_2__POR			(0x000000A5)
+#define TABLA_A_LDO_H_BIAS_3			(0x0117)
+#define TABLA_A_LDO_H_BIAS_3__POR			(0x00000060)
+#define TABLA_A_LDO_L_MODE_1			(0x0118)
+#define TABLA_A_LDO_L_MODE_1__POR			(0x00000028)
+#define TABLA_A_LDO_L_MODE_2			(0x0119)
+#define TABLA_A_LDO_L_MODE_2__POR			(0x000000A8)
+#define TABLA_A_LDO_L_LOOP_CTL			(0x011A)
+#define TABLA_A_LDO_L_LOOP_CTL__POR			(0x0000006D)
+#define TABLA_A_LDO_L_COMP_1			(0x011B)
+#define TABLA_A_LDO_L_COMP_1__POR			(0x00000031)
+#define TABLA_A_LDO_L_COMP_2			(0x011C)
+#define TABLA_A_LDO_L_COMP_2__POR			(0x000000A0)
+#define TABLA_A_LDO_L_BIAS_1			(0x011D)
+#define TABLA_A_LDO_L_BIAS_1__POR			(0x0000006D)
+#define TABLA_A_LDO_L_BIAS_2			(0x011E)
+#define TABLA_A_LDO_L_BIAS_2__POR			(0x00000065)
+#define TABLA_A_LDO_L_BIAS_3			(0x011F)
+#define TABLA_A_LDO_L_BIAS_3__POR			(0x00000050)
+#define TABLA_A_MICB_CFILT_1_CTL			(0x0128)
+#define TABLA_A_MICB_CFILT_1_CTL__POR			(0x00000040)
+#define TABLA_A_MICB_CFILT_1_VAL			(0x0129)
+#define TABLA_A_MICB_CFILT_1_VAL__POR			(0x00000080)
+#define TABLA_A_MICB_CFILT_1_PRECHRG			(0x012A)
+#define TABLA_A_MICB_CFILT_1_PRECHRG__POR			(0x00000038)
+#define TABLA_A_MICB_1_CTL			(0x012B)
+#define TABLA_A_MICB_1_CTL__POR			(0x00000016)
+#define TABLA_A_MICB_1_INT_RBIAS			(0x012C)
+#define TABLA_A_MICB_1_INT_RBIAS__POR			(0x00000000)
+#define TABLA_A_MICB_1_MBHC			(0x012D)
+#define TABLA_A_MICB_1_MBHC__POR			(0x00000001)
+#define TABLA_A_MICB_CFILT_2_CTL			(0x012E)
+#define TABLA_A_MICB_CFILT_2_CTL__POR			(0x00000040)
+#define TABLA_A_MICB_CFILT_2_VAL			(0x012F)
+#define TABLA_A_MICB_CFILT_2_VAL__POR			(0x00000080)
+#define TABLA_A_MICB_CFILT_2_PRECHRG			(0x0130)
+#define TABLA_A_MICB_CFILT_2_PRECHRG__POR			(0x00000038)
+#define TABLA_A_MICB_2_CTL			(0x0131)
+#define TABLA_A_MICB_2_CTL__POR			(0x00000016)
+#define TABLA_A_MICB_2_INT_RBIAS			(0x0132)
+#define TABLA_A_MICB_2_INT_RBIAS__POR			(0x00000000)
+#define TABLA_A_MICB_2_MBHC			(0x0133)
+#define TABLA_A_MICB_2_MBHC__POR			(0x00000000)
+#define TABLA_A_MICB_CFILT_3_CTL			(0x0134)
+#define TABLA_A_MICB_CFILT_3_CTL__POR			(0x00000040)
+#define TABLA_A_MICB_CFILT_3_VAL			(0x0135)
+#define TABLA_A_MICB_CFILT_3_VAL__POR			(0x00000080)
+#define TABLA_A_MICB_CFILT_3_PRECHRG			(0x0136)
+#define TABLA_A_MICB_CFILT_3_PRECHRG__POR			(0x00000038)
+#define TABLA_A_MICB_3_CTL			(0x0137)
+#define TABLA_A_MICB_3_CTL__POR			(0x00000016)
+#define TABLA_A_MICB_3_INT_RBIAS			(0x0138)
+#define TABLA_A_MICB_3_INT_RBIAS__POR			(0x00000000)
+#define TABLA_A_MICB_3_MBHC			(0x0139)
+#define TABLA_A_MICB_3_MBHC__POR			(0x00000000)
+#define TABLA_1_A_MICB_4_CTL			(0x013A)
+#define TABLA_2_A_MICB_4_CTL			(0x013D)
+#define TABLA_A_MICB_4_CTL__POR			(0x00000016)
+#define TABLA_1_A_MICB_4_INT_RBIAS			(0x013B)
+#define TABLA_2_A_MICB_4_INT_RBIAS			(0x013E)
+#define TABLA_A_MICB_4_INT_RBIAS__POR			(0x00000000)
+#define TABLA_1_A_MICB_4_MBHC			(0x013C)
+#define TABLA_2_A_MICB_4_MBHC			(0x013F)
+#define TABLA_A_MICB_4_MBHC__POR			(0x00000001)
+#define TABLA_A_TX_COM_BIAS			(0x014C)
+#define TABLA_A_TX_COM_BIAS__POR			(0x000000E0)
+#define TABLA_A_MBHC_SCALING_MUX_1			(0x014E)
+#define TABLA_A_MBHC_SCALING_MUX_1__POR			(0x00000000)
+#define TABLA_A_MBHC_SCALING_MUX_2			(0x014F)
+#define TABLA_A_MBHC_SCALING_MUX_2__POR			(0x00000080)
+#define TABLA_A_TX_SUP_SWITCH_CTRL_1			(0x0151)
+#define TABLA_A_TX_SUP_SWITCH_CTRL_1__POR			(0x00000000)
+#define TABLA_A_TX_SUP_SWITCH_CTRL_2			(0x0152)
+#define TABLA_A_TX_SUP_SWITCH_CTRL_2__POR			(0x00000080)
+#define TABLA_A_TX_1_2_EN			(0x0153)
+#define TABLA_A_TX_1_2_EN__POR			(0x00000000)
+#define TABLA_A_TX_1_2_TEST_EN			(0x0154)
+#define TABLA_A_TX_1_2_TEST_EN__POR			(0x000000CC)
+#define TABLA_A_TX_1_2_ADC_CH1			(0x0155)
+#define TABLA_A_TX_1_2_ADC_CH1__POR			(0x00000044)
+#define TABLA_A_TX_1_2_ADC_CH2			(0x0156)
+#define TABLA_A_TX_1_2_ADC_CH2__POR			(0x00000044)
+#define TABLA_A_TX_1_2_ATEST_REFCTRL			(0x0157)
+#define TABLA_A_TX_1_2_ATEST_REFCTRL__POR			(0x00000000)
+#define TABLA_A_TX_1_2_TEST_CTL			(0x0158)
+#define TABLA_A_TX_1_2_TEST_CTL__POR			(0x00000038)
+#define TABLA_A_TX_1_2_TEST_BLOCK_EN			(0x0159)
+#define TABLA_A_TX_1_2_TEST_BLOCK_EN__POR			(0x000000FF)
+#define TABLA_A_TX_1_2_TXFE_CLKDIV			(0x015A)
+#define TABLA_A_TX_1_2_TXFE_CLKDIV__POR			(0x000000EE)
+#define TABLA_A_TX_1_2_SAR_ERR_CH1			(0x015B)
+#define TABLA_A_TX_1_2_SAR_ERR_CH1__POR			(0x00000000)
+#define TABLA_A_TX_1_2_SAR_ERR_CH2			(0x015C)
+#define TABLA_A_TX_1_2_SAR_ERR_CH2__POR			(0x00000000)
+#define TABLA_A_TX_3_4_EN			(0x015D)
+#define TABLA_A_TX_3_4_EN__POR			(0x00000000)
+#define TABLA_A_TX_3_4_TEST_EN			(0x015E)
+#define TABLA_A_TX_3_4_TEST_EN__POR			(0x000000CC)
+#define TABLA_A_TX_3_4_ADC_CH3			(0x015F)
+#define TABLA_A_TX_3_4_ADC_CH3__POR			(0x00000044)
+#define TABLA_A_TX_3_4_ADC_CH4			(0x0160)
+#define TABLA_A_TX_3_4_ADC_CH4__POR			(0x00000044)
+#define TABLA_A_TX_3_4_ATEST_REFCTRL			(0x0161)
+#define TABLA_A_TX_3_4_ATEST_REFCTRL__POR			(0x00000000)
+#define TABLA_A_TX_3_4_TEST_CTL			(0x0162)
+#define TABLA_A_TX_3_4_TEST_CTL__POR			(0x00000038)
+#define TABLA_A_TX_3_4_TEST_BLOCK_EN			(0x0163)
+#define TABLA_A_TX_3_4_TEST_BLOCK_EN__POR			(0x000000FF)
+#define TABLA_A_TX_3_4_TXFE_CKDIV			(0x0164)
+#define TABLA_A_TX_3_4_TXFE_CKDIV__POR			(0x000000EE)
+#define TABLA_A_TX_3_4_SAR_ERR_CH3			(0x0165)
+#define TABLA_A_TX_3_4_SAR_ERR_CH3__POR			(0x00000000)
+#define TABLA_A_TX_3_4_SAR_ERR_CH4			(0x0166)
+#define TABLA_A_TX_3_4_SAR_ERR_CH4__POR			(0x00000000)
+#define TABLA_A_TX_5_6_EN			(0x0167)
+#define TABLA_A_TX_5_6_EN__POR			(0x00000011)
+#define TABLA_A_TX_5_6_TEST_EN			(0x0168)
+#define TABLA_A_TX_5_6_TEST_EN__POR			(0x000000CC)
+#define TABLA_A_TX_5_6_ADC_CH5			(0x0169)
+#define TABLA_A_TX_5_6_ADC_CH5__POR			(0x00000044)
+#define TABLA_A_TX_5_6_ADC_CH6			(0x016A)
+#define TABLA_A_TX_5_6_ADC_CH6__POR			(0x00000044)
+#define TABLA_A_TX_5_6_ATEST_REFCTRL			(0x016B)
+#define TABLA_A_TX_5_6_ATEST_REFCTRL__POR			(0x00000000)
+#define TABLA_A_TX_5_6_TEST_CTL			(0x016C)
+#define TABLA_A_TX_5_6_TEST_CTL__POR			(0x00000038)
+#define TABLA_A_TX_5_6_TEST_BLOCK_EN			(0x016D)
+#define TABLA_A_TX_5_6_TEST_BLOCK_EN__POR			(0x000000FF)
+#define TABLA_A_TX_5_6_TXFE_CKDIV			(0x016E)
+#define TABLA_A_TX_5_6_TXFE_CKDIV__POR			(0x000000EE)
+#define TABLA_A_TX_5_6_SAR_ERR_CH5			(0x016F)
+#define TABLA_A_TX_5_6_SAR_ERR_CH5__POR			(0x00000000)
+#define TABLA_A_TX_5_6_SAR_ERR_CH6			(0x0170)
+#define TABLA_A_TX_5_6_SAR_ERR_CH6__POR			(0x00000000)
+#define TABLA_A_TX_7_MBHC_EN			(0x0171)
+#define TABLA_A_TX_7_MBHC_EN__POR			(0x0000000C)
+#define TABLA_A_TX_7_MBHC_ATEST_REFCTRL			(0x0172)
+#define TABLA_A_TX_7_MBHC_ATEST_REFCTRL__POR			(0x00000000)
+#define TABLA_A_TX_7_MBHC_ADC			(0x0173)
+#define TABLA_A_TX_7_MBHC_ADC__POR			(0x00000044)
+#define TABLA_A_TX_7_MBHC_TEST_CTL			(0x0174)
+#define TABLA_A_TX_7_MBHC_TEST_CTL__POR			(0x00000038)
+#define TABLA_A_TX_7_MBHC_SAR_ERR			(0x0175)
+#define TABLA_A_TX_7_MBHC_SAR_ERR__POR			(0x00000000)
+#define TABLA_A_TX_7_TXFE_CLKDIV			(0x0176)
+#define TABLA_A_TX_7_TXFE_CLKDIV__POR			(0x0000001C)
+#define TABLA_A_AUX_COM_CTL			(0x0180)
+#define TABLA_A_AUX_COM_CTL__POR			(0x00000034)
+#define TABLA_A_AUX_COM_ATEST			(0x0181)
+#define TABLA_A_AUX_COM_ATEST__POR			(0x00000000)
+#define TABLA_A_AUX_L_EN			(0x0182)
+#define TABLA_A_AUX_L_EN__POR			(0x00000000)
+#define TABLA_A_AUX_L_GAIN			(0x0183)
+#define TABLA_A_AUX_L_GAIN__POR			(0x0000001F)
+#define TABLA_A_AUX_L_PA_CONN			(0x0184)
+#define TABLA_A_AUX_L_PA_CONN__POR			(0x00000000)
+#define TABLA_A_AUX_L_PA_CONN_INV			(0x0185)
+#define TABLA_A_AUX_L_PA_CONN_INV__POR			(0x00000000)
+#define TABLA_A_AUX_R_EN			(0x0186)
+#define TABLA_A_AUX_R_EN__POR			(0x00000000)
+#define TABLA_A_AUX_R_GAIN			(0x0187)
+#define TABLA_A_AUX_R_GAIN__POR			(0x0000001F)
+#define TABLA_A_AUX_R_PA_CONN			(0x0188)
+#define TABLA_A_AUX_R_PA_CONN__POR			(0x00000000)
+#define TABLA_A_AUX_R_PA_CONN_INV			(0x0189)
+#define TABLA_A_AUX_R_PA_CONN_INV__POR			(0x00000000)
+#define TABLA_A_CP_EN			(0x0192)
+#define TABLA_A_CP_EN__POR			(0x000000E6)
+#define TABLA_A_CP_CLK			(0x0193)
+#define TABLA_A_CP_CLK__POR			(0x00000029)
+#define TABLA_A_CP_STATIC			(0x0194)
+#define TABLA_A_CP_STATIC__POR			(0x00000010)
+#define TABLA_A_CP_DCC1			(0x0195)
+#define TABLA_A_CP_DCC1__POR			(0x00000052)
+#define TABLA_A_CP_DCC3			(0x0196)
+#define TABLA_A_CP_DCC3__POR			(0x00000001)
+#define TABLA_A_CP_ATEST			(0x0197)
+#define TABLA_A_CP_ATEST__POR			(0x00000000)
+#define TABLA_A_CP_DTEST			(0x0198)
+#define TABLA_A_CP_DTEST__POR			(0x00000000)
+#define TABLA_A_RX_COM_TIMER_DIV			(0x019E)
+#define TABLA_A_RX_COM_TIMER_DIV__POR			(0x000000E8)
+#define TABLA_A_RX_COM_OCP_CTL			(0x019F)
+#define TABLA_A_RX_COM_OCP_CTL__POR			(0x0000001F)
+#define TABLA_A_RX_COM_OCP_COUNT			(0x01A0)
+#define TABLA_A_RX_COM_OCP_COUNT__POR			(0x00000077)
+#define TABLA_A_RX_COM_DAC_CTL			(0x01A1)
+#define TABLA_A_RX_COM_DAC_CTL__POR			(0x00000000)
+#define TABLA_A_RX_COM_BIAS			(0x01A2)
+#define TABLA_A_RX_COM_BIAS__POR			(0x00000000)
+#define TABLA_A_RX_HPH_BIAS_PA			(0x01A6)
+#define TABLA_A_RX_HPH_BIAS_PA__POR			(0x000000AA)
+#define TABLA_A_RX_HPH_BIAS_LDO			(0x01A7)
+#define TABLA_A_RX_HPH_BIAS_LDO__POR			(0x00000086)
+#define TABLA_A_RX_HPH_BIAS_CNP			(0x01A8)
+#define TABLA_A_RX_HPH_BIAS_CNP__POR			(0x0000008A)
+#define TABLA_A_RX_HPH_BIAS_WG			(0x01A9)
+#define TABLA_A_RX_HPH_BIAS_WG__POR			(0x00000060)
+#define TABLA_A_RX_HPH_OCP_CTL			(0x01AA)
+#define TABLA_A_RX_HPH_OCP_CTL__POR			(0x000000E8)
+#define TABLA_A_RX_HPH_CNP_EN			(0x01AB)
+#define TABLA_A_RX_HPH_CNP_EN__POR			(0x00000080)
+#define TABLA_A_RX_HPH_CNP_WG_CTL			(0x01AC)
+#define TABLA_A_RX_HPH_CNP_WG_CTL__POR			(0x000000DC)
+#define TABLA_A_RX_HPH_CNP_WG_TIME			(0x01AD)
+#define TABLA_A_RX_HPH_CNP_WG_TIME__POR			(0x00000028)
+#define TABLA_A_RX_HPH_L_GAIN			(0x01AE)
+#define TABLA_A_RX_HPH_L_GAIN__POR			(0x00000000)
+#define TABLA_A_RX_HPH_L_TEST			(0x01AF)
+#define TABLA_A_RX_HPH_L_TEST__POR			(0x00000001)
+#define TABLA_A_RX_HPH_L_PA_CTL			(0x01B0)
+#define TABLA_A_RX_HPH_L_PA_CTL__POR			(0x00000040)
+#define TABLA_A_RX_HPH_L_DAC_CTL			(0x01B1)
+#define TABLA_A_RX_HPH_L_DAC_CTL__POR			(0x00000000)
+#define TABLA_A_RX_HPH_L_ATEST			(0x01B2)
+#define TABLA_A_RX_HPH_L_ATEST__POR			(0x00000000)
+#define TABLA_A_RX_HPH_L_STATUS			(0x01B3)
+#define TABLA_A_RX_HPH_L_STATUS__POR			(0x00000004)
+#define TABLA_A_RX_HPH_R_GAIN			(0x01B4)
+#define TABLA_A_RX_HPH_R_GAIN__POR			(0x00000000)
+#define TABLA_A_RX_HPH_R_TEST			(0x01B5)
+#define TABLA_A_RX_HPH_R_TEST__POR			(0x00000001)
+#define TABLA_A_RX_HPH_R_PA_CTL			(0x01B6)
+#define TABLA_A_RX_HPH_R_PA_CTL__POR			(0x00000040)
+#define TABLA_A_RX_HPH_R_DAC_CTL			(0x01B7)
+#define TABLA_A_RX_HPH_R_DAC_CTL__POR			(0x00000000)
+#define TABLA_A_RX_HPH_R_ATEST			(0x01B8)
+#define TABLA_A_RX_HPH_R_ATEST__POR			(0x00000000)
+#define TABLA_A_RX_HPH_R_STATUS			(0x01B9)
+#define TABLA_A_RX_HPH_R_STATUS__POR			(0x00000004)
+#define TABLA_A_RX_EAR_BIAS_PA			(0x01BA)
+#define TABLA_A_RX_EAR_BIAS_PA__POR			(0x000000AA)
+#define TABLA_A_RX_EAR_BIAS_CMBUFF			(0x01BB)
+#define TABLA_A_RX_EAR_BIAS_CMBUFF__POR			(0x000000A0)
+#define TABLA_A_RX_EAR_EN			(0x01BC)
+#define TABLA_A_RX_EAR_EN__POR			(0x00000000)
+#define TABLA_A_RX_EAR_GAIN			(0x01BD)
+#define TABLA_A_RX_EAR_GAIN__POR			(0x00000008)
+#define TABLA_A_RX_EAR_CMBUFF			(0x01BE)
+#define TABLA_A_RX_EAR_CMBUFF__POR			(0x00000000)
+#define TABLA_A_RX_EAR_ICTL			(0x01BF)
+#define TABLA_A_RX_EAR_ICTL__POR			(0x00000040)
+#define TABLA_A_RX_EAR_CCOMP			(0x01C0)
+#define TABLA_A_RX_EAR_CCOMP__POR			(0x00000008)
+#define TABLA_A_RX_EAR_VCM			(0x01C1)
+#define TABLA_A_RX_EAR_VCM__POR			(0x00000000)
+#define TABLA_A_RX_EAR_CNP			(0x01C2)
+#define TABLA_A_RX_EAR_CNP__POR			(0x00000080)
+#define TABLA_A_RX_EAR_ATEST			(0x01C3)
+#define TABLA_A_RX_EAR_ATEST__POR			(0x00000000)
+#define TABLA_A_RX_EAR_STATUS			(0x01C5)
+#define TABLA_A_RX_EAR_STATUS__POR			(0x00000004)
+#define TABLA_A_RX_LINE_BIAS_PA			(0x01C6)
+#define TABLA_A_RX_LINE_BIAS_PA__POR			(0x000000AA)
+#define TABLA_A_RX_LINE_BIAS_DAC			(0x01C7)
+#define TABLA_A_RX_LINE_BIAS_DAC__POR			(0x000000A0)
+#define TABLA_A_RX_LINE_BIAS_CNP			(0x01C8)
+#define TABLA_A_RX_LINE_BIAS_CNP__POR			(0x0000003A)
+#define TABLA_A_RX_LINE_COM			(0x01C9)
+#define TABLA_A_RX_LINE_COM__POR			(0x00000000)
+#define TABLA_A_RX_LINE_CNP_EN			(0x01CA)
+#define TABLA_A_RX_LINE_CNP_EN__POR			(0x00000080)
+#define TABLA_A_RX_LINE_CNP_WG_CTL			(0x01CB)
+#define TABLA_A_RX_LINE_CNP_WG_CTL__POR			(0x0000001C)
+#define TABLA_A_RX_LINE_CNP_WG_TIME			(0x01CC)
+#define TABLA_A_RX_LINE_CNP_WG_TIME__POR			(0x00000064)
+#define TABLA_A_RX_LINE_1_GAIN			(0x01CD)
+#define TABLA_A_RX_LINE_1_GAIN__POR			(0x00000000)
+#define TABLA_A_RX_LINE_1_TEST			(0x01CE)
+#define TABLA_A_RX_LINE_1_TEST__POR			(0x00000000)
+#define TABLA_A_RX_LINE_1_DAC_CTL			(0x01CF)
+#define TABLA_A_RX_LINE_1_DAC_CTL__POR			(0x0000000C)
+#define TABLA_A_RX_LINE_1_STATUS			(0x01D0)
+#define TABLA_A_RX_LINE_1_STATUS__POR			(0x00000000)
+#define TABLA_A_RX_LINE_2_GAIN			(0x01D1)
+#define TABLA_A_RX_LINE_2_GAIN__POR			(0x00000000)
+#define TABLA_A_RX_LINE_2_TEST			(0x01D2)
+#define TABLA_A_RX_LINE_2_TEST__POR			(0x00000000)
+#define TABLA_A_RX_LINE_2_DAC_CTL			(0x01D3)
+#define TABLA_A_RX_LINE_2_DAC_CTL__POR			(0x0000000C)
+#define TABLA_A_RX_LINE_2_STATUS			(0x01D4)
+#define TABLA_A_RX_LINE_2_STATUS__POR			(0x00000000)
+#define TABLA_A_RX_LINE_3_GAIN			(0x01D5)
+#define TABLA_A_RX_LINE_3_GAIN__POR			(0x00000000)
+#define TABLA_A_RX_LINE_3_TEST			(0x01D6)
+#define TABLA_A_RX_LINE_3_TEST__POR			(0x00000000)
+#define TABLA_A_RX_LINE_3_DAC_CTL			(0x01D7)
+#define TABLA_A_RX_LINE_3_DAC_CTL__POR			(0x0000000C)
+#define TABLA_A_RX_LINE_3_STATUS			(0x01D8)
+#define TABLA_A_RX_LINE_3_STATUS__POR			(0x00000000)
+#define TABLA_A_RX_LINE_4_GAIN			(0x01D9)
+#define TABLA_A_RX_LINE_4_GAIN__POR			(0x00000000)
+#define TABLA_A_RX_LINE_4_TEST			(0x01DA)
+#define TABLA_A_RX_LINE_4_TEST__POR			(0x00000000)
+#define TABLA_A_RX_LINE_4_DAC_CTL			(0x01DB)
+#define TABLA_A_RX_LINE_4_DAC_CTL__POR			(0x0000000C)
+#define TABLA_A_RX_LINE_4_STATUS			(0x01DC)
+#define TABLA_A_RX_LINE_4_STATUS__POR			(0x00000000)
+#define TABLA_A_RX_LINE_5_GAIN			(0x01DD)
+#define TABLA_A_RX_LINE_5_GAIN__POR			(0x00000000)
+#define TABLA_A_RX_LINE_5_TEST			(0x01DE)
+#define TABLA_A_RX_LINE_5_TEST__POR			(0x00000000)
+#define TABLA_A_RX_LINE_5_DAC_CTL			(0x01DF)
+#define TABLA_A_RX_LINE_5_DAC_CTL__POR			(0x0000000C)
+#define TABLA_A_RX_LINE_5_STATUS			(0x01E0)
+#define TABLA_A_RX_LINE_5_STATUS__POR			(0x00000000)
+#define TABLA_A_RX_LINE_CNP_DBG			(0x01EC)
+#define TABLA_A_RX_LINE_CNP_DBG__POR			(0x00000000)
+#define TABLA_A_MBHC_HPH			(0x01ED)
+#define TABLA_A_MBHC_HPH__POR			(0x00000048)
+#define TABLA_A_CONFIG_MODE_FREQ			(0x01F7)
+#define TABLA_A_CONFIG_MODE_FREQ__POR			(0x00000047)
+#define TABLA_A_CONFIG_MODE_TEST			(0x01F8)
+#define TABLA_A_CONFIG_MODE_TEST__POR			(0x0000000A)
+#define TABLA_A_CONFIG_MODE_STATUS			(0x01F9)
+#define TABLA_A_CONFIG_MODE_STATUS__POR			(0x0000001C)
+#define TABLA_A_CONFIG_MODE_TUNER			(0x01FA)
+#define TABLA_A_CONFIG_MODE_TUNER__POR			(0x00000000)
+#define TABLA_A_CDC_ANC1_CTL                    (0x00000200)
+#define TABLA_A_CDC_ANC1_CTL__POR                       (0x00000000)
+#define TABLA_A_CDC_ANC2_CTL                    (0x00000280)
+#define TABLA_A_CDC_ANC2_CTL__POR                       (0x00000000)
+#define TABLA_A_CDC_ANC1_SHIFT                  (0x00000201)
+#define TABLA_A_CDC_ANC1_SHIFT__POR                     (0x00000000)
+#define TABLA_A_CDC_ANC2_SHIFT                  (0x00000281)
+#define TABLA_A_CDC_ANC2_SHIFT__POR                     (0x00000000)
+#define TABLA_A_CDC_ANC1_FILT1_B1_CTL                     (0x00000202)
+#define TABLA_A_CDC_ANC1_FILT1_B1_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC2_FILT1_B1_CTL                     (0x00000282)
+#define TABLA_A_CDC_ANC2_FILT1_B1_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC1_FILT1_B2_CTL                     (0x00000203)
+#define TABLA_A_CDC_ANC1_FILT1_B2_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC2_FILT1_B2_CTL                     (0x00000283)
+#define TABLA_A_CDC_ANC2_FILT1_B2_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC1_FILT1_B3_CTL                     (0x00000204)
+#define TABLA_A_CDC_ANC1_FILT1_B3_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC2_FILT1_B3_CTL                     (0x00000284)
+#define TABLA_A_CDC_ANC2_FILT1_B3_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC1_FILT1_B4_CTL                     (0x00000205)
+#define TABLA_A_CDC_ANC1_FILT1_B4_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC2_FILT1_B4_CTL                     (0x00000285)
+#define TABLA_A_CDC_ANC2_FILT1_B4_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC1_FILT2_B1_CTL                     (0x00000206)
+#define TABLA_A_CDC_ANC1_FILT2_B1_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC2_FILT2_B1_CTL                     (0x00000286)
+#define TABLA_A_CDC_ANC2_FILT2_B1_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC1_FILT2_B2_CTL                     (0x00000207)
+#define TABLA_A_CDC_ANC1_FILT2_B2_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC2_FILT2_B2_CTL                     (0x00000287)
+#define TABLA_A_CDC_ANC2_FILT2_B2_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC1_FILT2_B3_CTL                     (0x00000208)
+#define TABLA_A_CDC_ANC1_FILT2_B3_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC2_FILT2_B3_CTL                     (0x00000288)
+#define TABLA_A_CDC_ANC2_FILT2_B3_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_ANC1_SPARE                  (0x00000209)
+#define TABLA_A_CDC_ANC1_SPARE__POR                     (0x00000000)
+#define TABLA_A_CDC_ANC2_SPARE                  (0x00000289)
+#define TABLA_A_CDC_ANC2_SPARE__POR                     (0x00000000)
+#define TABLA_A_CDC_ANC1_FILT3_CTL                      (0x0000020A)
+#define TABLA_A_CDC_ANC1_FILT3_CTL__POR                 (0x00000000)
+#define TABLA_A_CDC_ANC2_FILT3_CTL                      (0x0000028A)
+#define TABLA_A_CDC_ANC2_FILT3_CTL__POR                 (0x00000000)
+#define TABLA_A_CDC_ANC1_FILT4_CTL                      (0x0000020B)
+#define TABLA_A_CDC_ANC1_FILT4_CTL__POR                 (0x00000000)
+#define TABLA_A_CDC_ANC2_FILT4_CTL                      (0x0000028B)
+#define TABLA_A_CDC_ANC2_FILT4_CTL__POR                 (0x00000000)
+#define TABLA_A_CDC_TX1_VOL_CTL_TIMER			(0x00000220)
+#define TABLA_A_CDC_TX1_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX2_VOL_CTL_TIMER			(0x00000228)
+#define TABLA_A_CDC_TX2_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX3_VOL_CTL_TIMER			(0x00000230)
+#define TABLA_A_CDC_TX3_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX4_VOL_CTL_TIMER			(0x00000238)
+#define TABLA_A_CDC_TX4_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX5_VOL_CTL_TIMER			(0x00000240)
+#define TABLA_A_CDC_TX5_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX6_VOL_CTL_TIMER			(0x00000248)
+#define TABLA_A_CDC_TX6_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX7_VOL_CTL_TIMER			(0x00000250)
+#define TABLA_A_CDC_TX7_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX8_VOL_CTL_TIMER			(0x00000258)
+#define TABLA_A_CDC_TX8_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX9_VOL_CTL_TIMER			(0x00000260)
+#define TABLA_A_CDC_TX9_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX10_VOL_CTL_TIMER			(0x00000268)
+#define TABLA_A_CDC_TX10_VOL_CTL_TIMER__POR			(0x00000000)
+#define TABLA_A_CDC_TX1_VOL_CTL_GAIN			(0x00000221)
+#define TABLA_A_CDC_TX1_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX2_VOL_CTL_GAIN			(0x00000229)
+#define TABLA_A_CDC_TX2_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX3_VOL_CTL_GAIN			(0x00000231)
+#define TABLA_A_CDC_TX3_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX4_VOL_CTL_GAIN			(0x00000239)
+#define TABLA_A_CDC_TX4_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX5_VOL_CTL_GAIN			(0x00000241)
+#define TABLA_A_CDC_TX5_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX6_VOL_CTL_GAIN			(0x00000249)
+#define TABLA_A_CDC_TX6_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX7_VOL_CTL_GAIN			(0x00000251)
+#define TABLA_A_CDC_TX7_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX8_VOL_CTL_GAIN			(0x00000259)
+#define TABLA_A_CDC_TX8_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX9_VOL_CTL_GAIN			(0x00000261)
+#define TABLA_A_CDC_TX9_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX10_VOL_CTL_GAIN			(0x00000269)
+#define TABLA_A_CDC_TX10_VOL_CTL_GAIN__POR			(0x00000000)
+#define TABLA_A_CDC_TX1_VOL_CTL_CFG			(0x00000222)
+#define TABLA_A_CDC_TX1_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX2_VOL_CTL_CFG			(0x0000022A)
+#define TABLA_A_CDC_TX2_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX3_VOL_CTL_CFG			(0x00000232)
+#define TABLA_A_CDC_TX3_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX4_VOL_CTL_CFG			(0x0000023A)
+#define TABLA_A_CDC_TX4_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX5_VOL_CTL_CFG			(0x00000242)
+#define TABLA_A_CDC_TX5_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX6_VOL_CTL_CFG			(0x0000024A)
+#define TABLA_A_CDC_TX6_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX7_VOL_CTL_CFG			(0x00000252)
+#define TABLA_A_CDC_TX7_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX8_VOL_CTL_CFG			(0x0000025A)
+#define TABLA_A_CDC_TX8_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX9_VOL_CTL_CFG			(0x00000262)
+#define TABLA_A_CDC_TX9_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX10_VOL_CTL_CFG			(0x0000026A)
+#define TABLA_A_CDC_TX10_VOL_CTL_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_TX1_MUX_CTL			(0x00000223)
+#define TABLA_A_CDC_TX1_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX2_MUX_CTL			(0x0000022B)
+#define TABLA_A_CDC_TX2_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX3_MUX_CTL			(0x00000233)
+#define TABLA_A_CDC_TX3_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX4_MUX_CTL			(0x0000023B)
+#define TABLA_A_CDC_TX4_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX5_MUX_CTL			(0x00000243)
+#define TABLA_A_CDC_TX5_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX6_MUX_CTL			(0x0000024B)
+#define TABLA_A_CDC_TX6_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX7_MUX_CTL			(0x00000253)
+#define TABLA_A_CDC_TX7_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX8_MUX_CTL			(0x0000025B)
+#define TABLA_A_CDC_TX8_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX9_MUX_CTL			(0x00000263)
+#define TABLA_A_CDC_TX9_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX10_MUX_CTL			(0x0000026B)
+#define TABLA_A_CDC_TX10_MUX_CTL__POR			(0x00000008)
+#define TABLA_A_CDC_TX1_CLK_FS_CTL			(0x00000224)
+#define TABLA_A_CDC_TX1_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX2_CLK_FS_CTL			(0x0000022C)
+#define TABLA_A_CDC_TX2_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX3_CLK_FS_CTL			(0x00000234)
+#define TABLA_A_CDC_TX3_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX4_CLK_FS_CTL			(0x0000023C)
+#define TABLA_A_CDC_TX4_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX5_CLK_FS_CTL			(0x00000244)
+#define TABLA_A_CDC_TX5_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX6_CLK_FS_CTL			(0x0000024C)
+#define TABLA_A_CDC_TX6_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX7_CLK_FS_CTL			(0x00000254)
+#define TABLA_A_CDC_TX7_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX8_CLK_FS_CTL			(0x0000025C)
+#define TABLA_A_CDC_TX8_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX9_CLK_FS_CTL			(0x00000264)
+#define TABLA_A_CDC_TX9_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX10_CLK_FS_CTL			(0x0000026C)
+#define TABLA_A_CDC_TX10_CLK_FS_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_TX1_DMIC_CTL			(0x00000225)
+#define TABLA_A_CDC_TX1_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TX2_DMIC_CTL			(0x0000022D)
+#define TABLA_A_CDC_TX2_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TX3_DMIC_CTL			(0x00000235)
+#define TABLA_A_CDC_TX3_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TX4_DMIC_CTL			(0x0000023D)
+#define TABLA_A_CDC_TX4_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TX5_DMIC_CTL			(0x00000245)
+#define TABLA_A_CDC_TX5_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TX6_DMIC_CTL			(0x0000024D)
+#define TABLA_A_CDC_TX6_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TX7_DMIC_CTL			(0x00000255)
+#define TABLA_A_CDC_TX7_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TX8_DMIC_CTL			(0x0000025D)
+#define TABLA_A_CDC_TX8_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TX9_DMIC_CTL			(0x00000265)
+#define TABLA_A_CDC_TX9_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TX10_DMIC_CTL			(0x0000026D)
+#define TABLA_A_CDC_TX10_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_SRC1_PDA_CFG			(0x000002A0)
+#define TABLA_A_CDC_SRC1_PDA_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_SRC2_PDA_CFG			(0x000002A8)
+#define TABLA_A_CDC_SRC2_PDA_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_SRC1_FS_CTL			(0x000002A1)
+#define TABLA_A_CDC_SRC1_FS_CTL__POR			(0x0000001b)
+#define TABLA_A_CDC_SRC2_FS_CTL			(0x000002A9)
+#define TABLA_A_CDC_SRC2_FS_CTL__POR			(0x0000001b)
+#define TABLA_A_CDC_RX1_B1_CTL			(0x000002B0)
+#define TABLA_A_CDC_RX1_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX2_B1_CTL			(0x000002B8)
+#define TABLA_A_CDC_RX2_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX3_B1_CTL			(0x000002C0)
+#define TABLA_A_CDC_RX3_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX4_B1_CTL			(0x000002C8)
+#define TABLA_A_CDC_RX4_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX5_B1_CTL			(0x000002D0)
+#define TABLA_A_CDC_RX5_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX6_B1_CTL			(0x000002D8)
+#define TABLA_A_CDC_RX6_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX7_B1_CTL			(0x000002E0)
+#define TABLA_A_CDC_RX7_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX1_B2_CTL			(0x000002B1)
+#define TABLA_A_CDC_RX1_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX2_B2_CTL			(0x000002B9)
+#define TABLA_A_CDC_RX2_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX3_B2_CTL			(0x000002C1)
+#define TABLA_A_CDC_RX3_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX4_B2_CTL			(0x000002C9)
+#define TABLA_A_CDC_RX4_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX5_B2_CTL			(0x000002D1)
+#define TABLA_A_CDC_RX5_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX6_B2_CTL			(0x000002D9)
+#define TABLA_A_CDC_RX6_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX7_B2_CTL			(0x000002E1)
+#define TABLA_A_CDC_RX7_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX1_B3_CTL			(0x000002B2)
+#define TABLA_A_CDC_RX1_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX2_B3_CTL			(0x000002BA)
+#define TABLA_A_CDC_RX2_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX3_B3_CTL			(0x000002C2)
+#define TABLA_A_CDC_RX3_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX4_B3_CTL			(0x000002CA)
+#define TABLA_A_CDC_RX4_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX5_B3_CTL			(0x000002D2)
+#define TABLA_A_CDC_RX5_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX6_B3_CTL			(0x000002DA)
+#define TABLA_A_CDC_RX6_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX7_B3_CTL			(0x000002E2)
+#define TABLA_A_CDC_RX7_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX1_B4_CTL			(0x000002B3)
+#define TABLA_A_CDC_RX1_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX2_B4_CTL			(0x000002BB)
+#define TABLA_A_CDC_RX2_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX3_B4_CTL			(0x000002C3)
+#define TABLA_A_CDC_RX3_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX4_B4_CTL			(0x000002CB)
+#define TABLA_A_CDC_RX4_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX5_B4_CTL			(0x000002D3)
+#define TABLA_A_CDC_RX5_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX6_B4_CTL			(0x000002DB)
+#define TABLA_A_CDC_RX6_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX7_B4_CTL			(0x000002E3)
+#define TABLA_A_CDC_RX7_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX1_B5_CTL			(0x000002B4)
+#define TABLA_A_CDC_RX1_B5_CTL__POR			(0x00000060)
+#define TABLA_A_CDC_RX2_B5_CTL			(0x000002BC)
+#define TABLA_A_CDC_RX2_B5_CTL__POR			(0x00000060)
+#define TABLA_A_CDC_RX3_B5_CTL			(0x000002C4)
+#define TABLA_A_CDC_RX3_B5_CTL__POR			(0x00000060)
+#define TABLA_A_CDC_RX4_B5_CTL			(0x000002CC)
+#define TABLA_A_CDC_RX4_B5_CTL__POR			(0x00000060)
+#define TABLA_A_CDC_RX5_B5_CTL			(0x000002D4)
+#define TABLA_A_CDC_RX5_B5_CTL__POR			(0x00000060)
+#define TABLA_A_CDC_RX6_B5_CTL			(0x000002DC)
+#define TABLA_A_CDC_RX6_B5_CTL__POR			(0x00000060)
+#define TABLA_A_CDC_RX7_B5_CTL			(0x000002E4)
+#define TABLA_A_CDC_RX7_B5_CTL__POR			(0x00000060)
+#define TABLA_A_CDC_RX1_B6_CTL			(0x000002B5)
+#define TABLA_A_CDC_RX1_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX2_B6_CTL			(0x000002BD)
+#define TABLA_A_CDC_RX2_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX3_B6_CTL			(0x000002C5)
+#define TABLA_A_CDC_RX3_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX4_B6_CTL			(0x000002CD)
+#define TABLA_A_CDC_RX4_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX5_B6_CTL			(0x000002D5)
+#define TABLA_A_CDC_RX5_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX6_B6_CTL			(0x000002DD)
+#define TABLA_A_CDC_RX6_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX7_B6_CTL			(0x000002E5)
+#define TABLA_A_CDC_RX7_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX1_VOL_CTL_B1_CTL			(0x000002B6)
+#define TABLA_A_CDC_RX1_VOL_CTL_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX2_VOL_CTL_B1_CTL			(0x000002BE)
+#define TABLA_A_CDC_RX2_VOL_CTL_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX3_VOL_CTL_B1_CTL			(0x000002C6)
+#define TABLA_A_CDC_RX3_VOL_CTL_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX4_VOL_CTL_B1_CTL			(0x000002CE)
+#define TABLA_A_CDC_RX4_VOL_CTL_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX5_VOL_CTL_B1_CTL			(0x000002D6)
+#define TABLA_A_CDC_RX5_VOL_CTL_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX6_VOL_CTL_B1_CTL			(0x000002DE)
+#define TABLA_A_CDC_RX6_VOL_CTL_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX7_VOL_CTL_B1_CTL			(0x000002E6)
+#define TABLA_A_CDC_RX7_VOL_CTL_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX1_VOL_CTL_B2_CTL			(0x000002B7)
+#define TABLA_A_CDC_RX1_VOL_CTL_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX2_VOL_CTL_B2_CTL			(0x000002BF)
+#define TABLA_A_CDC_RX2_VOL_CTL_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX3_VOL_CTL_B2_CTL			(0x000002C7)
+#define TABLA_A_CDC_RX3_VOL_CTL_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX4_VOL_CTL_B2_CTL			(0x000002CF)
+#define TABLA_A_CDC_RX4_VOL_CTL_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX5_VOL_CTL_B2_CTL			(0x000002D7)
+#define TABLA_A_CDC_RX5_VOL_CTL_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX6_VOL_CTL_B2_CTL			(0x000002DF)
+#define TABLA_A_CDC_RX6_VOL_CTL_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_RX7_VOL_CTL_B2_CTL			(0x000002E7)
+#define TABLA_A_CDC_RX7_VOL_CTL_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_ANC_RESET_CTL                   (0x00000300)
+#define TABLA_A_CDC_CLK_ANC_RESET_CTL__POR                      (0x00000000)
+#define TABLA_A_CDC_CLK_RX_RESET_CTL			(0x00000301)
+#define TABLA_A_CDC_CLK_RX_RESET_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_TX_RESET_B1_CTL			(0x00000302)
+#define TABLA_A_CDC_CLK_TX_RESET_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_TX_RESET_B2_CTL			(0x00000303)
+#define TABLA_A_CDC_CLK_TX_RESET_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_DMIC_CTL			(0x00000304)
+#define TABLA_A_CDC_CLK_DMIC_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_RX_I2S_CTL			(0x00000305)
+#define TABLA_A_CDC_CLK_RX_I2S_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_CLK_TX_I2S_CTL			(0x00000306)
+#define TABLA_A_CDC_CLK_TX_I2S_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_CLK_OTHR_RESET_CTL			(0x00000307)
+#define TABLA_A_CDC_CLK_OTHR_RESET_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_TX_CLK_EN_B1_CTL			(0x00000308)
+#define TABLA_A_CDC_CLK_TX_CLK_EN_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_TX_CLK_EN_B2_CTL			(0x00000309)
+#define TABLA_A_CDC_CLK_TX_CLK_EN_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_OTHR_CTL			(0x0000030A)
+#define TABLA_A_CDC_CLK_OTHR_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_RDAC_CLK_EN_CTL			(0x0000030B)
+#define TABLA_A_CDC_CLK_RDAC_CLK_EN_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_ANC_CLK_EN_CTL                  (0x0000030C)
+#define TABLA_A_CDC_CLK_ANC_CLK_EN_CTL__POR                     (0x00000000)
+#define TABLA_A_CDC_CLK_RX_B1_CTL			(0x0000030D)
+#define TABLA_A_CDC_CLK_RX_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_RX_B2_CTL			(0x0000030E)
+#define TABLA_A_CDC_CLK_RX_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_MCLK_CTL			(0x0000030F)
+#define TABLA_A_CDC_CLK_MCLK_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_PDM_CTL			(0x00000310)
+#define TABLA_A_CDC_CLK_PDM_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLK_SD_CTL			(0x00000311)
+#define TABLA_A_CDC_CLK_SD_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CLSG_FREQ_THRESH_B1_CTL			(0x00000320)
+#define TABLA_A_CDC_CLSG_FREQ_THRESH_B1_CTL__POR		(0x00000007)
+#define TABLA_A_CDC_CLSG_FREQ_THRESH_B2_CTL			(0x00000321)
+#define TABLA_A_CDC_CLSG_FREQ_THRESH_B2_CTL__POR		(0x00000013)
+#define TABLA_A_CDC_CLSG_FREQ_THRESH_B3_CTL			(0x00000322)
+#define TABLA_A_CDC_CLSG_FREQ_THRESH_B3_CTL__POR		(0x00000053)
+#define TABLA_A_CDC_CLSG_FREQ_THRESH_B4_CTL			(0x00000323)
+#define TABLA_A_CDC_CLSG_FREQ_THRESH_B4_CTL__POR		(0x0000007f)
+#define TABLA_A_CDC_CLSG_GAIN_THRESH_CTL			(0x00000324)
+#define TABLA_A_CDC_CLSG_GAIN_THRESH_CTL__POR			(0x00000026)
+#define TABLA_A_CDC_CLSG_TIMER_B1_CFG			(0x00000325)
+#define TABLA_A_CDC_CLSG_TIMER_B1_CFG__POR			(0x0000000a)
+#define TABLA_A_CDC_CLSG_TIMER_B2_CFG			(0x00000326)
+#define TABLA_A_CDC_CLSG_TIMER_B2_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_CLSG_CTL			(0x00000327)
+#define TABLA_A_CDC_CLSG_CTL__POR			(0x00000013)
+#define TABLA_A_CDC_IIR1_GAIN_B1_CTL			(0x00000340)
+#define TABLA_A_CDC_IIR1_GAIN_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_GAIN_B1_CTL			(0x00000350)
+#define TABLA_A_CDC_IIR2_GAIN_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_GAIN_B2_CTL			(0x00000341)
+#define TABLA_A_CDC_IIR1_GAIN_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_GAIN_B2_CTL			(0x00000351)
+#define TABLA_A_CDC_IIR2_GAIN_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_GAIN_B3_CTL			(0x00000342)
+#define TABLA_A_CDC_IIR1_GAIN_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_GAIN_B3_CTL			(0x00000352)
+#define TABLA_A_CDC_IIR2_GAIN_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_GAIN_B4_CTL			(0x00000343)
+#define TABLA_A_CDC_IIR1_GAIN_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_GAIN_B4_CTL			(0x00000353)
+#define TABLA_A_CDC_IIR2_GAIN_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_GAIN_B5_CTL			(0x00000344)
+#define TABLA_A_CDC_IIR1_GAIN_B5_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_GAIN_B5_CTL			(0x00000354)
+#define TABLA_A_CDC_IIR2_GAIN_B5_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_GAIN_B6_CTL			(0x00000345)
+#define TABLA_A_CDC_IIR1_GAIN_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_GAIN_B6_CTL			(0x00000355)
+#define TABLA_A_CDC_IIR2_GAIN_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_GAIN_B7_CTL			(0x00000346)
+#define TABLA_A_CDC_IIR1_GAIN_B7_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_GAIN_B7_CTL			(0x00000356)
+#define TABLA_A_CDC_IIR2_GAIN_B7_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_GAIN_B8_CTL			(0x00000347)
+#define TABLA_A_CDC_IIR1_GAIN_B8_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_GAIN_B8_CTL			(0x00000357)
+#define TABLA_A_CDC_IIR2_GAIN_B8_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_CTL			(0x00000348)
+#define TABLA_A_CDC_IIR1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_CTL			(0x00000358)
+#define TABLA_A_CDC_IIR2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_GAIN_TIMER_CTL			(0x00000349)
+#define TABLA_A_CDC_IIR1_GAIN_TIMER_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_GAIN_TIMER_CTL			(0x00000359)
+#define TABLA_A_CDC_IIR2_GAIN_TIMER_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_COEF_B1_CTL			(0x0000034A)
+#define TABLA_A_CDC_IIR1_COEF_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_COEF_B1_CTL			(0x0000035A)
+#define TABLA_A_CDC_IIR2_COEF_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_COEF_B2_CTL			(0x0000034B)
+#define TABLA_A_CDC_IIR1_COEF_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_COEF_B2_CTL			(0x0000035B)
+#define TABLA_A_CDC_IIR2_COEF_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_COEF_B3_CTL			(0x0000034C)
+#define TABLA_A_CDC_IIR1_COEF_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_COEF_B3_CTL			(0x0000035C)
+#define TABLA_A_CDC_IIR2_COEF_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_COEF_B4_CTL			(0x0000034D)
+#define TABLA_A_CDC_IIR1_COEF_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_COEF_B4_CTL			(0x0000035D)
+#define TABLA_A_CDC_IIR2_COEF_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR1_COEF_B5_CTL			(0x0000034E)
+#define TABLA_A_CDC_IIR1_COEF_B5_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_IIR2_COEF_B5_CTL			(0x0000035E)
+#define TABLA_A_CDC_IIR2_COEF_B5_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_TOP_GAIN_UPDATE			(0x00000360)
+#define TABLA_A_CDC_TOP_GAIN_UPDATE__POR			(0x00000000)
+#define TABLA_A_CDC_DEBUG_B1_CTL			(0x00000368)
+#define TABLA_A_CDC_DEBUG_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_DEBUG_B2_CTL			(0x00000369)
+#define TABLA_A_CDC_DEBUG_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_DEBUG_B3_CTL			(0x0000036A)
+#define TABLA_A_CDC_DEBUG_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_DEBUG_B4_CTL			(0x0000036B)
+#define TABLA_A_CDC_DEBUG_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_DEBUG_B5_CTL			(0x0000036C)
+#define TABLA_A_CDC_DEBUG_B5_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_DEBUG_B6_CTL			(0x0000036D)
+#define TABLA_A_CDC_DEBUG_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP1_B1_CTL			(0x00000370)
+#define TABLA_A_CDC_COMP1_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP1_B2_CTL			(0x00000371)
+#define TABLA_A_CDC_COMP1_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP1_B3_CTL			(0x00000372)
+#define TABLA_A_CDC_COMP1_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP1_B4_CTL			(0x00000373)
+#define TABLA_A_CDC_COMP1_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP1_B5_CTL			(0x00000374)
+#define TABLA_A_CDC_COMP1_B5_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP1_B6_CTL			(0x00000375)
+#define TABLA_A_CDC_COMP1_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP1_SHUT_DOWN_STATUS		(0x00000376)
+#define TABLA_A_CDC_COMP1_SHUT_DOWN_STATUS__POR	(0x00000000)
+#define TABLA_A_CDC_COMP1_FS_CFG			(0x00000377)
+#define TABLA_A_CDC_COMP1_FS_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_COMP2_B1_CTL			(0x00000378)
+#define TABLA_A_CDC_COMP2_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP2_B2_CTL			(0x00000379)
+#define TABLA_A_CDC_COMP2_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP2_B3_CTL			(0x0000037A)
+#define TABLA_A_CDC_COMP2_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP2_B4_CTL			(0x0000037B)
+#define TABLA_A_CDC_COMP2_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP2_B5_CTL			(0x0000037C)
+#define TABLA_A_CDC_COMP2_B5_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP2_B6_CTL			(0x0000037D)
+#define TABLA_A_CDC_COMP2_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_COMP2_SHUT_DOWN_STATUS		(0x0000037E)
+#define TABLA_A_CDC_COMP2_SHUT_DOWN_STATUS__POR	(0x00000000)
+#define TABLA_A_CDC_COMP2_FS_CFG			(0x0000037F)
+#define TABLA_A_CDC_COMP2_FS_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX1_B1_CTL			(0x00000380)
+#define TABLA_A_CDC_CONN_RX1_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX1_B2_CTL			(0x00000381)
+#define TABLA_A_CDC_CONN_RX1_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX1_B3_CTL			(0x00000382)
+#define TABLA_A_CDC_CONN_RX1_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX2_B1_CTL			(0x00000383)
+#define TABLA_A_CDC_CONN_RX2_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX2_B2_CTL			(0x00000384)
+#define TABLA_A_CDC_CONN_RX2_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX2_B3_CTL			(0x00000385)
+#define TABLA_A_CDC_CONN_RX2_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX3_B1_CTL			(0x00000386)
+#define TABLA_A_CDC_CONN_RX3_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX3_B2_CTL			(0x00000387)
+#define TABLA_A_CDC_CONN_RX3_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX3_B3_CTL			(0x00000388)
+#define TABLA_A_CDC_CONN_RX3_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX4_B1_CTL			(0x00000389)
+#define TABLA_A_CDC_CONN_RX4_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX4_B2_CTL			(0x0000038A)
+#define TABLA_A_CDC_CONN_RX4_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX5_B1_CTL			(0x0000038B)
+#define TABLA_A_CDC_CONN_RX5_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX5_B2_CTL			(0x0000038C)
+#define TABLA_A_CDC_CONN_RX5_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX6_B1_CTL			(0x0000038D)
+#define TABLA_A_CDC_CONN_RX6_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX6_B2_CTL			(0x0000038E)
+#define TABLA_A_CDC_CONN_RX6_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX7_B1_CTL			(0x0000038F)
+#define TABLA_A_CDC_CONN_RX7_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX7_B2_CTL			(0x00000390)
+#define TABLA_A_CDC_CONN_RX7_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_ANC_B1_CTL                     (0x00000391)
+#define TABLA_A_CDC_CONN_ANC_B1_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_CONN_ANC_B2_CTL                     (0x00000392)
+#define TABLA_A_CDC_CONN_ANC_B2_CTL__POR                        (0x00000000)
+#define TABLA_A_CDC_CONN_TX_B1_CTL			(0x00000393)
+#define TABLA_A_CDC_CONN_TX_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_B2_CTL			(0x00000394)
+#define TABLA_A_CDC_CONN_TX_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_B3_CTL			(0x00000395)
+#define TABLA_A_CDC_CONN_TX_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_B4_CTL			(0x00000396)
+#define TABLA_A_CDC_CONN_TX_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_EQ1_B1_CTL			(0x00000397)
+#define TABLA_A_CDC_CONN_EQ1_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_EQ1_B2_CTL			(0x00000398)
+#define TABLA_A_CDC_CONN_EQ1_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_EQ1_B3_CTL			(0x00000399)
+#define TABLA_A_CDC_CONN_EQ1_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_EQ1_B4_CTL			(0x0000039A)
+#define TABLA_A_CDC_CONN_EQ1_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_EQ2_B1_CTL			(0x0000039B)
+#define TABLA_A_CDC_CONN_EQ2_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_EQ2_B2_CTL			(0x0000039C)
+#define TABLA_A_CDC_CONN_EQ2_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_EQ2_B3_CTL			(0x0000039D)
+#define TABLA_A_CDC_CONN_EQ2_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_EQ2_B4_CTL			(0x0000039E)
+#define TABLA_A_CDC_CONN_EQ2_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_SRC1_B1_CTL			(0x0000039F)
+#define TABLA_A_CDC_CONN_SRC1_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_SRC1_B2_CTL			(0x000003A0)
+#define TABLA_A_CDC_CONN_SRC1_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_SRC2_B1_CTL			(0x000003A1)
+#define TABLA_A_CDC_CONN_SRC2_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_SRC2_B2_CTL			(0x000003A2)
+#define TABLA_A_CDC_CONN_SRC2_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B1_CTL			(0x000003A3)
+#define TABLA_A_CDC_CONN_TX_SB_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B2_CTL			(0x000003A4)
+#define TABLA_A_CDC_CONN_TX_SB_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B3_CTL			(0x000003A5)
+#define TABLA_A_CDC_CONN_TX_SB_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B4_CTL			(0x000003A6)
+#define TABLA_A_CDC_CONN_TX_SB_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B5_CTL			(0x000003A7)
+#define TABLA_A_CDC_CONN_TX_SB_B5_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B6_CTL			(0x000003A8)
+#define TABLA_A_CDC_CONN_TX_SB_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B7_CTL			(0x000003A9)
+#define TABLA_A_CDC_CONN_TX_SB_B7_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B8_CTL			(0x000003AA)
+#define TABLA_A_CDC_CONN_TX_SB_B8_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B9_CTL			(0x000003AB)
+#define TABLA_A_CDC_CONN_TX_SB_B9_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B10_CTL			(0x000003AC)
+#define TABLA_A_CDC_CONN_TX_SB_B10_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_TX_SB_B11_CTL			(0x000003AD)
+#define TABLA_A_CDC_CONN_TX_SB_B11_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX_SB_B1_CTL			(0x000003AE)
+#define TABLA_A_CDC_CONN_RX_SB_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_RX_SB_B2_CTL			(0x000003AF)
+#define TABLA_A_CDC_CONN_RX_SB_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_CLSG_CTL			(0x000003B0)
+#define TABLA_A_CDC_CONN_CLSG_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_CONN_SPARE			(0x000003B1)
+#define TABLA_A_CDC_CONN_SPARE__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_EN_CTL			(0x000003C0)
+#define TABLA_A_CDC_MBHC_EN_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_FEATURE_B1_CFG			(0x000003C1)
+#define TABLA_A_CDC_MBHC_FEATURE_B1_CFG__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_FEATURE_B2_CFG			(0x000003C2)
+#define TABLA_A_CDC_MBHC_FEATURE_B2_CFG__POR			(0x00000006)
+#define TABLA_A_CDC_MBHC_TIMER_B1_CTL			(0x000003C3)
+#define TABLA_A_CDC_MBHC_TIMER_B1_CTL__POR			(0x00000003)
+#define TABLA_A_CDC_MBHC_TIMER_B2_CTL			(0x000003C4)
+#define TABLA_A_CDC_MBHC_TIMER_B2_CTL__POR			(0x00000009)
+#define TABLA_A_CDC_MBHC_TIMER_B3_CTL			(0x000003C5)
+#define TABLA_A_CDC_MBHC_TIMER_B3_CTL__POR			(0x0000001e)
+#define TABLA_A_CDC_MBHC_TIMER_B4_CTL			(0x000003C6)
+#define TABLA_A_CDC_MBHC_TIMER_B4_CTL__POR			(0x00000045)
+#define TABLA_A_CDC_MBHC_TIMER_B5_CTL			(0x000003C7)
+#define TABLA_A_CDC_MBHC_TIMER_B5_CTL__POR			(0x00000004)
+#define TABLA_A_CDC_MBHC_TIMER_B6_CTL			(0x000003C8)
+#define TABLA_A_CDC_MBHC_TIMER_B6_CTL__POR			(0x00000078)
+#define TABLA_A_CDC_MBHC_B1_STATUS			(0x000003C9)
+#define TABLA_A_CDC_MBHC_B1_STATUS__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_B2_STATUS			(0x000003CA)
+#define TABLA_A_CDC_MBHC_B2_STATUS__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_B3_STATUS			(0x000003CB)
+#define TABLA_A_CDC_MBHC_B3_STATUS__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_B4_STATUS			(0x000003CC)
+#define TABLA_A_CDC_MBHC_B4_STATUS__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_B5_STATUS			(0x000003CD)
+#define TABLA_A_CDC_MBHC_B5_STATUS__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_B1_CTL			(0x000003CE)
+#define TABLA_A_CDC_MBHC_B1_CTL__POR			(0x000000c0)
+#define TABLA_A_CDC_MBHC_B2_CTL			(0x000003CF)
+#define TABLA_A_CDC_MBHC_B2_CTL__POR			(0x0000005d)
+#define TABLA_A_CDC_MBHC_VOLT_B1_CTL			(0x000003D0)
+#define TABLA_A_CDC_MBHC_VOLT_B1_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_VOLT_B2_CTL			(0x000003D1)
+#define TABLA_A_CDC_MBHC_VOLT_B2_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_VOLT_B3_CTL			(0x000003D2)
+#define TABLA_A_CDC_MBHC_VOLT_B3_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_VOLT_B4_CTL			(0x000003D3)
+#define TABLA_A_CDC_MBHC_VOLT_B4_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_VOLT_B5_CTL			(0x000003D4)
+#define TABLA_A_CDC_MBHC_VOLT_B5_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_VOLT_B6_CTL			(0x000003D5)
+#define TABLA_A_CDC_MBHC_VOLT_B6_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_VOLT_B7_CTL			(0x000003D6)
+#define TABLA_A_CDC_MBHC_VOLT_B7_CTL__POR			(0x000000ff)
+#define TABLA_A_CDC_MBHC_VOLT_B8_CTL			(0x000003D7)
+#define TABLA_A_CDC_MBHC_VOLT_B8_CTL__POR			(0x00000007)
+#define TABLA_A_CDC_MBHC_VOLT_B9_CTL			(0x000003D8)
+#define TABLA_A_CDC_MBHC_VOLT_B9_CTL__POR			(0x000000ff)
+#define TABLA_A_CDC_MBHC_VOLT_B10_CTL			(0x000003D9)
+#define TABLA_A_CDC_MBHC_VOLT_B10_CTL__POR			(0x0000007f)
+#define TABLA_A_CDC_MBHC_VOLT_B11_CTL			(0x000003DA)
+#define TABLA_A_CDC_MBHC_VOLT_B11_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_VOLT_B12_CTL			(0x000003DB)
+#define TABLA_A_CDC_MBHC_VOLT_B12_CTL__POR			(0x00000080)
+#define TABLA_A_CDC_MBHC_CLK_CTL			(0x000003DC)
+#define TABLA_A_CDC_MBHC_CLK_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_INT_CTL			(0x000003DD)
+#define TABLA_A_CDC_MBHC_INT_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_DEBUG_CTL			(0x000003DE)
+#define TABLA_A_CDC_MBHC_DEBUG_CTL__POR			(0x00000000)
+#define TABLA_A_CDC_MBHC_SPARE			(0x000003DF)
+#define TABLA_A_CDC_MBHC_SPARE__POR			(0x00000000)
+
+
+/* SLIMBUS Slave Registers */
+#define TABLA_SLIM_PGD_PORT_INT_EN0                     (0x30)
+#define TABLA_SLIM_PGD_PORT_INT_STATUS0                 (0x34)
+#define TABLA_SLIM_PGD_PORT_INT_CLR0                    (0x38)
+#define TABLA_SLIM_PGD_PORT_INT_SOURCE0			(0x60)
+
+/* Macros for Packing Register Writes into a U32 */
+#define TABLA_PACKED_REG_SIZE sizeof(u32)
+
+#define TABLA_CODEC_PACK_ENTRY(reg, mask, val) ((val & 0xff)|\
+	((mask & 0xff) << 8)|((reg & 0xffff) << 16))
+
+#define TABLA_CODEC_UNPACK_ENTRY(packed, reg, mask, val) \
+	do { \
+		((reg) = ((packed >> 16) & (0xffff))); \
+		((mask) = ((packed >> 8) & (0xff))); \
+		((val) = ((packed) & (0xff))); \
+	} while (0);
+
+#endif
diff --git a/include/linux/mfd/wcd9xxx/wcd9xxx-slimslave.h b/include/linux/mfd/wcd9xxx/wcd9xxx-slimslave.h
new file mode 100644
index 0000000..c62c3a3
--- /dev/null
+++ b/include/linux/mfd/wcd9xxx/wcd9xxx-slimslave.h
@@ -0,0 +1,105 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __WCD9310_SLIMSLAVE_H_
+#define __WCD9310_SLIMSLAVE_H_
+
+#include <linux/slimbus/slimbus.h>
+#include <linux/mfd/wcd9xxx/core.h>
+
+/* Local to the core only */
+#define SLIM_MAX_RX_PORTS 7
+#define SLIM_MAX_TX_PORTS 10
+
+/* Channel numbers to be used for each port */
+enum {
+	SLIM_TX_1   = 128,
+	SLIM_TX_2   = 129,
+	SLIM_TX_3   = 130,
+	SLIM_TX_4   = 131,
+	SLIM_TX_5   = 132,
+	SLIM_TX_6   = 133,
+	SLIM_TX_7   = 134,
+	SLIM_TX_8   = 135,
+	SLIM_TX_9   = 136,
+	SLIM_TX_10  = 137,
+	SLIM_RX_1   = 138,
+	SLIM_RX_2   = 139,
+	SLIM_RX_3   = 140,
+	SLIM_RX_4   = 141,
+	SLIM_RX_5   = 142,
+	SLIM_RX_6   = 143,
+	SLIM_RX_7   = 144,
+	SLIM_MAX    = 145
+};
+
+/*
+ *  client is expected to give port ids in the range of 1-10 for Tx ports and
+ *  1-7 for Rx ports, we need to add offset for getting the absolute slave
+ *  port id before configuring the HW
+ */
+#define SB_PGD_MAX_NUMBER_OF_TX_SLAVE_DEV_PORTS 10
+#define SB_PGD_OFFSET_OF_TX_SLAVE_DEV_PORTS     -1
+#define SB_PGD_MAX_NUMBER_OF_RX_SLAVE_DEV_PORTS 7
+#define SB_PGD_OFFSET_OF_RX_SLAVE_DEV_PORTS     9
+
+/* below details are taken from SLIMBUS slave SWI */
+#define SB_PGD_PORT_BASE 0x000
+
+#define SB_PGD_PORT_CFG_BYTE_ADDR(port_num) \
+		(SB_PGD_PORT_BASE + 0x040 + 1*port_num)
+
+#define SB_PGD_TX_PORT_MULTI_CHANNEL_0(port_num) \
+		(SB_PGD_PORT_BASE + 0x100 + 4*port_num)
+#define SB_PGD_TX_PORT_MULTI_CHANNEL_0_START_PORT_ID   0
+#define SB_PGD_TX_PORT_MULTI_CHANNEL_0_END_PORT_ID     7
+
+#define SB_PGD_TX_PORT_MULTI_CHANNEL_1(port_num) \
+		(SB_PGD_PORT_BASE + 0x101 + 4*port_num)
+#define SB_PGD_TX_PORT_MULTI_CHANNEL_1_START_PORT_ID   8
+#define SB_PGD_TX_PORT_MULTI_CHANNEL_1_END_PORT_ID     9
+
+#define SB_PGD_RX_PORT_MULTI_CHANNEL_0(port_num) \
+		(SB_PGD_PORT_BASE + 0x180 + 4*port_num)
+#define SB_PGD_RX_PORT_MULTI_CHANNEL_0_START_PORT_ID   10
+#define SB_PGD_RX_PORT_MULTI_CHANNEL_0_END_PORT_ID     16
+
+/* slave port water mark level
+ *   (0: 6bytes, 1: 9bytes, 2: 12 bytes, 3: 15 bytes)
+ */
+#define SLAVE_PORT_WATER_MARK_VALUE 2
+#define SLAVE_PORT_WATER_MARK_SHIFT 1
+#define SLAVE_PORT_ENABLE           1
+#define SLAVE_PORT_DISABLE          0
+
+#define BASE_CH_NUM 128
+
+
+int wcd9xxx_init_slimslave(struct wcd9xxx *wcd9xxx, u8 wcd9xxx_pgd_la);
+
+int wcd9xxx_deinit_slimslave(struct wcd9xxx *wcd9xxx);
+
+int wcd9xxx_cfg_slim_sch_rx(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int tot_ch, unsigned int rate);
+int wcd9xxx_cfg_slim_sch_tx(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int tot_ch, unsigned int rate);
+int wcd9xxx_close_slim_sch_rx(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int tot_ch);
+int wcd9xxx_close_slim_sch_tx(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int tot_ch);
+int wcd9xxx_get_channel(struct wcd9xxx *wcd9xxx,
+			unsigned int *rx_ch,
+			unsigned int *tx_ch);
+int wcd9xxx_get_slave_port(unsigned int ch_num);
+int wcd9xxx_disconnect_port(struct wcd9xxx *wcd9xxx, unsigned int *ch_num,
+				unsigned int tot_ch, unsigned int rx_tx);
+#endif /* __WCD9310_SLIMSLAVE_H_ */
diff --git a/include/linux/mfd/wcd9xxx/wcd9xxx_registers.h b/include/linux/mfd/wcd9xxx/wcd9xxx_registers.h
new file mode 100644
index 0000000..73dda8f
--- /dev/null
+++ b/include/linux/mfd/wcd9xxx/wcd9xxx_registers.h
@@ -0,0 +1,42 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef WCD9XXX_CODEC_DIGITAL_H
+
+#define WCD9XXX_CODEC_DIGITAL_H
+
+#define WCD9XXX_A_CHIP_CTL			(0x00)
+#define WCD9XXX_A_CHIP_CTL__POR			(0x00000000)
+#define WCD9XXX_A_CHIP_STATUS			(0x01)
+#define WCD9XXX_A_CHIP_STATUS__POR			(0x00000000)
+#define WCD9XXX_A_CHIP_ID_BYTE_0			(0x04)
+#define WCD9XXX_A_CHIP_ID_BYTE_0__POR			(0x00000000)
+#define WCD9XXX_A_CHIP_ID_BYTE_1			(0x05)
+#define WCD9XXX_A_CHIP_ID_BYTE_1__POR			(0x00000000)
+#define WCD9XXX_A_CHIP_ID_BYTE_2			(0x06)
+#define WCD9XXX_A_CHIP_ID_BYTE_2__POR			(0x00000000)
+#define WCD9XXX_A_CHIP_ID_BYTE_3			(0x07)
+#define WCD9XXX_A_CHIP_ID_BYTE_3__POR			(0x00000001)
+#define WCD9XXX_A_CHIP_VERSION			(0x08)
+#define WCD9XXX_A_CHIP_VERSION__POR			(0x00000020)
+#define WCD9XXX_A_SB_VERSION			(0x09)
+#define WCD9XXX_A_SB_VERSION__POR			(0x00000010)
+#define WCD9XXX_A_SLAVE_ID_1			(0x0C)
+#define WCD9XXX_A_SLAVE_ID_1__POR			(0x00000077)
+#define WCD9XXX_A_SLAVE_ID_2			(0x0D)
+#define WCD9XXX_A_SLAVE_ID_2__POR			(0x00000066)
+#define WCD9XXX_A_SLAVE_ID_3			(0x0E)
+#define WCD9XXX_A_SLAVE_ID_3__POR			(0x00000055)
+#define WCD9XXX_A_CDC_CTL			(0x80)
+#define WCD9XXX_A_CDC_CTL__POR			(0x00000000)
+#define WCD9XXX_A_LEAKAGE_CTL			(0x88)
+#define WCD9XXX_A_LEAKAGE_CTL__POR			(0x00000004)
+#endif
-- 
1.7.5.4

