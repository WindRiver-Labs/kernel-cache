From 5c4dda7f194b7ad39b9fcc9e0da83c8537b5cf47 Mon Sep 17 00:00:00 2001
From: Catalin Enache <catalin.enache@windriver.com>
Date: Fri, 22 Nov 2013 13:42:14 +0200
Subject: [PATCH 60/66] Add Sierra i2c and spi drivers

Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 arch/arm/mach-msm/Makefile     |    2 +-
 arch/arm/mach-msm/sierra_i2c.c |  217 +++++++++++++
 arch/arm/mach-msm/sierra_spi.c |  688 ++++++++++++++++++++++++++++++++++++++++
 include/linux/i2c/sierra_i2c.h |   28 ++
 include/linux/spi/sierra_spi.h |  209 ++++++++++++
 5 files changed, 1143 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-msm/sierra_i2c.c
 create mode 100644 arch/arm/mach-msm/sierra_spi.c
 create mode 100644 include/linux/i2c/sierra_i2c.h
 create mode 100644 include/linux/spi/sierra_spi.h

diff --git a/arch/arm/mach-msm/Makefile b/arch/arm/mach-msm/Makefile
index 78da19f..273bc35 100644
--- a/arch/arm/mach-msm/Makefile
+++ b/arch/arm/mach-msm/Makefile
@@ -384,6 +384,6 @@ ifdef CONFIG_MSM_CPR
 obj-$(CONFIG_DEBUG_FS) += msm_cpr-debug.o
 endif
 # SWISTART
-obj-$(CONFIG_SIERRA) += sierra_bscommon.o
+obj-$(CONFIG_SIERRA) += sierra_bscommon.o sierra_i2c.o sierra_spi.o
 obj-$(CONFIG_SIERRA_SMEM) += sierra_smem.o sierra_smem_errdump.o
 #SWISTOP
diff --git a/arch/arm/mach-msm/sierra_i2c.c b/arch/arm/mach-msm/sierra_i2c.c
new file mode 100644
index 0000000..b97e131
--- /dev/null
+++ b/arch/arm/mach-msm/sierra_i2c.c
@@ -0,0 +1,217 @@
+/* arch/arm/mach-msm/sierra_i2c.c
+ *
+ * Copyright (C) 2013 Sierra Wireless, Inc
+ * Author: Alex Tan <atan@sierrawireless.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/* #define DEBUG */
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+
+#include <linux/i2c/sierra_i2c.h>
+
+#define I2C_BUF_SIZE 128
+static LIST_HEAD(sierra_i2c_device_list);
+
+struct sierra_i2c_device
+{
+  struct i2c_client *client;
+  struct list_head dev_list;
+};
+
+static struct i2c_client * sierra_i2c_lookup(int addr)
+{
+  struct sierra_i2c_device *dev;
+  list_for_each_entry(dev,&sierra_i2c_device_list,dev_list)
+  {
+    if(dev->client->addr == addr)
+      return dev->client;
+  }
+  return NULL;
+}
+
+static ssize_t sierra_i2c_read(struct file *fp, char __user *buf,
+            size_t count, loff_t *posp)
+{
+  struct i2c_adapter *i2c_adap;
+  struct i2c_client *client;
+  struct i2c_msg msg;
+  char data_buf[I2C_BUF_SIZE];
+  int ret,data_size;
+    
+  client = (struct i2c_client *)fp->private_data;
+  if(!client)
+  {
+    pr_err("sierra i2c dev was not configured\n");
+    return -EIO;
+  }
+
+  data_size = min(count,sizeof(data_buf));
+
+  i2c_adap = client->adapter;
+    
+  msg.addr = client->addr;
+  msg.flags = I2C_M_RD;
+  msg.len = count;
+  msg.buf = data_buf;
+    
+  ret = i2c_transfer(client->adapter, &msg, 1);
+  if(ret < 0)
+    return ret;
+
+  if(copy_to_user((void __user *)buf,(void *)data_buf,data_size))
+    return -EFAULT;
+  
+  return data_size;
+
+}
+
+static ssize_t sierra_i2c_write(struct file *fp, const char __user *buf,
+             size_t count, loff_t *posp)
+{
+  struct i2c_adapter *i2c_adap;
+  struct i2c_client *client;
+  struct i2c_msg msg;
+  char data_buf[I2C_BUF_SIZE];
+  int ret;
+  
+  client = (struct i2c_client *)fp->private_data;
+  if(!client)
+  {
+    pr_err("sierra i2c dev was not configured\n");
+    return -EIO;
+  }
+
+  if(count > sizeof(data_buf))
+    return -ENOMEM;
+  
+  if(copy_from_user(data_buf, buf, count))
+    return -EFAULT;
+  
+  i2c_adap = client->adapter;
+  
+  msg.addr = client->addr;
+  msg.flags = 0;
+  msg.len = count;
+  msg.buf = data_buf;
+
+  pr_debug("swi_i2c:reading %d data from 0x%x addr\n",count,client->addr);
+  ret = i2c_transfer(client->adapter, &msg, 1);
+  if(ret >= 0)
+    return 0;
+  
+  return ret;
+}
+    
+static int sierra_i2c_open(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static int sierra_i2c_release(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static long sierra_i2c_ioctl(struct file *filp, u_int cmd, u_long arg)
+{
+  int addr,freq,ret;
+  struct i2c_adapter *i2c_adap;
+  struct i2c_client *swi_i2c_client;
+  struct i2c_board_info info;
+  struct sierra_i2c_device *swi_i2c_dev;
+  unsigned short addr_list[] = {0xFF, I2C_CLIENT_END};
+  memset(&info, 0, sizeof(struct i2c_board_info));
+  i2c_adap = i2c_get_adapter(0x0);
+  if(i2c_adap == NULL)
+  {
+    pr_err("sierra:i2c get null adapter from 0x0\n");
+          return -EFAULT;
+  }
+  switch(cmd)
+  {
+    case SWI_IOCTL_I2C_ADDR_CONFIG:
+      if(copy_from_user(&addr,(void __user *)arg,sizeof(int)))
+        return -EFAULT;
+      
+      /*lookup the i2c dev list to check if this dev exist*/
+      swi_i2c_client = sierra_i2c_lookup(addr);
+      if(swi_i2c_client)
+      {
+        filp->private_data = swi_i2c_client;
+        return 0;
+      }
+      
+      addr_list[0] = addr;
+      swi_i2c_client = i2c_new_probed_device(i2c_adap, &info, addr_list, NULL);
+      if(!swi_i2c_client)
+        return -ENODEV;
+      
+      swi_i2c_dev = kmalloc(sizeof(struct sierra_i2c_device),GFP_KERNEL);
+      if(!swi_i2c_dev)
+        return -ENOMEM;
+
+      swi_i2c_dev->client = swi_i2c_client;
+      filp->private_data = swi_i2c_client;
+      list_add_tail(&swi_i2c_dev->dev_list,&sierra_i2c_device_list);
+      
+      pr_debug("config i2c device,addr 0x%x\n",addr);
+      break;
+      
+    case SWI_IOCTL_I2C_FREQ_CONFIG:
+      if(copy_from_user(&freq,(void __user *)arg,sizeof(int)))
+        return -EFAULT;
+      if((ret = swi_set_i2c_freq(i2c_adap,freq * 1000))< 0)
+        return ret;
+      break;
+      
+    default:
+      break;
+  }
+  return 0;
+}
+
+static struct file_operations sierra_i2c_fops = {
+    .owner = THIS_MODULE,
+    .read = sierra_i2c_read,
+    .write = sierra_i2c_write,
+    .open = sierra_i2c_open,
+    .unlocked_ioctl = sierra_i2c_ioctl,
+    .release = sierra_i2c_release,
+};
+
+static struct miscdevice sierra_i2c_misc = {
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = "sierra_i2c",
+    .fops = &sierra_i2c_fops,
+};
+
+static int __init sierra_i2c_init(void)
+{
+  return misc_register(&sierra_i2c_misc);
+}
+
+static void __exit sierra_i2c_exit(void)
+{
+  misc_deregister(&sierra_i2c_misc);
+}
+
+module_init(sierra_i2c_init);
+module_exit(sierra_i2c_exit);
+
+MODULE_AUTHOR("Alex Tan <atan@sierrawireless.com>");
+MODULE_DESCRIPTION("Sierra I2C driver");
+MODULE_LICENSE("GPL v2");
diff --git a/arch/arm/mach-msm/sierra_spi.c b/arch/arm/mach-msm/sierra_spi.c
new file mode 100644
index 0000000..2a54040
--- /dev/null
+++ b/arch/arm/mach-msm/sierra_spi.c
@@ -0,0 +1,688 @@
+/* arch/arm/mach-msm/sierra_spi.c
+ *
+ * Copyright (C) 2013 Sierra Wireless, Inc
+ * Author: Alex Tan <atan@sierrawireless.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* #define DEBUG */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/compat.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/sierra_spi.h>
+#include <linux/miscdevice.h>
+
+#include <asm/uaccess.h>
+
+/* Bit masks for spi_device.mode management.  Note that incorrect
+ * settings for some settings can cause *lots* of trouble for other
+ * devices on a shared bus:
+ *
+ *  - CS_HIGH ... this device will be active when it shouldn't be
+ *  - 3WIRE ... when active, it won't behave as it should
+ *  - NO_CS ... there will be no explicit message boundaries; this
+ *  is completely incompatible with the shared bus model
+ *  - READY ... transfers may proceed when they shouldn't.
+ *
+ * REVISIT should changing those flags be privileged?
+ */
+#define SPI_MODE_MASK    (SPI_CPHA | SPI_CPOL | SPI_CS_HIGH \
+                | SPI_LSB_FIRST | SPI_3WIRE | SPI_LOOP \
+                | SPI_NO_CS | SPI_READY | SPI_CS_FORCE | SPI_CLK_ALWAYS_ON )
+
+struct swi_spidev_data {
+    spinlock_t    spi_lock;
+    struct spi_device  *spi;
+
+    /* buffer is NULL unless this device is open (users > 0) */
+    struct mutex    buf_lock;
+    unsigned    users;
+    u8      *buffer;
+    u8      *bufferrx;
+    u32     swi_cfg_mask;
+};
+
+static LIST_HEAD(device_list);
+static DEFINE_MUTEX(device_list_lock);
+
+static unsigned bufsiz = 512;
+
+static struct spi_device *spi;
+struct swi_spidev_data  *swi_spidev;
+struct msm_spi    *dd;
+
+/*this table is same with the freq table in clock-9615.c*/
+static unsigned int gsbi_qup_clk_table[] = {0,960000,4800000,9600000,
+                                            15058800,24000000,25600000,
+                                            48000000,51200000};
+
+static void swi_spidev_setup(int mode)
+{
+  if(!spi)
+    return;
+  swi_reg_bit_set(spi,SPI_IO_CONTROL,SPI_IO_C_FORCE_CS,!!(mode & SPI_CS_FORCE));
+  swi_reg_bit_set(spi,SPI_IO_CONTROL,SPI_IO_C_CLK_ALWAYS_ON,!!(mode & SPI_CLK_ALWAYS_ON));
+}
+
+/*swi_spidev_check_spi_clk - we check the max_speed param and choose a proper freq in the table
+@spi: the spi_device struct we create for spi interface
+*/
+static void swi_spidev_check_spi_clk(struct spi_device  *spi)
+{
+  int i;
+  int size = sizeof(gsbi_qup_clk_table)/sizeof(gsbi_qup_clk_table[0]);
+  if(spi->max_speed_hz <= 0)
+    return;
+  
+  for(i=0; i<size; i++)
+  {
+    if(spi->max_speed_hz < gsbi_qup_clk_table[i])
+      break;
+  }
+  
+  if(i == size)
+    spi->max_speed_hz = gsbi_qup_clk_table[i];
+  else if(spi->max_speed_hz > (gsbi_qup_clk_table[i]+gsbi_qup_clk_table[i-1])/2)
+    spi->max_speed_hz = gsbi_qup_clk_table[i];
+  else
+    spi->max_speed_hz = gsbi_qup_clk_table[i-1];
+    
+}
+/*-------------------------------------------------------------------------*/
+
+/*
+ * We can't use the standard synchronous wrappers for file I/O; we
+ * need to protect against async removal of the underlying spi_device.
+ */
+static void swi_spidev_complete(void *arg)
+{
+  complete(arg);
+}
+
+static ssize_t
+swi_spidev_sync(struct swi_spidev_data *swi_spidev, struct spi_message *message)
+{
+  DECLARE_COMPLETION_ONSTACK(done);
+  int status;
+
+  message->complete = swi_spidev_complete;
+  message->context = &done;
+
+  spin_lock_irq(&swi_spidev->spi_lock);
+  if (swi_spidev->spi == NULL)
+    status = -ESHUTDOWN;
+  else
+    status = spi_async(swi_spidev->spi, message);
+  spin_unlock_irq(&swi_spidev->spi_lock);
+
+  if (status == 0) {
+    wait_for_completion(&done);
+    status = message->status;
+    if (status == 0)
+      status = message->actual_length;
+  }
+  return status;
+}
+
+static inline ssize_t
+swi_spidev_sync_write(struct swi_spidev_data *swi_spidev, size_t len)
+{
+  struct spi_transfer  t = {
+      .tx_buf  = swi_spidev->buffer,
+      .len     = len,
+    };
+  struct spi_message  m;
+
+  spi_message_init(&m);
+  spi_message_add_tail(&t, &m);
+  return swi_spidev_sync(swi_spidev, &m);
+}
+
+static inline ssize_t
+swi_spidev_sync_read(struct swi_spidev_data *swi_spidev, size_t len)
+{
+  struct spi_transfer  t = {
+      .rx_buf  = swi_spidev->bufferrx,
+      .len     = len,
+    };
+  struct spi_message  m;
+
+  spi_message_init(&m);
+  spi_message_add_tail(&t, &m);
+  return swi_spidev_sync(swi_spidev, &m);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Read-only message with current device setup */
+static ssize_t
+swi_spidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+  struct swi_spidev_data  *swi_spidev;
+  ssize_t      status = 0;
+
+  /* chipselect only toggles at start or end of operation */
+  if (count > bufsiz)
+    return -EMSGSIZE;
+
+  swi_spidev = filp->private_data;
+
+  mutex_lock(&swi_spidev->buf_lock);
+  status = swi_spidev_sync_read(swi_spidev, count);
+  if (status > 0) {
+    unsigned long  missing;
+
+    missing = copy_to_user(buf, swi_spidev->bufferrx, status);
+    if (missing == status)
+      status = -EFAULT;
+    else
+      status = status - missing;
+  }
+  mutex_unlock(&swi_spidev->buf_lock);
+
+  return status;
+}
+
+/* Write-only message with current device setup */
+static ssize_t
+swi_spidev_write(struct file *filp, const char __user *buf,
+    size_t count, loff_t *f_pos)
+{
+  struct swi_spidev_data  *swi_spidev;
+  ssize_t      status = 0;
+  unsigned long    missing;
+
+  /* chipselect only toggles at start or end of operation */
+  if (count > bufsiz)
+    return -EMSGSIZE;
+
+  swi_spidev = filp->private_data;
+
+  mutex_lock(&swi_spidev->buf_lock);
+  missing = copy_from_user(swi_spidev->buffer, buf, count);
+  if (missing == 0) {
+    status = swi_spidev_sync_write(swi_spidev, count);
+  } else
+    status = -EFAULT;
+  mutex_unlock(&swi_spidev->buf_lock);
+
+  return status;
+}
+
+static int swi_spidev_message(struct swi_spidev_data *swi_spidev,
+    struct spi_ioc_transfer *u_xfers, unsigned n_xfers)
+{
+  struct spi_message  msg;
+  struct spi_transfer  *k_xfers;
+  struct spi_transfer  *k_tmp;
+  struct spi_ioc_transfer *u_tmp;
+  unsigned    n, total;
+  u8      *buf, *bufrx;
+  int      status = -EFAULT;
+
+  spi_message_init(&msg);
+  k_xfers = kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL);
+  if (k_xfers == NULL)
+    return -ENOMEM;
+
+  /* Construct spi_message, copying any tx data to bounce buffer.
+   * We walk the array of user-provided transfers, using each one
+   * to initialize a kernel version of the same transfer.
+   */
+  buf = swi_spidev->buffer;
+  bufrx = swi_spidev->bufferrx;
+  total = 0;
+  for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
+      n;
+      n--, k_tmp++, u_tmp++) {
+    k_tmp->len = u_tmp->len;
+
+    total += k_tmp->len;
+    if (total > bufsiz) {
+      status = -EMSGSIZE;
+      goto done;
+    }
+
+    if (u_tmp->rx_buf) {
+      k_tmp->rx_buf = bufrx;
+      if (!access_ok(VERIFY_WRITE, (u8 __user *)
+            (uintptr_t) u_tmp->rx_buf,
+            u_tmp->len))
+        goto done;
+    }
+    if (u_tmp->tx_buf) {
+      k_tmp->tx_buf = buf;
+      if (copy_from_user(buf, (const u8 __user *)
+            (uintptr_t) u_tmp->tx_buf,
+          u_tmp->len))
+        goto done;
+    }
+    buf += k_tmp->len;
+    bufrx += k_tmp->len;
+
+    k_tmp->cs_change = !!u_tmp->cs_change;
+    k_tmp->bits_per_word = u_tmp->bits_per_word;
+    k_tmp->delay_usecs = u_tmp->delay_usecs;
+    k_tmp->speed_hz = u_tmp->speed_hz;
+#ifdef VERBOSE
+    dev_dbg(&swi_spidev->spi->dev,
+      "  xfer len %zd %s%s%s%dbits %u usec %uHz\n",
+      u_tmp->len,
+      u_tmp->rx_buf ? "rx " : "",
+      u_tmp->tx_buf ? "tx " : "",
+      u_tmp->cs_change ? "cs " : "",
+      u_tmp->bits_per_word ? : swi_spidev->spi->bits_per_word,
+      u_tmp->delay_usecs,
+      u_tmp->speed_hz ? : swi_spidev->spi->max_speed_hz);
+#endif
+    spi_message_add_tail(k_tmp, &msg);
+  }
+
+  status = swi_spidev_sync(swi_spidev, &msg);
+  if (status < 0)
+    goto done;
+
+  /* copy any rx data out of bounce buffer */
+  buf = swi_spidev->bufferrx;
+  for (n = n_xfers, u_tmp = u_xfers; n; n--, u_tmp++) {
+    if (u_tmp->rx_buf) {
+      if (__copy_to_user((u8 __user *)
+          (uintptr_t) u_tmp->rx_buf, buf,
+          u_tmp->len)) {
+        status = -EFAULT;
+        goto done;
+      }
+    }
+    buf += u_tmp->len;
+  }
+  status = total;
+
+done:
+  kfree(k_xfers);
+  return status;
+}
+
+static long
+swi_spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+  int      err = 0;
+  int      retval = 0;
+  int      deassert_time = 0;
+  struct swi_spidev_data  *swi_spidev;
+  struct spi_device  *spi;
+  u32      tmp;
+  unsigned    n_ioc;
+  struct spi_ioc_transfer  *ioc;
+
+  /* Check type and command number */
+  if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)
+    return -ENOTTY;
+
+  /* Check access direction once here; don't repeat below.
+   * IOC_DIR is from the user perspective, while access_ok is
+   * from the kernel perspective; so they look reversed.
+   */
+  if (_IOC_DIR(cmd) & _IOC_READ)
+    err = !access_ok(VERIFY_WRITE,
+        (void __user *)arg, _IOC_SIZE(cmd));
+  if (err == 0 && _IOC_DIR(cmd) & _IOC_WRITE)
+    err = !access_ok(VERIFY_READ,
+        (void __user *)arg, _IOC_SIZE(cmd));
+  if (err)
+    return -EFAULT;
+
+  /* guard against device removal before, or while,
+   * we issue this ioctl.
+   */
+  swi_spidev = filp->private_data;
+  spin_lock_irq(&swi_spidev->spi_lock);
+  spi = spi_dev_get(swi_spidev->spi);
+  spin_unlock_irq(&swi_spidev->spi_lock);
+
+  if (spi == NULL)
+    return -ESHUTDOWN;
+
+  /* use the buffer lock here for triple duty:
+   *  - prevent I/O (from us) so calling spi_setup() is safe;
+   *  - prevent concurrent SPI_IOC_WR_* from morphing
+   *    data fields while SPI_IOC_RD_* reads them;
+   *  - SPI_IOC_MESSAGE needs the buffer locked "normally".
+   */
+  mutex_lock(&swi_spidev->buf_lock);
+
+  switch (cmd) {
+  /* read requests */
+  case SPI_IOC_RD_MODE:
+    retval = __put_user(swi_spidev->swi_cfg_mask & SPI_MODE_MASK,
+          (__u32 __user *)arg);
+    break;
+  case SPI_IOC_RD_LSB_FIRST:
+    retval = __put_user((swi_spidev->swi_cfg_mask & SPI_LSB_FIRST) ?  1 : 0,
+          (__u8 __user *)arg);
+    break;
+  case SPI_IOC_RD_BITS_PER_WORD:
+    retval = __put_user(spi->bits_per_word, (__u8 __user *)arg);
+    break;
+  case SPI_IOC_RD_MAX_SPEED_HZ:
+    retval = __put_user(spi->max_speed_hz, (__u32 __user *)arg);
+    break;
+  case SPI_IOC_RD_DEASSERT_TIME:
+    deassert_time = swi_read_deassert_time(spi);
+    retval = __put_user(deassert_time, (__u32 __user *)arg);
+    break;
+  /* write requests */
+  case SPI_IOC_WR_MODE:
+    retval = __get_user(tmp, (u32 __user *)arg);
+    if (retval == 0) {
+      u32  save = swi_spidev->swi_cfg_mask;
+
+      if (tmp & ~SPI_MODE_MASK) {
+        retval = -EINVAL;
+        break;
+      }
+
+      tmp |= swi_spidev->swi_cfg_mask & ~SPI_MODE_MASK;
+      spi->mode = (u8)tmp;
+      swi_spidev->swi_cfg_mask = tmp;
+      
+      retval = spi_setup(spi);
+      if (retval < 0)
+        swi_spidev->swi_cfg_mask = save;
+      else
+      {
+        swi_spidev_setup(swi_spidev->swi_cfg_mask);
+        dev_dbg(&spi->dev, "spi mode %04x\n", tmp);
+      }
+      
+    }
+    break;
+  case SPI_IOC_WR_LSB_FIRST:
+    retval = __get_user(tmp, (__u8 __user *)arg);
+    if (retval == 0) {
+      u8  save = spi->mode;
+
+      if (tmp)
+        spi->mode |= SPI_LSB_FIRST;
+      else
+        spi->mode &= ~SPI_LSB_FIRST;
+      retval = spi_setup(spi);
+      if (retval < 0)
+        spi->mode = save;
+      else
+        dev_dbg(&spi->dev, "%csb first\n",
+            tmp ? 'l' : 'm');
+    }
+    break;
+  case SPI_IOC_WR_BITS_PER_WORD:
+    retval = __get_user(tmp, (__u8 __user *)arg);
+    if (retval == 0) {
+      u8  save = spi->bits_per_word;
+
+      spi->bits_per_word = tmp;
+      retval = spi_setup(spi);
+      if (retval < 0)
+        spi->bits_per_word = save;
+      else
+        dev_dbg(&spi->dev, "%d bits per word\n", tmp);
+    }
+    break;
+  case SPI_IOC_WR_MAX_SPEED_HZ:
+    retval = __get_user(tmp, (__u32 __user *)arg);
+    if (retval == 0) {
+      u32  save = spi->max_speed_hz;
+
+      spi->max_speed_hz = tmp;
+      swi_spidev_check_spi_clk(spi);
+      retval = spi_setup(spi);
+      if (retval < 0)
+        spi->max_speed_hz = save;
+      else
+        dev_dbg(&spi->dev, "%d Hz (max)\n", tmp);
+    }
+    break;
+  case SPI_IOC_WR_DEASSERT_TIME:
+    retval = __get_user(tmp, (__u8 __user *)arg);
+    swi_write_deassert_time(spi,(u8)tmp);
+    break;
+  default:
+    /* segmented and/or full-duplex I/O request */
+    if (_IOC_NR(cmd) != _IOC_NR(SPI_IOC_MESSAGE(0))
+        || _IOC_DIR(cmd) != _IOC_WRITE) {
+      retval = -ENOTTY;
+      break;
+    }
+
+    tmp = _IOC_SIZE(cmd);
+    if ((tmp % sizeof(struct spi_ioc_transfer)) != 0) {
+      retval = -EINVAL;
+      break;
+    }
+    n_ioc = tmp / sizeof(struct spi_ioc_transfer);
+    if (n_ioc == 0)
+      break;
+
+    /* copy into scratch area */
+    ioc = kmalloc(tmp, GFP_KERNEL);
+    if (!ioc) {
+      retval = -ENOMEM;
+      break;
+    }
+    if (__copy_from_user(ioc, (void __user *)arg, tmp)) {
+      kfree(ioc);
+      retval = -EFAULT;
+      break;
+    }
+
+    /* translate to spi_message, execute */
+    retval = swi_spidev_message(swi_spidev, ioc, n_ioc);
+    kfree(ioc);
+    break;
+  }
+
+  mutex_unlock(&swi_spidev->buf_lock);
+  spi_dev_put(spi);
+  return retval;
+}
+
+#ifdef CONFIG_COMPAT
+static long
+swi_spidev_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+  return swi_spidev_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));
+}
+#else
+#define swi_spidev_compat_ioctl NULL
+#endif /* CONFIG_COMPAT */
+
+static int swi_spidev_open(struct inode *inode, struct file *filp)
+{
+  
+  int  status = 0;
+  
+  if (!swi_spidev->buffer) {
+    swi_spidev->buffer = kmalloc(bufsiz, GFP_KERNEL);
+    if (!swi_spidev->buffer) {
+      dev_dbg(&swi_spidev->spi->dev, "open/ENOMEM\n");
+      status = -ENOMEM;
+    }
+  }
+  if (!swi_spidev->bufferrx) {
+    swi_spidev->bufferrx = kmalloc(bufsiz, GFP_KERNEL);
+    if (!swi_spidev->bufferrx) {
+      dev_dbg(&swi_spidev->spi->dev, "open/ENOMEM\n");
+      kfree(swi_spidev->buffer);
+      swi_spidev->buffer = NULL;
+      status = -ENOMEM;
+    }
+  }
+  swi_spidev->users++;
+  filp->private_data = swi_spidev;
+  nonseekable_open(inode, filp);
+
+  return status;
+}
+
+static int swi_spidev_release(struct inode *inode, struct file *filp)
+{
+  struct swi_spidev_data  *swi_spidev;
+  int      status = 0;
+
+  swi_spidev = filp->private_data;
+  filp->private_data = NULL;
+
+  /* last close? */
+  swi_spidev->users--;
+  if (!swi_spidev->users) {
+    int    dofree;
+
+    kfree(swi_spidev->buffer);
+    swi_spidev->buffer = NULL;
+    kfree(swi_spidev->bufferrx);
+    swi_spidev->bufferrx = NULL;
+
+    /* ... after we unbound from the underlying device? */
+    spin_lock_irq(&swi_spidev->spi_lock);
+    dofree = (swi_spidev->spi == NULL);
+    spin_unlock_irq(&swi_spidev->spi_lock);
+
+    if (dofree)
+      kfree(swi_spidev);
+  }
+
+  return status;
+}
+
+static const struct file_operations swi_spidev_fops = {
+  .owner =  THIS_MODULE,
+  /* REVISIT switch to aio primitives, so that userspace
+   * gets more complete API coverage.  It'll simplify things
+   * too, except for the locking.
+   */
+  .write =  swi_spidev_write,
+  .read =    swi_spidev_read,
+  .unlocked_ioctl = swi_spidev_ioctl,
+  .compat_ioctl = swi_spidev_compat_ioctl,
+  .open =    swi_spidev_open,
+  .release =  swi_spidev_release,
+  .llseek =  no_llseek,
+};
+
+static struct miscdevice sierra_spi_misc = {
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = "sierra_spi",
+    .fops = &swi_spidev_fops,
+};
+
+static int __devinit swi_spidev_probe(struct spi_device *spi)
+{
+
+  /* Allocate driver data */
+  swi_spidev = kzalloc(sizeof(*swi_spidev), GFP_KERNEL);
+  if (!swi_spidev)
+    return -ENOMEM;
+
+  /* Initialize the driver data */
+  swi_spidev->spi = spi;
+  swi_spidev->swi_cfg_mask = SPI_MODE_3;
+  
+  spi_set_drvdata(spi, swi_spidev);
+  
+  spin_lock_init(&swi_spidev->spi_lock);
+  mutex_init(&swi_spidev->buf_lock);
+  
+  return 0;
+}
+
+static struct spi_driver swi_spidev_spi_driver = {
+  .driver = {
+    .name =    "sierra_spi_dev",
+    .owner =  THIS_MODULE,
+  },
+  .probe =  swi_spidev_probe,
+
+  /* NOTE:  suspend/resume methods are not necessary here.
+   * We don't do anything except pass the requests to/from
+   * the underlying controller.  The refrigerator handles
+   * most issues; the controller driver handles the rest.
+   */
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init swi_spidev_init(void)
+{
+  int status;
+  struct spi_master *master;
+  struct spi_board_info chip = {
+          .modalias  = "sierra_spi_dev",
+          .mode    = SPI_MODE_3,
+          .bus_num  = 0,
+          .chip_select  = 0,
+          .max_speed_hz  = 4800000,
+  };
+
+  status = spi_register_driver(&swi_spidev_spi_driver);
+  if (status < 0)
+    return status;
+
+
+  master = spi_busnum_to_master(0);
+  if (!master) {
+    status = -ENODEV;
+    goto error;
+  }
+  
+  dd = spi_master_get_devdata(master);
+  
+  if(dd == NULL)
+    pr_err("dd == NULL\n");
+  
+  /* We create a virtual device that will sit on the bus */
+  spi = spi_new_device(master, &chip);
+  if (!spi) {
+    status = -EBUSY;
+    goto error;
+  }
+  
+  return misc_register(&sierra_spi_misc);
+  
+error:
+  spi_unregister_driver(&swi_spidev_spi_driver);
+  return status;
+}
+late_initcall(swi_spidev_init);
+
+static void __exit swi_spidev_exit(void)
+{
+  if (spi) {
+    spi_unregister_device(spi);
+    spi = NULL;
+  }
+  spi_unregister_driver(&swi_spidev_spi_driver);
+  misc_deregister(&sierra_spi_misc);
+}
+module_exit(swi_spidev_exit);
+
+MODULE_AUTHOR("Alex Tan, <atan@sierrawireless.com>");
+MODULE_DESCRIPTION("User mode SPI device interface");
+MODULE_LICENSE("GPL v2");
+
diff --git a/include/linux/i2c/sierra_i2c.h b/include/linux/i2c/sierra_i2c.h
new file mode 100644
index 0000000..e93df7a
--- /dev/null
+++ b/include/linux/i2c/sierra_i2c.h
@@ -0,0 +1,28 @@
+/* arch/arm/mach-msm/sierra_i2c.h
+ *
+ * Copyright (C) 2013 Sierra Wireless, Inc
+ * Author: Alex Tan <atan@sierrawireless.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef SIERRA_I2C_H
+#define SIERRA_I2C_H
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+#define SWI_IOCTL_MAGIC_NUM 'I'
+#define SWI_IOCTL_I2C_ADDR_CONFIG _IOW(SWI_IOCTL_MAGIC_NUM,0x1,int)
+#define SWI_IOCTL_I2C_FREQ_CONFIG _IOW(SWI_IOCTL_MAGIC_NUM,0x2,int)
+
+extern int swi_set_i2c_freq(struct i2c_adapter *adap,int freq);
+#endif
+
diff --git a/include/linux/spi/sierra_spi.h b/include/linux/spi/sierra_spi.h
new file mode 100644
index 0000000..d352fc4
--- /dev/null
+++ b/include/linux/spi/sierra_spi.h
@@ -0,0 +1,209 @@
+/*
+ * include/linux/spi/sierra_spi.h 
+ *
+ * Copyright (C) 2013 Sierra Wireless, Inc
+ *	Author: Alex Tan <atan@sierrawireless.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+
+#ifndef SWI_SPIDEV_H
+#define SWI_SPIDEV_H
+
+#include <linux/types.h>
+
+#if defined(CONFIG_SPI_QSD) || defined(CONFIG_SPI_QSD_MODULE)
+
+#define QSD_REG(x) (x)
+#define QUP_REG(x)
+
+#define SPI_FIFO_WORD_CNT             0x0048
+
+#else
+
+#define QSD_REG(x)
+#define QUP_REG(x) (x)
+
+#define QUP_CONFIG                    0x0000 /* N & NO_INPUT/NO_OUPUT bits */
+#define QUP_ERROR_FLAGS_EN            0x030C
+#define QUP_ERR_MASK                  0x3
+#define SPI_OUTPUT_FIFO_WORD_CNT      0x010C
+#define SPI_INPUT_FIFO_WORD_CNT       0x0214
+#define QUP_MX_WRITE_COUNT            0x0150
+#define QUP_MX_WRITE_CNT_CURRENT      0x0154
+
+#define QUP_CONFIG_SPI_MODE           0x0100
+#endif
+
+#define GSBI_CTRL_REG                 0x0
+#define GSBI_SPI_CONFIG               0x30
+#define QUP_HARDWARE_VER              0x0030
+#define QUP_OPERATIONAL_MASK          0x0028
+#define QUP_ERROR_FLAGS               0x0308
+
+#define SPI_CONFIG                    QSD_REG(0x0000) QUP_REG(0x0300)
+#define SPI_IO_CONTROL                QSD_REG(0x0004) QUP_REG(0x0304)
+#define SPI_IO_MODES                  QSD_REG(0x0008) QUP_REG(0x0008)
+#define SPI_SW_RESET                  QSD_REG(0x000C) QUP_REG(0x000C)
+#define SPI_TIME_OUT_CURRENT          QSD_REG(0x0014) QUP_REG(0x0014)
+#define SPI_MX_OUTPUT_COUNT           QSD_REG(0x0018) QUP_REG(0x0100)
+#define SPI_MX_OUTPUT_CNT_CURRENT     QSD_REG(0x001C) QUP_REG(0x0104)
+#define SPI_MX_INPUT_COUNT            QSD_REG(0x0020) QUP_REG(0x0200)
+#define SPI_MX_INPUT_CNT_CURRENT      QSD_REG(0x0024) QUP_REG(0x0204)
+#define SPI_MX_READ_COUNT             QSD_REG(0x0028) QUP_REG(0x0208)
+#define SPI_MX_READ_CNT_CURRENT       QSD_REG(0x002C) QUP_REG(0x020C)
+#define SPI_OPERATIONAL               QSD_REG(0x0030) QUP_REG(0x0018)
+#define SPI_ERROR_FLAGS               QSD_REG(0x0034) QUP_REG(0x001C)
+#define SPI_ERROR_FLAGS_EN            QSD_REG(0x0038) QUP_REG(0x0020)
+#define SPI_DEASSERT_WAIT             QSD_REG(0x003C) QUP_REG(0x0310)
+#define SPI_OUTPUT_DEBUG              QSD_REG(0x0040) QUP_REG(0x0108)
+#define SPI_INPUT_DEBUG               QSD_REG(0x0044) QUP_REG(0x0210)
+#define SPI_TEST_CTRL                 QSD_REG(0x004C) QUP_REG(0x0024)
+#define SPI_OUTPUT_FIFO               QSD_REG(0x0100) QUP_REG(0x0110)
+#define SPI_INPUT_FIFO                QSD_REG(0x0200) QUP_REG(0x0218)
+#define SPI_STATE                     QSD_REG(SPI_OPERATIONAL) QUP_REG(0x0004)
+
+/* SPI_CONFIG fields */
+#define SPI_CFG_INPUT_FIRST           0x00000200
+#define SPI_NO_INPUT                  0x00000080
+#define SPI_NO_OUTPUT                 0x00000040
+#define SPI_CFG_LOOPBACK              0x00000100
+#define SPI_CFG_N                     0x0000001F
+
+/* SPI_IO_CONTROL fields */
+#define SPI_IO_C_FORCE_CS             0x00000800
+#define SPI_IO_C_CLK_IDLE_HIGH        0x00000400
+#define SPI_IO_C_CLK_ALWAYS_ON        0x00000200
+#define SPI_IO_C_MX_CS_MODE           0x00000100
+#define SPI_IO_C_CS_N_POLARITY        0x000000F0
+#define SPI_IO_C_CS_N_POLARITY_0      0x00000010
+#define SPI_IO_C_CS_SELECT            0x0000000C
+#define SPI_IO_C_TRISTATE_CS          0x00000002
+#define SPI_IO_C_NO_TRI_STATE         0x00000001
+
+
+/* User space versions of kernel symbols for SPI clocking modes,
+ * matching <linux/spi/spi.h>
+ */
+
+#define SPI_CPHA		0x01
+#define SPI_CPOL		0x02
+
+#define SPI_MODE_0		(0|0)
+#define SPI_MODE_1		(0|SPI_CPHA)
+#define SPI_MODE_2		(SPI_CPOL|0)
+#define SPI_MODE_3		(SPI_CPOL|SPI_CPHA)
+
+#define SPI_CS_HIGH		0x04
+#define SPI_LSB_FIRST		0x08
+#define SPI_3WIRE		0x10
+#define SPI_LOOP		0x20
+#define SPI_NO_CS		0x40
+#define SPI_READY		0x80
+
+#define SPI_CS_FORCE 0x100
+#define SPI_CLK_ALWAYS_ON 0x200
+/*---------------------------------------------------------------------------*/
+
+/* IOCTL commands */
+
+#define SPI_IOC_MAGIC			'l'
+
+/**
+ * struct spi_ioc_transfer - describes a single SPI transfer
+ * @tx_buf: Holds pointer to userspace buffer with transmit data, or null.
+ *	If no data is provided, zeroes are shifted out.
+ * @rx_buf: Holds pointer to userspace buffer for receive data, or null.
+ * @len: Length of tx and rx buffers, in bytes.
+ * @speed_hz: Temporary override of the device's bitrate.
+ * @bits_per_word: Temporary override of the device's wordsize.
+ * @delay_usecs: If nonzero, how long to delay after the last bit transfer
+ *	before optionally deselecting the device before the next transfer.
+ * @cs_change: True to deselect device before starting the next transfer.
+ *
+ * This structure is mapped directly to the kernel spi_transfer structure;
+ * the fields have the same meanings, except of course that the pointers
+ * are in a different address space (and may be of different sizes in some
+ * cases, such as 32-bit i386 userspace over a 64-bit x86_64 kernel).
+ * Zero-initialize the structure, including currently unused fields, to
+ * accommodate potential future updates.
+ *
+ * SPI_IOC_MESSAGE gives userspace the equivalent of kernel spi_sync().
+ * Pass it an array of related transfers, they'll execute together.
+ * Each transfer may be half duplex (either direction) or full duplex.
+ *
+ *	struct spi_ioc_transfer mesg[4];
+ *	...
+ *	status = ioctl(fd, SPI_IOC_MESSAGE(4), mesg);
+ *
+ * So for example one transfer might send a nine bit command (right aligned
+ * in a 16-bit word), the next could read a block of 8-bit data before
+ * terminating that command by temporarily deselecting the chip; the next
+ * could send a different nine bit command (re-selecting the chip), and the
+ * last transfer might write some register values.
+ */
+struct spi_ioc_transfer {
+	__u64		tx_buf;
+	__u64		rx_buf;
+
+	__u32		len;
+	__u32		speed_hz;
+
+	__u16		delay_usecs;
+	__u8		bits_per_word;
+	__u8		cs_change;
+	__u32		pad;
+
+	/* If the contents of 'struct spi_ioc_transfer' ever change
+	 * incompatibly, then the ioctl number (currently 0) must change;
+	 * ioctls with constant size fields get a bit more in the way of
+	 * error checking than ones (like this) where that field varies.
+	 *
+	 * NOTE: struct layout is the same in 64bit and 32bit userspace.
+	 */
+};
+
+/* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */
+#define SPI_MSGSIZE(N) \
+	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \
+		? ((N)*(sizeof (struct spi_ioc_transfer))) : 0)
+#define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])
+
+
+/* Read / Write of SPI mode (SPI_MODE_0..SPI_MODE_3) */
+#define SPI_IOC_RD_MODE			_IOR(SPI_IOC_MAGIC, 1, __u8)
+#define SPI_IOC_WR_MODE			_IOW(SPI_IOC_MAGIC, 1, __u8)
+
+/* Read / Write SPI bit justification */
+#define SPI_IOC_RD_LSB_FIRST		_IOR(SPI_IOC_MAGIC, 2, __u8)
+#define SPI_IOC_WR_LSB_FIRST		_IOW(SPI_IOC_MAGIC, 2, __u8)
+
+/* Read / Write SPI device word length (1..N) */
+#define SPI_IOC_RD_BITS_PER_WORD	_IOR(SPI_IOC_MAGIC, 3, __u8)
+#define SPI_IOC_WR_BITS_PER_WORD	_IOW(SPI_IOC_MAGIC, 3, __u8)
+
+/* Read / Write SPI device default max speed hz */
+#define SPI_IOC_RD_MAX_SPEED_HZ		_IOR(SPI_IOC_MAGIC, 4, __u32)
+#define SPI_IOC_WR_MAX_SPEED_HZ		_IOW(SPI_IOC_MAGIC, 4, __u32)
+
+/* Read / Write SPI device deassert time */
+#define SPI_IOC_RD_DEASSERT_TIME	_IOR(SPI_IOC_MAGIC, 5, __u8)
+#define SPI_IOC_WR_DEASSERT_TIME	_IOW(SPI_IOC_MAGIC, 5, __u8)
+
+extern void swi_reg_bit_set(struct spi_device *spi, int reg_addr, int bit_offset,int set_flag);
+extern int swi_read_deassert_time(struct spi_device *spi);
+extern void swi_write_deassert_time(struct spi_device *spi,__u8 value);
+
+#endif /* SPIDEV_H */
-- 
1.7.5.4

