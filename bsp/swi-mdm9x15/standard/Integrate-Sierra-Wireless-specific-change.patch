From e928b6a89101e7c698ac31aea5ee02a900609abb Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Fri, 30 Aug 2013 15:16:15 +0800
Subject: [PATCH 57/66] Integrate Sierra Wireless specific change

Extracted from Sierra Wireless code release
04.05.10A

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 arch/arm/kernel/unwind.c                          |   13 +
 arch/arm/mach-msm/Kconfig                         |   19 +
 arch/arm/mach-msm/Makefile                        |    4 +
 arch/arm/mach-msm/board-9615-gpiomux.c            |   31 +
 arch/arm/mach-msm/board-9615-regulator.c          |   36 +
 arch/arm/mach-msm/board-9615-storage.c            |   19 +
 arch/arm/mach-msm/board-9615.c                    |  313 ++++
 arch/arm/mach-msm/clock-9615.c                    |   37 +
 arch/arm/mach-msm/devices-9615.c                  |  142 ++
 arch/arm/mach-msm/devices.h                       |   13 +
 arch/arm/mach-msm/include/mach/sierra_bsidefs.h   |   39 +
 arch/arm/mach-msm/include/mach/sierra_smem.h      |  181 +++
 arch/arm/mach-msm/include/mach/usb_gadget_xport.h |   28 +-
 arch/arm/mach-msm/nand_partitions.c               |    6 +
 arch/arm/mach-msm/restart.c                       |   26 +
 arch/arm/mach-msm/sierra_bscommon.c               |  605 ++++++++
 arch/arm/mach-msm/sierra_smem.c                   |  146 ++
 arch/arm/mach-msm/sierra_smem_errdump.c           |  188 +++
 arch/arm/mach-msm/smd_nmea.c                      |   92 ++
 arch/arm/mach-msm/smd_tty.c                       |    4 +
 drivers/char/diag/diagfwd.c                       |    5 +
 drivers/hwmon/pm8xxx-adc-scale.c                  |  528 +++++---
 drivers/input/misc/pmic8xxx-pwrkey.c              |   24 +
 drivers/mfd/pm8018-core.c                         |   18 +
 drivers/mtd/devices/msm_nand.c                    |    7 +
 drivers/regulator/core.c                          |  156 ++-
 drivers/usb/gadget/Makefile                       |    3 +
 drivers/usb/gadget/android.c                      |  403 +++++-
 drivers/usb/gadget/ci13xxx_msm_hsic.c             |    2 +-
 drivers/usb/gadget/composite.c                    |  207 +++-
 drivers/usb/gadget/f_acm.c                        |    7 +
 drivers/usb/gadget/f_mass_storage.c               |  235 +++-
 drivers/usb/gadget/f_mbim.c                       |   68 +-
 drivers/usb/gadget/f_qc_ecm.c                     |    2 +-
 drivers/usb/gadget/f_qc_rndis.c                   |   39 +-
 drivers/usb/gadget/f_rmnet.c                      |  159 ++-
 drivers/usb/gadget/f_rndis.c                      |   14 +-
 drivers/usb/gadget/f_serial.c                     |  295 ++++-
 drivers/usb/gadget/f_uac1.c                       |   27 +
 drivers/usb/gadget/u_bam.c                        |   26 +-
 drivers/usb/gadget/u_ether.c                      |   26 +-
 drivers/usb/gadget/u_qc_ether.c                   |   10 +-
 drivers/usb/gadget/u_qc_ether.h                   |    2 +-
 drivers/usb/gadget/u_rmnet.h                      |    5 +
 drivers/usb/gadget/u_rmnet_ctrl_smd.c             |   31 +-
 drivers/usb/gadget/u_serial.c                     |   13 +
 drivers/usb/gadget/u_smd.c                        |   37 +
 drivers/usb/gadget/u_uac1.c                       |    9 +
 drivers/usb/gadget/usb_netlink_base.c             |  177 +++
 drivers/usb/gadget/usb_netlink_base.h             |   34 +
 drivers/usb/host/ehci-msm-hsic.c                  |   14 +
 drivers/usb/otg/msm_otg.c                         |  318 ++++
 drivers/usb/serial/GobiSerial.c                   |  859 +++++++++++
 drivers/usb/serial/Kconfig                        |    8 +
 drivers/usb/serial/Makefile                       |    3 +
 include/linux/sierra_bsudefs.h                    |  242 +++
 include/linux/sierra_bsuproto.h                   |   24 +
 include/linux/usb/composite.h                     |    6 +
 include/linux/usb/msm_hsusb.h                     |   15 +
 include/linux/usb/sierra_ududefs.h                |  159 ++
 kernel/panic.c                                    |   15 +
 sound/soc/codecs/wcd9304.c                        |   21 +-
 sound/soc/codecs/wcd9304.h                        |    6 +
 sound/soc/msm/Kconfig                             |    3 +
 sound/soc/msm/mdm9615.c                           | 1610 +++++++++++++++++++--
 65 files changed, 7473 insertions(+), 341 deletions(-)
 create mode 100644 arch/arm/mach-msm/include/mach/sierra_bsidefs.h
 create mode 100644 arch/arm/mach-msm/include/mach/sierra_smem.h
 create mode 100644 arch/arm/mach-msm/sierra_bscommon.c
 create mode 100644 arch/arm/mach-msm/sierra_smem.c
 create mode 100644 arch/arm/mach-msm/sierra_smem_errdump.c
 create mode 100644 drivers/usb/gadget/usb_netlink_base.c
 create mode 100644 drivers/usb/gadget/usb_netlink_base.h
 create mode 100644 drivers/usb/serial/GobiSerial.c
 create mode 100644 include/linux/sierra_bsudefs.h
 create mode 100644 include/linux/sierra_bsuproto.h
 create mode 100755 include/linux/usb/sierra_ududefs.h

diff --git a/arch/arm/kernel/unwind.c b/arch/arm/kernel/unwind.c
index 00df012..4e81494 100644
--- a/arch/arm/kernel/unwind.c
+++ b/arch/arm/kernel/unwind.c
@@ -49,6 +49,12 @@
 #include <asm/traps.h>
 #include <asm/unwind.h>
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#include <mach/sierra_smem.h>
+#endif /* SIERRA */
+/* SWISTOP */
+
 /* Dummy functions to avoid linker complaints */
 void __aeabi_unwind_cpp_pr0(void)
 {
@@ -439,6 +445,13 @@ void unwind_backtrace(struct pt_regs *regs, struct task_struct *tsk)
 		frame.pc = thread_saved_pc(tsk);
 	}
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* log error str */
+	sierra_smem_errdump_save_frame(tsk, &frame);
+#endif /* SIERRA */
+/* SWISTOP */
+
 	while (1) {
 		int urc;
 		unsigned long where = frame.pc;
diff --git a/arch/arm/mach-msm/Kconfig b/arch/arm/mach-msm/Kconfig
index 9fd519d..b2ee716 100644
--- a/arch/arm/mach-msm/Kconfig
+++ b/arch/arm/mach-msm/Kconfig
@@ -2456,6 +2456,25 @@ config MSM_CACHE_DUMP
 	  This allows for analysis of the caches in case cache corruption is
 	  suspected.
 
+# SWISTART
+config SIERRA
+	bool "Activates/Deactivates Sierra Wireless changes"
+	help
+	  All Sierra Wireless changes are controlled by this define
+	default n  
+
+config SIERRA_AR7
+	bool "MDM9615 SIERRA AR7 FEATURES"
+	help
+	  this config used for features only valid in AR7 products
+	default n
+
+config SIERRA_SMEM
+	depends on ARCH_MSM9615 && SIERRA
+	bool "MSM9615 SIERRA"
+	help
+	  Support for the Sierra Wireless MSM9615 based devices.
+#SWISTOP
 config MSM_CACHE_DUMP_ON_PANIC
 	bool "Dump caches on panic"
 	depends on MSM_CACHE_DUMP
diff --git a/arch/arm/mach-msm/Makefile b/arch/arm/mach-msm/Makefile
index c582ca8..78da19f 100644
--- a/arch/arm/mach-msm/Makefile
+++ b/arch/arm/mach-msm/Makefile
@@ -383,3 +383,7 @@ obj-$(CONFIG_MSM_VP_REGULATOR) += msm_vp.o
 ifdef CONFIG_MSM_CPR
 obj-$(CONFIG_DEBUG_FS) += msm_cpr-debug.o
 endif
+# SWISTART
+obj-$(CONFIG_SIERRA) += sierra_bscommon.o
+obj-$(CONFIG_SIERRA_SMEM) += sierra_smem.o sierra_smem_errdump.o
+#SWISTOP
diff --git a/arch/arm/mach-msm/board-9615-gpiomux.c b/arch/arm/mach-msm/board-9615-gpiomux.c
index 59e9fde..8943485 100644
--- a/arch/arm/mach-msm/board-9615-gpiomux.c
+++ b/arch/arm/mach-msm/board-9615-gpiomux.c
@@ -47,11 +47,21 @@ static struct gpiomux_setting gsbi3 = {
 	.pull = GPIOMUX_PULL_NONE,
 };
 
+#ifndef CONFIG_SIERRA_AR7
 static struct gpiomux_setting gsbi3_cs1_config = {
 	.func = GPIOMUX_FUNC_4,
 	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
+#endif /* !CONFIG_SIERRA_AR7 */
+#ifdef CONFIG_SIERRA_AR7
+static struct gpiomux_setting gsbi5_uart = {
+    .func = GPIOMUX_FUNC_1,
+    .drv = GPIOMUX_DRV_8MA,
+    .pull = GPIOMUX_PULL_NONE,
+};
+#endif /* CONFIG_SIERRA_AR7 */
+/* SWISTOP */
 
 #ifdef CONFIG_LTC4088_CHARGER
 static struct gpiomux_setting ltc4088_chg_cfg = {
@@ -61,6 +71,7 @@ static struct gpiomux_setting ltc4088_chg_cfg = {
 };
 #endif
 
+#ifndef CONFIG_SIERRA
 static struct gpiomux_setting sdcc2_clk_actv_cfg = {
 	.func = GPIOMUX_FUNC_1,
 	.drv = GPIOMUX_DRV_16MA,
@@ -78,6 +89,7 @@ static struct gpiomux_setting sdcc2_suspend_cfg = {
 	.drv = GPIOMUX_DRV_2MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
+#endif
 
 static struct gpiomux_setting cdc_mclk = {
 	.func = GPIOMUX_FUNC_1,
@@ -128,6 +140,7 @@ static struct msm_gpiomux_config msm9615_audio_codec_configs[] __initdata = {
 	},
 };
 
+#ifndef CONFIG_SIERRA
 static struct msm_gpiomux_config msm9615_sdcc2_configs[] __initdata = {
 	{
 		/* SDC2_DATA_0 */
@@ -178,6 +191,7 @@ static struct msm_gpiomux_config msm9615_sdcc2_configs[] __initdata = {
 		},
 	},
 };
+#endif
 
 struct msm_gpiomux_config msm9615_ps_hold_config[] __initdata = {
 	{
@@ -291,6 +305,20 @@ struct msm_gpiomux_config msm9615_gsbi_configs[] __initdata = {
 			[GPIOMUX_SUSPENDED] = &gsbi5,
 		},
 	},
+#ifdef CONFIG_SIERRA_AR7
+    {
+        .gpio      = 18,    /* GSBI5 UART */
+        .settings = {
+            [GPIOMUX_SUSPENDED] = &gsbi5_uart,
+        },
+    },
+    {
+        .gpio      = 19,    /* GSBI5 UART */
+        .settings = {
+            [GPIOMUX_SUSPENDED] = &gsbi5_uart,
+        },
+    },
+#else /* CONFIG_SIERRA_AR7 */
 	{
 		/* GPIO 19 can be used for I2C/UART on GSBI5 */
 		.gpio      = 19,	/* GSBI3 QUP SPI_CS_1 */
@@ -298,6 +326,7 @@ struct msm_gpiomux_config msm9615_gsbi_configs[] __initdata = {
 			[GPIOMUX_SUSPENDED] = &gsbi3_cs1_config,
 		},
 	},
+#endif /* CONFIG_SIERRA_AR7 */
 };
 
 static struct msm_gpiomux_config msm9615_slimbus_configs[] __initdata = {
@@ -368,8 +397,10 @@ int __init msm9615_init_gpiomux(void)
 			ARRAY_SIZE(msm9615_ps_hold_config));
 	msm_gpiomux_install(sd_card_det_config,
 			ARRAY_SIZE(sd_card_det_config));
+#ifndef CONFIG_SIERRA
 	msm_gpiomux_install(msm9615_sdcc2_configs,
 			ARRAY_SIZE(msm9615_sdcc2_configs));
+#endif
 #ifdef CONFIG_LTC4088_CHARGER
 	msm_gpiomux_install(msm9615_ltc4088_charger_config,
 			ARRAY_SIZE(msm9615_ltc4088_charger_config));
diff --git a/arch/arm/mach-msm/board-9615-regulator.c b/arch/arm/mach-msm/board-9615-regulator.c
index 0a900e1..2e6677d 100644
--- a/arch/arm/mach-msm/board-9615-regulator.c
+++ b/arch/arm/mach-msm/board-9615-regulator.c
@@ -80,6 +80,16 @@ VREG_CONSUMERS(S2) = {
 	REGULATOR_SUPPLY("CDC_VDDA_A_1P2V",     "0-000d"),
 	REGULATOR_SUPPLY("VDDD_CDC_D",		"tabla top level"),
 	REGULATOR_SUPPLY("CDC_VDDA_A_1P2V",	"tabla top level"),
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#ifdef CONFIG_WCD9304_CODEC
+	REGULATOR_SUPPLY("VDDD_CDC_D",		"sitar-slim"),
+	REGULATOR_SUPPLY("VDDD_CDC_D",		"sitar1p1-slim"),
+	REGULATOR_SUPPLY("CDC_VDDA_A_1P2V",	"sitar-slim"),
+	REGULATOR_SUPPLY("CDC_VDDA_A_1P2V",	"sitar1p1-slim"),
+#endif
+#endif
+/* SWISTOP */
 };
 VREG_CONSUMERS(S3) = {
 	REGULATOR_SUPPLY("8018_s3",		NULL),
@@ -100,6 +110,20 @@ VREG_CONSUMERS(S3) = {
 	REGULATOR_SUPPLY("CDC_VDD_CP",		"0-000d"),
 	REGULATOR_SUPPLY("CDC_VDDA_TX",		"0-000d"),
 	REGULATOR_SUPPLY("CDC_VDDA_RX",		"0-000d"),
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#ifdef CONFIG_WCD9304_CODEC
+	REGULATOR_SUPPLY("CDC_VDD_CP",		"sitar-slim"),
+	REGULATOR_SUPPLY("CDC_VDD_CP",		"sitar1p1-slim"),
+	REGULATOR_SUPPLY("CDC_VDDA_RX",		"sitar-slim"),
+	REGULATOR_SUPPLY("CDC_VDDA_RX",		"sitar1p1-slim"),
+	REGULATOR_SUPPLY("CDC_VDDA_TX",		"sitar-slim"),
+	REGULATOR_SUPPLY("CDC_VDDA_TX",		"sitar1p1-slim"),
+	REGULATOR_SUPPLY("VDDIO_CDC",		"sitar-slim"),
+	REGULATOR_SUPPLY("VDDIO_CDC",		"sitar1p1-slim"),
+#endif
+#endif
+/* SWISTOP */
 };
 VREG_CONSUMERS(S4) = {
 	REGULATOR_SUPPLY("8018_s4",		NULL),
@@ -329,8 +353,20 @@ msm_rpm_regulator_init_data[] __devinitdata = {
 	/*	 ID    a_on pd ss min_uV   max_uV  supply  sys_uA init_ip */
 	RPM_LDO(L2,      1, 1, 0, 1800000, 1800000, NULL,      0, 10000),
 	RPM_LDO(L3,      1, 1, 0, 1800000, 1800000, NULL,      0, 0),
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+	/* Increase the VREG_L4 from 3.075V to 3.3V */
+    RPM_LDO(L4,      0, 1, 0, 3300000, 3300000, NULL,      0, 0),
+#else
 	RPM_LDO(L4,      0, 1, 0, 3075000, 3075000, NULL,      0, 0),
+#endif
+#if defined(CONFIG_SIERRA)
+/* set ss so can turn on it later - on HotSpot it powers LCD controller */
+	RPM_LDO(L5,      0, 1, 1, 2850000, 2850000, NULL,      0, 0),
+#else
 	RPM_LDO(L5,      0, 1, 0, 2850000, 2850000, NULL,      0, 0),
+#endif
+/* SWISTOP */
 	RPM_LDO(L6,      0, 1, 0, 1800000, 2850000, NULL,      0, 0),
 	RPM_LDO(L7,      0, 1, 0, 1850000, 1900000, "8018_s4", 0, 0),
 	RPM_LDO(L8,      0, 1, 0, 1200000, 1200000, "8018_s3", 0, 0),
diff --git a/arch/arm/mach-msm/board-9615-storage.c b/arch/arm/mach-msm/board-9615-storage.c
index 1bab3d1..244e665 100644
--- a/arch/arm/mach-msm/board-9615-storage.c
+++ b/arch/arm/mach-msm/board-9615-storage.c
@@ -183,6 +183,11 @@ static struct mmc_platform_data sdc1_data = {
 	.status_gpio	= GPIO_SDC1_HW_DET,
 	.status_irq	= MSM_GPIO_TO_INT(GPIO_SDC1_HW_DET),
 	.irq_flags	= IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	.is_status_gpio_active_low = true,
+#endif /*CONFIG_SIERRA*/
+/* SWISTOP */
 #endif
 	.xpc_cap	= 1,
 	.uhs_caps	= (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
@@ -196,6 +201,9 @@ static struct mmc_platform_data *msm9615_sdc1_pdata;
 #endif
 
 #ifdef CONFIG_MMC_MSM_SDC2_SUPPORT
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+/* SWISTOP */
 static unsigned int sdc2_sup_clk_rates[] = {
 	400000, 24000000, 48000000
 };
@@ -211,8 +219,17 @@ static struct mmc_platform_data sdc2_data = {
 	.msm_bus_voting_data = &sps_to_ddr_bus_voting_data,
 };
 static struct mmc_platform_data *msm9615_sdc2_pdata = &sdc2_data;
+/* SWISTART */
+#endif
+/* SWISTOP */
 #else
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+/* SWISTOP */
 static struct mmc_platform_data *msm9615_sdc2_pdata;
+/* SWISTART */
+#endif
+/* SWISTOP */
 #endif
 
 void __init msm9615_init_mmc(void)
@@ -221,9 +238,11 @@ void __init msm9615_init_mmc(void)
 		/* SDC1: External card slot for SD/MMC cards */
 		msm_add_sdcc(1, msm9615_sdc1_pdata);
 
+#ifndef CONFIG_SIERRA
 	if (msm9615_sdc2_pdata)
 		/* SDC2: External card slot used for WLAN */
 		msm_add_sdcc(2, msm9615_sdc2_pdata);
+#endif
 }
 #else
 void __init msm9615_init_mmc(void)
diff --git a/arch/arm/mach-msm/board-9615.c b/arch/arm/mach-msm/board-9615.c
index 09ce123..28da033 100644
--- a/arch/arm/mach-msm/board-9615.c
+++ b/arch/arm/mach-msm/board-9615.c
@@ -19,6 +19,12 @@
 #include <linux/mfd/wcd9xxx/core.h>
 #include <linux/mfd/wcd9xxx/pdata.h>
 #endif
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(CONFIG_WCD9304_CODEC)
+#include <linux/mfd/wcd9xxx/core.h>
+#include <linux/mfd/wcd9xxx/pdata.h>
+#endif
+/* SWISTOP */
 #include <linux/msm_ssbi.h>
 #include <linux/memblock.h>
 #include <linux/usb/android.h>
@@ -56,6 +62,12 @@
 #include <linux/usb/gadget.h>
 #include "ci13xxx_udc.h"
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#include <mach/rpm-regulator.h>
+#endif
+/* SWISTOP */
+
 #ifdef CONFIG_ION_MSM
 #define MSM_ION_AUDIO_SIZE	0xAF000
 #define MSM_ION_HEAP_NUM	3
@@ -196,10 +208,36 @@ struct pm8xxx_mpp_init {
 			PM_GPIO_FUNC_NORMAL, 0, 0)
 
 /* Initial PM8018 GPIO configurations */
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 static struct pm8xxx_gpio_init pm8018_gpios[] __initdata = {
 	PM8018_GPIO_OUTPUT(2,	0,	HIGH), /* EXT_LDO_EN_WLAN */
 	PM8018_GPIO_OUTPUT(6,	0,	LOW), /* WLAN_CLK_PWR_REQ */
 };
+#else
+static struct pm8xxx_gpio_init pm8018_gpios[] __initdata = {
+	PM8018_GPIO_INPUT(2,PM_GPIO_PULL_NO), /* EXT_LDO_EN_WLAN */
+	PM8018_GPIO_INPUT(6,PM_GPIO_PULL_NO), /* WLAN_CLK_PWR_REQ */
+};
+#endif
+/* SWISTOP */
+
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+static struct pm8xxx_mpp_init pm8018_mpp_swi =
+	PM8018_MPP_INIT(1, D_INPUT, PM8018_MPP_DIG_LEVEL_L4, DOUT_CTRL_LOW);
+	
+void msm9615_pm8xxx_gpio_mpp_init_swi(void)
+{
+	int rc;
+	rc = pm8xxx_mpp_config(pm8018_mpp_swi.mpp, &pm8018_mpp_swi.config);
+	if (rc) {
+	pr_err("%s: pm8018_mpp_config_swi: rc=%d\n", __func__, rc);
+	}
+} 
+#endif
+/* SWISTOP */
 
 /* Initial PM8018 MPP configurations */
 static struct pm8xxx_mpp_init pm8018_mpps[] __initdata = {
@@ -245,6 +283,10 @@ static struct pm8xxx_adc_amux pm8018_adc_channels_data[] = {
 	 */
 	{"batt_id", CHANNEL_BATT_ID_THERM, CHAN_PATH_SCALING1,
 		AMUX_RSV2, ADC_DECIMATION_TYPE2, ADC_SCALE_DEFAULT},
+/* SWISTART */
+	{"mpp_05", ADC_MPP_1_AMUX4, CHAN_PATH_SCALING1,
+		AMUX_RSV2, ADC_DECIMATION_TYPE2, ADC_SCALE_BATT_THERM},
+/* SWISTOP */
 	{"pmic_therm", CHANNEL_DIE_TEMP, CHAN_PATH_SCALING1, AMUX_RSV1,
 		ADC_DECIMATION_TYPE2, ADC_SCALE_PMIC_THERM},
 	{"625mv", CHANNEL_625MV, CHAN_PATH_SCALING1, AMUX_RSV1,
@@ -283,17 +325,37 @@ static struct pm8xxx_mpp_platform_data pm8xxx_mpp_pdata __devinitdata = {
 	.mpp_base		= PM8018_MPP_PM_TO_SYS(1),
 };
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA_AR7
+static struct pm8xxx_rtc_platform_data pm8xxx_rtc_pdata __devinitdata = {
+	.rtc_write_enable	= false,
+	.rtc_alarm_powerup	= true,
+};
+#else
 static struct pm8xxx_rtc_platform_data pm8xxx_rtc_pdata __devinitdata = {
 	.rtc_write_enable	= false,
 	.rtc_alarm_powerup	= false,
 };
+#endif
+/* SWISTOP */
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static struct pm8xxx_pwrkey_platform_data pm8xxx_pwrkey_pdata = {
+	.pull_up		= 1,
+	.kpd_trigger_delay_us	= 31250,   /* 1/32 Second */
+	.wakeup			= 1,
+};
+
+#else
 static struct pm8xxx_pwrkey_platform_data pm8xxx_pwrkey_pdata = {
 	.pull_up		= 1,
 	.kpd_trigger_delay_us	= 15625,
 	.wakeup			= 1,
 };
 
+#endif
+/* SWISTOP */
 static struct pm8xxx_misc_platform_data pm8xxx_misc_pdata = {
 	.priority		= 0,
 };
@@ -307,6 +369,7 @@ static struct pm8xxx_misc_platform_data pm8xxx_misc_pdata = {
  */
 #define PM8XXX_PWM_CHANNEL_NONE		-1
 
+#ifndef CONFIG_SIERRA
 static struct led_info pm8018_led_info[] = {
 	[0] = {
 		.name	= "led:kb",
@@ -333,6 +396,7 @@ static struct pm8xxx_led_platform_data pm8xxx_leds_pdata = {
 		.configs = pm8018_led_configs,
 		.num_configs = ARRAY_SIZE(pm8018_led_configs),
 };
+#endif
 
 #ifdef CONFIG_LTC4088_CHARGER
 static struct ltc4088_charger_platform_data ltc4088_chg_pdata = {
@@ -342,6 +406,7 @@ static struct ltc4088_charger_platform_data ltc4088_chg_pdata = {
 };
 #endif
 
+#ifndef CONFIG_SIERRA
 static struct pm8018_platform_data pm8018_platform_data __devinitdata = {
 	.irq_pdata		= &pm8xxx_irq_pdata,
 	.gpio_pdata		= &pm8xxx_gpio_pdata,
@@ -353,6 +418,18 @@ static struct pm8018_platform_data pm8018_platform_data __devinitdata = {
 	.adc_pdata		= &pm8018_adc_pdata,
 	.leds_pdata		= &pm8xxx_leds_pdata,
 };
+#else
+static struct pm8018_platform_data pm8018_platform_data __devinitdata = {
+	.irq_pdata		= &pm8xxx_irq_pdata,
+	.gpio_pdata		= &pm8xxx_gpio_pdata,
+	.mpp_pdata		= &pm8xxx_mpp_pdata,
+	.rtc_pdata		= &pm8xxx_rtc_pdata,
+	.pwrkey_pdata		= &pm8xxx_pwrkey_pdata,
+	.misc_pdata		= &pm8xxx_misc_pdata,
+	.regulator_pdatas	= msm_pm8018_regulator_pdata,
+	.adc_pdata		= &pm8018_adc_pdata,
+};
+#endif
 
 static struct msm_ssbi_platform_data msm9615_ssbi_pm8018_pdata __devinitdata = {
 	.controller_type = MSM_SBI_CTRL_PMIC_ARBITER,
@@ -403,7 +480,11 @@ static void __init msm9615_init_buses(void)
  * MDM9x15 I2S.
  */
 static struct wcd9xxx_pdata wcd9xxx_i2c_platform_data = {
+/* SWISTART */
+#ifndef CONFIG_SIERRA_AR7
 	.irq = MSM_GPIO_TO_INT(85),
+#endif
+/* SWISTOP */
 	.irq_base = TABLA_INTERRUPT_BASE,
 	.num_irqs = NR_TABLA_IRQS,
 	.reset_gpio = 84,
@@ -558,6 +639,156 @@ static struct slim_device msm_slim_tabla20 = {
 };
 #endif
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#ifdef CONFIG_WCD9304_CODEC
+
+#define SITAR_INTERRUPT_BASE (NR_MSM_IRQS + NR_GPIO_IRQS + 256/*NR_PM8921_IRQS*/)
+
+/* Micbias setting is based on 8660 CDP/MTP/FLUID requirement
+ * 4 micbiases are used to power various analog and digital
+ * microphones operating at 1800 mV. Technically, all micbiases
+ * can source from single cfilter since all microphones operate
+ * at the same voltage level. The arrangement below is to make
+ * sure all cfilters are exercised. LDO_H regulator ouput level
+ * does not need to be as high as 2.85V. It is choosen for
+ * microphone sensitivity purpose.
+ */
+static struct wcd9xxx_pdata sitar_platform_data = {
+		.slimbus_slave_device = {
+		.name = "sitar-slave",
+		.e_addr = {0, 0, 0x00, 0, 0x17, 2},
+	},
+	.irq = MSM_GPIO_TO_INT(86),
+	.irq_base = SITAR_INTERRUPT_BASE,
+	.num_irqs = NR_WCD9XXX_IRQS,
+	.reset_gpio = 84,
+	.micbias = {
+		.ldoh_v = SITAR_LDOH_2P85_V,
+		.cfilt1_mv = 1800,
+		.cfilt2_mv = 1800,
+		.bias1_cfilt_sel = SITAR_CFILT1_SEL,
+		.bias2_cfilt_sel = SITAR_CFILT2_SEL,
+		.bias1_cap_mode = MICBIAS_EXT_BYP_CAP,
+		.bias2_cap_mode = MICBIAS_EXT_BYP_CAP,
+	},
+	.regulator = {
+	{
+		.name = "CDC_VDD_CP",
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.optimum_uA = WCD9XXX_CDC_VDDA_CP_CUR_MAX,
+	},
+	{
+		.name = "CDC_VDDA_RX",
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.optimum_uA = WCD9XXX_CDC_VDDA_RX_CUR_MAX,
+	},
+	{
+		.name = "CDC_VDDA_TX",
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.optimum_uA = WCD9XXX_CDC_VDDA_TX_CUR_MAX,
+	},
+	{
+		.name = "VDDIO_CDC",
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.optimum_uA = WCD9XXX_VDDIO_CDC_CUR_MAX,
+	},
+	{
+		.name = "VDDD_CDC_D",
+		.min_uV = 1225000,
+		.max_uV = 1225000,
+		.optimum_uA = WCD9XXX_VDDD_CDC_D_CUR_MAX,
+	},
+	{
+		.name = "CDC_VDDA_A_1P2V",
+		.min_uV = 1225000,
+		.max_uV = 1225000,
+		.optimum_uA = WCD9XXX_VDDD_CDC_A_CUR_MAX,
+	},
+	},
+};
+
+static struct slim_device msm_slim_sitar = {
+	.name = "sitar-slim",
+	.e_addr = {0, 1, 0x00, 0, 0x17, 2},
+	.dev = {
+	.platform_data = &sitar_platform_data,
+	},
+};
+
+static struct wcd9xxx_pdata sitar1p1_platform_data = {
+		.slimbus_slave_device = {
+		.name = "sitar-slave",
+		.e_addr = {0, 0, 0x70, 0, 0x17, 2},
+	},
+	.irq = MSM_GPIO_TO_INT(86),
+	.irq_base = SITAR_INTERRUPT_BASE,
+	.num_irqs = NR_WCD9XXX_IRQS,
+	.reset_gpio = 84,
+	.micbias = {
+		.ldoh_v = SITAR_LDOH_2P85_V,
+		.cfilt1_mv = 1800,
+		.cfilt2_mv = 1800,
+		.bias1_cfilt_sel = SITAR_CFILT1_SEL,
+		.bias2_cfilt_sel = SITAR_CFILT2_SEL,
+		.bias1_cap_mode = MICBIAS_EXT_BYP_CAP,
+		.bias2_cap_mode = MICBIAS_EXT_BYP_CAP,
+	},
+	.regulator = {
+	{
+		.name = "CDC_VDD_CP",
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.optimum_uA = WCD9XXX_CDC_VDDA_CP_CUR_MAX,
+	},
+	{
+		.name = "CDC_VDDA_RX",
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.optimum_uA = WCD9XXX_CDC_VDDA_RX_CUR_MAX,
+	},
+	{
+		.name = "CDC_VDDA_TX",
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.optimum_uA = WCD9XXX_CDC_VDDA_TX_CUR_MAX,
+	},
+	{
+		.name = "VDDIO_CDC",
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.optimum_uA = WCD9XXX_VDDIO_CDC_CUR_MAX,
+	},
+	{
+		.name = "VDDD_CDC_D",
+		.min_uV = 1225000,
+		.max_uV = 1225000,
+		.optimum_uA = WCD9XXX_VDDD_CDC_D_CUR_MAX,
+	},
+	{
+		.name = "CDC_VDDA_A_1P2V",
+		.min_uV = 1225000,
+		.max_uV = 1225000,
+		.optimum_uA = WCD9XXX_VDDD_CDC_A_CUR_MAX,
+	},
+	},
+};
+
+static struct slim_device msm_slim_sitar1p1 = {
+	.name = "sitar1p1-slim",
+	.e_addr = {0, 1, 0x70, 0, 0x17, 2},
+	.dev = {
+	.platform_data = &sitar1p1_platform_data,
+	},
+};
+#endif
+#endif
+/* SWISTOP */
+
 static struct i2c_registry msm9615_i2c_devices[] __initdata = {
 #ifdef CONFIG_WCD9310_CODEC
 	{
@@ -577,6 +808,20 @@ static struct slim_boardinfo msm_slim_devices[] = {
 		.slim_slave = &msm_slim_tabla20,
 	},
 #endif
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#ifdef CONFIG_WCD9304_CODEC
+	{
+		.bus_num = 1,
+		.slim_slave = &msm_slim_sitar,
+	},
+	{
+		.bus_num = 1,
+		.slim_slave = &msm_slim_sitar1p1,
+	},
+#endif
+#endif
+/* SWISTOP */
 };
 
 static struct msm_spi_platform_data msm9615_qup_spi_gsbi3_pdata = {
@@ -588,7 +833,13 @@ static struct msm_i2c_platform_data msm9615_i2c_qup_gsbi5_pdata = {
 	.src_clk_rate = 24000000,
 };
 
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 #define USB_5V_EN		3
+#else
+#define USB_5V_EN   4
+#endif
+/* SWISTOP */
 #define PM_USB_5V_EN	PM8018_GPIO_PM_TO_SYS(USB_5V_EN)
 
 static int msm_hsusb_vbus_power(bool on)
@@ -757,6 +1008,13 @@ static struct msm_usb_bam_platform_data msm_usb_bam_pdata = {
 	.usb_bam_num_pipes = 16,
 };
 
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+#define MSM_MPM_PIN_USB1_OTGSESSVLD    40
+#endif
+/* SWISTOP */
+
 static struct msm_otg_platform_data msm_otg_pdata = {
 	.mode			= USB_OTG,
 	.otg_control	= OTG_PHY_CONTROL,
@@ -766,6 +1024,13 @@ static struct msm_otg_platform_data msm_otg_pdata = {
 	.enable_lpm_on_dev_suspend	= true,
 	.core_clk_always_on_workaround = true,
 	.delay_lpm_on_disconnect = true,
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+    .vdd_min_enable     = PM8018_MPP_PM_TO_SYS(1),
+    .mpm_otgsessvld_int = MSM_MPM_PIN_USB1_OTGSESSVLD, 
+#endif
+/* SWISTOP */
 };
 
 
@@ -884,6 +1149,10 @@ static struct platform_device *common_devices[] = {
 	&msm_android_usb_hsic_device,
 #endif
 	&msm9615_device_uart_gsbi4,
+#ifdef CONFIG_SIERRA_AR7
+    &msm9615_device_uart_gsbi5,
+#endif /* CONFIG_SIERRA_AR7 */
+/* SWISTOP */
 	&msm9615_device_ext_2p95v_vreg,
 	&msm9615_device_ssbi_pmic1,
 	&msm9615_device_qup_i2c_gsbi5,
@@ -981,6 +1250,42 @@ static void __init msm9615_reserve(void)
 	msm_reserve();
 #endif
 }
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+/* 
+ * We need to have LDO5 turned on to keep LCD on MHS powered. Other
+ * products want to keep it off - we provide a param to turn it off
+ * at runtime (or keep it off from command line).
+ * (There  should be a better way!)
+ */
+typedef bool ldo5_t;
+static ldo5_t ldo5 = 1;
+#define param_check_ldo5_t(name, p) __param_check(name, p, ldo5_t);
+
+int param_set_ldo5(const char *val, const struct kernel_param *kp)
+{
+	int voltage = 0;
+	int rv = param_set_bool( val, kp );
+	if( !rv )
+	{
+		printk( KERN_INFO "Setting LDO5 to %d\n", ldo5 );
+
+		if( ldo5 )
+			voltage = 2850000;
+
+		rpm_vreg_set_voltage(RPM_VREG_ID_PM8018_L5, RPM_VREG_VOTER3,
+							 voltage, voltage, 1);
+	}
+	return rv;
+}
+static const struct kernel_param_ops param_ops_ldo5_t = {
+	.set = param_set_ldo5,
+	.get = param_get_bool,
+	.free = NULL,
+};
+core_param(ldo5, ldo5, ldo5_t, 0644);
+#endif
+/* SWISTOP */
 
 static void __init msm9615_common_init(void)
 {
@@ -994,6 +1299,14 @@ static void __init msm9615_common_init(void)
 	msm9615_i2c_init();
 	regulator_suppress_info_printing();
 	platform_device_register(&msm9615_device_rpm_regulator);
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if( ldo5 )
+			/* LDO5 always on - on HotSpot it powers LCD controller */
+			rpm_vreg_set_voltage(RPM_VREG_ID_PM8018_L5, RPM_VREG_VOTER3,
+							2850000, 2850000, 1);  
+#endif
+/* SWISTOP */
 	msm_xo_init();
 	msm_clock_init(&msm9615_clock_init_data);
 	msm9615_init_buses();
diff --git a/arch/arm/mach-msm/clock-9615.c b/arch/arm/mach-msm/clock-9615.c
index e0999d9..afb14aa 100644
--- a/arch/arm/mach-msm/clock-9615.c
+++ b/arch/arm/mach-msm/clock-9615.c
@@ -695,7 +695,14 @@ static struct rcg_clk usb_hs1_xcvr_clk = {
 	.c = {
 		.dbg_name = "usb_hs1_xcvr_clk",
 		.ops = &clk_ops_rcg,
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+		VDD_DIG_FMAX_MAP1(NONE, 60000000),
+#else
 		VDD_DIG_FMAX_MAP1(NOMINAL, 60000000),
+#endif
+/* SWISTOP */
 		CLK_INIT(usb_hs1_xcvr_clk.c),
 	},
 };
@@ -720,7 +727,14 @@ static struct rcg_clk usb_hs1_sys_clk = {
 	.c = {
 		.dbg_name = "usb_hs1_sys_clk",
 		.ops = &clk_ops_rcg,
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+		VDD_DIG_FMAX_MAP1(NONE, 60000000),
+#else
 		VDD_DIG_FMAX_MAP1(NOMINAL, 60000000),
+#endif
+/* SWISTOP */
 		CLK_INIT(usb_hs1_sys_clk.c),
 	},
 };
@@ -1207,6 +1221,13 @@ static CLK_AIF_BIT_DIV(spare_i2s_spkr_bit, LCC_SPARE_I2S_SPKR_NS_REG,
 	}
 static struct clk_freq_tbl clk_tbl_pcm[] = {
 	{ .ns_val = BIT(10) /* external input */ },
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	F_PCM(   64000, pll4, 4, 1, 1536),
+	F_PCM(  128000, pll4, 4, 1,  768),
+	F_PCM(  256000, pll4, 4, 1,  384),
+#endif
+/* SWISTOP */
 	F_PCM(  512000, pll4, 4, 1, 192),
 	F_PCM(  768000, pll4, 4, 1, 128),
 	F_PCM( 1024000, pll4, 4, 1,  96),
@@ -1612,10 +1633,18 @@ static struct clk_lookup msm_clocks_9615[] = {
 
 	CLK_LOOKUP("core_clk", gsbi3_uart_clk.c, ""),
 	CLK_LOOKUP("core_clk", gsbi4_uart_clk.c, "msm_serial_hsl.0"),
+#ifdef CONFIG_SIERRA_AR7
+    CLK_LOOKUP("core_clk", gsbi5_uart_clk.c, "msm_serial_hsl.1"),
+#endif /* CONFIG_SIERRA_AR7 */
+/* SWISTOP */
 	CLK_LOOKUP("core_clk", gsbi5_uart_clk.c, ""),
 
 	CLK_LOOKUP("core_clk",	gsbi3_qup_clk.c, "spi_qsd.0"),
 	CLK_LOOKUP("core_clk",	gsbi4_qup_clk.c, ""),
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+  CLK_LOOKUP("core_clk",  gsbi4_qup_clk.c, "spi_qsd.4"),
+#endif
 	CLK_LOOKUP("core_clk",	gsbi5_qup_clk.c, "qup_i2c.0"),
 
 	CLK_LOOKUP("core_clk",		pdm_clk.c,		""),
@@ -1627,6 +1656,14 @@ static struct clk_lookup msm_clocks_9615[] = {
 
 	CLK_LOOKUP("iface_clk",	gsbi3_p_clk.c, "spi_qsd.0"),
 	CLK_LOOKUP("iface_clk",	gsbi4_p_clk.c, "msm_serial_hsl.0"),
+/* SWISTART */
+
+#ifdef CONFIG_SIERRA_AR7
+    CLK_LOOKUP("iface_clk", gsbi5_p_clk.c, "msm_serial_hsl.1"),
+#endif /* CONFIG_SIERRA_AR7 */
+#ifdef CONFIG_SIERRA
+	CLK_LOOKUP("iface_clk",	gsbi4_p_clk.c, "spi_qsd.4"),
+#endif
 	CLK_LOOKUP("iface_clk",	gsbi5_p_clk.c, "qup_i2c.0"),
 
 	CLK_LOOKUP("iface_clk",	     usb_hs1_p_clk.c,		"msm_otg"),
diff --git a/arch/arm/mach-msm/devices-9615.c b/arch/arm/mach-msm/devices-9615.c
index 6b558d7..470bac5 100644
--- a/arch/arm/mach-msm/devices-9615.c
+++ b/arch/arm/mach-msm/devices-9615.c
@@ -49,6 +49,11 @@
 #define MSM_GSBI4_PHYS		0x16300000
 #define MSM_GSBI5_PHYS          0x16400000
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA_AR7
+#define MSM_UART5DM_PHYS  (MSM_GSBI5_PHYS + 0x40000)
+#endif /* CONFIG_SIERRA_AR7 */
+/* SWISTOP */
 #define MSM_UART4DM_PHYS	(MSM_GSBI4_PHYS + 0x40000)
 
 /* GSBI QUP devices */
@@ -136,7 +141,13 @@ struct platform_device msm_device_otg = {
 	},
 };
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+#define MSM_HSUSB_RESUME_GPIO	82
+#else
 #define MSM_HSUSB_RESUME_GPIO	79
+#endif
+/* SWISTOP */
 
 static struct resource resources_hsusb[] = {
 	{
@@ -273,6 +284,36 @@ struct platform_device msm_device_hsic_host = {
 	},
 };
 
+#ifdef CONFIG_SIERRA_AR7
+static struct resource resources_uart_gsbi5[] = {
+  {
+    .start  = GSBI5_UARTDM_IRQ,
+    .end  = GSBI5_UARTDM_IRQ,
+    .flags  = IORESOURCE_IRQ,
+  },
+  {
+    .start  = MSM_UART5DM_PHYS,
+    .end  = MSM_UART5DM_PHYS + PAGE_SIZE - 1,
+    .name = "uartdm_resource",
+    .flags  = IORESOURCE_MEM,
+  },
+  {
+    .start  = MSM_GSBI5_PHYS,
+    .end  = MSM_GSBI5_PHYS + PAGE_SIZE - 1,
+    .name = "gsbi_resource",
+    .flags  = IORESOURCE_MEM,
+  },
+};
+
+struct platform_device msm9615_device_uart_gsbi5 = {
+  .name = "msm_serial_hsl",
+  .id = 1,
+  .num_resources  = ARRAY_SIZE(resources_uart_gsbi5),
+  .resource = resources_uart_gsbi5,
+};
+#endif /* CONFIG_SIERRA_AR7 */
+/* SWISTOP */
+
 static struct resource resources_uart_gsbi4[] = {
 	{
 		.start	= GSBI4_UARTDM_IRQ,
@@ -300,6 +341,51 @@ struct platform_device msm9615_device_uart_gsbi4 = {
 	.resource	= resources_uart_gsbi4,
 };
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static struct resource resources_qup_i2c_gsbi2[] = {
+	{
+		.name	= "gsbi_qup_i2c_addr",
+		.start	= MSM_GSBI2_PHYS,
+		.end	= MSM_GSBI2_PHYS + 4 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "qup_phys_addr",
+		.start	= MSM_GSBI2_QUP_PHYS,
+		.end	= MSM_GSBI2_QUP_PHYS + MSM_QUP_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "qup_err_intr",
+		.start	= GSBI2_QUP_IRQ,
+		.end	= GSBI2_QUP_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.name   = "i2c_clk",
+		.start     = MSM_GPIO_I2C_CLK,
+		.end       = MSM_GPIO_I2C_CLK,
+		.flags     = IORESOURCE_IO,
+	},
+	{
+		.name   = "i2c_sda",
+		.start     = MSM_GPIO_I2C_SDA,
+		.end       = MSM_GPIO_I2C_SDA,
+		.flags     = IORESOURCE_IO,
+
+	},
+};
+
+struct platform_device msm9615_device_qup_i2c_gsbi2 = {
+	.name		= "qup_i2c",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(resources_qup_i2c_gsbi2),
+	.resource	= resources_qup_i2c_gsbi2,
+};
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
+
 static struct resource resources_qup_i2c_gsbi5[] = {
 	{
 		.name	= "gsbi_qup_i2c_addr",
@@ -360,6 +446,28 @@ static struct resource resources_qup_spi_gsbi3[] = {
 		.end    = GSBI3_QUP_IRQ,
 		.flags  = IORESOURCE_IRQ,
 	},
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+	{
+		.name   = "spi_clk",
+		.start  = 8,
+		.end    = 8,
+		.flags  = IORESOURCE_IO,
+	},
+	{
+		.name   = "spi_mosi",
+		.start  = 11,
+		.end    = 11,
+		.flags  = IORESOURCE_IO,
+	},
+	{
+		.name   = "spi_cs",
+		.start  = 9,
+		.end    = 9,
+		.flags  = IORESOURCE_IO,
+	},
+#endif
+/* SWISTOP */
 };
 
 struct platform_device msm9615_device_qup_spi_gsbi3 = {
@@ -369,6 +477,40 @@ struct platform_device msm9615_device_qup_spi_gsbi3 = {
 	.resource	= resources_qup_spi_gsbi3,
 };
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static struct resource resources_qup_spi_gsbi4[] = {
+	{
+		.name   = "spi_base",
+		.start  = MSM_GSBI4_QUP_PHYS,
+		.end    = MSM_GSBI4_QUP_PHYS + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.name   = "gsbi_base",
+		.start  = MSM_GSBI4_PHYS,
+		.end    = MSM_GSBI4_PHYS + 4 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.name   = "spi_irq_in",
+		.start  = GSBI4_QUP_IRQ,
+		.end    = GSBI4_QUP_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device msm9615_device_qup_spi_gsbi4 = {
+	.name	= "spi_qsd",
+	.id	= 4,
+	.num_resources	= ARRAY_SIZE(resources_qup_spi_gsbi4),
+	.resource	= resources_qup_spi_gsbi4,
+};
+/* Exporting this symbol so this struct can be access / used by a module */
+EXPORT_SYMBOL_GPL(msm9615_device_qup_spi_gsbi4);
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
+
 #define LPASS_SLIMBUS_PHYS	0x28080000
 #define LPASS_SLIMBUS_BAM_PHYS	0x28084000
 #define LPASS_SLIMBUS_SLEW	(MSM9615_TLMM_PHYS + 0x207C)
diff --git a/arch/arm/mach-msm/devices.h b/arch/arm/mach-msm/devices.h
index b0b08b4..01db938 100644
--- a/arch/arm/mach-msm/devices.h
+++ b/arch/arm/mach-msm/devices.h
@@ -92,8 +92,21 @@ extern struct platform_device apq8064_device_ssbi_pmic2;
 extern struct platform_device apq8064_device_cache_erp;
 
 extern struct platform_device msm9615_device_uart_gsbi4;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#ifdef CONFIG_SIERRA_AR7
+extern struct platform_device msm9615_device_uart_gsbi5;
+#endif /* CONFIG_SIERRA_AR7 */
+extern struct platform_device msm9615_device_qup_i2c_gsbi2;
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 extern struct platform_device msm9615_device_qup_i2c_gsbi5;
 extern struct platform_device msm9615_device_qup_spi_gsbi3;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+extern struct platform_device msm9615_device_qup_spi_gsbi4;
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 extern struct platform_device msm9615_slim_ctrl;
 extern struct platform_device msm9615_device_ssbi_pmic1;
 extern struct platform_device msm9615_device_tsens;
diff --git a/arch/arm/mach-msm/include/mach/sierra_bsidefs.h b/arch/arm/mach-msm/include/mach/sierra_bsidefs.h
new file mode 100644
index 0000000..f2f671b
--- /dev/null
+++ b/arch/arm/mach-msm/include/mach/sierra_bsidefs.h
@@ -0,0 +1,39 @@
+#ifndef BS_IDEFS_H
+#define BS_IDEFS_H
+/* Local constants and enumerated types */
+
+/* RAM Copies of HW type, rev, etc. */
+extern bool bshwconfigread;
+
+
+/* Structures */
+
+/************
+ *
+ * Name:    bshwconfig
+ *
+ * Purpose: to allow easy access to fields of the hardware configuration
+ *
+ * Members:
+ *          all             - single uint32 containing all fields
+ *          hw.type         - hardware type
+ *          hw.rev          - hardware revision
+ *          hw.mfgmode      - manufacturing mode
+ *          hw.spare        - spare
+ *
+ * Notes:
+ *
+ ************/
+union bshwconfig
+{
+  uint32_t all;
+  struct __packed
+  {
+    uint8_t type;
+    uint8_t rev;
+    uint8_t mfgmode;
+    uint8_t spare;
+  } hw;
+};
+
+#endif
diff --git a/arch/arm/mach-msm/include/mach/sierra_smem.h b/arch/arm/mach-msm/include/mach/sierra_smem.h
new file mode 100644
index 0000000..29c6c70
--- /dev/null
+++ b/arch/arm/mach-msm/include/mach/sierra_smem.h
@@ -0,0 +1,181 @@
+/* arch/arm/mach-msm/sierra_smem.h
+ *
+ * Copyright (C) 2012 Sierra Wireless, Inc
+ * Author: Brad Du <bdu@sierrawireless.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef SIERRA_SMEM_H
+#define SIERRA_SMEM_H
+
+#include <mach/msm_iomap.h>
+#include <asm/stacktrace.h>
+
+#define SIERRA_SMEM_SIZE               0x5000     /* same as BSRAM_SIZE_SMI */
+#define SIERRA_SMEM_BASE               (MSM_SHARED_RAM_BASE + MSM_SHARED_RAM_SIZE - SIERRA_SMEM_SIZE)
+/* this is actually BS_ER_ABORT_DATA_MODEM_START */
+#define SIERRA_SMEM_ERR_DUMP_START     (SIERRA_SMEM_BASE + SIERRA_SMEM_SIZE - 0x1828)
+#define BS_BOOT_APP_MSG_START          (SIERRA_SMEM_BASE + SIERRA_SMEM_SIZE - 0x1020)
+
+/* Local constants and enumerated types */
+#define ERROR_START_MARKER  0x4552 /* "ER" in ASCII */
+#define ERROR_END_MARKER    0x4552 /* "ER" in ASCII */
+#define ERROR_USER          0x0101
+#define ERROR_EXCEPTION     0x0202
+#define ERROR_FATAL_ERROR   0x0404
+#define ERROR_LOCK_MARKER   0x0303
+#define ERROR_START_GLOBALTIME_MARKER   0x47744774
+#define ERROR_END_GLOBALTIME_MARKER     0x47744774
+
+#define MAX_SERIAL_LEN      20  /* must be larger than (NV_UE_IMEI_SIZE-1)*2 */
+#define MAX_VER_LEN         22
+#define DATE_TIME_LEN       16
+
+#define ERROR_STRING_LEN    64
+#define MAX_STACK_DATA      32
+#define MAX_TASK_NAME       12
+#define MAX_ARM_REGISTERS   15
+#define MAX_EXT_REGISTERS   17
+#define QDSP6_REG_SP        (29 - MAX_ARM_REGISTERS)  /* R29 = SP */
+#define QDSP6_REG_FP        (30 - MAX_ARM_REGISTERS)  /* R30 = FP */
+#define QDSP6_REG_LR        (31 - MAX_ARM_REGISTERS)  /* R31 = LR */
+
+#define MAX_FORMAT_PARAM    4
+
+#define DUMP_SET_FLAG       0x0001
+
+#define BC_VALID_BOOT_MSG_MARKER           0xBABECAFEU   /* indicates message from Boot to App */
+#define BC_MSG_MARKER_M                    0xFFFF0000U
+#define BCBOOTAPPFLAG_DLOAD_MODE_M         0x00000008
+
+#define ERDUMP_SAVE_CMD_START              0xFF00
+#define ERDUMP_SAVE_CMD_ERRSTR             0xFF01
+#define ERDUMP_SAVE_CMD_ERRDATA            0xFF02
+#define ERDUMP_SAVE_CMD_FMTSTR             0xFF03
+#define ERDUMP_SAVE_CMD_FMTDATA            0xFF04
+#define ERDUMP_SAVE_CMD_REGISTERS          0xFF05
+#define ERDUMP_SAVE_CMD_FRAME              0xFF06
+#define ERDUMP_SAVE_CMD_END                0xFF0F
+
+
+/* Structures */
+
+/*************
+ *
+ * Name:     sER_DATA - ER Data structure
+ *
+ * Purpose:  Contains ER data dumps
+ *
+ * Members:  start_marker    - buffer pointer
+ *           error_source    - user or exception vector
+ *           error_data      - passed error data
+ *           error_string[]  - Null-terminated string
+ *           task_name[]     -
+ *           time_stamp      - modem up time in seconds since power up
+ *           registers[]     - currently visible register set, may be exception
+ *                             registers rather than normal register
+ *           program_counter - code location error occurred
+ *           cpsr            - Current Program Status Register
+ *           stack_data[]    -
+ *           end_marker      - end marker to mark the availability of crucial info
+ *           app_ver         - APPL release at the time of crash
+ *           boot_ver        - BOOT release at the time of crash
+ *           swoc_ver        - SWoC release at the time of crash
+ *           serial_num      - modem IMEI
+ *           date_time       - date/time at the time of crash
+ *           flags           - flag to indicate whether the crash info sent to host or not
+ *           unused          - reserved for future use
+ *           ext_marker      - end marker to mark the availability of extended crash info
+ *           ext_registers   - extra register set for QDSP6 (R15-R31)
+ *                             valid if R29 R30 R31 (SP FP LR) are non-zero
+ *           format_string   - error_string/error_data will store error file name/line number
+ *                             so the error string and params will be actually stored in
+ *                             format_string and param
+ *                             SWI_TBD BD:09:12:16 - need add format string to XML message 
+ *           param           - params for format_string, current 3 possible param for ERR_FATAL 
+ *           reserved        - reserved for future use
+ *           format_marker   - marker to indicate that field format_string and after are valid
+ *
+ * Notes:    make sure uint32 fields is 4-byte aligned
+*           IMPORTANT: if offset of registers/program_counter/cpsr/stack_data or
+*           ext_registers is changed, need to update hardcoded offset in erqdsp.s
+ *
+ **************/
+struct __packed sER_DATA
+{
+    uint16_t start_marker;
+    uint16_t error_source;
+    uint32_t error_data;
+    char     error_string[ERROR_STRING_LEN];
+    char     task_name[MAX_TASK_NAME];
+    uint32_t time_stamp;
+    uint32_t registers[MAX_ARM_REGISTERS];
+    uint32_t program_counter;
+    uint32_t cpsr;
+    uint32_t stack_data[MAX_STACK_DATA];
+    uint16_t end_marker;
+    char     app_ver[MAX_VER_LEN];
+    char     boot_ver[MAX_VER_LEN];
+    char     swoc_ver[MAX_VER_LEN];
+    char     serial_num[MAX_SERIAL_LEN];
+    char     date_time[DATE_TIME_LEN];
+    uint16_t flags;
+    uint16_t ext_marker;
+    uint32_t ext_registers[MAX_EXT_REGISTERS];
+    char     format_string[ERROR_STRING_LEN];
+    uint32_t param[MAX_FORMAT_PARAM];
+    uint32_t reserved[MAX_STACK_DATA];
+    uint16_t format_marker;
+};
+
+/*************
+ *
+ * Name:     bcboottoappmsg - Boot Loader to Application message structure
+ *
+ * Purpose:  To provide a structure which allows information exchange between
+ *           the boot loader and the application.
+ *
+ * Members:
+ *           bcstartmarker  - marker indicating the start of this structure
+ *           flashdevdp     - pointer to flash device descriptor
+ *           launchcode     - ASCII code used to detect that
+ *                            application is to be launched
+ *           usbdescp       - pointer to USB descriptors structure
+ *           loopback       - bitfield for messages passed from the application
+ *                            back to itself over a warm boot
+ *           hwconfig       - hardware configuration
+ *           flags          - boot -> app flags, bitmasked
+ *           partisz        - sizes of APP partitions 
+ *
+ *
+ *************/
+struct __packed bcboottoappmsg
+{
+  uint32_t bcstartmarker;                /* indicates start of structure */
+  void *   flashdevdp;                   /* pointer to flash device descriptor */
+  uint32_t launchcode;                   /* launch code */
+  void *   usbdescp; /* pointer to USB descriptors */
+  uint32_t loopback;                     /* App->App messages */
+  uint32_t hwconfig;                     /* hardware configuration bits */
+  uint32_t flags;                        /* boot -> app messages */
+  uint32_t partisz[10];                  /* total size of 5 APP partitions, read from user partition */
+  uint32_t bcendmarker;                  /* indicates end of structure */
+};
+
+void sierra_smem_errdump_save_start(void);
+void sierra_smem_errdump_save_timestamp(uint32_t time_stamp);
+void sierra_smem_errdump_save_errstr(char *errstrp);
+void sierra_smem_errdump_save_fmtstr(char *errstrp);
+void sierra_smem_errdump_save_frame(void *taskp, struct stackframe *framep);
+int sierra_smem_get_download_mode(void);
+
+#endif /* SIERRA_SMEM_H */
diff --git a/arch/arm/mach-msm/include/mach/usb_gadget_xport.h b/arch/arm/mach-msm/include/mach/usb_gadget_xport.h
index 9cd4f3f..72da921 100644
--- a/arch/arm/mach-msm/include/mach/usb_gadget_xport.h
+++ b/arch/arm/mach-msm/include/mach/usb_gadget_xport.h
@@ -24,6 +24,13 @@ enum transport_type {
 	USB_GADGET_XPORT_BAM2BAM_IPA,
 	USB_GADGET_XPORT_HSIC,
 	USB_GADGET_XPORT_HSUART,
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	USB_GADGET_XPORT_TTYRD,
+	USB_GADGET_XPORT_SMDAT,
+	USB_GADGET_XPORT_SMDOSA,
+#endif /* SIERRA */
+/* SWISTOP */
 	USB_GADGET_XPORT_NONE,
 };
 
@@ -50,6 +57,16 @@ static char *xport_to_str(enum transport_type t)
 		return "HSUART";
 	case USB_GADGET_XPORT_NONE:
 		return "NONE";
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	case USB_GADGET_XPORT_TTYRD:
+		return "TTYRD";
+	case USB_GADGET_XPORT_SMDAT:
+		return "SMDAT";
+	case USB_GADGET_XPORT_SMDOSA:
+		return "SMDOSA";
+#endif /* SIERRA */
+/* SWISTOP */
 	default:
 		return "UNDEFINED";
 	}
@@ -75,7 +92,16 @@ static enum transport_type str_to_xport(const char *name)
 		return USB_GADGET_XPORT_HSUART;
 	if (!strncasecmp("", name, XPORT_STR_LEN))
 		return USB_GADGET_XPORT_NONE;
-
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if (!strncasecmp("TTYRD", name, XPORT_STR_LEN))
+		return USB_GADGET_XPORT_TTYRD;
+	if (!strncasecmp("SMDAT", name, XPORT_STR_LEN))
+		return USB_GADGET_XPORT_SMDAT;
+	if (!strncasecmp("SMDOSA", name, XPORT_STR_LEN))
+		return USB_GADGET_XPORT_SMDOSA;
+#endif /* SIERRA */
+/* SWISTOP */
 	return USB_GADGET_XPORT_UNDEF;
 }
 
diff --git a/arch/arm/mach-msm/nand_partitions.c b/arch/arm/mach-msm/nand_partitions.c
index ea5fb9c..666fdb4 100644
--- a/arch/arm/mach-msm/nand_partitions.c
+++ b/arch/arm/mach-msm/nand_partitions.c
@@ -48,7 +48,13 @@ struct msm_ptbl_entry {
 	__u32 flags;
 };
 
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 #define MSM_MAX_PARTITIONS 18
+#else /* SIERRA */
+#define MSM_MAX_PARTITIONS 32
+#endif /* SIERRA */
+/* SWISTOP */
 
 static struct mtd_partition msm_nand_partitions[MSM_MAX_PARTITIONS];
 static char msm_nand_names[MSM_MAX_PARTITIONS * 16];
diff --git a/arch/arm/mach-msm/restart.c b/arch/arm/mach-msm/restart.c
index bb64370..1fffd76 100644
--- a/arch/arm/mach-msm/restart.c
+++ b/arch/arm/mach-msm/restart.c
@@ -36,6 +36,12 @@
 #include "msm_watchdog.h"
 #include "timer.h"
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#include <mach/sierra_smem.h>
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
+
 #define WDT0_RST	0x38
 #define WDT0_EN		0x40
 #define WDT0_BARK_TIME	0x4C
@@ -188,14 +194,28 @@ static void msm_restart_prepare(const char *cmd)
 	/* Write download mode flags if we're panic'ing */
 	set_dload_mode(in_panic);
 
+/* SWISTART */
+/* move it down, download_mode should not control RESTART_DLOAD
+ * which is for firmware download
+ */
+#ifndef CONFIG_SIERRA
 	/* Write download mode flags if restart_mode says so */
 	if (restart_mode == RESTART_DLOAD)
 		set_dload_mode(1);
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 
 	/* Kill download mode if master-kill switch is set */
 	if (!download_mode)
 		set_dload_mode(0);
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* Write download mode flags if restart_mode says so */
+	if (restart_mode == RESTART_DLOAD)
+		set_dload_mode(1);
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 #endif
 
 	pm8xxx_reset_pwr_off(1);
@@ -264,6 +284,12 @@ static int __init msm_restart_init(void)
 #ifdef CONFIG_MSM_DLOAD_MODE
 	atomic_notifier_chain_register(&panic_notifier_list, &panic_blk);
 	dload_mode_addr = MSM_IMEM_BASE + DLOAD_MODE_ADDR;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	download_mode = sierra_smem_get_download_mode();
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
+
 	set_dload_mode(download_mode);
 #endif
 	msm_tmr0_base = msm_timer_get_timer0_base();
diff --git a/arch/arm/mach-msm/sierra_bscommon.c b/arch/arm/mach-msm/sierra_bscommon.c
new file mode 100644
index 0000000..8d7c6fe
--- /dev/null
+++ b/arch/arm/mach-msm/sierra_bscommon.c
@@ -0,0 +1,605 @@
+/* arch/arm/mach-msm/sierra_smem.c
+ *
+ * Copyright (C) 2013 Sierra Wireless, Inc
+ * Author: Alex Tan <atan@sierrawireless.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+
+
+#include <mach/sierra_smem.h>
+#include <mach/sierra_bsidefs.h>
+#include <linux/sierra_bsudefs.h>
+
+/* RAM Copies of HW type, rev, etc. */
+/* note that there is a copy for the bootloader and another for the app */
+bool bshwconfigread = false;
+union bshwconfig bscfg;
+
+
+/* Local structures and functions */
+/************
+ *
+ * Name:     bsreadhwconfig
+ *
+ * Purpose:  To get the hardware configuration from gpio
+ *
+ * Parms:    none
+ *
+ * Return:   uint32 bitmask of hardware configuration
+ *
+ * Abort:    none
+ *
+ * Notes:
+ *
+ ************/
+static ssize_t bsreadhwconfig(void)
+{
+  struct bcboottoappmsg *mp = (struct bcboottoappmsg *)BS_BOOT_APP_MSG_START;
+  return mp->hwconfig;
+}
+/************
+ *
+ * Name:     bsgethwtype
+ *
+ * Purpose:  Returns hardware type read from QFPROM /GPIO
+ *
+ * Parms:    none
+ *
+ * Return:   hardware type
+ *
+ * Abort:    none
+ *
+ * Notes:
+ *
+ ************/
+enum bshwtype bsgethwtype(
+  void)
+{
+  if (bshwconfigread == false)
+  {
+    bscfg.all = bsreadhwconfig();
+    bshwconfigread = true;
+  }
+
+  return (enum bshwtype) bscfg.hw.type;
+}
+EXPORT_SYMBOL(bsgethwtype);
+
+/************
+ *
+ * Name:     bsgethwrev
+ *
+ * Purpose:  Returns hardware revision read from QFPROM /GPIO
+ *
+ * Parms:    none
+ *
+ * Return:   hardware ID
+ *
+ * Abort:    none
+ *
+ * Notes:
+ *
+ ************/
+uint8_t bsgethwrev(
+  void)
+{
+  if (bshwconfigread == false)
+  {
+    bscfg.all = bsreadhwconfig();
+    bshwconfigread = true;
+  }
+
+  return bscfg.hw.rev;
+}
+EXPORT_SYMBOL(bsgethwrev);
+
+/************
+ *
+ * Name:     bsgetmanufacturingcode
+ *
+ * Purpose:  Returns the current coverage code
+ *
+ * Parms:    None
+ *
+ * Return:   manufacturing code
+ *
+ * Abort:    None
+ *
+ * Notes:    Bit states are inverted and lines are not necessarilly
+ *           in the same register
+ *
+ *
+ *           Code    MODE2   MODE1   MODE0         MANFMode
+ *           -----------------------------------------------------
+ *            000    high    high    high    Normal Mode (Default)
+ *            110     low     low    high    AT on USB, Diag on UART
+ *            111     low     low     low    AT on UART, Diag on USB
+ *
+ *
+ ************/
+uint32_t bsgetmanufacturingcode(
+  void)
+{
+  if (bshwconfigread == false)
+  {
+    bscfg.all = bsreadhwconfig();
+    bshwconfigread = true;
+  }
+
+  return bscfg.hw.mfgmode;
+}
+EXPORT_SYMBOL(bsgetmanufacturingcode);
+
+/************
+ *
+ * Name:     bssupport
+ *
+ * Purpose:  To check if the hardware supports a particular feature
+ *
+ * Parms:    feature - feature to check
+ *
+ * Return:   true if hardware supports this feature
+ *           false otherwise
+ *
+ * Abort:    none
+ *
+ * Notes:    This function is primarily designed to keep hardware variant
+ *           checks to a central location.
+ *
+ ************/
+bool bssupport(
+  enum bsfeature feature)
+{
+  bool supported = false;
+  enum bshwtype hwtype;
+
+  hwtype = bsgethwtype();
+
+  switch (feature)
+  {
+    case BSFEATURE_MINICARD:
+      switch (hwtype)
+      {
+        case BSMC7355:
+        case BSEM7355:
+        case BSEM7655:
+        case BSMC7305:
+        case BSEM7305:
+        case BSMC8805:
+        case BSEM8805:
+        case BSMC7800:
+        case BSMC7800LO:
+        case BSMC7802:
+        case BSMC7804:
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_USB:
+      switch (hwtype)
+      {
+        case BSAC340U:
+        case BSAC342U:
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_MHS:
+      switch (hwtype)
+      {
+        case BSAC770S:
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_AR:
+      switch (hwtype)
+      {
+        case BSAR7550:
+        case BSAR7552:
+        case BSAR7554: 
+        case BSAR7550_LARGER_MEMORY:
+        case BSAR7552_LARGER_MEMORY:
+        case BSAR7554_LARGER_MEMORY:     
+        case BSWP7100_NEW:
+        case BSWP7102_NEW:
+        case BSWP7104_NEW:             
+          supported = true;
+          break;
+          
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_WP:
+      switch (hwtype)
+      {
+        case BSWP7100:
+        case BSWP7102:
+        case BSWP7104:
+        case BSWP7100_LARGER_MEMORY:
+        case BSWP7102_LARGER_MEMORY:
+        case BSWP7104_LARGER_MEMORY:          
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_W_DISABLE:
+      switch (hwtype)
+      {
+        case BSMC7355:
+        case BSEM7355:
+        case BSEM7655:
+        case BSMC7305:
+        case BSEM7305:
+        case BSMC8805:
+        case BSEM8805:
+        case BSMC7800:
+        case BSMC7800LO:
+        case BSMC7802:
+        case BSMC7804:
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_SD:
+      switch (hwtype)
+      {
+        case BSAC340U:
+        case BSAC342U:
+        case BSWP7100:
+        case BSWP7102:
+        case BSWP7104:
+        case BSWP7100_LARGER_MEMORY:
+        case BSWP7102_LARGER_MEMORY:
+        case BSWP7104_LARGER_MEMORY:                        
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_VOICE:
+      switch (hwtype)
+      {
+        case BSAR7550:      
+        case BSAR7552:
+        case BSAR7554:   
+        case BSAR7550_LARGER_MEMORY:      
+        case BSAR7552_LARGER_MEMORY:
+        case BSAR7554_LARGER_MEMORY:                
+        case BSWP7100:
+        case BSWP7102:
+        case BSWP7104:
+        case BSWP7100_LARGER_MEMORY:
+        case BSWP7102_LARGER_MEMORY:
+        case BSWP7104_LARGER_MEMORY:                  
+        case BSMC7800:
+        case BSMC7800LO:
+        case BSMC7802:
+        case BSMC7804:
+        case BSWP7100_NEW:
+        case BSWP7102_NEW:
+        case BSWP7104_NEW: 
+          supported = true;
+          break;
+          
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_HSUPA:
+      switch (hwtype)
+      {
+        case BSMC7800:
+        case BSMC7800LO:
+          supported = false;
+          break;
+
+        default:
+          supported = true;
+          break;
+      }
+      break;
+
+    case BSFEATURE_GPIOSAR:
+      switch (hwtype)
+      {
+        case BSMC7355:
+        case BSEM7355:
+        case BSMC7305:
+        case BSEM7305:
+        case BSEM7655:
+        case BSMC8805:
+        case BSEM8805:
+        case BSMC7800:
+        case BSMC7802:
+        case BSMC7804:
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_RMAUTOCONNECT:
+      supported = true;
+      break;
+
+    case BSFEATURE_UART:
+      switch (hwtype)
+      {
+        case BSAR7550:
+        case BSAR7552:
+        case BSAR7554:
+        case BSAR7550_LARGER_MEMORY:      
+        case BSAR7552_LARGER_MEMORY:
+        case BSAR7554_LARGER_MEMORY:         
+        case BSWP7100:
+        case BSWP7102:
+        case BSWP7104:
+        case BSWP7100_LARGER_MEMORY:
+        case BSWP7102_LARGER_MEMORY:
+        case BSWP7104_LARGER_MEMORY:
+        case BSWP7100_NEW:
+        case BSWP7102_NEW:
+        case BSWP7104_NEW: 
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_ANTSEL:
+      switch (hwtype)
+      {
+        case BSMC7355:
+        case BSEM7355:
+        case BSEM7655:
+        case BSMC7305:
+        case BSEM7305:
+        case BSMC8805:
+        case BSEM8805:
+        case BSWP7100:
+        case BSWP7102:
+        case BSWP7104:
+        case BSWP7100_LARGER_MEMORY:
+        case BSWP7102_LARGER_MEMORY:
+        case BSWP7104_LARGER_MEMORY: 		
+        case BSAR7550:
+        case BSAR7552:
+        case BSAR7554:
+        case BSAR7550_LARGER_MEMORY:
+        case BSAR7552_LARGER_MEMORY:
+        case BSAR7554_LARGER_MEMORY:        
+        case BSMC7800:
+        case BSMC7800LO:
+        case BSMC7802:
+        case BSMC7804:
+        case BSWP7100_NEW:
+        case BSWP7102_NEW:
+        case BSWP7104_NEW:       
+          supported = true;
+          break;
+            
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_INSIM:
+      /* Not supported any more in WP710x, so returns false for all devices */
+      supported = false;
+      break;
+
+    case BSFEATURE_OOBWAKE:
+      switch (hwtype)
+      {
+        case BSMC7355:
+        case BSEM7355:
+        case BSMC7305:
+        case BSEM7305:
+        case BSEM7655:
+        case BSMC8805:
+        case BSEM8805:
+        case BSMC7800:
+        case BSMC7800LO:
+        case BSMC7802:
+        case BSMC7804:
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_CDMA:
+      switch (hwtype)
+      {
+        case BSMC7355:
+        case BSEM7355:
+        case BSEM7655:
+        case BSAR7550:
+        case BSAR7550_LARGER_MEMORY:        
+        case BSWP7100:
+        case BSWP7100_LARGER_MEMORY:        
+        case BSMC7800:
+        case BSWP7100_NEW:
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_GSM:
+      switch (hwtype)
+      {
+        case BSMC7800:
+        case BSMC7800LO:
+          supported = false;
+          break;
+
+        default:
+          supported = true;
+          break;
+      }
+      break;
+
+    case BSFEATURE_WCDMA:
+      switch (hwtype)
+      {
+        case BSMC7800:
+        case BSMC7800LO:
+          supported = false;
+          break;
+
+        default:
+          supported = true;
+          break;
+      }
+      break;
+
+    case BSFEATURE_LTE:
+      switch (hwtype)
+      {
+        case BSMC8805:
+        case BSEM8805:
+          supported = false;
+          break;
+
+        default:
+          supported = true;
+          break;
+      }
+      break;
+
+    case BSFEATURE_EM:
+      switch (hwtype)
+      {
+        case BSEM7355:
+        case BSEM7305:
+        case BSEM7655:
+        case BSEM8805:
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_SVC_PIN_DLOAD:
+      switch (hwtype)
+      {
+        case BSAR7550:
+        case BSAR7552:
+        case BSAR7554:
+        case BSAR7550_LARGER_MEMORY:      
+        case BSAR7552_LARGER_MEMORY:
+        case BSAR7554_LARGER_MEMORY:         
+        case BSWP7100:
+        case BSWP7102:
+        case BSWP7104:
+        case BSWP7100_LARGER_MEMORY:
+        case BSWP7102_LARGER_MEMORY:
+        case BSWP7104_LARGER_MEMORY:  
+        case BSWP7100_NEW:
+        case BSWP7102_NEW:
+        case BSWP7104_NEW:                 
+          supported = true;
+          break;
+
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    case BSFEATURE_BUZZER:
+      switch (hwtype)
+      {         
+        case BSWP7100:
+        case BSWP7102:
+        case BSWP7104:
+        case BSWP7100_LARGER_MEMORY:
+        case BSWP7102_LARGER_MEMORY:
+        case BSWP7104_LARGER_MEMORY:                  
+          supported = true;
+          break;
+          
+        default:
+          supported = false;
+          break;
+      }
+      break;
+
+    default:
+      pr_err("Unknown feature %X", (uint32_t)feature);
+      break;
+  }
+
+  return supported;
+
+}
+EXPORT_SYMBOL(bssupport);
+
+
diff --git a/arch/arm/mach-msm/sierra_smem.c b/arch/arm/mach-msm/sierra_smem.c
new file mode 100644
index 0000000..0fb84a2
--- /dev/null
+++ b/arch/arm/mach-msm/sierra_smem.c
@@ -0,0 +1,146 @@
+/* arch/arm/mach-msm/sierra_smem.c
+ *
+ * Copyright (C) 2012 Sierra Wireless, Inc
+ * Author: Brad Du <bdu@sierrawireless.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+
+#include <mach/sierra_smem.h>
+
+static ssize_t sierra_smem_read(struct file *fp, char __user *buf,
+            size_t count, loff_t *posp)
+{
+    unsigned char *memp = (void *) SIERRA_SMEM_BASE;
+    int ret;
+    loff_t pos = *posp;
+    ssize_t len;
+    
+    
+    if(pos >= SIERRA_SMEM_SIZE)
+    {
+        return 0;
+    }
+    
+    len = min(count, (size_t)(SIERRA_SMEM_SIZE - pos));
+    
+    memp += pos;
+    ret = copy_to_user(buf, memp, len);
+    
+    if(ret)
+    {
+        pr_err("%s: copy to user failed\n", __func__);
+        return -EFAULT;
+    }
+    else
+    {
+        *posp += len;
+    }
+
+    return len;
+}
+
+/* the write function will be used mainly to write errdump related fields
+ * offset field will indicate which field to update
+ */
+static ssize_t sierra_smem_write(struct file *fp, const char __user *buf,
+             size_t count, loff_t *posp)
+{
+	int r;
+	unsigned char cmddata[ERROR_STRING_LEN]  __attribute__((aligned(4)));
+	loff_t pos = *posp;
+	struct stackframe *frp;
+	uint32_t time_stamp;
+
+	if (count > sizeof(cmddata))
+	{
+		count = sizeof(cmddata);
+	}
+
+	r = copy_from_user(cmddata, buf, count);
+	if (r) 
+	{
+		printk(KERN_ERR "sierra_smem_write - copy_from_user failed %d\n", r);
+		return -EFAULT;
+	}
+
+	if(pos == ERDUMP_SAVE_CMD_START)
+	{
+		sierra_smem_errdump_save_start();        
+		/* timestamp in cmddata */
+		memcpy((void *)&time_stamp, cmddata, sizeof(time_stamp));
+		sierra_smem_errdump_save_timestamp(time_stamp);        
+	}
+	else if(pos == ERDUMP_SAVE_CMD_ERRSTR)
+	{
+		sierra_smem_errdump_save_errstr(cmddata);        
+	}
+	else if(pos == ERDUMP_SAVE_CMD_FMTSTR)
+	{
+		sierra_smem_errdump_save_fmtstr(cmddata);        
+	}
+	else if(pos == ERDUMP_SAVE_CMD_FRAME)
+	{
+		/* cast to frame pointer, can case since cmddata is 4 byte aligned */
+		frp = (struct stackframe *)&cmddata;
+		sierra_smem_errdump_save_frame(0, frp);        
+	}
+
+	return count;
+}
+    
+static int sierra_smem_open(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int sierra_smem_release(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static struct file_operations sierra_smem_fops = {
+    .owner = THIS_MODULE,
+    .read = sierra_smem_read,
+    .write = sierra_smem_write,
+    .llseek = default_llseek,
+    .open = sierra_smem_open,
+    .release = sierra_smem_release,
+};
+
+static struct miscdevice sierra_smem_misc = {
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = "sierra_smem",
+    .fops = &sierra_smem_fops,
+};
+
+static int __init sierra_smem_init(void)
+{
+    return misc_register(&sierra_smem_misc);
+}
+
+static void __exit sierra_smem_exit(void)
+{
+    misc_deregister(&sierra_smem_misc);
+}
+
+module_init(sierra_smem_init);
+module_exit(sierra_smem_exit);
+
+MODULE_AUTHOR("Brad Du <bdu@sierrawireless.com>");
+MODULE_DESCRIPTION("Sierra SMEM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/arch/arm/mach-msm/sierra_smem_errdump.c b/arch/arm/mach-msm/sierra_smem_errdump.c
new file mode 100644
index 0000000..2591ac4
--- /dev/null
+++ b/arch/arm/mach-msm/sierra_smem_errdump.c
@@ -0,0 +1,188 @@
+/* arch/arm/mach-msm/sierra_smem_errdump.c
+ *
+ * Sierra SMEM utility functions. These functions don't rely on Sierra SMEM driver,
+ * and can be used in early kernel start (after paging_init)
+ *
+ * Copyright (C) 2012 Sierra Wireless, Inc
+ * Author: Brad Du <bdu@sierrawireless.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/mutex.h>
+#include <asm/uaccess.h>
+#include <mach/sierra_smem.h>
+
+static DEFINE_MUTEX(errdump_lock);
+
+static struct sER_DATA *sierr_smem_get_dump_buf(void)
+{
+  return (struct sER_DATA *)SIERRA_SMEM_ERR_DUMP_START;
+}
+
+void sierra_smem_errdump_save_start(void)
+{
+  struct sER_DATA *errdatap = sierr_smem_get_dump_buf();
+
+  if(mutex_trylock(&errdump_lock))
+  {
+    /* note that the errdatap can only be accessible after paging_init at kernel start
+     * If there is a panic before paging_init, the following line will likely cause another panic
+     */
+    memset((void *)errdatap, 0x00, sizeof(struct sER_DATA));
+    mutex_unlock(&errdump_lock);
+  }
+  /* else, reentry, don't save */
+}
+EXPORT_SYMBOL(sierra_smem_errdump_save_start);
+
+void sierra_smem_errdump_save_timestamp(uint32_t time_stamp)
+{
+  struct sER_DATA *errdatap = sierr_smem_get_dump_buf();
+
+  if(mutex_trylock(&errdump_lock))
+  {
+    if(errdatap->time_stamp == 0)
+    {
+      errdatap->time_stamp = time_stamp;
+    }
+    /* else time_stamp has sth, should not happen since
+     * it should be cleared at sierra_smem_errdump_save_start
+     */
+
+    mutex_unlock(&errdump_lock);
+  }
+  /* else, reentry, don't save */
+}
+EXPORT_SYMBOL(sierra_smem_errdump_save_timestamp);
+
+void sierra_smem_errdump_save_errstr(char *errstrp)
+{
+  struct sER_DATA *errdatap = sierr_smem_get_dump_buf();
+
+  if(mutex_trylock(&errdump_lock))
+  {
+    if(errdatap->error_string[0] == 0x00)
+    {
+      errdatap->start_marker = ERROR_START_MARKER;
+      errdatap->error_source = ERROR_FATAL_ERROR;
+
+      strncpy(errdatap->error_string, errstrp, ERROR_STRING_LEN);
+      errdatap->error_string[ERROR_STRING_LEN - 1] = 0x00;
+
+      errdatap->end_marker = ERROR_END_MARKER;
+    }
+    /* else error_string has sth, should not happen since
+     * it should be cleared at sierra_smem_errdump_save_start
+     */
+    
+    mutex_unlock(&errdump_lock);
+  }
+  /* else, reentry, don't save */
+}
+EXPORT_SYMBOL(sierra_smem_errdump_save_errstr);
+
+void sierra_smem_errdump_save_fmtstr(char *errstrp)
+{
+  struct sER_DATA *errdatap = sierr_smem_get_dump_buf();
+
+  if(mutex_trylock(&errdump_lock))
+  {
+    if(errdatap->format_string[0] == 0x00)
+    {
+      strncpy(errdatap->format_string, errstrp, ERROR_STRING_LEN);
+      errdatap->format_string[ERROR_STRING_LEN - 1] = 0x00;
+
+      errdatap->ext_marker = ERROR_END_MARKER;
+      errdatap->format_marker = ERROR_END_MARKER;
+    }
+    /* else format_string has sth, should not happen since
+     * it should be cleared at sierra_smem_errdump_save_start
+     */
+
+    mutex_unlock(&errdump_lock);
+  }
+  /* else, reentry, don't save */
+}
+EXPORT_SYMBOL(sierra_smem_errdump_save_fmtstr);
+
+void sierra_smem_errdump_save_frame(void *taskp, struct stackframe *framep)
+{
+  struct sER_DATA *errdatap = sierr_smem_get_dump_buf();
+  unsigned long *stackp, stack_index;
+
+  if(mutex_trylock(&errdump_lock))
+  {
+    if(errdatap->program_counter == 0)
+    {
+      errdatap->start_marker = ERROR_START_MARKER;
+  
+      errdatap->program_counter = framep->pc;
+      errdatap->registers[11] = framep->fp; 
+      errdatap->registers[13] = framep->sp; 
+      errdatap->registers[14] = framep->lr;
+  
+      /* use frame pointer which is one step closer than stack pointer */
+      /* taskp != 0: kernel space stack processing : */
+      if(taskp && framep->fp)
+      {
+        stackp = (unsigned long *)framep->fp;
+        /* match mpss side pattern */
+        for (stack_index = 0; stack_index < MAX_STACK_DATA; stack_index ++)
+        {
+          errdatap->stack_data[MAX_STACK_DATA - stack_index - 1] = stackp[stack_index];
+        }
+      }
+      /* taskp == 0: user space stack processing: */
+      else if(taskp == 0 && access_ok(VERIFY_READ, (char __user *)framep->fp, MAX_STACK_DATA * sizeof(long)))
+      {
+        /* match mpss side pattern */
+        for (stack_index = 0; stack_index < MAX_STACK_DATA; stack_index ++)
+        {
+          get_user(errdatap->stack_data[MAX_STACK_DATA - stack_index - 1],
+                   (unsigned long __user *)(framep->fp + (sizeof(long) * stack_index)));
+        }
+      }
+ 
+      sprintf(errdatap->task_name, "%08X", (unsigned int)taskp);
+
+      errdatap->end_marker = ERROR_END_MARKER;
+    }
+    /* else pc has sth, should not happen since
+     * it should be cleared at sierra_smem_errdump_save_start
+     */
+
+    mutex_unlock(&errdump_lock);
+  }
+  /* else, reentry, don't save */
+}
+EXPORT_SYMBOL(sierra_smem_errdump_save_frame);
+
+int sierra_smem_get_download_mode(void)
+{
+  struct bcboottoappmsg *b2amsgp = (struct bcboottoappmsg *)BS_BOOT_APP_MSG_START;
+  int download_mode = 0;
+
+  if(b2amsgp->bcstartmarker == b2amsgp->bcendmarker &&
+     (b2amsgp->bcstartmarker & BC_MSG_MARKER_M) == (BC_VALID_BOOT_MSG_MARKER & BC_MSG_MARKER_M))
+  {
+    if(b2amsgp->flags & BCBOOTAPPFLAG_DLOAD_MODE_M)
+    {
+      download_mode = 1;
+    }
+  }
+
+  return download_mode;
+}
+EXPORT_SYMBOL(sierra_smem_get_download_mode);
diff --git a/arch/arm/mach-msm/smd_nmea.c b/arch/arm/mach-msm/smd_nmea.c
index d1b2b2d..7b6a38a 100644
--- a/arch/arm/mach-msm/smd_nmea.c
+++ b/arch/arm/mach-msm/smd_nmea.c
@@ -28,6 +28,13 @@
 #include <mach/msm_smd.h>
 
 #define MAX_BUF_SIZE 200
+/*SWISTART */
+#ifdef CONFIG_SIERRA
+#define READ_BUF_SIZE 10240
+char smd_buf[READ_BUF_SIZE];
+int smd_use=0;
+#endif
+/* SWISTOP */
 
 static DEFINE_MUTEX(nmea_ch_lock);
 static DEFINE_MUTEX(nmea_rx_buf_lock);
@@ -66,10 +73,41 @@ static void nmea_work_func(struct work_struct *ws)
 			printk(KERN_ERR "nmea: not enough data?!\n");
 			continue;
 		}
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+        if((smd_use+sz)<READ_BUF_SIZE)
+        {
+
+  		  nmea_devp->bytes_read = sz;
+           memcpy((char *)(&smd_buf)+smd_use,nmea_devp->rx_buf,sz);
+           smd_use+=sz;
+           smd_buf[smd_use]=0;
+        }
+        else
+        {
+          printk(KERN_ERR "NMEA read driver miss interrupt, abandon current buff\n");
+          smd_use=0;
+
+        }
+		mutex_unlock(&nmea_rx_buf_lock);
+    
+          if(smd_use>512)
+          {
+		    wake_up_interruptible(&nmea_wait_queue);
+          }
+	}
+
+    if(smd_use!=0)
+    {
+	   wake_up_interruptible(&nmea_wait_queue);
+     }
+#else
 		nmea_devp->bytes_read = sz;
 		mutex_unlock(&nmea_rx_buf_lock);
 		wake_up_interruptible(&nmea_wait_queue);
 	}
+#endif
+/* SWISTOP */
 }
 
 struct workqueue_struct *nmea_wq;
@@ -100,8 +138,15 @@ static ssize_t nmea_read(struct file *fp, char __user *buf,
 	int r;
 	int bytes_read;
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	r = wait_event_interruptible(nmea_wait_queue,
+				smd_use);
+#else
 	r = wait_event_interruptible(nmea_wait_queue,
 				nmea_devp->bytes_read);
+#endif
+/* SWISTOP */
 	if (r < 0) {
 		/* qualify error message */
 		if (r != -ERESTARTSYS) {
@@ -118,9 +163,18 @@ static ssize_t nmea_read(struct file *fp, char __user *buf,
 	}
 
 	mutex_lock(&nmea_rx_buf_lock);
+/*SWISTART */
+#ifdef CONFIG_SIERRA
+	bytes_read = smd_use;
+    smd_use=0;
+    
+	r = copy_to_user(buf, &smd_buf, bytes_read);
+#else
 	bytes_read = nmea_devp->bytes_read;
 	nmea_devp->bytes_read = 0;
 	r = copy_to_user(buf, nmea_devp->rx_buf, bytes_read);
+#endif
+/* SWISTOP */
 	mutex_unlock(&nmea_rx_buf_lock);
 
 	if (r > 0) {
@@ -136,6 +190,39 @@ static ssize_t nmea_read(struct file *fp, char __user *buf,
 	return bytes_read;
 }
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+/* code reference: smd_pkt_write */
+static int nmea_write(struct file *file, const char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	int r;
+	unsigned char cmd[64];
+
+	if (count > sizeof(cmd))
+		return -EINVAL;
+
+	if (smd_write_avail(nmea_devp->ch) < count) {
+        printk(KERN_ERR "nmea_write - Not enough space to write\n");
+		return -ENOMEM;
+	}
+
+	r = copy_from_user(cmd, buf, count);
+	if (r) {
+		printk(KERN_ERR "nmea_write - copy_from_user failed %d\n", r);
+		return -EFAULT;
+	}
+
+	r = smd_write(nmea_devp->ch, cmd, count);
+	if (r != count) {
+		printk(KERN_ERR "nmea_write failed to write %d bytes: %d.\n", count, r);
+		return -EIO;
+	}
+
+	return count;
+}
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 static int nmea_open(struct inode *ip, struct file *fp)
 {
 	int r = 0;
@@ -165,6 +252,11 @@ static int nmea_release(struct inode *ip, struct file *fp)
 static const struct file_operations nmea_fops = {
 	.owner = THIS_MODULE,
 	.read = nmea_read,
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	.write = nmea_write,
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 	.open = nmea_open,
 	.release = nmea_release,
 };
diff --git a/arch/arm/mach-msm/smd_tty.c b/arch/arm/mach-msm/smd_tty.c
index ecba7ef..e3aa486 100644
--- a/arch/arm/mach-msm/smd_tty.c
+++ b/arch/arm/mach-msm/smd_tty.c
@@ -85,8 +85,12 @@ static struct smd_config smd_configs[] = {
 	{4, "MBALBRIDGE", NULL, SMD_APPS_MODEM},
 	{5, "APPS_RIVA_ANT_CMD", NULL, SMD_APPS_WCNSS},
 	{6, "APPS_RIVA_ANT_DATA", NULL, SMD_APPS_WCNSS},
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	{7, "DATA1", NULL, SMD_APPS_MODEM},
 	{11, "DATA11", NULL, SMD_APPS_MODEM},
+#endif/* SIERRA */
+/* SWISTOP */
 	{21, "DATA21", NULL, SMD_APPS_MODEM},
 	{27, "GPSNMEA", NULL, SMD_APPS_MODEM},
 	{36, "LOOPBACK", "LOOPBACK_TTY", SMD_APPS_MODEM},
diff --git a/drivers/char/diag/diagfwd.c b/drivers/char/diag/diagfwd.c
index b68f25e..d449311 100644
--- a/drivers/char/diag/diagfwd.c
+++ b/drivers/char/diag/diagfwd.c
@@ -1492,6 +1492,9 @@ static int diag_process_apps_pkt(unsigned char *buf, int len)
 		ENCODE_RSP_AND_SEND(8 + ssid_range - 1);
 		return 0;
 	}
+/* SWISTART */
+/* will process 'switch to downloader' command on mpss side */
+#ifndef CONFIG_SIERRA
 	/* Check for download command */
 	else if ((cpu_is_msm8x60() || chk_apps_master()) && (*buf == 0x3A)) {
 		/* send response back */
@@ -1505,6 +1508,8 @@ static int diag_process_apps_pkt(unsigned char *buf, int len)
 		/* Not required, represents that command isnt sent to modem */
 		return 0;
 	}
+#endif /* SIERRA */
+/* SWISTOP */
 	/* Check for polling for Apps only DIAG */
 	else if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&
 		(*(buf+2) == 0x03)) {
diff --git a/drivers/hwmon/pm8xxx-adc-scale.c b/drivers/hwmon/pm8xxx-adc-scale.c
index 56c352a..823129d 100644
--- a/drivers/hwmon/pm8xxx-adc-scale.c
+++ b/drivers/hwmon/pm8xxx-adc-scale.c
@@ -110,7 +110,8 @@ static const struct pm8xxx_adc_map_pt adcmap_btm_threshold[] = {
 	{780,	208},
 	{790,	203}
 };
-
+/*SWISTART*/
+#ifndef CONFIG_SIERRA
 static const struct pm8xxx_adc_map_pt adcmap_pa_therm[] = {
 	{1731,	-30},
 	{1726,	-29},
@@ -270,175 +271,364 @@ static const struct pm8xxx_adc_map_pt adcmap_pa_therm[] = {
 	{49,	125}
 };
 
+#else
+
+static const struct pm8xxx_adc_map_pt adcmap_pa_therm[] = {
+	{ 1793, -40 },
+	{ 1793, -39 },
+	{ 1792, -38 },
+	{ 1791, -37 },
+	{ 1791, -36 },
+	{ 1790, -35 },
+	{ 1789, -34 },
+	{ 1787, -33 },
+	{ 1786, -32 },
+	{ 1785, -31 },
+	{ 1783, -30 },
+	{ 1782, -29 },
+	{ 1780, -28 },
+	{ 1778, -27 },
+	{ 1777, -26 },
+	{ 1775, -25 },
+	{ 1773, -24 },
+	{ 1771, -23 },
+	{ 1768, -22 },
+	{ 1766, -21 },
+	{ 1763, -20 },
+	{ 1761, -19 },
+	{ 1758, -18 },
+	{ 1755, -17 },
+	{ 1752, -16 },
+	{ 1748, -15 },
+	{ 1745, -14 },
+	{ 1741, -13 },
+	{ 1737, -12 },
+	{ 1733, -11 },
+	{ 1728, -10 },
+	{ 1723, -9 },
+	{ 1718, -8 },
+	{ 1713, -7 },
+	{ 1708, -6 },
+	{ 1702, -5 },
+	{ 1696, -4 },
+	{ 1690, -3 },
+	{ 1683, -2 },
+	{ 1676, -1 },
+	{ 1669, 0 },
+	{ 1661, 1 },
+	{ 1654, 2 },
+	{ 1646, 3 },
+	{ 1638, 4 },
+	{ 1629, 5 },
+	{ 1620, 6 },
+	{ 1610, 7 },
+	{ 1599, 8 },
+	{ 1589, 9 },
+	{ 1579, 10 },
+	{ 1568, 11 },
+	{ 1557, 12 },
+	{ 1545, 13 },
+	{ 1534, 14 },
+	{ 1522, 15 },
+	{ 1509, 16 },
+	{ 1496, 17 },
+	{ 1483, 18 },
+	{ 1469, 19 },
+	{ 1454, 20 },
+	{ 1440, 21 },
+	{ 1425, 22 },
+	{ 1409, 23 },
+	{ 1393, 24 },
+	{ 1377, 25 },
+	{ 1360, 26 },
+	{ 1343, 27 },
+	{ 1324, 28 },
+	{ 1306, 29 },
+	{ 1287, 30 },
+	{ 1267, 31 },
+	{ 1248, 32 },
+	{ 1229, 33 },
+	{ 1209, 34 },
+	{ 1189, 35 },
+	{ 1169, 36 },
+	{ 1149, 37 },
+	{ 1128, 38 },
+	{ 1108, 39 },
+	{ 1087, 40 },
+	{ 1066, 41 },
+	{ 1045, 42 },
+	{ 1025, 43 },
+	{ 1004, 44 },
+	{ 984, 45 },
+	{ 963, 46 },
+	{ 941, 47 },
+	{ 920, 48 },
+	{ 899, 49 },
+	{ 878, 50 },
+	{ 857, 51 },
+	{ 837, 52 },
+	{ 818, 53 },
+	{ 797, 54 },
+	{ 778, 55 },
+	{ 762, 56 },
+	{ 743, 57 },
+	{ 724, 58 },
+	{ 706, 59 },
+	{ 687, 60 },
+	{ 669, 61 },
+	{ 651, 62 },
+	{ 634, 63 },
+	{ 617, 64 },
+	{ 601, 65 },
+	{ 584, 66 },
+	{ 568, 67 },
+	{ 552, 68 },
+	{ 537, 69 },
+	{ 521, 70 },
+	{ 507, 71 },
+	{ 492, 72 },
+	{ 477, 73 },
+	{ 463, 74 },
+	{ 449, 75 },
+	{ 437, 76 },
+	{ 424, 77 },
+	{ 412, 78 },
+	{ 400, 79 },
+	{ 388, 80 },
+	{ 376, 81 },
+	{ 365, 82 },
+	{ 354, 83 },
+	{ 344, 84 },
+	{ 333, 85 },
+	{ 323, 86 },
+	{ 313, 87 },
+	{ 303, 88 },
+	{ 294, 89 },
+	{ 285, 90 },
+	{ 275, 91 },
+	{ 267, 92 },
+	{ 258, 93 },
+	{ 250, 94 },
+	{ 242, 95 },
+	{ 235, 96 },
+	{ 227, 97 },
+	{ 220, 98 },
+	{ 214, 99 },
+	{ 209, 100 },
+	{ 203, 101 },
+	{ 199, 102 },
+	{ 195, 103 },
+	{ 189, 104 },
+	{ 184, 105 },
+	{ 178, 106 },
+	{ 173, 107 },
+	{ 167, 108 },
+	{ 162, 109 },
+	{ 157, 110 },
+	{ 152, 111 },
+	{ 147, 112 },
+	{ 143, 113 },
+	{ 138, 114 },
+	{ 134, 115 },
+	{ 130, 116 },
+	{ 126, 117 },
+	{ 122, 118 },
+	{ 119, 119 },
+	{ 120, 115 },
+	{ 121, 111},
+	{ 122, 107},
+	{ 123, 103 },
+	{ 124, 99 },
+	{ 125, 95 }
+};
+#endif
+/*SWISTOP*/
+
 static const struct pm8xxx_adc_map_pt adcmap_ntcg_104ef_104fb[] = {
-	{374682,	-40960},
-	{360553,	-39936},
-	{346630,	-38912},
-	{332940,	-37888},
-	{319510,	-36864},
-	{306363,	-35840},
-	{293521,	-34816},
-	{281001,	-33792},
-	{268818,	-32768},
-	{256987,	-31744},
-	{245516,	-30720},
-	{234413,	-29696},
-	{223685,	-28672},
-	{213333,	-27648},
-	{203360,	-26624},
-	{193763,	-25600},
-	{184541,	-24576},
-	{175691,	-23552},
-	{167205,	-22528},
-	{159079,	-21504},
-	{151304,	-20480},
-	{143872,	-19456},
-	{136775,	-18432},
-	{130001,	-17408},
-	{123542,	-16384},
-	{117387,	-15360},
-	{111526,	-14336},
-	{105946,	-13312},
-	{100639,	-12288},
-	{95592,		-11264},
-	{90795,		-10240},
-	{86238,		-9216},
-	{81909,		-8192},
-	{77800,		-7168},
-	{73899,		-6144},
-	{70197,		-5120},
-	{66685,		-4096},
-	{63354,		-3072},
-	{60194,		-2048},
-	{57198,		-1024},
-	{54356,		0},
-	{51662,		1024},
-	{49108,		2048},
-	{46687,		3072},
-	{44391,		4096},
-	{42215,		5120},
-	{40151,		6144},
-	{38195,		7168},
-	{36340,		8192},
-	{34582,		9216},
-	{32914,		10240},
-	{31333,		11264},
-	{29833,		12288},
-	{28410,		13312},
-	{27061,		14336},
-	{25781,		15360},
-	{24566,		16384},
-	{23413,		17408},
-	{22319,		18432},
-	{21280,		19456},
-	{20294,		20480},
-	{19358,		21504},
-	{18469,		22528},
-	{17624,		23552},
-	{16822,		24576},
-	{16060,		25600},
-	{15335,		26624},
-	{14646,		27648},
-	{13992,		28672},
-	{13369,		29696},
-	{12777,		30720},
-	{12214,		31744},
-	{11678,		32768},
-	{11168,		33792},
-	{10682,		34816},
-	{10220,		35840},
-	{9780,		36864},
-	{9361,		37888},
-	{8962,		38912},
-	{8582,		39936},
-	{8219,		40960},
-	{7874,		41984},
-	{7545,		43008},
-	{7231,		44032},
-	{6931,		45056},
-	{6646,		46080},
-	{6373,		47104},
-	{6113,		48128},
-	{5865,		49152},
-	{5628,		50176},
-	{5402,		51200},
-	{5185,		52224},
-	{4979,		53248},
-	{4782,		54272},
-	{4593,		55296},
-	{4413,		56320},
-	{4241,		57344},
-	{4076,		58368},
-	{3919,		59392},
-	{3768,		60416},
-	{3624,		61440},
-	{3486,		62464},
-	{3354,		63488},
-	{3227,		64512},
-	{3106,		65536},
-	{2990,		66560},
-	{2879,		67584},
-	{2773,		68608},
-	{2671,		69632},
-	{2573,		70656},
-	{2479,		71680},
-	{2390,		72704},
-	{2303,		73728},
-	{2221,		74752},
-	{2142,		75776},
-	{2066,		76800},
-	{1993,		77824},
-	{1923,		78848},
-	{1855,		79872},
-	{1791,		80896},
-	{1729,		81920},
-	{1669,		82944},
-	{1612,		83968},
-	{1557,		84992},
-	{1504,		86016},
-	{1453,		87040},
-	{1404,		88064},
-	{1357,		89088},
-	{1312,		90112},
-	{1269,		91136},
-	{1227,		92160},
-	{1187,		93184},
-	{1148,		94208},
-	{1111,		95232},
-	{1075,		96256},
-	{1040,		97280},
-	{1007,		98304},
-	{975,		99328},
-	{944,		100352},
-	{914,		101376},
-	{886,		102400},
-	{858,		103424},
-	{831,		104448},
-	{806,		105472},
-	{781,		106496},
-	{757,		107520},
-	{734,		108544},
-	{712,		109568},
-	{690,		110592},
-	{670,		111616},
-	{650,		112640},
-	{630,		113664},
-	{612,		114688},
-	{594,		115712},
-	{576,		116736},
-	{559,		117760},
-	{543,		118784},
-	{527,		119808},
-	{512,		120832},
-	{498,		121856},
-	{483,		122880},
-	{470,		123904},
-	{456,		124928},
-	{444,		125952},
-	{431,		126976},
-	{419,		128000},
-	{408,		129024},
-	{396,		130048}
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+   /* below entries are provided by QCT */
+   /* provided that anything below -40C is out of QC published spec ranges */
+    { 519569, -51200 },
+    { 505353, -50176 },
+    { 490973, -49152 },
+    { 476468, -48128 },
+    { 461876, -47104 },
+    { 447237, -46080 },
+    { 432590, -45056 },
+    { 417973, -44032 },
+    { 403426, -43008 },
+    { 388983, -41984 },
+#endif
+/* SWISTOP */
+    { 374682, -40960 },
+    { 360553, -39936 },
+    { 346630, -38912 },
+    { 332940, -37888 },
+    { 319510, -36864 },
+    { 306363, -35840 },
+    { 293521, -34816 },
+    { 281001, -33792 },
+    { 268818, -32768 },
+    { 256987, -31744 },
+    { 245516, -30720 },
+    { 234413, -29696 },
+    { 223685, -28672 },
+    { 213333, -27648 },
+    { 203360, -26624 },
+    { 193763, -25600 },
+    { 184541, -24576 },
+    { 175691, -23552 },
+    { 167205, -22528 },
+    { 159079, -21504 },
+    { 151304, -20480 },
+    { 143872, -19456 },
+    { 136775, -18432 },
+    { 130001, -17408 },
+    { 123542, -16384 },
+    { 117387, -15360 },
+    { 111526, -14336 },
+    { 105946, -13312 },
+    { 100639, -12288 },
+    { 95592, -11264 },
+    { 90795, -10240 },
+    { 86238, -9216 },
+    { 81909, -8192 },
+    { 77800, -7168 },
+    { 73899, -6144 },
+    { 70197, -5120 },
+    { 66685, -4096 },
+    { 63354, -3072 },
+    { 60194, -2048 },
+    { 57198, -1024 },
+    { 54356, 0 },
+    { 51662, 1024 },
+    { 49108, 2048 },
+    { 46687, 3072 },
+    { 44391, 4096 },
+    { 42215, 5120 },
+    { 40151, 6144 },
+    { 38195, 7168 },
+    { 36340, 8192 },
+    { 34582, 9216 },
+    { 32914, 10240 },
+    { 31333, 11264 },
+    { 29833, 12288 },
+    { 28410, 13312 },
+    { 27061, 14336 },
+    { 25781, 15360 },
+    { 24566, 16384 },
+    { 23413, 17408 },
+    { 22319, 18432 },
+    { 21280, 19456 },
+    { 20294, 20480 },
+    { 19358, 21504 },
+    { 18469, 22528 },
+    { 17624, 23552 },
+    { 16822, 24576 },
+    { 16060, 25600 },
+    { 15335, 26624 },
+    { 14646, 27648 },
+    { 13992, 28672 },
+    { 13369, 29696 },
+    { 12777, 30720 },
+    { 12214, 31744 },
+    { 11678, 32768 },
+    { 11168, 33792 },
+    { 10682, 34816 },
+    { 10220, 35840 },
+    { 9780, 36864 },
+    { 9361, 37888 },
+    { 8962, 38912 },
+    { 8582, 39936 },
+    { 8219, 40960 },
+    { 7874, 41984 },
+    { 7545, 43008 },
+    { 7231, 44032 },
+    { 6931, 45056 },
+    { 6646, 46080 },
+    { 6373, 47104 },
+    { 6113, 48128 },
+    { 5865, 49152 },
+    { 5628, 50176 },
+    { 5402, 51200 },
+    { 5185, 52224 },
+    { 4979, 53248 },
+    { 4782, 54272 },
+    { 4593, 55296 },
+    { 4413, 56320 },
+    { 4241, 57344 },
+    { 4076, 58368 },
+    { 3919, 59392 },
+    { 3768, 60416 },
+    { 3624, 61440 },
+    { 3486, 62464 },
+    { 3354, 63488 },
+    { 3227, 64512 },
+    { 3106, 65536 },
+    { 2990, 66560 },
+    { 2879, 67584 },
+    { 2773, 68608 },
+    { 2671, 69632 },
+    { 2573, 70656 },
+    { 2479, 71680 },
+    { 2390, 72704 },
+    { 2303, 73728 },
+    { 2221, 74752 },
+    { 2142, 75776 },
+    { 2066, 76800 },
+    { 1993, 77824 },
+    { 1923, 78848 },
+    { 1855, 79872 },
+    { 1791, 80896 },
+    { 1729, 81920 },
+    { 1669, 82944 },
+    { 1612, 83968 },
+    { 1557, 84992 },
+    { 1504, 86016 },
+    { 1453, 87040 },
+    { 1404, 88064 },
+    { 1357, 89088 },
+    { 1312, 90112 },
+    { 1269, 91136 },
+    { 1227, 92160 },
+    { 1187, 93184 },
+    { 1148, 94208 },
+    { 1111, 95232 },
+    { 1075, 96256 },
+    { 1040, 97280 },
+    { 1007, 98304 },
+    { 975, 99328 },
+    { 944, 100352 },
+    { 914, 101376 },
+    { 886, 102400 },
+    { 858, 103424 },
+    { 831, 104448 },
+    { 806, 105472 },
+    { 781, 106496 },
+    { 757, 107520 },
+    { 734, 108544 },
+    { 712, 109568 },
+    { 690, 110592 },
+    { 670, 111616 },
+    { 650, 112640 },
+    { 630, 113664 },
+    { 612, 114688 },
+    { 594, 115712 },
+    { 576, 116736 },
+    { 559, 117760 },
+    { 543, 118784 },
+    { 527, 119808 },
+    { 512, 120832 },
+    { 498, 121856 },
+    { 483, 122880 },
+    { 470, 123904 },
+    { 456, 124928 },
+    { 444, 125952 },
+    { 431, 126976 },
+    { 419, 128000 },
+    { 408, 129024 },
+    { 396, 130048 }
 };
 
 static int32_t pm8xxx_adc_map_linear(const struct pm8xxx_adc_map_pt *pts,
diff --git a/drivers/input/misc/pmic8xxx-pwrkey.c b/drivers/input/misc/pmic8xxx-pwrkey.c
index bc46807..9a1afef 100644
--- a/drivers/input/misc/pmic8xxx-pwrkey.c
+++ b/drivers/input/misc/pmic8xxx-pwrkey.c
@@ -35,6 +35,13 @@
 struct pmic8xxx_pwrkey {
 	struct input_dev *pwr;
 	int key_press_irq;
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+	int key_release_irq; 
+	bool press; 
+	struct device *dev;
+#endif
+/* SWISTOP */
 	const struct pm8xxx_pwrkey_platform_data *pdata;
 };
 
@@ -198,6 +205,23 @@ static int __devinit pmic8xxx_pwrkey_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, pwrkey);
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+	/* check power key status during boot */
+	err = pm8xxx_read_irq_stat(pdev->dev.parent, key_press_irq);
+	if (err < 0) {
+		dev_err(&pdev->dev, "reading irq status failed\n");
+		goto unreg_input_dev;
+	}
+	pwrkey->press = !!err;
+
+	if (pwrkey->press) {
+		input_report_key(pwrkey->pwr, KEY_POWER, 1);
+		input_sync(pwrkey->pwr);
+	}
+#endif
+/* SWISTOP */
+
 	err = request_any_context_irq(key_press_irq, pwrkey_press_irq,
 		IRQF_TRIGGER_RISING, "pmic8xxx_pwrkey_press", pwrkey);
 	if (err < 0) {
diff --git a/drivers/mfd/pm8018-core.c b/drivers/mfd/pm8018-core.c
index 31cb2a2..006f933 100644
--- a/drivers/mfd/pm8018-core.c
+++ b/drivers/mfd/pm8018-core.c
@@ -597,6 +597,24 @@ static int __devinit pm8018_probe(struct platform_device *pdev)
 	val &= PM8018_RESTART_REASON_MASK;
 	pr_info("PMIC Restart Reason: %s\n", pm8018_restart_reason[val]);
 
+/* SWISATRT */
+#ifdef CONFIG_SIERRA_AR7
+	val = 0x18;
+	rc = msm_ssbi_write(pdev->dev.parent, 0x1AC, &val, 1);
+	if (rc) {
+		pr_err("Cannot write 0x1AC reason rc=%d\n", rc);
+		goto err_read_rev;
+	}
+	
+	val = 0x02;
+	rc = msm_ssbi_write(pdev->dev.parent, 0x1A5, &val, 1);
+	if (rc) {
+		pr_err("Cannot write 0x1A5 reason rc=%d\n", rc);
+		goto err_read_rev;
+	}
+#endif
+/* SWISTOP */
+
 	rc = pm8018_add_subdevices(pdata, pmic);
 	if (rc) {
 		pr_err("Cannot add subdevices rc=%d\n", rc);
diff --git a/drivers/mtd/devices/msm_nand.c b/drivers/mtd/devices/msm_nand.c
index 677c6e6..e5669b3 100644
--- a/drivers/mtd/devices/msm_nand.c
+++ b/drivers/mtd/devices/msm_nand.c
@@ -6758,6 +6758,13 @@ int msm_nand_scan(struct mtd_info *mtd, int maxchips)
 		}
 	}
 
+/* SWISTART - Add support for Samsung flash */
+	if (supported_flash.flash_id == 0x1900aaec)
+	{
+		supported_flash.oobsize = 64;
+	}
+/* SWISTOP */
+
 	if (dev_found) {
 		(!interleave_enable) ? (i = 1) : (i = 2);
 		wide_bus       = supported_flash.widebus;
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e590b9c..cfc5c36 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -29,7 +29,11 @@
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
 #include <linux/module.h>
-
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#include "../../arch/arm/mach-msm/include/mach/rpm-regulator-9615.h"
+#endif
+/* SWISTOP */
 #define CREATE_TRACE_POINTS
 #include <trace/events/regulator.h>
 
@@ -53,6 +57,11 @@ static bool has_full_constraints;
 static bool board_wants_dummy_regulator;
 static int suppress_info_printing;
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static struct regulator *reg[RPM_VREG_ID_PM8018_MAX_REAL]={0};
+#endif
+/* SWISTOP */
 static struct dentry *debugfs_root;
 
 /*
@@ -97,6 +106,11 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,
 					  const char *supply_name);
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+int regulator_enable(struct regulator *regulator);
+#endif
+/* SWISTOP */
 static const char *rdev_get_name(struct regulator_dev *rdev)
 {
 	if (rdev->constraints && rdev->constraints->name)
@@ -604,6 +618,129 @@ static DEVICE_ATTR(suspend_standby_state, 0444,
 		regulator_suspend_standby_state_show, NULL);
 
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static ssize_t regulator_enable_set(struct device *dev,
+                 struct device_attribute *attr, const char *buf, size_t count)
+{
+  int err_info;
+  u8  val;
+  struct regulator_dev *rdev = dev_get_drvdata(dev);
+  int id = rdev->desc->id ;
+  
+  err_info = kstrtou8(buf, 0, &val);
+  if( err_info<0 )
+  {
+    pr_err("Regulator_enable_set: get val failed");
+    return err_info;
+  }
+
+
+  if (IS_ERR(reg[id]) || reg[id] == NULL)
+  {
+    reg[id]=regulator_get(NULL, rdev->desc->name);
+    pr_info("Regulator_enable_set:reg[%d]=%p \n",id,reg[id]);
+    if (IS_ERR(reg[id]) || reg[id] == NULL) 
+    {
+      pr_err("Error-Bad Function Input\n");
+      return -EFAULT;
+    }
+  }
+  if (val)
+  {
+    err_info = regulator_enable(reg[id]);
+  }
+else
+{
+  err_info = regulator_disable(reg[id]);
+}  
+  return count;
+}
+
+static ssize_t regulator_enable_get(struct device *dev,
+                  struct device_attribute *attr, char *buf)
+{
+  struct regulator_dev *rdev = dev_get_drvdata(dev);
+  ssize_t ret;
+
+  mutex_lock(&rdev->mutex);
+  ret=sprintf(buf, "%d\n", _regulator_is_enabled(rdev));
+  mutex_unlock(&rdev->mutex);
+  
+  return ret;
+}
+static DEVICE_ATTR(enable, 0644, regulator_enable_get, regulator_enable_set);
+
+static ssize_t regulator_voltage_set(struct device *dev,
+                   struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct regulator_dev *rdev = dev_get_drvdata(dev);
+  int  id = 0;
+  char temp_buf[50];
+  int  min_microvolts = 0;
+  int  max_microvolts = 0;
+  int  err_info;
+  int  filled = 0;
+  
+  if(count > 50)
+  {
+    pr_info("regulator_voltage_set: Not enough memory ");
+    return -ENOMEM;
+  }
+  
+  if (memcpy(temp_buf, buf, count)== NULL)
+  {
+    pr_err("regulator_voltage_set: copy from use space failed %s", buf );
+    return -EFAULT;
+  }
+  temp_buf[count]= '\0';
+
+  filled = sscanf(temp_buf, "%d %d", &min_microvolts, &max_microvolts);
+
+  /* check that user entered two numbers */
+  if (filled < 2 || min_microvolts < 0 || max_microvolts < min_microvolts)
+  {
+    pr_err("Error, correct format: 'echo \"min max\""
+          " > voltage. filled=%d, min=%d, max =%d \r\n", filled,min_microvolts,max_microvolts);
+    return -EINVAL;
+  } 
+  else
+  {
+    id = rdev->desc->id;
+    if (IS_ERR(reg[id]) || reg[id] == NULL) 
+    {
+      reg[id] = regulator_get(NULL, rdev->desc->name);
+      pr_info("regulator_voltage_set:reg[%d]=%p \n",id,reg[id]);
+      if (IS_ERR(reg[id]) || reg[id] == NULL) 
+      {
+        pr_err("Error-Bad Function Input\n");
+        return -EFAULT;
+      }
+    }
+   
+  	err_info = regulator_set_voltage(reg[id],min_microvolts, max_microvolts);
+   
+  }
+   
+  return count;
+}
+
+static ssize_t regulator_voltage_get(struct device *dev,
+                 struct device_attribute *attr, char *buf)
+{
+  struct regulator_dev *rdev = dev_get_drvdata(dev);
+  int id = rdev->desc->id;
+  ssize_t ret;
+
+  ret = sprintf(buf, "min_microvolts:%d max_microvolts:%d \n", reg[id]->min_uV,reg[id]->max_uV);
+
+  return ret;
+}
+static DEVICE_ATTR(voltage, 0644, regulator_voltage_get, regulator_voltage_set);
+
+#endif
+/* SWISTOP */
+
 /*
  * These are the only attributes are present for all regulators.
  * Other attributes are a function of regulator functionality.
@@ -2743,6 +2880,16 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 		return status;
 
 	/* constraints need specific supporting methods */
+/* SWISTART*/
+#ifdef CONFIG_SIERRA   
+  if (ops->enable)
+  {
+    status = device_create_file(dev, &dev_attr_enable);
+    if (status < 0)
+    return status;
+  } 
+#endif
+/* SWISTOP */
 	if (ops->set_voltage || ops->set_voltage_sel) {
 		status = device_create_file(dev, &dev_attr_min_microvolts);
 		if (status < 0)
@@ -2750,6 +2897,13 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 		status = device_create_file(dev, &dev_attr_max_microvolts);
 		if (status < 0)
 			return status;
+/* SWISTART*/
+#ifdef CONFIG_SIERRA  
+    status = device_create_file(dev, &dev_attr_voltage);
+    if (status < 0)
+    return status;
+#endif
+/* SWISTOP */
 	}
 	if (ops->set_current_limit) {
 		status = device_create_file(dev, &dev_attr_min_microamps);
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 7bc5c96..4e6a861 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -75,3 +75,6 @@ obj-$(CONFIG_USB_G_WEBCAM)	+= g_webcam.o
 obj-$(CONFIG_USB_G_NCM)		+= g_ncm.o
 obj-$(CONFIG_USB_G_ACM_MS)	+= g_acm_ms.o
 obj-$(CONFIG_USB_G_ANDROID)	+= g_android.o
+#SWISTART
+obj-$(CONFIG_SIERRA)		+=usb_netlink_base.o
+#SWISTOP
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
index 5b6d9da..9f8cf17 100644
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -16,6 +16,14 @@
  *
  */
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#define FEATURE_MORPHING
+//#define CONFIG_USB_DEBUG
+//#define DEBUG 1
+#endif
+/* SWISTOP */
+
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/fs.h>
@@ -199,11 +207,32 @@ static char manufacturer_string[256];
 static char product_string[256];
 static char serial_string[256];
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+/* Add support for Vendor Specific Strings */
+#define STRING_PRINUM_IDX	241
+#define STRING_PRIVER_IDX	243
+#define STRING_IMEI_IDX		242
+
+static char pri_number_string[256];
+static char pri_revision_string[256];
+static char imei_string[256];
+static int usb_det = 0;
+#endif /* SIERRA */
+/* SWISTOP */
+
 /* String Table */
 static struct usb_string strings_dev[] = {
 	[STRING_MANUFACTURER_IDX].s = manufacturer_string,
 	[STRING_PRODUCT_IDX].s = product_string,
 	[STRING_SERIAL_IDX].s = serial_string,
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	{STRING_PRINUM_IDX, pri_number_string, },
+	{STRING_PRIVER_IDX, pri_revision_string, },
+	{STRING_IMEI_IDX,   imei_string, },
+#endif
+/* SWISTOP */
 	{  }			/* end of list */
 };
 
@@ -212,8 +241,25 @@ static struct usb_gadget_strings stringtab_dev = {
 	.strings	= strings_dev,
 };
 
+/* SWISTART */
+/* Test code from case 00984853 */
+/* Win8 MBIM driver will ask for Manufacturer and product string with invalid lang ID 0x0000 */
+#ifdef CONFIG_SIERRA
+static struct usb_gadget_strings stringtab_dev1 = {
+	.language	= 0x0000,	/* unspecified */
+	.strings	= strings_dev,
+};
+#endif /* SIERRA */
+/* SWISTOP */
+
 static struct usb_gadget_strings *dev_strings[] = {
 	&stringtab_dev,
+/* SWISTART */
+/* Test code from case 00984853 */
+#ifdef CONFIG_SIERRA
+	&stringtab_dev1,
+#endif /* SIERRA */
+/* SWISTOP */
 	NULL,
 };
 
@@ -274,7 +320,14 @@ static void android_work(struct work_struct *data)
 	char *connected[2]    = { "USB_STATE=CONNECTED", NULL };
 	char *configured[2]   = { "USB_STATE=CONFIGURED", NULL };
 	char **uevent_envp = NULL;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* Set initial value to CONNECTED to ensure missing DISCONNECT is sent */
+	static enum android_device_state last_uevent=USB_CONNECTED, next_state;
+#else
 	static enum android_device_state last_uevent, next_state;
+#endif
+/* SWISTOP */
 	unsigned long flags;
 	int pm_qos_vote = -1;
 
@@ -1504,18 +1557,96 @@ struct mass_storage_function_config {
 static int mass_storage_function_init(struct android_usb_function *f,
 					struct usb_composite_dev *cdev)
 {
-	struct android_dev *dev = cdev_to_android_dev(cdev);
 	struct mass_storage_function_config *config;
 	struct fsg_common *common;
 	int err;
+#ifndef CONFIG_SIERRA
+	struct android_dev *dev = cdev_to_android_dev(cdev);
 	int i;
 	const char *name[2];
+#endif
 
 	config = kzalloc(sizeof(struct mass_storage_function_config),
 								GFP_KERNEL);
 	if (!config)
 		return -ENOMEM;
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	config->fsg.can_stall = 1;
+	config->fsg.nluns = swoc_en + sd_en;
+	pr_info("%s:Number of LUNs = %d\n",__func__,
+		config->fsg.nluns );
+
+	switch	(config->fsg.nluns) {
+	case 2:
+		/*case sd + swoc*/
+		config->fsg.luns[0].removable = 1;
+		config->fsg.luns[1].removable = 1;
+		config->fsg.luns[1].cdrom = 1;
+		break;
+
+	case 1:
+		config->fsg.luns[0].removable = 1;
+		config->fsg.luns[0].cdrom = swoc_en;
+		break;
+
+	default:
+		/*default set it to one LUN to prevent crash
+		 * if somebody enables Mass storage
+		 */
+		config->fsg.nluns = 1;
+		pr_info("%s:Setting default  = %d\n",__func__,
+				config->fsg.nluns );
+		config->fsg.luns[0].removable = 1;
+		break;
+	}
+
+	common = fsg_common_init(NULL, cdev, &config->fsg);
+	if (IS_ERR(common)) {
+		kfree(config);
+		return PTR_ERR(common);
+	}
+
+	/*defer creation of file until bind function is called*/
+	switch (config->fsg.nluns) {
+	case 2:
+		/*case sd + swoc*/
+		err = sysfs_create_link(&f->dev->kobj,
+				&common->luns[0].dev.kobj,
+				"lun");
+		if (err ) {
+			fsg_common_release(&common->ref);
+			kfree(config);
+			return err;
+		}
+
+		err = sysfs_create_link(&f->dev->kobj,
+			&common->luns[1].dev.kobj,
+			"cdlun");
+		if (err ) {
+		fsg_common_release(&common->ref);
+		kfree(config);
+		return err;
+		}
+		break;
+
+	case 1:
+		err = sysfs_create_link(&f->dev->kobj,
+				&common->luns[0].dev.kobj,
+				swoc_en ? "cdlun" : "lun");
+		if (err ) {
+			fsg_common_release(&common->ref);
+			kfree(config);
+			return err;
+		}
+		break;
+
+	default:
+		break;
+	}
+#else
+
 	config->fsg.nluns = 1;
 	name[0] = "lun";
 	if (dev->pdata && dev->pdata->cdrom) {
@@ -1542,9 +1673,12 @@ static int mass_storage_function_init(struct android_usb_function *f,
 			goto error;
 	}
 
+#endif /* SIERRA */
+/* SWISTOP */
 	config->common = common;
 	f->config = config;
 	return 0;
+#ifndef CONFIG_SIERRA
 error:
 	for (; i > 0 ; i--)
 		sysfs_remove_link(&f->dev->kobj, name[i-1]);
@@ -1552,6 +1686,7 @@ error:
 	fsg_common_release(&common->ref);
 	kfree(config);
 	return err;
+#endif
 }
 
 static void mass_storage_function_cleanup(struct android_usb_function *f)
@@ -1564,6 +1699,27 @@ static int mass_storage_function_bind_config(struct android_usb_function *f,
 						struct usb_configuration *c)
 {
 	struct mass_storage_function_config *config = f->config;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+    int err;
+    if( !f->config)
+    {
+        pr_info("\n%s:Init if NULL", __func__ );
+
+        /*late init of mass storage figure out number of LUN's*/
+        err = mass_storage_function_init(f,c->cdev);
+        if( err )
+        {
+            pr_err("%s: mass_storage_function_init failed error=%d for Product = %s", __func__,
+                                err, product_string);
+            return err;
+        }
+        pr_info("%s: Init successfull for Product = %s", __func__,
+                                    product_string);
+    }
+    config = f->config;
+#endif /* SIERRA */
+/* SWISTOP */
 	return fsg_bind_config(c->cdev, c, config->common);
 }
 
@@ -1598,7 +1754,11 @@ static struct device_attribute *mass_storage_function_attributes[] = {
 
 static struct android_usb_function mass_storage_function = {
 	.name		= "mass_storage",
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	.init		= mass_storage_function_init,
+#endif /* SIERRA */
+/* SWISTOP */
 	.cleanup	= mass_storage_function_cleanup,
 	.bind_config	= mass_storage_function_bind_config,
 	.attributes	= mass_storage_function_attributes,
@@ -1973,6 +2133,151 @@ static ssize_t remote_wakeup_store(struct device *pdev,
 
 	return size;
 }
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static ssize_t self_powered_show(struct device *pdev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	struct android_configuration *conf;
+
+	/*
+	 * Show the wakeup attribute of the first configuration,
+	 * since all configurations have the same wakeup attribute
+	 */
+	if (dev->configs_num == 0)
+		return 0;
+	conf = list_entry(dev->configs.next,
+			  struct android_configuration,
+			  list_item);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			!!(conf->usb_config.bmAttributes &
+				USB_CONFIG_ATT_SELFPOWER));
+}
+
+static ssize_t self_powered_store(struct device *pdev,
+		struct device_attribute *attr, const char *buff, size_t size)
+{
+    struct android_dev *dev = dev_get_drvdata(pdev);
+    struct android_configuration *conf;
+	int enable = 0;
+
+	sscanf(buff, "%d", &enable);
+
+	pr_debug("android_usb: %s self_powered\n",
+			enable ? "ON" : "OFF");
+
+    list_for_each_entry(conf, &dev->configs, list_item)
+	if (enable)
+		conf->usb_config.bmAttributes |= USB_CONFIG_ATT_SELFPOWER;
+	else
+		conf->usb_config.bmAttributes &= ~USB_CONFIG_ATT_SELFPOWER;
+
+	return size;
+}
+static ssize_t swoc_en_show(struct device *pdev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n",swoc_en);
+}
+static ssize_t swoc_en_store(struct device *pdev,
+		struct device_attribute *attr, const char *buff, size_t size)
+{
+	int enable = 0;
+
+	sscanf(buff, "%d", &enable);
+
+	pr_err("android_usb: %s swoc\n",
+			enable ? "ON" : "OFF");
+
+	if (enable)
+		swoc_en = 1;
+	else
+        swoc_en = 0;
+
+	return size;
+}
+static ssize_t sd_en_show(struct device *pdev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n",sd_en);
+}
+static ssize_t sd_en_store(struct device *pdev,
+		struct device_attribute *attr, const char *buff, size_t size)
+{
+	int enable = 0;
+
+	sscanf(buff, "%d", &enable);
+
+	pr_err("android_usb: %s SD card\n",
+			enable ? "ON" : "OFF");
+
+	if (enable)
+		sd_en = 1;
+	else
+        sd_en = 0;
+
+	return size;
+}
+static ssize_t usr_pid_show(struct device *pdev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n",usr_pid);
+}
+static ssize_t usr_pid_store(struct device *pdev,
+		struct device_attribute *attr, const char *buff, size_t size)
+{
+	int pid = 0;
+
+	sscanf(buff, "%d", &pid);
+
+	pr_info("android_usb: User process id = %d\n",
+			pid);
+    usr_pid = pid;
+
+    /*If switch_sig = 1, re-send the last sent cmd
+     * to correct pid*/
+    if( switch_sig == 1)
+    {
+        sendnlmsg((char*)&switch_cmd,sizeof(switch_cmd), usr_pid);
+        switch_sig = 0;
+        pr_info("android_usb: Sending msg = %d to pid = %d\n",(int)switch_cmd.MsgType,usr_pid);
+    }
+	return size;
+}
+static ssize_t usb_det_show(struct device *pdev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n",usb_det);
+}
+
+static ssize_t usb_det_store(struct device *pdev,
+		struct device_attribute *attr, const char *buff, size_t size)
+{
+	int usbdetect = 0;
+
+	sscanf(buff, "%d", &usbdetect);
+
+	pr_info("android_usb: USB_DET = %d\n",
+			usbdetect);
+	usb_det = usbdetect;
+
+	/* Changes based on 80-N5423-14 */
+	if (usb_det == 2)
+	{
+		msm9615_pm8xxx_gpio_mpp_init_swi();	
+		msm_otg_vddmin_init();
+	}
+ 	return size;
+}
+
+int msm_get_usb_det(void)
+{
+	return usb_det;
+}
+#endif /* SIERRA */
+/* SWISTOP */
 
 static ssize_t
 functions_show(struct device *pdev, struct device_attribute *attr, char *buf)
@@ -2196,6 +2501,13 @@ field ## _store(struct device *dev, struct device_attribute *attr,	\
 }									\
 static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
 
+/* SWISTART */
+/*
+  Needed to change the SSCANF Format string from "%255S" to "%255C"
+  in order to prevent stopping at first space char in strings "Sierra Wireless" and
+  "Aircard 770S"
+*/
+#ifndef CONFIG_SIERRA
 #define DESCRIPTOR_STRING_ATTR(field, buffer)				\
 static ssize_t								\
 field ## _show(struct device *dev, struct device_attribute *attr,	\
@@ -2215,6 +2527,27 @@ field ## _store(struct device *dev, struct device_attribute *attr,	\
 }									\
 static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
 
+#else
+#define DESCRIPTOR_STRING_ATTR(field, buffer)				\
+static ssize_t								\
+field ## _show(struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
+{									\
+	return snprintf(buf, PAGE_SIZE, "%s", buffer);			\
+}									\
+static ssize_t								\
+field ## _store(struct device *dev, struct device_attribute *attr,	\
+    const char *buf, size_t size)				\
+{									\
+	if (size >= sizeof(buffer)) return -EINVAL;			\
+	if (sscanf(buf, "%255c", buffer) == 1) {			\
+		return size;						\
+	}								\
+	return -1;							\
+}									\
+static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
+#endif
+/* SWISTOP */
 
 DESCRIPTOR_ATTR(idVendor, "%04x\n")
 DESCRIPTOR_ATTR(idProduct, "%04x\n")
@@ -2225,6 +2558,13 @@ DESCRIPTOR_ATTR(bDeviceProtocol, "%d\n")
 DESCRIPTOR_STRING_ATTR(iManufacturer, manufacturer_string)
 DESCRIPTOR_STRING_ATTR(iProduct, product_string)
 DESCRIPTOR_STRING_ATTR(iSerial, serial_string)
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+DESCRIPTOR_STRING_ATTR(iPriNumber, pri_number_string)
+DESCRIPTOR_STRING_ATTR(iPriRevision, pri_revision_string)
+DESCRIPTOR_STRING_ATTR(iImei, imei_string)
+#endif
+/* SWISTOP */
 
 static DEVICE_ATTR(functions, S_IRUGO | S_IWUSR, functions_show,
 						 functions_store);
@@ -2235,6 +2575,21 @@ static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
 static DEVICE_ATTR(remote_wakeup, S_IRUGO | S_IWUSR,
 		remote_wakeup_show, remote_wakeup_store);
 
+/* SIWSTART */
+#ifdef CONFIG_SIERRA
+static DEVICE_ATTR(self_powered, S_IRUGO | S_IWUSR,
+		self_powered_show, self_powered_store);
+static DEVICE_ATTR(swoc_en, S_IRUGO | S_IWUSR,
+        swoc_en_show, swoc_en_store);
+static DEVICE_ATTR(sd_en, S_IRUGO | S_IWUSR,
+        sd_en_show, sd_en_store);
+static DEVICE_ATTR(usr_pid, S_IRUGO | S_IWUSR,
+        usr_pid_show, usr_pid_store);
+static DEVICE_ATTR(usb_det, S_IRUGO | S_IWUSR,
+		usb_det_show, usb_det_store);
+#endif /* SIERRA */
+/* SWISTOP */
+
 static struct device_attribute *android_usb_attributes[] = {
 	&dev_attr_idVendor,
 	&dev_attr_idProduct,
@@ -2245,6 +2600,18 @@ static struct device_attribute *android_usb_attributes[] = {
 	&dev_attr_iManufacturer,
 	&dev_attr_iProduct,
 	&dev_attr_iSerial,
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	&dev_attr_iPriNumber,
+	&dev_attr_iPriRevision,
+	&dev_attr_iImei,
+	&dev_attr_self_powered,
+    &dev_attr_swoc_en,
+    &dev_attr_sd_en,
+    &dev_attr_usr_pid,
+    &dev_attr_usb_det,
+#endif
+/* SWISTOP */
 	&dev_attr_functions,
 	&dev_attr_enable,
 	&dev_attr_pm_qos,
@@ -2315,11 +2682,16 @@ static int android_bind(struct usb_composite_dev *cdev)
 	strings_dev[STRING_PRODUCT_IDX].id = id;
 	device_desc.iProduct = id;
 
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+	/* These Strings are now updated from SMEM */
 	/* Default strings - should be updated by userspace */
 	strlcpy(manufacturer_string, "Android",
 		sizeof(manufacturer_string) - 1);
 	strlcpy(product_string, "Android", sizeof(product_string) - 1);
 	strlcpy(serial_string, "0123456789ABCDEF", sizeof(serial_string) - 1);
+#endif
+/* SWISTOP */
 
 	id = usb_string_id(cdev);
 	if (id < 0)
@@ -2347,9 +2719,14 @@ static int android_usb_unbind(struct usb_composite_dev *cdev)
 {
 	struct android_dev *dev = cdev_to_android_dev(cdev);
 
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+	/* Revisit -SWI-TBD - Not sure if allowing this is an issue */
 	manufacturer_string[0] = '\0';
 	product_string[0] = '\0';
 	serial_string[0] = '0';
+#endif
+/* SWISTOP */
 	cancel_work_sync(&dev->work);
 	android_cleanup_functions(dev->functions);
 	return 0;
@@ -2404,9 +2781,22 @@ android_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *c)
 	spin_lock_irqsave(&cdev->lock, flags);
 	if (!dev->connected) {
 		dev->connected = 1;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+		pr_info("%s: Connected\n", __func__);
+#endif
+/* SWISTOP */
 		schedule_work(&dev->work);
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* Limit check to the actual config request */
+	} else if (c->bRequestType == 0 && c->bRequest == USB_REQ_SET_CONFIGURATION && cdev->config) {
+		pr_info("%s: Configured\n", __func__);
+#else
 	} else if (c->bRequest == USB_REQ_SET_CONFIGURATION &&
 						cdev->config) {
+#endif
+/* SWISTOP */
 		schedule_work(&dev->work);
 	}
 	spin_unlock_irqrestore(&cdev->lock, flags);
@@ -2429,6 +2819,11 @@ static void android_disconnect(struct usb_gadget *gadget)
 
 	spin_lock_irqsave(&cdev->lock, flags);
 	dev->connected = 0;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	pr_info("%s: Disconnected\n", __func__);
+#endif
+/* SWISTOP */
 	schedule_work(&dev->work);
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
@@ -2596,6 +2991,12 @@ static int __devinit android_probe(struct platform_device *pdev)
 	android_dev->disable_depth = 1;
 	android_dev->functions = supported_functions;
 	android_dev->configs_num = 0;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* Set initial value to CONNECTED to trigger inital DISCONNECT */
+	android_dev->sw_connected = 1; 
+#endif
+/* SWISTOP */
 	INIT_LIST_HEAD(&android_dev->configs);
 	INIT_WORK(&android_dev->work, android_work);
 	mutex_init(&android_dev->mutex);
diff --git a/drivers/usb/gadget/ci13xxx_msm_hsic.c b/drivers/usb/gadget/ci13xxx_msm_hsic.c
index 3863f85..57473ff 100644
--- a/drivers/usb/gadget/ci13xxx_msm_hsic.c
+++ b/drivers/usb/gadget/ci13xxx_msm_hsic.c
@@ -32,7 +32,7 @@
 #include <mach/msm_xo.h>
 #include <mach/rpm-regulator.h>
 
-#include "ci13xxx_udc.c"
+#include "ci13xxx_udc_msm9615.c"
 
 #define MSM_USB_BASE	(mhsic->regs)
 
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 3f123af..78ecfe0 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -20,6 +20,11 @@
 
 #include <linux/usb/composite.h>
 #include <asm/unaligned.h>
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#include <linux/usb/sierra_ududefs.h>
+#endif /* SIERRA */
+/* SWISTOP */
 
 /*
  * The code in this file is utility code, used to build a gadget driver
@@ -65,6 +70,81 @@ MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
 
 static char composite_manufacturer[50];
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+#define MSOS_STRING_SIGNATURE_SIZE 14
+#define MSOS_STRING_DESCRIPTOR_SIZE 18
+#define MSOS_SIGNATURE "MSFT100"
+#define MSOS_VENDOR_CODE       0x20
+#define MSOS_STRING_INDEX 0xEE
+#define USB_REQ_GET_MS_DESCRIPTOR	MSOS_VENDOR_CODE
+
+struct ms_os_string_desc {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  qwSignature[MSOS_STRING_SIGNATURE_SIZE];
+	__u8  bMS_VendorCode;
+	__u8  bPad;
+} __attribute__ ((packed));
+
+static struct ms_os_string_desc android_msos_decriptor = {
+	.bLength = MSOS_STRING_DESCRIPTOR_SIZE,
+	.bDescriptorType = USB_DT_STRING,
+	.qwSignature = {'M',0,'S',0,'F',0,'T',0,'1',0,'0',0,'0',0},
+	.bMS_VendorCode = MSOS_VENDOR_CODE,
+	.bPad = 0,
+};
+
+/* Microsoft Extended Configuration Descriptor Header Section */
+struct ms_ext_config_desc_header {
+	__le32	dwLength;
+	__le16	bcdVersion;
+	__le16	wIndex;
+	__u8	bCount;
+	__u8	bReserved[7];
+} __attribute__ ((packed));
+
+/* Microsoft Extended Configuration Descriptor Function Section */
+struct ms_ext_config_desc_function {
+	__u8	bFirstInterfaceNumber;
+	__u8	bInterfaceCount;
+	__u8	compatibleID[8];
+	__u8	subCompatibleID[8];
+	__u8	bReserved[6];
+} __attribute__ ((packed));
+
+/* MS Extended Configuration Descriptor Before Configuration Selection */
+static struct {
+	struct ms_ext_config_desc_header		header;
+	struct ms_ext_config_desc_function	function;
+} __attribute__((packed)) ms_ext_config_desc = {
+	.header = {
+		.dwLength = __constant_cpu_to_le32(sizeof(ms_ext_config_desc)),
+		.bcdVersion = __constant_cpu_to_le16(0x0100),
+		.wIndex = __constant_cpu_to_le16(0x0004),
+		.bCount = 1,
+		.bReserved = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	},
+	.function = {
+		.bFirstInterfaceNumber = 2,
+		.bInterfaceCount = 3,
+		.compatibleID = { 'A', 'L', 'T', 'R', 'C', 'F', 'G', 0x00 },
+		.subCompatibleID = { 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.bReserved = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	},
+};
+
+/* MS Extended Configuration Descriptor After Configuration Selection*/
+static struct ms_ext_config_desc_header ms_ext_config_desc_done = {
+	.dwLength = __constant_cpu_to_le32(sizeof(ms_ext_config_desc_done)),
+	.bcdVersion = __constant_cpu_to_le16(0x0100),
+	.wIndex = __constant_cpu_to_le16(0x0004),
+	.bCount = 0,
+	.bReserved = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+};
+#endif /* SIERRA and MORPHING */
+/* SWISTOP */
+
 /*-------------------------------------------------------------------------*/
 /**
  * next_ep_desc() - advance to the next EP descriptor
@@ -342,9 +422,22 @@ int usb_interface_id(struct usb_configuration *config,
 	unsigned id = config->next_interface_id;
 
 	if (id < MAX_CONFIG_INTERFACES) {
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+		/* Obtain Interface Number Desired 
+			 Allow existing next_interface_id to continue counting
+			 That is used elsewhere for total number of interfaces in configuration */
+		unsigned swi_id;
+		swi_id = ud_get_interface_number( function->name, config );
+		config->interface[swi_id] = function;
+		config->next_interface_id = id + 1;
+		return swi_id;
+#else
 		config->interface[id] = function;
 		config->next_interface_id = id + 1;
 		return id;
+#endif /* SIERRA */
+/* SWISTOP */
 	}
 	return -ENODEV;
 }
@@ -631,9 +724,17 @@ static int set_config(struct usb_composite_dev *cdev,
 	for (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {
 		struct usb_function	*f = c->interface[tmp];
 		struct usb_descriptor_header **descriptors;
-
+		
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+		/* Our Interface numbers are not sequential, allow continuing when one is not used */
+		if (!f)
+			continue;
+#else
 		if (!f)
 			break;
+#endif /* SIERRA */
+/* SWISTOP */
 
 		/*
 		 * Record which endpoints are used by the function. This is used
@@ -1084,6 +1185,11 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	u8				endp;
 	struct usb_configuration *c;
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+    int intf_cnt  = 0;
+#endif /*SIERRA*/
+/* SWISTOP */
 
 	if (w_length > USB_BUFSIZ)
 		return value;
@@ -1097,6 +1203,87 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	req->length = 0;
 	gadget->ep0->driver_data = cdev;
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	switch(ctrl->bRequestType & USB_TYPE_MASK) {
+    
+	case USB_TYPE_VENDOR:
+		/*Handle vendor specific request here*/
+		switch( ctrl->bRequest ) {
+
+		case UD_SWI_SETUP_REQ_GET_DEV_SWOC_INFO:
+		case UD_SWI_SETUP_REQ_SET_DEV_SWOC_MODE:
+			/*Intercept a Vendor specific command for mass storage. 
+			* Find the interface number*/
+			for(intf_cnt=0; intf_cnt<MAX_CONFIG_INTERFACES; intf_cnt++ ) {
+				f  = cdev->config->interface[intf_cnt];
+				if( f ) {
+					if (!strcmp(cdev->config->interface[intf_cnt]->name,"mass_storage")) {
+						f = cdev->config->interface[intf_cnt];
+							break;
+					}
+				}
+			}
+			if (f && f->setup)
+				value = f->setup(f, ctrl);
+			break;
+
+#if defined(FEATURE_MORPHING)
+		case USB_REQ_GET_MS_DESCRIPTOR:
+			if ( cdev->desc.bNumConfigurations > 1 )
+			{  
+				/* Handle MS OS descriptor or Identity Morphing */
+				if ( (ctrl->bRequestType & USB_DIR_IN) && (w_index == 4) ) {
+					DBG(cdev, "MS request: %d index: %d value: %d length: %d\n",
+									ctrl->bRequest, w_index, w_value, w_length);
+          
+					if (cdev->config) {
+						value = (w_length < sizeof(ms_ext_config_desc_done) ?
+								w_length : sizeof(ms_ext_config_desc_done));
+						memcpy(req->buf, (const void *)&ms_ext_config_desc_done, value);
+					} else {
+						/* Update First Interface # and Number of Interfaces */
+						uint i;
+						list_for_each_entry(c, &cdev->configs, list) {
+							if (c->bConfigurationValue == 1) {            
+								ms_ext_config_desc.function.bInterfaceCount = c->next_interface_id;          
+								f = list_first_entry(&c->functions, struct usb_function, list);
+								for (i = 0 ; i < MAX_CONFIG_INTERFACES ; i++ )
+								{
+									if ( f == c->interface[i] )
+									{
+										ms_ext_config_desc.function.bFirstInterfaceNumber = i;
+										break;
+									}
+								}
+								break;
+							}
+						}
+						value = (w_length < sizeof(ms_ext_config_desc) ?
+								w_length : sizeof(ms_ext_config_desc));
+						memcpy(req->buf, (const void *)&ms_ext_config_desc, value);
+					}
+				}
+			}
+			break;
+#endif /* FEATURE_MORPHING */
+    
+		default:
+			VDBG(cdev,
+				"unknown vendor control req%02x.%02x v%04x i%04x l%d\n",
+				ctrl->bRequestType, ctrl->bRequest,
+				w_value, w_index, w_length);
+			break;
+    
+		}
+		break;
+ 
+	case USB_TYPE_STANDARD:
+	case USB_TYPE_CLASS:
+	default:
+#endif /*SIERRA*/
+/* SWISTOP */
+
 	switch (ctrl->bRequest) {
 
 	/* we handle all standard USB descriptors */
@@ -1155,6 +1342,18 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 						USB_DT_OTG);
 			break;			
 		case USB_DT_STRING:
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+			if ( (cdev->desc.bNumConfigurations > 1) &&
+					((w_value & 0xff) == MSOS_STRING_INDEX) )
+			{
+				value = (w_length < sizeof(android_msos_decriptor)
+									? w_length : sizeof(android_msos_decriptor));
+				memcpy(req->buf, (const void *)&android_msos_decriptor, value);
+				break;
+			}
+#endif /* SIERRA */
+/* SWISTOP */		
 			value = get_string(cdev, req->buf,
 					w_index, w_value & 0xff);
 			if (value >= 0)
@@ -1333,6 +1532,12 @@ unknown:
 
 		goto done;
 	}
+	
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+    } /*bRequestType & USB_TYPE_MASK*/
+#endif /*SIERRA*/
+/* SWISTOP */
 
 	/* respond with data transfer before status phase? */
 	if (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {
diff --git a/drivers/usb/gadget/f_acm.c b/drivers/usb/gadget/f_acm.c
index cc151cb..2fed8a0 100644
--- a/drivers/usb/gadget/f_acm.c
+++ b/drivers/usb/gadget/f_acm.c
@@ -179,7 +179,14 @@ static int acm_port_disconnect(struct f_acm *acm)
 /* notification endpoint uses smallish and infrequent fixed-size messages */
 
 #define GS_LOG2_NOTIFY_INTERVAL		5	/* 1 << 5 == 32 msec */
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+/* Work around issue where driver needs zero length packet if interrupt packet is at MAX size */
+#define GS_NOTIFY_MAXPACKET		10 + 2	/* notification + 2 bytes + 2 spares */
+#else
 #define GS_NOTIFY_MAXPACKET		10	/* notification + 2 bytes */
+#endif
+/* SWISTOP */
 
 /* interface and class descriptors: */
 
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index ff362d5..b79f7d4 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -220,7 +220,12 @@
 #include <linux/usb/composite.h>
 
 #include "gadget_chips.h"
-
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#include <linux/usb/sierra_ududefs.h>
+#include "usb_netlink_base.h"
+#endif /* SIERRA */
+/* SWISTOP */
 
 /*------------------------------------------------------------------------*/
 
@@ -241,6 +246,19 @@ static int csw_hack_sent;
 #endif
 /*-------------------------------------------------------------------------*/
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static int swoc_en;
+static int sd_en;
+static int usr_pid;
+static ud_msg_notify switch_cmd;
+static int switch_sig = 0;
+
+/*SCSI commands we recognize */
+#define SC_GET_CONFIG	0x46
+#endif /* SIERRA */
+/* SWISTOP */
+
 struct fsg_dev;
 struct fsg_common;
 
@@ -525,7 +543,110 @@ static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
 	wakeup_thread(common);
 	spin_unlock(&common->lock);
 }
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+/*netlink for switching cdrom to ecm */
+static int vendor_setup_req(struct fsg_dev *fsg,
+                           const struct usb_ctrlrequest *ctrl)
+
+{
+    char buf[60] ;
+    char *pbuf = buf;
+    struct usb_request                  *req = fsg->common->ep0req; 
+    int                                 value = -EOPNOTSUPP;
+    u16                                 w_index = le16_to_cpu(ctrl->wIndex);
+    u16                                 w_value = le16_to_cpu(ctrl->wValue);
+    u16                                 w_length = le16_to_cpu(ctrl->wLength);
+    struct usb_cdrom_verfile_ioctl_type info;
+
+     /* Usually this just stores reply data in the pre-allocated ep0 buffer,
+     * but config change events will also reconfigure hardware. */
+
+    pr_info("[%s:%d]Got request: ReqType=%02X, Req=%02X\n", __FILE__, __LINE__, ctrl->bRequestType, ctrl->bRequest);
+    pr_info("[%s:%d]USB req len=%u actual=%u ptr=%p\n", __FILE__, __LINE__, req->length, req->actual,req->buf);
+	switch (ctrl->bRequest) {
+		case UD_SWI_SETUP_REQ_GET_DEV_SWOC_INFO:
+			if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_VENDOR |
+									 USB_RECIP_DEVICE))
+                    break;
+			if (w_index != 0 || w_value != 0) {
+                value = -EDOM;
+				break;
+			}
+			if (w_length > 0x3c) {
+                value = -EOVERFLOW;
+                break;
+			}
+            value = w_length;
+
+            getcdromverinfo(&info);
+            memset(buf, 0x00, sizeof(buf));
+
+			memcpy(++pbuf, &info.os1_sipc, sizeof(info.os1_sipc));
+			pbuf = pbuf + sizeof(info.os1_sipc);
+			memcpy(pbuf, &info.os1_siver, sizeof(info.os1_siver));
+			pbuf = pbuf + sizeof(info.os1_siver);
+			memcpy(pbuf, &info.os2_sipc, sizeof(info.os2_sipc));
+			pbuf = pbuf + sizeof(info.os2_sipc);
+			memcpy(pbuf, &info.os2_siver, sizeof(info.os2_siver));
+			pbuf = pbuf + sizeof(info.os2_siver);
+			memcpy(pbuf, &info.os3_sipc, sizeof(info.os3_sipc));
+			pbuf = pbuf + sizeof(info.os3_sipc);
+			memcpy(pbuf, &info.os3_siver, sizeof(info.os3_siver));
+			pbuf = pbuf + sizeof(info.os3_siver);
+			memcpy(pbuf, &info.os4_sipc, sizeof(info.os4_sipc));
+			pbuf = pbuf + sizeof(info.os4_sipc);
+			memcpy(pbuf, &info.os4_siver, sizeof(info.os4_siver));
+			pbuf = pbuf + sizeof(info.os4_siver);
+			memcpy(pbuf, &info.cdpc, sizeof(info.cdpc));
+			pbuf = pbuf + sizeof(info.cdpc);
+			memcpy(pbuf, &info.cd_version, sizeof(info.cd_version) - 1);
+
+			memcpy(req->buf, buf, 60);
+            pr_info("[%s:%d]swoc values sent os1=(%u,%u), os2=(%u,%u),\
+os3=(%u%u) return value = %u\n", __FILE__, __LINE__,
+info.os1_sipc,info.os1_siver,
+info.os2_sipc,info.os2_siver,
+info.os3_sipc,info.os3_siver,
+value );
+			break;
 
+		case UD_SWI_SETUP_REQ_SET_DEV_SWOC_MODE:
+			if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR |
+									  USB_RECIP_DEVICE))
+                break;
+			if (w_index != 0 || w_length != 0) {
+                value = -EDOM;
+                break;
+			}
+			if (1 == w_value ){
+				switch_sig =1;
+				switch_cmd.MsgType = CDROM_TO_ECM;
+                if( usr_pid > 0 )
+                    switch_sig = 0;
+                sendnlmsg((char*)&switch_cmd, sizeof(switch_cmd), usr_pid );
+                pr_info("\n%s: SWI__TRU-Install_TBD switch to network mode", __func__ );
+			}
+            if( 0 == w_value ){
+                switch_sig =1;
+                switch_cmd.MsgType = ECM_TO_CDROM;
+                if( usr_pid > 0 )
+                    switch_sig = 0;
+                sendnlmsg((char*)&switch_cmd, sizeof(switch_cmd), usr_pid );
+                pr_info("\n%s: SWI__TRU-Install_TBD switch to CDROM mode", __func__ );
+            }           
+			value = 0;
+			break;
+		 default:
+			VDBG(fsg,
+					"unknown control req %02x.%02x v%04x i%04x l%u\n",
+					ctrl->bRequestType, ctrl->bRequest,
+					w_value, w_index, le16_to_cpu(ctrl->wLength));
+		 }
+        return value;
+}
+#endif /* SIERRA */
+/* SWISTOP */
 static int fsg_setup(struct usb_function *f,
 		     const struct usb_ctrlrequest *ctrl)
 {
@@ -543,6 +664,13 @@ static int fsg_setup(struct usb_function *f,
 	req->length = 0;
 	dump_msg(fsg, "ep0-setup", (u8 *) ctrl, sizeof(*ctrl));
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+    if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR)
+        return vendor_setup_req(fsg, ctrl);
+#endif /* SIERRA */
+/* SWISTOP */
+
 	switch (ctrl->bRequest) {
 
 	case US_BULK_RESET_REQUEST:
@@ -637,6 +765,20 @@ static bool start_out_transfer(struct fsg_common *common, struct fsg_buffhd *bh)
 		       bh->outreq, &bh->outreq_busy, &bh->state);
 	return true;
 }
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static int do_get_config( struct fsg_common *common, struct fsg_buffhd *bh)
+{
+    u8		*buf = (u8 *) bh->buf;
+    memset(buf,0,4);
+    bh->inreq->length = 4;
+    bh->state = BUF_STATE_FULL;
+    bh->inreq->zero = 0;
+    start_transfer(common->fsg,common->fsg->bulk_in,bh->inreq,&bh->inreq_busy,&bh->state);
+    return 0;
+}
+#endif /* SIERRA */
+/* SWISTOP */
 
 static int sleep_thread(struct fsg_common *common)
 {
@@ -1308,7 +1450,63 @@ static int do_read_toc(struct fsg_common *common, struct fsg_buffhd *bh)
 		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
 		return -EINVAL;
 	}
-
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+    memset(buf, 0, 48);
+    buf[1] = 0x2e;
+    buf[2] = 1;
+    buf[3] = 1;
+    //A0
+    buf[4] = 1;
+    buf[5] = 0x14;
+    buf[6] = 0;           //tno = 0
+    buf[7] = 0xa0;  //point a0 a1 a2 01
+
+    buf[8] = 0;
+    buf[9] = 0;
+    buf[10] = 0;
+    buf[11] = 0;         //zero
+    buf[12] = 1;         //first track number
+    buf[13] = 0x20;  //dis type
+    buf[14] = 0;
+    //A1
+    buf[15] = 1;
+    buf[16] = 0x14;
+    buf[17] = 0;         //tno = 0
+    buf[18] = 0xa1;  //point a0 a1 a2 01       
+
+    buf[19] = 0;         //ATime
+    buf[20] = 0x20;
+    buf[21] = 0x44;
+    buf[22] = 0x72;  //zero
+    buf[23] = 0x01; //last track number
+    buf[24] = 0x76; //0
+    buf[25] = 0x65; //0                         
+    //A2
+    buf[26] = 1;
+    buf[27] = 0x14;
+    buf[28] = 0x33;   //should always tno = 0
+    buf[29] = 0xa2;  //point a0 a1 a2 01
+
+    buf[30] = 0x30;
+    buf[31] = 0x20;
+    buf[32] = 0x36;
+
+    store_cdrom_address(&buf[33], msf, curlun->num_sectors);
+    //           buf[33] = ;
+    //           buf[34] = ;           //START postion of lead out
+    //           buf[35] = ;
+    //           buf[36] = ;
+
+    //01
+    buf[37] = 1;
+    buf[38] = 0x14;
+    buf[39] = 0;         //tno = 0
+    buf[40] = 0x01;  //point a0 a1 a2 01
+
+    buf[46] = 2;
+    return 48;
+#else
 	memset(buf, 0, 20);
 	buf[1] = (20-2);		/* TOC data length */
 	buf[2] = 1;			/* First track number */
@@ -1321,6 +1519,8 @@ static int do_read_toc(struct fsg_common *common, struct fsg_buffhd *bh)
 	buf[14] = 0xAA;			/* Lead-out track number */
 	store_cdrom_address(&buf[16], msf, curlun->num_sectors);
 	return 20;
+#endif /* SIERRA */
+/* SWISTOP */
 }
 
 static int do_mode_sense(struct fsg_common *common, struct fsg_buffhd *bh)
@@ -1465,6 +1665,16 @@ static int do_start_stop(struct fsg_common *common)
 	fsg_lun_close(curlun);
 	up_write(&common->filesem);
 	down_read(&common->filesem);
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+    switch_sig = 1;
+    switch_cmd.MsgType = CDROM_TO_ECM;
+    if( usr_pid > 0 )
+        switch_sig = 0;
+    sendnlmsg((char*)&switch_cmd,sizeof(switch_cmd),usr_pid);
+    pr_info("\n%s: SWI__TRU-Install_TBD switch to network mode", __func__ );
+#endif /* SIERRA */
+/* SWISTOP */
 
 	return common->ops && common->ops->post_eject
 		? min(0, common->ops->post_eject(common, curlun,
@@ -1964,7 +2174,17 @@ static int do_scsi_command(struct fsg_common *common)
 
 	down_read(&common->filesem);	/* We're using the backing file */
 	switch (common->cmnd[0]) {
-
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	case SC_GET_CONFIG:
+		common->data_size_from_cmnd = common->cmnd[4];
+		reply = check_command(common, 6, DATA_DIR_TO_HOST,
+				(1<<4), 0,
+				"GET CONFIG");
+            if (reply == 0)
+                reply = do_get_config(common, bh);
+#endif /* SIERRA */
+/* SWISTOP */
 	case INQUIRY:
 		common->data_size_from_cmnd = common->cmnd[4];
 		reply = check_command(common, 6, DATA_DIR_TO_HOST,
@@ -2889,6 +3109,13 @@ buffhds_first_it:
 			i = 0x0399;
 		}
 	}
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+    snprintf(common->inquiry_string, sizeof common->inquiry_string,
+		 "%-8s%-16s%4s", "Aircard",
+          /* Assume product name dependent on the first LUN */
+         "TRU-Install","2.31");
+#else
 	snprintf(common->inquiry_string, sizeof common->inquiry_string,
 		 "%-8s%-16s%04x", cfg->vendor_name ?: "Linux",
 		 /* Assume product name dependent on the first LUN */
@@ -2896,6 +3123,8 @@ buffhds_first_it:
 				     ? "File-Stor Gadget"
 				     : "File-CD Gadget"),
 		 i);
+#endif /* SIERRA */
+/* SWISTOP */
 
 	/*
 	 * Some peripheral controllers are known not to be able to
diff --git a/drivers/usb/gadget/f_mbim.c b/drivers/usb/gadget/f_mbim.c
index 626aef5..b1f384e 100644
--- a/drivers/usb/gadget/f_mbim.c
+++ b/drivers/usb/gadget/f_mbim.c
@@ -590,6 +590,14 @@ static void fmbim_ctrl_response_available(struct f_mbim *dev)
 	event->wValue = cpu_to_le16(0);
 	event->wIndex = cpu_to_le16(dev->ctrl_id);
 	event->wLength = cpu_to_le16(0);
+
+/* SWISTART */
+/* Fix the wrong notification response packet length */
+#ifdef CONFIG_SIERRA
+	req->length = sizeof *event;
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
+
 	spin_unlock_irqrestore(&dev->lock, flags);
 
 	ret = usb_ep_queue(dev->not_port.notify,
@@ -755,8 +763,6 @@ static void mbim_do_notify(struct f_mbim *mbim)
 {
 	struct usb_request		*req = mbim->not_port.notify_req;
 	struct usb_cdc_notification	*event;
-	struct usb_composite_dev	*cdev = mbim->cdev;
-	__le32				*data;
 	int				status;
 
 	pr_debug("notify_state: %d", mbim->not_port.notify_state);
@@ -783,6 +789,14 @@ static void mbim_do_notify(struct f_mbim *mbim)
 			pr_debug("notify_response_avaliable: done");
 			return;
 		}
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+		/* Added to avoid wrong formatted notification */
+		event->bNotificationType = USB_CDC_NOTIFY_RESPONSE_AVAILABLE;
+		event->wLength = 0;
+		req->length = sizeof *event;
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 
 		spin_unlock(&mbim->lock);
 		status = usb_ep_queue(mbim->not_port.notify, req, GFP_ATOMIC);
@@ -793,36 +807,6 @@ static void mbim_do_notify(struct f_mbim *mbim)
 		}
 
 		return;
-
-	case NCM_NOTIFY_CONNECT:
-		event->bNotificationType = USB_CDC_NOTIFY_NETWORK_CONNECTION;
-		if (mbim->is_open)
-			event->wValue = cpu_to_le16(1);
-		else
-			event->wValue = cpu_to_le16(0);
-		event->wLength = 0;
-		req->length = sizeof *event;
-
-		pr_info("notify connect %s\n",
-			mbim->is_open ? "true" : "false");
-		mbim->not_port.notify_state = NCM_NOTIFY_RESPONSE_AVAILABLE;
-		break;
-
-	case NCM_NOTIFY_SPEED:
-		event->bNotificationType = USB_CDC_NOTIFY_SPEED_CHANGE;
-		event->wValue = cpu_to_le16(0);
-		event->wLength = cpu_to_le16(8);
-		req->length = NCM_STATUS_BYTECOUNT;
-
-		/* SPEED_CHANGE data is up/down speeds in bits/sec */
-		data = req->buf + sizeof *event;
-		data[0] = cpu_to_le32(mbim_bitrate(cdev->gadget));
-		data[1] = data[0];
-
-		pr_info("notify speed %d\n",
-			mbim_bitrate(cdev->gadget));
-		mbim->not_port.notify_state = NCM_NOTIFY_CONNECT;
-		break;
 	}
 
 	event->bmRequestType = 0xA1;
@@ -848,6 +832,9 @@ static void mbim_do_notify(struct f_mbim *mbim)
 /*
  * Context: mbim->lock held
  */
+/* SWISTART*/
+/* To fix the yellow bang error code 10 issue, this function is not called anymore */
+#ifndef CONFIG_SIERRA
 static void mbim_notify(struct f_mbim *mbim)
 {
 	/*
@@ -860,6 +847,8 @@ static void mbim_notify(struct f_mbim *mbim)
 	mbim->not_port.notify_state = NCM_NOTIFY_SPEED;
 	mbim_do_notify(mbim);
 }
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 
 static void mbim_notify_complete(struct usb_ep *ep, struct usb_request *req)
 {
@@ -1393,9 +1382,15 @@ static int mbim_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 		}
 
 		mbim->data_alt_int = alt;
+
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+/* To work around the yellow bang error code 10 issue when using compositions support identity morphing */
 		spin_lock(&mbim->lock);
-		mbim_notify(mbim);
+		mbim->not_port.notify_state = NCM_NOTIFY_RESPONSE_AVAILABLE;
 		spin_unlock(&mbim->lock);
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 	} else {
 		goto fail;
 	}
@@ -1488,6 +1483,13 @@ mbim_bind(struct usb_configuration *c, struct usb_function *f)
 	if (status < 0)
 		goto fail;
 	mbim->ctrl_id = status;
+
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	mbim->data_alt_int = 0;
+#endif
+/* SWISTOP */
+
 	mbim_iad_desc.bFirstInterface = status;
 
 	mbim_control_intf.bInterfaceNumber = status;
diff --git a/drivers/usb/gadget/f_qc_ecm.c b/drivers/usb/gadget/f_qc_ecm.c
index 0b41197..757f9fe 100644
--- a/drivers/usb/gadget/f_qc_ecm.c
+++ b/drivers/usb/gadget/f_qc_ecm.c
@@ -548,7 +548,7 @@ static int ecm_qc_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 				);
 			ecm->port.cdc_filter = DEFAULT_FILTER;
 			DBG(cdev, "activate ecm\n");
-			net = gether_qc_connect_name(&ecm->port, "ecm0");
+			net = gether_qc_connect_name(&ecm->port, "ecm0", true);
 			if (IS_ERR(net))
 				return PTR_ERR(net);
 
diff --git a/drivers/usb/gadget/f_qc_rndis.c b/drivers/usb/gadget/f_qc_rndis.c
index f86bf12..711ed8b 100644
--- a/drivers/usb/gadget/f_qc_rndis.c
+++ b/drivers/usb/gadget/f_qc_rndis.c
@@ -93,6 +93,7 @@ struct f_rndis_qc {
 	struct usb_ep			*notify;
 	struct usb_request		*notify_req;
 	atomic_t			notify_count;
+	struct data_port		bam_port;
 };
 
 static inline struct f_rndis_qc *func_to_rndis_qc(struct usb_function *f)
@@ -116,8 +117,11 @@ static unsigned int rndis_qc_bitrate(struct usb_gadget *g)
 #define RNDIS_QC_LOG2_STATUS_INTERVAL_MSEC	5	/* 1 << 5 == 32 msec */
 #define RNDIS_QC_STATUS_BYTECOUNT		8	/* 8 bytes data */
 
-/* currently only one rndis instance is supported */
-#define RNDIS_QC_NO_PORTS					1
+/* currently only one rndis instance is supported - port
+ * index 0.
+ */
+#define RNDIS_QC_NO_PORTS				1
+#define RNDIS_QC_ACTIVE_PORT				0
 
 /* default max packets per tarnsfer value */
 #define DEFAULT_MAX_PKT_PER_XFER			15
@@ -398,7 +402,6 @@ static inline void rndis_qc_unlock(atomic_t *excl)
 }
 
 /* MSM bam support */
-static struct data_port rndis_qc_bam_port;
 
 static int rndis_qc_bam_setup(void)
 {
@@ -417,12 +420,12 @@ static int rndis_qc_bam_connect(struct f_rndis_qc *dev)
 {
 	int ret;
 
-	rndis_qc_bam_port.cdev = dev->port.func.config->cdev;
-	rndis_qc_bam_port.in = dev->port.in_ep;
-	rndis_qc_bam_port.out = dev->port.out_ep;
+	dev->bam_port.cdev = dev->port.func.config->cdev;
+	dev->bam_port.in = dev->port.in_ep;
+	dev->bam_port.out = dev->port.out_ep;
 
 	/* currently we use the first connection */
-	ret = bam_data_connect(&rndis_qc_bam_port, 0, 0);
+	ret = bam_data_connect(&dev->bam_port, 0, 0);
 	if (ret) {
 		pr_err("bam_data_connect failed: err:%d\n",
 				ret);
@@ -436,8 +439,8 @@ static int rndis_qc_bam_connect(struct f_rndis_qc *dev)
 
 static int rndis_qc_bam_disconnect(struct f_rndis_qc *dev)
 {
-	pr_info("dev:%p. %s Do nothing.\n",
-			dev, __func__);
+ 	pr_debug("dev:%p. %s Disconnect BAM.\n", dev, __func__);
+	bam_data_disconnect(&dev->bam_port, 0);
 
 	return 0;
 }
@@ -695,7 +698,7 @@ static int rndis_qc_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 		rndis->port.cdc_filter = 0;
 
 		DBG(cdev, "RNDIS RX/TX early activation ...\n");
-		net = gether_qc_connect_name(&rndis->port, "rndis0");
+		net = gether_qc_connect_name(&rndis->port, "rndis0", false);
 		if (IS_ERR(net))
 			return PTR_ERR(net);
 
@@ -729,6 +732,20 @@ static void rndis_qc_disable(struct usb_function *f)
 	rndis->notify->driver_data = NULL;
 }
 
+static void rndis_qc_suspend(struct usb_function *f)
+{
+	pr_debug("%s: rndis suspended\n", __func__);
+
+	bam_data_suspend(RNDIS_QC_ACTIVE_PORT);
+}
+
+static void rndis_qc_resume(struct usb_function *f)
+{
+	pr_debug("%s: rndis resumed\n", __func__);
+
+	bam_data_resume(RNDIS_QC_ACTIVE_PORT);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -1046,6 +1063,8 @@ rndis_qc_bind_config_vendor(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
 	rndis->port.func.set_alt = rndis_qc_set_alt;
 	rndis->port.func.setup = rndis_qc_setup;
 	rndis->port.func.disable = rndis_qc_disable;
+	rndis->port.func.suspend = rndis_qc_suspend;
+	rndis->port.func.resume = rndis_qc_resume;
 
 	_rndis_qc = rndis;
 
diff --git a/drivers/usb/gadget/f_rmnet.c b/drivers/usb/gadget/f_rmnet.c
index 4357e0d..5e900d2 100644
--- a/drivers/usb/gadget/f_rmnet.c
+++ b/drivers/usb/gadget/f_rmnet.c
@@ -23,8 +23,14 @@
 #include "gadget_chips.h"
 
 #define RMNET_NOTIFY_INTERVAL	5
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+/* Work around issue where driver needs zero length packet if interrupt packet is at MAX size */
+#define RMNET_MAX_NOTIFY_SIZE	( sizeof(struct usb_cdc_notification) + 2 )
+#else
 #define RMNET_MAX_NOTIFY_SIZE	sizeof(struct usb_cdc_notification)
-
+#endif
+/* SWISTOP */
 
 #define ACM_CTRL_DTR	(1 << 0)
 
@@ -49,8 +55,19 @@ struct f_rmnet {
 	struct list_head		cpkt_resp_q;
 	atomic_t			notify_count;
 	unsigned long			cpkts_len;
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+	struct work_struct  ctrl_reg_w;
+#endif /* SIERRA */
+/* SWISTOP */
 };
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+static struct workqueue_struct  *frmnet_wq;
+#endif /* SIERRA */
+/* SWISTOP */
+
 #define NR_RMNET_PORTS	3
 static unsigned int nr_rmnet_ports;
 static unsigned int no_ctrl_smd_ports;
@@ -542,6 +559,14 @@ static void frmnet_suspend(struct usb_function *f)
 	unsigned		port_num;
 	enum transport_type	dxport = rmnet_ports[dev->port_num].data_xport;
 
+/* SWISTART */
+/* QCT case 01085205 */
+#if defined(CONFIG_SIERRA)
+	struct rmnet_ctrl_pkt   *cpkt;
+	unsigned long		 flags;
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
+
 	pr_debug("%s: data xport: %s dev: %p portno: %d\n",
 		__func__, xport_to_str(dxport),
 		dev, dev->port_num);
@@ -563,6 +588,30 @@ static void frmnet_suspend(struct usb_function *f)
 		pr_err("%s: Un-supported transport: %s\n", __func__,
 				xport_to_str(dxport));
 	}
+
+/* SWISTART */
+/* Code provided by QCT case 01085205 
+ * If RESPONSE_AVAILABLE has been sent to host, but responses or indications haven't been read out by host side before 
+ * modem enters suspend state, the queue counter and the queue will be out of sync. Drop any pending packets in the 
+ * queue to resolve this issue, otherwise RmNet interface can't work properly after resume.
+ */
+#if defined(CONFIG_SIERRA)
+	/* Drop any pending packets */
+	spin_lock_irqsave(&dev->lock, flags);
+	while(!list_empty(&dev->cpkt_resp_q)) {
+		cpkt = list_first_entry(&dev->cpkt_resp_q, 
+								struct rmnet_ctrl_pkt, list);
+		pr_debug("%s: dev:%p port#%d Removing Pkt %p id %d\n",
+				 __func__, dev, dev->port_num, cpkt, *((char*)cpkt->buf + 7));
+		list_del(&cpkt->list);
+		rmnet_free_ctrl_pkt(cpkt);
+	}
+	atomic_set(&dev->notify_count, 0);
+	pr_debug("%s: dev: %p port#%d Cleared Counts\n", __func__,
+			 dev, dev->port_num);
+	spin_unlock_irqrestore(&dev->lock, flags);
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 }
 
 static void frmnet_resume(struct usb_function *f)
@@ -621,6 +670,54 @@ static void frmnet_disable(struct usb_function *f)
 	gport_rmnet_disconnect(dev);
 }
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+extern void frmnet_notify_complete(struct usb_ep *ep, struct usb_request *req);
+
+static int
+frmnet_bind_ep_req(struct usb_function *f)
+{
+	struct f_rmnet			*dev = func_to_rmnet(f);
+	int				ret = -ENODEV;
+	static int rmnet_gport_initialized = 0;
+
+	pr_info("Enter frmnet_bind_ep_req");
+
+	if( !rmnet_gport_initialized ) {
+		queue_work(frmnet_wq, &dev->ctrl_reg_w);
+		rmnet_gport_initialized = 1;
+	}
+
+	/* allocate notification request and buffer */
+	dev->notify_req = frmnet_alloc_req(dev->notify,
+				sizeof(struct usb_cdc_notification),
+				GFP_KERNEL);
+	if (IS_ERR(dev->notify_req)) {
+		pr_err("%s: unable to allocate memory for notify req\n",
+				__func__);
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	dev->notify_req->complete = frmnet_notify_complete;
+	dev->notify_req->context = dev;
+	pr_info("allocated notify ep request & request buffer\n");
+
+	return 0;
+
+fail:
+	pr_err("%s failed to allocate req, err %d\n", f->name, ret);
+	dev->notify->driver_data = NULL;
+	dev->notify = NULL;
+	dev->port.out->driver_data = NULL;
+	dev->port.out = NULL;
+	dev->port.in->driver_data = NULL;
+	dev->port.in = NULL;
+	return ret;
+}
+#endif /* SIERRA and FEATURE_MORPHING */
+/* SWISTOP */
+
 static int
 frmnet_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 {
@@ -631,6 +728,14 @@ frmnet_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 
 	pr_debug("%s:dev:%p port#%d\n", __func__, dev, dev->port_num);
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+  /* Allocate Request buffer and bind to EP now that config is assigned */
+	if (!dev->notify_req)
+		ret = frmnet_bind_ep_req(f);
+#endif /* SIERRA and FEATURE_MORPHING */
+/* SWISTOP */
+
 	if (dev->notify->driver_data) {
 		pr_debug("%s: reset port:%d\n", __func__, dev->port_num);
 		usb_ep_disable(dev->notify);
@@ -844,7 +949,13 @@ frmnet_cmd_complete(struct usb_ep *ep, struct usb_request *req)
 	}
 }
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+void frmnet_notify_complete(struct usb_ep *ep, struct usb_request *req)
+#else
 static void frmnet_notify_complete(struct usb_ep *ep, struct usb_request *req)
+#endif
+/* SWISTOP */
 {
 	struct f_rmnet *dev = req->context;
 	int status = req->status;
@@ -1018,6 +1129,11 @@ static int frmnet_bind(struct usb_configuration *c, struct usb_function *f)
 	dev->notify = ep;
 	ep->driver_data = cdev;
 
+/* SWISTART */
+/* 
+ Bind EP with Request Allocation after configuration selected
+*/
+#if !defined(CONFIG_SIERRA) || !defined(FEATURE_MORPHING)
 	dev->notify_req = frmnet_alloc_req(ep,
 				sizeof(struct usb_cdc_notification),
 				GFP_KERNEL);
@@ -1030,6 +1146,8 @@ static int frmnet_bind(struct usb_configuration *c, struct usb_function *f)
 
 	dev->notify_req->complete = frmnet_notify_complete;
 	dev->notify_req->context = dev;
+#endif /* SIERRA and FEATURE_MORPHING */
+/* SWISTOP */
 
 	ret = -ENOMEM;
 	f->descriptors = usb_copy_descriptors(rmnet_fs_function);
@@ -1083,7 +1201,11 @@ fail:
 		usb_free_descriptors(f->descriptors);
 	if (dev->notify_req)
 		frmnet_free_req(dev->notify, dev->notify_req);
+/* SWISTART */
+#if !defined(CONFIG_SIERRA) || !defined(FEATURE_MORPHING)
 ep_notify_alloc_fail:
+#endif /* SIERRA and FEATURE_MORPHING */
+/* SWISTOP */
 	dev->notify->driver_data = NULL;
 	dev->notify = NULL;
 ep_auto_notify_fail:
@@ -1173,8 +1295,28 @@ static void frmnet_cleanup(void)
 	no_data_hsic_ports = 0;
 	no_ctrl_hsuart_ports = 0;
 	no_data_hsuart_ports = 0;
+
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+	destroy_workqueue(frmnet_wq);
+#endif /* SIERRA */
+/* SWISTOP */
 }
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+/* 
+	Need to register the SMD ports but it cannot be done in the context
+	of the frmnet_set_alt function (interrupt handler)
+	Therefore we are using the work queue to get them registered
+*/
+static void frmnet_port_reg_work(struct work_struct *w)
+{
+	gsmd_ctrl_smd_port_reg();
+}
+#endif /* SIERRA */
+/* SWISTOP */
+
 static int frmnet_init_port(const char *ctrl_name, const char *data_name)
 {
 	struct f_rmnet			*dev;
@@ -1256,6 +1398,21 @@ static int frmnet_init_port(const char *ctrl_name, const char *data_name)
 	}
 	nr_rmnet_ports++;
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+	/* 
+		Need to establish a work queue to support registering rmnet QMI ports
+		over SMD after configuration selected to prevent collision with use by MBIM 
+	*/
+	frmnet_wq  = create_singlethread_workqueue("frmnet");
+	if (!frmnet_wq) {
+		pr_err("%s: Unable to create workqueue: frmnet\n", __func__);
+		return -ENOMEM;
+	}
+	INIT_WORK(&dev->ctrl_reg_w, frmnet_port_reg_work);
+#endif /* SIERRA */
+/* SWISTOP */
+
 	return 0;
 
 fail_probe:
diff --git a/drivers/usb/gadget/f_rndis.c b/drivers/usb/gadget/f_rndis.c
index 8c7295e..82ff934 100644
--- a/drivers/usb/gadget/f_rndis.c
+++ b/drivers/usb/gadget/f_rndis.c
@@ -412,9 +412,14 @@ static void rndis_response_available(void *_rndis)
 static void rndis_response_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct f_rndis			*rndis = req->context;
-	struct usb_composite_dev	*cdev = rndis->port.func.config->cdev;
+	struct usb_composite_dev	*cdev;
 	int				status = req->status;
 
+	if (!rndis->port.func.config || !rndis->port.func.config->cdev)
+		return;
+	else
+		cdev = rndis->port.func.config->cdev;
+
 	/* after TX:
 	 *  - USB_CDC_GET_ENCAPSULATED_RESPONSE (ep0/control)
 	 *  - RNDIS_RESPONSE_AVAILABLE (status/irq)
@@ -451,10 +456,15 @@ static void rndis_response_complete(struct usb_ep *ep, struct usb_request *req)
 static void rndis_command_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct f_rndis			*rndis = req->context;
-	struct usb_composite_dev	*cdev = rndis->port.func.config->cdev;
+	struct usb_composite_dev	*cdev;
 	int				status;
 	rndis_init_msg_type		*buf;
 
+	if (!rndis->port.func.config || !rndis->port.func.config->cdev)
+		return;
+	else
+		cdev = rndis->port.func.config->cdev;
+
 	/* received RNDIS command from USB_CDC_SEND_ENCAPSULATED_COMMAND */
 //	spin_lock(&dev->lock);
 	status = rndis_msg_parser(rndis->config, (u8 *) req->buf);
diff --git a/drivers/usb/gadget/f_serial.c b/drivers/usb/gadget/f_serial.c
index 43347b3..9839b20 100644
--- a/drivers/usb/gadget/f_serial.c
+++ b/drivers/usb/gadget/f_serial.c
@@ -27,7 +27,13 @@
  * CDC ACM driver.  However, for many purposes it's just as functional
  * if you can arrange appropriate host side drivers.
  */
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#define GSERIAL_NO_PORTS 5
+#else
 #define GSERIAL_NO_PORTS 3
+#endif /* SIERRA */
+/* SWISTOP */
 
 struct f_gser {
 	struct gserial			port;
@@ -75,6 +81,18 @@ static struct port_info {
 	unsigned		client_port_num;
 } gserial_ports[GSERIAL_NO_PORTS];
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static inline bool is_acm(struct f_gser *gser)
+{
+	if(!(strcmp(gser->port.func.name,"modem") && strcmp(gser->port.func.name,"at")))
+		return 1;
+	else
+		return 0;
+}
+#endif/* SIERRA */
+/* SWISTOP */
+
 static inline bool is_transport_sdio(enum transport_type t)
 {
 	if (t == USB_GADGET_XPORT_SDIO)
@@ -93,8 +111,15 @@ static inline struct f_gser *port_to_gser(struct gserial *p)
 	return container_of(p, struct f_gser, port);
 }
 #define GS_LOG2_NOTIFY_INTERVAL		5	/* 1 << 5 == 32 msec */
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+/* Work around issue where driver needs zero length packet if interrupt packet is at MAX size */
+#define GS_NOTIFY_MAXPACKET		10 + 2	/* notification + 2 bytes + 2 spares */
+#else
 #define GS_NOTIFY_MAXPACKET		10	/* notification + 2 bytes */
 #endif
+/* SWISTOP */
+#endif
 /*-------------------------------------------------------------------------*/
 
 /* interface descriptor: */
@@ -113,6 +138,22 @@ static struct usb_interface_descriptor gser_interface_desc = {
 	.bInterfaceProtocol =	0,
 	/* .iInterface = DYNAMIC */
 };
+
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static struct usb_interface_descriptor gser_obex_interface_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	/* .bInterfaceNumber = DYNAMIC */
+	.bNumEndpoints =	2,
+	.bInterfaceClass =	USB_CLASS_VENDOR_SPEC,
+	.bInterfaceSubClass =	0,
+	.bInterfaceProtocol =	0,
+	/* .iInterface = DYNAMIC */
+};
+#endif /* SIERRA */
+/* SWISTOP */
+
 #ifdef CONFIG_MODEM_SUPPORT
 static struct usb_cdc_header_desc gser_header_desc  = {
 	.bLength =		sizeof(gser_header_desc),
@@ -185,6 +226,17 @@ static struct usb_descriptor_header *gser_fs_function[] = {
 	NULL,
 };
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static struct usb_descriptor_header *gser_obex_fs_function[] = {
+	(struct usb_descriptor_header *) &gser_obex_interface_desc,
+	(struct usb_descriptor_header *) &gser_fs_in_desc,
+	(struct usb_descriptor_header *) &gser_fs_out_desc,
+	NULL,
+};
+#endif /* SIERRA */
+/* SWISTOP */
+
 /* high speed support: */
 #ifdef CONFIG_MODEM_SUPPORT
 static struct usb_endpoint_descriptor gser_hs_notify_desc  = {
@@ -282,6 +334,17 @@ static struct usb_descriptor_header *gser_ss_function[] = {
 	NULL,
 };
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static struct usb_descriptor_header *gser_obex_hs_function[] = {
+	(struct usb_descriptor_header *) &gser_obex_interface_desc,
+	(struct usb_descriptor_header *) &gser_hs_in_desc,
+	(struct usb_descriptor_header *) &gser_hs_out_desc,
+	NULL,
+};
+#endif /* SIERRA */
+/* SWISTOP */
+
 /* string descriptors: */
 
 static struct usb_string gser_string_defs[] = {
@@ -364,14 +427,34 @@ static int gport_connect(struct f_gser *gser)
 
 	switch (gser->transport) {
 	case USB_GADGET_XPORT_TTY:
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	case USB_GADGET_XPORT_TTYRD:
+#endif /* SIERRA */
+/* SWISTOP */
 		gserial_connect(&gser->port, port_num);
 		break;
 	case USB_GADGET_XPORT_SDIO:
 		gsdio_connect(&gser->port, port_num);
 		break;
 	case USB_GADGET_XPORT_SMD:
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+		gsmd_connect(&gser->port, port_num);
+		break;
+#else 
+	case USB_GADGET_XPORT_SMDAT:
+		gsmd_connect(&gser->port, port_num);
+		break;
+	case USB_GADGET_XPORT_SMDOSA:  
 		gsmd_connect(&gser->port, port_num);
+		{
+			struct gserial *gser_smd = &gser->port;
+			gser_smd->notify_modem(gser_smd, port_num, 0x03);
+		}
 		break;
+#endif /* SIERRA */
+/* SWISTOP */
 	case USB_GADGET_XPORT_HSIC:
 		ret = ghsic_ctrl_connect(&gser->port, port_num);
 		if (ret) {
@@ -416,12 +499,23 @@ static int gport_disconnect(struct f_gser *gser)
 
 	switch (gser->transport) {
 	case USB_GADGET_XPORT_TTY:
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	case USB_GADGET_XPORT_TTYRD:
+#endif /* SIERRA */
+/* SWISTOP */
 		gserial_disconnect(&gser->port);
 		break;
 	case USB_GADGET_XPORT_SDIO:
 		gsdio_disconnect(&gser->port, port_num);
 		break;
 	case USB_GADGET_XPORT_SMD:
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	case USB_GADGET_XPORT_SMDAT:
+	case USB_GADGET_XPORT_SMDOSA:
+#endif /* SIERRA */
+/* SWISTOP */    
 		gsmd_disconnect(&gser->port, port_num);
 		break;
 	case USB_GADGET_XPORT_HSIC:
@@ -545,6 +639,31 @@ static int gser_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 	/* we know alt == 0, so this is an activation or a reset */
 
 #ifdef CONFIG_MODEM_SUPPORT
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if(is_acm(gser))
+	{
+		if (gser->notify->driver_data) {
+			DBG(cdev, "reset generic ctl ttyGS%d\n", gser->port_num);
+			usb_ep_disable(gser->notify);
+		}
+
+		if (!gser->notify->desc) {
+			if (config_ep_by_speed(cdev->gadget, f, gser->notify)) {
+				gser->notify->desc = NULL;
+				return -EINVAL;
+			}
+		}
+		rc = usb_ep_enable(gser->notify);
+
+		if (rc) {
+			ERROR(cdev, "can't enable %s, result %d\n",
+						gser->notify->name, rc);
+			return rc;
+		}
+		gser->notify->driver_data = gser;
+	}
+#else
 	if (gser->notify->driver_data) {
 		DBG(cdev, "reset generic ctl ttyGS%d\n", gser->port_num);
 		usb_ep_disable(gser->notify);
@@ -564,6 +683,8 @@ static int gser_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 		return rc;
 	}
 	gser->notify->driver_data = gser;
+#endif /* SIERRA */
+/* SWISTOP */
 #endif
 
 	if (gser->port.in->driver_data) {
@@ -596,9 +717,20 @@ static void gser_disable(struct usb_function *f)
 	gport_disconnect(gser);
 
 #ifdef CONFIG_MODEM_SUPPORT
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if(is_acm(gser))
+	{
+		usb_ep_fifo_flush(gser->notify);
+		usb_ep_disable(gser->notify);
+		gser->notify->driver_data = NULL;
+	}
+#else
 	usb_ep_fifo_flush(gser->notify);
 	usb_ep_disable(gser->notify);
 	gser->notify->driver_data = NULL;
+#endif /* SIERRA */
+/* SWISTOP */
 #endif
 	gser->online = 0;
 }
@@ -784,7 +916,21 @@ gser_bind(struct usb_configuration *c, struct usb_function *f)
 	if (status < 0)
 		goto fail;
 	gser->data_id = status;
+/* SWISTART */
+#ifdef CONFIG_SIERRA	
+	if(is_acm(gser))
+	{
+		gser_interface_desc.bInterfaceNumber = status;
+	}
+	else
+	{
+		gser_obex_interface_desc.bInterfaceNumber = status;
+	}
+#else
 	gser_interface_desc.bInterfaceNumber = status;
+#endif /* SIERRA */
+/* SWISTOP */
+
 
 	status = -ENODEV;
 
@@ -802,6 +948,26 @@ gser_bind(struct usb_configuration *c, struct usb_function *f)
 	ep->driver_data = cdev;	/* claim */
 
 #ifdef CONFIG_MODEM_SUPPORT
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if(is_acm(gser))
+	{
+		ep = usb_ep_autoconfig(cdev->gadget, &gser_fs_notify_desc);
+		if (!ep)
+			goto fail;
+		gser->notify = ep;
+		ep->driver_data = cdev;	/* claim */
+		/* allocate notification */
+		gser->notify_req = gs_alloc_req(ep,
+				sizeof(struct usb_cdc_notification) + 2,
+				GFP_KERNEL);
+		if (!gser->notify_req)
+			goto fail;
+
+		gser->notify_req->complete = gser_notify_complete;
+		gser->notify_req->context = gser;
+	}
+#else
 	ep = usb_ep_autoconfig(cdev->gadget, &gser_fs_notify_desc);
 	if (!ep)
 		goto fail;
@@ -816,10 +982,26 @@ gser_bind(struct usb_configuration *c, struct usb_function *f)
 
 	gser->notify_req->complete = gser_notify_complete;
 	gser->notify_req->context = gser;
+#endif /* SIERRA */
+/* SWISTOP */
 #endif
 
 	/* copy descriptors, and track endpoint copies */
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if(is_acm(gser))
+	{
+		/* copy descriptors, and track endpoint copies */
+		f->descriptors = usb_copy_descriptors(gser_fs_function);
+	}
+	else
+	{
+		f->descriptors = usb_copy_descriptors(gser_obex_fs_function);
+	}
+#else
 	f->descriptors = usb_copy_descriptors(gser_fs_function);
+#endif /* SIERRA */
+/* SWISTOP */
 
 	if (!f->descriptors)
 		goto fail;
@@ -834,12 +1016,36 @@ gser_bind(struct usb_configuration *c, struct usb_function *f)
 		gser_hs_out_desc.bEndpointAddress =
 				gser_fs_out_desc.bEndpointAddress;
 #ifdef CONFIG_MODEM_SUPPORT
-		gser_hs_notify_desc.bEndpointAddress =
-				gser_fs_notify_desc.bEndpointAddress;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if(is_acm(gser))
+	{
+			gser_hs_notify_desc.bEndpointAddress =
+					gser_fs_notify_desc.bEndpointAddress;
+	}
+#else
+	gser_hs_notify_desc.bEndpointAddress =
+			gser_fs_notify_desc.bEndpointAddress;
+#endif /* SIERRA */
+/* SWISTOP */
 #endif
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if(is_acm(gser))
+	{
 		/* copy descriptors, and track endpoint copies */
 		f->hs_descriptors = usb_copy_descriptors(gser_hs_function);
+	}
+	else
+	{
+		f->hs_descriptors = usb_copy_descriptors(gser_obex_hs_function);
+	}
+#else
+	/* copy descriptors, and track endpoint copies */
+	f->hs_descriptors = usb_copy_descriptors(gser_hs_function);
+#endif /* SIERRA */
+/* SWISTOP */
 
 		if (!f->hs_descriptors)
 			goto fail;
@@ -876,12 +1082,27 @@ fail:
 	if (f->descriptors)
 		usb_free_descriptors(f->descriptors);
 #ifdef CONFIG_MODEM_SUPPORT
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if(is_acm(gser))
+	{
+		if (gser->notify_req)
+			gs_free_req(gser->notify, gser->notify_req);
+
+		/* we might as well release our claims on endpoints */
+		if (gser->notify)
+			gser->notify->driver_data = NULL;
+	}
+#else
 	if (gser->notify_req)
 		gs_free_req(gser->notify, gser->notify_req);
 
 	/* we might as well release our claims on endpoints */
 	if (gser->notify)
 		gser->notify->driver_data = NULL;
+
+#endif /* SIERRA */
+/* SWISTOP */
 #endif
 	/* we might as well release our claims on endpoints */
 	if (gser->port.out)
@@ -906,7 +1127,16 @@ gser_unbind(struct usb_configuration *c, struct usb_function *f)
 		usb_free_descriptors(f->ss_descriptors);
 	usb_free_descriptors(f->descriptors);
 #ifdef CONFIG_MODEM_SUPPORT
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if(is_acm(gser))
+	{
+		gs_free_req(gser->notify, gser->notify_req);
+	}
+#else
 	gs_free_req(gser->notify, gser->notify_req);
+#endif /* SIERRA */
+/* SWISTOP */
 #endif
 	kfree(func_to_gser(f));
 }
@@ -957,7 +1187,24 @@ int gser_bind_config(struct usb_configuration *c, u8 port_num)
 	gser->port.func.set_alt = gser_set_alt;
 	gser->port.func.disable = gser_disable;
 	gser->transport		= gserial_ports[port_num].transport;
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* For Compositions that have NMEA but not AT using port_num breaks the NMEA interface */
+	if (gser->transport == USB_GADGET_XPORT_SMD)
+		gser->port.func.name = "modem";
+	else if (gser->transport == USB_GADGET_XPORT_SMDAT)
+		gser->port.func.name = "at";
+	else if (gser->transport == USB_GADGET_XPORT_SMDOSA)
+		gser->port.func.name = "osa";
+	else if (gser->transport == USB_GADGET_XPORT_TTYRD)
+		gser->port.func.name = "raw_data";
+	else
+		gser->port.func.name = "nmea";
+#endif /* SIERRA */
+/* SWISTOP */
 #ifdef CONFIG_MODEM_SUPPORT
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	/* We support only three ports for now */
 	if (port_num == 0)
 		gser->port.func.name = "modem";
@@ -965,6 +1212,24 @@ int gser_bind_config(struct usb_configuration *c, u8 port_num)
 		gser->port.func.name = "nmea";
 	else
 		gser->port.func.name = "modem2";
+#endif /* SIERRA */
+/* SWISTOP */
+
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	if(is_acm(gser))
+	{
+		gser->port.func.setup = gser_setup;
+		gser->port.connect = gser_connect;
+		gser->port.get_dtr = gser_get_dtr;
+		gser->port.get_rts = gser_get_rts;
+		gser->port.send_carrier_detect = gser_send_carrier_detect;
+		gser->port.send_ring_indicator = gser_send_ring_indicator;
+		gser->port.send_modem_ctrl_bits = gser_send_modem_ctrl_bits;
+		gser->port.disconnect = gser_disconnect;
+		gser->port.send_break = gser_send_break;
+	}
+#else
 	gser->port.func.setup = gser_setup;
 	gser->port.connect = gser_connect;
 	gser->port.get_dtr = gser_get_dtr;
@@ -974,6 +1239,8 @@ int gser_bind_config(struct usb_configuration *c, u8 port_num)
 	gser->port.send_modem_ctrl_bits = gser_send_modem_ctrl_bits;
 	gser->port.disconnect = gser_disconnect;
 	gser->port.send_break = gser_send_break;
+#endif /* SIERRA */
+/* SWISTOP */
 #endif
 
 	status = usb_add_function(c, &gser->port.func);
@@ -1001,6 +1268,11 @@ static int gserial_init_port(int port_num, const char *name)
 
 	switch (transport) {
 	case USB_GADGET_XPORT_TTY:
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	case USB_GADGET_XPORT_TTYRD:
+#endif /* SIERRA */
+/* SWISTOP */
 		gserial_ports[port_num].client_port_num = no_tty_ports;
 		no_tty_ports++;
 		break;
@@ -1008,10 +1280,29 @@ static int gserial_init_port(int port_num, const char *name)
 		gserial_ports[port_num].client_port_num = no_sdio_ports;
 		no_sdio_ports++;
 		break;
+
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	case USB_GADGET_XPORT_SMD:
 		gserial_ports[port_num].client_port_num = no_smd_ports;
 		no_smd_ports++;
 		break;
+#else
+	case USB_GADGET_XPORT_SMD:
+		gserial_ports[port_num].client_port_num = 0;
+		no_smd_ports++;
+		break;
+	case USB_GADGET_XPORT_SMDAT:
+		gserial_ports[port_num].client_port_num = 1;
+		no_smd_ports++;
+		break;
+	case USB_GADGET_XPORT_SMDOSA:
+		gserial_ports[port_num].client_port_num = 2;
+		no_smd_ports++;
+		break;
+#endif /* SIERRA */
+/* SWISTOP */
+    
 	case USB_GADGET_XPORT_HSIC:
 		/*client port number will be updated in gport_setup*/
 		no_hsic_sports++;
diff --git a/drivers/usb/gadget/f_uac1.c b/drivers/usb/gadget/f_uac1.c
index 8c74381..52d70cf 100644
--- a/drivers/usb/gadget/f_uac1.c
+++ b/drivers/usb/gadget/f_uac1.c
@@ -46,7 +46,14 @@ static int audio_playback_buf_size = 256*32;
 module_param(audio_playback_buf_size, int, S_IRUGO);
 MODULE_PARM_DESC(audio_playback_buf_size, "Audio buffer size");
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#define CAPTURE_EP_MAX_PACKET_SIZE	16  /*Wait QCT CR to confirm this chang, but this change can fix problem*/
+#else
 #define CAPTURE_EP_MAX_PACKET_SIZE	32
+#endif
+/* SWISTOP */
+
 static int req_capture_buf_size = CAPTURE_EP_MAX_PACKET_SIZE;
 module_param(req_capture_buf_size, int, S_IRUGO);
 MODULE_PARM_DESC(req_capture_buf_size, "ISO IN endpoint (capture) request buffer size");
@@ -462,6 +469,8 @@ struct f_audio {
 	struct work_struct		capture_work;
 	struct list_head		capture_queue;
 	struct usb_request		*capture_req;
+	u8				alt_intf[F_AUDIO_NUM_INTERFACES];
+
 
 	/* Control Set command */
 	struct list_head		fu_cs;
@@ -881,6 +890,18 @@ f_audio_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
 	return value;
 }
 
+static int f_audio_get_alt(struct usb_function *f, unsigned intf)
+{
+	struct f_audio	*audio = func_to_audio(f);
+
+	if (intf == ac_header_desc.baInterfaceNr[0])
+		return audio->alt_intf[0];
+	if (intf == ac_header_desc.baInterfaceNr[1])
+		return audio->alt_intf[1];
+
+	return 0;
+}
+
 static int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 {
 	struct f_audio		*audio = func_to_audio(f);
@@ -938,6 +959,7 @@ static int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 			}
 			spin_unlock_irqrestore(&audio->capture_lock, flags);
 		}
+		audio->alt_intf[0] = alt;
 	} else if (intf == ac_header_desc.baInterfaceNr[1]) {
 		if (alt == 1) {
 			err = usb_ep_enable(out_ep);
@@ -986,10 +1008,12 @@ static int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 				list_add_tail(&playback_copy_buf->list,
 						&audio->play_queue);
 				schedule_work(&audio->playback_work);
+				audio->playback_copy_buf = NULL;
 			} else {
 				pr_err("playback_buf is empty. Stop.");
 			}
 		}
+		audio->alt_intf[1] = alt;
 	} else {
 		pr_err("Interface %d. Do nothing. Return %d\n", intf, err);
 	}
@@ -1066,6 +1090,7 @@ f_audio_bind(struct usb_configuration *c, struct usb_function *f)
 	microphone_as_interface_alt_0_desc.bInterfaceNumber = status;
 	microphone_as_interface_alt_1_desc.bInterfaceNumber = status;
 	ac_header_desc.baInterfaceNr[0] = status;
+	audio->alt_intf[0] = 0;
 
 	status = -ENODEV;
 
@@ -1077,6 +1102,7 @@ f_audio_bind(struct usb_configuration *c, struct usb_function *f)
 	speaker_as_interface_alt_0_desc.bInterfaceNumber = status;
 	speaker_as_interface_alt_1_desc.bInterfaceNumber = status;
 	ac_header_desc.baInterfaceNr[1] = status;
+	audio->alt_intf[1] = 0;
 
 	status = -ENODEV;
 
@@ -1225,6 +1251,7 @@ int audio_bind_config(struct usb_configuration *c)
 	audio->card.func.strings = audio_strings;
 	audio->card.func.bind = f_audio_bind;
 	audio->card.func.unbind = f_audio_unbind;
+	audio->card.func.get_alt = f_audio_get_alt;
 	audio->card.func.set_alt = f_audio_set_alt;
 	audio->card.func.setup = f_audio_setup;
 	audio->card.func.disable = f_audio_disable;
diff --git a/drivers/usb/gadget/u_bam.c b/drivers/usb/gadget/u_bam.c
index f092329..540873d 100644
--- a/drivers/usb/gadget/u_bam.c
+++ b/drivers/usb/gadget/u_bam.c
@@ -679,6 +679,7 @@ static void gbam2bam_connect_work(struct work_struct *w)
 	struct bam_ch_info *d = &port->data_ch;
 	u32 sps_params;
 	int ret;
+	unsigned long flags;
 
 	ret = usb_bam_connect(d->connection_idx, &d->src_pipe_idx,
 						  &d->dst_pipe_idx);
@@ -688,9 +689,21 @@ static void gbam2bam_connect_work(struct work_struct *w)
 		return;
 	}
 
-	d->rx_req = usb_ep_alloc_request(port->port_usb->out, GFP_KERNEL);
-	if (!d->rx_req)
+	spin_lock_irqsave(&port->port_lock_ul, flags);
+	spin_lock(&port->port_lock_dl);
+	if (!port->port_usb) {
+		pr_debug("%s: usb cable is disconnected, exiting\n", __func__);
+		spin_unlock(&port->port_lock_dl);
+		spin_unlock_irqrestore(&port->port_lock_ul, flags);
 		return;
+	}
+	d->rx_req = usb_ep_alloc_request(port->port_usb->out, GFP_ATOMIC);
+	if (!d->rx_req) {
+		spin_unlock(&port->port_lock_dl);
+		spin_unlock_irqrestore(&port->port_lock_ul, flags);
+		pr_err("%s: out of memory\n", __func__);
+		return;
+	}
 
 	d->rx_req->context = port;
 	d->rx_req->complete = gbam_endless_rx_complete;
@@ -698,9 +711,14 @@ static void gbam2bam_connect_work(struct work_struct *w)
 	sps_params = (MSM_SPS_MODE | d->src_pipe_idx |
 				 MSM_VENDOR_ID) & ~MSM_IS_FINITE_TRANSFER;
 	d->rx_req->udc_priv = sps_params;
-	d->tx_req = usb_ep_alloc_request(port->port_usb->in, GFP_KERNEL);
-	if (!d->tx_req)
+
+	d->tx_req = usb_ep_alloc_request(port->port_usb->in, GFP_ATOMIC);
+	spin_unlock(&port->port_lock_dl);
+	spin_unlock_irqrestore(&port->port_lock_ul, flags);
+	if (!d->tx_req) {
+		pr_err("%s: out of memory\n", __func__);
 		return;
+	}
 
 	d->tx_req->context = port;
 	d->tx_req->complete = gbam_endless_tx_complete;
diff --git a/drivers/usb/gadget/u_ether.c b/drivers/usb/gadget/u_ether.c
index f7b908b..18726a9 100644
--- a/drivers/usb/gadget/u_ether.c
+++ b/drivers/usb/gadget/u_ether.c
@@ -474,13 +474,27 @@ static void eth_work(struct work_struct *work)
 static void tx_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct sk_buff	*skb = req->context;
-	struct eth_dev	*dev = ep->driver_data;
-	struct net_device *net = dev->net;
+	struct eth_dev	*dev;
+	struct net_device *net;
 	struct usb_request *new_req;
 	struct usb_ep *in;
 	int length;
 	int retval;
 
+	if (!ep->driver_data) {
+		usb_ep_free_request(ep, req);
+		return;
+	}
+
+	dev = ep->driver_data;
+	net = dev->net;
+
+	if (!dev->port_usb) {
+		usb_ep_free_request(ep, req);
+		return;
+	}
+
+
 	switch (req->status) {
 	default:
 		dev->net->stats.tx_errors++;
@@ -597,11 +611,13 @@ static netdev_tx_t eth_start_xmit(struct sk_buff *skb,
 	unsigned long		flags;
 	struct usb_ep		*in;
 	u16			cdc_filter;
+	bool			multi_pkt_xfer = false;
 
 	spin_lock_irqsave(&dev->lock, flags);
 	if (dev->port_usb) {
 		in = dev->port_usb->in_ep;
 		cdc_filter = dev->port_usb->cdc_filter;
+		multi_pkt_xfer = dev->port_usb->multi_pkt_xfer;
 	} else {
 		in = NULL;
 		cdc_filter = 0;
@@ -614,7 +630,7 @@ static netdev_tx_t eth_start_xmit(struct sk_buff *skb,
 	}
 
 	/* Allocate memory for tx_reqs to support multi packet transfer */
-	if (dev->port_usb->multi_pkt_xfer && !dev->tx_req_bufsize)
+	if (multi_pkt_xfer && !dev->tx_req_bufsize)
 		alloc_tx_buffer(dev);
 
 	/* apply outgoing CDC or RNDIS filters */
@@ -677,7 +693,7 @@ static netdev_tx_t eth_start_xmit(struct sk_buff *skb,
 	dev->tx_skb_hold_count++;
 	spin_unlock_irqrestore(&dev->req_lock, flags);
 
-	if (dev->port_usb->multi_pkt_xfer) {
+	if (multi_pkt_xfer) {
 		memcpy(req->buf + req->length, skb->data, skb->len);
 		req->length = req->length + skb->len;
 		length = req->length;
@@ -749,7 +765,7 @@ static netdev_tx_t eth_start_xmit(struct sk_buff *skb,
 	}
 
 	if (retval) {
-		if (!dev->port_usb->multi_pkt_xfer)
+		if (!multi_pkt_xfer)
 			dev_kfree_skb_any(skb);
 drop:
 		dev->net->stats.tx_dropped++;
diff --git a/drivers/usb/gadget/u_qc_ether.c b/drivers/usb/gadget/u_qc_ether.c
index 4931c1e..8b79b89 100644
--- a/drivers/usb/gadget/u_qc_ether.c
+++ b/drivers/usb/gadget/u_qc_ether.c
@@ -348,7 +348,7 @@ void gether_qc_cleanup_name(const char *netname)
  * is active ("carrier detect").
  */
 struct net_device *gether_qc_connect_name(struct qc_gether *link,
-		const char *netname)
+		const char *netname, bool netif_enable)
 {
 	struct net_device *net_dev;
 	struct eth_qc_dev *dev;
@@ -375,9 +375,11 @@ struct net_device *gether_qc_connect_name(struct qc_gether *link,
 	}
 	spin_unlock(&dev->lock);
 
-	netif_carrier_on(dev->net);
-	if (netif_running(dev->net))
-		netif_wake_queue(dev->net);
+	if (netif_enable) {
+		netif_carrier_on(dev->net);
+		if (netif_running(dev->net))
+			netif_wake_queue(dev->net);
+	}
 
 	return dev->net;
 }
diff --git a/drivers/usb/gadget/u_qc_ether.h b/drivers/usb/gadget/u_qc_ether.h
index d91e805..bb22046 100644
--- a/drivers/usb/gadget/u_qc_ether.h
+++ b/drivers/usb/gadget/u_qc_ether.h
@@ -85,7 +85,7 @@ int gether_qc_setup_name(struct usb_gadget *g, u8 ethaddr[ETH_ALEN],
 
 /* connect/disconnect is handled by individual functions */
 struct net_device *gether_qc_connect_name(struct qc_gether *link,
-		const char *netname);
+		const char *netname, bool netif_enable);
 void gether_qc_disconnect_name(struct qc_gether *link, const char *netname);
 
 /* each configuration may bind one instance of an ethernet link */
diff --git a/drivers/usb/gadget/u_rmnet.h b/drivers/usb/gadget/u_rmnet.h
index 0f7c4fb..aadce61 100644
--- a/drivers/usb/gadget/u_rmnet.h
+++ b/drivers/usb/gadget/u_rmnet.h
@@ -55,5 +55,10 @@ void gbam_resume(struct grmnet *gr, u8 port_num, enum transport_type trans);
 int gsmd_ctrl_connect(struct grmnet *gr, int port_num);
 void gsmd_ctrl_disconnect(struct grmnet *gr, u8 port_num);
 int gsmd_ctrl_setup(unsigned int count);
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+void gsmd_ctrl_smd_port_reg(void);
+#endif /* SIERRA and FEATURE_MORPHING */
+/* SWISTOP */
 
 #endif /* __U_RMNET_H*/
diff --git a/drivers/usb/gadget/u_rmnet_ctrl_smd.c b/drivers/usb/gadget/u_rmnet_ctrl_smd.c
index 169008b..f56a06b 100644
--- a/drivers/usb/gadget/u_rmnet_ctrl_smd.c
+++ b/drivers/usb/gadget/u_rmnet_ctrl_smd.c
@@ -396,6 +396,7 @@ void gsmd_ctrl_disconnect(struct grmnet *gr, u8 port_num)
 	unsigned long		flags;
 	struct smd_ch_info	*c;
 	struct rmnet_ctrl_pkt	*cpkt;
+	int clear_bits;
 
 	pr_debug("%s: grmnet:%p port#%d\n", __func__, gr, port_num);
 
@@ -427,9 +428,11 @@ void gsmd_ctrl_disconnect(struct grmnet *gr, u8 port_num)
 
 	spin_unlock_irqrestore(&port->port_lock, flags);
 
-	if (test_and_clear_bit(CH_OPENED, &c->flags))
+	if (test_and_clear_bit(CH_OPENED, &c->flags)) {
+		clear_bits = ~(c->cbits_tomodem | TIOCM_RTS);
 		/* send dtr zero */
-		smd_tiocmset(c->ch, c->cbits_tomodem, ~c->cbits_tomodem);
+		smd_tiocmset(c->ch, c->cbits_tomodem, clear_bits);
+	}
 
 	if (c->ch) {
 		smd_close(c->ch);
@@ -506,6 +509,26 @@ static void grmnet_ctrl_smd_port_free(int portno)
 	}
 }
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA) && defined(FEATURE_MORPHING)
+void gsmd_ctrl_smd_port_reg(void)
+{
+	int i;
+	struct rmnet_ctrl_port	*port;
+	struct platform_driver	*pdrv;
+
+	for ( i = 0 ; i < NR_CTRL_SMD_PORTS ; i++ ) {
+		port = ctrl_smd_ports[i].port;
+		pdrv = &ctrl_smd_ports[i].pdrv;
+		if ( port ) {
+			pr_debug("%s: register port:%d\n", __func__, i);
+			platform_driver_register(pdrv);
+		}
+	}
+}
+#endif /* SIERRA */
+/* SWISTOP */
+
 static int grmnet_ctrl_smd_port_alloc(int portno)
 {
 	struct rmnet_ctrl_port	*port;
@@ -537,7 +560,11 @@ static int grmnet_ctrl_smd_port_alloc(int portno)
 	pdrv->driver.name = c->name;
 	pdrv->driver.owner = THIS_MODULE;
 
+/* SWISTART */
+#if !defined(CONFIG_SIERRA) || !defined(FEATURE_MORPHING)
 	platform_driver_register(pdrv);
+#endif /* SIERRA */
+/* SWISTOP */
 
 	pr_debug("%s: port:%p portno:%d\n", __func__, port, portno);
 
diff --git a/drivers/usb/gadget/u_serial.c b/drivers/usb/gadget/u_serial.c
index 909744f..2583370 100644
--- a/drivers/usb/gadget/u_serial.c
+++ b/drivers/usb/gadget/u_serial.c
@@ -1353,6 +1353,19 @@ int gserial_setup(struct usb_gadget *g, unsigned count)
 	gs_tty_driver->init_termios.c_ispeed = 9600;
 	gs_tty_driver->init_termios.c_ospeed = 9600;
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* set ~ICANON so that serial data will not be buffered
+	 * set ~ECHO so that serial data from host will not be echoed back
+	 * These two settings are required for NMEA port so that the short NMEA
+	 * command $GPS_START from host will not be buffered and echoed.
+	 * FIXME: make sure this will not affect other serial ports (diag and modem
+	 *        are not affected and they are not using this function)                
+	 */ 
+	gs_tty_driver->init_termios.c_lflag &= ~(ICANON | ECHO);
+#endif /* CONFIG_SIERRA*/
+/* SWISTOP */
+
 	coding.dwDTERate = cpu_to_le32(9600);
 	coding.bCharFormat = 8;
 	coding.bParityType = USB_CDC_NO_PARITY;
diff --git a/drivers/usb/gadget/u_smd.c b/drivers/usb/gadget/u_smd.c
index effe418..b6b3f2b 100644
--- a/drivers/usb/gadget/u_smd.c
+++ b/drivers/usb/gadget/u_smd.c
@@ -38,7 +38,14 @@
 
 static struct workqueue_struct *gsmd_wq;
 
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 #define SMD_N_PORTS	2
+#else
+#define SMD_N_PORTS	3
+#endif /* SIERRA */
+/* SWISTOP */
+
 #define CH_OPENED	0
 #define CH_READY	1
 struct smd_port_info {
@@ -51,9 +58,21 @@ struct smd_port_info smd_pi[SMD_N_PORTS] = {
 	{
 		.name = "DS",
 	},
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	{
 		.name = "UNUSED",
 	},
+#else
+	{
+		.name = "DATA1",
+	},
+
+	{
+		.name = "DATA11",
+	},
+#endif /* SIERRA */
+/* SWISTOP */
 };
 
 struct gsmd_port {
@@ -760,7 +779,13 @@ static int gsmd_ch_probe(struct platform_device *pdev)
 
 	pr_debug("%s: name:%s\n", __func__, pdev->name);
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	for (i = 0; i < 3; i++) {
+#else
 	for (i = 0; i < n_smd_ports; i++) {
+#endif /* SIERRA */
+/* SWISTOP */
 		port = smd_ports[i].port;
 		pi = port->pi;
 
@@ -966,7 +991,13 @@ int gsmd_setup(struct usb_gadget *g, unsigned count)
 		return -ENOMEM;
 	}
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	for (i = 0; i < 3; i++) {
+#else
 	for (i = 0; i < count; i++) {
+#endif /* SIERRA */
+/* SWISTOP */
 		mutex_init(&smd_ports[i].lock);
 		n_smd_ports++;
 		ret = gsmd_port_alloc(i, &coding);
@@ -981,7 +1012,13 @@ int gsmd_setup(struct usb_gadget *g, unsigned count)
 
 	return 0;
 free_smd_ports:
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	for (i = 0; i < 3; i++)
+#else
 	for (i = 0; i < n_smd_ports; i++)
+#endif /* SIERRA */
+/* SWISTOP */
 		gsmd_port_free(i);
 
 	destroy_workqueue(gsmd_wq);
diff --git a/drivers/usb/gadget/u_uac1.c b/drivers/usb/gadget/u_uac1.c
index fc4fb7a..1eeaecd 100644
--- a/drivers/usb/gadget/u_uac1.c
+++ b/drivers/usb/gadget/u_uac1.c
@@ -29,8 +29,17 @@
  * This component encapsulates the ALSA devices for USB audio gadget
  */
 
+/* SWISTART */
+/* SWI AFE PCM deveice is pcmC0D4p/pcmC0D5p */
+#ifndef CONFIG_SIERRA
 #define FILE_PCM_PLAYBACK	"/dev/snd/pcmC0D5p"
 #define FILE_PCM_CAPTURE	"/dev/snd/pcmC0D6c"
+#else
+#define FILE_PCM_PLAYBACK	"/dev/snd/pcmC0D4p"
+#define FILE_PCM_CAPTURE	"/dev/snd/pcmC0D5c"
+#endif
+/* SWISTOP */
+
 #define FILE_CONTROL		"/dev/snd/controlC0"
 
 static char *fn_play = FILE_PCM_PLAYBACK;
diff --git a/drivers/usb/gadget/usb_netlink_base.c b/drivers/usb/gadget/usb_netlink_base.c
new file mode 100644
index 0000000..b65ead4
--- /dev/null
+++ b/drivers/usb/gadget/usb_netlink_base.c
@@ -0,0 +1,177 @@
+#include "usb_netlink_base.h"
+#include <linux/export.h>
+#include <linux/module.h>
+
+struct sock *nl_sk = NULL;
+#define NETLINK_USB_SWITCH 24
+#define NETLINKBASE_MAJOR 227
+#define SET_VERSION_INFO 1
+#define SET_SKU_INFO 2
+
+static struct usb_cdrom_verfile_ioctl_type swupdate_ver_info;
+static struct usb_sku_info_ioctl_type sku_info;
+
+static int netlinkbase_open ( struct inode * , struct file * ); 
+static int netlinkbase_release ( struct inode * , struct file * ); 
+static long netlinkbase_ioctl( struct file *file, unsigned int command ,unsigned long arg);
+
+void sendnlmsg(char *message, int msg_len, unsigned int usr_pid)  
+{
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	int rc;
+	int len = NLMSG_SPACE(msg_len);
+
+    printk(KERN_ERR "recvd msg of len =%d for processid = %u\n",  msg_len,usr_pid);
+	if(!message)
+		return;
+	if(!nl_sk)
+		return;
+	if(usr_pid == 0)
+		return;
+	skb = alloc_skb(len, GFP_ATOMIC);
+	if (!skb){
+		printk(KERN_ERR "net_link: allocate failed.\n");
+		return;
+	}
+
+	nlh = nlmsg_put(skb, 0, 0, 0, msg_len, 0);
+	
+	NETLINK_CB(skb).pid = 0;      
+	
+       memcpy(NLMSG_DATA(nlh), message, msg_len);
+	rc = netlink_unicast(nl_sk, skb, usr_pid, MSG_DONTWAIT);
+	if (rc < 0) 	   
+		printk(KERN_ERR "net_link: can not unicast skb (%d)\n", rc);
+	else	   
+		printk("net_link: send is ok.\n");
+	 return;
+}
+EXPORT_SYMBOL(sendnlmsg);
+
+void getcdromverinfo(struct usb_cdrom_verfile_ioctl_type *info)
+{
+  if (!info)
+    return;
+
+  memcpy(info, &swupdate_ver_info, sizeof(swupdate_ver_info));
+}
+EXPORT_SYMBOL(getcdromverinfo);
+
+void getskuinfo(struct usb_sku_info_ioctl_type *info)
+{
+  if (!info)
+    return;
+
+  memcpy(info, &sku_info, sizeof(sku_info));
+}
+EXPORT_SYMBOL(getskuinfo);
+
+void nl_data_ready (struct sk_buff *__skb)
+{
+	return;
+}
+
+static ssize_t netlinkbase_write (struct file *file, const char __user *buf, size_t count,loff_t *offset)
+{
+	int ret = 0;
+	return ret;
+}   
+
+static int netlinkbase_open(struct inode *inode , struct file *file)
+{
+    if (!try_module_get(THIS_MODULE))
+    {
+        return -ENODEV;
+    }
+    return 0;  
+} 
+
+static long netlinkbase_ioctl( struct file *file, unsigned int command ,unsigned long arg)
+{
+	int ret = 0;
+
+	switch(command)
+	{
+		case SET_VERSION_INFO:
+        memset(&swupdate_ver_info, 0x00, sizeof(swupdate_ver_info));
+        ret = copy_from_user(&swupdate_ver_info, (void __user*)arg, 
+                       sizeof(swupdate_ver_info));
+        if( ret )
+        {
+            return -1;
+        }
+        printk(KERN_INFO"[%s:%d] SIPC1 = %u, SIVer1 = %u SIPC2 = %u SIver2 = %u", __FILE__, __LINE__,swupdate_ver_info.os1_sipc,swupdate_ver_info.os1_siver,swupdate_ver_info.os2_sipc, swupdate_ver_info.os2_siver);
+        break;
+		case SET_SKU_INFO:
+        memset(&sku_info, 0x00, sizeof(sku_info));
+        ret = copy_from_user(&sku_info, (void __user*)arg, 
+                       sizeof(sku_info));
+        if( ret )
+        {
+            return -1;
+        }	
+        break;
+		default:
+        break;
+	}
+    return 0;
+}
+
+static int netlinkbase_release(struct inode *inode, struct file *filp)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+static struct file_operations netlinkbase_ctl_fops = { 
+    	owner:	THIS_MODULE,
+      	open: 	netlinkbase_open , 
+      	read:	NULL,
+      	write:      netlinkbase_write,
+      	unlocked_ioctl: 	netlinkbase_ioctl ,
+      	release: netlinkbase_release , 
+};
+
+int netlink_init(void)
+{
+    int err=0;
+	nl_sk = netlink_kernel_create(&init_net,
+						NETLINK_USB_SWITCH,
+						0, nl_data_ready,
+						NULL, THIS_MODULE);
+
+	if (!nl_sk) 
+	{
+		printk(KERN_ERR "net_link: Cannot create netlink socket.\n");
+		if (nl_sk != NULL)
+        {
+    		sock_release(nl_sk->sk_socket);
+  		}
+		return 0;
+	}
+	
+    err = register_chrdev(NETLINKBASE_MAJOR, "basever",  &netlinkbase_ctl_fops);
+    if(err < 0)
+    {
+        printk("fail to register the basever device\n");   	
+        return -1;
+    }       
+	return 0;
+}
+
+void free_netlink_rc(void)
+{
+    if (nl_sk != NULL)
+    {
+        sock_release(nl_sk->sk_socket);
+    }
+	unregister_chrdev(NETLINKBASE_MAJOR, "basever");
+}
+
+module_init(netlink_init);
+module_exit(free_netlink_rc);
+
+MODULE_DESCRIPTION("USB NETLINK base");
+MODULE_AUTHOR("Chetan Karia");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/usb_netlink_base.h b/drivers/usb/gadget/usb_netlink_base.h
new file mode 100644
index 0000000..9252964
--- /dev/null
+++ b/drivers/usb/gadget/usb_netlink_base.h
@@ -0,0 +1,34 @@
+#include <linux/types.h>
+#include <net/sock.h>
+#include <net/netlink.h>
+
+
+struct usb_cdrom_verfile_ioctl_type
+{
+  char   version[32];
+  unsigned short enable;
+  unsigned short cdpc;
+  char   cd_version[4];
+  char   description[64];
+  unsigned short os1_sipc;
+  unsigned short os1_siver;
+  char   os1_sipc_desc[32];
+  char   os1_proj[32];
+  char   os1_ui_ver[4];
+  unsigned short os2_sipc;
+  unsigned short os2_siver;
+  unsigned short os3_sipc;
+  unsigned short os3_siver;
+  unsigned short os4_sipc;
+  unsigned short os4_siver;
+};
+struct usb_sku_info_ioctl_type
+{
+  char   sku[10];
+};
+
+
+void sendnlmsg(char *message, int msg_len, unsigned int usr_pid);
+
+void getcdromverinfo(struct usb_cdrom_verfile_ioctl_type *info);
+void getskuinfo(struct usb_sku_info_ioctl_type *info);
diff --git a/drivers/usb/host/ehci-msm-hsic.c b/drivers/usb/host/ehci-msm-hsic.c
index d33c0e9..f755611 100644
--- a/drivers/usb/host/ehci-msm-hsic.c
+++ b/drivers/usb/host/ehci-msm-hsic.c
@@ -560,6 +560,12 @@ static void msm_hsic_clk_reset(struct msm_hsic_hcd *mehci)
 #define HSIC_STROBE_GPIO_PAD_CTL	(MSM_TLMM_BASE+0x20C0)
 #define HSIC_DATA_GPIO_PAD_CTL		(MSM_TLMM_BASE+0x20C4)
 #define HSIC_CAL_PAD_CTL       (MSM_TLMM_BASE+0x20C8)
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#define HSIC_STROBE_PAD_CTL	(MSM_TLMM_BASE+0x20CC)
+#define HSIC_DATA_PAD_CTL	(MSM_TLMM_BASE+0x20C8)
+#endif
+/* SWISTOP */
 #define HSIC_LV_MODE		0x04
 #define HSIC_PAD_CALIBRATION	0xA8
 #define HSIC_GPIO_PAD_VAL	0x0A0AAA10
@@ -611,6 +617,14 @@ static int msm_hsic_reset(struct msm_hsic_hcd *mehci)
 		/* HSIC init sequence when HSIC signals (Strobe/Data) are routed
 		via dedicated I/O */
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* Decrease the ROUT from 0x05(default) to 0x03 */
+	writel_relaxed(0x034A4E10, HSIC_STROBE_PAD_CTL);
+	writel_relaxed(0x034A4E10, HSIC_DATA_PAD_CTL);
+#endif
+/* SWISTOP */
+
 		/* programmable length of connect signaling (33.2ns) */
 		ret = ulpi_write(mehci, 3, HSIC_DBG1_REG);
 		if (ret) {
diff --git a/drivers/usb/otg/msm_otg.c b/drivers/usb/otg/msm_otg.c
index c6fe765..b44b1ce 100644
--- a/drivers/usb/otg/msm_otg.c
+++ b/drivers/usb/otg/msm_otg.c
@@ -40,6 +40,7 @@
 #include <linux/mfd/pm8xxx/pm8921-charger.h>
 #include <linux/mfd/pm8xxx/misc.h>
 #include <linux/mhl_8334.h>
+#include <linux/gpio.h>
 
 #include <mach/scm.h>
 #include <mach/clk.h>
@@ -48,6 +49,22 @@
 #include <mach/msm_bus.h>
 #include <mach/rpm-regulator.h>
 
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/usb/msm_hsusb.h>
+
+static unsigned vddmin_gpio;
+static unsigned int msm_otg_sessvld_int;
+static bool msm_otg_connected = false;
+
+/* Based on case 1091889 */
+struct workqueue_struct *suspend_work_q = NULL;
+#endif
+/* SWISTOP */
+
 #define MSM_USB_BASE	(motg->regs)
 #define DRIVER_NAME	"msm_otg"
 
@@ -823,6 +840,21 @@ static int msm_otg_set_suspend(struct usb_phy *phy, int suspend)
 	return 0;
 }
 
+/* SWISTART */
+/* Based on case 1091889 */
+#ifdef CONFIG_SIERRA
+static void pm_suspend_w(struct work_struct *w)
+{
+	if(msm_get_usb_det() == 2)
+	{
+		pm_suspend(PM_SUSPEND_MEM);
+	}
+}
+
+static DECLARE_WORK(suspend_work_fast, pm_suspend_w);
+#endif
+/* SWISTOP */
+
 #define PHY_SUSPEND_TIMEOUT_USEC	(500 * 1000)
 #define PHY_RESUME_TIMEOUT_USEC	(100 * 1000)
 
@@ -934,6 +966,32 @@ static int msm_otg_suspend(struct msm_otg *motg)
 	 * BC1.2 spec mandates PD to enable VDP_SRC when charging from DCP.
 	 * PHY retention and collapse can not happen with VDP_SRC enabled.
 	 */
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+	if (msm_get_usb_det() == 2)
+	{
+		if (motg->caps & ALLOW_PHY_RETENTION && !host_bus_suspend &&
+		/* !device_bus_suspend && */ !dcp)
+		{
+			phy_ctrl_val = readl_relaxed(USB_PHY_CTRL);
+			if (!device_bus_suspend && motg->pdata->otg_control == OTG_PHY_CONTROL)
+				/* Enable PHY HV interrupts to wake MPM/Link */
+				phy_ctrl_val |=
+					(PHY_IDHV_INTEN | PHY_OTGSESSVLDHV_INTEN);
+
+			if (device_bus_suspend) {
+				gpio_direction_output(pdata->vdd_min_enable, 1);
+			}
+
+			writel_relaxed(phy_ctrl_val & ~PHY_RETEN, USB_PHY_CTRL);
+			motg->lpm_flags |= PHY_RETENTIONED;
+		}
+	}
+	else
+	{
+#endif
+/* SWISTOP */
 	if (motg->caps & ALLOW_PHY_RETENTION && !host_bus_suspend &&
 		!device_bus_suspend && !dcp) {
 		phy_ctrl_val = readl_relaxed(USB_PHY_CTRL);
@@ -950,6 +1008,12 @@ static int msm_otg_suspend(struct msm_otg *motg)
 		writel_relaxed(phy_ctrl_val & ~PHY_RETEN, USB_PHY_CTRL);
 		motg->lpm_flags |= PHY_RETENTIONED;
 	}
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+	}
+#endif
+/* SWISTOP */
 
 	/* Ensure that above operation is completed before turning off clocks */
 	mb();
@@ -1009,6 +1073,15 @@ static int msm_otg_suspend(struct msm_otg *motg)
 
 	dev_info(phy->dev, "USB in low power mode\n");
 
+/* SWISTART */
+/* Based on case 1091889 */
+#ifdef CONFIG_SIERRA
+	if(msm_get_usb_det() == 2 && device_bus_suspend){
+		queue_work(suspend_work_q, &suspend_work_fast);
+	}
+#endif
+/* SWISTOP */
+
 	return 0;
 }
 
@@ -1028,6 +1101,19 @@ static int msm_otg_resume(struct msm_otg *motg)
 	disable_irq(motg->irq);
 	wake_lock(&motg->wlock);
 
+/* SWISTART */
+/* Based on case 1091889 */
+#ifdef CONFIG_SIERRA
+	if (msm_get_usb_det() == 2)
+	{
+		if(work_pending(&suspend_work_fast))
+		{
+			cancel_work_sync(&suspend_work_fast);
+		}
+	}
+#endif
+/* SWISTOP */
+
 	/* Vote for TCXO when waking up the phy */
 	if (motg->lpm_flags & XO_SHUTDOWN) {
 		ret = msm_xo_mode_vote(motg->xo_handle, MSM_XO_MODE_ON);
@@ -1062,6 +1148,15 @@ static int msm_otg_resume(struct msm_otg *motg)
 				~(PHY_IDHV_INTEN | PHY_OTGSESSVLDHV_INTEN);
 		writel_relaxed(phy_ctrl_val, USB_PHY_CTRL);
 		motg->lpm_flags &= ~PHY_RETENTIONED;
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+		if (msm_get_usb_det() == 2)
+		{
+			gpio_direction_input(pdata->vdd_min_enable);
+		}
+#endif
+/* SWISTOP */
 	}
 
 	temp = readl(USB_USBCMD);
@@ -2357,6 +2452,12 @@ static void msm_otg_sm_work(struct work_struct *w)
 	struct usb_otg *otg = motg->phy.otg;
 	bool work = 0, srp_reqd;
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	enum usb_otg_state	otg_state = otg->phy->state;
+	static enum usb_chg_type charger_type = USB_INVALID_CHARGER;
+#endif
+/* SWISTOP */
 	pm_runtime_resume(otg->phy->dev);
 	pr_debug("%s work\n", otg_state_string(otg->phy->state));
 	switch (otg->phy->state) {
@@ -2440,6 +2541,21 @@ static void msm_otg_sm_work(struct work_struct *w)
 						OTG_STATE_B_PERIPHERAL;
 					mod_timer(&motg->chg_check_timer,
 							CHG_RECHECK_DELAY);
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+					if (msm_get_usb_det() == 2)
+					{
+						msm_mpm_set_pin_type(motg->pdata->mpm_otgsessvld_int, IRQ_TYPE_EDGE_FALLING);
+					}
+					else
+					{
+						/* usb_det is not ready at this time, so buffer the mpm_otgsessvld_int */
+						msm_otg_sessvld_int = motg->pdata->mpm_otgsessvld_int;
+						msm_otg_connected = true;
+					}
+#endif
+/* SWISTOP */
 					break;
 				default:
 					break;
@@ -2467,6 +2583,21 @@ static void msm_otg_sm_work(struct work_struct *w)
 			motg->chg_type = USB_INVALID_CHARGER;
 			msm_otg_notify_charger(motg, 0);
 			msm_otg_reset(otg->phy);
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+			if (msm_get_usb_det() == 2)
+			{
+				msm_mpm_set_pin_type(motg->pdata->mpm_otgsessvld_int, IRQ_TYPE_EDGE_RISING);
+			}
+			else
+			{
+				/* usb_det is not ready at this time, so buffer the mpm_otgsessvld_int */
+				msm_otg_sessvld_int = motg->pdata->mpm_otgsessvld_int;
+				msm_otg_connected = false;
+			}
+#endif
+/* SWISTOP */
 			/*
 			 * There is a small window where ID interrupt
 			 * is not monitored during ID detection circuit
@@ -2939,6 +3070,19 @@ static void msm_otg_sm_work(struct work_struct *w)
 	}
 	if (work)
 		queue_work(system_nrt_wq, &motg->sm_work);
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* Notfiy userspace when state changed */
+	if ((otg_state != otg->phy->state) || (charger_type != motg->chg_type)) {
+		dev_info(otg->phy->dev, "OTG state %s, charger_type %s\n", (otg_state != otg->phy->state)?"changed":"NOT changed",
+		(charger_type != motg->chg_type)?"changed":"NOT changed");
+		if (charger_type != motg->chg_type) {
+			charger_type = motg->chg_type;
+		}
+		kobject_uevent(&motg->phy.dev->kobj, KOBJ_CHANGE);
+	}
+#endif
+/* SWISTOP */
 }
 
 static void msm_otg_suspend_work(struct work_struct *w)
@@ -3561,6 +3705,85 @@ static void msm_otg_debugfs_cleanup(void)
 	debugfs_remove_recursive(msm_otg_dbg_root);
 }
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+static ssize_t show_chg_type(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct msm_otg *motg = dev_get_drvdata(dev);
+	int n = 0;
+	
+	if (attr == NULL || buf == NULL) {
+		dev_err(dev, "[%s] EINVAL\n", __func__);
+		return 0;
+	}
+	
+	n = scnprintf(buf, PAGE_SIZE, "%s", chg_to_string(motg->chg_type));
+
+	return n;
+}
+
+static DEVICE_ATTR(chg_type, S_IRUSR, show_chg_type, NULL);
+
+static ssize_t show_otg_state(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct msm_otg *motg = dev_get_drvdata(dev);
+	struct usb_phy *phy = &motg->phy;
+	int n = 0;
+	
+	if (attr == NULL || buf == NULL) {
+		dev_err(dev, "[%s] EINVAL\n", __func__);
+		return 0;
+	}
+	
+	n = scnprintf(buf, PAGE_SIZE, "%s", otg_state_string(phy->state));
+
+	return n;
+}
+static DEVICE_ATTR(otg_state, S_IRUSR, show_otg_state, NULL);
+
+/**
+ * msm_otg_sysfs_create_files: initializes the attribute interface
+ * @dev: device
+ *
+ * This function returns an error code
+ */
+__maybe_unused static int msm_otg_sysfs_create_files(struct device *dev)
+{
+	int retval = 0;
+
+	if (dev == NULL)
+		return -EINVAL;
+	/* Create sysfs to /sys/devices/platform/msm_otg/ */
+	retval = device_create_file(dev, &dev_attr_chg_type);
+	if (retval)
+		goto done;
+	retval = device_create_file(dev, &dev_attr_otg_state);
+	if (retval)
+		device_remove_file(dev, &dev_attr_chg_type);
+
+done:
+	return retval;
+}
+
+/**
+ * msm_otg_sysfs_remove_files: destroys the attribute interface
+ * @dev: device
+ *
+ * This function returns an error code
+ */
+__maybe_unused static int msm_otg_sysfs_remove_files(struct device *dev)
+{
+	if (dev == NULL)
+		return -EINVAL;
+	device_remove_file(dev, &dev_attr_chg_type);
+	device_remove_file(dev, &dev_attr_otg_state);
+	return 0;
+}
+#endif /* end of CONFIG_SIERRA */
+/* SWISTOP */
+
 #define MSM_OTG_CMD_ID		0x09
 #define MSM_OTG_DEVICE_ID	0x04
 #define MSM_OTG_VMID_IDX	0xFF
@@ -4012,6 +4235,16 @@ static int __init msm_otg_probe(struct platform_device *pdev)
 		dev_dbg(&pdev->dev, "mode debugfs file is"
 			"not available\n");
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* Init sysfs */
+	ret = msm_otg_sysfs_create_files(&pdev->dev);
+	if (ret)
+		dev_dbg(&pdev->dev, "mode sysfs file is"
+			"not available\n");
+#endif /* end of CONFIG_SIERRA */
+/* SWISTOP */
+
 	if (motg->pdata->phy_type == SNPS_28NM_INTEGRATED_PHY) {
 		if (motg->pdata->otg_control == OTG_PMIC_CONTROL &&
 			(!(motg->pdata->mode == USB_OTG) ||
@@ -4027,6 +4260,22 @@ static int __init msm_otg_probe(struct platform_device *pdev)
 	if (motg->pdata->enable_lpm_on_dev_suspend)
 		motg->caps |= ALLOW_LPM_ON_DEV_SUSPEND;
 
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+	if (msm_get_usb_det() == 2)
+	{
+		gpio_request(motg->pdata->vdd_min_enable, "VDD_MIN_GPIO"); 
+		gpio_direction_input(motg->pdata->vdd_min_enable); 
+	}
+	else
+	{
+		/* usb_det may be not ready at this time, so buffer the mpm_otgsessvld_int */
+		vddmin_gpio = motg->pdata->vdd_min_enable;
+	}
+#endif
+/* SWISTOP */
+
 	wake_lock(&motg->wlock);
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
@@ -4069,6 +4318,21 @@ static int __init msm_otg_probe(struct platform_device *pdev)
 	if (legacy_power_supply && pdata->otg_control == OTG_PMIC_CONTROL)
 		pm8921_charger_register_vbus_sn(&msm_otg_set_vbus_state);
 
+/* SWISTART */
+/* Based on case 1091889 */
+#ifdef CONFIG_SIERRA
+	if (msm_get_usb_det() == 2)
+	{
+		suspend_work_q = create_singlethread_workqueue("suspend_usb");
+		if (suspend_work_q == NULL) {
+			ret = -ENOMEM;
+			dev_err(&pdev->dev, "Unable to create PM suspend workqueue\n");
+			goto remove_phy;
+		}
+	}
+#endif
+/* SWISTOP */
+
 	return 0;
 
 remove_phy:
@@ -4113,6 +4377,31 @@ free_motg:
 	return ret;
 }
 
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+void msm_otg_vddmin_init(void)
+{
+	gpio_request(vddmin_gpio, "VDD_MIN_GPIO"); 
+	gpio_direction_input(vddmin_gpio); 
+
+	/* Based on case 1091889 */
+	if (suspend_work_q == NULL)
+	{
+		suspend_work_q = create_singlethread_workqueue("suspend_usb");
+	}
+
+	if (msm_otg_connected)
+	{
+		msm_mpm_set_pin_type(msm_otg_sessvld_int, IRQ_TYPE_EDGE_FALLING);
+	}
+	else
+	{
+		msm_mpm_set_pin_type(msm_otg_sessvld_int, IRQ_TYPE_EDGE_RISING);
+	}
+}
+#endif
+/* SWISTOP */
 static int __devexit msm_otg_remove(struct platform_device *pdev)
 {
 	struct msm_otg *motg = platform_get_drvdata(pdev);
@@ -4128,10 +4417,39 @@ static int __devexit msm_otg_remove(struct platform_device *pdev)
 		pm8921_charger_unregister_vbus_sn(0);
 	msm_otg_mhl_register_callback(motg, NULL);
 	msm_otg_debugfs_cleanup();
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* Remove sysfs */
+	msm_otg_sysfs_remove_files(&pdev->dev);
+#endif /* end of CONFIG_SIERRA */
+/* SWISTOP */
 	cancel_delayed_work_sync(&motg->chg_work);
 	cancel_delayed_work_sync(&motg->pmic_id_status_work);
+/* SWISTART */
+/* Based on case 1091889 */
+#ifdef CONFIG_SIERRA
+	if (msm_get_usb_det() < 2)
+	{
+#endif /* end of CONFIG_SIERRA */
+/* SWISTOP */
 	cancel_delayed_work_sync(&motg->suspend_work);
+/* SWISTART */
+/* Based on case 1091889 */
+#ifdef CONFIG_SIERRA
+	}
+#endif /* end of CONFIG_SIERRA */
+/* SWISTOP */
+
 	cancel_work_sync(&motg->sm_work);
+/* SWISTART */
+/* Based on case 1091889 */
+#ifdef CONFIG_SIERRA
+	if (msm_get_usb_det() == 2 && suspend_work_q != NULL)
+	{
+		destroy_workqueue(suspend_work_q);
+	}
+#endif /* end of CONFIG_SIERRA */
+/* SWISTOP */
 
 	pm_runtime_resume(&pdev->dev);
 
diff --git a/drivers/usb/serial/GobiSerial.c b/drivers/usb/serial/GobiSerial.c
new file mode 100644
index 0000000..108cf69
--- /dev/null
+++ b/drivers/usb/serial/GobiSerial.c
@@ -0,0 +1,859 @@
+/*===========================================================================
+FILE:
+   GobiSerial.c
+
+DESCRIPTION:
+   Linux Qualcomm Serial USB driver Implementation
+
+PUBLIC DRIVER FUNCTIONS:
+   GobiProbe
+   GobiOpen
+   GobiClose
+   GobiReadBulkCallback (if kernel is less than 2.6.25)
+   GobiSerialSuspend
+   GobiSerialResume (if kernel is less than 2.6.24)
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+Alternatively, provided that this notice is retained in full, this software
+may be relicensed by the recipient under the terms of the GNU General Public
+License version 2 ("GPL") and only version 2, in which case the provisions of
+the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+software under the GPL, then the identification text in the MODULE_LICENSE
+macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+recipient changes the license terms to the GPL, subsequent recipients shall
+not relicense under alternate licensing terms, including the BSD or dual
+BSD/GPL terms.  In addition, the following license statement immediately
+below and between the words START and END shall also then apply when this
+software is relicensed under the GPL:
+
+START
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License version 2 and only version 2 as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+END
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+==========================================================================*/
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/usb.h>
+#include <linux/usb/serial.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+//---------------------------------------------------------------------------
+// Global variables and definitions
+//---------------------------------------------------------------------------
+
+// Version Information
+#define DRIVER_VERSION "2013-03-06/SWI_2.9"
+#define DRIVER_AUTHOR "Qualcomm Innovation Center"
+#define DRIVER_DESC "GobiSerial"
+
+#define NUM_BULK_EPS         1
+#define MAX_BULK_EPS         6
+
+#define SET_CONTROL_LINE_STATE_REQUEST_TYPE        0x21
+#define SET_CONTROL_LINE_STATE_REQUEST             0x22
+#define CONTROL_DTR                     0x01
+#define CONTROL_RTS                     0x02
+
+
+// Debug flag
+static int debug;
+// flow control flag
+static int flow_control = 1;
+// allow port open to success even when GPS control message failed
+static int ignore_gps_start_error = 1;
+
+// Number of serial interfaces
+static int nNumInterfaces;
+
+// Global pointer to usb_serial_generic_close function
+// This function is not exported, which is why we have to use a pointer
+// instead of just calling it.
+   void (* gpClose)( struct usb_serial_port * );
+
+// DBG macro
+#define DBG( format, arg... ) \
+   if (debug == 1)\
+   { \
+      printk( KERN_INFO "GobiSerial::%s " format, __FUNCTION__, ## arg ); \
+   } \
+
+/*=========================================================================*/
+// Function Prototypes
+/*=========================================================================*/
+
+// Attach to correct interfaces
+static int GobiProbe(
+   struct usb_serial * pSerial,
+   const struct usb_device_id * pID );
+
+// Start GPS if GPS port, run usb_serial_generic_open
+   int GobiOpen(
+      struct tty_struct *        pTTY,
+      struct usb_serial_port *   pPort );
+
+// Stop GPS if GPS port, run usb_serial_generic_close
+   void GobiClose( struct usb_serial_port * );
+
+// Set reset_resume flag
+int GobiSerialSuspend(
+   struct usb_interface *     pIntf,
+   pm_message_t               powerEvent );
+
+/*============================================================================*/
+// Blacklisted Interface Lists - used to filter out non serial device interfaces
+/*============================================================================*/
+#define BLACKLISTED_INTERFACE_LIST_TERMINATOR  (signed char)(-1)
+static const signed char qmi_non_serial_interfaces[]  =
+   {8, 19, 20, BLACKLISTED_INTERFACE_LIST_TERMINATOR};
+static const signed char gobi_non_serial_interfaces[] =
+   {0, BLACKLISTED_INTERFACE_LIST_TERMINATOR};
+
+/*=========================================================================*/
+// Qualcomm Gobi 3000 VID/PIDs
+/*=========================================================================*/
+static struct usb_device_id GobiVIDPIDTable[] =
+{
+   { USB_DEVICE(0x05c6, 0x920c) },   // Gobi 3000 QDL
+   { USB_DEVICE(0x05c6, 0x920d) },   // Gobi 3000 Composite
+   /* Sierra Wireless QMI VID/PID */
+   { USB_DEVICE(0x1199, 0x68A2),
+      .driver_info = (kernel_ulong_t)&qmi_non_serial_interfaces
+   },
+   /* Sierra Wireless G5K Application VID/PID */
+   { USB_DEVICE(0x1199, 0x9041),
+      .driver_info = (kernel_ulong_t)&qmi_non_serial_interfaces
+   },
+   /* Sierra Wireless G3K Boot VID/PID */
+   { USB_DEVICE(0x1199, 0x9010) },
+   /* Sierra Wireless G3K Device Application VID/PID */
+   { USB_DEVICE(0x1199, 0x9011),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   /* Sierra Wireless G3K Boot VID/PID */
+   { USB_DEVICE(0x1199, 0x9012) },
+   /* Sierra Wireless G3K Application VID/PID */
+   { USB_DEVICE(0x1199, 0x9013),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   /* Sierra Wireless G3K Boot VID/PID */
+   { USB_DEVICE(0x1199, 0x9014) },
+   /* Sierra Wireless G3K Application VID/PID */
+   { USB_DEVICE(0x1199, 0x9015),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   /* Sierra Wireless G3K Boot VID/PID */
+   { USB_DEVICE(0x1199, 0x9018) },
+   /* Sierra Wireless G3K Application VID/PID */
+   { USB_DEVICE(0x1199, 0x9019),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   /* G3K Boot VID/PID */
+   { USB_DEVICE(0x03F0, 0x361D) },
+   /* G3K Application VID/PID */
+   { USB_DEVICE(0x03F0, 0x371D),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   { }  // Terminating entry
+};
+MODULE_DEVICE_TABLE( usb, GobiVIDPIDTable );
+
+/* per port private data */
+struct sierra_port_private {
+   /* Settings for the port */
+   int rts_state;    /* Handshaking pins (outputs) */
+   int dtr_state;
+};
+
+
+/*=========================================================================*/
+// Struct usb_serial_driver
+// Driver structure we register with the USB core
+/*=========================================================================*/
+static struct usb_driver GobiDriver =
+{
+   .name       = "GobiSerial",
+   .probe      = usb_serial_probe,
+   .disconnect = usb_serial_disconnect,
+   .id_table   = GobiVIDPIDTable,
+#ifdef CONFIG_PM
+   .suspend    = GobiSerialSuspend,
+   .resume     = usb_serial_resume,
+   .supports_autosuspend = true,
+#else
+   .suspend    = NULL,
+   .resume     = NULL,
+   .supports_autosuspend = false,
+#endif
+};
+
+static int Gobi_calc_interface(struct usb_serial *serial)
+{
+   int interface;
+   struct usb_interface *p_interface;
+   struct usb_host_interface *p_host_interface;
+   dev_dbg(&serial->dev->dev, "%s\n", __func__);
+
+   /* Get the interface structure pointer from the serial struct */
+   p_interface = serial->interface;
+
+   /* Get a pointer to the host interface structure */
+   p_host_interface = p_interface->cur_altsetting;
+
+   /* read the interface descriptor for this active altsetting
+    * to find out the interface number we are on
+    */
+   interface = p_host_interface->desc.bInterfaceNumber;
+
+   return interface;
+}
+
+static int Gobi_send_setup(struct usb_serial_port *port)
+{
+   struct usb_serial *serial = port->serial;
+   struct sierra_port_private *portdata;
+   __u16 interface = 0;
+   int val = 0;
+   int retval;
+
+   dev_dbg(&port->dev, "%s\n", __func__);
+
+   portdata = usb_get_serial_port_data(port);
+
+   if (portdata->dtr_state)
+      val |= CONTROL_DTR;
+   if (portdata->rts_state)
+      val |= CONTROL_RTS;
+
+   /* obtain interface for usb control message below */
+   if (serial->num_ports == 1) {
+      interface = Gobi_calc_interface(serial);
+   }
+   else {
+      dev_err(&port->dev, 
+            "flow control is not supported for %d serial port\n",
+            serial->num_ports);
+      return -ENODEV;
+   }
+
+   retval = usb_autopm_get_interface(serial->interface);
+   if (retval < 0)
+   {
+      return retval;
+   }
+
+   retval = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
+         SET_CONTROL_LINE_STATE_REQUEST,
+         SET_CONTROL_LINE_STATE_REQUEST_TYPE,
+         val, interface, NULL, 0, USB_CTRL_SET_TIMEOUT);
+   usb_autopm_put_interface(serial->interface);
+
+   return retval;
+}
+
+static void Gobi_dtr_rts(struct usb_serial_port *port, int on)
+{
+   struct usb_serial *serial = port->serial;
+   struct sierra_port_private *portdata;
+
+   portdata = usb_get_serial_port_data(port);
+   portdata->rts_state = on;
+   portdata->dtr_state = on;
+
+   /* only send down the usb control message if enabled */
+   if (serial->dev && flow_control) {
+      mutex_lock(&serial->disc_mutex);
+      if (!serial->disconnected)
+      {
+         Gobi_send_setup(port);
+      }
+      mutex_unlock(&serial->disc_mutex);
+   }
+}
+
+static int Gobi_startup(struct usb_serial *serial)
+{
+   struct usb_serial_port *port = NULL;
+   struct sierra_port_private *portdata = NULL;
+   int i;
+
+   dev_dbg(&serial->dev->dev, "%s\n", __func__);
+
+   if (serial->num_ports) {
+      /* Note: One big piece of memory is allocated for all ports 
+       * private data in one shot. This memory is split into equal 
+       * pieces for each port. 
+       */
+      portdata = (struct sierra_port_private *)kzalloc
+         (sizeof(*portdata) * serial->num_ports, GFP_KERNEL);
+      if (!portdata) {
+         dev_dbg(&serial->dev->dev, "%s: No memory!\n", __func__);
+         return -ENOMEM;
+      }
+   }
+
+   /* Now setup per port private data */
+   for (i = 0; i < serial->num_ports; i++, portdata++) {
+      port = serial->port[i];
+
+      /* Set the port private data pointer */
+      usb_set_serial_port_data(port, portdata);
+   }
+
+   return 0;
+}
+
+static void Gobi_release(struct usb_serial *serial)
+{
+   int i;
+   struct usb_serial_port *port;
+   struct sierra_intf_private *intfdata = serial->private;
+
+   dev_dbg(&serial->dev->dev, "%s\n", __func__);
+
+   if (serial->num_ports > 0) {
+      port = serial->port[0];
+      if (port)
+      {
+         /* Note: The entire piece of memory that was allocated 
+          * in the startup routine can be released by passing
+          * a pointer to the beginning of the piece.
+          * This address corresponds to the address of the chunk
+          * that was given to port 0.
+          */
+         kfree(usb_get_serial_port_data(port));
+      }
+   }
+
+   for (i = 0; i < serial->num_ports; ++i) {
+      port = serial->port[i];
+      if (!port)
+      {
+         continue;
+      }
+      usb_set_serial_port_data(port, NULL);
+   }
+   kfree(intfdata);
+}
+
+/*=========================================================================*/
+// Struct usb_serial_driver
+/*=========================================================================*/
+static struct usb_serial_driver gGobiDevice =
+{
+   .driver =
+   {
+      .owner     = THIS_MODULE,
+      .name      = "GobiSerial driver",
+   },
+   .description         = "GobiSerial",
+   .id_table            = GobiVIDPIDTable,
+   .usb_driver          = &GobiDriver,
+   .num_ports           = NUM_BULK_EPS,
+   .probe               = GobiProbe,
+   .open                = GobiOpen,
+   .dtr_rts             = Gobi_dtr_rts,
+   .attach              = Gobi_startup,
+   .release             = Gobi_release,
+};
+
+static struct usb_serial_driver * const serial_drivers[] = {
+   &gGobiDevice, NULL
+};
+
+//---------------------------------------------------------------------------
+// USB serial core overridding Methods
+//---------------------------------------------------------------------------
+
+/*===========================================================================
+METHOD:
+   InterfaceIsBlacklisted (Free Method)
+
+DESCRIPTION:
+   Check whether an interface is blacklisted
+
+PARAMETERS:
+   ifnum           [ I ] - interface number
+   pblklist        [ I ] - black listed interface list
+
+RETURN VALUE:
+   bool - true if the interface is blacklisted
+          false otherwise
+===========================================================================*/
+static bool InterfaceIsBlacklisted(
+   const signed char ifnum,
+   const signed char *pblklist)
+{
+   if (pblklist != NULL)
+   {
+      while(*pblklist != BLACKLISTED_INTERFACE_LIST_TERMINATOR)
+      {
+         if (*pblklist == ifnum)
+             return true;
+         pblklist ++;
+      }
+   }
+   return false;
+}
+
+/*===========================================================================
+METHOD:
+   GobiProbe (Free Method)
+
+DESCRIPTION:
+   Attach to correct interfaces
+
+PARAMETERS:
+   pSerial    [ I ] - Serial structure
+   pID        [ I ] - VID PID table
+
+RETURN VALUE:
+   int - negative error code on failure
+         zero on success
+===========================================================================*/
+static int GobiProbe(
+   struct usb_serial * pSerial,
+   const struct usb_device_id * pID )
+{
+   // Assume failure
+   int nRetval = -ENODEV;
+   int nInterfaceNum;
+   struct usb_host_endpoint * pEndpoint;
+   int endpointIndex;
+   int numEndpoints;
+
+   DBG( "\n" );
+
+   // Test parameters
+   if ( (pSerial == NULL)
+   ||   (pSerial->dev == NULL)
+   ||   (pSerial->dev->actconfig == NULL)
+   ||   (pSerial->interface == NULL)
+   ||   (pSerial->interface->cur_altsetting == NULL)
+   ||   (pSerial->type == NULL) )
+   {
+      DBG( "invalid parameter\n" );
+      return -EINVAL;
+   }
+
+   nNumInterfaces = pSerial->dev->actconfig->desc.bNumInterfaces;
+   DBG( "Num Interfaces = %d\n", nNumInterfaces );
+   nInterfaceNum = pSerial->interface->cur_altsetting->desc.bInterfaceNumber;
+   DBG( "This Interface = %d\n", nInterfaceNum );
+
+   if (nNumInterfaces == 1)
+   {
+      // QDL mode?
+      if ((nInterfaceNum == 0) || (nInterfaceNum == 1))
+      {
+         DBG( "QDL port found\n" );
+         nRetval = usb_set_interface( pSerial->dev,
+                                      nInterfaceNum,
+                                      0 );
+         if (nRetval < 0)
+         {
+            DBG( "Could not set interface, error %d\n", nRetval );
+         }
+      }
+      else
+      {
+         DBG( "Incorrect QDL interface number\n" );
+      }
+   }
+   else if (nNumInterfaces > 1)
+   {
+      /* Composite mode */
+      if( InterfaceIsBlacklisted((signed char)nInterfaceNum,
+          (const signed char *)pID->driver_info) )
+      {
+         DBG( "Ignoring blacklisted interface #%d\n", nInterfaceNum );
+         return -ENODEV;
+      }
+      else
+      {
+         nRetval = usb_set_interface( pSerial->dev,
+                                      nInterfaceNum,
+                                      0 );
+         if (nRetval < 0)
+         {
+            DBG( "Could not set interface, error %d\n", nRetval );
+         }
+
+         // Check for recursion
+         if (pSerial->type->close != GobiClose)
+         {
+            // Store usb_serial_generic_close in gpClose
+            gpClose = pSerial->type->close;
+            pSerial->type->close = GobiClose;
+         }
+      }
+   }
+   if (nRetval == 0 && nNumInterfaces > 1 )
+   {
+      // Clearing endpoint halt is a magic handshake that brings
+      // the device out of low power (airplane) mode
+      // NOTE: FCC verification should be done before this, if required
+      numEndpoints = pSerial->interface->cur_altsetting
+                         ->desc.bInterfaceNumber;
+
+      for (endpointIndex = 0; endpointIndex < numEndpoints; endpointIndex++)
+      {
+         pEndpoint = pSerial->interface->cur_altsetting->endpoint
+                   + endpointIndex;
+
+         if (pEndpoint != NULL
+         &&  usb_endpoint_dir_out( &pEndpoint->desc ) == true)
+         {
+            int pipe = usb_sndbulkpipe( pSerial->dev,
+                                        pEndpoint->desc.bEndpointAddress );
+            nRetval = usb_clear_halt( pSerial->dev, pipe );
+
+            // Should only be one
+            break;
+         }
+      }
+   }
+
+   return nRetval;
+}
+
+/*===========================================================================
+METHOD:
+   IsGPSPort (Free Method)
+
+DESCRIPTION:
+   Determines whether the interface is GPS port
+
+PARAMETERS:
+   pPort   [ I ] - USB serial port structure
+
+RETURN VALUE:
+   bool- true if this is a GPS port
+       - false otherwise
+===========================================================================*/
+bool IsGPSPort(struct usb_serial_port *   pPort )
+{
+   DBG( "Product=0x%x, Interface=0x%x\n",
+        cpu_to_le16(pPort->serial->dev->descriptor.idProduct),
+        pPort->serial->interface->cur_altsetting->desc.bInterfaceNumber);
+
+   switch (cpu_to_le16(pPort->serial->dev->descriptor.idProduct))
+   {
+      case 0x68A2:  /* Sierra Wireless QMI */
+         if (pPort->serial->interface->cur_altsetting->desc.bInterfaceNumber == 2)
+            return true;
+         break;
+
+      case 0x9011:  /* Sierra Wireless G3K */
+      case 0x9013:  /* Sierra Wireless G3K */
+      case 0x9015:  /* Sierra Wireless G3K */
+      case 0x9019:  /* Sierra Wireless G3K */
+      case 0x371D:  /* G3K */
+         if (pPort->serial->interface->cur_altsetting->desc.bInterfaceNumber == 3)
+            return true;
+         break;
+
+      default:
+         return false;
+         break;
+  }
+  return false;
+}
+
+/*===========================================================================
+METHOD:
+   GobiOpen (Free Method)
+
+DESCRIPTION:
+   Start GPS if GPS port, run usb_serial_generic_open
+
+PARAMETERS:
+   pTTY    [ I ] - TTY structure (only on kernels <= 2.6.26)
+   pPort   [ I ] - USB serial port structure
+   pFilp   [ I ] - File structure (only on kernels <= 2.6.31)
+
+RETURN VALUE:
+   int - zero for success
+       - negative errno on error
+===========================================================================*/
+int GobiOpen(
+   struct tty_struct *        pTTY,
+   struct usb_serial_port *   pPort )
+{
+   const char startMessage[] = "$GPS_START";
+   int nResult;
+   int bytesWrote;
+
+   DBG( "\n" );
+
+   // Test parameters
+   if ( (pPort == NULL)
+   ||   (pPort->serial == NULL)
+   ||   (pPort->serial->dev == NULL)
+   ||   (pPort->serial->interface == NULL)
+   ||   (pPort->serial->interface->cur_altsetting == NULL) )
+   {
+      DBG( "invalid parameter\n" );
+      return -EINVAL;
+   }
+
+   // Is this the GPS port?
+   if ((IsGPSPort(pPort)) == true)
+   {
+      // Send startMessage, 1s timeout
+      nResult = usb_bulk_msg( pPort->serial->dev,
+                              usb_sndbulkpipe( pPort->serial->dev,
+                                               pPort->bulk_out_endpointAddress ),
+                              (void *)&startMessage[0],
+                              sizeof( startMessage ),
+                              &bytesWrote,
+                              1000 );
+      if (nResult != 0)
+      {
+         DBG( "error %d sending startMessage\n", nResult );
+         if (!ignore_gps_start_error)
+         {
+            return nResult;
+         }
+      }
+      if (bytesWrote != sizeof( startMessage ))
+      {
+         DBG( "invalid write size %d, %u\n",
+              bytesWrote,
+              sizeof( startMessage ) );
+         if (!ignore_gps_start_error)
+         {
+            return -EIO;
+         }
+      }
+   }
+
+   // Clear endpoint halt condition
+   if( nNumInterfaces > 1 )
+   {
+      nResult = usb_clear_halt(pPort->serial->dev,
+                               usb_sndbulkpipe(pPort->serial->dev,
+                               pPort->bulk_in_endpointAddress) | USB_DIR_IN );
+      if (nResult != 0)
+      {
+         DBG( "usb_clear_halt return value = %d\n", nResult );
+      }
+   }
+
+   // Pass to usb_serial_generic_open
+   return usb_serial_generic_open( pTTY, pPort );
+}
+
+/*===========================================================================
+METHOD:
+   GobiClose (Free Method)
+
+DESCRIPTION:
+   Stop GPS if GPS port, run usb_serial_generic_close
+
+PARAMETERS:
+   pTTY    [ I ] - TTY structure (only if kernel > 2.6.26 and <= 2.6.29)
+   pPort   [ I ] - USB serial port structure
+   pFilp   [ I ] - File structure (only on kernel <= 2.6.30)
+===========================================================================*/
+void GobiClose( struct usb_serial_port * pPort )
+{
+   const char stopMessage[] = "$GPS_STOP";
+   int nResult;
+   int bytesWrote;
+
+   DBG( "\n" );
+
+   // Test parameters
+   if ( (pPort == NULL)
+   ||   (pPort->serial == NULL)
+   ||   (pPort->serial->dev == NULL)
+   ||   (pPort->serial->interface == NULL)
+   ||   (pPort->serial->interface->cur_altsetting == NULL) )
+   {
+      DBG( "invalid parameter\n" );
+      return;
+   }
+
+   // Is this the GPS port?
+   if ((IsGPSPort(pPort)) == true)
+   {
+      // Send stopMessage, 1s timeout
+      nResult = usb_bulk_msg( pPort->serial->dev,
+                              usb_sndbulkpipe( pPort->serial->dev,
+                                               pPort->bulk_out_endpointAddress ),
+                              (void *)&stopMessage[0],
+                              sizeof( stopMessage ),
+                              &bytesWrote,
+                              1000 );
+      if (nResult != 0)
+      {
+         DBG( "error %d sending stopMessage\n", nResult );
+      }
+      if (bytesWrote != sizeof( stopMessage ))
+      {
+         DBG( "invalid write size %d, %u\n",
+              bytesWrote,
+              sizeof( stopMessage ) );
+      }
+   }
+
+   // Pass to usb_serial_generic_close
+   if (gpClose == NULL)
+   {
+      DBG( "NULL gpClose\n" );
+      return;
+   }
+
+   gpClose( pPort );
+}
+
+#ifdef CONFIG_PM
+/*===========================================================================
+METHOD:
+   GobiSerialSuspend (Public Method)
+
+DESCRIPTION:
+   Set reset_resume flag
+
+PARAMETERS
+   pIntf          [ I ] - Pointer to interface
+   powerEvent     [ I ] - Power management event
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int GobiSerialSuspend(
+   struct usb_interface *     pIntf,
+   pm_message_t               powerEvent )
+{
+   struct usb_serial * pDev;
+
+   if (pIntf == 0)
+   {
+      return -ENOMEM;
+   }
+
+   pDev = usb_get_intfdata( pIntf );
+   if (pDev == NULL)
+   {
+      return -ENXIO;
+   }
+
+   // Unless this is PM_EVENT_SUSPEND, make sure device gets rescanned
+   if ((powerEvent.event & PM_EVENT_SUSPEND) == 0)
+   {
+      pDev->dev->reset_resume = 1;
+   }
+
+   // Run usb_serial's suspend function
+   return usb_serial_suspend( pIntf, powerEvent );
+}
+#endif /* CONFIG_PM*/
+
+#ifdef CONFIG_PM
+#endif /* CONFIG_PM*/
+/*===========================================================================
+METHOD:
+   GobiInit (Free Method)
+
+DESCRIPTION:
+   Register the driver and device
+
+PARAMETERS:
+
+RETURN VALUE:
+   int - negative error code on failure
+         zero on success
+===========================================================================*/
+static int __init GobiInit( void )
+{
+   int nRetval = 0;
+   gpClose = NULL;
+
+   nRetval = usb_serial_register_drivers(&GobiDriver, serial_drivers);
+   if (nRetval == 0)
+   {
+      printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+            DRIVER_DESC "\n");
+   }
+
+   return nRetval;
+}
+
+/*===========================================================================
+METHOD:
+   GobiExit (Free Method)
+
+DESCRIPTION:
+   Deregister the driver and device
+
+PARAMETERS:
+
+RETURN VALUE:
+===========================================================================*/
+static void __exit GobiExit( void )
+{
+   gpClose = NULL;
+   usb_serial_deregister_drivers(&GobiDriver, serial_drivers);
+}
+
+// Calling kernel module to init our driver
+module_init( GobiInit );
+module_exit( GobiExit );
+
+MODULE_VERSION( DRIVER_VERSION );
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE( "Dual BSD/GPL" );
+
+module_param(debug, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC(debug, "Debug enabled or not" );
+module_param(flow_control, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC(flow_control, "flow control enabled or not" );
+module_param(ignore_gps_start_error, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC(ignore_gps_start_error, 
+   "allow port open to success even when GPS control message failed");
diff --git a/drivers/usb/serial/Kconfig b/drivers/usb/serial/Kconfig
index be53b92..e130485 100644
--- a/drivers/usb/serial/Kconfig
+++ b/drivers/usb/serial/Kconfig
@@ -660,6 +660,14 @@ config USB_SERIAL_ZIO
 	  To compile this driver as a module, choose M here: the
 	  module will be called zio.
 
+config USB_SERIAL_GOBI_SERIAL
+	tristate "Qualcomm Serial USB driver Implementation"
+	help
+	  Say Y here if you want to use Qualcomm GOBI Serial.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called zio.
+
 config USB_SERIAL_SSU100
 	tristate "USB Quatech SSU-100 Single Port Serial Driver"
 	help
diff --git a/drivers/usb/serial/Makefile b/drivers/usb/serial/Makefile
index 893adfa..f52480f 100644
--- a/drivers/usb/serial/Makefile
+++ b/drivers/usb/serial/Makefile
@@ -62,5 +62,8 @@ obj-$(CONFIG_USB_SERIAL_WHITEHEAT)		+= whiteheat.o
 obj-$(CONFIG_USB_SERIAL_XIRCOM)			+= keyspan_pda.o
 obj-$(CONFIG_USB_SERIAL_VIVOPAY_SERIAL)		+= vivopay-serial.o
 obj-$(CONFIG_USB_SERIAL_ZIO)			+= zio.o
+#SWISTART
+obj-$(CONFIG_USB_SERIAL_GOBI_SERIAL)		+= GobiSerial.o
+#SWISTOP
 obj-$(CONFIG_FUSIONSTAGING)                += fusion.o
 obj-$(CONFIG_GOBISERIAL)           += gobi_serial.o 
diff --git a/include/linux/sierra_bsudefs.h b/include/linux/sierra_bsudefs.h
new file mode 100644
index 0000000..aa35f93
--- /dev/null
+++ b/include/linux/sierra_bsudefs.h
@@ -0,0 +1,242 @@
+/* kernel/include/linux/sierra_bsudefs.h
+ *
+ * Copyright (C) 2013 Sierra Wireless, Inc
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef BS_UDEFS_H
+#define BS_USDEFS_H
+/************
+ *
+ * Name:     bshwtype
+ *
+ * Purpose:  To enumerate hardware types
+ *
+ * Members:  BSQCTMTP    - Qualcomm MTP
+ *           BSHWNONE    - HW type NONE (Fuse has not been blown yet)
+ *           BSAC770S    - AirCard 770S (HANSEL)
+ *           BSMC7355    - MiniCard 7355
+ *           BSAR7550    - Automotive 7550
+ *           BSAR7552    - Automotive 7552
+ *           BSAR7554    - Automotive 7554
+ *           BSEM7355    - Embedded Module 7355
+ *           BSAC340U    - AirCard 340U (GRADY)
+ *           BSWP7100    - WP7100 (for Verizon)
+ *           BSWP7102    - WP7102 (for AT&T)
+ *           BSWP7104    - WP7104 (for EU&APAC)
+ *           BSMC7305    - MiniCard 7305
+ *           BSEM7305    - Embedded Module 7305
+ *           BSAC342U    - AirCard 342U (OSSO)
+ *           BSEM7655    - EM7655 (TFF version of EM7355)
+ *           BSMC8805    - MiniCard 8805
+ *           BSEM8805    - Embeddded Module 8805
+ *           BSWP7100_INSIM    - WP7100 (with In-SIM)
+ *           BSWP7102_INSIM    - WP7102 (with In-SIM)
+ *           BSWP7104_INSIM    - WP7104 (with In-SIM)
+ *           BSMC7800    - MiniCard 7800 (for Verizon & Sprint)
+ *           BSMC7800LO  - MiniCard 7800 LTE Only (for Verizon)
+ *           BSMC7802    - MiniCard 7802 (for AT&T)
+ *           BSMC7804    - MiniCard 7804 (for EU)
+ *           BSWP7100_LARGER_MEMORY    - WP7100 (with Larger Memory Design)
+ *           BSWP7102_LARGER_MEMORY    - WP7102 (with Larger Memory Design)
+ *           BSWP7104_LARGER_MEMORY    - WP7104 (with Larger Memory Design)
+ *           BSEM7330    - Embedded Module 7330
+ *           BSMC7330    - MiniCard 7330
+ *           BSAC343U    - AirCard 343U (HERMES WORLD MODE)
+ *           BSMC7371    - MiniCard 7371
+ *           BSAC778S    - Aircard 778S 
+ *           BSAR7550_LARGER_MEMORY    - Automotive 7550 (with Larger Memory Design) 
+ *           BSAR7552_LARGER_MEMORY    - Automotive 7552 (with Larger Memory Design) 
+ *           BSAR7554_LARGER_MEMORY    - Automotive 7554 (with Larger Memory Design) 
+ *           BSWP7100_NEW    - WP7100 with large memory and share same PCB with BSAR7550_LARGER_MEMORY
+ *           BSWP7102_NEW    - WP7100 with large memory and share same PCB with BSAR7552_LARGER_MEMORY 
+ *           BSWP7104_NEW    - WP7100 with large memory and share same PCB with BSAR7554_LARGER_MEMORY              
+ *           BSHWUNKNOWN - Unknown HW
+ *           BSHWINVALID - Invalid HW
+ *
+ * Notes:    None
+ *
+ ************/
+enum bshwtype
+{
+  BSQCTMTP,
+  BSHWNONE,
+  BSAC770S,
+  BSMC7355,
+  BSAR7550,
+  BSAR7552,
+  BSAR7554,
+  BSEM7355,
+  BSAC340U,
+  BSWP7100,
+  BSWP7102,
+  BSWP7104,
+  BSMC7305,
+  BSEM7305,
+  BSAC342U,
+  BSAC341U,
+  BSEM7655,
+  BSMC8805,
+  BSEM8805,
+  BSAC771S,
+  BSYW7X55,
+  BSWP7100_INSIM,   /* this is kept to align with BS_QFPROM_PROD_ID */
+  BSWP7102_INSIM,   /* this is kept to align with BS_QFPROM_PROD_ID */
+  BSWP7104_INSIM,   /* this is kept to align with BS_QFPROM_PROD_ID */
+  BSMC7800,
+  BSMC7800LO,
+  BSMC7802,
+  BSMC7804,
+  BSWP7100_LARGER_MEMORY,
+  BSWP7102_LARGER_MEMORY,
+  BSWP7104_LARGER_MEMORY, 
+  BSEM7330,
+  BSMC7330,
+  BSAC343U,
+  BSMC7371,
+  BSAC778S,
+  BSAR7550_LARGER_MEMORY,
+  BSAR7552_LARGER_MEMORY,
+  BSAR7554_LARGER_MEMORY,
+  BSWP7100_NEW,
+  BSWP7102_NEW,
+  BSWP7104_NEW,  
+  BSHWUNKNOWN,
+  BSHWINVALID = 0xFF
+};
+
+/************
+ *
+ * Name:     bsproctype
+ *
+ * Purpose:  Enumerate processor types
+ *
+ * Members:  BSPROC_UNKNOWN    - unknown
+ *           BSPROC_APPS       - Application processor
+ *           BSPROC_MODEM      - Modem processor
+ *           BSPROC_MAX        - Used for bounds checking
+ *
+ * Notes:    None
+ *
+ ************/
+enum bsproctype
+{
+  BSPROC_UNKNOWN = 0,
+  BSPROC_APPS,
+  BSPROC_MODEM,
+  
+  BSPROC_MAX
+};
+
+/************
+ *
+ * Name:     bshwrev
+ *
+ * Purpose:  To enumerate hardware revisions
+ *
+ * Members:  BSHWREV0              - Revision 0
+ *           BSHWDV1               - HW DV1
+ *           BSHWDV2               - HW DV2
+ *           BSHWDV3               - HW DV3
+ *           BSHWAC770SDV1         - Hansel DV1
+ *           BSHWREVMAX            - maximum possible HW revision
+ *           BSHWREVUNKNOWN - unknown revision
+ *
+ * Notes:
+ *          still keep BSHWREV0 for a while for backward compatible
+ *
+ *          In the early development phase, the HWREV of DV1 for some device may not be 4
+ *            define device specific enum here if needed, e.g. BSHWAC770SDV1
+ *          
+ *          For DV2.1, the HW rev in FSN should be "02" and the GPIO40/45 should both be low
+ *            then BSHWDV2 = 2 << 2, i.e. 8
+ *
+ *          For DV3.1, the HW rev in FSN should be "03" and the GPIO40/45 should both be low
+ *            then BSHWDV3 = 3 << 2, i.e. 12
+ * 
+ ************/
+enum bshwrev
+{
+  BSHWREV0 = 0,
+  BSHWDV1 = 4,
+  BSHWDV2 = 8,
+  BSHWDV3 = 12,
+  BSHWPP  = 40,
+
+  BSHWAC770SDV1 = 44,  /* AC770S DV1 */
+  
+  BSHWREVMAX = 59,
+  BSHWREVUNKNOWN = 0xFF
+};
+
+/************
+ *
+ * Name:     bsfeature
+ *
+ * Purpose:  Enumerated list of different features supported by different hardware variants
+ *
+ * Members:  BSFEATURE_MINICARD  - if the hardware is a MiniCard
+ *           BSFEATURE_USB       - if the hardware is a USB dongle
+ *           BSFEATURE_MHS       - if the hardware is a Mobile Hotspot product
+ *           BSFEATURE_AR        - if the hardware is an AR product
+ *           BSFEATURE_WP        - if the hardware is a WP product
+ *           BSFEATURE_W_DISABLE - if W_DISABLE is supported
+ *           BSFEATURE_SD        - if SD is supported
+ *           BSFEATURE_VOICE     - if voice is supported
+ *           BSFEATURE_HSUPA     - if the hardware supports HSUPA
+ *           BSFEATURE_GPIOSAR  -  if GPIO controlled SAR backoff is supported
+ *           BSFEATURE_RMAUTOCONNECT - if auto-connect feature is device centric
+ *           BSFEATURE_UART      - if the hardware support UART
+ *           BSFEATURE_ANTSEL    - if the hardware supports ANTSEL
+ *           BSFEATURE_INSIM     - Internal SIM supported (eSIM)
+ *           BSFEATURE_OOBWAKE   - if has OOB_WAKE GPIO
+ *           BSFEATURE_CDMA      - if the hardware supports CDMA/1x
+ *           BSFEATURE_GSM       - if the hardware supports GSM/EDGE
+ *           BSFEATURE_WCDMA     - if the hardware supports WCDMA
+ *           BSFEATURE_LTE       - if the hardware supports LTE
+ *           BSFEATURE_EM        - if device is EM product
+ *           BSFEATURE_SVC_PIN_DLOAD - if service pin for DL mode is supported
+ *           BSFEATURE_BUZZER    - if the hardware supports Buzzer  
+ *           BSFEATURE_MAX       - Used for bounds checking
+ *
+ * Notes:    None
+ *
+ ************/
+enum bsfeature
+{
+  BSFEATURE_MINICARD,
+  BSFEATURE_USB,
+  BSFEATURE_MHS,
+  BSFEATURE_AR,
+  BSFEATURE_WP,
+  BSFEATURE_W_DISABLE,
+  BSFEATURE_SD,
+  BSFEATURE_VOICE,
+  BSFEATURE_HSUPA,
+  BSFEATURE_GPIOSAR,
+  BSFEATURE_RMAUTOCONNECT,
+  BSFEATURE_UART,
+  BSFEATURE_ANTSEL,
+  BSFEATURE_INSIM,
+  BSFEATURE_OOBWAKE,
+  BSFEATURE_CDMA,
+  BSFEATURE_GSM,
+  BSFEATURE_WCDMA,
+  BSFEATURE_LTE,
+  BSFEATURE_EM,
+  BSFEATURE_SVC_PIN_DLOAD,
+  BSFEATURE_BUZZER,  
+  BSFEATURE_MAX
+};
+
+
+#endif
diff --git a/include/linux/sierra_bsuproto.h b/include/linux/sierra_bsuproto.h
new file mode 100644
index 0000000..4eb9202
--- /dev/null
+++ b/include/linux/sierra_bsuproto.h
@@ -0,0 +1,24 @@
+/* kernel/include/linux/sierra_bsuproto.h
+ *
+ * Copyright (C) 2013 Sierra Wireless, Inc
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+ 
+#ifndef BS_UPROTO_H
+#define BS_UPROTO_H
+
+extern enum bshwtype bsgethwtype(void);
+extern uint8_t bsgethwrev(void);
+extern uint32_t bsgetmanufacturingcode(void);
+extern bool bssupport(enum bsfeature feature);
+
+#endif
diff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.h
index 742b9e4..2e171cd 100644
--- a/include/linux/usb/composite.h
+++ b/include/linux/usb/composite.h
@@ -161,7 +161,13 @@ int usb_interface_id(struct usb_configuration *, struct usb_function *);
 int config_ep_by_speed(struct usb_gadget *g, struct usb_function *f,
 			struct usb_ep *_ep);
 
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 #define	MAX_CONFIG_INTERFACES		16	/* arbitrary; max 255 */
+#else
+#define	MAX_CONFIG_INTERFACES		32	/* arbitrary; max 255 */
+#endif
+/* SWISTOP */
 
 /**
  * struct usb_configuration - represents one gadget configuration
diff --git a/include/linux/usb/msm_hsusb.h b/include/linux/usb/msm_hsusb.h
index d12d378..55a832d 100644
--- a/include/linux/usb/msm_hsusb.h
+++ b/include/linux/usb/msm_hsusb.h
@@ -223,6 +223,12 @@ struct msm_otg_platform_data {
 	bool delay_lpm_on_disconnect;
 	struct msm_bus_scale_pdata *bus_scale_table;
 	const char *mhl_dev_name;
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+	unsigned vdd_min_enable;
+#endif
+/* SWISTOP */
 };
 
 /* Timeout (in msec) values (min - max) associated with OTG timers */
@@ -480,6 +486,15 @@ enum usb_bam {
 	MAX_BAMS,
 };
 
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+int msm_get_usb_det(void);
+void msm9615_pm8xxx_gpio_mpp_init_swi(void);
+void msm_otg_vddmin_init(void);
+#endif
+/* SWISTOP */
+
 #ifdef CONFIG_USB_CI13XXX_MSM
 void msm_hw_bam_disable(bool bam_disable);
 
diff --git a/include/linux/usb/sierra_ududefs.h b/include/linux/usb/sierra_ududefs.h
new file mode 100755
index 0000000..af6eff8
--- /dev/null
+++ b/include/linux/usb/sierra_ududefs.h
@@ -0,0 +1,159 @@
+/************
+ *
+ * $Id$
+ *
+ * Filename:  sierra_ududefs - user definitions USB gadget driver
+ *
+ * Copyright: � 2012 Sierra Wireless, Inc.
+ *            All rights reserved
+ *
+ ************/
+#ifndef SIERRA_UDUDEFS_H
+#define SIERRA_UDUDEFS_H
+
+#define UD_PID_68A2 0x68A2
+#define UD_PID_68B1 0x68B1
+
+/* Vendor specific setup request (bRequest) */
+#define UD_SWI_SETUP_REQ_SET_DEVICE_POWER_STATE   0x00
+#define UD_SWI_SETUP_REQ_SET_MODE_NON_MUX         0x01
+#define UD_SWI_SETUP_REQ_SET_MODE_MUX             0x02
+#define UD_SWI_SETUP_REQ_GET_MODE_MUX             0x03
+#define UD_SWI_SETUP_REQ_GET_NDIS_SUPPORT         0x04
+#define UD_SWI_SETUP_REQ_GET_NDIS_PREF            0x05
+#define UD_SWI_SETUP_REQ_GET_ATTRIBUTE            0x06
+#define UD_SWI_SETUP_REQ_SET_MODE_NMEA            0x07
+#define UD_SWI_SETUP_REQ_GET_MODE_NMEA            0x08
+#define UD_SWI_SETUP_REQ_SET_HOST_POWER_STATE     0x09
+#define UD_SWI_SETUP_REQ_GET_DEV_SWOC_INFO        0x0A
+#define UD_SWI_SETUP_REQ_SET_DEV_SWOC_MODE        0x0B
+#define UD_SWI_SETUP_REQ_GET_CONFIG_ITEM          0x0C
+#define UD_SWI_SETUP_REQ_SET_CONFIG_ITEM          0x0D
+#define UD_SWI_SETUP_REQ_SET_DEVICE_RESET         0x0E
+#define UD_SWI_SETUP_REQ_GET_OS_FEATURE_REQUEST   0x20
+#define UD_SWI_SETUP_REQ_NULL                     0xFF
+
+/* Sierra USB Interface Information */
+struct ud_usb_interface {
+  unsigned number;
+  char * name;
+};
+
+/* 
+  Define Interface assignments for each possible interface 
+  Interfaces may be exposed or not based on entry in "Start_USB" shell script
+  Supports interface types that require more than one interface #
+  Ordering is important for those interface types requiring more than one #
+  Interface #'s can be listed multiple times, however, They will be assigned in 
+  first-come-first-served fashion.
+  NOTE: To use interface #'s larger than 15 increase define MAX_CONFIG_INTERFACES
+*/
+static const struct ud_usb_interface ud_interface_68A2[] = {
+  /* Interface #      Name   */
+  {    0,       "diag"         },
+  {    1,       "adb"          },
+  {    2,       "nmea"         },
+  {    3,       "modem"        },
+  {    4,       "at"           },
+  {    5,       "raw_data"     },
+  {    6,       "osa"          },
+  {    8,       "rmnet0"       }, 
+  {    9,       "mass_storage" }, 
+  {   10,       "rmnet1"       }, 
+  {   11,       "rmnet2"       }, 
+  {   12,       "usb_mbim"     }, 
+  {   13,       "usb_mbim"     }, 
+  {   14,       "rndis"        }, 
+  {   15,       "rndis"        },
+  {   16,       "audio"        },
+  {   17,       "audio"        },
+  {   18,       "audio"        },
+  {   19,       "ecm"          },
+  {   20,       "ecm"          },
+};
+
+static const struct ud_usb_interface ud_interface_68B1[] = {
+  /* Interface #      Name   */
+  {    0,       "usb_mbim"     }, 
+  {    1,       "usb_mbim"     }, 
+  {    2,       "diag"         },
+  {    3,       "modem"        },
+  {    4,       "nmea"         },
+  {    5,       "mass_storage" }, 
+  {    6,       "adb"          },
+  {    8,       "rmnet0"       }, 
+  {   10,       "rmnet1"       }, 
+  {   11,       "rmnet2"       }, 
+  {   14,       "rndis"        }, 
+  {   15,       "rndis"        }, 
+};
+
+#define UD_MAX_INTERFACE_68A2 ARRAY_SIZE(ud_interface_68A2)
+#define UD_MAX_INTERFACE_68B1 ARRAY_SIZE(ud_interface_68B1)
+
+#define UD_INVALID_INTERFACE 255
+
+static bool interface_reserved[MAX_CONFIG_INTERFACES];
+
+static inline unsigned ud_get_interface_number( const char *interface_name, struct usb_configuration *config )
+{
+  unsigned interface_number = UD_INVALID_INTERFACE;
+  unsigned i;
+  unsigned max = UD_MAX_INTERFACE_68A2;
+  const struct ud_usb_interface * ud_interface = &ud_interface_68A2[0];
+
+  if(config->cdev->desc.idProduct == UD_PID_68B1)
+  {
+    ud_interface = &ud_interface_68B1[0];
+    max = UD_MAX_INTERFACE_68B1;
+  }
+    
+  for (i = 0 ; i < max ; i++ )
+  {
+    interface_reserved[ud_interface->number] = true;
+    
+    if ( (strcmp(interface_name, ud_interface->name) == 0) &&
+         (config->interface[ud_interface->number] == NULL) )
+    {
+      /* Strings match */
+      interface_number = ud_interface->number;
+      break;
+    }
+    ud_interface++;
+  }
+
+  if( interface_number == UD_INVALID_INTERFACE )
+  {
+    /* Find next available */
+    for(i=0 ; i<MAX_CONFIG_INTERFACES ; i++)
+    {
+      if( (interface_reserved[i] == false) && 
+          (config->interface[i] == NULL) )
+      {
+        interface_number = i;
+        break;
+      }
+    }
+    pr_info("No Match for Function Name: %s, Int #%d\n", interface_name, interface_number);
+  }
+  else
+  {
+    pr_info("Match for Function Name: %s, Int #%d\n", interface_name, interface_number);  
+  }
+
+  return (interface_number);
+}
+/*Data types for TRU-Install*/
+typedef enum{
+  CDROM_TO_ECM,
+  ECM_TO_CDROM,
+  HID_TO_CDROM,
+  HID_TO_ECM,
+  ECM_TO_HID,	
+}ud_usb_dev_switch;
+
+typedef struct {
+  unsigned char MsgType;
+} ud_msg_notify;
+
+#endif	/* SIERRA_UDUDEFS_H */
diff --git a/kernel/panic.c b/kernel/panic.c
index b4fe7e1..435c7b2 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -24,6 +24,11 @@
 #include <linux/nmi.h>
 #include <linux/dmi.h>
 #include <trace/kernel.h>
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#include <mach/sierra_smem.h>
+#endif /* SIERRA */
+/* SWISTOP */
 
 DEFINE_TRACE(kernel_panic);
 
@@ -108,6 +113,16 @@ void panic(const char *fmt, ...)
 	vsnprintf(buf, sizeof(buf), fmt, args);
 	va_end(args);
 	printk(KERN_EMERG "Kernel panic - not syncing: %s\n",buf);
+
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* mark the start of Sierra dump */
+	sierra_smem_errdump_save_start();
+
+	/* log error str */
+	sierra_smem_errdump_save_errstr(buf);
+#endif /* SIERRA */
+/* SWISTOP */
 #ifdef CONFIG_DEBUG_BUGVERBOSE
 	/*
 	 * Avoid nested stack-dumping if a panic occurs during oops processing
diff --git a/sound/soc/codecs/wcd9304.c b/sound/soc/codecs/wcd9304.c
index 2d82eb7..79908e8 100644
--- a/sound/soc/codecs/wcd9304.c
+++ b/sound/soc/codecs/wcd9304.c
@@ -1024,7 +1024,13 @@ static int sitar_codec_enable_anc(struct snd_soc_dapm_widget *w,
 	int i;
 	int ret;
 	int num_anc_slots;
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	struct anc_header *anc_head;
+#else
+    struct sitar_anc_header *anc_head;
+#endif
+/* SWISTOP */
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
 	u32 anc_writes_size = 0;
 	int anc_size_remaining;
@@ -1048,17 +1054,30 @@ static int sitar_codec_enable_anc(struct snd_soc_dapm_widget *w,
 				ret);
 			return -ENODEV;
 		}
-
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 		if (fw->size < sizeof(struct anc_header)) {
+#else
+		if (fw->size < sizeof(struct sitar_anc_header)) {
+#endif
+/* SWISTOP */
 			dev_err(codec->dev, "Not enough data\n");
 			release_firmware(fw);
 			return -ENOMEM;
 		}
 
 		/* First number is the number of register writes */
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 		anc_head = (struct anc_header *)(fw->data);
 		anc_ptr = (u32 *)((u32)fw->data + sizeof(struct anc_header));
 		anc_size_remaining = fw->size - sizeof(struct anc_header);
+#else
+		anc_head = (struct sitar_anc_header *)(fw->data);
+		anc_ptr = (u32 *)((u32)fw->data + sizeof(struct sitar_anc_header));
+		anc_size_remaining = fw->size - sizeof(struct sitar_anc_header);
+#endif
+/* SWISTOP */
 		num_anc_slots = anc_head->num_anc_slots;
 
 		if (sitar->anc_slot >= num_anc_slots) {
diff --git a/sound/soc/codecs/wcd9304.h b/sound/soc/codecs/wcd9304.h
index a512039..3cc2283 100644
--- a/sound/soc/codecs/wcd9304.h
+++ b/sound/soc/codecs/wcd9304.h
@@ -181,7 +181,13 @@ extern int sitar_hs_detect(struct snd_soc_codec *codec,
 			const struct sitar_mbhc_config *cfg);
 
 #ifndef anc_header_dec
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 struct anc_header {
+#else
+struct sitar_anc_header {
+#endif
+/* SWISTOP */
 	u32 reserved[3];
 	u32 num_anc_slots;
 };
diff --git a/sound/soc/msm/Kconfig b/sound/soc/msm/Kconfig
index d5cada7..ffa62ce 100644
--- a/sound/soc/msm/Kconfig
+++ b/sound/soc/msm/Kconfig
@@ -186,6 +186,9 @@ config SND_SOC_MDM9615
 	select SND_SOC_QDSP6
 	select SND_SOC_MSM_STUB
 	select SND_SOC_WCD9310
+#SWISTART
+	select SND_SOC_WCD9304
+#SWISTOP
 	select SND_SOC_MSM_HOSTLESS_PCM
 	select SND_DYNAMIC_MINORS
 	help
diff --git a/sound/soc/msm/mdm9615.c b/sound/soc/msm/mdm9615.c
index 423aea2..29acde9 100644
--- a/sound/soc/msm/mdm9615.c
+++ b/sound/soc/msm/mdm9615.c
@@ -27,6 +27,16 @@
 #include <mach/socinfo.h>
 #include "msm-pcm-routing.h"
 #include "../codecs/wcd9310.h"
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+#include <sound/msm-dai-q6.h>
+#include <linux/sierra_bsudefs.h>
+#include <linux/sierra_bsuproto.h>
+#ifdef CONFIG_WCD9304_CODEC
+#include "../codecs/wcd9304.h"
+#endif
+#endif
+/* SWISTOP */
 #include <mach/gpiomux.h>
 
 /* 9615 machine driver */
@@ -57,6 +67,13 @@
 #define GPIO_SEC_AUX_PCM_CLK 25
 
 #define TABLA_EXT_CLK_RATE 12288000
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#ifdef CONFIG_WCD9304_CODEC
+#define SITAR_EXT_CLK_RATE 12288000
+#endif
+#endif
+/* SWISTOP */
 
 #define TABLA_MBHC_DEF_BUTTONS 8
 #define TABLA_MBHC_DEF_RLOADS 5
@@ -192,6 +209,100 @@ static struct msm_gpiomux_config msm9615_audio_sec_i2s_codec_configs[] = {
 		},
 	},
 };
+#if defined(CONFIG_SIERRA)
+static struct gpiomux_setting pri_audio_auxpcm[] = {
+  /* Suspended state */
+  {
+    .func = GPIOMUX_FUNC_GPIO,
+    .drv = GPIOMUX_DRV_2MA,
+    .pull = GPIOMUX_PULL_DOWN,
+  },
+  /* Active state */
+  {
+    .func = GPIOMUX_FUNC_1,
+    .drv = GPIOMUX_DRV_8MA,
+    .pull = GPIOMUX_PULL_NONE,
+  },
+};
+
+static struct gpiomux_setting sec_audio_auxpcm[] = {
+  /* Suspended state */
+  {
+    .func = GPIOMUX_FUNC_GPIO,
+    .drv = GPIOMUX_DRV_2MA,
+    .pull = GPIOMUX_PULL_DOWN,
+  },
+  /* Active state */
+  {
+    .func = GPIOMUX_FUNC_2,
+    .drv = GPIOMUX_DRV_8MA,
+    .pull = GPIOMUX_PULL_NONE,
+  },
+};
+
+static struct msm_gpiomux_config msm9615_audio_pri_pcm_codec_configs[] = {
+{
+		.gpio = GPIO_AUX_PCM_DOUT,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &pri_audio_auxpcm[0],
+			[GPIOMUX_ACTIVE] = &pri_audio_auxpcm[1],
+		},
+	},
+	{
+		.gpio = GPIO_AUX_PCM_DIN,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &pri_audio_auxpcm[0],
+			[GPIOMUX_ACTIVE] = &pri_audio_auxpcm[1],
+		},
+	},
+	{
+		.gpio = GPIO_AUX_PCM_SYNC,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &pri_audio_auxpcm[0],
+			[GPIOMUX_ACTIVE] = &pri_audio_auxpcm[1],
+		},
+	},
+	{
+		.gpio = GPIO_AUX_PCM_CLK,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &pri_audio_auxpcm[0],
+			[GPIOMUX_ACTIVE] = &pri_audio_auxpcm[1],
+		},
+	},
+};
+
+static struct msm_gpiomux_config msm9615_audio_sec_pcm_codec_configs[] = {
+{
+		.gpio = GPIO_SEC_AUX_PCM_DOUT,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &sec_audio_auxpcm[0],
+			[GPIOMUX_ACTIVE] = &sec_audio_auxpcm[1],
+		},
+	},
+	{
+		.gpio = GPIO_SEC_AUX_PCM_DIN,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &sec_audio_auxpcm[0],
+			[GPIOMUX_ACTIVE] = &sec_audio_auxpcm[1],
+		},
+	},
+	{
+		.gpio = GPIO_SEC_AUX_PCM_SYNC,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &sec_audio_auxpcm[0],
+			[GPIOMUX_ACTIVE] = &sec_audio_auxpcm[1],
+		},
+	},
+	{
+		.gpio = GPIO_SEC_AUX_PCM_CLK,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &sec_audio_auxpcm[0],
+			[GPIOMUX_ACTIVE] = &sec_audio_auxpcm[1],
+		},
+	},
+};
+#endif
+
 /* Physical address for LPA CSR
  * LPA SIF mux registers. These are
  * ioremap( ) for Virtual address.
@@ -313,6 +424,17 @@ static int mdm9615_btsco_ch = 1;
 
 static int mdm9615_auxpcm_rate = SAMPLE_RATE_8KHZ;
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+extern struct platform_device msm_cpudai_auxpcm_rx;
+extern struct platform_device msm_cpudai_sec_auxpcm_rx;
+static int mdm9615_auxpcm_mode = AFE_PCM_CFG_MODE_PCM ;
+static int mdm9615_auxpcm_sync = AFE_PCM_CFG_SYNC_INT ;
+static int mdm9615_auxpcm_quant = AFE_PCM_CFG_QUANT_LINEAR_NOPAD ;
+static int mdm9615_auxpcm_frame = AFE_PCM_CFG_FRM_256BPF;
+#endif 
+/* SWISTOP */
+
 static struct clk *codec_clk;
 static int clk_users;
 
@@ -526,9 +648,23 @@ static int mdm9615_enable_codec_ext_clk(struct snd_soc_codec *codec, int enable,
 			clk_users--;
 			return -EINVAL;
 		}
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+		clk_set_rate(codec_clk, TABLA_EXT_CLK_RATE);
+		clk_prepare_enable(codec_clk);
+		tabla_mclk_enable(codec, 1, dapm);
+#else
+#ifdef CONFIG_WCD9310_CODEC
 		clk_set_rate(codec_clk, TABLA_EXT_CLK_RATE);
 		clk_prepare_enable(codec_clk);
 		tabla_mclk_enable(codec, 1, dapm);
+#elif defined(CONFIG_WCD9304_CODEC)
+		clk_set_rate(codec_clk, SITAR_EXT_CLK_RATE);
+		clk_prepare_enable(codec_clk);
+		sitar_mclk_enable(codec, 1, dapm);
+#endif
+#endif
+/* SWISTOP */
 	} else {
 		pr_debug("%s: clk_users = %d\n", __func__, clk_users);
 		if (clk_users == 0)
@@ -537,7 +673,17 @@ static int mdm9615_enable_codec_ext_clk(struct snd_soc_codec *codec, int enable,
 		if (!clk_users) {
 			pr_debug("%s: disabling MCLK. clk_users = %d\n",
 					 __func__, clk_users);
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+			tabla_mclk_enable(codec, 0, dapm);
+#else
+#ifdef CONFIG_WCD9310_CODEC
 			tabla_mclk_enable(codec, 0, dapm);
+#elif defined(CONFIG_WCD9304_CODEC)
+			sitar_mclk_enable(codec, 0, dapm);
+#endif
+#endif
+/* SWISTOP */
 			clk_disable_unprepare(codec_clk);
 		}
 	}
@@ -558,6 +704,105 @@ static int mdm9615_mclk_event(struct snd_soc_dapm_widget *w,
 	return 0;
 }
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static int mdm9615_wp7_enable_codec_ext_clk(struct snd_soc_codec *codec, int enable,
+					bool dapm)
+{
+	pr_debug("%s: enable = %d\n", __func__, enable);
+	if (enable) {
+		clk_users++;
+		pr_debug("%s: clk_users = %d\n", __func__, clk_users);
+		if (clk_users != 1)
+			return 0;
+		if (IS_ERR(codec_clk)) {
+
+			pr_err("%s: Error setting MCLK\n", __func__);
+			clk_users--;
+			return -EINVAL;
+		}
+		clk_set_rate(codec_clk, TABLA_EXT_CLK_RATE);
+		clk_prepare_enable(codec_clk);
+	} else {
+		pr_debug("%s: clk_users = %d\n", __func__, clk_users);
+		if (clk_users == 0)
+			return 0;
+		clk_users--;
+		if (!clk_users) {
+			pr_debug("%s: disabling clk_users = %d\n",
+					 __func__, clk_users);
+			clk_disable_unprepare(codec_clk);
+		}
+	}
+	return 0;
+}
+
+static int mdm9615_wp7_mclk_event(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	pr_debug("%s: event = %d\n", __func__, event);
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		return mdm9615_wp7_enable_codec_ext_clk(w->codec, 1, true);
+	case SND_SOC_DAPM_POST_PMD:
+		return mdm9615_wp7_enable_codec_ext_clk(w->codec, 0, true);
+	}
+	return 0;
+}
+static int mdm9615_ar7_enable_codec_ext_clk(struct snd_soc_codec *codec, int enable,
+					bool dapm)
+{
+	pr_info("%s: enable = %d\n", __func__, enable);
+
+	if (enable) {
+		clk_users++;
+		pr_debug("%s: clk_users = %d\n", __func__, clk_users);
+
+		if (clk_users != 1)
+			return 0;
+		if (IS_ERR(codec_clk))
+		{
+			pr_err("%s: Error setting MCLK\n", __func__);
+			clk_users--;
+			return -EINVAL;
+		}
+		clk_set_rate(codec_clk, TABLA_EXT_CLK_RATE);
+		clk_prepare_enable(codec_clk);
+	} else {
+		pr_debug("%s: clk_users = %d\n", __func__, clk_users);
+		if (clk_users == 0)
+			return 0;
+		clk_users--;
+		if (!clk_users) {
+			pr_debug("%s: disabling clk_users = %d\n",
+					 __func__, clk_users);
+			clk_disable_unprepare(codec_clk);
+		}
+	}
+	return 0;
+}
+static int mdm9615_ar7_mclk_event(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	pr_info("%s: event = %d\n", __func__, event);
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		return mdm9615_ar7_enable_codec_ext_clk(w->codec, 1, true);
+	case SND_SOC_DAPM_POST_PMD:
+		return mdm9615_ar7_enable_codec_ext_clk(w->codec, 0, true);
+	}
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget mdm9615_ar7_dapm_widgets[] = {
+
+	SND_SOC_DAPM_SUPPLY("MCLK",  SND_SOC_NOPM, 0, 0,
+	mdm9615_ar7_mclk_event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+};
+#endif
+/* SWISTOP */
+
 static const struct snd_soc_dapm_widget mdm9615_dapm_widgets[] = {
 
 	SND_SOC_DAPM_SUPPLY("MCLK",  SND_SOC_NOPM, 0, 0,
@@ -581,8 +826,19 @@ static const struct snd_soc_dapm_widget mdm9615_dapm_widgets[] = {
 
 };
 
-static const struct snd_soc_dapm_route common_audio_map[] = {
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static const struct snd_soc_dapm_widget mdm9615_wp7_dapm_widgets[] = {
 
+	SND_SOC_DAPM_SUPPLY("MCLK",  SND_SOC_NOPM, 0, 0,
+	mdm9615_wp7_mclk_event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+};
+#endif
+/* SWISTOP */
+
+static const struct snd_soc_dapm_route common_audio_map[] = {
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	{"RX_BIAS", NULL, "MCLK"},
 	{"LDO_H", NULL, "MCLK"},
 
@@ -664,6 +920,144 @@ static const struct snd_soc_dapm_route common_audio_map[] = {
 	 */
 	{"DMIC6", NULL, "MIC BIAS4 External"},
 	{"MIC BIAS4 External", NULL, "Digital Mic6"},
+#else
+	{"RX_BIAS", NULL, "MCLK"},
+	{"LDO_H", NULL, "MCLK"},
+
+#ifdef CONFIG_WCD9304_CODEC
+	{"MIC BIAS1 Internal1", NULL, "MCLK"},
+	{"MIC BIAS2 Internal1", NULL, "MCLK"},
+#endif
+
+	/* Speaker path */
+#ifdef CONFIG_WCD9310_CODEC
+	{"Ext Spk Pos", NULL, "LINEOUT1"},
+	{"Ext Spk Neg", NULL, "LINEOUT3"},  
+
+	{"Ext Spk Pos", NULL, "LINEOUT2"},
+	{"Ext Spk Neg", NULL, "LINEOUT4"},
+#elif defined(CONFIG_WCD9304_CODEC)
+	{"Ext Spk Pos", NULL, "LINEOUT1"},
+	{"Ext Spk Neg", NULL, "LINEOUT2"},
+#endif
+
+	/* Microphone path */
+#ifdef CONFIG_WCD9310_CODEC
+	{"AMIC1", NULL, "MIC BIAS1 External"},
+	{"MIC BIAS1 External", NULL, "Handset Mic"},
+
+	{"AMIC2", NULL, "MIC BIAS2 External"},
+	{"MIC BIAS2 External", NULL, "Headset Mic"},
+
+  /**
+   * AMIC3 and AMIC4 inputs are connected to ANC microphones
+   * These mics are biased differently on CDP and FLUID
+   * routing entries below are based on bias arrangement
+   * on FLUID.
+   */
+	{"AMIC3", NULL, "MIC BIAS3 Internal1"},
+	{"MIC BIAS3 Internal1", NULL, "ANCRight Headset Mic"},
+  
+	{"AMIC4", NULL, "MIC BIAS1 Internal2"},
+	{"MIC BIAS1 Internal2", NULL, "ANCLeft Headset Mic"},
+#elif defined(CONFIG_WCD9304_CODEC)
+	/* Headset Mic */
+	{"AMIC2", NULL, "MIC BIAS2 External"},
+	{"MIC BIAS2 External", NULL, "Headset Mic"},
+
+	{"AMIC1", NULL, "MIC BIAS2 External"},
+	{"MIC BIAS2 External", NULL, "ANCLeft Headset Mic"},
+
+	{"AMIC3", NULL, "MIC BIAS2 External"},
+	{"MIC BIAS2 External", NULL, "ANCRight Headset Mic"},
+#endif
+
+	{"HEADPHONE", NULL, "LDO_H"},
+
+	/**
+	 * The digital Mic routes are setup considering
+	 * fluid as default device.
+	 */
+#ifdef CONFIG_WCD9310_CODEC
+	/**
+	 * Digital Mic1. Front Bottom left Digital Mic on Fluid and MTP.
+	 * Digital Mic GM5 on CDP mainboard.
+	 * Conncted to DMIC2 Input on Tabla codec.
+	 */
+	{"DMIC2", NULL, "MIC BIAS1 External"},
+	{"MIC BIAS1 External", NULL, "Digital Mic1"},
+
+	/**
+	 * Digital Mic2. Front Bottom right Digital Mic on Fluid and MTP.
+	 * Digital Mic GM6 on CDP mainboard.
+	 * Conncted to DMIC1 Input on Tabla codec.
+	 */
+	{"DMIC1", NULL, "MIC BIAS1 External"},
+	{"MIC BIAS1 External", NULL, "Digital Mic2"},
+
+	/**
+	 * Digital Mic3. Back Bottom Digital Mic on Fluid.
+	 * Digital Mic GM1 on CDP mainboard.
+	 * Conncted to DMIC4 Input on Tabla codec.
+	 */
+	{"DMIC4", NULL, "MIC BIAS3 External"},
+	{"MIC BIAS3 External", NULL, "Digital Mic3"},
+
+	/**
+	 * Digital Mic4. Back top Digital Mic on Fluid.
+	 * Digital Mic GM2 on CDP mainboard.
+	 * Conncted to DMIC3 Input on Tabla codec.
+	 */
+	{"DMIC3", NULL, "MIC BIAS3 External"},
+	{"MIC BIAS3 External", NULL, "Digital Mic4"},
+
+	/**
+	 * Digital Mic5. Front top Digital Mic on Fluid.
+	 * Digital Mic GM3 on CDP mainboard.
+	 * Conncted to DMIC5 Input on Tabla codec.
+	 */
+	{"DMIC5", NULL, "MIC BIAS4 External"},
+	{"MIC BIAS4 External", NULL, "Digital Mic5"},
+
+	/* Tabla digital Mic6 - back bottom digital Mic on Liquid and
+	 * bottom mic on CDP. FLUID/MTP do not have dmic6 installed.
+	 */
+	{"DMIC6", NULL, "MIC BIAS4 External"},
+	{"MIC BIAS4 External", NULL, "Digital Mic6"},
+#elif defined(CONFIG_WCD9304_CODEC)
+  /**
+	 * Digital Mic1. Front Bottom left Mic on Fluid and MTP.
+	 * Digital Mic GM5 on CDP mainboard.
+	 * Conncted to DMIC1 Input on Sitar codec.
+	 */
+	{"DMIC1", NULL, "MIC BIAS1 External"},
+	{"MIC BIAS1 External", NULL, "Digital Mic1"},
+
+	/**
+	 * Digital Mic2. Back top MIC on Fluid.
+	 * Digital Mic GM6 on CDP mainboard.
+	 * Conncted to DMIC2 Input on Sitar codec.
+	 */
+	{"DMIC2", NULL, "MIC BIAS1 External"},
+	{"MIC BIAS1 External", NULL, "Digital Mic2"},
+	/**
+	 * Digital Mic3. Back Bottom Digital Mic on Fluid.
+	 * Digital Mic GM1 on CDP mainboard.
+	 * Conncted to DMIC4 Input on Sitar codec.
+	 */
+	{"DMIC3", NULL, "MIC BIAS1 External"},
+	{"MIC BIAS1 External", NULL, "Digital Mic3"},
+
+	/**
+	 * Digital Mic4. Back top Digital Mic on Fluid.
+	 * Digital Mic GM2 on CDP mainboard.
+	 * Conncted to DMIC3 Input on Sitar codec.
+	 */
+	{"DMIC4", NULL, "MIC BIAS1 External"},
+	{"MIC BIAS1 External", NULL, "Digital Mic4"},
+#endif
+#endif
+/* SWISTOP */
 };
 
 static const char *spk_function[] = {"Off", "On"};
@@ -682,10 +1076,26 @@ static const struct soc_enum mdm9615_btsco_enum[] = {
 };
 
 static const char *auxpcm_rate_text[] = {"rate_8000", "rate_16000"};
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static const char *auxpcm_mode_text[] = {"PCM", "AUX"};
+static const char *auxpcm_sync_text[] = {"EXT", "INT"};
+static const char *auxpcm_quant_text[] = {"ALAW_NOPAD", "MULAW_NOPAD", "LINER_NOPAD", "ALAW_PAD", "MULAW_PAD", "LINER_PAD"};
+static const char *auxpcm_frame_text[] = {"BPB_8", "BPF_16", "BPF_32", "BPF_64", "BPF_128", "BPF_256"};
+
 static const struct soc_enum mdm9615_auxpcm_enum[] = {
 		SOC_ENUM_SINGLE_EXT(2, auxpcm_rate_text),
+		SOC_ENUM_SINGLE_EXT(2, auxpcm_mode_text),
+		SOC_ENUM_SINGLE_EXT(2, auxpcm_sync_text),
+		SOC_ENUM_SINGLE_EXT(6, auxpcm_quant_text),
+		SOC_ENUM_SINGLE_EXT(6, auxpcm_frame_text),
 };
-
+#else
+static const struct soc_enum mdm9615_auxpcm_enum[] = {
+		SOC_ENUM_SINGLE_EXT(2, auxpcm_rate_text),
+};
+#endif
+/* SWISTOP */
 static int mdm9615_slim_0_rx_ch_get(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
@@ -780,31 +1190,208 @@ static int mdm9615_auxpcm_rate_put(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static const struct snd_kcontrol_new tabla_mdm9615_controls[] = {
-	SOC_ENUM_EXT("Speaker Function", mdm9615_enum[0], mdm9615_get_spk,
-		mdm9615_set_spk),
-	SOC_ENUM_EXT("SLIM_0_RX Channels", mdm9615_enum[1],
-		mdm9615_slim_0_rx_ch_get, mdm9615_slim_0_rx_ch_put),
-	SOC_ENUM_EXT("SLIM_0_TX Channels", mdm9615_enum[2],
-		mdm9615_slim_0_tx_ch_get, mdm9615_slim_0_tx_ch_put),
-};
-
-static const struct snd_kcontrol_new int_btsco_rate_mixer_controls[] = {
-	SOC_ENUM_EXT("Internal BTSCO SampleRate", mdm9615_btsco_enum[0],
-		mdm9615_btsco_rate_get, mdm9615_btsco_rate_put),
-};
-
-static const struct snd_kcontrol_new auxpcm_rate_mixer_controls[] = {
-	SOC_ENUM_EXT("AUX PCM SampleRate", mdm9615_auxpcm_enum[0],
-		mdm9615_auxpcm_rate_get, mdm9615_auxpcm_rate_put),
-};
-
-static int mdm9615_btsco_init(struct snd_soc_pcm_runtime *rtd)
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static int mdm9615_auxpcm_mode_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	int err = 0;
-	struct snd_soc_platform *platform = rtd->platform;
+	pr_debug("%s: mdm9615_auxpcm_mode  = %d", __func__,
+		mdm9615_auxpcm_mode);
+	ucontrol->value.integer.value[0] = mdm9615_auxpcm_mode;
+	return 0;
+}
 
-	err = snd_soc_add_platform_controls(platform,
+static int mdm9615_auxpcm_mode_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		mdm9615_auxpcm_mode = AFE_PCM_CFG_MODE_PCM;
+		break;
+	case 1:
+		mdm9615_auxpcm_mode = AFE_PCM_CFG_MODE_AUX;
+		break;
+	default:
+		mdm9615_auxpcm_mode = AFE_PCM_CFG_MODE_PCM;
+		break;
+	}
+	pr_info("%s: mdm9615_auxpcm_mode = %d"
+		"ucontrol->value.integer.value[0] = %d\n", __func__,
+		mdm9615_auxpcm_mode,
+		(int)ucontrol->value.integer.value[0]);
+	return 0;
+}
+
+static int mdm9615_auxpcm_sync_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	pr_info("%s: mdm9615_auxpcm_sync  = %d", __func__,
+		mdm9615_auxpcm_sync);
+	ucontrol->value.integer.value[0] = mdm9615_auxpcm_sync;
+	return 0;
+}
+
+static int mdm9615_auxpcm_sync_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		mdm9615_auxpcm_sync = AFE_PCM_CFG_SYNC_EXT;
+		break;
+	case 1:
+		mdm9615_auxpcm_sync = AFE_PCM_CFG_SYNC_INT;
+		break;
+	default:
+		mdm9615_auxpcm_sync = AFE_PCM_CFG_SYNC_INT;
+		break;
+	}
+	pr_debug("%s: mdm9615_auxpcm_sync = %d"
+		"ucontrol->value.integer.value[0] = %d\n", __func__,
+		mdm9615_auxpcm_sync,
+		(int)ucontrol->value.integer.value[0]);
+	return 0;
+}
+
+static int mdm9615_auxpcm_quant_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	pr_debug("%s: mdm9615_auxpcm_quant  = %d", __func__,
+		mdm9615_auxpcm_quant);
+	ucontrol->value.integer.value[0] = mdm9615_auxpcm_quant;
+	return 0;
+}
+
+static int mdm9615_auxpcm_quant_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		mdm9615_auxpcm_quant = AFE_PCM_CFG_QUANT_ALAW_NOPAD;
+		break;
+	case 1:
+		mdm9615_auxpcm_quant = AFE_PCM_CFG_QUANT_MULAW_NOPAD;
+		break;
+	case 2:
+		mdm9615_auxpcm_quant = AFE_PCM_CFG_QUANT_LINEAR_NOPAD;
+		break;
+	case 3:
+		mdm9615_auxpcm_quant = AFE_PCM_CFG_QUANT_ALAW_PAD;
+		break;
+	case 4:
+		mdm9615_auxpcm_quant = AFE_PCM_CFG_QUANT_MULAW_PAD;
+		break;
+	case 5:
+		mdm9615_auxpcm_quant = AFE_PCM_CFG_QUANT_LINEAR_PAD;
+		break;
+	default:
+		mdm9615_auxpcm_quant = AFE_PCM_CFG_QUANT_LINEAR_NOPAD;
+		break;
+	}
+	pr_debug("%s: mdm9615_auxpcm_quant = %d"
+		"ucontrol->value.integer.value[0] = %d\n", __func__,
+		mdm9615_auxpcm_quant,
+		(int)ucontrol->value.integer.value[0]);
+	return 0;
+}
+
+static int mdm9615_auxpcm_frame_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	pr_debug("%s: mdm9615_auxpcm_frame  = %d", __func__,
+		mdm9615_auxpcm_frame);
+	ucontrol->value.integer.value[0] = mdm9615_auxpcm_frame;
+	return 0;
+}
+
+static int mdm9615_auxpcm_frame_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		mdm9615_auxpcm_frame = AFE_PCM_CFG_FRM_8BPF;
+		break;
+	case 1:
+		mdm9615_auxpcm_frame = AFE_PCM_CFG_FRM_16BPF;
+		break;
+	case 2:
+		mdm9615_auxpcm_frame = AFE_PCM_CFG_FRM_32BPF;
+		break;
+	case 3:
+		mdm9615_auxpcm_frame = AFE_PCM_CFG_FRM_64BPF;
+		break;
+	case 4:
+		mdm9615_auxpcm_frame = AFE_PCM_CFG_FRM_128BPF;
+		break;
+	case 5:
+		mdm9615_auxpcm_frame = AFE_PCM_CFG_FRM_256BPF;
+		break;
+	default:
+		mdm9615_auxpcm_frame = AFE_PCM_CFG_FRM_256BPF;
+		break;
+	}
+	pr_debug("%s: mdm9615_auxpcm_frame = %d"
+		"ucontrol->value.integer.value[0] = %d\n", __func__,
+		mdm9615_auxpcm_frame,
+		(int)ucontrol->value.integer.value[0]);
+	return 0;
+}
+#endif 
+
+static const struct snd_kcontrol_new tabla_mdm9615_controls[] = {
+	SOC_ENUM_EXT("Speaker Function", mdm9615_enum[0], mdm9615_get_spk,
+		mdm9615_set_spk),
+	SOC_ENUM_EXT("SLIM_0_RX Channels", mdm9615_enum[1],
+		mdm9615_slim_0_rx_ch_get, mdm9615_slim_0_rx_ch_put),
+	SOC_ENUM_EXT("SLIM_0_TX Channels", mdm9615_enum[2],
+		mdm9615_slim_0_tx_ch_get, mdm9615_slim_0_tx_ch_put),
+};
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+#ifdef CONFIG_WCD9304_CODEC
+static const struct snd_kcontrol_new sitar_mdm9615_controls[] = {
+	SOC_ENUM_EXT("Speaker Function", mdm9615_enum[0], mdm9615_get_spk,
+		mdm9615_set_spk),
+	SOC_ENUM_EXT("SLIM_0_RX Channels", mdm9615_enum[1],
+		mdm9615_slim_0_rx_ch_get, mdm9615_slim_0_rx_ch_put),
+	SOC_ENUM_EXT("SLIM_0_TX Channels", mdm9615_enum[2],
+		mdm9615_slim_0_tx_ch_get, mdm9615_slim_0_tx_ch_put),
+};
+#endif
+#endif
+/* SWISTOP */
+static const struct snd_kcontrol_new int_btsco_rate_mixer_controls[] = {
+	SOC_ENUM_EXT("Internal BTSCO SampleRate", mdm9615_btsco_enum[0],
+		mdm9615_btsco_rate_get, mdm9615_btsco_rate_put),
+};
+
+static const struct snd_kcontrol_new auxpcm_rate_mixer_controls[] = {
+	SOC_ENUM_EXT("AUX PCM SampleRate", mdm9615_auxpcm_enum[0],
+		mdm9615_auxpcm_rate_get, mdm9615_auxpcm_rate_put),
+};
+
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static const struct snd_kcontrol_new auxpcm_mixer_controls[] = {
+	SOC_ENUM_EXT("AUX PCM SampleRate", mdm9615_auxpcm_enum[0],
+		mdm9615_auxpcm_rate_get, mdm9615_auxpcm_rate_put),
+	SOC_ENUM_EXT("AUX PCM Mode", mdm9615_auxpcm_enum[1],
+		mdm9615_auxpcm_mode_get, mdm9615_auxpcm_mode_put),
+	SOC_ENUM_EXT("AUX PCM Sync", mdm9615_auxpcm_enum[2],
+		mdm9615_auxpcm_sync_get, mdm9615_auxpcm_sync_put),
+	SOC_ENUM_EXT("AUX PCM Quant", mdm9615_auxpcm_enum[3],
+		mdm9615_auxpcm_quant_get, mdm9615_auxpcm_quant_put),
+	SOC_ENUM_EXT("AUX PCM Frame", mdm9615_auxpcm_enum[4],
+		mdm9615_auxpcm_frame_get, mdm9615_auxpcm_frame_put),
+};
+#endif
+/* SWISTOP */
+
+static int mdm9615_btsco_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int err = 0;
+	struct snd_soc_platform *platform = rtd->platform;
+
+	err = snd_soc_add_platform_controls(platform,
 			int_btsco_rate_mixer_controls,
 		ARRAY_SIZE(int_btsco_rate_mixer_controls));
 	if (err < 0)
@@ -816,14 +1403,49 @@ static int mdm9615_auxpcm_init(struct snd_soc_pcm_runtime *rtd)
 {
 	int err = 0;
 	struct snd_soc_platform *platform = rtd->platform;
+	pr_info("%s()\n", __func__);
+  
 	err = snd_soc_add_platform_controls(platform,
 			auxpcm_rate_mixer_controls,
 			ARRAY_SIZE(auxpcm_rate_mixer_controls));
 	if (err < 0)
 		return err;
+
+	msm_gpiomux_install(msm9615_audio_pri_pcm_codec_configs,
+		  ARRAY_SIZE(msm9615_audio_pri_pcm_codec_configs));
+		
 	return 0;
 }
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static int mdm9615_ar7_sec_auxpcm_init(struct snd_soc_pcm_runtime *rtd)
+{
+  int err = 0;
+  struct snd_soc_platform *platform = rtd->platform;
+  struct snd_soc_codec *codec = rtd->codec;
+  struct snd_soc_dapm_context *dapm = &codec->dapm;
+  struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+  pr_info("%s()\n", __func__);
+
+  err = snd_soc_add_platform_controls(platform,
+      auxpcm_mixer_controls,
+      ARRAY_SIZE(auxpcm_mixer_controls));
+  if (err < 0)
+    return err;
+    
+  snd_soc_dapm_new_controls(dapm, mdm9615_ar7_dapm_widgets,
+          ARRAY_SIZE(mdm9615_ar7_dapm_widgets));
+
+  codec_clk = clk_get(cpu_dai->dev, "sec_pcm_clk");
+  
+  return 0;
+}
+
+#endif
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 static void *def_tabla_mbhc_cal(void)
 {
 	void *tabla_cal;
@@ -900,7 +1522,8 @@ static void *def_tabla_mbhc_cal(void)
 
 	return tabla_cal;
 }
-
+#endif
+/* SWISTOP */
 static int msm9615_i2s_set_spk(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
@@ -1076,6 +1699,51 @@ static int msm9615_i2s_audrx_init(struct snd_soc_pcm_runtime *rtd)
 	return err;
 }
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static const struct snd_kcontrol_new mdm9615_ar7_i2s_controls[] = {
+	SOC_ENUM_EXT("PRI_RX Channels", mdm9615_enum[0],
+		     msm9615_i2s_rx_ch_get, msm9615_i2s_rx_ch_put),
+	SOC_ENUM_EXT("PRI_TX Channels", mdm9615_enum[1],
+		     msm9615_i2s_tx_ch_get, msm9615_i2s_tx_ch_put),
+	SOC_ENUM_EXT("SEC_RX Channels", mdm9615_enum[2],
+			msm9615_i2s_rx_ch_get, msm9615_i2s_rx_ch_put),
+	SOC_ENUM_EXT("SEC_TX Channels", mdm9615_enum[3],
+			msm9615_i2s_tx_ch_get, msm9615_i2s_tx_ch_put),
+};
+
+static int mdm9615_ar7_sec_i2s_audrx_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int err;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+ 	pr_info("%s()\n", __func__);
+
+  	err = snd_soc_add_platform_controls(platform, mdm9615_ar7_i2s_controls,
+		ARRAY_SIZE(mdm9615_ar7_i2s_controls));
+ 
+	if (err < 0) {
+		pr_info("returning loc 1 err = %d\n", err);
+		return err;
+	}
+
+	snd_soc_dapm_new_controls(dapm, mdm9615_ar7_dapm_widgets,
+				ARRAY_SIZE(mdm9615_ar7_dapm_widgets));
+
+	msm_gpiomux_install(msm9615_audio_sec_i2s_codec_configs,
+				ARRAY_SIZE(msm9615_audio_sec_i2s_codec_configs));
+
+	codec_clk = clk_get(cpu_dai->dev, "osr_clk");
+
+	return 0;
+}
+
+#endif
+/* SWISTOP */
+
 static int msm9615_i2s_rx_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
 					     struct snd_pcm_hw_params *params)
 {
@@ -1528,6 +2196,7 @@ static int msm9615_i2s_startup(struct snd_pcm_substream *substream)
 		pr_err("%s: Err in i2s_intf_dir_sel\n", __func__);
 		return -EINVAL;
 	}
+
 	pr_debug("Exit %s() Enable status Rx =%d Tx = %d\n", __func__,
 		 pintf->intf_status[i2s_intf][MSM_DIR_RX],
 		 pintf->intf_status[i2s_intf][MSM_DIR_TX]);
@@ -1558,6 +2227,7 @@ static void msm9615_i2s_shutdown(struct snd_pcm_substream *substream)
 		pintf->intf_status[i2s_intf][i2s_dir]--;
 		mdm9615_i2s_free_gpios(i2s_intf, i2s_dir);
 	}
+
 	pr_debug("%s( ): Enable status Rx =%d Tx = %d\n", __func__,
 		 pintf->intf_status[i2s_intf][MSM_DIR_RX],
 		 pintf->intf_status[i2s_intf][MSM_DIR_TX]);
@@ -1597,7 +2267,10 @@ static int msm9615_i2s_prepare(struct snd_pcm_substream *substream)
 
 	if (wcd9xxx_get_intf_type() < 0)
 		ret = -ENODEV;
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	else if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C)
+#endif
 		mdm9615_install_codec_i2s_gpio(substream);
 
 	return ret;
@@ -1616,6 +2289,8 @@ static int mdm9615_audrx_init(struct snd_soc_pcm_runtime *rtd)
 	struct snd_soc_codec *codec = rtd->codec;
 	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	struct pm_gpio jack_gpio_cfg = {
 		.direction = PM_GPIO_DIR_IN,
 		.pull = PM_GPIO_PULL_NO,
@@ -1623,14 +2298,31 @@ static int mdm9615_audrx_init(struct snd_soc_pcm_runtime *rtd)
 		.vin_sel = 2,
 		.inv_int_pol = 0,
 	};
-
+#endif
+/* SWISTOP */
 	pr_debug("%s(), dev_name%s\n", __func__, dev_name(cpu_dai->dev));
 
 	rtd->pmdown_time = 0;
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	err = snd_soc_add_codec_controls(codec, tabla_mdm9615_controls,
 				ARRAY_SIZE(tabla_mdm9615_controls));
 	if (err < 0)
 		return err;
+#else
+#ifdef CONFIG_WCD9310_CODEC
+	err = snd_soc_add_codec_controls(codec, tabla_mdm9615_controls,
+				ARRAY_SIZE(tabla_mdm9615_controls));
+	if (err < 0)
+		return err;
+#elif defined(CONFIG_WCD9304_CODEC)
+	err = snd_soc_add_codec_controls(codec, sitar_mdm9615_controls,
+				ARRAY_SIZE(sitar_mdm9615_controls));
+	if (err < 0)
+		return err;
+#endif
+#endif
+/* SWISTOP */
 
 	snd_soc_dapm_new_controls(dapm, mdm9615_dapm_widgets,
 				ARRAY_SIZE(mdm9615_dapm_widgets));
@@ -1659,7 +2351,8 @@ static int mdm9615_audrx_init(struct snd_soc_pcm_runtime *rtd)
 		return err;
 	}
 	codec_clk = clk_get(cpu_dai->dev, "osr_clk");
-
+/* SWISTART */
+#ifndef CONFIG_SIERRA
 	if (hs_detect_use_gpio) {
 		pr_debug("%s: GPIO Headset detection enabled\n", __func__);
 		mbhc_cfg.gpio = PM8018_GPIO_PM_TO_SYS(JACK_DETECT_GPIO);
@@ -1678,7 +2371,8 @@ static int mdm9615_audrx_init(struct snd_soc_pcm_runtime *rtd)
 	mbhc_cfg.read_fw_bin = hs_detect_use_firmware;
 
 	err = tabla_hs_detect(codec, &mbhc_cfg);
-
+#endif
+/* SWISTOP */
 	return err;
 }
 
@@ -1744,6 +2438,76 @@ static int mdm9615_auxpcm_be_params_fixup(struct snd_soc_pcm_runtime *rtd,
 	return 0;
 }
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static int mdm9615_ar7_sec_auxpcm_be_params_fixup(struct snd_soc_pcm_runtime *rtd,
+					struct snd_pcm_hw_params *params)
+{
+  struct msm_dai_auxpcm_pdata *auxpcm_pdata = msm_cpudai_sec_auxpcm_rx.dev.platform_data;
+
+	struct snd_interval *rate = hw_param_interval(params,
+					SNDRV_PCM_HW_PARAM_RATE);
+
+	struct snd_interval *channels = hw_param_interval(params,
+					SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	rate->min = rate->max = mdm9615_auxpcm_rate;
+	/* PCM only supports mono output */
+	channels->min = channels->max = 1;
+
+	auxpcm_pdata->mode_8k.frame  = mdm9615_auxpcm_frame;
+	auxpcm_pdata->mode_16k.frame = mdm9615_auxpcm_frame;
+	auxpcm_pdata->mode_8k.quant  = mdm9615_auxpcm_quant;
+	auxpcm_pdata->mode_16k.quant = mdm9615_auxpcm_quant;
+	auxpcm_pdata->mode_8k.sync   = mdm9615_auxpcm_sync;
+	auxpcm_pdata->mode_16k.sync  = mdm9615_auxpcm_sync;
+	
+	if( mdm9615_auxpcm_sync == AFE_PCM_CFG_SYNC_INT)
+	{
+		auxpcm_pdata->mode_8k.mode  = mdm9615_auxpcm_mode;
+		auxpcm_pdata->mode_16k.mode = mdm9615_auxpcm_mode;
+
+		/* Pleae note that the less PCM clk supported is 512kHz, clk_tbl_pcm[] */
+		if (mdm9615_auxpcm_mode == AFE_PCM_CFG_MODE_PCM)
+		{  
+			auxpcm_pdata->mode_8k.pcm_clk_rate =(int)(8000 * 8 * (0x0001 << mdm9615_auxpcm_frame));
+			auxpcm_pdata->mode_16k.pcm_clk_rate =(int)(16000 * 8 * (0x0001 << mdm9615_auxpcm_frame));
+			if( auxpcm_pdata->mode_8k.pcm_clk_rate < 64000)
+			{
+				auxpcm_pdata->mode_8k.pcm_clk_rate = 64000;
+			}
+			if( auxpcm_pdata->mode_16k.pcm_clk_rate < 128000)
+			{
+				auxpcm_pdata->mode_16k.pcm_clk_rate = 128000;
+			}
+		}
+		else
+		{
+			auxpcm_pdata->mode_8k.pcm_clk_rate = 128000;
+			auxpcm_pdata->mode_8k.frame= AFE_PCM_CFG_FRM_16BPF;
+		}
+	}
+	else
+	{
+		/* AUX mode can't work at slave mode  */
+		auxpcm_pdata->mode_8k.mode  = AFE_PCM_CFG_MODE_PCM;
+		auxpcm_pdata->mode_16k.mode = AFE_PCM_CFG_MODE_PCM;
+		auxpcm_pdata->mode_8k.pcm_clk_rate  = 0;
+		auxpcm_pdata->mode_16k.pcm_clk_rate = 0;
+
+	}
+
+	pr_debug("%s() Pdata 8kHz: Mode=%d  Sync=%d  Frame=%d Quant=%d Clock=%d \n", __func__,auxpcm_pdata->mode_8k.mode,
+			auxpcm_pdata->mode_8k.sync,auxpcm_pdata->mode_8k.frame, auxpcm_pdata->mode_8k.quant,auxpcm_pdata->mode_8k.pcm_clk_rate);
+	pr_debug("%s() Pdata 16kHz: Mode=%d  Sync=%d  Frame=%d Quant=%d Clock=%d \n", __func__,auxpcm_pdata->mode_16k.mode,
+			auxpcm_pdata->mode_16k.sync,auxpcm_pdata->mode_16k.frame, auxpcm_pdata->mode_16k.quant,auxpcm_pdata->mode_16k.pcm_clk_rate);
+
+	return 0;
+}
+
+#endif
+/* SWISTOP */
+
 static int mdm9615_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
 			struct snd_pcm_hw_params *params)
 {
@@ -1927,6 +2691,32 @@ static int mdm9615_sec_auxpcm_startup(struct snd_pcm_substream *substream)
 	return 0;
 }
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static int mdm9615_ar7_sec_auxpcm_startup(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	pr_info("%s\n", __func__ );
+	pr_debug("%s(): substream = %s\n", __func__, substream->name);
+	
+	msm_gpiomux_install(msm9615_audio_sec_pcm_codec_configs,
+			ARRAY_SIZE(msm9615_audio_sec_pcm_codec_configs));
+	if (atomic_inc_return(&msm9615_sec_auxpcm_ref) == 1) {
+		ret = mdm9615_sec_aux_pcm_get_gpios();
+		if (ret < 0) {
+			pr_err("%s: SEC Aux PCM GPIO request failed\n",
+			       __func__);
+			return -EINVAL;
+		}
+		msm9615_config_sif_mux(MSM_SIF_FUNC_PCM);
+		msm9615_config_port_select();
+	}
+	return 0;
+}
+
+#endif
+
+/* SWISTOP */
 static void mdm9615_sec_auxpcm_shutdown(struct snd_pcm_substream *substream)
 {
 	pr_debug("%s(): substream = %s\n", __func__, substream->name);
@@ -1951,11 +2741,21 @@ static struct snd_soc_ops mdm9615_auxpcm_be_ops = {
 	.shutdown = mdm9615_auxpcm_shutdown,
 };
 
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+static struct snd_soc_ops mdm9615_ar7_sec_auxpcm_be_ops = {
+	.startup = mdm9615_ar7_sec_auxpcm_startup,
+	.shutdown = mdm9615_sec_auxpcm_shutdown,
+};
+#endif
+/* SWISTOP */
+
 static struct snd_soc_ops mdm9615_sec_auxpcm_be_ops = {
 	.startup = mdm9615_sec_auxpcm_startup,
 	.shutdown = mdm9615_sec_auxpcm_shutdown,
 };
 
+
 /* Digital audio interface glue - connects codec <---> CPU */
 static struct snd_soc_dai_link mdm9615_dai_common[] = {
 	/* FrontEnd DAI Links */
@@ -2309,76 +3109,684 @@ static struct snd_soc_dai_link mdm9615_dai_slimbus_tabla[] = {
 	},
 };
 
-
-static struct snd_soc_dai_link mdm9615_i2s_dai[
-					 ARRAY_SIZE(mdm9615_dai_common) +
-					 ARRAY_SIZE(mdm9615_dai_i2s_tabla)];
-
-static struct snd_soc_dai_link mdm9615_slimbus_dai[
-					 ARRAY_SIZE(mdm9615_dai_common) +
-					 ARRAY_SIZE(mdm9615_dai_slimbus_tabla)];
-
-
-static struct snd_soc_card snd_soc_card_mdm9615 = {
-		.name		= "mdm9615-tabla-snd-card",
-};
-
-static struct platform_device *mdm9615_snd_device;
-
-void  __init install_codec_i2s_gpio(void)
-{
-	msm_gpiomux_install(msm9615_audio_prim_i2s_codec_configs,
-			ARRAY_SIZE(msm9615_audio_prim_i2s_codec_configs));
-}
-static int __init mdm9615_audio_init(void)
-{
-	int ret;
-
-	/* Set GPIO headset detection by default */
-	hs_detect_use_gpio = true;
-
-	if (!cpu_is_msm9615()) {
-		pr_err("%s: Not the right machine type\n", __func__);
-		return -ENODEV ;
-	}
-
-	mbhc_cfg.calibration = def_tabla_mbhc_cal();
-	if (!mbhc_cfg.calibration) {
-		pr_err("Calibration data allocation failed\n");
-		return -ENOMEM;
-	}
-
-	mdm9615_snd_device = platform_device_alloc("soc-audio", 0);
-	if (!mdm9615_snd_device) {
-		pr_err("Platform device allocation failed\n");
-		kfree(mbhc_cfg.calibration);
-		return -ENOMEM;
-	}
-	pr_err("%s: Interface Type = %d\n", __func__,
-			wcd9xxx_get_intf_type());
-	if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
-		memcpy(mdm9615_slimbus_dai, mdm9615_dai_common,
-			sizeof(mdm9615_dai_common));
-		memcpy(mdm9615_slimbus_dai + ARRAY_SIZE(mdm9615_dai_common),
-		       mdm9615_dai_slimbus_tabla,
-		       sizeof(mdm9615_dai_slimbus_tabla));
-		snd_soc_card_mdm9615.dai_link = mdm9615_slimbus_dai;
-		snd_soc_card_mdm9615.num_links =
-				ARRAY_SIZE(mdm9615_slimbus_dai);
-	} else if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C) {
-		memcpy(mdm9615_i2s_dai, mdm9615_dai_common,
-		       sizeof(mdm9615_dai_common));
-		memcpy(mdm9615_i2s_dai + ARRAY_SIZE(mdm9615_dai_common),
-		       mdm9615_dai_i2s_tabla,
-		       sizeof(mdm9615_dai_i2s_tabla));
-		snd_soc_card_mdm9615.dai_link = mdm9615_i2s_dai;
-		snd_soc_card_mdm9615.num_links =
-				ARRAY_SIZE(mdm9615_i2s_dai);
-	} else{
-		snd_soc_card_mdm9615.dai_link = mdm9615_dai_common;
-		snd_soc_card_mdm9615.num_links =
-				ARRAY_SIZE(mdm9615_dai_common);
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+/* Digital audio interface glue - connects codec <---> CPU */
+static struct snd_soc_dai_link mdm9615_dai_wp7_new[] = {
+	/* FrontEnd DAI Links */
+	{
+		.name = "MDM9615 Media1",
+		.stream_name = "MultiMedia1",
+		.cpu_dai_name	= "MultiMedia1",
+		.platform_name  = "msm-pcm-dsp",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_MULTIMEDIA1
+	},
+	{
+		.name = "MDM9615 Media2",
+		.stream_name = "MultiMedia2",
+		.cpu_dai_name	= "MultiMedia2",
+		.platform_name  = "msm-pcm-dsp",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_MULTIMEDIA2,
+	},
+	{
+		.name = "Circuit-Switch Voice",
+		.stream_name = "CS-Voice",
+		.cpu_dai_name   = "CS-VOICE",
+		.platform_name  = "msm-pcm-voice",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_CS_VOICE,
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "MSM VoIP",
+		.stream_name = "VoIP",
+		.cpu_dai_name	= "VoIP",
+		.platform_name  = "msm-voip-dsp",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_VOIP,
+	},
+	{
+		.name = "MSM AFE-PCM RX",
+		.stream_name = "AFE-PROXY RX",
+		.cpu_dai_name = "msm-dai-q6.241",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.platform_name  = "msm-pcm-afe",
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "MSM AFE-PCM TX",
+		.stream_name = "AFE-PROXY TX",
+		.cpu_dai_name = "msm-dai-q6.240",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.platform_name  = "msm-pcm-afe",
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "SLIMBUS_0 Hostless",
+		.stream_name = "SLIMBUS_0 Hostless",
+		.cpu_dai_name	= "SLIMBUS0_HOSTLESS",
+		.platform_name  = "msm-pcm-hostless",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+		.ignore_suspend = 1,
+		/* .be_id = do not care */
+	},
+	{
+		.name = "AUXPCM Hostless",
+		.stream_name = "AUXPCM Hostless",
+		.cpu_dai_name	= "AUXPCM_HOSTLESS",
+		.platform_name  = "msm-pcm-hostless",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "VoLTE",
+		.stream_name = "VoLTE",
+		.cpu_dai_name   = "VoLTE",
+		.platform_name  = "msm-pcm-voice",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.be_id = MSM_FRONTEND_DAI_VOLTE,
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "DTMF RX Hostless",
+		.stream_name = "DTMF RX Hostless",
+		.cpu_dai_name	= "DTMF_RX_HOSTLESS",
+		.platform_name  = "msm-pcm-dtmf",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
+			    SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_DTMF_RX,
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+	},
+	{
+		.name = "DTMF TX",
+		.stream_name = "DTMF TX",
+		.cpu_dai_name = "msm-dai-stub",
+		.platform_name  = "msm-pcm-dtmf",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.ignore_suspend = 1,
+	},
+	
+	/* Backend AFE DAI Links */
+	{
+		.name = LPASS_BE_AFE_PCM_RX,
+		.stream_name = "AFE Playback",
+		.cpu_dai_name = "msm-dai-q6.224",
+		.platform_name = "msm-pcm-routing",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_AFE_PCM_RX,
+	},
+	{
+		.name = LPASS_BE_AFE_PCM_TX,
+		.stream_name = "AFE Capture",
+		.cpu_dai_name = "msm-dai-q6.225",
+		.platform_name = "msm-pcm-routing",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_AFE_PCM_TX,
+	},
+	/* Incall Music BACK END DAI Link */
+	{
+		.name = LPASS_BE_VOICE_PLAYBACK_TX,
+		.stream_name = "Voice Farend Playback",
+		.cpu_dai_name = "msm-dai-q6.32773",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_VOICE_PLAYBACK_TX,
+		.be_hw_params_fixup = mdm9615_be_hw_params_fixup,
+	},
+	/* Incall Record Uplink BACK END DAI Link */
+	{
+		.name = LPASS_BE_INCALL_RECORD_TX,
+		.stream_name = "Voice Uplink Capture",
+		.cpu_dai_name = "msm-dai-q6.32772",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_INCALL_RECORD_TX,
+		.be_hw_params_fixup = mdm9615_be_hw_params_fixup,
+	},
+	/* Incall Record Downlink BACK END DAI Link */
+	{
+		.name = LPASS_BE_INCALL_RECORD_RX,
+		.stream_name = "Voice Downlink Capture",
+		.cpu_dai_name = "msm-dai-q6.32771",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_INCALL_RECORD_RX,
+		.be_hw_params_fixup = mdm9615_be_hw_params_fixup,
+		.ignore_pmdown_time = 1, /* this dailink has playback support */
+	},
+	/* SECONDARY AUX PCM Backend DAI Links */
+	{
+		.name = LPASS_BE_SEC_AUXPCM_RX,
+		.stream_name = "SEC AUX PCM Playback",
+		.cpu_dai_name = "msm-dai-q6.12",
+		.platform_name = "msm-pcm-routing",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.init = &mdm9615_ar7_sec_auxpcm_init,
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SEC_AUXPCM_RX,
+		.be_hw_params_fixup = mdm9615_ar7_sec_auxpcm_be_params_fixup,
+		.ops = &mdm9615_ar7_sec_auxpcm_be_ops,
+	},
+	{
+		.name = LPASS_BE_SEC_AUXPCM_TX,
+		.stream_name = "SEC AUX PCM Capture",
+		.cpu_dai_name = "msm-dai-q6.13",
+		.platform_name = "msm-pcm-routing",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SEC_AUXPCM_TX,
+		.be_hw_params_fixup = mdm9615_ar7_sec_auxpcm_be_params_fixup,
+		.ops = &mdm9615_ar7_sec_auxpcm_be_ops,
+	},
+	{
+		.name = LPASS_BE_SEC_I2S_RX,
+		.stream_name = "Secondary I2S Playback",
+		.cpu_dai_name = "msm-dai-q6.4",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.init = &mdm9615_ar7_sec_i2s_audrx_init,
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SEC_I2S_RX,
+		.be_hw_params_fixup = msm9615_i2s_rx_be_hw_params_fixup,
+		.ops = &msm9615_i2s_be_ops,
+	},
+	{
+		.name = LPASS_BE_SEC_I2S_TX,
+		.stream_name = "Secondary I2S Capture",
+		.cpu_dai_name = "msm-dai-q6.5",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SEC_I2S_TX,
+		.be_hw_params_fixup = msm9615_i2s_tx_be_hw_params_fixup,
+		.ops = &msm9615_i2s_be_ops,
+	},
+};
+
+/* Digital audio interface glue - connects codec <---> CPU */
+static struct snd_soc_dai_link mdm9615_dai_ar7[] = {
+	/* FrontEnd DAI Links */
+	{
+		.name = "MDM9615 Media1",
+		.stream_name = "MultiMedia1",
+		.cpu_dai_name	= "MultiMedia1",
+		.platform_name  = "msm-pcm-dsp",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_MULTIMEDIA1
+	},
+	{
+		.name = "MDM9615 Media2",
+		.stream_name = "MultiMedia2",
+		.cpu_dai_name	= "MultiMedia2",
+		.platform_name  = "msm-pcm-dsp",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_MULTIMEDIA2,
+	},
+	{
+		.name = "Circuit-Switch Voice",
+		.stream_name = "CS-Voice",
+		.cpu_dai_name   = "CS-VOICE",
+		.platform_name  = "msm-pcm-voice",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_CS_VOICE,
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "MSM VoIP",
+		.stream_name = "VoIP",
+		.cpu_dai_name	= "VoIP",
+		.platform_name  = "msm-voip-dsp",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_VOIP,
+	},
+	{
+		.name = "MSM AFE-PCM RX",
+		.stream_name = "AFE-PROXY RX",
+		.cpu_dai_name = "msm-dai-q6.241",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.platform_name  = "msm-pcm-afe",
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "MSM AFE-PCM TX",
+		.stream_name = "AFE-PROXY TX",
+		.cpu_dai_name = "msm-dai-q6.240",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.platform_name  = "msm-pcm-afe",
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "SLIMBUS_0 Hostless",
+		.stream_name = "SLIMBUS_0 Hostless",
+		.cpu_dai_name	= "SLIMBUS0_HOSTLESS",
+		.platform_name  = "msm-pcm-hostless",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+		.ignore_suspend = 1,
+		/* .be_id = do not care */
+	},
+	{
+		.name = "AUXPCM Hostless",
+		.stream_name = "AUXPCM Hostless",
+		.cpu_dai_name	= "AUXPCM_HOSTLESS",
+		.platform_name  = "msm-pcm-hostless",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "VoLTE",
+		.stream_name = "VoLTE",
+		.cpu_dai_name   = "VoLTE",
+		.platform_name  = "msm-pcm-voice",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.be_id = MSM_FRONTEND_DAI_VOLTE,
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "DTMF RX Hostless",
+		.stream_name = "DTMF RX Hostless",
+		.cpu_dai_name	= "DTMF_RX_HOSTLESS",
+		.platform_name  = "msm-pcm-dtmf",
+		.dynamic = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
+			    SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		.be_id = MSM_FRONTEND_DAI_DTMF_RX,
+		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+	},
+	{
+		.name = "DTMF TX",
+		.stream_name = "DTMF TX",
+		.cpu_dai_name = "msm-dai-stub",
+		.platform_name  = "msm-pcm-dtmf",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.ignore_suspend = 1,
+	},
+	
+	/* Backend AFE DAI Links */
+	{
+		.name = LPASS_BE_AFE_PCM_RX,
+		.stream_name = "AFE Playback",
+		.cpu_dai_name = "msm-dai-q6.224",
+		.platform_name = "msm-pcm-routing",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_AFE_PCM_RX,
+	},
+	{
+		.name = LPASS_BE_AFE_PCM_TX,
+		.stream_name = "AFE Capture",
+		.cpu_dai_name = "msm-dai-q6.225",
+		.platform_name = "msm-pcm-routing",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_AFE_PCM_TX,
+	},
+	/* Incall Music BACK END DAI Link */
+	{
+		.name = LPASS_BE_VOICE_PLAYBACK_TX,
+		.stream_name = "Voice Farend Playback",
+		.cpu_dai_name = "msm-dai-q6.32773",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_VOICE_PLAYBACK_TX,
+		.be_hw_params_fixup = mdm9615_be_hw_params_fixup,
+	},
+	/* Incall Record Uplink BACK END DAI Link */
+	{
+		.name = LPASS_BE_INCALL_RECORD_TX,
+		.stream_name = "Voice Uplink Capture",
+		.cpu_dai_name = "msm-dai-q6.32772",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_INCALL_RECORD_TX,
+		.be_hw_params_fixup = mdm9615_be_hw_params_fixup,
+	},
+	/* Incall Record Downlink BACK END DAI Link */
+	{
+		.name = LPASS_BE_INCALL_RECORD_RX,
+		.stream_name = "Voice Downlink Capture",
+		.cpu_dai_name = "msm-dai-q6.32771",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_INCALL_RECORD_RX,
+		.be_hw_params_fixup = mdm9615_be_hw_params_fixup,
+		.ignore_pmdown_time = 1, /* this dailink has playback support */
+	},
+	/* SECONDARY AUX PCM Backend DAI Links */
+	{
+		.name = LPASS_BE_SEC_AUXPCM_RX,
+		.stream_name = "SEC AUX PCM Playback",
+		.cpu_dai_name = "msm-dai-q6.12",
+		.platform_name = "msm-pcm-routing",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.init = &mdm9615_ar7_sec_auxpcm_init,
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SEC_AUXPCM_RX,
+		.be_hw_params_fixup = mdm9615_ar7_sec_auxpcm_be_params_fixup,
+		.ops = &mdm9615_ar7_sec_auxpcm_be_ops,
+	},
+	{
+		.name = LPASS_BE_SEC_AUXPCM_TX,
+		.stream_name = "SEC AUX PCM Capture",
+		.cpu_dai_name = "msm-dai-q6.13",
+		.platform_name = "msm-pcm-routing",
+		.codec_name = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SEC_AUXPCM_TX,
+		.be_hw_params_fixup = mdm9615_ar7_sec_auxpcm_be_params_fixup,
+		.ops = &mdm9615_ar7_sec_auxpcm_be_ops,
+	},
+	{
+		.name = LPASS_BE_SEC_I2S_RX,
+		.stream_name = "Secondary I2S Playback",
+		.cpu_dai_name = "msm-dai-q6.4",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-rx",
+		.init = &mdm9615_ar7_sec_i2s_audrx_init,
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SEC_I2S_RX,
+		.be_hw_params_fixup = msm9615_i2s_rx_be_hw_params_fixup,
+		.ops = &msm9615_i2s_be_ops,
+	},
+	{
+		.name = LPASS_BE_SEC_I2S_TX,
+		.stream_name = "Secondary I2S Capture",
+		.cpu_dai_name = "msm-dai-q6.5",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "msm-stub-codec.1",
+		.codec_dai_name = "msm-stub-tx",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SEC_I2S_TX,
+		.be_hw_params_fixup = msm9615_i2s_tx_be_hw_params_fixup,
+		.ops = &msm9615_i2s_be_ops,
+	},
+
+	/* Backend SlimBus DAI Links */
+/* SWISTART */
+#ifdef CONFIG_WCD9310_CODEC
+{
+		.name = LPASS_BE_SLIMBUS_0_RX,
+		.stream_name = "Slimbus Playback",
+		.cpu_dai_name = "msm-dai-q6.16384",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "tabla_codec",
+		.codec_dai_name	= "tabla_rx1",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SLIMBUS_0_RX,
+		.init = &mdm9615_audrx_init,
+		.be_hw_params_fixup = mdm9615_slim_0_rx_be_hw_params_fixup,
+		.ops = &mdm9615_be_ops,
+	},
+	{
+		.name = LPASS_BE_SLIMBUS_0_TX,
+		.stream_name = "Slimbus Capture",
+		.cpu_dai_name = "msm-dai-q6.16385",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "tabla_codec",
+		.codec_dai_name	= "tabla_tx1",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SLIMBUS_0_TX,
+		.be_hw_params_fixup = mdm9615_slim_0_tx_be_hw_params_fixup,
+		.ops = &mdm9615_be_ops,
+	},
+#elif defined(CONFIG_WCD9304_CODEC)
+	{
+		.name = LPASS_BE_SLIMBUS_0_RX,
+		.stream_name = "Slimbus Playback",
+		.cpu_dai_name = "msm-dai-q6.16384",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "sitar_codec",
+		.codec_dai_name	= "sitar_rx1",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SLIMBUS_0_RX,
+		.init = &mdm9615_audrx_init,
+		.be_hw_params_fixup = mdm9615_slim_0_rx_be_hw_params_fixup,
+		.ops = &mdm9615_be_ops,
+	},
+	{
+		.name = LPASS_BE_SLIMBUS_0_TX,
+		.stream_name = "Slimbus Capture",
+		.cpu_dai_name = "msm-dai-q6.16385",
+		.platform_name = "msm-pcm-routing",
+		.codec_name     = "sitar_codec",
+		.codec_dai_name	= "sitar_tx1",
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_SLIMBUS_0_TX,
+		.be_hw_params_fixup = mdm9615_slim_0_tx_be_hw_params_fixup,
+		.ops = &mdm9615_be_ops,
+	},
+#endif
+/* SWISTOP */
+};
+#endif
+/* SWISTOP */
+
+static struct snd_soc_dai_link mdm9615_i2s_dai[
+					 ARRAY_SIZE(mdm9615_dai_common) +
+					 ARRAY_SIZE(mdm9615_dai_i2s_tabla)];
+
+static struct snd_soc_dai_link mdm9615_slimbus_dai[
+					 ARRAY_SIZE(mdm9615_dai_common) +
+					 ARRAY_SIZE(mdm9615_dai_slimbus_tabla)];
+
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+static struct snd_soc_card snd_soc_card_mdm9615 = {
+		.name		= "mdm9615-tabla-snd-card",
+};
+#else
+static struct snd_soc_card snd_soc_card_mdm9615 = {
+#ifdef CONFIG_WCD9310_CODEC
+		.name		= "mdm9615-tabla-snd-card",
+#elif defined(CONFIG_WCD9304_CODEC)
+		.name		= "mdm9615-sitar-snd-card",
+#endif
+};
+#endif
+/* SWISTOP */
+
+static struct platform_device *mdm9615_snd_device;
+
+void  __init install_codec_i2s_gpio(void)
+{
+	msm_gpiomux_install(msm9615_audio_prim_i2s_codec_configs,
+			ARRAY_SIZE(msm9615_audio_prim_i2s_codec_configs));
+}
+static int __init mdm9615_audio_init(void)
+{
+	int ret;
+
+	/* Set GPIO headset detection by default */
+	hs_detect_use_gpio = true;
+
+	if (!cpu_is_msm9615()) {
+		pr_err("%s: Not the right machine type\n", __func__);
+		return -ENODEV ;
+	}
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+	mbhc_cfg.calibration = def_tabla_mbhc_cal();
+	if (!mbhc_cfg.calibration) {
+		pr_err("Calibration data allocation failed\n");
+		return -ENOMEM;
+	}
+#endif
+/* SWISTOP */
+
+	mdm9615_snd_device = platform_device_alloc("soc-audio", 0);
+	if (!mdm9615_snd_device) {
+		pr_err("Platform device allocation failed\n");
+		kfree(mbhc_cfg.calibration);
+		return -ENOMEM;
 	}
+	pr_err("%s: Interface Type = %d\n", __func__,
+			wcd9xxx_get_intf_type());
+			
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+	pr_info("%s(): Interface Type = %d\n", __func__, wcd9xxx_get_intf_type());
+
+	#ifdef CONFIG_SIERRA_AR7
+	if (1)
+	#else
+	if (0)
+	#endif
+	{
+		enum bshwtype hwtype;
+		hwtype = bsgethwtype();
+
+		switch (hwtype)
+		{
+  		  case BSAR7550:
+  		  case BSAR7552:
+  		  case BSAR7554: 
+  		  case BSAR7550_LARGER_MEMORY:
+  		  case BSAR7552_LARGER_MEMORY:
+  		  case BSAR7554_LARGER_MEMORY:
+		    pr_info("%s - AR7 configuration", __func__);
+		    snd_soc_card_mdm9615.dai_link = mdm9615_dai_ar7;
+		    snd_soc_card_mdm9615.num_links = ARRAY_SIZE(mdm9615_dai_ar7);
+  		  break;
+
+  		  case BSWP7100_NEW:
+  		  case BSWP7102_NEW:
+  		  case BSWP7104_NEW:
+		  default:
+		    pr_info("%s - WP7 configuration", __func__);
+		    snd_soc_card_mdm9615.dai_link = mdm9615_dai_wp7_new;
+		    snd_soc_card_mdm9615.num_links = ARRAY_SIZE(mdm9615_dai_wp7_new);
+  		  break;
+		}
+	} 
+	if (0)
+	{
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
+  	if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
+  		memcpy(mdm9615_slimbus_dai, mdm9615_dai_common,
+  			sizeof(mdm9615_dai_common));
+  		memcpy(mdm9615_slimbus_dai + ARRAY_SIZE(mdm9615_dai_common),
+  		       mdm9615_dai_slimbus_tabla,
+  		       sizeof(mdm9615_dai_slimbus_tabla));
+  		snd_soc_card_mdm9615.dai_link = mdm9615_slimbus_dai;
+  		snd_soc_card_mdm9615.num_links =
+  				ARRAY_SIZE(mdm9615_slimbus_dai);
+  	} else if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C) {
+  		memcpy(mdm9615_i2s_dai, mdm9615_dai_common,
+  		       sizeof(mdm9615_dai_common));
+  		memcpy(mdm9615_i2s_dai + ARRAY_SIZE(mdm9615_dai_common),
+  		       mdm9615_dai_i2s_tabla,
+  		       sizeof(mdm9615_dai_i2s_tabla));
+  		snd_soc_card_mdm9615.dai_link = mdm9615_i2s_dai;
+  		snd_soc_card_mdm9615.num_links =
+  				ARRAY_SIZE(mdm9615_i2s_dai);
+  	} else{
+  		snd_soc_card_mdm9615.dai_link = mdm9615_dai_common;
+  		snd_soc_card_mdm9615.num_links =
+  				ARRAY_SIZE(mdm9615_dai_common);
+   }
+/* SWISTART */
+#if defined(CONFIG_SIERRA)
+ }
+#endif
+/* SWISTOP */
 
 	platform_set_drvdata(mdm9615_snd_device, &snd_soc_card_mdm9615);
 	ret = platform_device_add(mdm9615_snd_device);
@@ -2398,6 +3806,12 @@ static int __init mdm9615_audio_init(void)
 	sif_virt_addr = ioremap(LPASS_SIF_MUX_ADDR, 4);
 	secpcm_portslc_virt_addr = ioremap(SEC_PCM_PORT_SLC_ADDR, 4);
 
+/* SWISTART */
+#ifndef CONFIG_SIERRA
+	hs_detect_use_gpio = true;
+#endif
+/* SWISTOP */
+
 	return ret;
 }
 module_init(mdm9615_audio_init);
-- 
1.7.5.4

