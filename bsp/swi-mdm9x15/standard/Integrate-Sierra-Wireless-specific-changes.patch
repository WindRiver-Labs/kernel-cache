From a27a9d01dcdfac328c4a391d24412ad5415bdccc Mon Sep 17 00:00:00 2001
From: Catalin Enache <catalin.enache@windriver.com>
Date: Thu, 24 Oct 2013 20:38:31 +0300
Subject: [PATCH 59/66] Integrate Sierra Wireless specific changes

Extracted from Sierra Wireless code release 06.00.01A

Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 arch/arm/mach-msm/Kconfig                |    1 +
 arch/arm/mach-msm/board-9615-regulator.c |    7 +-
 arch/arm/mach-msm/board-9615.c           |  133 ++--
 arch/arm/mach-msm/devices-9615.c         |   34 -
 arch/arm/mach-msm/devices.h              |    5 -
 arch/arm/mach-msm/include/mach/usb_bam.h |   14 +-
 arch/arm/mach-msm/sierra_bscommon.c      |   22 +
 arch/arm/mach-msm/timer.c                |    4 +-
 drivers/i2c/busses/i2c-qup.c             |   17 +
 drivers/platform/msm/usb_bam.c           |   29 +-
 drivers/spi/spi_qsd.c                    |   48 ++
 drivers/usb/gadget/android.c             |   36 +-
 drivers/usb/gadget/ci13xxx_msm.c         |   14 +-
 drivers/usb/gadget/ci13xxx_udc.c         |   15 +
 drivers/usb/gadget/f_mbim.c              |   36 +-
 drivers/usb/gadget/f_qc_ecm.c            |   58 ++-
 drivers/usb/gadget/f_qc_rndis.c          |   57 ++-
 drivers/usb/gadget/u_bam_data.c          |  120 +++-
 drivers/usb/host/ehci-hcd.c              |  268 ++++++--
 drivers/usb/host/ehci-msm2.c             | 1093 ++++++++++++++++++++++++++++++
 drivers/usb/host/ehci-msm72k.c           |  812 ++++++++++++++++++++++
 drivers/usb/otg/msm_otg.c                |  334 +++++-----
 include/linux/sierra_bsuproto.h          |    1 +
 include/linux/usb/sierra_ududefs.h       |    4 +-
 sound/soc/msm/msm-pcm-host-voice.c       |    7 +-
 25 files changed, 2725 insertions(+), 444 deletions(-)
 create mode 100644 drivers/usb/host/ehci-msm2.c
 create mode 100644 drivers/usb/host/ehci-msm72k.c

diff --git a/arch/arm/mach-msm/Kconfig b/arch/arm/mach-msm/Kconfig
index b2ee716..7dc890f 100644
--- a/arch/arm/mach-msm/Kconfig
+++ b/arch/arm/mach-msm/Kconfig
@@ -292,6 +292,7 @@ config ARCH_MSM9615
 	select ARM_GIC
 	select GIC_SECURE
 	select ARCH_MSM_CORTEX_A5
+	select HAVE_ARCH_HAS_CURRENT_TIMER
 	select CPU_V7
 	select MIGHT_HAVE_CACHE_L2X0
 	select MSM_V2_TLMM
diff --git a/arch/arm/mach-msm/board-9615-regulator.c b/arch/arm/mach-msm/board-9615-regulator.c
index 2e6677d..5f902df 100644
--- a/arch/arm/mach-msm/board-9615-regulator.c
+++ b/arch/arm/mach-msm/board-9615-regulator.c
@@ -360,12 +360,9 @@ msm_rpm_regulator_init_data[] __devinitdata = {
 #else
 	RPM_LDO(L4,      0, 1, 0, 3075000, 3075000, NULL,      0, 0),
 #endif
-#if defined(CONFIG_SIERRA)
-/* set ss so can turn on it later - on HotSpot it powers LCD controller */
-	RPM_LDO(L5,      0, 1, 1, 2850000, 2850000, NULL,      0, 0),
-#else
+
 	RPM_LDO(L5,      0, 1, 0, 2850000, 2850000, NULL,      0, 0),
-#endif
+
 /* SWISTOP */
 	RPM_LDO(L6,      0, 1, 0, 1800000, 2850000, NULL,      0, 0),
 	RPM_LDO(L7,      0, 1, 0, 1850000, 1900000, "8018_s4", 0, 0),
diff --git a/arch/arm/mach-msm/board-9615.c b/arch/arm/mach-msm/board-9615.c
index 28da033..e49374f 100644
--- a/arch/arm/mach-msm/board-9615.c
+++ b/arch/arm/mach-msm/board-9615.c
@@ -65,6 +65,8 @@
 /* SWISTART */
 #ifdef CONFIG_SIERRA
 #include <mach/rpm-regulator.h>
+#include <linux/sierra_bsudefs.h>
+#include <linux/sierra_bsuproto.h>
 #endif
 /* SWISTOP */
 
@@ -216,29 +218,12 @@ static struct pm8xxx_gpio_init pm8018_gpios[] __initdata = {
 };
 #else
 static struct pm8xxx_gpio_init pm8018_gpios[] __initdata = {
-	PM8018_GPIO_INPUT(2,PM_GPIO_PULL_NO), /* EXT_LDO_EN_WLAN */
-	PM8018_GPIO_INPUT(6,PM_GPIO_PULL_NO), /* WLAN_CLK_PWR_REQ */
+	PM8018_GPIO_OUTPUT(4,0,LOW), /* USB_VBUS_EN */
+	PM8018_GPIO_INPUT(6,PM_GPIO_PULL_DN), /* XO_OUT_A1_EN, pulled down so XO_OUT_A1 is OFF by default */
 };
 #endif
 /* SWISTOP */
 
-/* SWISTART */
-/* Change based on 80-N5423-14 */
-#ifdef CONFIG_SIERRA
-static struct pm8xxx_mpp_init pm8018_mpp_swi =
-	PM8018_MPP_INIT(1, D_INPUT, PM8018_MPP_DIG_LEVEL_L4, DOUT_CTRL_LOW);
-	
-void msm9615_pm8xxx_gpio_mpp_init_swi(void)
-{
-	int rc;
-	rc = pm8xxx_mpp_config(pm8018_mpp_swi.mpp, &pm8018_mpp_swi.config);
-	if (rc) {
-	pr_err("%s: pm8018_mpp_config_swi: rc=%d\n", __func__, rc);
-	}
-} 
-#endif
-/* SWISTOP */
-
 /* Initial PM8018 MPP configurations */
 static struct pm8xxx_mpp_init pm8018_mpps[] __initdata = {
 };
@@ -1012,6 +997,21 @@ static struct msm_usb_bam_platform_data msm_usb_bam_pdata = {
 /* Change based on 80-N5423-14 */
 #ifdef CONFIG_SIERRA
 #define MSM_MPM_PIN_USB1_OTGSESSVLD    40
+
+#if defined(CONFIG_SIERRA_AR7) || defined(CONFIG_SIERRA_MC7)
+#define PM8018_MPP_VDDMIN 1
+#else /* defined(CONFIG_SIERRA_AR7) || defined(CONFIG_SIERRA_MC7) */
+#define PM8018_MPP_VDDMIN 2
+#endif /* defined(CONFIG_SIERRA_AR7) || defined(CONFIG_SIERRA_MC7) */
+#define PM8018_VDDMIN_IO  PM8018_MPP_PM_TO_SYS(PM8018_MPP_VDDMIN)
+/*
+ * init MPP Pin for Vddmin
+ * Direction - input
+ * Voltage - VREG_L4 (3.3V, refer to msm_rpm_regulator_init_data)
+ * Default output - low
+ */
+static struct pm8xxx_mpp_init pm8018_mpp_vddmin =
+	PM8018_MPP_INIT(PM8018_MPP_VDDMIN, D_INPUT, PM8018_MPP_DIG_LEVEL_L4, DOUT_CTRL_LOW);
 #endif
 /* SWISTOP */
 
@@ -1027,12 +1027,42 @@ static struct msm_otg_platform_data msm_otg_pdata = {
 /* SWISTART */
 /* Change based on 80-N5423-14 */
 #ifdef CONFIG_SIERRA
-    .vdd_min_enable     = PM8018_MPP_PM_TO_SYS(1),
-    .mpm_otgsessvld_int = MSM_MPM_PIN_USB1_OTGSESSVLD, 
+	.vdd_min_enable     = PM8018_VDDMIN_IO,
+	.mpm_otgsessvld_int = MSM_MPM_PIN_USB1_OTGSESSVLD,
 #endif
 /* SWISTOP */
 };
 
+/* SWISTART */
+/* Change based on 80-N5423-14 */
+#ifdef CONFIG_SIERRA
+void msm9615_pm8xxx_gpio_mpp_init_vddmin(void)
+{
+	int rc;
+	int vdd_min_enable = PM8018_VDDMIN_IO;
+
+	enum bshwtype hwtype = bsgethwtype();
+	unsigned int hwrev = bsgethwrev();
+
+  /* MC7304 DV2 and onward reuses MC7305 HW, which define MPP_02 as Ref Volt of
+USB_DP, while MC7304 DV1 and other products all use MPP_01 for this purpose */
+	if ((hwtype == BSMC7804) && (hwrev != BSHWDV1))
+	{
+		msm_otg_pdata.vdd_min_enable = PM8018_MPP_PM_TO_SYS(2);
+		vdd_min_enable = PM8018_MPP_PM_TO_SYS(2);
+		pm8018_mpp_vddmin.mpp = PM8018_MPP_PM_TO_SYS(2);
+	}
+
+	rc = pm8xxx_mpp_config(pm8018_mpp_vddmin.mpp, &pm8018_mpp_vddmin.config);
+	gpio_request(vdd_min_enable, "VDD_MIN_GPIO");
+	gpio_direction_input(vdd_min_enable);
+
+	if (rc) {
+		pr_err("%s: pm8018_mpp_init_vddmin: rc=%d\n", __func__, rc);
+	}
+}
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 
 static struct ci13xxx_platform_data msm_peripheral_pdata = {
 	.usb_core_id = 0,
@@ -1148,14 +1178,24 @@ static struct platform_device *common_devices[] = {
 #ifdef CONFIG_USB_CI13XXX_MSM_HSIC
 	&msm_android_usb_hsic_device,
 #endif
+
+/* SWISTART */
+#ifndef CONFIG_SIERRA_MC7
 	&msm9615_device_uart_gsbi4,
+#endif /* !CONFIG_SIERRA_MC7 */
 #ifdef CONFIG_SIERRA_AR7
     &msm9615_device_uart_gsbi5,
 #endif /* CONFIG_SIERRA_AR7 */
 /* SWISTOP */
 	&msm9615_device_ext_2p95v_vreg,
 	&msm9615_device_ssbi_pmic1,
+/* SWISTART */
+#ifdef CONFIG_SIERRA_MC7
+	&msm9615_device_qup_i2c_gsbi2,
+#else /* !CONFIG_SIERRA_MC7 */
 	&msm9615_device_qup_i2c_gsbi5,
+#endif /* CONFIG_SIERRA_MC7 */
+/* SWISTOP */
 	&msm9615_device_qup_spi_gsbi3,
 	&msm_device_sps,
 	&msm9615_slim_ctrl,
@@ -1232,8 +1272,15 @@ static void __init msm9615_i2c_init(void)
 		mach_mask = I2C_FFA;
 	else
 		pr_err("unmatched machine ID in register_i2c_devices\n");
+/* SWISTART */
+#ifdef CONFIG_SIERRA_MC7
+	msm9615_device_qup_i2c_gsbi2.dev.platform_data =
+					&msm9615_i2c_qup_gsbi2_pdata;
+#else /* !CONFIG_SIERRA_MC7 */
 	msm9615_device_qup_i2c_gsbi5.dev.platform_data =
 					&msm9615_i2c_qup_gsbi5_pdata;
+#endif /* CONFIG_SIERRA_MC7 */
+/* SWISTOP */
 	for (i = 0; i < ARRAY_SIZE(msm9615_i2c_devices); ++i) {
 		if (msm9615_i2c_devices[i].machs & mach_mask) {
 			i2c_register_board_info(msm9615_i2c_devices[i].bus,
@@ -1250,42 +1297,6 @@ static void __init msm9615_reserve(void)
 	msm_reserve();
 #endif
 }
-/* SWISTART */
-#ifdef CONFIG_SIERRA
-/* 
- * We need to have LDO5 turned on to keep LCD on MHS powered. Other
- * products want to keep it off - we provide a param to turn it off
- * at runtime (or keep it off from command line).
- * (There  should be a better way!)
- */
-typedef bool ldo5_t;
-static ldo5_t ldo5 = 1;
-#define param_check_ldo5_t(name, p) __param_check(name, p, ldo5_t);
-
-int param_set_ldo5(const char *val, const struct kernel_param *kp)
-{
-	int voltage = 0;
-	int rv = param_set_bool( val, kp );
-	if( !rv )
-	{
-		printk( KERN_INFO "Setting LDO5 to %d\n", ldo5 );
-
-		if( ldo5 )
-			voltage = 2850000;
-
-		rpm_vreg_set_voltage(RPM_VREG_ID_PM8018_L5, RPM_VREG_VOTER3,
-							 voltage, voltage, 1);
-	}
-	return rv;
-}
-static const struct kernel_param_ops param_ops_ldo5_t = {
-	.set = param_set_ldo5,
-	.get = param_get_bool,
-	.free = NULL,
-};
-core_param(ldo5, ldo5, ldo5_t, 0644);
-#endif
-/* SWISTOP */
 
 static void __init msm9615_common_init(void)
 {
@@ -1299,14 +1310,6 @@ static void __init msm9615_common_init(void)
 	msm9615_i2c_init();
 	regulator_suppress_info_printing();
 	platform_device_register(&msm9615_device_rpm_regulator);
-/* SWISTART */
-#ifdef CONFIG_SIERRA
-	if( ldo5 )
-			/* LDO5 always on - on HotSpot it powers LCD controller */
-			rpm_vreg_set_voltage(RPM_VREG_ID_PM8018_L5, RPM_VREG_VOTER3,
-							2850000, 2850000, 1);  
-#endif
-/* SWISTOP */
 	msm_xo_init();
 	msm_clock_init(&msm9615_clock_init_data);
 	msm9615_init_buses();
diff --git a/arch/arm/mach-msm/devices-9615.c b/arch/arm/mach-msm/devices-9615.c
index 470bac5..7887242 100644
--- a/arch/arm/mach-msm/devices-9615.c
+++ b/arch/arm/mach-msm/devices-9615.c
@@ -477,40 +477,6 @@ struct platform_device msm9615_device_qup_spi_gsbi3 = {
 	.resource	= resources_qup_spi_gsbi3,
 };
 
-/* SWISTART */
-#ifdef CONFIG_SIERRA
-static struct resource resources_qup_spi_gsbi4[] = {
-	{
-		.name   = "spi_base",
-		.start  = MSM_GSBI4_QUP_PHYS,
-		.end    = MSM_GSBI4_QUP_PHYS + SZ_4K - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "gsbi_base",
-		.start  = MSM_GSBI4_PHYS,
-		.end    = MSM_GSBI4_PHYS + 4 - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "spi_irq_in",
-		.start  = GSBI4_QUP_IRQ,
-		.end    = GSBI4_QUP_IRQ,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device msm9615_device_qup_spi_gsbi4 = {
-	.name	= "spi_qsd",
-	.id	= 4,
-	.num_resources	= ARRAY_SIZE(resources_qup_spi_gsbi4),
-	.resource	= resources_qup_spi_gsbi4,
-};
-/* Exporting this symbol so this struct can be access / used by a module */
-EXPORT_SYMBOL_GPL(msm9615_device_qup_spi_gsbi4);
-#endif /* CONFIG_SIERRA */
-/* SWISTOP */
-
 #define LPASS_SLIMBUS_PHYS	0x28080000
 #define LPASS_SLIMBUS_BAM_PHYS	0x28084000
 #define LPASS_SLIMBUS_SLEW	(MSM9615_TLMM_PHYS + 0x207C)
diff --git a/arch/arm/mach-msm/devices.h b/arch/arm/mach-msm/devices.h
index 01db938..6ad128c 100644
--- a/arch/arm/mach-msm/devices.h
+++ b/arch/arm/mach-msm/devices.h
@@ -102,11 +102,6 @@ extern struct platform_device msm9615_device_qup_i2c_gsbi2;
 /* SWISTOP */
 extern struct platform_device msm9615_device_qup_i2c_gsbi5;
 extern struct platform_device msm9615_device_qup_spi_gsbi3;
-/* SWISTART */
-#ifdef CONFIG_SIERRA
-extern struct platform_device msm9615_device_qup_spi_gsbi4;
-#endif /* CONFIG_SIERRA */
-/* SWISTOP */
 extern struct platform_device msm9615_slim_ctrl;
 extern struct platform_device msm9615_device_ssbi_pmic1;
 extern struct platform_device msm9615_device_tsens;
diff --git a/arch/arm/mach-msm/include/mach/usb_bam.h b/arch/arm/mach-msm/include/mach/usb_bam.h
index 405cfaa..9efff5c 100644
--- a/arch/arm/mach-msm/include/mach/usb_bam.h
+++ b/arch/arm/mach-msm/include/mach/usb_bam.h
@@ -152,7 +152,7 @@ void get_bam2bam_connection_info(u8 conn_idx, enum usb_bam_pipe_dir pipe_dir,
  * Resets the entire USB BAM.
  *
  */
-int usb_bam_reset(void);
+int usb_bam_reset(bool to_reconnect);
 
 /**
  * Indicates if the client of the USB BAM is ready to start
@@ -162,6 +162,12 @@ int usb_bam_reset(void);
  *
  */
 int usb_bam_client_ready(bool ready);
+/**
+* Returns upon reset completion if reset is in progress
+* immediately otherwise.
+*
+*/
+void usb_bam_reset_complete(void);
 
 #else
 static inline int usb_bam_connect(u8 idx, u32 *src_pipe_idx, u32 *dst_pipe_idx)
@@ -206,7 +212,7 @@ static inline void get_bam2bam_connection_info(u8 conn_idx,
 	return;
 }
 
-static inline int usb_bam_reset(void)
+static inline int usb_bam_reset(bool to_reconnect)
 {
 	return -ENODEV;
 }
@@ -216,5 +222,9 @@ static inline int usb_bam_client_ready(bool ready)
 	return -ENODEV;
 }
 
+static inline void usb_bam_reset_complete(void)
+{
+	return;
+}
 #endif
 #endif				/* _USB_BAM_H_ */
diff --git a/arch/arm/mach-msm/sierra_bscommon.c b/arch/arm/mach-msm/sierra_bscommon.c
index 8d7c6fe..a1fc996 100644
--- a/arch/arm/mach-msm/sierra_bscommon.c
+++ b/arch/arm/mach-msm/sierra_bscommon.c
@@ -54,6 +54,28 @@ static ssize_t bsreadhwconfig(void)
 }
 /************
  *
+ * Name:     bsreadboottoappflag
+ *
+ * Purpose:  To get the boot to app flags from SMD
+ *
+ * Parms:    none
+ *
+ * Return:   uint32 bitmask of flags
+ *
+ * Abort:    none
+ *
+ * Notes:
+ *
+ ************/
+uint32_t bsreadboottoappflag(void)
+{
+  struct bcboottoappmsg *mp = (struct bcboottoappmsg *)BS_BOOT_APP_MSG_START;
+  return mp->flags;
+}
+EXPORT_SYMBOL(bsreadboottoappflag);
+
+/************
+ *
  * Name:     bsgethwtype
  *
  * Purpose:  Returns hardware type read from QFPROM /GPIO
diff --git a/arch/arm/mach-msm/timer.c b/arch/arm/mach-msm/timer.c
index d278f50..dd3ac4c 100644
--- a/arch/arm/mach-msm/timer.c
+++ b/arch/arm/mach-msm/timer.c
@@ -1163,7 +1163,7 @@ static void __init msm_timer_init(void)
 		clockevents_register_device(ce);
 	}
 	msm_sched_clock_init();
-
+#if 0
 #ifdef ARCH_HAS_READ_CURRENT_TIMER
 	if (is_smp()) {
 		__raw_writel(1,
@@ -1171,7 +1171,7 @@ static void __init msm_timer_init(void)
 		set_delay_fn(read_current_timer_delay_loop);
 	}
 #endif
-
+#endif
 #ifdef CONFIG_LOCAL_TIMERS
 	local_timer_register(&msm_lt_ops);
 #endif
diff --git a/drivers/i2c/busses/i2c-qup.c b/drivers/i2c/busses/i2c-qup.c
index 93cacf7..76dda62 100644
--- a/drivers/i2c/busses/i2c-qup.c
+++ b/drivers/i2c/busses/i2c-qup.c
@@ -197,6 +197,23 @@ static inline void qup_print_status(struct qup_i2c_dev *dev)
 }
 #endif
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+int swi_set_i2c_freq(struct i2c_adapter *adap,int freq)
+{
+	struct qup_i2c_dev *dev = i2c_get_adapdata(adap);
+	/* We support frequencies upto FAST Mode(400KHz) */
+	if (freq <= 0 || freq > 400000) {
+		pr_err("clock frequency not supported\n");
+		return -EIO;
+	}
+	dev->pdata->clk_freq = freq;
+	dev->clk_ctl = 0;
+	return 0;
+}
+#endif
+/* SWISTOP */
+
 static irqreturn_t
 qup_i2c_interrupt(int irq, void *devid)
 {
diff --git a/drivers/platform/msm/usb_bam.c b/drivers/platform/msm/usb_bam.c
index fdb66ee..1396628 100644
--- a/drivers/platform/msm/usb_bam.c
+++ b/drivers/platform/msm/usb_bam.c
@@ -79,6 +79,7 @@ void __iomem *qscratch_ram1_reg;
 struct clk *mem_clk;
 struct clk *mem_iface_clk;
 struct usb_bam_peer_handhskae_info peer_handhskae_info;
+static struct completion reset_done;
 
 static int connect_pipe(u8 conn_idx, enum usb_bam_pipe_dir pipe_dir,
 						u32 *usb_pipe_idx)
@@ -487,6 +488,10 @@ int usb_bam_client_ready(bool ready)
 	}
 
 	peer_handhskae_info.client_ready = ready;
+	if (peer_handhskae_info.state == USB_BAM_SM_PLUG_ACKED && !ready) {
+			pr_debug("Starting reset sequence");
+			INIT_COMPLETION(reset_done);
+	}
 
 	spin_unlock(&usb_bam_lock);
 	if (!queue_work(usb_bam_wq, &peer_handhskae_info.reset_event.event_w)) {
@@ -503,7 +508,8 @@ static void usb_bam_work(struct work_struct *w)
 	struct usb_bam_event_info *event_info =
 		container_of(w, struct usb_bam_event_info, event_w);
 
-	event_info->callback(event_info->param);
+	if (event_info->callback)
+		event_info->callback(event_info->param);
 }
 
 static void usb_bam_wake_cb(struct sps_event_notify *notify)
@@ -540,6 +546,7 @@ static void usb_bam_sm_work(struct work_struct *w)
 	case USB_BAM_SM_PLUG_ACKED:
 		if (!peer_handhskae_info.client_ready) {
 			spin_unlock(&usb_bam_lock);
+			pr_debug("Starting A2 reset sequence");
 			smsm_change_state(SMSM_APPS_STATE,
 				SMSM_USB_PLUG_UNPLUG, 0);
 			spin_lock(&usb_bam_lock);
@@ -552,6 +559,8 @@ static void usb_bam_sm_work(struct work_struct *w)
 			peer_handhskae_info.reset_event.
 				callback(peer_handhskae_info.reset_event.param);
 			spin_lock(&usb_bam_lock);
+			complete_all(&reset_done);
+			pr_debug("Finished reset sequence");
 			peer_handhskae_info.state = USB_BAM_SM_INIT;
 			peer_handhskae_info.ack_received = 0;
 		}
@@ -745,7 +754,16 @@ int usb_bam_disconnect_ipa(u8 idx,
 
 }
 
-int usb_bam_reset(void)
+void usb_bam_reset_complete(void)
+{
+	pr_debug("Waiting for reset compelte");
+	if (wait_for_completion_interruptible_timeout(&reset_done, 10*HZ) <= 0)
+		pr_warn("Timeout while waiting for reset");
+
+	pr_debug("Finished Waiting for reset complete");
+}
+
+int usb_bam_reset(bool to_reconnect)
 {
 	struct usb_bam_connect_info *connection;
 	int i;
@@ -775,6 +793,9 @@ int usb_bam_reset(void)
 	if (sps_device_reset(h_bam))
 		pr_err("%s: BAM reset failed\n", __func__);
 
+	if (!to_reconnect)
+		return ret;
+
 	/* Reconnect all pipes */
 	for (i = 0; i < CONNECTIONS_NUM; i++) {
 		connection = &usb_bam_connections[i];
@@ -1165,7 +1186,9 @@ static int usb_bam_probe(struct platform_device *pdev)
 
 	spin_lock_init(&usb_bam_lock);
 	INIT_WORK(&peer_handhskae_info.reset_event.event_w, usb_bam_sm_work);
-
+	init_completion(&reset_done);
+	complete(&reset_done);
+	
 	mem_clk = devm_clk_get(&pdev->dev, "mem_clk");
 	if (IS_ERR(mem_clk))
 		dev_dbg(&pdev->dev, "failed to get mem_clock\n");
diff --git a/drivers/spi/spi_qsd.c b/drivers/spi/spi_qsd.c
index 4713532..c7de51e 100644
--- a/drivers/spi/spi_qsd.c
+++ b/drivers/spi/spi_qsd.c
@@ -656,6 +656,11 @@ static irqreturn_t msm_spi_input_irq(int irq, void *dev_id)
 		}
 		if (dd->rx_bytes_remaining == 0)
 			msm_spi_complete(dd);
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+		dd->cur_msg->actual_length = dd->read_xfr_cnt;
+#endif
+/* SWISTOP */
 	}
 
 	return IRQ_HANDLED;
@@ -1514,6 +1519,49 @@ err_setup_exit:
 	return rc;
 }
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+void swi_reg_bit_set(struct spi_device *spi, int reg_addr, int bit_offset,int set_flag)
+{
+	u32 spi_ioc;
+	u32 spi_ioc_orig;
+	struct msm_spi	*dd;
+	dd = spi_master_get_devdata(spi->master);
+	clk_prepare_enable(dd->pclk);
+	spi_ioc = readl_relaxed(dd->base + reg_addr);
+	spi_ioc_orig = spi_ioc;
+	if (set_flag)
+		spi_ioc |= bit_offset;
+	else
+		spi_ioc &= ~bit_offset;
+
+	if (spi_ioc != spi_ioc_orig)
+		writel_relaxed(spi_ioc,dd->base + reg_addr);
+		clk_disable_unprepare(dd->pclk);
+}
+
+int swi_read_deassert_time(struct spi_device *spi)
+{
+	struct msm_spi	*dd;
+	int ret;
+	dd = spi_master_get_devdata(spi->master);
+	clk_prepare_enable(dd->pclk);
+	ret = readl_relaxed(dd->base + SPI_DEASSERT_WAIT);
+	clk_disable_unprepare(dd->pclk);
+	return ret;
+}
+
+void swi_write_deassert_time(struct spi_device *spi,u8 value)
+{
+	struct msm_spi	*dd;
+	dd = spi_master_get_devdata(spi->master);
+	clk_prepare_enable(dd->pclk);
+	writel_relaxed(value, dd->base + SPI_DEASSERT_WAIT);
+	clk_disable_unprepare(dd->pclk);
+}
+#endif
+/* SWISTOP */
+
 #ifdef CONFIG_DEBUG_FS
 static int debugfs_iomem_x32_set(void *data, u64 val)
 {
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
index 9f8cf17..0d6e973 100644
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -217,8 +217,7 @@ static char serial_string[256];
 static char pri_number_string[256];
 static char pri_revision_string[256];
 static char imei_string[256];
-static int usb_det = 0;
-#endif /* SIERRA */
+#endif
 /* SWISTOP */
 
 /* String Table */
@@ -2246,36 +2245,6 @@ static ssize_t usr_pid_store(struct device *pdev,
     }
 	return size;
 }
-static ssize_t usb_det_show(struct device *pdev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%d\n",usb_det);
-}
-
-static ssize_t usb_det_store(struct device *pdev,
-		struct device_attribute *attr, const char *buff, size_t size)
-{
-	int usbdetect = 0;
-
-	sscanf(buff, "%d", &usbdetect);
-
-	pr_info("android_usb: USB_DET = %d\n",
-			usbdetect);
-	usb_det = usbdetect;
-
-	/* Changes based on 80-N5423-14 */
-	if (usb_det == 2)
-	{
-		msm9615_pm8xxx_gpio_mpp_init_swi();	
-		msm_otg_vddmin_init();
-	}
- 	return size;
-}
-
-int msm_get_usb_det(void)
-{
-	return usb_det;
-}
 #endif /* SIERRA */
 /* SWISTOP */
 
@@ -2585,8 +2554,6 @@ static DEVICE_ATTR(sd_en, S_IRUGO | S_IWUSR,
         sd_en_show, sd_en_store);
 static DEVICE_ATTR(usr_pid, S_IRUGO | S_IWUSR,
         usr_pid_show, usr_pid_store);
-static DEVICE_ATTR(usb_det, S_IRUGO | S_IWUSR,
-		usb_det_show, usb_det_store);
 #endif /* SIERRA */
 /* SWISTOP */
 
@@ -2609,7 +2576,6 @@ static struct device_attribute *android_usb_attributes[] = {
     &dev_attr_swoc_en,
     &dev_attr_sd_en,
     &dev_attr_usr_pid,
-    &dev_attr_usb_det,
 #endif
 /* SWISTOP */
 	&dev_attr_functions,
diff --git a/drivers/usb/gadget/ci13xxx_msm.c b/drivers/usb/gadget/ci13xxx_msm.c
index e3c1216..cd974f9 100644
--- a/drivers/usb/gadget/ci13xxx_msm.c
+++ b/drivers/usb/gadget/ci13xxx_msm.c
@@ -10,7 +10,6 @@
  * GNU General Public License for more details.
  *
  */
-
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
@@ -233,6 +232,19 @@ int ci13xxx_msm_remove(struct platform_device *pdev)
 	return 0;
 }
 
+void msm_hw_bam_disable(bool bam_disable)
+{
+	u32 val;
+	struct ci13xxx *udc = _udc;
+
+	if (bam_disable)
+		val = readl_relaxed(USB_GENCONFIG) | GENCONFIG_BAM_DISABLE;
+	else
+		val = readl_relaxed(USB_GENCONFIG) & ~GENCONFIG_BAM_DISABLE;
+
+	writel_relaxed(val, USB_GENCONFIG);
+}
+
 static struct platform_driver ci13xxx_msm_driver = {
 	.probe = ci13xxx_msm_probe,
 	.driver = { .name = "msm_hsusb", },
diff --git a/drivers/usb/gadget/ci13xxx_udc.c b/drivers/usb/gadget/ci13xxx_udc.c
index f82ca99..3802422 100644
--- a/drivers/usb/gadget/ci13xxx_udc.c
+++ b/drivers/usb/gadget/ci13xxx_udc.c
@@ -1,3 +1,4 @@
+#define CONFIG_USB_GADGET_DEBUG_FILES
 /*
  * ci13xxx_udc.c - MIPS USB IP core family device controller
  *
@@ -2246,8 +2247,22 @@ static void isr_resume_handler(struct ci13xxx *udc)
  */
 static void isr_suspend_handler(struct ci13xxx *udc)
 {
+/* SWISTART */
+#if !defined(CONFIG_SIERRA)
 	if (udc->gadget.speed != USB_SPEED_UNKNOWN &&
 		udc->vbus_active) {
+#else  /* !defined(CONFIG_SIERRA) */
+/* When udc->gadget.speed = USB_SPEED_UNKNOWN on power up
+ * USB driver (msm_otg.c) does not suspend proplery after power up.
+ * We allow the interrupt to be properly handled below (otg_set_suspend).
+ */
+	if (udc->vbus_active) {
+		if (udc->gadget.speed == USB_SPEED_UNKNOWN) {
+			udc->gadget.speed = hw_port_is_high_speed() ?
+				USB_SPEED_HIGH : USB_SPEED_FULL;
+		}
+#endif /* !defined(CONFIG_SIERRA) */
+/* SWISTOP */
 		if (udc->suspended == 0) {
 			spin_unlock(udc->lock);
 			udc->driver->suspend(&udc->gadget);
diff --git a/drivers/usb/gadget/f_mbim.c b/drivers/usb/gadget/f_mbim.c
index b1f384e..c354d95 100644
--- a/drivers/usb/gadget/f_mbim.c
+++ b/drivers/usb/gadget/f_mbim.c
@@ -74,7 +74,6 @@ struct f_mbim {
 	struct usb_composite_dev	*cdev;
 
 	atomic_t	online;
-	bool		is_open;
 
 	atomic_t	open_excl;
 	atomic_t	ioctl_excl;
@@ -224,6 +223,18 @@ static struct usb_cdc_mbb_desc mbb_desc = {
 	.bmNetworkCapabilities = 0x20,
 };
 
+#if 0
+static struct usb_cdc_ext_mbb_desc ext_mbb_desc = {
+	.bLength =	sizeof ext_mbb_desc,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubType =	USB_CDC_EXT_MBB_TYPE,
+
+	.bcdMbbExtendedVersion =	cpu_to_le16(0x0100),
+	.bMaxOutstandingCmdMsges =	64,
+	.wMTU =	1500,
+};
+#endif
+
 /* the default data interface has no endpoints ... */
 static struct usb_interface_descriptor mbim_data_nop_intf = {
 	.bLength =		sizeof mbim_data_nop_intf,
@@ -710,11 +721,6 @@ static void mbim_reset_function_queue(struct f_mbim *dev)
 	pr_debug("Queue empty packet for QBI");
 
 	spin_lock(&dev->lock);
-	if (!dev->is_open) {
-		pr_err("%s: mbim file handler %p is not open", __func__, dev);
-		spin_unlock(&dev->lock);
-		return;
-	}
 
 	cpkt = mbim_alloc_ctrl_pkt(0, GFP_ATOMIC);
 	if (!cpkt) {
@@ -968,12 +974,6 @@ fmbim_cmd_complete(struct usb_ep *ep, struct usb_request *req)
 	memcpy(cpkt->buf, req->buf, len);
 
 	spin_lock(&dev->lock);
-	if (!dev->is_open) {
-		pr_err("mbim file handler %p is not open", dev);
-		spin_unlock(&dev->lock);
-		mbim_free_ctrl_pkt(cpkt);
-		return;
-	}
 
 	list_add_tail(&cpkt->list, &dev->cpkt_req_q);
 	spin_unlock(&dev->lock);
@@ -1506,6 +1506,7 @@ mbim_bind(struct usb_configuration *c, struct usb_function *f)
 	mbim_union_desc.bSlaveInterface0 = status;
 
 	mbim->bam_port.cdev = cdev;
+	mbim->bam_port.func = &mbim->function;
 
 	status = -ENODEV;
 
@@ -1624,6 +1625,7 @@ static void mbim_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct f_mbim	*mbim = func_to_mbim(f);
 
+	bam_data_destroy(mbim->port_num);
 	if (gadget_is_dualspeed(c->cdev->gadget))
 		usb_free_descriptors(f->hs_descriptors);
 	usb_free_descriptors(f->descriptors);
@@ -1895,10 +1897,6 @@ static int mbim_open(struct inode *ip, struct file *fp)
 
 	atomic_set(&_mbim_dev->error, 0);
 
-	spin_lock(&_mbim_dev->lock);
-	_mbim_dev->is_open = true;
-	spin_unlock(&_mbim_dev->lock);
-
 	pr_info("Exit, mbim file opened\n");
 
 	return 0;
@@ -1906,14 +1904,8 @@ static int mbim_open(struct inode *ip, struct file *fp)
 
 static int mbim_release(struct inode *ip, struct file *fp)
 {
-	struct f_mbim *mbim = fp->private_data;
-
 	pr_info("Close mbim file");
 
-	spin_lock(&mbim->lock);
-	mbim->is_open = false;
-	spin_unlock(&mbim->lock);
-
 	mbim_unlock(&_mbim_dev->open_excl);
 
 	return 0;
diff --git a/drivers/usb/gadget/f_qc_ecm.c b/drivers/usb/gadget/f_qc_ecm.c
index 757f9fe..904b2f3 100644
--- a/drivers/usb/gadget/f_qc_ecm.c
+++ b/drivers/usb/gadget/f_qc_ecm.c
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2003-2005,2008 David Brownell
  * Copyright (C) 2008 Nokia Corporation
- * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -67,6 +67,7 @@ struct f_ecm_qc {
 	struct usb_request		*notify_req;
 	u8				notify_state;
 	bool				is_open;
+	struct data_port		bam_port;
 };
 
 static inline struct f_ecm_qc *func_to_ecm_qc(struct usb_function *f)
@@ -101,8 +102,9 @@ static inline unsigned ecm_qc_bitrate(struct usb_gadget *g)
 #define ECM_QC_LOG2_STATUS_INTERVAL_MSEC	5	/* 1 << 5 == 32 msec */
 #define ECM_QC_STATUS_BYTECOUNT		16	/* 8 byte header + data */
 
-/* currently only one std ecm instance is supported */
+/* Currently only one std ecm instance is supported - port index 0. */
 #define ECM_QC_NO_PORTS						1
+#define ECM_QC_ACTIVE_PORT					0
 
 /* interface descriptor: */
 
@@ -286,8 +288,6 @@ static struct usb_gadget_strings *ecm_qc_strings[] = {
 	NULL,
 };
 
-static struct data_port ecm_qc_bam_port;
-
 static int ecm_qc_bam_setup(void)
 {
 	int ret;
@@ -304,13 +304,15 @@ static int ecm_qc_bam_setup(void)
 static int ecm_qc_bam_connect(struct f_ecm_qc *dev)
 {
 	int ret;
+	struct usb_composite_dev *cdev = dev->port.func.config->cdev;
 
-	ecm_qc_bam_port.cdev = dev->port.func.config->cdev;
-	ecm_qc_bam_port.in = dev->port.in_ep;
-	ecm_qc_bam_port.out = dev->port.out_ep;
+	dev->bam_port.cdev = cdev;
+	dev->bam_port.func = &dev->port.func;
+	dev->bam_port.in = dev->port.in_ep;
+	dev->bam_port.out = dev->port.out_ep;
 
 	/* currently we use the first connection */
-	ret = bam_data_connect(&ecm_qc_bam_port, 0, 0);
+	ret = bam_data_connect(&dev->bam_port, 0, 0);
 	if (ret) {
 		pr_err("bam_data_connect failed: err:%d\n",
 				ret);
@@ -324,8 +326,9 @@ static int ecm_qc_bam_connect(struct f_ecm_qc *dev)
 
 static int ecm_qc_bam_disconnect(struct f_ecm_qc *dev)
 {
-	pr_debug("dev:%p. %s Do nothing.\n",
-			 dev, __func__);
+	pr_debug("dev:%p. %s Disconnect BAM.\n", dev, __func__);
+
+	bam_data_disconnect(&dev->bam_port, 0);
 
 	return 0;
 }
@@ -402,10 +405,10 @@ static void ecm_qc_notify(struct f_ecm_qc *ecm)
 
 static void ecm_qc_notify_complete(struct usb_ep *ep, struct usb_request *req)
 {
-	struct f_ecm_qc			*ecm = req->context;
+	struct f_ecm_qc			*ecm = req->context;	
+	struct usb_cdc_notification	*event;
 	struct usb_composite_dev	*cdev = ecm->port.func.config->cdev;
-	struct usb_cdc_notification	*event = req->buf;
-
+	
 	switch (req->status) {
 	case 0:
 		/* no fault */
@@ -518,8 +521,12 @@ static int ecm_qc_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 
 		if (ecm->port.in_ep->driver_data) {
 			DBG(cdev, "reset ecm\n");
-			gether_qc_disconnect_name(&ecm->port, "ecm0");
+			/* ecm->port is needed for disconnecting the BAM data
+			 * path. Only after the BAM data path is disconnected,
+			 * we can disconnect the port from the network layer.
+			 */
 			ecm_qc_bam_disconnect(ecm);
+			gether_qc_disconnect_name(&ecm->port, "ecm0");
 		}
 
 		if (!ecm->port.in_ep->desc ||
@@ -586,13 +593,13 @@ static int ecm_qc_get_alt(struct usb_function *f, unsigned intf)
 static void ecm_qc_disable(struct usb_function *f)
 {
 	struct f_ecm_qc		*ecm = func_to_ecm_qc(f);
-	struct usb_composite_dev	*cdev = ecm->port.func.config->cdev;
-
+    struct usb_composite_dev	*cdev = ecm->port.func.config->cdev;
+    
 	DBG(cdev, "ecm deactivated\n");
 
 	if (ecm->port.in_ep->driver_data) {
-		gether_qc_disconnect_name(&ecm->port, "ecm0");
 		ecm_qc_bam_disconnect(ecm);
+		gether_qc_disconnect_name(&ecm->port, "ecm0");
 	}
 
 	if (ecm->notify->driver_data) {
@@ -602,6 +609,20 @@ static void ecm_qc_disable(struct usb_function *f)
 	}
 }
 
+static void ecm_qc_suspend(struct usb_function *f)
+{
+	pr_debug("ecm suspended\n");
+
+	bam_data_suspend(ECM_QC_ACTIVE_PORT);
+}
+
+static void ecm_qc_resume(struct usb_function *f)
+{
+	pr_debug("ecm resumed\n");
+
+	bam_data_resume(ECM_QC_ACTIVE_PORT);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -776,6 +797,7 @@ ecm_qc_unbind(struct usb_configuration *c, struct usb_function *f)
 
 	DBG(c->cdev, "ecm unbind\n");
 
+	bam_data_destroy(0);
 	if (gadget_is_dualspeed(c->cdev->gadget))
 		usb_free_descriptors(f->hs_descriptors);
 	usb_free_descriptors(f->descriptors);
@@ -862,6 +884,8 @@ ecm_qc_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN])
 	ecm->port.func.get_alt = ecm_qc_get_alt;
 	ecm->port.func.setup = ecm_qc_setup;
 	ecm->port.func.disable = ecm_qc_disable;
+	ecm->port.func.suspend = ecm_qc_suspend;
+	ecm->port.func.resume = ecm_qc_resume;
 
 	status = usb_add_function(c, &ecm->port.func);
 	if (status) {
diff --git a/drivers/usb/gadget/f_qc_rndis.c b/drivers/usb/gadget/f_qc_rndis.c
index 711ed8b..b1126fe 100644
--- a/drivers/usb/gadget/f_qc_rndis.c
+++ b/drivers/usb/gadget/f_qc_rndis.c
@@ -5,8 +5,8 @@
  * Copyright (C) 2003-2004 Robert Schwebel, Benedikt Spranger
  * Copyright (C) 2008 Nokia Corporation
  * Copyright (C) 2009 Samsung Electronics
- *			Author: Michal Nazarewicz (mina86@mina86.com)
- * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *			Author: Michal Nazarewicz (m.nazarewicz@samsung.com)
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2
@@ -85,6 +85,7 @@ struct f_rndis_qc {
 	u8				ethaddr[ETH_ALEN];
 	u32				vendorID;
 	u8				max_pkt_per_xfer;
+	u32				max_pkt_size;
 	const char			*manufacturer;
 	int				config;
 	atomic_t		ioctl_excl;
@@ -104,12 +105,10 @@ static inline struct f_rndis_qc *func_to_rndis_qc(struct usb_function *f)
 /* peak (theoretical) bulk transfer rate in bits-per-second */
 static unsigned int rndis_qc_bitrate(struct usb_gadget *g)
 {
-	if (gadget_is_superspeed(g) && g->speed == USB_SPEED_SUPER)
-		return 13 * 1024 * 8 * 1000 * 8;
-	else if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
+	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
 		return 13 * 512 * 8 * 1000 * 8;
 	else
-		return 19 * 64 * 1 * 1000 * 8;
+		return 19 *  64 * 1 * 1000 * 8;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -129,6 +128,7 @@ static unsigned int rndis_qc_bitrate(struct usb_gadget *g)
 
 #define RNDIS_QC_IOCTL_MAGIC		'i'
 #define RNDIS_QC_GET_MAX_PKT_PER_XFER   _IOR(RNDIS_QC_IOCTL_MAGIC, 1, u8)
+#define RNDIS_QC_GET_MAX_PKT_SIZE	_IOR(RNDIS_QC_IOCTL_MAGIC, 2, u32)
 
 
 /* interface descriptor: */
@@ -202,7 +202,7 @@ rndis_qc_iad_descriptor = {
 	.bInterfaceCount =	2, /* control + data */
 	.bFunctionClass =	USB_CLASS_COMM,
 	.bFunctionSubClass =	USB_CDC_SUBCLASS_ETHERNET,
-	.bFunctionProtocol =	USB_CDC_PROTO_NONE,
+	.bFunctionProtocol =	USB_CDC_ACM_PROTO_VENDOR,
 	/* .iFunction = DYNAMIC */
 };
 
@@ -421,6 +421,7 @@ static int rndis_qc_bam_connect(struct f_rndis_qc *dev)
 	int ret;
 
 	dev->bam_port.cdev = dev->port.func.config->cdev;
+	dev->bam_port.func = &dev->port.func;
 	dev->bam_port.in = dev->port.in_ep;
 	dev->bam_port.out = dev->port.out_ep;
 
@@ -439,7 +440,8 @@ static int rndis_qc_bam_connect(struct f_rndis_qc *dev)
 
 static int rndis_qc_bam_disconnect(struct f_rndis_qc *dev)
 {
- 	pr_debug("dev:%p. %s Disconnect BAM.\n", dev, __func__);
+	pr_debug("dev:%p. %s Disconnect BAM.\n", dev, __func__);
+
 	bam_data_disconnect(&dev->bam_port, 0);
 
 	return 0;
@@ -515,7 +517,7 @@ static void rndis_qc_response_available(void *_rndis)
 static void rndis_qc_response_complete(struct usb_ep *ep,
 						struct usb_request *req)
 {
-	struct f_rndis_qc		*rndis = req->context;
+	struct f_rndis_qc			*rndis = req->context;
 	int				status = req->status;
 	struct usb_composite_dev	*cdev = rndis->port.func.config->cdev;
 
@@ -555,14 +557,22 @@ static void rndis_qc_response_complete(struct usb_ep *ep,
 static void rndis_qc_command_complete(struct usb_ep *ep,
 							struct usb_request *req)
 {
-	struct f_rndis_qc			*rndis = req->context;
+	struct f_rndis_qc		*rndis = req->context;
 	int				status;
+	rndis_init_msg_type		*buf;
 
 	/* received RNDIS command from USB_CDC_SEND_ENCAPSULATED_COMMAND */
 	status = rndis_msg_parser(rndis->config, (u8 *) req->buf);
 	if (status < 0)
 		pr_err("RNDIS command error %d, %d/%d\n",
 			status, req->actual, req->length);
+
+	buf = (rndis_init_msg_type *)req->buf;
+
+	if (buf->MessageType == REMOTE_NDIS_INITIALIZE_MSG) {
+		rndis->max_pkt_size = buf->MaxTransferSize;
+		pr_debug("MaxTransferSize: %d\n", buf->MaxTransferSize);
+	}
 }
 
 static int
@@ -664,8 +674,12 @@ static int rndis_qc_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 
 		if (rndis->port.in_ep->driver_data) {
 			DBG(cdev, "reset rndis\n");
-			gether_qc_disconnect_name(&rndis->port, "rndis0");
+			/* rndis->port is needed for disconnecting the BAM data
+			 * path. Only after the BAM data path is disconnected,
+			 * we can disconnect the port from the network layer.
+			 */
 			rndis_qc_bam_disconnect(rndis);
+			gether_qc_disconnect_name(&rndis->port, "rndis0");
 		}
 
 		if (!rndis->port.in_ep->desc || !rndis->port.out_ep->desc) {
@@ -697,14 +711,14 @@ static int rndis_qc_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 		 */
 		rndis->port.cdc_filter = 0;
 
+		if (rndis_qc_bam_connect(rndis))
+			goto fail;
+
 		DBG(cdev, "RNDIS RX/TX early activation ...\n");
 		net = gether_qc_connect_name(&rndis->port, "rndis0", false);
 		if (IS_ERR(net))
 			return PTR_ERR(net);
 
-		if (rndis_qc_bam_connect(rndis))
-			goto fail;
-
 		rndis_set_param_dev(rndis->config, net,
 				&rndis->port.cdc_filter);
 	} else
@@ -725,8 +739,8 @@ static void rndis_qc_disable(struct usb_function *f)
 	pr_info("rndis deactivated\n");
 
 	rndis_uninit(rndis->config);
-	gether_qc_disconnect_name(&rndis->port, "rndis0");
 	rndis_qc_bam_disconnect(rndis);
+	gether_qc_disconnect_name(&rndis->port, "rndis0");
 
 	usb_ep_disable(rndis->notify);
 	rndis->notify->driver_data = NULL;
@@ -948,6 +962,8 @@ rndis_qc_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct f_rndis_qc		*rndis = func_to_rndis_qc(f);
 
+	pr_debug("rndis_qc_unbind: free");
+	bam_data_destroy(0);
 	rndis_deregister(rndis->config);
 	rndis_exit();
 
@@ -1129,6 +1145,17 @@ static long rndis_qc_ioctl(struct file *fp, unsigned cmd, unsigned long arg)
 		pr_info("Sent max packets per xfer %d",
 				rndis->max_pkt_per_xfer);
 		break;
+	case RNDIS_QC_GET_MAX_PKT_SIZE:
+		ret = copy_to_user((void __user *)arg,
+					&rndis->max_pkt_size,
+					sizeof(rndis->max_pkt_size));
+		if (ret) {
+			pr_err("copying to user space failed");
+			ret = -EFAULT;
+		}
+		pr_debug("Sent max packet size %d",
+				rndis->max_pkt_size);
+		break;
 	default:
 		pr_err("Unsupported IOCTL");
 		ret = -EINVAL;
diff --git a/drivers/usb/gadget/u_bam_data.c b/drivers/usb/gadget/u_bam_data.c
index 32f683e..95b0dce 100644
--- a/drivers/usb/gadget/u_bam_data.c
+++ b/drivers/usb/gadget/u_bam_data.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -36,6 +36,7 @@ static int n_bam2bam_data_ports;
 
 struct data_port {
 	struct usb_composite_dev	*cdev;
+	struct usb_function		*func;
 	struct usb_ep			*in;
 	struct usb_ep			*out;
 };
@@ -73,7 +74,7 @@ static void bam_data_endless_rx_complete(struct usb_ep *ep,
 {
 	int status = req->status;
 
-	pr_info("status: %d\n", status);
+	pr_debug("%s: status: %d\n", __func__, status);
 }
 
 static void bam_data_endless_tx_complete(struct usb_ep *ep,
@@ -81,7 +82,7 @@ static void bam_data_endless_tx_complete(struct usb_ep *ep,
 {
 	int status = req->status;
 
-	pr_info("status: %d\n", status);
+	pr_debug("%s: status: %d\n", __func__, status);
 }
 
 static void bam_data_start_endless_rx(struct bam_data_port *port)
@@ -89,6 +90,9 @@ static void bam_data_start_endless_rx(struct bam_data_port *port)
 	struct bam_data_ch_info *d = &port->data_ch;
 	int status;
 
+	if (!port->port_usb)
+		return;
+
 	status = usb_ep_queue(port->port_usb->out, d->rx_req, GFP_ATOMIC);
 	if (status)
 		pr_err("error enqueuing transfer, %d\n", status);
@@ -99,32 +103,41 @@ static void bam_data_start_endless_tx(struct bam_data_port *port)
 	struct bam_data_ch_info *d = &port->data_ch;
 	int status;
 
+	if (!port->port_usb)
+		return;
+
 	status = usb_ep_queue(port->port_usb->in, d->tx_req, GFP_ATOMIC);
 	if (status)
 		pr_err("error enqueuing transfer, %d\n", status);
 }
 
-static void bam2bam_data_disconnect_work(struct work_struct *w)
+static int bam_data_peer_reset_cb(void *param)
 {
-	struct bam_data_port *port =
-			container_of(w, struct bam_data_port, disconnect_w);
+	struct bam_data_port	*port = (struct bam_data_port *)param;
+	struct bam_data_ch_info *d;
+	int ret;
 
-	pr_info("Enter");
+	d = &port->data_ch;
 
-	/* disable endpoints */
-	if (!port->port_usb || !port->port_usb->out || !port->port_usb->in) {
-		pr_err("port_usb->out/in == NULL. Exit");
-		return;
+	pr_debug("%s: reset by peer\n", __func__);
+
+	/* Disable BAM */
+	msm_hw_bam_disable(1);
+
+	/* Reset BAM */
+	ret = usb_bam_reset(0);
+	if (ret) {
+		pr_err("%s: BAM reset failed %d\n", __func__, ret);
+		return ret;
 	}
-	usb_ep_disable(port->port_usb->out);
-	usb_ep_disable(port->port_usb->in);
 
-	port->port_usb->in->driver_data = NULL;
-	port->port_usb->out->driver_data = NULL;
+	/* Enable BAM */
+	msm_hw_bam_disable(0);
 
-	port->port_usb = 0;
+	/* Unregister the peer reset callback */
+	usb_bam_register_peer_reset_cb(d->connection_idx, NULL, NULL);
 
-	pr_info("Exit");
+	return 0;
 }
 
 static void bam2bam_data_connect_work(struct work_struct *w)
@@ -135,7 +148,8 @@ static void bam2bam_data_connect_work(struct work_struct *w)
 	u32 sps_params;
 	int ret;
 
-	pr_info("Enter");
+	pr_debug("%s: Connect workqueue started", __func__);
+	usb_bam_reset_complete();
 
 	ret = usb_bam_connect(d->connection_idx, &d->src_pipe_idx,
 						  &d->dst_pipe_idx);
@@ -182,7 +196,18 @@ static void bam2bam_data_connect_work(struct work_struct *w)
 	bam_data_start_endless_rx(port);
 	bam_data_start_endless_tx(port);
 
-	pr_info("Done\n");
+	/* Register for peer reset callback */
+	usb_bam_register_peer_reset_cb(d->connection_idx,
+			bam_data_peer_reset_cb, port);
+
+	ret = usb_bam_client_ready(true);
+	if (ret) {
+		pr_err("%s: usb_bam_client_ready failed: err:%d\n",
+			__func__, ret);
+		return;
+	}
+
+	pr_debug("%s: Connect workqueue done", __func__);
 }
 
 static void bam2bam_data_port_free(int portno)
@@ -203,14 +228,13 @@ static int bam2bam_data_port_alloc(int portno)
 	port->port_num = portno;
 
 	INIT_WORK(&port->connect_w, bam2bam_data_connect_work);
-	INIT_WORK(&port->disconnect_w, bam2bam_data_disconnect_work);
 
 	/* data ch */
 	d = &port->data_ch;
 	d->port = port;
 	bam2bam_data_ports[portno] = port;
 
-	pr_info("port:%p portno:%d\n", port, portno);
+	pr_debug("port:%p portno:%d\n", port, portno);
 
 	return 0;
 }
@@ -218,9 +242,8 @@ static int bam2bam_data_port_alloc(int portno)
 void bam_data_disconnect(struct data_port *gr, u8 port_num)
 {
 	struct bam_data_port	*port;
-	struct bam_data_ch_info	*d;
 
-	pr_info("dev:%p port#%d\n", gr, port_num);
+	pr_debug("dev:%p port#%d\n", gr, port_num);
 
 	if (port_num >= n_bam2bam_data_ports) {
 		pr_err("invalid bam2bam portno#%d\n", port_num);
@@ -234,10 +257,20 @@ void bam_data_disconnect(struct data_port *gr, u8 port_num)
 
 	port = bam2bam_data_ports[port_num];
 
-	d = &port->data_ch;
-	port->port_usb = gr;
+	if (port->port_usb && port->port_usb->in &&
+	  port->port_usb->in->driver_data) {
+		/* disable endpoints */
+		usb_ep_disable(port->port_usb->out);
+		usb_ep_disable(port->port_usb->in);
+
+		port->port_usb->in->driver_data = NULL;
+		port->port_usb->out->driver_data = NULL;
 
-	queue_work(bam_data_wq, &port->disconnect_w);
+		port->port_usb = 0;
+	}
+
+	if (usb_bam_client_ready(false))
+		pr_err("%s: usb_bam_client_ready failed\n", __func__);
 }
 
 int bam_data_connect(struct data_port *gr, u8 port_num,
@@ -263,6 +296,11 @@ int bam_data_connect(struct data_port *gr, u8 port_num,
 
 	d = &port->data_ch;
 
+	if (!gr) {
+		pr_err("data port is null\n");
+		return -ENODEV;
+	}
+
 	ret = usb_ep_enable(gr->in);
 	if (ret) {
 		pr_err("usb_ep_enable failed eptype:IN ep:%p", gr->in);
@@ -287,18 +325,40 @@ int bam_data_connect(struct data_port *gr, u8 port_num,
 	return 0;
 }
 
+int bam_data_destroy(unsigned int no_bam2bam_port)
+{
+	struct bam_data_ch_info	*d;
+	struct bam_data_port	*port;
+
+	port = bam2bam_data_ports[no_bam2bam_port];
+	d = &port->data_ch;
+
+	pr_debug("bam_data_destroy: Freeing ports\n");
+	bam2bam_data_port_free(no_bam2bam_port);
+	if (bam_data_wq)
+		destroy_workqueue(bam_data_wq);
+	bam_data_wq = NULL;
+
+	return 0;
+}
+
 int bam_data_setup(unsigned int no_bam2bam_port)
 {
 	int	i;
 	int	ret;
 
-	pr_info("requested %d BAM2BAM ports", no_bam2bam_port);
+	pr_debug("requested %d BAM2BAM ports", no_bam2bam_port);
 
 	if (!no_bam2bam_port || no_bam2bam_port > BAM2BAM_DATA_N_PORTS) {
 		pr_err("Invalid num of ports count:%d\n", no_bam2bam_port);
 		return -EINVAL;
 	}
 
+	if (bam_data_wq) {
+		pr_debug("bam_data is already setup");
+		return 0;
+	}
+
 	bam_data_wq = alloc_workqueue("k_bam_data",
 				      WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
 	if (!bam_data_wq) {
@@ -331,7 +391,7 @@ static int bam_data_wake_cb(void *param)
 	struct bam_data_port *port = (struct bam_data_port *)param;
 	struct data_port *d_port = port->port_usb;
 
-	pr_info("%s: woken up by peer\n", __func__);
+	pr_debug("%s: woken up by peer\n", __func__);
 
 	if (!d_port) {
 		pr_err("FAILED: d_port == NULL");
@@ -360,7 +420,7 @@ void bam_data_suspend(u8 port_num)
 	port = bam2bam_data_ports[port_num];
 	d = &port->data_ch;
 
-	pr_info("%s: suspended port %d\n", __func__, port_num);
+	pr_debug("%s: suspended port %d\n", __func__, port_num);
 	usb_bam_register_wake_cb(d->connection_idx, bam_data_wake_cb, port);
 }
 
@@ -373,7 +433,7 @@ void bam_data_resume(u8 port_num)
 	port = bam2bam_data_ports[port_num];
 	d = &port->data_ch;
 
-	pr_info("%s: resumed port %d\n", __func__, port_num);
+	pr_debug("%s: resumed port %d\n", __func__, port_num);
 	usb_bam_register_wake_cb(d->connection_idx, NULL, NULL);
 }
 
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 624609e..0c0a719 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -45,12 +45,15 @@
 #include <asm/byteorder.h>
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <asm/system.h>
 #include <asm/unaligned.h>
-
-#if defined(CONFIG_PPC_PS3)
-#include <asm/firmware.h>
+/* SWIATART */
+#ifdef CONFIG_SIERRA_AR7
+#include <linux/sierra_bsudefs.h>
+#include <linux/sierra_bsuproto.h>
+#define BCBOOTAPPFLAG_HSIC_ENABLE_M        0x00000200
 #endif
-
+/* SWISTOP */
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -94,11 +97,11 @@ static const char	hcd_name [] = "ehci_hcd";
  */
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
-#define EHCI_IAA_MSECS		10		/* arbitrary */
+#define EHCI_IAA_MSECS		100		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
-						/* 5-ms async qh unlink delay */
+						/* 200-ms async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
@@ -111,7 +114,7 @@ module_param (park, uint, S_IRUGO);
 MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
 
 /* for flakey hardware, ignore overcurrent indicators */
-static bool ignore_oc = 0;
+static int ignore_oc = 0;
 module_param (ignore_oc, bool, S_IRUGO);
 MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 
@@ -287,7 +290,7 @@ static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
 
 	if (error) {
 		ehci_halt(ehci);
-		ehci->rh_state = EHCI_RH_HALTED;
+		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
 		ehci_err(ehci, "force halt; handshake %p %08x %08x -> %d\n",
 			ptr, mask, done, error);
 	}
@@ -503,7 +506,7 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	spin_unlock_irq(&ehci->lock);
 }
 
-static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
+static void __maybe_unused ehci_port_power (struct ehci_hcd *ehci, int is_on)
 {
 	unsigned port;
 
@@ -579,8 +582,21 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* root hub is shut down separately (first, when possible) */
 	spin_lock_irq (&ehci->lock);
-	if (ehci->async)
+	if (ehci->async) {
+		/*
+		 * TODO: Observed that ehci->async next ptr is not
+		 * NULL sometimes which leads to crash in mem_cleanup.
+		 * Root cause is not yet known why this messup is
+		 * happenning.
+		 * The follwing workaround fixes the crash caused
+		 * by this temporarily.
+		 * check if async next ptr is not NULL and unlink
+		 * explictly.
+		 */
+		if (ehci->async->qh_next.ptr != NULL)
+			start_unlink_async(ehci, ehci->async->qh_next.qh);
 		ehci_work (ehci);
+	}
 	spin_unlock_irq (&ehci->lock);
 	ehci_mem_cleanup (ehci);
 
@@ -730,16 +746,26 @@ static int ehci_init(struct usb_hcd *hcd)
 }
 
 /* start HC running; it's halted, ehci_init() has been run (once) */
-static int ehci_run (struct usb_hcd *hcd)
+static int __maybe_unused ehci_run (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	int			retval;	
 	u32			temp;
 	u32			hcc_params;
 
 	hcd->uses_new_polling = 1;
 
 	/* EHCI spec section 4.1 */
-
+	/*
+	 * TDI driver does the ehci_reset in their reset callback.
+	 * Don't reset here, because configuration settings will
+	 * vanish.
+	 */
+	if (!ehci_is_TDI(ehci) && (retval = ehci_reset(ehci)) != 0) {
+		ehci_mem_cleanup(ehci);
+		return retval;
+	}
+	
 	ehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);
 	ehci_writel(ehci, (u32)ehci->async->qh_dma, &ehci->regs->async_next);
 
@@ -934,6 +960,12 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 				continue;
 			pstatus = ehci_readl(ehci,
 					 &ehci->regs->port_status[i]);
+					 
+			/*set RS bit in case of remote wakeup*/
+			if (ehci_is_TDI(ehci) && !(cmd & CMD_RUN) &&
+					(pstatus & PORT_SUSPEND))
+				ehci_writel(ehci, cmd | CMD_RUN,
+						&ehci->regs->command);
 
 			if (pstatus & PORT_OWNER)
 				continue;
@@ -1207,7 +1239,7 @@ done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 }
 
-static void
+static void __maybe_unused
 ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
@@ -1265,139 +1297,184 @@ MODULE_LICENSE ("GPL");
 #define	PCI_DRIVER		ehci_pci_driver
 #endif
 
+#ifdef CONFIG_PPC_PS3
+#include "ehci-ps3.c"
+#define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
+#endif
+
+#ifdef CONFIG_USB_EHCI_HCD_PPC_OF
+#include "ehci-ppc-of.c"
+#define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver
+#endif
+
+#ifdef CONFIG_XPS_USB_HCD_XILINX
+#include "ehci-xilinx-of.c"
+#define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
+#endif
+
 #ifdef CONFIG_USB_EHCI_FSL
 #include "ehci-fsl.c"
 #define	PLATFORM_DRIVER		ehci_fsl_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_EHCI_MXC
 #include "ehci-mxc.c"
 #define PLATFORM_DRIVER		ehci_mxc_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_EHCI_SH
 #include "ehci-sh.c"
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_MIPS_ALCHEMY
 #include "ehci-au1xxx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_EHCI_HCD_OMAP
 #include "ehci-omap.c"
 #define        PLATFORM_DRIVER         ehci_hcd_omap_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_EHCI_ARC
 #include "ehci-arc.c"
 #define	PLATFORM_DRIVER		ehci_fsl_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_EHCI_HCD_PPC_OF
 #include "ehci-ppc-of.c"
 #define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_XPS_USB_HCD_XILINX
 #include "ehci-xilinx-of.c"
 #define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_PLAT_ORION
 #include "ehci-orion.c"
 #define	PLATFORM_DRIVER		ehci_orion_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_ARCH_IXP4XX
 #include "ehci-ixp4xx.c"
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_W90X900_EHCI
 #include "ehci-w90x900.c"
 #define	PLATFORM_DRIVER		ehci_hcd_w90x900_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_ARCH_AT91
 #include "ehci-atmel.c"
 #define	PLATFORM_DRIVER		ehci_atmel_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_OCTEON_EHCI
 #include "ehci-octeon.c"
 #define PLATFORM_DRIVER		ehci_octeon_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_CNS3XXX_EHCI
 #include "ehci-cns3xxx.c"
 #define PLATFORM_DRIVER		cns3xxx_ehci_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_ARCH_VT8500
 #include "ehci-vt8500.c"
 #define	PLATFORM_DRIVER		vt8500_ehci_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_PLAT_SPEAR
 #include "ehci-spear.c"
 #define PLATFORM_DRIVER		spear_ehci_hcd_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
-#ifdef CONFIG_USB_EHCI_MSM
-#include "ehci-msm.c"
-#define PLATFORM_DRIVER		ehci_msm_driver
+#ifdef CONFIG_USB_EHCI_MSM_72K
+#include "ehci-msm72k.c"
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
-#ifdef CONFIG_USB_EHCI_MSM_HSIC
-#include "ehci-msm-hsic.c"
-#define HSIC_PLATFORM_DRIVER		ehci_msm_hsic_driver
+#ifdef CONFIG_USB_EHCI_MSM
+#include "ehci-msm.c"
+#include "ehci-msm2.c"
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_EHCI_HCD_PMC_MSP
 #include "ehci-pmcmsp.c"
 #define	PLATFORM_DRIVER		ehci_hcd_msp_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_EHCI_TEGRA
 #include "ehci-tegra.c"
 #define PLATFORM_DRIVER		tegra_ehci_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_EHCI_S5P
 #include "ehci-s5p.c"
 #define PLATFORM_DRIVER		s5p_ehci_driver
-#endif
-
-#ifdef CONFIG_SPARC_LEON
-#include "ehci-grlib.c"
-#define PLATFORM_DRIVER		ehci_grlib_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_CPU_XLR
 #include "ehci-xls.c"
 #define PLATFORM_DRIVER		ehci_xls_driver
+#define PLATFORM_DRIVER_PRESENT
+#endif
+
+#ifdef CONFIG_USB_EHCI_ATH79
+#include "ehci-ath79.c"
+#define PLATFORM_DRIVER_PRESENT
+#endif
+
+#ifdef CONFIG_SPARC_LEON
+#include "ehci-grlib.c"
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_EHCI_MV
 #include "ehci-mv.c"
 #define        PLATFORM_DRIVER         ehci_mv_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_MACH_LOONGSON1
 #include "ehci-ls1x.c"
 #define PLATFORM_DRIVER		ehci_ls1x_driver
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
-#ifdef CONFIG_USB_EHCI_HCD_PLATFORM
-#include "ehci-platform.c"
-#define PLATFORM_DRIVER		ehci_platform_driver
+#ifdef CONFIG_USB_EHCI_MSM_HSIC
+#define HSIC_PLATFORM_DRIVER		ehci_msm_hsic_driver
+#include "ehci-msm-hsic.c"
+#define PLATFORM_DRIVER_PRESENT
 #endif
 
 #ifdef CONFIG_USB_CI13612_HCD
@@ -1405,15 +1482,107 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER	ci13612_ehci_driver
 #endif
 
-#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
+#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER_PRESENT) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
 
+static struct platform_driver *plat_drivers[]  = {
+#ifdef CONFIG_USB_EHCI_FSL
+	&ehci_fsl_driver,
+#endif
+
+#ifdef CONFIG_USB_EHCI_MXC
+	&ehci_mxc_driver,
+#endif
+
+#ifdef CONFIG_CPU_SUBTYPE_SH7786
+	&ehci_hcd_sh_driver,
+#endif
+
+#ifdef CONFIG_SOC_AU1200
+	&ehci_hcd_au1xxx_driver,
+#endif
+
+#ifdef CONFIG_USB_EHCI_HCD_OMAP
+	&ehci_hcd_omap_driver,
+#endif
+
+#ifdef CONFIG_PLAT_ORION
+	&ehci_orion_driver,
+#endif
+
+#ifdef CONFIG_ARCH_IXP4XX
+	&ixp4xx_ehci_driver,
+#endif
+
+#ifdef CONFIG_USB_W90X900_EHCI
+	&ehci_hcd_w90x900_driver,
+#endif
+
+#ifdef CONFIG_ARCH_AT91
+	&ehci_atmel_driver,
+#endif
+
+#ifdef CONFIG_USB_OCTEON_EHCI
+	&ehci_octeon_driver,
+#endif
+
+#ifdef CONFIG_USB_CNS3XXX_EHCI
+	&cns3xxx_ehci_driver,
+#endif
+
+#ifdef CONFIG_ARCH_VT8500
+	&vt8500_ehci_driver,
+#endif
+
+#ifdef CONFIG_PLAT_SPEAR
+	&spear_ehci_hcd_driver,
+#endif
+
+#ifdef CONFIG_USB_EHCI_HCD_PMC_MSP
+	&ehci_hcd_msp_driver
+#endif
+
+#ifdef CONFIG_USB_EHCI_TEGRA
+	&tegra_ehci_driver
+#endif
+
+#ifdef CONFIG_USB_EHCI_S5P
+	&s5p_ehci_driver
+#endif
+
+#ifdef CONFIG_USB_EHCI_ATH79
+	&ehci_ath79_driver
+#endif
+
+#ifdef CONFIG_SPARC_LEON
+	&ehci_grlib_driver
+#endif
+
+#if defined(CONFIG_USB_EHCI_MSM_72K) || defined(CONFIG_USB_EHCI_MSM)
+	&ehci_msm_driver,
+#endif
+
+#ifdef CONFIG_USB_EHCI_MSM_HSIC
+	&ehci_msm_hsic_driver,
+#endif
+
+#ifdef CONFIG_USB_EHCI_MSM
+	&ehci_msm2_driver,
+#endif
+
+};
+
 static int __init ehci_hcd_init(void)
 {
-	int retval = 0;
+	int i, retval = 0;
+/* SWISTART */
+#ifdef CONFIG_SIERRA_AR7
+	char* hsichostname = "msm_hsic_host";
+#endif
+/* SWISTART */
 
 	if (usb_disabled())
 		return -ENODEV;
@@ -1438,12 +1607,28 @@ static int __init ehci_hcd_init(void)
 	}
 #endif
 
-#ifdef PLATFORM_DRIVER
-	retval = platform_driver_register(&PLATFORM_DRIVER);
-	if (retval < 0)
-		goto clean0;
+	for (i = 0; i < ARRAY_SIZE(plat_drivers); i++) {
+/* SWISTART */
+#ifdef CONFIG_SIERRA_AR7
+		if(!((bsreadboottoappflag()& BCBOOTAPPFLAG_HSIC_ENABLE_M)))
+		{
+			pr_info("%s():HSIC host is disabe", __func__ );
+			if(strcmp(plat_drivers[i]->driver.name, hsichostname )== 0)
+			{
+				continue;
+			}
+		}
 #endif
 
+/* SWISTOP */
+		retval = platform_driver_register(plat_drivers[i]);
+		if (retval) {
+			while (--i >= 0)
+				platform_driver_unregister(plat_drivers[i]);
+			goto clean0;
+		}
+	}
+
 #ifdef PCI_DRIVER
 	retval = pci_register_driver(&PCI_DRIVER);
 	if (retval < 0)
@@ -1496,10 +1681,9 @@ clean2:
 	pci_unregister_driver(&PCI_DRIVER);
 clean1:
 #endif
-#ifdef PLATFORM_DRIVER
-	platform_driver_unregister(&PLATFORM_DRIVER);
+	for (i = 0; i < ARRAY_SIZE(plat_drivers); i++)
+		platform_driver_unregister(plat_drivers[i]);
 clean0:
-#endif
 #ifdef DEBUG
 	debugfs_remove(ehci_debug_root);
 	ehci_debug_root = NULL;
@@ -1512,19 +1696,17 @@ module_init(ehci_hcd_init);
 
 static void __exit ehci_hcd_cleanup(void)
 {
-
+int i;
 #ifdef XILINX_OF_PLATFORM_DRIVER
 	platform_driver_unregister(&XILINX_OF_PLATFORM_DRIVER);
 #endif
 #ifdef OF_PLATFORM_DRIVER
 	platform_driver_unregister(&OF_PLATFORM_DRIVER);
 #endif
-#ifdef PLATFORM_DRIVER
-	platform_driver_unregister(&PLATFORM_DRIVER);
-#endif
-#ifdef HSIC_PLATFORM_DRIVER
-	platform_driver_unregister(&HSIC_PLATFORM_DRIVER);
-#endif
+
+	for (i = 0; i < ARRAY_SIZE(plat_drivers); i++)
+		platform_driver_unregister(plat_drivers[i]);
+
 #ifdef PCI_DRIVER
 	pci_unregister_driver(&PCI_DRIVER);
 #endif
diff --git a/drivers/usb/host/ehci-msm2.c b/drivers/usb/host/ehci-msm2.c
new file mode 100644
index 0000000..4a4e126
--- /dev/null
+++ b/drivers/usb/host/ehci-msm2.c
@@ -0,0 +1,1093 @@
+/* ehci-msm2.c - HSUSB Host Controller Driver Implementation
+ *
+ * Copyright (c) 2008-2012, The Linux Foundation. All rights reserved.
+ *
+ * Partly derived from ehci-fsl.c and ehci-hcd.c
+ * Copyright (c) 2000-2004 by David Brownell
+ * Copyright (c) 2005 MontaVista Software
+ *
+ * All source code in this file is licensed under the following license except
+ * where indicated.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can find it at http://www.fsf.org
+ */
+
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/wakelock.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <linux/usb/ulpi.h>
+#include <linux/usb/msm_hsusb_hw.h>
+#include <linux/usb/msm_hsusb.h>
+#include <mach/clk.h>
+#include <mach/msm_xo.h>
+#include <mach/msm_iomap.h>
+
+#undef ULPI_INT_DP
+#define ULPI_INT_DP				(1 << 7)
+
+#define MSM_USB_BASE (hcd->regs)
+
+#define PDEV_NAME_LEN 20
+
+struct msm_hcd {
+	struct ehci_hcd				ehci;
+	struct device				*dev;
+	struct clk				*iface_clk;
+	struct clk				*core_clk;
+	struct clk				*alt_core_clk;
+	struct regulator			*hsusb_vddcx;
+	struct regulator			*hsusb_3p3;
+	struct regulator			*hsusb_1p8;
+	struct regulator			*vbus;
+	struct msm_xo_voter			*xo_handle;
+	bool					async_int;
+	bool					vbus_on;
+	atomic_t				in_lpm;
+	struct wake_lock			wlock;
+};
+
+static inline struct msm_hcd *hcd_to_mhcd(struct usb_hcd *hcd)
+{
+	return (struct msm_hcd *) (hcd->hcd_priv);
+}
+
+static inline struct usb_hcd *mhcd_to_hcd(struct msm_hcd *mhcd)
+{
+	return container_of((void *) mhcd, struct usb_hcd, hcd_priv);
+}
+
+#define HSUSB_PHY_3P3_VOL_MIN		3050000 /* uV */
+#define HSUSB_PHY_3P3_VOL_MAX		3300000 /* uV */
+#define HSUSB_PHY_3P3_HPM_LOAD		50000	/* uA */
+
+#define HSUSB_PHY_1P8_VOL_MIN		1800000 /* uV */
+#define HSUSB_PHY_1P8_VOL_MAX		1800000 /* uV */
+#define HSUSB_PHY_1P8_HPM_LOAD		50000	/* uA */
+
+#define HSUSB_PHY_VDD_DIG_VOL_MIN	1045000	/* uV */
+#define HSUSB_PHY_VDD_DIG_VOL_MAX	1320000	/* uV */
+#define HSUSB_PHY_VDD_DIG_LOAD		49360	/* uA */
+
+static int msm_ehci_init_vddcx(struct msm_hcd *mhcd, int init)
+{
+	int ret = 0;
+
+	if (!init)
+		goto disable_reg;
+
+	mhcd->hsusb_vddcx = devm_regulator_get(mhcd->dev, "HSUSB_VDDCX");
+	if (IS_ERR(mhcd->hsusb_vddcx)) {
+		dev_err(mhcd->dev, "unable to get ehci vddcx\n");
+		return PTR_ERR(mhcd->hsusb_vddcx);
+	}
+
+	ret = regulator_set_voltage(mhcd->hsusb_vddcx,
+			HSUSB_PHY_VDD_DIG_VOL_MIN,
+			HSUSB_PHY_VDD_DIG_VOL_MAX);
+	if (ret) {
+		dev_err(mhcd->dev, "unable to set the voltage"
+				"for ehci vddcx\n");
+		return ret;
+	}
+
+	ret = regulator_set_optimum_mode(mhcd->hsusb_vddcx,
+				HSUSB_PHY_VDD_DIG_LOAD);
+	if (ret < 0) {
+		dev_err(mhcd->dev, "%s: Unable to set optimum mode of the"
+				" regulator: VDDCX\n", __func__);
+		goto reg_optimum_mode_err;
+	}
+
+	ret = regulator_enable(mhcd->hsusb_vddcx);
+	if (ret) {
+		dev_err(mhcd->dev, "unable to enable ehci vddcx\n");
+		goto reg_enable_err;
+	}
+
+	return 0;
+
+disable_reg:
+	regulator_disable(mhcd->hsusb_vddcx);
+reg_enable_err:
+	regulator_set_optimum_mode(mhcd->hsusb_vddcx, 0);
+reg_optimum_mode_err:
+	regulator_set_voltage(mhcd->hsusb_vddcx, 0,
+				HSUSB_PHY_VDD_DIG_VOL_MIN);
+	return ret;
+
+}
+
+static int msm_ehci_ldo_init(struct msm_hcd *mhcd, int init)
+{
+	int rc = 0;
+
+	if (!init)
+		goto put_1p8;
+
+	mhcd->hsusb_3p3 = devm_regulator_get(mhcd->dev, "HSUSB_3p3");
+	if (IS_ERR(mhcd->hsusb_3p3)) {
+		dev_err(mhcd->dev, "unable to get hsusb 3p3\n");
+		return PTR_ERR(mhcd->hsusb_3p3);
+	}
+
+	rc = regulator_set_voltage(mhcd->hsusb_3p3,
+			HSUSB_PHY_3P3_VOL_MIN, HSUSB_PHY_3P3_VOL_MAX);
+	if (rc) {
+		dev_err(mhcd->dev, "unable to set voltage level for"
+				"hsusb 3p3\n");
+		return rc;
+	}
+	mhcd->hsusb_1p8 = devm_regulator_get(mhcd->dev, "HSUSB_1p8");
+	if (IS_ERR(mhcd->hsusb_1p8)) {
+		dev_err(mhcd->dev, "unable to get hsusb 1p8\n");
+		rc = PTR_ERR(mhcd->hsusb_1p8);
+		goto put_3p3_lpm;
+	}
+	rc = regulator_set_voltage(mhcd->hsusb_1p8,
+			HSUSB_PHY_1P8_VOL_MIN, HSUSB_PHY_1P8_VOL_MAX);
+	if (rc) {
+		dev_err(mhcd->dev, "unable to set voltage level for"
+				"hsusb 1p8\n");
+		goto put_1p8;
+	}
+
+	return 0;
+
+put_1p8:
+	regulator_set_voltage(mhcd->hsusb_1p8, 0, HSUSB_PHY_1P8_VOL_MAX);
+put_3p3_lpm:
+	regulator_set_voltage(mhcd->hsusb_3p3, 0, HSUSB_PHY_3P3_VOL_MAX);
+
+	return rc;
+}
+
+#ifdef CONFIG_PM_SLEEP
+#define HSUSB_PHY_SUSP_DIG_VOL_P50  500000
+#define HSUSB_PHY_SUSP_DIG_VOL_P75  750000
+static int msm_ehci_config_vddcx(struct msm_hcd *mhcd, int high)
+{
+	struct msm_usb_host_platform_data *pdata;
+	int max_vol = HSUSB_PHY_VDD_DIG_VOL_MAX;
+	int min_vol;
+	int ret;
+
+	pdata = mhcd->dev->platform_data;
+
+	if (high)
+		min_vol = HSUSB_PHY_VDD_DIG_VOL_MIN;
+	else if (pdata && pdata->dock_connect_irq &&
+			!irq_read_line(pdata->dock_connect_irq))
+		min_vol = HSUSB_PHY_SUSP_DIG_VOL_P75;
+	else
+		min_vol = HSUSB_PHY_SUSP_DIG_VOL_P50;
+
+	ret = regulator_set_voltage(mhcd->hsusb_vddcx, min_vol, max_vol);
+	if (ret) {
+		dev_err(mhcd->dev, "%s: unable to set the voltage of regulator"
+			" HSUSB_VDDCX\n", __func__);
+		return ret;
+	}
+
+	dev_dbg(mhcd->dev, "%s: min_vol:%d max_vol:%d\n", __func__, min_vol,
+								max_vol);
+
+	return ret;
+}
+#else
+static int msm_ehci_config_vddcx(struct msm_hcd *mhcd, int high)
+{
+	return 0;
+}
+#endif
+
+static void msm_ehci_vbus_power(struct msm_hcd *mhcd, bool on)
+{
+	int ret;
+
+	if (!mhcd->vbus) {
+		pr_err("vbus is NULL.");
+		return;
+	}
+
+	if (mhcd->vbus_on == on)
+		return;
+
+	if (on) {
+		ret = regulator_enable(mhcd->vbus);
+		if (ret) {
+			pr_err("unable to enable vbus\n");
+			return;
+		}
+		mhcd->vbus_on = true;
+	} else {
+		ret = regulator_disable(mhcd->vbus);
+		if (ret) {
+			pr_err("unable to disable vbus\n");
+			return;
+		}
+		mhcd->vbus_on = false;
+	}
+}
+
+static irqreturn_t msm_ehci_dock_connect_irq(int irq, void *data)
+{
+	const struct msm_usb_host_platform_data *pdata;
+	struct msm_hcd *mhcd = data;
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+
+	pdata = mhcd->dev->platform_data;
+
+	if (atomic_read(&mhcd->in_lpm))
+		usb_hcd_resume_root_hub(hcd);
+
+	if (irq_read_line(pdata->dock_connect_irq)) {
+		dev_dbg(mhcd->dev, "%s:Dock removed disable vbus\n", __func__);
+		msm_ehci_vbus_power(mhcd, 0);
+	} else {
+		dev_dbg(mhcd->dev, "%s:Dock connected enable vbus\n", __func__);
+		msm_ehci_vbus_power(mhcd, 1);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int msm_ehci_init_vbus(struct msm_hcd *mhcd, int init)
+{
+	int rc = 0;
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	const struct msm_usb_host_platform_data *pdata;
+
+	pdata = mhcd->dev->platform_data;
+
+	if (!init) {
+		if (pdata && pdata->dock_connect_irq)
+			free_irq(pdata->dock_connect_irq, mhcd);
+		return rc;
+	}
+
+	mhcd->vbus = devm_regulator_get(mhcd->dev, "vbus");
+	if (IS_ERR(mhcd->vbus)) {
+		pr_err("Unable to get vbus\n");
+		return -ENODEV;
+	}
+
+	if (pdata) {
+		hcd->power_budget = pdata->power_budget;
+
+		if (pdata->dock_connect_irq) {
+			rc = request_threaded_irq(pdata->dock_connect_irq, NULL,
+					msm_ehci_dock_connect_irq,
+					IRQF_TRIGGER_FALLING |
+					IRQF_TRIGGER_RISING |
+					IRQF_ONESHOT, "msm_ehci_host", mhcd);
+			if (!rc)
+				enable_irq_wake(pdata->dock_connect_irq);
+		}
+	}
+	return rc;
+}
+
+static int msm_ehci_ldo_enable(struct msm_hcd *mhcd, int on)
+{
+	int ret = 0;
+
+	if (IS_ERR(mhcd->hsusb_1p8)) {
+		dev_err(mhcd->dev, "%s: HSUSB_1p8 is not initialized\n",
+								__func__);
+		return -ENODEV;
+	}
+
+	if (IS_ERR(mhcd->hsusb_3p3)) {
+		dev_err(mhcd->dev, "%s: HSUSB_3p3 is not initialized\n",
+								__func__);
+		return -ENODEV;
+	}
+
+	if (on) {
+		ret = regulator_set_optimum_mode(mhcd->hsusb_1p8,
+						HSUSB_PHY_1P8_HPM_LOAD);
+		if (ret < 0) {
+			dev_err(mhcd->dev, "%s: Unable to set HPM of the"
+				" regulator: HSUSB_1p8\n", __func__);
+			return ret;
+		}
+
+		ret = regulator_enable(mhcd->hsusb_1p8);
+		if (ret) {
+			dev_err(mhcd->dev, "%s: unable to enable the hsusb"
+						" 1p8\n", __func__);
+			regulator_set_optimum_mode(mhcd->hsusb_1p8, 0);
+			return ret;
+		}
+
+		ret = regulator_set_optimum_mode(mhcd->hsusb_3p3,
+						HSUSB_PHY_3P3_HPM_LOAD);
+		if (ret < 0) {
+			dev_err(mhcd->dev, "%s: Unable to set HPM of the "
+				"regulator: HSUSB_3p3\n", __func__);
+			regulator_set_optimum_mode(mhcd->hsusb_1p8, 0);
+			regulator_disable(mhcd->hsusb_1p8);
+			return ret;
+		}
+
+		ret = regulator_enable(mhcd->hsusb_3p3);
+		if (ret) {
+			dev_err(mhcd->dev, "%s: unable to enable the "
+					"hsusb 3p3\n", __func__);
+			regulator_set_optimum_mode(mhcd->hsusb_3p3, 0);
+			regulator_set_optimum_mode(mhcd->hsusb_1p8, 0);
+			regulator_disable(mhcd->hsusb_1p8);
+			return ret;
+		}
+
+	} else {
+		ret = regulator_disable(mhcd->hsusb_1p8);
+		if (ret) {
+			dev_err(mhcd->dev, "%s: unable to disable the "
+					"hsusb 1p8\n", __func__);
+			return ret;
+		}
+
+		ret = regulator_set_optimum_mode(mhcd->hsusb_1p8, 0);
+		if (ret < 0)
+			dev_err(mhcd->dev, "%s: Unable to set LPM of the "
+				"regulator: HSUSB_1p8\n", __func__);
+
+		ret = regulator_disable(mhcd->hsusb_3p3);
+		if (ret) {
+			dev_err(mhcd->dev, "%s: unable to disable the "
+					"hsusb 3p3\n", __func__);
+			return ret;
+		}
+		ret = regulator_set_optimum_mode(mhcd->hsusb_3p3, 0);
+		if (ret < 0)
+			dev_err(mhcd->dev, "%s: Unable to set LPM of the "
+					"regulator: HSUSB_3p3\n", __func__);
+	}
+
+	dev_dbg(mhcd->dev, "reg (%s)\n", on ? "HPM" : "LPM");
+
+	return ret < 0 ? ret : 0;
+}
+
+
+#define ULPI_IO_TIMEOUT_USECS	(10 * 1000)
+static int msm_ulpi_read(struct msm_hcd *mhcd, u32 reg)
+{
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	unsigned long timeout;
+
+	/* initiate read operation */
+	writel_relaxed(ULPI_RUN | ULPI_READ | ULPI_ADDR(reg),
+	       USB_ULPI_VIEWPORT);
+
+	/* wait for completion */
+	timeout = jiffies + usecs_to_jiffies(ULPI_IO_TIMEOUT_USECS);
+	while (readl_relaxed(USB_ULPI_VIEWPORT) & ULPI_RUN) {
+		if (time_after(jiffies, timeout)) {
+			dev_err(mhcd->dev, "msm_ulpi_read: timeout %08x\n",
+				readl_relaxed(USB_ULPI_VIEWPORT));
+			return -ETIMEDOUT;
+		}
+		udelay(1);
+	}
+
+	return ULPI_DATA_READ(readl_relaxed(USB_ULPI_VIEWPORT));
+}
+
+
+static int msm_ulpi_write(struct msm_hcd *mhcd, u32 val, u32 reg)
+{
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	unsigned long timeout;
+
+	/* initiate write operation */
+	writel_relaxed(ULPI_RUN | ULPI_WRITE |
+	       ULPI_ADDR(reg) | ULPI_DATA(val),
+	       USB_ULPI_VIEWPORT);
+
+	/* wait for completion */
+	timeout = jiffies + usecs_to_jiffies(ULPI_IO_TIMEOUT_USECS);
+	while (readl_relaxed(USB_ULPI_VIEWPORT) & ULPI_RUN) {
+		if (time_after(jiffies, timeout)) {
+			dev_err(mhcd->dev, "msm_ulpi_write: timeout\n");
+			return -ETIMEDOUT;
+		}
+		udelay(1);
+	}
+
+	return 0;
+}
+
+static int msm_ehci_link_clk_reset(struct msm_hcd *mhcd, bool assert)
+{
+	int ret;
+
+	if (assert) {
+		ret = clk_reset(mhcd->alt_core_clk, CLK_RESET_ASSERT);
+		if (ret)
+			dev_err(mhcd->dev, "usb alt_core_clk assert failed\n");
+	} else {
+		ret = clk_reset(mhcd->alt_core_clk, CLK_RESET_DEASSERT);
+		if (ret)
+			dev_err(mhcd->dev, "usb alt_core_clk deassert failed\n");
+	}
+
+	return ret;
+}
+
+static int msm_ehci_phy_reset(struct msm_hcd *mhcd)
+{
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	u32 val;
+	int ret;
+	int retries;
+
+	ret = msm_ehci_link_clk_reset(mhcd, 1);
+	if (ret)
+		return ret;
+
+	udelay(1);
+
+	ret = msm_ehci_link_clk_reset(mhcd, 0);
+	if (ret)
+		return ret;
+
+	val = readl_relaxed(USB_PORTSC) & ~PORTSC_PTS_MASK;
+	writel_relaxed(val | PORTSC_PTS_ULPI, USB_PORTSC);
+
+	for (retries = 3; retries > 0; retries--) {
+		ret = msm_ulpi_write(mhcd, ULPI_FUNC_CTRL_SUSPENDM,
+				ULPI_CLR(ULPI_FUNC_CTRL));
+		if (!ret)
+			break;
+	}
+	if (!retries)
+		return -ETIMEDOUT;
+
+	/* Wakeup the PHY with a reg-access for calibration */
+	for (retries = 3; retries > 0; retries--) {
+		ret = msm_ulpi_read(mhcd, ULPI_DEBUG);
+		if (ret != -ETIMEDOUT)
+			break;
+	}
+	if (!retries)
+		return -ETIMEDOUT;
+
+	dev_info(mhcd->dev, "phy_reset: success\n");
+
+	return 0;
+}
+
+#define LINK_RESET_TIMEOUT_USEC		(250 * 1000)
+static int msm_hsusb_reset(struct msm_hcd *mhcd)
+{
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	unsigned long timeout;
+	int ret;
+
+	clk_prepare_enable(mhcd->alt_core_clk);
+	ret = msm_ehci_phy_reset(mhcd);
+	if (ret) {
+		dev_err(mhcd->dev, "phy_reset failed\n");
+		return ret;
+	}
+
+	writel_relaxed(USBCMD_RESET, USB_USBCMD);
+
+	timeout = jiffies + usecs_to_jiffies(LINK_RESET_TIMEOUT_USEC);
+	while (readl_relaxed(USB_USBCMD) & USBCMD_RESET) {
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		udelay(1);
+	}
+
+	/* select ULPI phy */
+	writel_relaxed(0x80000000, USB_PORTSC);
+
+	msleep(100);
+
+	writel_relaxed(0x0, USB_AHBBURST);
+	writel_relaxed(0x08, USB_AHBMODE);
+
+	/* Ensure that RESET operation is completed before turning off clock */
+	mb();
+	clk_disable_unprepare(mhcd->alt_core_clk);
+
+	/*rising edge interrupts with Dp rise and fall enabled*/
+	msm_ulpi_write(mhcd, ULPI_INT_DP, ULPI_USB_INT_EN_RISE);
+	msm_ulpi_write(mhcd, ULPI_INT_DP, ULPI_USB_INT_EN_FALL);
+
+	/*Clear the PHY interrupts by reading the PHY interrupt latch register*/
+	msm_ulpi_read(mhcd, ULPI_USB_INT_LATCH);
+
+	return 0;
+}
+
+#define PHY_SUSPEND_TIMEOUT_USEC	(500 * 1000)
+#define PHY_RESUME_TIMEOUT_USEC		(100 * 1000)
+
+#ifdef CONFIG_PM_SLEEP
+static int msm_ehci_suspend(struct msm_hcd *mhcd)
+{
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	unsigned long timeout;
+	int ret;
+	u32 portsc;
+
+	if (atomic_read(&mhcd->in_lpm)) {
+		dev_dbg(mhcd->dev, "%s called in lpm\n", __func__);
+		return 0;
+	}
+
+	disable_irq(hcd->irq);
+
+	/* Set the PHCD bit, only if it is not set by the controller.
+	 * PHY may take some time or even fail to enter into low power
+	 * mode (LPM). Hence poll for 500 msec and reset the PHY and link
+	 * in failure case.
+	 */
+	portsc = readl_relaxed(USB_PORTSC);
+	if (!(portsc & PORTSC_PHCD)) {
+		writel_relaxed(portsc | PORTSC_PHCD,
+				USB_PORTSC);
+
+		timeout = jiffies + usecs_to_jiffies(PHY_SUSPEND_TIMEOUT_USEC);
+		while (!(readl_relaxed(USB_PORTSC) & PORTSC_PHCD)) {
+			if (time_after(jiffies, timeout)) {
+				dev_err(mhcd->dev, "Unable to suspend PHY\n");
+				msm_hsusb_reset(mhcd);
+				break;
+			}
+			udelay(1);
+		}
+	}
+
+	/*
+	 * PHY has capability to generate interrupt asynchronously in low
+	 * power mode (LPM). This interrupt is level triggered. So USB IRQ
+	 * line must be disabled till async interrupt enable bit is cleared
+	 * in USBCMD register. Assert STP (ULPI interface STOP signal) to
+	 * block data communication from PHY.
+	 */
+	writel_relaxed(readl_relaxed(USB_USBCMD) | ASYNC_INTR_CTRL |
+				ULPI_STP_CTRL, USB_USBCMD);
+
+	/*
+	 * Ensure that hardware is put in low power mode before
+	 * clocks are turned OFF and VDD is allowed to minimize.
+	 */
+	mb();
+
+	clk_disable_unprepare(mhcd->iface_clk);
+	clk_disable_unprepare(mhcd->core_clk);
+
+	/* usb phy does not require TCXO clock, hence vote for TCXO disable */
+	ret = msm_xo_mode_vote(mhcd->xo_handle, MSM_XO_MODE_OFF);
+	if (ret)
+		dev_err(mhcd->dev, "%s failed to devote for "
+			"TCXO D0 buffer%d\n", __func__, ret);
+
+	msm_ehci_config_vddcx(mhcd, 0);
+
+	atomic_set(&mhcd->in_lpm, 1);
+	enable_irq(hcd->irq);
+	wake_unlock(&mhcd->wlock);
+
+	dev_info(mhcd->dev, "EHCI USB in low power mode\n");
+
+	return 0;
+}
+
+static int msm_ehci_resume(struct msm_hcd *mhcd)
+{
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	unsigned long timeout;
+	unsigned temp;
+	int ret;
+
+	if (!atomic_read(&mhcd->in_lpm)) {
+		dev_dbg(mhcd->dev, "%s called in !in_lpm\n", __func__);
+		return 0;
+	}
+
+	wake_lock(&mhcd->wlock);
+
+	/* Vote for TCXO when waking up the phy */
+	ret = msm_xo_mode_vote(mhcd->xo_handle, MSM_XO_MODE_ON);
+	if (ret)
+		dev_err(mhcd->dev, "%s failed to vote for "
+			"TCXO D0 buffer%d\n", __func__, ret);
+
+	clk_prepare_enable(mhcd->core_clk);
+	clk_prepare_enable(mhcd->iface_clk);
+
+	msm_ehci_config_vddcx(mhcd, 1);
+
+	temp = readl_relaxed(USB_USBCMD);
+	temp &= ~ASYNC_INTR_CTRL;
+	temp &= ~ULPI_STP_CTRL;
+	writel_relaxed(temp, USB_USBCMD);
+
+	if (!(readl_relaxed(USB_PORTSC) & PORTSC_PHCD))
+		goto skip_phy_resume;
+
+	temp = readl_relaxed(USB_PORTSC) & ~PORTSC_PHCD;
+	writel_relaxed(temp, USB_PORTSC);
+
+	timeout = jiffies + usecs_to_jiffies(PHY_RESUME_TIMEOUT_USEC);
+	while ((readl_relaxed(USB_PORTSC) & PORTSC_PHCD) ||
+			!(readl_relaxed(USB_ULPI_VIEWPORT) & ULPI_SYNC_STATE)) {
+		if (time_after(jiffies, timeout)) {
+			/*This is a fatal error. Reset the link and PHY*/
+			dev_err(mhcd->dev, "Unable to resume USB. Resetting the h/w\n");
+			msm_hsusb_reset(mhcd);
+			break;
+		}
+		udelay(1);
+	}
+
+skip_phy_resume:
+
+	atomic_set(&mhcd->in_lpm, 0);
+
+	if (mhcd->async_int) {
+		mhcd->async_int = false;
+		pm_runtime_put_noidle(mhcd->dev);
+		enable_irq(hcd->irq);
+	}
+
+	dev_info(mhcd->dev, "EHCI USB exited from low power mode\n");
+
+	return 0;
+}
+#endif
+
+static irqreturn_t msm_ehci_irq(struct usb_hcd *hcd)
+{
+	struct msm_hcd *mhcd = hcd_to_mhcd(hcd);
+
+	if (atomic_read(&mhcd->in_lpm)) {
+		disable_irq_nosync(hcd->irq);
+		mhcd->async_int = true;
+		pm_runtime_get(mhcd->dev);
+		return IRQ_HANDLED;
+	}
+
+	return ehci_irq(hcd);
+}
+
+static int msm_ehci_reset(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	ehci->caps = USB_CAPLENGTH;
+	ehci->regs = USB_CAPLENGTH +
+		HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache the data to minimize the chip reads*/
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	hcd->has_tt = 1;
+	ehci->sbrn = HCD_USB2;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	retval = ehci_reset(ehci);
+	if (retval)
+		return retval;
+
+	/* bursts of unspecified length. */
+	writel_relaxed(0, USB_AHBBURST);
+	/* Use the AHB transactor */
+	writel_relaxed(0x08, USB_AHBMODE);
+	/* Disable streaming mode and select host mode */
+	writel_relaxed(0x13, USB_USBMODE);
+
+	ehci_port_power(ehci, 1);
+	return 0;
+}
+
+static struct hc_driver msm_hc2_driver = {
+	.description		= hcd_name,
+	.product_desc		= "Qualcomm EHCI Host Controller",
+	.hcd_priv_size		= sizeof(struct msm_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= msm_ehci_irq,
+	.flags			= HCD_USB2 | HCD_MEMORY,
+
+	.reset			= msm_ehci_reset,
+	.start			= ehci_run,
+
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.endpoint_reset		= ehci_endpoint_reset,
+	.clear_tt_buffer_complete	 = ehci_clear_tt_buffer_complete,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+
+	/*
+	 * PM support
+	 */
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+};
+
+static int msm_ehci_init_clocks(struct msm_hcd *mhcd, u32 init)
+{
+	int ret = 0;
+
+	if (!init)
+		goto put_clocks;
+
+	/* 60MHz alt_core_clk is for LINK to be used during PHY RESET  */
+	mhcd->alt_core_clk = clk_get(mhcd->dev, "alt_core_clk");
+	if (IS_ERR(mhcd->alt_core_clk)) {
+		dev_err(mhcd->dev, "failed to get alt_core_clk\n");
+		ret = PTR_ERR(mhcd->alt_core_clk);
+		return ret;
+	}
+	clk_set_rate(mhcd->alt_core_clk, 60000000);
+
+	/* iface_clk is required for data transfers */
+	mhcd->iface_clk = clk_get(mhcd->dev, "iface_clk");
+	if (IS_ERR(mhcd->iface_clk)) {
+		dev_err(mhcd->dev, "failed to get iface_clk\n");
+		ret = PTR_ERR(mhcd->iface_clk);
+		goto put_alt_core_clk;
+	}
+
+	/* Link's protocol engine is based on pclk which must
+	 * be running >55Mhz and frequency should also not change.
+	 * Hence, vote for maximum clk frequency on its source
+	 */
+	mhcd->core_clk = clk_get(mhcd->dev, "core_clk");
+	if (IS_ERR(mhcd->core_clk)) {
+		dev_err(mhcd->dev, "failed to get core_clk\n");
+		ret = PTR_ERR(mhcd->core_clk);
+		goto put_iface_clk;
+	}
+	clk_set_rate(mhcd->core_clk, INT_MAX);
+
+	clk_prepare_enable(mhcd->core_clk);
+	clk_prepare_enable(mhcd->iface_clk);
+
+	return 0;
+
+put_clocks:
+	clk_disable_unprepare(mhcd->iface_clk);
+	clk_disable_unprepare(mhcd->core_clk);
+	clk_put(mhcd->core_clk);
+put_iface_clk:
+	clk_put(mhcd->iface_clk);
+put_alt_core_clk:
+	clk_put(mhcd->alt_core_clk);
+
+	return ret;
+}
+
+static int __devinit ehci_msm2_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct resource *res;
+	struct msm_hcd *mhcd;
+	const struct msm_usb_host_platform_data *pdata;
+	char pdev_name[PDEV_NAME_LEN];
+	int ret;
+
+	dev_dbg(&pdev->dev, "ehci_msm2 probe\n");
+
+	hcd = usb_create_hcd(&msm_hc2_driver, &pdev->dev,
+				dev_name(&pdev->dev));
+	if (!hcd) {
+		dev_err(&pdev->dev, "Unable to create HCD\n");
+		return  -ENOMEM;
+	}
+
+	hcd->irq = platform_get_irq(pdev, 0);
+	if (hcd->irq < 0) {
+		dev_err(&pdev->dev, "Unable to get IRQ resource\n");
+		ret = hcd->irq;
+		goto put_hcd;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Unable to get memory resource\n");
+		ret = -ENODEV;
+		goto put_hcd;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_size(res);
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto put_hcd;
+	}
+
+	mhcd = hcd_to_mhcd(hcd);
+	mhcd->dev = &pdev->dev;
+
+	snprintf(pdev_name, PDEV_NAME_LEN, "%s.%d", pdev->name, pdev->id);
+	mhcd->xo_handle = msm_xo_get(MSM_XO_TCXO_D0, pdev_name);
+	if (IS_ERR(mhcd->xo_handle)) {
+		dev_err(&pdev->dev, "%s not able to get the handle "
+			"to vote for TCXO D0 buffer\n", __func__);
+		ret = PTR_ERR(mhcd->xo_handle);
+		goto unmap;
+	}
+
+	ret = msm_xo_mode_vote(mhcd->xo_handle, MSM_XO_MODE_ON);
+	if (ret) {
+		dev_err(&pdev->dev, "%s failed to vote for TCXO "
+			"D0 buffer%d\n", __func__, ret);
+		goto free_xo_handle;
+	}
+
+	ret = msm_ehci_init_clocks(mhcd, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to initialize clocks\n");
+		ret = -ENODEV;
+		goto devote_xo_handle;
+	}
+
+	ret = msm_ehci_init_vddcx(mhcd, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to initialize VDDCX\n");
+		ret = -ENODEV;
+		goto deinit_clocks;
+	}
+
+	ret = msm_ehci_config_vddcx(mhcd, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "hsusb vddcx configuration failed\n");
+		goto deinit_vddcx;
+	}
+
+	ret = msm_ehci_ldo_init(mhcd, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "hsusb vreg configuration failed\n");
+		goto deinit_vddcx;
+	}
+
+	ret = msm_ehci_ldo_enable(mhcd, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "hsusb vreg enable failed\n");
+		goto deinit_ldo;
+	}
+
+	ret = msm_ehci_init_vbus(mhcd, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to get vbus\n");
+		goto disable_ldo;
+	}
+
+	ret = msm_hsusb_reset(mhcd);
+	if (ret) {
+		dev_err(&pdev->dev, "hsusb PHY initialization failed\n");
+		goto vbus_deinit;
+	}
+
+	ret = usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register HCD\n");
+		goto vbus_deinit;
+	}
+
+	pdata = mhcd->dev->platform_data;
+	if (pdata && (!pdata->dock_connect_irq ||
+				!irq_read_line(pdata->dock_connect_irq)))
+		msm_ehci_vbus_power(mhcd, 1);
+
+	device_init_wakeup(&pdev->dev, 1);
+	wake_lock_init(&mhcd->wlock, WAKE_LOCK_SUSPEND, dev_name(&pdev->dev));
+	wake_lock(&mhcd->wlock);
+	/*
+	 * This pdev->dev is assigned parent of root-hub by USB core,
+	 * hence, runtime framework automatically calls this driver's
+	 * runtime APIs based on root-hub's state.
+	 */
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+
+	return 0;
+
+vbus_deinit:
+	msm_ehci_init_vbus(mhcd, 0);
+disable_ldo:
+	msm_ehci_ldo_enable(mhcd, 0);
+deinit_ldo:
+	msm_ehci_ldo_init(mhcd, 0);
+deinit_vddcx:
+	msm_ehci_init_vddcx(mhcd, 0);
+deinit_clocks:
+	msm_ehci_init_clocks(mhcd, 0);
+devote_xo_handle:
+	msm_xo_mode_vote(mhcd->xo_handle, MSM_XO_MODE_OFF);
+free_xo_handle:
+	msm_xo_put(mhcd->xo_handle);
+unmap:
+	iounmap(hcd->regs);
+put_hcd:
+	usb_put_hcd(hcd);
+
+	return ret;
+}
+
+static int __devexit ehci_msm2_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct msm_hcd *mhcd = hcd_to_mhcd(hcd);
+
+	device_init_wakeup(&pdev->dev, 0);
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+
+	usb_remove_hcd(hcd);
+
+	msm_xo_put(mhcd->xo_handle);
+	msm_ehci_vbus_power(mhcd, 0);
+	msm_ehci_init_vbus(mhcd, 0);
+	msm_ehci_ldo_enable(mhcd, 0);
+	msm_ehci_ldo_init(mhcd, 0);
+	msm_ehci_init_vddcx(mhcd, 0);
+
+	msm_ehci_init_clocks(mhcd, 0);
+	wake_lock_destroy(&mhcd->wlock);
+	iounmap(hcd->regs);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int ehci_msm2_pm_suspend(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct msm_hcd *mhcd = hcd_to_mhcd(hcd);
+
+	dev_dbg(dev, "ehci-msm2 PM suspend\n");
+
+	if (device_may_wakeup(dev))
+		enable_irq_wake(hcd->irq);
+
+	return msm_ehci_suspend(mhcd);
+
+}
+
+static int ehci_msm2_pm_resume(struct device *dev)
+{
+	int ret;
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct msm_hcd *mhcd = hcd_to_mhcd(hcd);
+
+	dev_dbg(dev, "ehci-msm2 PM resume\n");
+
+	if (device_may_wakeup(dev))
+		disable_irq_wake(hcd->irq);
+
+	ret = msm_ehci_resume(mhcd);
+	if (ret)
+		return ret;
+
+	/* Bring the device to full powered state upon system resume */
+	pm_runtime_disable(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int ehci_msm2_runtime_idle(struct device *dev)
+{
+	dev_dbg(dev, "EHCI runtime idle\n");
+
+	return 0;
+}
+
+static int ehci_msm2_runtime_suspend(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct msm_hcd *mhcd = hcd_to_mhcd(hcd);
+
+	dev_dbg(dev, "EHCI runtime suspend\n");
+	return msm_ehci_suspend(mhcd);
+}
+
+static int ehci_msm2_runtime_resume(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct msm_hcd *mhcd = hcd_to_mhcd(hcd);
+
+	dev_dbg(dev, "EHCI runtime resume\n");
+	return msm_ehci_resume(mhcd);
+}
+#endif
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops ehci_msm2_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ehci_msm2_pm_suspend, ehci_msm2_pm_resume)
+	SET_RUNTIME_PM_OPS(ehci_msm2_runtime_suspend, ehci_msm2_runtime_resume,
+				ehci_msm2_runtime_idle)
+};
+#endif
+
+static struct platform_driver ehci_msm2_driver = {
+	.probe	= ehci_msm2_probe,
+	.remove	= __devexit_p(ehci_msm2_remove),
+	.driver = {
+		.name = "msm_ehci_host",
+#ifdef CONFIG_PM
+		.pm = &ehci_msm2_dev_pm_ops,
+#endif
+	},
+};
diff --git a/drivers/usb/host/ehci-msm72k.c b/drivers/usb/host/ehci-msm72k.c
new file mode 100644
index 0000000..d661e85
--- /dev/null
+++ b/drivers/usb/host/ehci-msm72k.c
@@ -0,0 +1,812 @@
+/* ehci-msm.c - HSUSB Host Controller Driver Implementation
+ *
+ * Copyright (c) 2008-2012, The Linux Foundation. All rights reserved.
+ *
+ * Partly derived from ehci-fsl.c and ehci-hcd.c
+ * Copyright (c) 2000-2004 by David Brownell
+ * Copyright (c) 2005 MontaVista Software
+ *
+ * All source code in this file is licensed under the following license except
+ * where indicated.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can find it at http://www.fsf.org
+ */
+
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+
+#include <mach/board.h>
+#include <mach/rpc_hsusb.h>
+#include <mach/msm_hsusb.h>
+#include <mach/msm_hsusb_hw.h>
+#include <mach/msm_otg.h>
+#include <mach/clk.h>
+#include <linux/wakelock.h>
+#include <linux/pm_runtime.h>
+
+#include <mach/msm72k_otg.h>
+
+#define MSM_USB_BASE (hcd->regs)
+
+struct msmusb_hcd {
+	struct ehci_hcd ehci;
+	struct clk *alt_core_clk;
+	struct clk *iface_clk;
+	unsigned in_lpm;
+	struct work_struct lpm_exit_work;
+	spinlock_t lock;
+	struct wake_lock wlock;
+	unsigned int clk_enabled;
+	struct msm_usb_host_platform_data *pdata;
+	unsigned running;
+	struct otg_transceiver *xceiv;
+	struct work_struct otg_work;
+	unsigned flags;
+	struct msm_otg_ops otg_ops;
+};
+
+static inline struct msmusb_hcd *hcd_to_mhcd(struct usb_hcd *hcd)
+{
+	return (struct msmusb_hcd *) (hcd->hcd_priv);
+}
+
+static inline struct usb_hcd *mhcd_to_hcd(struct msmusb_hcd *mhcd)
+{
+	return container_of((void *) mhcd, struct usb_hcd, hcd_priv);
+}
+
+static void msm_xusb_pm_qos_update(struct msmusb_hcd *mhcd, int vote)
+{
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+
+	/* if otg driver is available, it would take
+	 * care of voting for appropriate pclk source
+	 */
+	if (mhcd->xceiv)
+		return;
+
+	if (vote)
+		clk_prepare_enable(pdata->ebi1_clk);
+	else
+		clk_disable_unprepare(pdata->ebi1_clk);
+}
+
+static void msm_xusb_enable_clks(struct msmusb_hcd *mhcd)
+{
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+
+	if (mhcd->clk_enabled)
+		return;
+
+	switch (PHY_TYPE(pdata->phy_info)) {
+	case USB_PHY_INTEGRATED:
+		/* OTG driver takes care of clock management */
+		break;
+	case USB_PHY_SERIAL_PMIC:
+		clk_prepare_enable(mhcd->alt_core_clk);
+		clk_prepare_enable(mhcd->iface_clk);
+		break;
+	default:
+		pr_err("%s: undefined phy type ( %X )\n", __func__,
+						pdata->phy_info);
+		return;
+	}
+	mhcd->clk_enabled = 1;
+}
+
+static void msm_xusb_disable_clks(struct msmusb_hcd *mhcd)
+{
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+
+	if (!mhcd->clk_enabled)
+		return;
+
+	switch (PHY_TYPE(pdata->phy_info)) {
+	case USB_PHY_INTEGRATED:
+		/* OTG driver takes care of clock management */
+		break;
+	case USB_PHY_SERIAL_PMIC:
+		clk_disable_unprepare(mhcd->alt_core_clk);
+		clk_disable_unprepare(mhcd->iface_clk);
+		break;
+	default:
+		pr_err("%s: undefined phy type ( %X )\n", __func__,
+						pdata->phy_info);
+		return;
+	}
+	mhcd->clk_enabled = 0;
+
+}
+
+static int usb_wakeup_phy(struct usb_hcd *hcd)
+{
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+	int ret = -ENODEV;
+
+	switch (PHY_TYPE(pdata->phy_info)) {
+	case USB_PHY_INTEGRATED:
+		break;
+	case USB_PHY_SERIAL_PMIC:
+		ret = msm_fsusb_resume_phy();
+		break;
+	default:
+		pr_err("%s: undefined phy type ( %X ) \n", __func__,
+						pdata->phy_info);
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int usb_suspend_phy(struct usb_hcd *hcd)
+{
+	int ret = 0;
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+
+	switch (PHY_TYPE(pdata->phy_info)) {
+	case USB_PHY_INTEGRATED:
+		break;
+	case USB_PHY_SERIAL_PMIC:
+		ret = msm_fsusb_set_remote_wakeup();
+		ret = msm_fsusb_suspend_phy();
+		break;
+	default:
+		pr_err("%s: undefined phy type ( %X ) \n", __func__,
+						pdata->phy_info);
+		ret = -ENODEV;
+		break;
+	}
+
+	return ret;
+}
+
+static int usb_lpm_enter(struct usb_hcd *hcd)
+{
+	struct device *dev = container_of((void *)hcd, struct device,
+							platform_data);
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+
+	disable_irq(hcd->irq);
+	if (mhcd->in_lpm) {
+		pr_info("%s: already in lpm. nothing to do\n", __func__);
+		enable_irq(hcd->irq);
+		return 0;
+	}
+
+	if (HC_IS_RUNNING(hcd->state)) {
+		pr_info("%s: can't enter into lpm. controller is runnning\n",
+			__func__);
+		enable_irq(hcd->irq);
+		return -1;
+	}
+
+	pr_info("%s: lpm enter procedure started\n", __func__);
+
+	mhcd->in_lpm = 1;
+
+	if (usb_suspend_phy(hcd)) {
+		mhcd->in_lpm = 0;
+		enable_irq(hcd->irq);
+		pr_info("phy suspend failed\n");
+		pr_info("%s: lpm enter procedure end\n", __func__);
+		return -1;
+	}
+
+	msm_xusb_disable_clks(mhcd);
+
+	if (mhcd->xceiv && mhcd->xceiv->set_suspend)
+		mhcd->xceiv->set_suspend(mhcd->xceiv, 1);
+
+	if (device_may_wakeup(dev))
+		enable_irq_wake(hcd->irq);
+	enable_irq(hcd->irq);
+	pr_info("%s: lpm enter procedure end\n", __func__);
+	return 0;
+}
+#endif
+
+void usb_lpm_exit_w(struct work_struct *work)
+{
+	struct msmusb_hcd *mhcd = container_of((void *) work,
+			struct msmusb_hcd, lpm_exit_work);
+
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+
+	struct device *dev = container_of((void *)hcd, struct device,
+							platform_data);
+	msm_xusb_enable_clks(mhcd);
+
+
+	if (usb_wakeup_phy(hcd)) {
+		pr_err("fatal error: cannot bring phy out of lpm\n");
+		return;
+	}
+
+	/* If resume signalling finishes before lpm exit, PCD is not set in
+	 * USBSTS register. Drive resume signal to the downstream device now
+	 * so that EHCI can process the upcoming port change interrupt.*/
+
+	writel(readl(USB_PORTSC) | PORTSC_FPR, USB_PORTSC);
+
+	if (mhcd->xceiv && mhcd->xceiv->set_suspend)
+		mhcd->xceiv->set_suspend(mhcd->xceiv, 0);
+
+	if (device_may_wakeup(dev))
+		disable_irq_wake(hcd->irq);
+	enable_irq(hcd->irq);
+}
+
+static void usb_lpm_exit(struct usb_hcd *hcd)
+{
+	unsigned long flags;
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+
+	spin_lock_irqsave(&mhcd->lock, flags);
+	if (!mhcd->in_lpm) {
+		spin_unlock_irqrestore(&mhcd->lock, flags);
+		return;
+	}
+	mhcd->in_lpm = 0;
+	disable_irq_nosync(hcd->irq);
+	schedule_work(&mhcd->lpm_exit_work);
+	spin_unlock_irqrestore(&mhcd->lock, flags);
+}
+
+static irqreturn_t ehci_msm_irq(struct usb_hcd *hcd)
+{
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+	struct msm_otg *otg = container_of(mhcd->xceiv, struct msm_otg, otg);
+
+	/*
+	 * OTG scheduled a work to get Integrated PHY out of LPM,
+	 * WAIT till then */
+	if (PHY_TYPE(mhcd->pdata->phy_info) == USB_PHY_INTEGRATED)
+		if (atomic_read(&otg->in_lpm))
+			return IRQ_HANDLED;
+
+	return ehci_irq(hcd);
+}
+
+#ifdef CONFIG_PM
+
+static int ehci_msm_bus_suspend(struct usb_hcd *hcd)
+{
+	int ret;
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+	struct device *dev = hcd->self.controller;
+
+	ret = ehci_bus_suspend(hcd);
+	if (ret) {
+		pr_err("ehci_bus suspend faield\n");
+		return ret;
+	}
+	if (PHY_TYPE(mhcd->pdata->phy_info) == USB_PHY_INTEGRATED)
+		ret = otg_set_suspend(mhcd->xceiv, 1);
+	else
+		ret = usb_lpm_enter(hcd);
+
+	pm_runtime_put_noidle(dev);
+	pm_runtime_suspend(dev);
+	wake_unlock(&mhcd->wlock);
+	return ret;
+}
+
+static int ehci_msm_bus_resume(struct usb_hcd *hcd)
+{
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+	struct device *dev = hcd->self.controller;
+
+	wake_lock(&mhcd->wlock);
+	pm_runtime_get_noresume(dev);
+	pm_runtime_resume(dev);
+
+	if (PHY_TYPE(mhcd->pdata->phy_info) == USB_PHY_INTEGRATED) {
+		otg_set_suspend(mhcd->xceiv, 0);
+	} else { /* PMIC serial phy */
+		usb_lpm_exit(hcd);
+		if (cancel_work_sync(&(mhcd->lpm_exit_work)))
+			usb_lpm_exit_w(&mhcd->lpm_exit_work);
+	}
+
+	return ehci_bus_resume(hcd);
+
+}
+
+#else
+
+#define ehci_msm_bus_suspend NULL
+#define ehci_msm_bus_resume NULL
+
+#endif	/* CONFIG_PM */
+
+static int ehci_msm_reset(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	ehci->caps = USB_CAPLENGTH;
+	ehci->regs = USB_CAPLENGTH +
+		HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	/* cache the data to minimize the chip reads*/
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	hcd->has_tt = 1;
+	ehci->sbrn = HCD_USB2;
+
+	retval = ehci_reset(ehci);
+
+	/* SW workaround for USB stability issues*/
+	writel(0x0, USB_AHB_MODE);
+	writel(0x0, USB_AHB_BURST);
+
+	return retval;
+}
+
+#define PTS_VAL(x) (PHY_TYPE(x) == USB_PHY_SERIAL_PMIC) ? PORTSC_PTS_SERIAL : \
+							PORTSC_PTS_ULPI
+
+static int ehci_msm_run(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci  = hcd_to_ehci(hcd);
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+	int             retval = 0;
+	int     	port   = HCS_N_PORTS(ehci->hcs_params);
+	u32 __iomem     *reg_ptr;
+	u32             hcc_params;
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+
+	hcd->uses_new_polling = 1;
+	set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+
+	/* set hostmode */
+	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
+	ehci_writel(ehci, (USBMODE_VBUS | USBMODE_SDIS), reg_ptr);
+
+	/* port configuration - phy, port speed, port power, port enable */
+	while (port--)
+		ehci_writel(ehci, (PTS_VAL(pdata->phy_info) | PORT_POWER |
+				PORT_PE), &ehci->regs->port_status[port]);
+
+	ehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);
+	ehci_writel(ehci, (u32)ehci->async->qh_dma, &ehci->regs->async_next);
+
+	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
+	if (HCC_64BIT_ADDR(hcc_params))
+		ehci_writel(ehci, 0, &ehci->regs->segment);
+
+	ehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);
+	ehci->command |= CMD_RUN;
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	ehci_readl(ehci, &ehci->regs->command); /* unblock posted writes */
+
+	hcd->state = HC_STATE_RUNNING;
+
+	/*Enable appropriate Interrupts*/
+	ehci_writel(ehci, INTR_MASK, &ehci->regs->intr_enable);
+
+	return retval;
+}
+
+static struct hc_driver msm_hc_driver = {
+	.description		= hcd_name,
+	.product_desc 		= "Qualcomm On-Chip EHCI Host Controller",
+	.hcd_priv_size 		= sizeof(struct msmusb_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq 			= ehci_msm_irq,
+	.flags 			= HCD_USB2,
+
+	.reset 			= ehci_msm_reset,
+	.start 			= ehci_msm_run,
+
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+	.bus_suspend		= ehci_msm_bus_suspend,
+	.bus_resume		= ehci_msm_bus_resume,
+	.relinquish_port	= ehci_relinquish_port,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+};
+
+static void msm_hsusb_request_host(void *handle, int request)
+{
+	struct msmusb_hcd *mhcd = handle;
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+	struct msm_otg *otg = container_of(mhcd->xceiv, struct msm_otg, otg);
+#ifdef CONFIG_USB_OTG
+	struct usb_device *udev = hcd->self.root_hub;
+#endif
+	struct device *dev = hcd->self.controller;
+
+	switch (request) {
+#ifdef CONFIG_USB_OTG
+	case REQUEST_HNP_SUSPEND:
+		/* disable Root hub auto suspend. As hardware is configured
+		 * for peripheral mode, mark hardware is not available.
+		 */
+		if (PHY_TYPE(pdata->phy_info) == USB_PHY_INTEGRATED) {
+			pm_runtime_disable(&udev->dev);
+			/* Mark root hub as disconnected. This would
+			 * protect suspend/resume via sysfs.
+			 */
+			udev->state = USB_STATE_NOTATTACHED;
+			clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+			hcd->state = HC_STATE_HALT;
+			pm_runtime_put_noidle(dev);
+			pm_runtime_suspend(dev);
+		}
+		break;
+	case REQUEST_HNP_RESUME:
+		if (PHY_TYPE(pdata->phy_info) == USB_PHY_INTEGRATED) {
+			pm_runtime_get_noresume(dev);
+			pm_runtime_resume(dev);
+			disable_irq(hcd->irq);
+			ehci_msm_reset(hcd);
+			ehci_msm_run(hcd);
+			set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+			pm_runtime_enable(&udev->dev);
+			udev->state = USB_STATE_CONFIGURED;
+			enable_irq(hcd->irq);
+		}
+		break;
+#endif
+	case REQUEST_RESUME:
+		usb_hcd_resume_root_hub(hcd);
+		break;
+	case REQUEST_START:
+		if (mhcd->running)
+			break;
+		pm_runtime_get_noresume(dev);
+		pm_runtime_resume(dev);
+		wake_lock(&mhcd->wlock);
+		msm_xusb_pm_qos_update(mhcd, 1);
+		msm_xusb_enable_clks(mhcd);
+		if (PHY_TYPE(pdata->phy_info) == USB_PHY_INTEGRATED)
+			if (otg->set_clk)
+				otg->set_clk(mhcd->xceiv, 1);
+		if (pdata->vbus_power)
+			pdata->vbus_power(pdata->phy_info, 1);
+		if (pdata->config_gpio)
+			pdata->config_gpio(1);
+		usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);
+		mhcd->running = 1;
+		if (PHY_TYPE(pdata->phy_info) == USB_PHY_INTEGRATED)
+			if (otg->set_clk)
+				otg->set_clk(mhcd->xceiv, 0);
+		break;
+	case REQUEST_STOP:
+		if (!mhcd->running)
+			break;
+		mhcd->running = 0;
+		/* come out of lpm before deregistration */
+		if (PHY_TYPE(pdata->phy_info) == USB_PHY_SERIAL_PMIC) {
+			usb_lpm_exit(hcd);
+			if (cancel_work_sync(&(mhcd->lpm_exit_work)))
+				usb_lpm_exit_w(&mhcd->lpm_exit_work);
+		}
+		usb_remove_hcd(hcd);
+		if (pdata->config_gpio)
+			pdata->config_gpio(0);
+		if (pdata->vbus_power)
+			pdata->vbus_power(pdata->phy_info, 0);
+		msm_xusb_disable_clks(mhcd);
+		wake_lock_timeout(&mhcd->wlock, HZ/2);
+		msm_xusb_pm_qos_update(mhcd, 0);
+		pm_runtime_put_noidle(dev);
+		pm_runtime_suspend(dev);
+		break;
+	}
+}
+
+static void msm_hsusb_otg_work(struct work_struct *work)
+{
+	struct msmusb_hcd *mhcd;
+
+	mhcd = container_of(work, struct msmusb_hcd, otg_work);
+	msm_hsusb_request_host((void *)mhcd, mhcd->flags);
+}
+static void msm_hsusb_start_host(struct usb_bus *bus, int start)
+{
+	struct usb_hcd *hcd = bus_to_hcd(bus);
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+
+	mhcd->flags = start;
+	if (in_interrupt())
+		schedule_work(&mhcd->otg_work);
+	else
+		msm_hsusb_request_host((void *)mhcd, mhcd->flags);
+
+}
+
+static int msm_xusb_init_phy(struct msmusb_hcd *mhcd)
+{
+	int ret = -ENODEV;
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+
+	switch (PHY_TYPE(pdata->phy_info)) {
+	case USB_PHY_INTEGRATED:
+		ret = 0;
+	case USB_PHY_SERIAL_PMIC:
+		msm_xusb_enable_clks(mhcd);
+		writel(0, USB_USBINTR);
+		ret = msm_fsusb_rpc_init(&mhcd->otg_ops);
+		if (!ret)
+			msm_fsusb_init_phy();
+		msm_xusb_disable_clks(mhcd);
+		break;
+	default:
+		pr_err("%s: undefined phy type ( %X ) \n", __func__,
+						pdata->phy_info);
+	}
+
+	return ret;
+}
+
+static int msm_xusb_rpc_close(struct msmusb_hcd *mhcd)
+{
+	int retval = -ENODEV;
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+
+	switch (PHY_TYPE(pdata->phy_info)) {
+	case USB_PHY_INTEGRATED:
+		if (!mhcd->xceiv)
+			retval = msm_hsusb_rpc_close();
+		break;
+	case USB_PHY_SERIAL_PMIC:
+		retval = msm_fsusb_reset_phy();
+		msm_fsusb_rpc_deinit();
+		break;
+	default:
+		pr_err("%s: undefined phy type ( %X ) \n", __func__,
+						pdata->phy_info);
+	}
+	return retval;
+}
+
+static int msm_xusb_init_host(struct platform_device *pdev,
+			      struct msmusb_hcd *mhcd)
+{
+	int ret = 0;
+	struct msm_otg *otg;
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+
+	switch (PHY_TYPE(pdata->phy_info)) {
+	case USB_PHY_INTEGRATED:
+		msm_hsusb_rpc_connect();
+
+		if (pdata->vbus_init)
+			pdata->vbus_init(1);
+
+		/* VBUS might be present. Turn off vbus */
+		if (pdata->vbus_power)
+			pdata->vbus_power(pdata->phy_info, 0);
+
+		INIT_WORK(&mhcd->otg_work, msm_hsusb_otg_work);
+		mhcd->xceiv = otg_get_transceiver();
+		if (!mhcd->xceiv)
+			return -ENODEV;
+		otg = container_of(mhcd->xceiv, struct msm_otg, otg);
+		hcd->regs = otg->regs;
+		otg->start_host = msm_hsusb_start_host;
+
+		ret = otg_set_host(mhcd->xceiv, &hcd->self);
+		ehci->transceiver = mhcd->xceiv;
+		break;
+	case USB_PHY_SERIAL_PMIC:
+		hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+
+		if (!hcd->regs)
+			return -EFAULT;
+		/* get usb clocks */
+		mhcd->alt_core_clk = clk_get(&pdev->dev, "alt_core_clk");
+		if (IS_ERR(mhcd->alt_core_clk)) {
+			iounmap(hcd->regs);
+			return PTR_ERR(mhcd->alt_core_clk);
+		}
+
+		mhcd->iface_clk = clk_get(&pdev->dev, "iface_clk");
+		if (IS_ERR(mhcd->iface_clk)) {
+			iounmap(hcd->regs);
+			clk_put(mhcd->alt_core_clk);
+			return PTR_ERR(mhcd->iface_clk);
+		}
+		mhcd->otg_ops.request = msm_hsusb_request_host;
+		mhcd->otg_ops.handle = (void *) mhcd;
+		ret = msm_xusb_init_phy(mhcd);
+		if (ret < 0) {
+			iounmap(hcd->regs);
+			clk_put(mhcd->alt_core_clk);
+			clk_put(mhcd->iface_clk);
+		}
+		break;
+	default:
+		pr_err("phy type is bad\n");
+	}
+	return ret;
+}
+
+static int __devinit ehci_msm_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct resource *res;
+	struct msm_usb_host_platform_data *pdata;
+	int retval;
+	struct msmusb_hcd *mhcd;
+
+	hcd = usb_create_hcd(&msm_hc_driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd)
+		return  -ENOMEM;
+
+	hcd->irq = platform_get_irq(pdev, 0);
+	if (hcd->irq < 0) {
+		usb_put_hcd(hcd);
+		return hcd->irq;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		usb_put_hcd(hcd);
+		return -ENODEV;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_size(res);
+
+	mhcd = hcd_to_mhcd(hcd);
+	spin_lock_init(&mhcd->lock);
+	mhcd->in_lpm = 0;
+	mhcd->running = 0;
+	device_init_wakeup(&pdev->dev, 1);
+
+	pdata = pdev->dev.platform_data;
+	if (PHY_TYPE(pdata->phy_info) == USB_PHY_UNDEFINED) {
+		usb_put_hcd(hcd);
+		return -ENODEV;
+	}
+	hcd->power_budget = pdata->power_budget;
+	mhcd->pdata = pdata;
+	INIT_WORK(&mhcd->lpm_exit_work, usb_lpm_exit_w);
+
+	wake_lock_init(&mhcd->wlock, WAKE_LOCK_SUSPEND, dev_name(&pdev->dev));
+	pdata->ebi1_clk = clk_get(&pdev->dev, "core_clk");
+	if (IS_ERR(pdata->ebi1_clk))
+		pdata->ebi1_clk = NULL;
+	else
+		clk_set_rate(pdata->ebi1_clk, INT_MAX);
+
+	retval = msm_xusb_init_host(pdev, mhcd);
+
+	if (retval < 0) {
+		wake_lock_destroy(&mhcd->wlock);
+		usb_put_hcd(hcd);
+		clk_put(pdata->ebi1_clk);
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	return retval;
+}
+
+static void msm_xusb_uninit_host(struct msmusb_hcd *mhcd)
+{
+	struct usb_hcd *hcd = mhcd_to_hcd(mhcd);
+	struct msm_usb_host_platform_data *pdata = mhcd->pdata;
+
+	switch (PHY_TYPE(pdata->phy_info)) {
+	case USB_PHY_INTEGRATED:
+		if (pdata->vbus_init)
+			pdata->vbus_init(0);
+		hcd_to_ehci(hcd)->transceiver = NULL;
+		otg_set_host(mhcd->xceiv, NULL);
+		otg_put_transceiver(mhcd->xceiv);
+		cancel_work_sync(&mhcd->otg_work);
+		break;
+	case USB_PHY_SERIAL_PMIC:
+		iounmap(hcd->regs);
+		clk_put(mhcd->alt_core_clk);
+		clk_put(mhcd->iface_clk);
+		msm_fsusb_reset_phy();
+		msm_fsusb_rpc_deinit();
+		break;
+	default:
+		pr_err("phy type is bad\n");
+	}
+}
+static int __exit ehci_msm_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct msmusb_hcd *mhcd = hcd_to_mhcd(hcd);
+	struct msm_usb_host_platform_data *pdata;
+	int retval = 0;
+
+	pdata = pdev->dev.platform_data;
+	device_init_wakeup(&pdev->dev, 0);
+
+	msm_hsusb_request_host((void *)mhcd, REQUEST_STOP);
+	msm_xusb_uninit_host(mhcd);
+	retval = msm_xusb_rpc_close(mhcd);
+
+	wake_lock_destroy(&mhcd->wlock);
+	usb_put_hcd(hcd);
+	clk_put(pdata->ebi1_clk);
+
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+
+	return retval;
+}
+
+static int ehci_msm_runtime_suspend(struct device *dev)
+{
+	dev_dbg(dev, "pm_runtime: suspending...\n");
+	return 0;
+}
+
+static int ehci_msm_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "pm_runtime: resuming...\n");
+	return 0;
+}
+
+static int ehci_msm_runtime_idle(struct device *dev)
+{
+	dev_dbg(dev, "pm_runtime: idling...\n");
+	return 0;
+}
+
+static const struct dev_pm_ops ehci_msm_dev_pm_ops = {
+	.runtime_suspend = ehci_msm_runtime_suspend,
+	.runtime_resume = ehci_msm_runtime_resume,
+	.runtime_idle = ehci_msm_runtime_idle
+};
+
+static struct platform_driver ehci_msm_driver = {
+	.probe	= ehci_msm_probe,
+	.remove	= __exit_p(ehci_msm_remove),
+	.driver	= {.name = "msm_hsusb_host",
+		    .pm = &ehci_msm_dev_pm_ops, },
+};
diff --git a/drivers/usb/otg/msm_otg.c b/drivers/usb/otg/msm_otg.c
index b44b1ce..1c611e5 100644
--- a/drivers/usb/otg/msm_otg.c
+++ b/drivers/usb/otg/msm_otg.c
@@ -41,6 +41,7 @@
 #include <linux/mfd/pm8xxx/misc.h>
 #include <linux/mhl_8334.h>
 #include <linux/gpio.h>
+#include <linux/power_supply.h>
 
 #include <mach/scm.h>
 #include <mach/clk.h>
@@ -50,19 +51,30 @@
 #include <mach/rpm-regulator.h>
 
 /* SWISTART */
-/* Change based on 80-N5423-14 */
 #ifdef CONFIG_SIERRA
+
+/* Change based on 80-N5423-14 */
 #include <linux/gpio.h>
 #include <linux/irq.h>
-#include <linux/usb/msm_hsusb.h>
 
-static unsigned vddmin_gpio;
-static unsigned int msm_otg_sessvld_int;
-static bool msm_otg_connected = false;
+/* should be aligned with bsudefs.h */
+enum bspctype
+{
+	BSPC_NOT_SUPPORT = 0,
+	BSPC_XO_SUPPORT,
+	BSPC_VDDMIN_SUPPORT,
+	BSPC_SUSMEM_SUPPORT,
+	BSPC_SUPPORT_MAX
+};
 
-/* Based on case 1091889 */
-struct workqueue_struct *suspend_work_q = NULL;
-#endif
+static unsigned char otg_pc;
+static bool otg_vddmin_inited = 0;
+extern void msm9615_pm8xxx_gpio_mpp_init_vddmin(void);
+
+static void pm_suspend_w(struct work_struct *w);
+static DECLARE_DELAYED_WORK(pm_suspend_work, pm_suspend_w);
+
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 
 #define MSM_USB_BASE	(motg->regs)
@@ -831,6 +843,16 @@ static int msm_otg_set_suspend(struct usb_phy *phy, int suspend)
 			if (!(motg->caps & ALLOW_LPM_ON_DEV_SUSPEND))
 				break;
 			clear_bit(A_BUS_SUSPEND, &motg->inputs);
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+			/* pm_runtime_suspend(otg->dev) may fail with otg->dev.power.usage_count=2, so
+			 * in pm suspended state, sm_work should NOT be scheduled and resume must be done by
+			 * msm_otg_pm_resume. This handling is done throughout this file but missed here. */
+			if (atomic_read(&motg->pm_suspended))
+				motg->sm_work_pending = true;
+			else
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 			queue_work(system_nrt_wq, &motg->sm_work);
 			break;
 		default:
@@ -845,14 +867,12 @@ static int msm_otg_set_suspend(struct usb_phy *phy, int suspend)
 #ifdef CONFIG_SIERRA
 static void pm_suspend_w(struct work_struct *w)
 {
-	if(msm_get_usb_det() == 2)
-	{
-		pm_suspend(PM_SUSPEND_MEM);
-	}
+	struct msm_otg *motg = the_msm_otg;
+	if (atomic_read(&motg->pm_suspended))
+		return;
+	pm_suspend(PM_SUSPEND_MEM);
 }
-
-static DECLARE_WORK(suspend_work_fast, pm_suspend_w);
-#endif
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 
 #define PHY_SUSPEND_TIMEOUT_USEC	(500 * 1000)
@@ -967,30 +987,30 @@ static int msm_otg_suspend(struct msm_otg *motg)
 	 * PHY retention and collapse can not happen with VDP_SRC enabled.
 	 */
 /* SWISTART */
-/* Change based on 80-N5423-14 */
 #ifdef CONFIG_SIERRA
-	if (msm_get_usb_det() == 2)
+	if (otg_pc >= BSPC_VDDMIN_SUPPORT)
 	{
+		/* Change based on 80-N5423-14 */
 		if (motg->caps & ALLOW_PHY_RETENTION && !host_bus_suspend &&
-		/* !device_bus_suspend && */ !dcp)
+			/* !device_bus_suspend && */ !dcp)
 		{
+			/* Enabling MPP Pin (Set MPP to output the voltage output) */
+			if (device_bus_suspend && pdata->vdd_min_enable)
+				gpio_direction_output(pdata->vdd_min_enable, 1);
+
 			phy_ctrl_val = readl_relaxed(USB_PHY_CTRL);
 			if (!device_bus_suspend && motg->pdata->otg_control == OTG_PHY_CONTROL)
 				/* Enable PHY HV interrupts to wake MPM/Link */
 				phy_ctrl_val |=
 					(PHY_IDHV_INTEN | PHY_OTGSESSVLDHV_INTEN);
 
-			if (device_bus_suspend) {
-				gpio_direction_output(pdata->vdd_min_enable, 1);
-			}
-
 			writel_relaxed(phy_ctrl_val & ~PHY_RETEN, USB_PHY_CTRL);
 			motg->lpm_flags |= PHY_RETENTIONED;
 		}
 	}
 	else
 	{
-#endif
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 	if (motg->caps & ALLOW_PHY_RETENTION && !host_bus_suspend &&
 		!device_bus_suspend && !dcp) {
@@ -1009,10 +1029,9 @@ static int msm_otg_suspend(struct msm_otg *motg)
 		motg->lpm_flags |= PHY_RETENTIONED;
 	}
 /* SWISTART */
-/* Change based on 80-N5423-14 */
 #ifdef CONFIG_SIERRA
 	}
-#endif
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 
 	/* Ensure that above operation is completed before turning off clocks */
@@ -1074,12 +1093,20 @@ static int msm_otg_suspend(struct msm_otg *motg)
 	dev_info(phy->dev, "USB in low power mode\n");
 
 /* SWISTART */
-/* Based on case 1091889 */
 #ifdef CONFIG_SIERRA
-	if(msm_get_usb_det() == 2 && device_bus_suspend){
-		queue_work(suspend_work_q, &suspend_work_fast);
+	if (otg_pc >= BSPC_SUSMEM_SUPPORT && !host_bus_suspend && device_bus_suspend)
+	{
+		dev_info(phy->dev, "PM_SUSPEND_MEM start\n");
+		/* only perfrom pm_suspend_w if
+		 * calling from msm_otg_runtime_suspend but not from pm_suspend */
+		if (!atomic_read(&motg->pm_suspended))
+		{
+			dev_info(phy->dev, "PM_SUSPEND_MEM enter\n");
+			/* Based on case 1091889 */
+			queue_delayed_work(system_nrt_wq, &pm_suspend_work, 1);
+		}
 	}
-#endif
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 
 	return 0;
@@ -1098,22 +1125,15 @@ static int msm_otg_resume(struct msm_otg *motg)
 	if (!atomic_read(&motg->in_lpm))
 		return 0;
 
-	disable_irq(motg->irq);
-	wake_lock(&motg->wlock);
-
 /* SWISTART */
-/* Based on case 1091889 */
 #ifdef CONFIG_SIERRA
-	if (msm_get_usb_det() == 2)
-	{
-		if(work_pending(&suspend_work_fast))
-		{
-			cancel_work_sync(&suspend_work_fast);
-		}
-	}
-#endif
+	if (delayed_work_pending(&pm_suspend_work))
+		cancel_delayed_work(&pm_suspend_work);
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 
+	wake_lock(&motg->wlock);
+
 	/* Vote for TCXO when waking up the phy */
 	if (motg->lpm_flags & XO_SHUTDOWN) {
 		ret = msm_xo_mode_vote(motg->xo_handle, MSM_XO_MODE_ON);
@@ -1140,6 +1160,14 @@ static int msm_otg_resume(struct msm_otg *motg)
 	if (motg->lpm_flags & PHY_RETENTIONED) {
 		msm_hsusb_mhl_switch_enable(motg, 1);
 		msm_hsusb_config_vddcx(1);
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+		/* Change based on 80-N5423-14 */
+		/* Disabling MPP Pin (set the MPP as an input) */
+		if (pdata->vdd_min_enable)
+			gpio_direction_input(pdata->vdd_min_enable);
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
 		phy_ctrl_val = readl_relaxed(USB_PHY_CTRL);
 		phy_ctrl_val |= PHY_RETEN;
 		if (motg->pdata->otg_control == OTG_PHY_CONTROL)
@@ -1148,15 +1176,6 @@ static int msm_otg_resume(struct msm_otg *motg)
 				~(PHY_IDHV_INTEN | PHY_OTGSESSVLDHV_INTEN);
 		writel_relaxed(phy_ctrl_val, USB_PHY_CTRL);
 		motg->lpm_flags &= ~PHY_RETENTIONED;
-/* SWISTART */
-/* Change based on 80-N5423-14 */
-#ifdef CONFIG_SIERRA
-		if (msm_get_usb_det() == 2)
-		{
-			gpio_direction_input(pdata->vdd_min_enable);
-		}
-#endif
-/* SWISTOP */
 	}
 
 	temp = readl(USB_USBCMD);
@@ -2542,19 +2561,14 @@ static void msm_otg_sm_work(struct work_struct *w)
 					mod_timer(&motg->chg_check_timer,
 							CHG_RECHECK_DELAY);
 /* SWISTART */
-/* Change based on 80-N5423-14 */
 #ifdef CONFIG_SIERRA
-					if (msm_get_usb_det() == 2)
-					{
-						msm_mpm_set_pin_type(motg->pdata->mpm_otgsessvld_int, IRQ_TYPE_EDGE_FALLING);
-					}
-					else
+					/* Change based on 80-N5423-14 */
+					if (motg->pdata->otg_control == OTG_PHY_CONTROL && motg->pdata->mpm_otgsessvld_int)
 					{
-						/* usb_det is not ready at this time, so buffer the mpm_otgsessvld_int */
-						msm_otg_sessvld_int = motg->pdata->mpm_otgsessvld_int;
-						msm_otg_connected = true;
+						msm_mpm_set_pin_type(motg->pdata->mpm_otgsessvld_int,
+							otg_pc >= BSPC_VDDMIN_SUPPORT ? IRQ_TYPE_EDGE_FALLING : IRQ_TYPE_EDGE_RISING);
 					}
-#endif
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 					break;
 				default:
@@ -2584,19 +2598,11 @@ static void msm_otg_sm_work(struct work_struct *w)
 			msm_otg_notify_charger(motg, 0);
 			msm_otg_reset(otg->phy);
 /* SWISTART */
-/* Change based on 80-N5423-14 */
 #ifdef CONFIG_SIERRA
-			if (msm_get_usb_det() == 2)
-			{
+			/* Change based on 80-N5423-14 */
+			if (motg->pdata->otg_control == OTG_PHY_CONTROL && motg->pdata->mpm_otgsessvld_int)
 				msm_mpm_set_pin_type(motg->pdata->mpm_otgsessvld_int, IRQ_TYPE_EDGE_RISING);
-			}
-			else
-			{
-				/* usb_det is not ready at this time, so buffer the mpm_otgsessvld_int */
-				msm_otg_sessvld_int = motg->pdata->mpm_otgsessvld_int;
-				msm_otg_connected = false;
-			}
-#endif
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 			/*
 			 * There is a small window where ID interrupt
@@ -3076,9 +3082,7 @@ static void msm_otg_sm_work(struct work_struct *w)
 	if ((otg_state != otg->phy->state) || (charger_type != motg->chg_type)) {
 		dev_info(otg->phy->dev, "OTG state %s, charger_type %s\n", (otg_state != otg->phy->state)?"changed":"NOT changed",
 		(charger_type != motg->chg_type)?"changed":"NOT changed");
-		if (charger_type != motg->chg_type) {
-			charger_type = motg->chg_type;
-		}
+		charger_type = motg->chg_type;
 		kobject_uevent(&motg->phy.dev->kobj, KOBJ_CHANGE);
 	}
 #endif
@@ -3718,7 +3722,7 @@ static ssize_t show_chg_type(struct device *dev, struct device_attribute *attr,
 		return 0;
 	}
 	
-	n = scnprintf(buf, PAGE_SIZE, "%s", chg_to_string(motg->chg_type));
+	n = scnprintf(buf, PAGE_SIZE, "%s\n", chg_to_string(motg->chg_type));
 
 	return n;
 }
@@ -3737,12 +3741,77 @@ static ssize_t show_otg_state(struct device *dev, struct device_attribute *attr,
 		return 0;
 	}
 	
-	n = scnprintf(buf, PAGE_SIZE, "%s", otg_state_string(phy->state));
+	n = scnprintf(buf, PAGE_SIZE, "%s\n", otg_state_string(phy->state));
 
 	return n;
 }
 static DEVICE_ATTR(otg_state, S_IRUSR, show_otg_state, NULL);
 
+/* Config OTG power collapse mode.
+ * Note that R1 uses usb_det in usb/gadget/andriod.c, which is misleading.
+ */
+static ssize_t otg_pc_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", otg_pc);
+}
+static ssize_t otg_pc_store(struct device *dev,
+		struct device_attribute *attr, const char *buff, size_t size)
+{
+	struct msm_otg *motg = dev_get_drvdata(dev);
+	int pc_mode = 0;
+
+	sscanf(buff, "%d", &pc_mode);
+	pr_info("otg_pc = %d\n", pc_mode);
+
+	if ((pc_mode>=BSPC_NOT_SUPPORT && pc_mode<BSPC_SUPPORT_MAX) && otg_pc != pc_mode)
+	{
+		if (pc_mode >= BSPC_VDDMIN_SUPPORT)
+		{
+			if (!otg_vddmin_inited)
+			{
+				msm9615_pm8xxx_gpio_mpp_init_vddmin();
+				otg_vddmin_inited = 1;
+			}
+			/* Based on case 1091889 */
+			if (motg->pdata->otg_control == OTG_PHY_CONTROL && motg->pdata->mpm_otgsessvld_int)
+			{
+				bool vddmin_falling = (motg->phy.state == OTG_STATE_B_PERIPHERAL &&
+										motg->chg_state == USB_CHG_STATE_DETECTED &&
+										motg->chg_type == USB_SDP_CHARGER);
+				msm_mpm_set_pin_type(motg->pdata->mpm_otgsessvld_int,
+					vddmin_falling ? IRQ_TYPE_EDGE_FALLING : IRQ_TYPE_EDGE_RISING);
+			}
+		}
+		else
+		{
+			if (motg->pdata->otg_control == OTG_PHY_CONTROL && motg->pdata->mpm_otgsessvld_int)
+				msm_mpm_set_pin_type(motg->pdata->mpm_otgsessvld_int, IRQ_TYPE_EDGE_RISING);
+		}
+
+		if (pc_mode < BSPC_SUSMEM_SUPPORT)
+		{
+			if (delayed_work_pending(&pm_suspend_work))
+				cancel_delayed_work(&pm_suspend_work);
+		}
+
+		if (pc_mode == BSPC_NOT_SUPPORT)
+		{
+			motg->caps &= ~ALLOW_LPM_ON_DEV_SUSPEND;
+		}
+		else /* pc_mode = BSPC_XO_SUPPORT or BSPC_SUSMEM_SUPPORT or BSPC_VDDMIN_SUPPORT */
+		{
+			if (motg->pdata->enable_lpm_on_dev_suspend)
+				motg->caps |= ALLOW_LPM_ON_DEV_SUSPEND;
+		}
+		otg_pc = pc_mode;
+	}
+
+	return size;
+}
+static DEVICE_ATTR(otg_pc, S_IRUGO | S_IWUSR,
+		otg_pc_show, otg_pc_store);
+
 /**
  * msm_otg_sysfs_create_files: initializes the attribute interface
  * @dev: device
@@ -3757,13 +3826,16 @@ __maybe_unused static int msm_otg_sysfs_create_files(struct device *dev)
 		return -EINVAL;
 	/* Create sysfs to /sys/devices/platform/msm_otg/ */
 	retval = device_create_file(dev, &dev_attr_chg_type);
-	if (retval)
-		goto done;
+	if (retval==0)
 	retval = device_create_file(dev, &dev_attr_otg_state);
+	if (retval==0)
+		retval = device_create_file(dev, &dev_attr_otg_pc);
+
+	if (retval)
+		device_remove_file(dev, &dev_attr_otg_state);
 	if (retval)
 		device_remove_file(dev, &dev_attr_chg_type);
 
-done:
 	return retval;
 }
 
@@ -3781,7 +3853,8 @@ __maybe_unused static int msm_otg_sysfs_remove_files(struct device *dev)
 	device_remove_file(dev, &dev_attr_otg_state);
 	return 0;
 }
-#endif /* end of CONFIG_SIERRA */
+
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 
 #define MSM_OTG_CMD_ID		0x09
@@ -4242,9 +4315,19 @@ static int __init msm_otg_probe(struct platform_device *pdev)
 	if (ret)
 		dev_dbg(&pdev->dev, "mode sysfs file is"
 			"not available\n");
-#endif /* end of CONFIG_SIERRA */
+
+	otg_pc = BSPC_XO_SUPPORT;
+
+	if (motg->pdata->otg_control == OTG_PHY_CONTROL && motg->pdata->mpm_otgsessvld_int)
+		msm_mpm_set_pin_type(motg->pdata->mpm_otgsessvld_int, IRQ_TYPE_EDGE_RISING);
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 
+#if 0
+	if (motg->pdata->otg_control == OTG_PMIC_CONTROL)
+		pm8921_charger_register_vbus_sn(&msm_otg_set_vbus_state);
+#endif
+
 	if (motg->pdata->phy_type == SNPS_28NM_INTEGRATED_PHY) {
 		if (motg->pdata->otg_control == OTG_PMIC_CONTROL &&
 			(!(motg->pdata->mode == USB_OTG) ||
@@ -4260,22 +4343,6 @@ static int __init msm_otg_probe(struct platform_device *pdev)
 	if (motg->pdata->enable_lpm_on_dev_suspend)
 		motg->caps |= ALLOW_LPM_ON_DEV_SUSPEND;
 
-/* SWISTART */
-/* Change based on 80-N5423-14 */
-#ifdef CONFIG_SIERRA
-	if (msm_get_usb_det() == 2)
-	{
-		gpio_request(motg->pdata->vdd_min_enable, "VDD_MIN_GPIO"); 
-		gpio_direction_input(motg->pdata->vdd_min_enable); 
-	}
-	else
-	{
-		/* usb_det may be not ready at this time, so buffer the mpm_otgsessvld_int */
-		vddmin_gpio = motg->pdata->vdd_min_enable;
-	}
-#endif
-/* SWISTOP */
-
 	wake_lock(&motg->wlock);
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
@@ -4318,21 +4385,6 @@ static int __init msm_otg_probe(struct platform_device *pdev)
 	if (legacy_power_supply && pdata->otg_control == OTG_PMIC_CONTROL)
 		pm8921_charger_register_vbus_sn(&msm_otg_set_vbus_state);
 
-/* SWISTART */
-/* Based on case 1091889 */
-#ifdef CONFIG_SIERRA
-	if (msm_get_usb_det() == 2)
-	{
-		suspend_work_q = create_singlethread_workqueue("suspend_usb");
-		if (suspend_work_q == NULL) {
-			ret = -ENOMEM;
-			dev_err(&pdev->dev, "Unable to create PM suspend workqueue\n");
-			goto remove_phy;
-		}
-	}
-#endif
-/* SWISTOP */
-
 	return 0;
 
 remove_phy:
@@ -4377,31 +4429,6 @@ free_motg:
 	return ret;
 }
 
-/* SWISTART */
-/* Change based on 80-N5423-14 */
-#ifdef CONFIG_SIERRA
-void msm_otg_vddmin_init(void)
-{
-	gpio_request(vddmin_gpio, "VDD_MIN_GPIO"); 
-	gpio_direction_input(vddmin_gpio); 
-
-	/* Based on case 1091889 */
-	if (suspend_work_q == NULL)
-	{
-		suspend_work_q = create_singlethread_workqueue("suspend_usb");
-	}
-
-	if (msm_otg_connected)
-	{
-		msm_mpm_set_pin_type(msm_otg_sessvld_int, IRQ_TYPE_EDGE_FALLING);
-	}
-	else
-	{
-		msm_mpm_set_pin_type(msm_otg_sessvld_int, IRQ_TYPE_EDGE_RISING);
-	}
-}
-#endif
-/* SWISTOP */
 static int __devexit msm_otg_remove(struct platform_device *pdev)
 {
 	struct msm_otg *motg = platform_get_drvdata(pdev);
@@ -4421,35 +4448,12 @@ static int __devexit msm_otg_remove(struct platform_device *pdev)
 #ifdef CONFIG_SIERRA
 	/* Remove sysfs */
 	msm_otg_sysfs_remove_files(&pdev->dev);
-#endif /* end of CONFIG_SIERRA */
+#endif /* CONFIG_SIERRA */
 /* SWISTOP */
 	cancel_delayed_work_sync(&motg->chg_work);
 	cancel_delayed_work_sync(&motg->pmic_id_status_work);
-/* SWISTART */
-/* Based on case 1091889 */
-#ifdef CONFIG_SIERRA
-	if (msm_get_usb_det() < 2)
-	{
-#endif /* end of CONFIG_SIERRA */
-/* SWISTOP */
 	cancel_delayed_work_sync(&motg->suspend_work);
-/* SWISTART */
-/* Based on case 1091889 */
-#ifdef CONFIG_SIERRA
-	}
-#endif /* end of CONFIG_SIERRA */
-/* SWISTOP */
-
 	cancel_work_sync(&motg->sm_work);
-/* SWISTART */
-/* Based on case 1091889 */
-#ifdef CONFIG_SIERRA
-	if (msm_get_usb_det() == 2 && suspend_work_q != NULL)
-	{
-		destroy_workqueue(suspend_work_q);
-	}
-#endif /* end of CONFIG_SIERRA */
-/* SWISTOP */
 
 	pm_runtime_resume(&pdev->dev);
 
@@ -4551,6 +4555,14 @@ static int msm_otg_pm_suspend(struct device *dev)
 
 	dev_dbg(dev, "OTG PM suspend\n");
 
+/* SWISTART */
+#ifdef CONFIG_SIERRA
+	/* ensure any pending pm_suspend is cancelled */
+	if (delayed_work_pending(&pm_suspend_work))
+		cancel_delayed_work(&pm_suspend_work);
+#endif /* CONFIG_SIERRA */
+/* SWISTOP */
+
 	atomic_set(&motg->pm_suspended, 1);
 	ret = msm_otg_suspend(motg);
 	if (ret)
diff --git a/include/linux/sierra_bsuproto.h b/include/linux/sierra_bsuproto.h
index 4eb9202..6c2d716 100644
--- a/include/linux/sierra_bsuproto.h
+++ b/include/linux/sierra_bsuproto.h
@@ -20,5 +20,6 @@ extern enum bshwtype bsgethwtype(void);
 extern uint8_t bsgethwrev(void);
 extern uint32_t bsgetmanufacturingcode(void);
 extern bool bssupport(enum bsfeature feature);
+extern uint32_t bsreadboottoappflag(void);
 
 #endif
diff --git a/include/linux/usb/sierra_ududefs.h b/include/linux/usb/sierra_ududefs.h
index af6eff8..989c4de0 100755
--- a/include/linux/usb/sierra_ududefs.h
+++ b/include/linux/usb/sierra_ududefs.h
@@ -68,8 +68,8 @@ static const struct ud_usb_interface ud_interface_68A2[] = {
   {   16,       "audio"        },
   {   17,       "audio"        },
   {   18,       "audio"        },
-  {   19,       "ecm"          },
-  {   20,       "ecm"          },
+  {   19,       "cdc_ethernet" },
+  {   20,       "cdc_ethernet" },
 };
 
 static const struct ud_usb_interface ud_interface_68B1[] = {
diff --git a/sound/soc/msm/msm-pcm-host-voice.c b/sound/soc/msm/msm-pcm-host-voice.c
index e908a0e..fb4c825 100755
--- a/sound/soc/msm/msm-pcm-host-voice.c
+++ b/sound/soc/msm/msm-pcm-host-voice.c
@@ -941,7 +941,8 @@ static int msm_pcm_playback_copy(struct snd_pcm_substream *substream, int a,
 						struct hpcm_buf_node, list);
 			list_del(&buf_node->list);
 			spin_unlock_irqrestore(&dai_data->dsp_lock, dsp_flags);
-			ret = copy_from_user(&buf_node->frame, buf, count);
+			ret = copy_from_user(&buf_node->frame.voc_pkt,
+					     buf, count);
 			buf_node->frame.len = count;
 			spin_lock_irqsave(&dai_data->dsp_lock, dsp_flags);
 			list_add_tail(&buf_node->list, &dai_data->filled_queue);
@@ -986,7 +987,9 @@ static int msm_pcm_capture_copy(struct snd_pcm_substream *substream,
 					struct hpcm_buf_node, list);
 			list_del(&buf_node->list);
 			spin_unlock_irqrestore(&dai_data->dsp_lock, dsp_flags);
-			ret = copy_to_user(buf, &buf_node->frame, count);
+			ret = copy_to_user(buf,
+					   &buf_node->frame.voc_pkt,
+					   count);
 			if (ret) {
 				pr_err("%s: Copy to user retuned %d\n",
 					__func__, ret);
-- 
1.7.5.4

