From f1660920179a59c459d14e9e4db2cd008a7e8917 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Thu, 11 Apr 2013 16:44:51 +0800
Subject: [PATCH 51/66] msm_serial_hs_lite: add break signal support

break signal is used by sysrq, enable it here

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 drivers/tty/serial/msm_serial_hs_lite.c |   27 ++++++++++++++++++++-------
 1 files changed, 20 insertions(+), 7 deletions(-)

diff --git a/drivers/tty/serial/msm_serial_hs_lite.c b/drivers/tty/serial/msm_serial_hs_lite.c
index 7aa14de..86c9048 100644
--- a/drivers/tty/serial/msm_serial_hs_lite.c
+++ b/drivers/tty/serial/msm_serial_hs_lite.c
@@ -568,11 +568,7 @@ static void handle_rx(struct uart_port *port, unsigned int misr)
 			break;
 		}
 		c = msm_hsl_read(port, regmap[vid][UARTDM_RF]);
-		if (sr & UARTDM_SR_RX_BREAK_BMSK) {
-			port->icount.brk++;
-			if (uart_handle_break(port))
-				continue;
-		} else if (sr & UARTDM_SR_PAR_FRAME_BMSK) {
+		if (sr & UARTDM_SR_PAR_FRAME_BMSK) {
 			port->icount.frame++;
 		} else {
 			port->icount.rx++;
@@ -586,7 +582,7 @@ static void handle_rx(struct uart_port *port, unsigned int misr)
 			flag = TTY_FRAME;
 
 		/* TODO: handle sysrq */
-		/* if (!uart_handle_sysrq_char(port, c)) */
+		if (!uart_handle_sysrq_char(port, c))
 		tty_insert_flip_string(tty, (char *) &c,
 				       (count > 4) ? 4 : count);
 		count -= 4;
@@ -691,6 +687,7 @@ static irqreturn_t msm_hsl_irq(int irq, void *dev_id)
 	unsigned int vid;
 	unsigned int misr;
 	unsigned long flags;
+	int sr;
 
 	spin_lock_irqsave(&port->lock, flags);
 	vid = msm_hsl_port->ver_id;
@@ -698,6 +695,22 @@ static irqreturn_t msm_hsl_irq(int irq, void *dev_id)
 	/* disable interrupt */
 	msm_hsl_write(port, 0, regmap[vid][UARTDM_IMR]);
 
+	if (misr & UARTDM_ISR_RXBREAK_BMSK){
+		sr = msm_hsl_read(port, regmap[vid][UARTDM_SR]);
+		/* it is weird that two interrupts are triggered when
+		   issue a break signal, and the test result shows bit
+		   9 of UARTDM_SR can be used to distiguish the two
+		   interrupts
+		 */
+		if (sr & 0x100) {
+			port->icount.brk++;
+			uart_handle_break(port);
+		}
+
+		msm_hsl_write(port, RESET_BREAK_INT,
+					regmap[vid][UARTDM_CR]);
+	}
+
 	if (misr & (UARTDM_ISR_RXSTALE_BMSK | UARTDM_ISR_RXLEV_BMSK)) {
 		handle_rx(port, misr);
 		if (misr & (UARTDM_ISR_RXSTALE_BMSK))
@@ -935,7 +948,7 @@ static void msm_hsl_set_baud_rate(struct uart_port *port,
 	msm_hsl_write(port, RESET_STALE_INT, regmap[vid][UARTDM_CR]);
 	/* turn on RX and CTS interrupts */
 	msm_hsl_port->imr = UARTDM_ISR_RXSTALE_BMSK
-		| UARTDM_ISR_DELTA_CTS_BMSK | UARTDM_ISR_RXLEV_BMSK;
+		| UARTDM_ISR_DELTA_CTS_BMSK | UARTDM_ISR_RXLEV_BMSK | UARTDM_ISR_RXBREAK_BMSK;
 	msm_hsl_write(port, msm_hsl_port->imr, regmap[vid][UARTDM_IMR]);
 	msm_hsl_write(port, 6500, regmap[vid][UARTDM_DMRX]);
 	msm_hsl_write(port, STALE_EVENT_ENABLE, regmap[vid][UARTDM_CR]);
-- 
1.7.5.4

