From 92b0561c021d6c4202a15017bdb5887bea5a1990 Mon Sep 17 00:00:00 2001
From: Aaron Ma <pengyu.ma@windriver.com>
Date: Mon, 17 Dec 2012 18:56:24 +0800
Subject: [PATCH 43/66] drivers: gpio: Add gpio pullup/pulldown support.

Add API in gpiolib to use sysfs;
Add setting gpio pullup/pulldown in msm gpio.

Signed-off-by: Aaron Ma <pengyu.ma@windriver.com>
Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 arch/arm/mach-msm/gpio-v2.c |   26 ++++++
 drivers/gpio/gpiolib.c      |  182 +++++++++++++++++++++++++++++++++++++++++++
 include/asm-generic/gpio.h  |    7 ++
 include/linux/gpio.h        |   10 +++
 4 files changed, 225 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-msm/gpio-v2.c b/arch/arm/mach-msm/gpio-v2.c
index 3b64669..5013649 100644
--- a/arch/arm/mach-msm/gpio-v2.c
+++ b/arch/arm/mach-msm/gpio-v2.c
@@ -227,6 +227,30 @@ static int msm_gpio_direction_output(struct gpio_chip *chip,
 	return 0;
 }
 
+static int msm_gpio_pull_up(struct gpio_chip *chip, unsigned offset)
+{
+        unsigned long irq_flags;
+
+        spin_lock_irqsave(&tlmm_lock, irq_flags);
+        gpio_tlmm_config(GPIO_CFG(offset, 0, GPIO_CFG_INPUT, 
+                GPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+        mb();
+        spin_unlock_irqrestore(&tlmm_lock, irq_flags);
+        return 0;
+}
+
+static int msm_gpio_pull_down(struct gpio_chip *chip, unsigned offset)
+{
+        unsigned long irq_flags;
+
+        spin_lock_irqsave(&tlmm_lock, irq_flags);
+        gpio_tlmm_config(GPIO_CFG(offset, 0, GPIO_CFG_INPUT, 
+                GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+	mb();
+        spin_unlock_irqrestore(&tlmm_lock, irq_flags);
+        return 0;
+}
+
 #ifdef CONFIG_OF
 static int msm_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 {
@@ -270,6 +294,8 @@ static struct msm_gpio_dev msm_gpio = {
 		.ngpio            = NR_MSM_GPIOS,
 		.direction_input  = msm_gpio_direction_input,
 		.direction_output = msm_gpio_direction_output,
+		.pull_up          = msm_gpio_pull_up,
+		.pull_down        = msm_gpio_pull_down,
 		.get              = msm_gpio_get,
 		.set              = msm_gpio_set,
 		.to_irq           = msm_gpio_to_irq,
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 112c16e..af17cbf 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -60,6 +60,7 @@ struct gpio_desc {
 #define FLAG_ACTIVE_LOW	7	/* sysfs value has active low */
 #define FLAG_OPEN_DRAIN	8	/* Gpio is open drain type */
 #define FLAG_OPEN_SOURCE 9	/* Gpio is open source type */
+#define FLAG_IS_UP	10
 
 #define ID_SHIFT	16	/* add new flags before this one */
 
@@ -265,6 +266,50 @@ static ssize_t gpio_direction_store(struct device *dev,
 static /* const */ DEVICE_ATTR(direction, 0644,
 		gpio_direction_show, gpio_direction_store);
 
+static ssize_t gpio_pull_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	const struct gpio_desc	*desc = dev_get_drvdata(dev);
+	ssize_t			status;
+
+	mutex_lock(&sysfs_lock);
+
+	if (!test_bit(FLAG_EXPORT, &desc->flags))
+		status = -EIO;
+	else
+		status = sprintf(buf, "%s\n",
+			test_bit(FLAG_IS_UP, &desc->flags)
+				? "up" : "down");
+
+	mutex_unlock(&sysfs_lock);
+	return status;
+}
+
+static ssize_t gpio_pull_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	const struct gpio_desc	*desc = dev_get_drvdata(dev);
+	unsigned		gpio = desc - gpio_desc;
+	ssize_t			status;
+
+	mutex_lock(&sysfs_lock);
+
+	if (!test_bit(FLAG_EXPORT, &desc->flags))
+		status = -EIO;
+	else if (sysfs_streq(buf, "up"))
+		status = gpio_pull_up(gpio);
+	else if (sysfs_streq(buf, "down"))
+		status = gpio_pull_down(gpio);
+	else
+		status = -EINVAL;
+
+	mutex_unlock(&sysfs_lock);
+	return status ? : size;
+}
+
+static /* const */ DEVICE_ATTR(pull, 0644,
+		gpio_pull_show, gpio_pull_store);
+
 static ssize_t gpio_value_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -548,6 +593,7 @@ static const DEVICE_ATTR(active_low, 0644,
 static const struct attribute *gpio_attrs[] = {
 	&dev_attr_value.attr,
 	&dev_attr_active_low.attr,
+	&dev_attr_pull.attr,
 	NULL,
 };
 
@@ -1504,6 +1550,142 @@ fail:
 }
 EXPORT_SYMBOL_GPL(gpio_direction_output);
 
+int gpio_pull_up(unsigned gpio)
+{
+	unsigned long		flags;
+	struct gpio_chip	*chip;
+	struct gpio_desc	*desc = &gpio_desc[gpio];
+	int			status = -EINVAL;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	if (!gpio_is_valid(gpio)) {
+		pr_debug("%s: gpio-%d invalid\n",
+                        __func__, gpio);
+		goto fail;
+	}
+	chip = desc->chip;
+	if (!chip)
+		pr_debug("%s: gpio-%d chip NULL\n",
+                        __func__, gpio);
+	if (!chip->get)
+                pr_debug("%s: gpio-%d chip->get NULL\n",
+                        __func__, gpio);
+	if (!chip->pull_up)
+                pr_debug("%s: gpio-%d chip->pull_up NULL\n",
+                        __func__, gpio);
+	if (!chip || !chip->get || !chip->pull_up)
+		goto fail;
+	gpio -= chip->base;
+	if (gpio >= chip->ngpio) {
+		pr_debug("%s: gpio-%d gpio error ngpio %d\n",
+                        __func__, gpio, chip->ngpio);
+		goto fail;
+	}
+	status = gpio_ensure_requested(desc, gpio);
+	if (status < 0) {
+		pr_debug("%s: gpio-%d gpio_ensure_requested %d\n",
+                        __func__, gpio, status);
+		goto fail;
+	}
+
+	/* now we know the gpio is valid and chip won't vanish */
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	might_sleep_if(chip->can_sleep);
+
+	if (status) {
+		status = chip->request(chip, gpio);
+		if (status < 0) {
+			pr_debug("GPIO-%d: chip request fail, %d\n",
+				chip->base + gpio, status);
+			/* and it's not available to anyone else ...
+			 * gpio_request() is the fully clean solution.
+			 */
+			goto lose;
+		}
+	}
+
+	status = chip->pull_up(chip, gpio);
+	if (status == 0)
+		set_bit(FLAG_IS_UP, &desc->flags);
+
+	trace_gpio_direction(chip->base + gpio, 1, status);
+lose:
+	return status;
+fail:
+	spin_unlock_irqrestore(&gpio_lock, flags);
+	if (status)
+		pr_debug("%s: gpio-%d status %d\n",
+			__func__, gpio, status);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpio_pull_up);
+
+int gpio_pull_down(unsigned gpio)
+{
+	unsigned long		flags;
+	struct gpio_chip	*chip;
+	struct gpio_desc	*desc = &gpio_desc[gpio];
+	int			status = -EINVAL;
+
+	/* Open drain pin should not be driven to 1 */
+/*	if (value && test_bit(FLAG_OPEN_DRAIN,  &desc->flags))
+		return gpio_direction_input(gpio);
+*/
+	/* Open source pin should not be driven to 0 */
+/*	if (!value && test_bit(FLAG_OPEN_SOURCE,  &desc->flags))
+		return gpio_direction_input(gpio);
+*/
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	if (!gpio_is_valid(gpio))
+		goto fail;
+	chip = desc->chip;
+	if (!chip || !chip->set || !chip->pull_down)
+		goto fail;
+	gpio -= chip->base;
+	if (gpio >= chip->ngpio)
+		goto fail;
+	status = gpio_ensure_requested(desc, gpio);
+	if (status < 0)
+		goto fail;
+
+	/* now we know the gpio is valid and chip won't vanish */
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	might_sleep_if(chip->can_sleep);
+
+	if (status) {
+		status = chip->request(chip, gpio);
+		if (status < 0) {
+			pr_debug("GPIO-%d: chip request fail, %d\n",
+				chip->base + gpio, status);
+			/* and it's not available to anyone else ...
+			 * gpio_request() is the fully clean solution.
+			 */
+			goto lose;
+		}
+	}
+
+	status = chip->pull_down(chip, gpio);
+	if (status == 0)
+		clear_bit(FLAG_IS_UP, &desc->flags);
+//	trace_gpio_value(chip->base + gpio, 0, value);
+	trace_gpio_direction(chip->base + gpio, 0, status);
+lose:
+	return status;
+fail:
+	spin_unlock_irqrestore(&gpio_lock, flags);
+	if (status)
+		pr_debug("%s: gpio-%d status %d\n",
+			__func__, gpio, status);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpio_pull_down);
+
 /**
  * gpio_set_debounce - sets @debounce time for a @gpio
  * @gpio: the gpio to set debounce time
diff --git a/include/asm-generic/gpio.h b/include/asm-generic/gpio.h
index 5f52690..ea978f8 100644
--- a/include/asm-generic/gpio.h
+++ b/include/asm-generic/gpio.h
@@ -105,6 +105,10 @@ struct gpio_chip {
 						unsigned offset);
 	int			(*direction_output)(struct gpio_chip *chip,
 						unsigned offset, int value);
+	int			(*pull_up)(struct gpio_chip *chip,
+                                                unsigned offset);
+	int                     (*pull_down)(struct gpio_chip *chip,
+                                                unsigned offset);
 	int			(*set_debounce)(struct gpio_chip *chip,
 						unsigned offset, unsigned debounce);
 
@@ -156,6 +160,9 @@ extern void gpio_free(unsigned gpio);
 extern int gpio_direction_input(unsigned gpio);
 extern int gpio_direction_output(unsigned gpio, int value);
 
+extern int gpio_pull_up(unsigned gpio);
+extern int gpio_pull_down(unsigned gpio);
+
 extern int gpio_set_debounce(unsigned gpio, unsigned debounce);
 
 extern int gpio_get_value_cansleep(unsigned gpio);
diff --git a/include/linux/gpio.h b/include/linux/gpio.h
index 6155ecf..587f719 100644
--- a/include/linux/gpio.h
+++ b/include/linux/gpio.h
@@ -92,6 +92,16 @@ static inline int gpio_direction_output(unsigned gpio, int value)
 	return -ENOSYS;
 }
 
+static inline int gpio_pull_up(unsigned gpio)
+{
+        return -ENOSYS;
+}
+
+static inline int gpio_pull_down(unsigned gpio)
+{
+        return -ENOSYS;
+}
+
 static inline int gpio_set_debounce(unsigned gpio, unsigned debounce)
 {
 	return -ENOSYS;
-- 
1.7.5.4

