From e9e41275768b93b936d31f4d0197b20d93f5f780 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Wed, 16 Jan 2013 15:27:37 +0800
Subject: [PATCH 59/70] msm serial: Add lock field in msm_hsl_port

msm_hsl_irq takes port->lock which leads to a recursive
spinlock calls if low_latency==1 or CONFIG_PREEMPT_RT_FULL=y:
  msm_hsl_irq
    spin_lock_irqsave(&port->lock, flags);
    handle_rx(port, misr);
      flush_to_ldisc
        disc->ops->receive_buf(tty, char_buf)
        n_tty_receive_buf
          tty->ops->flush_chars()
          uart_flush_chars
            uart_start
              spin_lock_irqsave(&port->lock) <--- already hold this lock

Avoid this by using a dedicated lock to protect the msm_hsl_port, and
this fix takes upstream commit
2588aba002d14e938c2f56d299ecf3e7ce1302a5
as reference

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 drivers/tty/serial/msm_serial_hs_lite.c |   32 ++++++++++++++++--------------
 1 files changed, 17 insertions(+), 15 deletions(-)

diff --git a/drivers/tty/serial/msm_serial_hs_lite.c b/drivers/tty/serial/msm_serial_hs_lite.c
index 1eeb215..02213c1 100644
--- a/drivers/tty/serial/msm_serial_hs_lite.c
+++ b/drivers/tty/serial/msm_serial_hs_lite.c
@@ -96,6 +96,7 @@ struct msm_hsl_port {
 	struct msm_bus_scale_pdata *bus_scale_table;
 	unsigned int		tx_fifothreshold;/* tx fifo threshold */
 	unsigned int		rx_fifothreshold;/* rx fifo threshold */
+	spinlock_t		lock;
 };
 
 #define UARTDM_VERSION_11_13	0
@@ -428,17 +429,17 @@ static int msm_hsl_loopback_enable_set(void *data, u64 val)
 
 	vid = msm_hsl_port->ver_id;
 	if (val) {
-		spin_lock_irqsave(&port->lock, flags);
+		spin_lock_irqsave(&msm_hsl_port->lock, flags);
 		ret = msm_hsl_read(port, regmap[vid][UARTDM_MR2]);
 		ret |= UARTDM_MR2_LOOP_MODE_BMSK;
 		msm_hsl_write(port, ret, regmap[vid][UARTDM_MR2]);
-		spin_unlock_irqrestore(&port->lock, flags);
+		spin_unlock_irqrestore(&msm_hsl_port->lock, flags);
 	} else {
-		spin_lock_irqsave(&port->lock, flags);
+		spin_lock_irqsave(&msm_hsl_port->lock, flags);
 		ret = msm_hsl_read(port, regmap[vid][UARTDM_MR2]);
 		ret &= ~UARTDM_MR2_LOOP_MODE_BMSK;
 		msm_hsl_write(port, ret, regmap[vid][UARTDM_MR2]);
-		spin_unlock_irqrestore(&port->lock, flags);
+		spin_unlock_irqrestore(&msm_hsl_port->lock, flags);
 	}
 
 	clk_en(port, 0);
@@ -460,9 +461,9 @@ static int msm_hsl_loopback_enable_get(void *data, u64 *val)
 		return -EINVAL;
 	}
 
-	spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&msm_hsl_port->lock, flags);
 	ret = msm_hsl_read(port, regmap[msm_hsl_port->ver_id][UARTDM_MR2]);
-	spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&msm_hsl_port->lock, flags);
 	clk_en(port, 0);
 
 	*val = (ret & UARTDM_MR2_LOOP_MODE_BMSK) ? 1 : 0;
@@ -691,7 +692,7 @@ static irqreturn_t msm_hsl_irq(int irq, void *dev_id)
 	unsigned long flags;
 	int sr;
 
-	spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&msm_hsl_port->lock, flags);
 	vid = msm_hsl_port->ver_id;
 	misr = msm_hsl_read(port, regmap[vid][UARTDM_MISR]);
 	/* disable interrupt */
@@ -729,7 +730,7 @@ static irqreturn_t msm_hsl_irq(int irq, void *dev_id)
 
 	/* restore interrupt */
 	msm_hsl_write(port, msm_hsl_port->imr, regmap[vid][UARTDM_IMR]);
-	spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&msm_hsl_port->lock, flags);
 
 	return IRQ_HANDLED;
 }
@@ -894,7 +895,7 @@ static void msm_hsl_put_poll_char(struct uart_port *port,
 	/*
 	 *	First save the ISR then disable the interrupts
 	 */
-	spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&msm_hsl_port->lock, flags);
         vid = msm_hsl_port->ver_id;
 
         /* disable interrupt */
@@ -921,7 +922,7 @@ static void msm_hsl_put_poll_char(struct uart_port *port,
 	wait_for_xmitr(port);
 	/* restore interrupt */
         msm_hsl_write(port, msm_hsl_port->imr, regmap[vid][UARTDM_IMR]);
-        spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&msm_hsl_port->lock, flags);
 }
 
 #endif /* CONFIG_CONSOLE_POLL */
@@ -1130,7 +1131,7 @@ static int msm_hsl_startup(struct uart_port *port)
 	else
 		rfr_level = port->fifosize;
 
-	spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&msm_hsl_port->lock, flags);
 
 	vid = msm_hsl_port->ver_id;
 	/* set automatic RFR level */
@@ -1140,7 +1141,7 @@ static int msm_hsl_startup(struct uart_port *port)
 	data |= UARTDM_MR1_AUTO_RFR_LEVEL1_BMSK & (rfr_level << 2);
 	data |= UARTDM_MR1_AUTO_RFR_LEVEL0_BMSK & rfr_level;
 	msm_hsl_write(port, data, regmap[vid][UARTDM_MR1]);
-	spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&msm_hsl_port->lock, flags);
 
 	ret = request_irq(port->irq, msm_hsl_irq, IRQF_TRIGGER_HIGH,
 			  msm_hsl_port->name, port);
@@ -1575,16 +1576,16 @@ static void msm_hsl_console_write(struct console *co, const char *s,
 
 	/* not pretty, but we can end up here via various convoluted paths */
 	if (port->sysrq || oops_in_progress)
-		locked = spin_trylock(&port->lock);
+		locked = spin_trylock(&msm_hsl_port->lock);
 	else {
 		locked = 1;
-		spin_lock(&port->lock);
+		spin_lock(&msm_hsl_port->lock);
 	}
 	msm_hsl_write(port, 0, regmap[vid][UARTDM_IMR]);
 	uart_console_write(port, s, count, msm_hsl_console_putchar);
 	msm_hsl_write(port, msm_hsl_port->imr, regmap[vid][UARTDM_IMR]);
 	if (locked == 1)
-		spin_unlock(&port->lock);
+		spin_unlock(&msm_hsl_port->lock);
 }
 
 static int msm_hsl_console_setup(struct console *co, char *options)
@@ -1978,6 +1979,7 @@ static int __devinit msm_serial_hsl_probe(struct platform_device *pdev)
 	port->dev = &pdev->dev;
 	port->uartclk = 7372800;
 	msm_hsl_port = UART_TO_MSM(port);
+	spin_lock_init(&msm_hsl_port->lock);
 
 	msm_hsl_port->clk = clk_get(&pdev->dev, "core_clk");
 	if (unlikely(IS_ERR(msm_hsl_port->clk))) {
-- 
1.7.5.4

