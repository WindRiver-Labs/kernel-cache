From e31abc0da966a647a09f26de473a2f2750609459 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Thu, 29 Aug 2013 17:11:20 +0800
Subject: [PATCH 35/70] regulator: add MSM GPIO regulator support

Extracted from git tree
git://codeaurora.org/quic/le/kernel/msm msm-3.4
And the commit ecff1cedf43b982be12f118318191a2c6e2eeea1
in msm-3.4 is the end point when created this patch.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 drivers/regulator/Kconfig                    |    9 +
 drivers/regulator/Makefile                   |    1 +
 drivers/regulator/msm-gpio-regulator.c       |  224 ++++++++++++++++++++++++++
 include/linux/regulator/msm-gpio-regulator.h |   37 +++++
 4 files changed, 271 insertions(+), 0 deletions(-)
 create mode 100644 drivers/regulator/msm-gpio-regulator.c
 create mode 100644 include/linux/regulator/msm-gpio-regulator.h

diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 0ad289b..ed07c07 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -73,6 +73,15 @@ config REGULATOR_PM8XXX
 	  regulators.  They also provide negative charge pumps and voltage
 	  switches.
 
+config REGULATOR_MSM_GPIO
+	tristate "MSM GPIO regulator"
+	depends on GPIOLIB
+	help
+	  This driver provides a regulator wrapper around a GPIO pin that is set
+	  to output.  It is intended to be used for GPIO pins that provide the
+	  enable signal to a physical regulator.  The GPIO enable signal can
+	  be configured to be active high (default) or active low.
+
 config REGULATOR_GPIO
 	tristate "GPIO regulator support"
 	depends on GENERIC_GPIO
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 9af04fb..1c6d3e6 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_REGULATOR_USERSPACE_CONSUMER) += userspace-consumer.o
 
 obj-$(CONFIG_REGULATOR_GPIO) += gpio-regulator.o
 obj-$(CONFIG_REGULATOR_PM8XXX) += pm8xxx-regulator.o
+obj-$(CONFIG_REGULATOR_MSM_GPIO) += msm-gpio-regulator.o
 obj-$(CONFIG_REGULATOR_88PM8607) += 88pm8607.o
 obj-$(CONFIG_REGULATOR_AAT2870) += aat2870-regulator.o
 obj-$(CONFIG_REGULATOR_AB3100) += ab3100.o
diff --git a/drivers/regulator/msm-gpio-regulator.c b/drivers/regulator/msm-gpio-regulator.c
new file mode 100644
index 0000000..15e5b53
--- /dev/null
+++ b/drivers/regulator/msm-gpio-regulator.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/msm-gpio-regulator.h>
+
+struct gpio_vreg {
+	struct regulator_desc	desc;
+	struct regulator_dev	*rdev;
+	char			*gpio_label;
+	char			*name;
+	unsigned		gpio;
+	int			active_low;
+	bool			gpio_requested;
+};
+
+static int gpio_vreg_request_gpio(struct gpio_vreg *vreg)
+{
+	int rc = 0;
+
+	/* Request GPIO now if it hasn't been requested before. */
+	if (!vreg->gpio_requested) {
+		rc = gpio_request(vreg->gpio, vreg->gpio_label);
+		if (rc < 0) {
+			pr_err("failed to request gpio %u (%s), rc=%d\n",
+				vreg->gpio, vreg->gpio_label, rc);
+			return rc;
+		} else {
+			vreg->gpio_requested = true;
+		}
+
+		rc = gpio_sysfs_set_active_low(vreg->gpio, vreg->active_low);
+		if (rc < 0)
+			pr_err("active_low=%d failed for gpio %u, rc=%d\n",
+				vreg->active_low, vreg->gpio, rc);
+	}
+
+	return rc;
+}
+
+static int gpio_vreg_is_enabled(struct regulator_dev *rdev)
+{
+	struct gpio_vreg *vreg = rdev_get_drvdata(rdev);
+	int rc;
+
+	rc = gpio_vreg_request_gpio(vreg);
+	if (rc < 0)
+		return rc;
+
+	return (gpio_get_value_cansleep(vreg->gpio) ? 1 : 0) ^ vreg->active_low;
+}
+
+static int gpio_vreg_enable(struct regulator_dev *rdev)
+{
+	struct gpio_vreg *vreg = rdev_get_drvdata(rdev);
+	int rc;
+
+	rc = gpio_vreg_request_gpio(vreg);
+	if (rc < 0)
+		return rc;
+
+	return gpio_direction_output(vreg->gpio, !vreg->active_low);
+}
+
+static int gpio_vreg_disable(struct regulator_dev *rdev)
+{
+	struct gpio_vreg *vreg = rdev_get_drvdata(rdev);
+	int rc;
+
+	rc = gpio_vreg_request_gpio(vreg);
+	if (rc < 0)
+		return rc;
+
+	return gpio_direction_output(vreg->gpio, vreg->active_low);
+}
+
+static struct regulator_ops gpio_vreg_ops = {
+	.enable		= gpio_vreg_enable,
+	.disable	= gpio_vreg_disable,
+	.is_enabled	= gpio_vreg_is_enabled,
+};
+
+static int __devinit gpio_vreg_probe(struct platform_device *pdev)
+{
+	const struct gpio_regulator_platform_data *pdata;
+	struct gpio_vreg *vreg;
+	int rc = 0;
+
+	pdata = pdev->dev.platform_data;
+
+	if (!pdata) {
+		pr_err("platform data required.\n");
+		return -EINVAL;
+	}
+
+	if (!pdata->gpio_label) {
+		pr_err("gpio_label required.\n");
+		return -EINVAL;
+	}
+
+	if (!pdata->regulator_name) {
+		pr_err("regulator_name required.\n");
+		return -EINVAL;
+	}
+
+	vreg = kzalloc(sizeof(struct gpio_vreg), GFP_KERNEL);
+	if (!vreg) {
+		pr_err("kzalloc failed.\n");
+		return -ENOMEM;
+	}
+
+	vreg->name = kstrdup(pdata->regulator_name, GFP_KERNEL);
+	if (!vreg->name) {
+		pr_err("kzalloc failed.\n");
+		rc = -ENOMEM;
+		goto free_vreg;
+	}
+
+	vreg->gpio_label = kstrdup(pdata->gpio_label, GFP_KERNEL);
+	if (!vreg->gpio_label) {
+		pr_err("kzalloc failed.\n");
+		rc = -ENOMEM;
+		goto free_name;
+	}
+
+	vreg->gpio		= pdata->gpio;
+	vreg->active_low	= (pdata->active_low ? 1 : 0);
+	vreg->gpio_requested	= false;
+
+	vreg->desc.name		= vreg->name;
+	vreg->desc.id		= pdev->id;
+	vreg->desc.ops		= &gpio_vreg_ops;
+	vreg->desc.type		= REGULATOR_VOLTAGE;
+	vreg->desc.owner	= THIS_MODULE;
+
+	vreg->rdev = regulator_register(&vreg->desc, &pdev->dev,
+					&pdata->init_data, vreg, NULL);
+	if (IS_ERR(vreg->rdev)) {
+		rc = PTR_ERR(vreg->rdev);
+		pr_err("%s: regulator_register failed, rc=%d.\n", vreg->name,
+			rc);
+		goto free_gpio_label;
+	}
+
+	platform_set_drvdata(pdev, vreg);
+
+	pr_info("id=%d, name=%s, gpio=%u, gpio_label=%s\n", pdev->id,
+		vreg->name, vreg->gpio, vreg->gpio_label);
+
+	return rc;
+
+free_gpio_label:
+	kfree(vreg->gpio_label);
+free_name:
+	kfree(vreg->name);
+free_vreg:
+	kfree(vreg);
+
+	return rc;
+}
+
+static int __devexit gpio_vreg_remove(struct platform_device *pdev)
+{
+	struct gpio_vreg *vreg = platform_get_drvdata(pdev);
+
+	if (vreg->gpio_requested)
+		gpio_free(vreg->gpio);
+
+	regulator_unregister(vreg->rdev);
+	kfree(vreg->name);
+	kfree(vreg->gpio_label);
+	kfree(vreg);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver gpio_vreg_driver = {
+	.probe = gpio_vreg_probe,
+	.remove = __devexit_p(gpio_vreg_remove),
+	.driver = {
+		.name = GPIO_REGULATOR_DEV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init gpio_vreg_init(void)
+{
+	return platform_driver_register(&gpio_vreg_driver);
+}
+
+static void __exit gpio_vreg_exit(void)
+{
+	platform_driver_unregister(&gpio_vreg_driver);
+}
+
+postcore_initcall(gpio_vreg_init);
+module_exit(gpio_vreg_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("GPIO regulator driver");
+MODULE_VERSION("1.0");
+MODULE_ALIAS("platform:" GPIO_REGULATOR_DEV_NAME);
diff --git a/include/linux/regulator/msm-gpio-regulator.h b/include/linux/regulator/msm-gpio-regulator.h
new file mode 100644
index 0000000..9efda85
--- /dev/null
+++ b/include/linux/regulator/msm-gpio-regulator.h
@@ -0,0 +1,37 @@
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MSM_GPIO_REGULATOR_H__
+#define __MSM_GPIO_REGULATOR_H__
+
+#include <linux/regulator/machine.h>
+
+#define GPIO_REGULATOR_DEV_NAME "msm-gpio-regulator"
+
+/**
+ * struct gpio_regulator_platform_data - GPIO regulator platform data
+ * @init_data:		regulator constraints
+ * @gpio_label:		label to use when requesting the GPIO
+ * @regulator_name:	name for regulator used during registration
+ * @gpio:		gpio number
+ * @active_low:		0 = regulator is enabled when GPIO outputs high
+ *			1 = regulator is enabled when GPIO outputs low
+ */
+struct gpio_regulator_platform_data {
+	struct regulator_init_data	init_data;
+	char				*gpio_label;
+	char				*regulator_name;
+	unsigned			gpio;
+	int				active_low;
+};
+
+#endif
-- 
1.7.5.4

