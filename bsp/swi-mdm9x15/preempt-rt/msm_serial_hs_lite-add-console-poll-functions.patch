From 74b3fd262655a25364848eed969dc4101c5bb8f8 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 16 Apr 2013 20:11:57 +0800
Subject: [PATCH 54/70] msm_serial_hs_lite: add console poll functions

console poll functions are needee by kgdboc, so implement
it to support kgdboc

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 drivers/tty/serial/msm_serial_hs_lite.c |  126 +++++++++++++++++++++++++++++++
 1 files changed, 126 insertions(+), 0 deletions(-)

diff --git a/drivers/tty/serial/msm_serial_hs_lite.c b/drivers/tty/serial/msm_serial_hs_lite.c
index fab21ea..1eeb215 100644
--- a/drivers/tty/serial/msm_serial_hs_lite.c
+++ b/drivers/tty/serial/msm_serial_hs_lite.c
@@ -804,6 +804,128 @@ static void msm_hsl_break_ctl(struct uart_port *port, int break_ctl)
 		msm_hsl_write(port, STOP_BREAK, regmap[vid][UARTDM_CR]);
 }
 
+#ifdef CONFIG_CONSOLE_POLL
+
+#define MAX_BUF_SIZE 2024
+
+/*
+ * Console polling routines for writing and reading from the uart while
+ * in an interrupt or debug context.
+ */
+static int msm_hsl_get_poll_char(struct uart_port *port)
+{
+	unsigned int vid, sr, c, misr = 0;
+        struct msm_hsl_port *msm_hsl_port = UART_TO_MSM(port);
+	int i, count = 0;
+	char *pchar, tmp_char;
+	static char *buffer;
+	static int  left_char_num, total_char_num;
+
+	if (buffer == NULL)
+		buffer = kmalloc(MAX_BUF_SIZE, GFP_ATOMIC);
+
+	vid = msm_hsl_port->ver_id;
+
+	if (left_char_num == 0) {
+		sr = msm_hsl_read(port, regmap[vid][UARTDM_SR]);
+		if ((sr & UARTDM_SR_RXRDY_BMSK) == 0)
+			return NO_POLL_CHAR;
+
+		misr = msm_hsl_read(port, regmap[vid][UARTDM_MISR]);
+		if (misr & UARTDM_ISR_RXSTALE_BMSK) {
+			count = msm_hsl_read(port,
+				regmap[vid][UARTDM_RX_TOTAL_SNAP]) -
+				msm_hsl_port->old_snap_state;
+
+			if (count < 0) {
+				count = msm_hsl_read(port,
+				regmap[vid][UARTDM_RX_TOTAL_SNAP]);
+			}
+			msm_hsl_port->old_snap_state = 0;
+		} else {
+			count = 4 * (msm_hsl_read(port,
+					regmap[vid][UARTDM_RFWR]));
+			msm_hsl_port->old_snap_state += count;
+		}
+
+		/* and now the main RX loop */
+		while (count > 0) {
+			sr = msm_hsl_read(port, regmap[vid][UARTDM_SR]);
+
+			c = msm_hsl_read(port, regmap[vid][UARTDM_RF]);
+
+			pchar = (char *) &c;
+			for (i = 0; i < ((count > 4) ? 4 : count); i++) {
+				buffer[left_char_num++] = *pchar;
+				pchar++;
+			}
+
+			total_char_num = left_char_num;
+
+			count -= 4;
+		}
+
+		if ( count <= 0) {
+			if (misr & (UARTDM_ISR_RXSTALE_BMSK))
+				msm_hsl_write(port, RESET_STALE_INT,
+						regmap[vid][UARTDM_CR]);
+			msm_hsl_write(port, 6500, regmap[vid][UARTDM_DMRX]);
+			msm_hsl_write(port, STALE_EVENT_ENABLE,
+					regmap[vid][UARTDM_CR]);
+		}
+	}
+
+	if (left_char_num != 0) {
+		tmp_char = buffer[total_char_num - left_char_num];
+		left_char_num--;
+		return tmp_char;
+	}
+
+	return NO_POLL_CHAR;
+}
+
+static void msm_hsl_put_poll_char(struct uart_port *port,
+			 unsigned char c)
+{
+	unsigned int vid;
+        struct msm_hsl_port *msm_hsl_port = UART_TO_MSM(port);
+	unsigned long flags;
+
+	/*
+	 *	First save the ISR then disable the interrupts
+	 */
+	spin_lock_irqsave(&port->lock, flags);
+        vid = msm_hsl_port->ver_id;
+
+        /* disable interrupt */
+        msm_hsl_write(port, 0, regmap[vid][UARTDM_IMR]);
+
+	wait_for_xmitr(port);
+	msm_hsl_write(port, 1, regmap[vid][UARTDM_NCF_TX]);
+        msm_hsl_read(port, regmap[vid][UARTDM_SR]);
+	msm_hsl_write(port, c, regmap[vid][UARTDM_TF]);
+
+	/*
+	 *	Send the character out.
+	 *	If a LF, also do CR...
+	 */
+	if (c == 10) {
+		wait_for_xmitr(port);
+		msm_hsl_write(port, 13, regmap[vid][UARTDM_TF]);
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IER
+	 */
+	wait_for_xmitr(port);
+	/* restore interrupt */
+        msm_hsl_write(port, msm_hsl_port->imr, regmap[vid][UARTDM_IMR]);
+        spin_unlock_irqrestore(&port->lock, flags);
+}
+
+#endif /* CONFIG_CONSOLE_POLL */
+
 /**
  * msm_hsl_set_baud_rate: set requested baud rate
  * @port: uart port
@@ -1308,6 +1430,10 @@ static struct uart_ops msm_hsl_uart_pops = {
 	.config_port = msm_hsl_config_port,
 	.verify_port = msm_hsl_verify_port,
 	.pm = msm_hsl_power,
+#ifdef CONFIG_CONSOLE_POLL
+        .poll_get_char = msm_hsl_get_poll_char,
+        .poll_put_char = msm_hsl_put_poll_char,
+#endif
 };
 
 static struct msm_hsl_port msm_hsl_uart_ports[] = {
-- 
1.7.5.4

