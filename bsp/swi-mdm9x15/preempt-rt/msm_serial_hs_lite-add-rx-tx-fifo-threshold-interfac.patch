From d9a8cc3c2f8b6b8a4fd4492d097032bff732a246 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 16 Apr 2013 17:59:04 +0800
Subject: [PATCH 53/70] msm_serial_hs_lite: add rx/tx fifo threshold interface

Add rx/tx fifo threshold interface to let customer set
it in rumtime

Signed-off-by: Aaron Ma <pengyu.ma@windriver.com>
Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Catalin Enache <catalin.enache@windriver.com>
---
 drivers/tty/serial/msm_serial_hs_lite.c |  147 ++++++++++++++++++++++++++++++-
 1 files changed, 145 insertions(+), 2 deletions(-)

diff --git a/drivers/tty/serial/msm_serial_hs_lite.c b/drivers/tty/serial/msm_serial_hs_lite.c
index 86c9048..fab21ea 100644
--- a/drivers/tty/serial/msm_serial_hs_lite.c
+++ b/drivers/tty/serial/msm_serial_hs_lite.c
@@ -94,6 +94,8 @@ struct msm_hsl_port {
 	u32			bus_perf_client;
 	/* BLSP UART required BUS Scaling data */
 	struct msm_bus_scale_pdata *bus_scale_table;
+	unsigned int		tx_fifothreshold;/* tx fifo threshold */
+	unsigned int		rx_fifothreshold;/* rx fifo threshold */
 };
 
 #define UARTDM_VERSION_11_13	0
@@ -931,11 +933,12 @@ static void msm_hsl_set_baud_rate(struct uart_port *port,
 	 * whereas it is consider to be in Bytes for UART Core.
 	 * Hence configuring Rx Watermark as 48 Words.
 	 */
-	watermark = (port->fifosize * 3) / 4;
+	watermark = msm_hsl_port->rx_fifothreshold;
 	msm_hsl_write(port, watermark, regmap[vid][UARTDM_RFWR]);
 
 	/* set TX watermark */
-	msm_hsl_write(port, 0, regmap[vid][UARTDM_TFWR]);
+	msm_hsl_write(port, msm_hsl_port->tx_fifothreshold,
+			regmap[vid][UARTDM_TFWR]);
 
 	msm_hsl_write(port, CR_PROTECTION_EN, regmap[vid][UARTDM_CR]);
 	msm_hsl_reset(port);
@@ -1316,6 +1319,8 @@ static struct msm_hsl_port msm_hsl_uart_ports[] = {
 			.fifosize = 64,
 			.line = 0,
 		},
+		.tx_fifothreshold = 0,
+		.rx_fifothreshold = 48,
 	},
 	{
 		.uart = {
@@ -1325,6 +1330,8 @@ static struct msm_hsl_port msm_hsl_uart_ports[] = {
 			.fifosize = 64,
 			.line = 1,
 		},
+		.tx_fifothreshold = 0,
+		.rx_fifothreshold = 48,
 	},
 	{
 		.uart = {
@@ -1334,6 +1341,8 @@ static struct msm_hsl_port msm_hsl_uart_ports[] = {
 			.fifosize = 64,
 			.line = 2,
 		},
+		.tx_fifothreshold = 0,
+		.rx_fifothreshold = 48,
 	},
 };
 
@@ -1614,6 +1623,131 @@ static DEVICE_ATTR(console, S_IWUSR | S_IRUGO, show_msm_console,
 #define MSM_HSL_CONSOLE	NULL
 #endif
 
+/* show_msm_fifo_rx - provide serial fifo rx size. */
+static ssize_t show_msm_fifo_rx(struct device *dev,
+                                struct device_attribute *attr, char *buf)
+{
+	struct uart_port *port;
+
+        struct platform_device *pdev = to_platform_device(dev);
+	port = get_port_from_line(get_line(pdev));
+	return snprintf(buf, sizeof(UART_TO_MSM(port)->rx_fifothreshold),
+			"%d\n", UART_TO_MSM(port)->rx_fifothreshold);
+
+}
+
+/*
+ * set_msm_fifo_rx - allow to set serial fifo rx size.
+ */
+
+static ssize_t set_msm_fifo_rx(struct device *dev,
+                                struct device_attribute *attr,
+                                const char *buf, size_t count)
+{
+        int err, set_size;
+        struct uart_port *port;
+	unsigned int vid;
+
+        struct platform_device *pdev = to_platform_device(dev);
+        port = get_port_from_line(get_line(pdev));
+	vid = UART_TO_MSM(port)->ver_id;
+
+	err = kstrtoint(buf, 0, &set_size);
+	if (err)
+                return err;
+
+	if(UART_TO_MSM(port)->rx_fifothreshold == set_size)
+		return count;
+	if((set_size <= 46) && (set_size >= 0))
+		UART_TO_MSM(port)->rx_fifothreshold = set_size;
+	else {
+		printk("%s: rx fifo threshold should be between"
+			" 0 - 48 Words(4 Bytes per Word)", __func__);
+		return -EINVAL;
+	}
+
+        /* Set RX watermark
+         * Configure Rx Watermark as 3/4 size of Rx FIFO.
+         * RFWR register takes value in Words for UARTDM Core
+         * whereas it is consider to be in Bytes for UART Core.
+         * Hence configuring Rx Watermark as 48 Words.
+         */
+        msm_hsl_write(port, UART_TO_MSM(port)->rx_fifothreshold,
+			regmap[vid][UARTDM_RFWR]);
+
+        /* set TX watermark */
+        msm_hsl_write(port, UART_TO_MSM(port)->tx_fifothreshold,
+			regmap[vid][UARTDM_TFWR]);
+
+	return count;
+}
+
+static DEVICE_ATTR(fifo_rx, S_IWUSR | S_IRUGO, show_msm_fifo_rx,
+                                                set_msm_fifo_rx);
+
+/* show_msm_fifo_tx - provide serial fifo rx size. */
+static ssize_t show_msm_fifo_tx(struct device *dev,
+                                struct device_attribute *attr, char *buf)
+{
+	struct uart_port *port;
+
+        struct platform_device *pdev = to_platform_device(dev);
+	port = get_port_from_line(get_line(pdev));
+	return snprintf(buf, sizeof(UART_TO_MSM(port)->tx_fifothreshold),
+			"%d\n", UART_TO_MSM(port)->tx_fifothreshold);
+
+}
+
+/*
+ * set_msm_fifo_tx - allow to set serial fifo rx size.
+ */
+
+static ssize_t set_msm_fifo_tx(struct device *dev,
+                                struct device_attribute *attr,
+                                const char *buf, size_t count)
+{
+        unsigned int vid;
+	int err, set_size;
+        struct uart_port *port;
+
+        struct platform_device *pdev = to_platform_device(dev);
+        port = get_port_from_line(get_line(pdev));
+	vid = UART_TO_MSM(port)->ver_id;
+
+	err = kstrtoint(buf, 0, &set_size);
+	if (err)
+                return err;
+
+	if(UART_TO_MSM(port)->tx_fifothreshold == set_size)
+		return count;
+
+	if((set_size <= 46) && (set_size >= 0))
+		UART_TO_MSM(port)->tx_fifothreshold = set_size;
+	else {
+		printk("%s: tx fifo threshold should be between"
+			"0 - 48 Words(4 Bytes per Word)", __func__);
+		return -EINVAL;
+	}
+
+        /* Set RX watermark
+	* Configure Rx Watermark as 3/4 size of Rx FIFO.
+        * RFWR register takes value in Words for UARTDM Core
+        * whereas it is consider to be in Bytes for UART Core.
+        * Hence configuring Rx Watermark as 48 Words.
+        */
+        msm_hsl_write(port, UART_TO_MSM(port)->rx_fifothreshold,
+			regmap[vid][UARTDM_RFWR]);
+
+        /* set TX watermark */
+        msm_hsl_write(port, UART_TO_MSM(port)->tx_fifothreshold,
+			regmap[vid][UARTDM_TFWR]);
+
+	return count;
+}
+
+static DEVICE_ATTR(fifo_tx, S_IWUSR | S_IRUGO, show_msm_fifo_tx,
+                                                set_msm_fifo_tx);
+
 static struct uart_driver msm_hsl_uart_driver = {
 	.owner = THIS_MODULE,
 	.driver_name = "msm_serial_hsl",
@@ -1812,6 +1946,15 @@ static int __devinit msm_serial_hsl_probe(struct platform_device *pdev)
 	if (unlikely(ret))
 		pr_err("Can't create console attribute\n");
 #endif
+
+	ret = device_create_file(&pdev->dev, &dev_attr_fifo_tx);
+        if (unlikely(ret))
+                pr_err("Can't create fifo_tx attribute\n");
+
+	ret = device_create_file(&pdev->dev, &dev_attr_fifo_rx);
+        if (unlikely(ret))
+                pr_err("Can't create fifo_rx attribute\n");
+
 	msm_hsl_debugfs_init(msm_hsl_port, get_line(pdev));
 	mutex_init(&msm_hsl_port->clk_mutex);
 	if (pdata && pdata->use_pm)
-- 
1.7.5.4

