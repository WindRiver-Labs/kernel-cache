From 11712339a53030316c555d2a1f649b06d244dacd Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Wed, 2 Jul 2008 17:01:59 +0800
Subject: [PATCH] TOLAPAI GCU driver

Add support for TOLAPAI Global Configuration Unit.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/misc/Kconfig        |    8 +
 drivers/misc/Makefile       |    1 +
 drivers/misc/gcu/Makefile   |   35 ++++
 drivers/misc/gcu/gcu.h      |   96 ++++++++++
 drivers/misc/gcu/gcu_if.c   |  315 ++++++++++++++++++++++++++++++++
 drivers/misc/gcu/gcu_if.h   |   50 +++++
 drivers/misc/gcu/gcu_main.c |  417 +++++++++++++++++++++++++++++++++++++++++++
 drivers/misc/gcu/gcu_reg.h  |   68 +++++++
 8 files changed, 990 insertions(+), 0 deletions(-)
 create mode 100644 drivers/misc/gcu/Makefile
 create mode 100644 drivers/misc/gcu/gcu.h
 create mode 100644 drivers/misc/gcu/gcu_if.c
 create mode 100644 drivers/misc/gcu/gcu_if.h
 create mode 100644 drivers/misc/gcu/gcu_main.c
 create mode 100644 drivers/misc/gcu/gcu_reg.h

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 4885d2d..8acb6e9 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -404,4 +404,12 @@ config SGI_XP
 	  this feature will allow for direct communication between SSIs
 	  based on a network adapter and DMA messaging.
 
+config TOLAPAI_GCU
+	tristate "Tolapai Global Configuration Unit"
+	depends on TOLAPAI
+	---help---
+	  This is a driver for Intel Tolapai Global Configuration Unit which
+	  implements configuration space registers for system-level. If you have
+	  a Tolapai SOC, say Y or M here.
+
 endif # MISC_DEVICES
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 2649528..1fccc54 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -27,3 +27,4 @@ obj-$(CONFIG_INTEL_MENLOW)	+= intel_menlow.o
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
+obj-$(CONFIG_TOLAPAI_GCU)	+= gcu/
diff --git a/drivers/misc/gcu/Makefile b/drivers/misc/gcu/Makefile
new file mode 100644
index 0000000..7f7ea93
--- /dev/null
+++ b/drivers/misc/gcu/Makefile
@@ -0,0 +1,35 @@
+################################################################################
+#
+# Intel PRO/1000 Linux driver
+# Copyright(c) 1999 - 2006 Intel Corporation.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Linux NICS <linux.nics@intel.com>
+# e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
+# Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+#
+################################################################################
+
+#
+# Makefile for the Tolapai GCU
+#
+
+obj-$(CONFIG_E1000) += gcu.o
+
+gcu-objs := gcu_main.o gcu_if.o
diff --git a/drivers/misc/gcu/gcu.h b/drivers/misc/gcu/gcu.h
new file mode 100644
index 0000000..e4d41f5
--- /dev/null
+++ b/drivers/misc/gcu/gcu.h
@@ -0,0 +1,96 @@
+/*****************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+ version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+*****************************************************************************/
+
+
+/* Linux GCU Driver main header file */
+
+#ifndef __GCU_H__
+#define __GCU_H__
+
+#include <linux/stddef.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <asm/bitops.h>
+#include <linux/slab.h>
+#include <linux/reboot.h>
+#include <asm/delay.h>
+#include <linux/netdevice.h>
+
+#define BAR_0		0
+
+#define INTEL_GCU_DEVICE(device_id) {\
+	PCI_DEVICE(PCI_VENDOR_ID_INTEL, device_id)}
+
+#define GCU_DEV_NAME_SIZE 16
+
+#ifdef DBG
+#define GCU_DBG(args...) printk(KERN_DEBUG "gcu: " args)
+#else
+#define GCU_DBG(args...)
+#endif
+
+#define GCU_ERR(args...) printk(KERN_ERR "gcu: " args)
+
+struct gcu_adapter {
+	struct pci_dev *pdev;
+	uint32_t mem_start;
+	uint32_t mem_end;
+	uint32_t base_addr;
+	uint8_t *hw_addr;
+	char name[GCU_DEV_NAME_SIZE];
+	uint32_t pci_state[16];
+	uint16_t device_id;
+	uint16_t vendor_id;
+	uint16_t subsystem_id;
+	uint16_t subsystem_vendor_id;
+	uint16_t pci_cmd_word;
+	uint8_t revision_id;
+	/* open/release and usage marking */
+	struct module *owner;
+};
+
+/*
+ * Exported interface functions need access to the modules
+ * gcu_adapter struct
+ */
+const struct gcu_adapter *gcu_get_adapter(void);
+void gcu_release_adapter(const struct gcu_adapter **adapter);
+
+#endif /* __GCU_H__ */
+
diff --git a/drivers/misc/gcu/gcu_if.c b/drivers/misc/gcu/gcu_if.c
new file mode 100644
index 0000000..dc81492
--- /dev/null
+++ b/drivers/misc/gcu/gcu_if.c
@@ -0,0 +1,315 @@
+/*****************************************************************************
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+  version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+*****************************************************************************/
+
+/*
+ * gcu_if.c
+ * Shared functions for accessing and configuring the GCU
+ */
+
+#include "gcu.h"
+#include "gcu_reg.h"
+#include "gcu_if.h"
+
+/* forward declaration for write verify used in gcu_write_eth_phy */
+int32_t gcu_write_verify(uint32_t phy_num,
+				uint32_t reg_addr,
+				uint16_t written_data,
+				const struct gcu_adapter *adapter);
+
+/**
+ * gcu_write_eth_phy
+ * @phy_num: phy we want to write to, either 0, 1, or 2
+ * @reg_addr: address in PHY's register space to write to
+ * @phy_data: data to be written
+ *
+ * interface function for other modules to access the GCU
+ **/
+int32_t
+gcu_write_eth_phy(uint32_t phy_num, uint32_t reg_addr, uint16_t phy_data)
+{
+	const struct gcu_adapter *adapter;
+	uint32_t data = 0;
+	uint32_t timeoutCounter = 0;
+	const uint32_t timeoutCounterMax = GCU_MAX_ATTEMPTS;
+	uint32_t complete;
+
+	GCU_DBG("%s\n", __func__);
+
+	if(phy_num > MDIO_COMMAND_PHY_ADDR_MAX)
+	{
+		GCU_ERR("phy_num = %d, which is greater than "
+				"MDIO_COMMAND_PHY_ADDR_MAX\n", phy_num);
+
+		return -1;
+	}
+
+	if(reg_addr > MDIO_COMMAND_PHY_REG_MAX)
+	{
+		GCU_ERR("reg_addr = %d, which is greater than "
+				"MDIO_COMMAND_PHY_REG_MAX\n", phy_num);
+
+		return -1;
+	}
+
+	/* format the data to be written to the MDIO_COMMAND_REG */
+	data = phy_data;
+	data |= (reg_addr << MDIO_COMMAND_PHY_REG_OFFSET);
+	data |= (phy_num << MDIO_COMMAND_PHY_ADDR_OFFSET);
+	data |= MDIO_COMMAND_OPER_MASK | MDIO_COMMAND_GO_MASK;
+
+	/*
+	 * get_gcu_adapter contains a spinlock, this may pause for a bit
+	 */
+	adapter = gcu_get_adapter();
+	if(!adapter)
+	{
+		GCU_ERR("gcu_adapter not available, cannot access MMIO\n");
+		return -1;
+	}
+
+	/*
+	 * We write to MDIO_COMMAND_REG initially, then read that
+	 * same register until its MDIO_GO bit is cleared. When cleared,
+	 * the transaction is complete
+	 */
+	iowrite32(data, adapter->hw_addr + MDIO_COMMAND_REG);
+	do {
+		timeoutCounter++;
+		udelay(50); /* 50 microsecond delay */
+		data = ioread32(adapter->hw_addr + MDIO_COMMAND_REG);
+		complete = (data & MDIO_COMMAND_GO_MASK) >> MDIO_COMMAND_GO_OFFSET;
+	} while(complete && timeoutCounter < timeoutCounterMax);
+	/* KAD !complete to complete */
+
+	if(timeoutCounter == timeoutCounterMax && !complete)
+	{
+		GCU_ERR("Reached maximum number of retries"
+				" accessing MDIO_COMMAND_REG\n");
+
+		gcu_release_adapter(&adapter);
+
+		return -1;
+	}
+
+	/* validate the write during debug */
+#ifdef DBG
+	if(!gcu_write_verify(phy_num, reg_addr, phy_data, adapter))
+	{
+		GCU_ERR("Write verification failed for PHY=%d and addr=%d\n",
+				phy_num, reg_addr);
+
+		gcu_release_adapter(&adapter);
+
+		return -1;
+	}
+#endif
+
+	gcu_release_adapter(&adapter);
+
+	return 0;
+}
+EXPORT_SYMBOL(gcu_write_eth_phy);
+
+
+/**
+ * gcu_read_eth_phy
+ * @phy_num: phy we want to write to, either 0, 1, or 2
+ * @reg_addr: address in PHY's register space to write to
+ * @phy_data: data to be written
+ *
+ * interface function for other modules to access the GCU
+ **/
+int32_t
+gcu_read_eth_phy(uint32_t phy_num, uint32_t reg_addr, uint16_t *phy_data)
+{
+	const struct gcu_adapter *adapter;
+	uint32_t data = 0;
+	uint32_t timeoutCounter = 0;
+	const uint32_t timeoutCounterMax = GCU_MAX_ATTEMPTS;
+	uint32_t complete = 0;
+
+	GCU_DBG("%s\n", __func__);
+
+	if(phy_num > MDIO_COMMAND_PHY_ADDR_MAX)
+	{
+		GCU_ERR("phy_num = %d, which is greater than "
+				"MDIO_COMMAND_PHY_ADDR_MAX\n", phy_num);
+
+		return -1;
+	}
+
+	if(reg_addr > MDIO_COMMAND_PHY_REG_MAX)
+	{
+		GCU_ERR("reg_addr = %d, which is greater than "
+				"MDIO_COMMAND_PHY_REG_MAX\n", phy_num);
+
+		return -1;
+	}
+
+	/* format the data to be written to MDIO_COMMAND_REG */
+	data |= (reg_addr << MDIO_COMMAND_PHY_REG_OFFSET);
+	data |= (phy_num << MDIO_COMMAND_PHY_ADDR_OFFSET);
+	data |= MDIO_COMMAND_GO_MASK;
+
+	/*
+	 * this call contains a spinlock, so this may pause for a bit
+	 */
+	adapter = gcu_get_adapter();
+	if(!adapter)
+	{
+		GCU_ERR("gcu_adapter not available, cannot access MMIO\n");
+		return -1;
+	}
+
+	/*
+	 * We write to MDIO_COMMAND_REG initially, then read that
+	 * same register until its MDIO_GO bit is cleared. When cleared,
+	 * the transaction is complete
+	 */
+	iowrite32(data, adapter->hw_addr + MDIO_COMMAND_REG);
+	do {
+		timeoutCounter++;
+		udelay(50); /* 50 microsecond delay */
+		data = ioread32(adapter->hw_addr + MDIO_COMMAND_REG);
+		complete = (data & MDIO_COMMAND_GO_MASK) >> MDIO_COMMAND_GO_OFFSET;
+	} while(complete && timeoutCounter < timeoutCounterMax);
+	/* KAD !complete to complete */
+
+	if(timeoutCounter == timeoutCounterMax && !complete)
+	{
+		GCU_ERR("Reached maximum number of retries"
+				" accessing MDIO_COMMAND_REG\n");
+
+	 	gcu_release_adapter(&adapter);
+
+		return -1;
+	}
+
+	/* we retrieve the data from the MDIO_STATUS_REGISTER */
+	data = ioread32(adapter->hw_addr + MDIO_STATUS_REG);
+	if((data & MDIO_STATUS_STATUS_MASK) != 0)
+	{
+		GCU_ERR("Unable to retrieve data from MDIO_STATUS_REG");
+
+		gcu_release_adapter(&adapter);
+
+		return -1;
+	}
+
+	*phy_data = (uint16_t) (data & MDIO_STATUS_READ_DATA_MASK);
+
+	gcu_release_adapter(&adapter);
+
+	return 0;
+}
+EXPORT_SYMBOL(gcu_read_eth_phy);
+
+
+/**
+ * gcu_write_verify
+ * @phy_num: phy we want to write to, either 0, 1, or 2
+ * @reg_addr: address in PHY's register space to write to
+ * @phy_data: data to be checked
+ * @adapter: pointer to global adapter struct
+ *
+ * This f(n) assumes that the spinlock acquired for adapter is
+ * still in force.
+ **/
+int32_t
+gcu_write_verify(uint32_t phy_num, uint32_t reg_addr, uint16_t written_data,
+				 const struct gcu_adapter *adapter)
+{
+	uint32_t data = 0;
+	uint32_t timeoutCounter = 0;
+	const uint32_t timeoutCounterMax = GCU_MAX_ATTEMPTS;
+	uint32_t complete = 0;
+
+	GCU_DBG("%s\n", __func__);
+
+	if(!adapter)
+	{
+		GCU_ERR("Invalid adapter pointer\n");
+		return 0;
+	}
+
+	if(phy_num > MDIO_COMMAND_PHY_ADDR_MAX)
+	{
+		GCU_ERR("phy_num = %d, which is greater than "
+				"MDIO_COMMAND_PHY_ADDR_MAX\n", phy_num);
+
+		return 0;
+	}
+
+	if(reg_addr > MDIO_COMMAND_PHY_REG_MAX)
+	{
+		GCU_ERR("reg_addr = %d, which is greater than "
+				"MDIO_COMMAND_PHY_REG_MAX\n", phy_num);
+
+		return 0;
+	}
+
+	/* format the data to be written to MDIO_COMMAND_REG */
+	data |= (reg_addr << MDIO_COMMAND_PHY_REG_OFFSET);
+	data |= (phy_num << MDIO_COMMAND_PHY_ADDR_OFFSET);
+	data |= MDIO_COMMAND_GO_MASK;
+
+	/*
+	 * We write to MDIO_COMMAND_REG initially, then read that
+	 * same register until its MDIO_GO bit is cleared. When cleared,
+	 * the transaction is complete
+	 */
+	iowrite32(data, adapter->hw_addr + MDIO_COMMAND_REG);
+	do {
+		timeoutCounter++;
+		udelay(50); /* 50 microsecond delay */
+		data = ioread32(adapter->hw_addr + MDIO_COMMAND_REG);
+		complete = (data & MDIO_COMMAND_GO_MASK) >> MDIO_COMMAND_GO_OFFSET;
+	} while(!complete && timeoutCounter < timeoutCounterMax);
+
+
+	if(timeoutCounter == timeoutCounterMax && !complete)
+	{
+		GCU_ERR("Reached maximum number of retries"
+				" accessing MDIO_COMMAND_REG\n");
+
+		return 0;
+	}
+
+	/* we retrieve the data from the MDIO_STATUS_REGISTER */
+	data = ioread32(adapter->hw_addr + MDIO_STATUS_REG);
+	if((data & MDIO_STATUS_STATUS_MASK) != 0)
+	{
+		GCU_ERR("Unable to retrieve data from MDIO_STATUS_REG");
+
+		return 0;
+	}
+
+	return written_data == (uint16_t) (data & MDIO_STATUS_READ_DATA_MASK);
+}
+
diff --git a/drivers/misc/gcu/gcu_if.h b/drivers/misc/gcu/gcu_if.h
new file mode 100644
index 0000000..1cbd4cc
--- /dev/null
+++ b/drivers/misc/gcu/gcu_if.h
@@ -0,0 +1,50 @@
+/*****************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+ version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+*****************************************************************************/
+
+/*
+ * gcu_if.h
+ * Shared functions for accessing and configuring the GCU
+ */
+
+#ifndef __GCU_IF_H__
+#define __GCU_IF_H__
+
+#define GCU_MAX_ATTEMPTS 64
+
+int32_t gcu_write_eth_phy(uint32_t phy_num, uint32_t reg_addr,
+                          uint16_t phy_data);
+
+int32_t gcu_read_eth_phy(uint32_t phy_num, uint32_t reg_addr,
+                         uint16_t *phy_data);
+
+#endif /* ifndef __GCU_IF_H__ */
+
diff --git a/drivers/misc/gcu/gcu_main.c b/drivers/misc/gcu/gcu_main.c
new file mode 100644
index 0000000..c970a0d
--- /dev/null
+++ b/drivers/misc/gcu/gcu_main.c
@@ -0,0 +1,417 @@
+/******************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+  version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+******************************************************************************/
+
+#include "gcu.h"
+
+static char gcu_driver_name[] = "GCU";
+static char gcu_driver_string[] = "Intel(R) Global Configuration Unit";
+#define DRV_VERSION "1.0.0"
+static char gcu_driver_version[] = DRV_VERSION;
+static char gcu_copyright[] = "Copyright (c) 1999-2007 Intel Corporation.";
+
+/* gcu_pci_tbl - PCI Device ID Table
+ *
+ * Last entry must be all 0s
+ *
+ * Macro expands to...
+ *   {PCI_DEVICE(PCI_VENDOR_ID_INTEL, device_id)}
+ */
+static struct pci_device_id gcu_pci_tbl[] = {
+	INTEL_GCU_DEVICE(0x503E),
+	/* required last entry */
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, gcu_pci_tbl);
+
+enum gcu_err_type {err_ioremap, err_alloc_gcu_adapter};
+
+static int gcu_init_module(void);
+static void gcu_exit_module(void);
+static int gcu_probe(struct pci_dev *pdev, const struct pci_device_id *ent);
+static void gcu_probe_err(enum gcu_err_type err, struct pci_dev *pdev,
+						  struct gcu_adapter *adapter);
+static void __devexit gcu_remove(struct pci_dev *pdev);
+static int gcu_notify_reboot(struct notifier_block *, unsigned long event,
+                             void *ptr);
+static int gcu_suspend(struct pci_dev *pdev, uint32_t state);
+static struct gcu_adapter *alloc_gcu_adapter(void);
+static void free_gcu_adapter(struct gcu_adapter *adapter);
+
+
+struct notifier_block gcu_notifier_reboot = {
+	.notifier_call	= gcu_notify_reboot,
+	.next		= NULL,
+	.priority	= 0
+};
+
+static struct pci_driver gcu_driver = {
+	.name     = gcu_driver_name,
+	.id_table = gcu_pci_tbl,
+	.probe    = gcu_probe,
+	.remove   = __devexit_p(gcu_remove),
+};
+
+static struct gcu_adapter *global_adapter = 0;
+static spinlock_t global_adapter_spinlock = SPIN_LOCK_UNLOCKED;
+
+MODULE_AUTHOR("Intel(R) Corporation");
+MODULE_DESCRIPTION("Intel(R) Global Configuration Unit");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.7.2");
+
+/**
+ * gcu_init_module - Driver Registration Routine
+ *
+ * gcu_init_module is the first routine called when the driver is
+ * loaded. All it does is register with the PCI subsystem.
+ **/
+static int __init
+gcu_init_module(void)
+{
+	int ret;
+	printk(KERN_INFO "%s - version %s\n",
+	       gcu_driver_string, gcu_driver_version);
+
+	printk(KERN_INFO "%s\n", gcu_copyright);
+
+	ret = pci_register_driver(&gcu_driver);
+	if(ret >= 0) {
+		register_reboot_notifier(&gcu_notifier_reboot);
+	}
+	return ret;
+}
+
+module_init(gcu_init_module);
+
+/**
+ * gcu_exit_module - Driver Exit Cleanup Routine
+ *
+ * gcu_exit_module is called just before the driver is removed
+ * from memory.
+ **/
+static void __exit
+gcu_exit_module(void)
+{
+	GCU_DBG("%s\n", __func__);
+
+	unregister_reboot_notifier(&gcu_notifier_reboot);
+	pci_unregister_driver(&gcu_driver);
+}
+
+module_exit(gcu_exit_module);
+
+
+/**
+ * gcu_probe - Device Initialization Routine
+ * @pdev: PCI device information struct
+ * @ent: entry in gcu_pci_tbl
+ *
+ * Returns 0 on success, negative on failure
+ *
+ * gcu_probe initializes an adapter identified by a pci_dev structure.
+ * The OS initialization, configuring of the adapter private structure,
+ * and a hardware reset occur.
+ **/
+static int __devinit
+gcu_probe(struct pci_dev *pdev,
+          const struct pci_device_id *ent)
+{
+	struct gcu_adapter *adapter=0;
+	uint32_t mmio_start, mmio_len;
+	int err;
+
+	GCU_DBG("%s\n", __func__);
+
+	if((err = pci_enable_device(pdev)))
+	{
+		GCU_DBG("Unable to enable PCI Device\n");
+		return err;
+	}
+
+	if((err = pci_request_regions(pdev, gcu_driver_name)))
+	{
+		GCU_DBG("Unable to acquire requested memory regions\n");
+		return err;
+	}
+
+	/*
+	 * acquire the adapter spinlock. Once the module is loaded, it is possible for
+	 * someone to access the adapter struct via the interface functions exported
+	 * in gcu_if.c
+	 */
+	spin_lock(&global_adapter_spinlock);
+
+	adapter = alloc_gcu_adapter();
+	if(!adapter) {
+	    gcu_probe_err(err_alloc_gcu_adapter, pdev, adapter);
+	    spin_unlock(&global_adapter_spinlock);
+	    return -ENOMEM;
+	}
+
+	adapter->owner = THIS_MODULE;
+
+	pci_set_drvdata(pdev, adapter);
+
+	adapter->pdev = pdev;
+
+	mmio_start = pci_resource_start(pdev, BAR_0);
+	mmio_len = pci_resource_len(pdev, BAR_0);
+
+	adapter->hw_addr = ioremap(mmio_start, mmio_len);
+	if(!adapter->hw_addr) {
+		GCU_DBG("Unable to map mmio\n");
+		gcu_probe_err(err_ioremap, pdev, adapter);
+		spin_unlock(&global_adapter_spinlock);
+		return -EIO;
+	}
+
+	strncpy(adapter->name, pci_name(pdev), sizeof(adapter->name)-1);
+	adapter->mem_start = mmio_start;
+	adapter->mem_end = mmio_start + mmio_len;
+
+	adapter->vendor_id = pdev->vendor;
+	adapter->device_id = pdev->device;
+	adapter->subsystem_vendor_id = pdev->subsystem_vendor;
+	adapter->subsystem_id = pdev->subsystem_device;
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &adapter->revision_id);
+
+	pci_read_config_word(pdev, PCI_COMMAND, &adapter->pci_cmd_word);
+
+	global_adapter = adapter;
+	spin_unlock(&global_adapter_spinlock);
+
+	printk("GCU:Intel(R) GCU Initialized\n");
+
+	return 0;
+}
+
+
+/**
+ * gcu_probe_err - gcu_probe error handler
+ * @err: gcu_err_type
+ *
+ * encapsulated error handling for gcu_probe
+ **/
+static void
+gcu_probe_err(enum gcu_err_type err, struct pci_dev *pdev,
+			  struct gcu_adapter *adapter)
+{
+
+	switch(err) {
+	case err_ioremap:
+		iounmap(adapter->hw_addr);
+		pci_release_regions(pdev);
+	case err_alloc_gcu_adapter:
+	default:
+    	free_gcu_adapter(adapter);
+		break;
+	}
+}
+
+
+/**
+ * gcu_remove - Device Removal Routine
+ * @pdev: PCI device information struct
+ *
+ * gcu_remove is called by the PCI subsystem to alert the driver
+ * that it should release a PCI device.  The could be caused by a
+ * Hot-Plug event, or because the driver is going to be removed from
+ * memory.
+ **/
+static void __devexit
+gcu_remove(struct pci_dev *pdev)
+{
+	struct gcu_adapter *adapter = pci_get_drvdata(pdev);
+
+	GCU_DBG("%s\n", __func__);
+
+	iounmap(adapter->hw_addr);
+	pci_release_regions(pdev);
+	free_gcu_adapter(adapter);
+	pci_set_drvdata(pdev, NULL);
+}
+
+static int
+gcu_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
+{
+	struct pci_dev *pdev = NULL;
+
+	GCU_DBG("%s\n", __func__);
+
+	switch(event) {
+	case SYS_DOWN:
+	case SYS_HALT:
+	case SYS_POWER_OFF:
+		while((pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev))) {
+			if(pci_dev_driver(pdev) == &gcu_driver)
+				gcu_suspend(pdev, 3);
+		}
+	}
+	return NOTIFY_DONE;
+}
+
+
+/**
+ * gcu_suspend - device sleep function
+ * @pdev: PCI device information struct
+ *
+ * gcu_supend is generally called to place a device in sleep mode,
+ * however the GCU doesn't support power mangement. For this case,
+ * it is part of the gcu_notify_reboot() call chain to quiese the
+ * device before a reboot.
+ **/
+static int
+gcu_suspend(struct pci_dev *pdev, uint32_t state)
+{
+	//struct gcu_adapter *adapter = pci_get_drvdata(pdev);
+
+	GCU_DBG("%s\n", __func__);
+
+	pci_save_state(pdev);
+
+	pci_disable_device(pdev);
+
+	state = (state > 0) ? 0 : 0;
+
+	/*
+	 * GCU doesn't support power management, but want to
+	 * leave a hook incase that situation changes in the future
+	 *
+	 * pci_set_power_state(pdev, state);
+	 *
+	 */
+
+	return state;
+}
+
+
+/**
+ * alloc_gcu_adapter
+ *
+ * alloc_gcu_adapter is a wrapper for the kmalloc call for the
+ * device specific data block plus inits the global_adapter variable.
+ *
+ * Note that this function assumes that the spinlock for the global
+ * gcu_adapter struct as been acquired.
+ **/
+static struct gcu_adapter * alloc_gcu_adapter()
+{
+	struct gcu_adapter *adapter;
+
+	GCU_DBG("%s\n", __func__);
+
+	adapter = (struct gcu_adapter*) kmalloc(sizeof(*adapter), GFP_KERNEL);
+
+	global_adapter = adapter;
+
+	if(!adapter) {
+		GCU_DBG("Unable to allocate space for global gcu_adapter");
+		return 0;
+	}
+
+	memset(adapter, 0, sizeof(*adapter));
+
+	return adapter;
+}
+
+
+/**
+ * free_gcu_adapter
+ * @adapter: gcu_adapter struct to be free'd
+ *
+ * free_gcu_adapter is a wrapper for the kfree call for the
+ * device specific data block plus clears the global_adapter variable
+ *
+ * Note that this function assumes that the spinlock for the global
+ * gcu_adapter struct as been acquired.
+ **/
+static void
+free_gcu_adapter(struct gcu_adapter *adapter)
+{
+	GCU_DBG("%s\n", __func__);
+
+	global_adapter = 0;
+
+	if(adapter)
+    	kfree(adapter);
+}
+
+
+/**
+ * gcu_get_adapter
+ *
+ * gcu_get_adapter is used by the functions exported in gcu_if.c to get
+ * access to the memory addresses needed to access the MMIO registers
+ * of the GCU
+ **/
+const struct gcu_adapter *
+gcu_get_adapter(void)
+{
+	GCU_DBG("%s\n", __func__);
+
+	if(global_adapter == NULL)
+	{
+	    GCU_DBG("global gcu_adapter is not available\n");
+	    	return NULL;
+	}
+
+	spin_lock(&global_adapter_spinlock);
+
+	return global_adapter;
+}
+
+/**
+ * gcu_release_adapter
+ *
+ * gcu_release_adapter is used by the functions exported in gcu_if.c to get
+ * release the adapter spinlock and the handle to the adapter
+ **/
+void
+gcu_release_adapter(const struct gcu_adapter **adapter)
+{
+	GCU_DBG("%s\n", __func__);
+
+	if(adapter == NULL)
+	{
+	    GCU_ERR("global gcu_adapter handle is invalid\n");
+	}
+	else
+	{
+		*adapter = 0;
+	}
+
+	spin_unlock(&global_adapter_spinlock);
+
+	return;
+}
diff --git a/drivers/misc/gcu/gcu_reg.h b/drivers/misc/gcu/gcu_reg.h
new file mode 100644
index 0000000..6f7f961
--- /dev/null
+++ b/drivers/misc/gcu/gcu_reg.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+ version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+******************************************************************************/
+
+/*
+ * gcu_reg.h
+ * Macros and constants related to the registers available on the GCU
+ */
+
+#ifndef __GCU_REG_H__
+#define __GCU_REG_H__
+
+/* Register Offsets within memory map register space */
+#define MDIO_STATUS_REG    0x00000010UL
+#define MDIO_COMMAND_REG   0x00000014UL
+
+/* MDIO_STATUS_REG fields */
+#define MDIO_STATUS_STATUS_MASK     0x80000000UL  /* bit 31 = 1 on error */
+#define MDIO_STATUS_READ_DATA_MASK  0x0000FFFFUL
+
+/* MDIO_COMMAND_REG fields */
+#define MDIO_COMMAND_GO_MASK         0x80000000UL /* bit 31 = 1 during read or
+                                                   * write, 0 on completion */
+#define MDIO_COMMAND_OPER_MASK       0x04000000UL /* bit = 1 is  a write */
+#define MDIO_COMMAND_PHY_ADDR_MASK   0x03E00000UL
+#define MDIO_COMMAND_PHY_REG_MASK    0x001F0000UL
+#define MDIO_COMMAND_WRITE_DATA_MASK 0x0000FFFFUL
+
+#define MDIO_COMMAND_GO_OFFSET         31
+#define MDIO_COMMAND_OPER_OFFSET       26
+#define MDIO_COMMAND_PHY_ADDR_OFFSET   21
+#define MDIO_COMMAND_PHY_REG_OFFSET    16
+#define MDIO_COMMAND_WRITE_DATA_OFFSET 0
+
+#define MDIO_COMMAND_PHY_ADDR_MAX      2  /* total phys supported by GCU */
+#define MDIO_COMMAND_PHY_REG_MAX       31 /* total registers available on
+                                           * the M88 Phy used on truxton */
+
+#endif /* ifndef __GCU_REG_H__ */
+
-- 
1.5.6.rc1

