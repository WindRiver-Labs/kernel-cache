From 2a07fd175b2a1ea8174329c54a12647c9921fcd1 Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Thu, 18 Dec 2008 16:11:57 +0800
Subject: [PATCH] intel_truxton: modify tolapai E1000 Net Driver

The driver is based on original e1000 net driver, and add GCU MDIO support.
If want to use the driver on tolapai board, must depend on GCU driver.

It is distilled from GbE driver included in Intel-provided SDK V0.7.18 for
Intel Truxton.

Signed-off-by: Li Wang <li.wang@windriver.com>
---
 drivers/net/e1000/Makefile        |    2 +-
 drivers/net/e1000/e1000.h         |    1 +
 drivers/net/e1000/e1000_ethtool.c |   48 +-
 drivers/net/e1000/e1000_hw.c      |  332 +++++++--
 drivers/net/e1000/e1000_hw.h      |  170 +++++-
 drivers/net/e1000/e1000_main.c    |  259 +++++++-
 drivers/net/e1000/e1000_oem_phy.c | 1494 +++++++++++++++++++++++++++++++++++++
 drivers/net/e1000/e1000_oem_phy.h |   89 +++
 drivers/net/e1000/e1000_param.c   |    6 +
 9 files changed, 2338 insertions(+), 63 deletions(-)
 create mode 100644 drivers/net/e1000/e1000_oem_phy.c
 create mode 100644 drivers/net/e1000/e1000_oem_phy.h

diff --git a/drivers/net/e1000/Makefile b/drivers/net/e1000/Makefile
index 4a6ab15..3dc1c19 100644
--- a/drivers/net/e1000/Makefile
+++ b/drivers/net/e1000/Makefile
@@ -32,4 +32,4 @@
 
 obj-$(CONFIG_E1000) += e1000.o
 
-e1000-objs := e1000_main.o e1000_hw.o e1000_ethtool.o e1000_param.o
+e1000-objs := e1000_main.o e1000_hw.o e1000_ethtool.o e1000_param.o e1000_oem_phy.o
diff --git a/drivers/net/e1000/e1000.h b/drivers/net/e1000/e1000.h
index 19e317e..e31c3d8 100644
--- a/drivers/net/e1000/e1000.h
+++ b/drivers/net/e1000/e1000.h
@@ -80,6 +80,7 @@
 struct e1000_adapter;
 
 #include "e1000_hw.h"
+#include "e1000_oem_phy.h"
 
 #ifdef DBG
 #define E1000_DBG(args...) printk(KERN_DEBUG "e1000: " args)
diff --git a/drivers/net/e1000/e1000_ethtool.c b/drivers/net/e1000/e1000_ethtool.c
index c854c96..913dfea 100644
--- a/drivers/net/e1000/e1000_ethtool.c
+++ b/drivers/net/e1000/e1000_ethtool.c
@@ -105,7 +105,8 @@ static int e1000_get_settings(struct net_device *netdev,
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
 
-	if (hw->media_type == e1000_media_type_copper) {
+	if ((hw->media_type == e1000_media_type_copper) ||
+		(hw->media_type == e1000_media_type_oem)) {
 
 		ecmd->supported = (SUPPORTED_10baseT_Half |
 		                   SUPPORTED_10baseT_Full |
@@ -267,8 +268,10 @@ static int e1000_set_pauseparam(struct net_device *netdev,
 		} else
 			e1000_reset(adapter);
 	} else
-		retval = ((hw->media_type == e1000_media_type_fiber) ?
-			  e1000_setup_link(hw) : e1000_force_mac_fc(hw));
+		retval = ((hw->media_type == e1000_media_type_fiber)
+			|| (hw->media_type == e1000_media_type_oem
+				&& !e1000_oem_phy_is_copper(&adapter->hw)) ?
+				e1000_setup_link(hw) : e1000_force_mac_fc(hw));
 
 	clear_bit(__E1000_RESETTING, &adapter->flags);
 	return retval;
@@ -421,6 +424,8 @@ static void e1000_get_regs(struct net_device *netdev, struct ethtool_regs *regs,
 		regs_buff[22] = 0; /* phy receive errors (unavailable) */
 		regs_buff[23] = regs_buff[18]; /* mdix mode */
 		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
+	} else if (hw->phy_type == e1000_phy_oem) {
+		e1000_oem_get_phy_regs(adapter, &regs_buff[13], 11);
 	} else {
 		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
 		regs_buff[13] = (u32)phy_data; /* cable length */
@@ -839,7 +844,8 @@ static int e1000_reg_test(struct e1000_adapter *adapter, u64 *data)
 
 		REG_SET_AND_CHECK(RCTL, before, 0xFFFFFFFF);
 		REG_PATTERN_TEST(RDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
-		if (hw->mac_type != e1000_ich8lan)
+		if (adapter->hw.mac_type != e1000_ich8lan
+			&& adapter->hw.mac_type != e1000_icp_xxxx)
 			REG_PATTERN_TEST(TXCW, 0xC000FFFF, 0x0000FFFF);
 		REG_PATTERN_TEST(TDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
 		REG_PATTERN_TEST(TIDV, 0x0000FFFF, 0x0000FFFF);
@@ -1381,6 +1387,10 @@ static int e1000_set_phy_loopback(struct e1000_adapter *adapter)
 		return e1000_integrated_phy_loopback(adapter);
 		break;
 
+	case e1000_icp_xxxx:
+		return e1000_oem_phy_loopback(adapter);
+		break;
+
 	default:
 		/* Default PHY loopback work is to read the MII
 		 * control register and assert bit 14 (loopback mode).
@@ -1423,7 +1433,9 @@ static int e1000_setup_loopback_test(struct e1000_adapter *adapter)
 			ew32(RCTL, rctl);
 			return 0;
 		}
-	} else if (hw->media_type == e1000_media_type_copper)
+	} else if (adapter->hw.media_type == e1000_media_type_copper
+			|| (adapter->hw.media_type == e1000_media_type_oem
+			&& e1000_oem_phy_is_copper(&adapter->hw)))
 		return e1000_set_phy_loopback(adapter);
 
 	return 7;
@@ -1609,8 +1621,26 @@ static int e1000_link_test(struct e1000_adapter *adapter, u64 *data)
 		if (hw->autoneg)  /* if auto_neg is set wait for it */
 			msleep(4000);
 
-		if (!(er32(STATUS) & E1000_STATUS_LU)) {
-			*data = 1;
+		/*
+		 * ICP_XXXX style MAC's do not have a link up bit int the STATUS
+		 * register, so query the PHY directly
+		 */
+		if (adapter->hw.mac_type != e1000_icp_xxxx) {
+			if (!(E1000_READ_REG_ARRAY(&adapter->hw, STATUS, 0) &
+				E1000_STATUS_LU))
+				*data = 1;
+		} else {
+			int isUp = 0;
+			if (e1000_oem_phy_is_link_up(&adapter->hw, &isUp) !=
+				E1000_SUCCESS) {
+				printk(KERN_WARNING
+					"unable to determine Link Status!\n");
+			} else {
+				if (isUp)
+					*data = 0;
+				else
+					*data = 1;
+			}
 		}
 	}
 	return *data;
@@ -1869,6 +1899,10 @@ static int e1000_phys_id(struct net_device *netdev, u32 data)
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
 
+	if (adapter->hw.mac_type == e1000_icp_xxxx)
+		/* No LED control on ICP family of gigE controllers */
+		return 0;
+
 	if (!data)
 		data = INT_MAX;
 
diff --git a/drivers/net/e1000/e1000_hw.c b/drivers/net/e1000/e1000_hw.c
index d04eef5..65324a9 100644
--- a/drivers/net/e1000/e1000_hw.c
+++ b/drivers/net/e1000/e1000_hw.c
@@ -31,6 +31,7 @@
  */
 
 
+#include "e1000_oem_phy.h"
 #include "e1000_hw.h"
 
 static s32 e1000_swfw_sync_acquire(struct e1000_hw *hw, u16 mask);
@@ -113,7 +114,6 @@ static void e1000_phy_init_script(struct e1000_hw *hw);
 static s32 e1000_setup_copper_link(struct e1000_hw *hw);
 static s32 e1000_setup_fiber_serdes_link(struct e1000_hw *hw);
 static s32 e1000_adjust_serdes_amplitude(struct e1000_hw *hw);
-static s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw);
 static s32 e1000_config_mac_to_phy(struct e1000_hw *hw);
 static void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl);
 static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl);
@@ -434,6 +434,20 @@ s32 e1000_set_mac_type(struct e1000_hw *hw)
 	case E1000_DEV_ID_ICH8_IGP_M:
 		hw->mac_type = e1000_ich8lan;
 		break;
+	case E1000_DEV_ID_ICP_5040:
+	case E1000_DEV_ID_ICP_5041:
+	case E1000_DEV_ID_ICP_5042:
+	case E1000_DEV_ID_ICP_5043:
+	case E1000_DEV_ID_ICP_5044:
+	case E1000_DEV_ID_ICP_5045:
+	case E1000_DEV_ID_ICP_5046:
+	case E1000_DEV_ID_ICP_5047:
+	case E1000_DEV_ID_ICP_5048:
+	case E1000_DEV_ID_ICP_5049:
+	case E1000_DEV_ID_ICP_504A:
+	case E1000_DEV_ID_ICP_504B:
+		hw->mac_type = e1000_icp_xxxx;
+		break;
 	default:
 		/* Should never have loaded on this device */
 		return -E1000_ERR_MAC_TYPE;
@@ -510,6 +524,20 @@ void e1000_set_media_type(struct e1000_hw *hw)
     case E1000_DEV_ID_80003ES2LAN_SERDES_DPT:
         hw->media_type = e1000_media_type_internal_serdes;
         break;
+    case E1000_DEV_ID_ICP_5040:
+    case E1000_DEV_ID_ICP_5041:
+    case E1000_DEV_ID_ICP_5042:
+    case E1000_DEV_ID_ICP_5043:
+    case E1000_DEV_ID_ICP_5044:
+    case E1000_DEV_ID_ICP_5045:
+    case E1000_DEV_ID_ICP_5046:
+    case E1000_DEV_ID_ICP_5047:
+    case E1000_DEV_ID_ICP_5048:
+    case E1000_DEV_ID_ICP_5049:
+    case E1000_DEV_ID_ICP_504A:
+    case E1000_DEV_ID_ICP_504B:
+        hw->media_type = e1000_media_type_oem;
+        break;
     default:
         switch (hw->mac_type) {
         case e1000_82542_rev2_0:
@@ -598,6 +626,13 @@ s32 e1000_reset_hw(struct e1000_hw *hw)
         msleep(5);
     }
 
+    if (hw->phy_type == e1000_phy_oem &&
+        e1000_oem_phy_needs_reset_with_mac(hw)) {
+        ret_val = e1000_oem_phy_hw_reset(hw);
+        if (ret_val)
+            return ret_val;
+    }
+
     /* Must acquire the MDIO ownership before MAC reset.
      * Ownership defaults to firmware after a reset. */
     if (hw->mac_type == e1000_82573) {
@@ -713,7 +748,9 @@ s32 e1000_reset_hw(struct e1000_hw *hw)
     }
 
     /* Disable HW ARPs on ASF enabled adapters */
-    if (hw->mac_type >= e1000_82540 && hw->mac_type <= e1000_82547_rev_2) {
+    if (hw->mac_type >= e1000_82540 &&
+        hw->mac_type <= e1000_82547_rev_2 &&
+        hw->mac_type != e1000_icp_xxxx) {
         manc = er32(MANC);
         manc &= ~(E1000_MANC_ARP_EN);
         ew32(MANC, manc);
@@ -729,6 +766,11 @@ s32 e1000_reset_hw(struct e1000_hw *hw)
         ew32(LEDCTL, led_ctrl);
     }
 
+    /* default configure the oem phy */
+    if (hw->phy_type == e1000_phy_oem &&
+		e1000_oem_phy_needs_reset_with_mac(hw))
+        e1000_oem_phy_init_script(hw);
+
     /* Clear interrupt mask to stop board from generating interrupts */
     DEBUGOUT("Masking off all interrupts\n");
     ew32(IMC, 0xffffffff);
@@ -1115,6 +1157,7 @@ s32 e1000_setup_link(struct e1000_hw *hw)
     u32 ctrl_ext;
     s32 ret_val;
     u16 eeprom_data;
+    u16 eeprom_control2_reg_offset = 0;
 
     DEBUGFUNC("e1000_setup_link");
 
@@ -1123,6 +1166,15 @@ s32 e1000_setup_link(struct e1000_hw *hw)
     if (e1000_check_phy_reset_block(hw))
         return E1000_SUCCESS;
 
+    /*
+     * for icp_xxxx style controllers, the init control 2 and 3 are packed into
+     * a single word, with the top byte being occupied by control 2
+     */
+    eeprom_control2_reg_offset =
+        hw->mac_type != e1000_icp_xxxx
+        ? EEPROM_INIT_CONTROL2_REG
+        : EEPROM_INIT_CONTROL3_ICP_xxxx(e1000_oem_get_phy_dev_number(hw));
+
     /* Read and store word 0x0F of the EEPROM. This word contains bits
      * that determine the hardware's default PAUSE (flow control) mode,
      * a bit that determines whether the HW defaults to enabling or
@@ -1138,7 +1190,7 @@ s32 e1000_setup_link(struct e1000_hw *hw)
             hw->fc = E1000_FC_FULL;
             break;
         default:
-            ret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
+            ret_val = e1000_read_eeprom(hw, eeprom_control2_reg_offset,
                                         1, &eeprom_data);
             if (ret_val) {
                 DEBUGOUT("EEPROM Read Error\n");
@@ -1189,9 +1241,17 @@ s32 e1000_setup_link(struct e1000_hw *hw)
     }
 
     /* Call the necessary subroutine to configure the link. */
-    ret_val = (hw->media_type == e1000_media_type_copper) ?
-              e1000_setup_copper_link(hw) :
-              e1000_setup_fiber_serdes_link(hw);
+    switch (hw->media_type) {
+    case e1000_media_type_copper:
+        ret_val = e1000_setup_copper_link(hw);
+        break;
+    case e1000_media_type_oem:
+        ret_val = e1000_oem_setup_link(hw);
+        break;
+    default:
+        ret_val = e1000_setup_fiber_serdes_link(hw);
+    break;
+    }
 
     /* Initialize the flow control address, type, and PAUSE timer
      * registers to their default values.  This is done even if flow
@@ -1356,8 +1416,18 @@ static s32 e1000_setup_fiber_serdes_link(struct e1000_hw *hw)
         DEBUGOUT("Looking for Link\n");
         for (i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
             msleep(10);
-            status = er32(STATUS);
-            if (status & E1000_STATUS_LU) break;
+            if (hw->mac_type != e1000_icp_xxxx) {
+                status = E1000_READ_REG_ARRAY(hw, STATUS, 0);
+                if (status & E1000_STATUS_LU)
+                    break;
+            } else {
+                int isUp = 0;
+                if (e1000_oem_phy_is_link_up(hw, &isUp) != E1000_SUCCESS)
+                        isUp = 0;
+
+                if (isUp)
+                    break;
+            }
         }
         if (i == (LINK_UP_TIMEOUT / 10)) {
             DEBUGOUT("Never got a valid link from auto-neg!!!\n");
@@ -1843,7 +1913,7 @@ static s32 e1000_copper_link_mgp_setup(struct e1000_hw *hw)
 *
 * hw - Struct containing variables accessed by shared code
 *********************************************************************/
-static s32 e1000_copper_link_autoneg(struct e1000_hw *hw)
+s32 e1000_copper_link_autoneg(struct e1000_hw *hw)
 {
     s32 ret_val;
     u16 phy_data;
@@ -1913,12 +1983,12 @@ static s32 e1000_copper_link_autoneg(struct e1000_hw *hw)
 *
 * hw - Struct containing variables accessed by shared code
 ******************************************************************************/
-static s32 e1000_copper_link_postconfig(struct e1000_hw *hw)
+s32 e1000_copper_link_postconfig(struct e1000_hw *hw)
 {
     s32 ret_val;
     DEBUGFUNC("e1000_copper_link_postconfig");
 
-    if (hw->mac_type >= e1000_82544) {
+    if (hw->mac_type >= e1000_82544 && hw->mac_type != e1000_icp_xxxx) {
         e1000_config_collision_dist(hw);
     } else {
         ret_val = e1000_config_mac_to_phy(hw);
@@ -1942,6 +2012,13 @@ static s32 e1000_copper_link_postconfig(struct e1000_hw *hw)
         }
     }
 
+    /* Config DSP to improve Giga link quality */
+    if (hw->phy_type == e1000_phy_oem) {
+        ret_val = e1000_oem_config_dsp_after_link_change(hw, true);
+        if (ret_val)
+            return ret_val;
+    }
+
     return E1000_SUCCESS;
 }
 
@@ -2282,7 +2359,7 @@ s32 e1000_phy_setup_autoneg(struct e1000_hw *hw)
 *
 * hw - Struct containing variables accessed by shared code
 ******************************************************************************/
-static s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)
+s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)
 {
     u32 ctrl;
     s32 ret_val;
@@ -2290,6 +2367,7 @@ static s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)
     u16 mii_status_reg;
     u16 phy_data;
     u16 i;
+    bool resetPhy = false;
 
     DEBUGFUNC("e1000_phy_force_speed_duplex");
 
@@ -2388,6 +2466,16 @@ static s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)
         if (ret_val)
             return ret_val;
 
+    } else if (hw->phy_type == e1000_phy_oem) {
+        ret_val = e1000_oem_force_mdi(hw, (int *)&resetPhy);
+        if (ret_val)
+            return ret_val;
+
+        if (resetPhy) {
+            ret_val = e1000_oem_phy_hw_reset(hw);
+            if (ret_val)
+                return ret_val;
+        }
     } else {
         /* Clear Auto-Crossover to force MDI manually.  IGP requires MDI
          * forced whenever speed or duplex are forced.
@@ -2449,6 +2537,12 @@ static s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)
                 return ret_val;
             }
         }
+        if (i == 0 && hw->phy_type == e1000_phy_oem) {
+            /* We didn't get link.  Reset the DSP and wait again for link. */
+            ret_val = e1000_oem_phy_reset_dsp(hw);
+            if (ret_val)
+                return ret_val;
+        }
         /* This loop will early-out if the link condition has been met.  */
         for (i = PHY_FORCE_TIME; i > 0; i--) {
             if (mii_status_reg & MII_SR_LINK_STATUS) break;
@@ -2518,6 +2612,8 @@ static s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)
         phy_data |= GG82563_MSCR_ASSERT_CRS_ON_TX;
 
         ret_val = e1000_write_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL, phy_data);
+        if (hw->phy_type == e1000_phy_oem && resetPhy)
+            ret_val = e1000_oem_cleanup_after_phy_reset(hw);
         if (ret_val)
             return ret_val;
     }
@@ -2565,13 +2661,16 @@ static s32 e1000_config_mac_to_phy(struct e1000_hw *hw)
 {
     u32 ctrl;
     s32 ret_val;
-    u16 phy_data;
+    u16 phy_data = 0;
+    bool is_FullDuplex = false;
+    bool is_1000MBS = false;
+    bool is_100MBS = false;
 
     DEBUGFUNC("e1000_config_mac_to_phy");
 
     /* 82544 or newer MAC, Auto Speed Detection takes care of
     * MAC speed/duplex configuration.*/
-    if (hw->mac_type >= e1000_82544)
+    if (hw->mac_type >= e1000_82544 && hw->mac_type != e1000_icp_xxxx)
         return E1000_SUCCESS;
 
     /* Read the Device Control Register and set the bits to Force Speed
@@ -2584,11 +2683,28 @@ static s32 e1000_config_mac_to_phy(struct e1000_hw *hw)
     /* Set up duplex in the Device Control and Transmit Control
      * registers depending on negotiated values.
      */
-    ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
-    if (ret_val)
-        return ret_val;
+    if (hw->phy_type == e1000_phy_oem) {
+        ret_val = e1000_oem_phy_is_full_duplex(hw, (int *)&is_FullDuplex);
+        if (ret_val)
+            return ret_val;
+
+        ret_val = e1000_oem_phy_is_speed_1000(hw, (int *) &is_1000MBS);
+        if (ret_val)
+            return ret_val;
+
+        ret_val = e1000_oem_phy_is_speed_100(hw, (int *) &is_100MBS);
+        if (ret_val)
+            return ret_val;
+    } else {
+        ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+        if (ret_val)
+            return ret_val;
+        is_FullDuplex = phy_data & M88E1000_PSSR_DPLX;
+        is_1000MBS = (phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS;
+        is_100MBS = (phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS;
+    }
 
-    if (phy_data & M88E1000_PSSR_DPLX)
+    if (is_FullDuplex)
         ctrl |= E1000_CTRL_FD;
     else
         ctrl &= ~E1000_CTRL_FD;
@@ -2598,9 +2714,9 @@ static s32 e1000_config_mac_to_phy(struct e1000_hw *hw)
     /* Set up speed in the Device Control register depending on
      * negotiated values.
      */
-    if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
+    if (is_1000MBS)
         ctrl |= E1000_CTRL_SPD_1000;
-    else if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
+    else if (is_100MBS)
         ctrl |= E1000_CTRL_SPD_100;
 
     /* Write the configured values back to the Device Control Reg. */
@@ -2703,7 +2819,13 @@ static s32 e1000_config_fc_after_link_up(struct e1000_hw *hw)
     if (((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed)) ||
         ((hw->media_type == e1000_media_type_internal_serdes) &&
          (hw->autoneg_failed)) ||
-        ((hw->media_type == e1000_media_type_copper) && (!hw->autoneg))) {
+        ((hw->media_type == e1000_media_type_copper) && (!hw->autoneg)) ||
+        ((hw->media_type == e1000_media_type_oem)
+            && !e1000_oem_phy_is_copper(hw)
+            && (hw->autoneg_failed)) ||
+        ((hw->media_type == e1000_media_type_oem)
+            && e1000_oem_phy_is_copper(hw)
+            && (!hw->autoneg))) {
         ret_val = e1000_force_mac_fc(hw);
         if (ret_val) {
             DEBUGOUT("Error forcing flow control settings\n");
@@ -2716,7 +2838,10 @@ static s32 e1000_config_fc_after_link_up(struct e1000_hw *hw)
      * has completed, and if so, how the PHY and link partner has
      * flow control configured.
      */
-    if ((hw->media_type == e1000_media_type_copper) && hw->autoneg) {
+    if ((hw->media_type == e1000_media_type_copper ||
+        (hw->media_type == e1000_media_type_oem
+		&& e1000_oem_phy_is_copper(hw)))
+        && hw->autoneg) {
         /* Read the MII Status Register and check to see if AutoNeg
          * has completed.  We read this twice because this reg has
          * some "sticky" (latched) bits.
@@ -2910,13 +3035,17 @@ s32 e1000_check_for_link(struct e1000_hw *hw)
      * cleared when there is a signal.  This applies to fiber media only.
      */
     if ((hw->media_type == e1000_media_type_fiber) ||
-        (hw->media_type == e1000_media_type_internal_serdes)) {
+        (hw->media_type == e1000_media_type_internal_serdes) ||
+        (hw->media_type == e1000_media_type_oem &&
+        !e1000_oem_phy_is_copper(hw))) {
         rxcw = er32(RXCW);
 
         if (hw->media_type == e1000_media_type_fiber) {
             signal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;
-            if (status & E1000_STATUS_LU)
-                hw->get_link_status = false;
+            if (hw->mac_type != e1000_icp_xxxx) {
+                if (status & E1000_STATUS_LU)
+                    hw->get_link_status = false;
+            }
         }
     }
 
@@ -2926,7 +3055,10 @@ s32 e1000_check_for_link(struct e1000_hw *hw)
      * receive a Link Status Change interrupt or we have Rx Sequence
      * Errors.
      */
-    if ((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {
+    if ((hw->media_type == e1000_media_type_copper ||
+        (hw->media_type == e1000_media_type_oem
+		&& e1000_oem_phy_is_copper(hw)))
+        && hw->get_link_status) {
         /* First we want to see if the MII Status Register reports
          * link.  If so, then we want to get the current speed/duplex
          * of the PHY.
@@ -2939,6 +3071,8 @@ s32 e1000_check_for_link(struct e1000_hw *hw)
         if (ret_val)
             return ret_val;
 
+        hw->icp_xxxx_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;
+
         if (phy_data & MII_SR_LINK_STATUS) {
             hw->get_link_status = false;
             /* Check if there was DownShift, must be checked immediately after
@@ -2967,6 +3101,8 @@ s32 e1000_check_for_link(struct e1000_hw *hw)
         } else {
             /* No link detected */
             e1000_config_dsp_after_link_change(hw, false);
+            if (hw->phy_type == e1000_phy_oem)
+                e1000_oem_config_dsp_after_link_change(hw, false);
             return 0;
         }
 
@@ -2978,6 +3114,9 @@ s32 e1000_check_for_link(struct e1000_hw *hw)
         /* optimize the dsp settings for the igp phy */
         e1000_config_dsp_after_link_change(hw, true);
 
+        if (hw->phy_type == e1000_phy_oem)
+            e1000_oem_config_dsp_after_link_change(hw, true);
+
         /* We have a M88E1000 PHY and Auto-Neg is enabled.  If we
          * have Si on board that is 82544 or newer, Auto
          * Speed Detection takes care of MAC speed/duplex
@@ -2985,8 +3124,10 @@ s32 e1000_check_for_link(struct e1000_hw *hw)
          * Distance in the MAC.  Otherwise, we need to force
          * speed/duplex on the MAC to the current PHY speed/duplex
          * settings.
+         * On ICP_XXXX style MACs, it is still necessary update
+         * the MAC to match the PHY configuration
          */
-        if (hw->mac_type >= e1000_82544)
+        if (hw->mac_type >= e1000_82544 && hw->mac_type != e1000_icp_xxxx)
             e1000_config_collision_dist(hw);
         else {
             ret_val = e1000_config_mac_to_phy(hw);
@@ -3055,27 +3196,41 @@ s32 e1000_check_for_link(struct e1000_hw *hw)
      */
     else if ((((hw->media_type == e1000_media_type_fiber) &&
               ((ctrl & E1000_CTRL_SWDPIN1) == signal)) ||
-              (hw->media_type == e1000_media_type_internal_serdes)) &&
-              (!(status & E1000_STATUS_LU)) &&
+              (hw->media_type == e1000_media_type_internal_serdes) ||
+              (hw->media_type == e1000_media_type_oem &&
+               !e1000_oem_phy_is_copper(hw))) &&
               (!(rxcw & E1000_RXCW_C))) {
-        if (hw->autoneg_failed == 0) {
-            hw->autoneg_failed = 1;
-            return 0;
+        int isUp = 0;
+
+        /*
+         * ICP_XXXX style MACs do not have a link up bit in the STATUS
+         * register, so check the PHY directly
+         */
+        if (hw->mac_type == e1000_icp_xxxx) {
+            ret_val = e1000_oem_phy_is_link_up(hw, &isUp);
+            if (ret_val)
+                return ret_val;
+        } else {
+            isUp = status & E1000_STATUS_LU;
         }
-        DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\n");
+
+        if (!isUp) {
+            if (hw->autoneg_failed == 0) {
+                hw->autoneg_failed = 1;
+                return 0;
+            }
 
         /* Disable auto-negotiation in the TXCW register */
-        ew32(TXCW, (hw->txcw & ~E1000_TXCW_ANE));
+        E1000_WRITE_REG_ARRAY(hw, TXCW, 0, (hw->txcw & ~E1000_TXCW_ANE));
 
         /* Force link-up and also force full-duplex. */
-        ctrl = er32(CTRL);
+        ctrl = E1000_READ_REG_ARRAY(hw, CTRL, 0);
         ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
-        ew32(CTRL, ctrl);
+        E1000_WRITE_REG_ARRAY(hw, CTRL, 0, ctrl);
 
         /* Configure Flow Control after forcing link up. */
         ret_val = e1000_config_fc_after_link_up(hw);
-        if (ret_val) {
-            DEBUGOUT("Error configuring flow control\n");
+        if (ret_val)
             return ret_val;
         }
     }
@@ -3085,7 +3240,9 @@ s32 e1000_check_for_link(struct e1000_hw *hw)
      * partner.
      */
     else if (((hw->media_type == e1000_media_type_fiber) ||
-              (hw->media_type == e1000_media_type_internal_serdes)) &&
+              (hw->media_type == e1000_media_type_internal_serdes) ||
+              (hw->media_type == e1000_media_type_oem
+			&& !e1000_oem_phy_is_copper(hw))) &&
               (ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {
         DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\n");
         ew32(TXCW, hw->txcw);
@@ -3112,7 +3269,22 @@ s32 e1000_check_for_link(struct e1000_hw *hw)
     }
     if ((hw->media_type == e1000_media_type_internal_serdes) &&
         (E1000_TXCW_ANE & er32(TXCW))) {
-        hw->serdes_link_down = !(E1000_STATUS_LU & er32(STATUS));
+       /*
+        * ICP_XXXX style MACs do not have a link up bit in the STATUS
+        * register, so check the PHY directly
+        */
+       if (hw->mac_type != e1000_icp_xxxx) {
+            hw->serdes_link_down =
+		!(E1000_STATUS_LU & E1000_READ_REG_ARRAY(hw, STATUS, 0));
+       } else {
+           int isUp = 0;
+
+           ret_val = e1000_oem_phy_is_link_up(hw, &isUp);
+           if (ret_val)
+               return ret_val;
+
+           hw->serdes_link_down = !isUp;
+       }
     }
     return E1000_SUCCESS;
 }
@@ -3512,7 +3684,7 @@ static s32 e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
         return -E1000_ERR_PARAM;
     }
 
-    if (hw->mac_type > e1000_82543) {
+    if (hw->mac_type > e1000_82543 && hw->mac_type != e1000_icp_xxxx) {
         /* Set up Op-code, Phy Address, and register address in the MDI
          * Control register.  The MAC will take care of interfacing with the
          * PHY to retrieve the desired data.
@@ -3538,6 +3710,10 @@ static s32 e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
             return -E1000_ERR_PHY;
         }
         *phy_data = (u16)mdic;
+    } else if (hw->mac_type == e1000_icp_xxxx) {
+        int ret_val = e1000_oem_read_phy_reg_ex(hw, reg_addr, phy_data);
+        if (ret_val)
+            return ret_val;
     } else {
         /* We must first send a preamble through the MDIO pin to signal the
          * beginning of an MII instruction.  This is done by sending 32
@@ -3647,7 +3823,7 @@ static s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
         return -E1000_ERR_PARAM;
     }
 
-    if (hw->mac_type > e1000_82543) {
+    if (hw->mac_type > e1000_82543 && hw->mac_type != e1000_icp_xxxx) {
         /* Set up Op-code, Phy Address, register address, and data intended
          * for the PHY register in the MDI Control register.  The MAC will take
          * care of interfacing with the PHY to send the desired data.
@@ -3669,6 +3845,10 @@ static s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
             DEBUGOUT("MDI Write did not complete\n");
             return -E1000_ERR_PHY;
         }
+    } else if (hw->mac_type == e1000_icp_xxxx) {
+        int ret_val = e1000_oem_write_phy_reg_ex(hw, reg_addr, phy_data);
+        if (ret_val)
+            return ret_val;
     } else {
         /* We'll need to use the SW defined pins to shift the write command
          * out to the PHY. We first send a preamble to the PHY to signal the
@@ -3769,6 +3949,14 @@ s32 e1000_phy_hw_reset(struct e1000_hw *hw)
         return E1000_SUCCESS;
 
     DEBUGOUT("Resetting Phy...\n");
+    if (hw->mac_type == e1000_icp_xxxx) {
+        ret_val = e1000_oem_phy_hw_reset(hw);
+        if (ret_val)
+            return ret_val;
+
+        e1000_oem_phy_init_script(hw);
+        return ret_val;
+    }
 
     if (hw->mac_type > e1000_82543) {
         if ((hw->mac_type == e1000_80003es2lan) &&
@@ -3827,6 +4015,9 @@ s32 e1000_phy_hw_reset(struct e1000_hw *hw)
         ew32(LEDCTL, led_ctrl);
     }
 
+    if (hw->phy_type == e1000_phy_oem)
+        e1000_oem_phy_init_script(hw);
+
     /* Wait for FW to finish PHY configuration. */
     ret_val = e1000_get_phy_cfg_done(hw);
     if (ret_val != E1000_SUCCESS)
@@ -3864,6 +4055,7 @@ s32 e1000_phy_reset(struct e1000_hw *hw)
     case e1000_phy_igp_2:
     case e1000_phy_igp_3:
     case e1000_phy_ife:
+    case e1000_phy_oem:
         ret_val = e1000_phy_hw_reset(hw);
         if (ret_val)
             return ret_val;
@@ -4341,7 +4533,9 @@ s32 e1000_phy_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info)
     phy_info->local_rx = e1000_1000t_rx_status_undefined;
     phy_info->remote_rx = e1000_1000t_rx_status_undefined;
 
-    if (hw->media_type != e1000_media_type_copper) {
+    if (hw->media_type != e1000_media_type_copper
+       && (hw->media_type == e1000_media_type_oem
+           && !e1000_oem_phy_is_copper(hw))) {
         DEBUGOUT("PHY info is only valid for copper media\n");
         return -E1000_ERR_CONFIG;
     }
@@ -4365,6 +4559,8 @@ s32 e1000_phy_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info)
         return e1000_phy_igp_get_info(hw, phy_info);
     else if (hw->phy_type == e1000_phy_ife)
         return e1000_phy_ife_get_info(hw, phy_info);
+    else if (hw->phy_type == e1000_phy_oem)
+        return e1000_oem_phy_get_info(hw, phy_info);
     else
         return e1000_phy_m88_get_info(hw, phy_info);
 }
@@ -4414,6 +4610,7 @@ s32 e1000_init_eeprom_params(struct e1000_hw *hw)
     case e1000_82540:
     case e1000_82545:
     case e1000_82545_rev_3:
+    case e1000_icp_xxxx:
     case e1000_82546:
     case e1000_82546_rev_3:
         eeprom->type = e1000_eeprom_microwire;
@@ -5144,6 +5341,9 @@ s32 e1000_validate_eeprom_checksum(struct e1000_hw *hw)
 {
     u16 checksum = 0;
     u16 i, eeprom_data;
+    u16 checksum_reg = hw->mac_type != e1000_icp_xxxx
+                            ? EEPROM_CHECKSUM_REG
+                            : EEPROM_CHECKSUM_REG_ICP_xxxx;
 
     DEBUGFUNC("e1000_validate_eeprom_checksum");
 
@@ -5179,7 +5379,7 @@ s32 e1000_validate_eeprom_checksum(struct e1000_hw *hw)
         }
     }
 
-    for (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
+    for (i = 0; i < (checksum_reg + 1); i++) {
         if (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
             DEBUGOUT("EEPROM Read Error\n");
             return -E1000_ERR_EEPROM;
@@ -5208,6 +5408,9 @@ s32 e1000_update_eeprom_checksum(struct e1000_hw *hw)
     u32 ctrl_ext;
     u16 checksum = 0;
     u16 i, eeprom_data;
+    u16 checksum_reg = hw->mac_type != e1000_icp_xxxx
+                            ? EEPROM_CHECKSUM_REG
+                            : EEPROM_CHECKSUM_REG_ICP_xxxx;
 
     DEBUGFUNC("e1000_update_eeprom_checksum");
 
@@ -5219,7 +5422,7 @@ s32 e1000_update_eeprom_checksum(struct e1000_hw *hw)
         checksum += eeprom_data;
     }
     checksum = (u16)EEPROM_SUM - checksum;
-    if (e1000_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
+    if (e1000_write_eeprom(hw, checksum_reg, 1, &checksum) < 0) {
         DEBUGOUT("EEPROM Write Error\n");
         return -E1000_ERR_EEPROM;
     } else if (hw->eeprom.type == e1000_eeprom_flash) {
@@ -5624,12 +5827,18 @@ s32 e1000_read_mac_addr(struct e1000_hw *hw)
 {
     u16 offset;
     u16 eeprom_data, i;
+    u16 ia_base_addr = 0;
 
     DEBUGFUNC("e1000_read_mac_addr");
 
+    if (hw->mac_type == e1000_icp_xxxx) {
+        ia_base_addr = (u16)
+                  EEPROM_IA_START_ICP_xxxx(e1000_oem_get_phy_dev_number(hw));
+    }
+
     for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
         offset = i >> 1;
-        if (e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
+        if (e1000_read_eeprom(hw, offset+ia_base_addr, 1, &eeprom_data) < 0) {
             DEBUGOUT("EEPROM Read Error\n");
             return -E1000_ERR_EEPROM;
         }
@@ -5933,7 +6142,7 @@ static s32 e1000_id_led_init(struct e1000_hw *hw)
 
     DEBUGFUNC("e1000_id_led_init");
 
-    if (hw->mac_type < e1000_82540) {
+    if (hw->mac_type < e1000_82540 || hw->mac_type == e1000_icp_xxxx) {
         /* Nothing to do */
         return E1000_SUCCESS;
     }
@@ -6016,6 +6225,7 @@ s32 e1000_setup_led(struct e1000_hw *hw)
     case e1000_82542_rev2_1:
     case e1000_82543:
     case e1000_82544:
+    case e1000_icp_xxxx:
         /* No setup necessary */
         break;
     case e1000_82541:
@@ -6107,6 +6317,7 @@ s32 e1000_cleanup_led(struct e1000_hw *hw)
     case e1000_82542_rev2_1:
     case e1000_82543:
     case e1000_82544:
+    case e1000_icp_xxxx:
         /* No cleanup necessary */
         break;
     case e1000_82541:
@@ -6144,6 +6355,9 @@ s32 e1000_led_on(struct e1000_hw *hw)
     DEBUGFUNC("e1000_led_on");
 
     switch (hw->mac_type) {
+    case e1000_icp_xxxx:
+       /* No LED control on ICP family of gigE controllers */
+       return E1000_SUCCESS;
     case e1000_82542_rev2_0:
     case e1000_82542_rev2_1:
     case e1000_82543:
@@ -6194,6 +6408,9 @@ s32 e1000_led_off(struct e1000_hw *hw)
     DEBUGFUNC("e1000_led_off");
 
     switch (hw->mac_type) {
+    case e1000_icp_xxxx:
+        /* No LED control on ICP family of gigE controllers */
+        return E1000_SUCCESS;
     case e1000_82542_rev2_0:
     case e1000_82542_rev2_1:
     case e1000_82543:
@@ -6308,7 +6525,8 @@ static void e1000_clear_hw_cntrs(struct e1000_hw *hw)
     temp = er32(TSCTC);
     temp = er32(TSCTFC);
 
-    if (hw->mac_type <= e1000_82544) return;
+    if (hw->mac_type <= e1000_82544 || hw->mac_type == e1000_icp_xxxx)
+        return;
 
     temp = er32(MGTPRC);
     temp = er32(MGTPDC);
@@ -6510,6 +6728,11 @@ void e1000_get_bus_info(struct e1000_hw *hw)
         hw->bus_speed = e1000_bus_speed_2500;
         hw->bus_width = e1000_bus_width_pciex_1;
         break;
+    case e1000_icp_xxxx:
+        hw->bus_type = e1000_bus_type_cpp;
+        hw->bus_speed = e1000_bus_speed_unknown;
+        hw->bus_width = e1000_bus_width_unknown;
+        break;
     default:
         status = er32(STATUS);
         hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
@@ -6743,6 +6966,10 @@ static s32 e1000_get_cable_length(struct e1000_hw *hw, u16 *min_length,
         *min_length = ((agc_value - IGP02E1000_AGC_RANGE) > 0) ?
                        (agc_value - IGP02E1000_AGC_RANGE) : 0;
         *max_length = agc_value + IGP02E1000_AGC_RANGE;
+    } else if (hw->phy_type == e1000_phy_oem) {
+        ret_val = e1000_oem_get_cable_length(hw, min_length, max_length);
+        if (ret_val)
+            return ret_val;
     }
 
     return E1000_SUCCESS;
@@ -6820,6 +7047,8 @@ static s32 e1000_check_polarity(struct e1000_hw *hw,
         *polarity = ((phy_data & IFE_PESC_POLARITY_REVERSED) >>
                      IFE_PESC_POLARITY_REVERSED_SHIFT) ?
                      e1000_rev_polarity_reversed : e1000_rev_polarity_normal;
+    } else if (hw->phy_type == e1000_phy_oem) {
+        return e1000_oem_check_polarity(hw, polarity);
     }
     return E1000_SUCCESS;
 }
@@ -6867,6 +7096,13 @@ static s32 e1000_check_downshift(struct e1000_hw *hw)
     } else if (hw->phy_type == e1000_phy_ife) {
         /* e1000_phy_ife supports 10/100 speed only */
         hw->speed_downgraded = false;
+    } else if (hw->phy_type == e1000_phy_oem) {
+        ret_val = e1000_oem_phy_speed_downgraded(hw, &phy_data);
+
+        if (ret_val)
+            return ret_val;
+
+        hw->speed_downgraded = phy_data > 0;
     }
 
     return E1000_SUCCESS;
diff --git a/drivers/net/e1000/e1000_hw.h b/drivers/net/e1000/e1000_hw.h
index 99fce2c..8779f0e 100644
--- a/drivers/net/e1000/e1000_hw.h
+++ b/drivers/net/e1000/e1000_hw.h
@@ -51,6 +51,7 @@ typedef enum {
     e1000_82540,
     e1000_82545,
     e1000_82545_rev_3,
+    e1000_icp_xxxx,
     e1000_82546,
     e1000_82546_rev_3,
     e1000_82541,
@@ -80,6 +81,7 @@ typedef enum {
     e1000_media_type_copper = 0,
     e1000_media_type_fiber = 1,
     e1000_media_type_internal_serdes = 2,
+    e1000_media_type_oem = 3,
     e1000_num_media_types
 } e1000_media_type;
 
@@ -110,6 +112,7 @@ typedef enum {
     e1000_bus_type_pci,
     e1000_bus_type_pcix,
     e1000_bus_type_pci_express,
+    e1000_bus_type_cpp,
     e1000_bus_type_reserved
 } e1000_bus_type;
 
@@ -228,6 +231,7 @@ typedef enum {
     e1000_phy_gg82563,
     e1000_phy_igp_3,
     e1000_phy_ife,
+    e1000_phy_oem,
     e1000_phy_undefined = 0xFF
 } e1000_phy_type;
 
@@ -330,6 +334,8 @@ s32 e1000_phy_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info);
 s32 e1000_validate_mdi_setting(struct e1000_hw *hw);
 
 void e1000_phy_powerdown_workaround(struct e1000_hw *hw);
+s32 e1000_phy_misctst_get_info(struct e1000_hw *hw, u16 *enabled);
+s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw);
 
 /* EEPROM Functions */
 s32 e1000_init_eeprom_params(struct e1000_hw *hw);
@@ -400,6 +406,8 @@ s32 e1000_write_eeprom(struct e1000_hw *hw, u16 reg, u16 words, u16 *data);
 s32 e1000_read_mac_addr(struct e1000_hw * hw);
 
 /* Filters (multicast, vlan, receive) */
+void e1000_mc_addr_list_update(struct e1000_hw *hw, u8 *mc_addr_list,
+				u32 mc_addr_count, u32 pad, u32 rar_used_count);
 u32 e1000_hash_mc_addr(struct e1000_hw *hw, u8 * mc_addr);
 void e1000_mta_set(struct e1000_hw *hw, u32 hash_value);
 void e1000_rar_set(struct e1000_hw *hw, u8 * mc_addr, u32 rar_index);
@@ -425,7 +433,10 @@ s32 e1000_read_pcie_cap_reg(struct e1000_hw *hw, u32 reg, u16 *value);
 void e1000_pcix_set_mmrbc(struct e1000_hw *hw, int mmrbc);
 int e1000_pcix_get_mmrbc(struct e1000_hw *hw);
 /* Port I/O is only supported on 82544 and newer */
+u32 e1000_io_read(struct e1000_hw *hw, unsigned long port);
+u32 e1000_read_reg_io(struct e1000_hw *hw, u32 offset);
 void e1000_io_write(struct e1000_hw *hw, unsigned long port, u32 value);
+void e1000_enable_pciex_master(struct e1000_hw *hw);
 s32 e1000_disable_pciex_master(struct e1000_hw *hw);
 s32 e1000_check_phy_reset_block(struct e1000_hw *hw);
 
@@ -436,6 +447,18 @@ s32 e1000_check_phy_reset_block(struct e1000_hw *hw);
     e1000_write_reg_io((a), E1000_##reg, val)
 
 /* PCI Device IDs */
+/* ICP xxxx Signal Target Capability */
+#define PCI_CAP_ID_ST     0x09
+#define PCI_ST_SCID_MASK  0x000000FF
+#define PCI_ST_SCP_MASK   0x0000FF00
+#define PCI_ST_SBC_MASK   0x00FF0000
+#define PCI_ST_STYP_MASK  0xFF000000
+#define PCI_ST_SMIA_MASK  0x000000FF
+#define PCI_ST_SMACC_MASK 0x0000FF00
+#define PCI_ST_SDATA_MASK 0xFFFF0000
+#define PCI_ST_SMIA_OFFSET 0x00000004
+
+/* IDs */
 #define E1000_DEV_ID_82542               0x1000
 #define E1000_DEV_ID_82543GC_FIBER       0x1001
 #define E1000_DEV_ID_82543GC_COPPER      0x1004
@@ -500,7 +523,22 @@ s32 e1000_check_phy_reset_block(struct e1000_hw *hw);
 #define E1000_DEV_ID_ICH8_IFE_GT         0x10C4
 #define E1000_DEV_ID_ICH8_IFE_G          0x10C5
 #define E1000_DEV_ID_ICH8_IGP_M          0x104D
-
+/*
+ * ICP GbE devices are not assigned Intel part numbers yet so just
+ * identify them via their device id's
+ */
+#define E1000_DEV_ID_ICP_5040            0x5040
+#define E1000_DEV_ID_ICP_5041            0x5041
+#define E1000_DEV_ID_ICP_5042            0x5042
+#define E1000_DEV_ID_ICP_5043            0x5043
+#define E1000_DEV_ID_ICP_5044            0x5044
+#define E1000_DEV_ID_ICP_5045            0x5045
+#define E1000_DEV_ID_ICP_5046            0x5046
+#define E1000_DEV_ID_ICP_5047            0x5047
+#define E1000_DEV_ID_ICP_5048            0x5048
+#define E1000_DEV_ID_ICP_5049            0x5049
+#define E1000_DEV_ID_ICP_504A            0x504A
+#define E1000_DEV_ID_ICP_504B            0x504B
 
 #define NODE_ADDRESS_SIZE 6
 #define ETH_LENGTH_OF_ADDRESS 6
@@ -902,6 +940,7 @@ struct e1000_ffvt_entry {
 #define E1000_IMS      0x000D0  /* Interrupt Mask Set - RW */
 #define E1000_IMC      0x000D8  /* Interrupt Mask Clear - WO */
 #define E1000_IAM      0x000E0  /* Interrupt Acknowledge Auto Mask */
+#define E1000_CTRL_AUX 0x000E0  /* Aux Control -RW */
 #define E1000_RCTL     0x00100  /* RX Control - RW */
 #define E1000_RDTR1    0x02820  /* RX Delay Timer (1) - RW */
 #define E1000_RDBAL1   0x02900  /* RX Descriptor Base Address Low (1) - RW */
@@ -917,6 +956,19 @@ struct e1000_ffvt_entry {
 #define E1000_TIPG     0x00410  /* TX Inter-packet gap -RW */
 #define E1000_TBT      0x00448  /* TX Burst Timer - RW */
 #define E1000_AIT      0x00458  /* Adaptive Interframe Spacing Throttle - RW */
+#define E1000_CPP_ERR_STAT_ICP_xxxx  0x00510 /* CPP Error Status Register */
+#define E1000_CPP_ERR_ADDR_ICP_xxxx  0x00514 /* CPP Error Address Register */
+#define E1000_CPP_ERR_PPID_ICP_xxxx  0x00518 /* CPP Error ID Register */
+#define E1000_ICR1     0x008C0  /* Interrupt Cause Read 1 - R/clr */
+#define E1000_ICS1     0x008C8  /* Interrupt Cause Set - WO */
+#define E1000_IMS1     0x008D0  /* Interrupt Mask Set 1 - RW */
+#define E1000_IMC1     0x008D8  /* Interrupt Mask Clear 1 - RW */
+#define E1000_ICR2     0x008E0  /* Interrupt Cause Read 2 - R0 */
+#define E1000_ICS2     0x008E8  /* Interrupt Cause Set 2 - RW */
+#define E1000_IMS2     0x008F0  /* Interrupt Mask Set 2 - RW */
+#define E1000_IMC2     0x008F8  /* Interrupt Mask 2 Clear - WO */
+#define E1000_MEM_TST  0x00900  /* Internal ECC Memory Test Register - RW */
+#define E1000_MEM_STS  0x00904  /* Internal ECC Memory Status Register - RO */
 #define E1000_LEDCTL   0x00E00  /* LED Control - RW */
 #define E1000_EXTCNF_CTRL  0x00F00  /* Extended Configuration Control */
 #define E1000_EXTCNF_SIZE  0x00F08  /* Extended Configuration Size */
@@ -1113,6 +1165,14 @@ struct e1000_ffvt_entry {
 #define E1000_82542_ICS      E1000_ICS
 #define E1000_82542_IMS      E1000_IMS
 #define E1000_82542_IMC      E1000_IMC
+#define E1000_82542_ICR1     E1000_ICR1
+#define E1000_82542_ICS1     E1000_ICS1
+#define E1000_82542_IMS1     E1000_IMS1
+#define E1000_82542_IMC1     E1000_IMC1
+#define E1000_82542_ICR2     E1000_ICR2
+#define E1000_82542_ICS2     E1000_ICS2
+#define E1000_82542_IMS2     E1000_IMS2
+#define E1000_82542_IMC2     E1000_IMC2
 #define E1000_82542_RCTL     E1000_RCTL
 #define E1000_82542_RDTR     0x00108
 #define E1000_82542_RDBAL    0x00110
@@ -1469,6 +1529,7 @@ struct e1000_hw {
 	bool			has_manc2h;
 	bool			rx_needs_kicking;
 	bool			has_smbus;
+	bool			icp_xxxx_is_link_up;
 };
 
 
@@ -1641,6 +1702,8 @@ struct e1000_hw {
 #define E1000_CTRL_EXT_WR_WMARK_320   0x01000000
 #define E1000_CTRL_EXT_WR_WMARK_384   0x02000000
 #define E1000_CTRL_EXT_WR_WMARK_448   0x03000000
+/* Interrupt delay cancellation */
+#define E1000_CTRL_EXT_CANC           0x04000000
 #define E1000_CTRL_EXT_DRV_LOAD       0x10000000 /* Driver loaded bit for FW */
 #define E1000_CTRL_EXT_IAME           0x08000000 /* Interrupt acknowledge Auto-mask */
 #define E1000_CTRL_EXT_INT_TIMER_CLR  0x20000000 /* Clear Interrupt timers after IMS clear */
@@ -1705,6 +1768,34 @@ struct e1000_hw {
 #define E1000_PHY_CTRL_GBE_DISABLE             0x00000040
 #define E1000_PHY_CTRL_B2B_EN                  0x00000080
 
+/* Auxiliary Control */
+#define E1000_CTRL_AUX_ICP_xxxx_MII_TGS  0x00000001
+#define E1000_CTRL_AUX_ICP_xxxx_ENDIAN   0x00000300
+#define E1000_CTRL_AUX_ICP_xxxx_PKT      0x00000400
+#define E1000_CTRL_AUX_ICP_xxxx_DESC     0x00000800
+
+/* CPP Error ID */
+#define E1000_CPP_ERR_PPID_ICP_xxxx_PPID  0x00000000
+
+/* CPP Error Address */
+#define E1000_CPP_ERR_ADDR_ICP_xxxx_ERR_ADDR  0x00000000
+
+/* CPP Error Status */
+#define E1000_CPP_ERR_STAT_ICP_xxxx_CERR  0x00000001
+#define E1000_CPP_ERR_STAT_ICP_xxxx_MERR  0x00000002
+#define E1000_CPP_ERR_STAT_ICP_xxxx_CD    0x00000004
+#define E1000_CPP_ERR_STAT_ICP_xxxx_TYPE  0x00000030
+
+/* Internal ECC Memory Error Test */
+#define E1000_MEM_TST_ICP_xxxx_MASK    0x0000FFFF
+#define E1000_MEM_TST_ICP_xxxx_NONE    0x00000000
+#define E1000_MEM_TST_ICP_xxxx_STAT    0x00010000
+#define E1000_MEM_TST_ICP_xxxx_MCAST   0x00020000
+#define E1000_MEM_TST_ICP_xxxx_SPFILT  0x00030000
+#define E1000_MEM_TST_ICP_xxxx_TXDESC  0x00040000
+#define E1000_MEM_TST_ICP_xxxx_RXDESC  0x00050000
+#define E1000_MEM_TST_ICP_xxxx_PKBUFF  0x00060000
+
 /* LED Control */
 #define E1000_LEDCTL_LED0_MODE_MASK       0x0000000F
 #define E1000_LEDCTL_LED0_MODE_SHIFT      0
@@ -1766,6 +1857,13 @@ struct e1000_hw {
 #define E1000_ICR_ACK           0x00020000 /* Receive Ack frame */
 #define E1000_ICR_MNG           0x00040000 /* Manageability event */
 #define E1000_ICR_DOCK          0x00080000 /* Dock/Undock */
+#define E1000_ICR_RX_DESC_FIFO_PAR 0x00100000 /* RX Desc FIFO Parity Err */
+#define E1000_ICR_TX_DESC_FIFO_PAR 0x00200000 /* TX Desc FIFO Parity Err */
+#define E1000_ICR_PB               0x00800000 /* Packet Buffer Parity Err */
+#define E1000_ICR_INTMEM_ICP_xxxx  0x04000000
+#define E1000_ICR_CPP_TARGET    0x08000000
+#define E1000_ICR_CPP_MASTER    0x10000000
+#define E1000_ICR_STAT          0x20000000
 #define E1000_ICR_INT_ASSERTED  0x80000000 /* If this bit asserted, the driver should claim the interrupt */
 #define E1000_ICR_RXD_FIFO_PAR0 0x00100000 /* queue 0 Rx descriptor FIFO parity error */
 #define E1000_ICR_TXD_FIFO_PAR0 0x00200000 /* queue 0 Tx descriptor FIFO parity error */
@@ -1806,6 +1904,13 @@ struct e1000_hw {
 #define E1000_ICS_DSW       E1000_ICR_DSW
 #define E1000_ICS_PHYINT    E1000_ICR_PHYINT
 #define E1000_ICS_EPRST     E1000_ICR_EPRST
+#define E1000_ICS_RX_DESC_FIFO_PAR  E1000_ICR_RX_DESC_FIFO_PAR
+#define E1000_ICS_TX_DESC_FIFO_PAR  E1000_ICR_TX_DESC_FIFO_PAR
+#define E1000_ICS_PB                E1000_ICR_PB
+#define E1000_ICS_INTMEM_ICP_xxxx   E1000_ICR_INTMEM_ICP_xxxx
+#define E1000_ICS_CPP_TARGET        E1000_ICR_CPP_TARGET
+#define E1000_ICS_CPP_MASTER        E1000_ICR_CPP_MASTER
+#define E1000_ICS_STAT              E1000_ICR_STAT
 
 /* Interrupt Mask Set */
 #define E1000_IMS_TXDW      E1000_ICR_TXDW      /* Transmit desc written back */
@@ -1826,6 +1931,13 @@ struct e1000_hw {
 #define E1000_IMS_ACK       E1000_ICR_ACK       /* Receive Ack frame */
 #define E1000_IMS_MNG       E1000_ICR_MNG       /* Manageability event */
 #define E1000_IMS_DOCK      E1000_ICR_DOCK      /* Dock/Undock */
+#define E1000_IMS_RX_DESC_FIFO_PAR E1000_ICR_RX_DESC_FIFO_PAR
+#define E1000_IMS_TX_DESC_FIFO_PAR E1000_ICR_TX_DESC_FIFO_PAR
+#define E1000_IMS_PB               E1000_ICR_PB
+#define E1000_IMS_INTMEM_ICP_xxxx  E1000_ICR_INTMEM_ICP_xxxx
+#define E1000_IMS_CPP_TARGET       E1000_ICR_CPP_TARGET
+#define E1000_IMS_CPP_MASTER       E1000_ICR_CPP_MASTER
+#define E1000_IMS_STAT             E1000_ICR_STAT
 #define E1000_IMS_RXD_FIFO_PAR0 E1000_ICR_RXD_FIFO_PAR0 /* queue 0 Rx descriptor FIFO parity error */
 #define E1000_IMS_TXD_FIFO_PAR0 E1000_ICR_TXD_FIFO_PAR0 /* queue 0 Tx descriptor FIFO parity error */
 #define E1000_IMS_HOST_ARB_PAR  E1000_ICR_HOST_ARB_PAR  /* host arb read buffer parity error */
@@ -1864,6 +1976,13 @@ struct e1000_hw {
 #define E1000_IMC_DSW       E1000_ICR_DSW
 #define E1000_IMC_PHYINT    E1000_ICR_PHYINT
 #define E1000_IMC_EPRST     E1000_ICR_EPRST
+#define E1000_IMC_RX_DESC_FIFO_PAR  E1000_ICR_RX_DESC_FIFO_PAR
+#define E1000_IMC_TX_DESC_FIFO_PAR  E1000_ICR_TX_DESC_FIFO_PAR
+#define E1000_IMC_PB                E1000_ICR_PB
+#define E1000_IMC_INTMEM_ICP_xxxx   E1000_ICR_INTMEM_ICP_xxxx
+#define E1000_IMC_CPP_TARGET        E1000_ICR_CPP_TARGET
+#define E1000_IMC_CPP_MASTER        E1000_ICR_CPP_MASTER
+#define E1000_IMC_STAT              E1000_ICR_STAT
 
 /* Receive Control */
 #define E1000_RCTL_RST            0x00000001    /* Software reset */
@@ -2285,6 +2404,38 @@ struct e1000_host_command_info {
 #define EEPROM_CFG                    0x0012
 #define EEPROM_FLASH_VERSION          0x0032
 #define EEPROM_CHECKSUM_REG           0x003F
+/* ICP PCI Dev ID xxxx EEPROM Word Offsets */
+#define EEPROM_INIT_CONTROL1_REG_ICP_xxxx           0x0000
+#define EEPROM_COMPAT_ICP_xxxx                      0x0003
+#define EEPROM_PBA_LOW_ICP_xxxx                     0x0008
+#define EEPROM_PBA_HIGH_ICP_xxxx                    0x0009
+#define EEPROM_MGMT_CONTROL_PORT_A_ICP_xxxx         0x0010
+#define EEPROM_INIT_CONTROL3_PORT_A_ICP_xxxx        0x0011
+#define EEPROM_IA_START_PORT_A_ICP_xxxx             0x0012
+#define EEPROM_IPV4_START_PORT_A_ICP_xxxx           0x0015
+#define EEPROM_IPV6_START_PORT_A_ICP_xxxx           0x0017
+#define EEPROM_MGMT_CONTROL_PORT_B_ICP_xxxx         0x0020
+#define EEPROM_INIT_CONTROL3_PORT_B_ICP_xxxx        0x0021
+#define EEPROM_IA_START_PORT_B_ICP_xxxx             0x0022
+#define EEPROM_IPV4_START_PORT_B_ICP_xxxx           0x0025
+#define EEPROM_IPV6_START_PORT_B_ICP_xxxx           0x0027
+#define EEPROM_MGMT_CONTROL_PORT_C_ICP_xxxx         0x0030
+#define EEPROM_INIT_CONTROL3_PORT_C_ICP_xxxx        0x0031
+#define EEPROM_IA_START_PORT_C_ICP_xxxx             0x0032
+#define EEPROM_IPV4_START_PORT_C_ICP_xxxx           0x0035
+#define EEPROM_IPV6_START_PORT_C_ICP_xxxx           0x0037
+#define EEPROM_CHECKSUM_REG_ICP_xxxx                EEPROM_CHECKSUM_REG
+
+/* ICP PCI Dev ID xxxx macros to calculate word offsets for IA, IPv4 and IPv6 */
+#define EEPROM_MGMT_CONTROL_ICP_xxxx(device_num)  (((device_num) + 1) << 4)
+#define EEPROM_INIT_CONTROL3_ICP_xxxx(device_num) \
+		((((device_num) + 1) << 4) + 1)
+#define EEPROM_IA_START_ICP_xxxx(device_num) \
+		((((device_num) + 1) << 4) + 2)
+#define EEPROM_IPV4_START_ICP_xxxx(device_num) \
+		((((device_num) + 1) << 4) + 5)
+#define EEPROM_IPV6_START_ICP_xxxx(device_num) \
+		((((device_num) + 1) << 4) + 7)
 
 #define E1000_EEPROM_CFG_DONE         0x00040000   /* MNG config cycle done */
 #define E1000_EEPROM_CFG_DONE_PORT_1  0x00080000   /* ...for second port */
@@ -2345,6 +2496,15 @@ struct e1000_host_command_info {
 /* Mask bits for fields in Word 0x1a of the EEPROM */
 #define EEPROM_WORD1A_ASPM_MASK  0x000C
 
+/* Mask bits for fields in EEPROM_INIT_CONTROL3_ICP_xxxx.
+ * For ICP style controllers, control word 2 and 3 are packed into the
+ * same word, with control word 2 occupying the top byte. This just
+ * happens to match the original iegbe storing the information in the top
+ * word of init control word 2. To access this data use the control 3
+ * macro
+ */
+#define EEPROM_INIT_CTRL_2_ANE_ICP_xxxx        EEPROM_WORD0F_ANE
+
 /* For checksumming, the sum of all words in the EEPROM should equal 0xBABA. */
 #define EEPROM_SUM 0xBABA
 
@@ -2356,6 +2516,10 @@ struct e1000_host_command_info {
 
 /* EEPROM Map Sizes (Byte Counts) */
 #define PBA_SIZE 4
+#define COMPAT_SIZE_ICP_xxxx 10
+
+/* ICP Mask bits for INIT_CONTROL3 */
+#define EEPROM_CTRL3_APME_ICP_xxxx     0x0004
 
 /* Collision related configuration parameters */
 #define E1000_COLLISION_THRESHOLD       15
@@ -2931,6 +3095,9 @@ struct e1000_host_command_info {
 #define M88EC018_EPSCR_DOWNSHIFT_COUNTER_6X    0x0A00
 #define M88EC018_EPSCR_DOWNSHIFT_COUNTER_7X    0x0C00
 #define M88EC018_EPSCR_DOWNSHIFT_COUNTER_8X    0x0E00
+/* RGMII TX and RX Timing Control*/
+#define M88E1000_EPSCR_TX_TIME_CTRL       0x0002 /* Add Delay */
+#define M88E1000_EPSCR_RX_TIME_CTRL       0x0080 /* Add Delay */
 
 /* IGP01E1000 Specific Port Config Register - R/W */
 #define IGP01E1000_PSCFR_AUTO_MDIX_PAR_DETECT  0x0010
@@ -3156,6 +3323,7 @@ struct e1000_host_command_info {
 #define M88E1000_14_PHY_ID M88E1000_E_PHY_ID
 #define M88E1011_I_REV_4   0x04
 #define M88E1111_I_PHY_ID  0x01410CC0
+#define M88E1141_E_PHY_ID  0x01410CD4
 #define L1LXT971A_PHY_ID   0x001378E0
 #define GG82563_E_PHY_ID   0x01410CA0
 
diff --git a/drivers/net/e1000/e1000_main.c b/drivers/net/e1000/e1000_main.c
index 437544f..63d2aa0 100644
--- a/drivers/net/e1000/e1000_main.c
+++ b/drivers/net/e1000/e1000_main.c
@@ -79,6 +79,18 @@ static struct pci_device_id e1000_pci_tbl[] = {
 	INTEL_E1000_ETHERNET_DEVICE(0x108A),
 	INTEL_E1000_ETHERNET_DEVICE(0x1099),
 	INTEL_E1000_ETHERNET_DEVICE(0x10B5),
+	INTEL_E1000_ETHERNET_DEVICE(0x5040),
+	INTEL_E1000_ETHERNET_DEVICE(0x5041),
+	INTEL_E1000_ETHERNET_DEVICE(0x5042),
+	INTEL_E1000_ETHERNET_DEVICE(0x5043),
+	INTEL_E1000_ETHERNET_DEVICE(0x5044),
+	INTEL_E1000_ETHERNET_DEVICE(0x5045),
+	INTEL_E1000_ETHERNET_DEVICE(0x5046),
+	INTEL_E1000_ETHERNET_DEVICE(0x5047),
+	INTEL_E1000_ETHERNET_DEVICE(0x5048),
+	INTEL_E1000_ETHERNET_DEVICE(0x5049),
+	INTEL_E1000_ETHERNET_DEVICE(0x504A),
+	INTEL_E1000_ETHERNET_DEVICE(0x504B),
 	/* required last entry */
 	{0,}
 };
@@ -149,6 +161,7 @@ static void e1000_alloc_rx_buffers_ps(struct e1000_adapter *adapter,
 static int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
 static int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,
 			   int cmd);
+extern int ethtool_ioctl(struct ifreq *ifr);
 static void e1000_enter_82542_rst(struct e1000_adapter *adapter);
 static void e1000_leave_82542_rst(struct e1000_adapter *adapter);
 static void e1000_tx_timeout(struct net_device *dev);
@@ -263,7 +276,8 @@ static int e1000_request_irq(struct e1000_adapter *adapter)
 	int irq_flags = IRQF_SHARED;
 	int err;
 
-	if (hw->mac_type >= e1000_82571) {
+	if (adapter->hw.mac_type >= e1000_82571 ||
+		adapter->hw.mac_type == e1000_icp_xxxx) {
 		adapter->have_msi = !pci_enable_msi(adapter->pdev);
 		if (adapter->have_msi) {
 			handler = e1000_intr_msi;
@@ -496,6 +510,16 @@ int e1000_up(struct e1000_adapter *adapter)
 	struct e1000_hw *hw = &adapter->hw;
 
 	/* hardware has been reset, we need to reload some things */
+
+	/* Reset the PHY if it was previously powered down */
+	if (adapter->hw.media_type == e1000_media_type_oem &&
+		e1000_oem_phy_is_copper(&adapter->hw)) {
+		u16 mii_reg;
+		e1000_read_phy_reg(&adapter->hw, PHY_CTRL, &mii_reg);
+		if (mii_reg & MII_CR_POWER_DOWN)
+			e1000_phy_reset(&adapter->hw);
+	}
+
 	e1000_configure(adapter);
 
 	clear_bit(__E1000_DOWN, &adapter->flags);
@@ -606,6 +630,17 @@ void e1000_down(struct e1000_adapter *adapter)
 	e1000_reset(adapter);
 	e1000_clean_all_tx_rings(adapter);
 	e1000_clean_all_rx_rings(adapter);
+	/* If WoL is not enabled and management mode is not IAMT
+	 * or if WoL is not enabled and OEM PHY is copper based,
+	 * power down the PHY so no link is implied when interface is down */
+	if (!adapter->wol && adapter->hw.media_type == e1000_media_type_oem
+		&& e1000_oem_phy_is_copper(&adapter->hw)) {
+		u16 mii_reg;
+		e1000_read_phy_reg(&adapter->hw, PHY_CTRL, &mii_reg);
+		mii_reg |= MII_CR_POWER_DOWN;
+		e1000_write_phy_reg(&adapter->hw, PHY_CTRL, mii_reg);
+		mdelay(1);
+	}
 }
 
 void e1000_reinit_locked(struct e1000_adapter *adapter)
@@ -664,6 +699,9 @@ void e1000_reset(struct e1000_adapter *adapter)
 	case e1000_undefined:
 	case e1000_num_macs:
 		break;
+	default:
+		pba = E1000_PBA_48K;
+		break;
 	}
 
 	if (legacy_pba_adjust) {
@@ -1124,6 +1162,12 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
 			EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data);
 		eeprom_apme_mask = E1000_EEPROM_82544_APM;
 		break;
+	case e1000_icp_xxxx:
+		e1000_read_eeprom(&adapter->hw,
+			EEPROM_INIT_CONTROL3_ICP_xxxx(adapter->pdev->devfn),
+			1, &eeprom_data);
+		eeprom_apme_mask = EEPROM_CTRL3_APME_ICP_xxxx;
+		break;
 	case e1000_ich8lan:
 		e1000_read_eeprom(hw,
 			EEPROM_INIT_CONTROL1_REG, 1, &eeprom_data);
@@ -1221,6 +1265,19 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
 	netif_carrier_off(netdev);
 	netif_stop_queue(netdev);
 
+	/*
+	 * The ICP_xxxx device has multiple, duplicate interrupt
+	 * registers, so disable all but the first one
+	 */
+	if (adapter->hw.mac_type == e1000_icp_xxxx) {
+			int offset = pci_find_capability(adapter->pdev,
+					PCI_CAP_ID_ST) + PCI_ST_SMIA_OFFSET;
+			pci_write_config_dword(adapter->pdev, offset,
+						0x00000006);
+			E1000_WRITE_REG_ARRAY(&adapter->hw, IMC1, 0, ~0UL);
+			E1000_WRITE_REG_ARRAY(&adapter->hw, IMC2, 0, ~0UL);
+	}
+
 	strcpy(netdev->name, "eth%d");
 	err = register_netdev(netdev);
 	if (err)
@@ -1363,7 +1420,9 @@ static int __devinit e1000_sw_init(struct e1000_adapter *adapter)
 
 	/* Copper options */
 
-	if (hw->media_type == e1000_media_type_copper) {
+	if (hw->media_type == e1000_media_type_copper
+		|| (hw->media_type == e1000_media_type_oem
+			&& e1000_oem_phy_is_copper(&adapter->hw))) {
 		hw->mdix = AUTO_ALL_MODES;
 		hw->disable_polarity_correction = false;
 		hw->master_slave = E1000_MASTER_SLAVE;
@@ -1384,6 +1443,14 @@ static int __devinit e1000_sw_init(struct e1000_adapter *adapter)
 	}
 	spin_lock_init(&adapter->tx_queue_lock);
 
+	/*
+	 * for ICP_XXXX style controllers, it is necessary to keep
+	 * track of the last known state of the link to determine if
+	 * the link experienced a change in state when e1000_watchdog
+	 * fires
+	 */
+	adapter->hw.icp_xxxx_is_link_up = false;
+
 	/* Explicitly disable IRQ since the NIC can be in any state. */
 	e1000_irq_disable(adapter);
 
@@ -1779,6 +1846,8 @@ static void e1000_configure_tx(struct e1000_adapter *adapter)
 
 	if (hw->mac_type < e1000_82543)
 		adapter->txd_cmd |= E1000_TXD_CMD_RPS;
+	else if (hw->mac_type == e1000_icp_xxxx)
+		adapter->txd_cmd &= ~E1000_TXD_CMD_RS;
 	else
 		adapter->txd_cmd |= E1000_TXD_CMD_RS;
 
@@ -2611,6 +2680,21 @@ static void e1000_watchdog(unsigned long data)
 	u32 link, tctl;
 	s32 ret_val;
 
+	/*
+	 * Test the PHY for link status on icp_xxxx MACs.
+	 * If the link status is different than the last link status stored
+	 * in the adapter->hw structure, then set hw->get_link_status = 1
+	 */
+	if (adapter->hw.mac_type == e1000_icp_xxxx) {
+		int isUp = 0;
+		ret_val = e1000_oem_phy_is_link_up(&adapter->hw, &isUp);
+		if (ret_val != E1000_SUCCESS)
+			isUp = 0;
+
+		if (isUp != adapter->hw.icp_xxxx_is_link_up)
+			adapter->hw.get_link_status = 1;
+	}
+
 	ret_val = e1000_check_for_link(hw);
 	if ((ret_val == E1000_ERR_PHY) &&
 	    (hw->phy_type == e1000_phy_igp_3) &&
@@ -2629,8 +2713,18 @@ static void e1000_watchdog(unsigned long data)
 	if ((hw->media_type == e1000_media_type_internal_serdes) &&
 	   !(er32(TXCW) & E1000_TXCW_ANE))
 		link = !hw->serdes_link_down;
-	else
-		link = er32(STATUS) & E1000_STATUS_LU;
+	else {
+		if (adapter->hw.mac_type != e1000_icp_xxxx) {
+			link = E1000_READ_REG_ARRAY(&adapter->hw, STATUS, 0) &
+							E1000_STATUS_LU;
+		} else {
+			int isUp = 0;
+			if (e1000_oem_phy_is_link_up(&adapter->hw, &isUp) !=
+							E1000_SUCCESS)
+				isUp = 0;
+			link = isUp;
+		}
+	}
 
 	if (link) {
 		if (!netif_carrier_ok(netdev)) {
@@ -3779,6 +3873,105 @@ void e1000_update_stats(struct e1000_adapter *adapter)
 	spin_unlock_irqrestore(&adapter->stats_lock, flags);
 }
 
+/*
+ * Check for tx hang condition. This is the condition where a
+ * decsriptor is in the hardware and hasn't been processed for a
+ * while. This code is similar to the check in e1000_clean_rx_irq()
+ */
+static void e1000_tx_hang_check(struct e1000_adapter *adapter,
+				struct e1000_tx_ring *tx_ring)
+{
+	struct net_device *netdev = adapter->netdev;
+	unsigned int i;
+
+	/*
+	 * Check for a hang condition using the buffer currently at
+	 * the Tx head pointer
+	 */
+	i = readl(adapter->hw.hw_addr + tx_ring->tdh);
+
+	if (adapter->detect_tx_hung) {
+		/* Detect a transmit hang in hardware, this serializes the
+		 * check with the clearing of time_stamp and movement of i */
+		adapter->detect_tx_hung = false;
+
+		if (tx_ring->buffer_info[i].dma &&
+			time_after(jiffies,
+				tx_ring->buffer_info[i].time_stamp + HZ)
+			&& !(E1000_READ_REG_ARRAY(&adapter->hw, STATUS, 0) &
+			E1000_STATUS_TXOFF)) {
+
+			/* detected Tx unit hang */
+			DPRINTK(DRV, ERR, "Detected Tx Unit Hang\n"
+				"  TDH                  <%x>\n"
+				"  TDT                  <%x>\n"
+				"  next_to_use          <%x>\n"
+				"  next_to_clean        <%x>\n"
+				"buffer_info[tdh]\n"
+				"  dma                  <%zx>\n"
+				"  time_stamp           <%lx>\n"
+				"  jiffies              <%lx>\n",
+				readl(adapter->hw.hw_addr + tx_ring->tdh),
+				readl(adapter->hw.hw_addr + tx_ring->tdt),
+				tx_ring->next_to_use,
+				tx_ring->next_to_clean,
+				(size_t)tx_ring->buffer_info[i].dma,
+				tx_ring->buffer_info[i].time_stamp,
+				jiffies);
+			netif_stop_queue(netdev);
+		}
+	}
+}
+
+/*
+ * e1000_clean_tx_ring_partial - Free Tx Buffers without using the DD
+ * bit in the descriptor
+ * @adapter: board private structure
+ * @tx_ring: ring to be cleaned
+ */
+static void e1000_clean_tx_ring_partial(struct e1000_adapter *adapter,
+					struct e1000_tx_ring *tx_ring)
+{
+	struct e1000_buffer *buffer_info;
+	struct e1000_tx_desc *tx_desc;
+	struct net_device *netdev = adapter->netdev;
+	unsigned int i;
+	unsigned tail;
+	unsigned head;
+	int cleaned = false;
+
+	tail = readl(adapter->hw.hw_addr + tx_ring->tdt);
+	head = readl(adapter->hw.hw_addr + tx_ring->tdh);
+
+	/* Free all the Tx ring sk_buffs from next_to_clean up until
+	 *  the current head pointer
+	 */
+	i = tx_ring->next_to_clean;
+	while (i != head) {
+		cleaned = true;
+		tx_desc = E1000_TX_DESC(*tx_ring, i);
+
+		buffer_info = &tx_ring->buffer_info[i];
+		e1000_unmap_and_free_tx_resource(adapter, buffer_info);
+
+		tx_desc->upper.data = 0;
+
+		if (unlikely(++i == tx_ring->count))
+			i = 0;
+	}
+	tx_ring->next_to_clean = head;
+
+	spin_lock(&tx_ring->tx_lock);
+
+	/* Wake up the queue if it's currently stopped */
+	if (unlikely(cleaned && netif_queue_stopped(netdev) &&
+		netif_carrier_ok(netdev))) {
+		netif_wake_queue(netdev);
+	}
+
+	spin_unlock(&tx_ring->tx_lock);
+}
+
 /**
  * e1000_intr_msi - Interrupt Handler
  * @irq: interrupt number
@@ -3791,6 +3984,7 @@ static irqreturn_t e1000_intr_msi(int irq, void *data)
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
 	u32 icr = er32(ICR);
+	int i;
 
 	/* in NAPI mode read ICR disables interrupts using IAM */
 
@@ -3819,6 +4013,15 @@ static irqreturn_t e1000_intr_msi(int irq, void *data)
 	} else
 		e1000_irq_enable(adapter);
 
+	/* Clean the Tx ring */
+	for (i = 0; i < E1000_MAX_INTR; i++) {
+		/* Only clean Tx descriptors for a TXQE interrupt */
+		if (icr & E1000_ICR_TXQE)
+			e1000_clean_tx_ring_partial(adapter, adapter->tx_ring);
+		else
+			e1000_tx_hang_check(adapter, adapter->tx_ring);
+	}
+
 	return IRQ_HANDLED;
 }
 
@@ -3834,6 +4037,7 @@ static irqreturn_t e1000_intr(int irq, void *data)
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
 	u32 rctl, icr = er32(ICR);
+	int i;
 
 	if (unlikely((!icr) || test_bit(__E1000_RESETTING, &adapter->flags)))
 		return IRQ_NONE;  /* Not our interrupt */
@@ -3881,6 +4085,15 @@ static irqreturn_t e1000_intr(int irq, void *data)
 		 * bug, but not a hard error, so enable ints and continue */
 		e1000_irq_enable(adapter);
 
+	/* Clean the Tx ring */
+	for (i = 0; i < E1000_MAX_INTR; i++) {
+		/* Only clean Tx descriptors for a TXQE interrupt */
+		if (icr & E1000_ICR_TXQE)
+			e1000_clean_tx_ring_partial(adapter, adapter->tx_ring);
+		else
+			e1000_tx_hang_check(adapter, adapter->tx_ring);
+	}
+
 	return IRQ_HANDLED;
 }
 
@@ -4952,8 +5165,10 @@ int e1000_set_spd_dplx(struct e1000_adapter *adapter, u16 spddplx)
 	hw->autoneg = 0;
 
 	/* Fiber NICs only allow 1000 gbps Full duplex */
-	if ((hw->media_type == e1000_media_type_fiber) &&
-		spddplx != (SPEED_1000 + DUPLEX_FULL)) {
+	if ((adapter->hw.media_type == e1000_media_type_fiber
+		|| (adapter->hw.media_type == e1000_media_type_oem
+		&& !e1000_oem_phy_is_copper(&adapter->hw)))
+		&& spddplx != (SPEED_1000 + DUPLEX_FULL)) {
 		DPRINTK(PROBE, ERR, "Unsupported Speed/Duplex configuration\n");
 		return -EINVAL;
 	}
@@ -4990,6 +5205,7 @@ static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
 	struct e1000_hw *hw = &adapter->hw;
 	u32 ctrl, ctrl_ext, rctl, status;
 	u32 wufc = adapter->wol;
+	u16 cmd_word;
 #ifdef CONFIG_PM
 	int retval = 0;
 #endif
@@ -5007,9 +5223,22 @@ static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
 		return retval;
 #endif
 
+	/*
+	 * ICP_XXXX style MACs do not have a link up bit in
+	 * the STATUS register, query the PHY directly
+	 */
+	if (adapter->hw.mac_type != e1000_icp_xxxx) {
 	status = er32(STATUS);
 	if (status & E1000_STATUS_LU)
 		wufc &= ~E1000_WUFC_LNKC;
+	} else {
+		int isUp = 0;
+		if (e1000_oem_phy_is_link_up(&adapter->hw, &isUp) !=
+			E1000_SUCCESS)
+			isUp = 0;
+		if (isUp)
+			wufc &= ~E1000_WUFC_LNKC;
+	}
 
 	if (wufc) {
 		e1000_setup_rctl(adapter);
@@ -5071,6 +5300,24 @@ static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
 
 	pci_disable_device(pdev);
 
+	if (adapter->hw.mac_type == e1000_icp_xxxx) {
+		/*
+		 * ICP xxxx devices are not true PCI devices, in the context
+		 * of power management, disabling the bus mastership is not
+		 * sufficient to disable the device, it is also necessary to
+		 * disable IO, Memory, and Interrupts if they are enabled.
+		 */
+		pci_read_config_word(pdev, PCI_COMMAND, &cmd_word);
+		if (cmd_word & PCI_COMMAND_IO)
+			cmd_word &= ~PCI_COMMAND_IO;
+		if (cmd_word & PCI_COMMAND_MEMORY)
+			cmd_word &= ~PCI_COMMAND_MEMORY;
+		if (cmd_word & PCI_COMMAND_INTX_DISABLE)
+			cmd_word &= ~PCI_COMMAND_INTX_DISABLE;
+
+		pci_write_config_word(pdev, PCI_COMMAND, cmd_word);
+	}
+
 	return 0;
 }
 
diff --git a/drivers/net/e1000/e1000_oem_phy.c b/drivers/net/e1000/e1000_oem_phy.c
new file mode 100644
index 0000000..765a4c6
--- /dev/null
+++ b/drivers/net/e1000/e1000_oem_phy.c
@@ -0,0 +1,1494 @@
+/******************************************************************************
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+version: Embedded.L.0.7.018
+
+Contact Information:
+
+Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+ ******************************************************************************/
+
+#include "e1000_oem_phy.h"
+#include "e1000.h"
+
+/*
+ * List of functions leveraged from the base iegbe driver.
+ * Ideally, it would have been nice to keep e1000_oem_phy.c
+ * minimally dependent on the iegbe. Any function taking
+ * a struct e1000_hw as a parameter can be implemented in
+ * this file. It was chosen to reuse as much code as possible
+ * to save time (isn't that always the case ;)
+ */
+extern int e1000_up(struct e1000_adapter *adapter);
+extern void e1000_down(struct e1000_adapter *adapter);
+extern void e1000_reset(struct e1000_adapter *adapter);
+extern int e1000_set_spd_dplx(struct e1000_adapter *adapter, u16 spddplx);
+extern int e1000_copper_link_autoneg(struct e1000_hw *hw);
+extern int e1000_phy_force_speed_duplex(struct e1000_hw *hw);
+extern int e1000_copper_link_postconfig(struct e1000_hw *hw);
+#ifdef CONFIG_TOLAPAI_GCU
+extern int gcu_read_eth_phy(u32 phy_num, u32 reg_addr, u16 *phy_data);
+extern int gcu_write_eth_phy(u32 phy_num, u32 reg_addr, u16 phy_data);
+#else
+int gcu_read_eth_phy(u32 phy_num, u32 reg_addr, u16 *phy_data)
+{return 0; }
+int gcu_write_eth_phy(u32 phy_num, u32 reg_addr, u16 phy_data)
+{return 0; }
+#endif
+
+/* forward declarations for static support functions */
+static int e1000_oem_link_m88_setup(struct e1000_hw *hw);
+static int e1000_oem_set_phy_mode(struct e1000_hw *hw);
+static int e1000_oem_detect_phy(struct e1000_hw *hw);
+
+/*
+ * e1000_oem_setup_link
+ * @hw: e1000_hw struct containing device specific information
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ * Performs OEM Transceiver specific link setup as part of the
+ * global e1000_setup_link() function.
+ */
+int e1000_oem_setup_link(struct e1000_hw *hw)
+{
+	/*
+	 * see e1000_setup_copper_link() as the primary example. Look at both
+	 * the M88 and IGP functions that are called for ideas, possibly for
+	 * power management.
+	 */
+
+	int ret_val;
+	u32 ctrl;
+	u16 i;
+	u16 phy_data;
+
+	if (!hw)
+		return -1;
+
+	/* AFU: add test to exit out if improper phy type */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		/* relevent parts of e1000_copper_link_preconfig */
+		ctrl = E1000_READ_REG_ARRAY(hw, CTRL, 0);
+		ctrl |= E1000_CTRL_SLU;
+		ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+		E1000_WRITE_REG_ARRAY(hw, CTRL, 0, ctrl);
+
+		/* this is required for *hw init */
+		ret_val = e1000_oem_detect_phy(hw);
+		if (ret_val)
+			return ret_val;
+
+		ret_val = e1000_oem_set_phy_mode(hw);
+		if (ret_val)
+			return ret_val;
+
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+		phy_data |= 0x00000008;
+		ret_val = e1000_oem_write_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_CTRL, phy_data);
+
+		ret_val = e1000_oem_link_m88_setup(hw);
+		if (ret_val)
+			return ret_val;
+
+		if (hw->autoneg) {
+			ret_val = e1000_copper_link_autoneg(hw);
+			if (ret_val)
+				return ret_val;
+		} else {
+			ret_val = e1000_phy_force_speed_duplex(hw);
+		}
+
+		/*
+		 * Check link status. Wait up to 100 microseconds for link to
+		 * become valid.
+		 */
+		for (i = 0; i < 10; i++) {
+			ret_val = e1000_oem_read_phy_reg_ex(
+					hw, PHY_STATUS, &phy_data);
+			if (ret_val)
+				return ret_val;
+
+			ret_val = e1000_oem_read_phy_reg_ex(
+					hw, PHY_STATUS, &phy_data);
+			if (ret_val)
+				return ret_val;
+
+			hw->icp_xxxx_is_link_up =
+				(phy_data & MII_SR_LINK_STATUS) != 0;
+
+			if (phy_data & MII_SR_LINK_STATUS) {
+				/* Config the MAC and PHY after link is up */
+				ret_val = e1000_copper_link_postconfig(hw);
+				if (ret_val)
+					return ret_val;
+				return E1000_SUCCESS;
+			}
+			udelay(10);
+		}
+
+		return E1000_SUCCESS;
+	}
+}
+
+/*
+ * e1000_oem_link_m88_setup
+ * @hw: e1000_hw struct containing device specific information
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ * lifted from e1000_copper_link_mgp_setup, pretty much
+ * copied verbatim except replace e1000_phy_reset with e1000_phy_hw_reset
+ */
+static int e1000_oem_link_m88_setup(struct e1000_hw *hw)
+{
+	int ret_val;
+	u16 phy_data;
+
+	if (!hw)
+		return -1;
+
+	/* phy_reset_disable is set in e1000_oem_set_phy_mode */
+	if (hw->phy_reset_disable)
+		return E1000_SUCCESS;
+
+	/* Enable CRS on TX. This must be set for half-duplex operation. */
+	ret_val = e1000_oem_read_phy_reg_ex(
+			hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+	if (ret_val)
+		return ret_val;
+
+	phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+
+	/*
+	 * Options:
+	 *   MDI/MDI-X = 0 (default)
+	 *   0 - Auto for all speeds
+	 *   1 - MDI mode
+	 *   2 - MDI-X mode
+	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
+	 */
+	phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
+
+	switch (hw->mdix) {
+	case 1:
+		phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
+		break;
+	case 2:
+		phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
+		break;
+	case 3:
+		phy_data |= M88E1000_PSCR_AUTO_X_1000T;
+		break;
+	case 0:
+	default:
+		phy_data |= M88E1000_PSCR_AUTO_X_MODE;
+		break;
+	}
+
+	/*
+	 * Options:
+	 *   disable_polarity_correction = 0 (default)
+	 *       Automatic Correction for Reversed Cable Polarity
+	 *   0 - Disabled
+	 *   1 - Enabled
+	 */
+	phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
+
+	if (hw->disable_polarity_correction == 1)
+		phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
+	ret_val = e1000_oem_write_phy_reg_ex(
+			hw, M88E1000_PHY_SPEC_CTRL, phy_data);
+	if (ret_val)
+		return ret_val;
+
+	/*
+	 * Force TX_CLK in the Extended PHY Specific Control Register
+	 * to 25MHz clock.
+	 */
+	ret_val = e1000_oem_read_phy_reg_ex(
+			hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);
+	if (ret_val)
+		return ret_val;
+
+	/*
+	 * For Truxton, it is necessary to add RGMII tx and rx
+	 * timing delay though the EXT_PHY_SPEC_CTRL register
+	 */
+	phy_data |= M88E1000_EPSCR_TX_TIME_CTRL;
+	phy_data |= M88E1000_EPSCR_RX_TIME_CTRL;
+
+	if (hw->phy_revision < M88E1011_I_REV_4) {
+		phy_data |= M88E1000_EPSCR_TX_CLK_25;
+		/* Configure Master and Slave downshift values */
+		phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
+				M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
+		phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
+				M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
+	}
+	ret_val = e1000_oem_write_phy_reg_ex(
+			hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
+	if (ret_val)
+		return ret_val;
+
+	/* SW Reset the PHY so all changes take effect */
+	ret_val = e1000_phy_hw_reset(hw);
+	if (ret_val)
+		return ret_val;
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_force_mdi
+ * @hw: e1000_hw struct containing device specific information
+ * @resetPhy: returns true if after calling this function the
+ *            PHY requires a reset
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ * This is called from e1000_phy_force_speed_duplex, which is
+ * called from e1000_oem_setup_link.
+ */
+int e1000_oem_force_mdi(struct e1000_hw *hw, int *resetPhy)
+{
+	u16 phy_data;
+	int ret_val;
+
+	if (!hw || !resetPhy)
+		return -1;
+
+	/*
+	 * a boolean to indicate if the phy needs to be reset
+	 * Make note that the M88 phy is what'll be used on Truxton
+	 * see e1000_phy_force_speed_duplex, which does the following for M88
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+		if (ret_val)
+			return ret_val;
+		/*
+		 * Clear Auto-Crossover to force MDI manually. M88E1000
+		 * requires MDI forced whenever speed are duplex are forced.
+		 */
+		phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
+		ret_val = e1000_oem_write_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_CTRL, phy_data);
+		if (ret_val)
+			return ret_val;
+
+		*resetPhy = true;
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_phy_reset_dsp
+ * @hw: e1000_hw struct containing device specific information
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ * This is called from e1000_phy_force_speed_duplex, which is
+ * called from e1000_oem_setup_link.
+ */
+int e1000_oem_phy_reset_dsp(struct e1000_hw *hw)
+{
+	if (!hw)
+		return -1;
+
+	/*
+	 * Make note that the M88 phy is what'll be used on Truxton.
+	 * See e1000_phy_force_speed_duplex, which calls e1000_phy_reset_dsp
+	 * for the M88 PHY. The code as written references registers 29 and 30,
+	 * which are reserved for the M88 used on Truxton, so this will be a
+	 * no-op.
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_cleanup_after_phy_reset
+ * @hw: e1000_hw struct containing device specific information
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ * This is called from e1000_phy_force_speed_duplex, which is
+ * called from e1000_oem_setup_link.
+ */
+int e1000_oem_cleanup_after_phy_reset(struct e1000_hw *hw)
+{
+	u16 phy_data;
+	int ret_val;
+
+	if (!hw)
+		return -1;
+
+	/*
+	 * Make note that the M88 phy is what'll be used on Truxton.
+	 * see e1000_phy_force_speed_duplex, which does the following for M88
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+
+		/*
+		 * Because we reset the PHY above, we need to re-force TX_CLK
+		 * in the Extended PHY Specific Control Register to 25MHz
+		 * clock.  This value defaults back to a 2.5MHz clock when the
+		 * PHY is reset.
+		 */
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		phy_data |= M88E1000_EPSCR_TX_CLK_25;
+		ret_val = e1000_oem_write_phy_reg_ex(
+				hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
+		if (ret_val)
+			return ret_val;
+
+		/*
+		 * In addition, because of the s/w reset above, we need to
+		 * enable CRX on TX.  This must be set for both full and half
+		 * duplex operation.
+		 */
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+		ret_val = e1000_oem_write_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_CTRL, phy_data);
+		if (ret_val)
+			return ret_val;
+
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_set_phy_mode
+ * @hw: e1000_hw struct containing device specific information
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ * This is called from e1000_oem_setup_link which is
+ * called from e1000_setup_link.
+ */
+static int e1000_oem_set_phy_mode(struct e1000_hw *hw)
+{
+	/*
+	 * it is unclear if it is necessary to set the phy mode. Right now only
+	 * one MAC 82545 Rev 3 does it, but the other MACs like Tolapai do not.
+	 * Leave the functionality off for now until it is determined that
+	 * Tolapai needs it as well.
+	 */
+#ifdef skip_set_mode
+#undef skip_set_mode
+#endif
+
+#ifdef skip_set_mode
+	int ret_val;
+	u16 eeprom_data;
+#endif
+
+	if (!hw)
+		return -1;
+
+	/*
+	 * e1000_set_phy_mode specifically works for 82545 Rev 3 only,
+	 * since it is a 'loner' compared to the 82545, 82546, and
+	 * 82546 Rev 3, assume for now it is anomaly and don't repeat
+	 * for Truxton/Haxton.
+	 * Note that this is the approach taken in both the Windows and
+	 * FreeBSD drivers
+	 */
+#ifdef skip_set_mode
+	/*
+	 * Make note that the M88 phy is what'll be used on Truxton.
+	 * use e1000_set_phy_mode as example
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = e1000_read_eeprom(
+				hw, EEPROM_PHY_CLASS_WORD, 1, &eeprom_data);
+		if (ret_val)
+			return ret_val;
+
+		if ((eeprom_data != EEPROM_RESERVED_WORD) &&
+			(eeprom_data & EEPROM_PHY_CLASS_A)) {
+			ret_val = e1000_oem_write_phy_reg_ex(
+					hw, M88E1000_PHY_PAGE_SELECT, 0x000B);
+			if (ret_val)
+				return ret_val;
+
+			ret_val = e1000_oem_write_phy_reg_ex(
+					hw, M88E1000_PHY_GEN_CONTROL, 0x8104);
+			if (ret_val)
+				return ret_val;
+
+			hw->phy_reset_disable = false;
+		}
+
+		break;
+	}
+#endif
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_detect_phy
+ * @hw: e1000_hw struct containing device specific information
+ * Fills hw->phy_type, hw->phy_id and hw->phy_revision fields as well
+ * as verifies that the PHY identified is one that is comprehended
+ * by the driver.
+ * This borrows heavily from e1000_detect_gig_phy
+ */
+static int e1000_oem_detect_phy(struct e1000_hw *hw)
+{
+	int ret_val;
+	u16 phy_id_high, phy_id_low;
+
+	if (!hw)
+		return -1;
+
+	hw->phy_type = e1000_phy_oem;
+
+	ret_val = e1000_oem_read_phy_reg_ex(hw, PHY_ID1, &phy_id_high);
+	if (ret_val)
+		return ret_val;
+
+	udelay(20);
+	ret_val = e1000_oem_read_phy_reg_ex(hw, PHY_ID2, &phy_id_low);
+	if (ret_val)
+		return ret_val;
+
+	hw->phy_id = (u32)((phy_id_high << 16) + phy_id_low);
+	hw->phy_revision = (u32) phy_id_low & ~PHY_REVISION_MASK;
+	if (hw->phy_id != M88E1000_I_PHY_ID && hw->phy_id != M88E1141_E_PHY_ID)
+		return -E1000_ERR_PHY;
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_get_tipg
+ * @hw: e1000_hw struct containing device specific information
+ * Returns the value of the Inter Packet Gap (IPG) Transmit Time (IPGT) in the
+ * Transmit IPG register appropriate for the given PHY. This field is only 10
+ * bits wide.
+ * In the original iegbe code, only the IPGT field varied between media types.
+ * If the OEM phy requires setting IPG Receive Time 1 & 2 Registers, it would
+ * be required to modify the e1000_config_tx() function to accomdate the change
+ */
+u32 e1000_oem_get_tipg(struct e1000_hw *hw)
+{
+	u32 phy_num;
+
+	if (!hw)
+		return DEFAULT_ICP_XXXX_TIPG_IPGT;
+
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		phy_num = DEFAULT_ICP_XXXX_TIPG_IPGT;
+		break;
+	}
+
+	return phy_num;
+}
+
+/*
+ * e1000_oem_phy_is_copper
+ * @hw: e1000_hw struct containing device specific information
+ * Test for media type within the iegbe driver is common, so this is a simple
+ * test for copper PHYs. The ICP_XXXX family of controllers initially only
+ * supported copper interconnects (no TBI (ten bit interface) for Fiber
+ * existed). If future revs support either Fiber or an internal SERDES, it
+ * may become necessary to evaluate where this function is used to go beyond
+ * determining whether or not media type is just copper.
+ */
+int e1000_oem_phy_is_copper(struct e1000_hw *hw)
+{
+	int isCopper = true;
+
+	if (!hw)
+		return isCopper;
+
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		isCopper = true;
+		break;
+	}
+
+	return isCopper;
+}
+
+/*
+ * e1000_oem_get_phy_dev_number
+ * @hw: e1000_hw struct containing device specific information
+ * For ICP_XXXX family of devices, there are 3 MACs, each of which may
+ * have a different PHY (and indeed a different media interface). This
+ * function is used to indicate which of the MAC/PHY pairs we are interested
+ * in.
+ */
+u32 e1000_oem_get_phy_dev_number(struct e1000_hw *hw)
+{
+	/*
+	 * for ICP_XXXX family of devices, the three network interfaces are
+	 * differentiated by their PCI device number, where the three share
+	 * the same PCI bus
+	 */
+	struct e1000_adapter *adapter;
+	u32 device_number;
+
+	if (!hw)
+		return 0;
+
+	adapter = (struct e1000_adapter *) hw->back;
+	device_number = PCI_SLOT(adapter->pdev->devfn);
+
+	switch (device_number) {
+	case ICP_XXXX_MAC_0:
+		return ICP_XXXX_PHY_0;
+	case ICP_XXXX_MAC_1:
+		return ICP_XXXX_PHY_1;
+	case ICP_XXXX_MAC_2:
+		return ICP_XXXX_PHY_2;
+	default:
+		return ICP_XXXX_PHY_0;
+	}
+}
+
+/*
+ * e1000_oem_mii_ioctl
+ * @adapter: e1000_hw struct containing device specific information
+ * @flags: The saved adapter->stats_lock flags from the initiating spinlock
+ * @ifr: interface request structure for socket ioctls
+ * @cmd: the original IOCTL command that instigated the call chain.
+ *
+ * This function abstracts out the code necessary to service the
+ * SIOCSMIIREG case within the e1000_mii_ioctl() for oem PHYs.
+ * e1000_mii_ioctl() was implemented for copper phy's only and this
+ * function will only be called if e1000_oem_phy_is_copper() returns true for
+ * a given MAC. Note that e1000_mii_ioctl() has a compile flag
+ * and exists only if SIOCGMIIPHY is defined.
+ * NOTE: a spinlock is in effect for the duration of this call. It is
+ *       imperative that a negative value be returned on any error, so
+ *       the spinlock can be released properly.
+ */
+int e1000_oem_mii_ioctl(struct e1000_adapter *adapter, unsigned long flags,
+			struct ifreq *ifr, int cmd)
+{
+	struct mii_ioctl_data *data = if_mii(ifr);
+	u16 mii_reg = data->val_in;
+	u16 spddplx;
+	int retval;
+
+	if (!adapter || !ifr)
+		return -1;
+
+	switch (e1000_oem_get_phy_dev_number(&adapter->hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		switch (data->reg_num) {
+		case PHY_CTRL:
+			if (mii_reg & MII_CR_POWER_DOWN)
+				break;
+			if (mii_reg & MII_CR_AUTO_NEG_EN) {
+				adapter->hw.autoneg = 1;
+				adapter->hw.autoneg_advertised = 0x2F;
+			} else {
+				if (mii_reg & 0x40)
+					spddplx = SPEED_1000;
+				else if (mii_reg & 0x2000)
+					spddplx = SPEED_100;
+				else
+					spddplx = SPEED_10;
+				spddplx += (mii_reg & 0x100) ?
+						FULL_DUPLEX : HALF_DUPLEX;
+				retval = e1000_set_spd_dplx(adapter, spddplx);
+				if (retval)
+					return retval;
+			}
+			if (netif_running(adapter->netdev)) {
+				e1000_down(adapter);
+				e1000_up(adapter);
+			} else {
+				e1000_reset(adapter);
+			}
+			break;
+		case M88E1000_PHY_SPEC_CTRL:
+		case M88E1000_EXT_PHY_SPEC_CTRL:
+			retval = e1000_phy_reset(&adapter->hw);
+			if (retval)
+				return -EIO;
+			break;
+		}
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_fiber_live_in_suspend
+ * @hw: e1000_hw struct containing device specific information
+ * This is called within e1000_suspend() to allow an action to be performed
+ * on an oem phy before before the MAC goes into suspend. This is only called
+ * if the STATUS.LU (link up) bit has been previous set.
+ * For ICP_XXXX, this is a no op
+ */
+void e1000_oem_fiber_live_in_suspend(struct e1000_hw *hw)
+{
+	return;
+}
+
+/*
+ * e1000_oem_get_phy_regs
+ * @adapter e1000_adapter struct containing device specific information
+ * @data unsigned integer array of size data_len
+ * @data_len number of elements in data
+ * This is called by e1000_get_regs() in response to an ethtool request
+ * to return the data of the controller. Most of the data returned is from
+ * the MAC, but some data comes from the PHY, thus from this f().
+ * Note: The call to e1000_get_regs() assumed an array of 24 elements
+ *       where the last 11 are passed to this function. If the array
+ *       that is passed to the calling function has its size or element
+ *       defintions changed, this function becomes broken.
+ */
+void e1000_oem_get_phy_regs(struct e1000_adapter *adapter, u32 *data,
+				u32 data_len)
+{
+#define EXPECTED_ARRAY_LEN 11
+	u32 corrected_len;
+
+	if (!adapter || !data)
+		return;
+
+	/* This f(n) expects to have EXPECTED_ARRAY_LEN elements to initialize.
+	 * Use the corrected_length variable to make sure we don't exceed that
+	 * length
+	 */
+	corrected_len = data_len > EXPECTED_ARRAY_LEN ?
+				EXPECTED_ARRAY_LEN : data_len;
+	memset(data, 0, corrected_len*sizeof(u32));
+
+	/*
+	 * Fill data[] with...
+	 * [0] = cable length
+	 * [1] = cable length
+	 * [2] = cable length
+	 * [3] = cable length
+	 * [4] = extended 10bt distance
+	 * [5] = cable polarity
+	 * [6] = cable polarity
+	 * [7] = polarity correction enabled
+	 * [8] = undefined
+	 * [9] = phy receive errors
+	 * [10] = mdix mode
+	 */
+	switch (e1000_oem_get_phy_dev_number(&adapter->hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		if (corrected_len > 0)
+			e1000_oem_read_phy_reg_ex(
+				&adapter->hw, M88E1000_PHY_SPEC_STATUS,
+				(u16 *)&data[0]);
+		if (corrected_len > 1)
+			data[1] = 0; /* Dummy(to align w/ IGP phy reg dump) */
+		if (corrected_len > 2)
+			data[2] = 0; /* Dummy(to align w/ IGP phy reg dump) */
+		if (corrected_len > 3)
+			data[3] = 0; /* Dummy(to align w/ IGP phy reg dump) */
+		if (corrected_len > 4)
+			e1000_oem_read_phy_reg_ex(
+				&adapter->hw, M88E1000_PHY_SPEC_CTRL,
+				(u16 *)&data[4]);
+		if (corrected_len > 5)
+			data[5] = data[0];
+		if (corrected_len > 6)
+			data[6] = 0; /* Dummy(to align w/ IGP phy reg dump) */
+		if (corrected_len > 7)
+			data[7] = data[4];
+		/* phy receive errors */
+		if (corrected_len > 9)
+			data[9] = adapter->phy_stats.receive_errors;
+		if (corrected_len > 10)
+			data[10] = data[0];
+		break;
+	}
+
+#undef EXPECTED_ARRAY_LEN
+	return;
+}
+
+/*
+ * e1000_oem_phy_loopback
+ * @adapter e1000_adapter struct containing device specific information
+ * This is called from e1000_set_phy_loopback in response from call from
+ * ethtool to place the PHY into loopback mode.
+ */
+int e1000_oem_phy_loopback(struct e1000_adapter *adapter)
+{
+	int ret_val;
+	u32 ctrl_reg = 0;
+
+	if (!adapter)
+		return -1;
+
+	/*
+	 * This borrows liberally from e1000_integrated_phy_loopback().
+	 * e1000_nonintegrated_phy_loopback() was also a point of reference
+	 * since it was similar. The biggest difference between the two
+	 * was that nonintegrated called e1000_phy_reset_clk_and_crs(),
+	 * hopefully this won't matter as CRS required for half-duplex
+	 * operation and this is set to full duplex.
+	 * Make note that the M88 phy is what'll be used on Truxton
+	 */
+	switch (e1000_oem_get_phy_dev_number(&adapter->hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		adapter->hw.autoneg = false;
+
+		/* autoneg off */
+		ret_val = e1000_oem_write_phy_reg_ex(&adapter->hw, PHY_CTRL,
+							0xa100);
+		if (ret_val)
+			return ret_val;
+
+		/* force 1000, set loopback */
+		ret_val = e1000_oem_write_phy_reg_ex(&adapter->hw, PHY_CTRL,
+				0x6100);
+		if (ret_val)
+			return ret_val;
+
+		ctrl_reg = E1000_READ_REG_ARRAY(&adapter->hw, CTRL, 0);
+		ctrl_reg &= ~E1000_CTRL_SPD_SEL;     /* speed sel bits */
+		ctrl_reg |= (E1000_CTRL_FRCSPD	     /* Force Speed Bit */
+				| E1000_CTRL_FRCDPX  /* Force Duplex Bit */
+				| E1000_CTRL_SPD_100 /* Force Speed to 1000 */
+				| E1000_CTRL_FD);    /* Force Duplex to FULL */
+
+		E1000_WRITE_REG_ARRAY(&adapter->hw, CTRL, 0, ctrl_reg);
+
+		/*
+		 * Write to PHY registers 29 and 30 to disable the Receiver.
+		 * This directly lifted from e1000_phy_disable_receiver().
+		 * The code is currently commented out as for the M88 used in
+		 * Truxton, registers 29 and 30 are unutilized. Leave in, just
+		 * in case we are on the receiving end of an 'undocumented'
+		 * feature
+		 */
+		/*
+		 * e1000_oem_write_phy_reg_ex(&adapter->hw, 29, 0x001F);
+		 * e1000_oem_write_phy_reg_ex(&adapter->hw, 30, 0x8FFC);
+		 * e1000_oem_write_phy_reg_ex(&adapter->hw, 29, 0x001A);
+		 * e1000_oem_write_phy_reg_ex(&adapter->hw, 30, 0x8FF0);
+		 */
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * e1000_oem_loopback_cleanup
+ * @adapter e1000_adapter struct containing device specific information
+ * This is called from e1000_loopback_cleanup in response from call from
+ * ethtool to place the PHY out of loopback mode. This handles the OEM
+ * specific part of loopback cleanup.
+ */
+void e1000_oem_loopback_cleanup(struct e1000_adapter *adapter)
+{
+	/*
+	 * This borrows liberally from e1000_loopback_cleanup().
+	 * making note that the M88 phy is what'll be used on Truxton
+	 */
+	int ret_val;
+	u16 phy_reg;
+
+	if (!adapter)
+		return;
+
+	switch (e1000_oem_get_phy_dev_number(&adapter->hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		adapter->hw.autoneg = true;
+
+		ret_val = e1000_oem_read_phy_reg_ex(&adapter->hw, PHY_CTRL,
+							&phy_reg);
+		if (ret_val)
+			return;
+
+		if (phy_reg & MII_CR_LOOPBACK) {
+			phy_reg &= ~MII_CR_LOOPBACK;
+
+			ret_val = e1000_oem_write_phy_reg_ex(
+					&adapter->hw, PHY_CTRL, phy_reg);
+			if (ret_val)
+				return;
+
+			e1000_phy_reset(&adapter->hw);
+		}
+		break;
+	}
+
+	return;
+}
+
+/*
+ * e1000_oem_phy_speed_downgraded
+ * @hw e1000_hw struct containing device specific information
+ * @isDowngraded returns with value > 0 if the link belonging to hw
+ *               has been downshifted
+ * Called by e1000_check_downshift(), checks the PHY to see if it running
+ * at as speed slower than its maximum.
+ */
+u32 e1000_oem_phy_speed_downgraded(struct e1000_hw *hw, u16 *isDowngraded)
+{
+	u32 ret_val;
+	u16 phy_data;
+
+	if (!hw || !isDowngraded)
+		return 1;
+
+	/*
+	 * borrow liberally from E1000_check_downshift e1000_phy_m88 case.
+	 * Make note that the M88 phy is what'll be used on Truxton
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		*isDowngraded = (phy_data & M88E1000_PSSR_DOWNSHIFT) >>
+					M88E1000_PSSR_DOWNSHIFT_SHIFT;
+
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * e1000_oem_check_polarity
+ * @hw e1000_hw struct containing device specific information
+ * @isDowngraded returns with value > 0 if the link belonging to hw
+ *               has its polarity shifted.
+ * Called by e1000_check_downshift(), checks the PHY to see if it running
+ * at as speed slower than its maximum.
+ */
+int e1000_oem_check_polarity(struct e1000_hw *hw, e1000_rev_polarity *polarity)
+{
+	int ret_val;
+	u16 phy_data;
+
+	if (!hw || !polarity)
+		return -1;
+
+	/*
+	 * borrow liberally from e1000_check_polarity.
+	 * Make note that the M88 phy is what'll be used on Truxton
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		/* return the Polarity bit in the Status register. */
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		*polarity = (phy_data & M88E1000_PSSR_REV_POLARITY) >>
+				M88E1000_PSSR_REV_POLARITY_SHIFT;
+
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * e1000_oem_phy_is_full_duplex
+ * @hw e1000_hw struct containing device specific information
+ * @isFD a boolean returning true if phy is full duplex
+ * This is called as part of e1000_config_mac_to_phy() to align
+ * the MAC with the PHY. It turns out on ICP_XXXX, this is not
+ * done automagically.
+ */
+int e1000_oem_phy_is_full_duplex(struct e1000_hw *hw, int *isFD)
+{
+	u16 phy_data;
+	int ret_val;
+
+	if (!hw || !isFD)
+		return -1;
+
+	/*
+	 * Make note that the M88 phy is what'll be used on Truxton
+	 * see e1000_config_mac_to_phy
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		*isFD = (phy_data & M88E1000_PSSR_DPLX) != 0;
+
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_phy_is_speed_1000
+ * @hw e1000_hw struct containing device specific information
+ * @is1000 a boolean returning true if phy is running at 1000
+ * This is called as part of e1000_config_mac_to_phy() to align
+ * the MAC with the PHY. It turns out on ICP_XXXX, this is not
+ * done automagically.
+ */
+int e1000_oem_phy_is_speed_1000(struct e1000_hw *hw, int *is1000)
+{
+	u16 phy_data;
+	int ret_val;
+
+	if (!hw || !is1000)
+		return -1;
+
+	/*
+	 * Make note that the M88 phy is what'll be used on Truxton.
+	 * see e1000_config_mac_to_phy
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		*is1000 = (phy_data & M88E1000_PSSR_SPEED) ==
+				M88E1000_PSSR_1000MBS;
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_phy_is_speed_100
+ * @hw e1000_hw struct containing device specific information
+ * @is100 a boolean returning true if phy is running at 100
+ * This is called as part of e1000_config_mac_to_phy() to align
+ * the MAC with the PHY. It turns out on ICP_XXXX, this is not
+ * done automagically.
+ */
+int e1000_oem_phy_is_speed_100(struct e1000_hw *hw, int *is100)
+{
+	u16 phy_data;
+	int ret_val;
+
+	if (!hw || !is100)
+		return -1;
+
+	/*
+	 * Make note that the M88 phy is what'll be used on Truxton
+	 * see e1000_config_mac_to_phy
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		*is100 = (phy_data & M88E1000_PSSR_SPEED) ==
+				M88E1000_PSSR_100MBS;
+
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_phy_get_info
+ * @hw struct e1000_hw containing hardware specific data
+ * @phy_info struct e1000_phy_info that returned
+ * This is called by e1000_phy_get_info to gather PHY specific
+ * data. This is called for copper media based phys.
+ */
+int e1000_oem_phy_get_info(struct e1000_hw *hw,
+				struct e1000_phy_info *phy_info)
+{
+	int ret_val;
+	u16 phy_data;
+	e1000_rev_polarity polarity;
+
+	if (!hw || !phy_info)
+		return -1;
+
+	/*
+	 * Make note that the M88 phy is what'll be used on Truxton
+	 * see e1000_phy_m88_get_info
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		/*
+		 * The downshift status is checked only once, after link is
+		 * established and it stored in the hw->speed_downgraded
+		 * parameter.
+		 */
+		phy_info->downshift = (e1000_downshift)hw->speed_downgraded;
+
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		phy_info->extended_10bt_distance =
+			(phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE)
+				>> M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT;
+		phy_info->polarity_correction =
+			(phy_data & M88E1000_PSCR_POLARITY_REVERSAL)
+				>> M88E1000_PSCR_POLARITY_REVERSAL_SHIFT;
+
+		/* Check polarity status */
+		ret_val = e1000_oem_check_polarity(hw, &polarity);
+		if (ret_val)
+			return ret_val;
+
+		phy_info->cable_polarity = polarity;
+
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		phy_info->mdix_mode = (phy_data & M88E1000_PSSR_MDIX)
+						>> M88E1000_PSSR_MDIX_SHIFT;
+
+		if ((phy_data & M88E1000_PSSR_SPEED) ==
+			M88E1000_PSSR_1000MBS) {
+			/*
+			 * Cable Length Estimation and Local/Remote Receiver
+			 * Information are only valid at 1000 Mbps.
+			 */
+			phy_info->cable_length =
+				(phy_data & M88E1000_PSSR_CABLE_LENGTH)
+					>> M88E1000_PSSR_CABLE_LENGTH_SHIFT;
+
+			ret_val = e1000_oem_read_phy_reg_ex(
+					hw, PHY_1000T_STATUS, &phy_data);
+			if (ret_val)
+				return ret_val;
+
+			phy_info->local_rx =
+				(phy_data & SR_1000T_LOCAL_RX_STATUS)
+					>> SR_1000T_LOCAL_RX_STATUS_SHIFT;
+
+			phy_info->remote_rx =
+				(phy_data & SR_1000T_REMOTE_RX_STATUS)
+					>> SR_1000T_REMOTE_RX_STATUS_SHIFT;
+		}
+
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_phy_hw_reset
+ * @hw struct e1000_hw containing hardware specific data
+ * This function will perform a software initiated reset of
+ * the PHY
+ */
+int e1000_oem_phy_hw_reset(struct e1000_hw *hw)
+{
+	int ret_val;
+	u16 phy_data;
+
+	if (!hw)
+		return -1;
+
+	/*
+	 * This code pretty much copies the default case from
+	 * e1000_phy_reset() as that is what is appropriate for
+	 * the M88 used in truxton.
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = e1000_oem_read_phy_reg_ex(hw, PHY_CTRL, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		phy_data |= MII_CR_RESET;
+		ret_val = e1000_oem_write_phy_reg_ex(hw, PHY_CTRL, phy_data);
+		if (ret_val)
+			return ret_val;
+
+		udelay(1);
+
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+
+/*
+ * e1000_oem_phy_init_script
+ * @hw struct e1000_hw containing hardware specific data
+ * This gets called in three places, after e1000_oem_phy_hw_reset()
+ * to perform and post reset initialiation. Not all PHYs require
+ * this, which is why it was split off as a seperate function.
+ */
+void e1000_oem_phy_init_script(struct e1000_hw *hw)
+{
+	if (!hw)
+		return;
+
+	/*
+	 * call the GCU func that can do any phy specific init
+	 * functions after a reset
+	 * Make note that the M88 phy is what'll be used on Truxton
+	 * The closest thing is in e1000_phy_init_script, however this is
+	 * for the IGP style of phy. This is probably a no-op for truxton
+	 * but may be needed by OEM's later on
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		break;
+	}
+
+	return;
+}
+
+/*
+ * e1000_oem_read_phy_reg_ex
+ * @hw struct e1000_hw containing hardware specific data
+ * @reg_addr address location within the PHY register set
+ * @phy_data returns the data read from reg_addr
+ * This encapsulates the interface call to the GCU for access
+ * to the MDIO for the PHY.
+ */
+int e1000_oem_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data)
+{
+	int ret_val;
+
+	if (!hw || !phy_data)
+		return -1;
+
+	/*
+	 * call the GCU func that will read the phy
+	 * Make note that the M88 phy is what'll be used on Truxton.
+	 * The closest thing is in e1000_read_phy_reg_ex.
+	 * NOTE: this is 1 (of 2) functions that is truly dependant on the
+	 *       gcu module
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = gcu_read_eth_phy(e1000_oem_get_phy_dev_number(hw),
+						reg_addr, phy_data);
+		if (ret_val)
+			return ret_val;
+
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_write_phy_reg_ex
+ * @hw struct e1000_hw containing hardware specific data
+ * @reg_addr address location within the PHY register set
+ * @phy_data data to be written to reg_addr
+ * This encapsulates the interface call to the GCU for access
+ * to the MDIO for the PHY.
+ */
+int e1000_oem_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr, u16 phy_data)
+{
+	int ret_val;
+
+	if (!hw)
+		return -1;
+
+	/*
+	 * call the GCU func that will write to the phy
+	 * Make note that the M88 phy is what'll be used on Truxton.
+	 * The closest thing is in e1000_write_phy_reg_ex
+	 * NOTE: this is 2 (of 2) functions that is truly dependant on the
+	 *       gcu module
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = gcu_write_eth_phy(e1000_oem_get_phy_dev_number(hw),
+						reg_addr, phy_data);
+		if (ret_val)
+			return ret_val;
+
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_phy_needs_reset_with_mac
+ * @hw struct e1000_hw hardware specific data
+ * e1000_reset_hw is called to reset the MAC. If, for
+ * some reason the PHY needs to be reset as well, this
+ * should return TRUE and then e1000_oem_phy_hw_reset()
+ * will be called.
+ */
+int e1000_oem_phy_needs_reset_with_mac(struct e1000_hw *hw)
+{
+	int ret_val;
+
+	if (!hw)
+		return false;
+
+	/*
+	 * From the original iegbe driver, the M88
+	 * PHYs did not seem to need this reset,
+	 * so returning FALSE.
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = false;
+		break;
+	}
+
+	return ret_val;
+}
+
+/*
+ * e1000_oem_config_dsp_after_link_change
+ * @hw struct e1000_hw containing hardware specific data
+ * @link_up allows different configurations based on whether
+ *          not the link was up.
+ * This is called from e1000_check_for_link, and allows for
+ * tweaking of the PHY, for PHYs that support a DSP.
+ */
+int e1000_oem_config_dsp_after_link_change(struct e1000_hw *hw, int link_up)
+{
+	if (!hw)
+		return -1;
+
+	/*
+	 * Make note that the M88 phy is what'll be used on Truxton,
+	 * but in the iegbe driver, it had no such func. This is a no-op
+	 * for M88, but may be useful for other phys
+	 * use e1000_config_dsp_after_link_change as example
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_get_cable_length
+ * @hw struct e1000_hw containing hardware specific data
+ * @min_length pointer to return the approx minimum length
+ * @max_length pointer to return the approx maximum length
+ */
+int e1000_oem_get_cable_length(struct e1000_hw *hw, u16 *min_length,
+				u16 *max_length)
+{
+	int ret_val;
+	u16 cable_length;
+	u16 phy_data;
+
+	if (!hw || !min_length || !max_length)
+		return -1;
+
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		cable_length = (phy_data & M88E1000_PSSR_CABLE_LENGTH)
+					>> M88E1000_PSSR_CABLE_LENGTH_SHIFT;
+
+		/* Convert the enum value to ranged values */
+		switch (cable_length) {
+		case e1000_cable_length_50:
+			*min_length = 0;
+			*max_length = e1000_igp_cable_length_50;
+			break;
+		case e1000_cable_length_50_80:
+			*min_length = e1000_igp_cable_length_50;
+			*max_length = e1000_igp_cable_length_80;
+			break;
+		case e1000_cable_length_80_110:
+			*min_length = e1000_igp_cable_length_80;
+			*max_length = e1000_igp_cable_length_110;
+			break;
+		case e1000_cable_length_110_140:
+			*min_length = e1000_igp_cable_length_110;
+			*max_length = e1000_igp_cable_length_140;
+			break;
+		case e1000_cable_length_140:
+			*min_length = e1000_igp_cable_length_140;
+			*max_length = e1000_igp_cable_length_170;
+			break;
+		default:
+			return -E1000_ERR_PHY;
+			break;
+		}
+
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*
+ * e1000_oem_phy_is_link_up
+ * @hw e1000_hw struct containing device specific information
+ * @isUp a boolean returning true if link is up
+ * This is called as part of e1000_config_mac_to_phy() to align
+ * the MAC with the PHY. It turns out on ICP_XXXX, this is not
+ * done automagically.
+ */
+int e1000_oem_phy_is_link_up(struct e1000_hw *hw, int *isUp)
+{
+	u16 phy_data;
+	int ret_val;
+
+	if (!hw || !isUp)
+		return -1;
+
+	/*
+	 * Make note that the M88 phy is what'll be used on Truxton
+	 * see e1000_config_mac_to_phy
+	 */
+	switch (e1000_oem_get_phy_dev_number(hw)) {
+	case ICP_XXXX_PHY_0:
+	case ICP_XXXX_PHY_1:
+	case ICP_XXXX_PHY_2:
+	default:
+		/*
+		 * according to the Marvell data sheet, it is required to
+		 * read the PHY_SPEC_STATUS register twice if one wishes to
+		 * obtain the current link state
+		 */
+		e1000_oem_read_phy_reg_ex(
+			hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		ret_val = e1000_oem_read_phy_reg_ex(
+				hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		if (ret_val)
+			return ret_val;
+
+		*isUp = (phy_data & M88E1000_PSSR_LINK) != 0;
+
+		break;
+	}
+
+	return E1000_SUCCESS;
+}
diff --git a/drivers/net/e1000/e1000_oem_phy.h b/drivers/net/e1000/e1000_oem_phy.h
new file mode 100644
index 0000000..0668f66
--- /dev/null
+++ b/drivers/net/e1000/e1000_oem_phy.h
@@ -0,0 +1,89 @@
+/*******************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+ version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+*******************************************************************************/
+#ifndef _IEGBE_OEM_PHY_H_
+#define _IEGBE_OEM_PHY_H_
+
+#include <linux/types.h>
+#include "e1000_hw.h"
+
+struct e1000_hw;
+struct e1000_adapter;
+struct ifreq;
+struct e1000_phy_info;
+
+int e1000_oem_setup_link(struct e1000_hw *hw);
+
+u32 e1000_oem_get_tipg(struct e1000_hw *hw);
+int e1000_oem_phy_is_copper(struct e1000_hw *hw);
+u32 e1000_oem_get_phy_dev_number(struct e1000_hw *hw);
+int e1000_oem_mii_ioctl(struct e1000_adapter *adapter, unsigned long flags,
+			struct ifreq *ifr, int cmd);
+void e1000_oem_fiber_live_in_suspend(struct e1000_hw *hw);
+void e1000_oem_get_phy_regs(struct e1000_adapter *adapter, u32 *data,
+				u32 data_length);
+int e1000_oem_phy_loopback(struct e1000_adapter *adapter);
+void e1000_oem_loopback_cleanup(struct e1000_adapter *adapter);
+u32 e1000_oem_phy_speed_downgraded(struct e1000_hw *hw, u16 *isDowngraded);
+int e1000_oem_check_polarity(struct e1000_hw *hw, e1000_rev_polarity *polarity);
+int e1000_oem_phy_is_full_duplex(struct e1000_hw *hw, int *isFD);
+int e1000_oem_phy_is_speed_1000(struct e1000_hw *hw, int *is1000);
+int e1000_oem_phy_is_speed_100(struct e1000_hw *hw, int *is100);
+int e1000_oem_force_mdi(struct e1000_hw *hw, int *resetPhy);
+int e1000_oem_phy_reset_dsp(struct e1000_hw *hw);
+int e1000_oem_cleanup_after_phy_reset(struct e1000_hw *hw);
+int e1000_oem_phy_get_info(struct e1000_hw *hw,
+				struct e1000_phy_info *phy_info);
+int e1000_oem_phy_hw_reset(struct e1000_hw *hw);
+void e1000_oem_phy_init_script(struct e1000_hw *hw);
+int e1000_oem_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
+				u16 *phy_data);
+int e1000_oem_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
+				u16 phy_data);
+int e1000_oem_phy_needs_reset_with_mac(struct e1000_hw *hw);
+int e1000_oem_config_dsp_after_link_change(struct e1000_hw *hw, int link_up);
+int e1000_oem_get_cable_length(struct e1000_hw *hw, u16 *min_length,
+				u16 *max_length);
+int e1000_oem_phy_is_link_up(struct e1000_hw *hw, int *isUp);
+
+/* Default Register Macros */
+#define ICP_XXXX_MAC_0 0/* PCI Device numbers associated with MACs on */
+#define ICP_XXXX_MAC_1 1/* ICP_XXXX family of controllers */
+#define ICP_XXXX_MAC_2 2
+
+#define ICP_XXXX_PHY_0 0/* Braindead pneumonics for PHY numbers */
+#define ICP_XXXX_PHY_1 1
+#define ICP_XXXX_PHY_2 2
+
+#define DEFAULT_ICP_XXXX_TIPG_IPGT 8	/* Inter Packet Gap Transmit Time */
+#define ICP_XXXX_TIPG_IPGT_MASK 0x000003FFUL
+
+#endif /* ifndef _IEGBE_OEM_PHY_H_ */
diff --git a/drivers/net/e1000/e1000_param.c b/drivers/net/e1000/e1000_param.c
index 213437d..8aef8f7 100644
--- a/drivers/net/e1000/e1000_param.c
+++ b/drivers/net/e1000/e1000_param.c
@@ -543,6 +543,12 @@ void __devinit e1000_check_options(struct e1000_adapter *adapter)
 	case e1000_media_type_copper:
 		e1000_check_copper_options(adapter);
 		break;
+	case e1000_media_type_oem:
+		if (e1000_oem_phy_is_copper(&adapter->hw))
+			e1000_check_copper_options(adapter);
+		else
+			e1000_check_fiber_options(adapter);
+		break;
 	default:
 		BUG();
 	}
-- 
1.6.0.3

