From 6a047db14ae68e1fe07c6538a1991d3e7e6fe924 Mon Sep 17 00:00:00 2001
From: Junxiao Bi <junxiao.bi@windriver.com>
Date: Mon, 24 Oct 2011 17:43:37 +0800
Subject: [PATCH] intel_truxton: fix tx packets statistics

The intel_truxton has a custom NIC driver, which was based on the e1000.
This driver introduces a new function e1000_clean_tx_ring_partial() to
clean the tx ring buffers. This function does not add to tx packet statistics,
but it should. To fix this, we add tx packet statistic calculations based
on the e1000 e1000_clean_tx_irq().

Signed-off-by: Junxiao Bi <junxiao.bi@windriver.com>
---
 drivers/net/e1000/e1000_main.c |   25 +++++++++++++++++++++++++
 1 files changed, 25 insertions(+), 0 deletions(-)

diff --git a/drivers/net/e1000/e1000_main.c b/drivers/net/e1000/e1000_main.c
index 55cfb8a..523eae7 100644
--- a/drivers/net/e1000/e1000_main.c
+++ b/drivers/net/e1000/e1000_main.c
@@ -3939,6 +3939,9 @@ static void e1000_clean_tx_ring_partial(struct e1000_adapter *adapter,
 	unsigned tail;
 	unsigned head;
 	int cleaned = false;
+	unsigned int eop;
+	unsigned int total_tx_bytes=0, total_tx_packets=0;
+	int counted = false;
 
 	tail = readl(adapter->hw.hw_addr + tx_ring->tdt);
 	head = readl(adapter->hw.hw_addr + tx_ring->tdh);
@@ -3947,17 +3950,34 @@ static void e1000_clean_tx_ring_partial(struct e1000_adapter *adapter,
 	 *  the current head pointer
 	 */
 	i = tx_ring->next_to_clean;
+	eop = tx_ring->buffer_info[i].next_to_watch;
 	while (i != head) {
 		cleaned = true;
 		tx_desc = E1000_TX_DESC(*tx_ring, i);
 
 		buffer_info = &tx_ring->buffer_info[i];
+		if (i == eop && buffer_info->skb) {
+			struct sk_buff *skb = buffer_info->skb;
+			unsigned int segs, bytecount;
+			segs = skb_shinfo(skb)->gso_segs ?: 1;
+			/* multiply data chunks by size of headers */
+			bytecount = ((segs - 1) * skb_headlen(skb)) +
+				skb->len;
+			total_tx_packets += segs;
+			total_tx_bytes += bytecount;
+			counted = true;
+		}
+
 		e1000_unmap_and_free_tx_resource(adapter, buffer_info);
 
 		tx_desc->upper.data = 0;
 
 		if (unlikely(++i == tx_ring->count))
 			i = 0;
+		if (counted) {
+			eop = tx_ring->buffer_info[i].next_to_watch;
+			counted = false;
+		}
 	}
 	tx_ring->next_to_clean = head;
 
@@ -3970,6 +3990,11 @@ static void e1000_clean_tx_ring_partial(struct e1000_adapter *adapter,
 	}
 
 	spin_unlock(&tx_ring->tx_lock);
+
+	adapter->total_tx_bytes += total_tx_bytes;
+	adapter->total_tx_packets += total_tx_packets;
+	adapter->net_stats.tx_bytes += total_tx_bytes;
+	adapter->net_stats.tx_packets += total_tx_packets;
 }
 
 /**
-- 
1.7.0.4

