From a36b3e98eeb446d0fc83aa52f8a080444d854652 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Wed, 2 Jul 2008 17:08:40 +0800
Subject: [PATCH] TOLAPAI ethernet driver

Add support for TOLAPAI Gigabit ethernet controller.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/Kconfig               |    2 +-
 drivers/net/e1000/Makefile        |    2 +-
 drivers/net/e1000/e1000.h         |    1 +
 drivers/net/e1000/e1000_ethtool.c |   48 +-
 drivers/net/e1000/e1000_hw.c      |  407 +++++++--
 drivers/net/e1000/e1000_hw.h      |  165 ++++
 drivers/net/e1000/e1000_main.c    |  271 +++++-
 drivers/net/e1000/e1000_oem_phy.c | 1899 +++++++++++++++++++++++++++++++++++++
 drivers/net/e1000/e1000_oem_phy.h |  104 ++
 drivers/net/e1000/e1000_param.c   |    6 +
 10 files changed, 2814 insertions(+), 91 deletions(-)
 create mode 100644 drivers/net/e1000/e1000_oem_phy.c
 create mode 100644 drivers/net/e1000/e1000_oem_phy.h

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 61ecee7..e8faac5 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -1953,7 +1953,7 @@ config DL2K
 
 config E1000
 	tristate "Intel(R) PRO/1000 Gigabit Ethernet support"
-	depends on PCI
+	depends on PCI && (!TOLAPAI || (TOLAPAI && TOLAPAI_GCU))
 	---help---
 	  This driver supports Intel(R) PRO/1000 gigabit ethernet family of
 	  adapters.  For more information on how to identify your adapter, go 
diff --git a/drivers/net/e1000/Makefile b/drivers/net/e1000/Makefile
index 4a6ab15..3dc1c19 100644
--- a/drivers/net/e1000/Makefile
+++ b/drivers/net/e1000/Makefile
@@ -32,4 +32,4 @@
 
 obj-$(CONFIG_E1000) += e1000.o
 
-e1000-objs := e1000_main.o e1000_hw.o e1000_ethtool.o e1000_param.o
+e1000-objs := e1000_main.o e1000_hw.o e1000_ethtool.o e1000_param.o e1000_oem_phy.o
diff --git a/drivers/net/e1000/e1000.h b/drivers/net/e1000/e1000.h
index 31feae1..3c1bb08 100644
--- a/drivers/net/e1000/e1000.h
+++ b/drivers/net/e1000/e1000.h
@@ -80,6 +80,7 @@
 struct e1000_adapter;
 
 #include "e1000_hw.h"
+#include "e1000_oem_phy.h"
 
 #ifdef DBG
 #define E1000_DBG(args...) printk(KERN_DEBUG "e1000: " args)
diff --git a/drivers/net/e1000/e1000_ethtool.c b/drivers/net/e1000/e1000_ethtool.c
index 701531e..4855d5d 100644
--- a/drivers/net/e1000/e1000_ethtool.c
+++ b/drivers/net/e1000/e1000_ethtool.c
@@ -118,7 +118,8 @@ e1000_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
 
-	if (hw->media_type == e1000_media_type_copper) {
+	if ((hw->media_type == e1000_media_type_copper) ||
+	   (hw->media_type == e1000_media_type_oem)) {
 
 		ecmd->supported = (SUPPORTED_10baseT_Half |
 		                   SUPPORTED_10baseT_Full |
@@ -282,7 +283,9 @@ e1000_set_pauseparam(struct net_device *netdev,
 		} else
 			e1000_reset(adapter);
 	} else
-		retval = ((hw->media_type == e1000_media_type_fiber) ?
+		retval = ((hw->media_type == e1000_media_type_fiber)
+			|| (hw->media_type == e1000_media_type_oem
+				&& !e1000_oem_phy_is_copper(&adapter->hw)) ?
 			  e1000_setup_link(hw) : e1000_force_mac_fc(hw));
 
 	clear_bit(__E1000_RESETTING, &adapter->flags);
@@ -442,6 +445,8 @@ e1000_get_regs(struct net_device *netdev,
 		regs_buff[22] = 0; /* phy receive errors (unavailable) */
 		regs_buff[23] = regs_buff[18]; /* mdix mode */
 		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
+	} else if (hw->phy_type == e1000_phy_oem) {
+ 	       e1000_oem_get_phy_regs(adapter, &regs_buff[13], 11);
 	} else {
 		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
 		regs_buff[13] = (u32)phy_data; /* cable length */
@@ -854,7 +859,8 @@ e1000_reg_test(struct e1000_adapter *adapter, u64 *data)
 
 		REG_SET_AND_CHECK(RCTL, before, 0xFFFFFFFF);
 		REG_PATTERN_TEST(RDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
-		if (adapter->hw.mac_type != e1000_ich8lan)
+		if (adapter->hw.mac_type != e1000_ich8lan
+			&& adapter->hw.mac_type != e1000_icp_xxxx)
 			REG_PATTERN_TEST(TXCW, 0xC000FFFF, 0x0000FFFF);
 		REG_PATTERN_TEST(TDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
 		REG_PATTERN_TEST(TIDV, 0x0000FFFF, 0x0000FFFF);
@@ -1397,7 +1403,9 @@ e1000_set_phy_loopback(struct e1000_adapter *adapter)
 	case e1000_ich8lan:
 		return e1000_integrated_phy_loopback(adapter);
 		break;
-
+	case e1000_icp_xxxx:
+       		return e1000_oem_phy_loopback(adapter);
+       		break;
 	default:
 		/* Default PHY loopback work is to read the MII
 		 * control register and assert bit 14 (loopback mode).
@@ -1441,7 +1449,9 @@ e1000_setup_loopback_test(struct e1000_adapter *adapter)
 			E1000_WRITE_REG(hw, RCTL, rctl);
 			return 0;
 		}
-	} else if (hw->media_type == e1000_media_type_copper)
+	} else if (adapter->hw.media_type == e1000_media_type_copper
+              || (adapter->hw.media_type == e1000_media_type_oem
+		  && e1000_oem_phy_is_copper(&adapter->hw)))
 		return e1000_set_phy_loopback(adapter);
 
 	return 7;
@@ -1468,6 +1478,10 @@ e1000_loopback_cleanup(struct e1000_adapter *adapter)
 			msleep(10);
 			break;
 		}
+	case e1000_media_type_oem:
+	        e1000_oem_loopback_cleanup(adapter);
+		break;
+
 		/* Fall Through */
 	case e1000_82545:
 	case e1000_82546:
@@ -1625,8 +1639,24 @@ e1000_link_test(struct e1000_adapter *adapter, u64 *data)
 		if (adapter->hw.autoneg)  /* if auto_neg is set wait for it */
 			msleep(4000);
 
-		if (!(E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU)) {
-			*data = 1;
+		/*
+		 * ICP_XXXX style MAC's do not have a link up bit int the STATUS
+		 * register, so query the PHY directly
+		 */
+		if (adapter->hw.mac_type != e1000_icp_xxxx) {
+			if (!(E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU))
+				*data = 1;
+		} else {
+			int isUp = 0;
+			if (e1000_oem_phy_is_link_up(&adapter->hw, &isUp) != E1000_SUCCESS)
+				printk("unable to determine Link Status!\n");
+			else
+			{
+				if (isUp)
+					*data = 0;
+				else
+					*data = 1;
+			}
 		}
 	}
 	return *data;
@@ -1881,6 +1911,10 @@ e1000_phys_id(struct net_device *netdev, u32 data)
 {
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 
+ 	if (adapter->hw.mac_type == e1000_icp_xxxx)
+ 		/* No LED control on ICP family of gigE controllers */
+ 		return 0;
+ 
 	if (!data)
 		data = INT_MAX;
 
diff --git a/drivers/net/e1000/e1000_hw.c b/drivers/net/e1000/e1000_hw.c
index 9a4b6cb..9bfd172 100644
--- a/drivers/net/e1000/e1000_hw.c
+++ b/drivers/net/e1000/e1000_hw.c
@@ -31,6 +31,7 @@
  */
 
 
+#include "e1000_oem_phy.h"
 #include "e1000_hw.h"
 
 static s32 e1000_swfw_sync_acquire(struct e1000_hw *hw, u16 mask);
@@ -96,7 +97,7 @@ static void e1000_phy_init_script(struct e1000_hw *hw);
 static s32 e1000_setup_copper_link(struct e1000_hw *hw);
 static s32 e1000_setup_fiber_serdes_link(struct e1000_hw *hw);
 static s32 e1000_adjust_serdes_amplitude(struct e1000_hw *hw);
-static s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw);
+s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw);
 static s32 e1000_config_mac_to_phy(struct e1000_hw *hw);
 static void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl);
 static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl);
@@ -419,6 +420,20 @@ e1000_set_mac_type(struct e1000_hw *hw)
 	case E1000_DEV_ID_ICH8_IGP_M:
 		hw->mac_type = e1000_ich8lan;
 		break;
+	case E1000_DEV_ID_ICP_5040:
+	case E1000_DEV_ID_ICP_5041:
+	case E1000_DEV_ID_ICP_5042:
+	case E1000_DEV_ID_ICP_5043:
+	case E1000_DEV_ID_ICP_5044:
+	case E1000_DEV_ID_ICP_5045:
+	case E1000_DEV_ID_ICP_5046:
+	case E1000_DEV_ID_ICP_5047:
+	case E1000_DEV_ID_ICP_5048:
+	case E1000_DEV_ID_ICP_5049:
+	case E1000_DEV_ID_ICP_504A:
+	case E1000_DEV_ID_ICP_504B:
+		hw->mac_type = e1000_icp_xxxx;
+ 		break;
 	default:
 		/* Should never have loaded on this device */
 		return -E1000_ERR_MAC_TYPE;
@@ -496,6 +511,20 @@ e1000_set_media_type(struct e1000_hw *hw)
     case E1000_DEV_ID_80003ES2LAN_SERDES_DPT:
         hw->media_type = e1000_media_type_internal_serdes;
         break;
+    case E1000_DEV_ID_ICP_5040:
+    case E1000_DEV_ID_ICP_5041:
+    case E1000_DEV_ID_ICP_5042:
+    case E1000_DEV_ID_ICP_5043:
+    case E1000_DEV_ID_ICP_5044:
+    case E1000_DEV_ID_ICP_5045:
+    case E1000_DEV_ID_ICP_5046:
+    case E1000_DEV_ID_ICP_5047:
+    case E1000_DEV_ID_ICP_5048:
+    case E1000_DEV_ID_ICP_5049:
+    case E1000_DEV_ID_ICP_504A:
+    case E1000_DEV_ID_ICP_504B:
+	hw->media_type = e1000_media_type_oem;
+	break;
     default:
         switch (hw->mac_type) {
         case e1000_82542_rev2_0:
@@ -585,6 +614,13 @@ e1000_reset_hw(struct e1000_hw *hw)
         msleep(5);
     }
 
+    if (hw->phy_type == e1000_phy_oem
+       && e1000_oem_phy_needs_reset_with_mac(hw)) {
+        ret_val = e1000_oem_phy_hw_reset(hw);
+        if (ret_val)
+            return ret_val;
+     }
+
     /* Must acquire the MDIO ownership before MAC reset.
      * Ownership defaults to firmware after a reset. */
     if (hw->mac_type == e1000_82573) {
@@ -700,7 +736,9 @@ e1000_reset_hw(struct e1000_hw *hw)
     }
 
     /* Disable HW ARPs on ASF enabled adapters */
-    if (hw->mac_type >= e1000_82540 && hw->mac_type <= e1000_82547_rev_2) {
+    if (hw->mac_type >= e1000_82540
+       && hw->mac_type <= e1000_82547_rev_2
+       && hw->mac_type != e1000_icp_xxxx) {
         manc = E1000_READ_REG(hw, MANC);
         manc &= ~(E1000_MANC_ARP_EN);
         E1000_WRITE_REG(hw, MANC, manc);
@@ -716,6 +754,11 @@ e1000_reset_hw(struct e1000_hw *hw)
         E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
     }
 
+    /* default configure the oem phy */
+    if (hw->phy_type == e1000_phy_oem
+       && e1000_oem_phy_needs_reset_with_mac(hw))
+        e1000_oem_phy_init_script(hw);
+
     /* Clear interrupt mask to stop board from generating interrupts */
     DEBUGOUT("Masking off all interrupts\n");
     E1000_WRITE_REG(hw, IMC, 0xffffffff);
@@ -1106,6 +1149,7 @@ e1000_setup_link(struct e1000_hw *hw)
     u32 ctrl_ext;
     s32 ret_val;
     u16 eeprom_data;
+    u16 eeprom_control2_reg_offset = 0;
 
     DEBUGFUNC("e1000_setup_link");
 
@@ -1114,6 +1158,14 @@ e1000_setup_link(struct e1000_hw *hw)
     if (e1000_check_phy_reset_block(hw))
         return E1000_SUCCESS;
 
+    /* for icp_xxxx style controllers, the init control 2 and 3 are packed into
+     * a single word, with the top byte being occupied by control 2
+     */
+    eeprom_control2_reg_offset =
+        hw->mac_type != e1000_icp_xxxx
+        ? EEPROM_INIT_CONTROL2_REG
+        : EEPROM_INIT_CONTROL3_ICP_xxxx(e1000_oem_get_phy_dev_number(hw));
+
     /* Read and store word 0x0F of the EEPROM. This word contains bits
      * that determine the hardware's default PAUSE (flow control) mode,
      * a bit that determines whether the HW defaults to enabling or
@@ -1129,7 +1181,7 @@ e1000_setup_link(struct e1000_hw *hw)
             hw->fc = E1000_FC_FULL;
             break;
         default:
-            ret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
+            ret_val = e1000_read_eeprom(hw, eeprom_control2_reg_offset,
                                         1, &eeprom_data);
             if (ret_val) {
                 DEBUGOUT("EEPROM Read Error\n");
@@ -1180,9 +1232,17 @@ e1000_setup_link(struct e1000_hw *hw)
     }
 
     /* Call the necessary subroutine to configure the link. */
-    ret_val = (hw->media_type == e1000_media_type_copper) ?
-              e1000_setup_copper_link(hw) :
-              e1000_setup_fiber_serdes_link(hw);
+    switch(hw->media_type) {
+    case e1000_media_type_copper:
+        ret_val = e1000_setup_copper_link(hw);
+	break;
+    case e1000_media_type_oem:
+        ret_val = e1000_oem_setup_link(hw);
+        break;
+    default:
+        ret_val = e1000_setup_fiber_serdes_link(hw);
+        break;
+    }
 
     /* Initialize the flow control address, type, and PAUSE timer
      * registers to their default values.  This is done even if flow
@@ -1348,8 +1408,17 @@ e1000_setup_fiber_serdes_link(struct e1000_hw *hw)
         DEBUGOUT("Looking for Link\n");
         for (i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
             msleep(10);
-            status = E1000_READ_REG(hw, STATUS);
-            if (status & E1000_STATUS_LU) break;
+	    if (hw->mac_type != e1000_icp_xxxx) {
+                status = E1000_READ_REG(hw, STATUS);
+                if (status & E1000_STATUS_LU) break;
+	    } else {
+		int isUp = 0;
+		if (e1000_oem_phy_is_link_up(hw, &isUp) != E1000_SUCCESS)
+			isUp = 0;
+
+			if (isUp)
+			break;
+	    }
         }
         if (i == (LINK_UP_TIMEOUT / 10)) {
             DEBUGOUT("Never got a valid link from auto-neg!!!\n");
@@ -1839,8 +1908,7 @@ e1000_copper_link_mgp_setup(struct e1000_hw *hw)
 *
 * hw - Struct containing variables accessed by shared code
 *********************************************************************/
-static s32
-e1000_copper_link_autoneg(struct e1000_hw *hw)
+s32 e1000_copper_link_autoneg(struct e1000_hw *hw)
 {
     s32 ret_val;
     u16 phy_data;
@@ -1910,8 +1978,7 @@ e1000_copper_link_autoneg(struct e1000_hw *hw)
 *
 * hw - Struct containing variables accessed by shared code
 ******************************************************************************/
-static s32
-e1000_copper_link_postconfig(struct e1000_hw *hw)
+s32 e1000_copper_link_postconfig(struct e1000_hw *hw)
 {
     s32 ret_val;
     DEBUGFUNC("e1000_copper_link_postconfig");
@@ -1940,6 +2007,15 @@ e1000_copper_link_postconfig(struct e1000_hw *hw)
         }
     }
 
+    /* Config DSP to improve Giga link quality */
+    if (hw->phy_type == e1000_phy_oem) {
+        ret_val = e1000_oem_config_dsp_after_link_change(hw, true);
+        if (ret_val) {
+            DEBUGOUT("Error Configuring OEM PHY DSP after link up\n");
+            return ret_val;
+        }
+    }
+
     return E1000_SUCCESS;
 }
 
@@ -2284,8 +2360,7 @@ e1000_phy_setup_autoneg(struct e1000_hw *hw)
 *
 * hw - Struct containing variables accessed by shared code
 ******************************************************************************/
-static s32
-e1000_phy_force_speed_duplex(struct e1000_hw *hw)
+s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)
 {
     u32 ctrl;
     s32 ret_val;
@@ -2293,6 +2368,7 @@ e1000_phy_force_speed_duplex(struct e1000_hw *hw)
     u16 mii_status_reg;
     u16 phy_data;
     u16 i;
+    bool resetPhy = false;
 
     DEBUGFUNC("e1000_phy_force_speed_duplex");
 
@@ -2391,6 +2467,16 @@ e1000_phy_force_speed_duplex(struct e1000_hw *hw)
         if (ret_val)
             return ret_val;
 
+    } else if (hw->phy_type == e1000_phy_oem) {
+        ret_val = e1000_oem_force_mdi(hw, (int *) &resetPhy);
+        if (ret_val)
+            return ret_val;
+
+        if (resetPhy) {
+            ret_val = e1000_oem_phy_hw_reset(hw);
+            if (ret_val)
+                return ret_val;
+        }
     } else {
         /* Clear Auto-Crossover to force MDI manually.  IGP requires MDI
          * forced whenever speed or duplex are forced.
@@ -2452,6 +2538,16 @@ e1000_phy_force_speed_duplex(struct e1000_hw *hw)
                 return ret_val;
             }
         }
+        if (i == 0 && hw->phy_type == e1000_phy_oem)
+        {
+            /* We didn't get link.  Reset the DSP and wait again for link. */
+            ret_val = e1000_oem_phy_reset_dsp(hw);
+            if (ret_val) {
+                DEBUGOUT("Error Resetting the OEM PHY DSP\n");
+                return ret_val;
+            }
+
+        }
         /* This loop will early-out if the link condition has been met.  */
         for (i = PHY_FORCE_TIME; i > 0; i--) {
             if (mii_status_reg & MII_SR_LINK_STATUS) break;
@@ -2521,6 +2617,8 @@ e1000_phy_force_speed_duplex(struct e1000_hw *hw)
         phy_data |= GG82563_MSCR_ASSERT_CRS_ON_TX;
 
         ret_val = e1000_write_phy_reg(hw, GG82563_PHY_MAC_SPEC_CTRL, phy_data);
+        if (hw->phy_type == e1000_phy_oem && resetPhy)
+            ret_val = e1000_oem_cleanup_after_phy_reset(hw);
         if (ret_val)
             return ret_val;
     }
@@ -2570,13 +2668,17 @@ e1000_config_mac_to_phy(struct e1000_hw *hw)
 {
     u32 ctrl;
     s32 ret_val;
-    u16 phy_data;
+    u16 phy_data=0;
+    bool is_FullDuplex = false;
+    bool is_1000MBS = false;
+    bool is_100MBS = false;
 
     DEBUGFUNC("e1000_config_mac_to_phy");
 
     /* 82544 or newer MAC, Auto Speed Detection takes care of
     * MAC speed/duplex configuration.*/
-    if (hw->mac_type >= e1000_82544)
+    if (hw->mac_type >= e1000_82544
+        && hw->mac_type != e1000_icp_xxxx)
         return E1000_SUCCESS;
 
     /* Read the Device Control Register and set the bits to Force Speed
@@ -2589,11 +2691,33 @@ e1000_config_mac_to_phy(struct e1000_hw *hw)
     /* Set up duplex in the Device Control and Transmit Control
      * registers depending on negotiated values.
      */
-    ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
-    if (ret_val)
-        return ret_val;
+    if (hw->phy_type == e1000_phy_oem) {
+
+        ret_val = e1000_oem_phy_is_full_duplex(
+            hw, (int *) &is_FullDuplex);
+        if (ret_val)
+            return ret_val;
+
+        ret_val = e1000_oem_phy_is_speed_1000(
+            hw, (int *) &is_1000MBS);
+        if (ret_val)
+            return ret_val;
 
-    if (phy_data & M88E1000_PSSR_DPLX)
+        ret_val = e1000_oem_phy_is_speed_100(
+            hw, (int *) &is_100MBS);
+        if (ret_val)
+            return ret_val;
+
+    } else {
+        ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+        if (ret_val)
+            return ret_val;
+        is_FullDuplex = phy_data & M88E1000_PSSR_DPLX;
+        is_1000MBS = (phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS;
+        is_100MBS = (phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS;
+    }
+
+    if (is_FullDuplex)
         ctrl |= E1000_CTRL_FD;
     else
         ctrl &= ~E1000_CTRL_FD;
@@ -2603,9 +2727,9 @@ e1000_config_mac_to_phy(struct e1000_hw *hw)
     /* Set up speed in the Device Control register depending on
      * negotiated values.
      */
-    if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
+    if (is_1000MBS)
         ctrl |= E1000_CTRL_SPD_1000;
-    else if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
+    else if (is_100MBS)
         ctrl |= E1000_CTRL_SPD_100;
 
     /* Write the configured values back to the Device Control Reg. */
@@ -2707,10 +2831,18 @@ e1000_config_fc_after_link_up(struct e1000_hw *hw)
      * so we had to force link.  In this case, we need to force the
      * configuration of the MAC to match the "fc" parameter.
      */
-    if (((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed)) ||
-        ((hw->media_type == e1000_media_type_internal_serdes) &&
-         (hw->autoneg_failed)) ||
-        ((hw->media_type == e1000_media_type_copper) && (!hw->autoneg))) {
+    if (((hw->media_type == e1000_media_type_fiber)
+        && (hw->autoneg_failed))
+       || ((hw->media_type == e1000_media_type_internal_serdes)
+           && (hw->autoneg_failed))
+       || ((hw->media_type == e1000_media_type_oem)
+           && !e1000_oem_phy_is_copper(hw)
+           && (hw->autoneg_failed))
+       || ((hw->media_type == e1000_media_type_copper)
+           && (!hw->autoneg))
+       || ((hw->media_type == e1000_media_type_oem)
+           && e1000_oem_phy_is_copper(hw)
+           && (!hw->autoneg))) {
         ret_val = e1000_force_mac_fc(hw);
         if (ret_val) {
             DEBUGOUT("Error forcing flow control settings\n");
@@ -2723,7 +2855,10 @@ e1000_config_fc_after_link_up(struct e1000_hw *hw)
      * has completed, and if so, how the PHY and link partner has
      * flow control configured.
      */
-    if ((hw->media_type == e1000_media_type_copper) && hw->autoneg) {
+    if ((hw->media_type == e1000_media_type_copper
+        || (hw->media_type == e1000_media_type_oem
+            && e1000_oem_phy_is_copper(hw)))
+       && hw->autoneg) {
         /* Read the MII Status Register and check to see if AutoNeg
          * has completed.  We read this twice because this reg has
          * some "sticky" (latched) bits.
@@ -2917,14 +3052,24 @@ e1000_check_for_link(struct e1000_hw *hw)
      * set when the optics detect a signal. On older adapters, it will be
      * cleared when there is a signal.  This applies to fiber media only.
      */
-    if ((hw->media_type == e1000_media_type_fiber) ||
-        (hw->media_type == e1000_media_type_internal_serdes)) {
+    if ((hw->media_type == e1000_media_type_fiber)
+       || (hw->media_type == e1000_media_type_internal_serdes)
+       || (hw->media_type == e1000_media_type_oem
+           && !e1000_oem_phy_is_copper(hw))) {
         rxcw = E1000_READ_REG(hw, RXCW);
 
         if (hw->media_type == e1000_media_type_fiber) {
             signal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;
-            if (status & E1000_STATUS_LU)
-                hw->get_link_status = false;
+	    if (hw->mac_type != e1000_icp_xxxx) {
+                if (status & E1000_STATUS_LU)
+                    hw->get_link_status = false;
+		/* } else {
+		 *  for icp_xxxx MACs, need to test the link up
+		 *  status from the PHY directly if link is up
+		 *  then hw->get_link_status = false 
+		 * }
+		 */
+	    }
         }
     }
 
@@ -2934,7 +3079,10 @@ e1000_check_for_link(struct e1000_hw *hw)
      * receive a Link Status Change interrupt or we have Rx Sequence
      * Errors.
      */
-    if ((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {
+    if ((hw->media_type == e1000_media_type_copper
+        || (hw->media_type == e1000_media_type_oem
+            && e1000_oem_phy_is_copper(hw)))
+       && hw->get_link_status) {
         /* First we want to see if the MII Status Register reports
          * link.  If so, then we want to get the current speed/duplex
          * of the PHY.
@@ -2947,6 +3095,8 @@ e1000_check_for_link(struct e1000_hw *hw)
         if (ret_val)
             return ret_val;
 
+        hw->icp_xxxx_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;
+
         if (phy_data & MII_SR_LINK_STATUS) {
             hw->get_link_status = false;
             /* Check if there was DownShift, must be checked immediately after
@@ -2975,6 +3125,10 @@ e1000_check_for_link(struct e1000_hw *hw)
         } else {
             /* No link detected */
             e1000_config_dsp_after_link_change(hw, false);
+
+            if (hw->phy_type == e1000_phy_oem)
+                e1000_oem_config_dsp_after_link_change(hw, false);
+
             return 0;
         }
 
@@ -2986,6 +3140,10 @@ e1000_check_for_link(struct e1000_hw *hw)
         /* optimize the dsp settings for the igp phy */
         e1000_config_dsp_after_link_change(hw, true);
 
+        if (hw->phy_type == e1000_phy_oem)
+            e1000_oem_config_dsp_after_link_change(hw, true);
+
+
         /* We have a M88E1000 PHY and Auto-Neg is enabled.  If we
          * have Si on board that is 82544 or newer, Auto
          * Speed Detection takes care of MAC speed/duplex
@@ -2993,8 +3151,12 @@ e1000_check_for_link(struct e1000_hw *hw)
          * Distance in the MAC.  Otherwise, we need to force
          * speed/duplex on the MAC to the current PHY speed/duplex
          * settings.
+         *
+         * On ICP_XXXX style MACs, it is still necessary update
+         * the MAC to match the PHY configuration
          */
-        if (hw->mac_type >= e1000_82544)
+        if (hw->mac_type >= e1000_82544
+           && hw->mac_type != e1000_icp_xxxx)
             e1000_config_collision_dist(hw);
         else {
             ret_val = e1000_config_mac_to_phy(hw);
@@ -3061,40 +3223,64 @@ e1000_check_for_link(struct e1000_hw *hw)
      * auto-negotiation time to complete, in case the cable was just plugged
      * in. The autoneg_failed flag does this.
      */
-    else if ((((hw->media_type == e1000_media_type_fiber) &&
-              ((ctrl & E1000_CTRL_SWDPIN1) == signal)) ||
-              (hw->media_type == e1000_media_type_internal_serdes)) &&
-              (!(status & E1000_STATUS_LU)) &&
-              (!(rxcw & E1000_RXCW_C))) {
-        if (hw->autoneg_failed == 0) {
-            hw->autoneg_failed = 1;
-            return 0;
-        }
-        DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\n");
+    else if ((((hw->media_type == e1000_media_type_fiber)
+              && ((ctrl & E1000_CTRL_SWDPIN1) == signal))
+             || (hw->media_type == e1000_media_type_internal_serdes)
+             || (hw->media_type == e1000_media_type_oem
+                 && !e1000_oem_phy_is_copper(hw)))
+            && (!(rxcw & E1000_RXCW_C))) {
+
+		int isUp = 0;
+
+		/*
+		 * ICP_XXXX style MACs do not have a link up bit in the STATUS
+		 * register, so check the PHY directly
+		 */
+		if (hw->mac_type == e1000_icp_xxxx) {
+			ret_val = e1000_oem_phy_is_link_up(hw, &isUp);
+			if (ret_val)
+				return ret_val;
+		} else {
+			isUp = status & E1000_STATUS_LU;
 
-        /* Disable auto-negotiation in the TXCW register */
-        E1000_WRITE_REG(hw, TXCW, (hw->txcw & ~E1000_TXCW_ANE));
+		}
 
-        /* Force link-up and also force full-duplex. */
-        ctrl = E1000_READ_REG(hw, CTRL);
-        ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
-        E1000_WRITE_REG(hw, CTRL, ctrl);
+    	if (!isUp) {
 
-        /* Configure Flow Control after forcing link up. */
-        ret_val = e1000_config_fc_after_link_up(hw);
-        if (ret_val) {
-            DEBUGOUT("Error configuring flow control\n");
-            return ret_val;
-        }
+            if (hw->autoneg_failed == 0) {
+                hw->autoneg_failed = 1;
+                return 0;
+            }
+            DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\n");
+
+            /* Disable auto-negotiation in the TXCW register */
+            E1000_WRITE_REG(hw, TXCW, (hw->txcw & ~E1000_TXCW_ANE));
+
+            /* Force link-up and also force full-duplex. */
+            ctrl = E1000_READ_REG(hw, CTRL);
+            ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
+            E1000_WRITE_REG(hw, CTRL, ctrl);
+
+            /* Configure Flow Control after forcing link up. */
+            ret_val = e1000_config_fc_after_link_up(hw);
+            if (ret_val) {
+                DEBUGOUT("Error configuring flow control\n");
+                return ret_val;
+            }
+	}
     }
     /* If we are forcing link and we are receiving /C/ ordered sets, re-enable
      * auto-negotiation in the TXCW register and disable forced link in the
      * Device Control register in an attempt to auto-negotiate with our link
      * partner.
      */
-    else if (((hw->media_type == e1000_media_type_fiber) ||
-              (hw->media_type == e1000_media_type_internal_serdes)) &&
-              (ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {
+    else if (((hw->media_type == e1000_media_type_fiber)
+             || (hw->media_type == e1000_media_type_internal_serdes)
+             || (hw->media_type == e1000_media_type_oem
+                 && !e1000_oem_phy_is_copper(hw)))
+            && (ctrl & E1000_CTRL_SLU)
+            && (rxcw & E1000_RXCW_C)) {
+
         DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\n");
         E1000_WRITE_REG(hw, TXCW, hw->txcw);
         E1000_WRITE_REG(hw, CTRL, (ctrl & ~E1000_CTRL_SLU));
@@ -3120,7 +3306,24 @@ e1000_check_for_link(struct e1000_hw *hw)
     }
     if ((hw->media_type == e1000_media_type_internal_serdes) &&
         (E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
-        hw->serdes_link_down = !(E1000_STATUS_LU & E1000_READ_REG(hw, STATUS));
+
+	/*
+	 * ICP_XXXX style MACs do not have a link up bit in the STATUS
+	 * register, so check the PHY directly
+	 */
+
+	if (hw->mac_type != e1000_icp_xxxx) {
+            hw->serdes_link_down = !(E1000_STATUS_LU & E1000_READ_REG(hw, STATUS));
+	} else {
+	    int isUp = 0;
+
+	    ret_val = e1000_oem_phy_is_link_up(hw, &isUp);
+	    if (ret_val)
+	    	return ret_val;
+
+	    hw->serdes_link_down = !isUp;
+	}
+
     }
     return E1000_SUCCESS;
 }
@@ -3538,7 +3741,8 @@ e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
         return -E1000_ERR_PARAM;
     }
 
-    if (hw->mac_type > e1000_82543) {
+    if (hw->mac_type > e1000_82543
+       && hw->mac_type != e1000_icp_xxxx) {
         /* Set up Op-code, Phy Address, and register address in the MDI
          * Control register.  The MAC will take care of interfacing with the
          * PHY to retrieve the desired data.
@@ -3564,6 +3768,10 @@ e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
             return -E1000_ERR_PHY;
         }
         *phy_data = (u16) mdic;
+    } else if (hw->mac_type == e1000_icp_xxxx) {
+        int32_t ret_val = e1000_oem_read_phy_reg_ex(hw, reg_addr, phy_data);
+        if (ret_val)
+            return ret_val;
     } else {
         /* We must first send a preamble through the MDIO pin to signal the
          * beginning of an MII instruction.  This is done by sending 32
@@ -3676,7 +3884,8 @@ e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
         return -E1000_ERR_PARAM;
     }
 
-    if (hw->mac_type > e1000_82543) {
+    if (hw->mac_type > e1000_82543
+       && hw->mac_type != e1000_icp_xxxx) {
         /* Set up Op-code, Phy Address, register address, and data intended
          * for the PHY register in the MDI Control register.  The MAC will take
          * care of interfacing with the PHY to send the desired data.
@@ -3698,6 +3907,10 @@ e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
             DEBUGOUT("MDI Write did not complete\n");
             return -E1000_ERR_PHY;
         }
+    } else if (hw->mac_type == e1000_icp_xxxx) {
+        int32_t ret_val = e1000_oem_write_phy_reg_ex(hw, reg_addr, phy_data);
+        if (ret_val)
+            return ret_val;
     } else {
         /* We'll need to use the SW defined pins to shift the write command
          * out to the PHY. We first send a preamble to the PHY to signal the
@@ -3805,6 +4018,14 @@ e1000_phy_hw_reset(struct e1000_hw *hw)
         return E1000_SUCCESS;
 
     DEBUGOUT("Resetting Phy...\n");
+    if (hw->mac_type == e1000_icp_xxxx) {
+	ret_val = e1000_oem_phy_hw_reset(hw);
+	if (ret_val)
+		return ret_val;
+
+	e1000_oem_phy_init_script(hw);
+	return ret_val;
+    }
 
     if (hw->mac_type > e1000_82543) {
         if ((hw->mac_type == e1000_80003es2lan) &&
@@ -3863,6 +4084,9 @@ e1000_phy_hw_reset(struct e1000_hw *hw)
         E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
     }
 
+    if (hw->phy_type == e1000_phy_oem)
+        e1000_oem_phy_init_script(hw);
+
     /* Wait for FW to finish PHY configuration. */
     ret_val = e1000_get_phy_cfg_done(hw);
     if (ret_val != E1000_SUCCESS)
@@ -3901,6 +4125,7 @@ e1000_phy_reset(struct e1000_hw *hw)
     case e1000_phy_igp_2:
     case e1000_phy_igp_3:
     case e1000_phy_ife:
+    case e1000_phy_oem:
         ret_val = e1000_phy_hw_reset(hw);
         if (ret_val)
             return ret_val;
@@ -4387,7 +4612,9 @@ e1000_phy_get_info(struct e1000_hw *hw,
     phy_info->local_rx = e1000_1000t_rx_status_undefined;
     phy_info->remote_rx = e1000_1000t_rx_status_undefined;
 
-    if (hw->media_type != e1000_media_type_copper) {
+    if (hw->media_type != e1000_media_type_copper
+       && (hw->media_type == e1000_media_type_oem
+           && !e1000_oem_phy_is_copper(hw))) {
         DEBUGOUT("PHY info is only valid for copper media\n");
         return -E1000_ERR_CONFIG;
     }
@@ -4411,6 +4638,8 @@ e1000_phy_get_info(struct e1000_hw *hw,
         return e1000_phy_igp_get_info(hw, phy_info);
     else if (hw->phy_type == e1000_phy_ife)
         return e1000_phy_ife_get_info(hw, phy_info);
+    else if (hw->phy_type == e1000_phy_oem)
+	return e1000_oem_phy_get_info(hw,phy_info);
     else
         return e1000_phy_m88_get_info(hw, phy_info);
 }
@@ -4462,6 +4691,7 @@ e1000_init_eeprom_params(struct e1000_hw *hw)
     case e1000_82540:
     case e1000_82545:
     case e1000_82545_rev_3:
+    case e1000_icp_xxxx:
     case e1000_82546:
     case e1000_82546_rev_3:
         eeprom->type = e1000_eeprom_microwire;
@@ -5209,6 +5439,9 @@ e1000_validate_eeprom_checksum(struct e1000_hw *hw)
 {
     u16 checksum = 0;
     u16 i, eeprom_data;
+    u16 checksum_reg = hw->mac_type != e1000_icp_xxxx
+                            ? EEPROM_CHECKSUM_REG
+                            : EEPROM_CHECKSUM_REG_ICP_xxxx;
 
     DEBUGFUNC("e1000_validate_eeprom_checksum");
 
@@ -5244,7 +5477,7 @@ e1000_validate_eeprom_checksum(struct e1000_hw *hw)
         }
     }
 
-    for (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
+    for (i = 0; i < (checksum_reg + 1); i++) {
         if (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
             DEBUGOUT("EEPROM Read Error\n");
             return -E1000_ERR_EEPROM;
@@ -5274,6 +5507,9 @@ e1000_update_eeprom_checksum(struct e1000_hw *hw)
     u32 ctrl_ext;
     u16 checksum = 0;
     u16 i, eeprom_data;
+    u16 checksum_reg = hw->mac_type != e1000_icp_xxxx
+                            ? EEPROM_CHECKSUM_REG
+                            : EEPROM_CHECKSUM_REG_ICP_xxxx;
 
     DEBUGFUNC("e1000_update_eeprom_checksum");
 
@@ -5285,7 +5521,7 @@ e1000_update_eeprom_checksum(struct e1000_hw *hw)
         checksum += eeprom_data;
     }
     checksum = (u16) EEPROM_SUM - checksum;
-    if (e1000_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
+    if (e1000_write_eeprom(hw, checksum_reg, 1, &checksum) < 0) {
         DEBUGOUT("EEPROM Write Error\n");
         return -E1000_ERR_EEPROM;
     } else if (hw->eeprom.type == e1000_eeprom_flash) {
@@ -5692,12 +5928,18 @@ e1000_read_mac_addr(struct e1000_hw * hw)
 {
     u16 offset;
     u16 eeprom_data, i;
+    u16 ia_base_addr=0;
 
     DEBUGFUNC("e1000_read_mac_addr");
 
+    if (hw->mac_type == e1000_icp_xxxx) {
+        ia_base_addr = (uint16_t)
+                 EEPROM_IA_START_ICP_xxxx(e1000_oem_get_phy_dev_number(hw));
+     }
+ 
     for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
         offset = i >> 1;
-        if (e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
+        if (e1000_read_eeprom(hw, offset+ia_base_addr, 1, &eeprom_data) < 0) {
             DEBUGOUT("EEPROM Read Error\n");
             return -E1000_ERR_EEPROM;
         }
@@ -6015,7 +6257,8 @@ e1000_id_led_init(struct e1000_hw * hw)
 
     DEBUGFUNC("e1000_id_led_init");
 
-    if (hw->mac_type < e1000_82540) {
+    if(hw->mac_type < e1000_82540
+	   || hw->mac_type == e1000_icp_xxxx) {
         /* Nothing to do */
         return E1000_SUCCESS;
     }
@@ -6099,6 +6342,7 @@ e1000_setup_led(struct e1000_hw *hw)
     case e1000_82542_rev2_1:
     case e1000_82543:
     case e1000_82544:
+    case e1000_icp_xxxx:
         /* No setup necessary */
         break;
     case e1000_82541:
@@ -6192,6 +6436,7 @@ e1000_cleanup_led(struct e1000_hw *hw)
     case e1000_82542_rev2_1:
     case e1000_82543:
     case e1000_82544:
+    case e1000_icp_xxxx:
         /* No cleanup necessary */
         break;
     case e1000_82541:
@@ -6230,6 +6475,9 @@ e1000_led_on(struct e1000_hw *hw)
     DEBUGFUNC("e1000_led_on");
 
     switch (hw->mac_type) {
+    case e1000_icp_xxxx:
+	/* No LED control on ICP family of gigE controllers */
+	return E1000_SUCCESS;
     case e1000_82542_rev2_0:
     case e1000_82542_rev2_1:
     case e1000_82543:
@@ -6281,6 +6529,9 @@ e1000_led_off(struct e1000_hw *hw)
     DEBUGFUNC("e1000_led_off");
 
     switch (hw->mac_type) {
+    case e1000_icp_xxxx:
+	/* No LED control on ICP family of gigE controllers */
+	return E1000_SUCCESS;
     case e1000_82542_rev2_0:
     case e1000_82542_rev2_1:
     case e1000_82543:
@@ -6396,7 +6647,8 @@ e1000_clear_hw_cntrs(struct e1000_hw *hw)
     temp = E1000_READ_REG(hw, TSCTC);
     temp = E1000_READ_REG(hw, TSCTFC);
 
-    if (hw->mac_type <= e1000_82544) return;
+    if (hw->mac_type <= e1000_82544
+       || hw->mac_type == e1000_icp_xxxx) return;
 
     temp = E1000_READ_REG(hw, MGTPRC);
     temp = E1000_READ_REG(hw, MGTPDC);
@@ -6604,6 +6856,11 @@ e1000_get_bus_info(struct e1000_hw *hw)
         hw->bus_speed = e1000_bus_speed_2500;
         hw->bus_width = e1000_bus_width_pciex_1;
         break;
+    case e1000_icp_xxxx:
+	hw->bus_type = e1000_bus_type_cpp;
+	hw->bus_speed = e1000_bus_speed_unknown;
+	hw->bus_width = e1000_bus_width_unknown;
+	break;
     default:
         status = E1000_READ_REG(hw, STATUS);
         hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
@@ -6842,6 +7099,12 @@ e1000_get_cable_length(struct e1000_hw *hw,
         *min_length = ((agc_value - IGP02E1000_AGC_RANGE) > 0) ?
                        (agc_value - IGP02E1000_AGC_RANGE) : 0;
         *max_length = agc_value + IGP02E1000_AGC_RANGE;
+    } else if (hw->phy_type == e1000_phy_oem) {
+		ret_val = e1000_oem_get_cable_length(hw,
+                                             min_length,
+                                             max_length);
+		if (ret_val)
+			return ret_val;
     }
 
     return E1000_SUCCESS;
@@ -6920,7 +7183,8 @@ e1000_check_polarity(struct e1000_hw *hw,
         *polarity = ((phy_data & IFE_PESC_POLARITY_REVERSED) >>
                      IFE_PESC_POLARITY_REVERSED_SHIFT) ?
                      e1000_rev_polarity_reversed : e1000_rev_polarity_normal;
-    }
+    } else if (hw->phy_type == e1000_phy_oem)
+	return e1000_oem_check_polarity(hw,polarity);
     return E1000_SUCCESS;
 }
 
@@ -6968,6 +7232,13 @@ e1000_check_downshift(struct e1000_hw *hw)
     } else if (hw->phy_type == e1000_phy_ife) {
         /* e1000_phy_ife supports 10/100 speed only */
         hw->speed_downgraded = false;
+    } else if (hw->phy_type == e1000_phy_oem) {
+        ret_val = e1000_oem_phy_speed_downgraded(hw, &phy_data);
+
+        if (ret_val)
+            return ret_val;
+
+        hw->speed_downgraded = phy_data>0;
     }
 
     return E1000_SUCCESS;
diff --git a/drivers/net/e1000/e1000_hw.h b/drivers/net/e1000/e1000_hw.h
index 99fce2c..8b8bab9 100644
--- a/drivers/net/e1000/e1000_hw.h
+++ b/drivers/net/e1000/e1000_hw.h
@@ -51,6 +51,7 @@ typedef enum {
     e1000_82540,
     e1000_82545,
     e1000_82545_rev_3,
+    e1000_icp_xxxx,
     e1000_82546,
     e1000_82546_rev_3,
     e1000_82541,
@@ -80,6 +81,7 @@ typedef enum {
     e1000_media_type_copper = 0,
     e1000_media_type_fiber = 1,
     e1000_media_type_internal_serdes = 2,
+    e1000_media_type_oem = 3,
     e1000_num_media_types
 } e1000_media_type;
 
@@ -110,6 +112,7 @@ typedef enum {
     e1000_bus_type_pci,
     e1000_bus_type_pcix,
     e1000_bus_type_pci_express,
+    e1000_bus_type_cpp,
     e1000_bus_type_reserved
 } e1000_bus_type;
 
@@ -228,6 +231,7 @@ typedef enum {
     e1000_phy_gg82563,
     e1000_phy_igp_3,
     e1000_phy_ife,
+    e1000_phy_oem,
     e1000_phy_undefined = 0xFF
 } e1000_phy_type;
 
@@ -330,6 +334,7 @@ s32 e1000_phy_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info);
 s32 e1000_validate_mdi_setting(struct e1000_hw *hw);
 
 void e1000_phy_powerdown_workaround(struct e1000_hw *hw);
+int32_t e1000_phy_misctst_get_info(struct e1000_hw *hw, uint16_t *enabled);
 
 /* EEPROM Functions */
 s32 e1000_init_eeprom_params(struct e1000_hw *hw);
@@ -400,6 +405,8 @@ s32 e1000_write_eeprom(struct e1000_hw *hw, u16 reg, u16 words, u16 *data);
 s32 e1000_read_mac_addr(struct e1000_hw * hw);
 
 /* Filters (multicast, vlan, receive) */
+void e1000_mc_addr_list_update(struct e1000_hw *hw, uint8_t * mc_addr_list,
+			uint32_t mc_addr_count, uint32_t pad, uint32_t rar_used_count);
 u32 e1000_hash_mc_addr(struct e1000_hw *hw, u8 * mc_addr);
 void e1000_mta_set(struct e1000_hw *hw, u32 hash_value);
 void e1000_rar_set(struct e1000_hw *hw, u8 * mc_addr, u32 rar_index);
@@ -425,7 +432,10 @@ s32 e1000_read_pcie_cap_reg(struct e1000_hw *hw, u32 reg, u16 *value);
 void e1000_pcix_set_mmrbc(struct e1000_hw *hw, int mmrbc);
 int e1000_pcix_get_mmrbc(struct e1000_hw *hw);
 /* Port I/O is only supported on 82544 and newer */
+u32 e1000_io_read(struct e1000_hw *hw, unsigned long port);
+u32 e1000_read_reg_io(struct e1000_hw *hw, u32 offset);
 void e1000_io_write(struct e1000_hw *hw, unsigned long port, u32 value);
+void e1000_enable_pciex_master(struct e1000_hw *hw);
 s32 e1000_disable_pciex_master(struct e1000_hw *hw);
 s32 e1000_check_phy_reset_block(struct e1000_hw *hw);
 
@@ -436,6 +446,18 @@ s32 e1000_check_phy_reset_block(struct e1000_hw *hw);
     e1000_write_reg_io((a), E1000_##reg, val)
 
 /* PCI Device IDs */
+/* ICP xxxx Signal Target Capability */
+#define PCI_CAP_ID_ST     0x09
+#define PCI_ST_SCID_MASK  0x000000FF
+#define PCI_ST_SCP_MASK   0x0000FF00
+#define PCI_ST_SBC_MASK   0x00FF0000
+#define PCI_ST_STYP_MASK  0xFF000000
+#define PCI_ST_SMIA_MASK  0x000000FF
+#define PCI_ST_SMACC_MASK 0x0000FF00
+#define PCI_ST_SDATA_MASK 0xFFFF0000
+#define PCI_ST_SMIA_OFFSET 0x00000004
+
+/* IDs */
 #define E1000_DEV_ID_82542               0x1000
 #define E1000_DEV_ID_82543GC_FIBER       0x1001
 #define E1000_DEV_ID_82543GC_COPPER      0x1004
@@ -500,6 +522,22 @@ s32 e1000_check_phy_reset_block(struct e1000_hw *hw);
 #define E1000_DEV_ID_ICH8_IFE_GT         0x10C4
 #define E1000_DEV_ID_ICH8_IFE_G          0x10C5
 #define E1000_DEV_ID_ICH8_IGP_M          0x104D
+/*
+ * ICP GbE devices are not assigned Intel part numbers yet so just
+ * identify them via their device id's
+ */
+#define E1000_DEV_ID_ICP_5040            0x5040
+#define E1000_DEV_ID_ICP_5041            0x5041
+#define E1000_DEV_ID_ICP_5042            0x5042
+#define E1000_DEV_ID_ICP_5043            0x5043
+#define E1000_DEV_ID_ICP_5044            0x5044
+#define E1000_DEV_ID_ICP_5045            0x5045
+#define E1000_DEV_ID_ICP_5046            0x5046
+#define E1000_DEV_ID_ICP_5047            0x5047
+#define E1000_DEV_ID_ICP_5048            0x5048
+#define E1000_DEV_ID_ICP_5049            0x5049
+#define E1000_DEV_ID_ICP_504A            0x504A
+#define E1000_DEV_ID_ICP_504B            0x504B
 
 
 #define NODE_ADDRESS_SIZE 6
@@ -902,6 +940,7 @@ struct e1000_ffvt_entry {
 #define E1000_IMS      0x000D0  /* Interrupt Mask Set - RW */
 #define E1000_IMC      0x000D8  /* Interrupt Mask Clear - WO */
 #define E1000_IAM      0x000E0  /* Interrupt Acknowledge Auto Mask */
+#define E1000_CTRL_AUX 0x000E0  /* Aux Control -RW */
 #define E1000_RCTL     0x00100  /* RX Control - RW */
 #define E1000_RDTR1    0x02820  /* RX Delay Timer (1) - RW */
 #define E1000_RDBAL1   0x02900  /* RX Descriptor Base Address Low (1) - RW */
@@ -917,6 +956,19 @@ struct e1000_ffvt_entry {
 #define E1000_TIPG     0x00410  /* TX Inter-packet gap -RW */
 #define E1000_TBT      0x00448  /* TX Burst Timer - RW */
 #define E1000_AIT      0x00458  /* Adaptive Interframe Spacing Throttle - RW */
+#define E1000_CPP_ERR_STAT_ICP_xxxx  0x00510 /* CPP Error Status Register */
+#define E1000_CPP_ERR_ADDR_ICP_xxxx  0x00514 /* CPP Error Address Register */
+#define E1000_CPP_ERR_PPID_ICP_xxxx  0x00518 /* CPP Error ID Register */
+#define E1000_ICR1     0x008C0  /* Interrupt Cause Read 1 - R/clr */
+#define E1000_ICS1     0x008C8  /* Interrupt Cause Set - WO */
+#define E1000_IMS1     0x008D0  /* Interrupt Mask Set 1 - RW */
+#define E1000_IMC1     0x008D8  /* Interrupt Mask Clear 1 - RW */
+#define E1000_ICR2     0x008E0  /* Interrupt Cause Read 2 - R0 */
+#define E1000_ICS2     0x008E8  /* Interrupt Cause Set 2 - RW */
+#define E1000_IMS2     0x008F0  /* Interrupt Mask Set 2 - RW */
+#define E1000_IMC2     0x008F8  /* Interrupt Mask 2 Clear - WO */
+#define E1000_MEM_TST  0x00900  /* Internal ECC Memory Test Register - RW */
+#define E1000_MEM_STS  0x00904  /* Internal ECC Memory Status Register - RO */
 #define E1000_LEDCTL   0x00E00  /* LED Control - RW */
 #define E1000_EXTCNF_CTRL  0x00F00  /* Extended Configuration Control */
 #define E1000_EXTCNF_SIZE  0x00F08  /* Extended Configuration Size */
@@ -1113,6 +1165,14 @@ struct e1000_ffvt_entry {
 #define E1000_82542_ICS      E1000_ICS
 #define E1000_82542_IMS      E1000_IMS
 #define E1000_82542_IMC      E1000_IMC
+#define E1000_82542_ICR1     E1000_ICR1
+#define E1000_82542_ICS1     E1000_ICS1
+#define E1000_82542_IMS1     E1000_IMS1
+#define E1000_82542_IMC1     E1000_IMC1
+#define E1000_82542_ICR2     E1000_ICR2
+#define E1000_82542_ICS2     E1000_ICS2
+#define E1000_82542_IMS2     E1000_IMS2
+#define E1000_82542_IMC2     E1000_IMC2
 #define E1000_82542_RCTL     E1000_RCTL
 #define E1000_82542_RDTR     0x00108
 #define E1000_82542_RDBAL    0x00110
@@ -1469,6 +1529,7 @@ struct e1000_hw {
 	bool			has_manc2h;
 	bool			rx_needs_kicking;
 	bool			has_smbus;
+ 	bool			icp_xxxx_is_link_up;
 };
 
 
@@ -1641,6 +1702,7 @@ struct e1000_hw {
 #define E1000_CTRL_EXT_WR_WMARK_320   0x01000000
 #define E1000_CTRL_EXT_WR_WMARK_384   0x02000000
 #define E1000_CTRL_EXT_WR_WMARK_448   0x03000000
+#define E1000_CTRL_EXT_CANC           0x04000000  /* Interrupt delay cancellation */
 #define E1000_CTRL_EXT_DRV_LOAD       0x10000000 /* Driver loaded bit for FW */
 #define E1000_CTRL_EXT_IAME           0x08000000 /* Interrupt acknowledge Auto-mask */
 #define E1000_CTRL_EXT_INT_TIMER_CLR  0x20000000 /* Clear Interrupt timers after IMS clear */
@@ -1705,6 +1767,34 @@ struct e1000_hw {
 #define E1000_PHY_CTRL_GBE_DISABLE             0x00000040
 #define E1000_PHY_CTRL_B2B_EN                  0x00000080
 
+/* Auxiliary Control */
+#define E1000_CTRL_AUX_ICP_xxxx_MII_TGS  0x00000001
+#define E1000_CTRL_AUX_ICP_xxxx_ENDIAN   0x00000300
+#define E1000_CTRL_AUX_ICP_xxxx_PKT      0x00000400
+#define E1000_CTRL_AUX_ICP_xxxx_DESC     0x00000800
+
+/* CPP Error ID */
+#define E1000_CPP_ERR_PPID_ICP_xxxx_PPID  0x00000000
+
+/* CPP Error Address */
+#define E1000_CPP_ERR_ADDR_ICP_xxxx_ERR_ADDR  0x00000000
+
+/* CPP Error Status */
+#define E1000_CPP_ERR_STAT_ICP_xxxx_CERR  0x00000001
+#define E1000_CPP_ERR_STAT_ICP_xxxx_MERR  0x00000002
+#define E1000_CPP_ERR_STAT_ICP_xxxx_CD    0x00000004
+#define E1000_CPP_ERR_STAT_ICP_xxxx_TYPE  0x00000030
+
+/* Internal ECC Memory Error Test */
+#define E1000_MEM_TST_ICP_xxxx_MASK    0x0000FFFF
+#define E1000_MEM_TST_ICP_xxxx_NONE    0x00000000
+#define E1000_MEM_TST_ICP_xxxx_STAT    0x00010000
+#define E1000_MEM_TST_ICP_xxxx_MCAST   0x00020000
+#define E1000_MEM_TST_ICP_xxxx_SPFILT  0x00030000
+#define E1000_MEM_TST_ICP_xxxx_TXDESC  0x00040000
+#define E1000_MEM_TST_ICP_xxxx_RXDESC  0x00050000
+#define E1000_MEM_TST_ICP_xxxx_PKBUFF  0x00060000
+
 /* LED Control */
 #define E1000_LEDCTL_LED0_MODE_MASK       0x0000000F
 #define E1000_LEDCTL_LED0_MODE_SHIFT      0
@@ -1766,6 +1856,13 @@ struct e1000_hw {
 #define E1000_ICR_ACK           0x00020000 /* Receive Ack frame */
 #define E1000_ICR_MNG           0x00040000 /* Manageability event */
 #define E1000_ICR_DOCK          0x00080000 /* Dock/Undock */
+#define E1000_ICR_RX_DESC_FIFO_PAR 0x00100000 /* RX Desc FIFO Parity Err */
+#define E1000_ICR_TX_DESC_FIFO_PAR 0x00200000 /* TX Desc FIFO Parity Err */
+#define E1000_ICR_PB               0x00800000 /* Packet Buffer Parity Err */
+#define E1000_ICR_INTMEM_ICP_xxxx  0x04000000
+#define E1000_ICR_CPP_TARGET    0x08000000
+#define E1000_ICR_CPP_MASTER    0x10000000
+#define E1000_ICR_STAT          0x20000000
 #define E1000_ICR_INT_ASSERTED  0x80000000 /* If this bit asserted, the driver should claim the interrupt */
 #define E1000_ICR_RXD_FIFO_PAR0 0x00100000 /* queue 0 Rx descriptor FIFO parity error */
 #define E1000_ICR_TXD_FIFO_PAR0 0x00200000 /* queue 0 Tx descriptor FIFO parity error */
@@ -1806,6 +1903,14 @@ struct e1000_hw {
 #define E1000_ICS_DSW       E1000_ICR_DSW
 #define E1000_ICS_PHYINT    E1000_ICR_PHYINT
 #define E1000_ICS_EPRST     E1000_ICR_EPRST
+#define E1000_ICS_RX_DESC_FIFO_PAR  E1000_ICR_RX_DESC_FIFO_PAR
+#define E1000_ICS_TX_DESC_FIFO_PAR  E1000_ICR_TX_DESC_FIFO_PAR
+#define E1000_ICS_PB                E1000_ICR_PB
+#define E1000_ICS_INTMEM_ICP_xxxx   E1000_ICR_INTMEM_ICP_xxxx
+#define E1000_ICS_CPP_TARGET        E1000_ICR_CPP_TARGET
+#define E1000_ICS_CPP_MASTER        E1000_ICR_CPP_MASTER
+#define E1000_ICS_STAT              E1000_ICR_STAT
+
 
 /* Interrupt Mask Set */
 #define E1000_IMS_TXDW      E1000_ICR_TXDW      /* Transmit desc written back */
@@ -1826,6 +1931,13 @@ struct e1000_hw {
 #define E1000_IMS_ACK       E1000_ICR_ACK       /* Receive Ack frame */
 #define E1000_IMS_MNG       E1000_ICR_MNG       /* Manageability event */
 #define E1000_IMS_DOCK      E1000_ICR_DOCK      /* Dock/Undock */
+#define E1000_IMS_RX_DESC_FIFO_PAR E1000_ICR_RX_DESC_FIFO_PAR
+#define E1000_IMS_TX_DESC_FIFO_PAR E1000_ICR_TX_DESC_FIFO_PAR
+#define E1000_IMS_PB               E1000_ICR_PB
+#define E1000_IMS_INTMEM_ICP_xxxx  E1000_ICR_INTMEM_ICP_xxxx
+#define E1000_IMS_CPP_TARGET       E1000_ICR_CPP_TARGET
+#define E1000_IMS_CPP_MASTER       E1000_ICR_CPP_MASTER
+#define E1000_IMS_STAT             E1000_ICR_STAT
 #define E1000_IMS_RXD_FIFO_PAR0 E1000_ICR_RXD_FIFO_PAR0 /* queue 0 Rx descriptor FIFO parity error */
 #define E1000_IMS_TXD_FIFO_PAR0 E1000_ICR_TXD_FIFO_PAR0 /* queue 0 Tx descriptor FIFO parity error */
 #define E1000_IMS_HOST_ARB_PAR  E1000_ICR_HOST_ARB_PAR  /* host arb read buffer parity error */
@@ -1864,6 +1976,13 @@ struct e1000_hw {
 #define E1000_IMC_DSW       E1000_ICR_DSW
 #define E1000_IMC_PHYINT    E1000_ICR_PHYINT
 #define E1000_IMC_EPRST     E1000_ICR_EPRST
+#define E1000_IMC_RX_DESC_FIFO_PAR  E1000_ICR_RX_DESC_FIFO_PAR
+#define E1000_IMC_TX_DESC_FIFO_PAR  E1000_ICR_TX_DESC_FIFO_PAR
+#define E1000_IMC_PB                E1000_ICR_PB
+#define E1000_IMC_INTMEM_ICP_xxxx   E1000_ICR_INTMEM_ICP_xxxx
+#define E1000_IMC_CPP_TARGET        E1000_ICR_CPP_TARGET
+#define E1000_IMC_CPP_MASTER        E1000_ICR_CPP_MASTER
+#define E1000_IMC_STAT              E1000_ICR_STAT
 
 /* Receive Control */
 #define E1000_RCTL_RST            0x00000001    /* Software reset */
@@ -2285,6 +2404,35 @@ struct e1000_host_command_info {
 #define EEPROM_CFG                    0x0012
 #define EEPROM_FLASH_VERSION          0x0032
 #define EEPROM_CHECKSUM_REG           0x003F
+/* ICP PCI Dev ID xxxx EEPROM Word Offsets */
+#define EEPROM_INIT_CONTROL1_REG_ICP_xxxx           0x0000
+#define EEPROM_COMPAT_ICP_xxxx                      0x0003
+#define EEPROM_PBA_LOW_ICP_xxxx                     0x0008
+#define EEPROM_PBA_HIGH_ICP_xxxx                    0x0009
+#define EEPROM_MGMT_CONTROL_PORT_A_ICP_xxxx         0x0010
+#define EEPROM_INIT_CONTROL3_PORT_A_ICP_xxxx        0x0011
+#define EEPROM_IA_START_PORT_A_ICP_xxxx             0x0012
+#define EEPROM_IPV4_START_PORT_A_ICP_xxxx           0x0015
+#define EEPROM_IPV6_START_PORT_A_ICP_xxxx           0x0017
+#define EEPROM_MGMT_CONTROL_PORT_B_ICP_xxxx         0x0020
+#define EEPROM_INIT_CONTROL3_PORT_B_ICP_xxxx        0x0021
+#define EEPROM_IA_START_PORT_B_ICP_xxxx             0x0022
+#define EEPROM_IPV4_START_PORT_B_ICP_xxxx           0x0025
+#define EEPROM_IPV6_START_PORT_B_ICP_xxxx           0x0027
+#define EEPROM_MGMT_CONTROL_PORT_C_ICP_xxxx         0x0030
+#define EEPROM_INIT_CONTROL3_PORT_C_ICP_xxxx        0x0031
+#define EEPROM_IA_START_PORT_C_ICP_xxxx             0x0032
+#define EEPROM_IPV4_START_PORT_C_ICP_xxxx           0x0035
+#define EEPROM_IPV6_START_PORT_C_ICP_xxxx           0x0037
+#define EEPROM_CHECKSUM_REG_ICP_xxxx                EEPROM_CHECKSUM_REG
+
+/* ICP PCI Dev ID xxxx macros to calculate word offsets for IA, IPv4 and IPv6 */
+#define EEPROM_MGMT_CONTROL_ICP_xxxx(device_num)  (((device_num) + 1) << 4)
+#define EEPROM_INIT_CONTROL3_ICP_xxxx(device_num) ((((device_num) + 1) << 4) + 1)
+#define EEPROM_IA_START_ICP_xxxx(device_num)      ((((device_num) + 1) << 4) + 2)
+#define EEPROM_IPV4_START_ICP_xxxx(device_num)    ((((device_num) + 1) << 4) + 5)
+#define EEPROM_IPV6_START_ICP_xxxx(device_num)    ((((device_num) + 1) << 4) + 7)
+
 
 #define E1000_EEPROM_CFG_DONE         0x00040000   /* MNG config cycle done */
 #define E1000_EEPROM_CFG_DONE_PORT_1  0x00080000   /* ...for second port */
@@ -2345,6 +2493,15 @@ struct e1000_host_command_info {
 /* Mask bits for fields in Word 0x1a of the EEPROM */
 #define EEPROM_WORD1A_ASPM_MASK  0x000C
 
+/* Mask bits for fields in EEPROM_INIT_CONTROL3_ICP_xxxx.
+ * For ICP style controllers, control word 2 and 3 are packed into the
+ * same word, with control word 2 occupying the top byte. This just
+ * happens to match the original iegbe storing the information in the top
+ * word of init control word 2. To access this data use the control 3
+ * macro
+ */
+#define EEPROM_INIT_CTRL_2_ANE_ICP_xxxx        EEPROM_WORD0F_ANE
+
 /* For checksumming, the sum of all words in the EEPROM should equal 0xBABA. */
 #define EEPROM_SUM 0xBABA
 
@@ -2356,6 +2513,10 @@ struct e1000_host_command_info {
 
 /* EEPROM Map Sizes (Byte Counts) */
 #define PBA_SIZE 4
+#define COMPAT_SIZE_ICP_xxxx 10
+
+/* ICP Mask bits for INIT_CONTROL3 */
+#define EEPROM_CTRL3_APME_ICP_xxxx     0x0004
 
 /* Collision related configuration parameters */
 #define E1000_COLLISION_THRESHOLD       15
@@ -2931,6 +3092,9 @@ struct e1000_host_command_info {
 #define M88EC018_EPSCR_DOWNSHIFT_COUNTER_6X    0x0A00
 #define M88EC018_EPSCR_DOWNSHIFT_COUNTER_7X    0x0C00
 #define M88EC018_EPSCR_DOWNSHIFT_COUNTER_8X    0x0E00
+/* RGMII TX and RX Timing Control*/
+#define M88E1000_EPSCR_TX_TIME_CTRL       0x0002 /* Add Delay */
+#define M88E1000_EPSCR_RX_TIME_CTRL       0x0080 /* Add Delay */
 
 /* IGP01E1000 Specific Port Config Register - R/W */
 #define IGP01E1000_PSCFR_AUTO_MDIX_PAR_DETECT  0x0010
@@ -3156,6 +3320,7 @@ struct e1000_host_command_info {
 #define M88E1000_14_PHY_ID M88E1000_E_PHY_ID
 #define M88E1011_I_REV_4   0x04
 #define M88E1111_I_PHY_ID  0x01410CC0
+#define M88E1141_E_PHY_ID  0x01410CD4
 #define L1LXT971A_PHY_ID   0x001378E0
 #define GG82563_E_PHY_ID   0x01410CA0
 
diff --git a/drivers/net/e1000/e1000_main.c b/drivers/net/e1000/e1000_main.c
index 59579b1..0040487 100644
--- a/drivers/net/e1000/e1000_main.c
+++ b/drivers/net/e1000/e1000_main.c
@@ -117,6 +117,18 @@ PCIE(	INTEL_E1000_ETHERNET_DEVICE(0x10C5))
 PCIE(	INTEL_E1000_ETHERNET_DEVICE(0x10D5))
 PCIE(	INTEL_E1000_ETHERNET_DEVICE(0x10D9))
 PCIE(	INTEL_E1000_ETHERNET_DEVICE(0x10DA))
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5040),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5041),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5042),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5043),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5044),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5045),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5046),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5047),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5048),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x5049),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x504A),
+ 	INTEL_E1000_ETHERNET_DEVICE(0x504B),
 	/* required last entry */
 	{0,}
 };
@@ -194,6 +206,7 @@ static void e1000_alloc_rx_buffers_ps(struct e1000_adapter *adapter,
 static int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
 static int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,
 			   int cmd);
+extern int ethtool_ioctl(struct ifreq *ifr);
 static void e1000_enter_82542_rst(struct e1000_adapter *adapter);
 static void e1000_leave_82542_rst(struct e1000_adapter *adapter);
 static void e1000_tx_timeout(struct net_device *dev);
@@ -309,7 +322,8 @@ static int e1000_request_irq(struct e1000_adapter *adapter)
 	int irq_flags = IRQF_SHARED;
 	int err;
 
-	if (adapter->hw.mac_type >= e1000_82571) {
+	if (adapter->hw.mac_type >= e1000_82571
+		|| adapter->hw.mac_type == e1000_icp_xxxx) {
 		adapter->have_msi = !pci_enable_msi(adapter->pdev);
 		if (adapter->have_msi) {
 			handler = e1000_intr_msi;
@@ -517,6 +531,15 @@ static void e1000_configure(struct e1000_adapter *adapter)
 	struct net_device *netdev = adapter->netdev;
 	int i;
 
+	/* Reset the PHY if it was previously powered down */
+        if (adapter->hw.media_type == e1000_media_type_oem
+            && e1000_oem_phy_is_copper(&adapter->hw)) {
+		uint16_t mii_reg;
+		e1000_read_phy_reg(&adapter->hw, PHY_CTRL, &mii_reg);
+		if (mii_reg & MII_CR_POWER_DOWN)
+			e1000_phy_reset(&adapter->hw);
+	}
+
 	e1000_set_rx_mode(netdev);
 
 	e1000_restore_vlan(adapter);
@@ -651,6 +674,18 @@ e1000_down(struct e1000_adapter *adapter)
 	e1000_reset(adapter);
 	e1000_clean_all_tx_rings(adapter);
 	e1000_clean_all_rx_rings(adapter);
+	/* If WoL is not enabled and management mode is not IAMT
+	 * or if WoL is not enabled and OEM PHY is copper based,
+	 * power down the PHY so no link is implied when interface is down */
+	if (!adapter->wol && adapter->hw.media_type == e1000_media_type_oem
+              && e1000_oem_phy_is_copper(&adapter->hw)) {
+
+		uint16_t mii_reg;
+		e1000_read_phy_reg(&adapter->hw, PHY_CTRL, &mii_reg);
+		mii_reg |= MII_CR_POWER_DOWN;
+		e1000_write_phy_reg(&adapter->hw, PHY_CTRL, mii_reg);
+		mdelay(1);
+	}
 }
 
 void
@@ -710,6 +745,9 @@ e1000_reset(struct e1000_adapter *adapter)
 	case e1000_undefined:
 	case e1000_num_macs:
 		break;
+	default:
+		pba = E1000_PBA_48K;
+		break;
 	}
 
 	if (legacy_pba_adjust) {
@@ -1115,6 +1153,12 @@ e1000_probe(struct pci_dev *pdev,
 			EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data);
 		eeprom_apme_mask = E1000_EEPROM_82544_APM;
 		break;
+	case e1000_icp_xxxx:
+		e1000_read_eeprom(&adapter->hw,
+			EEPROM_INIT_CONTROL3_ICP_xxxx(adapter->pdev->devfn),
+			 1, &eeprom_data);
+		eeprom_apme_mask = EEPROM_CTRL3_APME_ICP_xxxx;
+		break;
 	case e1000_ich8lan:
 		e1000_read_eeprom(&adapter->hw,
 			EEPROM_INIT_CONTROL1_REG, 1, &eeprom_data);
@@ -1213,6 +1257,16 @@ e1000_probe(struct pci_dev *pdev,
 	/* tell the stack to leave us alone until e1000_open() is called */
 	netif_carrier_off(netdev);
 	netif_stop_queue(netdev);
+	/* The ICP_xxxx device has multiple, duplicate interrupt
+	 * registers, so disable all but the first one
+	 */
+	if (adapter->hw.mac_type == e1000_icp_xxxx) {
+       		int offset = pci_find_capability(adapter->pdev, PCI_CAP_ID_ST)
+       		              + PCI_ST_SMIA_OFFSET;
+       		pci_write_config_dword(adapter->pdev, offset, 0x00000006);
+       		E1000_WRITE_REG(&adapter->hw, IMC1, ~0UL);
+       		E1000_WRITE_REG(&adapter->hw, IMC2, ~0UL);
+    	}
 
 	strcpy(netdev->name, "eth%d");
 	if ((err = register_netdev(netdev)))
@@ -1368,7 +1422,9 @@ e1000_sw_init(struct e1000_adapter *adapter)
 
 	/* Copper options */
 
-	if (hw->media_type == e1000_media_type_copper) {
+	if (hw->media_type == e1000_media_type_copper
+	        || (hw->media_type == e1000_media_type_oem
+       		&& e1000_oem_phy_is_copper(&adapter->hw))) {
 		hw->mdix = AUTO_ALL_MODES;
 		hw->disable_polarity_correction = false;
 		hw->master_slave = E1000_MASTER_SLAVE;
@@ -1390,6 +1446,14 @@ e1000_sw_init(struct e1000_adapter *adapter)
 	}
 	spin_lock_init(&adapter->tx_queue_lock);
 #endif
+        /*
+	 * for ICP_XXXX style controllers, it is necessary to keep
+	 * track of the last known state of the link to determine if
+	 * the link experienced a change in state when e1000_watchdog
+	 * fires
+	 */
+	adapter->hw.icp_xxxx_is_link_up = false;
+
 
 	/* Explicitly disable IRQ since the NIC can be in any state. */
 	e1000_irq_disable(adapter);
@@ -1792,6 +1856,8 @@ e1000_configure_tx(struct e1000_adapter *adapter)
 
 	if (hw->mac_type < e1000_82543)
 		adapter->txd_cmd |= E1000_TXD_CMD_RPS;
+	else if (hw->mac_type == e1000_icp_xxxx)
+		adapter->txd_cmd &= ~E1000_TXD_CMD_RS;
 	else
 		adapter->txd_cmd |= E1000_TXD_CMD_RS;
 
@@ -2640,6 +2706,20 @@ e1000_watchdog(unsigned long data)
 	u32 link, tctl;
 	s32 ret_val;
 
+	/*
+	 * Test the PHY for link status on icp_xxxx MACs.
+	 * If the link status is different than the last link status stored
+	 * in the adapter->hw structure, then set hw->get_link_status = 1
+	 */
+	if (adapter->hw.mac_type == e1000_icp_xxxx) {
+		int isUp = 0;
+		ret_val = e1000_oem_phy_is_link_up(&adapter->hw, &isUp);
+		if (ret_val != E1000_SUCCESS)
+		isUp = 0;
+
+		if (isUp != adapter->hw.icp_xxxx_is_link_up)
+		adapter->hw.get_link_status = 1;
+	}
 	ret_val = e1000_check_for_link(&adapter->hw);
 	if ((ret_val == E1000_ERR_PHY) &&
 	    (adapter->hw.phy_type == e1000_phy_igp_3) &&
@@ -2658,8 +2738,16 @@ e1000_watchdog(unsigned long data)
 	if ((adapter->hw.media_type == e1000_media_type_internal_serdes) &&
 	   !(E1000_READ_REG(&adapter->hw, TXCW) & E1000_TXCW_ANE))
 		link = !adapter->hw.serdes_link_down;
-	else
-		link = E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU;
+	else {
+		if (adapter->hw.mac_type != e1000_icp_xxxx) {
+			link = E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU;
+		} else {
+			int isUp = 0;
+			if (e1000_oem_phy_is_link_up(&adapter->hw, &isUp) != E1000_SUCCESS)
+				isUp = 0;
+			link = isUp;
+		}
+	}
 
 	if (link) {
 		if (!netif_carrier_ok(netdev)) {
@@ -3814,6 +3902,103 @@ e1000_update_stats(struct e1000_adapter *adapter)
 	spin_unlock_irqrestore(&adapter->stats_lock, flags);
 }
 
+/*
+ * Check for tx hang condition. This is the condition where a
+ * decsriptor is in the hardware and hasn't been processed for a
+ * while. This code is similar to the check in e1000_clean_rx_irq()
+ */
+static void
+e1000_tx_hang_check(struct e1000_adapter *adapter,
+		    struct e1000_tx_ring *tx_ring)
+{
+	struct net_device *netdev = adapter->netdev;
+	unsigned int i;
+
+    /* Check for a hang condition using the buffer currently at the Tx
+       head pointer */
+	i = readl(adapter->hw.hw_addr + tx_ring->tdh);
+
+	if (adapter->detect_tx_hung) {
+		/* Detect a transmit hang in hardware, this serializes the
+		 * check with the clearing of time_stamp and movement of i */
+		adapter->detect_tx_hung = false;
+
+		if (tx_ring->buffer_info[i].dma &&
+		    time_after(jiffies, tx_ring->buffer_info[i].time_stamp + HZ)
+		    && !(E1000_READ_REG(&adapter->hw, STATUS) &
+                 E1000_STATUS_TXOFF)) {
+
+			/* detected Tx unit hang */
+			DPRINTK(DRV, ERR, "Detected Tx Unit Hang\n"
+					"  TDH                  <%x>\n"
+					"  TDT                  <%x>\n"
+					"  next_to_use          <%x>\n"
+					"  next_to_clean        <%x>\n"
+					"buffer_info[tdh]\n"
+					"  dma                  <%zx>\n"
+					"  time_stamp           <%lx>\n"
+                    "  jiffies              <%lx>\n",
+                    readl(adapter->hw.hw_addr + tx_ring->tdh),
+                    readl(adapter->hw.hw_addr + tx_ring->tdt),
+                    tx_ring->next_to_use,
+                    tx_ring->next_to_clean,
+                    (size_t)tx_ring->buffer_info[i].dma,
+                    tx_ring->buffer_info[i].time_stamp,
+                    jiffies);
+			netif_stop_queue(netdev);
+		}
+	}
+}
+/**
+ * e1000_clean_tx_ring_partial - Free Tx Buffers without using the DD
+ * bit in the descriptor
+ * @adapter: board private structure
+ * @tx_ring: ring to be cleaned
+ **/
+static void e1000_clean_tx_ring_partial(struct e1000_adapter *adapter,
+                                        struct e1000_tx_ring *tx_ring)
+{
+	struct e1000_buffer *buffer_info;
+	struct e1000_tx_desc *tx_desc;
+	struct net_device *netdev = adapter->netdev;
+	unsigned int i;
+	unsigned tail;
+	unsigned head;
+	int cleaned = false;
+
+	tail = readl(adapter->hw.hw_addr + tx_ring->tdt);
+	head = readl(adapter->hw.hw_addr + tx_ring->tdh);
+
+
+    /* Free all the Tx ring sk_buffs from next_to_clean up until
+     *  the current head pointer
+     */
+    i = tx_ring->next_to_clean;
+    while(i != head) {
+        cleaned = true;
+        tx_desc = E1000_TX_DESC(*tx_ring, i);
+
+        buffer_info = &tx_ring->buffer_info[i];
+        e1000_unmap_and_free_tx_resource(adapter, buffer_info);
+
+        tx_desc->upper.data = 0;
+
+        if (unlikely(++i == tx_ring->count)) i = 0;
+
+    }
+    tx_ring->next_to_clean = head;
+
+    spin_lock(&tx_ring->tx_lock);
+
+    /* Wake up the queue if it's currently stopped */
+    if (unlikely(cleaned && netif_queue_stopped(netdev) &&
+                 netif_carrier_ok(netdev))) {
+        netif_wake_queue(netdev);
+    }
+
+    spin_unlock(&tx_ring->tx_lock);
+}
+
 /**
  * e1000_intr_msi - Interrupt Handler
  * @irq: interrupt number
@@ -3864,10 +4049,23 @@ e1000_intr_msi(int irq, void *data)
 	adapter->total_tx_packets = 0;
 	adapter->total_rx_packets = 0;
 
-	for (i = 0; i < E1000_MAX_INTR; i++)
-		if (unlikely(!adapter->clean_rx(adapter, adapter->rx_ring) &
-		   !e1000_clean_tx_irq(adapter, adapter->tx_ring)))
-			break;
+	for (i = 0; i < E1000_MAX_INTR; i++) {
+		if (hw->mac_type == e1000_icp_xxxx) {
+			int rx;
+
+			rx = adapter->clean_rx(adapter,adapter->rx_ring);
+
+			if (icr & E1000_ICR_TXQE)
+				e1000_clean_tx_ring_partial(adapter,adapter->tx_ring);
+			else
+				e1000_tx_hang_check(adapter,adapter->tx_ring);
+			if (!rx)
+				break;
+		} else
+			if (unlikely(!adapter->clean_rx(adapter, adapter->rx_ring) &
+			   !e1000_clean_tx_irq(adapter, adapter->tx_ring)))
+				break;
+	}
 
 	if (likely(adapter->itr_setting & 3))
 		e1000_set_itr(adapter);
@@ -3959,10 +4157,23 @@ e1000_intr(int irq, void *data)
 	adapter->total_tx_packets = 0;
 	adapter->total_rx_packets = 0;
 
-	for (i = 0; i < E1000_MAX_INTR; i++)
-		if (unlikely(!adapter->clean_rx(adapter, adapter->rx_ring) &
-		   !e1000_clean_tx_irq(adapter, adapter->tx_ring)))
-			break;
+	for (i = 0; i < E1000_MAX_INTR; i++) {
+		if (hw->mac_type == e1000_icp_xxxx) {
+			int rx;
+
+			rx = adapter->clean_rx(adapter,adapter->rx_ring);
+
+			if (icr & E1000_ICR_TXQE)
+				e1000_clean_tx_ring_partial(adapter,adapter->tx_ring);
+			else
+				e1000_tx_hang_check(adapter,adapter->tx_ring);
+			if (!rx)
+				break;
+		} else
+			if (unlikely(!adapter->clean_rx(adapter, adapter->rx_ring) &
+			   !e1000_clean_tx_irq(adapter, adapter->tx_ring)))
+				break;
+	}
 
 	if (likely(adapter->itr_setting & 3))
 		e1000_set_itr(adapter);
@@ -5093,8 +5304,10 @@ e1000_set_spd_dplx(struct e1000_adapter *adapter, u16 spddplx)
 	adapter->hw.autoneg = 0;
 
 	/* Fiber NICs only allow 1000 gbps Full duplex */
-	if ((adapter->hw.media_type == e1000_media_type_fiber) &&
-		spddplx != (SPEED_1000 + DUPLEX_FULL)) {
+	if ((adapter->hw.media_type == e1000_media_type_fiber
+        || (adapter->hw.media_type == e1000_media_type_oem
+            && !e1000_oem_phy_is_copper(&adapter->hw)))
+       && spddplx != (SPEED_1000 + DUPLEX_FULL)) {
 		DPRINTK(PROBE, ERR, "Unsupported Speed/Duplex configuration\n");
 		return -EINVAL;
 	}
@@ -5131,6 +5344,7 @@ e1000_suspend(struct pci_dev *pdev, pm_message_t state)
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	u32 ctrl, ctrl_ext, rctl, status;
 	u32 wufc = adapter->wol;
+ 	u16 cmd_word;
 #ifdef CONFIG_PM
 	int retval = 0;
 #endif
@@ -5148,9 +5362,21 @@ e1000_suspend(struct pci_dev *pdev, pm_message_t state)
 		return retval;
 #endif
 
+	/*
+	 * ICP_XXXX style MACs do not have a link up bit in
+	 * the STATUS register, query the PHY directly
+	 */
+	if (adapter->hw.mac_type != e1000_icp_xxxx) {
 	status = E1000_READ_REG(&adapter->hw, STATUS);
 	if (status & E1000_STATUS_LU)
 		wufc &= ~E1000_WUFC_LNKC;
+	} else {
+		int isUp = 0;
+		if (e1000_oem_phy_is_link_up(&adapter->hw, &isUp) != E1000_SUCCESS)
+			isUp = 0;
+		if (isUp)
+			wufc &= ~E1000_WUFC_LNKC;
+	}
 
 	if (wufc) {
 		e1000_setup_rctl(adapter);
@@ -5215,6 +5441,23 @@ e1000_suspend(struct pci_dev *pdev, pm_message_t state)
 	e1000_release_hw_control(adapter);
 
 	pci_disable_device(pdev);
+	if (adapter->hw.mac_type == e1000_icp_xxxx) {
+		/*
+		 * ICP xxxx devices are not true PCI devices, in the context
+		 * of power management, disabling the bus mastership is not
+		 * sufficient to disable the device, it is also necessary to
+		 * disable IO, Memory, and Interrupts if they are enabled.
+		 */
+		pci_read_config_word(pdev, PCI_COMMAND, &cmd_word);
+		if (cmd_word & PCI_COMMAND_IO)
+			cmd_word &= ~PCI_COMMAND_IO;
+		if (cmd_word & PCI_COMMAND_MEMORY)
+			cmd_word &= ~PCI_COMMAND_MEMORY;
+		if (cmd_word & PCI_COMMAND_INTX_DISABLE)
+			cmd_word &= ~PCI_COMMAND_INTX_DISABLE;
+
+		pci_write_config_word(pdev, PCI_COMMAND, cmd_word);
+	}
 
 	pci_set_power_state(pdev, pci_choose_state(pdev, state));
 
diff --git a/drivers/net/e1000/e1000_oem_phy.c b/drivers/net/e1000/e1000_oem_phy.c
new file mode 100644
index 0000000..3f41f99
--- /dev/null
+++ b/drivers/net/e1000/e1000_oem_phy.c
@@ -0,0 +1,1899 @@
+/******************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+ version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+******************************************************************************/
+
+#include "e1000_oem_phy.h"
+#include "e1000.h"
+/*
+ * List of functions leveraged from the base iegbe driver.
+ *
+ * Ideally, it would have been nice to keep e1000_oem_phy.c
+ * minimally dependent on the iegbe. Any function taking
+ * a struct e1000_hw as a parameter can be implemented in
+ * this file. It was chosen to reuse as much code as possible
+ * to save time (isn't that always the case ;)
+ */
+extern int e1000_up(struct e1000_adapter *adapter);
+extern void e1000_down(struct e1000_adapter *adapter);
+extern void e1000_reset(struct e1000_adapter *adapter);
+extern int e1000_set_spd_dplx(struct e1000_adapter *adapter, uint16_t spddplx);
+extern int32_t e1000_copper_link_autoneg(struct e1000_hw *hw);
+extern int32_t e1000_phy_force_speed_duplex(struct e1000_hw *hw);
+extern int32_t e1000_copper_link_postconfig(struct e1000_hw *hw);
+#ifdef CONFIG_TOLAPAI
+extern int32_t gcu_read_eth_phy(uint32_t phy_num, uint32_t reg_addr,
+                         uint16_t *phy_data);
+extern int32_t gcu_write_eth_phy(uint32_t phy_num, uint32_t reg_addr,
+                          uint16_t phy_data);
+#else
+int32_t gcu_read_eth_phy(uint32_t phy_num, uint32_t reg_addr,
+                         uint16_t *phy_data) {return 0;}
+int32_t gcu_write_eth_phy(uint32_t phy_num, uint32_t reg_addr,
+                          uint16_t phy_data) {return 0;}
+#endif
+
+/* forward declarations for static support functions */
+static int32_t e1000_oem_link_m88_setup(struct e1000_hw *hw);
+static int32_t e1000_oem_set_phy_mode(struct e1000_hw *hw);
+static int32_t e1000_oem_detect_phy(struct e1000_hw *hw);
+
+/**
+ * e1000_oem_setup_link
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ *
+ * Performs OEM Transceiver specific link setup as part of the
+ * global e1000_setup_link() function.
+ **/
+int32_t
+e1000_oem_setup_link(struct e1000_hw *hw)
+{
+	/*
+     * see e1000_setup_copper_link() as the primary example. Look at both
+     * the M88 and IGP functions that are called for ideas, possibly for
+     * power management.
+	 */
+
+    int32_t ret_val;
+    uint32_t ctrl;
+    uint16_t i;
+    uint16_t phy_data;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return -1;
+
+    /* AFU: add test to exit out if improper phy type
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          /* relevent parts of e1000_copper_link_preconfig */
+          ctrl = E1000_READ_REG(hw, CTRL);
+          ctrl |= E1000_CTRL_SLU;
+          ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+          E1000_WRITE_REG(hw, CTRL, ctrl);
+
+          ret_val = e1000_oem_detect_phy(hw); // this is required for *hw init
+          if(ret_val)
+              return ret_val;
+
+          ret_val = e1000_oem_set_phy_mode(hw);
+          if(ret_val)
+              return ret_val;
+
+
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_CTRL,
+                                              &phy_data);
+          phy_data |= 0x00000008;
+          ret_val = e1000_oem_write_phy_reg_ex(hw, M88E1000_PHY_SPEC_CTRL,
+                                               phy_data);
+
+          ret_val = e1000_oem_link_m88_setup(hw);
+          if(ret_val) return ret_val;
+
+          if(hw->autoneg)
+          {
+              ret_val = e1000_copper_link_autoneg(hw);
+              if(ret_val) return ret_val;
+          }
+          else
+          {
+              DEBUGOUT("Forcing speed and duplex\n");
+              ret_val = e1000_phy_force_speed_duplex(hw);
+          }
+
+
+          /*
+           * Check link status. Wait up to 100 microseconds for link to become
+           * valid.
+           */
+          for(i = 0; i < 10; i++)
+          {
+              ret_val = e1000_oem_read_phy_reg_ex(hw, PHY_STATUS, &phy_data);
+              if(ret_val)
+              {
+                  DEBUGOUT("Unable to read register PHY_STATUS\n");
+                  return ret_val;
+              }
+
+              ret_val = e1000_oem_read_phy_reg_ex(hw, PHY_STATUS, &phy_data);
+              if(ret_val)
+              {
+                  DEBUGOUT("Unable to read register PHY_STATUS\n");
+                  return ret_val;
+              }
+
+	      hw->icp_xxxx_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;
+
+              if(phy_data & MII_SR_LINK_STATUS)
+              {
+                  // Config the MAC and PHY after link is up
+                  ret_val = e1000_copper_link_postconfig(hw);
+                  if(ret_val)
+                      return ret_val;
+
+                  DEBUGOUT("Valid link established!!!\n");
+                  return E1000_SUCCESS;
+              }
+              udelay(10);
+          }
+
+          DEBUGOUT("Unable to establish link!!!\n");
+          return E1000_SUCCESS;
+    }
+
+}
+
+
+/**
+ * e1000_oem_link_m88_setup
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ *
+ * lifted from e1000_copper_link_mgp_setup, pretty much
+ * copied verbatim except replace e1000_phy_reset with e1000_phy_hw_reset
+ **/
+static int32_t
+e1000_oem_link_m88_setup(struct e1000_hw *hw)
+{
+    int32_t ret_val;
+    uint16_t phy_data;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return -1;
+
+    /* phy_reset_disable is set in e1000_oem_set_phy_mode */
+    if(hw->phy_reset_disable)
+        return E1000_SUCCESS;
+
+    /* Enable CRS on TX. This must be set for half-duplex operation. */
+    ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+    if(ret_val)
+    {
+        DEBUGOUT("Unable to read M88E1000_PHY_SPEC_CTRL register\n");
+        return ret_val;
+    }
+
+    phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+
+    /*
+     * Options:
+     *   MDI/MDI-X = 0 (default)
+     *   0 - Auto for all speeds
+     *   1 - MDI mode
+     *   2 - MDI-X mode
+     *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
+     */
+    phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
+
+    switch (hw->mdix) {
+    case 1:
+        phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
+        break;
+    case 2:
+        phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
+        break;
+    case 3:
+        phy_data |= M88E1000_PSCR_AUTO_X_1000T;
+        break;
+    case 0:
+    default:
+        phy_data |= M88E1000_PSCR_AUTO_X_MODE;
+        break;
+    }
+
+    /*
+     * Options:
+     *   disable_polarity_correction = 0 (default)
+     *       Automatic Correction for Reversed Cable Polarity
+     *   0 - Disabled
+     *   1 - Enabled
+     */
+    phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
+
+    if(hw->disable_polarity_correction == 1)
+        phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
+    ret_val = e1000_oem_write_phy_reg_ex(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
+    if(ret_val)
+    {
+        DEBUGOUT("Unable to write M88E1000_PHY_SPEC_CTRL register\n");
+        return ret_val;
+    }
+
+    /*
+     * Force TX_CLK in the Extended PHY Specific Control Register
+     * to 25MHz clock.
+     */
+    ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+                                        &phy_data);
+    if(ret_val)
+    {
+        DEBUGOUT("Unable to read M88E1000_EXT_PHY_SPEC_CTRL register\n");
+        return ret_val;
+    }
+
+    /*
+     * For Truxton, it is necessary to add RGMII tx and rx
+     * timing delay though the EXT_PHY_SPEC_CTRL register
+     */
+    phy_data |= M88E1000_EPSCR_TX_TIME_CTRL;
+    phy_data |= M88E1000_EPSCR_RX_TIME_CTRL;
+
+    if (hw->phy_revision < M88E1011_I_REV_4) {
+
+        phy_data |= M88E1000_EPSCR_TX_CLK_25;
+        /* Configure Master and Slave downshift values */
+        phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
+                      M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
+        phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
+                     M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
+    }
+    ret_val = e1000_oem_write_phy_reg_ex(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+                                         phy_data);
+    if(ret_val)
+    {
+            DEBUGOUT("Unable to read M88E1000_EXT_PHY_SPEC_CTRL register\n");
+        return ret_val;
+    }
+
+
+    /* SW Reset the PHY so all changes take effect */
+    ret_val = e1000_phy_hw_reset(hw);
+    if(ret_val) {
+        DEBUGOUT("Error Resetting the PHY\n");
+        return ret_val;
+    }
+
+    return E1000_SUCCESS;
+}
+
+
+/**
+ * e1000_oem_force_mdi
+ * @hw: e1000_hw struct containing device specific information
+ * @resetPhy: returns true if after calling this function the
+ *            PHY requires a reset
+ *
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ *
+ * This is called from e1000_phy_force_speed_duplex, which is
+ * called from e1000_oem_setup_link.
+ **/
+int32_t
+e1000_oem_force_mdi(struct e1000_hw *hw, int *resetPhy)
+{
+
+    uint16_t phy_data;
+    int32_t ret_val;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw || !resetPhy)
+        return -1;
+
+    /*
+     * a boolean to indicate if the phy needs to be reset
+     *
+     * Make note that the M88 phy is what'll be used on Truxton
+     * see e1000_phy_force_speed_duplex, which does the following for M88
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_CTRL,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read M88E1000_PHY_SPEC_CTRL register\n");
+              return ret_val;
+          }
+
+          /*
+           * Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI
+           * forced whenever speed are duplex are forced.
+           */
+
+          phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
+          ret_val = e1000_oem_write_phy_reg_ex(hw, M88E1000_PHY_SPEC_CTRL,
+                                               phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to write M88E1000_PHY_SPEC_CTRL register\n");
+              return ret_val;
+          }
+
+          *resetPhy = true;
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_phy_reset_dsp
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ *
+ * This is called from e1000_phy_force_speed_duplex, which is
+ * called from e1000_oem_setup_link.
+ **/
+int32_t
+e1000_oem_phy_reset_dsp(struct e1000_hw *hw)
+{
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return -1;
+
+    /*
+     * Make note that the M88 phy is what'll be used on Truxton.
+     *
+     * See e1000_phy_force_speed_duplex, which calls e1000_phy_reset_dsp
+     * for the M88 PHY. The code as written references registers 29 and 30,
+     * which are reserved for the M88 used on Truxton, so this will be a
+     * no-op.
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          DEBUGOUT("No DSP to reset on OEM PHY\n");
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_cleanup_after_phy_reset
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ *
+ * This is called from e1000_phy_force_speed_duplex, which is
+ * called from e1000_oem_setup_link.
+ **/
+int32_t
+e1000_oem_cleanup_after_phy_reset(struct e1000_hw *hw)
+{
+
+    uint16_t phy_data;
+    int32_t ret_val;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return -1;
+
+    /*
+     * Make note that the M88 phy is what'll be used on Truxton.
+     * see e1000_phy_force_speed_duplex, which does the following for M88
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          /*
+           * Because we reset the PHY above, we need to re-force TX_CLK in the
+           * Extended PHY Specific Control Register to 25MHz clock.  This value
+           * defaults back to a 2.5MHz clock when the PHY is reset.
+           */
+
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read M88E1000_EXT_SPEC_CTRL register\n");
+              return ret_val;
+          }
+
+          phy_data |= M88E1000_EPSCR_TX_CLK_25;
+          ret_val = e1000_oem_write_phy_reg_ex(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+                                               phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to write M88E1000_EXT_PHY_SPEC_CTRL "
+                       "register\n");
+              return ret_val;
+          }
+
+          /*
+           * In addition, because of the s/w reset above, we need to enable
+           * CRX on TX.  This must be set for both full and half duplex
+           * operation.
+           */
+
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_CTRL,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read M88E1000_PHY_SPEC_CTRL register\n");
+              return ret_val;
+          }
+
+          phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+          ret_val = e1000_oem_write_phy_reg_ex(hw, M88E1000_PHY_SPEC_CTRL,
+                                               phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to write M88E1000_PHY_SPEC_CTRL register\n");
+              return ret_val;
+          }
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_set_phy_mode
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * Returns E1000_SUCCESS, negative E1000 error code on failure
+ *
+ * This is called from e1000_oem_setup_link which is
+ * called from e1000_setup_link.
+ **/
+static int32_t
+e1000_oem_set_phy_mode(struct e1000_hw *hw)
+{
+	/*
+	 * it is unclear if it is necessary to set the phy mode. Right now only
+	 * one MAC 82545 Rev 3 does it, but the other MACs like Tolapai do not.
+	 * Leave the functionality off for now until it is determined that Tolapai
+	 * needs it as well.
+	 */
+#ifdef skip_set_mode
+#undef skip_set_mode
+#endif
+
+#ifdef skip_set_mode
+    int32_t ret_val;
+    uint16_t eeprom_data;
+#endif
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return -1;
+
+	/*
+	 * e1000_set_phy_mode specifically works for 82545 Rev 3 only,
+	 * since it is a 'loner' compared to the 82545, 82546, and
+	 * 82546 Rev 3, assume for now it is anomaly and don't repeat
+	 * for Truxton/Haxton.
+	 * Note that this is the approach taken in both the Windows and
+	 * FreeBSD drivers
+	 */
+#ifndef skip_set_mode
+	DEBUGOUT("No need to call oem_set_phy_mode on Truxton\n");
+#else
+    /*
+     * Make note that the M88 phy is what'll be used on Truxton.
+     *
+     * use e1000_set_phy_mode as example
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          ret_val = e1000_read_eeprom(hw, EEPROM_PHY_CLASS_WORD, 1, &eeprom_data);
+          if(ret_val)
+          {
+              return ret_val;
+          }
+
+          if((eeprom_data != EEPROM_RESERVED_WORD) && (eeprom_data & EEPROM_PHY_CLASS_A))
+          {
+              ret_val = e1000_oem_write_phy_reg_ex(hw, M88E1000_PHY_PAGE_SELECT, 0x000B);
+              if(ret_val)
+              {
+                  DEBUGOUT("Unable to write to M88E1000_PHY_PAGE_SELECT register on PHY\n");
+                  return ret_val;
+              }
+
+              ret_val = e1000_oem_write_phy_reg_ex(hw,
+                                                   M88E1000_PHY_GEN_CONTROL,
+                                                   0x8104);
+              if(ret_val)
+              {
+                  DEBUGOUT("Unable to write to M88E1000_PHY_GEN_CONTROL"
+                           "register on PHY\n");
+                  return ret_val;
+              }
+
+              hw->phy_reset_disable = false;
+          }
+
+          break;
+    }
+#endif
+
+	return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_detect_phy
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * Fills hw->phy_type, hw->phy_id and hw->phy_revision fields as well
+ * as verifies that the PHY identified is one that is comprehended
+ * by the driver.
+ *
+ * This borrows heavily from e1000_detect_gig_phy
+ **/
+static int32_t
+e1000_oem_detect_phy(struct e1000_hw *hw)
+{
+    int32_t ret_val;
+    uint16_t phy_id_high, phy_id_low;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return -1;
+
+    hw->phy_type = e1000_phy_oem;
+
+    ret_val = e1000_oem_read_phy_reg_ex(hw, PHY_ID1, &phy_id_high);
+    if(ret_val)
+    {
+        DEBUGOUT("Unable to read PHY register PHY_ID1\n");
+        return ret_val;
+    }
+
+    udelay(20);
+    ret_val = e1000_oem_read_phy_reg_ex(hw, PHY_ID2, &phy_id_low);
+    if(ret_val)
+    {
+        DEBUGOUT("Unable to read PHY register PHY_ID2\n");
+        return ret_val;
+    }
+    hw->phy_id = (uint32_t) ((phy_id_high << 16) + phy_id_low);
+    hw->phy_revision = (uint32_t) phy_id_low & ~PHY_REVISION_MASK;
+    if(hw->phy_id != M88E1000_I_PHY_ID
+       && hw->phy_id != M88E1141_E_PHY_ID)
+    {
+        DEBUGOUT("PHY ID indicates an unsupported PHY\n");
+        return -E1000_ERR_PHY;
+    }
+
+    return E1000_SUCCESS;
+}
+
+
+/**
+ * e1000_oem_get_tipg
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * Returns the value of the Inter Packet Gap (IPG) Transmit Time (IPGT) in the
+ * Transmit IPG register appropriate for the given PHY. This field is only 10
+ * bits wide.
+ *
+ * In the original iegbe code, only the IPGT field varied between media types.
+ * If the OEM phy requires setting IPG Receive Time 1 & 2 Registers, it would
+ * be required to modify the e1000_config_tx() function to accomdate the change
+ *
+ **/
+uint32_t
+e1000_oem_get_tipg(struct e1000_hw *hw)
+{
+
+    uint32_t phy_num;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return DEFAULT_ICP_XXXX_TIPG_IPGT;
+
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          phy_num = DEFAULT_ICP_XXXX_TIPG_IPGT;
+          break;
+    }
+
+    return phy_num;
+
+}
+
+
+/**
+ * e1000_oem_phy_is_copper
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * Test for media type within the iegbe driver is common, so this is a simple
+ * test for copper PHYs. The ICP_XXXX family of controllers initially only
+ * supported copper interconnects (no TBI (ten bit interface) for Fiber
+ * existed). If future revs support either Fiber or an internal SERDES, it
+ * may become necessary to evaluate where this function is used to go beyond
+ * determining whether or not media type is just copper.
+ *
+ **/
+int
+e1000_oem_phy_is_copper(struct e1000_hw *hw)
+{
+
+    int isCopper = true;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return isCopper;
+
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+        isCopper = true;
+        break;
+    }
+
+	return isCopper;
+}
+
+
+/**
+ * e1000_oem_get_phy_dev_number
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * For ICP_XXXX family of devices, there are 3 MACs, each of which may
+ * have a different PHY (and indeed a different media interface). This
+ * function is used to indicate which of the MAC/PHY pairs we are interested
+ * in.
+ *
+ **/
+uint32_t
+e1000_oem_get_phy_dev_number(struct e1000_hw *hw)
+{
+
+    /*
+     * for ICP_XXXX family of devices, the three network interfaces are
+     * differentiated by their PCI device number, where the three share
+     * the same PCI bus
+     */
+	struct e1000_adapter *adapter;
+    uint32_t device_number;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return 0;
+
+	adapter = (struct e1000_adapter *) hw->back;
+    device_number = PCI_SLOT(adapter->pdev->devfn);
+
+    switch(device_number)
+    {
+      case ICP_XXXX_MAC_0: return ICP_XXXX_PHY_0;
+      case ICP_XXXX_MAC_1: return ICP_XXXX_PHY_1;
+      case ICP_XXXX_MAC_2: return ICP_XXXX_PHY_2;
+      default: return ICP_XXXX_PHY_0;
+    }
+
+}
+
+
+/**
+ * e1000_oem_mii_ioctl
+ * @adapter: e1000_hw struct containing device specific information
+ * @flags: The saved adapter->stats_lock flags from the initiating spinlock
+ * @ifr: interface request structure for socket ioctls
+ * @cmd: the original IOCTL command that instigated the call chain.
+ *
+ * This function abstracts out the code necessary to service the
+ * SIOCSMIIREG case within the e1000_mii_ioctl() for oem PHYs.
+ * e1000_mii_ioctl() was implemented for copper phy's only and this
+ * function will only be called if e1000_oem_phy_is_copper() returns true for
+ * a given MAC. Note that e1000_mii_ioctl() has a compile flag
+ * and exists only if SIOCGMIIPHY is defined.
+ *
+ * NOTE: a spinlock is in effect for the duration of this call. It is
+ *       imperative that a negative value be returned on any error, so
+ *       the spinlock can be released properly.
+ *
+ **/
+int
+e1000_oem_mii_ioctl(struct e1000_adapter *adapter, unsigned long flags,
+                    struct ifreq *ifr, int cmd)
+{
+
+    struct mii_ioctl_data *data = if_mii(ifr);
+    uint16_t mii_reg = data->val_in;
+    uint16_t spddplx;
+    int retval;
+
+    DEBUGFUNC(__func__);
+
+    if(!adapter || !ifr)
+        return -1;
+
+    switch(e1000_oem_get_phy_dev_number(&adapter->hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          switch (data->reg_num) {
+          case PHY_CTRL:
+              if(mii_reg & MII_CR_POWER_DOWN)
+                  break;
+              if(mii_reg & MII_CR_AUTO_NEG_EN) {
+                  adapter->hw.autoneg = 1;
+                  adapter->hw.autoneg_advertised = 0x2F;
+              } else {
+                  if(mii_reg & 0x40)
+                      spddplx = SPEED_1000;
+                  else if(mii_reg & 0x2000)
+                      spddplx = SPEED_100;
+                  else
+                      spddplx = SPEED_10;
+                  spddplx += (mii_reg & 0x100) ? FULL_DUPLEX : HALF_DUPLEX;
+                  retval = e1000_set_spd_dplx(adapter, spddplx);
+                  if(retval)
+                      return retval;
+              }
+              if(netif_running(adapter->netdev)) {
+                  e1000_down(adapter);
+                  e1000_up(adapter);
+              } else
+                  e1000_reset(adapter);
+              break;
+
+          case M88E1000_PHY_SPEC_CTRL:
+          case M88E1000_EXT_PHY_SPEC_CTRL:
+              retval = e1000_phy_reset(&adapter->hw);
+              if(retval)
+              {
+                  DEBUGOUT("Error resetting the PHY\n");
+                  return -EIO;
+              }
+              break;
+          }
+
+          break;
+    }
+	return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_fiber_live_in_suspend
+ * @hw: e1000_hw struct containing device specific information
+ *
+ * This is called within e1000_suspend() to allow an action to be performed
+ * on an oem phy before before the MAC goes into suspend. This is only called
+ * if the STATUS.LU (link up) bit has been previous set.
+ *
+ * For ICP_XXXX, this is a no op
+ **/
+void e1000_oem_fiber_live_in_suspend(struct e1000_hw *hw)
+{
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return;
+
+    return;
+
+}
+
+
+/**
+ * e1000_oem_get_phy_regs
+ * @adapter e1000_adapter struct containing device specific information
+ * @data unsigned integer array of size data_len
+ * @data_len number of elements in data
+ *
+ * This is called by e1000_get_regs() in response to an ethtool request
+ * to return the data of the controller. Most of the data returned is from
+ * the MAC, but some data comes from the PHY, thus from this f().
+ *
+ * Note: The call to e1000_get_regs() assumed an array of 24 elements
+ *       where the last 11 are passed to this function. If the array
+ *       that is passed to the calling function has its size or element
+ *       defintions changed, this function becomes broken.
+ *
+ **/
+void e1000_oem_get_phy_regs(struct e1000_adapter *adapter, uint32_t *data,
+                            uint32_t data_len)
+{
+#define EXPECTED_ARRAY_LEN 11
+    uint32_t corrected_len;
+
+    DEBUGFUNC(__func__);
+
+    if(!adapter || !data)
+        return;
+
+    /* This f(n) expects to have EXPECTED_ARRAY_LEN elements to initialize.
+     * Use the corrected_length variable to make sure we don't exceed that
+     * length
+     */
+    corrected_len = data_len>EXPECTED_ARRAY_LEN
+                    ? EXPECTED_ARRAY_LEN : data_len;
+    memset(data, 0, corrected_len*sizeof(uint32_t));
+
+
+    /*
+     * Fill data[] with...
+     *
+     * [0] = cable length
+     * [1] = cable length
+     * [2] = cable length
+     * [3] = cable length
+     * [4] = extended 10bt distance
+     * [5] = cable polarity
+     * [6] = cable polarity
+     * [7] = polarity correction enabled
+     * [8] = undefined
+     * [9] = phy receive errors
+     * [10] = mdix mode
+     */
+    switch(e1000_oem_get_phy_dev_number(&adapter->hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          if(corrected_len > 0)
+              e1000_oem_read_phy_reg_ex(&adapter->hw,
+                                        M88E1000_PHY_SPEC_STATUS,
+                                        (uint16_t *) &data[0]);
+          if(corrected_len > 1)
+              data[1] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
+          if(corrected_len > 2)
+              data[2] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
+          if(corrected_len > 3)
+              data[3] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
+          if(corrected_len > 4)
+              e1000_oem_read_phy_reg_ex(&adapter->hw, M88E1000_PHY_SPEC_CTRL,
+                                 (uint16_t *) &data[4]);
+          if(corrected_len > 5)
+              data[5] = data[0];
+          if(corrected_len > 6)
+              data[6] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
+          if(corrected_len > 7)
+              data[7] = data[4];
+          /* phy receive errors */
+          if(corrected_len > 9)
+              data[9] = adapter->phy_stats.receive_errors;
+          if(corrected_len > 10)
+              data[10] = data[0];
+
+          break;
+    }
+
+#undef EXPECTED_ARRAY_LEN
+    return;
+}
+
+
+/**
+ * e1000_oem_phy_loopback
+ * @adapter e1000_adapter struct containing device specific information
+ *
+ * This is called from e1000_set_phy_loopback in response from call from
+ * ethtool to place the PHY into loopback mode.
+ **/
+int
+e1000_oem_phy_loopback(struct e1000_adapter *adapter)
+{
+
+    int ret_val;
+    uint32_t ctrl_reg = 0;
+
+    DEBUGFUNC(__func__);
+
+    if(!adapter)
+        return -1;
+
+    /*
+     * This borrows liberally from e1000_integrated_phy_loopback().
+     * e1000_nonintegrated_phy_loopback() was also a point of reference
+     * since it was similar. The biggest difference between the two
+     * was that nonintegrated called e1000_phy_reset_clk_and_crs(),
+     * hopefully this won't matter as CRS required for half-duplex
+     * operation and this is set to full duplex.
+     *
+     * Make note that the M88 phy is what'll be used on Truxton
+     */
+
+    switch(e1000_oem_get_phy_dev_number(&adapter->hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          adapter->hw.autoneg = false;
+
+          /* turn off Auto-MDI/MDIX */
+          //ret_val = e1000_oem_write_phy_reg_ex(&adapter->hw,
+          //                                     M88E1000_PHY_SPEC_CTRL, 0x0808);
+          //if(ret_val)
+          //{
+         //     DEBUGOUT("Unable to write to register M88E1000_PHY_SPEC_CTRL\n");
+          //    return ret_val;
+         // }
+
+          /* reset to update Auto-MDI/MDIX */
+        //  ret_val = e1000_oem_write_phy_reg_ex(&adapter->hw, PHY_CTRL, 0x9140);
+        //  if(ret_val)
+        //  {
+        //      DEBUGOUT("Unable to write to register PHY__CTRL\n");
+        //      return ret_val;
+        //  }
+
+          /* autoneg off */
+          //ret_val = e1000_oem_write_phy_reg_ex(&adapter->hw, PHY_CTRL, 0x8140);
+          ret_val = e1000_oem_write_phy_reg_ex(&adapter->hw, PHY_CTRL, 0xa100);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to write to register PHY_CTRL\n");
+              return ret_val;
+          }
+
+
+          /* force 1000, set loopback */
+          //ret_val = e1000_oem_write_phy_reg_ex(&adapter->hw, PHY_CTRL, 0x4140);
+          ret_val = e1000_oem_write_phy_reg_ex(&adapter->hw, PHY_CTRL, 0x6100);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to write to register PHY_CTRL\n");
+              return ret_val;
+          }
+
+          ctrl_reg = E1000_READ_REG(&adapter->hw, CTRL);
+          ctrl_reg &= ~E1000_CTRL_SPD_SEL;   /* Clear the speed sel bits */
+          ctrl_reg |= (E1000_CTRL_FRCSPD     /* Set the Force Speed Bit */
+                       | E1000_CTRL_FRCDPX   /* Set the Force Duplex Bit */
+                       | E1000_CTRL_SPD_100 /* Force Speed to 1000 */
+                       | E1000_CTRL_FD);       /* Force Duplex to FULL */
+                    //   | E1000_CTRL_ILOS);   /* Invert Loss of Signal */
+
+          E1000_WRITE_REG(&adapter->hw, CTRL, ctrl_reg);
+
+          /*
+           * Write out to PHY registers 29 and 30 to disable the Receiver.
+           * This directly lifted from e1000_phy_disable_receiver().
+           *
+           * The code is currently commented out as for the M88 used in
+           * Truxton, registers 29 and 30 are unutilized. Leave in, just
+           * in case we are on the receiving end of an 'undocumented'
+           * feature
+           */
+          /*
+           * e1000_oem_write_phy_reg_ex(&adapter->hw, 29, 0x001F);
+           * e1000_oem_write_phy_reg_ex(&adapter->hw, 30, 0x8FFC);
+           * e1000_oem_write_phy_reg_ex(&adapter->hw, 29, 0x001A);
+           * e1000_oem_write_phy_reg_ex(&adapter->hw, 30, 0x8FF0);
+           */
+
+          break;
+    }
+
+    return 0;
+
+}
+
+
+/**
+ * e1000_oem_loopback_cleanup
+ * @adapter e1000_adapter struct containing device specific information
+ *
+ * This is called from e1000_loopback_cleanup in response from call from
+ * ethtool to place the PHY out of loopback mode. This handles the OEM
+ * specific part of loopback cleanup.
+ **/
+void
+e1000_oem_loopback_cleanup(struct e1000_adapter *adapter)
+{
+
+    /*
+     * This borrows liberally from e1000_loopback_cleanup().
+     * making note that the M88 phy is what'll be used on Truxton
+     */
+    int32_t ret_val;
+    uint16_t phy_reg;
+
+    DEBUGFUNC(__func__);
+
+    if(!adapter)
+        return ;
+
+    switch(e1000_oem_get_phy_dev_number(&adapter->hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          adapter->hw.autoneg = true;
+
+          ret_val = e1000_oem_read_phy_reg_ex(&adapter->hw, PHY_CTRL,
+                                              &phy_reg);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read to register PHY_CTRL\n");
+              return;
+          }
+
+          if(phy_reg & MII_CR_LOOPBACK)
+          {
+              phy_reg &= ~MII_CR_LOOPBACK;
+
+              ret_val = e1000_oem_write_phy_reg_ex(&adapter->hw, PHY_CTRL,
+                                                   phy_reg);
+              if(ret_val)
+              {
+                  DEBUGOUT("Unable to write to register PHY_CTRL\n");
+                  return;
+              }
+
+              e1000_phy_reset(&adapter->hw);
+          }
+
+          break;
+    }
+
+    return;
+
+}
+
+
+/**
+ * e1000_oem_phy_speed_downgraded
+ * @hw e1000_hw struct containing device specific information
+ * @isDowngraded returns with value > 0 if the link belonging to hw
+ *               has been downshifted
+ *
+ * Called by e1000_check_downshift(), checks the PHY to see if it running
+ * at as speed slower than its maximum.
+ **/
+uint32_t
+e1000_oem_phy_speed_downgraded(struct e1000_hw *hw, uint16_t *isDowngraded)
+{
+
+    uint32_t ret_val;
+    uint16_t phy_data;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw || !isDowngraded)
+        return 1;
+
+    /*
+     * borrow liberally from E1000_check_downshift e1000_phy_m88 case.
+     * Make note that the M88 phy is what'll be used on Truxton
+     */
+
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_STATUS,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read register M88E1000_PHY_SPEC_STATUS\n");
+              return ret_val;
+          }
+
+          *isDowngraded = (phy_data & M88E1000_PSSR_DOWNSHIFT)
+                          >> M88E1000_PSSR_DOWNSHIFT_SHIFT;
+
+          break;
+    }
+
+    return 0;
+
+}
+
+
+/**
+ * e1000_oem_check_polarity
+ * @hw e1000_hw struct containing device specific information
+ * @isDowngraded returns with value > 0 if the link belonging to hw
+ *               has its polarity shifted.
+ *
+ * Called by e1000_check_downshift(), checks the PHY to see if it running
+ * at as speed slower than its maximum.
+ **/
+int32_t
+e1000_oem_check_polarity(struct e1000_hw *hw, e1000_rev_polarity *polarity)
+{
+
+    int32_t ret_val;
+    uint16_t phy_data;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw || !polarity)
+        return -1;
+
+    /*
+     * borrow liberally from e1000_check_polarity.
+     * Make note that the M88 phy is what'll be used on Truxton
+     */
+
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          /* return the Polarity bit in the Status register. */
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_STATUS,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read register M88E1000_PHY_SPEC_STATUS\n");
+              return ret_val;
+          }
+
+          *polarity = (phy_data & M88E1000_PSSR_REV_POLARITY)
+                      >> M88E1000_PSSR_REV_POLARITY_SHIFT;
+
+          break;
+    }
+
+    return 0;
+
+}
+
+
+/**
+ * e1000_oem_phy_is_full_duplex
+ * @hw e1000_hw struct containing device specific information
+ * @isFD a boolean returning true if phy is full duplex
+ *
+ * This is called as part of e1000_config_mac_to_phy() to align
+ * the MAC with the PHY. It turns out on ICP_XXXX, this is not
+ * done automagically.
+ **/
+int32_t
+e1000_oem_phy_is_full_duplex(struct e1000_hw *hw, int *isFD)
+{
+
+    uint16_t phy_data;
+    int32_t ret_val;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw || !isFD)
+        return -1;
+
+    /*
+     * Make note that the M88 phy is what'll be used on Truxton
+     * see e1000_config_mac_to_phy
+     */
+
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_STATUS,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read register M88E1000_PHY_SPEC_STATUS\n");
+              return ret_val;
+          }
+
+          *isFD = (phy_data & M88E1000_PSSR_DPLX) != 0;
+
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_phy_is_speed_1000
+ * @hw e1000_hw struct containing device specific information
+ * @is1000 a boolean returning true if phy is running at 1000
+ *
+ * This is called as part of e1000_config_mac_to_phy() to align
+ * the MAC with the PHY. It turns out on ICP_XXXX, this is not
+ * done automagically.
+ **/
+int32_t
+e1000_oem_phy_is_speed_1000(struct e1000_hw *hw, int *is1000)
+{
+
+    uint16_t phy_data;
+    int32_t ret_val;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw || !is1000)
+        return -1;
+
+    /*
+     * Make note that the M88 phy is what'll be used on Truxton.
+     * see e1000_config_mac_to_phy
+     */
+
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_STATUS,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read register M88E1000_PHY_SPEC_STATUS\n");
+              return ret_val;
+          }
+
+          *is1000 = (phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS;
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_phy_is_speed_100
+ * @hw e1000_hw struct containing device specific information
+ * @is100 a boolean returning true if phy is running at 100
+ *
+ * This is called as part of e1000_config_mac_to_phy() to align
+ * the MAC with the PHY. It turns out on ICP_XXXX, this is not
+ * done automagically.
+ **/
+int32_t
+e1000_oem_phy_is_speed_100(struct e1000_hw *hw, int *is100)
+{
+
+    uint16_t phy_data;
+    int32_t ret_val;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw || !is100)
+        return -1;
+
+    /*
+     * Make note that the M88 phy is what'll be used on Truxton
+     * see e1000_config_mac_to_phy
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_STATUS,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read register M88E1000_PHY_SPEC_STATUS\n");
+              return ret_val;
+          }
+
+          *is100 = (phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS;
+
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_phy_get_info
+ * @hw struct e1000_hw containing hardware specific data
+ * @phy_info struct e1000_phy_info that returned
+ *
+ * This is called by e1000_phy_get_info to gather PHY specific
+ * data. This is called for copper media based phys.
+ **/
+int32_t
+e1000_oem_phy_get_info(struct e1000_hw *hw,
+                       struct e1000_phy_info *phy_info)
+{
+
+    int32_t ret_val;
+    uint16_t phy_data;
+    e1000_rev_polarity  polarity;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw || !phy_info)
+        return -1;
+
+    /*
+     * Make note that the M88 phy is what'll be used on Truxton
+     * see e1000_phy_m88_get_info
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          /* The downshift status is checked only once, after link is
+           * established and it stored in the hw->speed_downgraded parameter.*/
+          phy_info->downshift = (e1000_downshift)hw->speed_downgraded;
+
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_CTRL,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read register M88E1000_PHY_SPEC_CTRL\n");
+              return ret_val;
+          }
+
+          phy_info->extended_10bt_distance =
+              (phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE)
+               >> M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT;
+          phy_info->polarity_correction =
+              (phy_data & M88E1000_PSCR_POLARITY_REVERSAL)
+               >> M88E1000_PSCR_POLARITY_REVERSAL_SHIFT;
+
+          /* Check polarity status */
+          ret_val = e1000_oem_check_polarity(hw, &polarity);
+          if(ret_val)
+              return ret_val;
+
+          phy_info->cable_polarity = polarity;
+
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_STATUS,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read register M88E1000_PHY_SPEC_STATUS\n");
+              return ret_val;
+          }
+
+          phy_info->mdix_mode = (phy_data & M88E1000_PSSR_MDIX)
+                                 >> M88E1000_PSSR_MDIX_SHIFT;
+
+          if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) {
+              /* Cable Length Estimation and Local/Remote Receiver Information
+               * are only valid at 1000 Mbps.
+               */
+              phy_info->cable_length =
+                  (phy_data & M88E1000_PSSR_CABLE_LENGTH)
+                   >> M88E1000_PSSR_CABLE_LENGTH_SHIFT;
+
+              ret_val = e1000_oem_read_phy_reg_ex(hw, PHY_1000T_STATUS,
+                                                  &phy_data);
+              if(ret_val)
+              {
+                  DEBUGOUT("Unable to read register PHY_1000T_STATUS\n");
+                  return ret_val;
+              }
+
+              phy_info->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS)
+                                    >> SR_1000T_LOCAL_RX_STATUS_SHIFT;
+
+              phy_info->remote_rx = (phy_data & SR_1000T_REMOTE_RX_STATUS)
+                                    >> SR_1000T_REMOTE_RX_STATUS_SHIFT;
+          }
+
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_phy_hw_reset
+ * @hw struct e1000_hw containing hardware specific data
+ *
+ * This function will perform a software initiated reset of
+ * the PHY
+ **/
+int32_t
+e1000_oem_phy_hw_reset(struct e1000_hw *hw)
+{
+
+    int32_t ret_val;
+    uint16_t phy_data
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return -1;
+
+    /*
+     * This code pretty much copies the default case from
+     * e1000_phy_reset() as that is what is appropriate for
+     * the M88 used in truxton.
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          ret_val = e1000_oem_read_phy_reg_ex(hw, PHY_CTRL, &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read register PHY_CTRL\n");
+              return ret_val;
+          }
+
+          phy_data |= MII_CR_RESET;
+          ret_val = e1000_oem_write_phy_reg_ex(hw, PHY_CTRL, phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to write register PHY_CTRL\n");
+              return ret_val;
+          }
+
+          udelay(1);
+
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_phy_init_script
+ * @hw struct e1000_hw containing hardware specific data
+ *
+ * This gets called in three places, after e1000_oem_phy_hw_reset()
+ * to perform and post reset initialiation. Not all PHYs require
+ * this, which is why it was split off as a seperate function.
+ **/
+void
+e1000_oem_phy_init_script(struct e1000_hw *hw)
+{
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return;
+
+    /* call the GCU func that can do any phy specific init
+     * functions after a reset
+     *
+     * Make note that the M88 phy is what'll be used on Truxton
+     *
+     * The closest thing is in e1000_phy_init_script, however this is
+     * for the IGP style of phy. This is probably a no-op for truxton
+     * but may be needed by OEM's later on
+     *
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          DEBUGOUT("Nothing to do for OEM PHY Init");
+          break;
+    }
+
+    return;
+
+}
+
+
+/**
+ * e1000_oem_read_phy_reg_ex
+ * @hw struct e1000_hw containing hardware specific data
+ * @reg_addr address location within the PHY register set
+ * @phy_data returns the data read from reg_addr
+ *
+ * This encapsulates the interface call to the GCU for access
+ * to the MDIO for the PHY.
+ **/
+int32_t
+e1000_oem_read_phy_reg_ex(struct e1000_hw *hw,
+                          uint32_t reg_addr,
+                          uint16_t *phy_data)
+{
+
+    int32_t ret_val;
+    DEBUGFUNC(__func__);
+
+    if(!hw || !phy_data)
+        return -1;
+
+    /* call the GCU func that will read the phy
+     *
+     * Make note that the M88 phy is what'll be used on Truxton.
+     *
+     * The closest thing is in e1000_read_phy_reg_ex.
+     *
+     * NOTE: this is 1 (of 2) functions that is truly dependant on the
+     *       gcu module
+     */
+
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          ret_val = gcu_read_eth_phy(e1000_oem_get_phy_dev_number(hw),
+                                     reg_addr, phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Error reading GCU");
+              return ret_val;
+          }
+
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_write_phy_reg_ex
+ * @hw struct e1000_hw containing hardware specific data
+ * @reg_addr address location within the PHY register set
+ * @phy_data data to be written to reg_addr
+ *
+ * This encapsulates the interface call to the GCU for access
+ * to the MDIO for the PHY.
+ **/
+int32_t
+e1000_oem_write_phy_reg_ex(struct e1000_hw *hw,
+                           uint32_t reg_addr,
+                           uint16_t phy_data)
+{
+
+    int32_t ret_val;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return -1;
+
+    /* call the GCU func that will write to the phy
+     *
+     * Make note that the M88 phy is what'll be used on Truxton.
+     *
+     * The closest thing is in e1000_write_phy_reg_ex
+     *
+     * NOTE: this is 2 (of 2) functions that is truly dependant on the
+     *       gcu module
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          ret_val = gcu_write_eth_phy(e1000_oem_get_phy_dev_number(hw),
+                                      reg_addr, phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Error writing to GCU");
+              return ret_val;
+          }
+
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_phy_needs_reset_with_mac
+ * @hw struct e1000_hw hardware specific data
+ *
+ * e1000_reset_hw is called to reset the MAC. If, for
+ * some reason the PHY needs to be reset as well, this
+ * should return TRUE and then e1000_oem_phy_hw_reset()
+ * will be called.
+ **/
+int
+e1000_oem_phy_needs_reset_with_mac(struct e1000_hw *hw)
+{
+
+    int ret_val;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return false;
+
+	/*
+     * From the original iegbe driver, the M88
+     * PHYs did not seem to need this reset,
+     * so returning false.
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          ret_val = false;
+          break;
+    }
+
+	return ret_val;
+
+}
+
+
+/**
+ * e1000_oem_config_dsp_after_link_change
+ * @hw struct e1000_hw containing hardware specific data
+ * @link_up allows different configurations based on whether
+ *          not the link was up.
+ *
+ * This is called from e1000_check_for_link, and allows for
+ * tweaking of the PHY, for PHYs that support a DSP.
+ *
+ **/
+int32_t
+e1000_oem_config_dsp_after_link_change(struct e1000_hw *hw,
+                                       int link_up)
+{
+
+    DEBUGFUNC(__func__);
+
+    if(!hw)
+        return -1;
+
+	/*
+     * Make note that the M88 phy is what'll be used on Truxton,
+     * but in the iegbe driver, it had no such func. This is a no-op
+     * for M88, but may be useful for other phys
+     *
+     * use e1000_config_dsp_after_link_change as example
+     */
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+          DEBUGOUT("No DSP to configure on OEM PHY");
+          break;
+    }
+
+	return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_get_cable_length
+ * @hw struct e1000_hw containing hardware specific data
+ * @min_length pointer to return the approx minimum length
+ * @max_length pointer to return the approx maximum length
+ *
+ *
+ **/
+int32_t
+e1000_oem_get_cable_length(struct e1000_hw *hw,
+						   uint16_t *min_length,
+						   uint16_t *max_length)
+{
+
+	int32_t ret_val;
+	uint16_t cable_length;
+	uint16_t phy_data;
+
+	DEBUGFUNC(__func__);
+
+    if(!hw || !min_length || !max_length)
+        return -1;
+
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+        ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_STATUS,
+                                     	    &phy_data);
+        if(ret_val)
+            return ret_val;
+
+        cable_length = (phy_data & M88E1000_PSSR_CABLE_LENGTH)
+			   	        >> M88E1000_PSSR_CABLE_LENGTH_SHIFT;
+
+        /* Convert the enum value to ranged values */
+        switch (cable_length) {
+        case e1000_cable_length_50:
+            *min_length = 0;
+            *max_length = e1000_igp_cable_length_50;
+            break;
+        case e1000_cable_length_50_80:
+            *min_length = e1000_igp_cable_length_50;
+            *max_length = e1000_igp_cable_length_80;
+            break;
+        case e1000_cable_length_80_110:
+            *min_length = e1000_igp_cable_length_80;
+            *max_length = e1000_igp_cable_length_110;
+            break;
+        case e1000_cable_length_110_140:
+            *min_length = e1000_igp_cable_length_110;
+            *max_length = e1000_igp_cable_length_140;
+            break;
+        case e1000_cable_length_140:
+            *min_length = e1000_igp_cable_length_140;
+            *max_length = e1000_igp_cable_length_170;
+            break;
+        default:
+            return -E1000_ERR_PHY;
+            break;
+        }
+
+          break;
+    }
+
+	return E1000_SUCCESS;
+
+}
+
+
+/**
+ * e1000_oem_phy_is_link_up
+ * @hw e1000_hw struct containing device specific information
+ * @isUp a boolean returning true if link is up
+ *
+ * This is called as part of e1000_config_mac_to_phy() to align
+ * the MAC with the PHY. It turns out on ICP_XXXX, this is not
+ * done automagically.
+ **/
+int32_t
+e1000_oem_phy_is_link_up(struct e1000_hw *hw, int *isUp)
+{
+
+    uint16_t phy_data;
+    int32_t ret_val;
+
+    DEBUGFUNC(__func__);
+
+    if(!hw || !isUp)
+        return -1;
+
+    /*
+     * Make note that the M88 phy is what'll be used on Truxton
+     * see e1000_config_mac_to_phy
+     */
+
+    switch(e1000_oem_get_phy_dev_number(hw))
+    {
+      case ICP_XXXX_PHY_0:
+      case ICP_XXXX_PHY_1:
+      case ICP_XXXX_PHY_2:
+      default:
+
+          /*
+	   * according to the Marvell data sheet, it is required to
+	   * read the PHY_SPEC_STATUS register twice if one wishes to
+	   * obtain the current link state
+	   */
+          e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+          ret_val = e1000_oem_read_phy_reg_ex(hw, M88E1000_PHY_SPEC_STATUS,
+                                              &phy_data);
+          if(ret_val)
+          {
+              DEBUGOUT("Unable to read register M88E1000_PHY_SPEC_STATUS\n");
+              return ret_val;
+          }
+
+          *isUp = (phy_data & M88E1000_PSSR_LINK) != 0;
+
+          break;
+    }
+
+    return E1000_SUCCESS;
+
+}
+
+
diff --git a/drivers/net/e1000/e1000_oem_phy.h b/drivers/net/e1000/e1000_oem_phy.h
new file mode 100644
index 0000000..4e4482b
--- /dev/null
+++ b/drivers/net/e1000/e1000_oem_phy.h
@@ -0,0 +1,104 @@
+/*******************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+ version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+*******************************************************************************/
+#ifndef _IEGBE_OEM_PHY_H_
+#define _IEGBE_OEM_PHY_H_
+
+#include <linux/types.h>
+#include "e1000_hw.h"
+
+struct e1000_hw;
+struct e1000_adapter;
+struct ifreq;
+struct e1000_phy_info;
+
+int32_t e1000_oem_setup_link(struct e1000_hw *hw);
+
+uint32_t e1000_oem_get_tipg(struct e1000_hw *hw);
+int e1000_oem_phy_is_copper(struct e1000_hw *hw);
+uint32_t e1000_oem_get_phy_dev_number(struct e1000_hw *hw);
+int e1000_oem_mii_ioctl(struct e1000_adapter *adapter, unsigned long flags,
+                        struct ifreq *ifr, int cmd);
+void e1000_oem_fiber_live_in_suspend(struct e1000_hw *hw);
+void e1000_oem_get_phy_regs(struct e1000_adapter *adapter, uint32_t *data,
+                            uint32_t data_length);
+int e1000_oem_phy_loopback(struct e1000_adapter *adapter);
+void e1000_oem_loopback_cleanup(struct e1000_adapter *adapter);
+uint32_t e1000_oem_phy_speed_downgraded(struct e1000_hw *hw, uint16_t *isDowngraded);
+int32_t e1000_oem_check_polarity(struct e1000_hw *hw, e1000_rev_polarity *polarity);
+
+int32_t e1000_oem_phy_is_full_duplex(struct e1000_hw *hw, int *isFD);
+int32_t e1000_oem_phy_is_speed_1000(struct e1000_hw *hw, int *is1000);
+int32_t e1000_oem_phy_is_speed_100(struct e1000_hw *hw, int *is100);
+
+int32_t e1000_oem_force_mdi(struct e1000_hw *hw, int *resetPhy);
+int32_t e1000_oem_phy_reset_dsp(struct e1000_hw *hw);
+int32_t e1000_oem_cleanup_after_phy_reset(struct e1000_hw *hw);
+
+int32_t e1000_oem_phy_get_info(struct e1000_hw *hw,
+                               struct e1000_phy_info *phy_info);
+
+int32_t e1000_oem_phy_hw_reset(struct e1000_hw *hw);
+void e1000_oem_phy_init_script(struct e1000_hw *hw);
+
+int32_t e1000_oem_read_phy_reg_ex(struct e1000_hw *hw,
+                                  uint32_t reg_addr,
+                                  uint16_t *phy_data);
+int32_t e1000_oem_write_phy_reg_ex(struct e1000_hw *hw,
+                                   uint32_t reg_addr,
+                                   uint16_t phy_data);
+
+int e1000_oem_phy_needs_reset_with_mac(struct e1000_hw *hw);
+
+int32_t e1000_oem_config_dsp_after_link_change(struct e1000_hw *hw,
+                                               int link_up);
+
+int32_t e1000_oem_get_cable_length(struct e1000_hw *hw,
+		        				   uint16_t *min_length,
+			        			   uint16_t *max_length);
+
+int32_t e1000_oem_phy_is_link_up(struct e1000_hw *hw, int *isUp);
+
+/* Default Register Macros */
+
+#define ICP_XXXX_MAC_0 0       /* PCI Device numbers associated with MACs on */
+#define ICP_XXXX_MAC_1 1       /* ICP_XXXX family of controllers */
+#define ICP_XXXX_MAC_2 2
+
+#define ICP_XXXX_PHY_0 0       /* Braindead pneumonics for PHY numbers */
+#define ICP_XXXX_PHY_1 1
+#define ICP_XXXX_PHY_2 2
+
+#define DEFAULT_ICP_XXXX_TIPG_IPGT 8      /* Inter Packet Gap Transmit Time */
+#define ICP_XXXX_TIPG_IPGT_MASK 0x000003FFUL
+
+#endif /* ifndef _IEGBE_OEM_PHY_H_ */
+
diff --git a/drivers/net/e1000/e1000_param.c b/drivers/net/e1000/e1000_param.c
index e6565ce..2cececa 100644
--- a/drivers/net/e1000/e1000_param.c
+++ b/drivers/net/e1000/e1000_param.c
@@ -539,6 +539,12 @@ e1000_check_options(struct e1000_adapter *adapter)
 	case e1000_media_type_copper:
 		e1000_check_copper_options(adapter);
 		break;
+        case e1000_media_type_oem:
+        	if(e1000_oem_phy_is_copper(&adapter->hw))
+        	    e1000_check_copper_options(adapter);
+        	else
+        	    e1000_check_fiber_options(adapter);
+        	break;
 	default:
 		BUG();
 	}
-- 
1.5.6.rc1

