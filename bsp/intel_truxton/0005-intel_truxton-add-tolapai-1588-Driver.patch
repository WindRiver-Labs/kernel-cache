From cb036856364c3982c93e3a4373411a30fa57e1a7 Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Thu, 18 Dec 2008 16:12:00 +0800
Subject: [PATCH] intel_truxton: add tolapai 1588 Driver

The 1588 driver module enables a client application to have
access to the 1588 time synchronization hardware assist block.
A client application can use this driver to retreive tx and rx
timestamps of IEEE 1588(TM) PTP messages captured on ethernet or CAN
ports. Access is provided by a set of APIs that can be called directly
or through ioctl commands.

This driver is ported from the Intel SDK V0.7.18 version.

Signed-off-by: Li Wang <li.wang@windriver.com>
---
 drivers/char/Kconfig        |    9 +
 drivers/char/Makefile       |    2 +
 drivers/char/tolapai_1588.c | 2620 +++++++++++++++++++++++++++++++++++++++++++
 drivers/char/tolapai_1588.h | 1962 ++++++++++++++++++++++++++++++++
 4 files changed, 4593 insertions(+), 0 deletions(-)
 create mode 100644 drivers/char/tolapai_1588.c
 create mode 100644 drivers/char/tolapai_1588.h

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index caff851..ffd332c 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -1104,5 +1104,14 @@ config DEVPORT
 
 source "drivers/s390/char/Kconfig"
 
+config TOLAPAI_1588
+	tristate "Tolapai IEEE 1588 Time Synchronization Hardware Assist"
+	depends on X86 && PCI
+	---help---
+	  The 1588 driver module enables a client application to have access to
+	  the 1588 time synchronization hardware assist block. A client
+	  application can use this driver to receive tx and rx timestamps
+	  of IEEE 1588 PTP messages captured on ethernet or CAN ports.
+
 endmenu
 
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 6850f6d..6cff75b 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -111,6 +111,8 @@ obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
 
+obj-$(CONFIG_TOLAPAI_1588)	+= tolapai_1588.o
+
 # Files generated that shall be removed upon make clean
 clean-files := consolemap_deftbl.c defkeymap.c
 
diff --git a/drivers/char/tolapai_1588.c b/drivers/char/tolapai_1588.c
new file mode 100644
index 0000000..b57e761
--- /dev/null
+++ b/drivers/char/tolapai_1588.c
@@ -0,0 +1,2620 @@
+/*
+ *   Copyright(c) 2007 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *  version: Embedded.L.0.7.018
+*/
+
+/*
+ * Abstract:
+ *	The 1588 driver module enables a client application to have
+ * 	access to the 1588 time synchronization hardware assist block.
+ * 	A client application can use this driver to retreive tx and rx
+ * 	timestamps of IEEE 1588(TM) PTP messages captured on ethernet or CAN
+ * 	ports. Access is provided by a set of APIs that can be called directly
+ * 	or through ioctl commands.
+ */
+
+#include "tolapai_1588.h"
+
+MODULE_AUTHOR("Intel(R) Corporation");
+MODULE_DESCRIPTION("Intel(R) 1588 Time Synchronization Hardware Assist");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.7.2");
+
+/* driver data struct */
+static drvr_data_t g_drvr_data;
+/* Global event variables */
+static unsigned int g_eventflag[NUM_EVENTS];
+static wait_queue_head_t g_notify_event[NUM_EVENTS];
+/* ioctl call data structures for notify events */
+static IxTimeSyncAccTimeValue gTargTimeIoctl;
+static IxTimeSyncAccTimeValue gAuxTargTimeIoctl;
+static IxTimeSyncAccAuxTimeIoctl gAuxTimeIoctl;
+static unsigned int gPulsePerSecondIoctl;
+
+/* HAL callback function pointers */
+static IxTimeSyncAccTargetTimeCallback TargetTimeCallbackPtr;
+static IxTimeSyncAccAuxTimeCallback AuxTimeCallbackPtr;
+static IxTimeSyncAccAuxTargetTimeCallback AuxTargetTimeCallbackPtr;
+static IxTimeSyncAccPulsePerSecondCallback PulsePerSecondCallbackPtr;
+
+/*
+ * Client registered callback routines for
+ * a) the target time reached or exceeded interrupt notification
+ * b) the auxiliary time stamps availability interrupt notification
+ * c) the auxiliary target time reached or exceeded interrupt notification
+ * d) the pulser per second interrupt notification
+ */
+static IxTimeSyncAccTargetTimeCallback  ixTsTargetTimeCallback; /*(a)*/
+static IxTimeSyncAccAuxTimeCallback  ixTsAuxMasterTimeCallback; /*(b)*/
+static IxTimeSyncAccAuxTimeCallback   ixTsAuxSlaveTimeCallback; /*(b)*/
+static IxTimeSyncAccAuxTargetTimeCallback ixTsAuxTargetTimeCallback; /*(c)*/
+static IxTimeSyncAccPulsePerSecondCallback ixTsPulsePerSecondCallback; /*(d)*/
+
+/*
+ * The transmit and receive timestamp statistics
+ */
+static IxTimeSyncAccStats ixTsStats = { 0, 0 };
+
+/*
+ * Indicates whether hardware access library has been initialized
+ */
+static u32 ixInitialized;
+
+/*
+ * Hw channel to PTP port mapping
+ */
+static u32 ixPortToChnlMap[ICP_TIMESYNCACC_MAX_1588PTP_PORT];
+
+/* Function to determine the port mode */
+static IxTimeSyncAcc1588PTPPortMode
+ixTimeSyncAccPTPPortModeGet(IxTimeSyncAcc1588PTPPort ptpPort)
+{
+	/* Local variables */
+	u32 masterMode = false;
+	u32 allMsgMode = false;
+	IxTimeSyncAcc1588PTPPortMode ptpPortMode
+		= ICP_TIMESYNCACC_1588PTP_PORT_SLAVE;
+
+	/* Get the Mode of the PTP Port */
+	masterMode = ixTimeSyncAccControlPTPPortMasterModeGet(
+					ixPortToChnlMap[ptpPort]);
+	allMsgMode = ixTimeSyncAccControlPTPPortPTPMsgTimestampGet(
+					ixPortToChnlMap[ptpPort]);
+
+	/* Is ANY mode (all message timestamp mode) on? */
+	if (allMsgMode == false) {
+		/* Is Master mode on? */
+		if (masterMode == true)
+			ptpPortMode = ICP_TIMESYNCACC_1588PTP_PORT_MASTER;
+		else
+			ptpPortMode = ICP_TIMESYNCACC_1588PTP_PORT_SLAVE;
+	} else
+		/*
+		 * When Any mode is on (the ta bit is set) we do not care
+		 * for Master/Slave mode (the mm bit status) since all the
+		 * packets get time stamped anyways.
+		 */
+		ptpPortMode = ICP_TIMESYNCACC_1588PTP_PORT_ANYMODE;
+
+	return ptpPortMode;
+}
+
+/* Function for setting the base address registers */
+static IxTimeSyncAccStatus
+ixTimeSyncAccBlPlBaseAddressesSet(u32 RegsVirtualBaseAddr)
+{
+	/* Local variables */
+	u32 ptpChannelNum = 0;
+
+	if (!RegsVirtualBaseAddr)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Virtual Addresses assignment for Block Level Registers */
+	ixTsRegisters.blRegisters.tsControl   =
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_TSC_OFFSET;
+	ixTsRegisters.blRegisters.tsEvent	 =
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_TSE_OFFSET;
+	ixTsRegisters.blRegisters.tsAddend	=
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_ADD_OFFSET;
+	ixTsRegisters.blRegisters.tsAccum	 =
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_ACC_OFFSET;
+	ixTsRegisters.blRegisters.tsTest	 =
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_TST_OFFSET;
+	ixTsRegisters.blRegisters.tsSysTimeLo =
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_STL_OFFSET;
+	ixTsRegisters.blRegisters.tsSysTimeHi =
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_STH_OFFSET;
+	ixTsRegisters.blRegisters.tsTrgtLo	=
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_TTL_OFFSET;
+	ixTsRegisters.blRegisters.tsTrgtHi	=
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_TTH_OFFSET;
+	ixTsRegisters.blRegisters.tsASMSLo	=
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_ASSL_OFFSET;
+	ixTsRegisters.blRegisters.tsASMSHi	=
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_ASSH_OFFSET;
+	ixTsRegisters.blRegisters.tsAMMSLo	=
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_AMSL_OFFSET;
+	ixTsRegisters.blRegisters.tsAMMSHi	=
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_AMSH_OFFSET;
+	ixTsRegisters.blRegisters.tsPpsCompare	 =
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_PPS_OFFSET;
+	ixTsRegisters.blRegisters.tsATTSLo	=
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_ATTL_OFFSET;
+	ixTsRegisters.blRegisters.tsATTSHi	=
+		RegsVirtualBaseAddr + ICP_TIMESYNCACC_ATTH_OFFSET;
+
+	/* Virtual Addresses assignment for Ethernet Port Level Registers */
+	for (ptpChannelNum = 0;
+		 ptpChannelNum < ICP_TIMESYNCACC_MAX_1588ETH_CHNL;
+		 ptpChannelNum++) {
+		ixTsRegisters.plRegisters[ptpChannelNum].tsChControl =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_CC_OFFSET(ptpChannelNum);
+		ixTsRegisters.plRegisters[ptpChannelNum].tsChEvent =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_CE_OFFSET(ptpChannelNum);
+		ixTsRegisters.plRegisters[ptpChannelNum].tsTxSnapLo  =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_XSL_OFFSET(ptpChannelNum);
+		ixTsRegisters.plRegisters[ptpChannelNum].tsTxSnapHi =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_XSH_OFFSET(ptpChannelNum);
+		ixTsRegisters.plRegisters[ptpChannelNum].tsRxSnapLo =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_RSL_OFFSET(ptpChannelNum);
+		ixTsRegisters.plRegisters[ptpChannelNum].tsRxSnapHi =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_RSH_OFFSET(ptpChannelNum);
+		ixTsRegisters.plRegisters[ptpChannelNum].tsSrcUUIDLo =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_UID_OFFSET(ptpChannelNum);
+		ixTsRegisters.plRegisters[ptpChannelNum].tsSrcUUIDHi =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_SID_OFFSET(ptpChannelNum);
+	}
+
+	/* Virtual Addresses assignment for CAN Port Level Registers */
+	for (ptpChannelNum = 0;
+		 ptpChannelNum < ICP_TIMESYNCACC_MAX_1588CAN_CHNL;
+		 ptpChannelNum++) {
+		ixTsRegisters.plRegisters[ptpChannelNum].tsCANChEvent =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_CCE_OFFSET(ptpChannelNum);
+		ixTsRegisters.plRegisters[ptpChannelNum].tsCANTxSnapLo =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_CXSL_OFFSET(ptpChannelNum);
+		ixTsRegisters.plRegisters[ptpChannelNum].tsCANTxSnapHi =
+			RegsVirtualBaseAddr +
+			ICP_TIMESYNCACC_CXSH_OFFSET(ptpChannelNum);
+	}
+
+	/* PTP port to hardware channel mapping */
+	ixPortToChnlMap[ICP_TIMESYNCACC_GBE_0_1588PTP_PORT] =
+		ICP_TIMESYNCACC_GBE_0_1588PTP_CHNL;
+	ixPortToChnlMap[ICP_TIMESYNCACC_GBE_1_1588PTP_PORT] =
+		ICP_TIMESYNCACC_GBE_1_1588PTP_CHNL;
+	ixPortToChnlMap[ICP_TIMESYNCACC_CAN_0_1588PTP_PORT] =
+		ICP_TIMESYNCACC_CAN_0_1588PTP_CHNL;
+	ixPortToChnlMap[ICP_TIMESYNCACC_CAN_1_1588PTP_PORT] =
+		ICP_TIMESYNCACC_CAN_1_1588PTP_CHNL;
+
+	/*
+	 * Clear the snapshot availability condition for both master aux and
+	 * slave aux
+	 */
+	ixTimeSyncAccEventAmmsFlagClear();
+	ixTimeSyncAccEventAsmsFlagClear();
+
+	/* Init Callback Routines */
+	ixTsTargetTimeCallback =
+		(IxTimeSyncAccTargetTimeCallback) NULL;
+	ixTsAuxMasterTimeCallback =
+		(IxTimeSyncAccAuxTimeCallback) NULL;
+	ixTsAuxSlaveTimeCallback =
+		(IxTimeSyncAccAuxTimeCallback) NULL;
+	ixTsAuxTargetTimeCallback =
+		(IxTimeSyncAccAuxTargetTimeCallback) NULL;
+	ixTsPulsePerSecondCallback =
+		(IxTimeSyncAccPulsePerSecondCallback) NULL;
+
+	/* Clear Stats */
+	ixTsStats.rxMsgs = ixTsStats.txMsgs = 0;
+
+	/* module is initialized */
+	ixInitialized = 1;
+
+	return ICP_TIMESYNCACC_SUCCESS;
+}  /* end of ixTimeSyncAccBlPlBaseAddressesSet() function */
+
+/*
+ * Process TimeSync interrupt events
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccIsr(void)
+{
+	/* Local variables */
+	IxTimeSyncAccTimeValue targetTime = {0, 0};
+	IxTimeSyncAccTimeValue auxTime = {0, 0};
+	IxTimeSyncAccTimeValue auxTargetTime = {0, 0};
+	u32 pulsePerSecond = 0;
+
+	/*
+	 * Handle the Interrupts in the following order
+	 * 1 - Target Time Reached/Hit Condition
+	 * 2 - Auxiliary Master Timestamp
+	 * 3 - Auxiliary Slave Timestamp
+	 * 4 - Auxiliary Target Time Reached/Hit Condition
+	 * 5 - Pulse Per Second
+	 */
+
+	 /*
+	  * Also verify that valid callbacks are available for each of the
+	  * following since the client application may choose to use one or
+	  * more of the following in interrupt mode while others in
+	  * non-interrupt mode i.e., makes use of poll or get methods in which
+	  * case there is no valid callback registered.
+	  */
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Handle Target Time Reached or Exceeded Interrupt */
+	if ((ixTsTargetTimeCallback != NULL) &&
+		(ixTimeSyncAccEventTtmFlagGet() == true)) {
+		/* Disable interrupt */
+		ixTimeSyncAccControlTtmInterruptMaskClear();
+
+		/* Target Time registers contents  */
+		ixTimeSyncAccTargetTimeSnapshotGet(
+			&targetTime.timeValueLowWord,
+			&targetTime.timeValueHighWord);
+
+		/* Invoke client callback */
+		(*ixTsTargetTimeCallback)(targetTime);
+
+		/* Clear the target time reached condition (ttipend bit) */
+		ixTimeSyncAccEventTtmFlagClear();
+	}
+
+	/* Handle Auxiliary Master Mode Snapshot Interrupt */
+	if ((ixTsAuxMasterTimeCallback != NULL) &&
+		(ixTimeSyncAccEventAmmsFlagGet() == true)) {
+		/* Disable interrupt */
+		ixTimeSyncAccControlAmmsInterruptMaskClear();
+
+		/* Fetch Auxiliary Master Mode Snapshot */
+		ixTimeSyncAccAuxMasterModeSnapshotGet(
+			&auxTime.timeValueLowWord,
+			&auxTime.timeValueHighWord);
+
+		/* Return Auxiliary Master Mode Snapshot */
+		(*ixTsAuxMasterTimeCallback)(
+			ICP_TIMESYNCACC_AUXMODE_MASTER, auxTime);
+
+		/* Clear the snapshot availability condition */
+		ixTimeSyncAccEventAmmsFlagClear();
+	}
+
+	/* Handle Auxiliary Slave Mode Snapshot Interrupt */
+	if ((ixTsAuxSlaveTimeCallback != NULL) &&
+		(ixTimeSyncAccEventAsmsFlagGet() == true)) {
+		/* Disable interrupt */
+		ixTimeSyncAccControlAsmsInterruptMaskClear();
+
+		/* Fetch Auxiliary Slave Mode Snapshot */
+		ixTimeSyncAccAuxSlaveModeSnapshotGet(
+			&auxTime.timeValueLowWord,
+			&auxTime.timeValueHighWord);
+
+		/* Return Auxiliary Slave Mode Snapshot */
+		(*ixTsAuxSlaveTimeCallback)(
+			ICP_TIMESYNCACC_AUXMODE_SLAVE, auxTime);
+
+		/* Clear the snapshot availability condition */
+		ixTimeSyncAccEventAsmsFlagClear();
+	}
+
+	/* Handle Auxiliary Target Time Reached or Exceeded Interrupt */
+	if ((ixTsAuxTargetTimeCallback != NULL) &&
+		(ixTimeSyncAccEventAtmFlagGet() == true)) {
+		/* Disable interrupt */
+		ixTimeSyncAccControlAtmInterruptMaskClear();
+
+		/* Auxiliary Target Time registers contents  */
+		ixTimeSyncAccAuxTargetTimeSnapshotGet(
+			&auxTargetTime.timeValueLowWord,
+			&auxTargetTime.timeValueHighWord);
+
+		/* Invoke client callback */
+		(*ixTsAuxTargetTimeCallback)(auxTargetTime);
+
+		/*Clear the auxiliary target time reached condition (atp bit)*/
+		ixTimeSyncAccEventAtmFlagClear();
+	}
+
+	/* Handle Pulse Per Second Interrupt */
+	if ((ixTsPulsePerSecondCallback != NULL) &&
+		(ixTimeSyncAccEventPpsmFlagGet() == true)) {
+		/* Disable interrupt */
+		ixTimeSyncAccControlPpsmInterruptMaskClear();
+
+		/* Pulse per Second registers contents */
+		ixTimeSyncAccPulsePerSecondCompareGet(&pulsePerSecond);
+
+		/* Invoke client callback */
+		(*ixTsPulsePerSecondCallback)(pulsePerSecond);
+
+		/* Clear the pulse per second (ppsm bit) */
+		ixTimeSyncAccEventPpsmFlagClear();
+	}
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccIsr() function */
+
+/*
+ * Configure IEEE 1588 Hardware Assist message detection
+ * on a particular PTP port
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPPortConfigSet(
+	IxTimeSyncAcc1588PTPPort ptpPort,
+	IxTimeSyncAcc1588PTPPortMode ptpPortMode)
+{
+	/* Verify the parameters for proper values */
+	if (((ptpPort != ICP_TIMESYNCACC_GBE_0_1588PTP_PORT) &&
+		 (ptpPort != ICP_TIMESYNCACC_GBE_1_1588PTP_PORT)) ||
+		 (ptpPortMode >= ICP_TIMESYNCACC_1588PTP_PORT_MODE_INVALID) ||
+		 (ptpPortMode < 0))
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Set the Mode of the PTP Port */
+	switch (ptpPortMode) {
+	case ICP_TIMESYNCACC_1588PTP_PORT_MASTER:
+		ixTimeSyncAccControlPTPPortMasterModeSet(
+			ixPortToChnlMap[ptpPort], true);
+		ixTimeSyncAccControlPTPPortPTPMsgTimestampSet(
+			ixPortToChnlMap[ptpPort], false);
+		break;
+	case ICP_TIMESYNCACC_1588PTP_PORT_SLAVE:
+		ixTimeSyncAccControlPTPPortMasterModeSet(
+			ixPortToChnlMap[ptpPort], false);
+		ixTimeSyncAccControlPTPPortPTPMsgTimestampSet(
+			ixPortToChnlMap[ptpPort], false);
+		break;
+	case ICP_TIMESYNCACC_1588PTP_PORT_ANYMODE:
+		ixTimeSyncAccControlPTPPortMasterModeSet(
+			ixPortToChnlMap[ptpPort], false);
+		ixTimeSyncAccControlPTPPortPTPMsgTimestampSet(
+			ixPortToChnlMap[ptpPort], true);
+		break;
+	default:
+		/* This part of the code should not be reached */
+		printk(KERN_INFO "ixTimeSyncAccPTPPortConfigSet(): "
+			"Invalid Port Mode\n");
+		return ICP_TIMESYNCACC_FAILED;
+	}
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccPTPPortConfigSet() function */
+
+/*
+ * Retrieve IEEE 1588 Hardware Assist PTP operation mode
+ * on particular PTP port
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPPortConfigGet(
+	IxTimeSyncAcc1588PTPPort ptpPort,
+	IxTimeSyncAcc1588PTPPortMode *ptpPortMode)
+{
+	/* Verify the parameters for proper values */
+	if (((ptpPort != ICP_TIMESYNCACC_GBE_0_1588PTP_PORT) &&
+		 (ptpPort != ICP_TIMESYNCACC_GBE_1_1588PTP_PORT)) ||
+		((IxTimeSyncAcc1588PTPPortMode *)NULL == ptpPortMode))
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Get the Mode of the PTP Port */
+	*ptpPortMode = ixTimeSyncAccPTPPortModeGet(ptpPort);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccPTPPortConfigGet() function */
+
+/*
+ * Poll the IEEE 1588 Hardware Assist message/time stamp detect status
+ * on a particular PTP Port on the Receive side
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPRxPoll(
+	IxTimeSyncAcc1588PTPPort ptpPort,
+	IxTimeSyncAccPtpMsgData  *ptpMsgData)
+{
+	/* Local variables */
+	u32 rxsFlag = false;
+	IxTimeSyncAcc1588PTPPortMode ptpPortMode =
+		ICP_TIMESYNCACC_1588PTP_PORT_SLAVE;
+
+	/* Verify the parameters for proper values */
+	if (((ptpPort != ICP_TIMESYNCACC_GBE_0_1588PTP_PORT) &&
+		(ptpPort != ICP_TIMESYNCACC_GBE_1_1588PTP_PORT)) ||
+		(ptpMsgData == (IxTimeSyncAccPtpMsgData *)NULL))
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Get the Mode of the PTP Port */
+	ptpPortMode = ixTimeSyncAccPTPPortModeGet(ptpPort);
+
+	/* If the Port Mode is ANY mode OR the receive timestamp available */
+	rxsFlag = ixTimeSyncAccControlPTPPortRxsFlagGet(
+		ixPortToChnlMap[ptpPort]);
+
+	if ((ICP_TIMESYNCACC_1588PTP_PORT_ANYMODE != ptpPortMode) &&
+		(rxsFlag != true))
+		return ICP_TIMESYNCACC_NOTIMESTAMP;
+
+	/* Fetch the receive timestamp */
+	ixTimeSyncAccPTPPortReceiveSnapshotGet(ixPortToChnlMap[ptpPort],
+		&ptpMsgData->ptpTimeStamp.timeValueLowWord,
+		&ptpMsgData->ptpTimeStamp.timeValueHighWord);
+
+	/* Fetch the UUID & Seq# of PTP messages in 'Master/Slave Mode' only */
+	if (rxsFlag == true)
+		ixTimeSyncAccPTPMsgUuidSeqIdGet(ixPortToChnlMap[ptpPort],
+			&ptpMsgData->ptpUuid.uuidValueLowWord,
+			&ptpMsgData->ptpUuid.uuidValueHighHalfword,
+			&ptpMsgData->ptpSequenceNumber);
+	/* Clear-off the UUID & Seq# of all the messages in 'Any Mode' */
+	else {
+		ptpMsgData->ptpUuid.uuidValueLowWord = 0;
+		ptpMsgData->ptpUuid.uuidValueHighHalfword = 0;
+		ptpMsgData->ptpSequenceNumber = 0;
+	}
+
+	/* Fill-in the PTP message type */
+	switch (ptpPortMode) {
+	case ICP_TIMESYNCACC_1588PTP_PORT_MASTER:
+		ptpMsgData->ptpMsgType =
+			ICP_TIMESYNCACC_1588PTP_MSGTYPE_DELAYREQ;
+		break;
+	case ICP_TIMESYNCACC_1588PTP_PORT_SLAVE:
+		ptpMsgData->ptpMsgType =
+			ICP_TIMESYNCACC_1588PTP_MSGTYPE_SYNC;
+		break;
+	case ICP_TIMESYNCACC_1588PTP_PORT_ANYMODE:
+		ptpMsgData->ptpMsgType =
+			ICP_TIMESYNCACC_1588PTP_MSGTYPE_UNKNOWN;
+		break;
+	default:
+		printk(KERN_INFO "ixTimeSyncAccPTPRxPoll(): "
+			"Invalid Port Mode\n");
+		return ICP_TIMESYNCACC_FAILED;
+	}
+
+	/* Increment receive timestamp counter */
+	ixTsStats.rxMsgs++;
+
+	/* Allow next timestamp to be captured */
+	ixTimeSyncAccControlPTPPortRxsFlagClear(ixPortToChnlMap[ptpPort]);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccPTPRxPoll() function */
+
+/*
+ * Poll for the IEEE 1588 Hardware Assist message/time stamp detect status
+ * on a particular PTP Port on the Transmit side.
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPTxPoll(
+	IxTimeSyncAcc1588PTPPort ptpPort,
+	IxTimeSyncAccPtpMsgData  *ptpMsgData)
+{
+	/* Local variables */
+	u32 txsFlag = false;
+	IxTimeSyncAcc1588PTPPortMode ptpPortMode =
+		ICP_TIMESYNCACC_1588PTP_PORT_SLAVE;
+
+	/* Verify the parameters for proper values */
+	if (((ptpPort != ICP_TIMESYNCACC_GBE_0_1588PTP_PORT) &&
+		(ptpPort != ICP_TIMESYNCACC_GBE_1_1588PTP_PORT)) ||
+		(ptpMsgData == (IxTimeSyncAccPtpMsgData *)NULL))
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Get the Mode of the PTP Port */
+	ptpPortMode = ixTimeSyncAccPTPPortModeGet(ptpPort);
+
+	/* If the Port Mode is ANY mode OR the transmit timestamp available? */
+	txsFlag = ixTimeSyncAccControlPTPPortTxsFlagGet(
+			ixPortToChnlMap[ptpPort]);
+
+	if ((ptpPortMode == ICP_TIMESYNCACC_1588PTP_PORT_ANYMODE) ||
+	   (txsFlag == true)) {
+		/* Fetch the transmit timestamp */
+		ixTimeSyncAccPTPPortTransmitSnapshotGet(
+			ixPortToChnlMap[ptpPort],
+			&ptpMsgData->ptpTimeStamp.timeValueLowWord,
+			&ptpMsgData->ptpTimeStamp.timeValueHighWord);
+
+		/*
+		 * Fill the UUID and Seq# with invalid values (zeros)
+		 * since they are not relevant for transmit timestamp
+		 */
+		ptpMsgData->ptpUuid.uuidValueLowWord = 0;
+		ptpMsgData->ptpUuid.uuidValueHighHalfword = 0;
+		ptpMsgData->ptpSequenceNumber = 0;
+	} else
+		return ICP_TIMESYNCACC_NOTIMESTAMP;
+
+	/* Fill-in the PTP message type */
+	switch (ptpPortMode) {
+	case ICP_TIMESYNCACC_1588PTP_PORT_MASTER:
+		ptpMsgData->ptpMsgType =
+			ICP_TIMESYNCACC_1588PTP_MSGTYPE_SYNC;
+		break;
+	case ICP_TIMESYNCACC_1588PTP_PORT_SLAVE:
+		ptpMsgData->ptpMsgType =
+			ICP_TIMESYNCACC_1588PTP_MSGTYPE_DELAYREQ;
+		break;
+	case ICP_TIMESYNCACC_1588PTP_PORT_ANYMODE:
+		ptpMsgData->ptpMsgType =
+			ICP_TIMESYNCACC_1588PTP_MSGTYPE_UNKNOWN;
+		break;
+	default:
+		printk(KERN_INFO "ixTimeSyncAccPTPTxPoll(): "
+			"Invalid Port Mode\n");
+		return ICP_TIMESYNCACC_FAILED;
+	}
+
+	/* Increment transmit timestamp counter */
+	ixTsStats.txMsgs++;
+
+	/* Allow next timestamp to be captured */
+	ixTimeSyncAccControlPTPPortTxsFlagClear(ixPortToChnlMap[ptpPort]);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccPTPTxPoll() function */
+
+/* Set the System Time in the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccSystemTimeSet(IxTimeSyncAccTimeValue systemTime)
+{
+	/* Local variables */
+	u32 oldFsv = 0;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Retrieve old Frequency Scaling Value */
+	ixTimeSyncAccAddendFsvGet(&oldFsv);
+
+	/*
+	 * Set the Frequency Scaling Value to zero (0) so that
+	 * System Time doesn't get incremented while it is being
+	 * written into low and high registers
+	 */
+	ixTimeSyncAccAddendFsvSet(0);
+
+	/* Update System Time with user specified values */
+	ixTimeSyncAccSystemTimeSnapshotSet(systemTime.timeValueLowWord,
+				   systemTime.timeValueHighWord);
+
+	/*
+	 * Let the hardware assist re-evaluate the target time reached
+	 * condition based on the new system time
+	 */
+	ixTimeSyncAccEventTtmFlagClear();
+
+	/*
+	 * Let the hardware assist re-evaluate the aux target time reached
+	 * condition based on the new system time
+	 */
+	ixTimeSyncAccEventAtmFlagClear();
+
+	/*
+	 * Restore old Frequency Scaling Value so that System Time
+	 * can be incremented
+	 */
+	ixTimeSyncAccAddendFsvSet(oldFsv);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccSystemTimeSet() function */
+
+/* Get the System Time from the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccSystemTimeGet(IxTimeSyncAccTimeValue *systemTime)
+{
+	/* Verify the parameter */
+	if (systemTime == (IxTimeSyncAccTimeValue *)NULL)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Fetch System Time */
+	ixTimeSyncAccSystemTimeSnapshotGet(&systemTime->timeValueLowWord,
+				   &systemTime->timeValueHighWord);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccSystemTimeGet() function */
+
+/*
+ * Set the Tick Rate (Frequency Scaling Value) in the IEEE 1588
+ * hardware assist block
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTickRateSet(u32 tickRate)
+{
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Update the Frequency Scaling Value */
+	ixTimeSyncAccAddendFsvSet(tickRate);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccTickRateSet() function */
+
+/*
+ * Get the Tick Rate (Frequency Scaling Value) from the IEEE 1588
+ * hardware assist block
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTickRateGet(u32 *tickRate)
+{
+	/* Verify the parameter */
+	if (tickRate == (u32 *)NULL)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Retrieve Current Frequency Scaling Value */
+	ixTimeSyncAccAddendFsvGet(tickRate);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccTickRateGet() function */
+
+/*
+ * Enable the interrupt to verify the condition where the System Time is
+ * greater or equal to the Target Time in the IEEE 1588 hardware assist
+ * block.
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimeInterruptEnable(
+	IxTimeSyncAccTargetTimeCallback targetTimeCallback)
+{
+	/* Verify the parameter */
+	if (targetTimeCallback == (IxTimeSyncAccTargetTimeCallback)NULL)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Register the Callback */
+	ixTsTargetTimeCallback = targetTimeCallback;
+
+	/* Set target time interrupt mask */
+	ixTimeSyncAccControlTtmInterruptMaskSet();
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccTargetTimeInterruptEnable() function */
+
+/*
+ * Disable the interrupt to verify the condition that the System Time is
+ * greater or equal to the Target Time in the IEEE 1588 hardware assist
+ * block.
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimeInterruptDisable(void)
+{
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Clear target time interrupt mask */
+	ixTimeSyncAccControlTtmInterruptMaskClear();
+
+	/* Unregister the Callback */
+	ixTsTargetTimeCallback = (IxTimeSyncAccTargetTimeCallback) NULL;
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccTargetTimeInterruptDisable() function */
+
+/*
+ * Poll to verify the condition where the System Time is greater or equal
+ * to the Target Time in the IEEE 1588 hardware assist block.
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimePoll(
+	u32 *ttmPollFlag,
+	IxTimeSyncAccTimeValue *targetTime)
+{
+	/* Verify the parameters */
+	if (ttmPollFlag == ((u32 *)NULL) ||
+		targetTime == ((IxTimeSyncAccTimeValue *)NULL))
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Is interrupt mode of processing is enabled? */
+	if (ixTsTargetTimeCallback != (IxTimeSyncAccTargetTimeCallback)NULL)
+		return ICP_TIMESYNCACC_INTERRUPTMODEINUSE;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Is the System Time reached or exceeded Target Time? */
+	*ttmPollFlag = ixTimeSyncAccEventTtmFlagGet();
+	if (ttmPollFlag == false) {
+		/* Target Time not to be returned yet */
+		targetTime->timeValueLowWord = 0;
+		targetTime->timeValueHighWord = 0;
+
+		return ICP_TIMESYNCACC_SUCCESS;
+	}
+
+	/* Fetch Target Time */
+	ixTimeSyncAccTargetTimeSnapshotGet(&targetTime->timeValueLowWord,
+				  &targetTime->timeValueHighWord);
+
+	/* Clear the target time reached condition (ttipend bit) */
+	ixTimeSyncAccEventTtmFlagClear();
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccTargetTimePoll() function */
+
+/* Set the Target Time in the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimeSet(IxTimeSyncAccTimeValue targetTime)
+{
+	/* Local variables */
+	u32 oldTtmMask = false;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Retrieve existing target time interrupt mask value */
+	oldTtmMask = ixTimeSyncAccControlTtmInterruptMaskGet();
+
+	/* Clear the target time interrupt mask value to prevent false
+	 * interrupts from being asserted due to the increments of the
+	 * values in the System Time low and high registers (i.e., the
+	 * target time reached or exceeded interrupt does not get
+	 * generated
+	 */
+	ixTimeSyncAccControlTtmInterruptMaskClear();
+
+	/* Update Target Time with user specified values */
+	ixTimeSyncAccTargetTimeSnapshotSet(targetTime.timeValueLowWord,
+				   targetTime.timeValueHighWord);
+
+	/*
+	 * Let the hardware assist re-evaluate the target time reached
+	 * condition based on the new target time
+	 */
+	ixTimeSyncAccEventTtmFlagClear();
+
+	/* Restore the preserved target time interrupt mask value */
+	if (oldTtmMask == true)
+		ixTimeSyncAccControlTtmInterruptMaskSet();
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccTargetTimeSet() function */
+
+/* Get the Target Time in the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimeGet(IxTimeSyncAccTimeValue *targetTime)
+{
+	/* Verify the parameter */
+	if ((IxTimeSyncAccTimeValue *)NULL == targetTime)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Fetch Target Time */
+	ixTimeSyncAccTargetTimeSnapshotGet(&targetTime->timeValueLowWord,
+				   &targetTime->timeValueHighWord);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccTargetTimeGet() function */
+
+/*
+ * Enable the interrupt to verify the condition where the System Time is
+ * greater or equal to the Auxiliary Target Time in the IEEE 1588 hardware
+ * assist block.
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimeInterruptEnable(
+	IxTimeSyncAccAuxTargetTimeCallback auxTargetTimeCallback)
+{
+	/* Verify the parameter */
+	if (auxTargetTimeCallback ==
+		(IxTimeSyncAccAuxTargetTimeCallback)NULL)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Register the Callback */
+	ixTsAuxTargetTimeCallback = auxTargetTimeCallback;
+
+	/* Set auxiliary target time interrupt mask */
+	ixTimeSyncAccControlAtmInterruptMaskSet();
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccAuxTargetTimeInterruptEnable() function */
+
+/*
+ * Disable the interrupt to verify the condition that the System Time is
+ * greater or equal to the Auxiliary Target Time in the IEEE 1588 hardware
+ *  assist block.
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimeInterruptDisable(void)
+{
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Clear auxiliary target time interrupt mask */
+	ixTimeSyncAccControlAtmInterruptMaskClear();
+
+	/* Unregister the Callback */
+	ixTsAuxTargetTimeCallback = (IxTimeSyncAccAuxTargetTimeCallback) NULL;
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccAuxTargetTimeInterruptDisable() function */
+
+/*
+ * Poll to verify the condition where the System Time greater or equal
+ * to the Auxiliary Target Time in the IEEE 1588 hardware assist block.
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimePoll(
+	u32 *atmPollFlag,
+	IxTimeSyncAccTimeValue *auxTargetTime)
+{
+	/* Verify the parameters */
+	if (atmPollFlag == ((u32 *)NULL) ||
+		(auxTargetTime == (IxTimeSyncAccTimeValue *)NULL))
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Is interrupt mode of processing is enabled? */
+	if (ixTsAuxTargetTimeCallback !=
+		(IxTimeSyncAccAuxTargetTimeCallback)NULL)
+		return ICP_TIMESYNCACC_INTERRUPTMODEINUSE;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Is the System Time reached or exceeded Auxiliary Target Time? */
+	*atmPollFlag = ixTimeSyncAccEventAtmFlagGet();
+	if (atmPollFlag == false) {
+		/* Auxiliary Target Time not to be returned yet */
+		auxTargetTime->timeValueLowWord = 0;
+		auxTargetTime->timeValueHighWord = 0;
+
+		return ICP_TIMESYNCACC_SUCCESS;
+	}
+
+	/* Fetch Auxiliary Target Time */
+	ixTimeSyncAccAuxTargetTimeSnapshotGet(&auxTargetTime->timeValueLowWord,
+					&auxTargetTime->timeValueHighWord);
+
+	/* Clear the auxiliary target time reached condition (atp bit) */
+	ixTimeSyncAccEventAtmFlagClear();
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccAuxTargetTimePoll() function */
+
+/* Set the Auxiliary Target Time in the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimeSet(IxTimeSyncAccTimeValue auxTargetTime)
+{
+	/* Local variables */
+	u32 oldAtmMask = false;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Retrieve existing auxiliary target time interrupt mask value */
+	oldAtmMask = ixTimeSyncAccControlAtmInterruptMaskGet();
+
+	/* Clear the auxiliary target time interrupt mask value to
+	 * prevent false interrupts from being asserted due to the
+	 * increments of the values in the System Time low and high
+	 * registers (i.e., the auxiliary target time reached or exceeded
+	 * interrupt does not get generated
+	 */
+	ixTimeSyncAccControlAtmInterruptMaskClear();
+
+	/* Update Auxiliary Target Time with user specified values */
+	ixTimeSyncAccAuxTargetTimeSnapshotSet(auxTargetTime.timeValueLowWord,
+					   auxTargetTime.timeValueHighWord);
+
+	/*
+	 * Let the hardware assist to re-evaluate the auxiliary target time
+	 * reached condition based on the new auxiliary target time
+	 */
+	ixTimeSyncAccEventAtmFlagClear();
+
+	/* Restore the preserved auxiliary target time interrupt mask value */
+	if (oldAtmMask == true)
+		ixTimeSyncAccControlAtmInterruptMaskSet();
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccAuxTargetTimeSet() function */
+
+/* Get the Auxiliary Target Time in the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimeGet(IxTimeSyncAccTimeValue *auxTargetTime)
+{
+	/* Verify the parameter */
+	if (auxTargetTime == (IxTimeSyncAccTimeValue *)NULL)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Fetch Auxiliary Target Time */
+	ixTimeSyncAccAuxTargetTimeSnapshotGet(&auxTargetTime->timeValueLowWord,
+				   &auxTargetTime->timeValueHighWord);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccAuxTargetTimeGet() function */
+
+/*
+ * Enable the interrupt notification for the given mode of Auxiliary Time
+ * Stamp in the IEEE 1588 hardware assist block
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTimeInterruptEnable(
+	IxTimeSyncAccAuxMode auxMode,
+	IxTimeSyncAccAuxTimeCallback auxTimeCallback)
+{
+	/* Verify the parameters */
+	if ((auxMode >= ICP_TIMESYNCACC_AUXMODE_INVALID) ||
+		(auxTimeCallback == (IxTimeSyncAccAuxTimeCallback)NULL))
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Register the Callback and SET the amm/asm bits on */
+	if (auxMode == ICP_TIMESYNCACC_AUXMODE_MASTER) {
+		ixTsAuxMasterTimeCallback = auxTimeCallback;
+		ixTimeSyncAccControlAmmsInterruptMaskSet();
+	} else {
+		ixTsAuxSlaveTimeCallback = auxTimeCallback;
+		ixTimeSyncAccControlAsmsInterruptMaskSet();
+	}
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccAuxTimeInterruptEnable() function */
+
+/*
+ * Disable the interrupt for the indicated mode of Auxiliary Time Stamp
+ * in the IEEE 1588 hardware assist block
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTimeInterruptDisable(IxTimeSyncAccAuxMode auxMode)
+{
+	/* Verify the parameters */
+	if (ICP_TIMESYNCACC_AUXMODE_INVALID <= auxMode)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Unregister the Callback and CLEAR the amm/asm bits on */
+	if (ICP_TIMESYNCACC_AUXMODE_MASTER == auxMode) {
+		ixTimeSyncAccControlAmmsInterruptMaskClear();
+		ixTsAuxMasterTimeCallback =
+			(IxTimeSyncAccAuxTimeCallback) NULL;
+	} else {
+		ixTimeSyncAccControlAsmsInterruptMaskClear();
+		ixTsAuxSlaveTimeCallback = (IxTimeSyncAccAuxTimeCallback) NULL;
+	}
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccAuxTimeInterruptDisable() function */
+
+/*
+ * Poll for the Auxiliary Time Stamp captured for the mode indicated
+ * (Master or Slave)
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTimePoll(IxTimeSyncAccAuxMode auxMode,
+	u32 *auxPollFlag,
+	IxTimeSyncAccTimeValue *auxTime)
+{
+	/* Local variables */
+	u32 ammsFlag = false;
+	u32 asmsFlag = false;
+
+	/* Verify the parameters */
+	if (((u32 *)NULL == auxPollFlag) ||
+		(ICP_TIMESYNCACC_AUXMODE_INVALID <= auxMode) ||
+		((IxTimeSyncAccTimeValue *)NULL == auxTime)) {
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+	}
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Fetch Auxiliary Master/Slave Mode Snapshot */
+	if (ICP_TIMESYNCACC_AUXMODE_MASTER == auxMode) {
+		/* Is interrupt mode of processing is enabled? */
+		if ((IxTimeSyncAccAuxTimeCallback) NULL !=
+			ixTsAuxMasterTimeCallback)
+			return ICP_TIMESYNCACC_INTERRUPTMODEINUSE;
+
+		/* Is the Auxiliary Master Mode Snapshot available? */
+		ammsFlag = ixTimeSyncAccEventAmmsFlagGet();
+		if (ammsFlag == false) {
+			*auxPollFlag = false;
+			auxTime->timeValueLowWord = 0;
+			auxTime->timeValueHighWord = 0;
+			return ICP_TIMESYNCACC_SUCCESS;
+		}
+
+		/* Fetch Auxiliary Master Snapshot */
+		ixTimeSyncAccAuxMasterModeSnapshotGet(
+			&auxTime->timeValueLowWord,
+			 &auxTime->timeValueHighWord);
+		*auxPollFlag = true;
+
+		/* Clear the snapshot availability condition */
+		ixTimeSyncAccEventAmmsFlagClear();
+	} else {
+		/* Is interrupt mode of processing is enabled? */
+		if ((IxTimeSyncAccAuxTimeCallback) NULL !=
+			ixTsAuxSlaveTimeCallback)
+			return ICP_TIMESYNCACC_INTERRUPTMODEINUSE;
+
+		/* Is the Auxiliary Slave Mode Snapshot available? */
+		asmsFlag = ixTimeSyncAccEventAsmsFlagGet();
+		if (asmsFlag == false) {
+			*auxPollFlag = false;
+			auxTime->timeValueLowWord = 0;
+			auxTime->timeValueHighWord = 0;
+			return ICP_TIMESYNCACC_SUCCESS;
+		}
+
+		/* Fetch Auxiliary Slave Snapshot */
+		ixTimeSyncAccAuxSlaveModeSnapshotGet(
+			&auxTime->timeValueLowWord,
+			&auxTime->timeValueHighWord);
+		*auxPollFlag = true;
+
+		/* Clear the snapshot availability condition */
+		ixTimeSyncAccEventAsmsFlagClear();
+	}
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccAuxTimePoll() function */
+
+/*
+ * Poll the IEEE 1588 Hardware Assist message/time stamp detect status on a
+ * particular PTP CAN Port
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPCANPoll(
+	IxTimeSyncAcc1588PTPPort ptpPort,
+	IxTimeSyncAccTimeValue *ptpTimeStamp)
+{
+	/* Local variables */
+	u32 valFlag = false;
+	u32 ovrFlag = false;
+
+	/* Verify the parameters for proper values */
+	if (((ptpPort != ICP_TIMESYNCACC_CAN_0_1588PTP_PORT) &&
+		 (ptpPort != ICP_TIMESYNCACC_CAN_1_1588PTP_PORT)) ||
+		((IxTimeSyncAccTimeValue *)NULL == ptpTimeStamp))
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Is a new timestamp available? */
+	valFlag = ixTimeSyncAccControlPTPPortValFlagGet(
+			ixPortToChnlMap[ptpPort]);
+
+	/* there is not a valid timestamp */
+	if (valFlag != true)
+		return ICP_TIMESYNCACC_NOTIMESTAMP;
+
+	/* check overrun bit before retreiving timestamp */
+	ovrFlag = ixTimeSyncAccControlPTPPortOvrFlagGet(
+			ixPortToChnlMap[ptpPort]);
+
+	/* if the timestamp has been overwritten */
+	if (ovrFlag == true) {
+		/* reset valid and overrun bits */
+		ixTimeSyncAccControlPTPPortValFlagClear(
+			ixPortToChnlMap[ptpPort]);
+		ixTimeSyncAccControlPTPPortOvrFlagClear(
+			ixPortToChnlMap[ptpPort]);
+
+		/* return no valid timestamp available */
+		ptpTimeStamp->timeValueLowWord = 0;
+		ptpTimeStamp->timeValueHighWord = 0;
+
+		return ICP_TIMESYNCACC_NOTIMESTAMP;
+	}
+
+	/* Fetch the receive timestamp */
+	ixTimeSyncAccPTPPortCANSnapshotGet(ixPortToChnlMap[ptpPort],
+		&ptpTimeStamp->timeValueLowWord,
+		&ptpTimeStamp->timeValueHighWord);
+
+	/* check overrun bit again to ensure timestamp is valid */
+	ovrFlag = ixTimeSyncAccControlPTPPortOvrFlagGet(
+			ixPortToChnlMap[ptpPort]);
+
+	/* if the timestamp has been overwritten */
+	if (ovrFlag == true) {
+		/* reset valid and overrun bits */
+		ixTimeSyncAccControlPTPPortValFlagClear(
+			ixPortToChnlMap[ptpPort]);
+		ixTimeSyncAccControlPTPPortOvrFlagClear(
+			ixPortToChnlMap[ptpPort]);
+
+		/* return no valid timestamp available */
+		ptpTimeStamp->timeValueLowWord = 0;
+		ptpTimeStamp->timeValueHighWord = 0;
+
+		return ICP_TIMESYNCACC_NOTIMESTAMP;
+	}
+
+	/* reset valid bit */
+	ixTimeSyncAccControlPTPPortValFlagClear(ixPortToChnlMap[ptpPort]);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccPTPCANPoll() function */
+
+/*
+ * Enable the interrupt to verify the condition where the System Time is
+ * greater or equal to the Pulse Per Second in the IEEE 1588 hardware assist
+ * block.
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPulsePerSecondInterruptEnable(
+	IxTimeSyncAccPulsePerSecondCallback pulsePerSecondCallback)
+{
+	/* Verify the parameter */
+	if ((IxTimeSyncAccPulsePerSecondCallback)NULL ==
+		pulsePerSecondCallback)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Register the Callback */
+	ixTsPulsePerSecondCallback = pulsePerSecondCallback;
+
+	/* Set pulse per second interrupt mask */
+	ixTimeSyncAccControlPpsmInterruptMaskSet();
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccPulsePerSecondInterruptEnable() function */
+
+/*
+ * Disable the interrupt to verify the condition that the System Time is
+ * greater or equal to the Pulse Per Second  in the IEEE 1588 hardware assist
+ * block.
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPulsePerSecondInterruptDisable(void)
+{
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Clear pulse per second interrupt mask */
+	ixTimeSyncAccControlPpsmInterruptMaskClear();
+
+	/* Unregister the Callback */
+	ixTsPulsePerSecondCallback =
+		(IxTimeSyncAccPulsePerSecondCallback) NULL;
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccPulsePerSecondInterruptDisable() function */
+
+/* Set the pulse per second Time in the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPulsePerSecondTimeSet(u32 ppsTime)
+{
+	/* Local variables */
+	u32 oldPpsMask = false;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Retrieve existing pulse per second time interrupt mask value */
+	oldPpsMask = ixTimeSyncAccControlPpsmInterruptMaskGet();
+
+	/* Clear the pulse per second time interrupt mask value to
+	 * prevent false interrupts from being asserted due to the
+	 * increments of the values in the System Time low and high
+	 * registers (i.e., the pulse per second time reached or
+	 * exceeded interrupt does not get generated
+	 */
+	ixTimeSyncAccControlPpsmInterruptMaskClear();
+
+	/* Update pulse per second Time with user specified values */
+	ixTimeSyncAccPulsePerSecondCompareSet(ppsTime);
+
+	/*
+	 * Let the hardware assist re-evaluate the pulse per second time
+	 * reached condition based on the new pulse per second time
+	 */
+	ixTimeSyncAccEventPpsmFlagClear();
+
+	/* Restore the preserved pulse per second time interrupt mask value */
+	if (oldPpsMask == true)
+		ixTimeSyncAccControlPpsmInterruptMaskSet();
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccPulsePerSecondTimeSet() function */
+
+/* Get the pulse per second Time in the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPulsePerSecondTimeGet(u32 *ppsTime)
+{
+	/* Verify the parameter */
+	if ((u32 *)NULL == ppsTime)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Fetch pulse per second Time */
+	ixTimeSyncAccPulsePerSecondCompareGet(ppsTime);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccPulsePerSecondTimeGet() function */
+
+/* Reset the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccReset(void)
+{
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Reset Hardware Assist */
+	ixTimeSyncAccControlReset();
+
+	/* Clear Stats */
+	ixTsStats.rxMsgs = ixTsStats.txMsgs = 0;
+
+	/* Unregister any Callback Routines */
+	ixTsTargetTimeCallback = (IxTimeSyncAccTargetTimeCallback) NULL;
+	ixTsAuxMasterTimeCallback = (IxTimeSyncAccAuxTimeCallback) NULL;
+	ixTsAuxSlaveTimeCallback = (IxTimeSyncAccAuxTimeCallback) NULL;
+	ixTsAuxTargetTimeCallback =
+		(IxTimeSyncAccAuxTargetTimeCallback) NULL;
+	ixTsPulsePerSecondCallback =
+		(IxTimeSyncAccPulsePerSecondCallback) NULL;
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccReset() function */
+
+/* Reset a channel in the IEEE 1588 hardware assist block */
+static IxTimeSyncAccStatus
+ixTimeSyncAccChnlReset(IxTimeSyncAcc1588PTPPort ptpPort)
+{
+	/* Initialised before */
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Verify the parameters for proper values */
+	if ((ptpPort != ICP_TIMESYNCACC_GBE_0_1588PTP_PORT) &&
+		(ptpPort != ICP_TIMESYNCACC_GBE_1_1588PTP_PORT))
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Reset Hardware Assist */
+	ixTimeSyncAccChannelReset(ixPortToChnlMap[ptpPort]);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccChnlReset() function */
+
+/* Return the IxTimeSyncAcc Statistics */
+static IxTimeSyncAccStatus
+ixTimeSyncAccStatsGet(IxTimeSyncAccStats *timeSyncStats)
+{
+	/* Verify the parameter */
+	if ((IxTimeSyncAccStats *) NULL == timeSyncStats)
+		return ICP_TIMESYNCACC_INVALIDPARAM;
+
+	/* Return Stats */
+	timeSyncStats->rxMsgs = ixTsStats.rxMsgs;
+	timeSyncStats->txMsgs = ixTsStats.txMsgs;
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of IxTimeSyncAccStatsGet() function */
+
+/* Reset Time Sync statistics */
+void
+ixTimeSyncAccStatsReset(void)
+{
+	/* Clear Stats */
+	ixTsStats.rxMsgs = ixTsStats.txMsgs = 0;
+
+	return;
+} /* end of ixTimeSyncAccStatsReset() function */
+
+/* Display the Time Sync current status */
+static IxTimeSyncAccStatus
+ixTimeSyncAccShow(void)
+{
+	/* Local Varaiables */
+	u32 regValue = 0;
+	u32 regLowValue = 0;
+	u32 regHighValue = 0;
+	u16 seqId = 0;
+	u32 uuIdLow = 0;
+	u16 uuIdHigh = 0;
+	u32   bitSet   = false;
+	u32 ptpPortNum = 0;
+
+	if (!ixInitialized)
+		return ICP_TIMESYNCACC_UNINITIALIZED;
+
+	/* Dump Block Level Status */
+
+	/* System Time registers contents */
+	regLowValue = 0;
+	regHighValue = 0;
+	ixTimeSyncAccSystemTimeSnapshotGet(&regLowValue, &regHighValue);
+	printk(KERN_INFO "System Test (Low:High): %x : %x\n",
+		regLowValue, regHighValue);
+
+	/* Frequency Scaling Value */
+	regValue = 0;
+	ixTimeSyncAccAddendFsvGet(&regValue);
+	printk(KERN_INFO "Frequency Scaling Value: %x\n", regValue);
+
+	/* Target time reached/exceeded interrupt mask value */
+	bitSet = ixTimeSyncAccControlTtmInterruptMaskGet();
+	printk(KERN_INFO "Target Time Reached/Exceeded Interrupt Mask: %s\n",
+		((bitSet == true) ? "ENABLED" : "DISABLED"));
+
+	/* Target time reached/exceeded event flag value */
+	bitSet = ixTimeSyncAccEventTtmFlagGet();
+	printk(KERN_INFO "Target Time Reached/Exceeded Event Flag: %s\n",
+		((bitSet == true) ? "SET" : "CLEAR"));
+
+	/* Target Time registers contents */
+	regLowValue = 0;
+	regHighValue = 0;
+	ixTimeSyncAccTargetTimeSnapshotGet(&regLowValue, &regHighValue);
+	printk(KERN_INFO "Target Time (Low:High): %x : %x\n",
+		regLowValue, regHighValue);
+
+	/* Auxiliary Master Mode Snapshot interrupt mask value */
+	bitSet = ixTimeSyncAccControlAmmsInterruptMaskGet();
+	printk(KERN_INFO "Auxiliary Master Mode Snapshot Interrupt Mask:"
+		" %s\n", ((bitSet == true) ? "ENABLED" : "DISABLED"));
+
+	/* Auxiliary Master Mode Snapshot event flag value */
+	bitSet = ixTimeSyncAccEventAmmsFlagGet();
+	printk(KERN_INFO "Auxiliary Master Mode Snapshot Event Flag: %s\n",
+		((bitSet == true) ? "SET" : "CLEAR"));
+
+	/* Auxiliary Master Snapshot registers */
+	regLowValue = 0;
+	regHighValue = 0;
+	ixTimeSyncAccAuxMasterModeSnapshotGet(&regLowValue, &regHighValue);
+	printk(KERN_INFO "Auxiliary Master Mode Snapshot (Low:High):"
+		" %x : %x\n", regLowValue, regHighValue);
+
+	/* Auxiliary Slave Mode Snapshot interrupt mask value */
+	bitSet = ixTimeSyncAccControlAsmsInterruptMaskGet();
+	printk(KERN_INFO "Auxiliary Slave Mode Snapshot Interrupt Mask: %s\n",
+		((bitSet == true) ? "ENABLED" : "DISABLED"));
+
+	/* Auxiliary Slave Mode Snapshot event flag value */
+	bitSet = ixTimeSyncAccEventAsmsFlagGet();
+	printk(KERN_INFO "Auxiliary Slave Mode Snapshot Event Flag: %s\n",
+		((bitSet == true) ? "SET" : "CLEAR"));
+
+	/* Auxiliary Slave Snapshot registers */
+	regLowValue = 0;
+	regHighValue = 0;
+	ixTimeSyncAccAuxSlaveModeSnapshotGet(&regLowValue, &regHighValue);
+	printk(KERN_INFO "Auxiliary Slave Mode Snapshot (Low:High):"
+		" %x : %x\n", regLowValue, regHighValue);
+
+	/* Auxiliary Target time reached/exceeded interrupt mask value */
+	bitSet = ixTimeSyncAccControlAtmInterruptMaskGet();
+	printk(KERN_INFO "Auxiliary Target Time Reached/Exceeded Interrupt"
+		" Mask: %s\n", ((bitSet == true) ? "ENABLED" : "DISABLED"));
+
+	/* Auxiliary Target time reached/exceeded event flag value */
+	bitSet = ixTimeSyncAccEventAtmFlagGet();
+	printk(KERN_INFO "Auxiliary Target Time Reached/Exceeded Event Flag:"
+		" %s\n", ((bitSet == true) ? "SET" : "CLEAR"));
+
+	/* Auxiliary Target Time registers contents */
+	regLowValue = 0;
+	regHighValue = 0;
+	ixTimeSyncAccAuxTargetTimeSnapshotGet(&regLowValue, &regHighValue);
+	printk(KERN_INFO "Auxiliary Target Time (Low:High): %x : %x\n",
+		regLowValue, regHighValue);
+
+	/* Pulse Per Second reached/exceeded interrupt mask value */
+	bitSet = ixTimeSyncAccControlPpsmInterruptMaskGet();
+	printk(KERN_INFO "Pulse Per Second Reached/Exceeded Interrupt Mask:"
+		" %s\n", ((bitSet == true) ? "ENABLED" : "DISABLED"));
+
+	/* Pulse Per Second reached/exceeded event flag value */
+	bitSet = ixTimeSyncAccEventPpsmFlagGet();
+	printk(KERN_INFO "Pulse Per Second Reached/Exceeded Event Flag: %s\n",
+		((bitSet == true) ? "SET" : "CLEAR"));
+
+	/* Pulse Per Second registers contents */
+	regLowValue = 0;
+	ixTimeSyncAccPulsePerSecondCompareGet(&regLowValue);
+	printk(KERN_INFO "Pulse Per Second: %x\n", regLowValue);
+
+	/* Dump Port Level Status for ethernet ports */
+	for (ptpPortNum = 0;
+		 ptpPortNum < ICP_TIMESYNCACC_MAX_1588ETH_CHNL;
+		 ptpPortNum++) {
+		/* output status for ethernet ports */
+		if ((ptpPortNum == ICP_TIMESYNCACC_GBE_0_1588PTP_PORT) ||
+			 (ptpPortNum == ICP_TIMESYNCACC_GBE_1_1588PTP_PORT)) {
+			/* Display the port number */
+			printk(KERN_INFO "PTP Eth Port #: %u\n",
+				ptpPortNum ==
+				ICP_TIMESYNCACC_GBE_0_1588PTP_PORT ? 0 : 1);
+
+			/*
+			 * Get the Master Mode and Timestamp All PTP
+			 * messages status
+			 */
+			bitSet = ixTimeSyncAccControlPTPPortMasterModeGet(
+						ixPortToChnlMap[ptpPortNum]);
+			printk(KERN_INFO "\tMaster Mode: %s\n",
+				((bitSet == true) ? "SET" : "CLEAR"));
+
+			bitSet = ixTimeSyncAccControlPTPPortPTPMsgTimestampGet(
+						ixPortToChnlMap[ptpPortNum]);
+			printk(KERN_INFO "\tTimestamp All Mode: %s\n",
+				((bitSet == true) ? "SET" : "CLEAR"));
+
+			/* Receive Timestamp Event Flag */
+			bitSet = ixTimeSyncAccControlPTPPortRxsFlagGet(
+						ixPortToChnlMap[ptpPortNum]);
+			printk(KERN_INFO "\tReceive Timestamp Event Flag: "
+				"%s\n", ((bitSet == true) ? "SET" : "CLEAR"));
+
+			/* Receive timestamp registers */
+			regLowValue = 0;
+			regHighValue = 0;
+			ixTimeSyncAccPTPPortReceiveSnapshotGet(
+				ixPortToChnlMap[ptpPortNum],
+				&regLowValue, &regHighValue);
+			printk(KERN_INFO "\tReceive Timestamp (Low:High): "
+				"%x : %x\n", regLowValue, regHighValue);
+
+			/* UUID and Seq# */
+			ixTimeSyncAccPTPMsgUuidSeqIdGet(
+				ixPortToChnlMap[ptpPortNum],
+				&uuIdLow, &uuIdHigh, &seqId);
+			printk(KERN_INFO "\tUUID (Low: High (16-Bits)): "
+				"%x : %x \nSeq# (16Bits Only): %x\n",
+				uuIdLow, uuIdHigh, seqId);
+
+			/* Transmit Timestamp Event Flag */
+			bitSet = ixTimeSyncAccControlPTPPortTxsFlagGet(
+						ixPortToChnlMap[ptpPortNum]);
+			printk(KERN_INFO "\tTransmit Timestamp Event Flag: "
+				"%s\n", ((bitSet == true) ? "SET" : "CLEAR"));
+
+			/* Transmit timestamp registers */
+			regLowValue = 0;
+			regHighValue = 0;
+			ixTimeSyncAccPTPPortTransmitSnapshotGet(
+				ixPortToChnlMap[ptpPortNum],
+				&regLowValue, &regHighValue);
+			printk(KERN_INFO "\tTransmit Timestamp "
+				"(Low:High): %x : %x\n",
+				regLowValue, regHighValue);
+		}
+	}
+
+	/* Dump Port Level Status for CAN ports */
+	for (ptpPortNum = 0;
+		 ptpPortNum < ICP_TIMESYNCACC_MAX_1588PTP_PORT;
+		 ptpPortNum++)
+		/* output status for ethernet ports */
+		if ((ptpPortNum == ICP_TIMESYNCACC_CAN_0_1588PTP_PORT) ||
+			 (ptpPortNum == ICP_TIMESYNCACC_CAN_1_1588PTP_PORT)) {
+			/* Display the port number */
+			printk(KERN_INFO "PTP CAN Port #: %u\n",
+				ptpPortNum ==
+				ICP_TIMESYNCACC_CAN_0_1588PTP_PORT ? 0 : 1);
+
+			/* Valid Timestamp Event Flag */
+			bitSet = ixTimeSyncAccControlPTPPortValFlagGet(
+						ixPortToChnlMap[ptpPortNum]);
+			printk(KERN_INFO "\tValid Timestamp Event Flag: %s\n",
+				((bitSet == true) ? "SET" : "CLEAR"));
+
+			/* Overrun Event Flag */
+			bitSet = ixTimeSyncAccControlPTPPortOvrFlagGet(
+						ixPortToChnlMap[ptpPortNum]);
+			printk(KERN_INFO "\tOverrun Event Flag: %s\n",
+				((bitSet == true) ? "SET" : "CLEAR"));
+
+			/* CAN timestamp registers */
+			regLowValue = 0;
+			regHighValue = 0;
+			ixTimeSyncAccPTPPortCANSnapshotGet(
+				ixPortToChnlMap[ptpPortNum],
+				&regLowValue, &regHighValue);
+			printk(KERN_INFO "\tCAN Timestamp (Low:High): %x : %x\n",
+				regLowValue, regHighValue);
+		}
+
+	/* Stats */
+	printk(KERN_INFO "Receive Timestamps Count: %u\n"
+		"Transmit Timestamp Count: %u\n",
+		ixTsStats.rxMsgs, ixTsStats.txMsgs);
+
+	/* Callback Routine Addresses */
+	printk(KERN_INFO "Target Time Callback: %p\n"
+		"Auxiliary Master Mode Snapshot Callback: %p\n"
+		"Auxiliary Slave Mode Snapshot Callback: %p\n"
+		"Auxiliary Target Time Callback: %p\n"
+		"Pulse Per Second Callback: %p\n",
+		ixTsTargetTimeCallback,
+		ixTsAuxMasterTimeCallback,
+		ixTsAuxSlaveTimeCallback,
+		ixTsAuxTargetTimeCallback,
+		ixTsPulsePerSecondCallback);
+
+	return ICP_TIMESYNCACC_SUCCESS;
+} /* end of ixTimeSyncAccShow() function */
+
+struct file_operations file_ops = {
+	.owner		= THIS_MODULE,
+	.open		= timesync_open,
+	.release	= timesync_release,
+	.ioctl		= timesync_ioctl,
+};
+
+static struct pci_driver pci_ops = {
+	.name		= DRIVERNAME,
+	.id_table	= pci_ids,
+	.probe		= pci_probe,
+	.remove		= pci_remove,
+};
+
+/*****************************************************************************
+  Description:
+	timesync_init is the entry point for the driver.
+  Parameters:
+	none
+  Returns:
+	  0 => success
+	< 0 => error
+******************************************************************************/
+static int __init timesync_init(void)
+{
+	int ret;
+	dev_t devno;
+
+	memset(&g_drvr_data, 0, sizeof(drvr_data_t));
+
+	/*request and reserve a device number */
+	ret = alloc_chrdev_region(&g_drvr_data.devnum, 0, 1, DRIVERNAME);
+
+	if (ret < 0) {
+		printk(KERN_INFO "%s-timesync_init: "
+			"Could not register module\n", DRIVERNAME);
+		return ret;
+	}
+
+	/*init cdev struct for adding device to kernel */
+	cdev_init(&g_drvr_data.cdev, &file_ops);
+	g_drvr_data.cdev.owner = THIS_MODULE;
+	g_drvr_data.cdev.ops = &file_ops;
+
+	devno = MKDEV(MAJOR(g_drvr_data.devnum), 0);
+
+	if (cdev_add(&g_drvr_data.cdev, devno, 1)) {
+		printk(KERN_INFO "%s-timesync_init: cdev_add failed\n",
+			DRIVERNAME);
+		goto exit_error;
+	}
+
+	/* register the driver with the pci core */
+	ret = pci_register_driver(&pci_ops);
+
+	if (ret) {
+		printk(KERN_INFO "%s-timesync_init: pci_register failed\n",
+			DRIVERNAME);
+		goto exit_error;
+	}
+
+	goto exit;
+exit_error:
+	printk(KERN_INFO "%s-timesync_init: Initialization failed\n",
+		DRIVERNAME);
+	timesync_close();
+	return -ENODEV;
+exit:
+	printk(KERN_INFO "%s-timesync_init: Initialization complete\n",
+		DRIVERNAME);
+	return 0;
+}
+
+/*****************************************************************************
+  Description:
+	timesync_close is called when the driver is unloaded from memory.
+  Parameters:
+	none
+  Returns:
+	  none
+******************************************************************************/
+static void timesync_close(void)
+{
+	/*remove cdev struct from system */
+	cdev_del(&g_drvr_data.cdev);
+
+	/*unregister driver module */
+	unregister_chrdev_region(g_drvr_data.devnum, 1);
+
+	/* unregister the driver */
+	pci_unregister_driver(&pci_ops);
+
+	printk(KERN_INFO "%s-timesync_close: Driver unload complete\n",
+		DRIVERNAME);
+}
+
+
+/*****************************************************************************
+  Description:
+	timesync_open is called when the driver interface is opened
+  Parameters:
+	inode  kernel file structure
+	filp   open file structure
+  Returns:
+	  0 => success
+	< 0 => error
+******************************************************************************/
+static int timesync_open(struct inode *inode, struct file *filp)
+{
+	/* if going into low power mode */
+	if (g_drvr_data.suspend)
+		return -EINTR;
+
+	printk(KERN_INFO "%s-timesync_open: module opened\n", DRIVERNAME);
+
+	return 0;
+}
+
+/*****************************************************************************
+  Description:
+	timesync_release is called when the driver interface is closed
+  Parameters:
+	inode  kernel file structure
+	filp   open file structure
+  Returns:
+	  0 => success
+	< 0 => error
+******************************************************************************/
+static int timesync_release(struct inode *inode, struct file *filp)
+{
+	printk(KERN_INFO "%s-timesync_release: module released\n", DRIVERNAME);
+
+	return 0;
+}
+
+/*****************************************************************************
+  Description:
+	pci_probe is called right after insmod by the PCI core. Here we
+	enable the device to make the device's resources live. We can then
+	read PCI CFG space and init the device.
+  Parameters:
+	dev   pci device structure
+	id	types of devices supported
+  Returns:
+	  0 => success
+	< 0 => error
+
+******************************************************************************/
+static int pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+
+	int ret = 0;
+	int i;
+
+	/* get the starting physical address of the IO memory */
+	g_drvr_data.mem_base = pci_resource_start(dev, IO_MEM_BAR);
+
+	if (!g_drvr_data.mem_base) {
+		printk(KERN_INFO "%s-pci_probe: could not locate IO "
+			"memory address\n",
+			DRIVERNAME);
+		goto exit_error;
+	}
+
+	/* retreive the available length of the IO memory space */
+	g_drvr_data.mem_size = pci_resource_len(dev, IO_MEM_BAR);
+
+	printk(KERN_INFO "%s-pci_probe: dev memory len %d\n", DRIVERNAME,
+		g_drvr_data.mem_size);
+
+	/*allocate the memory for the gpio registers */
+	if (!request_mem_region(g_drvr_data.mem_base,
+			g_drvr_data.mem_size, "1588_regs")) {
+		printk(KERN_INFO "%s-pci_probe: "
+			"could not allocate register memory space\n",
+			DRIVERNAME);
+		g_drvr_data.mem_base = 0;
+		goto exit_error;
+	}
+
+	/* get the virtual address to the 1588 registers */
+	g_drvr_data.mem_virt = ioremap(g_drvr_data.mem_base,
+					g_drvr_data.mem_size);
+
+	if (!g_drvr_data.mem_virt) {
+		printk(KERN_INFO "%s-pci_probe: "
+			"Could not get virtual address\n", DRIVERNAME);
+		goto exit_error;
+	}
+
+	/* enable the 1588 pci device */
+	ret = pci_enable_device(dev);
+
+	if (ret) {
+		printk(KERN_INFO "%s-pci_probe: pci_enable_device failed\n",
+			DRIVERNAME);
+		return ret;
+	}
+
+	/* init events */
+	for (i = 0; i < NUM_EVENTS; i++) {
+		init_waitqueue_head(&g_notify_event[i]);
+		g_eventflag[i] = 0;
+	}
+
+	/* init callback ptrs */
+	TargetTimeCallbackPtr = TargTimeCallback;
+	AuxTimeCallbackPtr = AuxTimeCallback;
+	AuxTargetTimeCallbackPtr = AuxTargetTimeCallback;
+	PulsePerSecondCallbackPtr = PulsePerSecondCallback;
+
+	/* init the HAL i/o memory addr structure */
+	if (ixTimeSyncAccBlPlBaseAddressesSet(
+		(unsigned int)g_drvr_data.mem_virt) !=
+		ICP_TIMESYNCACC_SUCCESS) {
+		printk(KERN_INFO "%s-pci_probe: "
+			"ixTimeSyncAccBlPlBaseAddressesSet failed\n",
+			DRIVERNAME);
+		goto exit_error;
+	}
+
+	/* request an interrupt */
+	if (request_irq(dev->irq, &timesync_isr, IRQF_PROBE_SHARED,
+			DRIVERNAME, &g_drvr_data)) {
+		printk(KERN_INFO "%s-pci_probe: irq\n", DRIVERNAME);
+		goto exit_error;
+	}
+
+	/* indicate success */
+	g_drvr_data.irq = dev->irq;
+
+	/* enable interrupts to be sent to IA cpu */
+	if (pci_write_config_byte(dev, 0xE8, 1)) {
+		printk(KERN_INFO "%s-pci_probe: "
+			"pci_write_config_byte failed\n", DRIVERNAME);
+		goto exit_error;
+	}
+
+	goto exit;
+exit_error:
+	printk(KERN_INFO "%s-pci_probe: probe failed\n", DRIVERNAME);
+	return -ENODEV;
+exit:
+	printk(KERN_INFO "%s-pci_probe: probe succeeded\n", DRIVERNAME);
+	return 0;
+}
+
+/*****************************************************************************
+  Description:
+	pci_remove is called when the pci driver is being unloaded from the
+	kernel.
+  Parameters:
+	dev   pci device structure
+  Returns:
+	  0 => success
+	< 0 => error
+******************************************************************************/
+static void pci_remove(struct pci_dev *dev)
+{
+	/*disable the interrupts on the 1588 hardware */
+	disable_interrupts();
+
+	/* free the interrupt */
+	if (dev->irq)
+		free_irq(dev->irq, &g_drvr_data);
+
+	/*disable the 1588 hardware */
+	pci_disable_device(dev);
+
+	/*unmap the virtual IO memory space */
+	if (g_drvr_data.mem_virt)
+		iounmap(g_drvr_data.mem_virt);
+
+	/*release the reserved IO memory space */
+	if (g_drvr_data.mem_base)
+		release_mem_region(g_drvr_data.mem_base, g_drvr_data.mem_size);
+
+	printk(KERN_INFO "%s-pci_remove: remove complete\n", DRIVERNAME);
+}
+
+/*****************************************************************************
+  Description:
+	disable_interrupts disables all interrupts on the 1588 device.
+  Parameters:
+	none
+  Returns:
+	  0 => success
+	< 0 => error
+******************************************************************************/
+static int disable_interrupts(void)
+{
+	ixTimeSyncAccControlAmmsInterruptMaskClear();
+	ixTimeSyncAccControlAsmsInterruptMaskClear();
+	ixTimeSyncAccControlTtmInterruptMaskClear();
+	ixTimeSyncAccControlAtmInterruptMaskClear();
+	ixTimeSyncAccControlPpsmInterruptMaskClear();
+
+	return 0;
+}
+
+/*****************************************************************************
+  Description:
+	timesync_isr is the driver interrupt service routine.
+  Parameters:
+	irq	 interrupt number
+	dev_id  client data
+	regs	processor context
+  Returns:
+	  IRQ_HANDLED => interrupt handled
+	  IRQ_NONE => this device did not interrupt
+******************************************************************************/
+static irqreturn_t timesync_isr(int irq, void *dev_id)
+{
+	/*check intrpt event flags for this device */
+	if (!ixTimeSyncAccEventAmmsFlagGet() &&
+		!ixTimeSyncAccEventAsmsFlagGet() &&
+		!ixTimeSyncAccEventAtmFlagGet() &&
+		!ixTimeSyncAccEventPpsmFlagGet() &&
+		!ixTimeSyncAccEventTtmFlagGet())
+		return IRQ_NONE;
+
+	/* process the interrupt in the HAL */
+	if (ixTimeSyncAccIsr() != ICP_TIMESYNCACC_SUCCESS) {
+		printk(KERN_INFO "%s-timesync_isr: "
+			"ixTimeSyncAccIsr failed\n", DRIVERNAME);
+		return IRQ_NONE;
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*****************************************************************************
+  Description:
+	timesync_ioctl is the ioctl interface to the driver.
+  Parameters:
+	inode  ptr to inode
+	filp   ptr to file struct
+	cmd	ioctl command
+	arg	passed in argument
+  Returns:
+	  0 => success
+	< 0 => error
+******************************************************************************/
+static int timesync_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg)
+{
+	wait_queue_head_t *event = NULL;
+	unsigned int bytes_ret = 0;
+	void *param_addr = NULL;
+	unsigned int eventnum = 0;
+	unsigned int buffsize;
+	unsigned int val32;
+	char buff[100];
+	int ret = 0;
+	int i = 0;
+
+	IxTimeSyncAccAuxMode auxMode;
+	IxTimeSyncAcc1588PTPPort ptpPort;
+	IxTimeSyncAccPortCfgIoctl *pPortCfgIoctl;
+	IxTimeSyncAccRxTxPollIoctl *pRxTxPollIoctl;
+	IxTimeSyncAccCANPollIoctl *pCANPollIoctl;
+	IxTimeSyncAccTimePollIoctl *pTimePollIoctl;
+	IxTimeSyncAccTimeValue TimeValue;
+
+	/* if going into low power mode */
+	if (g_drvr_data.suspend)
+		return -EINTR;
+
+	/* get the required size of the buffer for this ioctl call */
+	buffsize = _IOC_SIZE(cmd);
+
+	/* debug check buffer size */
+	if (buffsize > sizeof(buff)) {
+		printk(KERN_INFO "%s-timesync_ioctl: "
+			"buffer size too small.\n", DRIVERNAME);
+		return -EINVAL;
+	}
+
+	/* if data is being written to the driver */
+	if (_IOC_DIR(cmd) & _IOC_WRITE)
+		/*get the data passed in by user */
+		if (copy_from_user(&buff, (void *)arg, buffsize)) {
+			printk(KERN_INFO "%s-timesync_ioctl: "
+				"could not copy user space data.\n",
+				DRIVERNAME);
+			return -EFAULT;
+		}
+
+	switch (cmd) {
+	case IOCTL_TARG_TIME_NOTIFY:
+	case IOCTL_AUX_TIME_NOTIFY:
+	case IOCTL_AUX_TARG_TIME_NOTIFY:
+	case IOCTL_PULSE_PER_SEC_NOTIFY:
+		/* Target Time */
+		if (cmd == IOCTL_TARG_TIME_NOTIFY) {
+			event = &g_notify_event[TARG_TIME_EVENT_NUM];
+			bytes_ret = sizeof(IxTimeSyncAccTimeValue);
+			param_addr = &gTargTimeIoctl;
+			eventnum = TARG_TIME_EVENT_NUM;
+		}
+		/* Aux Time */
+		else if (cmd == IOCTL_AUX_TIME_NOTIFY) {
+			event = &g_notify_event[AUX_TIME_EVENT_NUM];
+			bytes_ret = sizeof(IxTimeSyncAccAuxTimeIoctl);
+			param_addr = &gAuxTimeIoctl;
+			eventnum = AUX_TIME_EVENT_NUM;
+		}
+		/* Aux Target Time */
+		else if (cmd == IOCTL_AUX_TARG_TIME_NOTIFY) {
+			event = &g_notify_event[
+					AUX_TARG_TIME_EVENT_NUM];
+			bytes_ret = sizeof(IxTimeSyncAccTimeValue);
+			param_addr = &gAuxTargTimeIoctl;
+			eventnum = AUX_TARG_TIME_EVENT_NUM;
+		}
+		/* Pulse Per Second */
+		else if (cmd == IOCTL_PULSE_PER_SEC_NOTIFY) {
+			event = &g_notify_event[PPS_EVENT_NUM];
+			bytes_ret = sizeof(u32);
+			param_addr = &gPulsePerSecondIoctl;
+			eventnum = PPS_EVENT_NUM;
+		}
+
+		/*
+		 * wait infinitely for a 1588 interrupt event to occur
+		 */
+		wait_event_interruptible(
+			*event, g_eventflag[eventnum] == 1);
+
+		/* copy global data retreived from interrupt handler */
+		memcpy(buff, param_addr, bytes_ret);
+
+		/* reset global data to 0 */
+		memset(param_addr, 0, bytes_ret);
+
+		/* reset event flag */
+		g_eventflag[eventnum] = 0;
+		break;
+	case IOCTL_TARG_TIME_CLR_NOTIFY:
+	case IOCTL_AUX_TIME_CLR_NOTIFY:
+	case IOCTL_AUX_TARG_TIME_CLR_NOTIFY:
+	case IOCTL_PULSE_PER_SEC_CLR_NOTIFY:
+		/* Target Time */
+		if (cmd == IOCTL_TARG_TIME_CLR_NOTIFY)
+			eventnum = TARG_TIME_EVENT_NUM;
+		/* Aux Time */
+		else if (cmd == IOCTL_AUX_TIME_CLR_NOTIFY)
+			eventnum = AUX_TIME_EVENT_NUM;
+		/* Aux Target Time */
+		else if (cmd == IOCTL_AUX_TARG_TIME_CLR_NOTIFY)
+			eventnum = AUX_TARG_TIME_EVENT_NUM;
+		/* Pulse Per Second */
+		else if (cmd == IOCTL_PULSE_PER_SEC_CLR_NOTIFY)
+			eventnum = PPS_EVENT_NUM;
+
+		/* set event flag */
+		g_eventflag[eventnum] = 1;
+
+		/* force notify thread to wake up */
+		wake_up_interruptible(&g_notify_event[eventnum]);
+		break;
+	case IOCTL_TARG_TIME_INTRPT_ENABLE:
+		/* enable the Target Time interrupt */
+		if (ixTimeSyncAccTargetTimeInterruptEnable(
+			TargetTimeCallbackPtr) !=
+				ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAcc"
+				"TargetTimeInterruptEnable failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_AUX_TIME_INTRPT_ENABLE:
+		/* copy aux mode params from user buffer */
+		memcpy(&auxMode, buff, sizeof(IxTimeSyncAccAuxMode));
+
+		/* enable the Aux Time interrupt */
+		if (ixTimeSyncAccAuxTimeInterruptEnable(
+			auxMode, AuxTimeCallbackPtr)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccAux"
+				"TimeInterruptEnable failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_AUX_TARG_TIME_INTRPT_ENABLE:
+		/* enable the Aux Target Time interrupt */
+		if (ixTimeSyncAccAuxTargetTimeInterruptEnable(
+			AuxTargetTimeCallbackPtr)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccAux"
+				"TargetTimeInterruptEnable failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_PULSE_PER_SEC_INTRPT_ENABLE:
+		/* enable the Pulse per Second interrupt */
+		if (ixTimeSyncAccPulsePerSecondInterruptEnable(
+			PulsePerSecondCallbackPtr)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccPulse"
+				"PerSecondInterruptEnable failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_TARG_TIME_INTRPT_DISABLE:
+		/* disable the Target Time interrupt */
+		if (ixTimeSyncAccTargetTimeInterruptDisable()
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAcc"
+				"TargetTimeInterruptDisable failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_AUX_TIME_INTRPT_DISABLE:
+		/* copy aux mode params from user buffer */
+		memcpy(&auxMode, buff, sizeof(IxTimeSyncAccAuxMode));
+
+		/* disable the Aux Time interrupt */
+		if (ixTimeSyncAccAuxTimeInterruptDisable(auxMode)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccAux"
+				"TimeInterruptDisable failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_AUX_TARG_TIME_INTRPT_DISABLE:
+		/* disable the Aux Target Time interrupt */
+		if (ixTimeSyncAccAuxTargetTimeInterruptDisable()
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccAux"
+				"TargetTimeInterruptDisable failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_PULSE_PER_SEC_INTRPT_DISABLE:
+		/* disable the Pulse per Second interrupt */
+		if (ixTimeSyncAccPulsePerSecondInterruptDisable()
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccPulsePer"
+				"SecondInterruptDisable failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_PORT_CONFIG_SET:
+		/* cast user buff to port cfg struct ptr */
+		pPortCfgIoctl = (IxTimeSyncAccPortCfgIoctl *)buff;
+
+		/* configure the port */
+		if (ixTimeSyncAccPTPPortConfigSet(
+			pPortCfgIoctl->ptpPort,
+			pPortCfgIoctl->ptpPortMode)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccPTPPortConfigSet"
+				" failed\n", DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_PORT_CONFIG_GET:
+		/* cast user buff to port cfg struct ptr */
+		pPortCfgIoctl = (IxTimeSyncAccPortCfgIoctl *)buff;
+
+		/* get port config data */
+		if (ixTimeSyncAccPTPPortConfigGet(
+			pPortCfgIoctl->ptpPort,
+			&pPortCfgIoctl->ptpPortMode)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccPTPPortConfigGet"
+				" failed\n", DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_RX_POLL:
+	case IOCTL_TX_POLL:
+		/* cast user buffer to RxTxPoll struct */
+		pRxTxPollIoctl = (IxTimeSyncAccRxTxPollIoctl *)buff;
+
+		/* if requesting to retreive rx timestamp */
+		if (cmd == IOCTL_RX_POLL) {
+			/* retreive rx timestamp */
+			if (ixTimeSyncAccPTPRxPoll(
+				pRxTxPollIoctl->ptpPort,
+				&pRxTxPollIoctl->ptpMsgData)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl:"
+					" ixTimeSyncAccPTPRxPoll"
+					" failed\n", DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		/* if requesting to retreive tx timestamp */
+		else if (cmd == IOCTL_TX_POLL) {
+			/* retreive tx timestamp */
+			if (ixTimeSyncAccPTPTxPoll(
+				pRxTxPollIoctl->ptpPort,
+				&pRxTxPollIoctl->ptpMsgData)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl:"
+					" ixTimeSyncAccPTPTxPoll"
+					" failed\n", DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		break;
+	case IOCTL_CAN_POLL:
+		/* cast user buffer to a CANPoll struct */
+		pCANPollIoctl = (IxTimeSyncAccCANPollIoctl *)buff;
+
+		/* retreive the CAN port timestamp */
+		if (ixTimeSyncAccPTPCANPoll(
+			pCANPollIoctl->ptpPort,
+			&pCANPollIoctl->ptpTimeStamp)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccPTPCANPoll failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_SYS_TIME_SET:
+	case IOCTL_TARG_TIME_SET:
+	case IOCTL_AUX_TARG_TIME_SET:
+		/* copy time value from user buffer */
+		memcpy(&TimeValue, buff,
+			sizeof(IxTimeSyncAccTimeValue));
+
+		/* set system time */
+		if (cmd == IOCTL_SYS_TIME_SET) {
+			if (ixTimeSyncAccSystemTimeSet(TimeValue)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccSystemTimeSet "
+					"failed\n",
+					DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		/* set target time */
+		else if (cmd == IOCTL_TARG_TIME_SET) {
+			if (ixTimeSyncAccTargetTimeSet(TimeValue)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccTargetTimeSet "
+					"failed\n",
+					DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		/* set aux target time */
+		else if (cmd == IOCTL_AUX_TARG_TIME_SET) {
+			if (ixTimeSyncAccAuxTargetTimeSet(TimeValue)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccAuxTargetTimeSet "
+					"failed\n",
+					DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		break;
+	case IOCTL_SYS_TIME_GET:
+	case IOCTL_TARG_TIME_GET:
+	case IOCTL_AUX_TARG_TIME_GET:
+		TimeValue = *(IxTimeSyncAccTimeValue *)buff;
+
+		/* get system time */
+		if (cmd == IOCTL_SYS_TIME_GET) {
+			if (ixTimeSyncAccSystemTimeGet(&TimeValue)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-ixTimeSyncAcc"
+					"SystemTimeGet failed\n",
+					DRIVERNAME);
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* get target time */
+		else if (cmd == IOCTL_TARG_TIME_GET) {
+			if (ixTimeSyncAccTargetTimeGet(&TimeValue)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccTargetTimeGet"
+					" failed\n", DRIVERNAME);
+				ret = -EINVAL;
+				break;
+			}
+		}
+		/* get aux target time */
+		else if (cmd == IOCTL_AUX_TARG_TIME_GET) {
+			if (ixTimeSyncAccAuxTargetTimeGet(&TimeValue)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccAuxTargetTimeGet"
+					" failed\n",
+					DRIVERNAME);
+				ret = -EINVAL;
+				break;
+			}
+		}
+
+		/* copy time value into return buffer */
+		memcpy(buff, &TimeValue,
+			sizeof(IxTimeSyncAccTimeValue));
+		break;
+	case IOCTL_TICK_RATE_GET:
+	case IOCTL_TICK_RATE_SET:
+	case IOCTL_PULSE_PER_SEC_TIME_SET:
+	case IOCTL_PULSE_PER_SEC_TIME_GET:
+		/* get tick rate */
+		if (cmd == IOCTL_TICK_RATE_GET) {
+			if (ixTimeSyncAccTickRateGet(&val32)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccTickRateGet"
+					" failed\n", DRIVERNAME);
+				ret = -EINVAL;
+			}
+
+			memcpy(buff, &val32, sizeof(u32));
+		}
+		/* set tick rate */
+		else if (cmd == IOCTL_TICK_RATE_SET) {
+			memcpy(&val32, (u32 *)buff, sizeof(u32));
+
+			if (ixTimeSyncAccTickRateSet(val32)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccTickRateSet"
+					" failed\n", DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		/* get pulse per second time */
+		else if (cmd == IOCTL_PULSE_PER_SEC_TIME_GET) {
+			if (ixTimeSyncAccPulsePerSecondTimeGet(&val32)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccPulse"
+					"PerSecondTimeGet failed\n",
+					DRIVERNAME);
+				ret = -EINVAL;
+			}
+
+			memcpy(buff, &val32, sizeof(u32));
+		}
+		/* set pulse per second */
+		else if (cmd == IOCTL_PULSE_PER_SEC_TIME_SET) {
+			memcpy(&val32, (u32 *)buff, sizeof(u32));
+
+			if (ixTimeSyncAccPulsePerSecondTimeSet(val32)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccPulse"
+					"PerSecondTimeSet failed\n",
+					DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		break;
+	case IOCTL_TARG_TIME_POLL:
+	case IOCTL_AUX_TARG_TIME_POLL:
+	case IOCTL_AUX_TIME_POLL:
+		/* cast the user buff to a TimePollIoctl struct */
+		pTimePollIoctl = (IxTimeSyncAccTimePollIoctl *)buff;
+
+		/* poll the target time */
+		if (cmd == IOCTL_TARG_TIME_POLL) {
+			if (ixTimeSyncAccTargetTimePoll(
+				&pTimePollIoctl->PollFlag,
+				&pTimePollIoctl->timeVal)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAcc"
+					"TargetTimePoll failed\n",
+					DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		/* poll the aux target time */
+		else if (cmd == IOCTL_AUX_TARG_TIME_POLL) {
+			if (ixTimeSyncAccAuxTargetTimePoll(
+				&pTimePollIoctl->PollFlag,
+				&pTimePollIoctl->timeVal)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccAux"
+					"TargetTimePoll failed\n",
+					DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		/* poll the aux time */
+		else if (cmd == IOCTL_AUX_TIME_POLL) {
+			if (ixTimeSyncAccAuxTimePoll(
+				pTimePollIoctl->auxMode,
+				&pTimePollIoctl->PollFlag,
+				&pTimePollIoctl->timeVal)
+					!= ICP_TIMESYNCACC_SUCCESS) {
+				printk(KERN_INFO "%s-timesync_ioctl: "
+					"ixTimeSyncAccAuxTimePoll"
+					" failed\n", DRIVERNAME);
+				ret = -EINVAL;
+			}
+		}
+		break;
+	case IOCTL_RESET:
+		/* init events!!  verify */
+		for (i = 0; i < NUM_EVENTS; i++) {
+			init_waitqueue_head(&g_notify_event[i]);
+			g_eventflag[i] = 0;
+		}
+
+		/* reset the 1588 hardware */
+		if (ixTimeSyncAccReset() != ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl:"
+				" ixTimeSyncAccReset failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_CHNL_RESET:
+		/*
+		 * copy the passed in parameter (port number to reset)
+		 */
+		memcpy(&ptpPort, buff,
+			sizeof(IxTimeSyncAcc1588PTPPort));
+
+		/* reset the specified channel */
+		if (ixTimeSyncAccChnlReset(ptpPort) !=
+			ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl: "
+				"ixTimeSyncAccChnlReset failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_SHOW_ALL:
+		/* display regs */
+		if (ixTimeSyncAccShow() != ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl: "
+				"ixTimeSyncAccShow failed\n",
+				DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_STATS_GET:
+		/* get statistics */
+		if (ixTimeSyncAccStatsGet((IxTimeSyncAccStats *)buff)
+				!= ICP_TIMESYNCACC_SUCCESS) {
+			printk(KERN_INFO "%s-timesync_ioctl: "
+				"ixTimeSyncAccStatsGet"
+				" failed\n", DRIVERNAME);
+			ret = -EINVAL;
+		}
+		break;
+	case IOCTL_STATS_RESET:
+		/* reset stats */
+		ixTimeSyncAccStatsReset();
+		break;
+	default:
+		printk(KERN_INFO "%s-timesync_ioctl: "
+			"unknown command (%d)\n", DRIVERNAME, cmd);
+		return -EINVAL;
+	}
+
+	/* if data is being read from the driver */
+	if (_IOC_DIR(cmd) & _IOC_READ) {
+		if (copy_to_user((void *)arg, buff, buffsize)) {
+			printk(KERN_INFO "%s-timesync_ioctl: "
+				"could not copy data to user space.\n",
+				DRIVERNAME);
+			return -EFAULT;
+		}
+	}
+
+	return ret;
+}
+
+/*****************************************************************************
+  Description:
+	TargTimeCallback is a callback function that will be called from the HAL
+	when the target time has expired and generates an interrupt
+  Parameters:
+	targetTime   target time register timestamp
+  Returns:
+	  none
+******************************************************************************/
+static void TargTimeCallback(IxTimeSyncAccTimeValue targetTime)
+{
+	/*
+	 *copy the target time value to the global value to be read by the
+	 *notify ioctl
+	 */
+	memcpy(&gTargTimeIoctl, &targetTime, sizeof(IxTimeSyncAccTimeValue));
+
+	g_eventflag[TARG_TIME_EVENT_NUM] = 1;
+
+	/* signal the notify ioctl that the target time has expired */
+	wake_up_interruptible(&g_notify_event[TARG_TIME_EVENT_NUM]);
+}
+
+/*****************************************************************************
+  Description:
+	AuxTimeCallback is a callback function that will be called from the HAL
+	when an aux time interrupt has occurred
+  Parameters:
+	auxMode   master, slave, or any
+	auxTime   aux time register timestamp
+  Returns:
+	  none
+******************************************************************************/
+static void AuxTimeCallback(IxTimeSyncAccAuxMode auxMode,
+			 IxTimeSyncAccTimeValue auxTime)
+{
+	/* copy the aux time value and aux mode to the global value
+	 * to be read by the notify ioctl
+	 */
+	gAuxTimeIoctl.auxMode = auxMode;
+	memcpy(&gAuxTimeIoctl.auxTime, &auxTime,
+		sizeof(IxTimeSyncAccAuxTimeIoctl));
+
+	g_eventflag[AUX_TIME_EVENT_NUM] = 1;
+
+	/* signal the notify ioctl that the aux timestamp has been set */
+	wake_up_interruptible(&g_notify_event[AUX_TIME_EVENT_NUM]);
+}
+
+/*****************************************************************************
+  Description:
+	AuxTargetTimeCallback is a callback function that will be called from
+	the HAL when the aux target time has expired and generates an interrupt
+  Parameters:
+	auxTargetTime   aux target time register timestamp
+  Returns:
+	  none
+******************************************************************************/
+static void AuxTargetTimeCallback(IxTimeSyncAccTimeValue auxTargetTime)
+{
+	/*
+	 *copy the target time value to the global value to be read by the
+	 * notify ioctl
+	 */
+	memcpy(&gAuxTargTimeIoctl, &auxTargetTime,
+		sizeof(IxTimeSyncAccTimeValue));
+
+	g_eventflag[AUX_TARG_TIME_EVENT_NUM] = 1;
+
+	/* signal the notify ioctl that the aux target time has expired */
+	wake_up_interruptible(&g_notify_event[AUX_TARG_TIME_EVENT_NUM]);
+}
+
+/*****************************************************************************
+  Description:
+	PulsePerSecondCallback is a callback function that will be called from
+	the HAL when the pulse per second time has expired and
+	generates an interrupt
+  Parameters:
+	pulsePerSecond   pulse per second register timestamp
+  Returns:
+	  none
+******************************************************************************/
+static void PulsePerSecondCallback(u32 pulsePerSecond)
+{
+	gPulsePerSecondIoctl = pulsePerSecond;
+
+	g_eventflag[PPS_EVENT_NUM] = 1;
+
+	/* signal the notify ioctl that the pulse per second time has expired */
+	wake_up_interruptible(&g_notify_event[PPS_EVENT_NUM]);
+}
+
+module_init(timesync_init);
+module_exit(timesync_close);
diff --git a/drivers/char/tolapai_1588.h b/drivers/char/tolapai_1588.h
new file mode 100644
index 0000000..04c6579
--- /dev/null
+++ b/drivers/char/tolapai_1588.h
@@ -0,0 +1,1962 @@
+/*
+ *   copyright(c) 2007 intel corporation. all rights reserved.
+ *
+ *   this program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the gnu general public license as
+ *   published by the free software foundation.
+ *
+ *   this program is distributed in the hope that it will be useful, but
+ *   without any warranty; without even the implied warranty of
+ *   merchantability or fitness for a particular purpose.  see the gnu
+ *   general public license for more details.
+ *
+ *   you should have received a copy of the gnu general public license
+ *   along with this program; if not, write to the free software
+ *   foundation, inc., 51 franklin st - fifth floor, boston, ma 02110-1301 usa.
+ *   the full gnu general public license is included in this distribution
+ *   in the file called license.gpl.
+ *
+ *   contact information:
+ *   intel corporation
+ *  version: embedded.l.0.7.018
+ */
+
+#ifndef __tolapai_1588_h__
+#define __tolapai_1588_h__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/socket.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <linux/uaccess.h>
+#include <linux/pci.h>
+#include <linux/cdev.h>
+
+#define DRIVERNAME "1588"
+
+#define VENDOR_ID 0x8086
+#define DEVICE_ID 0x503c
+#define IO_MEM_BAR 0
+
+static inline void write32(u32 val, u32 addr)
+{
+	iowrite32(val, (u32 *)addr);
+}
+
+static inline u32 read32(u32 addr)
+{
+	return ioread32((u32 *)addr);
+}
+
+/*
+ * SET, CLEAR & CHECK macros for bit manipulation on the
+ * memory mapped registers' contents
+ */
+#define ICP_TIMESYNCACC_BIT_SET(regAddr, bitMask) \
+	do { \
+		/* *(regAddr) |= (bitMask); */ \
+		write32(read32(regAddr) | bitMask, \
+				regAddr); \
+	} while (0) /* Don't include ';' here */
+
+#define ICP_TIMESYNCACC_BIT_CLEAR(regAddr, bitMask) \
+	do { \
+		/* *(regAddr) &= ~(bitMask); */ \
+		write32(read32(regAddr) & ~(bitMask), \
+				regAddr); \
+	} while (0) /* Don't include ';' here */
+
+#define ICP_TIMESYNCACC_BIT_SET_CHECK(regAddr, bitMask) \
+	((read32(regAddr)  & (bitMask)) == (bitMask))
+/* Don't include ';' here */
+
+/*
+ * READ, WRITE macros for memory mapped registers
+ */
+#define ICP_TIMESYNCACC_REG_READ(regAddr, varRef) \
+	do { \
+		*(varRef) = read32(regAddr); \
+	} while (0) /* Don't include ';' here */
+
+#define ICP_TIMESYNCACC_REG_WRITE(regAddr, varValue) \
+	do { \
+		write32(varValue, regAddr); \
+	} while (0) /* Don't include ';' here */
+
+/* Masks to extract High and Low SHORTs from u32 values */
+#define ICP_TIMESYNCACC_MSB_SHORT_MASK  (0xFFFF0000)
+#define ICP_TIMESYNCACC_LSB_SHORT_MASK  (0x0000FFFF)
+
+/* Location of SeqID in the register */
+#define ICP_TIMESYNCACC_SID_LOC         (16)
+
+/* Max number of time sync hw channels for each port type */
+#define ICP_TIMESYNCACC_MAX_1588ETH_CHNL  (0x08)
+#define ICP_TIMESYNCACC_MAX_1588CAN_CHNL  (0x02)
+
+/* Max number of time sync ports */
+#define ICP_TIMESYNCACC_MAX_1588PTP_PORT  (ICP_TIMESYNCACC_MAX_1588ETH_CHNL + \
+		ICP_TIMESYNCACC_MAX_1588CAN_CHNL)
+
+/* active hardware channel numbers */
+#define ICP_TIMESYNCACC_GBE_0_1588PTP_CHNL (0x3)
+#define ICP_TIMESYNCACC_GBE_1_1588PTP_CHNL (0x4)
+#define ICP_TIMESYNCACC_CAN_0_1588PTP_CHNL (0x0)
+#define ICP_TIMESYNCACC_CAN_1_1588PTP_CHNL (0x1)
+
+/* Size of the each Block / Port Level Register */
+#define ICP_TIMESYNCACC_BLPLREG_SIZE  (0x04)
+
+/* Offsets to eth and can port level registers */
+#define ICP_TIMESYNCACC_PLETH_OFFSET  (0x40)
+#define ICP_TIMESYNCACC_PLCAN_OFFSET  (0x140)
+
+/* Block wise offset of each Port Level Registers for a given ethernet PTP Port
+*/
+#define ICP_TIMESYNCACC_PLREGS_ETH_BOFFSET  (0x20)
+
+/* Block wise offset of each Port Level Registers for a given CAN PTP Port
+*/
+#define ICP_TIMESYNCACC_PLREGS_CAN_BOFFSET  (0x10)
+
+/*
+ * Block Level Registers Offset Values
+ * Please refer to the struct - IxTimeSyncAccBlockLevelRegisters defined
+ * to hold the virtual addresses of the various block level registers of
+ * time sync hardware
+ */
+#define ICP_TIMESYNCACC_TSC_OFFSET	(0x00)	/* TS_Control */
+#define ICP_TIMESYNCACC_TSE_OFFSET	(0x04)	/* TS_Event */
+#define ICP_TIMESYNCACC_ADD_OFFSET	(0x08)	/* TS_Addend */
+#define ICP_TIMESYNCACC_ACC_OFFSET	(0x0C)	/* TS_Accum */
+#define ICP_TIMESYNCACC_TST_OFFSET	(0x10)	/* TS_Test */
+#define ICP_TIMESYNCACC_PPS_OFFSET	(0x14)	/* TS_PPS_Compare */
+#define ICP_TIMESYNCACC_STL_OFFSET	(0x20)	/* TS_SysTimeLo */
+#define ICP_TIMESYNCACC_STH_OFFSET	(0x24)	/* TS_SysTimeHi */
+#define ICP_TIMESYNCACC_TTL_OFFSET	(0x28)	/* TS_TrgtLo */
+#define ICP_TIMESYNCACC_TTH_OFFSET	(0x2c)	/* TS_TrgtHi */
+#define ICP_TIMESYNCACC_ASSL_OFFSET	(0x30)	/* TS_ASMSLo */
+#define ICP_TIMESYNCACC_ASSH_OFFSET	(0x34)	/* TS_ASMSHi */
+#define ICP_TIMESYNCACC_AMSL_OFFSET	(0x38)	/* TS_AMMSLo */
+#define ICP_TIMESYNCACC_AMSH_OFFSET	(0x3C)	/* TS_AMMSHi */
+#define ICP_TIMESYNCACC_ATTL_OFFSET	(0x1F0)	/* TS_Aux_TrgtLo */
+#define	ICP_TIMESYNCACC_ATTH_OFFSET	(0x1F4)	/* TS_Aux_TrgtHi */
+
+/*
+ * Port Level Registers Offset Values
+ * The following offset macros work as explained below.
+ * Effective Address:= Starting Virtual Address +
+ *                     Vertical Offset + Block Offset for Port
+ * NOTE: a) Starting Virtual Address will be obtained using OSAL macro
+ *       b) portNum (0 -> Max ICP_TIMESYNCACC_MAX_1588PTP_PORT)
+ *       c) Block Offset for Port starts from Zero
+ * The example assumes that Starting Virtual Address has been 0x40.
+ * Eg., CC0:  0x40 + (0x04 * 0x00) + (0x20 * 0x00) = 0x40
+ *      XSH1: 0x40 + (0x04 * 0x03) + (0x20 * 0x01) = 0x6C
+ *      RSH2: 0x40 + (0x04 * 0x05) + (0x20 * 0x02) = 0x94
+ */
+
+/* Vertical/Relative Offset of a given ethernet Port Level Register
+ * within a single set/block for each ethernet PTP channel
+ * Please refer to the struct - IxTimeSyncAccPortLevelRegisters defined
+ * to hold the virtual addresses of the various port level registers of
+ * time sync hardware
+ */
+#define ICP_TIMESYNCACC_CC_VOFFSET	(0x00)
+#define ICP_TIMESYNCACC_CE_VOFFSET	(0x04)
+#define ICP_TIMESYNCACC_XSL_VOFFSET	(0x08)
+#define ICP_TIMESYNCACC_XSH_VOFFSET	(0x0C)
+#define ICP_TIMESYNCACC_RSL_VOFFSET	(0x10)
+#define ICP_TIMESYNCACC_RSH_VOFFSET	(0x14)
+#define ICP_TIMESYNCACC_UID_VOFFSET	(0x18)
+#define ICP_TIMESYNCACC_SID_VOFFSET	(0x1C)
+
+
+/* Vertical/Relative Offset of a given CAN Port Level Register
+ * within a single set/block for each CAN PTP channel
+ * Please refer to the struct - IxTimeSyncAccPortLevelRegisters defined
+ * to hold the virtual addresses of the various port level registers of
+ * time sync hardware
+ */
+#define ICP_TIMESYNCACC_CCE_VOFFSET	(0x00)
+#define ICP_TIMESYNCACC_CXSL_VOFFSET	(0x04)
+#define	ICP_TIMESYNCACC_CXSH_VOFFSET	(0x08)
+
+/* Compounded Offsets for each of the Port Level Registers as explained
+ * in the NOTE of the above comments
+ */
+#define ICP_TIMESYNCACC_CC_OFFSET(portNum)  \
+	(ICP_TIMESYNCACC_PLETH_OFFSET + ICP_TIMESYNCACC_CC_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_ETH_BOFFSET * (portNum))
+#define ICP_TIMESYNCACC_CE_OFFSET(portNum)  \
+	(ICP_TIMESYNCACC_PLETH_OFFSET + ICP_TIMESYNCACC_CE_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_ETH_BOFFSET * (portNum))
+#define ICP_TIMESYNCACC_XSL_OFFSET(portNum) \
+	(ICP_TIMESYNCACC_PLETH_OFFSET + ICP_TIMESYNCACC_XSL_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_ETH_BOFFSET * (portNum))
+#define ICP_TIMESYNCACC_XSH_OFFSET(portNum) \
+	(ICP_TIMESYNCACC_PLETH_OFFSET + ICP_TIMESYNCACC_XSH_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_ETH_BOFFSET * (portNum))
+#define ICP_TIMESYNCACC_RSL_OFFSET(portNum) \
+	(ICP_TIMESYNCACC_PLETH_OFFSET + ICP_TIMESYNCACC_RSL_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_ETH_BOFFSET * (portNum))
+#define ICP_TIMESYNCACC_RSH_OFFSET(portNum) \
+	(ICP_TIMESYNCACC_PLETH_OFFSET + ICP_TIMESYNCACC_RSH_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_ETH_BOFFSET * (portNum))
+#define ICP_TIMESYNCACC_UID_OFFSET(portNum) \
+	(ICP_TIMESYNCACC_PLETH_OFFSET + ICP_TIMESYNCACC_UID_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_ETH_BOFFSET * (portNum))
+#define ICP_TIMESYNCACC_SID_OFFSET(portNum) \
+	(ICP_TIMESYNCACC_PLETH_OFFSET + ICP_TIMESYNCACC_SID_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_ETH_BOFFSET * (portNum))
+#define ICP_TIMESYNCACC_CCE_OFFSET(portNum) \
+	(ICP_TIMESYNCACC_PLCAN_OFFSET + ICP_TIMESYNCACC_CCE_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_CAN_BOFFSET  * (portNum))
+#define ICP_TIMESYNCACC_CXSL_OFFSET(portNum) \
+	(ICP_TIMESYNCACC_PLCAN_OFFSET + ICP_TIMESYNCACC_CXSL_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_CAN_BOFFSET  * (portNum))
+#define	ICP_TIMESYNCACC_CXSH_OFFSET(portNum) \
+	(ICP_TIMESYNCACC_PLCAN_OFFSET + ICP_TIMESYNCACC_CXSH_VOFFSET + \
+	 ICP_TIMESYNCACC_PLREGS_CAN_BOFFSET  * (portNum))
+
+/*
+ * Bit Masks of Block Level Control Register
+ */
+/* Auxiliary Target Time Interrupt Mask */
+#define ICP_TIMESYNCACC_TSC_ATM_MASK	(1 << 5)
+/* Pulse Per Second Interrupt Mask */
+#define ICP_TIMESYNCACC_TSC_PPSM_MASK	(1 << 4)
+/* Auxiliary Master Mode snapshot Interrupt Mask */
+#define ICP_TIMESYNCACC_TSC_AMMS_MASK	(1 << 3)
+/* Auxiliary Slave Mode snapshot Interrupt Mask */
+#define ICP_TIMESYNCACC_TSC_ASMS_MASK	(1 << 2)
+/* Target Time Interrupt Mask */
+#define ICP_TIMESYNCACC_TSC_TTM_MASK	(1 << 1)
+/* Hardware Assist Reset */
+#define ICP_TIMESYNCACC_TSC_RESET	(1 << 0)
+
+/*
+ * Bit Masks of Block Level Event Register
+ */
+/* GBe1 Mode Status - 1 indicates the gbe1 port is running in MII mode
+ * 0 indicates the gbe1 port is running in GMII mode
+ */
+#define ICP_TIMESYNCACC_TSE_GB1M     (1 << 9)
+/* GBe0 Mode Status - 1 indicates the Gbe0 port is running in MII mode
+ * 0 indicates the gbe1 port is running in GMII mode
+ */
+#define ICP_TIMESYNCACC_TSE_GB0M     (1 << 8)
+/* Auxiliary Target Time Interrupt Pending Event */
+#define ICP_TIMESYNCACC_TSE_ATP      (1 << 5)
+/* Pulse Per Second Match */
+#define ICP_TIMESYNCACC_TSE_PPM      (1 << 4)
+/* Auxiliary Master Mode snapshot Event */
+#define ICP_TIMESYNCACC_TSE_SNM          (1 << 3)
+/* Auxiliary Slave Mode snapshot Event */
+#define ICP_TIMESYNCACC_TSE_SNS          (1 << 2)
+/* Target Time Interrupt Pending Event */
+#define ICP_TIMESYNCACC_TSE_TTIPEND      (1 << 1)
+
+/*
+ * Bit Masks of Channel/Port Level Control Register
+ */
+/* Channel Reset Control Flag */
+#define ICP_TIMESYNCACC_CC_CRST          (1 << 2)
+/* Timestamp All Messages Control Flag */
+#define ICP_TIMESYNCACC_CC_TA            (1 << 1)
+/* Timestamp Master or Slave Mode Control Flag */
+#define ICP_TIMESYNCACC_CC_MM            (1 << 0)
+
+/*
+ * Bit Masks of Channel/Port Level Event Register
+ */
+/* Receive Snapshot Locked Indicator Flag */
+#define ICP_TIMESYNCACC_CE_RXS           (1 << 1)
+/* Transmit Snapshot Locked Indicator Flag */
+#define ICP_TIMESYNCACC_CE_TXS           (1 << 0)
+
+/*
+ * Bit Masks of CAN Channel/Port Level Event Register
+ */
+/* Valid Indicator Flag */
+#define ICP_TIMESYNCACC_CE_VAL           (1 << 1)
+/* Overrun Indicator Flag */
+#define ICP_TIMESYNCACC_CE_OVR           (1 << 0)
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @enum IxTimeSyncAccStatus
+ * @brief The status as returned from the API
+ */
+typedef enum {
+	/**< Requested operation successful */
+	ICP_TIMESYNCACC_SUCCESS,
+	/**< An invalid parameter was passed */
+	ICP_TIMESYNCACC_INVALIDPARAM,
+	/**< While polling no time stamp available */
+	ICP_TIMESYNCACC_NOTIMESTAMP,
+	/**< Polling not allowed while operating in interrupt mode */
+	ICP_TIMESYNCACC_INTERRUPTMODEINUSE,
+	/**< Internal error occurred */
+	ICP_TIMESYNCACC_FAILED,
+	/**< Hardware access library not yet initialized */
+	ICP_TIMESYNCACC_UNINITIALIZED,
+} IxTimeSyncAccStatus;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @enum IxTimeSyncAccAuxMode
+ * @brief Master or Slave Auxiliary Time Stamp (Snap Shot)
+ */
+typedef enum {
+	ICP_TIMESYNCACC_AUXMODE_MASTER,          /**< Auxiliary Master Mode */
+	ICP_TIMESYNCACC_AUXMODE_SLAVE,           /**< Auxiliary Slave Mode */
+	ICP_TIMESYNCACC_AUXMODE_INVALID          /**< Invalid Auxiliary Mode */
+} IxTimeSyncAccAuxMode;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @enum IxTimeSyncAcc1588PTPPort
+ * @brief IEEE 1588 PTP Communication Port(Channel)
+ */
+typedef enum {
+	/**< PTP Communication Port on GBE-0 */
+	ICP_TIMESYNCACC_GBE_0_1588PTP_PORT,
+	/**< PTP Communication Port on GBE-1 */
+	ICP_TIMESYNCACC_GBE_1_1588PTP_PORT,
+	/**< PTP Communication Port on CAN-0 */
+	ICP_TIMESYNCACC_CAN_0_1588PTP_PORT,
+	/**< PTP Communication Port on CAN-1 */
+	ICP_TIMESYNCACC_CAN_1_1588PTP_PORT,
+	/**< Invalid PTP Communication Port */
+	ICP_TIMESYNCACC_1588PORT_INVALID
+} IxTimeSyncAcc1588PTPPort;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @enum IxTimeSyncAcc1588PTPPortMode
+ * @brief Master or Slave mode for IEEE 1588 PTP Communication Port
+ */
+typedef enum {
+	/**< PTP Communication Port in Master Mode */
+	ICP_TIMESYNCACC_1588PTP_PORT_MASTER,
+	/**< PTP Communication Port in Slave Mode */
+	ICP_TIMESYNCACC_1588PTP_PORT_SLAVE,
+	/* < PTP Communication Port in ANY Mode
+	 * allows time stamping of all messages
+	 * including non-1588 PTP
+	 */
+	ICP_TIMESYNCACC_1588PTP_PORT_ANYMODE,
+	/**< Invalid PTP Port Mode */
+	ICP_TIMESYNCACC_1588PTP_PORT_MODE_INVALID
+} IxTimeSyncAcc1588PTPPortMode;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @enum ixTimeSyncAcc1588PTPMsgType
+ * @brief 1588 PTP Messages types that can be detected on communication port
+ * Note that client code can determine this based on master/slave mode in which
+ * it is already operating in and this information is made available for the
+ * sake of convenience only.
+ */
+typedef enum {
+	/**< PTP Sync message sent by Master or received by Slave */
+	ICP_TIMESYNCACC_1588PTP_MSGTYPE_SYNC,
+	/**< PTP Delay_Req message sent by Slave or received by Master */
+	ICP_TIMESYNCACC_1588PTP_MSGTYPE_DELAYREQ,
+	/*
+	 * < Other PTP and non-PTP message sent or received by both
+	 * Master and/or Slave
+	 */
+	ICP_TIMESYNCACC_1588PTP_MSGTYPE_UNKNOWN
+} ixTimeSyncAcc1588PTPMsgType;
+
+/*
+ * Section for struct
+ */
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @struct IxTimeSyncAccTimeValue
+ * @brief Struct to hold 64 bit SystemTime and TimeStamp values
+ */
+typedef struct {
+	u32 timeValueLowWord;         /**< Lower 32 bits of the time value */
+	u32 timeValueHighWord;        /**< Upper 32 bits of the time value */
+} IxTimeSyncAccTimeValue;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @struct ixTimeSyncAccUuid
+ * @brief Struct to hold 48 bit UUID values captured in Sync or
+ * Delay_Req messages
+ */
+typedef struct {
+	u32 uuidValueLowWord;          /**<The lower 32 bits of the UUID */
+	u16 uuidValueHighHalfword;     /**<The upper 16 bits of the UUID */
+} ixTimeSyncAccUuid;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @struct IxTimeSyncAccPtpMsgData
+ * @brief Struct for data from the PTP message returned when
+ * TimeStamp available
+ */
+typedef struct {
+	/**< PTP Messages type */
+	ixTimeSyncAcc1588PTPMsgType ptpMsgType;
+	/**< 64 bit TimeStamp value from PTP Message */
+	IxTimeSyncAccTimeValue ptpTimeStamp;
+	/**< 48 bit UUID value from the PTP Message */
+	ixTimeSyncAccUuid ptpUuid;
+	/**< 16 bit Sequence Number from PTP Message */
+	u16 ptpSequenceNumber;
+} IxTimeSyncAccPtpMsgData;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @struct IxTimeSyncAccStats
+ * @brief Statistics for the PTP messages
+ */
+typedef struct {
+	u32 rxMsgs; /**< Count of timestamps for received PTP Messages */
+	u32 txMsgs; /**< Count of timestamps for transmitted PTP Messages */
+} IxTimeSyncAccStats;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @struct IxTimeSyncAccAuxTimeIoctl
+ * @brief Struct to pass aux time data for ioctl call
+ */
+typedef struct {
+	IxTimeSyncAccAuxMode auxMode;   /**< aux mode: master or slave */
+	IxTimeSyncAccTimeValue auxTime; /**< aux time snapshot */
+} IxTimeSyncAccAuxTimeIoctl;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @struct IxTimeSyncAccPortCfgIoctl
+ * @brief Struct to pass port config data for ioctl call
+ */
+typedef struct {
+	/**< IEEE 1588 PTP Communication Port */
+	IxTimeSyncAcc1588PTPPort ptpPort;
+	/**< Master, Slave, or Any mode */
+	IxTimeSyncAcc1588PTPPortMode ptpPortMode;
+} IxTimeSyncAccPortCfgIoctl;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @struct IxTimeSyncAccRxTxPollIoctl
+ * @brief Struct to pass PTP message data for ioctl call
+ */
+typedef struct {
+	/**< IEEE 1588 PTP Communication Port */
+	IxTimeSyncAcc1588PTPPort ptpPort;
+	IxTimeSyncAccPtpMsgData ptpMsgData; /**< data from the PTP message */
+} IxTimeSyncAccRxTxPollIoctl;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @struct IxTimeSyncAccCANPollIoctl
+ * @brief Struct to pass CAN timestamp data for ioctl call
+ */
+typedef struct {
+	/**< IEEE 1588 PTP Communication Port */
+	IxTimeSyncAcc1588PTPPort ptpPort;
+	IxTimeSyncAccTimeValue ptpTimeStamp; /**< CAN PTP timestamp */
+} IxTimeSyncAccCANPollIoctl;
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @struct IxTimeSyncAccTimePollIoctl
+ * @brief Struct to pass timestamp data for ioctl call
+ */
+typedef struct {
+	u32 PollFlag;   /**< time event */
+	IxTimeSyncAccTimeValue timeVal; /**< timestamp value */
+	IxTimeSyncAccAuxMode auxMode;   /**< Master or Slave mode */
+} IxTimeSyncAccTimePollIoctl;
+
+/* 1588 register states */
+typedef struct reg_states {
+	unsigned int AmmsInterrupt;
+	unsigned int AsmsInterrupt;
+	unsigned int TtmInterrupt;
+	unsigned int AtmInterrupt;
+	unsigned int PpsmInterrupt;
+	IxTimeSyncAccTimeValue SystemTime;
+	IxTimeSyncAccTimeValue TargetTime;
+	IxTimeSyncAccTimeValue AuxTargetTime;
+	unsigned int PulsePerSecond;
+	unsigned int Addend;
+	unsigned int MasterMode[ICP_TIMESYNCACC_1588PORT_INVALID];
+	unsigned int MsgTimestamp[ICP_TIMESYNCACC_1588PORT_INVALID];
+} reg_states_t;
+
+/* private driver data */
+typedef struct drvr_data {
+	dev_t devnum;
+	struct cdev cdev;
+	void *mem_virt;
+	unsigned int mem_base;
+	unsigned int mem_size;
+	unsigned int irq;
+	unsigned int suspend;
+	reg_states_t state;
+} drvr_data_t;
+
+/* Block Level Registers */
+typedef struct {
+	u32 tsControl;    /* Time Sync Control */
+	u32 tsEvent;      /* Time Sync Event */
+	u32 tsAddend;     /* Addend */
+	u32 tsAccum;      /* Accumulator */
+	u32 tsTest;       /* Test */
+	u32 tsPpsCompare; /* Pulse Per Second Compare */
+	u32 tsSysTimeLo;  /* SystemTime_Low */
+	u32 tsSysTimeHi;  /* SystemTime_High */
+	u32 tsTrgtLo;     /* TargetTime_Low */
+	u32 tsTrgtHi;     /* TargetTime_High */
+	u32 tsASMSLo;     /* AuxSlaveModeSnap_Low */
+	u32 tsASMSHi;     /* AuxSlaveModeSnap_High */
+	u32 tsAMMSLo;     /* AuxMasterModeSnap_Low */
+	u32 tsAMMSHi;     /* AuxMasterModeSnap_High */
+	u32 tsATTSHi;	   /*	AuxTargetTimeSnap_High */
+	u32 tsATTSLo;	   /*	AuxTargetTimeSnap_Low */
+} IxTimeSyncAccBlockLevelRegisters;
+
+/* Port Level Registers */
+typedef struct {
+	u32 tsChControl;  	/* TS Channel Control */
+	u32 tsChEvent;    	/* TS Channel Event */
+	u32 tsTxSnapLo;   	/* XMIT Snaphot Low */
+	u32 tsTxSnapHi;   	/* XMIT Snapshot High */
+	u32 tsRxSnapLo;   	/* RECV Snapshot Low */
+	u32 tsRxSnapHi;   	/* RECV Snapshot High */
+	u32 tsSrcUUIDLo;  	/* SourceUUID Low */
+	u32 tsSrcUUIDHi;  	/* SequenceID0/SourceUUID High */
+	u32 tsCANChEvent;	/* TS CAN Channel Event */
+	u32 tsCANTxSnapLo;	/* CAN XMIT Snapshot Low */
+	u32 tsCANTxSnapHi;	/* CAN XMIT Snapshot High */
+} IxTimeSyncAccPortLevelRegisters;
+
+/* Virtual addresses of time sync hardware registers */
+typedef struct {
+	/* Block Level Registers */
+	IxTimeSyncAccBlockLevelRegisters  blRegisters;
+	/* Port Level Registers */
+	IxTimeSyncAccPortLevelRegisters   plRegisters[
+		ICP_TIMESYNCACC_MAX_1588PTP_PORT];
+} IxTimeSyncAccRegisters;
+
+/* enumeration of events used */
+typedef enum _NotifyEvent {
+	TARG_TIME_EVENT_NUM,
+	AUX_TIME_EVENT_NUM,
+	AUX_TARG_TIME_EVENT_NUM,
+	PPS_EVENT_NUM,
+	NUM_EVENTS
+} NotifyEvent;
+
+static struct pci_device_id pci_ids[] = {
+	{ PCI_DEVICE(VENDOR_ID, DEVICE_ID) },
+	{ 0, },
+};
+MODULE_DEVICE_TABLE(pci, pci_ids);
+
+#define TS_IOCTL_BASE 0xCD
+#define IOCTL_PORT_CONFIG_SET \
+		_IOW(TS_IOCTL_BASE, 0, IxTimeSyncAccPortCfgIoctl)
+#define IOCTL_PORT_CONFIG_GET \
+		_IOWR(TS_IOCTL_BASE, 1, IxTimeSyncAccPortCfgIoctl)
+#define IOCTL_RX_POLL _IOWR(TS_IOCTL_BASE, 2, IxTimeSyncAccRxTxPollIoctl)
+#define IOCTL_TX_POLL _IOWR(TS_IOCTL_BASE, 3, IxTimeSyncAccRxTxPollIoctl)
+#define IOCTL_CAN_POLL _IOWR(TS_IOCTL_BASE, 4, IxTimeSyncAccCANPollIoctl)
+#define IOCTL_SYS_TIME_GET _IOR(TS_IOCTL_BASE, 5, IxTimeSyncAccTimeValue)
+#define IOCTL_SYS_TIME_SET _IOW(TS_IOCTL_BASE, 6, IxTimeSyncAccTimeValue)
+#define IOCTL_TICK_RATE_SET _IOW(TS_IOCTL_BASE, 7, u32)
+#define IOCTL_TICK_RATE_GET _IOR(TS_IOCTL_BASE, 8, u32)
+#define IOCTL_TARG_TIME_INTRPT_ENABLE _IO(TS_IOCTL_BASE, 9)
+#define IOCTL_TARG_TIME_INTRPT_DISABLE _IO(TS_IOCTL_BASE, 10)
+#define IOCTL_TARG_TIME_POLL \
+		_IOR(TS_IOCTL_BASE, 11, IxTimeSyncAccTimePollIoctl)
+#define IOCTL_TARG_TIME_SET _IOW(TS_IOCTL_BASE, 12, IxTimeSyncAccTimeValue)
+#define IOCTL_TARG_TIME_GET _IOR(TS_IOCTL_BASE, 13, IxTimeSyncAccTimeValue)
+#define IOCTL_AUX_TIME_INTRPT_ENABLE \
+		_IOW(TS_IOCTL_BASE, 14, IxTimeSyncAccAuxMode)
+#define IOCTL_AUX_TIME_INTRPT_DISABLE \
+		_IOW(TS_IOCTL_BASE, 15, IxTimeSyncAccAuxMode)
+#define IOCTL_AUX_TIME_POLL \
+		_IOWR(TS_IOCTL_BASE, 16, IxTimeSyncAccTimePollIoctl)
+#define IOCTL_RESET _IO(TS_IOCTL_BASE, 17)
+#define IOCTL_CHNL_RESET _IOW(TS_IOCTL_BASE, 18, IxTimeSyncAcc1588PTPPort)
+#define IOCTL_STATS_GET _IOR(TS_IOCTL_BASE, 19, IxTimeSyncAccStats)
+#define IOCTL_STATS_RESET _IO(TS_IOCTL_BASE, 20)
+#define IOCTL_SHOW_ALL _IO(TS_IOCTL_BASE, 21)
+#define IOCTL_AUX_TARG_TIME_INTRPT_ENABLE _IO(TS_IOCTL_BASE, 22)
+#define IOCTL_AUX_TARG_TIME_INTRPT_DISABLE _IO(TS_IOCTL_BASE, 23)
+#define IOCTL_AUX_TARG_TIME_POLL \
+		_IOR(TS_IOCTL_BASE, 24, IxTimeSyncAccTimePollIoctl)
+#define IOCTL_AUX_TARG_TIME_SET _IOW(TS_IOCTL_BASE, 25, IxTimeSyncAccTimeValue)
+#define IOCTL_AUX_TARG_TIME_GET _IOR(TS_IOCTL_BASE, 26, IxTimeSyncAccTimeValue)
+#define IOCTL_PULSE_PER_SEC_INTRPT_ENABLE _IO(TS_IOCTL_BASE, 27)
+#define IOCTL_PULSE_PER_SEC_INTRPT_DISABLE _IO(TS_IOCTL_BASE, 28)
+#define IOCTL_TARG_TIME_NOTIFY _IOR(TS_IOCTL_BASE, 29, IxTimeSyncAccTimeValue)
+#define IOCTL_AUX_TIME_NOTIFY \
+		_IOR(TS_IOCTL_BASE, 30, IxTimeSyncAccAuxTimeIoctl)
+#define IOCTL_AUX_TARG_TIME_NOTIFY \
+		_IOR(TS_IOCTL_BASE, 31, IxTimeSyncAccTimeValue)
+#define IOCTL_PULSE_PER_SEC_NOTIFY _IOR(TS_IOCTL_BASE, 32, u32)
+#define IOCTL_TARG_TIME_CLR_NOTIFY _IO(TS_IOCTL_BASE, 33)
+#define IOCTL_AUX_TIME_CLR_NOTIFY _IO(TS_IOCTL_BASE, 34)
+#define IOCTL_AUX_TARG_TIME_CLR_NOTIFY _IO(TS_IOCTL_BASE, 35)
+#define IOCTL_PULSE_PER_SEC_CLR_NOTIFY _IO(TS_IOCTL_BASE, 36)
+#define IOCTL_PULSE_PER_SEC_TIME_GET _IOR(TS_IOCTL_BASE, 37, u32)
+#define IOCTL_PULSE_PER_SEC_TIME_SET _IOW(TS_IOCTL_BASE, 38, u32)
+
+/* TimeSync Hardware Registers */
+static IxTimeSyncAccRegisters ixTsRegisters;
+
+/* Enable Auxiliary Master Mode Snapshot Interrupt */
+static inline void
+ixTimeSyncAccControlAmmsInterruptMaskSet(void)
+{
+	/* SET the amms bit */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_AMMS_MASK);
+} /* end of ixTimeSyncAccControlAmmsInterruptMaskSet() function */
+
+/* Enable Auxiliary Slave Mode Snapshot Interrupt */
+static inline void
+ixTimeSyncAccControlAsmsInterruptMaskSet(void)
+{
+	/* SET the asms bit */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_ASMS_MASK);
+} /* end of ixTimeSyncAccControlAsmsInterruptMaskSet() function */
+
+/* Enable Target Time Interrupt */
+static inline void
+ixTimeSyncAccControlTtmInterruptMaskSet(void)
+{
+	/* SET the ttm bit */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_TTM_MASK);
+} /* end of ixTimeSyncAccControlTtmInterruptMaskSet() function */
+
+/* Enable Auxiliary Target Time Interrupt */
+static inline void
+ixTimeSyncAccControlAtmInterruptMaskSet(void)
+{
+	/* SET the atm bit */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_ATM_MASK);
+} /* end of ixTimeSyncAccControlAtmInterruptMaskSet() function */
+
+/* Enable Pulse Per Second Interrupt */
+static inline void
+ixTimeSyncAccControlPpsmInterruptMaskSet(void)
+{
+	/* SET the ppsm bit */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_PPSM_MASK);
+} /* end of ixTimeSyncAccControlPpsmInterruptMaskSet() function */
+
+/* Get Auxiliary Master Mode Snapshot Interrupt Mask value */
+static inline u32
+ixTimeSyncAccControlAmmsInterruptMaskGet(void)
+{
+	/* Is the amms bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_AMMS_MASK);
+} /* end of ixTimeSyncAccControlAmmsInterruptMaskGet() function */
+
+/* Get Auxiliary Slave Mode Snapshot Interrupt  Mask value */
+static inline u32
+ixTimeSyncAccControlAsmsInterruptMaskGet(void)
+{
+	/* Is the asms bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_ASMS_MASK);
+} /* end of ixTimeSyncAccControlAsmsInterruptMaskGet() function */
+
+/* Get Target Time Interrupt Mask value */
+static inline u32
+ixTimeSyncAccControlTtmInterruptMaskGet(void)
+{
+	/* Is the ttm bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_TTM_MASK);
+} /* end of ixTimeSyncAccControlTtmInterruptMaskGet() function */
+
+/* Clarkspoint specific code */
+/* Get Auxiliary Target Time Interrupt Mask value */
+static inline u32
+ixTimeSyncAccControlAtmInterruptMaskGet(void)
+{
+	/* Is the atm bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_ATM_MASK);
+} /* end of ixTimeSyncAccControlAtmInterruptMaskGet() function */
+
+/* Get Pulse Per Second Interrupt Mask value */
+static inline u32
+ixTimeSyncAccControlPpsmInterruptMaskGet(void)
+{
+	/* Is the ppsm bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_PPSM_MASK);
+} /* end of ixTimeSyncAccControlPpsmInterruptMaskGet() function */
+
+/* Disable Auxiliary Master Mode Snapshot Interrupt */
+static inline void
+ixTimeSyncAccControlAmmsInterruptMaskClear(void)
+{
+	/* CLEAR the amms bit */
+	ICP_TIMESYNCACC_BIT_CLEAR(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_AMMS_MASK);
+} /* end of ixTimeSyncAccControlAmmsInterruptMaskClear() function */
+
+/* Disable Auxiliary Slave Mode Snapshot Interrupt */
+static inline void
+ixTimeSyncAccControlAsmsInterruptMaskClear(void)
+{
+	/* CLEAR the asms bit */
+	ICP_TIMESYNCACC_BIT_CLEAR(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_ASMS_MASK);
+} /* end of ixTimeSyncAccControlAsmsInterruptMaskClear() function */
+
+/* Disable Target Time Interrupt */
+static inline void
+ixTimeSyncAccControlTtmInterruptMaskClear(void)
+{
+	/* CLEAR the ttm bit */
+	ICP_TIMESYNCACC_BIT_CLEAR(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_TTM_MASK);
+} /* end of ixTimeSyncAccControlTtmInterruptMaskClear() function */
+
+/* Disable Target Time Interrupt */
+static inline void
+ixTimeSyncAccControlAtmInterruptMaskClear(void)
+{
+	/* CLEAR the atm bit */
+	ICP_TIMESYNCACC_BIT_CLEAR(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_ATM_MASK);
+} /* end of ixTimeSyncAccControlAtmInterruptMaskClear() function */
+
+/* Disable Pulse Per Second Interrupt */
+static inline void
+ixTimeSyncAccControlPpsmInterruptMaskClear(void)
+{
+	/* CLEAR the ppsm bit */
+	ICP_TIMESYNCACC_BIT_CLEAR(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_PPSM_MASK);
+} /* end of ixTimeSyncAccControlPpsmInterruptMaskClear() function */
+
+/* Reset Hardware Assist block */
+static inline void
+ixTimeSyncAccControlReset(void)
+{
+	/* SET the rst bit */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_RESET);
+	/* CLEAR the rst bit */
+	ICP_TIMESYNCACC_BIT_CLEAR(ixTsRegisters.blRegisters.tsControl,
+			ICP_TIMESYNCACC_TSC_RESET);
+} /* end of ixTimeSyncAccControlReset() function */
+
+/* Poll for Auxiliary Master Mode Snapshot Captured event */
+static inline u32
+ixTimeSyncAccEventAmmsFlagGet(void)
+{
+	/* Is the snm bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_SNM);
+} /* end of ixTimeSyncAccEventAmmsFlagGet() function */
+
+/* Poll for Auxiliary Slave Mode Snapshot Captured event */
+static inline u32
+ixTimeSyncAccEventAsmsFlagGet(void)
+{
+	/* Is the sns bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_SNS);
+} /* end of ixTimeSyncAccEventAsmsFlagGet() function */
+
+/* Poll for Target Time Reached event function */
+static inline u32
+ixTimeSyncAccEventTtmFlagGet(void)
+{
+	/* Is the ttipend bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_TTIPEND);
+} /* end of ixTimeSyncAccEventTtmFlagGet() function */
+
+/* Poll for Auxiliary Target Time Reached event function */
+static inline u32
+ixTimeSyncAccEventAtmFlagGet(void)
+{
+	/* Is the atp bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_ATP);
+} /* end of ixTimeSyncAccEventAtmFlagGet() function */
+
+/* Poll for Pulse Per Second Reached event function */
+static inline u32
+ixTimeSyncAccEventPpsmFlagGet(void)
+{
+	/* Is the ppsm bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_PPM);
+} /* end of ixTimeSyncAccEventPpsmFlagGet() function */
+
+/* Clear Auxiliary Master Mode Snapshot Captured event */
+static inline void
+ixTimeSyncAccEventAmmsFlagClear(void)
+{
+	/* CLEAR the snm bit by writing '1' onto it */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_SNM);
+} /* end of ixTimeSyncAccEventAmmsFlagClear() function */
+
+/* Clear Auxiliary Slave Mode Snapshot Captured event */
+static inline void
+ixTimeSyncAccEventAsmsFlagClear(void)
+{
+	/* CLEAR the sns bit by writing '1' onto it */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_SNS);
+} /* end of ixTimeSyncAccEventAsmsFlagClear() function */
+
+/* Clear Target Time Reached event */
+static inline void
+ixTimeSyncAccEventTtmFlagClear(void)
+{
+	/* CLEAR the ttipend bit by writing '1' onto it */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_TTIPEND);
+} /* end of ixTimeSyncAccEventTtmFlagClear() function */
+
+/* Clear Auxiliary Target Time Reached event */
+static inline void
+ixTimeSyncAccEventAtmFlagClear(void)
+{
+	/* CLEAR the atp bit by writing '1' onto it */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_ATP);
+} /* end of ixTimeSyncAccEventAtmFlagClear() function */
+
+/* Clear Pulse Per Second Time Reached event */
+static inline void
+ixTimeSyncAccEventPpsmFlagClear(void)
+{
+	/* CLEAR the pps bit by writing '1' onto it */
+	ICP_TIMESYNCACC_BIT_SET(ixTsRegisters.blRegisters.tsEvent,
+			ICP_TIMESYNCACC_TSE_PPM);
+} /* end of ixTimeSyncAccEventAtmFlagClear() function */
+
+/* Block level timestamp support functions definitions */
+
+/* Set System Time value */
+static inline void
+ixTimeSyncAccSystemTimeSnapshotSet(
+		u32 systemTimeLow,
+		u32 systemTimeHigh)
+{
+	/* Update the System Time Low Register contents */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.blRegisters.tsSysTimeLo,
+			systemTimeLow);
+	/* Update the System Time High Register contents */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.blRegisters.tsSysTimeHi,
+			systemTimeHigh);
+} /* end of ixTimeSyncAccSystemTimeSnapshotSet() function */
+
+/* Get System Time Low value */
+static inline void
+ixTimeSyncAccSystemTimeSnapshotGet(
+		u32 *systemTimeLow,
+		u32 *systemTimeHigh)
+{
+	/* Fetch the System Time Low Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsSysTimeLo,
+			systemTimeLow);
+	/* Fetch the System Time High Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsSysTimeHi,
+			systemTimeHigh);
+} /* end of ixTimeSyncAccSystemTimeSnapshotGet() function */
+
+/* Set Target Time value */
+static inline void
+ixTimeSyncAccTargetTimeSnapshotSet(
+		u32 targetTimeLow,
+		u32 targetTimeHigh)
+{
+	/* Update the Target Time Low Register contents */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.blRegisters.tsTrgtLo,
+			targetTimeLow);
+	/* Update the Target Time High Register contents */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.blRegisters.tsTrgtHi,
+			targetTimeHigh);
+} /* end of ixTimeSyncAccTargetTimeSnapshotSet() function */
+
+/* Get Target Time value */
+static inline void
+ixTimeSyncAccTargetTimeSnapshotGet(
+		u32 *targetTimeLow,
+		u32 *targetTimeHigh)
+{
+	/* Fetch the Target Time Low Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsTrgtLo,
+			targetTimeLow);
+	/* Fetch the Target Time High Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsTrgtHi,
+			targetTimeHigh);
+} /* end of ixTimeSyncAccTargetTimeSnapshotGet() function */
+
+/* Set Auxiliary Target Time value */
+static inline void
+ixTimeSyncAccAuxTargetTimeSnapshotSet(
+		u32 auxTargetTimeLow,
+		u32 auxTargetTimeHigh)
+{
+	/* Update the Auxiliary Target Time Low Register contents */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.blRegisters.tsATTSLo,
+			auxTargetTimeLow);
+	/* Update the Auxliliary Target Time High Register contents */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.blRegisters.tsATTSHi,
+			auxTargetTimeHigh);
+} /* end of ixTimeSyncAccAuxTargetTimeSnapshotSet() function */
+
+/* Get Auxiliary Target Time value */
+static inline void
+ixTimeSyncAccAuxTargetTimeSnapshotGet(
+		u32 *auxTargetTimeLow,
+		u32 *auxTargetTimeHigh)
+{
+	/* Fetch the Auxiliary Target Time Low Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsATTSLo,
+			auxTargetTimeLow);
+	/* Fetch the Auxiliary Target Time High Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsATTSHi,
+			auxTargetTimeHigh);
+} /* end of ixTimeSyncAccAuxTargetTimeSnapshotGet() function */
+
+/* Set Pulse Per Second Time value */
+	static inline void
+ixTimeSyncAccPulsePerSecondCompareSet(u32 ppsTime)
+{
+	/* Update the Pulse Per Second Compare Register contents */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.blRegisters.tsPpsCompare,
+					ppsTime);
+} /* end of ixTimeSyncAccPulsePerSecondCompareSet() function */
+
+/* Get Pulse Per Second Time value */
+	static inline void
+ixTimeSyncAccPulsePerSecondCompareGet(u32 *ppsTime)
+{
+	/* Fetch the Pulse Per Second Compare Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsPpsCompare,
+					ppsTime);
+} /* end of ixTimeSyncAccPulsePerSecondCompareGet() function */
+
+/* Set Frequency Scaling Value */
+	static inline void
+ixTimeSyncAccAddendFsvSet(u32 fsv)
+{
+	/* Update the Addend Register contents */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.blRegisters.tsAddend, fsv);
+} /* end of ixTimeSyncAccAddendFsvSet() function */
+
+/* Get Frequency Scaling Value */
+	static inline void
+ixTimeSyncAccAddendFsvGet(u32 *fsv)
+{
+	/* Fetch the Addend Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsAddend, fsv);
+} /* end of ixTimeSyncAccAddendFsvGet() function */
+
+/* Get AMMS value */
+static inline void
+ixTimeSyncAccAuxMasterModeSnapshotGet(
+		u32 *ammsLow,
+		u32 *ammsHigh)
+{
+	/* Fetch the Auxiliary Master Mode Snapshot Low Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsAMMSLo, ammsLow);
+	/* Fetch the Auxiliary Master Mode Snapshot High Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsAMMSHi, ammsHigh);
+} /* end of ixTimeSyncAccAuxMasterModeSnapshotGet() function */
+
+/* Get ASMS value */
+static inline void
+ixTimeSyncAccAuxSlaveModeSnapshotGet(
+		u32 *asmsLow,
+		u32 *asmsHigh)
+{
+	/* Fetch the Auxiliary Slave Mode Snapshot Low Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsASMSLo, asmsLow);
+	/* Fetch the Auxiliary Slave Mode Snapshot High Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.blRegisters.tsASMSHi, asmsHigh);
+} /* end of ixTimeSyncAccAuxSlaveModeSnapshotGet() function */
+
+/* Port level configuration support functions definitions */
+
+/* Reset PTP channel hardware */
+static inline void
+ixTimeSyncAccChannelReset(u32 ptpPort)
+{
+	/* SET the rst bit */
+	ICP_TIMESYNCACC_BIT_SET(
+		ixTsRegisters.plRegisters[ptpPort].tsChControl,
+		ICP_TIMESYNCACC_CC_CRST);
+	/* CLEAR the rst bit */
+	ICP_TIMESYNCACC_BIT_CLEAR(
+		ixTsRegisters.plRegisters[ptpPort].tsChControl,
+		ICP_TIMESYNCACC_CC_CRST);
+} /* end of ixTimeSyncAccControlReset() function */
+
+/* Set the channel mode to 1588 Master */
+static inline void
+ixTimeSyncAccControlPTPPortMasterModeSet(
+		u32 ptpPort, u32 masterMode)
+{
+	/* SET or CLEAR the Master Mode */
+	if (masterMode == true) {
+		/* SET the mm bit */
+		ICP_TIMESYNCACC_BIT_SET(
+			ixTsRegisters.plRegisters[ptpPort].tsChControl,
+			ICP_TIMESYNCACC_CC_MM);
+	} else {
+		/* CLEAR the mm bit */
+		ICP_TIMESYNCACC_BIT_CLEAR(
+			ixTsRegisters.plRegisters[ptpPort].tsChControl,
+			ICP_TIMESYNCACC_CC_MM);
+	}
+} /* end of ixTimeSyncAccControlPTPPortMasterModeSet() function */
+
+/* Check for 1588 master mode of channel */
+static inline u32
+ixTimeSyncAccControlPTPPortMasterModeGet(u32 ptpPort)
+{
+	/* Is the mm bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+		ixTsRegisters.plRegisters[ptpPort].tsChControl,
+		ICP_TIMESYNCACC_CC_MM);
+} /* end of ixTimeSyncAccControlPTPPortMasterModeGet() function */
+
+/* Set Timestamp all or only PTP messages flag */
+static inline void
+ixTimeSyncAccControlPTPPortPTPMsgTimestampSet(
+		u32 ptpPort, u32 allMsg)
+{
+	/* SET or CLEAR the All Message Timestamping */
+	if (allMsg == true) {
+		/* SET the ta bit */
+		ICP_TIMESYNCACC_BIT_SET(
+			ixTsRegisters.plRegisters[ptpPort].tsChControl,
+			ICP_TIMESYNCACC_CC_TA);
+	} else {
+		/* CLEAR the ta bit */
+		ICP_TIMESYNCACC_BIT_CLEAR(
+			ixTsRegisters.plRegisters[ptpPort].tsChControl,
+			ICP_TIMESYNCACC_CC_TA);
+	}
+} /* end of ixTimeSyncAccControlPTPPortPTPMsgTimestampSet() function */
+
+/* Check for Timestamp all or only PTP messages flag */
+	static inline u32
+ixTimeSyncAccControlPTPPortPTPMsgTimestampGet(u32 ptpPort)
+{
+	/* Is the ta bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.plRegisters[ptpPort].tsChControl,
+			ICP_TIMESYNCACC_CC_TA);
+} /* end of ixTimeSyncAccControlPTPPortPTPMsgTimestampGet() function */
+
+/* Port level timestamp support functions definitions */
+
+/* CAN Timestamp available */
+static inline u32
+ixTimeSyncAccControlPTPPortValFlagGet(u32 ptpPort)
+{
+	/* Is the valid bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.plRegisters[ptpPort].tsCANChEvent,
+			ICP_TIMESYNCACC_CE_VAL);
+} /* end of ixTimeSyncAccControlPTPPortValFlagGet() function */
+
+/* CAN Timestamp overrun */
+static inline u32
+ixTimeSyncAccControlPTPPortOvrFlagGet(u32 ptpPort)
+{
+	/* Is the ovr bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.plRegisters[ptpPort].tsCANChEvent,
+			ICP_TIMESYNCACC_CE_OVR);
+} /* end of ixTimeSyncAccControlPTPPortOvrFlagGet() function */
+
+/* Clear CAN Timestamp valid flag */
+static inline void
+ixTimeSyncAccControlPTPPortValFlagClear(u32 ptpPort)
+{
+	/* CLEAR the valid bit by writing '1' onto it */
+	ICP_TIMESYNCACC_REG_WRITE(
+		ixTsRegisters.plRegisters[ptpPort].tsCANChEvent,
+		ICP_TIMESYNCACC_CE_VAL);
+} /* end of ixTimeSyncAccControlPTPPortValFlagClear() function */
+
+/* Clear CAN Timestamp overrun flag */
+static inline void
+ixTimeSyncAccControlPTPPortOvrFlagClear(u32 ptpPort)
+{
+	/* CLEAR the overrun bit by writing '1' onto it */
+	ICP_TIMESYNCACC_REG_WRITE(
+		ixTsRegisters.plRegisters[ptpPort].tsCANChEvent,
+		ICP_TIMESYNCACC_CE_OVR);
+} /* end of ixTimeSyncAccControlPTPPortOvrFlagClear() function */
+
+/* Receive Timestamp available */
+static inline u32
+ixTimeSyncAccControlPTPPortRxsFlagGet(u32 ptpPort)
+{
+	/* Is the rxs bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.plRegisters[ptpPort].tsChEvent,
+			ICP_TIMESYNCACC_CE_RXS);
+} /* end of ixTimeSyncAccControlPTPPortRxsFlagGet() function */
+
+/* Transmit Timestamp available */
+static inline u32
+ixTimeSyncAccControlPTPPortTxsFlagGet(u32 ptpPort)
+{
+	/* Is the txs bit SET? */
+	return ICP_TIMESYNCACC_BIT_SET_CHECK(
+			ixTsRegisters.plRegisters[ptpPort].tsChEvent,
+			ICP_TIMESYNCACC_CE_TXS);
+} /* end of ixTimeSyncAccControlPTPPortTxsFlagGet() function */
+
+/* Clear Receive Timestamp available event */
+static inline void
+ixTimeSyncAccControlPTPPortRxsFlagClear(u32 ptpPort)
+{
+	/* CLEAR the rxs bit by writing '1' onto it */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.plRegisters[ptpPort].tsChEvent,
+			ICP_TIMESYNCACC_CE_RXS);
+} /* end of ixTimeSyncAccControlPTPPortRxsFlagClear() function */
+
+/* Clear Transmit Timestamp available event */
+static inline void
+ixTimeSyncAccControlPTPPortTxsFlagClear(u32 ptpPort)
+{
+	/* CLEAR the txs bit by writing '1' onto it */
+	ICP_TIMESYNCACC_REG_WRITE(ixTsRegisters.plRegisters[ptpPort].tsChEvent,
+			ICP_TIMESYNCACC_CE_TXS);
+} /* end of ixTimeSyncAccControlPTPPortTxsFlagClear() function */
+
+/* Get PTP CAN Port Timestamp value */
+static inline void
+ixTimeSyncAccPTPPortCANSnapshotGet(
+	u32 ptpPort,
+	u32 *rxsLow,
+	u32 *rxsHigh)
+{
+	/* Fetch the Receive Timestamp/Snapshot Low Register contents */
+	ICP_TIMESYNCACC_REG_READ(
+		ixTsRegisters.plRegisters[ptpPort].tsCANTxSnapLo, rxsLow);
+	/* Fetch the Receive Timestamp/Snapshot High Register contents */
+	ICP_TIMESYNCACC_REG_READ(
+		ixTsRegisters.plRegisters[ptpPort].tsCANTxSnapHi, rxsHigh);
+} /* end of ixTimeSyncAccPTPPortCANSnapshotGet() function */
+
+/* Get PTP Port Rx Timestamp value */
+static inline void
+ixTimeSyncAccPTPPortReceiveSnapshotGet(
+	u32 ptpPort,
+	u32 *rxsLow,
+	u32 *rxsHigh)
+{
+	/* Fetch the Receive Timestamp/Snapshot Low Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.plRegisters[ptpPort].tsRxSnapLo,
+			rxsLow);
+	/* Fetch the Receive Timestamp/Snapshot High Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.plRegisters[ptpPort].tsRxSnapHi,
+			rxsHigh);
+} /* end of ixTimeSyncAccPTPPortReceiveSnapshotGet() function */
+
+/* Get PTP Port Tx Timestamp value */
+static inline void
+ixTimeSyncAccPTPPortTransmitSnapshotGet(
+	u32 ptpPort,
+	u32 *txsLow,
+	u32 *txsHigh)
+{
+	/* Fetch the Transmit Timestamp/Snapshot Low Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.plRegisters[ptpPort].tsTxSnapLo,
+			txsLow);
+	/* Fetch the Transmit Timestamp/Snapshot High Register contents */
+	ICP_TIMESYNCACC_REG_READ(ixTsRegisters.plRegisters[ptpPort].tsTxSnapHi,
+			txsHigh);
+} /* end of ixTimeSyncAccPTPPortTransmitSnapshotGet() function */
+
+/* Get UUID High (16-bit value) & Sequence ID (16-bit value) of PTP message */
+static inline void
+ixTimeSyncAccPTPMsgUuidSeqIdGet(
+	u32 ptpPort,
+	u32 *uuidLow,
+	u16 *uuidHigh,
+	u16 *seqId)
+{
+	/* Local variables */
+	u32 seqIdUuidHigh = 0;
+
+	/* Fetch the UUID Low Register contents */
+	ICP_TIMESYNCACC_REG_READ(
+		ixTsRegisters.plRegisters[ptpPort].tsSrcUUIDLo, uuidLow);
+	/* Fetch the Sequence ID and Source UUID High Register contents */
+	ICP_TIMESYNCACC_REG_READ(
+		ixTsRegisters.plRegisters[ptpPort].tsSrcUUIDHi,
+		&seqIdUuidHigh);
+
+	*seqId    = (seqIdUuidHigh >> ICP_TIMESYNCACC_SID_LOC);
+	*uuidHigh = (ICP_TIMESYNCACC_LSB_SHORT_MASK & seqIdUuidHigh);
+} /* end of ixTimeSyncAccPTPMsgUuidHighSeqIdGet() function */
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @typedef IxTimeSyncAccTargetTimeCallback
+ * @brief Callback for use by target time stamp interrupt
+ */
+typedef void (*IxTimeSyncAccTargetTimeCallback)(
+		IxTimeSyncAccTimeValue targetTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @typedef IxTimeSyncAccAuxTimeCallback
+ * @brief Callback for use by auxiliary time interrupts
+ */
+typedef void (*IxTimeSyncAccAuxTimeCallback)(IxTimeSyncAccAuxMode auxMode,
+		IxTimeSyncAccTimeValue auxTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @typedef IxTimeSyncAccAuxTargetTimeCallback
+ * @brief Callback for use by auxiliary target time stamp interrupt
+ */
+typedef void (*IxTimeSyncAccAuxTargetTimeCallback)(
+		IxTimeSyncAccTimeValue auxTargetTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @typedef IxTimeSyncAccPulsePerSecondCallback
+ * @brief Callback for use by pulse per second interrupt
+ */
+typedef void (*IxTimeSyncAccPulsePerSecondCallback)(u32 pulsePerSecond);
+
+/* Section for prototypes interface functions */
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccBlPlBaseAddressesSet(
+ * 2 RegsVirtualBaseAddr)
+ * @brief Sets virtual addresses for 1588 hardware registers.
+ * @param RegsVirtualBaseAddr [in] - register virtual address
+ * This API will set the virtual starting adresses for the 1588
+ * hardware registers.
+ * @li Re-entrant   : Yes
+ * @li ISR Callable : No
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Invalid parameters passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccBlPlBaseAddressesSet(u32 RegsVirtualBaseAddr);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccPTPPortConfigSet(
+ * TimeSyncAcc1588PTPPort ptpPort,
+ * TimeSyncAcc1588PTPPortMode ptpPortMode)
+ * @brief Configures the IEEE 1588 message detect on particular PTP port.
+ * @param ptpPort [in] - PTP port to config
+ * @param ptpPortMode [in]- Port to operate in Master or Slave mode
+ * This API will enable the time stamping on a particular PTP port.
+ * @li Re-entrant   : No
+ * @li ISR Callable : No
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Invalid parameters passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPPortConfigSet(IxTimeSyncAcc1588PTPPort ptpPort,
+		IxTimeSyncAcc1588PTPPortMode ptpPortMode);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccPTPPortConfigGet(
+ * TimeSyncAcc1588PTPPort ptpPort,
+ * TimeSyncAcc1588PTPPortMode *ptpPortMode)
+ * @brief Retrieves IEEE 1588 PTP operation mode on particular PTP port.
+ * @param ptpPort [in] - PTP port
+ * @param ptpPortMode [in]- Mode of operation of PTP port (Master or Slave)
+ * This API will identify the time stamping capability of a PTP port by means
+ * of obtaining its mode of operation.
+ * @li Re-entrant   : No
+ * @li ISR Callable : No
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Invalid parameters passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPPortConfigGet(IxTimeSyncAcc1588PTPPort ptpPort,
+		IxTimeSyncAcc1588PTPPortMode *ptpPortMode);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccPTPRxPoll(
+ * TimeSyncAcc1588PTPPort ptpPort,
+ * TimeSyncAccPtpMsgData  *ptpMsgData)
+ * @brief Polls the IEEE 1588 message/time stamp detect status on a particular
+ * PTP Port on the Receive side.
+ * @param ptpPort [in] - PTP port to poll
+ * @param ptpMsgData [out] - Current TimeStamp and other Data
+ * This API will poll for the availability of a time stamp on the received Sync
+ * (Slave) or Delay_Req (Master) messages.
+ * The client application will provide the buffer.
+ * @li Re-entrant   : No
+ * @li ISR Callable : No
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Invalid parameters passed
+ *         @li ICP_TIMESYNCACC_NOTIMESTAMP - No time stamp available
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPRxPoll(IxTimeSyncAcc1588PTPPort ptpPort,
+		IxTimeSyncAccPtpMsgData  *ptpMsgData);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccPTPTxPoll(
+ * TimeSyncAcc1588PTPPort ptpPort,
+ * TimeSyncAccPtpMsgData  *ptpMsgData)
+ * @brief Polls the IEEE 1588 message/time stamp detect status on a particular
+ * PTP Port on the Transmit side.
+ * @param ptpPort [in] - PTP port to poll
+ * @param ptpMsgData [out] - Current TimeStamp and other Data
+ * This API will poll for the availability of a time stamp on the transmitted
+ * Sync (Master) or Delay_Req (Slave) messages.
+ * The client application will provide the buffer.
+ * @li Re-entrant   : No
+ * @li ISR Callable : No
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Invalid parameters passed
+ *         @li ICP_TIMESYNCACC_NOTIMESTAMP - No time stamp available
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPTxPoll(IxTimeSyncAcc1588PTPPort ptpPort,
+		IxTimeSyncAccPtpMsgData  *ptpMsgData);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccSystemTimeSet(
+ IxTimeSyncAccTimeValue systemTime)
+ * @brief Sets the System Time in the IEEE 1588 hardware assist block
+ * @param systemTime [in] - Value to set System Time
+ * This API will set the SystemTime to given value.
+ * @li Re-entrant   : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccSystemTimeSet(IxTimeSyncAccTimeValue systemTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccSystemTimeGet(
+ * TimeSyncAccTimeValue *systemTime)
+ * @brief Gets the System Time from the IEEE 1588 hardware assist block
+ * @param systemTime [out] - Copy the current System Time into the client
+ * application provided buffer
+ * This API will get the SystemTime from IEEE1588 block and return to client
+ * @li Re-entrant   : no
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Invalid parameters passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccSystemTimeGet(IxTimeSyncAccTimeValue *systemTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccTickRateSet(u32 tickRate)
+ * @brief Sets the Tick Rate (Frequency Scaling Value) in the IEEE 1588
+ * hardware assist block
+ * @param tickRate [in] - Value to set Tick Rate
+ * This API will set the Tick Rate (Frequency Scaling Value) in the IEEE
+ * 1588 block to the given value. The Accumulator register (not client
+ * visible) is incremented by this TickRate value every clock cycle. When
+ * the Accumulator overflows, the SystemTime is incremented by one. This
+ * TickValue can therefore be used to adjust the system timer.
+ * @li Re-entrant   : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTickRateSet(u32 tickRate);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccTickRateGet(u32 *tickRate)
+ * @brief Gets the Tick Rate (Frequency Scaling Value) from the IEEE 1588
+ * hardware assist block
+ * @param tickRate [out] - Current Tick Rate value in the IEEE 1588 block
+ * This API will get the TickRate on IEE15588 block. Refer to @ref
+ * ixTimeSyncAccTickRateSet for notes on usage of this value.
+ * @li   Reentrant    : yes
+ * @li   ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Invalid parameters passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTickRateGet(u32 *tickRate);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccTargetTimeInterruptEnable(
+ * IxTimeSyncAccTargetTimeCallback targetTimeCallback)
+ * @brief Enables the interrupt to verify the condition where the System Time
+ * greater or equal to the Target Time in the IEEE 1588 hardware assist block.
+ * If the condition is true an interrupt will be sent to Intel XScale(R) Core.
+ * @param targetTimeCallback [in] - Callback to be invoked when interrupt fires
+ * This API will enable the Target Time reached/hit condition interrupt.
+ * NOTE: The client application needs to ensure that the APIs
+ * @ref ixTimeSyncAccTargetTimeInterruptEnable, @ref ixTimeSyncAccTargetTimeSet
+ * and
+ * @ref ixTimeSyncAccTargetTimeInterruptDisable are accessed in mutual
+ * exclusive manner with respect to each other.
+ * @li Re-entrant   : no
+ * @li ISR Callable : yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed for
+ *          callback
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimeInterruptEnable(
+	IxTimeSyncAccTargetTimeCallback targetTimeCallback);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccTargetTimeInterruptDisable(void)
+ * @brief Disables the interrupt for the condition explained in the function
+ * description of @ref ixTimeSyncAccTargetTimeInterruptEnable.
+ * This API will disable the Target Time interrupt.
+ * NOTE: The client application needs to ensure that the APIs
+ * @ref ixTimeSyncAccTargetTimeInterruptEnable,
+ * @ref ixTimeSyncAccTargetTimeSet and
+ * @ref ixTimeSyncAccTargetTimeInterruptDisable are accessed in mutual
+ * exclusive manner with respect to each other.
+ * @li Re-entrant   : no
+ * @li ISR Callable : yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimeInterruptDisable(void);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccTargetTimePoll(u32 *ttmPollFlag,
+ * IxTimeSyncAccTimeValue *targetTime)
+ * @brief Poll to verify the condition where the System Time greater or equal
+ * to the Target Time in the IEEE 1588 hardware assist block. If the condition
+ * is true an event flag is set in the hardware.
+ * @param ttmPollFlag [out] - TRUE  if the target time reached/hit condition
+ *				    event is set
+ *                            FALSE if the target time reached/hit condition
+ * 				    event is not set
+ * @param targetTime [out] - Capture current targetTime into client provided
+ * buffer Poll the target time reached/hit condition status. Return true and
+ * the current target time value, if the condition is true else return false.
+ * @note The client application will need to clear the event flag that will be
+ * set as long as the condition that the System Time greater or equal to the
+ * Target Time is valid, in one of the following ways:
+ *     1) Invoke the API to change the target time
+ *     2) Change the system timer value
+ * @li Re-entrant   : Yes
+ * @li ISR Callable : No
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ *         @li ICP_TIMESYNCACC_INTERRUPTMODEINUSE - Interrupt mode in use
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimePoll(u32 *ttmPollFlag,
+		IxTimeSyncAccTimeValue *targetTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccTargetTimeSet(
+ * IxTimeSyncAccTimeValue targetTime)
+ * @brief Sets the Target Time in the IEEE 1588 hardware assist block
+ * @param targetTime [in] - Value to set Target Time
+ * This API will set the Target Time to a given value.
+ * NOTE: The client application needs to ensure that the APIs
+ * @ref ixTimeSyncAccTargetTimeInterruptEnable,
+ * @ref ixTimeSyncAccTargetTimeSet and
+ * @ref ixTimeSyncAccTargetTimeInterruptDisable are accessed in mutual
+ * exclusive manner with respect to each other.
+ * @li   Reentrant    : no
+ * @li   ISR Callable : yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimeSet(IxTimeSyncAccTimeValue targetTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccTargetTimeGet(
+ IxTimeSyncAccTimeValue *targetTime)
+ * @brief Gets the Target Time in the IEEE 1588 hardware assist block
+ * @param targetTime [out] - Copy current time to client provided buffer
+ * This API will get the Target Time from IEEE 1588 block and return to the
+ * client application
+ * @li Re-entrant   : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccTargetTimeGet(IxTimeSyncAccTimeValue *targetTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccAuxTimeInterruptEnable(
+ * IxTimeSyncAccAuxMode auxMode,
+ * IxTimeSyncAccAuxTimeCallback auxTimeCallback)
+ * @brief Enables the interrupt notification for the given mode of Auxiliary
+ * Time Stamp in the IEEE 1588 hardware assist block.
+ * @param auxMode [in] - Auxiliary time stamp register (slave or master) to use
+ * @param auxTimeCallback [in] - Callback to be invoked when interrupt fires
+ * This API will enable the Auxiliary Master/Slave Time stamp Interrupt.
+ * <pre>
+ * NOTE: An individual callback is to be registered for each Slave and Master
+ * Auxiliary Time Stamp registers. Thus to register for both Master and Slave
+ * time stamp interrupts either the same callback or two separate callbacks
+ * the API has to be invoked twice.
+ * </pre>
+ * @li Re-entrant   : no
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed for
+ *          callback or invalid auxiliary snapshot mode
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTimeInterruptEnable(IxTimeSyncAccAuxMode auxMode,
+		IxTimeSyncAccAuxTimeCallback auxTimeCallback);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccAuxTimeInterruptDisable(
+ * IxTimeSyncAccAuxMode auxMode)
+ * @brief Disables the interrupt for the indicated mode of Auxiliary Time Stamp
+ * in the IEEE 1588 hardware assist block
+ * @param auxMode [in] - Auxiliary time stamp mode (slave or master) using
+ * which the interrupt will be disabled.
+ * This API will disable the Auxiliary Time Stamp Interrupt (Master or Slave)
+ * @li Re-entrant   : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Invalid parameters passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTimeInterruptDisable(IxTimeSyncAccAuxMode auxMode);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccAuxTimePoll(
+ * IxTimeSyncAccAuxMode auxMode,
+ * u32 *auxPollFlag,
+ * IxTimeSyncAccTimeValue *auxTime)
+ * @brief Poll for the Auxiliary Time Stamp captured for the mode indicated
+ * (Master or Slave)
+ * @param auxMode [in] - Auxiliary Snapshot Register (Slave or Master) to
+ * be checked
+ * @param auxPollFlag [out] - TRUE if the time stamp captured in auxiliary
+ * snapshot register
+ *                            FALSE if the time stamp not captured in
+ * auxiliary snapshot register
+ * @param auxTime [out] - Copy the current Auxiliary Snapshot Register value
+ * into the client provided buffer
+ * Polls for the Time stamp in the appropriate Auxiliary Snapshot Registers
+ * based on the mode specified. Return true and the contents of the Auxiliary
+ * snapshot, if it is available else return false.
+ * @li Re-entrant   : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed for
+ *         auxPollFlag, callback or invalid auxiliary snapshot mode
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ *         @li ICP_TIMESYNCACC_INTERRUPTMODEINUSE - Interrupt mode in use
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTimePoll(IxTimeSyncAccAuxMode auxMode,
+		u32 *auxPollFlag,
+		IxTimeSyncAccTimeValue *auxTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccReset(void)
+ * @brief Resets the IEEE 1588 hardware assist block
+ * Sets the reset bit in the IEEE1588 silicon which fully resets the silicon
+ * block.
+ * @li Reentrant    : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED  - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccReset(void);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccChnlReset(
+ * IxTimeSyncAcc1588PTPPort ptpPort)
+ * @brief Resets the IEEE 1588 hardware for a single channel
+ * @param ptpPort [in] - Port which is to be reset
+ * Sets the reset bit in the IEEE1588 silicon which fully resets the channel
+ * @li Reentrant    : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED  - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccChnlReset(IxTimeSyncAcc1588PTPPort ptpPort);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccStatsGet(IxTimeSyncAccStats
+ *                              *timeSyncStats)
+ * @brief Returns the IxTimeSyncAcc Statistics in the client supplied buffer
+ * @param timeSyncStats [out] - TimeSync statistics counter values
+ * This API will return the statistics of the received or transmitted messages.
+ * NOTE: 1) These counters are updated only when the client polls for the time
+ * stamps or interrupt are enabled. This is because the IxTimeSyncAcc module
+ * does not either transmit or receive messages and does only run the code
+ * when explicit requests received by client application.
+ *       2) These statistics reflect the number of valid PTP messages exchanged
+ * in Master and Slave modes but includes all the messages (including valid
+ * non-PTP messages) while operating in the Any mode.
+ * @li Reentrant    : no
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - NULL parameter passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccStatsGet(IxTimeSyncAccStats *timeSyncStats);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn void ixTimeSyncAccStatsReset(void)
+ * @brief Reset Time Sync statistics
+ * This API will reset the statistics counters of the TimeSync access layer.
+ * @li Reentrant    : yes
+ * @li ISR Callable:  no
+ * @return @li None
+ */
+static void
+ixTimeSyncAccStatsReset(void);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccShow(void)
+ * @brief Displays the Time Sync current status
+ * This API will display status on the current configuration of the IEEE
+ * 1588 hardware assist block, contents of the various time stamp registers,
+ * outstanding interrupts and/or events.
+ * Note that this is intended for debug only, and in contrast to the other
+ * functions, it does not clear the any of the status bits associated with
+ * active timestamps and so is passive in its nature.
+ * @li Reentrant    : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccShow(void);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccAuxTargetTimeInterruptEnable(
+ * IxTimeSyncAccAuxTargetTimeCallback auxTargetTimeCallback)
+ * @brief Enables the interrupt to verify the condition where the System Time
+ * greater or equal to the Auxiliary Target Time in the IEEE 1588 hardware
+ * assist block. If the condition is true an interrupt will be sent to
+ * Intel XScale(R) Core.
+ * @param auxTargetTimeCallback [in] - Callback to be invoked when interrupt
+ * fires.
+ * This API will enable the Auxiliary Target Time reached/hit condition
+ * interrupt.
+ * NOTE: The client application needs to ensure that the APIs
+ * @ref ixTimeSyncAccAuxTargetTimeInterruptEnable and
+ * @ref ixTimeSyncAccAuxTargetTimeInterruptDisable are accessed in mutual
+ * exclusive manner with respect to each other.
+ * @li Re-entrant   : no
+ * @li ISR Callable : yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed
+ *          for callback
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimeInterruptEnable(
+	IxTimeSyncAccAuxTargetTimeCallback auxTargetTimeCallback);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccAuxTargetTimeInterruptDisable(void)
+ * @brief Disables the interrupt for the condition explained in the function
+ * description of @ref ixTimeSyncAccAuxTargetTimeInterruptEnable.
+ * This API will disable the Auxiliary Target Time interrupt.
+ * NOTE: The client application needs to ensure that the APIs
+ * @ref ixTimeSyncAccAuxTargetTimeInterruptEnable and
+ * @ref ixTimeSyncAccAuxTargetTimeInterruptDisable are accessed in mutual
+ * exclusive manner with respect to each other.
+ * @li Re-entrant   : no
+ * @li ISR Callable : yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimeInterruptDisable(void);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccAuxTargetTimePoll(
+ * u32 *atmPollFlag,
+ * IxTimeSyncAccTimeValue *auxTargetTime)
+ * @brief Poll to verify the condition where the System Time greater or equal
+ * to the Auxiliary Target Time in the IEEE 1588 hardware assist block. If
+ * the condition is true an event flag is set in the hardware.
+ * @param atmPollFlag [out] - TRUE  if the auxiliary target time reached/hit
+ * condition event set
+ *                            FALSE if the auxiliary target time reached/hit
+ * condition event is not set
+ * @param auxTargetTime [out] - Capture current auxTargetTime into client
+ * provided buffer Poll the auxiliary target time reached/hit condition
+ * status. Return true and the current auxiliary target time value, if the
+ * condition is true else return false.
+ * NOTE: The client application will need to clear the event flag that will
+ * be set as long as the condition that the System Time greater or equal to
+ * the Auxiliary Target Time is valid, in one of the following ways:
+ *     1) Invoke the API to change the target time
+ *     2) Change the system timer value
+ * @li Re-entrant   : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ *         @li ICP_TIMESYNCACC_INTERRUPTMODEINUSE - Interrupt mode in use
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimePoll(
+	u32 *atmPollFlag, IxTimeSyncAccTimeValue *auxTargetTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccAuxTargetTimeSet(
+ * IxTimeSyncAccTimeValue auxTargetTime)
+ * @brief Sets the Auxiliary Target Time in the IEEE 1588 hardware assist block
+ * @param auxTargetTime [in] - Value to set Auxiliary Target Time
+ * This API will set the Auxiliary Target Time to a given value.
+ * @note The client application needs to ensure that the APIs
+ * @ref ixTimeSyncAccAuxTargetTimeInterruptEnable(),
+ * @ref ixTimeSyncAccAuxTargetTimeSet() and
+ * @ref ixTimeSyncAccAuxTargetTimeInterruptDisable() are accessed in
+ * mutual exclusive manner with respect to each other.
+ * @li   Reentrant    : No
+ * @li   ISR Callable : Yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimeSet(IxTimeSyncAccTimeValue auxTargetTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccAuxTargetTimeGet(
+ * IxTimeSyncAccTimeValue *auxTargetTime)
+ * @brief Gets the Auxiliary Target Time in the IEEE 1588 hardware assist block
+ * @param auxTargetTime [out] - Copy current time to client provided buffer
+ * This API will get the Auxiliary Target Time from IEEE 1588 block and return
+ * to the client application
+ * @li Re-entrant   : Yes
+ * @li ISR Callable : No
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccAuxTargetTimeGet(IxTimeSyncAccTimeValue *auxTargetTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccPulsePerSecondInterruptEnable(
+ * IxTimeSyncAccPulsePerSecondCallback pulsePerSecondCallback)
+ * @brief Enables the interrupt to verify the condition where the Pulse Per
+ * Second Compare register indicates a match in the IEEE 1588 hardware assist
+ * block. If the condition is true an interrupt will be sent to
+ * Intel XScale(R) Core.
+ * @param pulsePerSecondCallback [in] - Callback to be invoked when interrupt
+ * fires.
+ * This API will enable the Pulse Per Second reached/hit condition interrupt.
+ * NOTE: The client application needs to ensure that the APIs
+ * @ref ixTimeSyncAccPulsePerSecondInterruptEnable and
+ * @ref ixTimeSyncAccPulsePerSecondInterruptDisable are accessed in mutual
+ * exclusive manner with respect to each other.
+ * @li Re-entrant   : no
+ * @li ISR Callable : yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed for callback
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPulsePerSecondInterruptEnable(
+	IxTimeSyncAccPulsePerSecondCallback pulsePerSecondCallback);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccPulsePerSecondInterruptDisable(void)
+ * @brief Disables the interrupt for the condition explained in the function
+ * description of @ref ixTimeSyncAccPulsePerSecondInterruptEnable.
+ * This API will disable the Pulse Per Second interrupt.
+ * NOTE: The client application needs to ensure that the APIs
+ * @ref ixTimeSyncAccPulsePerSecondInterruptEnable and
+ * @ref ixTimeSyncAccPulsePerSecondInterruptDisable are accessed in mutual
+ * exclusive manner with respect to each other.
+ * @li Re-entrant   : no
+ * @li ISR Callable : yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPulsePerSecondInterruptDisable(void);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccPulsePerSecondTimeGet(u32 *ppsTime)
+ * @brief Gets the Pulse Per Second Time in the IEEE 1588 hardware assist block
+ * @param ppsTime [out] - Copy current time to client provided buffer
+ * This API will get the PPS Time from IEEE 1588 block and return to the
+ * client application
+ * @li Re-entrant   : yes
+ * @li ISR Callable : no
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Null parameter passed
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPulsePerSecondTimeGet(u32 *ppsTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccPulsePerSecondTimeSet(u32 ppsTime)
+ * @brief Sets the Pulse Per Second Time in the IEEE 1588 hardware assist block
+ * @param ppsTime [in] - Value to set PPS Time
+ * This API will set the Pulse Per Second Time to a given value.
+ * NOTE: The client application needs to ensure that the APIs
+ * @ref ixTimeSyncAccPulsePerSecondInterruptEnable,
+ * @ref ixTimeSyncAccPulsePerSecondTimeSet and
+ * @ref ixTimeSyncAccPulsePerSecondInterruptDisable are accessed
+ * in mutual exclusive manner with respect to each other.
+ * @li   Reentrant    : no
+ * @li   ISR Callable : yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPulsePerSecondTimeSet(u32 ppsTime);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccPTPCANPoll(
+ * IxTimeSyncAcc1588PTPPort ptpPort,
+ * IxTimeSyncAccTimeValue *ptpTimeStamp)
+ * @brief Polls the IEEE 1588 message/time stamp detect status on a particular
+ * CAN PTP Port.
+ * @param ptpPort [in] - PTP port to poll
+ * @param ptpTimeStamp [out] - Current TimeStamp
+ * This API will poll for the availability of a time stamp on a CAN port.
+ * The client application will provide the buffer.
+ * @li Re-entrant   : No
+ * @li ISR Callable : No
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_INVALIDPARAM - Invalid parameters passed
+ *         @li ICP_TIMESYNCACC_NOTIMESTAMP - No time stamp available
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus
+ixTimeSyncAccPTPCANPoll(
+	IxTimeSyncAcc1588PTPPort ptpPort,
+	IxTimeSyncAccTimeValue *ptpTimeStamp);
+
+/*
+ * @ingroup IxTimeSyncAcc
+ * @fn IxTimeSyncAccStatus ixTimeSyncAccIsr(void)
+ * @brief Processes 1588 interrupt events.
+ * This API will process interrupt events.
+ * @li Re-entrant   : no
+ * @li ISR Callable : yes
+ * @return @li ICP_TIMESYNCACC_SUCCESS - Operation is successful
+ *         @li ICP_TIMESYNCACC_FAILED - Internal error occurred
+ */
+static IxTimeSyncAccStatus ixTimeSyncAccIsr(void);
+static int timesync_open(struct inode *inode, struct file *filp);
+static int timesync_release(struct inode *inode, struct file *filp);
+static int timesync_ioctl(struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg);
+static void timesync_close(void);
+static int pci_probe(struct pci_dev *dev, const struct pci_device_id *id);
+static void pci_remove(struct pci_dev *dev);
+static irqreturn_t timesync_isr(int irq, void *dev_id);
+
+static int disable_interrupts(void);
+
+/* interrupt event flags */
+static u32 ixTimeSyncAccEventAmmsFlagGet(void);
+static u32 ixTimeSyncAccEventAsmsFlagGet(void);
+static u32 ixTimeSyncAccEventAtmFlagGet(void);
+static u32 ixTimeSyncAccEventPpsmFlagGet(void);
+static u32 ixTimeSyncAccEventTtmFlagGet(void);
+
+/* HAL callback function prototypes */
+static void TargTimeCallback(IxTimeSyncAccTimeValue targetTime);
+static void AuxTimeCallback(IxTimeSyncAccAuxMode auxMode,
+				IxTimeSyncAccTimeValue auxTime);
+static void AuxTargetTimeCallback(IxTimeSyncAccTimeValue auxTargetTime);
+static void PulsePerSecondCallback(u32 pulsePerSecond);
+
+#endif /* __TOLAPAI_1588_H__ */
-- 
1.6.0.2.GIT

