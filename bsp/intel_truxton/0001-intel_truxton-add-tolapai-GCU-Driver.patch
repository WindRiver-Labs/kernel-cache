From 8e246197b76aafe331398182e66b515bde704300 Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Thu, 18 Dec 2008 16:11:56 +0800
Subject: [PATCH] intel_truxton: add tolapai GCU Driver

Add GCU(Global Configuration Unit) driver for Intel Truxton. This unit
implements an MDIO interface to support the E1000 net interfaces. If want to
use E1000 net driver, must select the driver.

It is distilled from GCU driver included in Intel-provided SDK V0.7.18 for
Intel Truxton.

Signed-off-by: Li Wang <li.wang@windriver.com>
---
 drivers/misc/Kconfig        |    8 +
 drivers/misc/Makefile       |    1 +
 drivers/misc/gcu/Makefile   |   35 +++++
 drivers/misc/gcu/gcu.h      |   94 ++++++++++++
 drivers/misc/gcu/gcu_if.c   |  291 +++++++++++++++++++++++++++++++++++++
 drivers/misc/gcu/gcu_if.h   |   49 ++++++
 drivers/misc/gcu/gcu_main.c |  339 +++++++++++++++++++++++++++++++++++++++++++
 drivers/misc/gcu/gcu_reg.h  |   67 +++++++++
 8 files changed, 884 insertions(+), 0 deletions(-)
 create mode 100644 drivers/misc/gcu/Makefile
 create mode 100644 drivers/misc/gcu/gcu.h
 create mode 100644 drivers/misc/gcu/gcu_if.c
 create mode 100644 drivers/misc/gcu/gcu_if.h
 create mode 100644 drivers/misc/gcu/gcu_main.c
 create mode 100644 drivers/misc/gcu/gcu_reg.h

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index f0202ee..191764b 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -488,4 +488,12 @@ config SGI_GRU_DEBUG
 	This option enables addition debugging code for the SGI GRU driver. If
 	you are unsure, say N.
 
+config TOLAPAI_GCU
+	tristate "Tolapai Global Configuration Unit"
+	depends on X86 && PCI
+	---help---
+	  This is a driver for Intel Tolapai Global Configuration Unit which
+	  implements configuration space registers for system-level. If you have
+	  a Tolapai SOC, say Y or M here.
+
 endif # MISC_DEVICES
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index b6167e7..ce739a7 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -31,3 +31,4 @@ obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
+obj-$(CONFIG_TOLAPAI_GCU)	+= gcu/
diff --git a/drivers/misc/gcu/Makefile b/drivers/misc/gcu/Makefile
new file mode 100644
index 0000000..7f7ea93
--- /dev/null
+++ b/drivers/misc/gcu/Makefile
@@ -0,0 +1,35 @@
+################################################################################
+#
+# Intel PRO/1000 Linux driver
+# Copyright(c) 1999 - 2006 Intel Corporation.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Linux NICS <linux.nics@intel.com>
+# e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
+# Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+#
+################################################################################
+
+#
+# Makefile for the Tolapai GCU
+#
+
+obj-$(CONFIG_E1000) += gcu.o
+
+gcu-objs := gcu_main.o gcu_if.o
diff --git a/drivers/misc/gcu/gcu.h b/drivers/misc/gcu/gcu.h
new file mode 100644
index 0000000..7f8864a
--- /dev/null
+++ b/drivers/misc/gcu/gcu.h
@@ -0,0 +1,94 @@
+/*****************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+ version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+*****************************************************************************/
+
+/* Linux GCU Driver main header file */
+
+#ifndef __GCU_H__
+#define __GCU_H__
+
+#include <linux/stddef.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/bitops.h>
+#include <linux/slab.h>
+#include <linux/reboot.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+
+#define BAR_0	0
+
+#define INTEL_GCU_DEVICE(device_id) {\
+	PCI_DEVICE(PCI_VENDOR_ID_INTEL, device_id)}
+
+#define GCU_DEV_NAME_SIZE 16
+
+#ifdef DBG
+#define GCU_DBG(args...) printk(KERN_DEBUG "gcu: " args)
+#else
+#define GCU_DBG(args...)
+#endif
+
+#define GCU_ERR(args...) printk(KERN_ERR "gcu: " args)
+
+struct gcu_adapter {
+	struct pci_dev *pdev;
+	u32 mem_start;
+	u32 mem_end;
+	u32 base_addr;
+	u8 *hw_addr;
+	char name[GCU_DEV_NAME_SIZE];
+	u32 pci_state[16];
+	u16 device_id;
+	u16 vendor_id;
+	u16 subsystem_id;
+	u16 subsystem_vendor_id;
+	u16 pci_cmd_word;
+	u8 revision_id;
+	/* open/release and usage marking */
+	struct module *owner;
+};
+
+/*
+ * Exported interface functions need access to the modules
+ * gcu_adapter struct
+ */
+const struct gcu_adapter *gcu_get_adapter(void);
+void gcu_release_adapter(const struct gcu_adapter **adapter);
+
+#endif /* __GCU_H__ */
diff --git a/drivers/misc/gcu/gcu_if.c b/drivers/misc/gcu/gcu_if.c
new file mode 100644
index 0000000..551fa06
--- /dev/null
+++ b/drivers/misc/gcu/gcu_if.c
@@ -0,0 +1,291 @@
+/*****************************************************************************
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+  version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+*****************************************************************************/
+
+/*
+ * gcu_if.c
+ * Shared functions for accessing and configuring the GCU
+ */
+
+#include "gcu.h"
+#include "gcu_reg.h"
+#include "gcu_if.h"
+
+#ifdef DBG
+/* forward declaration for write verify used in gcu_write_eth_phy */
+static int gcu_write_verify(u32 phy_num, u32 reg_addr, u16 written_data,
+				const struct gcu_adapter *adapter);
+#endif
+
+/*
+ * gcu_write_eth_phy
+ * @phy_num: phy we want to write to, either 0, 1, or 2
+ * @reg_addr: address in PHY's register space to write to
+ * @phy_data: data to be written
+ * interface function for other modules to access the GCU
+ */
+int
+gcu_write_eth_phy(u32 phy_num, u32 reg_addr, u16 phy_data)
+{
+	const struct gcu_adapter *adapter;
+	u32 data = 0;
+	u32 timeoutCounter = 0;
+	const u32 timeoutCounterMax = GCU_MAX_ATTEMPTS;
+	u32 complete;
+
+	GCU_DBG("%s\n", __func__);
+
+	if (phy_num > MDIO_COMMAND_PHY_ADDR_MAX) {
+		GCU_ERR("phy_num = %d, which is greater than "
+				"MDIO_COMMAND_PHY_ADDR_MAX\n", phy_num);
+		return -1;
+	}
+
+	if (reg_addr > MDIO_COMMAND_PHY_REG_MAX) {
+		GCU_ERR("reg_addr = %d, which is greater than "
+				"MDIO_COMMAND_PHY_REG_MAX\n", phy_num);
+		return -1;
+	}
+
+	/* format the data to be written to the MDIO_COMMAND_REG */
+	data = phy_data;
+	data |= (reg_addr << MDIO_COMMAND_PHY_REG_OFFSET);
+	data |= (phy_num << MDIO_COMMAND_PHY_ADDR_OFFSET);
+	data |= MDIO_COMMAND_OPER_MASK | MDIO_COMMAND_GO_MASK;
+
+	/*
+	 * get_gcu_adapter contains a spinlock, this may pause for a bit
+	 */
+	adapter = gcu_get_adapter();
+	if (!adapter) {
+		GCU_ERR("gcu_adapter not available, cannot access MMIO\n");
+		return -1;
+	}
+
+	/*
+	 * We write to MDIO_COMMAND_REG initially, then read that
+	 * same register until its MDIO_GO bit is cleared. When cleared,
+	 * the transaction is complete
+	 */
+	iowrite32(data, adapter->hw_addr + MDIO_COMMAND_REG);
+	do {
+		timeoutCounter++;
+		udelay(50); /* 50 microsecond delay */
+		data = ioread32(adapter->hw_addr + MDIO_COMMAND_REG);
+		complete = (data & MDIO_COMMAND_GO_MASK) >>
+				MDIO_COMMAND_GO_OFFSET;
+	} while (complete && timeoutCounter < timeoutCounterMax);
+	/* KAD !complete to complete */
+
+	if (timeoutCounter == timeoutCounterMax && !complete) {
+		GCU_ERR("Reached maximum number of retries"
+				" accessing MDIO_COMMAND_REG\n");
+
+		gcu_release_adapter(&adapter);
+
+		return -1;
+	}
+
+	/* validate the write during debug */
+#ifdef DBG
+	if (!gcu_write_verify(phy_num, reg_addr, phy_data, adapter)) {
+		GCU_ERR("Write verification failed for PHY=%d and addr=%d\n",
+				phy_num, reg_addr);
+
+		gcu_release_adapter(&adapter);
+
+		return -1;
+	}
+#endif
+
+	gcu_release_adapter(&adapter);
+
+	return 0;
+}
+EXPORT_SYMBOL(gcu_write_eth_phy);
+
+/*
+ * gcu_read_eth_phy
+ * @phy_num: phy we want to write to, either 0, 1, or 2
+ * @reg_addr: address in PHY's register space to write to
+ * @phy_data: data to be written
+ * interface function for other modules to access the GCU
+ */
+int
+gcu_read_eth_phy(u32 phy_num, u32 reg_addr, u16 *phy_data)
+{
+	const struct gcu_adapter *adapter;
+	u32 data = 0;
+	u32 timeoutCounter = 0;
+	const u32 timeoutCounterMax = GCU_MAX_ATTEMPTS;
+	u32 complete = 0;
+
+	GCU_DBG("%s\n", __func__);
+
+	if (phy_num > MDIO_COMMAND_PHY_ADDR_MAX) {
+		GCU_ERR("phy_num = %d, which is greater than "
+				"MDIO_COMMAND_PHY_ADDR_MAX\n", phy_num);
+		return -1;
+	}
+
+	if (reg_addr > MDIO_COMMAND_PHY_REG_MAX) {
+		GCU_ERR("reg_addr = %d, which is greater than "
+				"MDIO_COMMAND_PHY_REG_MAX\n", phy_num);
+		return -1;
+	}
+
+	/* format the data to be written to MDIO_COMMAND_REG */
+	data |= (reg_addr << MDIO_COMMAND_PHY_REG_OFFSET);
+	data |= (phy_num << MDIO_COMMAND_PHY_ADDR_OFFSET);
+	data |= MDIO_COMMAND_GO_MASK;
+
+	/*
+	 * this call contains a spinlock, so this may pause for a bit
+	 */
+	adapter = gcu_get_adapter();
+	if (!adapter) {
+		GCU_ERR("gcu_adapter not available, cannot access MMIO\n");
+		return -1;
+	}
+
+	/*
+	 * We write to MDIO_COMMAND_REG initially, then read that
+	 * same register until its MDIO_GO bit is cleared. When cleared,
+	 * the transaction is complete
+	 */
+	iowrite32(data, adapter->hw_addr + MDIO_COMMAND_REG);
+	do {
+		timeoutCounter++;
+		udelay(50); /* 50 microsecond delay */
+		data = ioread32(adapter->hw_addr + MDIO_COMMAND_REG);
+		complete = (data & MDIO_COMMAND_GO_MASK) >>
+				MDIO_COMMAND_GO_OFFSET;
+	} while (complete && timeoutCounter < timeoutCounterMax);
+	/* KAD !complete to complete */
+
+	if (timeoutCounter == timeoutCounterMax && !complete) {
+		GCU_ERR("Reached maximum number of retries"
+				" accessing MDIO_COMMAND_REG\n");
+
+		gcu_release_adapter(&adapter);
+
+		return -1;
+	}
+
+	/* we retrieve the data from the MDIO_STATUS_REGISTER */
+	data = ioread32(adapter->hw_addr + MDIO_STATUS_REG);
+	if ((data & MDIO_STATUS_STATUS_MASK) != 0) {
+		GCU_ERR("Unable to retrieve data from MDIO_STATUS_REG");
+
+		gcu_release_adapter(&adapter);
+
+		return -1;
+	}
+
+	*phy_data = (u16) (data & MDIO_STATUS_READ_DATA_MASK);
+
+	gcu_release_adapter(&adapter);
+
+	return 0;
+}
+EXPORT_SYMBOL(gcu_read_eth_phy);
+
+#ifdef DBG
+/*
+ * gcu_write_verify
+ * @phy_num: phy we want to write to, either 0, 1, or 2
+ * @reg_addr: address in PHY's register space to write to
+ * @phy_data: data to be checked
+ * @adapter: pointer to global adapter struct
+ *
+ * This f(n) assumes that the spinlock acquired for adapter is
+ * still in force.
+ */
+int
+gcu_write_verify(u32 phy_num, u32 reg_addr, u16 written_data,
+				 const struct gcu_adapter *adapter)
+{
+	u32 data = 0;
+	u32 timeoutCounter = 0;
+	const u32 timeoutCounterMax = GCU_MAX_ATTEMPTS;
+	u32 complete = 0;
+
+	GCU_DBG("%s\n", __func__);
+
+	if (!adapter) {
+		GCU_ERR("Invalid adapter pointer\n");
+		return 0;
+	}
+
+	if (phy_num > MDIO_COMMAND_PHY_ADDR_MAX) {
+		GCU_ERR("phy_num = %d, which is greater than "
+				"MDIO_COMMAND_PHY_ADDR_MAX\n", phy_num);
+		return 0;
+	}
+
+	if (reg_addr > MDIO_COMMAND_PHY_REG_MAX) {
+		GCU_ERR("reg_addr = %d, which is greater than "
+				"MDIO_COMMAND_PHY_REG_MAX\n", phy_num);
+		return 0;
+	}
+
+	/* format the data to be written to MDIO_COMMAND_REG */
+	data |= (reg_addr << MDIO_COMMAND_PHY_REG_OFFSET);
+	data |= (phy_num << MDIO_COMMAND_PHY_ADDR_OFFSET);
+	data |= MDIO_COMMAND_GO_MASK;
+
+	/*
+	 * We write to MDIO_COMMAND_REG initially, then read that
+	 * same register until its MDIO_GO bit is cleared. When cleared,
+	 * the transaction is complete
+	 */
+	iowrite32(data, adapter->hw_addr + MDIO_COMMAND_REG);
+	do {
+		timeoutCounter++;
+		udelay(50); /* 50 microsecond delay */
+		data = ioread32(adapter->hw_addr + MDIO_COMMAND_REG);
+		complete = (data & MDIO_COMMAND_GO_MASK) >>
+				MDIO_COMMAND_GO_OFFSET;
+	} while (!complete && timeoutCounter < timeoutCounterMax);
+
+	if (timeoutCounter == timeoutCounterMax && !complete) {
+		GCU_ERR("Reached maximum number of retries"
+				" accessing MDIO_COMMAND_REG\n");
+		return 0;
+	}
+
+	/* we retrieve the data from the MDIO_STATUS_REGISTER */
+	data = ioread32(adapter->hw_addr + MDIO_STATUS_REG);
+	if ((data & MDIO_STATUS_STATUS_MASK) != 0) {
+		GCU_ERR("Unable to retrieve data from MDIO_STATUS_REG");
+		return 0;
+	}
+
+	return written_data == (u16)(data & MDIO_STATUS_READ_DATA_MASK);
+}
+#endif
diff --git a/drivers/misc/gcu/gcu_if.h b/drivers/misc/gcu/gcu_if.h
new file mode 100644
index 0000000..0537586
--- /dev/null
+++ b/drivers/misc/gcu/gcu_if.h
@@ -0,0 +1,49 @@
+/*****************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+ version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+*****************************************************************************/
+
+/*
+ * gcu_if.h
+ * Shared functions for accessing and configuring the GCU
+ */
+
+#ifndef __GCU_IF_H__
+#define __GCU_IF_H__
+
+#define GCU_MAX_ATTEMPTS 64
+
+int gcu_write_eth_phy(u32 phy_num, u32 reg_addr,
+			u16 phy_data);
+
+int gcu_read_eth_phy(u32 phy_num, u32 reg_addr,
+			u16 *phy_data);
+
+#endif /* ifndef __GCU_IF_H__ */
diff --git a/drivers/misc/gcu/gcu_main.c b/drivers/misc/gcu/gcu_main.c
new file mode 100644
index 0000000..121dc2b
--- /dev/null
+++ b/drivers/misc/gcu/gcu_main.c
@@ -0,0 +1,339 @@
+/******************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+  version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+******************************************************************************/
+
+#include "gcu.h"
+
+static char gcu_driver_name[] = "GCU";
+static char gcu_driver_string[] = "Intel(R) Global Configuration Unit";
+#define DRV_VERSION "1.0.0"
+static char gcu_driver_version[] = DRV_VERSION;
+static char gcu_copyright[] = "Copyright (c) 1999-2007 Intel Corporation.";
+
+/*
+ * gcu_pci_tbl - PCI Device ID Table
+ * Last entry must be all 0s
+ * Macro expands to...
+ *   {PCI_DEVICE(PCI_VENDOR_ID_INTEL, device_id)}
+ */
+static struct pci_device_id gcu_pci_tbl[] = {
+	INTEL_GCU_DEVICE(0x503E),
+	/* required last entry */
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, gcu_pci_tbl);
+
+enum gcu_err_type {err_ioremap, err_alloc_gcu_adapter};
+
+static int gcu_init_module(void);
+static void gcu_exit_module(void);
+static int gcu_probe(struct pci_dev *pdev, const struct pci_device_id *ent);
+static void gcu_probe_err(enum gcu_err_type err, struct pci_dev *pdev,
+				struct gcu_adapter *adapter);
+static void __devexit gcu_remove(struct pci_dev *pdev);
+static int gcu_notify_reboot(struct notifier_block *, unsigned long event,
+				void *ptr);
+static int gcu_suspend(struct pci_dev *pdev, u32 state);
+static struct gcu_adapter *alloc_gcu_adapter(void);
+static void free_gcu_adapter(struct gcu_adapter *adapter);
+
+struct notifier_block gcu_notifier_reboot = {
+	.notifier_call	= gcu_notify_reboot,
+	.next		= NULL,
+	.priority	= 0
+};
+
+static struct pci_driver gcu_driver = {
+	.name		= gcu_driver_name,
+	.id_table	= gcu_pci_tbl,
+	.probe		= gcu_probe,
+	.remove		= __devexit_p(gcu_remove)
+};
+
+static struct gcu_adapter *global_adapter;
+static DEFINE_SPINLOCK(global_adapter_spinlock);
+
+MODULE_AUTHOR("Intel(R) Corporation");
+MODULE_DESCRIPTION("Intel(R) Global Configuration Unit");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.7.2");
+
+/*
+ * gcu_init_module - Driver Registration Routine
+ * gcu_init_module is the first routine called when the driver is
+ * loaded. All it does is register with the PCI subsystem.
+ */
+static int __init gcu_init_module(void)
+{
+	int ret;
+	printk(KERN_INFO "%s - version %s\n",
+		gcu_driver_string, gcu_driver_version);
+
+	printk(KERN_INFO "%s\n", gcu_copyright);
+
+	ret = pci_register_driver(&gcu_driver);
+	if (ret >= 0)
+		register_reboot_notifier(&gcu_notifier_reboot);
+
+	return ret;
+}
+module_init(gcu_init_module);
+
+/*
+ * gcu_exit_module - Driver Exit Cleanup Routine
+ * gcu_exit_module is called just before the driver is removed
+ * from memory.
+ */
+static void __exit gcu_exit_module(void)
+{
+	unregister_reboot_notifier(&gcu_notifier_reboot);
+	pci_unregister_driver(&gcu_driver);
+}
+module_exit(gcu_exit_module);
+
+/*
+ * gcu_probe - Device Initialization Routine
+ * @pdev: PCI device information struct
+ * @ent: entry in gcu_pci_tbl
+ * Returns 0 on success, negative on failure
+ * gcu_probe initializes an adapter identified by a pci_dev structure.
+ * The OS initialization, configuring of the adapter private structure,
+ * and a hardware reset occur.
+ */
+static int __devinit gcu_probe(struct pci_dev *pdev,
+				const struct pci_device_id *ent)
+{
+	struct gcu_adapter *adapter = 0;
+	u32 mmio_start, mmio_len;
+	int err;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		return err;
+
+	err = pci_request_regions(pdev, gcu_driver_name);
+	if (err)
+		return err;
+
+	/*
+	 * acquire the adapter spinlock. Once the module is loaded, it is
+	 * possible for someone to access the adapter struct via the interface
+	 * functions exported in gcu_if.c
+	 */
+	spin_lock(&global_adapter_spinlock);
+
+	adapter = alloc_gcu_adapter();
+	if (!adapter) {
+		gcu_probe_err(err_alloc_gcu_adapter, pdev, adapter);
+		spin_unlock(&global_adapter_spinlock);
+		return -ENOMEM;
+	}
+
+	pci_set_drvdata(pdev, adapter);
+
+	adapter->pdev = pdev;
+
+	mmio_start = pci_resource_start(pdev, BAR_0);
+	mmio_len = pci_resource_len(pdev, BAR_0);
+
+	adapter->hw_addr = ioremap(mmio_start, mmio_len);
+	if (!adapter->hw_addr) {
+		gcu_probe_err(err_ioremap, pdev, adapter);
+		spin_unlock(&global_adapter_spinlock);
+		return -EIO;
+	}
+
+	strncpy(adapter->name, pci_name(pdev), sizeof(adapter->name)-1);
+	adapter->mem_start = mmio_start;
+	adapter->mem_end = mmio_start + mmio_len;
+
+	adapter->vendor_id = pdev->vendor;
+	adapter->device_id = pdev->device;
+	adapter->subsystem_vendor_id = pdev->subsystem_vendor;
+	adapter->subsystem_id = pdev->subsystem_device;
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &adapter->revision_id);
+
+	pci_read_config_word(pdev, PCI_COMMAND, &adapter->pci_cmd_word);
+
+	global_adapter = adapter;
+	spin_unlock(&global_adapter_spinlock);
+
+	printk(KERN_INFO "GCU:Intel(R) GCU Initialized\n");
+	return 0;
+}
+
+/*
+ * gcu_probe_err - gcu_probe error handler
+ * @err: gcu_err_type
+ * encapsulated error handling for gcu_probe
+ */
+static void gcu_probe_err(enum gcu_err_type err, struct pci_dev *pdev,
+				struct gcu_adapter *adapter)
+{
+	switch (err) {
+	case err_ioremap:
+		iounmap(adapter->hw_addr);
+		pci_release_regions(pdev);
+	case err_alloc_gcu_adapter:
+	default:
+		free_gcu_adapter(adapter);
+		break;
+	}
+}
+
+/*
+ * gcu_remove - Device Removal Routine
+ * @pdev: PCI device information struct
+ * gcu_remove is called by the PCI subsystem to alert the driver
+ * that it should release a PCI device.  The could be caused by a
+ * Hot-Plug event, or because the driver is going to be removed from
+ * memory.
+ */
+static void __devexit gcu_remove(struct pci_dev *pdev)
+{
+	struct gcu_adapter *adapter = pci_get_drvdata(pdev);
+
+	iounmap(adapter->hw_addr);
+	pci_release_regions(pdev);
+	free_gcu_adapter(adapter);
+	pci_set_drvdata(pdev, NULL);
+}
+
+static int gcu_notify_reboot(struct notifier_block *nb, unsigned long event,
+				void *p)
+{
+	struct pci_dev *pdev = NULL;
+
+	switch (event) {
+	case SYS_DOWN:
+	case SYS_HALT:
+	case SYS_POWER_OFF:
+		while ((pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev))) {
+			if (pci_dev_driver(pdev) == &gcu_driver)
+				gcu_suspend(pdev, 3);
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
+/*
+ * gcu_suspend - device sleep function
+ * @pdev: PCI device information struct
+ * gcu_supend is generally called to place a device in sleep mode,
+ * however the GCU doesn't support power mangement. For this case,
+ * it is part of the gcu_notify_reboot() call chain to quiese the
+ * device before a reboot.
+ */
+static int gcu_suspend(struct pci_dev *pdev, u32 state)
+{
+	pci_save_state(pdev);
+
+	pci_disable_device(pdev);
+
+	state = (state > 0) ? 0 : 0;
+
+	/*
+	 * GCU doesn't support power management, but want to
+	 * leave a hook incase that situation changes in the future
+	 * pci_set_power_state(pdev, state);
+	 */
+	return state;
+}
+
+/*
+ * alloc_gcu_adapter
+ * alloc_gcu_adapter is a wrapper for the kmalloc call for the
+ * device specific data block plus inits the global_adapter variable.
+ * Note that this function assumes that the spinlock for the global
+ * gcu_adapter struct as been acquired.
+ */
+static struct gcu_adapter *alloc_gcu_adapter()
+{
+	struct gcu_adapter *adapter;
+
+	adapter = kmalloc(sizeof(*adapter), GFP_KERNEL);
+
+	global_adapter = adapter;
+
+	if (!adapter)
+		return 0;
+
+	memset(adapter, 0, sizeof(*adapter));
+
+	return adapter;
+}
+
+/*
+ * free_gcu_adapter
+ * @adapter: gcu_adapter struct to be free'd
+ * free_gcu_adapter is a wrapper for the kfree call for the
+ * device specific data block plus clears the global_adapter variable
+ * Note that this function assumes that the spinlock for the global
+ * gcu_adapter struct as been acquired.
+ */
+static void free_gcu_adapter(struct gcu_adapter *adapter)
+{
+	global_adapter = 0;
+
+	kfree(adapter);
+}
+
+/*
+ * gcu_get_adapter
+ * gcu_get_adapter is used by the functions exported in gcu_if.c to get
+ * access to the memory addresses needed to access the MMIO registers
+ * of the GCU
+ */
+const struct gcu_adapter *gcu_get_adapter(void)
+{
+	if (global_adapter == NULL)
+		return NULL;
+
+	spin_lock(&global_adapter_spinlock);
+
+	return global_adapter;
+}
+
+/*
+ * gcu_release_adapter
+ * gcu_release_adapter is used by the functions exported in gcu_if.c to get
+ * release the adapter spinlock and the handle to the adapter
+ */
+void gcu_release_adapter(const struct gcu_adapter **adapter)
+{
+	if (adapter != NULL)
+		*adapter = 0;
+
+	spin_unlock(&global_adapter_spinlock);
+}
diff --git a/drivers/misc/gcu/gcu_reg.h b/drivers/misc/gcu/gcu_reg.h
new file mode 100644
index 0000000..e704f7a
--- /dev/null
+++ b/drivers/misc/gcu/gcu_reg.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+
+GPL LICENSE SUMMARY
+
+  Copyright(c) 2007 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+  Intel Corporation
+
+ version: Embedded.L.0.7.018
+
+  Contact Information:
+
+  Intel Corporation, 5000 W Chandler Blvd, Chandler, AZ 85226
+
+******************************************************************************/
+
+/*
+ * gcu_reg.h
+ * Macros and constants related to the registers available on the GCU
+ */
+
+#ifndef __GCU_REG_H__
+#define __GCU_REG_H__
+
+/* Register Offsets within memory map register space */
+#define MDIO_STATUS_REG			0x00000010UL
+#define MDIO_COMMAND_REG		0x00000014UL
+
+/* MDIO_STATUS_REG fields */
+#define MDIO_STATUS_STATUS_MASK		0x80000000UL  /* bit 31 = 1 on error */
+#define MDIO_STATUS_READ_DATA_MASK	0x0000FFFFUL
+
+/* MDIO_COMMAND_REG fields */
+#define MDIO_COMMAND_GO_MASK		0x80000000UL
+/* bit 31 = 1 during read or write, 0 on completion */
+#define MDIO_COMMAND_OPER_MASK		0x04000000UL /* bit = 1 is  a write */
+#define MDIO_COMMAND_PHY_ADDR_MASK	0x03E00000UL
+#define MDIO_COMMAND_PHY_REG_MASK	0x001F0000UL
+#define MDIO_COMMAND_WRITE_DATA_MASK	0x0000FFFFUL
+
+#define MDIO_COMMAND_GO_OFFSET		31
+#define MDIO_COMMAND_OPER_OFFSET	26
+#define MDIO_COMMAND_PHY_ADDR_OFFSET	21
+#define MDIO_COMMAND_PHY_REG_OFFSET	16
+#define MDIO_COMMAND_WRITE_DATA_OFFSET	0
+
+#define MDIO_COMMAND_PHY_ADDR_MAX	2  /* total phys supported by GCU */
+#define MDIO_COMMAND_PHY_REG_MAX	31
+/* total registers available on the M88 Phy used on truxton */
+
+#endif /* ifndef __GCU_REG_H__ */
-- 
1.6.0.2.GIT

