From c8de6ed2152e3a54f913693e26f7a60c1abd200f Mon Sep 17 00:00:00 2001
From: Zhang Xiao <xiao.zhang@windriver.com>
Date: Fri, 20 Apr 2012 15:32:11 +0800
Subject: [PATCH] intel_truxton: error handling enhancement on TX ring cleaning

Once an interrupt occurred after NAPI handler scheduled, ISR shouldn't clean TX
ring but just return to avoid conflicting with NAPI handler.

In TX cleaning process, check the pointer before using it to avoid null pointer
reference.

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 drivers/net/e1000/e1000_main.c |   10 +++++++---
 1 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/drivers/net/e1000/e1000_main.c b/drivers/net/e1000/e1000_main.c
index 523eae7..2002bf7 100644
--- a/drivers/net/e1000/e1000_main.c
+++ b/drivers/net/e1000/e1000_main.c
@@ -4035,8 +4035,10 @@ static irqreturn_t e1000_intr_msi(int irq, void *data)
 		adapter->total_rx_bytes = 0;
 		adapter->total_rx_packets = 0;
 		__netif_rx_schedule(netdev, &adapter->napi);
-	} else
+	} else {
 		e1000_irq_enable(adapter);
+		return IRQ_HANDLED;
+	}
 
 	/* Clean the Tx ring */
 	for (i = 0; i < E1000_MAX_INTR; i++) {
@@ -4105,10 +4107,12 @@ static irqreturn_t e1000_intr(int irq, void *data)
 		adapter->total_rx_bytes = 0;
 		adapter->total_rx_packets = 0;
 		__netif_rx_schedule(netdev, &adapter->napi);
-	} else
+	} else {
 		/* this really should not happen! if it does it is basically a
 		 * bug, but not a hard error, so enable ints and continue */
 		e1000_irq_enable(adapter);
+		return IRQ_HANDLED;
+	}
 
 	/* Clean the Tx ring */
 	for (i = 0; i < E1000_MAX_INTR; i++) {
@@ -4188,7 +4192,7 @@ static bool e1000_clean_tx_irq(struct e1000_adapter *adapter,
 			buffer_info = &tx_ring->buffer_info[i];
 			cleaned = (i == eop);
 
-			if (cleaned) {
+			if (cleaned && buffer_info->skb) {
 				struct sk_buff *skb = buffer_info->skb;
 				unsigned int segs, bytecount;
 				segs = skb_shinfo(skb)->gso_segs ?: 1;
-- 
1.7.0.2

