From 78e301d25bef5dd152a0b4b1b3653aa39f3c56d0 Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Thu, 18 Dec 2008 16:12:01 +0800
Subject: [PATCH] intel_truxton: add tolapai CAN Driver

Add CAN(Controller Area Network) driver support for tolapai. The driver is a
standard char device, and client can use "open", "close", "read", "write", and
"ioctl" to operate the CAN controller for communication.

This driver is ported from the Intel SDK V0.7.18 version.

Signed-off-by: Li Wang <li.wang@windriver.com>
---
 drivers/Kconfig           |    2 +
 drivers/Makefile          |    1 +
 drivers/can/Kconfig       |   46 ++
 drivers/can/Makefile      |   16 +
 drivers/can/can-base.c    |  181 +++++
 drivers/can/can-base.h    |   52 ++
 drivers/can/can-dev.c     |  298 ++++++++
 drivers/can/can-fifo.c    |  160 ++++
 drivers/can/can-fifo.h    |   47 ++
 drivers/can/can_tolapai.c | 1832 +++++++++++++++++++++++++++++++++++++++++++++
 drivers/can/can_tolapai.h |  566 ++++++++++++++
 11 files changed, 3201 insertions(+), 0 deletions(-)
 create mode 100644 drivers/can/Kconfig
 create mode 100644 drivers/can/Makefile
 create mode 100644 drivers/can/can-base.c
 create mode 100644 drivers/can/can-base.h
 create mode 100644 drivers/can/can-dev.c
 create mode 100644 drivers/can/can-fifo.c
 create mode 100644 drivers/can/can-fifo.h
 create mode 100644 drivers/can/can_tolapai.c
 create mode 100644 drivers/can/can_tolapai.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index 59f33fa..67c4029 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -92,6 +92,8 @@ source "drivers/edac/Kconfig"
 
 source "drivers/rtc/Kconfig"
 
+source "drivers/can/Kconfig"
+
 source "drivers/dma/Kconfig"
 
 source "drivers/dca/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 39cfe40..0fec76f 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -70,6 +70,7 @@ obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
 obj-$(CONFIG_I2O)		+= message/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
+obj-$(CONFIG_CAN_DEV)		+= can/
 obj-$(CONFIG_W1)		+= w1/
 obj-$(CONFIG_POWER_SUPPLY)	+= power/
 obj-$(CONFIG_HWMON)		+= hwmon/
diff --git a/drivers/can/Kconfig b/drivers/can/Kconfig
new file mode 100644
index 0000000..8e83736
--- /dev/null
+++ b/drivers/can/Kconfig
@@ -0,0 +1,46 @@
+#
+# CAN class/drivers configuration
+#
+
+menu "Controller Area Network"
+
+config CAN_DEV
+	tristate "CAN device class"
+	depends on EXPERIMENTAL
+	default n 
+	help
+	  Generic CAN class support. If you say yes here, you will
+	  be allowed to plug one or more CANs to your system. You will
+	  probably want to use your CANs using the /dev interfaces,
+	  which "udev" sets up as /dev/can0 through /dev/canN.  
+
+	  This driver can also be built as a module. If so, the module
+	  will be called can_class.
+
+config CAN_PHYS_ENDPOINT_NUM
+	int "CAN endpoint number of all kinds of controllers"
+	depends on CAN_DEV
+	default "2"
+	help
+	  This is the total number of the can endpoint in your platform.
+	  Including all kinds of CAN controllers routed to misc interfaces.
+
+config CAN_DEBUG
+	bool "CAN debug support"
+	depends on CAN_DEV 
+	help
+	  Say yes here to enable debugging support in the CAN framework
+	  and individual CAN drivers.
+
+comment "CAN drivers"
+	depends on CAN_DEV
+
+config CAN_DRV_TOLAPAI
+	tristate "Intel Tolapai CAN Controller"
+	depends on X86 && PCI
+	help
+	  Say Y here to enable Tolapai CAN support. To compile this driver
+          as a module, choose M here. If so, the module will be called
+	  can_tolapai.
+
+endmenu
diff --git a/drivers/can/Makefile b/drivers/can/Makefile
new file mode 100644
index 0000000..e55f71b
--- /dev/null
+++ b/drivers/can/Makefile
@@ -0,0 +1,16 @@
+#
+# Makefile for CAN driver.
+#
+
+# Core
+#
+obj-$(CONFIG_CAN_DEV)	+= can-core.o
+
+can-core-y := can-base.o can-fifo.o can-dev.o
+
+# CAN controller drivers
+obj-$(CONFIG_CAN_DRV_TOLAPAI) += can_tolapai.o
+
+ifeq ($(CONFIG_CAN_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff --git a/drivers/can/can-base.c b/drivers/can/can-base.c
new file mode 100644
index 0000000..677c2fb
--- /dev/null
+++ b/drivers/can/can-base.c
@@ -0,0 +1,181 @@
+/*
+ * Controller Aera Network(CAN) driver for Linux 2.6
+ *
+ * Re-written by Zumeng.Chen <zumeng.chen@windriver.com>
+ * Based on peak-linux-driver.3.17.tar.gz.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/atomic.h>
+#include <linux/types.h>
+
+#include "can-base.h"
+
+/* ------------------------------------------------------------------------ */
+#define FIFOSIZE 200
+/* Used for minor number allocation */
+static struct can_endpoint_t *can_endpoint[CAN_MAX_ENDPOINTS];
+struct class *can_dev_class;
+
+struct can_endpoint_t *can_endpoint_get_by_minor(unsigned index)
+{
+	if (index < 0 || index >= CAN_MAX_ENDPOINTS)
+		return NULL;
+	return can_endpoint[index];
+}
+
+struct can_endpoint_t *can_endpoint_init(int factorTx2Rx)
+{
+	struct can_endpoint_t *endpoint = kmalloc(
+			sizeof(struct can_endpoint_t), GFP_KERNEL);
+
+	memset((void *) endpoint, 0x0, sizeof(struct can_endpoint_t));
+
+	if (can_fifo_init(&endpoint->txfifo, FIFOSIZE))
+		goto free_exit;
+
+	printk(KERN_INFO "CAN FIFO: %dBytes for Tx\n",
+		FIFOSIZE * (sizeof(struct can_frame)));
+
+	if (!(can_fifo_init(&endpoint->rxfifo, FIFOSIZE*factorTx2Rx)))
+		goto normal_exit;
+
+	printk(KERN_ERR "CAN: %s out of memory\n", __func__);
+	kfree((const void *)endpoint->rxfifo.data);
+free_exit:
+	kfree((const void *)endpoint);
+normal_exit:
+	return endpoint;
+}
+EXPORT_SYMBOL(can_endpoint_init);
+
+void can_endpoint_free(struct can_endpoint_t *endpoint)
+{
+	kfree((const void *)endpoint->txfifo.data);
+	kfree((const void *)endpoint->rxfifo.data);
+	kfree((const void *)endpoint);
+	return ;
+}
+EXPORT_SYMBOL(can_endpoint_free);
+
+/* read a frame from buffer-FIFO */
+can_frame_t *can_endpoint_readframe(struct can_endpoint_t *endpoint, int uid,
+					int *retval)
+{
+	can_frame_t *frame = NULL;
+
+	can_fifo_lock(&endpoint->rxfifo);
+	frame = can_fifo_pop(&endpoint->rxfifo, uid, retval);
+	can_fifo_unlock(&endpoint->rxfifo);
+	/*Try to release lock asap. */
+
+	return frame;
+}
+
+/* Try to write a CAN frame from buffer-FIFO to Hard-Tx */
+void  can_endpoint_writeframe(struct can_endpoint_t *endpoint)
+{
+	int sending = 0;
+
+	can_fifo_lock(&endpoint->txfifo);
+	sending = atomic_sub_and_test(1, &endpoint->send_ready_flag);
+	can_fifo_unlock(&endpoint->txfifo);
+
+	if (sending)
+		endpoint->initiate2write(endpoint);
+	return;
+}
+
+/* Try to get free frame from buffer-FIFO */
+can_frame_t *can_endpoint_getframe(struct can_endpoint_t *endpoint,
+					int *retval)
+{
+	can_frame_t *frame = NULL;
+
+	can_fifo_lock(&endpoint->txfifo);
+	frame = can_fifo_get(&endpoint->txfifo, retval);
+	can_fifo_unlock(&endpoint->txfifo);
+
+	return frame;
+}
+
+int can_endpoint_adduser(struct can_endpoint_t *endpoint)
+{
+	int uid;
+
+	can_fifo_lock(&endpoint->rxfifo);
+	uid = can_fifo_adduser(&endpoint->rxfifo);
+	can_fifo_unlock(&endpoint->rxfifo);
+
+	return uid;
+}
+
+int can_endpoint_deluser(struct can_endpoint_t *endpoint, int uid)
+{
+	int retval = 0;
+
+	can_fifo_lock(&endpoint->rxfifo);
+	retval = can_fifo_deluser(&endpoint->rxfifo, uid);
+	can_fifo_unlock(&endpoint->rxfifo);
+
+	return retval;
+}
+
+/*
+ * This function will be called by chip-specific implementations; return minor
+ * number
+ */
+int can_endpoint_register(struct can_endpoint_t *endpoint)
+{
+	int retval, i, minor = -1;
+
+	/* Allocate a minor number */
+	for (i = 0; i < CAN_MAX_ENDPOINTS; i++) {
+		if (can_endpoint[i] == NULL) {
+			minor = i;
+			break;
+		}
+	}
+
+	if (minor == -1) {
+		printk(KERN_ERR "CAN: Ran out of minor numbers!\n");
+		return -EFAULT;
+	}
+
+	can_endpoint[minor] = endpoint;
+	endpoint->minor = minor;
+	endpoint->txfifo.end[0] = endpoint->txfifo.start;
+
+	init_waitqueue_head(&endpoint->write_queue);
+	init_waitqueue_head(&endpoint->read_queue);
+
+	snprintf(endpoint->name, 7, "can%i", minor);
+	retval = minor;
+
+	printk(KERN_INFO "CAN: Registering CAN endpoint %s\n", endpoint->name);
+
+	/* To create a class device */
+	device_create(can_dev_class, NULL, MKDEV(CAN_MAJOR, minor), NULL,
+			endpoint->name);
+
+	return minor;
+}
+EXPORT_SYMBOL(can_endpoint_register);
+
+/* Unregister a endpoint (device specific module unloaded or USB hotplug) */
+void can_endpoint_unregister(struct can_endpoint_t *endpoint)
+{
+	device_destroy(can_dev_class, MKDEV(CAN_MAJOR, endpoint->minor));
+
+	can_endpoint[endpoint->minor] = NULL;
+	can_endpoint_free(endpoint);
+}
+EXPORT_SYMBOL(can_endpoint_unregister);
diff --git a/drivers/can/can-base.h b/drivers/can/can-base.h
new file mode 100644
index 0000000..e5c0fe8
--- /dev/null
+++ b/drivers/can/can-base.h
@@ -0,0 +1,52 @@
+#ifndef _LINUX_CAN_H
+#define _LINUX_CAN_H
+
+#include "can-fifo.h"
+
+#define CAN_MAJOR		231
+
+#define CAN_MAX_ENDPOINTS	CONFIG_CAN_PHYS_ENDPOINT_NUM
+
+#define CAN_SETBAUDRATE		0x01
+#define CAN_IOCHIPRESET		0x02
+#define CAN_MODE		0x03
+
+struct can_endpoint_t {
+	int minor;	/* Minor number of can device */
+	atomic_t send_ready_flag;
+	char name[8];	/* Device name */
+	void *chip;	/* Point to specific chip  */
+	can_fifo_t rxfifo;	/* Rx FIFO */
+	can_fifo_t txfifo;	/* Tx FIFO */
+	wait_queue_head_t read_queue;
+	wait_queue_head_t write_queue;
+	void (*set_bitrate)(struct can_endpoint_t *endpoint, int bitrate);
+	void (*chip_reset)(struct can_endpoint_t *endpoint);
+	void (*set_mode)(struct can_endpoint_t *endpoint, int mode);
+	int (*initiate2write)(struct can_endpoint_t *endpoint);
+	int (*ioctl)(struct can_endpoint_t *endpoint, unsigned int cmd,
+			unsigned long arg);
+};
+
+struct can_dev_client {
+	int uid;
+	u32 magic_num;
+	int reserved;
+	struct can_endpoint_t *endpoint;
+};
+
+extern struct class *can_dev_class;
+extern can_frame_t *can_fifo_get(can_fifo_t *fifo, int *retval);
+can_frame_t *can_endpoint_getframe(struct can_endpoint_t *endpoint,
+					int *retval);
+extern int can_endpoint_adduser(struct can_endpoint_t *endpoint);
+extern int can_endpoint_deluser(struct can_endpoint_t *endpoint, int uid);
+extern void can_endpoint_writeframe(struct can_endpoint_t *endpoint);
+extern can_frame_t *can_endpoint_readframe(struct can_endpoint_t *endpoint,
+						int uid, int  *retval);
+extern struct can_endpoint_t *can_endpoint_init(int factorTx2Rx);
+extern struct can_endpoint_t *can_endpoint_get_by_minor(unsigned index);
+extern void can_endpoint_free(struct can_endpoint_t *endpoint);
+extern int can_endpoint_register(struct can_endpoint_t *endpoint);
+extern void can_endpoint_unregister(struct can_endpoint_t *endpoint);
+#endif /* _LINUX_CAN_H */
diff --git a/drivers/can/can-dev.c b/drivers/can/can-dev.c
new file mode 100644
index 0000000..ef69c57
--- /dev/null
+++ b/drivers/can/can-dev.c
@@ -0,0 +1,298 @@
+/*
+ * Controller Aera Network(CAN) driver for Linux 2.6
+ *
+ * Re-written by Zumeng.Chen <zumeng.chen@windriver.com>
+ * Based on peak-linux-driver.3.17.tar.gz.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <asm/atomic.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+
+#include "can-base.h"
+
+/* --------------CAN File operation functions start --------------------*/
+/* File operation function for CAN endpoint */
+/* CAN Open function . */
+static int can_endpoint_open(struct inode *inode, struct file *file)
+{
+	struct can_endpoint_t *endpoint;
+	int uid = -1, deviceId = iminor(inode);
+	struct can_dev_client *can_client =
+		kmalloc(sizeof(struct can_dev_client), GFP_KERNEL);
+
+	endpoint = (struct can_endpoint_t *)
+			can_endpoint_get_by_minor(deviceId);
+
+	if (endpoint == NULL || can_client == NULL)
+		return -ENODEV;
+
+	if ((endpoint->rxfifo.user_counter) == (u32)CAN_MAX_USER_BIT)
+		return -EBUSY;
+
+	can_client->endpoint = endpoint;
+
+	uid = can_endpoint_adduser(endpoint);
+
+	if (uid < 0)
+		return uid;
+
+	can_client->uid = uid;
+	can_client->magic_num = ((uid) ^ (unsigned int)endpoint);
+
+	printk(KERN_INFO "CAN: Opening endpoint %s (uid %i)\n",
+		endpoint->name, uid);
+
+	file->private_data = (void *)can_client;
+
+	return 0;
+}
+
+/* CAN release function */
+static int can_endpoint_release(struct inode *inode, struct file *file)
+{
+	struct can_dev_client *can_client =
+		(struct can_dev_client *)file->private_data;
+	struct can_endpoint_t *endpoint = can_client->endpoint;
+	int uid = can_client->uid;
+	int retval = -1;
+
+	if (can_client->magic_num != ((uid) ^ (unsigned int)endpoint)) {
+		printk(KERN_ERR "CAN can_client has been overrun "
+			"by unknown reason.\n ");
+	}
+
+	printk(KERN_INFO "CAN: /dev/can%i closed\n", can_client->uid);
+
+	retval = can_endpoint_deluser(endpoint, can_client->uid);
+
+	kfree((const void *)can_client);
+	if (retval != 0) {
+		printk(KERN_ERR "CAN: wicked error in %s \n", __func__);
+		retval = -EFAULT;
+	}
+
+	return retval;
+}
+
+/* CAN read function*/
+static ssize_t can_endpoint_read(struct file *file, char *buf, size_t count,
+					loff_t *ppos)
+{
+	struct can_dev_client *can_client =
+		(struct can_dev_client *)file->private_data;
+	struct can_endpoint_t *endpoint = can_client->endpoint;
+	can_frame_t *frame = NULL;
+	int uid = can_client->uid;
+	int retval = -1;
+	size_t index = 0;
+
+	if (can_client->magic_num != ((uid) ^ (unsigned int)endpoint)) {
+		printk(KERN_ERR"CAN can_client has been overrun "
+			"by unknown reason.\n ");
+		return -EFAULT;
+	}
+
+	while (count - index >= sizeof(struct can_frame)) {
+		frame = can_endpoint_readframe(endpoint, can_client->uid,
+						&retval);
+
+		if (retval == 0) {
+			retval = copy_to_user(buf, frame,
+						sizeof(struct can_frame));
+			if (retval)
+				return -EFAULT;
+			index += sizeof(struct can_frame);
+			buf += sizeof(struct can_frame);
+			continue;
+		}
+
+		if (retval == -ENODATA) {
+			if (file->f_flags & O_NONBLOCK) {
+				if (index == 0)
+					return -EAGAIN;
+				else
+					return index;
+			} else {
+				interruptible_sleep_on(&endpoint->read_queue);
+				if (signal_pending(current)) {
+					if (index == 0)
+						return -EINTR;
+					return index;
+				}
+			}
+		} else  {
+			printk(KERN_ERR "%s: Unknow error when read from "
+				"fifo retval = %d \n", __func__, retval);
+			return retval;
+		}
+	}
+
+	return index;
+}
+
+/*CAN  write function */
+static ssize_t can_endpoint_write(struct file *file, const char *buf,
+					size_t count, loff_t *ppos)
+{
+	struct can_dev_client *can_client =
+		(struct can_dev_client *)file->private_data;
+	struct can_endpoint_t *endpoint = can_client->endpoint;
+	int uid = can_client->uid;
+	int retval = -1;
+	size_t index = 0;
+
+	if (can_client->magic_num != ((uid) ^ (unsigned int)endpoint)) {
+		printk(KERN_ERR"CAN can_client has been overrun by "
+			"unknown reason.\n ");
+		return -EFAULT;
+	}
+
+	while (count - index >= sizeof(struct can_frame)) {
+		can_frame_t *frame = NULL;
+
+		frame = can_endpoint_getframe(endpoint, &retval);
+
+		if (retval == 0) {
+			if (copy_from_user(frame, (can_frame_t *) &buf[index],
+						sizeof(struct can_frame)))
+				return -EFAULT;
+
+			can_endpoint_writeframe(endpoint);
+			index += sizeof(struct can_frame);
+			continue;
+		}
+
+		if (retval == -EBUSY) {
+			if (file->f_flags & O_NONBLOCK) {
+				if (index == 0)
+					return -EAGAIN;
+				else
+					return index;
+			}
+			interruptible_sleep_on(&endpoint->write_queue);
+			if (signal_pending(current)) {
+				if (index == 0)
+					return -EINTR;
+				return index;
+			}
+		} else if (retval < 0) {
+			printk(KERN_ERR "%s: Unknow error when write to "
+				"fifo retval = %d \n", __func__, retval);
+			return retval;
+		}
+	}
+
+	return index;
+}
+
+/* CAN IOCTL function*/
+static int can_endpoint_ioctl(struct inode *inode, struct file *file,
+				unsigned int cmd, unsigned long arg)
+{
+	struct can_dev_client *can_client =
+		(struct can_dev_client *)file->private_data;
+	struct can_endpoint_t *endpoint = can_client->endpoint;
+	int uid = can_client->uid;
+	int retval = 0;
+
+	if (can_client->magic_num != ((uid) ^ (unsigned int)endpoint)) {
+		printk(KERN_ERR"CAN can_client has been overrun by "
+			"unknown reason.\n ");
+		return -EFAULT;
+	}
+
+	can_fifo_lock(&endpoint->rxfifo);
+	can_fifo_lock(&endpoint->txfifo);
+	switch (cmd) {
+	case CAN_SETBAUDRATE:
+		endpoint->set_bitrate(endpoint, arg);
+		break;
+	case CAN_IOCHIPRESET:
+		if (endpoint->chip_reset != NULL)
+			endpoint->chip_reset(endpoint);
+		else
+			retval = -EPERM;
+		break;
+	case CAN_MODE:
+		if (endpoint->set_mode != NULL)
+			endpoint->set_mode(endpoint, arg);
+		else
+			retval = -EPERM;
+		break;
+	default:
+		if (endpoint->ioctl)
+			retval = endpoint->ioctl(endpoint, cmd, arg);
+		else
+			retval = -EINVAL;
+	}
+
+	can_fifo_unlock(&endpoint->txfifo);
+	can_fifo_unlock(&endpoint->rxfifo);
+
+	if (retval == -EINVAL)
+		printk(KERN_WARNING "CAN device: Invalid ioctl request.\n");
+
+	return retval;
+}
+
+static struct file_operations can_endpoint_fops = {
+	.owner   = THIS_MODULE,
+	.open    = can_endpoint_open,
+	.release = can_endpoint_release,
+	.write   = can_endpoint_write,
+	.read    = can_endpoint_read,
+	.ioctl   = can_endpoint_ioctl
+};
+/* --------------CAN File operation functions end --------------------*/
+
+
+/* -----------module function start ------------------------------- */
+
+static int __init can_dev_init(void)
+{
+	int err = 0;
+
+	can_dev_class = class_create(THIS_MODULE, "can-dev");
+	if (IS_ERR(can_dev_class)) {
+		err = PTR_ERR(can_dev_class);
+		goto err_exit;
+	}
+
+	/* Register can device operation to VFS*/
+	if (register_chrdev(CAN_MAJOR, "can-dev", &can_endpoint_fops)) {
+		printk(KERN_ERR "Register the CAN major number failed !\n");
+		err = -EFAULT;
+		goto err_destroy_class;
+	}
+
+	printk(KERN_INFO "CAN device class register Version 0.1\n");
+	return 0;
+
+err_destroy_class:
+	class_destroy(can_dev_class);
+err_exit:
+	return err;
+}
+
+static void __exit can_dev_cleanup(void)
+{
+	unregister_chrdev(CAN_MAJOR, "can-dev");
+	class_destroy(can_dev_class);
+}
+
+module_init(can_dev_init);
+module_exit(can_dev_cleanup);
+/* -----------module function end ------------------------------- */
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MPC52xx CAN Device class support");
diff --git a/drivers/can/can-fifo.c b/drivers/can/can-fifo.c
new file mode 100644
index 0000000..5058506
--- /dev/null
+++ b/drivers/can/can-fifo.c
@@ -0,0 +1,160 @@
+/*
+ * Controller Aera Network(CAN) driver for Linux 2.6
+ *
+ * Re-written by Zumeng.Chen <zumeng.chen@windriver.com>
+ * Based on peak-linux-driver.3.17.tar.gz.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/atomic.h>
+#include <linux/types.h>
+
+#include "can-fifo.h"
+
+/*
+ * It is somewhat confusion, current definition is if only there is a valid
+ * reader, this function return 0; otherwise a negative return value:
+ * This function will be called only if read interrupter happen.
+ */
+static int can_fifo_full_check(can_fifo_t *fifo)
+{
+	int i, retval = 0;
+#ifdef CONFIG_CAN_DEBUG
+	int overrun_bit = fifo->rd_overrun_bit;
+#endif
+
+	for (i = 0; i < CAN_MAX_USER; i++) {
+		if (fifo->end[i] != -1) {
+			if ((fifo->end[i] == fifo->start + 1) ||
+				(fifo->end[i] == 0 &&
+				fifo->start == fifo->size - 1))
+				fifo->rd_overrun_bit |= (1<<i);
+		}
+	}
+
+#ifdef CONFIG_CAN_DEBUG
+	if (overrun_bit != fifo->rd_overrun_bit)
+		printk(KERN_WARNING "CAN Rx FIFO is full bit = 0x%x\n",
+			fifo->rd_overrun_bit);
+#endif
+	if (fifo->rd_overrun_bit == fifo->user_counter) {
+		printk(KERN_WARNING "CAN Rx FIFO is full bit = 0x%x\n",
+			fifo->rd_overrun_bit);
+		retval =  -ENOSPC;
+	}
+
+	return retval;
+}
+
+static int  can_fifo_empty(can_fifo_t *fifo, int id)
+{
+	if (fifo->end[id] == -1) {
+		printk(KERN_ERR "%s: Wicked Error Client number %d \n",
+			__func__, id);
+		return -EINVAL;
+	}
+	return (fifo->start == fifo->end[id]) ? (-ENODATA) : 0;
+}
+
+/* FIFO initialization, and end[i] = -1 means that this slot is idle. */
+int can_fifo_init(can_fifo_t *fifo, int size)
+{
+	int i;
+
+	fifo->data = kmalloc(size * sizeof(struct can_frame), GFP_KERNEL);
+
+	if (!fifo->data)
+		return -ENOMEM;
+
+	fifo->size = size;
+	fifo->start = 0;
+	for (i = 0; i < CAN_MAX_USER; i++)
+		fifo->end[i] = -1;
+
+	spin_lock_init(&fifo->lock);
+
+	return 0;
+}
+
+int can_fifo_adduser(can_fifo_t *fifo)
+{
+	int i;
+	for (i = 0; i < CAN_MAX_USER; i++) {
+		if (fifo->end[i] == -1) {
+			fifo->end[i] = fifo->start;
+			fifo->user_counter |= (1<<i);
+			return i;
+		}
+	}
+	return -EBUSY;
+}
+
+int can_fifo_deluser(can_fifo_t *fifo, int id)
+{
+	fifo->end[id] = -1;
+	fifo->user_counter &= ~(1<<id);
+	fifo->rd_overrun_bit &= ~(1<<id);
+	return 0;
+}
+
+/* Push a CAN frame into FIFO */
+int can_fifo_push(can_fifo_t *fifo, can_frame_t *frame)
+{
+	int retval = 0;
+
+	retval = can_fifo_full_check(fifo);
+
+	memcpy(&fifo->data[fifo->start], frame, sizeof(struct can_frame));
+
+	if (++fifo->start == fifo->size)
+		fifo->start = 0;
+	return retval;
+}
+EXPORT_SYMBOL(can_fifo_push);
+
+/* ------------------------------------------------------------------------ */
+/* POP a CAN frame from FIFO */
+can_frame_t *can_fifo_pop(can_fifo_t *fifo, int id, int  *retval)
+{
+	int val = can_fifo_empty(fifo, id);
+	can_frame_t *frame = NULL;
+
+	*retval = val;
+
+	if (val == 0) {
+		frame = &fifo->data[fifo->end[id]];
+
+		/*There is a implicit expression, and wrap around*/
+		if (++fifo->end[id] ==  fifo->size)
+			fifo->end[id] = 0;
+	}
+
+	return frame;
+}
+EXPORT_SYMBOL(can_fifo_pop);
+
+/* get a CAN free frame pointer from FIFO */
+can_frame_t *can_fifo_get(can_fifo_t *fifo, int *retval)
+{
+	can_frame_t *frame = NULL;
+
+	if ((fifo->end[0] == fifo->start + 1) || (fifo->end[0] == 0 &&
+		fifo->start == fifo->size - 1))
+			*retval = -EBUSY;
+	else {
+			*retval = 0;
+	}
+
+	frame = &(fifo->data[fifo->start]);
+	if (++fifo->start == fifo->size)
+		fifo->start = 0;
+	return frame;
+}
diff --git a/drivers/can/can-fifo.h b/drivers/can/can-fifo.h
new file mode 100644
index 0000000..34f8f9b
--- /dev/null
+++ b/drivers/can/can-fifo.h
@@ -0,0 +1,47 @@
+#ifndef _LINUX_CANFIFO_H
+#define _LINUX_CANFIFO_H
+#include <linux/spinlock.h>
+
+/* Maximum number of connected clients */
+#define CAN_MAX_USER		8
+#define CAN_MAX_USER_BIT	((1<<CAN_MAX_USER) - 1)
+
+typedef struct can_frame {
+	u32 id;			/* CAN ID */
+	u8 efi;			/* Extended format identifier  bit */
+	u8 data_len;
+	u8 rtr;			/* Remote transmission request bit */
+	u8 data[8];		/* Message */
+	struct timeval tv;	/* Timestamp for frame package */
+} can_frame_t;
+
+/* CAN FIFO structure */
+typedef struct can_fifo {
+	spinlock_t lock;
+	unsigned long flags;		/* Backup for interrupt status */
+	/*read overrun status bit, so CAN_MAX_ENDPOINTS should be less than
+	 * 32-bit*/
+	int rd_overrun_bit;
+	u32 user_counter;	/*can endpoint user counter */
+	int size;
+	int start;		/* Start offset */
+	int end[CAN_MAX_USER];	/* End offset */
+	can_frame_t *data;	/* Buffer loop-pool */
+} can_fifo_t;
+
+static inline void can_fifo_lock(can_fifo_t *fifo)
+{
+	spin_lock_irqsave(&fifo->lock, fifo->flags);
+}
+
+static inline void can_fifo_unlock(can_fifo_t *fifo)
+{
+	spin_unlock_irqrestore(&fifo->lock, fifo->flags);
+}
+
+extern int can_fifo_init(can_fifo_t *fifo, int size);
+extern int can_fifo_adduser(can_fifo_t *fifo);
+extern int can_fifo_deluser(can_fifo_t *fifo, int id);
+extern int can_fifo_push(can_fifo_t *fifo, can_frame_t *frame);
+extern can_frame_t *can_fifo_pop(can_fifo_t *fifo, int id, int *retval);
+#endif /* _LINUX_CANFIFO_H*/
diff --git a/drivers/can/can_tolapai.c b/drivers/can/can_tolapai.c
new file mode 100644
index 0000000..8093f81
--- /dev/null
+++ b/drivers/can/can_tolapai.c
@@ -0,0 +1,1832 @@
+/*****************************************************************************
+ * Intel Tolapai CAN Driver
+ *
+ * Re-written by Kevin Hao <Kexin.Hao@windriver.com>
+ * Based on Intel Tolapai CAN Driver
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *****************************************************************************/
+
+#include "can_tolapai.h"
+#include "can-fifo.h"
+#include "can-base.h"
+
+static can_tolapai_timing_t can_rec_timing[] = {
+	{10,  249, 12, 1, 0, 0, 0},		/*   10 kbits/s	     */
+	{20,  124, 12, 1, 0, 0, 0},		/*   20 kbits/s	     */
+	{50,   49, 12, 1, 0, 0, 0},		/*   50 kbits/s	     */
+	{125,  19, 12, 1, 0, 0, 0},		/*  125 kbits/s	     */
+	{250,   9, 12, 1, 0, 0, 0},		/*  250 kbits/s	     */
+	{500,   4, 12, 1, 0, 0, 0},		/*  500 kbits/s	     */
+	{800,   4,  6, 1, 0, 0, 0},		/*  800 kbits/s	     */
+	{1000,  4,  4, 1, 0, 0, 0}		/* 1000 kbits/s	     */
+};
+
+/*****************************************************************************
+ * Sets the value of a specified memory mapped register.
+ *****************************************************************************/
+static void can_reg_set(can_tolapai_dev_t *dev, unsigned int offset,
+				unsigned int mask, unsigned int value)
+{
+	unsigned int *reg = NULL;
+	unsigned int tmp;
+
+	reg = (unsigned int *)(dev->io_base + offset);
+
+	tmp = CAN_REG_READ(reg);	/* get the reg */
+	tmp &= ~mask;			/* clear the bits */
+	tmp |= (value & mask);		/* set the bits */
+
+	CAN_REG_WRITE(reg, tmp);	/* write the reg */
+}
+
+/*****************************************************************************
+ * Sets the value of a specified memory mapped register.
+ *****************************************************************************/
+static void can_reg_set_fast(
+	can_tolapai_dev_t	*dev,
+	unsigned int		offset,
+	unsigned int		value)
+{
+	unsigned int *reg = NULL;
+
+	reg = (unsigned int *)(dev->io_base + offset);
+	CAN_REG_WRITE(reg, value);	/* write the reg */
+}
+
+/*****************************************************************************
+ * Gets the value of a specified memory mapped register.
+ *****************************************************************************/
+static unsigned int can_reg_get(
+	can_tolapai_dev_t	*dev,
+	unsigned int		offset)
+{
+	unsigned int *reg = NULL;
+	unsigned int value = 0;
+
+	reg = (unsigned int *)(dev->io_base + offset);
+	value = CAN_REG_READ(reg);
+
+	return value;
+}
+
+/*****************************************************************************
+ * Sets the CAN to run or listen mode.
+ *****************************************************************************/
+static int can_tolapai_set_run_mode(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_run_mode_t	mode)
+{
+	int err = 0;
+	/*unsigned int txreq_status;*/
+
+	DEBUG_OUT("can_tolapai_set_run_mode");
+
+	switch (mode) {
+	case CAN_TOLAPAI_RUN:
+		can_reg_set(dev, MM_CMD, MSK_CMD_RUN, MSK_CMD_RUN);
+		break;
+	case CAN_TOLAPAI_STOP:
+		/*if ((txreq_status=(can_tolapai_get_buffer_status(dev)
+			& MSK_BS_TXALL))) {
+			can_tolapai_set_listen_mode(dev, CAN_TOLAPAI_LISTEN);
+		}*/
+		can_reg_set(dev, MM_CMD, MSK_CMD_RUN, 0);
+		break;
+	default:
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "run mode");
+		err = -1;
+		break;
+	}
+
+	return err;
+}
+
+static int can_tolapai_get_run_mode(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_run_mode_t	*mode)
+{
+	unsigned int cmd_reg;
+
+	DEBUG_OUT("can_tolapai_get_run_mode");
+
+	cmd_reg = can_reg_get(dev, MM_CMD);
+
+	if (cmd_reg & 1)
+		*mode = CAN_TOLAPAI_RUN;
+	else
+		*mode = CAN_TOLAPAI_STOP;
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Sets CAN's arbiter mode.
+ *****************************************************************************/
+static int can_tolapai_set_arbiter_mode(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_arbiter_t	mode)
+{
+	int err = 0;
+
+	DEBUG_OUT("can_tolapai_set_arbiter_mode");
+
+	switch (mode) {
+	case CAN_TOLAPAI_ROUND_ROBIN:
+		can_reg_set(dev, MM_CFG, MSK_CFG_ARB, 0);
+		break;
+	case CAN_TOLAPAI_FIXED_PRIORITY:
+		can_reg_set(dev, MM_CFG, MSK_CFG_ARB, MSK_CFG_ARB);
+		break;
+	default:
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "arbiter mode");
+		err = -1;
+		break;
+	}
+
+	return err;
+}
+
+/*****************************************************************************
+ * Gets CAN's arbiter mode.
+ *****************************************************************************/
+static int can_tolapai_get_arbiter_mode(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_arbiter_t	*mode)
+{
+	int err = 0;
+	unsigned int reg;
+
+	DEBUG_OUT("can_tolapai_get_arbiter_mode");
+
+	reg = can_reg_get(dev, MM_CFG);
+
+	if (reg & MSK_CFG_ARB)
+		*mode = CAN_TOLAPAI_FIXED_PRIORITY;
+	else
+		*mode = CAN_TOLAPAI_ROUND_ROBIN;
+
+	return err;
+}
+
+/*****************************************************************************
+ * Sets CAN's restart mode.
+ *****************************************************************************/
+static int can_tolapai_set_restart_mode(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_auto_restart_t	mode)
+{
+	int err = 0;
+
+	DEBUG_OUT("can_tolapai_set_restart_mode");
+
+	switch (mode) {
+	case CAN_TOLAPAI_MANUAL:
+		can_reg_set(dev, MM_CFG, MSK_CFG_RSTRT, 0<<BIT_CFG_RSTRT);
+		break;
+	case CAN_TOLAPAI_AUTO:
+		can_reg_set(dev, MM_CFG, MSK_CFG_RSTRT, 1<<BIT_CFG_RSTRT);
+		break;
+	default:
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "auto-restart mode");
+		err = -1;
+		break;
+	}
+
+	return err;
+}
+
+/*****************************************************************************
+ * Gets CAN's restart mode.
+ *****************************************************************************/
+static int can_tolapai_get_restart_mode(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_auto_restart_t *mode)
+{
+	int err = 0;
+	unsigned int reg;
+
+	DEBUG_OUT("can_tolapai_get_restart_mode");
+
+	reg = can_reg_get(dev, MM_CFG);
+
+	if (reg & (1<<BIT_CFG_RSTRT))
+		*mode = CAN_TOLAPAI_AUTO;
+	else
+		*mode = CAN_TOLAPAI_MANUAL;
+
+	return err;
+}
+
+/*****************************************************************************
+ * Sets CAN's active/listen mode.
+ *****************************************************************************/
+static int can_tolapai_set_listen_mode(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_listen_mode_t	mode)
+{
+	int err = 0;
+
+	DEBUG_OUT("can_tolapai_set_listen_mode");
+
+	switch (mode) {
+	case CAN_TOLAPAI_LISTEN:
+		can_reg_set(dev, MM_CMD, MSK_CMD_LISTEN, MSK_CMD_LISTEN);
+		break;
+	case CAN_TOLAPAI_ACTIVE:
+		can_reg_set(dev, MM_CMD, MSK_CMD_LISTEN, 0);
+		break;
+	default:
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "listen mode");
+		err = -1;
+		break;
+	}
+
+	return err;
+}
+
+/*****************************************************************************
+ * Sets the CAN to run or listen mode.
+ *****************************************************************************/
+static int can_tolapai_get_listen_mode(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_listen_mode_t *mode)
+{
+	unsigned int reg;
+
+	DEBUG_OUT("can_tolapai_get_listen_mode");
+
+	reg = can_reg_get(dev, MM_CMD);
+
+	if (reg & (1<<BIT_CMD_LISTEN))
+		*mode = CAN_TOLAPAI_ACTIVE;
+	else
+		*mode = CAN_TOLAPAI_LISTEN;
+
+	return 0;
+}
+
+static int can_tolapai_get_int_enables(
+	can_tolapai_dev_t	*dev,
+	unsigned int		*enables)
+{
+	unsigned int *reg = NULL;
+
+	DEBUG_OUT("can_tolapai_get_int_enables");
+
+	reg = (unsigned int *)(dev->io_base + MM_INTENBL);
+	*enables = CAN_REG_READ(reg);
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Enables/disables interrupts and sets "interrupt enables".
+ *****************************************************************************/
+static int can_tolapai_set_int_enables(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_interrupt_t	interrupt)
+{
+	unsigned int *reg = NULL;
+	unsigned int tmp;
+	int err = 0;
+
+	DEBUG_OUT("can_tolapai_set_int_enables");
+
+	switch (interrupt) {
+	case CAN_TOLAPAI_ENABLE:
+		reg = (unsigned int *)(dev->io_base + MM_INTENBL);
+		tmp = CAN_REG_READ(reg);
+		tmp &= ~MSK_IE_INTENBL;
+		tmp |= MSK_IE_INTENBL;
+		CAN_REG_WRITE(reg, tmp);
+		break;
+	case CAN_TOLAPAI_DISABLE:
+		reg = (unsigned int *)(dev->io_base + MM_INTENBL);
+		tmp = CAN_REG_READ(reg);
+		tmp &= ~MSK_IE_INTENBL;
+		CAN_REG_WRITE(reg, tmp);
+		break;
+	case CAN_TOLAPAI_ALL:
+		can_reg_set(dev, MM_INTENBL, MSK_IE_ALL, MSK_IE_ALL);
+		break;
+	case CAN_TOLAPAI_NONE:
+		can_reg_set(dev, MM_INTENBL, MSK_IE_ALL, 0x0);
+		break;
+	default:
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "interrupt");
+		err = -1;
+		break;
+	}
+
+	return err;
+}
+
+static int can_tolapai_rx_enable_all(can_tolapai_dev_t *dev)
+{
+	unsigned int i;
+
+	DEBUG_OUT("can_tolapai_rx_enable_all");
+
+	for (i = 0; i < NUM_RX_BUFFS; i++)
+		can_tolapai_set_rx_enable(dev, i, 1);
+
+	return 0;
+}
+
+static int can_tolapai_rx_disable_all(can_tolapai_dev_t *dev)
+{
+	unsigned int i;
+
+	DEBUG_OUT("can_tolapai_rx_disable_all");
+
+	for (i = 0; i < NUM_RX_BUFFS; i++)
+		can_tolapai_set_rx_enable(dev, i, 0);
+
+	return 0;
+}
+
+static int can_tolapai_tx_enable_all(can_tolapai_dev_t *dev)
+{
+	unsigned int i;
+
+	DEBUG_OUT("can_tolapai_tx_enable_all");
+
+	for (i = 0; i < NUM_TX_BUFFS; i++)
+		can_tolapai_set_tx_enable(dev, i, 1);
+
+	return 0;
+}
+
+static int can_tolapai_rx_init_filter(
+	can_tolapai_dev_t	*dev,
+	unsigned int		buff_num)
+{
+	int err;
+	can_tolapai_rx_filter_t filter;
+
+	DEBUG_OUT("can_tolapai_rx_init_filter");
+
+	if (buff_num >= NUM_RX_BUFFS) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "buff_num");
+		return -1;
+	}
+
+	/* Set all Rx filters to allow all msgs. */
+	filter.amr.id 		= ~0;
+	filter.amr.id_ext  	= ~0;
+	filter.amr.rtr 		= ~0;
+	filter.amr.data 	= ~0;
+	filter.acr.id 		= 0;
+	filter.acr.id_ext  	= 0;
+	filter.acr.rtr 		= 0;
+	filter.acr.data 	= 0;
+	filter.num 	        = buff_num;
+
+	err = can_tolapai_set_rx_filter(dev, &filter);
+
+	return err;
+}
+
+static int can_tolapai_set_rx_enable(
+	can_tolapai_dev_t	*dev,
+	unsigned int 		buff_num,
+	unsigned int		set)
+{
+	unsigned int offset;
+
+	DEBUG_OUT("can_tolapai_set_rx_enable");
+
+	if (buff_num >= NUM_RX_BUFFS) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "buff_num");
+		return -1;
+	}
+
+	/* Enable / disable buffer */
+	offset = MM_RX0 + (buff_num * (MM_RX1 - MM_RX0)) + MM_RXCTL;
+	can_reg_set(dev, offset,
+		MSK_RXCTL_BUFENBL | MSK_RXCTL_WPNL,
+		set ? (MSK_RXCTL_BUFENBL | MSK_RXCTL_WPNL) :
+		      (0x0 | MSK_RXCTL_WPNL));
+
+	/* Enable / disable interrupt */
+	can_reg_set(dev, offset,
+		MSK_RXCTL_INTENBL | MSK_RXCTL_WPNL,
+		set ? (MSK_RXCTL_INTENBL  | MSK_RXCTL_WPNL) :
+		      (0x0 | MSK_RXCTL_WPNL));
+
+	return 0;
+}
+
+static int can_tolapai_get_rx_enable(
+	can_tolapai_dev_t	*dev,
+	unsigned int 		buff_num,
+	unsigned int		*enable)
+{
+	unsigned int offset;
+
+	DEBUG_OUT("can_tolapai_get_rx_enable");
+
+	if (buff_num >= NUM_RX_BUFFS) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "buff_num");
+		return -1;
+	}
+
+	/* Enable buffer */
+	offset = MM_RX0 + (buff_num * (MM_RX1 - MM_RX0)) + MM_RXCTL;
+	can_reg_set(dev, offset, MSK_RXCTL_BUFENBL, MSK_RXCTL_BUFENBL);
+	*enable = (can_reg_get(dev, offset) & MSK_RXCTL_BUFENBL)
+				>> BIT_RXCTL_BUFENBL;
+
+	return 0;
+}
+
+static int can_tolapai_set_tx_enable(
+	can_tolapai_dev_t	*dev,
+	unsigned int 		buff_num,
+	unsigned int		set)
+{
+	unsigned int offset;
+
+	DEBUG_OUT("can_tolapai_set_tx_enable");
+
+	if (buff_num >= NUM_TX_BUFFS) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "buff_num");
+		return -1;
+	}
+
+	/* Enable / disable interrupt */
+	offset = MM_TX0 + (buff_num * (MM_TX1 - MM_TX0)) + MM_TXCTL;
+	can_reg_set(dev, offset,
+		MSK_TXCTL_INTENBL | MSK_TXCTL_WPN0,
+		set ? (MSK_TXCTL_INTENBL | MSK_TXCTL_WPN0) :
+			  (0x0 | MSK_TXCTL_WPN0));
+
+	return 0;
+}
+
+static int can_tolapai_get_tx_enable(
+	can_tolapai_dev_t	*dev,
+	unsigned int 		buff_num,
+	unsigned int		*enable)
+{
+	unsigned int offset;
+
+	DEBUG_OUT("can_tolapai_get_tx_enable");
+
+	if (buff_num >= NUM_TX_BUFFS) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "buff_num");
+		return -1;
+	}
+
+	/* Get interrupt enable */
+	offset = MM_TX0 + (buff_num * (MM_TX1 - MM_TX0)) + MM_TXCTL;
+	*enable = (can_reg_get(dev, offset) & MSK_TXCTL_INTENBL)
+			>> BIT_TXCTL_INTENBL;
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Returns CAN device's interrupt status; i.e. any ints pending?
+ *****************************************************************************/
+static unsigned int can_tolapai_int_pending(can_tolapai_dev_t *dev)
+{
+	/*DEBUG_OUT("can_tolapai_int_pending");*/
+
+	return can_reg_get(dev, MM_INTSTAT);
+}
+
+/*****************************************************************************
+ * Set the baud rate of the CAN device based on recommended timings.
+ *****************************************************************************/
+static int can_tolapai_set_baud_simple(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_baud_t	baud)
+{
+	unsigned int mask = 0;
+	unsigned int reg = 0;
+
+	DEBUG_OUT("can_tolapai_set_baud_simple");
+
+	if (baud > CAN_TOLAPAI_BAUD_1000) {
+		DEBUG_OUT("Wrong baud parameter\n");
+		return -EINVAL;
+	}
+
+	mask = MSK_CFG_BITRATE | MSK_CFG_TSEG1 | MSK_CFG_TSEG2 | MSK_CFG_SJW |
+			MSK_CFG_SMPL | MSK_CFG_EDGE;
+
+	reg = 	(can_rec_timing[baud].cfg_bitrate << BIT_CFG_BITRATE) |
+		(can_rec_timing[baud].cfg_tseg1   << BIT_CFG_TSEG1)   |
+		(can_rec_timing[baud].cfg_tseg2   << BIT_CFG_TSEG2)   |
+		(can_rec_timing[baud].cfg_sjw     << BIT_CFG_SJW)     |
+		(can_rec_timing[baud].smpl_mode   << BIT_CFG_SMPL)    |
+		(can_rec_timing[baud].edge_mode   << BIT_CFG_EDGE);
+
+	can_reg_set(dev, MM_CFG, mask, reg);
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Sets the CAN baud rate set; user specifies all timing parameters.
+ *****************************************************************************/
+static int can_tolapai_set_baud_custom(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_timing_t	*timing)
+{
+	unsigned int mask = 0;
+	unsigned int reg = 0;
+
+	DEBUG_OUT("can_tolapai_set_baud_custom");
+
+	/* max is 32768 */
+	if (timing->cfg_bitrate > 32768) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "timing->cfg_bitrate");
+		return -1;
+	}
+
+	/* 0 and 1 not allowed */
+	if (timing->cfg_tseg1 < 2) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "timing->cfg_tseg1");
+		return -1;
+	}
+
+	/* 0 is not allowed; 1 is allowed if sample_mode is direct */
+	if (timing->cfg_tseg2 == 0) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "timing->cfg_tseg2");
+		return -1;
+	}
+
+	if ((timing->cfg_tseg2 == 1) && (timing->smpl_mode != 0)) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "timing->cfg_tseg2");
+		return -1;
+	}
+
+	/* sjw <= tseg1; sjw <= tseg2 */
+	if ((timing->cfg_sjw > timing->cfg_tseg1) ||
+		(timing->cfg_sjw > timing->cfg_tseg2)) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "timing->cfg_sjw");
+		return -1;
+	}
+
+	/* 0 and 1 are the only valid values */
+	if (timing->smpl_mode > 1) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "timing->smpl_mode");
+		return -1;
+	}
+
+	/* 0 and 1 are the only valid values */
+	if (timing->edge_mode > 1) {
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_PARAM, "timing->edge_mode");
+		return -1;
+	}
+
+	mask = MSK_CFG_BITRATE | MSK_CFG_TSEG1 | MSK_CFG_TSEG2 | MSK_CFG_SJW |
+			MSK_CFG_SMPL | MSK_CFG_EDGE;
+
+	reg = 	(timing->cfg_bitrate << BIT_CFG_BITRATE) |
+		(timing->cfg_tseg1   << BIT_CFG_TSEG1)   |
+		(timing->cfg_tseg2   << BIT_CFG_TSEG2)   |
+		(timing->cfg_sjw     << BIT_CFG_SJW)     |
+		(timing->smpl_mode   << BIT_CFG_SMPL)    |
+		(timing->edge_mode   << BIT_CFG_EDGE);
+
+	can_reg_set(dev, MM_CFG, mask, reg);
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Gets the CAN baud rate set.
+ *****************************************************************************/
+static int can_tolapai_get_baud(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_timing_t	*timing)
+{
+	unsigned int timing_reg = 0;
+
+	DEBUG_OUT("can_tolapai_get_baud");
+
+	timing_reg = can_reg_get(dev, MM_CFG);
+
+	timing->cfg_bitrate = (timing_reg & MSK_CFG_BITRATE) >> BIT_CFG_BITRATE;
+	timing->cfg_tseg1 = (timing_reg & MSK_CFG_TSEG1) >> BIT_CFG_TSEG1;
+	timing->cfg_tseg2 = (timing_reg & MSK_CFG_TSEG2) >> BIT_CFG_TSEG2;
+	timing->cfg_sjw = (timing_reg & MSK_CFG_SJW) >> BIT_CFG_SJW;
+	timing->smpl_mode = (timing_reg & MSK_CFG_SMPL) >> BIT_CFG_SMPL;
+	timing->edge_mode = (timing_reg & MSK_CFG_EDGE) >> BIT_CFG_EDGE;
+
+	return 0;
+}
+/*****************************************************************************
+ * Resets the CAN Rx/Tx buffers.
+ *****************************************************************************/
+static int can_tolapai_clear_buffers(can_tolapai_dev_t *dev)
+{
+	unsigned int base;
+	unsigned int offset;
+	unsigned int buff_num;
+
+	DEBUG_OUT("can_tolapai_clear_buffers");
+
+	/* Zero out Tx Buffers */
+	for (buff_num = 0; buff_num < NUM_TX_BUFFS; buff_num++) {
+		base = MM_TX0 + (buff_num * (MM_TX1 - MM_TX0));
+
+		/* Control Register */
+		offset = base;
+		can_reg_set_fast(dev, offset, 0x00800008);
+
+		/* Message Id */
+		offset = base + MM_TXID;
+		can_reg_set_fast(dev, offset, 0x00000000);
+
+		/* Data Hi */
+		offset = base + MM_TXDATAH;
+		can_reg_set_fast(dev, offset, 0x00000000);
+
+		/* Data Lo */
+		offset = base + MM_TXDATAL;
+		can_reg_set_fast(dev, offset, 0x00000000);
+	}
+
+	/* Zero out Rx Buffers */
+	for (buff_num = 0; buff_num < NUM_RX_BUFFS; buff_num++) {
+		base = MM_RX0 + (buff_num * (MM_RX1 - MM_RX0));
+
+		/* Control Register */
+		offset = base;
+		if (buff_num < (NUM_RX_BUFFS - 1)) {
+			/* enable link on everyone else */
+			can_reg_set_fast(dev, offset, 0x008000c0);
+		} else {
+			/* don't enable link on last buffer */
+			can_reg_set_fast(dev, offset, 0x00800080);
+		}
+
+		/* Message Id */
+		offset = base + MM_RXID;
+		can_reg_set_fast(dev, offset, 0x00000000);
+
+		/* Data Hi */
+		offset = base + MM_RXDATAH;
+		can_reg_set_fast(dev, offset, 0x00000000);
+
+		/* Data Lo */
+		offset = base + MM_RXDATAL;
+		can_reg_set_fast(dev, offset, 0x00000000);
+
+		/* AMR */
+		offset = base + MM_RXAMR;
+		can_reg_set_fast(dev, offset, 0x00000000);
+
+		/* ACR */
+		offset = base + MM_RXACR;
+		can_reg_set_fast(dev, offset, 0x00000000);
+
+		/* AMR Data */
+		offset = base + MM_RXAMRDATA;
+		can_reg_set_fast(dev, offset, 0x00000000);
+
+		/* ACR Data */
+		offset = base + MM_RXACRDATA;
+		can_reg_set_fast(dev, offset, 0x00000000);
+	}
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Sets the Rx filter for a receive buffer.
+ *****************************************************************************/
+static int can_tolapai_set_rx_filter(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_rx_filter_t	*filter)
+{
+	unsigned int rx_offset;
+	unsigned int offset;
+	unsigned int mask;
+	unsigned int reg;
+
+	DEBUG_OUT("can_tolapai_set_rx_filter");
+
+	/* Find the n'th Rx buffer. */
+	rx_offset = MM_RX0 + (filter->num * (MM_RX1 - MM_RX0));
+
+	/* AMR */
+	offset = rx_offset + MM_RXAMR;
+	mask = MSK_RXAMR_RTR | MSK_RXAMR_IDE | MSK_RXAMR_ID;
+	reg = ((filter->amr.rtr) ? MSK_RXAMR_RTR : 0) |
+		  ((filter->amr.id_ext) ? MSK_RXAMR_IDE : 0);
+
+	if (filter->amr.id_ext) {
+		reg |= ((filter->amr.id << BIT_RXAMR_ID) & MSK_RXAMR_ID);
+	} else {
+		reg |= ((filter->amr.id << BIT_RXAMR_ID_UPPER) &
+				(MSK_RXAMR_ID_UPPER));
+		/* 17:0 ext id bits set to don't care */
+		reg |= 0x3ffff << BIT_RXAMR_ID;
+	}
+	can_reg_set(dev, offset, mask, reg);
+
+	/* ACR */
+	offset = rx_offset + MM_RXACR;
+	mask = MSK_RXACR_RTR | MSK_RXACR_IDE | MSK_RXACR_ID;
+	reg = ((filter->acr.rtr) ? MSK_RXACR_RTR : 0) |
+		  ((filter->acr.id_ext) ? MSK_RXACR_IDE : 0);
+
+	if (filter->acr.id_ext) {
+		reg |= ((filter->acr.id << BIT_RXACR_ID) & MSK_RXACR_ID);
+	} else {
+		reg |= ((filter->acr.id << BIT_RXACR_ID_UPPER) &
+				(MSK_RXACR_ID_UPPER));
+		/* 17:0 ext id bits set to don't care */
+		reg |= 0x3ffff << BIT_RXACR_ID;
+	}
+	can_reg_set(dev, offset, mask, reg);
+
+	/* AMR data */
+	offset = rx_offset + MM_RXAMRDATA;
+	can_reg_set(dev, offset, MSK_RXAMRDATA,
+		filter->amr.data << BIT_RXAMRDATA);
+
+	/* ACR data */
+	offset = rx_offset + MM_RXACRDATA;
+	can_reg_set(dev, offset, MSK_RXACRDATA,
+		filter->acr.data<<BIT_RXACRDATA);
+
+	return 0;
+}
+
+static int can_tolapai_set_rx_buffer_link(
+	can_tolapai_dev_t	*dev,
+	unsigned int		buffer_num,
+	unsigned int 		set)
+{
+	unsigned int rx_offset;
+	unsigned int offset;
+	unsigned int reg;
+
+	/* Find the n'th Rx buffer. */
+	rx_offset = MM_RX0 + (buffer_num * (MM_RX1 - MM_RX0));
+
+	/* Message Control */
+	offset = rx_offset + MM_RXCTL;
+	reg = can_reg_get(dev, offset);
+
+	can_reg_set(dev, offset,
+		MSK_RXCTL_WPNL | MSK_RXCTL_LNKFLG,
+		(set) ? (MSK_RXCTL_WPNL | MSK_RXCTL_LNKFLG) : (MSK_RXCTL_WPNL));
+
+	return 0;
+}
+
+static int can_tolapai_get_rx_buffer_link(
+	can_tolapai_dev_t	*dev,
+	unsigned int		buffer_num,
+	unsigned int 		*link)
+{
+	unsigned int rx_offset;
+	unsigned int offset;
+
+	DEBUG_OUT("can_tolapai_get_rx_buffer_link");
+
+	/* Find the n'th Rx buffer. */
+	rx_offset = MM_RX0 + (buffer_num * (MM_RX1 - MM_RX0));
+
+	/* Message Control */
+	offset = rx_offset + MM_RXCTL;
+
+	*link = (can_reg_get(dev, offset) & MSK_RXCTL_LNKFLG)
+			>> BIT_RXCTL_LNKFLG;
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Gets the Rx filter for a receive buffer.
+ *****************************************************************************/
+static int can_tolapai_get_rx_filter(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_rx_filter_t	*filter)
+{
+	unsigned int rx_offset;
+	unsigned int offset;
+	unsigned int reg;
+
+	DEBUG_OUT("can_tolapai_get_rx_filter");
+
+	/* Find the n'th Rx buffer. */
+	rx_offset = MM_RX0 + (filter->num * (MM_RX1 - MM_RX0));
+
+	/* AMR */
+	offset = rx_offset + MM_RXAMR;
+	reg = can_reg_get(dev, offset);
+	filter->amr.rtr = (reg & MSK_RXAMR_RTR) >> BIT_RXAMR_RTR;
+	filter->amr.id_ext = (reg & MSK_RXAMR_IDE) >> BIT_RXAMR_IDE;
+
+	if (!(filter->amr.id_ext))
+		filter->amr.id = (reg & MSK_RXAMR_ID) >> BIT_RXAMR_ID_UPPER;
+	else
+		filter->amr.id = (reg & MSK_RXAMR_ID) >> BIT_RXAMR_ID;
+
+	/* ACR */
+	offset = rx_offset + MM_RXACR;
+	reg = can_reg_get(dev, offset);
+	filter->acr.rtr = (reg & MSK_RXACR_RTR) >> BIT_RXACR_RTR;
+	filter->acr.id_ext = (reg & MSK_RXACR_IDE) >> BIT_RXACR_IDE;
+
+	if (!(filter->acr.id_ext))
+		filter->acr.id = (reg & MSK_RXACR_ID) >> BIT_RXACR_ID_UPPER;
+	else
+		filter->acr.id = (reg & MSK_RXACR_ID) >> BIT_RXACR_ID;
+
+	/* AMR data */
+	offset = rx_offset + MM_RXAMRDATA;
+	reg = can_reg_get(dev, offset);
+	filter->amr.data = (reg & MSK_RXAMRDATA) >> BIT_RXAMRDATA;
+
+	/* ACR data */
+	offset = rx_offset + MM_RXACRDATA;
+	reg = can_reg_get(dev, offset);
+	filter->acr.data = (reg & MSK_RXACRDATA) >> BIT_RXACRDATA;
+
+	return 0;
+}
+/*****************************************************************************
+ * Clears an interrupt.
+ *****************************************************************************/
+static void can_tolapai_int_clr(
+	can_tolapai_dev_t	*dev,
+	unsigned int		mask)
+{
+	DEBUG_OUT("can_tolapai_int_clr");
+
+	/* Interrupts are cleared by setting a one
+	   to the interrupt status bits. */
+
+	can_reg_set(dev, MM_INTSTAT, mask, mask);
+}
+
+/*****************************************************************************
+ * Get the Rx and Tx buffer status.
+ *****************************************************************************/
+static unsigned int can_tolapai_get_buffer_status(can_tolapai_dev_t *dev)
+{
+	DEBUG_OUT("can_tolapai__get_buffer_status");
+
+	return can_reg_get(dev, MM_BUFFSTAT);
+}
+
+/*****************************************************************************
+ * Get a pending Rx message.
+ *****************************************************************************/
+static int can_tolapai_rx_dequeue(
+	can_tolapai_dev_t	*dev,
+	can_frame_t		*msg,
+	unsigned int		buff_num)
+{
+	unsigned int i = 0;
+	unsigned int offset;
+	unsigned int data;
+	unsigned int tmp;
+	char *data_tmp = msg->data;
+
+	DEBUG_OUT("can_tolapai_rx_dequeue");
+
+	/* Message base */
+	offset = MM_RX0 + (buff_num * (MM_RX1 - MM_RX0));
+
+	/* DLC, RTR, IDE */
+	tmp = can_reg_get(dev, offset + MM_RXCTL);
+	msg->data_len = (tmp & MSK_RXCTL_DLC) >> BIT_RXCTL_DLC;
+	msg->rtr = (tmp & MSK_RXCTL_RTR) ? 1 : 0;
+	msg->efi = (tmp & MSK_RXCTL_IDE) ? 1 : 0;
+
+	/* ID */
+	if (msg->efi) {
+		msg->id = can_reg_get(dev, offset + MM_RXID)
+					>> BIT_RXID;
+	} else {
+		msg->id = can_reg_get(dev, offset + MM_RXID)
+					>> BIT_RXID_UPPER;
+	}
+
+	/* Data */
+	switch (msg->data_len) {
+	case 0:
+		break;
+	case 1:
+		/* Data high */
+		data = can_reg_get(dev, offset + MM_RXDATAH);
+		data_tmp[0] = (data & 0xff000000) >> 24;
+		break;
+	case 2:
+		/* Data high */
+		data = can_reg_get(dev, offset + MM_RXDATAH);
+		data_tmp[0] = (data & 0xff000000) >> 24;
+		data_tmp[1] = (data & 0x00ff0000) >> 16;
+		break;
+	case 3:
+		/* Data high */
+		data = can_reg_get(dev, offset + MM_RXDATAH);
+		data_tmp[0] = (data & 0xff000000) >> 24;
+		data_tmp[1] = (data & 0x00ff0000) >> 16;
+		data_tmp[2] = (data & 0x0000ff00) >> 8;
+		break;
+	case 4:
+		/* Data high */
+		data = can_reg_get(dev, offset + MM_RXDATAH);
+		data_tmp[0] = (data & 0xff000000) >> 24;
+		data_tmp[1] = (data & 0x00ff0000) >> 16;
+		data_tmp[2] = (data & 0x0000ff00) >> 8;
+		data_tmp[3] = (data & 0x000000ff);
+		break;
+	case 5:
+		/* Data high */
+		data = can_reg_get(dev, offset + MM_RXDATAH);
+		data_tmp[0] = (data & 0xff000000) >> 24;
+		data_tmp[1] = (data & 0x00ff0000) >> 16;
+		data_tmp[2] = (data & 0x0000ff00) >> 8;
+		data_tmp[3] = (data & 0x000000ff);
+
+		/* Data low */
+		data = can_reg_get(dev, offset + MM_RXDATAL);
+		data_tmp[4] = (data & 0xff000000) >> 24;
+		break;
+	case 6:
+		/* Data high */
+		data = can_reg_get(dev, offset + MM_RXDATAH);
+		data_tmp[0] = (data & 0xff000000) >> 24;
+		data_tmp[1] = (data & 0x00ff0000) >> 16;
+		data_tmp[2] = (data & 0x0000ff00) >> 8;
+		data_tmp[3] = (data & 0x000000ff);
+
+		/* Data low */
+		data = can_reg_get(dev, offset + MM_RXDATAL);
+		data_tmp[4] = (data & 0xff000000) >> 24;
+		data_tmp[5] = (data & 0x00ff0000) >> 16;
+		break;
+	case 7:
+		/* Data high */
+		data = can_reg_get(dev, offset + MM_RXDATAH);
+		data_tmp[0] = (data & 0xff000000) >> 24;
+		data_tmp[1] = (data & 0x00ff0000) >> 16;
+		data_tmp[2] = (data & 0x0000ff00) >> 8;
+		data_tmp[3] = (data & 0x000000ff);
+
+		/* Data low */
+		data = can_reg_get(dev, offset + MM_RXDATAL);
+		data_tmp[4] = (data & 0xff000000) >> 24;
+		data_tmp[5] = (data & 0x00ff0000) >> 16;
+		data_tmp[6] = (data & 0x0000ff00) >> 8;
+		break;
+	case 8:
+	default:
+		/* Data high */
+		data = can_reg_get(dev, offset + MM_RXDATAH);
+		data_tmp[0] = (data & 0xff000000) >> 24;
+		data_tmp[1] = (data & 0x00ff0000) >> 16;
+		data_tmp[2] = (data & 0x0000ff00) >> 8;
+		data_tmp[3] = (data & 0x000000ff);
+
+		/* Data low */
+		data = can_reg_get(dev, offset + MM_RXDATAL);
+		data_tmp[4] = (data & 0xff000000) >> 24;
+		data_tmp[5] = (data & 0x00ff0000) >> 16;
+		data_tmp[6] = (data & 0x0000ff00) >> 8;
+		data_tmp[7] = (data & 0x000000ff);
+		break;
+	}
+
+	/* Clear unused Data bytes */
+	for (i = msg->data_len; i < CAN_TOLAPAI_MSG_DATA_LEN; i++)
+		msg->data[i] = 0x00;
+
+	/* Clear MsgAv since we got the message */
+	can_reg_set(dev, offset + MM_RXCMD, MSK_RXCMD_MSGAV, MSK_RXCMD_MSGAV);
+	do_gettimeofday(&msg->tv);
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Log stat/error messages.
+ *****************************************************************************/
+static void can_tolapai_log_message(unsigned int status)
+{
+	DEBUG_OUT("can_tolapai_log_message");
+
+	if (status & MSK_IS_OVRLOAD)
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_DEVICE, "overload");
+	else if (status & MSK_IS_BITERR)
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_DEVICE, "bit error");
+	else if (status & MSK_IS_STUFFERR)
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_DEVICE, "stuff error");
+	else if (status & MSK_IS_ACKERR)
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_DEVICE, "ack error");
+	else if (status & MSK_IS_FORMERR)
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_DEVICE, "form error");
+	else if (status & MSK_IS_CRCERR)
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_DEVICE, "CRC error");
+	else if (status & MSK_IS_BUSOFF)
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_DEVICE, "bus off");
+	else if (status & MSK_IS_RXMSGLOSS)
+		CAN_PRINT_DEBUG(CAN_TOLAPAI_ERR_DEVICE, "recv msg loss");
+}
+
+/*****************************************************************************
+ * Get stat/error messages.
+ *****************************************************************************/
+static int can_tolapai_get_error_stats(
+	can_tolapai_dev_t	*dev,
+	can_tolapai_error_t		*error)
+{
+	unsigned int reg;
+
+	DEBUG_OUT("can_tolapai_get_error_stats");
+
+	reg = can_reg_get(dev, MM_ERRSTAT);
+
+	error->rxgte96 = reg & MSK_ES_RXGTE96 >> BIT_ES_RXGTE96;
+	error->txgte96 = reg & MSK_ES_TXGTE96 >> BIT_ES_TXGTE96;
+	error->error_stat = reg & MSK_ES_ERRSTAT >> BIT_ES_ERRSTAT;
+	error->rx_err_cnt = reg & MSK_ES_RXERRCNT >> BIT_ES_RXERRCNT;
+	error->tx_err_cnt = reg & MSK_ES_TXERRCNT >> BIT_ES_TXERRCNT;
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Transmit a CAN message.
+ *****************************************************************************/
+static int can_tolapai_msg_tx(
+	can_tolapai_dev_t	*dev,
+	can_frame_t		*msg)
+{
+	unsigned int offset;
+	unsigned int txreq;
+	unsigned int data;
+	unsigned int buffer_status;
+	unsigned int tx_buffer_avail;
+	can_tolapai_run_mode_t	run_mode;
+
+	DEBUG_OUT("can_tolapai_msg_tx");
+
+	can_tolapai_get_run_mode(dev, &run_mode);
+
+	if (run_mode != CAN_TOLAPAI_RUN) {
+		printk(CAN_TOLAPAI_ERR_DEVICE, "CAN stopped on transmit "
+			"attempt");
+		return -1;
+	}
+
+	buffer_status = can_tolapai_get_buffer_status(dev);
+	buffer_status = (buffer_status & MSK_BS_TXALL) >> BIT_BS_TXMSG0;
+
+	tx_buffer_avail = 0;
+	while (buffer_status & 0x1) {
+		buffer_status = buffer_status >> 0x1;
+		tx_buffer_avail++;
+	}
+
+	if (tx_buffer_avail >= NUM_TX_BUFFS) {
+		printk(CAN_TOLAPAI_ERR_DEVICE, "transmit buffer full");
+		return -1;
+	};
+
+	offset = MM_TX0 + (tx_buffer_avail * (MM_TX1 - MM_TX0));
+	txreq = can_reg_get(dev, offset + MM_TXCMD) & MSK_TXCMD_REQ;
+	if (!txreq) {
+		/* RTR, IDE, DLC */
+		can_reg_set(dev,
+			offset + MM_TXCTL,
+			MSK_TXCTL_RTR |
+			MSK_TXCTL_IDE |
+			MSK_TXCTL_DLC |
+			MSK_TXCTL_WPN1,
+			((msg->rtr) ? MSK_TXCTL_RTR : 0) |
+			((msg->efi) ? MSK_TXCTL_IDE : 0) |
+			((msg->data_len)<<BIT_TXCTL_DLC) |
+			MSK_TXCTL_WPN1);
+
+		/* ID */
+		if (msg->efi)
+			data = msg->id << BIT_TXID;
+		else
+			data = msg->id << BIT_TXID_UPPER;
+
+		can_reg_set(dev, offset + MM_TXID, 0xfffffff8, data);
+
+		/* Data */
+		data = (msg->data[0]<<24) | (msg->data[1]<<16) |
+			(msg->data[2]<<8) | (msg->data[3]);
+		can_reg_set_fast(dev, offset + MM_TXDATAH, data);
+
+		data = (msg->data[4]<<24) | (msg->data[5]<<16) |
+			(msg->data[6]<<8) | (msg->data[7]);
+		can_reg_set_fast(dev, offset + MM_TXDATAL, data);
+
+		/* Transmit the message */
+		can_reg_set(dev, offset + MM_TXCMD, MSK_TXCMD_REQ,
+				MSK_TXCMD_REQ);
+
+		if (dev->block_mode)
+			interruptible_sleep_on(&dev->write_wait_queue);
+		return 0;
+	}
+
+	return -1;
+}
+
+/*****************************************************************************
+ * Device IO control.
+ *****************************************************************************/
+static int can_tolapai_ioctl(struct can_endpoint_t *ep, unsigned int cmd,
+			unsigned long arg)
+{
+	can_tolapai_dev_t *dev = (can_tolapai_dev_t *)ep->chip;
+	void __user *argp = (void __user *)arg;
+	unsigned long var;
+	unsigned int err = 0;
+	can_tolapai_timing_t tm;
+	can_tolapai_rx_filter_t filter;
+	can_tolapai_error_t error;
+
+	switch (cmd) {
+	case CAN_TOLAPAI_IO_RESET:
+		can_tolapai_set_run_mode(dev, CAN_TOLAPAI_STOP);
+		can_tolapai_reset(dev);
+		can_tolapai_set_run_mode(dev, CAN_TOLAPAI_RUN);
+		break;
+	case CAN_TOLAPAI_IO_RUN:
+		err = can_tolapai_set_run_mode(dev, CAN_TOLAPAI_RUN);
+		break;
+	case CAN_TOLAPAI_IO_RUN_GET:
+		err = can_tolapai_get_run_mode(
+			dev, (can_tolapai_run_mode_t *)&var);
+		put_user(var, (unsigned long *)argp);
+		break;
+	case CAN_TOLAPAI_IO_STOP:
+		err = can_tolapai_set_run_mode(dev, CAN_TOLAPAI_STOP);
+		break;
+	case CAN_TOLAPAI_IO_SIMPLE:
+		can_tolapai_set_run_mode(dev, CAN_TOLAPAI_STOP);
+		err = can_tolapai_set_baud_simple(
+			dev, ((can_tolapai_baud_t)arg));
+		can_tolapai_set_run_mode(dev, CAN_TOLAPAI_RUN);
+		break;
+	case CAN_TOLAPAI_IO_CUSTOM:
+		if (copy_from_user(&tm, argp, sizeof(tm))) {
+			err = -EFAULT;
+			break;
+		}
+		can_tolapai_set_run_mode(dev, CAN_TOLAPAI_STOP);
+		err = can_tolapai_set_baud_custom(
+			dev, (can_tolapai_timing_t *)&tm);
+		can_tolapai_set_run_mode(dev, CAN_TOLAPAI_RUN);
+		break;
+	case CAN_TOLAPAI_IO_TIMING_GET:
+		err = can_tolapai_get_baud(dev, (can_tolapai_timing_t *)&tm);
+		if (copy_to_user(argp, &tm, sizeof(tm)))
+			err = -EFAULT;
+		break;
+	case CAN_TOLAPAI_IO_FILTER:
+		if (copy_from_user(&filter, argp, sizeof(filter))) {
+			err = -EFAULT;
+			break;
+		}
+		can_tolapai_set_rx_filter(
+			dev, (can_tolapai_rx_filter_t *)&filter);
+		break;
+	case CAN_TOLAPAI_IO_FILTER_GET:
+		err = can_tolapai_get_rx_filter(
+			dev, (can_tolapai_rx_filter_t *)&filter);
+		if (copy_to_user(argp, &filter, sizeof(filter)))
+			err = -EFAULT;
+		break;
+	case CAN_TOLAPAI_IO_BLOCK:
+		dev->block_mode = 1;
+		break;
+	case CAN_TOLAPAI_IO_NON_BLOCK:
+		dev->block_mode = 0;
+		break;
+	case CAN_TOLAPAI_IO_BLOCK_GET:
+		put_user(dev->block_mode, (unsigned long *)argp);
+		break;
+	case CAN_TOLAPAI_IO_LISTEN:
+		err = can_tolapai_set_listen_mode(dev, CAN_TOLAPAI_LISTEN);
+		break;
+	case CAN_TOLAPAI_IO_ACTIVE:
+		err = can_tolapai_set_listen_mode(dev, CAN_TOLAPAI_ACTIVE);
+		break;
+	case CAN_TOLAPAI_IO_LISTEN_GET:
+		err = can_tolapai_get_listen_mode(
+			dev, (can_tolapai_listen_mode_t *)&var);
+		put_user(var, (unsigned long *)argp);
+		break;
+	case CAN_TOLAPAI_IO_ARBITER_ROUND_ROBIN:
+		err = can_tolapai_set_arbiter_mode(
+			dev, CAN_TOLAPAI_ROUND_ROBIN);
+		break;
+	case CAN_TOLAPAI_IO_ARBITER_FIXED_PRIORITY:
+		err = can_tolapai_set_arbiter_mode(
+			dev, CAN_TOLAPAI_FIXED_PRIORITY);
+		break;
+	case CAN_TOLAPAI_IO_ARBITER_GET:
+		err = can_tolapai_get_arbiter_mode(
+			dev, (can_tolapai_arbiter_t *)&var);
+		put_user(var, (unsigned long *)argp);
+		break;
+	case CAN_TOLAPAI_IO_ERROR_STATS_GET:
+		err = can_tolapai_get_error_stats(
+			dev, (can_tolapai_error_t *)&error);
+		if (copy_to_user(argp, &error, sizeof(error)))
+			err = -EFAULT;
+		break;
+	case CAN_TOLAPAI_IO_RESTART_MODE_AUTO:
+		err = can_tolapai_set_restart_mode(dev, CAN_TOLAPAI_AUTO);
+		break;
+	case CAN_TOLAPAI_IO_RESTART_MODE_MANUAL:
+		err = can_tolapai_set_restart_mode(dev, CAN_TOLAPAI_MANUAL);
+		break;
+	case CAN_TOLAPAI_IO_RESTART_MODE_GET:
+		err = can_tolapai_get_restart_mode(
+			dev, (can_tolapai_auto_restart_t *)&var);
+		put_user(var, (unsigned long *)argp);
+		break;
+	case CAN_TOLAPAI_IO_BUFFER_LINK_SET:
+		err = can_tolapai_set_rx_buffer_link(dev, arg, 1);
+		break;
+	case CAN_TOLAPAI_IO_BUFFER_LINK_CLEAR:
+		err = can_tolapai_set_rx_buffer_link(dev, arg, 0);
+		break;
+	case CAN_TOLAPAI_IO_BUFFER_LINK_GET:
+		get_user(var, (unsigned long *)argp);
+		err = can_tolapai_get_rx_buffer_link(
+			dev, var, (unsigned int *)&var);
+		put_user(var, (unsigned long *)argp);
+		break;
+	case CAN_TOLAPAI_IO_RX_ENABLE_SET:
+		err = can_tolapai_set_rx_enable(dev, arg, 1);
+		break;
+	case CAN_TOLAPAI_IO_RX_ENABLE_CLEAR:
+		err = can_tolapai_set_rx_enable(dev, arg, 0);
+		break;
+	case CAN_TOLAPAI_IO_RX_ENABLE_GET:
+		get_user(var, (unsigned long *)argp);
+		err = can_tolapai_get_rx_enable(
+			dev, var, (unsigned int *)&var);
+		put_user(var, (unsigned long *)argp);
+		break;
+	case CAN_TOLAPAI_IO_TX_ENABLE_SET:
+		err = can_tolapai_set_tx_enable(dev, arg, 1);
+		break;
+	case CAN_TOLAPAI_IO_TX_ENABLE_CLEAR:
+		err = can_tolapai_set_tx_enable(dev, arg, 0);
+		break;
+	case CAN_TOLAPAI_IO_TX_ENABLE_GET:
+		get_user(var, (unsigned long *)argp);
+		err = can_tolapai_get_tx_enable(
+			dev, var, (unsigned int *)&var);
+		put_user(var, (unsigned long *)argp);
+		break;
+	default:
+		CAN_PRINT_DEBUG("Unrecognizined IOCTL, skipping 0x%x. \n",
+					cmd);
+		break;
+	}
+
+	return err;
+}
+
+/*****************************************************************************
+ * Open the CAN device for use. Reset the CAN, enable interrupts and start.
+ *****************************************************************************/
+static int can_tolapai_init(
+	can_tolapai_dev_t 	*dev,
+	can_tolapai_listen_mode_t	listen,
+	can_tolapai_arbiter_t  	arbiter)
+{
+	int err;
+	int i;
+
+	err = can_tolapai_clear_buffers(dev);
+	if (err) {
+		printk(CAN_TOLAPAI_ERR_OPERATION, "clear buffers");
+		return err;
+	}
+
+	for (i = 0; i < NUM_RX_BUFFS; i++) {
+		err = can_tolapai_rx_init_filter(dev, i);
+		if (err) {
+			printk(CAN_TOLAPAI_ERR_OPERATION, "init rx filters");
+			return err;
+		}
+	}
+
+	err = can_tolapai_set_listen_mode(dev, CAN_TOLAPAI_ACTIVE);
+	if (err) {
+		printk(CAN_TOLAPAI_ERR_OPERATION, "active mode");
+		return err;
+	}
+
+	err = can_tolapai_set_arbiter_mode(dev, arbiter);
+	if (err) {
+		printk(CAN_TOLAPAI_ERR_OPERATION, "set arbiter");
+		return err;
+	}
+
+	err = can_tolapai_rx_enable_all(dev);
+	if (err) {
+		printk(CAN_TOLAPAI_ERR_OPERATION, "set rx enable all");
+		return err;
+	}
+
+	err = can_tolapai_tx_enable_all(dev);
+	if (err) {
+		printk(CAN_TOLAPAI_ERR_OPERATION, "set tx enable all");
+		return err;
+	}
+
+	err = can_tolapai_set_int_enables(dev, CAN_TOLAPAI_ALL);
+	if (err) {
+		printk(CAN_TOLAPAI_ERR_OPERATION, "set int enables");
+		return err;
+	}
+
+	err = can_tolapai_set_int_enables(dev, CAN_TOLAPAI_ENABLE);
+	if (err) {
+		printk(CAN_TOLAPAI_ERR_OPERATION, "enable ints");
+		return err;
+	}
+
+	return 0;
+}
+
+static void can_tolapai_set_bitrate(struct can_endpoint_t *ep, int bitrate)
+{
+	can_tolapai_ioctl(ep, CAN_TOLAPAI_IO_SIMPLE, bitrate);
+}
+
+static void can_tolapai_set_mode(struct can_endpoint_t *ep, int mode)
+{
+}
+
+static void can_tolapai_chip_reset(struct can_endpoint_t *ep)
+{
+	can_tolapai_dev_t *dev = (can_tolapai_dev_t *)ep->chip;
+
+	can_tolapai_set_run_mode(dev, CAN_TOLAPAI_STOP);
+	can_tolapai_reset(dev);
+	can_tolapai_set_run_mode(dev, CAN_TOLAPAI_RUN);
+}
+
+static int can_tolapai_read(struct can_endpoint_t *ep, int buff_num)
+{
+	can_tolapai_dev_t *dev = (can_tolapai_dev_t *)ep->chip;
+	can_frame_t msg;
+
+	if (!ep->rxfifo.user_counter) {
+		CAN_PRINT_DEBUG(KERN_WARNING "CAN: /dev/can%d no reader "
+					"attached.\n", ep->minor);
+		return -EAGAIN;
+	}
+
+	can_tolapai_rx_dequeue(dev, &msg, buff_num);
+
+	return can_fifo_push(&ep->rxfifo, &msg);
+}
+
+/* Initiate a CAN endpoint write operation */
+static int can_tolapai_initiate2write(struct can_endpoint_t *ep)
+{
+	can_tolapai_dev_t *dev = (can_tolapai_dev_t *)ep->chip;
+	can_frame_t *frame = NULL;
+	int ret = 0;
+
+	can_fifo_lock(&ep->txfifo);
+	frame = can_fifo_pop(&ep->txfifo, 0, &ret);
+	can_fifo_unlock(&ep->txfifo);
+	wake_up_interruptible(&ep->write_queue);
+	if (ret)
+		CAN_PRINT_DEBUG("No frame ready to be sent\n");
+	else
+		can_tolapai_msg_tx(dev, frame);
+
+	return ret;
+}
+
+static struct pci_device_id can_pci_ids[] = {
+	{ PCI_DEVICE(CAN_TOLAPAI_PCI_VENDOR_ID, CAN_TOLAPAI_PCI_DEVICE_ID_0) },
+	{ PCI_DEVICE(CAN_TOLAPAI_PCI_VENDOR_ID, CAN_TOLAPAI_PCI_DEVICE_ID_1) },
+	{ 0, },
+};
+
+MODULE_DEVICE_TABLE(pci, can_pci_ids);
+
+static struct pci_driver pci_ops = {
+	.name		= DRIVER_NAME,
+	.id_table	= can_pci_ids,
+	.probe		= can_pci_probe,
+	.remove		= can_pci_remove,
+	.suspend	= can_pci_suspend,
+	.resume		= can_pci_resume
+};
+
+/*****************************************************************************
+ * Driver's "main" functions. Init the device and register w/PCI subsystem.
+ *****************************************************************************/
+static int can_init(void)
+{
+	int err;
+
+	err = pci_register_driver(&pci_ops);
+	if (err < 0) {
+		printk(KERN_ERR "Couldn't register driver %d. Exiting.\n", err);
+		return err;
+	}
+
+	printk(KERN_INFO "Tolapai Controller Area Network Driver\n");
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Called when the driver exists. Undoes what init() does.
+ *****************************************************************************/
+static void can_exit(void)
+{
+	pci_unregister_driver(&pci_ops);
+}
+
+static int can_tolapai_register(can_tolapai_dev_t *dev)
+{
+	int ret = 0;
+	struct can_endpoint_t *ep = dev->endpoint;
+
+	ret = can_endpoint_register(ep);
+	if (ret < 0) {
+		printk(KERN_ERR "CAN: wicked error from out of device "
+			"endpoint");
+		return ret;
+	}
+
+	ep->chip = dev;
+	ep->initiate2write = can_tolapai_initiate2write;
+	ep->set_bitrate = can_tolapai_set_bitrate;
+	ep->chip_reset = can_tolapai_chip_reset;
+	ep->set_mode = can_tolapai_set_mode;
+	ep->ioctl = can_tolapai_ioctl;
+
+	return ret;
+}
+
+/*****************************************************************************
+ * Probe is called when a device is found. If it's a CAN, the device is
+ * initialized and enabled.
+ *****************************************************************************/
+static int can_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	unsigned int pci_bar;
+	can_tolapai_dev_t *can_dev;
+	int err = -1, minor, num;
+
+	switch (dev->device) {
+	case CAN_TOLAPAI_PCI_DEVICE_ID_0:
+		num = 0;
+		break;
+	case CAN_TOLAPAI_PCI_DEVICE_ID_1:
+		num = 1;
+		break;
+	default:
+		printk(KERN_ERR "Unrecognized CAN device id 0x%x. Exiting\n",
+			dev->device);
+		return -ENODEV;
+	}
+
+	if (pci_enable_device(dev)) {
+		printk(KERN_ERR "Couldn't enable PCI device v:0x%x d:0x%x. Exiting\n",
+			dev->vendor, dev->device);
+		return -ENODEV;
+	}
+
+	can_dev = kzalloc(sizeof(can_tolapai_dev_t), GFP_KERNEL);
+	if (!can_dev) {
+		printk(KERN_ERR "Couldn't allocate mem for can devevice\n");
+		return -ENOMEM;
+	}
+
+	pci_bar = pci_resource_start(dev, 0);
+	can_dev->io_base = ioremap(pci_bar, MM_REG_SIZE);
+	if (!can_dev->io_base) {
+		printk(KERN_ERR "Tolapai CAN : Failed to map controller\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	can_dev->irq = dev->irq;
+	can_dev->dev = dev;
+	can_dev->block_mode = 1;
+	init_waitqueue_head(&can_dev->pm_wait_queue);
+	init_waitqueue_head(&can_dev->write_wait_queue);
+	spin_lock_init(&can_dev->lock);
+	dev_set_drvdata(&dev->dev, can_dev);
+
+	can_tolapai_reset(can_dev);
+
+	can_dev->endpoint = can_endpoint_init(2);
+	if (can_dev->endpoint == NULL) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	minor = can_tolapai_register(can_dev);
+	if (minor < 0) {
+		can_endpoint_free(can_dev->endpoint);
+		goto ep_err;
+	}
+	atomic_set(&can_dev->endpoint->send_ready_flag, 1);
+
+	can_tolapai_init(can_dev, CAN_TOLAPAI_ACTIVE, CAN_TOLAPAI_ROUND_ROBIN);
+	tasklet_init(&can_dev->tasklet, can_tolapai_tasklet,
+			(unsigned long)can_dev);
+
+	err = request_irq(can_dev->irq, can_tolapai_irq, IRQF_SHARED,
+		num ? CAN_PROC_1 : CAN_PROC_0, (void *)can_dev);
+	if (err) {
+		printk(KERN_ERR "IRQ request failed on IRQ %d. Exiting.\n",
+			can_dev->irq);
+		goto ep_err;
+	}
+
+	printk(KERN_INFO "Probe completed for CAN [0x%x:0x%x] base 0x%08x irq 0x%x.\n",
+		dev->vendor,
+		dev->device,
+		(unsigned int)can_dev->io_base,
+		can_dev->irq);
+
+	return 0;
+
+ep_err:
+	can_endpoint_free(can_dev->endpoint);
+err_out:
+	iounmap(can_dev->io_base);
+	kfree(can_dev);
+
+	return err;
+}
+
+/*****************************************************************************
+ * Called when device is removed. Undoes what probe does.
+ *****************************************************************************/
+static void can_pci_remove(struct pci_dev *dev)
+{
+	can_tolapai_dev_t *can_dev = dev->dev.driver_data;
+
+	can_endpoint_unregister(can_dev->endpoint);
+	dev_set_drvdata(&dev->dev, NULL);
+	if (can_dev->irq)
+		free_irq(can_dev->irq, can_dev);
+	iounmap(can_dev->io_base);
+	kfree(can_dev);
+	pci_disable_device(dev);
+}
+
+/*****************************************************************************
+ * Called when the device is suspended. Saves CAN state.
+ *****************************************************************************/
+static int can_pci_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	unsigned int i;
+	unsigned int buffer_status;
+	unsigned short pci_cmd;
+	can_tolapai_dev_t *can_dev = dev->dev.driver_data;
+	int err;
+
+	/* Save Context */
+	can_tolapai_get_baud(can_dev, &(can_dev->timing));
+	can_tolapai_get_listen_mode(can_dev, &(can_dev->listen_mode));
+	can_tolapai_get_run_mode(can_dev, &(can_dev->run_mode));
+	can_tolapai_get_arbiter_mode(can_dev, &(can_dev->arbiter_mode));
+	can_tolapai_get_int_enables(can_dev, &(can_dev->int_enables));
+
+	for (i = 0; i < NUM_TX_BUFFS; i++)
+		can_tolapai_get_tx_enable(
+			can_dev, i, &(can_dev->tx_enable[i]));
+
+	for (i = 0; i < NUM_RX_BUFFS; i++) {
+		can_tolapai_get_rx_enable(
+			can_dev, i, &(can_dev->rx_enable[i]));
+		can_tolapai_get_rx_buffer_link(
+			can_dev, i, &(can_dev->rx_link[i]));
+	}
+
+	/* Disable Rx buffers */
+	can_tolapai_rx_disable_all(can_dev);
+
+	/* Check Tx and Rx buffer status. We can save the CAN state once all
+	 * msgs are transmitted and all msgs are received.
+	 */
+	while ((buffer_status = can_tolapai_get_buffer_status(can_dev)))
+		interruptible_sleep_on_timeout(&(can_dev->pm_wait_queue), 1);
+
+	can_tolapai_set_int_enables(can_dev, CAN_TOLAPAI_DISABLE);
+	can_tolapai_set_run_mode(can_dev, CAN_TOLAPAI_STOP);
+
+	err = pci_save_state(dev);
+
+	if (!err) {
+		/* Set additional PCI command bits. */
+		pci_read_config_word(dev, PCI_COMMAND, &pci_cmd);
+		pci_cmd |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY |
+				PCI_COMMAND_MASTER | PCI_COMMAND_INTX_DISABLE;
+		pci_write_config_word(can_dev->dev, PCI_COMMAND, pci_cmd);
+	}
+
+	return err;
+}
+
+/*****************************************************************************
+ * Called when the device is resumed. Restores the CAN state.
+ *****************************************************************************/
+static int can_pci_resume(struct pci_dev *dev)
+{
+	unsigned int i;
+	can_tolapai_dev_t *can_dev = dev->dev.driver_data;
+
+	can_tolapai_reset(can_dev);
+	can_tolapai_clear_buffers(can_dev);
+	can_tolapai_set_int_enables(can_dev, CAN_TOLAPAI_DISABLE);
+	can_tolapai_set_run_mode(can_dev, CAN_TOLAPAI_STOP);
+
+	can_tolapai_set_baud_custom(can_dev, &(can_dev->timing));
+	can_tolapai_set_listen_mode(can_dev, can_dev->listen_mode);
+	can_tolapai_set_arbiter_mode(can_dev, can_dev->arbiter_mode);
+
+	for (i = 0; i < NUM_TX_BUFFS; i++)
+		can_tolapai_set_tx_enable(can_dev, i, can_dev->tx_enable[i]);
+
+	for (i = 0; i < NUM_RX_BUFFS; i++) {
+		can_tolapai_set_rx_enable(can_dev, i, can_dev->rx_enable[i]);
+		can_tolapai_set_rx_buffer_link(can_dev, i, can_dev->rx_link[i]);
+	}
+
+	can_tolapai_set_run_mode(can_dev, can_dev->run_mode);
+	can_tolapai_set_int_enables(can_dev, can_dev->int_enables);
+
+	return pci_restore_state(dev);
+}
+
+
+/*****************************************************************************
+ * Reset CAN device.
+ *****************************************************************************/
+static void can_tolapai_reset(can_tolapai_dev_t *can_dev)
+{
+	unsigned short pci_pm_csr;
+
+	pci_read_config_word(can_dev->dev, 0xE0, &pci_pm_csr);
+
+	/* Enter D3; power off state */
+	pci_pm_csr |=  0x3;
+	pci_write_config_word(can_dev->dev, 0xE0, pci_pm_csr);
+
+	/* Enter D0; power on state; reset */
+	pci_pm_csr &=  ~0x3;
+	pci_write_config_word(can_dev->dev, 0xE0, pci_pm_csr);
+
+	/* Set interrupts to target the driver */
+	pci_write_config_word(can_dev->dev, 0xE8, 0x0003);
+}
+
+/*****************************************************************************
+ * Interrupt handler.
+ *****************************************************************************/
+static irqreturn_t can_tolapai_irq(int irq, void *dev_id)
+{
+	can_tolapai_dev_t *dev = (can_tolapai_dev_t *)dev_id;
+	struct can_endpoint_t *ep = dev->endpoint;
+	unsigned int int_status;
+	unsigned int err;
+	unsigned int i;
+	unsigned int buffer_status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* Get the interrupt status */
+	int_status = can_tolapai_int_pending(dev);
+
+	if (int_status) {
+		/* Clear the interrupt status */
+		can_tolapai_int_clr(dev, int_status);
+
+		if (int_status & MSK_IS_RXMSG) {
+			/* Read buffer status and dequeue all arrived
+			 * messages */
+			buffer_status = can_tolapai_get_buffer_status(dev) &
+						MSK_BS_RXALL;
+			i = 0;
+
+			while (buffer_status) {
+				if (buffer_status & 0x1)
+					can_tolapai_read(ep, i);
+				buffer_status >>= 1;
+				i++;
+			}
+
+			if (i)
+				wake_up_interruptible(&ep->read_queue);
+
+			int_status &= ~MSK_IS_RXMSG;
+		}
+
+		/* Only schedule the tasklet if there are still pending
+		 * interrupts. */
+		if (int_status) {
+			/* Save the interrupt status */
+			dev->int_status |= int_status;
+
+			/* Schedule the Tasklet */
+			tasklet_schedule(&dev->tasklet);
+		}
+
+		err = IRQ_HANDLED;
+	} else {
+		err = IRQ_NONE;
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return err;
+
+}
+
+static void can_tolapai_tasklet(unsigned long arg)
+{
+	can_tolapai_dev_t *dev = (can_tolapai_dev_t *)arg;
+
+	if (dev->int_status & MSK_IS_TXMSG) {
+		atomic_set(&dev->endpoint->send_ready_flag, 1);
+		wake_up_interruptible(&dev->write_wait_queue);
+		dev->int_status &= ~MSK_IS_TXMSG;
+	}
+
+	if (dev->int_status & MSK_IS_RXMSGLOSS) {
+		can_tolapai_log_message(MSK_IS_RXMSGLOSS);
+		dev->int_status &= ~MSK_IS_RXMSGLOSS;
+	}
+
+	if (dev->int_status & MSK_IS_BUSOFF) {
+		can_tolapai_log_message(MSK_IS_BUSOFF);
+		dev->int_status &= ~MSK_IS_BUSOFF;
+	}
+
+	if (dev->int_status & MSK_IS_CRCERR) {
+		can_tolapai_log_message(MSK_IS_CRCERR);
+		dev->int_status &= ~MSK_IS_CRCERR;
+	}
+
+	if (dev->int_status & MSK_IS_FORMERR) {
+		can_tolapai_log_message(MSK_IS_FORMERR);
+		dev->int_status &= ~MSK_IS_FORMERR;
+	}
+
+	if (dev->int_status & MSK_IS_ACKERR) {
+		can_tolapai_log_message(MSK_IS_ACKERR);
+		dev->int_status &= ~MSK_IS_ACKERR;
+	}
+
+	if (dev->int_status & MSK_IS_STUFFERR) {
+		can_tolapai_log_message(MSK_IS_STUFFERR);
+		dev->int_status &= ~MSK_IS_STUFFERR;
+	}
+
+	if (dev->int_status & MSK_IS_BITERR) {
+		can_tolapai_log_message(MSK_IS_BITERR);
+		dev->int_status &= ~MSK_IS_BITERR;
+	}
+
+	if (dev->int_status & MSK_IS_OVRLOAD) {
+		can_tolapai_log_message(MSK_IS_OVRLOAD);
+		dev->int_status &= ~MSK_IS_OVRLOAD;
+	}
+
+	if (dev->int_status & MSK_IS_ARLOSS) {
+		can_tolapai_log_message(MSK_IS_ARLOSS);
+		dev->int_status &= ~MSK_IS_ARLOSS;
+	}
+}
+
+module_init(can_init);
+module_exit(can_exit);
+
+MODULE_AUTHOR("Kevin Hao <Kexin.Hao@windriver.com>");
+MODULE_DESCRIPTION("Tolapai CAN Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/can/can_tolapai.h b/drivers/can/can_tolapai.h
new file mode 100644
index 0000000..0e96f11
--- /dev/null
+++ b/drivers/can/can_tolapai.h
@@ -0,0 +1,566 @@
+/*****************************************************************************
+ * Intel Tolapai CAN Driver
+ *
+ * Re-written by Kevin Hao <Kexin.Hao@windriver.com>
+ * Based on Intel Tolapai CAN Driver
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *****************************************************************************/
+
+#ifndef __CAN_TOLAPAI_H__
+#define __CAN_TOLAPAI_H__
+
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/cdev.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/ioctl.h>
+#include <asm-x86/io.h>
+#include <asm-x86/uaccess.h>
+
+/*#define CAN_TOLAPAI_DEBUG 		1*/	/* CAN debug enable/disable */
+#define CAN_TOLAPAI_MSG_DATA_LEN	8	/* CAN Msg data length */
+
+#define CAN_REG_WRITE(addr, val)    	writel((val), (addr));
+#define CAN_REG_READ(addr)      	readl((addr));
+
+#ifdef CONFIG_CAN_DEBUG
+#define CAN_PRINT_DEBUG(S...)		printk(S)
+#else
+#define CAN_PRINT_DEBUG(S...)
+#endif
+
+#ifdef CAN_TOLAPAI_DEBUG
+#define DEBUG_OUT(S)			printk("CAN_DEBUG: %s\n", S)
+#else
+#define DEBUG_OUT(S)
+#endif
+
+/*****************************************************************************
+ * Device characteristics
+ *****************************************************************************/
+#define MM_REG_SIZE		0x29c  	/**< All CAN regs */
+#define NUM_RX_BUFFS		16      /**< Num CAN Rx buffers */
+#define NUM_TX_BUFFS		8	/**< Num CAN Tx buffers */
+
+/*****************************************************************************
+ * Memory map offset definitions
+ *****************************************************************************/
+#define MM_INTSTAT		0x000		/**< Interrupt status */
+#define MM_INTENBL		0x004		/**< Interrupt enables */
+#define MM_BUFFSTAT		0x008		/**< Buffer status */
+#define MM_ERRSTAT		0x00c		/**< Error status */
+#define MM_CMD			0x010		/**< Command reg */
+#define MM_CFG			0x014		/**< Config reg */
+
+#define MM_TX0			0x020		/**< Tx reg 0 */
+#define MM_TX1			0x030		/**< Tx reg 1 */
+#define MM_TX2			0x040		/**< Tx reg 2 */
+#define MM_TX3			0x050		/**< Tx reg 3 */
+#define MM_TX4			0x060		/**< Tx reg 4 */
+#define MM_TX5			0x070		/**< Tx reg 5 */
+#define MM_TX6			0x080		/**< Tx reg 6 */
+#define MM_TX7			0x090		/**< Tx reg 7 */
+
+#define MM_RX0			0x0a0		/**< Rx reg 0 */
+#define MM_RX1			0x0c0		/**< Tx reg 1 */
+#define MM_RX2			0x0e0		/**< Tx reg 2 */
+#define MM_RX3			0x100		/**< Tx reg 3 */
+#define MM_RX4			0x120		/**< Tx reg 4 */
+#define MM_RX5			0x140		/**< Tx reg 5 */
+#define MM_RX6			0x160		/**< Tx reg 6 */
+#define MM_RX7			0x180		/**< Tx reg 7 */
+#define MM_RX8			0x1a0		/**< Tx reg 8 */
+#define MM_RX9			0x1c0		/**< Tx reg 9 */
+#define MM_RX10			0x1e0		/**< Tx reg 10 */
+#define MM_RX11			0x200		/**< Tx reg 11 */
+#define MM_RX12			0x220		/**< Tx reg 12 */
+#define MM_RX13			0x240		/**< Tx reg 13 */
+#define MM_RX14			0x260		/**< Tx reg 14 */
+#define MM_RX15			0x280		/**< Tx reg 15 */
+
+/*
+ * Tx message register offsets. These offsets corresponds
+ * to offsets within each of the MM_TXx registers
+ */
+#define MM_TXCTL		0x00		/**< Tx control */
+#define MM_TXCMD		0x00		/**< Tx command */
+#define MM_TXID			0x04		/**< Tx ID */
+#define MM_TXDATAH		0x08		/**< Tx data high */
+#define MM_TXDATAL		0x0c		/**< Tx data low */
+
+/*
+ * Rx message register offsets.These offsets corresponds
+ * to offsets withing each of the MM_RXx registers
+ */
+#define MM_RXCTL		0x00		/**< Rx conrol */
+#define MM_RXCMD		0x00		/**< Rx command */
+#define MM_RXID			0x04		/**< Rx ID */
+#define MM_RXDATAH		0x08		/**< Rx data high */
+#define MM_RXDATAL		0x0c		/**< Rx data low */
+#define MM_RXAMR		0x10		/**< Rx acceptance mask */
+#define MM_RXACR		0x14		/**< Rx acceptance control */
+#define MM_RXAMRDATA		0x18		/**< Rx AMR data */
+#define MM_RXACRDATA		0x1c		/**< Rx ACR data */
+
+/*****************************************************************************
+ * Register mask and bit definitions
+ *****************************************************************************/
+/* Interrupt Status Bits */
+#define MSK_IS_ARLOSS		(1<<BIT_IS_ARLOSS)	/**< Arbitration loss*/
+#define MSK_IS_OVRLOAD		(1<<BIT_IS_OVRLOAD)	/**< Overload */
+#define MSK_IS_BITERR		(1<<BIT_IS_BITERR)	/**< Bit error */
+#define MSK_IS_STUFFERR		(1<<BIT_IS_STUFFERR)	/**< Stuff error */
+#define MSK_IS_ACKERR		(1<<BIT_IS_ACKERR)	/**< ACK error */
+#define MSK_IS_FORMERR		(1<<BIT_IS_FORMERR)	/**< Form error */
+#define MSK_IS_CRCERR		(1<<BIT_IS_CRCERR)	/**< CRC error */
+#define MSK_IS_BUSOFF		(1<<BIT_IS_BUSOFF)	/**< Bus off */
+#define MSK_IS_RXMSGLOSS	(1<<BIT_IS_RXMSGLOSS)	/**< Rx msg loss */
+#define MSK_IS_TXMSG		(1<<BIT_IS_TXMSG)	/**< Tx msg */
+#define MSK_IS_RXMSG		(1<<BIT_IS_RXMSG)	/**< Rx msg */
+
+#define BIT_IS_ARLOSS		2
+#define BIT_IS_OVRLOAD		3
+#define BIT_IS_BITERR		4
+#define BIT_IS_STUFFERR		5
+#define BIT_IS_ACKERR		6
+#define BIT_IS_FORMERR		7
+#define BIT_IS_CRCERR		8
+#define BIT_IS_BUSOFF		9
+#define BIT_IS_RXMSGLOSS	10
+#define BIT_IS_TXMSG		11
+#define BIT_IS_RXMSG		12
+
+/* Interrupt enable register */
+#define MSK_IE_INTENBL		(1<<BIT_IE_INTENBL)	/**< Ints Enabled */
+#define MSK_IE_ARLOSS		(1<<BIT_IE_ARLOSS)	/**< Arbitration loss*/
+#define MSK_IE_OVRLOAD		(1<<BIT_IE_OVRLOAD)	/**< Overload */
+#define MSK_IE_BITERR		(1<<BIT_IE_BITERR)	/**< Bit error */
+#define MSK_IE_STUFFERR		(1<<BIT_IE_STUFFERR)	/**< Stuff error */
+#define MSK_IE_ACKERR		(1<<BIT_IE_ACKERR)	/**< ACK error */
+#define MSK_IE_FORMERR		(1<<BIT_IE_FORMERR)	/**< Form error */
+#define MSK_IE_CRCERR		(1<<BIT_IE_CRCERR)	/**< CRC error */
+#define MSK_IE_BUSOFF		(1<<BIT_IE_BUSOFF)	/**< Bus off */
+#define MSK_IE_RXMSGLOSS	(1<<BIT_IE_RXMSGLOSS)	/**< Rx msg loss */
+#define MSK_IE_TXMSG		(1<<BIT_IE_TXMSG)	/**< Tx msg */
+#define MSK_IE_RXMSG		(1<<BIT_IE_RXMSG)	/**< Rx msg */
+
+#define MSK_IE_ALL		0x1ffd			/**< Enable all ints */
+#define MSK_IE_ERR		0x07fc			/**< Enable all errs */
+
+#define BIT_IE_INTENBL		0
+#define BIT_IE_ARLOSS		2
+#define BIT_IE_OVRLOAD		3
+#define BIT_IE_BITERR		4
+#define BIT_IE_STUFFERR		5
+#define BIT_IE_ACKERR		6
+#define BIT_IE_FORMERR		7
+#define BIT_IE_CRCERR		8
+#define BIT_IE_BUSOFF		9
+#define BIT_IE_RXMSGLOSS	10
+#define BIT_IE_TXMSG		11
+#define BIT_IE_RXMSG		12
+
+/* Buffer status indicators */
+#define MSK_BS_RXMSG0		(1<<BIT_BS_RXMSG0)	/**< Rx msg 0 */
+#define MSK_BS_RXMSG1		(1<<BIT_BS_RXMSG1)	/**< Rx msg 1 */
+#define MSK_BS_RXMSG2		(1<<BIT_BS_RXMSG2)	/**< Rx msg 2 */
+#define MSK_BS_RXMSG3		(1<<BIT_BS_RXMSG3)	/**< Rx msg 3 */
+#define MSK_BS_RXMSG4		(1<<BIT_BS_RXMSG4)	/**< Rx msg 4 */
+#define MSK_BS_RXMSG5		(1<<BIT_BS_RXMSG5)	/**< Rx msg 5 */
+#define MSK_BS_RXMSG6		(1<<BIT_BS_RXMSG6)	/**< Rx msg 6 */
+#define MSK_BS_RXMSG7		(1<<BIT_BS_RXMSG7)	/**< Rx msg 7 */
+#define MSK_BS_RXMSG8		(1<<BIT_BS_RXMSG8)	/**< Rx msg 8 */
+#define MSK_BS_RXMSG9		(1<<BIT_BS_RXMSG9)	/**< Rx msg 9 */
+#define MSK_BS_RXMSG10		(1<<BIT_BS_RXMSG10)	/**< Rx msg 10 */
+#define MSK_BS_RXMSG11		(1<<BIT_BS_RXMSG11)	/**< Rx msg 11 */
+#define MSK_BS_RXMSG12		(1<<BIT_BS_RXMSG12)	/**< Rx msg 12 */
+#define MSK_BS_RXMSG13		(1<<BIT_BS_RXMSG13)	/**< Rx msg 13 */
+#define MSK_BS_RXMSG14		(1<<BIT_BS_RXMSG14)	/**< Rx msg 14 */
+#define MSK_BS_RXMSG15		(1<<BIT_BS_RXMSG15)	/**< Rx msg 15 */
+
+#define MSK_BS_RXALL		0x0000FFFF		/**< All Rx msg bufs */
+
+/* Transmit msg buffers statuses */
+#define MSK_BS_TXMSG0		(1<<BIT_BS_TXMSG0)	/**< Tx msg 0 */
+#define MSK_BS_TXMSG1		(1<<BIT_BS_TXMSG1)	/**< Tx msg 1 */
+#define MSK_BS_TXMSG2		(1<<BIT_BS_TXMSG2)	/**< Tx msg 2 */
+#define MSK_BS_TXMSG3		(1<<BIT_BS_TXMSG3)	/**< Tx msg 3 */
+#define MSK_BS_TXMSG4		(1<<BIT_BS_TXMSG4)	/**< Tx msg 4 */
+#define MSK_BS_TXMSG5		(1<<BIT_BS_TXMSG5)	/**< Tx msg 5 */
+#define MSK_BS_TXMSG6		(1<<BIT_BS_TXMSG6)	/**< Tx msg 6 */
+#define MSK_BS_TXMSG7		(1<<BIT_BS_TXMSG7)	/**< Tx msg 7 */
+
+#define MSK_BS_TXALL		0x00FF0000		/**< All Tx msg bufs */
+
+#define BIT_BS_RXMSG0		0
+#define BIT_BS_RXMSG1		1
+#define BIT_BS_RXMSG2		2
+#define BIT_BS_RXMSG3		3
+#define BIT_BS_RXMSG4		4
+#define BIT_BS_RXMSG5		5
+#define BIT_BS_RXMSG6		6
+#define BIT_BS_RXMSG7		7
+#define BIT_BS_RXMSG8		8
+#define BIT_BS_RXMSG9		9
+#define BIT_BS_RXMSG10		10
+#define BIT_BS_RXMSG11		11
+#define BIT_BS_RXMSG12		12
+#define BIT_BS_RXMSG13		13
+#define BIT_BS_RXMSG14		14
+#define BIT_BS_RXMSG15		15
+#define BIT_BS_TXMSG0		16
+#define BIT_BS_TXMSG1		17
+#define BIT_BS_TXMSG2		18
+#define BIT_BS_TXMSG3		19
+#define BIT_BS_TXMSG4		20
+#define BIT_BS_TXMSG5		21
+#define BIT_BS_TXMSG6		22
+#define BIT_BS_TXMSG7		23
+
+/* Error status */
+#define MSK_ES_TXERRCNT		(0xff<<BIT_ES_TXERRCNT)	/**< Tx err count */
+#define MSK_ES_RXERRCNT		(0xff<<BIT_ES_RXERRCNT)	/**< Rx err count */
+#define MSK_ES_ERRSTAT		(0x3<<BIT_ES_ERRSTAT)	/**< Error state */
+#define MSK_ES_TXGTE96		(1<<BIT_ES_TXGTE96)	/**< Tx >= 96 */
+#define MSK_ES_RXGTE96		(1<<BIT_ES_RXGTE96)	/**< Rx >= 96 */
+
+#define BIT_ES_TXERRCNT		0
+#define BIT_ES_RXERRCNT		8
+#define BIT_ES_ERRSTAT		16
+#define BIT_ES_TXGTE96		18
+#define BIT_ES_RXGTE96		19
+
+/* Command */
+#define MSK_CMD_RUN		(1<<BIT_CMD_RUN)	/**< Run mode */
+#define MSK_CMD_LISTEN		(1<<BIT_CMD_LISTEN)	/**< Listen mode */
+
+#define BIT_CMD_RUN		0
+#define BIT_CMD_LISTEN		1
+
+/* Configuration */
+#define MSK_CFG_EDGE		(1<<BIT_CFG_EDGE)	/**< Edge trig */
+#define MSK_CFG_SMPL		(1<<BIT_CFG_SMPL)	/**< Sample mode */
+#define MSK_CFG_SJW		(0x3<<BIT_CFG_SJW)	/**< Synch jump width*/
+#define MSK_CFG_RSTRT		(1<<BIT_CFG_RSTRT)	/**< Auto restart */
+#define MSK_CFG_TSEG2		(0x7<<BIT_CFG_TSEG2)	/**< Time segment 2 */
+#define MSK_CFG_TSEG1		(0xf<<BIT_CFG_TSEG1)	/**< Time segment 1 */
+#define MSK_CFG_ARB		(1<<BIT_CFG_ARB)	/**< Arb: RR/Fixed */
+#define MSK_CFG_BITRATE		(0x3fff<<BIT_CFG_BITRATE)/**< Prescaler */
+
+#define BIT_CFG_EDGE		0
+#define BIT_CFG_SMPL		1
+#define BIT_CFG_SJW		2
+#define BIT_CFG_RSTRT		4
+#define BIT_CFG_TSEG2		5
+#define BIT_CFG_TSEG1		8
+#define BIT_CFG_ARB		12
+#define BIT_CFG_BITRATE		16
+
+/* TxMessage control */
+#define MSK_TXCTL_INTENBL	(1<<BIT_TXCTL_INTENBL)	/**< Tx int enable */
+#define MSK_TXCTL_WPN0		(1<<BIT_TXCTL_WPN0)	/**< WPN b[2] */
+#define MSK_TXCTL_DLC		(0xf<<BIT_TXCTL_DLC)	/**< Data length */
+#define MSK_TXCTL_IDE		(1<<BIT_TXCTL_IDE)	/**< Ext ID? */
+#define MSK_TXCTL_RTR		(1<<BIT_TXCTL_RTR)	/**< RTR? */
+#define MSK_TXCTL_WPN1		(1<<BIT_TXCTL_WPN1)	/**< WPN b[21:16] */
+
+#define BIT_TXCTL_INTENBL	2
+#define BIT_TXCTL_WPN0		3
+#define BIT_TXCTL_DLC		16
+#define BIT_TXCTL_IDE		20
+#define BIT_TXCTL_RTR		21
+#define BIT_TXCTL_WPN1		23
+
+/* TxMessage command */
+#define MSK_TXCMD_REQ		(1<<BIT_TXCMD_REQ)	/**< Req tx */
+#define MSK_TXCMD_ABORT		(1<<BIT_TXCMD_ABORT)	/**< Req abort */
+#define MSK_TXCMD_WPN0		(1<<BIT_TXCMD_WPN0)	/**< WPN 0 */
+#define MSK_TXCMD_WPN1		(1<<BIT_TXCMD_WPN1)	/**< WPN 1 */
+
+#define BIT_TXCMD_REQ		0
+#define BIT_TXCMD_ABORT		1
+#define BIT_TXCMD_WPN0		3
+#define BIT_TXCMD_WPN1		23
+
+/* TxMessage ID */
+#define MSK_TXMSGIDS		0xfffffff8
+#define BIT_TXID			3
+#define BIT_TXID_UPPER		21
+
+/* RxMessage control */
+#define MSK_RXCTL_BUFENBL	(1<<BIT_RXCTL_BUFENBL)	/**< Buf enabled */
+#define MSK_RXCTL_RTRRPLY	(1<<BIT_RXCTL_RTRRPLY)	/**< RTR msg */
+#define MSK_RXCTL_INTENBL	(1<<BIT_RXCTL_INTENBL)	/**< Int enabled */
+#define MSK_RXCTL_LNKFLG	(1<<BIT_RXCTL_LNKFLG)	/**< Linked buffer */
+#define MSK_RXCTL_WPNL		(1<<BIT_RXCTL_WPNL)	/**< WPN b[6:3] */
+#define MSK_RXCTL_DLC		(0xf<<BIT_RXCTL_DLC)	/**< Data len code */
+#define MSK_RXCTL_IDE		(1<<BIT_RXCTL_IDE)	/**< Ext ID? */
+#define MSK_RXCTL_RTR		(1<<BIT_RXCTL_RTR)	/**< RTR? */
+#define MSK_RXCTL_WPNH		(1<<BIT_RXCTL_WPNH)	/**< WPN b[21:16] */
+
+#define BIT_RXCTL_BUFENBL	3
+#define BIT_RXCTL_RTRRPLY	4
+#define BIT_RXCTL_INTENBL	5
+#define BIT_RXCTL_LNKFLG	6
+#define BIT_RXCTL_WPNL		7
+#define BIT_RXCTL_DLC		16
+#define BIT_RXCTL_IDE		20
+#define BIT_RXCTL_RTR		21
+#define BIT_RXCTL_WPNH		23
+
+/* RxMessage command */
+#define MSK_RXCMD_MSGAV		(1<<BIT_RXCMD_MSGAV)	/**< Msg avail */
+#define MSK_RXCMD_RTRRPLYPEND	(1<<BIT_RXCMD_RTRRPLYPEND)/**< RTR reply pend*/
+#define MSK_RXCMD_RTRABORT	(1<<BIT_RXCMD_RTRABORT)	/**< RTR abort */
+#define MSK_RXCMD_WPNL		(1<<BIT_RXCMD_WPNL)	/**< WPNL */
+#define MSK_RXCMD_WPNH		(1<<BIT_RXCMD_WPNH)	/**< WPNH */
+
+#define BIT_RXCMD_MSGAV		0
+#define BIT_RXCMD_RTRRPLYPEND	1
+#define BIT_RXCMD_RTRABORT	2
+#define BIT_RXCMD_WPNL		7
+#define BIT_RXCMD_WPNH		23
+
+/* RxMessage ID */
+#define MSK_RXID		(0x1fffffff<<BIT_RXMSGIDS)/**< Rx msg ID */
+#define BIT_RXID		3
+#define BIT_RXID_UPPER	21
+
+/* RxMessage acceptance mask register */
+#define MSK_RXAMR_RTR		(1<<BIT_RXAMR_RTR)	/**< Rx AMR RTR */
+#define MSK_RXAMR_IDE		(1<<BIT_RXAMR_IDE)	/**< Rx AMR IDE? */
+#define MSK_RXAMR_ID		(0x1fffffff<<BIT_RXAMR_ID) /**< Rx AMR ID */
+#define MSK_RXAMR_ID_UPPER	(0x7ff<<BIT_RXAMR_ID_UPPER) /*Rx AMR ID UPPER*/
+
+#define BIT_RXAMR_RTR		1
+#define BIT_RXAMR_IDE		2
+#define BIT_RXAMR_ID		3
+#define BIT_RXAMR_ID_UPPER	21
+
+/* RxMessage acceptance code register */
+#define MSK_RXACR_RTR		(1<<BIT_RXACR_RTR)	/**< Rx ACR RTR */
+#define MSK_RXACR_IDE		(1<<BIT_RXACR_IDE)	/**< Rx ACR IDE? */
+#define MSK_RXACR_ID		(0x1fffffff<<BIT_RXACR_ID)/**< Rx ACR ID */
+#define MSK_RXACR_ID_UPPER	(0x7ff<<BIT_RXACR_ID_UPPER) /*Rx ACR ID UPPER*/
+
+#define BIT_RXACR_RTR		1
+#define BIT_RXACR_IDE		2
+#define BIT_RXACR_ID		3
+#define BIT_RXACR_ID_UPPER	21
+
+/* RxMessage acceptance mask register - data */
+#define MSK_RXAMRDATA		0x0000ffff		/**< Rx AMR data */
+#define BIT_RXAMRDATA		0
+
+/* RxMessage acceptance code register - data */
+#define MSK_RXACRDATA		0x0000ffff		/**< Rx ACR data */
+#define BIT_RXACRDATA		0
+
+#define CAN_TOLAPAI_PCI_VENDOR_ID		0x8086
+#define CAN_TOLAPAI_PCI_DEVICE_ID_0		0x5039
+#define CAN_TOLAPAI_PCI_DEVICE_ID_1		0x503a
+
+#define CAN_TOLAPAI_ERR_GENERIC			"CAN: %s.\n"
+#define CAN_TOLAPAI_ERR_ALLOC			"CAN: Allocate failed on %s.\n"
+#define CAN_TOLAPAI_ERR_FREE			"CAN: Free failed on %s.\n"
+#define CAN_TOLAPAI_ERR_PARAM			"CAN: Parameter %s invalid.\n"
+#define CAN_TOLAPAI_ERR_OPERATION 		"CAN: Operation %s failed.\n"
+#define CAN_TOLAPAI_ERR_DEVICE 			"CAN: Detected %s condition.\n"
+#define CAN_TOLAPAI_ERR_QUEUE_FULL		"CAN: Queue full.\n"
+#define CAN_TOLAPAI_ERR_QUEUE_EMPTY		"CAN: Queue empty.\n"
+
+/*****************************************************************************
+ * Device IO control codes.
+ *****************************************************************************/
+
+#define MAGIC					0xdd
+
+#define CAN_TOLAPAI_IO_RESET			_IO(MAGIC, 0)
+
+#define CAN_TOLAPAI_IO_RUN			_IO(MAGIC, 1)
+#define CAN_TOLAPAI_IO_STOP			_IO(MAGIC, 2)
+#define CAN_TOLAPAI_IO_RUN_GET \
+		_IOR(MAGIC, 3, can_tolapai_run_mode_t)
+
+#define CAN_TOLAPAI_IO_FILTER \
+		_IOW(MAGIC, 4, can_tolapai_rx_filter_t *)
+#define CAN_TOLAPAI_IO_FILTER_GET \
+		_IOR(MAGIC, 5, can_tolapai_rx_filter_t)
+
+#define CAN_TOLAPAI_IO_CUSTOM \
+		_IOW(MAGIC, 6, can_tolapai_timing_t *)
+#define CAN_TOLAPAI_IO_SIMPLE \
+		_IOW(MAGIC, 7, can_tolapai_baud_t)
+#define CAN_TOLAPAI_IO_TIMING_GET \
+		_IOR(MAGIC, 8, can_tolapai_timing_t *)
+
+#define CAN_TOLAPAI_IO_BLOCK			_IO(MAGIC, 9)
+#define CAN_TOLAPAI_IO_NON_BLOCK		_IO(MAGIC, 10)
+#define CAN_TOLAPAI_IO_BLOCK_GET		_IOR(MAGIC, 11, unsigned int)
+
+#define CAN_TOLAPAI_IO_LISTEN			_IO(MAGIC, 12)
+#define CAN_TOLAPAI_IO_ACTIVE			_IO(MAGIC, 13)
+#define CAN_TOLAPAI_IO_LISTEN_GET \
+		_IOR(MAGIC, 14, can_tolapai_listen_mode_t)
+
+#define CAN_TOLAPAI_IO_ARBITER_ROUND_ROBIN	_IO(MAGIC, 15)
+#define CAN_TOLAPAI_IO_ARBITER_FIXED_PRIORITY 	_IO(MAGIC, 16)
+#define CAN_TOLAPAI_IO_ARBITER_GET \
+		_IOR(MAGIC, 17, can_tolapai_arbiter_t)
+
+#define CAN_TOLAPAI_IO_ERROR_STATS_GET \
+		_IOR(MAGIC, 18, can_tolapai_error_t *)
+
+#define CAN_TOLAPAI_IO_RESTART_MODE_AUTO	_IO(MAGIC, 19)
+#define CAN_TOLAPAI_IO_RESTART_MODE_MANUAL	_IO(MAGIC, 20)
+#define CAN_TOLAPAI_IO_RESTART_MODE_GET \
+		_IOR(MAGIC, 21, can_tolapai_auto_restart_t)
+
+#define CAN_TOLAPAI_IO_BUFFER_LINK_SET		_IO(MAGIC, 22)
+#define CAN_TOLAPAI_IO_BUFFER_LINK_CLEAR	_IO(MAGIC, 23)
+#define CAN_TOLAPAI_IO_BUFFER_LINK_GET		_IOR(MAGIC, 24, unsigned int)
+
+#define CAN_TOLAPAI_IO_RX_ENABLE_SET		_IO(MAGIC, 25)
+#define CAN_TOLAPAI_IO_RX_ENABLE_CLEAR		_IO(MAGIC, 26)
+#define CAN_TOLAPAI_IO_RX_ENABLE_GET		_IOR(MAGIC, 27, unsigned int)
+
+#define CAN_TOLAPAI_IO_TX_ENABLE_SET		_IO(MAGIC, 28)
+#define CAN_TOLAPAI_IO_TX_ENABLE_CLEAR		_IO(MAGIC, 29)
+#define CAN_TOLAPAI_IO_TX_ENABLE_GET		_IOR(MAGIC, 30, unsigned int)
+
+typedef struct can_tolapai_timing {
+	unsigned int bitrate;			/**< Bitrate (kbps) 	     */
+	unsigned int cfg_bitrate;		/**< Bitrate 		     */
+	unsigned int cfg_tseg1;			/**< Tseg1 		     */
+	unsigned int cfg_tseg2;			/**< Tseg2 		     */
+	unsigned int cfg_sjw;			/**< Sync jump width 	     */
+	unsigned int smpl_mode;			/**< Sampling mode 	     */
+	unsigned int edge_mode;			/**< Edge R / D		     */
+} can_tolapai_timing_t;
+
+typedef struct icp_can_error {
+	unsigned int rxgte96;			/**< Rx err cnt >=96   	     */
+	unsigned int txgte96;			/**< Tx err cnt >=96   	     */
+	unsigned int error_stat;		/**< Error state of CAN node */
+						/**< 00=error active (normal)*/
+						/**< 01=error passive        */
+						/**< 1x=bus off              */
+	unsigned int rx_err_cnt;		/**< Rx counter              */
+	unsigned int tx_err_cnt;		/**< Tx counter              */
+} can_tolapai_error_t;
+
+typedef struct can_tolapai_acc_filter {
+	unsigned int id;			/**< ID 	  */
+	unsigned int id_ext;		/**< Standard/extended ID?    */
+	unsigned int rtr;		/**< RTR message 	      */
+	unsigned short data;		/**< High byte pair  	      */
+} can_tolapai_acc_filter_t;
+
+typedef struct can_tolapai_rx_filter {
+	unsigned int num;			/**< Filter number 	     */
+	can_tolapai_acc_filter_t amr;		/**< Acceptance Mask Reg     */
+	can_tolapai_acc_filter_t acr;		/**< Acceptance Control Reg  */
+} can_tolapai_rx_filter_t;
+
+typedef enum {
+	CAN_TOLAPAI_ACTIVE = 0,			/**< R/w to/from the CAN     */
+	CAN_TOLAPAI_LISTEN			/**< Only read from the CAN  */
+} can_tolapai_listen_mode_t;
+
+typedef enum {
+	CAN_TOLAPAI_STOP = 0,		/**< CAN stopped 	     */
+	CAN_TOLAPAI_RUN			/**< CAN running  	     */
+} can_tolapai_run_mode_t;
+
+typedef enum {
+	CAN_TOLAPAI_ROUND_ROBIN = 0,		/**< Equal priority 	     */
+	CAN_TOLAPAI_FIXED_PRIORITY		/**< Buffer num priority     */
+} can_tolapai_arbiter_t;
+
+typedef enum {
+	CAN_TOLAPAI_ONE_POINT = 0,		/**< One sampling point	     */
+	CAN_TOLAPAI_THREE_POINTS		/**< Three sampling points   */
+} can_tolapai_sampling_mode_t;
+
+typedef enum {
+	CAN_TOLAPAI_EDGE_R_TO_D = 0,	/**< Recessive to dominant   */
+	CAN_TOLAPAI_BOTH_EDGES		/**< Trigger on both edges   */
+} can_tolapai_sync_t;
+
+typedef enum {
+	CAN_TOLAPAI_MANUAL = 0,			/**< Manual restart 	     */
+	CAN_TOLAPAI_AUTO			/**< Automatic restart       */
+} can_tolapai_auto_restart_t;
+
+typedef enum {
+	CAN_TOLAPAI_BAUD_10 = 0,		/**< 10   kbps 	             */
+	CAN_TOLAPAI_BAUD_20,			/**< 20   kbps 	             */
+	CAN_TOLAPAI_BAUD_50,			/**< 50   kbps 	             */
+	CAN_TOLAPAI_BAUD_125,			/**< 125  kbps 	             */
+	CAN_TOLAPAI_BAUD_250,			/**< 250  kbps 	             */
+	CAN_TOLAPAI_BAUD_500,			/**< 500  kbps 	             */
+	CAN_TOLAPAI_BAUD_800,			/**< 800  kbps 	             */
+	CAN_TOLAPAI_BAUD_1000			/**< 1000 kbps 	             */
+} can_tolapai_baud_t;
+
+typedef enum {
+	CAN_TOLAPAI_ENABLE,			/**< Enable bit only	     */
+	CAN_TOLAPAI_DISABLE,			/**< Disable bit only	     */
+	CAN_TOLAPAI_ALL,			/**< All ints		     */
+	CAN_TOLAPAI_NONE			/**< No ints		     */
+} can_tolapai_interrupt_t;
+
+#define DRIVER_NAME			"tolapai_can"
+#define CAN_PROC_0			"can0"
+#define CAN_PROC_1			"can1"
+
+/*****************************************************************************
+ * CAN OS context structure.
+ *****************************************************************************/
+typedef struct can_tolapai_dev {
+	struct can_endpoint_t *endpoint;	/* Device's CAN endpoint     */
+	void __iomem *io_base;			/* MMap regs                 */
+	struct pci_dev *dev;			/* PCI Device                */
+	unsigned int irq;			/* IRQ 	                     */
+	unsigned int int_status;		/* Interrupt status 	     */
+	spinlock_t lock;			/* Interrupt sl              */
+	can_tolapai_timing_t timing;		/* CAN: timing		     */
+	can_tolapai_run_mode_t run_mode;	/* CAN: run mode	     */
+	can_tolapai_listen_mode_t listen_mode; 	/* CAN: listen mode	     */
+	can_tolapai_arbiter_t arbiter_mode;	/* CAN: arbiter mode	     */
+	wait_queue_head_t pm_wait_queue;	/* CAN: PM wait queue        */
+	wait_queue_head_t write_wait_queue;	/* CAN: write wait queeu     */
+	unsigned int tx_enable[NUM_TX_BUFFS];	/* CAN: Tx buffer state      */
+	unsigned int rx_enable[NUM_RX_BUFFS];   /* CAN: Rx buffer state      */
+	unsigned int rx_link[NUM_RX_BUFFS];     /* CAN: Rx link set          */
+	unsigned int int_enables;		/* CAN: ints enabled         */
+	struct tasklet_struct tasklet;
+	int 	block_mode;
+} can_tolapai_dev_t;
+
+
+static int can_tolapai_set_rx_enable(
+		can_tolapai_dev_t *dev, unsigned int buff_num,
+		unsigned int set);
+static int can_tolapai_set_tx_enable(
+		can_tolapai_dev_t *dev, unsigned int buff_num,
+		unsigned int set);
+static int can_tolapai_set_rx_filter(
+		can_tolapai_dev_t *dev, can_tolapai_rx_filter_t	*filter);
+static int can_pci_probe(
+		struct pci_dev *dev, const struct pci_device_id *id);
+static void can_pci_remove(struct pci_dev *dev);
+static int can_pci_suspend(struct pci_dev *dev, pm_message_t state);
+static int can_pci_resume(struct pci_dev *dev);
+static void can_tolapai_reset(can_tolapai_dev_t *dev);
+static irqreturn_t can_tolapai_irq(int irq, void *dev_id);
+static void can_tolapai_tasklet(unsigned long arg);
+
+#endif /* ifndef __CAN_TOLAPAI_H__ */
+
-- 
1.6.0.2.GIT

