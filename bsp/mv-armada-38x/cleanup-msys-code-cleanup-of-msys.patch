From 9f34948e5396575d9cd2018c7ab7cf19f3fbdbad Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Wed, 5 Feb 2014 14:43:55 +0200
Subject: [PATCH 1332/1825] cleanup: msys: code cleanup of msys

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit f78c02ecb923ee99d7acf9d330a6a1c307c88a82

	remove unused files (pci) and update defconfig
	fix compile warnings (add __cpuinit in missing places)
	remove commented code

Change-Id: Ibd97ca42f1aeded9186b84c807f18eb54fdb09b7
Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5460
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/msys_defconfig         |    1 -
 arch/arm/mach-msys/headsmp.S            |    1 +
 arch/arm/mach-msys/mv_hal_if/mvSysPci.c | 1270 -------------------------------
 arch/arm/mach-msys/mv_hal_if/mvSysPci.h |  251 ------
 arch/arm/mach-msys/mv_hal_if/mvSysSpi.c |    7 +-
 arch/arm/mach-msys/pci.c                |  246 ------
 arch/arm/mach-msys/platsmp.c            |    4 +-
 arch/arm/mach-msys/time.c               |    2 +-
 arch/arm/plat-armada/Kconfig            |    2 +-
 9 files changed, 6 insertions(+), 1778 deletions(-)
 delete mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysPci.c
 delete mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysPci.h
 delete mode 100644 arch/arm/mach-msys/pci.c

diff --git a/arch/arm/configs/msys_defconfig b/arch/arm/configs/msys_defconfig
index f603c14..5f5c0fa 100644
--- a/arch/arm/configs/msys_defconfig
+++ b/arch/arm/configs/msys_defconfig
@@ -26,7 +26,6 @@ CONFIG_MV_PMU_PROC=y
 CONFIG_MV_ETH_GROUP0_CPU=0x3
 # CONFIG_SWP_EMULATE is not set
 CONFIG_SHEEVA_ERRATA_ARM_CPU_PMU_RESET=y
-CONFIG_PCI_DEBUG=y
 CONFIG_NO_HZ=y
 CONFIG_SMP=y
 CONFIG_SCHED_MC=y
diff --git a/arch/arm/mach-msys/headsmp.S b/arch/arm/mach-msys/headsmp.S
index b8eb3de..cc113c2 100644
--- a/arch/arm/mach-msys/headsmp.S
+++ b/arch/arm/mach-msys/headsmp.S
@@ -30,6 +30,7 @@ disclaimer.
 #include <asm/memory.h>
 #include <mach/hardware.h>
 
+__CPUINIT
 
 #define MSYS_COHERENCY_FABRIC_CTL_REG (INTER_REGS_PHYS_BASE + 0x20200)
 #define MSYS_COHERENCY_FABRIC_CFG_REG (INTER_REGS_PHYS_BASE + 0x20204)
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysPci.c b/arch/arm/mach-msys/mv_hal_if/mvSysPci.c
deleted file mode 100644
index b38a995..0000000
--- a/arch/arm/mach-msys/mv_hal_if/mvSysPci.c
+++ /dev/null
@@ -1,1270 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#include "mvSysPci.h"
-#include "ddr2_3/mvDramIf.h"
-
-/* PCI BARs registers offsets are inconsecutive. This struct describes BAR	*/
-/* register offsets	and its function where its is located.			*/
-/* Also, PCI address remap registers offsets are inconsecutive. This struct	*/
-/* describes address remap register offsets					*/
-struct _pciBarRegInfo {
-	MV_U32 funcNum;
-	MV_U32 baseLowRegOffs;
-	MV_U32 baseHighRegOffs;
-	MV_U32 sizeRegOffs;
-	MV_U32 remapLowRegOffs;
-	MV_U32 remapHighRegOffs;
-};
-
-struct _pciBarStatus {
-	enum _mvPCIBars	bar;
-	int		enable;
-};
-
-struct _pciBarStatus pciBarStatusMap[] = {
-#if defined(MV_INCLUDE_SDRAM_CS0)
-	{CS0_BAR, EN},
-#endif
-#if defined(MV_INCLUDE_SDRAM_CS1)
-	{CS1_BAR, EN},
-#endif
-#if defined(MV_INCLUDE_SDRAM_CS2)
-	{CS2_BAR, EN},
-#endif
-#if defined(MV_INCLUDE_SDRAM_CS3)
-	{CS3_BAR, EN},
-#endif
-#if defined(MV_INCLUDE_DEVICE_CS0)
-	{DEVCS0_BAR, EN},
-#endif
-#if defined(MV_INCLUDE_DEVICE_CS1)
-	{DEVCS1_BAR, EN},
-#endif
-#if defined(MV_INCLUDE_DEVICE_CS2)
-	{DEVCS2_BAR, EN},
-#endif
-	{BOOTCS_BAR, EN},
-	{MEM_INTER_REGS_BAR, EN},
-	{IO_INTER_REGS_BAR, EN},
-	{P2P_MEM0, DIS},
-	{P2P_IO, DIS},
-	{TBL_TERM, TBL_TERM}
-};
-
-
-/* Locals */
-static MV_U32 pciBurstBytes2Reg(MV_U32 size);
-static MV_U32 pciBurstReg2Bytes(MV_U32 size);
-
-static MV_STATUS pciWinOverlapDetect(MV_U32 pciIf, enum _mvPCIBars bar,
-					MV_ADDR_WIN *pAddrWin);
-
-static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf, enum _mvPCIBars bar,
-					struct _pciBarRegInfo *pBarRegInfo);
-
-static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size);
-
-/* Forward declarations */
-const MV_8 *pciBarNameGet(enum _mvPCIBars bar);
-
-/*******************************************************************************
-* mvPciInit - Initialize PCI interfaces
-*
-* DESCRIPTION:
-*       This function initiate the PCI interface:
-*       1) Set local bus number. In case of convential PCI it gets the bus
-*          number using mvPciLocalBusNumGet(). In case of PCI-X this
-*          information is read only.
-*       2) Interface device number. In case of conventional PCI it gets the
-*          device number using mvPciLocalDevNumGet(). In case of PCI-X this
-*          information is read only.
-*       3) PCI Arbiter if needed.
-*       4) Enable Master and Slave on PCI interfaces.
-*	5) Open PCI BARs according to default setting.
-*	   Note that PCI bridge (P2P) is NOT initialized.
-*	6) Enable CPU to PCI ordering.
-*
-* INPUT:
-*
-*       pciIf   - PCI interface number.
-*		localBus - Local Bus of the PCI interface to be set
-*		localDev - Local Dev of the PCI interface to be set
-*		bFirstCall - Indicates wether this is the first call of this
-*					 function .
-*
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
-*
-*******************************************************************************/
-MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod)
-{
-	enum _mvPCIBars		bar, barix = 0;
-	MV_PCI_MODE		pciMode;
-	struct _mvPciProtWin	pciProtWin;
-	struct _mvPciBarWin	pciBarMap[PCI_MAX_BARS];
-	MV_UNIT_WIN_INFO	addrWinMap[MAX_TARGETS + 1];
-	MV_TARGET		target;
-	MV_UNIT_WIN_INFO	*addrDecWin;
-
-	/* Parameter checking  */
-	if (pciIf >= mvCtrlPciMaxIfGet()) {
-		mvOsPrintf("mvPciInit: ERR. Invalid PCI interface %d\n", pciIf);
-		return MV_BAD_PARAM;
-	}
-
-	/* device and bus numbers */
-	if (MV_OK != mvPciModeGet(pciIf, &pciMode)) {
-		mvOsPrintf("mvPciInit: ERR. mvPciModeGet failed\n");
-		return MV_ERROR;
-	}
-
-	/* First disable all PCI target windows  */
-	for (bar = 0; bar < PCI_MAX_BARS; bar++)
-		mvPciTargetWinEnable(pciIf, bar, MV_FALSE);
-
-	/* WA CQ 4382*/
-	MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BIT15);
-
-	/* Loop over all BARs and copy enabled SDRAM windows only */
-	if (MV_OK != mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1)) {
-		mvOsPrintf("mvPciInit: ERR. mvCtrlAddrWinMapBuild failed\n");
-		return MV_ERROR;
-	}
-
-	for (target = SDRAM_CS0; target <= SDRAM_CS3; target++) {
-		addrDecWin = &addrWinMap[target];
-		if (addrDecWin->enable == MV_TRUE) {
-			pciBarMap[barix].addrWin.baseLow = addrDecWin->addrWin.baseLow;
-			pciBarMap[barix].addrWin.baseHigh = addrDecWin->addrWin.baseHigh;
-			pciBarMap[barix].addrWin.size = addrDecWin->addrWin.size;
-			pciBarMap[barix].enable = EN;
-			barix++;
-		}
-	}
-
-	/* Initialize all non used BARs */
-	for (bar = barix; bar < PCI_MAX_BARS; bar++) {
-		pciBarMap[bar].addrWin.baseLow = 0xFFFFFFFF;
-		pciBarMap[bar].addrWin.baseHigh = 0;
-		pciBarMap[bar].addrWin.size = 0xFFFFFFFF;
-		pciBarMap[bar].enable = DIS;
-	}
-
-	/* finally fill table with TBL_TERM entry */
-	bar = PCI_MAX_BARS - 1;
-	pciBarMap[bar].addrWin.baseLow = TBL_TERM;
-	pciBarMap[bar].addrWin.baseHigh = TBL_TERM;
-	pciBarMap[bar].addrWin.size = TBL_TERM;
-	pciBarMap[bar].enable = TBL_TERM;
-
-
-	/* Memory Mapped Internal Registers BAR can not be disabled.		*/
-	/* Relocate its BAR first to avoid colisions with other BARs (e.g DRAM) */
-	if (MV_OK != mvPciTargetWinSet(pciIf, MEM_INTER_REGS_BAR, &pciBarMap[MEM_INTER_REGS_BAR])) {
-		mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet failed\n");
-		return MV_ERROR;
-	}
-
-	/* Now, go through all targets in default table until table terminator	*/
-	for (bar = 0; pciBarMap[bar].enable != TBL_TERM; bar++) {
-		/* Skip the P2P BARs. They should be configured seperately			*/
-		if (0xFFFFFFFF == pciBarMap[bar].addrWin.baseLow)
-			continue;
-
-		/* check if the size passed is zero ! */
-		if (0 == pciBarMap[bar].addrWin.size) {
-			/* disable the bar */
-			mvPciTargetWinEnable(pciIf, bar, MV_FALSE);
-			continue;
-		}
-
-		if (MV_OK != mvPciTargetWinSet(pciIf, bar, &pciBarMap[bar])) {
-			mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet %d failed\n", bar);
-			return MV_ERROR;
-		}
-	}
-
-	MV_REG_BIT_SET(PCI_ADDR_DECODE_CONTROL_REG(pciIf), PADCR_REMAP_REG_WR_DIS);
-
-	/* configure access control unit 0 to DDR to enhance performance */
-	pciProtWin.addrWin.baseLow = 0;
-	pciProtWin.addrWin.baseHigh = 0;
-	pciProtWin.addrWin.size = mvDramIfSizeGet();
-#ifdef AURORA_IO_CACHE_COHERENCY
-	pciProtWin.attributes.snoop = WT_CACHE_COHER;
-#else
-	pciProtWin.attributes.snoop = NO_CACHE_COHER;
-#endif
-	pciProtWin.attributes.access = ALLOWED;
-	pciProtWin.attributes.write = ALLOWED;
-	pciProtWin.attributes.swapType = MV_BYTE_SWAP;
-	pciProtWin.attributes.readMaxBurst = 128;
-	pciProtWin.attributes.readBurst = 256;
-	pciProtWin.attributes.writeMaxBurst = 128;
-	pciProtWin.attributes.pciOrder = MV_FALSE;
-	pciProtWin.enable = MV_TRUE;
-	if (mvPciProtWinSet(pciIf, 0, &pciProtWin) != MV_OK) {
-		mvOsPrintf("mvPciInit: ERR. mvPciProtWinSet failed\n");
-		return MV_ERROR;
-	}
-
-	mvPciHalInit(pciIf, pciIfmod);
-
-	return MV_OK;
-}
-
-
-
-/*******************************************************************************
-* mvPciTargetWinSet - Set PCI to peripheral target address window BAR
-*
-* DESCRIPTION:
-*       This function sets an address window from PCI to a peripheral
-*       target (e.g. SDRAM bank0, PCI_MEM0), also known as BARs.
-*       A new PCI BAR window is set for specified target address window.
-*       If address decode window parameter structure enables the window,
-*       the routine will also enable the target window, allowing PCI to access
-*       the target window.
-*
-* INPUT:
-*       pciIf       - PCI interface number.
-*       bar         - BAR to be accessed by slave.
-*       pAddrBarWin - PCI target window information data structure.
-*
-* OUTPUT:
-*       N/A
-*
-* RETURN:
-*       MV_OK if PCI BAR target window was set correctly, MV_BAD_PARAM on bad params
-*       MV_ERROR otherwise
-*       (e.g. address window overlapps with other active PCI target window).
-*
-*******************************************************************************/
-MV_STATUS mvPciTargetWinSet(MV_U32			pciIf,
-				enum _mvPCIBars		bar,
-				struct _mvPciBarWin	*pAddrBarWin)
-{
-	MV_U32 pciData;
-	MV_U32 sizeToReg;
-	MV_U32 size;
-	MV_U32 baseLow;
-	MV_U32 baseHigh;
-	MV_U32 localBus;
-	MV_U32 localDev;
-	struct _pciBarRegInfo barRegInfo;
-
-	size	= pAddrBarWin->addrWin.size;
-	baseLow	= pAddrBarWin->addrWin.baseLow;
-	baseHigh = pAddrBarWin->addrWin.baseHigh;
-
-	/* Parameter checking   */
-	if (pciIf >= mvCtrlPciMaxIfGet()) {
-		mvOsPrintf("mvPciTargetWinSet: ERR. Invalid PCI interface %d\n", pciIf);
-		return MV_BAD_PARAM;
-	}
-
-	if (bar >= PCI_MAX_BARS) {
-		mvOsPrintf("mvPciTargetWinSet: ERR. Illigal PCI BAR %d\n", bar);
-		return MV_BAD_PARAM;
-	}
-
-	/* if the address windows is disabled , we only disable the appropriare
-	pci bar and ignore other settings */
-
-	if (MV_FALSE == pAddrBarWin->enable) {
-		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
-		return MV_OK;
-	}
-
-	if (0 == pAddrBarWin->addrWin.size) {
-		mvOsPrintf("mvPciTargetWinSet: ERR. Target %d can't be zero!\n", bar);
-		return MV_BAD_PARAM;
-	}
-
-	/* Check if the window complies with PCI spec */
-	if (MV_TRUE != pciWinIsValid(baseLow, size)) {
-		mvOsPrintf("mvPciTargetWinSet: ERR. Target %d window invalid\n", bar);
-		return MV_BAD_PARAM;
-	}
-
-	/* 2) Check if the requested window overlaps with current windows */
-	if (MV_TRUE == pciWinOverlapDetect(pciIf, bar, &pAddrBarWin->addrWin)) {
-		mvOsPrintf("mvPciTargetWinSet: ERR. Overlap detected for target %d\n", bar);
-		return MV_BAD_PARAM;
-	}
-
-	/* Get size register value according to window size */
-	sizeToReg = ctrlSizeToReg(size, PBBLR_BASE_ALIGNMET);
-
-	/* Size parameter validity check */
-	if (-1 == sizeToReg) {
-		mvOsPrintf("mvPciTargetWinSet: ERR. Target BAR %d size invalid.\n", bar);
-		return MV_BAD_PARAM;
-	}
-
-	localBus = mvPciLocalBusNumGet(pciIf);
-	localDev = mvPciLocalDevNumGet(pciIf);
-
-	/* Get BAR register information */
-	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
-
-	/* Internal register space size have no size register. Do not perform	*/
-	/* size register assigment for this slave target			*/
-	if (0 != barRegInfo.sizeRegOffs) {
-		/* Update size register */
-		MV_REG_WRITE(barRegInfo.sizeRegOffs, (sizeToReg << BAR_SIZE_OFFS));
-	}
-
-	/* Read current address */
-	pciData = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
-				barRegInfo.baseLowRegOffs);
-
-	/* Clear current address */
-	pciData &= ~PBBLR_BASE_MASK;
-	pciData |= (baseLow & PBBLR_BASE_MASK);
-
-	/* Write new address */
-	mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
-			barRegInfo.baseLowRegOffs, pciData);
-
-	/* Skip base high settings if the BAR has only base low (32-bit) */
-	if (0 != barRegInfo.baseHighRegOffs) {
-		mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
-				barRegInfo.baseHighRegOffs, baseHigh);
-	}
-
-	/* Enable/disable the BAR */
-	if (MV_TRUE == pAddrBarWin->enable)
-		MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
-	else
-		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
-
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvPciTargetWinGet - Get PCI to peripheral target address window
-*
-* DESCRIPTION:
-*		Get the PCI to peripheral target address window BAR.
-*
-* INPUT:
-*       pciIf - PCI interface number.
-*       bar   - BAR to be accessed by slave.
-*
-* OUTPUT:
-*       pAddrBarWin - PCI target window information data structure.
-*
-* RETURN:
-*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
-*
-*******************************************************************************/
-MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, enum _mvPCIBars bar,
-			struct _mvPciBarWin *pAddrBarWin)
-{
-	MV_U32			size;
-	MV_U32			baseLow;
-	MV_U32			baseHigh;
-	MV_U32			localBus;
-	MV_U32			localDev;
-	MV_U32			barEnable;
-	struct _pciBarRegInfo	barRegInfo;
-
-	/* Parameter checking   */
-	if (pciIf >= mvCtrlPciMaxIfGet()) {
-		mvOsPrintf("mvPciTargetWinGet: ERR. Invalid PCI interface %d\n", pciIf);
-		return MV_BAD_PARAM;
-	}
-
-	if (bar >= PCI_MAX_BARS) {
-		mvOsPrintf("mvPciTargetWinGet: ERR. Illigal PCI BAR %d.\n", bar);
-		return MV_BAD_PARAM;
-	}
-
-	localBus = mvPciLocalBusNumGet(pciIf);
-	localDev = mvPciLocalDevNumGet(pciIf);
-
-	/* Get BAR register information */
-	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
-
-	/* Reading Base Low bar */
-	baseLow = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
-				barRegInfo.baseLowRegOffs);
-
-	baseLow &= PBBLR_BASE_MASK;
-
-	/* Skip base high if the BAR has only base low (32-bit) */
-	if (0 != barRegInfo.baseHighRegOffs) {
-		/* Reading Base High */
-		baseHigh = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
-					barRegInfo.baseHighRegOffs);
-	} else
-		baseHigh = 0;
-
-	/* Internal register space size have no size register. Do not perform	*/
-	/* size register assigment for this slave target			*/
-	if (0 != barRegInfo.sizeRegOffs) {
-		/* Reading bar size*/
-		size = ctrlRegToSize((MV_REG_READ(barRegInfo.sizeRegOffs) >> PBSR_SIZE_OFFS),
-					PBBLR_BASE_ALIGNMET);
-	} else
-		size = INTER_REGS_SIZE;
-
-	/* Assign value to user struct */
-	pAddrBarWin->addrWin.baseLow	= baseLow;
-	pAddrBarWin->addrWin.baseHigh	= baseHigh;
-	pAddrBarWin->addrWin.size	= size;
-
-	/* Check if window is enabled   */
-	barEnable = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
-
-	if (~barEnable & (BARER_ENABLE(bar)))
-		pAddrBarWin->enable = MV_TRUE;
-	else
-		pAddrBarWin->enable = MV_FALSE;
-
-	return MV_OK;
-}
-
-
-/*******************************************************************************
-* mvPciTargetWinEnable - Enable/disable a PCI BAR window
-*
-* DESCRIPTION:
-*       This function enable/disable a PCI BAR window.
-*       if parameter 'enable' == MV_TRUE the routine will enable the
-*       window, thus enabling PCI accesses for that BAR (before enabling the
-*       window it is tested for overlapping). Otherwise, the window will
-*       be disabled.
-*
-* INPUT:
-*       pciIf  - PCI interface number.
-*       bar    - BAR to be accessed by slave.
-*       enable - Enable/disable parameter.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
-*
-*******************************************************************************/
-MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf, enum _mvPCIBars bar, MV_BOOL enable)
-{
-	struct _mvPciBarWin barWin;
-
-	/* Parameter checking   */
-	if (pciIf >= mvCtrlPciMaxIfGet()) {
-		mvOsPrintf("mvPciTargetWinEnable: ERR. Invalid PCI interface %d\n", pciIf);
-		return MV_BAD_PARAM;
-	}
-
-	if (bar >= PCI_MAX_BARS) {
-		mvOsPrintf("mvPciTargetWinEnable: ERR. Illigal PCI BAR %d\n", bar);
-		return MV_BAD_PARAM;
-	}
-
-	if (MV_TRUE == enable) {
-		/* First check for overlap with other enabled windows */
-		/* Get current window */
-		if (MV_OK != mvPciTargetWinGet(pciIf, bar, &barWin)) {
-			mvOsPrintf("mvPciTargetWinEnable: ERR. targetWinGet fail\n");
-			return MV_ERROR;
-		}
-
-		/* Check for overlapping */
-		if (MV_TRUE == pciWinOverlapDetect(pciIf, bar, &barWin.addrWin)) {
-			/* Overlap detected */
-			mvOsPrintf("mvPciTargetWinEnable: ERR. Overlap detected\n");
-			return MV_ERROR;
-		} else
-			/* No Overlap. Enable address decode target window */
-			MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
-	} else
-		/* Disable address decode target window */
-		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
-
-	return MV_OK;
-}
-
-
-/*******************************************************************************
-* mvPciProtWinSet - Set PCI protection access window
-*
-* DESCRIPTION:
-*       This function sets a specified address window with access protection
-*       attributes. If protection structure enables the window the routine will
-*       also enable the protection window.
-*
-* INPUT:
-*       pciIf    - PCI interface number.
-*       winNum   - Protecion window number.
-*       pProtWin - Protection window structure.
-*
-* OUTPUT:
-*       N/A
-*
-* RETURN:
-*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
-*
-*******************************************************************************/
-MV_STATUS mvPciProtWinSet(MV_U32		pciIf,
-			MV_U32			winNum,
-			struct _mvPciProtWin	*pProtWin)
-{
-	MV_U32 protBaseLow;
-	MV_U32 protBaseHigh;
-	MV_U32 protSize;
-
-	/* Parameter checking */
-	if (pciIf >= mvCtrlPciMaxIfGet()) {
-		mvOsPrintf("mvPciProtWinSet: ERR. Invalid PCI interface %d\n", pciIf);
-		return MV_BAD_PARAM;
-	}
-
-	if (winNum >= PCI_MAX_PROT_WIN)	{
-		mvOsPrintf("mvPciProtWinSet: ERR. Invalid window num %d\n", winNum);
-		return MV_BAD_PARAM;
-	}
-
-	/* Check if the window complies with PCI spec */
-	if (MV_TRUE != pciWinIsValid(pProtWin->addrWin.baseLow,
-					pProtWin->addrWin.size)) {
-		mvOsPrintf("mvPciProtWinSet: ERR. Win base 0x%x unaligned to size 0x%llx\n",
-			pProtWin->addrWin.baseLow, pProtWin->addrWin.size);
-
-		return MV_BAD_PARAM;
-	}
-
-	if (pProtWin->attributes.swapType >= SWAP_TYPE_MAX) {
-		mvOsPrintf("mvPciProtWinSet: ERR. Swap parameter invalid %d\n",
-			pProtWin->attributes.swapType);
-		return MV_BAD_PARAM;
-	}
-
-	/* 1) Calculate protection window base low register value */
-	protBaseLow = pProtWin->addrWin.baseLow;
-
-	/* Setting the appropriate bits according to the passed values */
-	if (MV_TRUE == pProtWin->enable)
-		protBaseLow |= PACBLR_EN;
-	else
-		protBaseLow &= ~PACBLR_EN;
-
-	/* I/O Cache Coherency */
-	protBaseLow |= ((MV_U32)pProtWin->attributes.snoop << PACBLR_SNOOP_OFFS);
-
-	/* Access protect */
-	if (ALLOWED == pProtWin->attributes.access)
-		protBaseLow &= ~PACBLR_ACCPROT;
-	else
-		protBaseLow |= PACBLR_ACCPROT;
-
-	/* Write Protect */
-	if (ALLOWED == pProtWin->attributes.write)
-		protBaseLow &= ~PACBLR_WRPROT;
-	else
-		protBaseLow |= PACBLR_WRPROT;
-
-	/* PCI slave Data Swap Control */
-	protBaseLow |= (pProtWin->attributes.swapType << PACBLR_PCISWAP_OFFS);
-
-	/* Read Max Burst */
-	if ((pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS) > PACBLR_RDMBURST_128BYTE) {
-		mvOsPrintf("mvPciProtWinSet: ERR illigal read max burst\n");
-		return MV_ERROR;
-	}
-	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS);
-
-
-	/* Typical PCI read transaction Size. Only valid for PCI conventional */
-	if ((pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS) > PACBLR_RDSIZE_256BYTE) {
-		mvOsPrintf("mvPciProtWinSet: ERR. illigal read size\n");
-		return MV_ERROR;
-	}
-	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS);
-
-
-	/* 2) Calculate protection window base high register value */
-	protBaseHigh = pProtWin->addrWin.baseHigh;
-
-	/* 3) Calculate protection window size register value	*/
-	protSize = ctrlSizeToReg(pProtWin->addrWin.size, PACSR_SIZE_ALIGNMENT) << PACSR_SIZE_OFFS;
-
-	/* Write Max Burst */
-	if ((pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS) > PACSR_WRMBURST_128BYTE) {
-		mvOsPrintf("mvPciProtWinSet: ERR illigal write max burst\n");
-		return MV_ERROR;
-	}
-	protSize |= (pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS);
-
-	/* Pci Order */
-	if (MV_TRUE == pProtWin->attributes.pciOrder)
-		protSize |= PACSR_PCI_ORDERING;
-	else
-		protSize &= ~PACSR_PCI_ORDERING;
-
-	/* Writing protection window walues into registers */
-	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum), protBaseLow);
-	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEH_REG(pciIf, winNum), protBaseHigh);
-	MV_REG_WRITE(PCI_ACCESS_CTRL_SIZE_REG(pciIf, winNum), protSize);
-
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvPciProtWinGet - Get PCI protection access window
-*
-* DESCRIPTION:
-*       This function gets a specified address window and access protection
-*       attributes for a specific protection window .
-*
-* INPUT:
-*       pciIf    - PCI interface number.
-*       winNum   - Protecion window number.
-*       pProtWin - pointer to a Protection window structure.
-*
-* OUTPUT:
-*       pProtWin - Protection window structure.
-*
-* RETURN:
-*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
-*
-*******************************************************************************/
-MV_STATUS mvPciProtWinGet(MV_U32		pciIf,
-			MV_U32			winNum,
-			struct _mvPciProtWin	*pProtWin)
-{
-	MV_U32 protBaseLow;
-	MV_U32 protBaseHigh;
-	MV_U32 protSize;
-
-	/* Parameter checking   */
-	if (pciIf >= mvCtrlPciMaxIfGet()) {
-		mvOsPrintf("mvPciProtWinGet: ERR. Invalid PCI interface %d\n", pciIf);
-		return MV_BAD_PARAM;
-	}
-
-	if (winNum >= PCI_MAX_PROT_WIN) {
-		mvOsPrintf("mvPciProtWinGet: ERR. Invalid window num %d\n", winNum);
-		return MV_BAD_PARAM;
-	}
-
-	/* Writing protection window walues into registers */
-	protBaseLow = MV_REG_READ(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum));
-	protBaseHigh = MV_REG_READ(PCI_ACCESS_CTRL_BASEH_REG(pciIf, winNum));
-	protSize = MV_REG_READ(PCI_ACCESS_CTRL_SIZE_REG(pciIf, winNum));
-
-	/* 1) Get Protection Windows base low */
-	pProtWin->addrWin.baseLow = protBaseLow & PACBLR_BASE_L_MASK;
-
-	/* Get the appropriate protection attributes according to register bits */
-
-	/* Is Windows enabled ? */
-	if (protBaseLow & PACBLR_EN)
-		pProtWin->enable = MV_TRUE;
-	else
-		pProtWin->enable = MV_FALSE;
-
-
-	/* What is access protect ? */
-	if (protBaseLow & PACBLR_ACCPROT)
-		pProtWin->attributes.access = FORBIDDEN;
-	else
-		pProtWin->attributes.access = ALLOWED;
-
-	/* Is write protect ? */
-	if (protBaseLow & PACBLR_WRPROT)
-		pProtWin->attributes.write = FORBIDDEN;
-	else
-		pProtWin->attributes.write = ALLOWED;
-
-	/* PCI slave Data Swap Control */
-	pProtWin->attributes.swapType = (protBaseLow & PACBLR_PCISWAP_MASK) >> PACBLR_PCISWAP_OFFS;
-
-	/* Read Max Burst */
-	pProtWin->attributes.readMaxBurst =
-		pciBurstReg2Bytes((protBaseLow & PACBLR_RDMBURST_MASK) >> PACBLR_RDMBURST_OFFS);
-
-	/* Typical PCI read transaction Size. */
-	pProtWin->attributes.readBurst = pciBurstReg2Bytes((protBaseLow & PACBLR_RDSIZE_MASK) >> PACBLR_RDSIZE_OFFS);
-
-
-	/* window base high register value */
-	pProtWin->addrWin.baseHigh = protBaseHigh;
-
-	/*Calculate protection window size register value */
-	pProtWin->addrWin.size = ctrlRegToSize(((protSize & PACSR_SIZE_MASK) >> PACSR_SIZE_OFFS), PACSR_SIZE_ALIGNMENT);
-
-	/* Write Max Burst */
-	pProtWin->attributes.writeMaxBurst = pciBurstReg2Bytes((protSize & PACSR_WRMBURST_MASK) >> PACSR_WRMBURST_OFFS);
-
-	/* Pci Order */
-	if (protSize & PACSR_PCI_ORDERING)
-		pProtWin->attributes.pciOrder = MV_TRUE;
-	else
-		pProtWin->attributes.pciOrder = MV_FALSE;
-
-	return MV_OK;
-}
-
-
-/*******************************************************************************
-* mvPciProtWinEnable - Enable/disable a PCI protection access window
-*
-* DESCRIPTION:
-*       This function enable/disable a PCI protection access window.
-*       if parameter 'enable' == MV_TRUE the routine will enable the
-*       protection window, otherwise, the protection window will be disabled.
-*
-* INPUT:
-*       pciIf  - PCI interface number.
-*       winNum - Protecion window number.
-*       enable - Enable/disable parameter.
-*
-* OUTPUT:
-*       N/A
-*
-* RETURN:
-*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
-*
-*******************************************************************************/
-MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable)
-{
-	/* Parameter checking   */
-	if (pciIf >= mvCtrlPciMaxIfGet()) {
-		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid PCI interface %d\n", pciIf);
-		return MV_BAD_PARAM;
-	}
-
-	if (winNum >= PCI_MAX_PROT_WIN) {
-		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid window num %d\n", winNum);
-		return MV_BAD_PARAM;
-	}
-
-	if (MV_TRUE == enable)
-		MV_REG_BIT_SET(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum), PACBLR_EN);
-	else
-		MV_REG_BIT_RESET(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum), PACBLR_EN);
-
-	return MV_OK;
-}
-
-
-/*******************************************************************************
-* mvPciTargetRemap - Set PCI to target address window remap.
-*
-* DESCRIPTION:
-*       The PCI interface supports remap of the BAR original address window.
-*       For each BAR it is possible to define a remap address. For example
-*       an address 0x12345678 that hits BAR 0x10 (SDRAM CS[0]) will be modified
-*       according to remap register but will also be targeted to the
-*       SDRAM CS[0].
-*
-* INPUT:
-*       pciIf    - PCI interface number.
-*       bar      - Peripheral target enumerator accessed by slave.
-*       pAddrWin - Address window to be checked.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
-*
-*******************************************************************************/
-MV_STATUS mvPciTargetRemap(MV_U32	pciIf,
-			enum _mvPCIBars	bar,
-			MV_ADDR_WIN	*pAddrWin)
-{
-	struct _pciBarRegInfo barRegInfo;
-
-	/* Parameter checking   */
-	if (pciIf >= mvCtrlPciMaxIfGet()) {
-		mvOsPrintf("mvPciTargetRemap: ERR. Invalid PCI interface num %d\n", pciIf);
-		return MV_BAD_PARAM;
-	}
-
-	if (MV_IS_NOT_ALIGN(pAddrWin->baseLow, PBARR_REMAP_ALIGNMENT)) {
-		mvOsPrintf("mvPciTargetRemap: Error remapping PCI interface %d bar %s."\
-			"\nAddress 0x%08x is unaligned to size 0x%llx.\n",
-			pciIf,
-			pciBarNameGet(bar),
-			pAddrWin->baseLow,
-			pAddrWin->size);
-		return MV_ERROR;
-	}
-
-	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
-
-	/* Set remap low register value */
-	MV_REG_WRITE(barRegInfo.remapLowRegOffs, pAddrWin->baseLow);
-
-	/* Skip base high settings if the BAR has only base low (32-bit) */
-	if (0 != barRegInfo.remapHighRegOffs)
-		MV_REG_WRITE(barRegInfo.remapHighRegOffs, pAddrWin->baseHigh);
-
-	return MV_OK;
-}
-
-/*******************************************************************************
-* pciWinOverlapDetect - Detect address windows overlapping
-*
-* DESCRIPTION:
-*       This function detects address window overlapping of a given address
-*       window in PCI BARs.
-*
-* INPUT:
-*       pAddrWin - Address window to be checked.
-*       bar      - BAR to be accessed by slave.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_TRUE if the given address window overlap current address
-*       decode map, MV_FALSE otherwise.
-*
-*******************************************************************************/
-static MV_BOOL pciWinOverlapDetect(MV_U32 pciIf, enum _mvPCIBars bar, MV_ADDR_WIN *pAddrWin)
-{
-	MV_U32			barEnableReg;
-	MV_U32			targetBar;
-	struct _mvPciBarWin	barAddrWin;
-
-	/* Read base address enable register. Do not check disabled windows */
-	barEnableReg = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
-
-	for (targetBar = 0; targetBar < PCI_MAX_BARS; targetBar++) {
-		/* don't check our target or illegal targets */
-		if (targetBar == bar)
-			continue;
-
-		/* Do not check disabled windows */
-		if (barEnableReg & (BARER_ENABLE(targetBar)))
-			continue;
-
-		/* Get window parameters */
-		if (MV_OK != mvPciTargetWinGet(pciIf, targetBar, &barAddrWin)) {
-			mvOsPrintf("pciWinOverlapDetect: ERR. TargetWinGet failed\n");
-			return MV_ERROR;
-		}
-
-		/* skip overlapp detect between MEM_INTER_REGS_BAR and IO_INTER_REGS_BAR*/
-		if (((bar == MEM_INTER_REGS_BAR) && (targetBar == IO_INTER_REGS_BAR)) ||
-			((bar == IO_INTER_REGS_BAR) && (targetBar == MEM_INTER_REGS_BAR)))
-			return MV_FALSE;
-		else if (MV_TRUE == mvWinOverlapTest(pAddrWin, &barAddrWin.addrWin)) {
-			mvOsPrintf("pciWinOverlapDetect: BAR %d overlap current %d\n", bar, targetBar);
-			return MV_TRUE;
-		}
-	}
-
-	return MV_FALSE;
-}
-
-/*******************************************************************************
-* cpuWinIsValid - Check if the given address window is valid
-*
-* DESCRIPTION:
-*	PCI spec restrict BAR base to be aligned to BAR size.
-*	This function checks if the given address window is valid.
-*
-* INPUT:
-*       baseLow - 32bit low base address.
-*       size    - Window size.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_TRUE if the address window is valid, MV_FALSE otherwise.
-*
-*******************************************************************************/
-static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size)
-{
-	/* PCI spec restrict BAR base to be aligned to BAR size */
-	if (MV_IS_NOT_ALIGN(baseLow, size))
-		return MV_ERROR;
-	else
-		return MV_TRUE;
-}
-
-/*******************************************************************************
-* pciBarRegInfoGet - Get BAR register information
-*
-* DESCRIPTION:
-*	PCI BARs registers offsets are inconsecutive.
-*	This function gets a PCI BAR register information like register offsets
-*	and function location of the BAR.
-*
-* INPUT:
-*       pciIf - PCI interface number.
-*	bar	  - The PCI BAR in question.
-*
-* OUTPUT:
-*       pBarRegInfo - BAR register info struct.
-*
-* RETURN:
-*	MV_BAD_PARAM when bad parameters ,MV_ERROR on error ,othewise MV_OK
-*
-*******************************************************************************/
-static MV_STATUS pciBarRegInfoGet(MV_U32		pciIf,
-				enum _mvPCIBars		bar,
-				struct _pciBarRegInfo	*pBarRegInfo)
-{
-	switch (bar) {
-	/* Function 0 Bars */
-	#if defined(MV_INCLUDE_SDRAM_CS0)
-	case CS0_BAR:		/* SDRAM chip select 0 bar*/
-		pBarRegInfo->funcNum		= 0;
-		pBarRegInfo->baseLowRegOffs	= PCI_SCS0_BASE_ADDR_LOW;
-		pBarRegInfo->baseHighRegOffs	= PCI_SCS0_BASE_ADDR_HIGH;
-		pBarRegInfo->sizeRegOffs	= PCI_CS0_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_CS0_ADDR_REMAP_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-	#endif
-
-	#if defined(MV_INCLUDE_SDRAM_CS1)
-	case CS1_BAR:		/* SDRAM chip select 1 bar*/
-		pBarRegInfo->funcNum		= 0;
-		pBarRegInfo->baseLowRegOffs	= PCI_SCS1_BASE_ADDR_LOW;
-		pBarRegInfo->baseHighRegOffs	= PCI_SCS1_BASE_ADDR_HIGH;
-		pBarRegInfo->sizeRegOffs	= PCI_CS1_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_CS1_ADDR_REMAP_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-	#endif
-
-	case MEM_INTER_REGS_BAR: /* Memory Mapped Internal bar */
-		pBarRegInfo->funcNum		= 0;
-		pBarRegInfo->baseLowRegOffs	= PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_L;
-		pBarRegInfo->baseHighRegOffs	= PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_H;
-		pBarRegInfo->sizeRegOffs	= 0;
-		pBarRegInfo->remapLowRegOffs	= 0;
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-
-	/* Function 1 Bars */
-	#if defined(MV_INCLUDE_SDRAM_CS2)
-	case CS2_BAR:		/* SDRAM chip select 2 bar*/
-		pBarRegInfo->funcNum		= 1;
-		pBarRegInfo->baseLowRegOffs	= PCI_SCS2_BASE_ADDR_LOW;
-		pBarRegInfo->baseHighRegOffs	= PCI_SCS2_BASE_ADDR_HIGH;
-		pBarRegInfo->sizeRegOffs	= PCI_CS2_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_CS2_ADDR_REMAP_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-	#endif
-
-	#if defined(MV_INCLUDE_SDRAM_CS3)
-	case CS3_BAR:		/* SDRAM chip select 3 bar*/
-		pBarRegInfo->funcNum		= 1;
-		pBarRegInfo->baseLowRegOffs	= PCI_SCS3_BASE_ADDR_LOW;
-		pBarRegInfo->baseHighRegOffs	= PCI_SCS3_BASE_ADDR_HIGH;
-		pBarRegInfo->sizeRegOffs	= PCI_CS3_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_CS3_ADDR_REMAP_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-	#endif
-
-	#if defined(MV_INCLUDE_DEVICE_CS0)
-	/* Function 2 Bars */
-	case DEVCS0_BAR:	/* Device chip select 0 bar*/
-		pBarRegInfo->funcNum		= 2;
-		pBarRegInfo->baseLowRegOffs	= PCI_DEVCS0_BASE_ADDR_LOW;
-		pBarRegInfo->baseHighRegOffs	= PCI_DEVCS0_BASE_ADDR_HIGH;
-		pBarRegInfo->sizeRegOffs	= PCI_DEVCS0_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_DEVCS0_ADDR_REMAP_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-	#endif
-
-	#if defined(MV_INCLUDE_DEVICE_CS1)
-	case DEVCS1_BAR:	/* Device chip select 0 bar*/
-		pBarRegInfo->funcNum		= 2;
-		pBarRegInfo->baseLowRegOffs	= PCI_DEVCS1_BASE_ADDR_LOW;
-		pBarRegInfo->baseHighRegOffs	= PCI_DEVCS1_BASE_ADDR_HIGH;
-		pBarRegInfo->sizeRegOffs	= PCI_DEVCS1_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_DEVCS1_ADDR_REMAP_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-	#endif
-
-	#if defined(MV_INCLUDE_DEVICE_CS2)
-	case DEVCS2_BAR:	/* Device chip select 0 bar*/
-		pBarRegInfo->funcNum		= 2;
-		pBarRegInfo->baseLowRegOffs	= PCI_DEVCS2_BASE_ADDR_LOW;
-		pBarRegInfo->baseHighRegOffs	= PCI_DEVCS2_BASE_ADDR_HIGH;
-		pBarRegInfo->sizeRegOffs	= PCI_DEVCS2_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_DEVCS2_ADDR_REMAP_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-	#endif
-
-	case BOOTCS_BAR:	/* Boot device chip select bar*/
-		pBarRegInfo->funcNum		= 3;
-		pBarRegInfo->baseLowRegOffs	= PCI_BOOTCS_BASE_ADDR_LOW;
-		pBarRegInfo->baseHighRegOffs	= PCI_BOOTCS_BASE_ADDR_HIGH;
-		pBarRegInfo->sizeRegOffs	= PCI_BOOTCS_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_BOOTCS_ADDR_REMAP_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-
-	/* Function 4 Bars */
-	case P2P_MEM0:		/* P2P memory 0 */
-		pBarRegInfo->funcNum		= 4;
-		pBarRegInfo->baseLowRegOffs	= PCI_P2P_MEM0_BASE_ADDR_LOW;
-		pBarRegInfo->baseHighRegOffs	= PCI_P2P_MEM0_BASE_ADDR_HIGH;
-		pBarRegInfo->sizeRegOffs	= PCI_P2P_MEM0_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf);
-		break;
-
-	case P2P_IO:		/* P2P IO */
-		pBarRegInfo->funcNum		= 4;
-		pBarRegInfo->baseLowRegOffs	= PCI_P2P_IO_BASE_ADDR;
-		pBarRegInfo->baseHighRegOffs	= 0;
-		pBarRegInfo->sizeRegOffs	= PCI_P2P_IO_BAR_SIZE_REG(pciIf);
-		pBarRegInfo->remapLowRegOffs	= PCI_P2P_IO_ADDR_REMAP_REG(pciIf);
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-
-	case IO_INTER_REGS_BAR: /* IO Mapped Internal bar */
-		pBarRegInfo->funcNum		= 4;
-		pBarRegInfo->baseLowRegOffs	= PCI_INTER_REGS_IO_MAPPED_BASE_ADDR;
-		pBarRegInfo->baseHighRegOffs	= 0;
-		pBarRegInfo->sizeRegOffs	= 0;
-		pBarRegInfo->remapLowRegOffs	= 0;
-		pBarRegInfo->remapHighRegOffs	= 0;
-		break;
-
-	default:
-		mvOsPrintf("mvPciTargetWinGet: ERR.non existing target\n");
-		return MV_ERROR;
-
-	}
-
-	return MV_OK;
-}
-
-/*******************************************************************************
-* pciBarNameGet - Get the string name of PCI BAR.
-*
-* DESCRIPTION:
-*		This function get the string name of PCI BAR.
-*
-* INPUT:
-*       bar - PCI bar number.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       pointer to the string name of PCI BAR.
-*
-*******************************************************************************/
-const MV_8 *pciBarNameGet(enum _mvPCIBars bar)
-{
-	switch (bar) {
-#if defined(MV_INCLUDE_SDRAM_CS0)
-	case CS0_BAR:
-		return "CS0_BAR..............";
-#endif
-#if defined(MV_INCLUDE_SDRAM_CS1)
-	case CS1_BAR:
-		return "CS1_BAR..............";
-#endif
-#if defined(MV_INCLUDE_SDRAM_CS2)
-	case CS2_BAR:
-		return "CS2_BAR..............";
-#endif
-#if defined(MV_INCLUDE_SDRAM_CS3)
-	case CS3_BAR:
-		return "CS3_BAR..............";
-#endif
-#if defined(MV_INCLUDE_DEVICE_CS0)
-	case DEVCS0_BAR:
-		return "DEVCS0_BAR...........";
-#endif
-#if defined(MV_INCLUDE_DEVICE_CS1)
-	case DEVCS1_BAR:
-		return "DEVCS1_BAR...........";
-#endif
-#if defined(MV_INCLUDE_DEVICE_CS2)
-	case DEVCS2_BAR:
-		return "DEVCS2_BAR...........";
-#endif
-	case BOOTCS_BAR:
-		return "BOOTCS_BAR...........";
-	case MEM_INTER_REGS_BAR:
-		return "MEM_INTER_REGS_BAR...";
-	case IO_INTER_REGS_BAR:
-		return "IO_INTER_REGS_BAR....";
-	case P2P_MEM0:
-		return "P2P_MEM0.............";
-	case P2P_IO:
-		return "P2P_IO...............";
-	default:
-		 return "target unknown";
-	}
-}
-
-/*******************************************************************************
-* mvPciAddrDecShow - Print the PCI address decode map (BARs).
-*
-* DESCRIPTION:
-*		This function print the PCI address decode map (BARs).
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-MV_VOID mvPciAddrDecShow(MV_VOID)
-{
-	struct _mvPciBarWin	win;
-	enum _mvPCIBars		bar;
-	MV_U32			pciIf;
-
-	for (pciIf = 0; pciIf < mvCtrlPciMaxIfGet(); pciIf++) {
-		mvOsOutput("\n");
-		mvOsOutput("PCI%d:\n", pciIf);
-		mvOsOutput("-----\n");
-
-		for (bar = 0; bar < PCI_MAX_BARS; bar++) {
-			memset(&win, 0, sizeof(struct _mvPciBarWin));
-
-			mvOsOutput("%s ", pciBarNameGet(bar));
-
-			if (mvPciTargetWinGet(pciIf, bar, &win) == MV_OK) {
-				if (win.enable) {
-					mvOsOutput("base %08x, ", win.addrWin.baseLow);
-					mvSizePrint(win.addrWin.size);
-					mvOsOutput("\n");
-				} else
-					mvOsOutput("disable\n");
-			}
-		}
-	}
-}
-
-/* convert burst bytes to register value*/
-static MV_U32 pciBurstBytes2Reg(MV_U32 size)
-{
-	MV_U32 ret;
-
-	switch (size) {
-	case 32:
-		ret = 0;
-		break;
-	case 64:
-		ret = 1;
-		break;
-	case 128:
-		ret = 2;
-		break;
-	case 256:
-		ret = 3;
-		break;
-	default:
-		ret = 0xF; /* error */
-	}
-	return ret;
-}
-
-/* convert register value to burst bytes*/
-static MV_U32 pciBurstReg2Bytes(MV_U32 size)
-{
-	MV_U32 ret;
-
-	switch (size) {
-	case 0:
-		ret = 32;
-		break;
-	case 1:
-		ret = 64;
-		break;
-	case 2:
-		ret = 128;
-		break;
-	case 3:
-		ret = 256;
-		break;
-	default:
-		ret = 0x0; /* error */
-	}
-	return ret;
-}
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysPci.h b/arch/arm/mach-msys/mv_hal_if/mvSysPci.h
deleted file mode 100644
index 29abf28..0000000
--- a/arch/arm/mach-msys/mv_hal_if/mvSysPci.h
+++ /dev/null
@@ -1,251 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-
-#ifndef __INCSysPCIH
-#define __INCSysPCIH
-
-#include "ctrlEnv/sys/mvCpuIf.h"
-#include "pci/mvPci.h"
-#include "ctrlEnv/mvCtrlEnvLib.h"
-#include "ctrlEnv/mvCtrlEnvAddrDec.h"
-#include "mvSysPciConfig.h"
-
-#define PCI_MAX_PROT_WIN			6
-
-/* 4KB granularity */
-#define MINIMUM_WINDOW_SIZE			0x1000
-#define MINIMUM_BAR_SIZE			0x1000
-#define MINIMUM_BAR_SIZE_MASK			0xFFFFF000
-#define BAR_SIZE_OFFS				12
-#define BAR_SIZE_MASK				(0xFFFFF << BAR_SIZE_OFFS)
-
-#define PCI_IO_WIN_NUM				1 /* Number of PCI_IO windows  */
-#define PCI_MEM_WIN_NUM				4 /* Number of PCI_MEM windows */
-
-#ifndef MV_ASMLANGUAGE
-#include "ctrlEnv/mvCtrlEnvLib.h"
-enum _mvPCIBars {
-	PCI_BAR_TBL_TERM = -1, /* none valid bar, used as bars list terminator */
-#if defined(MV_INCLUDE_SDRAM_CS0)
-	CS0_BAR,
-#endif
-#if defined(MV_INCLUDE_SDRAM_CS1)
-	CS1_BAR,
-#endif
-#if defined(MV_INCLUDE_SDRAM_CS2)
-	CS2_BAR,
-#endif
-#if defined(MV_INCLUDE_SDRAM_CS3)
-	CS3_BAR,
-#endif
-#if defined(MV_INCLUDE_DEVICE_CS0)
-	DEVCS0_BAR,
-#endif
-#if defined(MV_INCLUDE_DEVICE_CS1)
-	DEVCS1_BAR,
-#endif
-#if defined(MV_INCLUDE_DEVICE_CS2)
-	DEVCS2_BAR,
-#endif
-	BOOTCS_BAR,		/* Boot device chip select bar*/
-	MEM_INTER_REGS_BAR,	/* Memory Mapped Internal bar */
-	IO_INTER_REGS_BAR,	/* IO Mapped Internal bar */
-	P2P_MEM0,		/* P2P memory 0 */
-	P2P_IO,			/* P2P IO */
-	PCI_MAX_BARS
-} MV_PCI_BAR;
-#endif /* MV_ASMLANGUAGE */
-
-#if defined(MV_INCLUDE_SDRAM_CS3)
-#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS3_BAR))
-#elif defined(MV_INCLUDE_SDRAM_CS2)
-#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS2_BAR))
-#elif defined(MV_INCLUDE_SDRAM_CS1)
-#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS1_BAR))
-#elif defined(MV_INCLUDE_SDRAM_CS0)
-#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar == CS0_BAR))
-#endif
-
-
-/****************************************/
-/* PCI Slave Address Decoding registers */
-/****************************************/
-#define PCI_CS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c08 + ((pciIf) * 0x80))
-#define PCI_CS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d08 + ((pciIf) * 0x80))
-#define PCI_CS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c0c + ((pciIf) * 0x80))
-#define PCI_CS3_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d0c + ((pciIf) * 0x80))
-#define PCI_DEVCS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c10 + ((pciIf) * 0x80))
-#define PCI_DEVCS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d10 + ((pciIf) * 0x80))
-#define PCI_DEVCS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d18 + ((pciIf) * 0x80))
-#define PCI_BOOTCS_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d14 + ((pciIf) * 0x80))
-#define PCI_P2P_MEM0_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d1c + ((pciIf) * 0x80))
-#define PCI_P2P_IO_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d24 + ((pciIf) * 0x80))
-#define PCI_EXPAN_ROM_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d2c + ((pciIf) * 0x80))
-#define PCI_BASE_ADDR_ENABLE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c3c + ((pciIf) * 0x80))
-#define PCI_CS0_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c48 + ((pciIf) * 0x80))
-#define PCI_CS1_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d48 + ((pciIf) * 0x80))
-#define PCI_CS2_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c4c + ((pciIf) * 0x80))
-#define PCI_CS3_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d4c + ((pciIf) * 0x80))
-#define PCI_DEVCS0_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c50 + ((pciIf) * 0x80))
-#define PCI_DEVCS1_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d50 + ((pciIf) * 0x80))
-#define PCI_DEVCS2_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d58 + ((pciIf) * 0x80))
-#define PCI_BOOTCS_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d54 + ((pciIf) * 0x80))
-#define PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d5c + ((pciIf) * 0x80))
-#define PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d60 + ((pciIf) * 0x80))
-#define PCI_P2P_IO_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d6c + ((pciIf) * 0x80))
-#define PCI_EXPAN_ROM_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0f38 + ((pciIf) * 0x80))
-#define PCI_DRAM_BAR_BANK_SELECT_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c1c + ((pciIf) * 0x80))
-#define PCI_ADDR_DECODE_CONTROL_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d3c + ((pciIf) * 0x80))
-
-/* PCI Bars Size Registers (PBSR) */
-#define PBSR_SIZE_OFFS				12
-#define PBSR_SIZE_MASK				(0xfffff << PBSR_SIZE_OFFS)
-
-/* Base Address Registers Enable Register (BARER) */
-#define BARER_ENABLE(target)			(1 << (target))
-
-/* PCI Base Address Remap Registers (PBARR) */
-#define PBARR_REMAP_OFFS			12
-#define PBARR_REMAP_MASK			(0xfffff << PBARR_REMAP_OFFS)
-#define PBARR_REMAP_ALIGNMENT			(1 << PBARR_REMAP_OFFS)
-
-/* PCI DRAM Bar Bank Select Register (PDBBSR) */
-#define PDBBSR_DRAM_BANK_OFFS(bank)		((bank) * 2)
-#define PDBBSR_DRAM_BANK_MASK(bank)		(0x3 << PDBBSR_DRAM_BANK_OFFS(bank))
-
-/* PCI Address Decode Control Register (PADCR)*/
-#define PADCR_REMAP_REG_WR_DIS			BIT0
-#define PADCR_MSG_REG_ACC			BIT3
-
-#define PADCR_VPD_HIGH_ADDR_OFFS		8 /* Bits [31:15] of the VPD address */
-#define PADCR_VPD_HIGH_ADDR_MASK		(0x1ffff << PADCR_VPD_HIGH_ADDR_OFFS)
-
-/* PCI Headers Retarget Control Register (PHRCR) */
-#define PHRCR_ENABLE				BIT0
-#define PHRCR_BUFF_SIZE_OFFS			1
-#define PHRCR_BUFF_SIZE_MASK			(0x7 << PHRCR_BUFF_SIZE_OFFS)
-#define PHRCR_BUFF_SIZE_258BYTE			(0x0 << PHRCR_BUFF_SIZE_OFFS)
-#define PHRCR_BUFF_SIZE_512BYTE			(0x1 << PHRCR_BUFF_SIZE_OFFS)
-#define PHRCR_BUFF_SIZE_1KB			(0x2 << PHRCR_BUFF_SIZE_OFFS)
-#define PHRCR_BUFF_SIZE_2KB			(0x3 << PHRCR_BUFF_SIZE_OFFS)
-#define PHRCR_BUFF_SIZE_4KB			(0x4 << PHRCR_BUFF_SIZE_OFFS)
-#define PHRCR_BUFF_SIZE_8KB			(0x5 << PHRCR_BUFF_SIZE_OFFS)
-#define PHRCR_MASK1_OFFS			16
-#define PHRCR_MASK1_MASK			(0xffff << PHRCR_MASK1_OFFS)
-
-/* PCI Headers Retarget Base Register (PHRBR) */
-#define PHRBR_BASE_OFFS				16
-#define PHRBR_BASE_MASK				(0xffff << PHRBR_BASE_OFFS)
-
-/* PCI Headers Retarget Base High Register (PHRBHR) */
-#define PHRBHR_BASE_OFFS			0
-#define PHRBHR_BASE_MASK			(0xffffffff << PHRBHR_BASE_OFFS)
-
-/* This structure describes a PCI BAR. It is also refered as PCI target     */
-/* window to keep consistency with other address decode units in the system */
-struct _mvPciBarWin {
-	MV_ADDR_WIN	addrWin;	/* Address window	*/
-	MV_BOOL		enable;		/* BAR enable/disable	*/
-};
-
-enum _mvPciSnoop {
-	NO_CACHE_COHER = 0,
-	WT_CACHE_COHER,
-	WB_CACHE_COHER
-};
-
-/* This structure describes PCI region attributes */
-struct _mvPciRegionAttr {
-	enum _mvPciSnoop	snoop;		/* Cache Coherenc			*/
-	MV_PROT_RIGHT	access;		/* Access protection			*/
-	MV_PROT_RIGHT	write;		/* Write protection			*/
-	MV_SWAP_TYPE	swapType;	/* Data swap mode for that region	*/
-	MV_U32		readMaxBurst;	/* Read max burst			*/
-	MV_U32		readBurst;	/* Read burst. Conventional PCI only	*/
-	MV_U32		writeMaxBurst;	/* Write max burst			*/
-	MV_BOOL		pciOrder;	/* Hardware support for PCI ordering	*/
-};
-
-/* The PCI slave interface supports configurable access control		*/
-/* It is possible to define up to six address ranges to different	*/
-/* configurations. This structure describes the PCI access region	*/
-struct _mvPciProtWin {
-	MV_ADDR_WIN		addrWin;	/* An address window		*/
-	struct _mvPciRegionAttr	attributes;	/* Window attributes		*/
-	MV_BOOL			enable;		/* Window enabled/disabled	*/
-};
-
-/* Global Functions prototypes */
-MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod);
-MV_STATUS mvPciTargetWinSet(MV_U32 pciIf, enum _mvPCIBars slaveTarget, struct _mvPciBarWin *pAddrBarWin);
-MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, enum _mvPCIBars slaveTarget, struct _mvPciBarWin *pAddrBarWin);
-MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf, enum _mvPCIBars slaveTarget, MV_BOOL enable);
-MV_STATUS mvPciProtWinSet(MV_U32 pciIf, MV_U32 winNum, struct _mvPciProtWin *pProtWin);
-MV_STATUS mvPciProtWinGet(MV_U32 pciIf, MV_U32 winNum, struct _mvPciProtWin *pProtWin);
-MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable);
-MV_STATUS mvPciTargetRemap(MV_U32 pciIf, enum _mvPCIBars slaveTarget, MV_ADDR_WIN *pAddrWin);
-MV_VOID mvPciAddrDecShow(MV_VOID);
-
-#endif
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysSpi.c b/arch/arm/mach-msys/mv_hal_if/mvSysSpi.c
index fa61ec9..0d2bf8d 100644
--- a/arch/arm/mach-msys/mv_hal_if/mvSysSpi.c
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysSpi.c
@@ -115,11 +115,6 @@ MV_STATUS mvSysSpiInit(MV_U8 spiId, MV_U32 serialBaudRate)
 *******************************************************************************/
 MV_STATUS mvSysSpiMppConfig(MV_U8 mode)
 {
-#if 0
-	if (mode == SYS_SPI_MPP_ENABLE)
-		mvMPPConfigToSPI();
-	else
-		mvMPPConfigToDefault();
-#endif
 	return MV_OK;
 }
+
diff --git a/arch/arm/mach-msys/pci.c b/arch/arm/mach-msys/pci.c
deleted file mode 100644
index 45497b8..0000000
--- a/arch/arm/mach-msys/pci.c
+++ /dev/null
@@ -1,246 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-#include <linux/kernel.h>
-#include <linux/pci.h>
-#include <linux/ptrace.h>
-#include <linux/slab.h>
-#include <linux/ioport.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/init.h>
-
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-#include <asm/mach/pci.h>
-
-#include "ctrlEnv/mvCtrlEnvLib.h"
-#include "ctrlEnv/sys/mvCpuIf.h"
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-#include "mvSysPci.h"
-#include "pci/mvPci.h"
-
-#undef DEBUG
-#ifdef DEBUG
-#	define DB(x) x
-#else
-#	define DB(x)
-#endif
-
-static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
-
-void __init mv_pci_preinit(void)
-{
-	MV_ADDR_WIN win;
-
-	if (mvCtrlPciMaxIfGet() > 1)
-		panic("Single PCI is supported ONLY!");
-
-	mvPciInit(0, MV_PCI_MOD_HOST);
-
-	/* I/O remmap */
-	win.baseLow = 0x0;
-	win.baseHigh = 0x0;
-	mvCpuIfPciRemap(PCI_IF0_IO, &win);
-}
-
-
-/* Currentlly the PCI config read/write are implemented as read modify write
-   to 32 bit.
-   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
-   read config WA will be removed.
-*/
-static int mv_pci0_read_config(struct pci_bus *bus, unsigned int devfn, int where,
-				int size, u32 *val)
-{
-	MV_U32 bus_num, func, regOff, dev_no, temp;
-	MV_U32 localBus;
-
-	*val = 0xffffffff;
-
-	bus_num = bus->number;
-	dev_no = PCI_SLOT(devfn);
-
-	/* don't return for our device */
-	localBus = mvPciLocalBusNumGet(0);
-	if ((dev_no == 0) && (bus_num == localBus)) {
-		DB(printk(KERN_DEBUG "PCI 0 read from our own dev return 0xffffffff\n"));
-		return 0xffffffff;
-	}
-
-	func = PCI_FUNC(devfn);
-	regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
-
-	if ((func == 0) && (dev_no < 2))
-		DB(printk(KERN_DEBUG "PCI 0 read: bus = %x dev = %x func = %x regOff = %x",
-			bus_num, dev_no, func, regOff));
-
-	temp = (u32)mvPciConfigRead(0, bus_num, dev_no, func, regOff);
-
-	switch (size) {
-	case 1:
-		temp = (temp >> (8*(where & 0x3))) & 0xff;
-		break;
-
-	case 2:
-		temp = (temp >> (8*(where & 0x2))) & 0xffff;
-		break;
-
-	default:
-		break;
-	}
-
-	*val = temp;
-
-	if ((func == 0) && (dev_no < 2))
-		DB(printk(KERN_DEBUG " got %x\n", temp));
-
-	return 0;
-}
-
-static int mv_pci0_write_config(struct pci_bus *bus, unsigned int devfn, int where,
-				int size, u32 val)
-{
-	MV_U32 bus_num, func, regOff, dev_no, temp, mask, shift;
-
-	bus_num = bus->number;
-	dev_no = PCI_SLOT(devfn);
-	func = PCI_FUNC(devfn);
-	regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
-
-	DB(printk(KERN_DEBUG "PCI 0: writing data %x size %x to bus %x dev %x func %x offs %x\n",
-			val, size, bus_num, dev_no, func, regOff));
-	if (size != 4)
-		temp = (u32)mvPciConfigRead(0, bus_num, dev_no, func, regOff);
-	else
-		temp = val;
-
-	switch (size) {
-	case 1:
-		shift = (8 * (where & 0x3));
-		mask = 0xff;
-		break;
-
-	case 2:
-		shift = (8 * (where & 0x2));
-		mask = 0xffff;
-		break;
-
-	default:
-		shift = 0;
-		mask = 0xffffffff;
-		break;
-	}
-
-	temp = (temp & (~(mask<<shift))) | ((val & mask) << shift);
-	mvPciConfigWrite(0, bus_num, dev_no, func, regOff, temp);
-
-	return 0;
-}
-
-static struct pci_ops mv_pci_ops = {
-	.read	= mv_pci0_read_config,
-	.write	= mv_pci0_write_config,
-};
-
-int __init mv_pci_setup(int nr, struct pci_sys_data *sys)
-{
-	struct resource *res;
-
-	if (nr)
-		panic("Single PCI is supported ONLY!");
-
-	sys->map_irq = mv_map_irq;
-
-	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
-	if (!res)
-		panic("PCI: unable to alloc resources");
-
-	memset(res, 0, sizeof(struct resource) * 2);
-
-	res[0].start = PEX0_IO_PHYS_BASE - IO_SPACE_REMAP;
-	res[0].end   =  PEX0_IO_PHYS_BASE - IO_SPACE_REMAP + PEX0_IO_SIZE - 1;
-	res[0].name  = "PCI0 IO Primary";
-	res[0].flags = IORESOURCE_IO;
-
-	res[1].start =  PEX_MEM_PHYS_BASE;
-	res[1].end   =  PEX_MEM_PHYS_BASE + PEX_MEM_SIZE - 1;
-	res[1].name  = "PCI0 Memory Primary";
-	res[1].flags = IORESOURCE_MEM;
-
-	if (request_resource(&ioport_resource, &res[0]))
-		printk(KERN_ERROR "IO Request resource failed - Pci If %x\n", nr);
-
-	if (request_resource(&iomem_resource, &res[1]))
-		printk(KERN_ERROR "Memory Request resource failed - Pci If %x\n", nr);
-
-	pci_add_resource(&sys->resources, &res[0]);
-	pci_add_resource(&sys->resources, &res[1]);
-	sys->io_offset = 0x0;
-
-	return 1;
-}
-
-struct pci_bus *mv_pci_scan_bus(int nr, struct pci_sys_data *sys)
-{
-	struct pci_ops *ops;
-	struct pci_bus *bus;
-
-	if (nr)
-		panic("Single PCI is supported ONLY!");
-
-	ops = &mv_pci_ops;
-	bus = pci_scan_bus(sys->busnr, ops, sys);
-	return bus;
-}
-
-static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-	return IRQ_AURORA_PCI0;
-}
-
-static struct hw_pci mv_pci __initdata = {
-	.swizzle	= pci_std_swizzle,
-	.map_irq	= mv_map_irq,
-	.setup		= mv_pci_setup,
-	.scan		= mv_pci_scan_bus,
-	.preinit	= mv_pci_preinit,
-};
-
-static int __init mv_pci_init(void)
-{
-	MV_U32 ifnum = mvCtrlPciMaxIfGet();
-	if (ifnum) {
-		mv_pci.nr_controllers = ifnum;
-		pci_common_init(&mv_pci);
-	}
-
-	return 0;
-}
-
-subsys_initcall(mv_pci_init);
diff --git a/arch/arm/mach-msys/platsmp.c b/arch/arm/mach-msys/platsmp.c
index d6b7ad8..73b3dee 100644
--- a/arch/arm/mach-msys/platsmp.c
+++ b/arch/arm/mach-msys/platsmp.c
@@ -102,7 +102,7 @@ void __init set_core_count(unsigned int cpu_count)
  */
 
 
-void  platform_secondary_init(unsigned int cpu)
+void __cpuinit platform_secondary_init(unsigned int cpu)
 {
 	trace_hardirqs_off();
 
@@ -124,7 +124,7 @@ void  platform_secondary_init(unsigned int cpu)
 	smp_wmb();
 }
 
-int  boot_secondary(unsigned int cpu, struct task_struct *idle)
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	MV_U32 reg;
 
diff --git a/arch/arm/mach-msys/time.c b/arch/arm/mach-msys/time.c
index c14d115..9b90964 100644
--- a/arch/arm/mach-msys/time.c
+++ b/arch/arm/mach-msys/time.c
@@ -328,7 +328,7 @@ int __cpuinit msys_local_timer_setup(struct clock_event_device *clk)
 /*
  * take a local timer down
  */
-void  __cpuexit msys_local_timer_stop(struct clock_event_device *evt)
+void msys_local_timer_stop(struct clock_event_device *evt)
 {
 	unsigned long flags;
 	u32 u;
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index b85551e..9d899d9 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -67,7 +67,7 @@ endif
 
 config MV_INCLUDE_PCI
 	bool "PCI Support"
-	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X || ARCH_MSYS)
+	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X)
 	default n
         help
         Please don't change this configs unless you know what you are doing.
-- 
1.7.5.4

