From ea5129faa970b322e4ffb6079da371f9357cb1b6 Mon Sep 17 00:00:00 2001
From: Jing Hua <jinghua@marvell.com>
Date: Mon, 24 Mar 2014 17:30:27 +0800
Subject: [PATCH 1501/1825] alp: switch: integrate modification from PON SDK

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit dd9ee7b2b3a939de9798a59a9abb6a3a1750b8ba

	merge switch change that TPM team made in PON SDK
	1. add routine feGetAutoMode
	2. add routine gigCopperGetAutoMode
	3. add routine phyGetAutoMode
	4. add routine gprtGetPortLoopback
	5. add routine gprtSetPortLineLoopback
	6. add routine gprtGetPortLineLoopback
	7. add routine gprtGetPortAutoNegState
	8. add routine gprtGetPortPowerDown
	9. add routine gprtGetPortAutoMode
	10. add routine gprtGetPause
	11. add routine gsysSetLearn2All
	12. add routine gsysGetLearn2All

Change-Id: I2d7874ba7e70aac2b535b42e213ea4b0b8973191
Signed-off-by: Jing Hua <jinghua@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/6633
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../qd-dsdt-3.3/Include/h/driver/gtDrvSwRegs.h     |    4 +
 .../mv_hal/qd-dsdt-3.3/Include/msApiPrototype.h    |  291 +++++++-
 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/makedefs   |    2 +-
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl.c       |  829 +++++++++++++++++++-
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPortCtrl.c      |   95 +++
 5 files changed, 1178 insertions(+), 43 deletions(-)

diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvSwRegs.h b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvSwRegs.h
index 15b3d79..4f8c586 100644
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvSwRegs.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvSwRegs.h
@@ -58,6 +58,7 @@
 #define QD_REG_MACADDR_23        0x2
 #define QD_REG_MACADDR_45        0x3
 #define QD_REG_GLOBAL_CONTROL        0x4
+#define QD_REG_AGETIME_LA_CONTROL    0xA
 #define QD_REG_GLOBAL_CONTROL2        0x1C    /* for Sapphire, Schooner family */
 #define QD_REG_CORETAG_TYPE        0x19        /* for Ruby family */
 #define QD_REG_IP_MAPPING_TABLE    0x19        /* for Amber family */
@@ -269,6 +270,9 @@
 #define QD_PHY_INT_POLARITY_CHANGED        0x2
 #define QD_PHY_INT_JABBER            0x1
 
+/*Line loopback register related definition*/
+#define QD_PHY_FE_LINE_LOOPBACK_REG    0x1c
+#define QD_PHY_GE_LINE_LOOPBACK_REG    0x15
 
 /* Bit definition for DEVICE Interrupt */
 #define QD_DEV_INT_WATCHDOG            0x8000
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiPrototype.h b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiPrototype.h
index b84d7f4..4935bcf 100644
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiPrototype.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiPrototype.h
@@ -1838,6 +1838,109 @@ GT_STATUS gprtSetPortLoopback
     IN GT_BOOL         enable
 );
 
+/*******************************************************************************
+* gprtGetPortLoopback
+*
+* DESCRIPTION:
+* Get Internal Port Loopback state.
+* For 10/100 Fast Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled, this routine disables Auto-Negotiation and
+*   forces speed to be 10Mbps.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   Disabling Loopback simply clears bit 14 of control register(0.14). Therefore,
+*   it is recommended to call gprtSetPortAutoMode for PHY configuration after
+*   Loopback test.
+* For 10/100/1000 Gigagbit Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled and Link is active, the current speed is used.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   All other cases, default MAC Interface speed is used. Please refer to the data
+*   sheet for the information of the default MAC Interface speed.
+*
+*
+* INPUTS:
+*       port - The logical port number, unless SERDES device is accessed
+*              The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       enable - If GT_TRUE,  loopback mode is enabled
+*       If GT_FALSE,  loopback mode is disabled
+*
+* RETURNS:
+*       GT_OK - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       data sheet register 0.14 - Loop_back
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortLoopback
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    OUT GT_BOOL  *enable
+);
+
+/*******************************************************************************
+* gprtSetPortLineLoopback
+*
+* DESCRIPTION:
+*        Enable/Disable Port Line Loopback.
+*
+* INPUTS:
+*        port   - The logical port number, unless SERDES device is accessed
+*                 The physical address, if SERDES device is accessed
+*        enable - If GT_TRUE, enable loopback mode
+*                 If GT_FALSE, disable loopback mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        data sheet register FE:28.4, GE:21_2.14  - Loop_back
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortLineLoopback
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   enable
+);
+
+/*******************************************************************************
+* gprtGetPortLineLoopback
+*
+* DESCRIPTION:
+*       Get Port Line Loopback status.
+*
+*
+* INPUTS:
+*       port - The logical port number, unless SERDES device is accessed
+*              The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       enable - If GT_TRUE, enable loopback mode
+*                If GT_FALSE, disable loopback mode* enable - If GT_TRUE, enable loopback mode
+*                If GT_FALSE, disable loopback mode
+*
+* RETURNS:
+*      GT_OK - on success
+*      GT_FAIL - on error
+*
+* COMMENTS:
+*      data sheet register FE:28.4, GE:21_2.14  - Loop_back
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortLineLoopback
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    OUT GT_BOOL  *enable
+)
+;
 
 /*******************************************************************************
 * gprtSetPortSpeed
@@ -1910,6 +2013,36 @@ GT_STATUS gprtPortAutoNegEnable
     IN GT_BOOL         state
 );
 
+/*******************************************************************************
+* gprtGetPortAutoNegState
+*
+* DESCRIPTION:
+*         Read the auto negotiation state of specific logical port.
+*         This routine simply reads Auto Negotiation bit (bit 12) of Control
+*         Register.
+*
+* INPUTS:
+*         port    - The logical port number, unless SERDES device is accessed
+*                   The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*         state   - GT_TRUE for enable Auto-Negotiation,
+*                   GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK   - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*         data sheet register 0.12 - Auto-Negotiation Enable
+*         data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*******************************************************************************/
+GT_STATUS gprtGetPortAutoNegState
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+);
 
 /*******************************************************************************
 * gprtPortPowerDown
@@ -1943,6 +2076,34 @@ GT_STATUS gprtPortPowerDown
     IN GT_BOOL        state
 );
 
+/*******************************************************************************
+* gprtGetPortPowerDown
+*
+* DESCRIPTION:
+*         Read Port state (power down/normal operation) on specific logical port.
+*
+* INPUTS:
+*         port    - The logical port number, unless SERDES device is accessed
+*                   The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*         state   - GT_TRUE: power down
+*                   GT_FALSE: normal operation
+*
+* RETURNS:
+*         GT_OK   - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*         data sheet register 0.11 - Power Down
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortPowerDown
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+);
 
 /*******************************************************************************
 * gprtPortRestartAutoNeg
@@ -2049,6 +2210,50 @@ GT_STATUS gprtSetPortAutoMode
 );
 
 /*******************************************************************************
+* gprtGetPortAutoMode
+*
+* DESCRIPTION:
+*        This routine get Auto Mode of specific port.
+*        Supported mode is as follows:
+*        - Auto for both speed and duplex.
+*        - Auto for speed only and Full duplex.
+*        - Auto for speed only and Half duplex.
+*        - Auto for duplex only and speed 1000Mbps.
+*        - Auto for duplex only and speed 100Mbps.
+*        - Auto for duplex only and speed 10Mbps.
+*        - Speed 1000Mbps and Full duplex.
+*        - Speed 1000Mbps and Half duplex.
+*        - Speed 100Mbps and Full duplex.
+*        - Speed 100Mbps and Half duplex.
+*        - Speed 10Mbps and Full duplex.
+*        - Speed 10Mbps and Half duplex.
+*
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                  The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*        mode -    Auto Mode to be written
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - on device without copper
+*
+* COMMENTS:
+*         data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+*         data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+*         data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*******************************************************************************/
+GT_STATUS gprtGetPortAutoMode
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    OUT GT_PHY_AUTO_MODE *mode
+);
+
+/*******************************************************************************
 * gprtSetPause
 *
 * DESCRIPTION:
@@ -2081,6 +2286,38 @@ GT_STATUS gprtSetPause
 );
 
 /*******************************************************************************
+* gprtGetPause
+*
+* DESCRIPTION:
+*       This routine will get the pause bit in Autonegotiation Advertisement
+*       Register.
+*
+* INPUTS:
+*        port -  The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*
+*
+* OUTPUTS:
+*        state - GT_PHY_PAUSE_MODE enum value.
+*                GT_PHY_NO_PAUSE         - disable pause
+*                GT_PHY_PAUSE            - support pause
+*                GT_PHY_ASYMMETRIC_PAUSE - support asymmetric pause
+*                GT_PHY_BOTH_PAUSE       - support both pause and asymmetric pause
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+*       data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+GT_STATUS gprtGetPause
+(
+    IN GT_QD_DEV           *dev,
+    IN GT_LPORT            port,
+    OUT  GT_PHY_PAUSE_MODE *state
+);
+
+/*******************************************************************************
 * gprtSetDTEDetect
 *
 * DESCRIPTION:
@@ -9400,7 +9637,59 @@ GT_STATUS gsysGetRsvd2Cpu
     IN  GT_QD_DEV    *dev,
     OUT GT_BOOL      *en
 );
-
+/*******************************************************************************
+* gsysSetLearn2All
+*
+* DESCRIPTION:
+*	enable the Learn to All devices in a Switch, this must be enabled for
+*	hardware learn limiting is enabled on any port on any device
+*
+* INPUTS:
+*        en - GT_TRUE if Learn2All is set. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetLearn2All
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+/*******************************************************************************
+* gsysGetLearn2All
+*
+* DESCRIPTION:
+*	returns the state of Learn to All devices in a Switch flag
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Learn2All is set. GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetLearn2All
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL       *en
+);
 /*******************************************************************************
 * gsysSetMGMTPri
 *
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/makedefs b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/makedefs
index 0da52e5..0bedc22 100644
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/makedefs
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/makedefs
@@ -7,7 +7,7 @@ DSDT_OBJS = ./gtDrvConfig.o ./gtDrvEvents.o ./gtHwCntl.o             \
         gtPCSCtrl.o gtPhyCtrl.o gtPhyInt.o gtPortCtrl.o gtPortPav.o    \
         gtPortRateCtrl.o gtPortRmon.o gtPortStat.o gtPortStatus.o    \
         gtQosMap.o gtSysConfig.o gtSysCtrl.o gtSysStatus.o gtUtils.o \
-        gtVct.o gtVersion.o gtPIRL.o gtPIRL2.o        \
+        gtVct.o gtVersion.o gtPIRL.o gtPIRL2.o gtWeight.o       \
             gtCCPVT.o gtPolicy.o \
             gtPriTable.o gtWeight.o gtPTP.o gtPortLed.o gtMisc.o \
             gtTCAM.o \
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl.c
index 9b0507d..9ce3efd 100644
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl.c
@@ -98,7 +98,72 @@ GT_STATUS feSetAutoMode
 }
 
 /*
- * This routine set Auto-Negotiation Ad Register for Copper
+ * This routine get Auto-Negotiation Ad Register for Fast Ethernet Phy
+*/
+static
+GT_STATUS feGetAutoMode
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U8            hwPort,
+    IN  GT_PHY_INFO      *phyInfo,
+    OUT GT_PHY_AUTO_MODE *mode
+)
+{
+    GT_U16  u16Data;
+
+    GT_UNUSED_PARAM(phyInfo);
+
+    DBG_INFO(("feGetAutoMode Called.\n"));
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+           return GT_FAIL;
+    }
+
+    /* Pick out all auto mode related bits. */
+    u16Data &= QD_PHY_MODE_AUTO_AUTO;
+
+    switch(u16Data)
+    {
+        case QD_PHY_MODE_10_HALF:
+                *mode = SPEED_10_DUPLEX_HALF;
+                break;
+        case QD_PHY_MODE_10_FULL:
+                *mode = SPEED_10_DUPLEX_FULL;
+                break;
+        case QD_PHY_MODE_100_HALF:
+                *mode = SPEED_100_DUPLEX_HALF;
+                break;
+        case QD_PHY_MODE_100_FULL:
+                *mode = SPEED_100_DUPLEX_FULL;
+                break;
+        case QD_PHY_MODE_AUTO_HALF:
+                *mode = SPEED_AUTO_DUPLEX_HALF;
+                break;
+        case QD_PHY_MODE_AUTO_FULL:
+                *mode = SPEED_AUTO_DUPLEX_FULL;
+                break;
+        case QD_PHY_MODE_10_AUTO:
+                *mode = SPEED_10_DUPLEX_AUTO;
+                break;
+        case QD_PHY_MODE_100_AUTO:
+                *mode = SPEED_100_DUPLEX_AUTO;
+                break;
+        case QD_PHY_MODE_AUTO_AUTO:
+                *mode = SPEED_AUTO_DUPLEX_AUTO;
+                break;
+        default:
+                DBG_INFO(("Unknown Auto Mode (%d)\n", u16Data));
+                *mode = SPEED_AUTO_DUPLEX_AUTO;
+                break;
+    }
+
+    return GT_OK;
+}
+
+/*
+ * This routine set Auto-Negotiation Advertisement Register for Copper
 */
 static
 GT_STATUS gigCopperSetAutoMode
@@ -193,6 +258,90 @@ GT_STATUS gigCopperSetAutoMode
 }
 
 /*
+ * This routine get Auto-Negotiation Ad Register for Copper
+*/
+static
+GT_STATUS gigCopperGetAutoMode
+(
+    IN GT_QD_DEV        *dev,
+    IN GT_U8            hwPort,
+    IN GT_PHY_INFO      *phyInfo,
+    IN GT_PHY_AUTO_MODE *mode
+)
+{
+    GT_U16 u16Data, u16Data1;
+    GT_U32 u32Data;
+
+    DBG_INFO(("gigCopperGetAutoMode Called.\n"));
+
+    if(hwReadPagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_AD_REG,phyInfo->anyPage,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+           return GT_FAIL;
+    }
+
+    /* Pick out all auto mode related bits. */
+    u16Data &= QD_PHY_MODE_AUTO_AUTO;
+
+    if(hwReadPagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_1000AD_REG,phyInfo->anyPage,&u16Data1) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+           return GT_FAIL;
+    }
+
+    /* Pick out all auto mode related bits. */
+    u16Data1 &= (QD_GIGPHY_1000T_FULL|QD_GIGPHY_1000T_HALF);
+
+    u32Data  = (u16Data&0xffff)|((u16Data1&0xffff)<<16);
+
+    switch(u32Data)
+    {
+        case QD_PHY_MODE_10_HALF:
+                *mode = SPEED_10_DUPLEX_HALF;
+                break;
+        case QD_PHY_MODE_10_FULL:
+                *mode = SPEED_10_DUPLEX_FULL;
+                break;
+        case QD_PHY_MODE_100_HALF:
+                *mode = SPEED_100_DUPLEX_HALF;
+                break;
+        case QD_PHY_MODE_100_FULL:
+                *mode = SPEED_100_DUPLEX_FULL;
+                break;
+        case (QD_GIGPHY_1000T_HALF<<16):
+                *mode = SPEED_1000_DUPLEX_HALF;
+                break;
+        case (QD_GIGPHY_1000T_FULL<<16):
+                *mode = SPEED_1000_DUPLEX_FULL;
+                break;
+        case QD_PHY_MODE_AUTO_HALF|(QD_GIGPHY_1000T_HALF<<16):
+                *mode = SPEED_AUTO_DUPLEX_HALF;
+                break;
+        case QD_PHY_MODE_AUTO_FULL|(QD_GIGPHY_1000T_FULL<<16):
+                *mode = SPEED_AUTO_DUPLEX_FULL;
+                break;
+        case QD_PHY_MODE_10_AUTO:
+                *mode = SPEED_10_DUPLEX_AUTO;
+                break;
+        case QD_PHY_MODE_100_AUTO:
+                *mode = SPEED_100_DUPLEX_AUTO;
+                break;
+        case ((QD_GIGPHY_1000T_FULL|QD_GIGPHY_1000T_HALF)<<16):
+                *mode = SPEED_1000_DUPLEX_AUTO;
+                break;
+        case QD_PHY_MODE_AUTO_AUTO|((QD_GIGPHY_1000T_FULL|QD_GIGPHY_1000T_HALF)<<16):
+                *mode = SPEED_AUTO_DUPLEX_AUTO;
+                break;
+        default:
+                *mode = SPEED_AUTO_DUPLEX_AUTO;
+                DBG_INFO(("Unknown Auto Mode (%08x)\n", u32Data));
+                break;
+    }
+
+    return GT_OK;
+}
+
+/*
  * This routine set Auto-Negotiation Ad Register for Fiber
 */
 static
@@ -326,6 +475,57 @@ GT_STATUS phySetAutoMode
     return hwPhyReset(dev,hwPort,0xFF);
 }
 
+/*
+ * This routine gets Auto Mode
+*/
+static
+GT_STATUS phyGetAutoMode
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U8            hwPort,
+    IN  GT_PHY_INFO      *phyInfo,
+    OUT GT_PHY_AUTO_MODE *mode
+)
+{
+    GT_STATUS    status;
+    GT_BOOL      autoOn;
+    GT_U16       pageReg;
+
+    DBG_INFO(("phyGetAutoMode Called.\n"));
+
+    if (!(phyInfo->flag & GT_PHY_GIGABIT))
+    {
+        if((status=feGetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
+        {
+               return status;
+        }
+        return status;
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo->pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        return GT_FAIL;
+    }
+
+    if(phyInfo->flag & GT_PHY_COPPER)
+    {
+        if((status=gigCopperGetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
+        {
+               return status;
+        }
+    }
+    else if(phyInfo->flag & GT_PHY_FIBER)
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo->pageType,autoOn,pageReg) != GT_OK)
+    {
+        return GT_FAIL;
+    }
+
+    return status;
+}
 
 /*******************************************************************************
 * gprtPhyReset
@@ -460,7 +660,283 @@ GT_STATUS gprtSetPortLoopback
         return gprtSetPortLoopback_mad(dev, port, enable);
 #endif
 
-    DBG_INFO(("gprtSetPortLoopback Called.\n"));
+    DBG_INFO(("gprtSetPortLoopback Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* is this Fast Ethernet Phy? */
+    if (!(phyInfo.flag & GT_PHY_GIGABIT))
+    {
+        if(enable)
+        {
+            if(u16Data & QD_PHY_AUTONEGO)
+            {
+                /* disable Auto-Neg and force speed to be 10Mbps */
+                u16Data = u16Data & QD_PHY_DUPLEX;
+
+                if((retVal=hwPhyReset(dev,hwPort,u16Data)) != GT_OK)
+                {
+                    DBG_INFO(("Softreset failed.\n"));
+                    gtSemGive(dev,dev->phyRegsSem);
+                    return retVal;
+                }
+            }
+        }
+    }
+
+    BOOL_2_BIT(enable,u16Data);
+
+    /* Write to Phy Control Register.  */
+    retVal = hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,14,1,u16Data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPortLoopback
+*
+* DESCRIPTION:
+* Get Internal Port Loopback state.
+* For 10/100 Fast Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled, this routine disables Auto-Negotiation and
+*   forces speed to be 10Mbps.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   Disabling Loopback simply clears bit 14 of control register(0.14). Therefore,
+*   it is recommended to call gprtSetPortAutoMode for PHY configuration after
+*   Loopback test.
+* For 10/100/1000 Gigagbit Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled and Link is active, the current speed is used.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   All other cases, default MAC Interface speed is used. Please refer to the data
+*   sheet for the information of the default MAC Interface speed.
+*
+*
+* INPUTS:
+*       port - The logical port number, unless SERDES device is accessed
+*              The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       enable - If GT_TRUE,  loopback mode is enabled
+*       If GT_FALSE,  loopback mode is disabled
+*
+* RETURNS:
+*       GT_OK - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       data sheet register 0.14 - Loop_back
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortLoopback
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    OUT GT_BOOL  *enable
+)
+{
+    GT_STATUS      retVal;         /* Functions return value.      */
+    GT_U8          hwPort;         /* the physical port number     */
+    GT_U16         u16Data;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gprtGetPortLoopback Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /*get loopback state*/
+    retVal = hwGetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,14,1,&u16Data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+        BIT_2_BOOL(u16Data, *enable);
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetPortLineLoopback
+*
+* DESCRIPTION:
+*        Enable/Disable Port Line Loopback.
+*
+* INPUTS:
+*        port   - The logical port number, unless SERDES device is accessed
+*                 The physical address, if SERDES device is accessed
+*        enable - If GT_TRUE, enable loopback mode
+*                 If GT_FALSE, disable loopback mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        data sheet register FE:28.4, GE:21_2.14  - Loop_back
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortLineLoopback
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   enable
+)
+{
+    GT_STATUS      retVal;         /* Functions return value.      */
+    GT_U8          hwPort;         /* the physical port number     */
+    GT_U16         u16Data;
+    GT_PHY_INFO    phyInfo;
+    GT_U16         pageReg;
+
+    DBG_INFO(("gprtSetPortLineLoopback Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    BOOL_2_BIT(enable,u16Data);
+
+    /* GE Phy */
+    if ((phyInfo.flag & GT_PHY_GIGABIT))
+    {
+        if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,0,&pageReg) != GT_OK)
+        {
+            return GT_FAIL;
+        }
+        /* Write to GE PHY MAC specific control register.  */
+        retVal = hwSetPagedPhyRegField(dev,hwPort, 2, QD_PHY_GE_LINE_LOOPBACK_REG,14,1,phyInfo.anyPage, u16Data);
+
+        if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,0,pageReg) != GT_OK)
+        {
+            return GT_FAIL;
+        }
+    }
+    else /* FE Phy */
+    {
+        /* Write to FE PHY specific control register.  */
+        retVal = hwSetPhyRegField(dev,hwPort,QD_PHY_FE_LINE_LOOPBACK_REG,4,1,u16Data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPortLineLoopback
+*
+* DESCRIPTION:
+*       Get Port Line Loopback status.
+*
+*
+* INPUTS:
+*       port - The logical port number, unless SERDES device is accessed
+*              The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       enable - If GT_TRUE, enable loopback mode
+*                If GT_FALSE, disable loopback mode* enable - If GT_TRUE, enable loopback mode
+*                If GT_FALSE, disable loopback mode
+*
+* RETURNS:
+*      GT_OK - on success
+*      GT_FAIL - on error
+*
+* COMMENTS:
+*      data sheet register FE:28.4, GE:21_2.14  - Loop_back
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortLineLoopback
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    OUT GT_BOOL  *enable
+)
+{
+    GT_STATUS      retVal;         /* Functions return value.      */
+    GT_U8          hwPort;         /* the physical port number     */
+    GT_U16         u16Data;
+    GT_PHY_INFO    phyInfo;
+    GT_U16         pageReg;
+
+    DBG_INFO(("gprtGetPortLineLoopback Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
@@ -481,37 +957,27 @@ GT_STATUS gprtSetPortLoopback
         return GT_FAIL;
     }
 
-    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
-    {
-        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
-        gtSemGive(dev,dev->phyRegsSem);
-        return GT_FAIL;
-    }
-
-    /* is this Fast Ethernet Phy? */
-    if (!(phyInfo.flag & GT_PHY_GIGABIT))
+     /* GE Phy */
+    if ((phyInfo.flag & GT_PHY_GIGABIT))
     {
-        if(enable)
+        if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,0,&pageReg) != GT_OK)
         {
-            if(u16Data & QD_PHY_AUTONEGO)
-            {
-                /* disable Auto-Neg and force speed to be 10Mbps */
-                u16Data = u16Data & QD_PHY_DUPLEX;
+            return GT_FAIL;
+        }
+        /* Read to GE PHY MAC specific control register.  */
+        retVal = hwGetPagedPhyRegField(dev,hwPort, 2, QD_PHY_GE_LINE_LOOPBACK_REG,14,1,phyInfo.anyPage,&u16Data);
 
-                if((retVal=hwPhyReset(dev,hwPort,u16Data)) != GT_OK)
-                {
-                    DBG_INFO(("Softreset failed.\n"));
-                    gtSemGive(dev,dev->phyRegsSem);
-                    return retVal;
-                }
-            }
+        if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,0,pageReg) != GT_OK)
+        {
+            return GT_FAIL;
         }
     }
+    else /* FE Phy */
+    {
+        /* Read to FE PHY specific control register.  */
+        retVal = hwGetPhyRegField(dev,hwPort,QD_PHY_FE_LINE_LOOPBACK_REG,4,1,&u16Data);
+    }
 
-    BOOL_2_BIT(enable,u16Data);
-
-    /* Write to Phy Control Register.  */
-    retVal = hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,14,1,u16Data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -520,11 +986,13 @@ GT_STATUS gprtSetPortLoopback
     {
         DBG_INFO(("OK.\n"));
     }
+
+    BIT_2_BOOL(u16Data, *enable);
+
     gtSemGive(dev,dev->phyRegsSem);
     return retVal;
 }
 
-
 /*******************************************************************************
 * gprtSetPortSpeed
 *
@@ -717,6 +1185,69 @@ GT_STATUS gprtPortAutoNegEnable
 }
 
 /*******************************************************************************
+* gprtGetPortAutoNegState
+*
+* DESCRIPTION:
+*         Read the auto negotiation state of specific logical port.
+*         This routine simply reads Auto Negotiation bit (bit 12) of Control
+*         Register.
+*
+* INPUTS:
+*         port    - The logical port number, unless SERDES device is accessed
+*                   The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*         state   - GT_TRUE for enable Auto-Negotiation,
+*                   GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK   - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*         data sheet register 0.12 - Auto-Negotiation Enable
+*         data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*******************************************************************************/
+GT_STATUS gprtGetPortAutoNegState
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U8        hwPort;  /* the physical port number     */
+    GT_U16       u16Data;
+    GT_STATUS    retVal;
+
+    DBG_INFO(("gprtGetPortAutoNegState Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* read the auto negotiation state from bit 12 of PHY control register */
+    if((retVal=hwGetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,12,1,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
+
+    BIT_2_BOOL(u16Data, *state);
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+/*******************************************************************************
 * gprtPortPowerDown
 *
 * DESCRIPTION:
@@ -785,6 +1316,75 @@ IN GT_BOOL   state
 }
 
 /*******************************************************************************
+* gprtGetPortPowerDown
+*
+* DESCRIPTION:
+*         Read Port state (power down/normal operation) on specific logical port.
+*
+* INPUTS:
+*         port    - The logical port number, unless SERDES device is accessed
+*                   The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*         state   - GT_TRUE: power down
+*                   GT_FALSE: normal operation
+*
+* RETURNS:
+*         GT_OK   - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*         data sheet register 0.11 - Power Down
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortPowerDown
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        hwPort;         /* the physical port number     */
+    GT_U16       u16Data;
+
+#ifdef GT_USE_MAD
+
+#endif
+
+    DBG_INFO(("gprtGetPortPowerDown Called.\n"));
+
+    if(state == NULL)
+    {
+        DBG_INFO(("input pointer is NULL, return\n"));
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal=hwGetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,11,1,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
+
+    BIT_2_BOOL(u16Data, *state);
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
 * gprtPortRestartAutoNeg
 *
 * DESCRIPTION:
@@ -1031,6 +1631,85 @@ GT_STATUS gprtSetPortAutoMode
 
 }
 
+/*******************************************************************************
+* gprtGetPortAutoMode
+*
+* DESCRIPTION:
+*        This routine get Auto Mode of specific port.
+*        Supported mode is as follows:
+*        - Auto for both speed and duplex.
+*        - Auto for speed only and Full duplex.
+*        - Auto for speed only and Half duplex.
+*        - Auto for duplex only and speed 1000Mbps.
+*        - Auto for duplex only and speed 100Mbps.
+*        - Auto for duplex only and speed 10Mbps.
+*        - Speed 1000Mbps and Full duplex.
+*        - Speed 1000Mbps and Half duplex.
+*        - Speed 100Mbps and Full duplex.
+*        - Speed 100Mbps and Half duplex.
+*        - Speed 10Mbps and Full duplex.
+*        - Speed 10Mbps and Half duplex.
+*
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                  The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*        mode -    Auto Mode to be written
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - on device without copper
+*
+* COMMENTS:
+*         data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+*         data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+*         data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*******************************************************************************/
+
+GT_STATUS gprtGetPortAutoMode
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    OUT GT_PHY_AUTO_MODE *mode
+)
+{
+    GT_STATUS       retVal; /* Functions return value.  */
+    GT_U8           hwPort; /* the physical port number */
+    GT_PHY_INFO     phyInfo;
+
+    DBG_INFO(("gprtGetPortAutoMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    retVal = GT_NOT_SUPPORTED;
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        DBG_INFO(("PHY device is not configurable.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    retVal = phyGetAutoMode(dev,hwPort,&phyInfo,mode);
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+
+}
 
 /*******************************************************************************
 * gprtSetPause
@@ -1136,6 +1815,74 @@ IN GT_PHY_PAUSE_MODE state
     return retVal;
 }
 
+/*******************************************************************************
+* gprtGetPause
+*
+* DESCRIPTION:
+*       This routine will get the pause bit in Autonegotiation Advertisement
+*       Register.
+*
+* INPUTS:
+*        port -  The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*
+*
+* OUTPUTS:
+*        state - GT_PHY_PAUSE_MODE enum value.
+*                GT_PHY_NO_PAUSE         - disable pause
+*                GT_PHY_PAUSE            - support pause
+*                GT_PHY_ASYMMETRIC_PAUSE - support asymmetric pause
+*                GT_PHY_BOTH_PAUSE       - support both pause and asymmetric pause
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+*       data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+GT_STATUS gprtGetPause
+(
+    IN GT_QD_DEV           *dev,
+    IN GT_LPORT            port,
+    OUT  GT_PHY_PAUSE_MODE *state
+)
+{
+    GT_U8          hwPort;  /* the physical port number */
+    GT_U16         u16Data;
+    GT_U16         regStart;
+    GT_STATUS      retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gprtGetPause Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    regStart = 10;
+
+    /* Read Phy AutoNegotiation Advertisement Register.  */
+    if((retVal=hwGetPhyRegField(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,(GT_U8)regStart,2,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+
+    *state = u16Data;
+
+    return retVal;
+}
 
 static
 GT_STATUS dteWorkAround_Phy100M
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortCtrl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortCtrl.c
index 664364d..2fd2cf0 100644
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortCtrl.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortCtrl.c
@@ -4746,6 +4746,101 @@ GT_STATUS gprtGetARPtoCPU
 
 
 /*******************************************************************************
+* gsysSetLearn2All
+*
+* DESCRIPTION:
+*       enable the Learn to All devices in a Switch, this must be enabled for
+*       hardware learn limiting is enabled on any port on any device
+*
+* INPUTS:
+*        en - GT_TRUE if Learn2All is set. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetLearn2All
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetLearn2All Called.\n"));
+
+    BOOL_2_BIT(en, data);
+
+    /* Set related bit */
+    retVal = hwSetGlobalRegField(dev,QD_REG_AGETIME_LA_CONTROL,3,1, data);
+
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetLearn2All
+*
+* DESCRIPTION:
+*       returns the state of Learn to All devices in a Switch flag
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Learn2All is set. GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetLearn2All
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL       *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetLearn2All Called.\n"));
+
+    /* Set related bit */
+    retVal = hwGetGlobalRegField(dev, QD_REG_AGETIME_LA_CONTROL, 3, 1, &data);
+
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
 * gprtSetEgressFlood
 *
 * DESCRIPTION:
-- 
1.7.5.4

