From 6614e25f0eaf3dc08079e88718ff4d89c02723d9 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Mon, 10 Jun 2013 10:41:05 +0300
Subject: [PATCH 0721/1825] PPv2: GW driver promiscus mode support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit f3e50a59b47b262e1cdf4dcbbf531287232ccabb

Change-Id: Ifd9afd5ea40f998f03955b59aaae5ee390dd9dba
Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2209
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c      |    3 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c  |   48 +++++++++++------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h  |    1 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c   |    6 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |    3 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |    2 +
 .../mv_drivers_lsp/mv_switch/mv_switch.c           |   53 ++++++++------------
 .../mv_drivers_lsp/mv_switch/mv_switch.h           |    2 +-
 8 files changed, 63 insertions(+), 55 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
index cad0289..78a6a75 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
@@ -102,12 +102,15 @@ static int __init mv_gw_mgr_init(void)
 	/* update netdev port with tag type */
 	pp = mv_eth_port_by_id(gbe_port);
 	mv_mux_tag_type_set(pp, tag_mode);
+	if (tag_mode != MV_TAG_TYPE_NONE)
+		mv_eth_port_promisc_set(gbe_port);
 
 	/* set switch ops to be used by mux driver */
 	switch_ops.group_enable = mv_switch_group_enable;
 	switch_ops.group_disable = mv_switch_group_disable;
 	switch_ops.link_status = mv_switch_link_status_get;
 	switch_ops.mac_update = mv_switch_mac_update;
+	switch_ops.promisc_set = mv_switch_promisc_set;
 	mv_mux_switch_ops_set(&switch_ops);
 
 	/* set mux ops to be used by switch driver */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
index ce5f0360..3529182 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
@@ -181,6 +181,17 @@ static void mv_mux_set_rx_mode(struct net_device *dev)
 }
 
 /*-----------------------------------------------------------------------------------------*/
+
+void mv_mux_change_rx_flags(struct net_device *dev, int flags)
+{
+	if (switch_ops && switch_ops->promisc_set) {
+		struct eth_netdev *pmux_priv = MV_DEV_PRIV(dev);
+
+		switch_ops->promisc_set(pmux_priv->idx, (dev->flags & IFF_PROMISC) ? 1 : 0);
+	}
+}
+
+/*-----------------------------------------------------------------------------------------*/
 static int mv_mux_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 	/*TODO compleate implementation*/
@@ -303,7 +314,8 @@ struct net_device *mv_mux_netdev_alloc(char* name, int idx, MV_MUX_TAG *tag_cfg)
 			return NULL;
 		}
 
-	}
+	} else
+		dev_put(mux_dev);
 
 	pmux_priv = MV_DEV_PRIV(mux_dev);
 
@@ -327,31 +339,32 @@ static inline void mv_mux_init_features(struct net_device *mux_dev)
 	struct eth_port *pp = MV_ETH_PRIV(mux_dev);
 
 	mux_dev->features = pp->dev->features;
-/*
+
 	mux_dev->hw_features = pp->dev->hw_features;
 	mux_dev->wanted_features = pp->dev->wanted_features;
-*/
+
 	mux_dev->vlan_features = pp->dev->vlan_features;
 
 }
 
 /*-----------------------------------------------------------------------------------------*/
-static int mv_mux_set_features(struct net_device *mux_dev, u32 features)
+static int mv_mux_set_features(struct net_device *mux_dev, netdev_features_t features)
 {
-	u32 changed = mux_dev->features ^ features;
-	u32 old = mux_dev->features;
+	struct eth_port *pp = MV_ETH_PRIV(mux_dev);
+	netdev_features_t changed = mux_dev->features ^ features;
+	netdev_features_t old = mux_dev->features;
 
-	if (changed & NETIF_F_SG)
+	if (changed & NETIF_F_TSO)
 		if (!(old & NETIF_F_TSO))
 			/* mux interface want to set tso */
-			/*if (!pp->dev->ethtool_ops->get_sg(pp->dev))*/
+			if (!(pp->dev->features & NETIF_F_TSO))
 				/* master tso is down */
 				return -EOPNOTSUPP;
 
 	if (changed & NETIF_F_IP_CSUM)
 		if (!(old & NETIF_F_IP_CSUM))
 			/* mux interface want to set tx csum */
-			/*if (!pp->dev->ethtool_ops->get_tx_csum(pp->dev))*/
+			if (!(pp->dev->features & NETIF_F_IP_CSUM))
 				/* master tx csum is down */
 				return -EOPNOTSUPP;
 	return MV_OK;
@@ -395,7 +408,7 @@ static struct net_device *mv_mux_netdev_init(struct net_device *root_dev, struct
 	/* TODO: handle features */
 	mv_mux_init_features(mux_dev);
 
-/*	SET_ETHTOOL_OPS(mux_dev, &mv_mux_tool_ops);*/
+	/*SET_ETHTOOL_OPS(mux_dev, &mv_mux_tool_ops);*/
 
 	return mux_dev;
 }
@@ -1089,13 +1102,14 @@ void mv_mux_netdev_print(struct net_device *mux_dev)
 /*-----------------------------------------------------------------------------------------*/
 
 static const struct net_device_ops mv_mux_netdev_ops = {
-	.ndo_open               = mv_mux_open,
-	.ndo_stop               = mv_mux_close,
-	.ndo_start_xmit         = mv_mux_xmit,
-	.ndo_set_mac_address    = mv_mux_set_mac,
-	.ndo_do_ioctl           = mv_mux_ioctl,
-	.ndo_set_rx_mode        = mv_mux_set_rx_mode,
-/*	.ndo_set_features 	= mv_mux_set_features,*/
+	.ndo_open		= mv_mux_open,
+	.ndo_stop		= mv_mux_close,
+	.ndo_start_xmit		= mv_mux_xmit,
+	.ndo_set_mac_address	= mv_mux_set_mac,
+	.ndo_do_ioctl		= mv_mux_ioctl,
+	.ndo_set_rx_mode	= mv_mux_set_rx_mode,
+	.ndo_change_rx_flags	= mv_mux_change_rx_flags,
+	.ndo_set_features	= mv_mux_set_features,
 };
 
 module_init(mux_proto_init);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h
index 6ede2bf..3656ed4 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h
@@ -45,6 +45,7 @@ struct switch_device_ops {
 	int	(*group_disable)(int group_id);
 	int	(*link_status)(int group_id);
 	int	(*mac_update)(int group_id, unsigned char *old_mac, unsigned char *new_mac);
+	int	(*promisc_set)(int group_id, u8 promisc_on);
 };
 
 int mv_mux_switch_ops_set(struct switch_device_ops *switch_ops_ptr);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c
index 048be06..eabefd4 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c
@@ -83,6 +83,8 @@ static ssize_t mv_mux_netdev_store(struct device *dev,
 	sscanf(buf, "%s %x %x", dev_name, &a, &b);
 	mux_dev = dev_get_by_name(&init_net, dev_name);
 
+	dev_put(mux_dev);
+
 	if (!strcmp(name, "dump")) {
 		mv_mux_netdev_print(mux_dev);
 
@@ -134,10 +136,8 @@ static ssize_t mv_mux_netdev_store(struct device *dev,
 		struct eth_port *pp = mv_eth_port_by_id(a);
 		err =  mv_mux_netdev_add(pp, mux_dev) ? 0 : 1;
 
-	} else if (!strcmp(name, "del")) {
-		mux_dev = dev_get_by_name(&init_net, dev_name);
+	} else if (!strcmp(name, "del"))
 		err = mv_mux_netdev_delete(mux_dev);
-	}
 
 	if (err)
 		printk(KERN_ERR "%s: error %d\n", __func__, err);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index d3dd028..1453cf4 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -1510,7 +1510,6 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 
 
 		if (rx_status & PP2_RX_ES_MASK) {
-
 			mv_eth_rx_error(pp, rx_desc);
 
 			mv_eth_rxq_refill(pp, rxq, pkt, pool, rx_desc);
@@ -2702,7 +2701,7 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 	return rx_done;
 }
 
-void mv_eth_port_promisc_set(int port, int queue)
+void mv_eth_port_promisc_set(int port)
 {
 	if (mv_eth_pnc_ctrl_en)
 		mvPrsMacPromiscousSet(port, 1);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 3c7b5dc..5b07ecd 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -726,6 +726,8 @@ int         mv_eth_suspend_internals(struct eth_port *pp);
 int         mv_eth_resume_internals(struct eth_port *pp, int mtu);
 int         mv_eth_restore_registers(struct eth_port *pp, int mtu);
 
+void	    mv_eth_port_promisc_set(int port);
+
 void        mv_eth_win_init(void);
 int         mv_eth_resume_network_interfaces(struct eth_port *pp);
 int         mv_eth_pm_mode_set(int port, int mode);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
index 50be7aa..0d88725 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
@@ -378,41 +378,30 @@ int mv_switch_atu_db_flush(int db_num)
 	return 0;
 }
 
-int mv_switch_promisc_set(u16 vlan_grp_id, u16 port_map, u16 cpu_port, u8 promisc_on)
+int mv_switch_promisc_set(int db, u8 promisc_on)
 {
 	int i;
+	unsigned int ports_mask = db_port_mask[db];
+	int vlan_grp_id = MV_SWITCH_GROUP_VLAN_ID(db);
 
-	if (promisc_on) {
-
-		mv_switch_port_based_vlan_set((port_map | (1 << cpu_port)), 0);
-
-		for (i = 0; i < qd_dev->numOfPorts; i++) {
-			if (MV_BIT_CHECK(port_map, i) && (i != cpu_port)) {
-				if (mv_switch_vlan_in_vtu_set(MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, i),
-							      MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id),
-							      (port_map | (1 << cpu_port))) != 0) {
-					printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
-					return -1;
-				}
-			}
-		}
-
-	} else {
+	if (promisc_on)
+		ports_mask |= (1 << qd_cpu_port);
+	else
+		ports_mask &= ~(1 << qd_cpu_port);
 
-		mv_switch_port_based_vlan_set((port_map & ~(1 << cpu_port)), 0);
+	mv_switch_port_based_vlan_set(ports_mask, 0);
 
-		for (i = 0; i < qd_dev->numOfPorts; i++) {
-			if (MV_BIT_CHECK(port_map, i) && (i != cpu_port)) {
-				if (mv_switch_vlan_in_vtu_set(MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, i),
-							      MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id),
-							      (port_map & ~(1 << cpu_port))) != 0) {
-					printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
-					return -1;
-				}
+	for (i = 0; i < qd_dev->numOfPorts; i++) {
+		if (MV_BIT_CHECK(ports_mask, i) && (i != qd_cpu_port)) {
+			if (mv_switch_vlan_in_vtu_set(MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, i),
+						      MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id),
+						      ports_mask) != 0) {
+				printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
+				return -1;
 			}
 		}
-
 	}
+	db_port_mask[db] = ports_mask;
 
 	return 0;
 }
@@ -1528,8 +1517,8 @@ int mv_switch_port_add(int switch_port, u16 grp_id)
 		return -1;
 	}
 
-	/* Add port to the VLAN (CPU port is not part of VLAN) */
-	if (mv_switch_port_based_vlan_set((port_map & ~(1 << qd_cpu_port)), 0) != 0)
+	/* Add port to the VLAN */
+	if (mv_switch_port_based_vlan_set(port_map, 0) != 0)
 		printk(KERN_ERR "mv_switch_port_based_vlan_set failed\n");
 
 	/* Add port to vtu (used in tx) */
@@ -1541,7 +1530,7 @@ int mv_switch_port_add(int switch_port, u16 grp_id)
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
 		if (MV_BIT_CHECK(port_map, p) && (p != qd_cpu_port)) {
 			if (mv_switch_vlan_in_vtu_set(MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, p),
-						      grp_id, port_map & ~(1 << qd_cpu_port)) != 0) {
+						      grp_id, port_map) != 0) {
 				printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
 			}
 		}
@@ -1599,8 +1588,8 @@ int mv_switch_port_del(int switch_port)
 	if (gstpSetPortState(qd_dev, switch_port, GT_PORT_DISABLE) != GT_OK)
 		printk(KERN_ERR "gstpSetPortState failed on port #%d\n", switch_port);
 
-	/* Remove port from the VLAN (CPU port is not part of VLAN) */
-	if (mv_switch_port_based_vlan_set((port_map & ~(1 << qd_cpu_port)), 0) != 0)
+	/* Remove port from the VLAN */
+	if (mv_switch_port_based_vlan_set(port_map, 0) != 0)
 		printk(KERN_ERR "mv_gtw_set_port_based_vlan failed\n");
 
 	/* Remove port from vtu (used in tx) */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
index 16aa76f..1f384016 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
@@ -60,7 +60,6 @@ int     mv_switch_port_based_vlan_set(unsigned int ports_mask, int set_cpu_port)
 int     mv_switch_vlan_in_vtu_set(unsigned short vlan_id, unsigned short db_num, unsigned int ports_mask);
 int     mv_switch_atu_db_flush(int db_num);
 int     mv_switch_vlan_set(u16 vlan_grp_id, u16 port_map);
-int     mv_switch_promisc_set(u16 vlan_grp_id, u16 port_map, u16 cpu_port, u8 promisc_on);
 
 int     mv_switch_reg_read(int port, int reg, int type, MV_U16 *value);
 int     mv_switch_reg_write(int port, int reg, int type, MV_U16 value);
@@ -84,4 +83,5 @@ int		mv_switch_mac_update(int db, unsigned char *old_mac, unsigned char *new_mac
 int		mv_switch_mac_addr_set(unsigned char *mac_addr, unsigned char db, unsigned char op);
 int		mv_switch_mux_ops_set(struct mux_device_ops *mux_ops_ptr);
 int		mv_switch_preset_init(MV_SWITCH_PRESET_TYPE preset, MV_TAG_TYPE tag_mode, int vid);
+int		mv_switch_promisc_set(int db, u8 promisc_on);
 #endif /* __mv_switch_h__ */
-- 
1.7.5.4

