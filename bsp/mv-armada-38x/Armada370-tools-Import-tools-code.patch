From 69701c33c2c3b8dfe4cfea2f645cfdb09fd84fa1 Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Wed, 24 Oct 2012 11:14:19 +0200
Subject: [PATCH 0298/1825] Armada370, tools: Import tools code.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 1a1abf6b3a96e11b277762a2941d00d3376d5dde

Change-Id: Icbc29ea66aa9aa0a2e3de22135708f43abafd213
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 tools/Makefile              |   79 +++
 tools/mv_cesa_tool.c        |  307 ++++++++++
 tools/mv_shell.c            |  455 +++++++++++++++
 tools/voice/Makefile        |   59 ++
 tools/voice/mv_voice_tool.c | 1337 +++++++++++++++++++++++++++++++++++++++++++
 tools/voice/mv_voice_tool.h |   84 +++
 tools/voice/profile_79238.c | 1248 ++++++++++++++++++++++++++++++++++++++++
 tools/voice/profile_79238.h |   82 +++
 tools/voice/profile_88266.c |  644 +++++++++++++++++++++
 tools/voice/profile_88266.h |   97 ++++
 tools/voice/vpapi_lib.c     |  432 ++++++++++++++
 tools/voice/vpapi_lib.h     |  102 ++++
 12 files changed, 4926 insertions(+), 0 deletions(-)
 create mode 100644 tools/Makefile
 create mode 100644 tools/mv_cesa_tool.c
 create mode 100644 tools/mv_shell.c
 create mode 100644 tools/voice/Makefile
 create mode 100644 tools/voice/mv_voice_tool.c
 create mode 100644 tools/voice/mv_voice_tool.h
 create mode 100644 tools/voice/profile_79238.c
 create mode 100644 tools/voice/profile_79238.h
 create mode 100644 tools/voice/profile_88266.c
 create mode 100644 tools/voice/profile_88266.h
 create mode 100644 tools/voice/vpapi_lib.c
 create mode 100644 tools/voice/vpapi_lib.h

diff --git a/tools/Makefile b/tools/Makefile
new file mode 100644
index 0000000..5cca5b7
--- /dev/null
+++ b/tools/Makefile
@@ -0,0 +1,79 @@
+# kernel sources
+srctree  := $(shell /bin/pwd)
+
+ifndef KSRC
+KSRC  := $(srctree)/..
+endif
+
+include $(KSRC)/.config
+
+CFLAGS  := $(EXTRA_CFLAGS)
+
+ifdef CONFIG_CPU_BIG_ENDIAN
+CFLAGS  += -DCONFIG_CPU_BIG_ENDIAN
+endif
+
+CC := $(CROSS_COMPILE)gcc
+LD := $(CROSS_COMPILE)ld
+
+SUBDIRS +=
+
+TARGETS=mv_shell
+
+ifeq ($(CONFIG_MV_ETHERNET),y)
+CFLAGS += -DCONFIG_MV_ETHERNET
+endif
+
+ifeq ($(CONFIG_MV_PON),y)
+TARGETS+=mv_omci_tool
+CFLAGS +=
+endif
+
+ifeq ($(CONFIG_MV_ETH_LEGACY),y)
+TARGETS+=mv_eth_tool
+CFLAGS += -DCONFIG_MV_ETH_LEGACY
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_drivers_lsp/mv_network/mv_ethernet/
+endif
+
+ifeq ($(CONFIG_MV_CPU_PERF_CNTRS),y)
+CFLAGS += -DCONFIG_MV_CPU_PERF_CNTRS
+endif
+
+ifeq ($(CONFIG_MV_CESA),y)
+TARGETS += mv_cesa_tool
+CFLAGS  += -I$(KSRC)/arch/arm/plat-armada/mv_drivers_lsp/mv_cesa/
+endif
+
+#ifeq ($(CONFIG_MV_INCLUDE_USB),y)
+#TARGETS += testusb
+#endif
+
+ifeq ($(CONFIG_MV_PHONE),y)
+SUBDIRS+=voice
+endif
+
+all : Makefile $(TARGETS)
+	@for subdir in $(SUBDIRS); do \
+                (cd $$subdir && $(MAKE) $@) || exit 1; \
+        done
+
+mv_shell : mv_shell.c
+	$(CC) $(CFLAGS) -static mv_shell.c -o mv_shell
+
+mv_eth_tool: mv_eth_tool.c
+	$(CC) $(CFLAGS) -static mv_eth_tool.c -o mv_eth_tool
+
+mv_set_coal : mv_set_coal.c
+	$(CC) $(CFLAGS) mv_set_coal.c -o mv_set_coal
+
+mv_cesa_tool:mv_cesa_tool.c
+	$(CC) $(CFLAGS) -static mv_cesa_tool.c -o mv_cesa_tool
+
+testusb: testusb.c
+	$(CC) $(CFLAGS) -static testusb.c -o testusb -lpthread
+
+clean:
+	rm -f $(TARGETS) *.o
+	@for subdir in $(SUBDIRS); do \
+                (cd $$subdir && $(MAKE) $@) || exit 1; \
+        done
diff --git a/tools/mv_cesa_tool.c b/tools/mv_cesa_tool.c
new file mode 100644
index 0000000..db3375a
--- /dev/null
+++ b/tools/mv_cesa_tool.c
@@ -0,0 +1,307 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/poll.h>
+
+#include "cesa_dev.h"
+
+
+
+void show_usage(int badarg)
+{
+        fprintf(stderr,
+                "Usage:                                                                                 \n"
+                " mv_cesa_tool -h                                                                       \n"
+                "   Display this help.                                                                  \n"
+                "                                                                                       \n"
+		" mv_cesa_tool -test  <test_mode> <iter> <req_size> <checkmode>				\n"
+		"	(can be used only in Test Mode)							\n"
+		"	test_mode: Multi, Size AES, DES, 3DES MD5 SHA1     				\n"
+		"	iter	 : number of iteration to run						\n"
+		"	req_size : size of the buffer to be encrypt/decrypt/HASING			\n"
+		"	checkmode: 0 - Fast verify 							\n"
+		"		   1 - Full verify						        \n"
+		"		   2 - without verify (for performence)					\n"
+		"											\n"
+		" mv_cesa_tool -test -s <iter> <req_size> <session_id> <data_id>			\n"
+		"       (can be used only in Test Mode)                                                 \n"
+		"	+++ for debug usage only +++							\n"
+		"	req_size  : size of the buffer to be encrypt/decrypt/HASING                     \n"
+		"	iter      : number of iteration to run 						\n"
+		"	session_id: which session to open out of the cesa_test session see in kernel.	\n"
+		"	data_id   : which data pattern to use out of the cesa_test session see in kernel\n"
+		"       checkmode : 0 - Fast verify                                                     \n"
+                "                   1 - Full verify                                                     \n"
+                "                   2 - without verify (for performence)                                \n"
+		"											\n"
+		" mv_cesa_tool -debug <debug_mode> [-i index] [-v] [-s size]				\n"
+		"	(Tst_req, Tst_stats and Tst_ses can be used only in Test Mode)			\n"
+		"	debug_mode: Sts       - display general status 					\n"
+		"		    Chan      - display channel index status 				\n"
+		"		    Q         - display SW Q 						\n"
+		"		    SA        - display SA index 					\n"
+		"		    SAD       - display entire SAD					\n"
+		"		    Sram - display SRAM contents					\n"
+		"		    Tst_req - display request index with buffer of size size		\n"
+		"                   Tst_stats - display test statistics                                 \n"
+		"		    Tst_ses - display session index					\n"
+		"	-i index  : index (only relevant for: Chan, SA, Tst_req and Tst_ses  \n"
+		"	-v        : verbose mode							\n"
+		"	-s size	  : buffer size (only relevant for Tst_req)				\n\n"
+	);
+
+	exit(badarg);
+}
+
+static void get_index(int argc, char **argv, CESA_DEBUG *cesa_debug)
+{
+	int j;
+	for(j = 3; j < argc; j++) {
+		if(!strcmp(argv[j], "-i")) {
+			j++;
+			break;
+		}
+	}
+	if(!(j < argc)) {
+		fprintf(stderr,"missing/ illegal index. \n");
+		exit(1);
+	}
+	cesa_debug->index = atoi(argv[j]);
+}
+
+static void parse_debug_cmdline(int argc, char **argv, CESA_DEBUG *cesa_debug)
+{
+	unsigned int i = 2,j;
+
+        cesa_debug->mode = 0;
+	for(j = i; j < argc; j++) {
+		if(!strcmp(argv[j], "-v"))
+			cesa_debug->mode++;
+	}
+
+	if(argc < 3) {
+                fprintf(stderr,"missing arguments\n");
+		exit(1);
+	}
+
+	if(!strcmp(argv[i], "Sts"))
+		cesa_debug->debug = STATUS;
+	else if(!strcmp(argv[i], "Chan")) {
+                cesa_debug->debug = CHAN;
+		get_index(argc, argv, cesa_debug);
+	}
+        else if(!strcmp(argv[i], "Q"))
+                cesa_debug->debug = QUEUE;
+        else if(!strcmp(argv[i], "SA")) {
+                cesa_debug->debug = SA;
+		get_index(argc, argv, cesa_debug);
+	}
+        else if(!strcmp(argv[i], "Cache_idx")) {
+                cesa_debug->debug = CACHE_IDX;
+		get_index(argc, argv, cesa_debug);
+	}
+        else if(!strcmp(argv[i], "Sram"))
+                cesa_debug->debug = SRAM;
+        else if(!strcmp(argv[i], "SAD"))
+                cesa_debug->debug = SAD;
+        else if(!strcmp(argv[i], "Tst_req")) {
+                cesa_debug->debug = TST_REQ;
+		for(j = i; j < argc; j++) {
+			if(!strcmp(argv[j], "-s")) {
+				j++;
+				break;
+			}
+		}
+		if(!(j < argc)) {
+			fprintf(stderr,"missing/illegal size\n");
+			exit(1);
+		}
+		cesa_debug->size = atoi(argv[j]);
+		get_index(argc, argv, cesa_debug);
+	}
+        else if(!strcmp(argv[i], "Tst_ses")) {
+                cesa_debug->debug = TST_SES;
+		get_index(argc, argv, cesa_debug);
+	}
+	else if(!strcmp(argv[i], "Tst_stats")) {
+		cesa_debug->debug = TST_STATS;
+        }
+	else{
+		fprintf(stderr,"illegal debug option\n");
+		exit(1);
+	}
+
+}
+
+static void parse_test_cmdline(int argc, char **argv, CESA_TEST *cesa_test)
+{
+        unsigned int i = 2;
+
+	if(argc < 6) {
+		fprintf(stderr,"missing arguments\n");
+		exit(1);
+	}
+
+	if(!strcmp(argv[i], "-s")) { /* single test */
+		i++;
+		if(argc != 8)
+			show_usage(1);
+		cesa_test->test = SINGLE;
+		cesa_test->iter = atoi(argv[i++]);
+		cesa_test->req_size = atoi(argv[i++]);
+		cesa_test->session_id = atoi(argv[i++]);
+		cesa_test->data_id = atoi(argv[i++]);
+                cesa_test->checkmode = atoi(argv[i++]);
+	}
+        else {
+		if(argc != 6)
+                        show_usage(1);
+		if (!strcmp(argv[i], "Multi"))
+			cesa_test->test = MULTI;
+                else if (!strcmp(argv[i], "Size"))
+                        cesa_test->test = SIZE;
+		else if(!strcmp(argv[i], "AES"))
+                        cesa_test->test = AES;
+                else if(!strcmp(argv[i], "DES"))
+                        cesa_test->test = DES;
+                else if(!strcmp(argv[i], "3DES"))
+                        cesa_test->test = TRI_DES;
+                else if(!strcmp(argv[i], "MD5"))
+                        cesa_test->test = MD5;
+                else if(!strcmp(argv[i], "SHA1"))
+                        cesa_test->test = SHA1;
+		else {
+			fprintf(stderr,"illegal test option\n");
+			exit(1);
+		}
+		i++;
+		cesa_test->iter = atoi(argv[i++]);
+		cesa_test->req_size = atoi(argv[i++]);
+		cesa_test->checkmode = atoi(argv[i++]);
+        }
+}
+
+
+
+int main(int argc, char *argv[])
+{
+        char *name = "/dev/cesa";
+        int fd, t, i, fdflags;
+        int rc = 0;
+	CESA_TEST	cesa_test;
+	CESA_DEBUG	cesa_debug;
+
+	memset(&cesa_test, 0, sizeof(CESA_TEST));
+	memset(&cesa_debug, 0, sizeof(CESA_DEBUG));
+
+        /* open the device */
+        fd = open(name, O_RDWR);
+        if (fd <= 0) {
+                printf("## Cannot open %s device.##\n",name);
+                exit(2);
+        }
+
+        /* set some flags */
+        fdflags = fcntl(fd,F_GETFL,0);
+        fdflags |= O_NONBLOCK;
+        fcntl(fd,F_SETFL,fdflags);
+
+        if(argc < 2) {
+                fprintf(stderr,"missing arguments\n");
+		exit(1);
+        }
+
+	i = 1;
+
+        if (!strcmp(argv[i], "-h")) {
+                show_usage(0);
+        }
+
+        else if (!strcmp(argv[i], "-test")) { /* test */
+		parse_test_cmdline(argc, argv, &cesa_test);
+		printf("test %d iter %d req_size %d checkmode %d sess_id %d data_id %d \n",
+			cesa_test.test, cesa_test.iter, cesa_test.req_size, cesa_test.checkmode,
+			cesa_test.session_id, cesa_test.data_id );
+
+		rc = ioctl(fd, CIOCTEST, &cesa_test);
+	}
+	else { /* debug */
+                parse_debug_cmdline(argc, argv, &cesa_debug);
+		printf("debug %d index %d mode %d size %d \n",
+			cesa_debug.debug, cesa_debug.index, cesa_debug.mode, cesa_debug.size);
+                rc = ioctl(fd, CIOCDEBUG, &cesa_debug);
+	}
+	if(rc < 0) printf("Cesa Tool failed to perform action!\n");
+
+	close(fd);
+
+	return 0;
+}
diff --git a/tools/mv_shell.c b/tools/mv_shell.c
new file mode 100644
index 0000000..b6738dc
--- /dev/null
+++ b/tools/mv_shell.c
@@ -0,0 +1,455 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <stdio.h>
+
+#define DEBUG
+
+char str[256];
+
+/*************************************************************************************/
+
+void show_help(void) {
+  printf("\n-----------\n");
+  printf("rr reg       - register read, used to read a register\n");
+  printf("rw reg value - register write, used to write a value to a register\n");
+  printf("md offset    - memory dump, used to dump 128 bytes in memory\n");
+  printf("mw reg value - memory write, used to write a value to a physical memory\n");
+#if defined (CONFIG_MV_ETHERNET) || defined (CONFIG_MV_GATEWAY)
+  printf("sr dev_addr reg - smi register read, used to read a Switch or Phy register\n");
+  printf("sw dev_addr reg value - smi register write, used to write a 16-bit value to a Switch or Phy register\n");
+#endif
+#ifdef CONFIG_MV_CPU_PERF_CNTRS
+  printf("cchelp\n");
+  printf("tcc cc0_type cc1_type cc2_type cc3_type - trigger cpu counter capture \n");
+  printf("dcc - display cpu counters \n");
+#endif
+#ifdef CONFIG_MV_CPU_PERF_CNTRS
+  printf("l2help\n");
+  printf("tl2 l20_type l21_type - trigger cpu l2 counter capture \n");
+  printf("dl2 - display cpu l2 counters \n");
+#endif
+
+  printf("quit - exit from tool\n");
+  printf("-----------\n");
+}
+
+void show_counters_help(void) {
+    int i = 1;
+    printf("cpu counter type can be one of the below, make sure no error is recieved\n");
+    printf("for example: tcc 11 2 1 4\n");
+    printf("%d: MV_CPU_CNTRS_CYCLES\n",i++);
+    printf("%d: MV_CPU_CNTRS_ICACHE_READ_MISS\n",i++);
+    printf("%d: MV_CPU_CNTRS_DCACHE_ACCESS\n",i++);
+    printf("%d: MV_CPU_CNTRS_DCACHE_READ_MISS\n",i++);
+    printf("%d: MV_CPU_CNTRS_DCACHE_READ_HIT\n",i++);
+    printf("%d: MV_CPU_CNTRS_DCACHE_WRITE_MISS\n",i++);
+    printf("%d: MV_CPU_CNTRS_DCACHE_WRITE_HIT\n",i++);
+    printf("%d: MV_CPU_CNTRS_DTLB_MISS\n",i++);
+    printf("%d: MV_CPU_CNTRS_TLB_MISS\n",i++);
+    printf("%d: MV_CPU_CNTRS_ITLB_MISS\n",i++);
+    printf("%d: MV_CPU_CNTRS_INSTRUCTIONS\n",i++);
+    printf("%d: MV_CPU_CNTRS_SINGLE_ISSUE\n",i++);
+    printf("%d: MV_CPU_CNTRS_MMU_READ_LATENCY\n",i++);
+    printf("%d: MV_CPU_CNTRS_MMU_READ_BEAT\n",i++);
+    printf("%d: MV_CPU_CNTRS_BRANCH_RETIRED\n",i++);
+    printf("%d: MV_CPU_CNTRS_BRANCH_TAKEN\n",i++);
+    printf("%d: MV_CPU_CNTRS_BRANCH_PREDICT_MISS\n",i++);
+    printf("%d: MV_CPU_CNTRS_BRANCH_PREDICT_COUNT\n",i++);
+    printf("%d: MV_CPU_CNTRS_WB_FULL_CYCLES\n",i++);
+    printf("%d: MV_CPU_CNTRS_WB_WRITE_LATENCY\n",i++);
+    printf("%d: MV_CPU_CNTRS_WB_WRITE_BEAT\n",i++);
+    printf("%d: MV_CPU_CNTRS_ICACHE_READ_LATENCY\n",i++);
+    printf("%d: MV_CPU_CNTRS_ICACHE_READ_BEAT\n",i++);
+    printf("%d: MV_CPU_CNTRS_DCACHE_READ_LATENCY\n",i++);
+    printf("%d: MV_CPU_CNTRS_DCACHE_READ_BEAT\n",i++);
+    printf("%d: MV_CPU_CNTRS_DCACHE_WRITE_LATENCY\n",i++);
+    printf("%d: MV_CPU_CNTRS_DCACHE_WRITE_BEAT\n",i++);
+    printf("%d: MV_CPU_CNTRS_LDM_STM_HOLD\n",i++);
+    printf("%d: MV_CPU_CNTRS_IS_HOLD\n",i++);
+    printf("%d: MV_CPU_CNTRS_DATA_WRITE_ACCESS\n",i++);
+    printf("%d: MV_CPU_CNTRS_DATA_READ_ACCESS\n",i++);
+    printf("%d: MV_CPU_CNTRS_BIU_SIMULT_ACCESS\n",i++);
+    printf("%d: MV_CPU_CNTRS_BIU_ANY_ACCESS\n",i++);
+}
+
+void show_l2_counters_help(void) {
+    int i = 1;
+    printf("cpu l2 counter type can be one of the below, make sure no error is recieved\n");
+    printf("%d: MV_CPU_L2_CNTRS_DATA_REQ\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_DATA_MISS_REQ\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_INST_REQ\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_INST_MISS_REQ\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_DATA_READ_REQ\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_DATA_READ_MISS_REQ\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_DATA_WRITE_REQ\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_DATA_WRITE_MISS_REQ\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_RESERVED\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_DIRTY_EVICT_REQ\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_EVICT_BUFF_STALL\n",i++);
+    printf("%d: MV_CPU_L2_CNTRS_ACTIVE_CYCLES\n",i++);
+}
+/*************************************************************************************/
+
+void gt_reg_read(unsigned int rgst) {
+  unsigned int reg = rgst, value;
+  char ch;
+  FILE *resource_dump,*output;
+
+  output = fopen ("./xxx.out","w");
+  if (!output) { printf ("Cannot open file\n");return;}
+
+  while (1){
+    resource_dump = fopen ("/proc/resource_dump" , "w");
+    if (!resource_dump) {
+      printf ("Error opening file /proc/resource_dump\n");
+      exit(-1);
+    }
+    fprintf (resource_dump,"register  r %08x",reg);
+    fclose (resource_dump);
+    resource_dump = fopen ("/proc/resource_dump" , "r");
+    if (!resource_dump) {
+      printf ("Error opening file /proc/resource_dump\n");
+      exit(-1);
+    }
+    fscanf (resource_dump , "%x" , &value);
+    fclose (resource_dump);
+    printf ("%08x : %08x ",reg,value);
+
+    if (!fgets (str, 255, stdin)) {
+     printf ("Error in reading line from stdin\n");
+      exit (-1);
+    }
+    if (str[0] == '.') break;
+    reg += 4;
+
+  }
+}
+
+/*************************************************************************************/
+#if defined (CONFIG_MV_ETHERNET) || defined (CONFIG_MV_GATEWAY)
+
+void gt_smi_reg_read(unsigned int dev_addr, unsigned int rgst) {
+  unsigned int reg = rgst, value;
+  char ch;
+  FILE *resource_dump,*output;
+
+  output = fopen ("./xxx.out","w");
+  if (!output) { printf ("Cannot open file\n");return;}
+
+  while (1){
+    resource_dump = fopen ("/proc/resource_dump" , "w");
+    if (!resource_dump) {
+      printf ("Error opening file /proc/resource_dump\n");
+      exit(-1);
+    }
+    fprintf (resource_dump,"smi  r %08x %08x", dev_addr, reg);
+    fclose (resource_dump);
+    resource_dump = fopen ("/proc/resource_dump" , "r");
+    if (!resource_dump) {
+      printf ("Error opening file /proc/resource_dump\n");
+      exit(-1);
+    }
+    fscanf (resource_dump , "%x" , &value);
+    fclose (resource_dump);
+    printf ("SMI Device: %08x, Reg: %08x, Data: %08x ", dev_addr, reg, value);
+
+    if (!fgets (str, 255, stdin)) {
+     printf ("Error in reading line from stdin\n");
+      exit (-1);
+    }
+    if (str[0] == '.') break;
+    reg += 1;
+
+  }
+}
+
+/*************************************************************************************/
+
+void gt_smi_reg_write(unsigned int dev_addr, unsigned int rgst, unsigned int vlue) {
+  unsigned int reg = rgst, value = vlue;
+  unsigned int element;
+  char ch;
+  FILE *resource_dump;
+  resource_dump = fopen ("/proc/resource_dump" , "w");
+  if (!resource_dump) {
+    printf ("Eror opening file /proc/resource_dump\n");
+    exit(-1);
+  }
+  fprintf (resource_dump,"smi  w %08x %08x %08x", dev_addr, reg, value);
+  fclose (resource_dump);
+}
+#endif
+/*************************************************************************************/
+
+void gt_mem_dump(unsigned int rgst) {
+  unsigned int offset = rgst, value , i , j;
+  char ch;
+  FILE *resource_dump;
+  FILE *output;
+  output = fopen ("./xxx.out","w");
+  if (!output) { printf ("Canot open file\n");return;}
+  i = 0;
+  while (1) {
+    if (i == 0) printf ("\n");
+    printf ("%08x : ",offset);
+    for (j = 0 ; j < 8 ; j++) {
+      resource_dump = fopen ("/proc/resource_dump" , "w");
+      if (!resource_dump) {
+	printf ("Eror opening file /proc/resource_dump\n");
+	exit(-1);
+      }
+
+      fprintf (resource_dump,"memory    r %08x",offset);
+      fclose (resource_dump);
+      resource_dump = fopen ("/proc/resource_dump" , "r");
+      if (!resource_dump) {
+	printf ("Eror opening file /proc/resource_dump\n");
+	exit(-1);
+      }
+      fscanf (resource_dump , "%x" , &value);
+      fclose (resource_dump);
+            printf ("%08x ",value);
+
+      {
+	unsigned int temp;
+	temp = ((value & 0xff) << 24) |
+	  ((value & 0xff00) << 8) |
+	  ((value & 0xff0000) >> 8) |
+	  ((value & 0xff000000) >> 24);
+	value = temp;
+      }
+      fprintf (output, "%c",value & 0xff);
+      value = value >> 8;
+      fprintf (output, "%c",value & 0xff);
+      value = value >> 8;
+      fprintf (output, "%c",value & 0xff);
+      value = value >> 8;
+      fprintf (output, "%c",value & 0xff);
+      value = value >> 8;
+
+      offset += 4;
+      }
+      if (!fgets (str, 255, stdin)) {
+	printf ("Error in reading line from stdin\n");
+	exit (-1);
+      }
+      if (str[0] == '.') break;
+      i ++;
+
+  }
+  fclose (output);
+  printf ("\n");
+}
+
+/*************************************************************************************/
+
+void gt_mem_write(unsigned int rgst, unsigned int vlue) {
+  unsigned int reg = rgst, value = vlue;
+  unsigned int element;
+  char ch;
+  FILE *resource_dump;
+  resource_dump = fopen ("/proc/resource_dump" , "w");
+  if (!resource_dump) {
+    printf ("Eror opening file /proc/resource_dump\n");
+    exit(-1);
+  }
+  fprintf (resource_dump,"memory    w %08x %08x",reg,value);
+  fclose (resource_dump);
+}
+
+/*************************************************************************************/
+
+void gt_reg_write(unsigned int rgst, unsigned int vlue) {
+  unsigned int reg = rgst, value = vlue;
+  unsigned int element;
+  char ch;
+  FILE *resource_dump;
+  resource_dump = fopen ("/proc/resource_dump" , "w");
+  if (!resource_dump) {
+    printf ("Eror opening file /proc/resource_dump\n");
+    exit(-1);
+  }
+  fprintf (resource_dump,"register  w %08x %08x",reg,value);
+  fclose (resource_dump);
+}
+
+/*************************************************************************************/
+
+int main(void) {
+  unsigned int dev, reg , value , offset , element;
+  char inst[256];
+  char value_s[10];
+  printf ("\n\n\n*******\nWelcome to the GT Shell environment\n\n");
+  printf ("Write 'help' for getting help on the instructions\n");
+  while (1) {
+    memset (str , 0 , 256);
+    memset (inst , 0 , 256);
+    printf ("MV Shell -> ");
+    if (!fgets (str, 255, stdin)) {
+      printf ("Error in reading line from stdin\n");
+      exit (-1);
+    }
+    element = sscanf (str , "%s" , inst);
+    if (element == 0) continue;
+    offset = strlen (inst);
+    if (!strcmp (inst , "quit")) break;
+
+    if (!strcmp (inst , "rr")) {
+      element = sscanf (str+offset , "%x" , &reg);
+      if (element == 1) gt_reg_read (reg);
+      else printf ("Insufficient parameters\n");
+    }
+    else if (!strcmp (inst , "rw")) {
+      element = sscanf (str+offset , "%x %x" , &reg , &value);
+      if (element == 2) gt_reg_write (reg,value);
+      else printf ("Insufficient parameters\n");
+    }
+    else if (!strcmp (inst , "help")) {
+      show_help();
+    }
+    else if (!strcmp (inst , "md")) {
+      element = sscanf (str+offset , "%x" , &reg);
+      if (element == 1) gt_mem_dump (reg);
+      else printf ("Insufficient parameters\n");
+    }
+    else if (!strcmp (inst , "mw")) {
+      element = sscanf (str+offset , "%x %x" , &reg , &value);
+      if (element == 2) gt_mem_write (reg,value);
+      else printf ("Insufficient parameters\n");
+    }
+#if defined (CONFIG_MV_ETHERNET) || defined (CONFIG_MV_GATEWAY)
+    else if (!strcmp (inst , "sr")) {
+      element = sscanf (str+offset , "%x %x %x" , &dev, &reg);
+      if (element == 2) gt_smi_reg_read (dev, reg);
+      else printf ("Insufficient parameters\n");
+    }
+    else if (!strcmp (inst , "sw")) {
+      element = sscanf (str+offset , "%x %x %x" , &dev, &reg , &value);
+      if (element == 3) gt_smi_reg_write (dev, reg, value);
+      else printf ("Insufficient parameters\n");
+    }
+#endif
+#ifdef CONFIG_MV_CPU_PERF_CNTRS
+   else if (!strcmp (inst , "cchelp")) {
+	show_counters_help();
+   }
+   else if (!strcmp (inst , "tcc")) {
+	int cc0, cc1, cc2, cc3;
+	FILE *resource_dump;
+	resource_dump = fopen ("/proc/resource_dump" , "w");
+	if (!resource_dump) {
+		printf ("Eror opening file /proc/resource_dump\n");
+		exit(-1);
+	}
+	sscanf(str + 3," %d %d %d %d", &cc0, &cc1, &cc2, &cc3);
+	fprintf (resource_dump,"start_cc %d %d %d %d",cc0, cc1, cc2, cc3);
+	fclose (resource_dump);
+   }
+   else if (!strcmp (inst , "dcc")) {
+	FILE *resource_dump;
+	resource_dump = fopen ("/proc/resource_dump" , "w");
+	if (!resource_dump) {
+		printf ("Eror opening file /proc/resource_dump\n");
+		exit(-1);
+	}
+	fprintf (resource_dump,"show__cc");
+	fclose (resource_dump);
+   }
+#endif
+#ifdef CONFIG_MV_CPU_PERF_CNTRS
+   else if (!strcmp (inst , "l2help")) {
+	show_l2_counters_help();
+   }
+   else if (!strcmp (inst , "tl2")) {
+	int l20, l21;
+	FILE *resource_dump;
+	resource_dump = fopen ("/proc/resource_dump" , "w");
+	if (!resource_dump) {
+		printf ("Eror opening file /proc/resource_dump\n");
+		exit(-1);
+	}
+	sscanf(str + 3," %d %d", &l20, &l21);
+	fprintf (resource_dump,"start_l2 %d %d",l20, l21);
+	fclose (resource_dump);
+   }
+   else if (!strcmp (inst , "dl2")) {
+	FILE *resource_dump;
+	resource_dump = fopen ("/proc/resource_dump" , "w");
+	if (!resource_dump) {
+		printf ("Eror opening file /proc/resource_dump\n");
+		exit(-1);
+	}
+	fprintf (resource_dump,"show__l2");
+	fclose (resource_dump);
+   }
+#endif
+
+    else if (strlen (str) != 0) printf ("Invalid command - %s\n",inst);
+  }
+  printf ("Good Bye\n");
+
+}
+
+/*************************************************************************************/
diff --git a/tools/voice/Makefile b/tools/voice/Makefile
new file mode 100644
index 0000000..4078310
--- /dev/null
+++ b/tools/voice/Makefile
@@ -0,0 +1,59 @@
+# kernel sources
+srctree  := $(shell /bin/pwd)
+
+ifndef KSRC
+KSRC  := $(srctree)/../..
+endif
+
+include $(KSRC)/.config
+
+CFLAGS  := $(EXTRA_CFLAGS)
+
+ifdef CONFIG_CPU_BIG_ENDIAN
+CFLAGS  += -DCONFIG_CPU_BIG_ENDIAN
+endif
+
+CC := $(CROSS_COMPILE)gcc
+LD := $(CROSS_COMPILE)ld
+AR := $(CROSS_COMPILE)ar
+
+#CFLAGS += -I$(KSRC)/tools/voice/
+
+ifeq ($(CONFIG_ZARLINK_SLIC_SUPPORT),y)
+TARGETS += vpapi_lib.o
+LIBS := libvpapi.a
+TOOL := mv_voice_tool.c
+CFLAGS += -I$(KSRC)/arch/arm/plat-armada/mv_hal/voiceband/slic/zarlink/arch_marvell/
+CFLAGS += -I$(KSRC)/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/
+ifeq ($(CONFIG_ZARLINK_SLIC_VE792),y)
+ CFLAGS += -I$(KSRC)/arch/arm/plat-armada/mv_hal/voiceband/slic/zarlink/vp792_api_lib/includes/
+ CFLAGS += -DZARLINK_SLIC_VE792
+ PROFILE = profile_79238.c
+endif
+ifeq ($(CONFIG_ZARLINK_SLIC_VE880),y)
+ CFLAGS += -I$(KSRC)/arch/arm/plat-armada/mv_hal/voiceband/slic/zarlink/api_lib/includes/
+ CFLAGS += -DZARLINK_SLIC_VE880
+ PROFILE = profile_88266.c
+endif
+
+CFLAGS += -I$(KSRC)/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/
+
+all:
+	$(CC) $(CFLAGS) -static -c vpapi_lib.c -o $(TARGETS)
+	$(AR) rcs $(LIBS) $(TARGETS)
+	$(CC) $(CFLAGS) -static $(PROFILE) $(TOOL) -L. $(LIBS) -o mv_voice_tool
+
+mv_voice_tool: $(PROFILE) $(TOOL)
+	$(CC) $(CFLAGS) -static $(PROFILE) $(TOOL) -L. $(LIBS) -o mv_voice_tool
+
+clean:
+	rm -f *.o *.a mv_voice_tool
+	@for subdir in $(SUBDIRS); do \
+                (cd $$subdir && $(MAKE) $@) || exit 1; \
+        done
+
+endif #CONFIG_ZARLINK_SLIC_SUPPORT
+
+#ifeq ($(CONFIG_SILABS_SLIC_SUPPORT),y)
+#TARGETS +=
+#endif
diff --git a/tools/voice/mv_voice_tool.c b/tools/voice/mv_voice_tool.c
new file mode 100644
index 0000000..8b803a0
--- /dev/null
+++ b/tools/voice/mv_voice_tool.c
@@ -0,0 +1,1337 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <signal.h>
+#include "vpapi_lib.h"
+#include "tdm/test/tdm_dev.h"
+#if defined(ZARLINK_SLIC_VE880)
+#include "profile_88266.h"
+#elif defined(ZARLINK_SLIC_VE792)
+#include "profile_79238.h"
+#endif
+
+#define TOOL_PREFIX	">> "
+#define TIMEOUT		11000 /* usec */
+/* Line calibration increases init time significantly */
+#define LINE_CALIBRATION_SUPPORT
+
+/* Defines */
+#define GET_DEVICE(line_id)	(line_id/MAX_DEVICE_LINES)
+#define GET_LINE(line_id)	(line_id % MAX_DEVICE_LINES)
+#define N_A			0
+#define ON_HOOK			0
+#define OFF_HOOK		1
+#define CH_BUFF_SIZE		(80 * pcm_bytes)
+#define BUFF_ADDR(buff, line)	((unsigned char*)buff + (line*80*pcm_bytes))
+
+/* VE880 */
+#if defined(ZARLINK_SLIC_VE880)
+
+#define MAX_DEVICES		2
+#define MAX_DEVICE_LINES	2
+#define MAX_LINES		4
+#define VP_DEV_SERIES		VP_DEV_880_SERIES
+#define DEV_PROFILE		ABS_VBL_FLYBACK
+#define DC_COEFF		DC_22MA_CC
+#define AC_COEFF		AC_FXS_RF14_DEF
+#define WB_AC_COEFF		AC_FXS_RF14_WB_US
+#define RING_PROFILE		RING_DEF
+
+/* VE792 */
+#elif defined(ZARLINK_SLIC_VE792)
+
+#define MAX_DEVICES		4
+#define MAX_DEVICE_LINES	8
+#define MAX_LINES		32
+#define VP_DEV_SERIES		VP_DEV_792_SERIES
+#define DEV_PROFILE		VE792_DEV_PROFILE
+#define DC_COEFF		VE792_DC_COEFF
+#define AC_COEFF		VE792_AC_COEFF_600
+#define WB_AC_COEFF		TBD /* TBD: AC profile for WideBand support */
+#define RING_PROFILE		RING_20HZ_SINE
+
+/* Power-supply related parameters */
+#define VBH			-50
+#define VBL			-25
+#define VBP			 50
+
+#endif
+
+/* Extern */
+extern int dev_profile_size;
+extern int dc_profile_size;
+extern int ac_profile_size;
+extern int ring_profile_size;
+
+/* GLobals */
+static unsigned short total_lines = 0;
+static unsigned short total_devs = 0;
+static unsigned char pcm_bytes = 0;
+static unsigned char cal_devs = 0;
+#ifdef LINE_CALIBRATION_SUPPORT
+static unsigned short cal_lines = 0;
+#endif
+static VpOptionCodecType codec = VP_OPTION_ALAW;
+static unsigned char time_slot_table[MAX_LINES];
+static unsigned char hook_state[MAX_LINES];
+static char dev_name[] = "/dev/tdm";
+static int buff_size = 0;
+static unsigned char aud_buf[2][320 * MAX_LINES];
+static unsigned short f1Mem = 0;
+static unsigned short f2Mem = 0;
+static int offhook_count = 0;
+static unsigned int event_count = 0;
+static int tdm_fd = 0;
+static unsigned char data_buff[MAX_SLIC_RDWR_BUFF_SIZE];
+static int slic_init = 0;
+
+/* sin table, 256 points */
+static short sinTbl[] = {0,402,804,1205,1606,2005,2404,2801,3196,3590,3981,4370,4756,
+5139,5519,5896,6270,6639,7005,7366,7723,8075,8423,8765,9102,9433,9759,10079,10393,
+10701,11002,11297,11585,11865,12139,12405,12664,12915,13159,13394,13622,13841,14052,
+14255,14449,14634,14810,14977,15136,15285,15425,15556,15678,15790,15892,15985,16068,
+16142,16206,16260,16304,16339,16363,16378,16383,16378,16363,16339,16304,16260,16206,
+16142,16068,15985,15892,15790,15678,15556,15425,15285,15136,14977,14810,14634,14449,
+14255,14052,13841,13622,13394,13159,12915,12664,12405,12139,11865,11585,11297,11002,
+10701,10393,10079,9759,9433,9102,8765,8423,8075,7723,7366,7005,6639,6270,5896,5519,
+5139,4756,4370,3981,3590,3196,2801,2404,2005,1606,1205,804,402,0,-402,-804,-1205,-1606,
+-2005,-2404,-2801,-3196,-3590,-3981,-4370,-4756,-5139,-5519,-5896,-6270,-6639,-7005,
+-7366,-7723,-8075,-8423,-8765,-9102,-9433,-9759,-10079,-10393,-10701,-11002,-11297,
+-11585,-11865,-12139,-12405,-12664,-12915,-13159,-13394,-13622,-13841,-14052,-14255,
+-14449,-14634,-14810,-14977,-15136,-15285,-15425,-15556,-15678,-15790,-15892,-15985,
+-16068,-16142,-16206,-16260,-16304,-16339,-16363,-16378,-16383,-16378,-16363,-16339,
+-16304,-16260,-16206,-16142,-16068,-15985,-15892,-15790,-15678,-15556,-15425,-15285,
+-15136,-14977,-14810,-14634,-14449,-14255,-14052,-13841,-13622,-13394,-13159,-12915,
+-12664,-12405,-12139,-11865,-11585,-11297,-11002,-10701,-10393,-10079,-9759,-9433,-9102,
+-8765,-8423,-8075,-7723,-7366,-7005,-6639,-6270,-5896,-5519,-5139,-4756,-4370,-3981,
+-3590,-3196,-2801,-2404,-2005,-1606,-1205,-804,-402,0};
+
+/* Static APIs */
+static void vpapi_dev_init(VpDeviceIdType dev_id);
+static inline void wait_for_vpapi_event(void);
+static int vpapi_init(void);
+static void vpapi_init_done(void);
+static void vpapi_release(void);
+static void release(int signum);
+static void sw_tone_test(int tdm_fd, unsigned char line_id);
+static void sw_loopback_two_phones_test(int tdm_fd, unsigned char line0, unsigned char line1);
+static void sw_loopback_multi_phones_test(int tdm_fd, unsigned char start_line, unsigned char end_line);
+static void gen_tone(unsigned short freq, unsigned char line_id, unsigned char* tx_buff);
+static void sw_loopback(int tdm_fd, unsigned char line_id);
+static void slic_digital_loopback(int tdm_fd, unsigned long int iterations);
+static void channel_balancing_test(int tdm_fd, unsigned long int iterations);
+static inline int slic_dl_data_compare(int offset);
+
+int main(void)
+{
+	int ret = 0, cmd = 0, val = 0, tdm_init = 0;
+	int proc_fd, fdflags, cmd_len, i;
+	char str[32];
+	unsigned char line0_id, line1_id;
+	tdm_dev_params_t tdm_params;
+	unsigned long int iterations;
+
+	event_count = 0;
+	slic_init = 0;
+
+	/* open tdm device */
+	tdm_fd = open(dev_name, O_RDWR);
+	if (tdm_fd <= 0) {
+		printf("%s Cannot open %s device\n", TOOL_PREFIX, dev_name);
+		return 1;
+	}
+
+	/* set some flags */
+	fdflags = fcntl(tdm_fd, F_GETFL, 0);
+	fdflags |= O_NONBLOCK;
+	fcntl(tdm_fd, F_SETFL, fdflags);
+
+	printf("\n%s Please enter total lines number: ", TOOL_PREFIX);
+	gets(str);
+	total_lines = atoi(str);
+
+	printf("%s Please enter PCM sample size(1/2/4): ",TOOL_PREFIX);
+	gets(str);
+	pcm_bytes = atoi(str);
+
+	/* Calculate total lines buffer size */
+	buff_size = (80 * pcm_bytes * total_lines);
+
+	/* Fill TDM info */
+	tdm_params.pcm_format = pcm_bytes;
+	tdm_params.total_lines = total_lines;
+
+	/* Start TDM */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_START, &tdm_params)) {
+		printf("%s Error, unable to init TDM\n", TOOL_PREFIX);
+		return 1;
+	}
+
+	total_devs = (total_lines/MAX_DEVICE_LINES);
+	if((total_lines % MAX_DEVICE_LINES))
+		total_devs++;
+
+	if(vpapi_open_device()) {
+		printf("%s Error, could not open vpapi device\n", TOOL_PREFIX);
+		return 1;
+	}
+
+	if(vpapi_init()) {
+		printf("%s Error, init failed\n", TOOL_PREFIX);
+		ret = 1;
+		goto vpapi_out;
+	}
+	slic_init = 1;
+
+	/* Wait to device/s and line/s calibration to finish */
+#ifdef LINE_CALIBRATION_SUPPORT
+	while((cal_devs < total_devs) || (cal_lines < total_lines)) {
+#else
+	while(cal_devs < total_devs) {
+#endif
+		wait_for_vpapi_event();
+	}
+
+	/* Handle termination gracefully */
+	if (signal (SIGINT, release) == SIG_IGN)
+		signal (SIGINT, SIG_IGN);
+
+	/* Issue main menu */
+	while(1) {
+		printf("\n  Marvell Voice Tool:\n");
+		printf("  0. Read from SLIC register(VE880 only)\n");
+		printf("  1. Write to SLIC register(VE880 only)\n");
+		printf("  2. Start ring\n");
+		printf("  3. Stop ring\n");
+                printf("  4. Start SW tone\n");
+                printf("  5. Self echo on local phone\n");
+                printf("  6. Loopback two local phones\n");
+		printf("  7. Multiple local phone pairs loopback\n");
+		printf("  8. Digital Loopback(incremental pattern)\n");
+		printf("  9. Channel balancing\n");
+		printf("  q. Quit\n");
+		printf("\n%s Please select option: ", TOOL_PREFIX);
+
+		/* Clear write buffer */
+		memset(aud_buf[1], 0, buff_size);
+		gets(str);
+		switch(str[0])
+		{
+                        case '0':
+#if defined(ZARLINK_SLIC_VE880)
+                                printf("%s Enter line id: ",TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter SLIC register command(decimal): ",TOOL_PREFIX);
+				gets(str);
+				cmd = atoi(str);
+				printf("%s Enter SLIC register command size: ",TOOL_PREFIX);
+				gets(str);
+				cmd_len = atoi(str);
+				vpapi_slic_reg_read(line0_id, cmd, cmd_len, data_buff);
+				printf("\n%s Sent command 0x%x to line(%d)\n", TOOL_PREFIX, cmd, line0_id);
+				printf("%s Return value: ",TOOL_PREFIX);
+				for(i = 0; i < cmd_len; i++)
+					printf("0x%x ", data_buff[i]);
+				printf("\n");
+#else
+				printf("%s operation not supported\n",TOOL_PREFIX);
+#endif
+				break;
+
+			case '1':
+#if defined(ZARLINK_SLIC_VE880)
+				printf("%s Enter line id: ",TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter SLIC register command(decimal): ",TOOL_PREFIX);
+				gets(str);
+				cmd = atoi(str);
+				printf("%s Enter SLIC register command size: ",TOOL_PREFIX);
+				gets(str);
+				cmd_len = atoi(str);
+				printf("%s Enter data(press Enter after each byte): ",TOOL_PREFIX);
+				for(i = 0; i < cmd_len; i++) {
+					gets(str);
+					data_buff[i] = atoi(str);
+				}
+				vpapi_slic_reg_write(line0_id, cmd, cmd_len, data_buff);
+				printf("\n%s Sent command 0x%x to line(%d)\n", TOOL_PREFIX, cmd, line0_id);
+#else
+				printf("%s operation not supported\n",TOOL_PREFIX);
+#endif
+				break;
+
+
+			case '2':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("Start ringing on line %d\n", line0_id);
+				vpapi_set_line_state(line0_id, VP_LINE_RINGING);
+				break;
+
+			case '3':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("Stop ringing on line %d\n", line0_id);
+				vpapi_set_line_state(line0_id, VP_LINE_STANDBY);
+				break;
+
+			case '4':
+				if(pcm_bytes < 2) {
+					printf("Test is supported for linear mode only - try again\n");
+					break;
+				}
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				sw_tone_test(tdm_fd, line0_id);
+				break;
+
+			case '5':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				printf("%s Waiting for off-hook...\n", TOOL_PREFIX);
+				line0_id = atoi(str);
+				sw_loopback(tdm_fd, line0_id);
+				break;
+
+			case '6':
+				printf("%s Enter line #0: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter line #1: ", TOOL_PREFIX);
+				gets(str);
+				printf("Waiting for off-hook...\n");
+				line1_id = atoi(str);
+				if(line0_id >= MAX_LINES || line1_id >= MAX_LINES) {
+					printf("%s Error, line must be in the range of 0-%d\n", TOOL_PREFIX, (MAX_LINES-1));
+					break;
+				}
+				sw_loopback_two_phones_test(tdm_fd, line0_id, line1_id);
+				break;
+
+			case '7':
+				printf("%s Enter starting line range: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter ending line range: ", TOOL_PREFIX);
+				gets(str);
+				printf("Waiting for off-hook...\n");
+				line1_id = atoi(str);
+				if((line0_id >= MAX_LINES) ||
+				   (line1_id >= MAX_LINES) ||
+				   ((line1_id-line0_id) % 2 == 0)) {
+					printf("%s Error, lines range must be even and \
+							between 0-%d\n", TOOL_PREFIX, (MAX_LINES-1));
+					break;
+				}
+				sw_loopback_multi_phones_test(tdm_fd, line0_id, line1_id);
+				break;
+
+			case '8':
+				printf("%s Enter number of iterations(must be greater than 3): ", TOOL_PREFIX);
+				gets(str);
+				iterations = (unsigned long int)atoi(str);
+				if(iterations < 4) {
+					printf("Requires at least 4 iterations  - try again\n");
+					break;
+				}
+				slic_digital_loopback(tdm_fd, iterations);
+				break;
+
+			case '9':
+				printf("%s Enter number of iterations('0' - for infinite loop): ", TOOL_PREFIX);
+				gets(str);
+				iterations = (unsigned long int)atoi(str);
+				channel_balancing_test(tdm_fd, iterations);
+				break;
+
+			case 'q':
+				goto vpapi_out;
+
+			default:
+				printf("Option is not supported - try again\n");
+				break;
+		}
+	}
+
+vpapi_out:
+	release(0);
+
+	return ret;
+}
+
+void release(int signum)
+{
+	printf("\n%s Exit\n", TOOL_PREFIX);
+	sleep(1);
+
+	/* Stop SLIC/s */
+	if(slic_init)
+		vpapi_release();
+
+	/* Stop TDM */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_STOP, 0)) {
+		printf("Error, unable to stop TDM\n");
+		return;
+	}
+
+	close(tdm_fd);
+
+	if(vpapi_close_device()) {
+		printf("## Error, could not close vpapi device ##\n");
+		return;
+	}
+
+	exit(0);
+}
+
+static void channel_balancing_test(int tdm_fd, unsigned long int iterations)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, cmp_status = 0, ch, cb_loop = 0, i;
+	unsigned long int loops = 0, index;
+	VpOptionLoopbackType lp = VP_OPTION_LB_TIMESLOT;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Fill Tx buffer with incremental pattern */
+	for(ch = 0; ch < total_lines; ch++) {
+		for(index = 0; index < (80 * pcm_bytes); index+=2)
+			*((unsigned short*)&aud_buf[1][(80 * pcm_bytes * ch) + index]) = (((index+3) << 8)+ (index+1));
+	}
+
+	/* Put SLIC/s in loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_option(1, ch, GET_DEVICE(ch), VP_OPTION_ID_LOOPBACK, &lp);
+
+	/* Wait a bit */
+	sleep(1);
+
+	/* Put SLIC/s in TALK mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_line_state(ch, VP_LINE_TALK);
+
+	/* Wait a bit */
+	sleep(1);
+
+	if (iterations == 0)
+		iterations = (unsigned long int)(-1); /* Assume infinite */
+
+	while (loops < iterations) {
+
+	  cb_loop = 0;
+	  i = 0;
+
+	  if (ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	  }
+
+	  while (cb_loop == 0) {
+
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			goto cb_out;
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds))
+		{
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len < buff_size) {
+				printf("write() failed\n");
+				goto cb_out;
+			}
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds))
+		{
+			memset(aud_buf[0], 0, buff_size);
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len < buff_size) {
+				printf("read() failed\n");
+				goto cb_out;
+			}
+
+			if(i > 3) {
+
+				for(ch = 1; ch < total_lines; ch++) {
+					if(memcmp(aud_buf[0], &aud_buf[0][(ch * pcm_bytes * 80)], (pcm_bytes * 80))) {
+						printf("\nERROR - data miscompare(ch=%d) !!!\n", ch);
+						cmp_status = 1;
+						goto cb_out;
+					}
+				}
+
+				cb_loop = 1;
+			}
+			i++;
+		}
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	  }
+
+	  loops++;
+	  if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	  }
+	  printf("loop #%u\n", loops);
+	  sleep(1);
+	}
+
+cb_out:
+
+	if(cmp_status == 0) {
+		printf("\nChannel balancing test PASSED !!!\n");
+	}
+	else {
+		printf("Dump Rx buffer:\n");
+		for(ch = 0; ch < total_lines; ch++) {
+			printf("Buffer #%d: ", ch);
+			for(i = 0; i < (pcm_bytes * 80); i++) {
+				printf("0x%x ", aud_buf[0][(ch * pcm_bytes * 80) + i]);
+			}
+			printf("\n\n");
+			sleep(1);
+		}
+	}
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+
+	lp = VP_OPTION_LB_OFF;
+
+	/* Disable loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_option(1, ch, GET_DEVICE(ch), VP_OPTION_ID_LOOPBACK, &lp);
+
+	/* Put SLIC/s in STANDBY mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_line_state(ch, VP_LINE_STANDBY);
+}
+
+static void slic_digital_loopback(int tdm_fd, unsigned long int iterations)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, cmp_status = 0, ch;
+	unsigned long int loops = 0, index;
+	VpOptionLoopbackType lp = VP_OPTION_LB_TIMESLOT;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Put SLIC/s in loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_option(1, ch, GET_DEVICE(ch), VP_OPTION_ID_LOOPBACK, &lp);
+
+	/* Wait a bit */
+	sleep(1);
+
+	/* Put SLIC/s in TALK mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_line_state(ch, VP_LINE_TALK);
+
+	/* Fill Tx buffer with incremental pattern */
+	for(ch = 0; ch < total_lines; ch++) {
+		for(index = 0; index < (80 * pcm_bytes); index++)
+			aud_buf[1][index + (80 * pcm_bytes * ch)] = (index+ch+2);
+	}
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while (loops < iterations) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			goto slic_dl_out;
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds))
+		{
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len < buff_size) {
+				printf("write() failed\n");
+				goto slic_dl_out;
+			}
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds))
+		{
+			memset(aud_buf[0], 0, buff_size);
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);										     if (msg_len < buff_size) {
+				printf("read() failed\n");
+				goto slic_dl_out;
+			}
+
+			if(loops++ > 3) {
+				for(ch = 0; ch < total_lines; ch++) {
+					if(slic_dl_data_compare(ch)) {
+						printf("\nERROR - data miscompare(loops=%d) !!!\n",loops);
+						cmp_status = 1;
+						goto slic_dl_out;
+					}
+				}
+			}
+		}
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+
+	}
+
+slic_dl_out:
+
+	if(cmp_status == 0)
+		printf("\nDigital loopback test(%d lines) - PASS !!!\n",total_lines);
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+
+	lp = VP_OPTION_LB_OFF;
+
+	/* Disable loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_option(1, ch, GET_DEVICE(ch), VP_OPTION_ID_LOOPBACK, &lp);
+
+	/* Put SLIC/s in STANDBY mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_line_state(ch, VP_LINE_STANDBY);
+}
+
+static inline int slic_dl_data_compare(int ch)
+{
+	int i = 0, offset = (ch * pcm_bytes * 80);
+
+	/* Align Tx & Rx data start */
+	while((aud_buf[1][offset] != aud_buf[0][offset+i]) && (i < (pcm_bytes * 80)))
+		i++;
+
+	if(i >= (offset + (pcm_bytes * 80))) {
+		printf("\nError, first Tx byte not found inside Rx buffer\n");
+		return -1;
+	}
+
+	if(memcmp(&aud_buf[0][offset+i], &aud_buf[1][offset], ((pcm_bytes * 80) - i))) {
+			printf("\nDump buffers:\n");
+			for(i = offset; i < (offset +(pcm_bytes * 80)); i++)
+				printf("write[%d] = 0x%x, read[%d] = 0x%x\n", i, aud_buf[1][i], i, aud_buf[0][i]);
+			return -1;
+	}
+	else
+		return 0;
+}
+
+static void sw_loopback(int tdm_fd, unsigned char line_id)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Wait until line goes off-hook */
+	while(hook_state[line_id] == 0) {
+		wait_for_vpapi_event();
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while(hook_state[line_id] == 1) {
+
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds))
+		{
+			printf("Rd\n");
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);										     if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+			memcpy(BUFF_ADDR(aud_buf[1], line_id), BUFF_ADDR(aud_buf[0], line_id), CH_BUFF_SIZE);
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds))
+		{
+			printf("Wr\n");
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_vpapi_event();
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static void gen_tone(unsigned short freq, unsigned char line_id, unsigned char* tx_buff)
+{
+	short i;
+	short buf[80];
+	short sample;
+
+	for(i = 0; i < 80; i++) {
+		sample = (sinTbl[f1Mem >> 8] + sinTbl[f2Mem >> 8]) >> 2;
+#ifndef CONFIG_CPU_BIG_ENDIAN
+		buf[i] = sample;
+#else
+		buf[i] = ((sample & 0xff) << 8)+ (sample >> 8);
+#endif
+		f1Mem += freq;
+		f2Mem += freq;
+	}
+	memcpy(BUFF_ADDR(tx_buff, line_id), (void *)buf, 160);
+}
+
+static void sw_tone_test(int tdm_fd, unsigned char line_id)
+{
+	fd_set wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, x;
+	char str[4];
+
+	if (tdm_fd <= 0) {
+			printf("%s Device %s is not accessible\n", TOOL_PREFIX, dev_name);
+			return;
+	}
+
+	while(1) {
+		printf("%s Choose frequency: (1) 300HZ (2) 630HZ (3) 1000HZ (4) Back to main menu: ", TOOL_PREFIX);
+		gets(str);
+		printf("%s Waiting for off-hook...\n", TOOL_PREFIX);
+
+		if(str[0] == '1') {
+			x = 2457;
+			//printf("%s Generating 300HZ tone\n", TOOL_PREFIX);
+		}
+		else if (str[0] == '2') {
+			x = 5161;
+			//printf("%s Generating 630HZ tone\n", TOOL_PREFIX);
+		}
+		else if (str[0] == '3') {
+			x = 8192;
+			//printf("%s Generating 1000HZ tone\n", TOOL_PREFIX);
+		}
+		else if (str[0] == '4') {
+			return;
+	        }
+		else {
+			printf("%s Input error - try again\n", TOOL_PREFIX);
+			continue;
+		}
+
+		/* Wait until both lines go off-hook */
+		while(hook_state[line_id] == 0) {
+			wait_for_vpapi_event();
+		}
+
+		if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+			printf("Error, unable to start pcm bus\n");
+			return;
+		}
+
+		printf("%s Waiting for on-hook to return to menu.\n", TOOL_PREFIX);
+
+		while(hook_state[line_id] == 1) {
+			FD_ZERO(&wr_fds);
+			FD_SET(tdm_fd, &wr_fds);
+
+			/* Wait for event  */
+			if (select(tdm_fd+1, NULL, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				return;
+			}
+
+			/* Write */
+			if (FD_ISSET(tdm_fd, &wr_fds))
+			{
+				gen_tone(x, line_id, aud_buf[1]);
+				if (pcm_bytes == 4)
+					gen_tone(x, line_id, (aud_buf[1]+160));
+
+				msg_len = write(tdm_fd, aud_buf[1], buff_size);
+				if (msg_len <= 0) {
+					printf("write() failed\n");
+					return;
+				}
+			}
+
+			/* Check hook state */
+			wait_for_vpapi_event();
+
+			/* Reload timeout */
+			timeout.tv_usec = TIMEOUT;
+		}
+	}
+}
+
+static void sw_loopback_multi_phones_test(int tdm_fd, unsigned char start_line, unsigned char end_line)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len;
+	unsigned char line_id;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Wait until at least one line goes off-hook */
+	while(offhook_count == 0) {
+		wait_for_vpapi_event();
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while(offhook_count) {
+
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds))
+		{
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);										     if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+
+			for(line_id = start_line; line_id < end_line; line_id+=2) {
+				memcpy(BUFF_ADDR(aud_buf[1], line_id), BUFF_ADDR(aud_buf[0], (line_id+1)), CH_BUFF_SIZE);
+				memcpy(BUFF_ADDR(aud_buf[1], (line_id+1)), BUFF_ADDR(aud_buf[0], line_id), CH_BUFF_SIZE);
+			}
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds))
+		{
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_vpapi_event();
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static void sw_loopback_two_phones_test(int tdm_fd, unsigned char line0, unsigned char line1)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	/* Wait until both lines go off-hook */
+	while((hook_state[line0] == 0) || (hook_state[line1] == 0)) {
+		wait_for_vpapi_event();
+	}
+
+
+	while((hook_state[line0] == 1) && (hook_state[line1] == 1)) {
+
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds))
+		{
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);										     if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+			memcpy(BUFF_ADDR(aud_buf[1], line0), BUFF_ADDR(aud_buf[0], line1), CH_BUFF_SIZE);
+			memcpy(BUFF_ADDR(aud_buf[1], line1), BUFF_ADDR(aud_buf[0], line0), CH_BUFF_SIZE);
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds))
+		{
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_vpapi_event();
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static int vpapi_init(void)
+{
+	int i = 0;
+	VpDeviceIdType dev_id = 0;
+	VpLineIdType line_id = 0;
+	VpStatusType status;
+	vpapi_init_device_params_t params;
+
+	/* Check params */
+	if(total_lines > MAX_LINES) {
+		printf("## Error, total number of lines(%d) exceeded maximum(%d) ##\n", total_lines, MAX_LINES);
+		return -1;
+	}
+
+	/* Set lines status to on-hook */
+	memset(hook_state, 0, MAX_LINES);
+
+	cal_devs = 0;
+#ifdef LINE_CALIBRATION_SUPPORT
+	cal_lines = 0;
+#endif
+	/* Fill time slot table */
+	memset(time_slot_table, 0, MAX_LINES);
+	for(i = 0; i < total_lines; i++)
+		time_slot_table[i] = ((i+1) * pcm_bytes); /* skip slot #0 */
+
+	/* Extract PCM format */
+	switch(pcm_bytes)
+	{
+		case 1:
+			codec = VP_OPTION_ALAW;
+			break;
+		case 2:
+			codec = VP_OPTION_LINEAR;
+			break;
+		case 4:
+			codec = VP_OPTION_WIDEBAND;
+			break;
+		default:
+			codec = VP_OPTION_ALAW;
+			printf("## Warning, wrong PCM size - set to default(ALAW) ##\n");
+			break;
+	}
+
+#if defined(ZARLINK_SLIC_VE792)
+	/* Bring up the power supply */
+	if(vpapi_battary_on(VBH, VBL, VBP)) {
+		printf("## Error, VE792 power supply could not initialized properly ##\n");
+                return -1;
+	}
+#endif
+	/* Create max device objects */
+	for(dev_id = 0; dev_id < total_devs; dev_id++) {
+
+		status = vpapi_make_dev_object(VP_DEV_SERIES, dev_id);
+		if (status != VP_STATUS_SUCCESS) {
+			printf("## Error, device %d could not initialized properly(status=%d) ##\n", dev_id, status);
+			return -1;
+		}
+
+#if defined(ZARLINK_SLIC_VE792)
+		status = vpapi_map_slac_id(dev_id, 0);
+		if (status != VP_STATUS_SUCCESS) {
+			printf("## Error, SLAC %d could not be mapped(status=%d) ##\n", dev_id, status);
+			return -1;
+		}
+#endif
+		/* Create requested channels for each device */
+		while((line_id < ((dev_id+1)*MAX_DEVICE_LINES)) && (line_id < total_lines)) {
+			status = vpapi_make_line_object(VP_TERM_FXS_GENERIC, line_id);
+			if (status != VP_STATUS_SUCCESS) {
+				printf("## Error, line %d of device %d could not initialized \
+						properly(status=%d) ##\n", line_id, dev_id, status);
+				return -1;
+			}
+
+
+			/* Map unique LineId to LineCtx */
+			status = vpapi_map_line_id(line_id);
+
+			if (status != VP_STATUS_SUCCESS) {
+				printf("## Error, line %d for device %d could not \
+						mapped(status=%d) ##\n", line_id, dev_id, status);
+				return -1;
+			}
+			line_id++;
+		}
+
+		params.dev_size = dev_profile_size;
+		params.ac_size = ac_profile_size;
+		params.dc_size = dc_profile_size;
+		params.ring_size = ring_profile_size;
+		params.fxo_ac_size = 0;
+		params.fxo_cfg_size = 0;
+
+		if (pcm_bytes < 4)
+			status = vpapi_init_device(dev_id, DEV_PROFILE, AC_COEFF, DC_COEFF, RING_PROFILE, NULL, NULL, &params);
+		else
+			status = vpapi_init_device(dev_id, DEV_PROFILE, WB_AC_COEFF, DC_COEFF, RING_PROFILE, NULL, NULL, &params);
+
+		if (status != VP_STATUS_SUCCESS)
+		{
+			printf("## Error, device(%d) init failed(status=%d)\n", dev_id, status);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static inline void wait_for_vpapi_event(void)
+{
+	bool status;
+	VpEventType event;
+	VpDeviceIdType dev_id;
+
+	for(dev_id = 0; dev_id < total_devs ; dev_id++) {
+		while(vpapi_get_event(dev_id, &event) == true) {
+			switch(event.eventCategory) {
+				case VP_EVCAT_SIGNALING:
+					switch(event.eventId) {
+						case VP_LINE_EVID_HOOK_OFF:
+							if(cal_devs == total_devs) {
+								printf("off-hook(%d)\n", event.lineId);
+								hook_state[event.lineId] = 1;
+								offhook_count++;
+								vpapi_set_line_state(event.lineId, VP_LINE_TALK);
+							}
+							break;
+
+						case VP_LINE_EVID_HOOK_ON:
+							if(cal_devs == total_devs) {
+								printf("on-hook(%d)\n", event.lineId);
+								hook_state[event.lineId] = 0;
+								offhook_count--;
+								vpapi_set_line_state(event.lineId, VP_LINE_STANDBY);
+							}
+							break;
+
+						default:
+							/*printf("Unknown SIGNALING event[id-0x%x][lineId-%d]\n",event.eventId, event.lineId);*/
+							break;
+					}
+					break;
+
+				case VP_EVCAT_RESPONSE:
+					switch(event.eventId) {
+						case VP_DEV_EVID_DEV_INIT_CMP:
+							printf("Zarlink telephony device(%d) initialized successfully\n", event.deviceId);
+							vpapi_dev_init(event.deviceId);
+							cal_devs++;
+							break;
+
+						case VP_EVID_CAL_CMP:
+#ifdef LINE_CALIBRATION_SUPPORT
+							cal_lines++;
+							if(cal_lines == total_lines) {
+								/*VpOptionLoopbackType lp = VP_OPTION_LB_TIMESLOT;
+								vpapi_set_option(1, 0, 0, VP_OPTION_ID_LOOPBACK, &lp); */
+								printf("Zarlink telephony lines(%d) calibrated successfully\n", total_lines);
+								vpapi_init_done();
+							}
+#endif
+							break;
+
+						default:
+							/*printf("Unknown RESPONSE event[id-0x%x][lineId-%d]\n",event.eventId, event.lineId);*/
+							break;
+					}
+					break;
+
+				case VP_EVCAT_FAULT:
+					printf("Got FAULT event[id-0x%x][lineId-%d]\n",event.eventId, event.lineId);
+					break;
+
+				default:
+					printf("Got event[category-0x%x][id-%d]\n",event.eventCategory,event.eventId);
+					break;
+			}
+		}
+	}
+}
+
+static void vpapi_init_done(void)
+{
+	VpStatusType status;
+	VpDeviceIdType dev_id;
+	VpLineIdType line_id, base_line_id;
+
+	for (dev_id = 0; dev_id < total_devs; dev_id++)
+	{
+		base_line_id = (dev_id * MAX_DEVICE_LINES);
+		for (line_id = base_line_id; line_id < (base_line_id + MAX_DEVICE_LINES); line_id++)
+		{
+			/* Set CODEC options */
+			status = vpapi_set_option(1, line_id, dev_id, VP_OPTION_ID_CODEC, &codec);
+			if(status != VP_STATUS_SUCCESS)
+			{
+				printf("## Error setting VP_OPTION_ID_CODEC (%d) ##\n", status);
+				return;
+			}
+		}
+	}
+
+	return;
+}
+
+static void vpapi_dev_init(VpDeviceIdType dev_id)
+{
+	VpOptionEventMaskType event_mask;
+	VpStatusType status;
+	VpOptionTimeslotType time_slot;
+	VpLineIdType line_id;
+
+	/* Clear all events */
+	memset(&event_mask, 0xff, sizeof(VpOptionEventMaskType));
+
+	event_mask.faults = (unsigned short)VP_EVCAT_FAULT_UNMASK_ALL;
+	event_mask.signaling = (unsigned short)(~(VP_LINE_EVID_HOOK_OFF | VP_LINE_EVID_HOOK_ON));
+#ifdef LINE_CALIBRATION_SUPPORT
+	event_mask.response = (unsigned short)(~VP_EVID_CAL_CMP);
+#endif
+	status = vpapi_set_option(0, N_A, dev_id, VP_OPTION_ID_EVENT_MASK, &event_mask);
+	if(status != VP_STATUS_SUCCESS)
+	{
+		printf("## Error while setting VP_OPTION_ID_EVENT_MASK (%d) ##\n", status);
+		return;
+	}
+
+	line_id = (dev_id * MAX_DEVICE_LINES);
+	while((line_id < ((dev_id+1)*MAX_DEVICE_LINES)) && (line_id < total_lines)) {
+
+		vpapi_set_line_state(line_id, VP_LINE_STANDBY);
+
+		/* Configure PCM timeslots */
+		time_slot.tx = time_slot.rx = time_slot_table[line_id];
+
+		/*printf("## INFO: line(%d): rx-slot(%d) , tx-slot(%d) ##\n", line_id, time_slot.rx, time_slot.tx);*/
+
+		status = vpapi_set_option(1, line_id, dev_id, VP_OPTION_ID_TIMESLOT, &time_slot);
+		if(status != VP_STATUS_SUCCESS)
+		{
+			printf("## Error setting VP_OPTION_ID_TIMESLOT (%d) ##\n", status);
+			return;
+		}
+#if 0
+		/* Set CODEC options */
+		status = vpapi_set_option(1, line_id, dev_id, VP_OPTION_ID_CODEC, &codec);
+		if(status != VP_STATUS_SUCCESS)
+		{
+			printf("## Error setting VP_OPTION_ID_CODEC (%d) ##\n", status);
+			return;
+		}
+#endif
+#ifdef LINE_CALIBRATION_SUPPORT
+		/* Start line calibration */
+		vpapi_cal_line(line_id);
+#endif
+		line_id++;
+	}
+}
+
+static void vpapi_release(void)
+{
+	VpDeviceIdType dev_id = 0;
+	VpLineIdType line_id = 0;
+	VpOptionEventMaskType event_mask;
+	VpStatusType status;
+
+
+	/* Clear all events */
+	memset(&event_mask, 0xff, sizeof(VpOptionEventMaskType));
+
+	for(dev_id = 0; dev_id < total_devs; dev_id++) {
+		/* Mask all interrupts */
+		status = vpapi_set_option(0, N_A, dev_id, VP_OPTION_ID_EVENT_MASK, &event_mask);
+
+		if(status != VP_STATUS_SUCCESS) {
+			printf("Error while setting VP_OPTION_ID_EVENT_MASK (%d)\n", status);
+			continue;
+		}
+
+		while((line_id < ((dev_id+1)*MAX_DEVICE_LINES)) && (line_id < total_lines)) {
+			/* Place each line in DISCONNECT state */
+			vpapi_set_line_state(line_id, VP_LINE_DISCONNECT);
+
+			/* Free line context */
+			status = vpapi_free_line_context(line_id);
+			if(status != VP_STATUS_SUCCESS)
+			{
+				printf("Error while free line %d context\n", line_id);
+				continue;
+			}
+			line_id++;
+		}
+	}
+#if defined(ZARLINK_SLIC_VE792)
+	/* Shut down the power supply */
+	if(vpapi_battery_off()) {
+		printf("## Error while shutting down VE792 power supply ##\n");
+		sleep(1);
+	}
+#endif
+}
diff --git a/tools/voice/mv_voice_tool.h b/tools/voice/mv_voice_tool.h
new file mode 100644
index 0000000..82473d3
--- /dev/null
+++ b/tools/voice/mv_voice_tool.h
@@ -0,0 +1,84 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#ifndef _MVZARLINKIF_H_
+#define _MVZARLINKIF_H_
+
+#include "mvSysTdmConfig.h"
+#include "voiceband/mvSysTdmSpi.h"
+
+MV_STATUS mvZarlinkIfInit(MV_U16 totalSLICs, MV_U16 pSlotInfo[][2],
+				MV_BAND_MODE bandMode, MV_PCM_FORMAT pcmFormat);
+MV_STATUS mvZarlinkIfTimerTick(MV_SLIC_EVENT_INFO* slic_event_info);
+MV_VOID mvZarlinkIfISR(MV_U8 deviceId);
+MV_VOID mvZarlinkIfActivateRinging(MV_U16 lineId);
+MV_VOID mvZarlinkIfStopRinging(MV_U16 lineId);
+MV_VOID mvZarlinkIfHookStateGet(MV_U16 lineId, MV_U8* hookstate);
+MV_VOID mvZarlinkIfLinefeedControlSet(MV_U16 lineId, MV_LINEFEED_STATE lfState);
+MV_VOID mvZarlinkIfLinefeedControlGet(MV_U16 lineId, MV_LINEFEED_STATE* lfState);
+MV_VOID mvZarlinkIfReverseDcPolarity(MV_U16 lineId);
+MV_VOID mvZarlinkIfRelease(MV_VOID);
+MV_VOID mvZarlinkIfRegRead(MV_U8 lineId, MV_U8 cmd, MV_U8 cmdLen,MV_U8* dataBuff);
+
+#endif /* _MVZARLINKIF_H_ */
diff --git a/tools/voice/profile_79238.c b/tools/voice/profile_79238.c
new file mode 100644
index 0000000..4483f39
--- /dev/null
+++ b/tools/voice/profile_79238.c
@@ -0,0 +1,1248 @@
+/*
+ * profile_79238.c --
+ *
+ * This file contains profile data in byte format
+ *
+ * Project Info --
+ *   File:  C:\Documents and Settings\benavi\Desktop\profile_792\792.vpw
+ *   Type:  VCP2-792 Project (Line Module Le51HR0128)
+ *   Date:  Wednesday, June 30, 2010 14:29:56
+ *
+ *   This file was generated with Profile Wizard Version: P1.14.1
+ */
+
+#include "profile_79238.h"
+
+/*** Device_Parameters for VE792 Device Family ***/
+const VpProfileDataType VE792_DEV_PROFILE[] =
+{
+    /* Device Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0xFF,       /* 0xFF = device profile */
+        /* number of sections */    0x02,
+        /* content length */        0x24,        /* (2 + 5) + (2 + 27)      */
+    /* Section 0 ----------------------------------------------(PRE-BOOT)-- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x05,
+        /* Access 0 */
+            /* access type */       0x00,       /* 0x00 = direct page write */
+            /* page offset */       0x0B,       /* CLK_CFG register */
+            /* length */            0x01,
+            /* data */              0x00, 0x0A, /* PCLK = 8192 KHz */
+    /* Section 1 ---------------------------------------------(POST-BOOT)-- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x1B,       /* 5 + 11 + 11 */
+        /* Access 0 */
+            /* access type */       0x00,       /* 0x00 = direct page write */
+            /* page offset */       0x09,       /* PCM_CFG register */
+            /* length */            0x01,
+            /* data */              0x00, 0x40, /* Pos. edge, RCS 0, TCS 0 */
+        /* Access 1 */
+            /* access type */       0x00,       /* 0x00 = direct page write */
+            /* page offset */       0x32,       /* HBAT_ADJ + TBAT register */
+            /* length */            0x04,
+            /* data */              0x00, 0x00, /* HBAT_ADJ = 0 V */
+            /* data */              0xEC, 0xCD, /* THBAT = -30 V */
+            /* data */              0xF6, 0x66, /* TLBAT = -15 V */
+            /* data */              0x13, 0x33, /* TPBAT = 30 V */
+        /* Access 2 */
+            /* access type */       0x00,       /* 0x00 = direct page write */
+            /* page offset */       0x38,
+            /* length */            0x04,
+            /* data */              0x7F, 0xFF,
+            /* data */              0x7F, 0xFF,
+            /* data */              0x7F, 0xFF,
+            /* data */              0x00, 0x00
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/************** AC_Coefficients **************/
+
+/* AC Parameters (600) */
+const VpProfileDataType VE792_AC_COEFF_600[] =
+{
+    /* AC Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x00,       /* 0x00 = AC profile */
+        /* number of sections */    0x01,
+        /* content length */        0x74,     /* (2 + 81) + 1 + 32 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x01,       /* 0x01 = mailbox command */
+        /* content length */        0x51,       /* 81 */
+        /* command ID */            0x2A,       /* 0x2A = WR_AC_PARAM */
+        /* data */
+            /* AC_MASK */           0x01, 0xFF,
+            /* Z FIR */             0x00, 0x22, 0xBA, 0x74, 0x45, 0x3E, 0x33,
+                                    0x5A, 0x24, 0xDC, 0x4B,
+            /* Z IIR */             0x22, 0x22, 0x97, 0x9F, 0x01,
+            /* GR */                0xA2, 0xA0,
+            /* R IIR */             0xDC, 0x01,
+            /* R FIR */             0x2A, 0x10, 0xAD, 0xC9, 0x22, 0x27, 0x22,
+                                    0x52, 0x3F, 0xBA, 0xC3, 0xB4,
+            /* B FIR */             0x00, 0x3C, 0x7A, 0x4B, 0xAF, 0x9A, 0xA9,
+                                    0xC6, 0xBA, 0x37, 0x24, 0x6B, 0x8F, 0x3B,
+                                    0x70,
+            /* B IIR */             0x2E, 0x01,
+            /* GX */                0x3A, 0x30,
+            /* X FIR */             0x3D, 0x20, 0x9F, 0x2A, 0xA3, 0x4E, 0x4B,
+                                    0x23, 0x52, 0xAB, 0xBB, 0x97, 0x00,
+            /* AISN */              0x00, 0x05,
+            /* DISN */              0x00, 0x01, 0x00, 0x07, 0x00, 0x6F, 0x00,
+                                    0x1C, 0x00, 0x80,
+            /* MTR_CFG */           0x00, 0x00,
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00,         /* VP_CFG2 bit LRG = 0 */
+        /* Meter LUT */             0x11, 0x5F,   /* Shadow Register 1 12KHz 2/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x2F,   /* Shadow Register 1 12KHz 4/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x77,   /* Shadow Register 1 12KHz 6/8 */
+                                    0x08, 0x0C,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x77,   /* Shadow Register 1 12KHz 8/8 */
+                                    0x0C, 0x12,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x9F,   /* Shadow Register 1 16KHz 2/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x67,   /* Shadow Register 1 16KHz 4/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x2F,   /* Shadow Register 1 16KHz 6/8 */
+                                    0x08, 0x0C,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x2F,   /* Shadow Register 1 16KHz 8/8 */
+                                    0x0C, 0x12    /* Shadow Register 2 */
+
+};
+
+/* AC Parameters (900) */
+const VpProfileDataType AC_COEFF_900[] =
+{
+    /* AC Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x00,       /* 0x00 = AC profile */
+        /* number of sections */    0x01,
+        /* content length */        0x74,     /* (2 + 81) + 1 + 32 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x01,       /* 0x01 = mailbox command */
+        /* content length */        0x51,       /* 81 */
+        /* command ID */            0x2A,       /* 0x2A = WR_AC_PARAM */
+        /* data */
+            /* AC_MASK */           0x01, 0xFF,
+            /* Z FIR */             0x00, 0x4A, 0xCA, 0xBD, 0xA5, 0x43, 0x23,
+                                    0x2B, 0xA3, 0xC2, 0x3B,
+            /* Z IIR */             0xA3, 0xA1, 0x97, 0x9F, 0x01,
+            /* GR */                0xA2, 0xB0,
+            /* R IIR */             0xDC, 0x01,
+            /* R FIR */             0x3A, 0x10, 0xAD, 0xD9, 0xC3, 0xA7, 0x42,
+                                    0x42, 0xA3, 0xBA, 0x2B, 0xA4,
+            /* B FIR */             0x00, 0xAA, 0x73, 0x4B, 0x2F, 0x9B, 0xA9,
+                                    0xA5, 0xB3, 0xA6, 0x2A, 0x5C, 0x87, 0xCA,
+                                    0x70,
+            /* B IIR */             0x2E, 0x01,
+            /* GX */                0xA3, 0xA0,
+            /* X FIR */             0x27, 0x20, 0xC2, 0x2A, 0x4A, 0x2E, 0x23,
+                                    0x23, 0x22, 0x2C, 0x2A, 0x87, 0x00,
+            /* AISN */              0x00, 0x0A,
+            /* DISN */              0x00, 0x01, 0x00, 0x07, 0x00, 0x72, 0x00,
+                                    0x35, 0x00, 0x80,
+            /* MTR_CFG */           0x00, 0x00,
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00,         /* VP_CFG2 bit LRG = 0 */
+        /* Meter LUT */             0x11, 0x5F,   /* Shadow Register 1 12KHz 2/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x2F,   /* Shadow Register 1 12KHz 4/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x77,   /* Shadow Register 1 12KHz 6/8 */
+                                    0x08, 0x0C,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x77,   /* Shadow Register 1 12KHz 8/8 */
+                                    0x0C, 0x12,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x9F,   /* Shadow Register 1 16KHz 2/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x67,   /* Shadow Register 1 16KHz 4/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x2F,   /* Shadow Register 1 16KHz 6/8 */
+                                    0x08, 0x0C,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x2F,   /* Shadow Register 1 16KHz 8/8 */
+                                    0x0C, 0x12    /* Shadow Register 2 */
+
+};
+
+/************** DC_Parameters **************/
+
+/* DC Parameters */
+const VpProfileDataType VE792_DC_COEFF[] =
+{
+    /* DC Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x01,       /* 0x01 = DC profile */
+        /* number of sections */    0x02,
+        /* content length */        0x25,       /* (2 + 13) + (2 + 20) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x01,       /* 0x01 = mailbox command */
+        /* content length */        0x0D,       /* 13 */
+        /* command ID */            0x2C,       /* 0x2C = WR_DC_PARAM */
+        /* data */                  0x11, 0x11, /* V1 */
+        /* data */                  0x11, 0xEC, /* VAS */
+        /* data */                  0x01, 0x1C, /* VAS_OFFSET */
+        /* data */                  0x55, 0x55, /* RFD */
+        /* data */                  0x80, 0x00, /* RPTC */
+        /* data */                  0x49, 0x25, /* ILA */
+    /* Section 1 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x14,       /* 20 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x33,       /* LOOP_SUP register */
+            /* length */            0x06,
+            /* data */              0xF3, 0x33, /* TGK */
+            /* data */              0x00, 0xC8, /* PGK */
+            /* data */              0x0B, 0xB8, /* TSH */
+            /* data */              0x00, 0x1E, /* DSH */
+            /* data */              0x40, 0x00, /* IFTA */
+            /* data */              0x0C, 0xCD, /* IFTD */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x3C,       /* LOOP_SUP register, HSH */
+            /* length */            0x01,
+            /* data */              0x03, 0xE8  /* HSH */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/************** Ring_Parameters **************/
+
+/* Ringing 20Hz, Sine Wave, 40Vrms */
+const VpProfileDataType RING_20HZ_SINE[] =
+{
+    /* Ring Profile */
+    /* Balanced, Sinusoidal, Crest Factor 1.4142 */
+    /* 20 Hz, 82.86 Vpk, 15.33 V Tip Bias, 4.67 V Ring Bias */
+    /* Ring Trip: Short Loop 41.9 mA, Long Loop 8 mA */
+    /*            Current Spike Threshold 100 mA */
+    /*            Averaging Period 50 ms */
+    /* Ring Exit Hook Switch Debounce: Threshold 0 ms, Duration 0 ms */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x04,       /* 0x04 = ringing profile */
+        /* number of sections */    0x01,
+        /* content length */        0x22,       /* (2 + 32) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x20,       /* 32 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x22,       /* RING register */
+            /* length */            0x0B,       /* 11 */
+            /* data */              0x30, 0x00, /* R control / FRQR[23:16] */
+            /* data */              0xA3, 0xD7, /* FRQR[15:0] */
+            /* data */              0x46, 0xB6, /* AMPR */
+            /* data */              0x0D, 0x15, /* RBA */
+            /* data */              0x03, 0xFC, /* RBB */
+            /* data */              0x04, 0x05, /* EBR */
+            /* data */              0x35, 0xAB, /* RTSL */
+            /* data */              0x0A, 0x3D, /* RTLL */
+            /* data */              0x00, 0x19, /* RTAP */
+            /* data */              0x00, 0x00, /* RSVD */
+            /* data */              0x7F, 0xFF, /* IST */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x3A,       /* REDSH, REDD */
+            /* length */            0x02,
+            /* data */              0x00, 0x00, /* REDSH */
+            /* data */              0x00, 0x00  /* REDD */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Ringing 25Hz, Sine Wave, 40Vrms */
+const VpProfileDataType RING_25HZ_SINE[] =
+{
+    /* Ring Profile */
+    /* Balanced, Sinusoidal, Crest Factor 1.4142 */
+    /* 25 Hz, 66.31 Vpk, 15.33 V Tip Bias, 4.67 V Ring Bias */
+    /* Ring Trip: Short Loop 19 mA, Long Loop 8 mA */
+    /*            Current Spike Threshold 100 mA */
+    /*            Averaging Period 40 ms */
+    /* Ring Exit Hook Switch Debounce: Threshold 0 ms, Duration 0 ms */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x04,       /* 0x04 = ringing profile */
+        /* number of sections */    0x01,
+        /* content length */        0x22,       /* (2 + 32) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x20,       /* 32 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x22,       /* RING register */
+            /* length */            0x0B,       /* 11 */
+            /* data */              0x30, 0x00, /* R control / FRQR[23:16] */
+            /* data */              0xCC, 0xCD, /* FRQR[15:0] */
+            /* data */              0x38, 0x97, /* AMPR */
+            /* data */              0x0D, 0x15, /* RBA */
+            /* data */              0x03, 0xFC, /* RBB */
+            /* data */              0x04, 0x05, /* EBR */
+            /* data */              0x18, 0x49, /* RTSL */
+            /* data */              0x0A, 0x3D, /* RTLL */
+            /* data */              0x00, 0x14, /* RTAP */
+            /* data */              0x00, 0x00, /* RSVD */
+            /* data */              0x7F, 0xFF, /* IST */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x3A,       /* REDSH, REDD */
+            /* length */            0x02,
+            /* data */              0x00, 0x00, /* REDSH */
+            /* data */              0x00, 0x00  /* REDD */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/************** Call_Progress_Tones **************/
+
+/* US Dial Tone */
+const VpProfileDataType TONE_DIAL[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0B,
+            /* data */              0x33, 0x33, /* FreqA = 350Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x0E, 0x14, /* FreqB = 440Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* US Ringback Tone */
+const VpProfileDataType TONE_RINGBACK[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0E,
+            /* data */              0x14, 0x7B, /* FreqA = 440Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x0F, 0x5C, /* FreqB = 480Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* US Busy Tone */
+const VpProfileDataType TONE_BUSY[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0F,
+            /* data */              0x5C, 0x29, /* FreqA = 480Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x13, 0xD7, /* FreqB = 620Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* US Reorder Tone */
+const VpProfileDataType TONE_REORDER[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0F,
+            /* data */              0x5C, 0x29, /* FreqA = 480Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x13, 0xD7, /* FreqB = 620Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* US Howler Tone (ROH) */
+const VpProfileDataType TONE_US_HOWLER[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x2C,
+            /* data */              0xCC, 0xCD, /* FreqA = 1400Hz */
+            /* data */              0x58, 0xD6, /* AmpA  = 0dBm0 */
+            /* data */              0x41, 0xEC, /* FreqB = 2060Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x4E, 0x66, /* FreqC = 2450Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x53, 0x33, /* FreqD = 2600Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x0F  /* Generator control = ABCD */
+};
+
+/* UK Howler Tone */
+const VpProfileDataType TONE_UK_HOWLER[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x13,       /* (2 + 15) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0F,       /* 15 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x02,       /* SIG_GEN register */
+            /* length */            0x06,
+            /* data */              0x34, 0xCD, /* 1650Hz Offset */
+            /* data */              0x20, 0x00, /* Periodic, Linear */
+            /* data */              0x08, 0x31, /* FreqA = 1Hz */
+            /* data */              0x1B, 0x33, /* AmpA = 850Hz */
+            /* data */              0x80, 0x00, /* FreqB = Freq Modulated */
+            /* data */              0x00, 0x00, /* AmpB = Sequence control */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x13  /* Generators = Bias+AB */
+};
+
+/* Australia Howler Tone */
+const VpProfileDataType TONE_AUS_HOWLER[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x13,       /* (2 + 15) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0F,       /* 15 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x02,       /* SIG_GEN register */
+            /* length */            0x06,
+            /* data */              0x4B, 0x33, /* 2350Hz Offset */
+            /* data */              0x20, 0x00, /* Periodic, Linear */
+            /* data */              0x08, 0x31, /* FreqA = 1Hz */
+            /* data */              0x1B, 0x33, /* AmpA = 850Hz */
+            /* data */              0x80, 0x00, /* FreqB = Freq Modulated */
+            /* data */              0x00, 0x00, /* AmpB = Sequence control */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x13  /* Generators = Bias+AB */
+};
+
+/* Japan Howler Tone */
+const VpProfileDataType TONE_NTT_HOWLER[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x11,       /* (2 + 13) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0D,       /* 13 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x05,
+            /* data */              0x00, 0x00, /* One-shot, Linear */
+            /* data */              0x00, 0x23, /* FreqA = 15s Ramp */
+            /* data */              0x7F, 0xFF, /* AmpA = Maximum */
+            /* data */              0x0C, 0xCD, /* FreqB = 400Hz */
+            /* data */              0x80, 0x00, /* AmpB = Ampl Modulated */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* Special Information Tone (Called Number Not Connected) */
+const VpProfileDataType TONE_SIT[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x1E,
+            /* data */              0x66, 0x66, /* FreqA = 950Hz */
+            /* data */              0x23, 0x5D, /* AmpA  = -8dBm0 */
+            /* data */              0x2C, 0xCD, /* FreqB = 1400Hz */
+            /* data */              0x23, 0x5D, /* AmpB  = -8dBm0 */
+            /* data */              0x39, 0x9A, /* FreqC = 1800Hz */
+            /* data */              0x23, 0x5D, /* AmpC  = -8dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x07  /* Generator control = ABC */
+};
+
+/* A 1kHz tone at -10dBm0 */
+const VpProfileDataType TONE_ONEKHZ_L[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x20,
+            /* data */              0x00, 0x00, /* FreqA = 1000Hz */
+            /* data */              0x1C, 0x17, /* AmpA  = -10dBm0 */
+            /* data */              0x00, 0x00, /* FreqB = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x01  /* Generator control = A */
+};
+
+/* A 1kHz tone at 0dBm0 */
+const VpProfileDataType TONE_ONEKHZ_H[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x20,
+            /* data */              0x00, 0x00, /* FreqA = 1000Hz */
+            /* data */              0x58, 0xD6, /* AmpA  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqB = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x01  /* Generator control = A */
+};
+
+/* Call Waiting Beep */
+const VpProfileDataType TONE_CALLWAIT[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0E,
+            /* data */              0x14, 0x7B, /* FreqA = 440Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqB = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x01  /* Generator control = A */
+};
+
+/* Caller ID Alert Tone */
+const VpProfileDataType TONE_CLI[] =
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x44,
+            /* data */              0x28, 0xF6, /* FreqA = 2130Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x58, 0x00, /* FreqB = 2750Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/************** Cadence_Definitions **************/
+
+/* US Dial Tone Cadence */
+const VpProfileDataType TONE_CAD_DIAL[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x06,       /* (2 + 4) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x04,       /* 4 */
+        /* data */                  0x00, 0x00, /* sequence length = 1 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Stutter Dial Tone Cadence */
+const VpProfileDataType TONE_CAD_STUTTER[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x10,       /* (2 + 14) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0E,       /* 14 */
+        /* data */                  0x00, 0x05, /* sequence length = 6 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+        /* data */                  0x40, 0x64, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x40, 0x64, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x60, /* 04 - Branch to 00 */
+        /* data */                  0x05, 0x03, /* 05 - Generator Ctrl */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* US Ringback Tone Cadence */
+const VpProfileDataType TONE_CAD_RINGBACK[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x0E,       /* (2 + 12) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+        /* data */                  0x47, 0xD0, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x4F, 0xA0, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* US Busy Tone Cadence */
+const VpProfileDataType TONE_CAD_BUSY[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x0E,       /* (2 + 12) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+        /* data */                  0x41, 0xF4, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x41, 0xF4, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* US Reorder Tone Cadence */
+const VpProfileDataType TONE_CAD_REORDER[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x0E,       /* (2 + 12) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+        /* data */                  0x40, 0xFA, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x40, 0xFA, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* US Howler Tone Cadence (ROH) */
+const VpProfileDataType TONE_CAD_US_HOWLER[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x0E,       /* (2 + 12) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x05, 0x0F, /* 00 - Generator Ctrl */
+        /* data */                  0x40, 0x64, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x40, 0x64, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* UK Howler Tone Cadence */
+const VpProfileDataType TONE_CAD_UK_HOWLER[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = Tone cadence prof */
+        /* number of sections */    0x01,
+        /* content length */        0x38,       /* (2 + 54) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x36,       /* 54 */
+        /* data */                  0x00, 0x19, /* sequence length = 26 */
+        /* data */                  0x05, 0x13,
+        /* data */                  0x82, 0x04,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x82, 0x8A,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x83, 0x33,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x84, 0x07,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x85, 0x12,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x86, 0x62,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x88, 0x09,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x8A, 0x1E,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x8C, 0xBD,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x90, 0x09,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x94, 0x30,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x99, 0x6A,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x9F, 0xFF
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Australia Howler Tone Cadence */
+const VpProfileDataType TONE_CAD_AUS_HOWLER[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = Tone cadence prof */
+        /* number of sections */    0x01,
+        /* content length */        0x44,       /* (2 + 66) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x42,       /* 66 */
+        /* data */                  0x00, 0x1F, /* sequence length = 32 */
+        /* data */                  0x05, 0x13,
+        /* data */                  0x81, 0x03,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x81, 0x46,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x81, 0x9B,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x82, 0x05,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x82, 0x8B,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x83, 0x33,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x84, 0x07,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x85, 0x12,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x86, 0x62,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x88, 0x0A,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x8A, 0x1E,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x8C, 0xBD,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x90, 0x0A,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x94, 0x31,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x99, 0x6B,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x9F, 0xFF
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Japan Howler Tone Cadence */
+const VpProfileDataType TONE_CAD_NTT_HOWLER[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x06,       /* (2 + 4) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x04,       /* 4 */
+        /* data */                  0x00, 0x00, /* sequence length = 1 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Special Information Tone Cadence */
+const VpProfileDataType TONE_CAD_SIT[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x12,       /* (2 + 16) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x10,       /* 16 */
+        /* data */                  0x00, 0x06, /* sequence length = 7 */
+        /* data */                  0x05, 0x01, /* 00 - Generator Ctrl */
+        /* data */                  0x41, 0x2C, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x02, /* 02 - Generator Ctrl */
+        /* data */                  0x41, 0x2C, /* 03 - Sequential Delay */
+        /* data */                  0x05, 0x04, /* 04 - Generator Ctrl */
+        /* data */                  0x41, 0x2C, /* 05 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 06 - Generator Ctrl */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Standard Ringing Cadence */
+const VpProfileDataType RING_CAD_STD[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x08,       /* 0x08 = ring cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x12,       /* (2 + 16) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x10,       /* 16 */
+        /* data */                  0x00, 0x06, /* sequence length = 7 */
+        /* data */                  0x02, 0x86, /* 00 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x47, 0xD0, /* 01 - Sequential Delay */
+        /* data */                  0x02, 0x83, /* 02 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x4F, 0xA0, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Ringing Cadence with CallerID */
+const VpProfileDataType RING_CAD_CID[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x08,       /* 0x08 = ring cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x28,       /* (2 + 38) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x26,       /* 38 */
+        /* data */                  0x00, 0x11, /* sequence length = 18 */
+        /* data */                  0x02, 0x86, /* 00 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x47, 0xD0, /* 01 - Sequential Delay */
+        /* data */                  0x02, 0x83, /* 02 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x0A, 0x00, /* 03 - Relative Time Marker */
+        /* data */                  0x40, 0xC8, /* 04 - Sequential Delay */
+        /* data */                  0x02, 0x85, /* 05 - Line State */
+        /* data */                  0x01, 0x3A,
+        /* data */                  0x01, 0x22, /* 06 - Start CallerID */
+        /* data */                  0x6F, 0xA0, /* 07 - Relative Delay */
+        /* data */                  0x02, 0x86, /* 08 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x47, 0xD0, /* 09 - Sequential Delay */
+        /* data */                  0x02, 0x83, /* 10 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x4F, 0xA0, /* 11 - Sequential Delay */
+        /* data */                  0x10, 0x0B, /* 12 - Branch to 08 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Ringing Always On */
+const VpProfileDataType RING_CAD_ON[] =
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x08,       /* 0x08 = ring cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x08,       /* (2 + 6) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x06,       /* 6 */
+        /* data */                  0x00, 0x01, /* sequence length = 2 */
+        /* data */                  0x02, 0x86, /* 00 - Line State */
+        /* data */                  0x01, 0x3B,
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/************** Caller_ID **************/
+
+/* US Caller ID Type II */
+const VpProfileDataType CID_TYPE2_US[] =
+{
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x05,       /* 0x05 = caller ID profile */
+        /* number of sections */    0x04,
+        /* content length */        0x70,       /* 112 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequencer program */
+        /* content length */        0x24,       /* 36 */
+        /* data */                  0x00, 0x10, /* sequence length = 17 */
+        /* data */                  0x01, 0x3B, /* Mute on */
+        /* data */                  0x01, 0x3D, /* Alert tone 300ms */
+        /* data */                  0x41, 0x2C, /* - TONE_CALLWAIT */
+        /* data */                  0x05, 0x00,
+        /* data */                  0x40, 0x0A, /* Silence 10ms */
+        /* data */                  0x01, 0x3E, /* Alert tone 80ms */
+        /* data */                  0x40, 0x50, /* - TONE_CLI */
+        /* data */                  0x05, 0x00,
+        /* data */                  0x01, 0x32, /* Detect interval 160ms */
+        /* data */                  0x40, 0xA0, /* - Tones: A, D */
+        /* data */                  0x09, 0xB2,
+        /* data */                  0x40, 0x64, /* Silence 100ms */
+        /* data */                  0x01, 0x26, /* Send FSK */
+        /* data */                  0x0B, 0x01,
+        /* data */                  0x09, 0x00,
+        /* data */                  0x01, 0x27,
+        /* data */                  0x01, 0x3A, /* Mute off */
+    /* Section 1 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0E,       /* 14 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x1F,       /* FSK_GEN register */
+            /* length */            0x01,
+            /* data */              0x00, 0x04, /* stop = 1, start = 0 */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x10,       /* FSK_GEN register */
+            /* length */            0x03,
+            /* data */              0x29, 0x9A, /* mark freq. 1300Hz  */
+                                    0x43, 0x33, /* space freq. 2100Hz */
+                                    0x12, 0xC6, /* amplitude = -13.5dBm0 */
+    /* Section 2 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x17,       /* 23 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x0A,       /* 10 */
+            /* data */              0x30, 0x0E,
+            /* data */              0x14, 0x7B, /* FreqA = 440Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqB = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+            /* data */              0x00, 0x01, /* Generator control = A */
+    /* Section 3 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x17,       /* 23 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x0A,       /* 10 */
+            /* data */              0x30, 0x44,
+            /* data */              0x28, 0xF6, /* FreqA = 2130Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x58, 0x00, /* FreqB = 2750Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+            /* data */              0x00, 0x03, /* Generator control = AB */
+    /* Unstructured data -------------------------------------------------- */
+                                    0x00, 0x00, /* 0-bit channel seizure */
+                                    0x00, 0x58, /* 88-bit mark period */
+                                    0x00, 0x0D, /* Detect Tones A, D */
+                                    0x01,       /* API checksum */
+                                    0x00        /* FSK Message Data */
+};
+
+/* UK Caller ID Type I */
+const VpProfileDataType CID_TYPE1_UK[] =
+{
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x05,       /* 0x05 = caller ID profile */
+        /* number of sections */    0x03,
+        /* content length */        0x55,       /* 85 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequencer program */
+        /* content length */        0x22,       /* 34 */
+        /* data */                  0x00, 0x0F, /* sequence length = 16 */
+        /* data */                  0x40, 0x32, /* Silence 50ms */
+        /* data */                  0x03, 0x00, /* Line Reversal */
+        /* data */                  0x40, 0x64, /* Silence 100ms */
+        /* data */                  0x01, 0x3D, /* Alert tone 100ms */
+        /* data */                  0x40, 0x64, /* - TONE_CLI */
+        /* data */                  0x05, 0x00,
+        /* data */                  0x01, 0x2F, /* Mask hooks 20ms, */
+        /* data */                  0x40, 0x14, /*    Silence 100ms */
+        /* data */                  0x01, 0x2F,
+        /* data */                  0x40, 0x50,
+        /* data */                  0x01, 0x26, /* Send FSK */
+        /* data */                  0x0B, 0x01,
+        /* data */                  0x09, 0x00,
+        /* data */                  0x01, 0x27,
+        /* data */                  0x40, 0xC8, /* Silence 200ms */
+        /* data */                  0x03, 0x00, /* Line Reversal */
+    /* Section 1 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0E,       /* 14 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x1F,       /* FSK_GEN register */
+            /* length */            0x01,
+            /* data */              0x00, 0x04, /* stop = 1, start = 0 */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x10,       /* FSK_GEN register */
+            /* length */            0x03,
+            /* data */              0x29, 0x9A, /* mark freq. 1300Hz  */
+                                    0x43, 0x33, /* space freq. 2100Hz */
+                                    0x27, 0xAE, /* amplitude = -7dBm0 */
+    /* Section 2 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x17,       /* 23 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x0A,       /* 10 */
+            /* data */              0x30, 0x44,
+            /* data */              0x28, 0xF6, /* FreqA = 2130Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x58, 0x00, /* FreqB = 2750Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+            /* data */              0x00, 0x03, /* Generator control = AB */
+    /* Unstructured data -------------------------------------------------- */
+                                    0x00, 0x78, /* 120-bit channel seizure */
+                                    0x00, 0x40, /* 64-bit mark period */
+                                    0x00, 0x00,
+                                    0x01,       /* API checksum */
+                                    0x00        /* FSK Message Data */
+};
+
+/* US Caller ID (Type 1 - On-Hook) */
+const VpProfileDataType CLI_TYPE1_US[] =
+{
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x05,       /* 0x05 = caller ID profile */
+        /* number of sections */    0x02,
+        /* content length */        0x26,       /* 38 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequencer program */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x42, 0x08, /* Silence 520ms */
+        /* data */                  0x01, 0x26, /* Send FSK */
+        /* data */                  0x0B, 0x01,
+        /* data */                  0x09, 0x00,
+        /* data */                  0x01, 0x27,
+    /* Section 1 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0E,       /* 14 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x1F,       /* FSK_GEN register */
+            /* length */            0x01,
+            /* data */              0x00, 0x04, /* stop = 1, start = 0 */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x10,       /* FSK_GEN register */
+            /* length */            0x03,
+            /* data */              0x26, 0x66, /* mark freq. 1200Hz  */
+                                    0x46, 0x66, /* space freq. 2200Hz */
+                                    0x27, 0xAE, /* amplitude = -7dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+                                    0x01, 0x30, /* 304-bit channel seizure */
+                                    0x00, 0xB8, /* 184-bit mark period */
+                                    0x00, 0x00,
+                                    0x01,       /* API checksum */
+                                    0x00        /* FSK Message Data */
+};
+
+/************** Metering_Profile **************/
+
+/* Metering Profile 12 kHz Tone */
+const VpProfileDataType METER_12KHZ[] =
+{
+    /* Metering Profile */
+    /* 12KHz Tone Metering */
+    /* Ramp Time: 10ms, Amplitude: 2000mVrms (Normal Gain) */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x07,       /* 0x07 = Metering profile */
+        /* number of sections */    0x00,
+        /* content length */        0x06,
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x02, /* MTR_TYPE */
+        /* data */                  0x00, 0x0A, /* RAMP_TIME */
+        /* data */                  0x09, 0x94  /* RAMP_STEP */
+};
+
+/* Metering Profile Polarity Reversal */
+const VpProfileDataType METER_POLREV[] =
+{
+    /* Metering Profile */
+    /* Polrev Pulse Metering */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x07,       /* 0x07 = Metering profile */
+        /* number of sections */    0x00,
+        /* content length */        0x02,
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x00  /* MTR_TYPE */
+};
+
+int dev_profile_size = sizeof(VE792_DEV_PROFILE);
+int dc_profile_size = sizeof(VE792_DC_COEFF);
+int ac_profile_size = sizeof(VE792_AC_COEFF_600);
+int ring_profile_size = sizeof(RING_20HZ_SINE);
+
+/* end of file profile_79238.c */
diff --git a/tools/voice/profile_79238.h b/tools/voice/profile_79238.h
new file mode 100644
index 0000000..1e27ce3
--- /dev/null
+++ b/tools/voice/profile_79238.h
@@ -0,0 +1,82 @@
+/*
+ * profile_79238.h --
+ *
+ * This header file exports the Profile data types
+ *
+ * Project Info --
+ *   File:  C:\Documents and Settings\benavi\Desktop\profile_792\792.vpw
+ *   Type:  VCP2-792 Project (Line Module Le51HR0128)
+ *   Date:  Thursday, June 03, 2010 13:40:38
+ *
+ *   This file was generated with Profile Wizard Version: P1.14.1
+ */
+
+#ifndef PROFILE_79238_H
+#define PROFILE_79238_H
+
+#ifdef VP_API_TYPES_H
+#include "vp_api_types.h"
+#else
+typedef unsigned char VpProfileDataType;
+#endif
+
+extern int dev_profile_size;
+extern int dc_profile_size;
+extern int ac_profile_size;
+extern int ring_profile_size;
+
+/************** Device_Parameters **************/
+/* Device Profile */
+extern const VpProfileDataType VE792_DEV_PROFILE[];
+
+/************** AC_Coefficients **************/
+extern const VpProfileDataType VE792_AC_COEFF_600[]; /* AC Parameters (600) */
+extern const VpProfileDataType AC_COEFF_900[];       /* AC Parameters (900) */
+
+/************** DC_Parameters **************/
+extern const VpProfileDataType VE792_DC_COEFF[];     /* DC Parameters */
+
+/************** Ring_Parameters **************/
+extern const VpProfileDataType RING_20HZ_SINE[];     /* Ringing 20Hz, Sine Wave, 40Vrms */
+extern const VpProfileDataType RING_25HZ_SINE[];     /* Ringing 25Hz, Sine Wave, 40Vrms */
+
+/************** Call_Progress_Tones **************/
+extern const VpProfileDataType TONE_DIAL[];          /* US Dial Tone */
+extern const VpProfileDataType TONE_RINGBACK[];      /* US Ringback Tone */
+extern const VpProfileDataType TONE_BUSY[];          /* US Busy Tone */
+extern const VpProfileDataType TONE_REORDER[];       /* US Reorder Tone */
+extern const VpProfileDataType TONE_US_HOWLER[];     /* US Howler Tone (ROH) */
+extern const VpProfileDataType TONE_UK_HOWLER[];     /* UK Howler Tone */
+extern const VpProfileDataType TONE_AUS_HOWLER[];    /* Australia Howler Tone */
+extern const VpProfileDataType TONE_NTT_HOWLER[];    /* Japan Howler Tone */
+extern const VpProfileDataType TONE_SIT[];           /* Special Information Tone (Called Number Not Connected) */
+extern const VpProfileDataType TONE_ONEKHZ_L[];      /* A 1kHz tone at -10dBm0 */
+extern const VpProfileDataType TONE_ONEKHZ_H[];      /* A 1kHz tone at 0dBm0 */
+extern const VpProfileDataType TONE_CALLWAIT[];      /* Call Waiting Beep */
+extern const VpProfileDataType TONE_CLI[];           /* Caller ID Alert Tone */
+
+/************** Cadence_Definitions **************/
+extern const VpProfileDataType TONE_CAD_DIAL[];      /* US Dial Tone Cadence */
+extern const VpProfileDataType TONE_CAD_STUTTER[];   /* Stutter Dial Tone Cadence */
+extern const VpProfileDataType TONE_CAD_RINGBACK[];  /* US Ringback Tone Cadence */
+extern const VpProfileDataType TONE_CAD_BUSY[];      /* US Busy Tone Cadence */
+extern const VpProfileDataType TONE_CAD_REORDER[];   /* US Reorder Tone Cadence */
+extern const VpProfileDataType TONE_CAD_US_HOWLER[]; /* US Howler Tone Cadence (ROH) */
+extern const VpProfileDataType TONE_CAD_UK_HOWLER[]; /* UK Howler Tone Cadence */
+extern const VpProfileDataType TONE_CAD_AUS_HOWLER[];/* Australia Howler Tone Cadence */
+extern const VpProfileDataType TONE_CAD_NTT_HOWLER[];/* Japan Howler Tone Cadence */
+extern const VpProfileDataType TONE_CAD_SIT[];       /* Special Information Tone Cadence */
+extern const VpProfileDataType RING_CAD_STD[];       /* Standard Ringing Cadence */
+extern const VpProfileDataType RING_CAD_CID[];       /* Ringing Cadence with CallerID */
+extern const VpProfileDataType RING_CAD_ON[];        /* Ringing Always On */
+
+/************** Caller_ID **************/
+extern const VpProfileDataType CID_TYPE2_US[];       /* US Caller ID Type II */
+extern const VpProfileDataType CID_TYPE1_UK[];       /* UK Caller ID Type I */
+extern const VpProfileDataType CLI_TYPE1_US[];       /* US Caller ID (Type 1 - On-Hook) */
+
+/************** Metering_Profile **************/
+extern const VpProfileDataType METER_12KHZ[];        /* Metering Profile 12 kHz Tone */
+extern const VpProfileDataType METER_POLREV[];       /* Metering Profile Polarity Reversal */
+
+#endif /* PROFILE_79238_H */
diff --git a/tools/voice/profile_88266.c b/tools/voice/profile_88266.c
new file mode 100644
index 0000000..e9ab45c
--- /dev/null
+++ b/tools/voice/profile_88266.c
@@ -0,0 +1,644 @@
+/*
+ * profile_8266.c --
+ *
+ * This file contains profile data in byte format
+ *
+ *   This file was generated with Profile Wizard Version: P1.12.3
+ */
+
+#include "profile_88266.h"
+
+
+/*** Device Parameters for VoicePort Device Family ***/
+const VpProfileDataType ABS_VBL_FLYBACK[] =
+{
+  /* Device Profile */
+ 0x00, 0xFF, 0x00, 0x1A, /* Profile Index and Length */
+ 0x04, 0x00, /* Version and MPI Command */
+ 0x20, 0x00, /* PCLK Frequency */
+ 0x8A, 0x00, /* Device Config 1 and MCLK Correction */
+ 0x40, 0x02, /* Clock Slot and Max Events */
+ 0x0A, 0x00, /* Device Tickrate */
+ 0xE4, 0x00, 0x05, 0x00, /* Switching Regulator Parameters */
+ 0x00, 0x00, /* RSVD */
+ 0x22, 0x00, 0x55, 0x55, /* Linecard Parameters */
+ 0xB2, 0x00, 0xB1, 0x00, 0xB0, 0x40  /* Regulator Timing Parameters */
+};
+
+/************** AC Filter Coefficients **************/
+
+/* AC FXS RF14 600 Ohm Coefficients [Default} */
+const VpProfileDataType AC_FXS_RF14_DEF[] =
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 900 Ohm Coefficients */
+const VpProfileDataType AC_FXS_RF14_900[] =
+{
+  /* AC Profile */
+ 0xE4, 0x00, 0xF7, 0x4C, 0x01, 0x49, 0xCA, 0x0B, 0x98, 0x34, 0x3B, 0xB2,
+ 0x2C, 0x9F, 0xA4, 0xD2, 0xA3, 0x22, 0xAC, 0x9A, 0xA4, 0xAA, 0x67, 0x9F,
+ 0x01, 0x8A, 0xB3, 0xD0, 0xA6, 0x21, 0xAA, 0x34, 0x2B, 0x2F, 0x4A, 0xA6,
+ 0xAB, 0x2F, 0x4A, 0x37, 0x88, 0x2A, 0xC0, 0x23, 0xAC, 0x2A, 0x26, 0x32,
+ 0xA5, 0x3C, 0xAD, 0xA4, 0xA7, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xAB, 0x49, 0xF1, 0x2A, 0x0A, 0x43, 0xC9, 0xF3, 0x27, 0xBC,
+ 0xE2, 0xAF, 0xAD, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Australia 220+820//220nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_AU[] =
+{
+  /* AC Profile */
+ 0xBF, 0x00, 0xAF, 0x4C, 0x01, 0x49, 0xCA, 0xE8, 0x98, 0xBA, 0x41, 0x54,
+ 0xA2, 0x2A, 0x5B, 0xA4, 0xAA, 0x3A, 0xB3, 0x9A, 0x87, 0xA2, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0x23, 0x20, 0x3E, 0xA8, 0x2A, 0x57, 0xCB, 0x34,
+ 0xBA, 0xAC, 0xBB, 0xA6, 0x88, 0xAA, 0xB0, 0x49, 0xF6, 0x3B, 0x2E, 0x49,
+ 0xFF, 0xBC, 0xA5, 0x3A, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x34, 0x5C, 0x32, 0x25, 0x1A, 0xA1, 0x3B, 0x23, 0xB3, 0x5B,
+ 0x4D, 0xB5, 0xDC, 0x60, 0x96, 0x3B, 0xA1, 0x00
+};
+
+/* AC FXS RF14 Austria 220+820//115nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_AT[] =
+{
+  /* AC Profile */
+ 0x6D, 0x00, 0xA7, 0x4C, 0x01, 0x49, 0xCA, 0xEA, 0x98, 0xFA, 0xE1, 0x23,
+ 0xA2, 0xEA, 0xCB, 0xB3, 0xAA, 0xA3, 0xB3, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0xB3, 0x20, 0xAB, 0xA8, 0xCC, 0x24, 0x22, 0x97,
+ 0xAF, 0x8F, 0xD3, 0xBF, 0x88, 0x3B, 0xB0, 0x33, 0x46, 0x2A, 0x2E, 0x33,
+ 0x4F, 0xAE, 0xA5, 0xB3, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0x22, 0x98, 0x02, 0x42, 0xA2, 0x43, 0xA6, 0xD8,
+ 0xFA, 0x8F, 0x29, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Belgium 150+830//72 Coefficients */
+const VpProfileDataType AC_FXS_RF14_BE[] =
+{
+  /* AC Profile */
+ 0x8F, 0x00, 0x2E, 0x4C, 0x01, 0x49, 0xCA, 0xF3, 0x98, 0x2C, 0xA1, 0xB4,
+ 0xE3, 0x34, 0xCB, 0x2C, 0x2B, 0xA3, 0xA3, 0x9A, 0x87, 0xA6, 0x97, 0x9F,
+ 0x01, 0x8A, 0x42, 0xD0, 0xBA, 0x30, 0xC2, 0x49, 0xA3, 0x4C, 0xDC, 0xC2,
+ 0x22, 0x2B, 0xBA, 0xA4, 0x88, 0xB3, 0xB0, 0xA3, 0xA4, 0x4A, 0xDD, 0xCA,
+ 0xAD, 0x43, 0xA4, 0x22, 0xAD, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x3A, 0x42, 0xA1, 0xA4, 0x19, 0x81, 0x5A, 0x4B, 0x2F, 0xA2,
+ 0xFB, 0xAF, 0xBA, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Brazil 900 Coefficients */
+const VpProfileDataType AC_FXS_RF14_BR[] =
+{
+  /* AC Profile */
+ 0xE4, 0x00, 0xF7, 0x4C, 0x01, 0x49, 0xCA, 0x0B, 0x98, 0x34, 0x3B, 0xB2,
+ 0x2C, 0x9F, 0xA4, 0xD2, 0xA3, 0x22, 0xAC, 0x9A, 0xA4, 0xAA, 0x67, 0x9F,
+ 0x01, 0x8A, 0xB3, 0xD0, 0xA6, 0x21, 0xAA, 0x34, 0x2B, 0x2F, 0x4A, 0xA6,
+ 0xAB, 0x2F, 0x4A, 0x37, 0x88, 0x2A, 0xC0, 0xA2, 0xAC, 0x2A, 0x26, 0x32,
+ 0xA5, 0x4C, 0xAD, 0xA4, 0xA7, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x3D, 0x53, 0x22, 0x52, 0x1A, 0x22, 0x2B, 0x6A, 0x87, 0x29,
+ 0xFB, 0x2F, 0xFC, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXA RF14 China 200+680//100nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_CN[] =
+{
+  /* AC Profile */
+ 0xB9, 0x00, 0x1F, 0x4C, 0x01, 0x49, 0xCA, 0xE9, 0x98, 0x5C, 0xB1, 0xAA,
+ 0x23, 0x43, 0xEB, 0x32, 0xAA, 0x23, 0xB3, 0x9A, 0x98, 0x94, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0x22, 0x30, 0x6A, 0x59, 0x2A, 0xCB, 0xB4, 0xB2,
+ 0xBF, 0x3B, 0xA3, 0x25, 0x88, 0x43, 0xC0, 0x3A, 0x45, 0x2B, 0xBD, 0x4C,
+ 0x2E, 0x4C, 0x25, 0x42, 0xAD, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xA4, 0x5A, 0x32, 0xB5, 0x12, 0xA1, 0xA2, 0x3A, 0xA4, 0xB5,
+ 0x64, 0x97, 0xAA, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Czech Republic 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_CZ[] =
+{
+  /* AC Profile */
+ 0x1A, 0x00, 0x03, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x22, 0xBA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0xAA, 0xC0, 0x97, 0xA0, 0xAA, 0x33, 0xD2, 0xDB, 0x7C, 0x23,
+ 0x2A, 0xEB, 0x32, 0xB4, 0x88, 0x2A, 0x20, 0x6C, 0xBC, 0xCE, 0xA6, 0x2B,
+ 0xA5, 0xAA, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xC3, 0x5A, 0x22, 0xC7, 0x16, 0xE2, 0x2B, 0x42, 0xC6, 0xC8,
+ 0xFA, 0x9F, 0x2B, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Denmark 300+1000//220nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_DK[] =
+{
+  /* AC Profile */
+ 0x7D, 0x00, 0x9A, 0x4C, 0x01, 0x49, 0xCA, 0xE6, 0x98, 0x22, 0xA1, 0x52,
+ 0xD2, 0xE7, 0x24, 0xF4, 0xCD, 0xAA, 0x97, 0x9A, 0xCA, 0xB3, 0xA5, 0x6E,
+ 0x01, 0x8A, 0x32, 0xD0, 0xAB, 0x20, 0xAA, 0x49, 0x29, 0x7A, 0x32, 0xD6,
+ 0xA2, 0xED, 0xC5, 0x97, 0x88, 0xBA, 0xC0, 0x22, 0xA7, 0x2C, 0xFE, 0x42,
+ 0xDE, 0x22, 0xB6, 0xB3, 0x9F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x23, 0x53, 0x32, 0x2C, 0x1B, 0x22, 0xCA, 0x23, 0x63, 0x2A,
+ 0x33, 0xD4, 0x2A, 0x40, 0x96, 0xA2, 0xA0, 0x00
+};
+
+/* AC FXS RF14 ETSI 270+750//150nF Harmonized Coefficients */
+const VpProfileDataType AC_FXS_RF14_EU[] =
+{
+  /* AC Profile */
+ 0xD5, 0x00, 0xEC, 0x4C, 0x01, 0x49, 0xCA, 0xE8, 0x98, 0x4A, 0xA1, 0x34,
+ 0xA2, 0xA2, 0xAC, 0x2C, 0xBB, 0x2B, 0xA4, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x9C, 0xD0, 0x2B, 0x20, 0x8F, 0x39, 0x2A, 0xBB, 0xA4, 0x24,
+ 0xB2, 0xBC, 0x4B, 0x26, 0x88, 0xA3, 0xC0, 0xC2, 0x27, 0xBA, 0x3E, 0xAC,
+ 0xAF, 0xB4, 0x26, 0x24, 0x3F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xC3, 0x5F, 0x32, 0x98, 0x03, 0xA1, 0xAA, 0x23, 0xB3, 0x2C,
+ 0x4B, 0x55, 0x25, 0x60, 0x96, 0xF2, 0xC1, 0x00
+};
+
+/* AC FXS RF14 Finland 270+910//120 Coefficients */
+const VpProfileDataType AC_FXS_RF14_FI[] =
+{
+  /* AC Profile */
+ 0xFF, 0x00, 0x8D, 0x4C, 0x01, 0x49, 0xCA, 0xEF, 0x98, 0x2A, 0xB1, 0x23,
+ 0x33, 0xB2, 0xAB, 0x44, 0xEB, 0xA4, 0x44, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0x24, 0x20, 0x25, 0xB8, 0x2D, 0x42, 0xDB, 0xBA,
+ 0xE3, 0x43, 0xF2, 0xAC, 0x88, 0xC4, 0xB0, 0xA2, 0xA7, 0x42, 0x3E, 0xA2,
+ 0x9F, 0x32, 0x26, 0xBE, 0x2F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xA2, 0x5C, 0x22, 0xA2, 0x13, 0xC1, 0xB3, 0x22, 0x23, 0x7A,
+ 0x3D, 0xB4, 0xD4, 0x50, 0x96, 0x3C, 0x41, 0x00
+};
+
+/* AC FXS RF14 France 215+1000//137nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_FR[] =
+{
+  /* AC Profile */
+ 0xFC, 0x00, 0xA4, 0x4C, 0x01, 0x49, 0xCA, 0xE7, 0x98, 0xBA, 0x31, 0xA5,
+ 0x62, 0x35, 0xAB, 0xAA, 0xAA, 0xAC, 0xA3, 0x9A, 0xAA, 0xA2, 0xC7, 0x6F,
+ 0x01, 0x8A, 0x2D, 0x01, 0xBB, 0x10, 0xC2, 0x38, 0x2A, 0xA1, 0xC2, 0xA9,
+ 0x23, 0xA2, 0x22, 0x2D, 0x88, 0xA3, 0xB0, 0x53, 0x55, 0x4A, 0xAD, 0xB2,
+ 0xAD, 0x5A, 0x25, 0x72, 0x5E, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x43, 0x22, 0x9F, 0x1A, 0x22, 0x4B, 0x33, 0xD5, 0x2C,
+ 0x7A, 0x87, 0xA8, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 German 220+820//115nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_DE[] =
+{
+  /* AC Profile */
+ 0xEB, 0x00, 0xDC, 0x4C, 0x01, 0x49, 0xCA, 0xEA, 0x98, 0xA2, 0xE1, 0x24,
+ 0xA2, 0x2A, 0xCB, 0xB3, 0xAA, 0xD3, 0xB3, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0x24, 0x20, 0x2C, 0xA8, 0xAB, 0x24, 0x22, 0x97,
+ 0xAF, 0x8F, 0x23, 0xBF, 0x88, 0x3B, 0xB0, 0x33, 0x46, 0x2A, 0x2E, 0x33,
+ 0x4F, 0xAE, 0xA5, 0xB3, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x53, 0x54, 0x32, 0xC4, 0x1A, 0xA1, 0x2B, 0x2A, 0xA3, 0xAA,
+ 0x4A, 0xA5, 0xBA, 0x60, 0x96, 0xD2, 0xA1, 0x00
+};
+
+/* AC FXS RF14 Greece 400+500//50nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_GR[] =
+{
+  /* AC Profile */
+ 0x63, 0x00, 0x7D, 0x4C, 0x01, 0x49, 0xCA, 0x03, 0x98, 0x22, 0xA6, 0x2C,
+ 0x3E, 0x2B, 0x87, 0x44, 0x36, 0x2A, 0x9F, 0x9A, 0x22, 0xBA, 0xA7, 0x9F,
+ 0x01, 0x8A, 0x7D, 0xD0, 0xAA, 0xA0, 0x22, 0xAA, 0x98, 0xB4, 0x23, 0xBE,
+ 0xAB, 0xBF, 0xAA, 0x97, 0x88, 0x3C, 0xC0, 0x3A, 0xBD, 0xED, 0x8F, 0xEB,
+ 0xA6, 0x3A, 0x8F, 0x2B, 0x6F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xD2, 0x52, 0x22, 0xA2, 0x13, 0xA1, 0x97, 0x32, 0x25, 0xCA,
+ 0x6B, 0x87, 0x2B, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Hungary 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_HU[] =
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 India 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_IN[] =
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Italy 180+630//60nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_IT[] =
+{
+  /* AC Profile */
+ 0xEE, 0x00, 0xBD, 0x4C, 0x01, 0x49, 0xCA, 0xF3, 0x98, 0x22, 0xD2, 0xBA,
+ 0x34, 0x22, 0x3C, 0x53, 0xAB, 0xAA, 0xB4, 0x9A, 0x98, 0x1B, 0x97, 0x9F,
+ 0x01, 0x8A, 0x9C, 0xD0, 0xBC, 0xD0, 0x2A, 0x2A, 0x3C, 0x4C, 0x4E, 0x23,
+ 0xD2, 0xBB, 0xDB, 0x55, 0x88, 0xAA, 0xC0, 0x2C, 0xB5, 0x23, 0xAD, 0x4A,
+ 0x5E, 0xAD, 0xB5, 0x2B, 0x2E, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xA2, 0x52, 0xA1, 0xA3, 0x1A, 0x32, 0xAA, 0x4A, 0xAF, 0x3B,
+ 0xF4, 0x9F, 0x3A, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Japan 600+1uF Coefficients */
+const VpProfileDataType AC_FXS_RF14_JP[] =
+{
+  /* AC Profile */
+ 0x0C, 0x00, 0x79, 0x4C, 0x01, 0x49, 0xCA, 0xF9, 0x98, 0xAC, 0xEE, 0x2A,
+ 0x87, 0x2A, 0x3F, 0xA3, 0x97, 0xE5, 0xC3, 0x9A, 0xAB, 0xA2, 0x24, 0xA6,
+ 0xD0, 0x8A, 0x42, 0xB0, 0x2A, 0xA0, 0x34, 0xAA, 0x3B, 0xA2, 0xCA, 0xAA,
+ 0xA4, 0x24, 0x3B, 0x4D, 0x88, 0xBA, 0x30, 0xAC, 0x2D, 0xAA, 0xCE, 0xAA,
+ 0x25, 0x22, 0x2C, 0xB2, 0x65, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x3B, 0x52, 0xA1, 0xA5, 0x14, 0xA2, 0x23, 0x44, 0x24, 0xA5,
+ 0x4B, 0xA4, 0xAC, 0x40, 0x96, 0x32, 0xD0, 0x00
+};
+
+/* AC FXS RF14 S. Korea 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_KR[] =
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Mexico 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_MX[] =
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Netherlands 600/340+422//100 Coefficients */
+const VpProfileDataType AC_FXS_RF14_NL[] =
+{
+  /* AC Profile */
+ 0x7D, 0x00, 0x38, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x22, 0xBA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x34, 0xD0, 0xCD, 0xA0, 0xAB, 0xD3, 0x22, 0xAB, 0x4A, 0xA3,
+ 0xA2, 0x2C, 0xAB, 0x45, 0x88, 0x2A, 0x20, 0x6C, 0xBC, 0xCE, 0xA6, 0x2B,
+ 0xA5, 0xAA, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x62, 0x52, 0x22, 0xCD, 0x12, 0x23, 0x44, 0x7A, 0x87, 0x3B,
+ 0xFC, 0xBF, 0xBA, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 New Zealand 370+620//310nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_NZ[] =
+{
+  /* AC Profile */
+ 0x14, 0x00, 0x00, 0x4C, 0x01, 0x49, 0xCA, 0xE9, 0x98, 0xAA, 0xB3, 0xB2,
+ 0xA2, 0xDA, 0xA3, 0x2B, 0x36, 0xAA, 0x25, 0x9A, 0x2B, 0xA2, 0x27, 0x6F,
+ 0x01, 0x8A, 0x1D, 0x01, 0x52, 0x50, 0x2A, 0x3B, 0x45, 0xA9, 0xCA, 0xA3,
+ 0x2C, 0xAB, 0xAA, 0x27, 0x88, 0xC3, 0x50, 0xBA, 0x8F, 0x37, 0x2F, 0xC2,
+ 0xBE, 0xEA, 0x87, 0xAA, 0x87, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x53, 0x53, 0x32, 0xCB, 0x1C, 0x42, 0x32, 0x3B, 0xB3, 0xA2,
+ 0x42, 0xB4, 0x23, 0x50, 0x96, 0x42, 0xA0, 0x00
+};
+
+/* AC FXS RF14 Norway 120+820//110nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_NO[] =
+{
+  /* AC Profile */
+ 0x04, 0x00, 0xA8, 0x4C, 0x01, 0x49, 0xCA, 0xE4, 0x98, 0xAA, 0x41, 0x22,
+ 0xA1, 0xAA, 0x3B, 0x23, 0x2A, 0xD4, 0x23, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0xEA, 0x10, 0x22, 0xB8, 0x22, 0x3B, 0x23, 0xA1,
+ 0xAA, 0xBA, 0x32, 0xC4, 0x88, 0x25, 0xB0, 0x3B, 0x24, 0x2C, 0x2D, 0xA3,
+ 0xAC, 0xF4, 0xC4, 0xAB, 0xAD, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xBB, 0x52, 0xE2, 0xBD, 0x1B, 0xA1, 0x3B, 0x2A, 0xA3, 0x3A,
+ 0x4A, 0x26, 0x29, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Portugal 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_PT[] =
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Slovenia 600/220+820//115 Coefficients */
+const VpProfileDataType AC_FXS_RF14_SI[] =
+{
+  /* AC Profile */
+ 0x00, 0x00, 0x00, 0x4C, 0x00, 0x49, 0xCA, 0xF5, 0x98, 0x2A, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2B, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0x55, 0xA0, 0xA2, 0xA2, 0x57, 0x2B, 0xC6, 0x23,
+ 0x34, 0xBB, 0x6A, 0xC5, 0x88, 0x2A, 0x20, 0x6C, 0xBC, 0xCE, 0xA6, 0x2B,
+ 0xA5, 0xAA, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xC8, 0xF0, 0x50,
+ 0x00, 0x86, 0xC3, 0x5A, 0x22, 0xC7, 0x16, 0xE2, 0x2B, 0x42, 0xC6, 0xC8,
+ 0xFA, 0x9F, 0x2B, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Spain 220+820//120nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_ES[] =
+{
+  /* AC Profile */
+ 0xBF, 0x00, 0xAF, 0x4C, 0x01, 0x49, 0xCA, 0xE8, 0x98, 0xBA, 0x41, 0x54,
+ 0xA2, 0x2A, 0x5B, 0xA4, 0xAA, 0x3A, 0xB3, 0x9A, 0x87, 0xA2, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0x23, 0x20, 0x3E, 0xA8, 0x2A, 0x57, 0xCB, 0x34,
+ 0xBA, 0xAC, 0xBB, 0xA6, 0x88, 0xAA, 0xB0, 0x49, 0xF6, 0x3B, 0x2E, 0x49,
+ 0xFF, 0xBC, 0xA5, 0x3A, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x34, 0x5C, 0x32, 0x25, 0x1A, 0xA1, 0x3B, 0x23, 0xB3, 0x5B,
+ 0x4D, 0xB5, 0xDC, 0x60, 0x96, 0x3B, 0xA1, 0x00
+};
+
+/* AC FXS RF14 Sweden 200+1000//100nF_900//30nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_SE[] =
+{
+  /* AC Profile */
+ 0x0E, 0x00, 0x42, 0x4C, 0x01, 0x49, 0xCA, 0xF0, 0x98, 0x24, 0xF1, 0xB4,
+ 0xA2, 0xAB, 0x4B, 0x4B, 0xAA, 0xA7, 0xC3, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0xB3, 0x20, 0x5B, 0xB8, 0x24, 0xA2, 0x3C, 0xAC,
+ 0xAA, 0x27, 0x32, 0x9F, 0x88, 0x3A, 0xA0, 0x3A, 0x25, 0x3A, 0xAD, 0x22,
+ 0xAD, 0xBE, 0x25, 0xA5, 0x2E, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x73, 0x52, 0x22, 0xD2, 0x12, 0xB1, 0x4A, 0x23, 0xC4, 0xC3,
+ 0x6A, 0x97, 0xA8, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 U.K. 300+1000//220_370+620//310nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_GB[] =
+{
+  /* AC Profile */
+ 0x24, 0x00, 0x0A, 0x4C, 0x01, 0x49, 0xCA, 0xE6, 0x98, 0x22, 0xA1, 0x52,
+ 0xD2, 0xE7, 0x24, 0xF4, 0xCD, 0xAA, 0x97, 0x9A, 0x2B, 0xA2, 0x27, 0x6E,
+ 0x01, 0x8A, 0x32, 0xD0, 0xCB, 0x20, 0xBB, 0x59, 0x5A, 0x4A, 0xAA, 0xB5,
+ 0x2C, 0x2D, 0x42, 0xC7, 0x88, 0xAA, 0xC0, 0xA3, 0xA7, 0xBA, 0xDE, 0x5C,
+ 0xCE, 0xAA, 0xA6, 0xA2, 0x9F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x43, 0x5B, 0x32, 0x2C, 0x1D, 0x22, 0xAA, 0x2B, 0x33, 0xBA,
+ 0x3C, 0x34, 0xBA, 0x40, 0x96, 0xA2, 0xA0, 0x00
+};
+
+/* AC FXS RF14 US 900//2.16uF_1650//(100+5nF) Coefficients */
+const VpProfileDataType AC_FXS_RF14_US_loaded[] =
+{
+  /* AC Profile */
+ 0x01, 0x00, 0x90, 0x4C, 0x01, 0x49, 0xCA, 0x0E, 0x98, 0x32, 0x2B, 0x24,
+ 0x7C, 0x4A, 0x24, 0x55, 0xA3, 0x3A, 0xBC, 0x9A, 0xBA, 0xB3, 0xF4, 0x2D,
+ 0x01, 0x8A, 0xEB, 0xC0, 0x26, 0x21, 0xB2, 0x35, 0xB3, 0xA6, 0x2A, 0xAD,
+ 0xD4, 0xA6, 0x52, 0x4F, 0x88, 0xA3, 0xD0, 0x23, 0xAA, 0xAF, 0x62, 0xEA,
+ 0xBA, 0x2A, 0xB3, 0x4A, 0x3D, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2B, 0x4C, 0x21, 0xAC, 0x03, 0xB2, 0xA5, 0x5A, 0xE4, 0x74,
+ 0xF3, 0xA5, 0xBE, 0x60, 0x96, 0xAA, 0xC0, 0x00
+};
+
+/* AC FXS RF14 US 900//2,16uF_800//(100+50nF) Coefficients */
+const VpProfileDataType AC_FXS_RF14_US_Nonloaded[] =
+{
+  /* AC Profile */
+ 0x01, 0x00, 0x90, 0x4C, 0x01, 0x49, 0xCA, 0x0E, 0x98, 0x32, 0x2B, 0x24,
+ 0x7C, 0x4A, 0x24, 0x55, 0xA3, 0x3A, 0xBC, 0x9A, 0xBA, 0xB3, 0xF4, 0x2D,
+ 0x01, 0x8A, 0xEB, 0xC0, 0x26, 0x21, 0xB2, 0x35, 0xB3, 0xA6, 0x2A, 0xAD,
+ 0xD4, 0xA6, 0x52, 0x4F, 0x88, 0xA3, 0xD0, 0x23, 0xAA, 0xAF, 0x62, 0xEA,
+ 0xBA, 0x2A, 0xB3, 0x4A, 0x3D, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xBD, 0x52, 0xA1, 0x62, 0x1B, 0x22, 0x3A, 0x4B, 0xB5, 0x2A,
+ 0x65, 0xA7, 0xB6, 0x70, 0x96, 0x23, 0xC0, 0x00
+};
+
+/* AC FXS RF14 US 900//2.16uF Coefficients */
+const VpProfileDataType AC_FXS_RF14_US_SS[] =
+{
+  /* AC Profile */
+ 0x01, 0x00, 0x90, 0x4C, 0x01, 0x49, 0xCA, 0x0E, 0x98, 0x32, 0x2B, 0x24,
+ 0x7C, 0x4A, 0x24, 0x55, 0xA3, 0x3A, 0xBC, 0x9A, 0xBA, 0xB3, 0xF4, 0x2D,
+ 0x01, 0x8A, 0xEB, 0xC0, 0x26, 0x21, 0xB2, 0x35, 0xB3, 0xA6, 0x2A, 0xAD,
+ 0xD4, 0xA6, 0x52, 0x4F, 0x88, 0xA3, 0xD0, 0x23, 0xAA, 0xAF, 0x62, 0xEA,
+ 0xBA, 0x2A, 0xB3, 0x4A, 0x3D, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xDA, 0x4A, 0x41, 0x3A, 0x02, 0x23, 0x3A, 0x42, 0x25, 0xAA,
+ 0x72, 0xA5, 0x2B, 0x50, 0x96, 0x1D, 0x01, 0x00
+};
+
+/************** WideBand AC Filter Coefficients **************/
+/* AC FXS RF14 600 Ohm Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_US[] =
+{
+  /* AC Profile */
+ 0xED, 0x00, 0xA9, 0x4C, 0x01, 0x49, 0xCA, 0xFC, 0x98, 0xCC, 0x2A, 0xA2,
+ 0x3B, 0x98, 0xB3, 0x43, 0xA2, 0x3A, 0xAB, 0x9A, 0x2D, 0xAA, 0xB6, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0xC4, 0xA0, 0x2E, 0x23, 0x3A, 0x2E, 0x9F, 0x87,
+ 0x4C, 0xCE, 0xB2, 0x27, 0x88, 0xDE, 0x20, 0xAA, 0xCA, 0x22, 0x32, 0x23,
+ 0xAA, 0xA2, 0xB4, 0x2A, 0x87, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xCB, 0x5E, 0x22, 0xBC, 0x12, 0xA3, 0xA9, 0xFA, 0xC6, 0x34,
+ 0xE2, 0x9F, 0xBA, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 European Union Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_EU[] =
+{
+  /* AC Profile */
+ 0xAA, 0x00, 0x9C, 0x4C, 0x01, 0x49, 0xCA, 0xE0, 0x98, 0xAA, 0xA3, 0x6B,
+ 0x22, 0x43, 0xA2, 0xAC, 0xBF, 0x22, 0xA6, 0x9A, 0x01, 0x90, 0x01, 0x01,
+ 0x90, 0x8A, 0x2E, 0x01, 0xBA, 0x10, 0xA2, 0x3A, 0xBA, 0xE9, 0xAA, 0xB5,
+ 0x2A, 0xBC, 0xAF, 0x97, 0x88, 0xAB, 0xC0, 0x4A, 0xBE, 0xBA, 0x9F, 0xC3,
+ 0xAF, 0x3A, 0x3F, 0xCD, 0xA7, 0x82, 0xC8, 0x71, 0x80, 0x69, 0xF0, 0x50,
+ 0x00, 0x86, 0xBA, 0x52, 0xB2, 0xBA, 0x12, 0x42, 0x4A, 0x2A, 0x33, 0xBA,
+ 0x33, 0x34, 0x4B, 0x40, 0x96, 0xB2, 0xA0, 0x00
+};
+
+/* AC FXS RF14 France Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_FR[] =
+{
+  /* AC Profile */
+ 0x98, 0x00, 0x26, 0x4C, 0x01, 0x49, 0xCA, 0xD7, 0x98, 0x4F, 0x22, 0xB5,
+ 0xB1, 0xC6, 0x23, 0x3A, 0xAB, 0x24, 0xB5, 0x9A, 0x01, 0x90, 0x01, 0x01,
+ 0x90, 0x8A, 0x01, 0x11, 0x22, 0x10, 0x3A, 0x29, 0x3C, 0x29, 0x32, 0xB3,
+ 0x4A, 0x2C, 0x2E, 0xB6, 0x88, 0xAC, 0xB0, 0x43, 0x37, 0xAB, 0x3E, 0xB4,
+ 0x3E, 0x22, 0x37, 0x22, 0xAF, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xAA, 0x52, 0xE2, 0x2B, 0x12, 0x62, 0x63, 0x3A, 0x24, 0xA2,
+ 0x5C, 0x36, 0x39, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 German Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_DE[] =
+{
+  /* AC Profile */
+ 0x27, 0x00, 0xD7, 0x4C, 0x01, 0x49, 0xCA, 0xDB, 0x98, 0xBA, 0xA1, 0xBA,
+ 0x22, 0x2A, 0xF4, 0xAA, 0xAB, 0x22, 0x65, 0x9A, 0x01, 0x90, 0x01, 0x01,
+ 0x90, 0x8A, 0x2E, 0x01, 0xA3, 0x10, 0x2B, 0x29, 0x53, 0xB9, 0xBD, 0xB3,
+ 0x7B, 0xCC, 0xDB, 0xA6, 0x88, 0x2A, 0xB0, 0x2B, 0x9F, 0x2E, 0x3E, 0x22,
+ 0xBE, 0xC3, 0x26, 0x35, 0x2F, 0x82, 0xB8, 0x71, 0x80, 0xAB, 0xF0, 0x50,
+ 0x00, 0x86, 0xCA, 0x5A, 0xA2, 0xBA, 0x1F, 0x22, 0x3B, 0x2A, 0x23, 0x2B,
+ 0x3A, 0x24, 0x4B, 0x40, 0x96, 0x22, 0x21, 0x00
+};
+
+/* AC FXS RF14 China Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_CN[] =
+{
+  /* AC Profile */
+ 0xEF, 0x00, 0x46, 0x4C, 0x01, 0x49, 0xCA, 0xDA, 0x98, 0xB3, 0xB1, 0x23,
+ 0x32, 0x64, 0x97, 0xAA, 0x2B, 0x4A, 0xA4, 0x9A, 0x01, 0x90, 0x01, 0x01,
+ 0x90, 0x8A, 0x2E, 0x01, 0xCD, 0x10, 0x2B, 0x29, 0x22, 0x2A, 0xA2, 0x33,
+ 0x4B, 0x4C, 0xBD, 0xF6, 0x88, 0x2A, 0xC0, 0x52, 0x97, 0xF2, 0x2E, 0xAA,
+ 0x4E, 0xAC, 0xB5, 0x5B, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x5A, 0xA2, 0xBA, 0x1B, 0x22, 0xCA, 0x24, 0xC3, 0x43,
+ 0x42, 0xA4, 0x4B, 0x50, 0x96, 0x3C, 0x41, 0x00
+};
+
+/* AC FXS RF14 Australia Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_AU[] =
+{
+  /* AC Profile */
+ 0xC2, 0x00, 0x2E, 0x4C, 0x01, 0x49, 0xCA, 0xF0, 0x98, 0xBA, 0xA1, 0xAD,
+ 0xA3, 0xA2, 0x2C, 0x2D, 0xAB, 0x22, 0xD4, 0x9A, 0xCC, 0xA2, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0x7A, 0x10, 0xBA, 0x29, 0x2A, 0x3A, 0xA2, 0x32,
+ 0xB2, 0xAA, 0xF2, 0xA4, 0x88, 0xBA, 0xA0, 0x5C, 0x3F, 0x2C, 0xCE, 0xAA,
+ 0x87, 0xC2, 0x66, 0xDB, 0x7E, 0x82, 0xA8, 0x71, 0x80, 0x39, 0x70, 0x50,
+ 0x00, 0x86, 0xAA, 0x59, 0x81, 0x25, 0x1A, 0xA1, 0xBB, 0x2B, 0xB3, 0x2C,
+ 0x46, 0xD5, 0xBC, 0x60, 0x96, 0xAA, 0xB1, 0x00
+};
+
+/************** DC Feed Parameters **************/
+
+/* 22mA  current feed */
+const VpProfileDataType DC_22MA_CC[] =
+{
+ /* DC Profile */
+ 0x00, 0x01, 0x01, 0x0B, 0x01, 0x08, 0xC2, 0x1A, 0x88, 0xD0, 0x05, 0xC6,
+ 0x11, 0x04, 0x01
+};
+
+/************** Ring Signal Parameters **************/
+
+/* Default Rnging, 25Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_DEF[] =
+{
+  /* Sine, 25 Hz, 1.41 CF, 70.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x44,
+ 0x3A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* US Ringing, 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_US[] =
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Canada Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_CA[] =
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* France Ringing 50Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_FR[] =
+{
+  /* Sine, 50 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x88,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Japan Ringing 16Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_JP[] =
+{
+  /* Sine, 16 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x2B,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* S. Korea Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_KR[] =
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Taiwan Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_TW[] =
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Hong Kong Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_HK[] =
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Singapore Rnging, 24Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_SG[] =
+{
+  /* Sine, 24 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x41,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Austria Ringing 50Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_AT[] =
+{
+  /* Sine, 50 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x88,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Australia Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_AU[] =
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+
+/************** Call Progress Tones **************/
+
+/************** Cadence Definitions **************/
+/* RING Cadence Profile */
+const VpProfileDataType RING_CAD_STD[] =
+{
+  /* Cadence Profile */
+ 0x00, 0x08, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x07, 0x21, 0x90,
+ 0x01, 0x00, 0x23, 0x20, 0x40, 0x00
+};
+
+/************** Caller ID **************/
+
+/************** Metering Profile **************/
+
+int dev_profile_size = sizeof(ABS_VBL_FLYBACK);
+int dc_profile_size = sizeof(DC_22MA_CC);
+int ac_profile_size = sizeof(AC_FXS_RF14_DEF);
+int ring_profile_size = sizeof(RING_DEF);
+
+/* end of file profile_8266.c */
diff --git a/tools/voice/profile_88266.h b/tools/voice/profile_88266.h
new file mode 100644
index 0000000..1b14d76
--- /dev/null
+++ b/tools/voice/profile_88266.h
@@ -0,0 +1,97 @@
+/*
+ * profile_8266.h --
+ *
+ * This header file exports the Profile data types
+ *
+ * Project Info --
+ *   File:  C:\Documents and Settings\benavi\Desktop\tmp\NewProject.vpw
+ *   Type:  Le71HR0865G Line Module Project - VBL Reg ABS Power Supply and 8.192MHz PCLK
+ *   Date:  Thursday, February 25, 2010 16:58:41
+ *
+ *   This file was generated with Profile Wizard Version: P1.12.3
+ */
+
+#ifndef PROFILE_8266_H
+#define PROFILE_8266_H
+
+#ifdef VP_API_TYPES_H
+#include "vp_api_types.h"
+#else
+typedef unsigned char VpProfileDataType;
+#endif
+
+extern int dev_profile_size;
+extern int dc_profile_size;
+extern int ac_profile_size;
+extern int ring_profile_size;
+
+/************** Device Parameters **************/
+/* Device Profile */
+extern const VpProfileDataType ABS_VBL_FLYBACK[];
+
+/************** AC Filter Coefficients **************/
+extern const VpProfileDataType AC_FXS_RF14_DEF[];    /* AC FXS RF14 600 Ohm Coefficients [Default} */
+extern const VpProfileDataType AC_FXS_RF14_900[];    /* AC FXS RF14 900 Ohm Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_AU[];     /* AC FXS RF14 Australia 220+820//220nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_AT[];     /* AC FXS RF14 Austria 220+820//115nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_BE[];     /* AC FXS RF14 Belgium 150+830//72 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_BR[];     /* AC FXS RF14 Brazil 900 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_CN[];     /* AC FXA RF14 China 200+680//100nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_CZ[];     /* AC FXS RF14 Czech Republic 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_DK[];     /* AC FXS RF14 Denmark 300+1000//220nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_EU[];     /* AC FXS RF14 ETSI 270+750//150nF Harmonized Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_FI[];     /* AC FXS RF14 Finland 270+910//120 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_FR[];     /* AC FXS RF14 France 215+1000//137nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_DE[];     /* AC FXS RF14 German 220+820//115nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_GR[];     /* AC FXS RF14 Greece 400+500//50nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_HU[];     /* AC FXS RF14 Hungary 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_IN[];     /* AC FXS RF14 India 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_IT[];     /* AC FXS RF14 Italy 180+630//60nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_JP[];     /* AC FXS RF14 Japan 600+1uF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_KR[];     /* AC FXS RF14 S. Korea 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_MX[];     /* AC FXS RF14 Mexico 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_NL[];     /* AC FXS RF14 Netherlands 600/340+422//100 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_NZ[];     /* AC FXS RF14 New Zealand 370+620//310nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_NO[];     /* AC FXS RF14 Norway 120+820//110nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_PT[];     /* AC FXS RF14 Portugal 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_SI[];     /* AC FXS RF14 Slovenia 600/220+820//115 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_ES[];     /* AC FXS RF14 Spain 220+820//120nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_SE[];     /* AC FXS RF14 Sweden 200+1000//100nF_900//30nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_GB[];     /* AC FXS RF14 U.K. 300+1000//220_370+620//310nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_US_loaded[];/* AC FXS RF14 US 900//2.16uF_1650//(100+5nF) Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_US_Nonloaded[];/* AC FXS RF14 US 900//2,16uF_800//(100+50nF) Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_US_SS[];  /* AC FXS RF14 US 900//2.16uF Coefficients */
+
+/************** WideBand AC Filter Coefficients **************/
+extern const VpProfileDataType AC_FXS_RF14_WB_US[];  /* AC FXS RF14 600 Ohm Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_EU[];  /* AC FXS RF14 European Union Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_FR[];  /* AC FXS RF14 France Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_DE[];  /* AC FXS RF14 German Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_CN[];  /* AC FXS RF14 China Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_AU[];  /* AC FXS RF14 Australia Wideband Coefficients */
+
+/************** DC Feed Parameters **************/
+extern const VpProfileDataType DC_22MA_CC[];         /* 22mA  current feed */
+
+/************** Ring Signal Parameters **************/
+extern const VpProfileDataType RING_DEF[];           /* Default Rnging, 25Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_US[];            /* US Ringing, 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_CA[];            /* Canada Ringing 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_FR[];            /* France Ringing 50Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_JP[];            /* Japan Ringing 16Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_KR[];            /* S. Korea Ringing 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_TW[];            /* Taiwan Ringing 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_HK[];            /* Hong Kong Ringing 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_SG[];            /* Singapore Rnging, 24Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_AT[];            /* Austria Ringing 50Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_AU[];            /* Australia Ringing 20Hz, Sinewave, 80Vpk */
+
+/************** Call Progress Tones **************/
+
+/************** Cadence Definitions **************/
+extern const VpProfileDataType RING_CAD_STD[];
+/************** Caller ID **************/
+
+/************** Metering Profile **************/
+
+#endif /* PROFILE_8266_H */
diff --git a/tools/voice/vpapi_lib.c b/tools/voice/vpapi_lib.c
new file mode 100644
index 0000000..27e5c6b
--- /dev/null
+++ b/tools/voice/vpapi_lib.c
@@ -0,0 +1,432 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include "vpapi_lib.h"
+
+/* Locals */
+static char dev_name[] = "/dev/vpapi";
+static int dev_fd = 0;
+static char lib_str[] = "[vpapi_lib]:";
+
+int vpapi_open_device(void)
+{
+	int fdflags;
+
+	/* open the device */
+	dev_fd = open(dev_name, O_RDWR);
+	if (dev_fd <= 0) {
+		printf("Cannot open %s device\n", dev_name);
+		return -1;
+	}
+
+	/* set some flags */
+	fdflags = fcntl(dev_fd, F_GETFL, 0);
+	fdflags |= O_NONBLOCK;
+	fcntl(dev_fd, F_SETFL, fdflags);
+
+	return 0;
+}
+
+int vpapi_close_device(void)
+{
+	if(dev_fd > 0)
+		close(dev_fd);
+
+	return 0;
+}
+
+VpStatusType vpapi_make_dev_object(VpDeviceType dev_type, VpDeviceIdType dev_id)
+{
+	VpApiModMkDevObjType data;
+
+	data.deviceType = dev_type;
+	data.deviceId = dev_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_MK_DEV_OBJ, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_MK_DEV_OBJ) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_make_line_object(VpTermType term_type, VpLineIdType line_id)
+{
+	VpApiModMkLnObjType data;
+
+	data.termType = term_type;
+	data.lineId = line_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_MK_LN_OBJ, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_MK_LN_OBJ) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_map_line_id(VpLineIdType line_id)
+{
+	VpApiModMapLnIdType data;
+
+	data.lineId = line_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_MAP_LN_ID, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_MAP_LN_ID) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_map_slac_id(VpDeviceIdType dev_id, unsigned char slac_id)
+{
+	VpApiModMapSlacIdType data;
+
+	data.deviceId = dev_id;
+	data.slacId = slac_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_MAP_SLAC_ID, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_MAP_SLAC_ID) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_free_line_context(VpLineIdType line_id)
+{
+	VpApiModFreeLnCtxType data;
+
+	data.lineId = line_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_FREE_LN_CTX, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_FREE_LN_CTX) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_init_device(VpDeviceIdType dev_id, VpProfilePtrType dev_profile_ptr,
+				VpProfilePtrType ac_profile_ptr, VpProfilePtrType dc_profile_ptr,
+				VpProfilePtrType ring_profile_ptr, VpProfilePtrType fxo_ac_profile_ptr,
+				VpProfilePtrType fxo_cfg_profile_ptr, vpapi_init_device_params_t *params_ptr)
+{
+	VpApiModInitDeviceType data;
+
+	data.deviceId = dev_id;
+	data.pDevProfile = dev_profile_ptr;
+	data.pAcProfile = ac_profile_ptr;
+	data.pDcProfile = dc_profile_ptr;
+	data.pRingProfile = ring_profile_ptr;
+	data.pFxoAcProfile = fxo_ac_profile_ptr;
+	data.pFxoCfgProfile = fxo_cfg_profile_ptr;
+	data.devProfileSize = params_ptr->dev_size;
+	data.acProfileSize = params_ptr->ac_size;
+	data.dcProfileSize = params_ptr->dc_size;
+	data.ringProfileSize = params_ptr->ring_size;
+	data.fxoAcProfileSize = params_ptr->fxo_ac_size;
+	data.fxoCfgProfileSize = params_ptr->fxo_cfg_size;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_INIT_DEV, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_INIT_DEV) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_cal_line(VpLineIdType line_id)
+{
+	VpApiModCalLnType data;
+
+	data.lineId = line_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_CAL_LN, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_CAL_LN) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_set_line_state(VpLineIdType line_id, VpLineStateType state)
+{
+	VpApiModSetLnStType data;
+
+	data.lineId = line_id;
+	data.state = state;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_SET_LN_ST, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_SET_LN_ST) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_set_option(unsigned char line_request, VpLineIdType line_id,
+				VpDeviceIdType dev_id, VpOptionIdType option, void *value_p)
+{
+	VpApiModSetOptionType data;
+
+	data.lineRequest = line_request;
+	data.lineId = line_id;
+	data.deviceId = dev_id;
+	data.option = option;
+	data.pValue = value_p;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_SET_OPTION, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_SET_OPTION) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+bool vpapi_get_event(VpDeviceIdType dev_id, VpEventType *event_p)
+{
+	VpApiModGetEventType data;
+
+	data.deviceId = dev_id;
+	data.pEvent = event_p;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return false;
+	}
+
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_GET_EVENT, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_GET_EVENT) failed\n");
+		return false;
+	}
+
+	return data.newEvent;
+}
+
+int vpapi_check_event(void)
+{
+	fd_set ex_fds;
+	struct timeval timeout = {0, 1};
+	int ret;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return 1;
+	}
+
+	FD_ZERO(&ex_fds);
+	FD_SET(dev_fd, &ex_fds);
+
+	/* Wait for event  */
+	ret = select(dev_fd+1, NULL, NULL, &ex_fds, &timeout);
+
+	if(FD_ISSET(dev_fd, &ex_fds))
+		return 0;
+	else
+		return 1;
+}
+
+int vpapi_battary_on(int vbh, int vbl, int vbp)
+{
+	VpModBatteryOnType data;
+
+	data.vbh = vbh;
+	data.vbl = vbl;
+	data.vbp = vbp;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_BATT_ON, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_BATT_ON) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int vpapi_battery_off(void)
+{
+	VpModBatteryOffType data;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_BATT_OFF, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_BATT_OFF) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int vpapi_slic_reg_read(VpLineIdType line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff)
+{
+	VpModRegOpType data;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	data.lineId = line_id;
+	data.cmd = cmd;
+	data.cmdLen = cmd_len;
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_REG_READ, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_REG_READ) failed\n");
+		return -1;
+	}
+
+	memcpy(buff, data.buff, cmd_len);
+
+	return 0;
+}
+
+int vpapi_slic_reg_write(VpLineIdType line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff)
+{
+	VpModRegOpType data;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	data.lineId = line_id;
+	data.cmd = cmd;
+	data.cmdLen = cmd_len;
+	memcpy(data.buff, buff, cmd_len);
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_REG_WRITE, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_REG_WRITE) failed\n");
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/tools/voice/vpapi_lib.h b/tools/voice/vpapi_lib.h
new file mode 100644
index 0000000..da4ab0b
--- /dev/null
+++ b/tools/voice/vpapi_lib.h
@@ -0,0 +1,102 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _VPAPI_LIB_H
+#define _VPAPI_LIB_H
+
+#include <stdbool.h>
+#include <slic/vpapi_dev.h>
+
+typedef struct vpapi_init_device_params {
+	unsigned short dev_size;
+	unsigned short ac_size;
+	unsigned short dc_size;
+	unsigned short ring_size;
+	unsigned short fxo_ac_size;
+	unsigned short fxo_cfg_size;
+} vpapi_init_device_params_t;
+
+int vpapi_open_device(void);
+int vpapi_close_device(void);
+int vpapi_check_event(void);
+VpStatusType vpapi_make_dev_object(VpDeviceType dev_type, VpDeviceIdType dev_id);
+VpStatusType vpapi_make_line_object(VpTermType term_type, VpLineIdType line_id);
+VpStatusType vpapi_map_line_id(VpLineIdType line_id);
+VpStatusType vpapi_map_slac_id(VpDeviceIdType dev_id, unsigned char slac_id);
+VpStatusType vpapi_free_line_context(VpLineIdType line_id);
+VpStatusType vpapi_init_device(VpDeviceIdType dev_id, VpProfilePtrType dev_profile_ptr,
+				VpProfilePtrType ac_profile_ptr, VpProfilePtrType dc_profile_ptr,
+				VpProfilePtrType ring_profile_ptr, VpProfilePtrType fxo_ac_profile_ptr,
+				VpProfilePtrType fxo_cfg_profile_ptr, vpapi_init_device_params_t *params_ptr);
+VpStatusType vpapi_cal_line(VpLineIdType line_id);
+VpStatusType vpapi_set_line_state(VpLineIdType line_id, VpLineStateType state);
+VpStatusType vpapi_set_option(unsigned char line_request, VpLineIdType line_id, VpDeviceIdType dev_id,
+				VpOptionIdType option, void *value_p);
+bool vpapi_get_event(VpDeviceIdType dev_id, VpEventType *event_p);
+int vpapi_battary_on(int vbh, int vbl, int vbp);
+int vpapi_battery_off(void);
+int vpapi_slic_reg_read(VpLineIdType line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff);
+int vpapi_slic_reg_write(VpLineIdType line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff);
+
+#endif /* _VPAPI_LIB_H */
-- 
1.7.5.4

