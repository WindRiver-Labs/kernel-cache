From 9fc609d0083fe0ef722947659b78dba1a4410440 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Mon, 29 Jul 2013 14:56:32 +0300
Subject: [PATCH 0894/1825] PPv2: add flags to plat_data, arrange boot time
 prints

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit f7d212c4332bb0f2357817fe4828ede7d55fc867

        - use flags in pp2 plat_data that provide info:
                - port is RGMII/SGMII
                - port is LB
                - port is connected to Linux netdevice
        - remove old port str config
        - re-arrange PPv2 prints at boot time so info printing will look better

Change-Id: Ia7bb5730455cf68e373ea034c92370d5e4032b81
Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2869
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/core.c                      |   10 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  196 ++++----------------
 include/linux/mv_pp2.h                             |   13 +-
 3 files changed, 56 insertions(+), 163 deletions(-)

diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index ca4a017..0931ddb 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -524,11 +524,11 @@ static void mv_pp2_giga_pdev_register(struct platform_device *pdev)
 	plat_data->ctrl_rev = mvCtrlRevGet();
 	plat_data->cpu_mask  = group_cpu_mask;
 	plat_data->phy_addr = mvBoardPhyAddrGet(port);
-	plat_data->lb_enable = mvBoardIsPortLoopback(port);
-	plat_data->is_sgmii = MV_FALSE;
-	plat_data->is_rgmii = MV_FALSE;
 	plat_data->duplex = DUPLEX_FULL;
 
+	if (mvBoardIsPortLoopback(port))
+		plat_data->flags |= MV_PP2_PDATA_F_LB;
+
 	if (port < MV_UBOOT_ETH_PORTS) {
 		plat_data->mtu = mvMtu[port];
 		if (plat_data->mtu == 0) {
@@ -573,6 +573,7 @@ static struct resource mv_pp2_ge0_resources[] = {
 static struct mv_pp2_pdata mv_pp2_ge0_pdata = {
 	.mtu		= 1500,
 	.phy_addr	= 0,
+	.flags		= MV_PP2_PDATA_F_LINUX_CONNECT,
 };
 
 static struct platform_device mv_pp2_ge0_plat = {
@@ -596,6 +597,7 @@ static struct resource mv_pp2_ge1_resources[] = {
 static struct mv_pp2_pdata mv_pp2_ge1_pdata = {
 	.mtu		= 1500,
 	.phy_addr	= 0,
+	.flags		= MV_PP2_PDATA_F_LINUX_CONNECT,
 };
 
 static struct platform_device mv_pp2_ge1_plat = {
@@ -619,6 +621,7 @@ static struct resource mv_pp2_ge2_resources[] = {
 static struct mv_pp2_pdata mv_pp2_ge2_pdata = {
 	.mtu		= 1500,
 	.phy_addr	= -1,
+	.flags		= MV_PP2_PDATA_F_LINUX_CONNECT,
 };
 
 static struct platform_device mv_pp2_ge2_plat = {
@@ -634,6 +637,7 @@ static struct platform_device mv_pp2_ge2_plat = {
 static struct mv_pp2_pdata mv_pp2_ge3_pdata = {
 	.mtu		= 1500,
 	.phy_addr	= -1,
+	.flags		= MV_PP2_PDATA_F_LINUX_CONNECT,
 };
 
 static struct resource mv_pp2_ge3_resources[] = {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 7716c77..96c069a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -142,74 +142,6 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_
 			struct tx_queue *txq_ctrl, struct aggr_tx_queue *aggr_txq_ctrl);
 #endif
 
-/* Get the configuration string from the Kernel Command Line */
-static char *port0_config_str = NULL, *port1_config_str = NULL, *port2_config_str = NULL, *port3_config_str = NULL,
-	    *port4_config_str = NULL, *port5_config_str = NULL, *port6_config_str = NULL, *port7_config_str = NULL;
-int mv_eth_cmdline_port0_config(char *s);
-__setup("mv_port0_config=", mv_eth_cmdline_port0_config);
-int mv_eth_cmdline_port1_config(char *s);
-__setup("mv_port1_config=", mv_eth_cmdline_port1_config);
-int mv_eth_cmdline_port2_config(char *s);
-__setup("mv_port2_config=", mv_eth_cmdline_port2_config);
-int mv_eth_cmdline_port3_config(char *s);
-__setup("mv_port3_config=", mv_eth_cmdline_port3_config);
-int mv_eth_cmdline_port4_config(char *s);
-__setup("mv_port4_config=", mv_eth_cmdline_port4_config);
-int mv_eth_cmdline_port5_config(char *s);
-__setup("mv_port5_config=", mv_eth_cmdline_port5_config);
-int mv_eth_cmdline_port6_config(char *s);
-__setup("mv_port6_config=", mv_eth_cmdline_port6_config);
-int mv_eth_cmdline_port7_config(char *s);
-__setup("mv_port7_config=", mv_eth_cmdline_port7_config);
-
-int mv_eth_cmdline_port0_config(char *s)
-{
-	port0_config_str = s;
-	return 1;
-}
-
-int mv_eth_cmdline_port1_config(char *s)
-{
-	port1_config_str = s;
-	return 1;
-}
-
-int mv_eth_cmdline_port2_config(char *s)
-{
-	port2_config_str = s;
-	return 1;
-}
-
-int mv_eth_cmdline_port3_config(char *s)
-{
-	port3_config_str = s;
-	return 1;
-}
-
-int mv_eth_cmdline_port4_config(char *s)
-{
-	port4_config_str = s;
-	return 1;
-}
-
-int mv_eth_cmdline_port5_config(char *s)
-{
-	port5_config_str = s;
-	return 1;
-}
-
-int mv_eth_cmdline_port6_config(char *s)
-{
-	port6_config_str = s;
-	return 1;
-}
-
-int mv_eth_cmdline_port7_config(char *s)
-{
-	port7_config_str = s;
-	return 1;
-}
-
 void mv_eth_ctrl_pnc(int en)
 {
 	mv_eth_pnc_ctrl_en = en;
@@ -464,59 +396,6 @@ int mv_eth_napi_set_rxq_affinity(int port, int group, int rxq_mask)
 
 /**********************************************************/
 
-static int mv_eth_port_config_parse(struct eth_port *pp)
-{
-	char *str;
-
-	printk(KERN_ERR "\n");
-	if (pp == NULL) {
-		printk(KERN_ERR "  o mv_eth_port_config_parse: got NULL pp\n");
-		return -1;
-	}
-
-	switch (pp->port) {
-	case 0:
-		str = port0_config_str;
-		break;
-	case 1:
-		str = port1_config_str;
-		break;
-	case 2:
-		str = port2_config_str;
-		break;
-	case 3:
-		str = port3_config_str;
-		break;
-	case 4:
-		str = port4_config_str;
-		break;
-	case 5:
-		str = port5_config_str;
-		break;
-	case 6:
-		str = port6_config_str;
-		break;
-	case 7:
-		str = port7_config_str;
-		break;
-	default:
-		printk(KERN_ERR "  o mv_eth_port_config_parse: got unknown port %d\n", pp->port);
-		return -1;
-	}
-
-	if (str != NULL) {
-		if ((!strcmp(str, "disconnected")) || (!strcmp(str, "Disconnected"))) {
-			printk(KERN_ERR "  o Port %d is disconnected from Linux netdevice\n", pp->port);
-			clear_bit(MV_ETH_F_CONNECT_LINUX_BIT, &(pp->flags));
-			return 0;
-		}
-	}
-
-	printk(KERN_ERR "  o Port %d is connected to Linux netdevice\n", pp->port);
-	set_bit(MV_ETH_F_CONNECT_LINUX_BIT, &(pp->flags));
-	return 0;
-}
-
 struct eth_port *mv_eth_port_by_id(unsigned int port)
 {
 	if (mv_eth_ports && (port < mv_eth_ports_num))
@@ -3186,7 +3065,7 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 
 	port = pdev->id;
 	phys_port = MV_PPV2_PORT_PHYS(port);
-	printk(KERN_ERR "  o Loading network interface(s) for port #%d: cpu_mask=0x%x, mtu=%d\n",
+	pr_info("  o Loading network interface(s) for port #%d: cpu_mask=0x%x, mtu=%d\n",
 			port, plat_data->cpu_mask, plat_data->mtu);
 
 	mtu = mv_eth_config_get(pdev, mac);
@@ -3194,7 +3073,7 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	dev = mv_eth_netdev_init(mtu, mac, pdev);
 
 	if (dev == NULL) {
-		printk(KERN_ERR "%s: can't create netdevice\n", __func__);
+		pr_err("\to %s: can't create netdevice\n", __func__);
 		return -EIO;
 	}
 
@@ -3208,6 +3087,15 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 		return err;
 	}
 
+	if (plat_data->flags & MV_PP2_PDATA_F_LINUX_CONNECT) {
+		pr_info("\to Port %d is connected to Linux netdevice\n", port);
+		set_bit(MV_ETH_F_CONNECT_LINUX_BIT, &(pp->flags));
+	} else {
+		pr_info("\to Port %d is disconnected from Linux netdevice\n", pp->port);
+		clear_bit(MV_ETH_F_CONNECT_LINUX_BIT, &(pp->flags));
+	}
+
+
 	pp->cpuMask = plat_data->cpu_mask;
 
 	switch (plat_data->speed) {
@@ -3228,7 +3116,7 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 		force_link = 0;
 		break;
 	default:
-		pr_err("gbe #%d: unknown speed = %d\n", pp->port, plat_data->speed);
+		pr_err("\to gbe #%d: unknown speed = %d\n", pp->port, plat_data->speed);
 		return -EIO;
 	}
 
@@ -3242,18 +3130,18 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 		}
 	}
 
-	pr_info("\t%s p=%d: phy=%d,  mtu=%d, mac="MV_MACQUAD_FMT", speed=%s %s\n",
+	pr_info("\to %s p=%d: phy=%d,  mtu=%d, mac="MV_MACQUAD_FMT", speed=%s %s\n",
 		MV_PON_PORT(port) ? "pon" : "giga", port, plat_data->phy_addr, mtu,
 		MV_MACQUAD(mac), mvEthSpeedStrGet(speed), force_link ? "(force)" : "");
 
 	if (mv_eth_hal_init(pp)) {
-		printk(KERN_ERR "%s: can't init eth hal\n", __func__);
+		pr_err("\to %s: can't init eth hal\n", __func__);
 		mv_eth_priv_cleanup(pp);
 		return -EIO;
 	}
 
 	if (mv_eth_netdev_connect(pp) < 0) {
-		printk(KERN_ERR "%s: can't connect to linux\n", __func__);
+		pr_err("\to %s: can't connect to linux\n", __func__);
 		mv_eth_priv_cleanup(pp);
 		return -EIO;
 	}
@@ -3287,6 +3175,8 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	mux_eth_ops.promisc_set = mv_eth_port_promisc_set;
 	mv_mux_eth_attach(pp->port, pp->dev, &mux_eth_ops);
 
+	pr_info("\n");
+
 	return 0;
 }
 
@@ -3561,7 +3451,7 @@ static void mv_eth_shared_cleanup(void)
 static int mv_eth_probe(struct platform_device *pdev)
 {
 	struct mv_pp2_pdata *plat_data = (struct mv_pp2_pdata *)pdev->dev.platform_data;
-	int phyAddr, port = pdev->id;
+	int phyAddr, is_sgmii, is_rgmii, port = pdev->id;
 
 	if (!mv_eth_initialized) {
 
@@ -3571,27 +3461,26 @@ static int mv_eth_probe(struct platform_device *pdev)
 			return -ENODEV;
 	}
 
-	if (!MV_PON_PORT(pdev->id)) {
-		if (!plat_data->lb_enable) {
-			/* Set the board information regarding PHY address */
-			phyAddr = plat_data->phy_addr;
-			if (phyAddr != -1)
-				mvEthPhyAddrSet(pdev->id, phyAddr);
-		}
+	if (!MV_PON_PORT(port)) {
+		/* Set the board information regarding PHY address */
+		phyAddr = plat_data->phy_addr;
+		if (phyAddr != -1)
+			mvEthPhyAddrSet(port, phyAddr);
+
+		is_sgmii = (plat_data->flags & MV_PP2_PDATA_F_SGMII) ? 1 : 0;
+		is_rgmii = (plat_data->flags & MV_PP2_PDATA_F_RGMII) ? 1 : 0;
 
-		if (plat_data->lb_enable)
-			mvEthPortLbSet(port, (plat_data->speed == SPEED_1000), plat_data->is_sgmii);
+		if (plat_data->flags & MV_PP2_PDATA_F_LB)
+			mvEthPortLbSet(port, (plat_data->speed == SPEED_1000), is_sgmii);
 
-		mvEthPortPowerUp(port, plat_data->is_sgmii, plat_data->is_rgmii);
+		mvEthPortPowerUp(port, is_sgmii, is_rgmii);
 	}
 
 	if (mv_eth_load_network_interfaces(pdev))
 		return -ENODEV;
 
 	/* used in mv_eth_all_ports_probe */
-	plats[pdev->id] = pdev;
-
-	printk(KERN_ERR "\n");
+	plats[port] = pdev;
 
 	return 0;
 }
@@ -3676,7 +3565,7 @@ static int mv_eth_netdev_connect(struct eth_port *pp)
 	int cpu;
 
 	if (!pp) {
-		printk(KERN_ERR "failed to register, uninitialized port\n");
+		pr_err("\to failed to register, uninitialized port\n");
 		return -ENODEV;
 	}
 
@@ -3690,13 +3579,11 @@ static int mv_eth_netdev_connect(struct eth_port *pp)
 	if (pp->flags & MV_ETH_F_CONNECT_LINUX) {
 		mv_eth_netdev_init_features(pp->dev);
 		if (register_netdev(dev)) {
-			printk(KERN_ERR "failed to register %s\n", dev->name);
+			pr_err("\to failed to register %s\n", dev->name);
 			free_netdev(dev);
 			return -ENODEV;
-		} else {
-			printk(KERN_ERR "    o %s, ifindex = %d, GbE port = %d", dev->name, dev->ifindex, pp->port);
-			printk(KERN_CONT "\n");
-		}
+		} else
+			pr_info("\to %s, ifindex = %d, GbE port = %d", dev->name, dev->ifindex, pp->port);
 	}
 
 	return MV_OK;
@@ -4532,9 +4419,7 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 		pp->txq_dscp_map[i] = MV_ETH_TXQ_INVALID;
 #ifdef CONFIG_MV_ETH_TX_SPECIAL
 	pp->tx_special_check = NULL;
-#endif /* CONFIG_MV_ETH_TX_SPECIAL */
-
-	mv_eth_port_config_parse(pp);
+#endif
 
 #ifdef CONFIG_MV_INCLUDE_PON
 	if (MV_PON_PORT(port)) {
@@ -4562,13 +4447,14 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	pp->extBufSize = CONFIG_MV_ETH_EXTRA_BUF_SIZE;
 	pp->extArrStack = mvStackCreate(CONFIG_MV_ETH_EXTRA_BUF_NUM);
 	if (pp->extArrStack == NULL) {
-		printk(KERN_ERR "Error: failed create  extArrStack for port #%d\n", port);
+		pr_err("\to %s: Error: failed create  extArrStack for port #%d\n", __func__, port);
 		return -ENOMEM;
 	}
+
 	for (i = 0; i < CONFIG_MV_ETH_EXTRA_BUF_NUM; i++) {
 		ext_buf = mvOsMalloc(CONFIG_MV_ETH_EXTRA_BUF_SIZE);
 		if (ext_buf == NULL) {
-			printk(KERN_WARNING "%s Warning: %d of %d extra buffers allocated\n",
+			pr_warn("\to %s Warning: %d of %d extra buffers allocated\n",
 				__func__, i, CONFIG_MV_ETH_EXTRA_BUF_NUM);
 			break;
 		}
@@ -4581,7 +4467,7 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 		pp->dist_stats.rx_dist_size = pp->rxq_num * CONFIG_MV_ETH_RXQ_DESC + 1;
 		memset(pp->dist_stats.rx_dist, 0, sizeof(u32) * pp->dist_stats.rx_dist_size);
 	} else
-		printk(KERN_ERR "ethPort #%d: Can't allocate %d bytes for rx_dist\n",
+		pr_err("\to ethPort #%d: Can't allocate %d bytes for rx_dist\n",
 		       pp->port, sizeof(u32) * (pp->rxq_num * CONFIG_MV_ETH_RXQ_DESC + 1));
 
 	pp->dist_stats.tx_done_dist =
@@ -4590,9 +4476,9 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 		pp->dist_stats.tx_done_dist_size = pp->txp_num * CONFIG_MV_ETH_TXQ * CONFIG_MV_ETH_TXQ_DESC + 1;
 		memset(pp->dist_stats.tx_done_dist, 0, sizeof(u32) * pp->dist_stats.tx_done_dist_size);
 	} else
-		printk(KERN_ERR "ethPort #%d: Can't allocate %d bytes for tx_done_dist\n",
+		pr_err("\to ethPort #%d: Can't allocate %d bytes for tx_done_dist\n",
 		       pp->port, sizeof(u32) * (pp->txp_num * CONFIG_MV_ETH_TXQ * CONFIG_MV_ETH_TXQ_DESC + 1));
-#endif /* CONFIG_MV_ETH_STAT_DIST */
+#endif
 
 	return 0;
 }
diff --git a/include/linux/mv_pp2.h b/include/linux/mv_pp2.h
index b62fe59..cc40c8d 100644
--- a/include/linux/mv_pp2.h
+++ b/include/linux/mv_pp2.h
@@ -68,6 +68,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define MV_PP2_PORT_NAME	"mv_pp2_port"
 
+/* valid values for flags */
+#define MV_PP2_PDATA_F_SGMII		0x1 /* MAC connected to PHY via SGMII, PCS block is active */
+#define MV_PP2_PDATA_F_RGMII		0x2 /* MAC connected to PHY via RGMII */
+#define MV_PP2_PDATA_F_LB		0x4 /* This port is serve as LoopBack port */
+#define MV_PP2_PDATA_F_LINUX_CONNECT	0x8 /* This port is connected to Linux */
+
 struct mv_pp2_pdata {
 
 	/* Global parameters common for all ports */
@@ -96,11 +102,6 @@ struct mv_pp2_pdata {
 	int      speed;
 	int      duplex;
 
-	/* Port configuration: indicates if this port is LB, and if PCS block is active */
-	int	lb_enable;
-	int	is_sgmii;
-	int	is_rgmii;
-
 	/*
 	* How many RX/TX queues to use.
 	*/
@@ -112,6 +113,8 @@ struct mv_pp2_pdata {
 	*/
 	int      rx_queue_size;
 	int      tx_queue_size;
+
+	unsigned int flags;
 };
 
 
-- 
1.7.5.4

