From 745418d778550ceb0304c3b9a80cf7ca887a3541 Mon Sep 17 00:00:00 2001
From: Dovrat <dovrat@marvell.com>
Date: Wed, 7 May 2014 12:22:49 +0300
Subject: [PATCH 1636/1825] pp3: qm: new debug functions in sysfs

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit fc0b7058580b1f3c62cd901138271767b1841a79

Change-Id: I6dba07db8322780da82a832fbe6ce681ab6f0b38
Signed-off-by: Dovrat <dovrat@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7865
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c |  198 ++++++++++++++++++---
 1 files changed, 169 insertions(+), 29 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c b/drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c
index b4e04ef..5cef9c7 100644
--- a/drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c
+++ b/drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c
@@ -162,7 +162,7 @@ static ssize_t mv_qm_config(struct device *dev,
 					else
 						pr_info("there are no packets in Q's");
 					qm_idle_status_get(&status);
-					pr_info("idle status is %x\n", status);
+					pr_info("idle status is 0x%x\n", status);
 				}
 			}
 		}
@@ -203,26 +203,6 @@ static ssize_t mv_qm_config(struct device *dev,
 		rc = qm_dma_gpm_pools_enable(qece_thr_hi, qece_thr_lo, pl_thr_hi, pl_thr_lo);
 		if (rc != OK)
 			PR_ERR_CODE(rc)
-	} else if (!strcmp(name, "register_read")) {
-		u32 base_address, offset, wordsNumber, dataPtr;
-
-		PR_INFO_CALLED
-		base_address = offset = wordsNumber = dataPtr = 0xFFFFFFFF;
-		/* Read input values */
-		sscanf(buf, "%x %x %x %x", &base_address, &offset, &wordsNumber, &dataPtr);
-		rc = qm_register_read(base_address, offset, wordsNumber, (u32 *)&dataPtr);
-		if (rc != OK)
-			PR_ERR_CODE(rc)
-	} else if (!strcmp(name, "register_write")) {
-		u32 base_address, offset, wordsNumber, dataPtr;
-
-		PR_INFO_CALLED
-		base_address = offset = wordsNumber = dataPtr = 0xFFFFFFFF;
-		/* Read input values */
-		sscanf(buf, "%x %x %x %x", &base_address, &offset, &wordsNumber, &dataPtr);
-		rc = qm_register_write(base_address, offset, wordsNumber, (u32 *)&dataPtr);
-		if (rc != OK)
-			PR_ERR_CODE(rc)
 	} else {
 		err = 1;
 		pr_err("%s: wrong name of QM function <%s>\n", __func__, attr->attr.name);
@@ -240,8 +220,6 @@ static DEVICE_ATTR(close,                           S_IWUSR, NULL,       mv_qm_c
 static DEVICE_ATTR(default_set,                     S_IWUSR, NULL,       mv_qm_config);
 static DEVICE_ATTR(dma_gpm_pools_def_enable,        S_IWUSR, NULL,       mv_qm_config);
 static DEVICE_ATTR(dma_dram_pools_def_enable,       S_IWUSR, NULL,       mv_qm_config);
-static DEVICE_ATTR(qm_register_read,                S_IWUSR, NULL,       mv_qm_config);
-static DEVICE_ATTR(qm_register_write,               S_IWUSR, NULL,       mv_qm_config);
 
 
 static struct attribute *mv_qm_attrs[] = {
@@ -252,27 +230,189 @@ static struct attribute *mv_qm_attrs[] = {
 	&dev_attr_default_set.attr,
 	&dev_attr_dma_gpm_pools_def_enable.attr,
 	&dev_attr_dma_dram_pools_def_enable.attr,
-	&dev_attr_qm_register_read.attr,
-	&dev_attr_qm_register_write.attr,
 	NULL
 };
 
-
 static struct attribute_group mv_qm_group = {
-	.name = "qm",
 	.attrs = mv_qm_attrs,
 };
 
+static ssize_t mv_qm_debug_help(char *b)
+{
+	int o = 0; /* buffer offset */
+	int s = PAGE_SIZE; /* buffer size */
+
+	o += scnprintf(b+o, s-o, "\n");
+	o += scnprintf(b+o, s-o, "echo             > errors_dump           - Print error registers\n");
+	o += scnprintf(b+o, s-o, "echo             > global_dump           - Print global registers\n");
+	o += scnprintf(b+o, s-o, "echo             > nempty_queue_len_dump - Print length of non-empty queues\n");
+	o += scnprintf(b+o, s-o, "echo q           > queue_dump            - print Q registers\n");
+	o += scnprintf(b+o, s-o, "echo q           > queue_no_traffic_dump - Print registers when there is no traffic\n");
+	o += scnprintf(b+o, s-o, "echo p           > dqf_port_dump         - Print dequeue fifo registers\n");
+	o += scnprintf(b+o, s-o, "\n");
+	o += scnprintf(b+o, s-o, "parameters: [p]    port\n");
+	o += scnprintf(b+o, s-o, "            [q]    queue\n");
+	o += scnprintf(b+o, s-o, "\n");
+
+	return o;
+}
+
+static ssize_t mv_qm_debug_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	const char      *name = attr->attr.name;
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "help_debug")) {
+		off = mv_qm_debug_help(buf);
+	} else if (!strcmp(name, "help")) {
+		off = mv_qm_debug_help(buf);
+	} else {
+		off = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	return off;
+}
+
+static ssize_t mv_qm_debug_config(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int rc = -QM_INPUT_NOT_IN_RANGE;
+	int             err = 0;
+
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "errors_dump")) {
+		rc = qm_errors_dump();
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "global_dump")) {
+		rc = qm_global_dump();
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "queue_dump")) {
+		u32 queue;
+		queue = 0xFFFFFFFF;
+		/* Read input values */
+		sscanf(buf, "%d", &queue);
+		rc = qm_queue_dump(queue);
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "queue_no_traffic_dump")) {
+		u32 queue;
+		queue = 0xFFFFFFFF;
+		/* Read input values */
+		sscanf(buf, "%d", &queue);
+		rc = qm_queue_no_traffic_dump(queue);
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "nempty_queue_len_dump")) {
+		rc = qm_nempty_queue_len_dump();
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "dqf_port_dump")) {
+		u32 port;
+		port = 0xFFFFFFFF;
+		/* Read input values */
+		sscanf(buf, "%d", &port);
+		rc = qm_dqf_port_dump(port);
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "register_read")) {
+		u32 base_address, offset, wordsNumber, dataPtr, i;
+		u32 sili_base = mv_hw_silicon_base_addr_get();
+		base_address = offset = wordsNumber = dataPtr = 0xFFFFFFFF;
+		/* Read input values */
+		sscanf(buf, "%x %x %x", &base_address, &offset, &wordsNumber);
+		for (i = 0; i < wordsNumber; i++) {
+			rc = qm_register_read(sili_base+base_address+i*sizeof(u32), offset, wordsNumber, &dataPtr);
+			if (rc != OK)
+				PR_ERR_CODE(rc)
+			pr_info("%x %x", sili_base+base_address+i*sizeof(u32), dataPtr);
+		}
+	} else if (!strcmp(name, "register_write")) {
+		u32 base_address, offset, dataPtr;
+		u32 sili_base = mv_hw_silicon_base_addr_get();
+		base_address = offset = dataPtr = 0xFFFFFFFF;
+		/* Read input values */
+		sscanf(buf, "%x %x %x", &base_address, &offset, &dataPtr);
+		rc = qm_register_write(sili_base+base_address, offset, 1, &dataPtr);
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else {
+		err = 1;
+		pr_err("%s: wrong name of QM function <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	return err ? -EINVAL : len;
+}
+
+
+static DEVICE_ATTR(help_debug,                S_IRUSR, mv_qm_debug_show, NULL);
+static DEVICE_ATTR(errors_dump,               S_IWUSR, NULL,       mv_qm_debug_config);
+static DEVICE_ATTR(global_dump,               S_IWUSR, NULL,       mv_qm_debug_config);
+static DEVICE_ATTR(queue_dump,                S_IWUSR, NULL,       mv_qm_debug_config);
+static DEVICE_ATTR(queue_no_traffic_dump,     S_IWUSR, NULL,       mv_qm_debug_config);
+static DEVICE_ATTR(nempty_queue_len_dump,  S_IWUSR, NULL,       mv_qm_debug_config);
+static DEVICE_ATTR(dqf_port_dump,             S_IWUSR, NULL,       mv_qm_debug_config);
+static DEVICE_ATTR(register_read,             S_IWUSR, NULL,       mv_qm_debug_config);
+static DEVICE_ATTR(register_write,            S_IWUSR, NULL,       mv_qm_debug_config);
+
+static struct attribute *mv_qm_debug_attrs[] = {
+	&dev_attr_help_debug.attr,
+	&dev_attr_errors_dump.attr,
+	&dev_attr_global_dump.attr,
+	&dev_attr_queue_dump.attr,
+	&dev_attr_queue_no_traffic_dump.attr,
+	&dev_attr_nempty_queue_len_dump.attr,
+	&dev_attr_dqf_port_dump.attr,
+	&dev_attr_register_read.attr,
+	&dev_attr_register_write.attr,
+	NULL
+};
+
+static struct attribute_group mv_qm_debug_group = {
+	.name = "debug",
+	.attrs = mv_qm_debug_attrs,
+};
+
+
 int mv_pp3_qm_sysfs_init(struct kobject *neta_kobj)
 {
 	int err;
+	struct kobject *qm_kobj;
+
+	qm_kobj = kobject_create_and_add("qm", neta_kobj);
+	if (!qm_kobj) {
+		printk(KERN_ERR"%s: cannot create bm kobject\n", __func__);
+		return -ENOMEM;
+	}
+
+	err = sysfs_create_group(qm_kobj, &mv_qm_group);
+	if (err) {
+		pr_err(KERN_INFO "sysfs group failed for bm%d\n", err);
+		return err;
+	}
 
-	err = sysfs_create_group(neta_kobj, &mv_qm_group);
+	err = sysfs_create_group(qm_kobj, &mv_qm_debug_group);
 	if (err) {
-		pr_err(KERN_INFO "sysfs group failed for qm%d\n", err);
+		pr_err(KERN_INFO "sysfs group failed for bm debug%d\n", err);
 		return err;
 	}
 
+
 	return err;
 }
 
-- 
1.7.5.4

