From 81f81b4e30c56ba2014f9af0af8be84353560739 Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Wed, 2 Oct 2013 19:10:42 +0300
Subject: [PATCH 1010/1825] alp: Enable Hardware Semaphore WA

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit f0480f2d3dd80f58d5a86401b43c3e109b20ed6e

    Use Global Scratch Pad registers instead of using Semaphores and
    MV_AMP_GLOBAL_REG which works inconsistent.

Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>

Change-Id: If934fa13ea1773405893dc857f4cbf9293c71e92
Reviewed-on: http://vgitil04.il.marvell.com:8080/3591
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/ctrlEnv/mvSemaphore.c         |   26 ++++++++++++++++++-
 .../avanta_lp_family/ctrlEnv/mvSemaphore.h         |   27 ++++++++++++++++++++
 arch/arm/mm/Kconfig                                |   10 +++++++
 3 files changed, 62 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.c
index 3e116c3..fb5db1d 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.c
@@ -66,9 +66,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "ctrlEnv/sys/mvCpuIf.h"
 #include "cpu/mvCpu.h"
 #include "ctrlEnv/mvSemaphore.h"
+#include <linux/spinlock.h>
 
 MV_BOOL mvSemaLock(MV_32 num)
 {
+#ifdef CONFIG_ALP_HW_SEMAPHORE_WA
+	BUG_ON(num >= MV_MAX_SEMA);
+	arch_spin_lock((arch_spinlock_t *)GLOBAL_SCRATCH_PAD(num));
+#else
 	MV_U32 tmp;
 	MV_U32 cpuId;
 	if (num > MV_MAX_SEMA)
@@ -81,11 +86,16 @@ MV_BOOL mvSemaLock(MV_32 num)
 	{
 		tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
 	} while ((tmp & 0xFF) != cpuId);
+#endif
 	return MV_TRUE;
 }
 
 MV_BOOL mvSemaTryLock(MV_32 num)
 {
+#ifdef CONFIG_ALP_HW_SEMAPHORE_WA
+	BUG_ON(num >= MV_MAX_SEMA);
+	return arch_spin_trylock((arch_spinlock_t *)GLOBAL_SCRATCH_PAD(num));
+#else
 	MV_U32 tmp;
 	if (num > MV_MAX_SEMA)
 	{
@@ -99,25 +109,39 @@ MV_BOOL mvSemaTryLock(MV_32 num)
 	}
 	else
 		return MV_TRUE;
+#endif
 }
 
 MV_BOOL mvSemaUnlock(MV_32 num)
 {
+#ifdef CONFIG_ALP_HW_SEMAPHORE_WA
+	BUG_ON(num >= MV_MAX_SEMA);
+	arch_spin_unlock((arch_spinlock_t *)GLOBAL_SCRATCH_PAD(num));
+#else
 	if (num > MV_MAX_SEMA)
 	{
 		mvOsPrintf("Invalid semaphore number\n");
 		return MV_FALSE;
 	}
 	MV_REG_BYTE_WRITE(MV_SEMA_REG_BASE+(num), 0xFF);
+#endif
 	return MV_TRUE;
 }
 
 MV_32 mvReadAmpReg(int regId)
 {
+#ifdef CONFIG_ALP_HW_SEMAPHORE_WA
+	return MV_REG_READ((GLOBAL_SCRATCH_PAD_0 + (32 * regId)));
+#else
 	return MV_REG_READ(MV_AMP_GLOBAL_REG(regId));
+#endif
 }
 
 MV_32 mvWriteAmpReg(int regId, MV_32 value)
 {
+#ifdef CONFIG_ALP_HW_SEMAPHORE_WA
+	return MV_REG_WRITE((GLOBAL_SCRATCH_PAD_0 + (32 * regId)), value);
+#else
 	return MV_REG_WRITE(MV_AMP_GLOBAL_REG(regId), value);
-}
\ No newline at end of file
+#endif
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h
index 2cbc793..9431e10 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h
@@ -69,6 +69,31 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "config.h"
 #endif
 
+
+#ifdef CONFIG_ALP_HW_SEMAPHORE_WA
+/*
+ * XXX: After returning from U-Boot the value of GLOBAL_SCRATCH_PAD(0) is 0x5E
+ * instead of reset value 0x0. Next values (for GLOBAL_SCRATCH_PAD(1-7)) are
+ * correct - 0x0
+ */
+#define GLOBAL_SCRATCH_PAD_0	(0x20520)
+#define GLOBAL_SCRATCH_PAD(x)	(INTER_REGS_VIRT_BASE \
+					   | (GLOBAL_SCRATCH_PAD_0 + (32 * (x))))
+#define MV_MAX_SEMA		8
+
+/*
+ * Only 8 scratch reg are available
+ */
+#define ADR_WIN_EN_REG		1
+#define MV_SEMA_PEX0		2
+#define MV_SEMA_GIC		3
+#define MV_SEMA_IRQ		4
+#define MV_SEMA_CLOCK		5
+#define MV_SEMA_CLOCK_INIT	6
+#define MV_SEMA_TWSI		7
+
+#else /* CONFIG_ALP_HW_SEMAPHORE_WA */
+
 #define MV_AMP_GLOBAL_REG(x)	(0x20980 + (4*x))
 #define ADR_WIN_EN_REG			0
 
@@ -90,6 +115,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define MV_SEMA_BARRIER(cpu)	(50 + cpu)
 
+#endif /* CONFIG_ALP_HW_SEMAPHORE_WA */
+
 #define MV_LOCK_SEMA		0x10C
 
 MV_BOOL mvSemaLock(MV_32 num);
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index eedca05..a0e80a9 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -1217,6 +1217,16 @@ config ALP_IOCC_SYNC_BARRIER_WA
 	  This WA enables driver to keep in sync with memory
 	  updated by IO engine.
 
+config ALP_HW_SEMAPHORE_WA
+	depends on ARCH_AVANTA_LP && MV_AMP_ENABLE
+	bool "Enable Hardware Semaphore WA"
+	default y
+	help
+	  Enable Hardware Semaphores work-around using GLOBAL_SCRATCH_PAD
+	  register with ldrex/strex access instead of using MV_SEMA_REG_BASE
+	  which works inconsistent.
+	  This woekarounf is needed due to bug in HW semaphores in Z1 SoC stepping.
+
 config CPU_PMC_ACCESS_IN_USERMODE
 	bool "Enabled User mode access for PMC"
 	depends on CPU_V7
-- 
1.7.5.4

