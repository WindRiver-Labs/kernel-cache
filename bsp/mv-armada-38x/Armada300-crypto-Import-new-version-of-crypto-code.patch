From e9db17ca39b00faea7cb69ec3591fc59de65e7a1 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Wed, 22 Oct 2014 11:06:18 +0800
Subject: [PATCH 1795/1825] Armada300,crypto: Import new version of crypto
 code.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 060af136db3fda96b3f4290d3dbc758ed48d39d9

Change-Id: I0798b807ab5c270fdb2dcfb41e1c6272ce4e45dd
Signed-off-by: Tawfik Bayouk <tawfik@marvell.com>
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 cesa/openswan/README                               |   10 +-
 crypto/Makefile                                    |    1 +
 crypto/algif_hash.c                                |    5 +-
 crypto/algif_skcipher.c                            |    4 +-
 crypto/ansi_cprng.c                                |    4 +-
 crypto/authenc.c                                   |    7 +-
 crypto/ccm.c                                       |    3 +-
 crypto/ocf/Config.in                               |    4 +
 crypto/ocf/Kconfig                                 |   24 +
 crypto/ocf/Makefile                                |  109 ++-
 crypto/ocf/c7108/aes-7108.c                        |  196 ++--
 crypto/ocf/c7108/aes-7108.h                        |   52 +-
 crypto/ocf/criov.c                                 |   10 +-
 crypto/ocf/crypto.c                                |  220 +++--
 crypto/ocf/cryptocteon/README.txt                  |   11 +
 crypto/ocf/cryptocteon/cavium_crypto.c             |    8 +-
 crypto/ocf/cryptodev.c                             |   50 +-
 crypto/ocf/cryptodev.h                             |    7 +-
 crypto/ocf/cryptosoft.c                            |  854 +++++++++++++-----
 crypto/ocf/ep80579/Makefile                        |   38 +-
 crypto/ocf/ep80579/environment.mk                  |    3 +
 crypto/ocf/ep80579/icp_asym.c                      |  201 ++---
 crypto/ocf/ep80579/icp_common.c                    |  550 +++++-------
 crypto/ocf/ep80579/icp_ocf.h                       |  333 ++++----
 crypto/ocf/ep80579/icp_sym.c                       |  411 ++-------
 crypto/ocf/hifn/hifn7751.c                         |   42 +-
 crypto/ocf/hifn/hifn7751var.h                      |    1 -
 crypto/ocf/hifn/hifnHIPP.c                         |    4 +-
 crypto/ocf/ixp4xx/ixp4xx.c                         |   27 +-
 crypto/ocf/kirkwood/cesa/AES/mvAes.h               |   28 +-
 crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c            |   60 +-
 crypto/ocf/kirkwood/cesa/AES/mvAesApi.c            |  124 ++--
 crypto/ocf/kirkwood/cesa/AES/mvAesBoxes.dat        |  123 +++
 crypto/ocf/kirkwood/cesa/mvCesa.c                  |  124 ++--
 crypto/ocf/kirkwood/cesa/mvCesa.h                  |    4 +-
 crypto/ocf/kirkwood/cesa/mvCesaDebug.c             |   34 +-
 crypto/ocf/kirkwood/cesa/mvCesaRegs.h              |  714 +++++++-------
 crypto/ocf/kirkwood/cesa/mvCesaTest.c              |    8 +-
 crypto/ocf/kirkwood/cesa/mvLru.c                   |   62 +-
 crypto/ocf/kirkwood/cesa/mvLru.h                   |   56 +-
 crypto/ocf/kirkwood/cesa/mvMD5.c                   |   92 +--
 crypto/ocf/kirkwood/cesa/mvMD5.h                   |   68 +-
 crypto/ocf/kirkwood/cesa/mvSHA1.c                  |   93 +--
 crypto/ocf/kirkwood/cesa/mvSHA1.h                  |   70 +-
 crypto/ocf/kirkwood/cesa_ocf_drv.c                 |  150 ++--
 crypto/ocf/kirkwood/mvHal/common/mv802_3.h         |   66 +-
 crypto/ocf/kirkwood/mvHal/common/mvCommon.c        |   68 +-
 crypto/ocf/kirkwood/mvHal/common/mvCommon.h        |   76 +-
 crypto/ocf/kirkwood/mvHal/common/mvDebug.c         |  124 ++--
 crypto/ocf/kirkwood/mvHal/common/mvDebug.h         |   72 +-
 crypto/ocf/kirkwood/mvHal/common/mvDeviceId.h      |   62 +-
 crypto/ocf/kirkwood/mvHal/common/mvHalVer.h        |  144 ++--
 crypto/ocf/kirkwood/mvHal/common/mvStack.c         |   38 +-
 crypto/ocf/kirkwood/mvHal/common/mvStack.h         |   34 +-
 crypto/ocf/kirkwood/mvHal/dbg-trace.c              |    2 +-
 crypto/ocf/kirkwood/mvHal/dbg-trace.h              |    2 +-
 .../mvHal/kw_family/boardEnv/mvBoardEnvLib.c       |  116 ++--
 .../mvHal/kw_family/boardEnv/mvBoardEnvLib.h       |    2 +-
 .../mvHal/kw_family/boardEnv/mvBoardEnvSpec.c      |  350 ++++----
 .../mvHal/kw_family/boardEnv/mvBoardEnvSpec.h      |    2 +-
 crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.c    |  166 +---
 crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.h    |   60 +-
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c     |  194 ++--
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.h     |  100 +-
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvAsm.h         |   58 +-
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c         |  264 +++---
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h         |   66 +-
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h        |   92 +-
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvSpec.h        |   62 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.h      |   60 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h  |   62 +-
 .../kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c |    4 +-
 .../kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.h |   62 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvCpuIfInit.S      |  163 ++++
 .../mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h      |   78 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c       |  106 ++--
 .../mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h       |   60 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysCesa.c        |   56 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysCesa.h        |    4 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysDram.c        |   96 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysDram.h        |   60 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysGbe.c         |  144 ++--
 .../mvHal/kw_family/ctrlEnv/sys/mvSysGbe.h         |   62 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysPex.c         |  250 +++---
 .../mvHal/kw_family/ctrlEnv/sys/mvSysPex.h         |   84 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysSata.c        |  116 ++--
 .../mvHal/kw_family/ctrlEnv/sys/mvSysSata.h        |  256 +++---
 .../mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c       |  116 ++--
 .../mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h       |  250 +++---
 .../mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c         |  924 +++++++++---------
 .../mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h         |   60 +-
 .../kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.c |   24 +-
 .../kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.h |   58 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysUsb.h         |   60 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysXor.c         |  162 ++--
 .../mvHal/kw_family/ctrlEnv/sys/mvSysXor.h         |   66 +-
 .../ocf/kirkwood/mvHal/kw_family/device/mvDevice.c |   68 +-
 .../ocf/kirkwood/mvHal/kw_family/device/mvDevice.h |   58 +-
 .../kirkwood/mvHal/kw_family/device/mvDeviceRegs.h |   60 +-
 crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c         |   42 +-
 crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h         |   60 +-
 crypto/ocf/kirkwood/mvHal/linux_oss/mvOsSata.h     |   22 +-
 crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h          |   36 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c   |  110 ++--
 crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.h   |   62 +-
 .../ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmrRegs.h  |   62 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.c  |   34 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h  |   32 +-
 .../ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.c   |   16 +-
 .../ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h   |   32 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c   |  562 ++++++------
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.h   |   92 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c |  470 +++++-----
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.h |   82 +-
 .../mvHal/mv_hal/ddr1_2/mvDramIfBasicInit.S        |  988 ++++++++++++++++++++
 .../kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S  |  668 +++++++++++++
 .../kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.h  |   66 +-
 .../kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfRegs.h    |   70 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c   |  400 ++++----
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.h   |   72 +-
 .../kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S |  986 +++++++++++++++++++
 .../kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S    |  528 +++++++++++
 .../kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.h    |   64 +-
 .../ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfRegs.h  |   80 +-
 .../mvHal/mv_hal/ddr2/mvDramIfStaticInit.h         |  182 ++--
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c  |  560 ++++++------
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.h  |   92 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c   |  388 ++++----
 .../ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.c |  358 ++++----
 .../ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.h |   60 +-
 .../ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h   |  116 ++--
 .../ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthRegs.h  |  112 ++--
 crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h       |   84 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c       |   90 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h       |   60 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGppRegs.h   |   60 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c  |  134 ++--
 crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h  |   60 +-
 .../ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h |   80 +-
 .../mvHal/mv_hal/pci-if/pci_util/mvPciUtils.h      |   74 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c       |  228 +++---
 crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h       |   64 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h   |   74 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c       |  256 +++---
 crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.h       |   60 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h   |  124 ++--
 crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c |  626 +++++++-------
 crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.h |  164 ++--
 crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c |    4 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.h       |   58 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h   |   56 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c     |  158 ++--
 crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h     |   60 +-
 .../ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiEeprom.S  |  457 +++++++++
 crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiSpec.h |   62 +-
 crypto/ocf/ocf-bench.c                             |  136 +++-
 crypto/ocf/ocf-compat.h                            |  116 +++-
 crypto/ocf/ocfnull/ocfnull.c                       |    9 +-
 crypto/ocf/pasemi/pasemi.c                         |   10 +-
 crypto/ocf/random.c                                |   10 +-
 crypto/ocf/rndtest.c                               |    8 +-
 crypto/ocf/safe/safe.c                             |   76 +--
 crypto/ocf/safe/safevar.h                          |    3 +-
 crypto/ocf/talitos/talitos.c                       |   16 +-
 crypto/ocf/talitos/talitos_soft.h                  |    1 -
 crypto/ocf/ubsec_ssb/bsdqueue.h                    |   14 +-
 crypto/ocf/ubsec_ssb/ubsec_ssb.c                   |  116 ++--
 crypto/ocf/uio.h                                   |    4 +-
 168 files changed, 13044 insertions(+), 8920 deletions(-)
 create mode 100644 crypto/ocf/cryptocteon/README.txt
 create mode 100644 crypto/ocf/kirkwood/cesa/AES/mvAesBoxes.dat
 create mode 100644 crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfInit.S
 create mode 100644 crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfBasicInit.S
 create mode 100644 crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S
 create mode 100644 crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S
 create mode 100644 crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S
 create mode 100644 crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiEeprom.S

diff --git a/cesa/openswan/README b/cesa/openswan/README
index fcd68f4..ccbd457 100644
--- a/cesa/openswan/README
+++ b/cesa/openswan/README
@@ -2,12 +2,13 @@ OpenSWAN
 =========
 In order to explore the CESA through the OpenSWAN, please follow the next steps:
 
-1. Download openswan-2.6.37 (http://www.openswan.org/), then untar+unzip it.
+1. Download openswan-2.6.38 (http://www.openswan.org/), then untar+unzip it.
  
 2. Apply the patch:
-	- mv_openswan_2_6_37.patch:
+	- 0001-marvell-patch-for-openswan-2.6.38.patch:
 		> Disable default DEBUG support.
 		> Enable OCF support.
+		> Set OCF flag CRYPTO_F_CBIMM to mark immediate callback handling.
 
 3. Compile:
 
@@ -20,7 +21,7 @@ In order to explore the CESA through the OpenSWAN, please follow the next steps:
   'make KERNELSRC=<path to this release, after config> programs'
   'make install'
 
-Note: before tunnel is enabled on target, reverse path filtering(rp_filter) must be disabled under sysfs, using
+4. Before tunnel is enabled on target, reverse path filtering(rp_filter) must be disabled under sysfs, using
       the following commands:
       - echo 0  > /proc/sys/net/ipv4/conf/eth<x>/rp_filter
       - echo 0  > /proc/sys/net/ipv4/conf/all/rp_filter
@@ -29,6 +30,9 @@ Reverse Path Filtering(rp_filter): it is a technology that is used on IP routers
 which is often used for DenialOfService attacks. RPF works by checking the source IP of each packet received on an interface
 against the routing table. If the best route for the source IP address does not use the same interface that the packet was received on the packet is dropped.
 
+5. Before tunnel is enabled on target, PMTU discovery must be disabled under procfs, using the following command:
+      - echo 1 > /proc/sys/net/ipv4/ip_no_pmtu_disc
+
 IPSec routing using encryption/authentication only:
 
   basic vpn connection:
diff --git a/crypto/Makefile b/crypto/Makefile
index e05fd2e..07f3d5c 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -91,6 +91,7 @@ obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
 obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
 obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 obj-$(CONFIG_OCF_OCF) += ocf/
+
 #
 # generic algorithms and the async_tx api
 #
diff --git a/crypto/algif_hash.c b/crypto/algif_hash.c
index 8502462..0262210 100644
--- a/crypto/algif_hash.c
+++ b/crypto/algif_hash.c
@@ -114,9 +114,6 @@ static ssize_t hash_sendpage(struct socket *sock, struct page *page,
 	struct hash_ctx *ctx = ask->private;
 	int err;
 
-	if (flags & MSG_SENDPAGE_NOTLAST)
-		flags |= MSG_MORE;
-
 	lock_sock(sk);
 	sg_init_table(ctx->sgl.sg, 1);
 	sg_set_page(ctx->sgl.sg, page, size, offset);
@@ -164,6 +161,8 @@ static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
 	else if (len < ds)
 		msg->msg_flags |= MSG_TRUNC;
 
+	msg->msg_namelen = 0;
+
 	lock_sock(sk);
 	if (ctx->more) {
 		ctx->more = 0;
diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c
index a19c027..a1c4f0a 100644
--- a/crypto/algif_skcipher.c
+++ b/crypto/algif_skcipher.c
@@ -378,9 +378,6 @@ static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
 	struct skcipher_sg_list *sgl;
 	int err = -EINVAL;
 
-	if (flags & MSG_SENDPAGE_NOTLAST)
-		flags |= MSG_MORE;
-
 	lock_sock(sk);
 	if (!ctx->more && ctx->used)
 		goto unlock;
@@ -435,6 +432,7 @@ static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
 	long copied = 0;
 
 	lock_sock(sk);
+	msg->msg_namelen = 0;
 	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
 	     iovlen--, iov++) {
 		unsigned long seglen = iov->iov_len;
diff --git a/crypto/ansi_cprng.c b/crypto/ansi_cprng.c
index c21f761..6ddd99e 100644
--- a/crypto/ansi_cprng.c
+++ b/crypto/ansi_cprng.c
@@ -230,11 +230,11 @@ remainder:
 	 */
 	if (byte_count < DEFAULT_BLK_SZ) {
 empty_rbuf:
-		while (ctx->rand_data_valid < DEFAULT_BLK_SZ) {
+		for (; ctx->rand_data_valid < DEFAULT_BLK_SZ;
+			ctx->rand_data_valid++) {
 			*ptr = ctx->rand_data[ctx->rand_data_valid];
 			ptr++;
 			byte_count--;
-			ctx->rand_data_valid++;
 			if (byte_count == 0)
 				goto done;
 		}
diff --git a/crypto/authenc.c b/crypto/authenc.c
index d21da2f..5ef7ba6 100644
--- a/crypto/authenc.c
+++ b/crypto/authenc.c
@@ -368,10 +368,9 @@ static void crypto_authenc_encrypt_done(struct crypto_async_request *req,
 	if (!err) {
 		struct crypto_aead *authenc = crypto_aead_reqtfm(areq);
 		struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
-		struct authenc_request_ctx *areq_ctx = aead_request_ctx(areq);
-		struct ablkcipher_request *abreq = (void *)(areq_ctx->tail
-							    + ctx->reqoff);
-		u8 *iv = (u8 *)abreq - crypto_ablkcipher_ivsize(ctx->enc);
+		struct ablkcipher_request *abreq = aead_request_ctx(areq);
+		u8 *iv = (u8 *)(abreq + 1) +
+			 crypto_ablkcipher_reqsize(ctx->enc);
 
 		err = crypto_authenc_genicv(areq, iv, 0);
 	}
diff --git a/crypto/ccm.c b/crypto/ccm.c
index 18d64ad..32fe1bb 100644
--- a/crypto/ccm.c
+++ b/crypto/ccm.c
@@ -271,8 +271,7 @@ static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,
 	}
 
 	/* compute plaintext into mac */
-	if (cryptlen)
-		get_data_to_compute(cipher, pctx, plain, cryptlen);
+	get_data_to_compute(cipher, pctx, plain, cryptlen);
 
 out:
 	return err;
diff --git a/crypto/ocf/Config.in b/crypto/ocf/Config.in
index cb01ea9..652f76e 100644
--- a/crypto/ocf/Config.in
+++ b/crypto/ocf/Config.in
@@ -25,6 +25,10 @@ dep_tristate '  pasemi (HW crypto engine)' \
 				CONFIG_OCF_PASEMI $CONFIG_OCF_OCF
 dep_tristate '  ep80579 (HW crypto engine)' \
 				CONFIG_OCF_EP80579 $CONFIG_OCF_OCF
+dep_tristate '  Micronas c7108 (HW crypto engine)' \
+				CONFIG_OCF_C7108 $CONFIG_OCF_OCF
+dep_tristate '  uBsec BCM5365 (HW crypto engine)'
+				CONFIG_OCF_UBSEC_SSB $CONFIG_OCF_OCF
 dep_tristate '  ocfnull (does no crypto)' \
 				CONFIG_OCF_OCFNULL $CONFIG_OCF_OCF
 dep_tristate '  ocf-bench (HW crypto in-kernel benchmark)' \
diff --git a/crypto/ocf/Kconfig b/crypto/ocf/Kconfig
index 74b98b2..65a4461 100644
--- a/crypto/ocf/Kconfig
+++ b/crypto/ocf/Kconfig
@@ -84,6 +84,30 @@ config OCF_EP80579
 	help
 	  OCF driver for the Intel EP80579 Integrated Processor Product Line.
 
+config OCF_CRYPTOCTEON
+	tristate "cryptocteon (HW crypto engine)"
+	depends on OCF_OCF
+	help
+	  OCF driver for the Cavium OCTEON Processors.
+
+config OCF_KIRKWOOD
+	tristate "kirkwood (HW crypto engine)"
+	depends on OCF_OCF
+	help
+	  OCF driver for the Marvell Kirkwood (88F6xxx) Processors.
+
+config OCF_C7108
+	tristate "Micronas 7108 (HW crypto engine)"
+	depends on OCF_OCF
+	help
+	  OCF driver for the Microna 7108 Cipher processors.
+
+config OCF_UBSEC_SSB
+	tristate "uBsec BCM5365 (HW crypto engine)"
+	depends on OCF_OCF
+	help
+	  OCF driver for uBsec BCM5365 hardware crypto accelerator.
+
 config OCF_OCFNULL
 	tristate "ocfnull (fake crypto engine)"
 	depends on OCF_OCF
diff --git a/crypto/ocf/Makefile b/crypto/ocf/Makefile
index cae4b25..8605c44 100644
--- a/crypto/ocf/Makefile
+++ b/crypto/ocf/Makefile
@@ -42,11 +42,24 @@ $(_obj)-$(CONFIG_OCF_HIFN)    += hifn$(_slash)
 $(_obj)-$(CONFIG_OCF_IXP4XX)  += ixp4xx$(_slash)
 $(_obj)-$(CONFIG_OCF_TALITOS) += talitos$(_slash)
 $(_obj)-$(CONFIG_OCF_PASEMI)  += pasemi$(_slash)
-#$(_obj)-$(CONFIG_OCF_EP80579) += ep80579$(_slash)
+$(_obj)-$(CONFIG_OCF_EP80579) += ep80579$(_slash)
+$(_obj)-$(CONFIG_OCF_CRYPTOCTEON) += cryptocteon$(_slash)
+$(_obj)-$(CONFIG_OCF_KIRKWOOD) += kirkwood$(_slash)
 $(_obj)-$(CONFIG_OCF_OCFNULL) += ocfnull$(_slash)
+$(_obj)-$(CONFIG_OCF_C7108) += c7108$(_slash)
+$(_obj)-$(CONFIG_OCF_UBSEC_SSB) += ubsec_ssb$(_slash)
 
 ocf-objs := $(OCF_OBJS)
 
+dummy:
+	@echo "Please consult the README for how to build OCF."
+	@echo "If you can't wait then the following should do it:"
+	@echo ""
+	@echo "    make ocf_modules"
+	@echo "    sudo make ocf_install"
+	@echo ""
+	@exit 1
+
 $(list-multi) dummy1: $(ocf-objs)
 	$(LD) -r -o $@ $(ocf-objs)
 
@@ -54,21 +67,45 @@ $(list-multi) dummy1: $(ocf-objs)
 clean:
 	rm -f *.o *.ko .*.o.flags .*.ko.cmd .*.o.cmd .*.mod.o.cmd *.mod.c
 	rm -f */*.o */*.ko */.*.o.cmd */.*.ko.cmd */.*.mod.o.cmd */*.mod.c */.*.o.flags
+	rm -f */modules.order */modules.builtin modules.order modules.builtin
 
 ifdef TOPDIR
 -include $(TOPDIR)/Rules.make
 endif
 
 #
-# release gen targets
+# targets to build easily on the current machine
+#
+
+ocf_make:
+	make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m
+	make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m CONFIG_OCF_CRYPTOSOFT=m
+	-make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m CONFIG_OCF_BENCH=m
+	-make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m CONFIG_OCF_OCFNULL=m
+	-make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m CONFIG_OCF_HIFN=m
+
+ocf_modules:
+	$(MAKE) ocf_make OCF_TARGET=modules
+
+ocf_install:
+	$(MAKE) ocf_make OCF_TARGET="modules modules_install"
+	depmod
+	mkdir -p /usr/include/crypto
+	cp cryptodev.h /usr/include/crypto/.
+
+#
+# generate full kernel patches for 2.4 and 2.6 kernels to make patching
+# your kernel easier
 #
 
 .PHONY: patch
 patch:
-	REL=`date +%Y%m%d`; \
-		patch=ocf-linux-$$REL.patch; \
-		patch24=ocf-linux-24-$$REL.patch; \
-		patch26=ocf-linux-26-$$REL.patch; \
+	patchbase=.; \
+		[ -d $$patchbase/patches ] || patchbase=..; \
+		patch=ocf-linux-base.patch; \
+		patch24=ocf-linux-24.patch; \
+		patch26=ocf-linux-26.patch; \
+		patch3=ocf-linux-3.patch; \
 		( \
 			find . -name Makefile; \
 			find . -name Config.in; \
@@ -78,44 +115,34 @@ patch:
 		) | while read t; do \
 			diff -Nau /dev/null $$t | sed 's?^+++ \./?+++ linux/crypto/ocf/?'; \
 		done > $$patch; \
-		cat patches/linux-2.4.35-ocf.patch $$patch > $$patch24; \
-		cat patches/linux-2.6.26-ocf.patch $$patch > $$patch26
+		cat $$patchbase/patches/linux-2.4.35-ocf.patch $$patch > $$patch24; \
+		cat $$patchbase/patches/linux-2.6.38-ocf.patch $$patch > $$patch26; \
+		cat $$patchbase/patches/linux-3.2.1-ocf.patch $$patch > $$patch3; \
+
+
+#
+# this target probably does nothing for anyone but me - davidm
+#
 
-.PHONY: tarball
-tarball:
+.PHONY: release
+release:
 	REL=`date +%Y%m%d`; RELDIR=/tmp/ocf-linux-$$REL; \
 		CURDIR=`pwd`; \
 		rm -rf /tmp/ocf-linux-$$REL*; \
-		mkdir -p $$RELDIR/tools; \
-		cp README* $$RELDIR; \
-		cp patches/openss*.patch $$RELDIR; \
-		cp patches/crypto-tools.patch $$RELDIR; \
-		cp tools/[!C]* $$RELDIR/tools; \
-		cd ..; \
-		tar cvf $$RELDIR/ocf-linux.tar \
-					--exclude=CVS \
-					--exclude=.* \
-					--exclude=*.o \
-					--exclude=*.ko \
-					--exclude=*.mod.* \
-					--exclude=README* \
-					--exclude=ocf-*.patch \
-					--exclude=ocf/patches/openss*.patch \
-					--exclude=ocf/patches/crypto-tools.patch \
-					--exclude=ocf/tools \
-					ocf; \
-		gzip -9 $$RELDIR/ocf-linux.tar; \
-		cd /tmp; \
+		mkdir -p $$RELDIR/ocf; \
+		mkdir -p $$RELDIR/patches; \
+		mkdir -p $$RELDIR/crypto-tools; \
+		cp README* $$RELDIR/.; \
+		cp patches/[!C]* $$RELDIR/patches/.; \
+		cp tools/[!C]* $$RELDIR/crypto-tools/.; \
+		cp -r [!C]* Config.in $$RELDIR/ocf/.; \
+		rm -rf $$RELDIR/ocf/patches $$RELDIR/ocf/tools; \
+		rm -f $$RELDIR/ocf/README*; \
+		cp $$CURDIR/../../user/crypto-tools/[!C]* $$RELDIR/crypto-tools/.; \
+		make -C $$RELDIR/crypto-tools clean; \
+		make -C $$RELDIR/ocf clean; \
+		find $$RELDIR/ocf -name CVS | xargs rm -rf; \
+		cd $$RELDIR/..; \
 		tar cvf ocf-linux-$$REL.tar ocf-linux-$$REL; \
-		gzip -9 ocf-linux-$$REL.tar; \
-		cd $$CURDIR/../../user; \
-		rm -rf /tmp/crypto-tools-$$REL*; \
-		tar cvf /tmp/crypto-tools-$$REL.tar \
-					--exclude=CVS \
-					--exclude=.* \
-					--exclude=*.o \
-					--exclude=cryptotest \
-					--exclude=cryptokeytest \
-					crypto-tools; \
-		gzip -9 /tmp/crypto-tools-$$REL.tar
+		gzip -9 ocf-linux-$$REL.tar
 
diff --git a/crypto/ocf/c7108/aes-7108.c b/crypto/ocf/c7108/aes-7108.c
index f4841f5..c57a58d 100644
--- a/crypto/ocf/c7108/aes-7108.c
+++ b/crypto/ocf/c7108/aes-7108.c
@@ -79,20 +79,20 @@ static spinlock_t csr_mutex;
 #define c7108_reg_rd16(a)    ioread16((void*)(iobar+(a)))
 #define c7108_reg_rd32(a)    ioread32((void*)(iobar+(a)))
 
-static int 
+static int
 c7108_xlate_key(int klen, u8* k8ptr, u32* k32ptr)
 {
         int i, nw=0;
 	nw = ((klen >= 256) ? 8 : (klen >= 192) ? 6 : 4);
-	for ( i = 0; i < nw; i++) { 
-	    k32ptr[i] =    (k8ptr[i+3] << 24) | (k8ptr[i+2] << 16) | 
+	for ( i = 0; i < nw; i++) {
+	    k32ptr[i] =    (k8ptr[i+3] << 24) | (k8ptr[i+2] << 16) |
 		           (k8ptr[i+1] << 8)  | k8ptr[i];
-	    
+
 	}
 	return 0;
 }
 
-static int 
+static int
 c7108_cache_key(int klen, u32* k32ptr, u8* k8ptr)
 {
         int i, nb=0;
@@ -113,7 +113,7 @@ c7108_aes_setup_dma(u32 src, u32 dst, u32 len)
 	if (len % 16) {
 	    printk("len not multiple of 16\n");
 	    return -11;
-	}	
+	}
 	c7108_reg_wr16(C7108_AES_DMA_SRC0_LO, (u16) src);
 	c7108_reg_wr16(C7108_AES_DMA_SRC0_HI, (u16)((src & 0xffff0000) >> 16));
 	c7108_reg_wr16(C7108_AES_DMA_DST0_LO, (u16) dst);
@@ -141,21 +141,21 @@ c7108_aes_set_hw_iv(u8 iv[16])
 static void
 c7108_aes_read_dkey(u32 * dkey)
 {
-        dkey[0] = (c7108_reg_rd16(C7108_AES_EKEY0_HI) << 16) | 
+        dkey[0] = (c7108_reg_rd16(C7108_AES_EKEY0_HI) << 16) |
 	           c7108_reg_rd16(C7108_AES_EKEY0_LO);
-	dkey[1] = (c7108_reg_rd16(C7108_AES_EKEY1_HI) << 16) | 
+	dkey[1] = (c7108_reg_rd16(C7108_AES_EKEY1_HI) << 16) |
 	           c7108_reg_rd16(C7108_AES_EKEY1_LO);
-	dkey[2] = (c7108_reg_rd16(C7108_AES_EKEY2_HI) << 16) | 
+	dkey[2] = (c7108_reg_rd16(C7108_AES_EKEY2_HI) << 16) |
 	           c7108_reg_rd16(C7108_AES_EKEY2_LO);
-	dkey[3] = (c7108_reg_rd16(C7108_AES_EKEY3_HI) << 16) | 
+	dkey[3] = (c7108_reg_rd16(C7108_AES_EKEY3_HI) << 16) |
 	           c7108_reg_rd16(C7108_AES_EKEY3_LO);
-	dkey[4] = (c7108_reg_rd16(C7108_AES_EKEY4_HI) << 16) | 
+	dkey[4] = (c7108_reg_rd16(C7108_AES_EKEY4_HI) << 16) |
                    c7108_reg_rd16(C7108_AES_EKEY4_LO);
-	dkey[5] = (c7108_reg_rd16(C7108_AES_EKEY5_HI) << 16) | 
+	dkey[5] = (c7108_reg_rd16(C7108_AES_EKEY5_HI) << 16) |
                    c7108_reg_rd16(C7108_AES_EKEY5_LO);
-	dkey[6] = (c7108_reg_rd16(C7108_AES_EKEY6_HI) << 16) | 
+	dkey[6] = (c7108_reg_rd16(C7108_AES_EKEY6_HI) << 16) |
                    c7108_reg_rd16(C7108_AES_EKEY6_LO);
-	dkey[7] = (c7108_reg_rd16(C7108_AES_EKEY7_HI) << 16) | 
+	dkey[7] = (c7108_reg_rd16(C7108_AES_EKEY7_HI) << 16) |
                    c7108_reg_rd16(C7108_AES_EKEY7_LO);
 }
 
@@ -185,7 +185,7 @@ c7108_aes_cipher(int op,
 	    AES_UNLOCK();
 	    return -3;
 	}
-	
+
 	/* Check opcode */
 	if (C7108_AES_ENCRYPT == op) {
 	    ctrl |= C7108_AES_ENCRYPT;
@@ -195,26 +195,26 @@ c7108_aes_cipher(int op,
 	    AES_UNLOCK();
 	    return -4;
 	}
-	
+
 	/* check mode */
 	if ( (mode != C7108_AES_CTRL_MODE_CBC) &&
 	     (mode != C7108_AES_CTRL_MODE_CFB) &&
 	     (mode != C7108_AES_CTRL_MODE_OFB) &&
-	     (mode != C7108_AES_CTRL_MODE_CTR) && 
-	     (mode != C7108_AES_CTRL_MODE_ECB) ) { 
-	    AES_UNLOCK();	    
+	     (mode != C7108_AES_CTRL_MODE_CTR) &&
+	     (mode != C7108_AES_CTRL_MODE_ECB) ) {
+	    AES_UNLOCK();
 	    return -5;
 	}
-	
+
 	/* Now set mode */
 	ctrl |= mode;
-	
+
 	/* For CFB, OFB, and CTR, neither backward key
 	 * expansion nor key inversion is required.
 	 */
-	if ( (C7108_AES_DECRYPT == op) &&  
+	if ( (C7108_AES_DECRYPT == op) &&
 	     (C7108_AES_CTRL_MODE_CBC == mode ||
-	      C7108_AES_CTRL_MODE_ECB == mode ) ){ 
+	      C7108_AES_CTRL_MODE_ECB == mode ) ){
 
 	    /* Program Key */
 	    c7108_reg_wr16(C7108_AES_KEY0_LO, (u16) key[4]);
@@ -229,24 +229,24 @@ c7108_aes_cipher(int op,
 	    c7108_reg_wr16(C7108_AES_KEY6_HI, (u16) (key[2] >> 16));
 	    c7108_reg_wr16(C7108_AES_KEY7_LO, (u16) key[3]);
 	    c7108_reg_wr16(C7108_AES_KEY7_HI, (u16) (key[3] >> 16));
-	    
-	    
-	    if (192 == klen) { 
+
+
+	    if (192 == klen) {
 		c7108_reg_wr16(C7108_AES_KEY4_LO, (u16) key[7]);
 		c7108_reg_wr16(C7108_AES_KEY4_HI, (u16) (key[7] >> 16));
 		c7108_reg_wr16(C7108_AES_KEY5_LO, (u16) key[7]);
 		c7108_reg_wr16(C7108_AES_KEY5_HI, (u16) (key[7] >> 16));
-		
+
 	    } else if (256 == klen) {
 		/* 256 */
 		c7108_reg_wr16(C7108_AES_KEY4_LO, (u16) key[0]);
 		c7108_reg_wr16(C7108_AES_KEY4_HI, (u16) (key[0] >> 16));
 		c7108_reg_wr16(C7108_AES_KEY5_LO, (u16) key[1]);
 		c7108_reg_wr16(C7108_AES_KEY5_HI, (u16) (key[1] >> 16));
-		
+
 	    }
-	    
-	} else { 
+
+	} else {
 	    /* Program Key */
 	    c7108_reg_wr16(C7108_AES_KEY0_LO, (u16) key[0]);
 	    c7108_reg_wr16(C7108_AES_KEY0_HI, (u16) (key[0] >> 16));
@@ -264,40 +264,40 @@ c7108_aes_cipher(int op,
 	    c7108_reg_wr16(C7108_AES_KEY6_HI, (u16) (key[6] >> 16));
 	    c7108_reg_wr16(C7108_AES_KEY7_LO, (u16) key[7]);
 	    c7108_reg_wr16(C7108_AES_KEY7_HI, (u16) (key[7] >> 16));
-	    
+
 	}
-	
+
 	/* Set IV always */
 	c7108_aes_set_hw_iv(iv);
-	
+
 	/* Program DMA addresses */
-	if ((rv = c7108_aes_setup_dma(src, dst, len)) < 0) { 
+	if ((rv = c7108_aes_setup_dma(src, dst, len)) < 0) {
 	    AES_UNLOCK();
 	    return rv;
 	}
 
-	
+
 	/* Start AES cipher */
 	c7108_reg_wr16(C7108_AES_CTRL, ctrl | C7108_AES_GO);
-	
+
 	//printk("Ctrl: 0x%x\n", ctrl | C7108_AES_GO);
 	do {
 	    /* TODO: interrupt mode */
 	    //        printk("aes_stat=0x%x\n", stat);
 	    //udelay(100);
-	} while ((cnt++ < 1000000) && 
+	} while ((cnt++ < 1000000) &&
 		 !((stat=c7108_reg_rd16(C7108_AES_CTRL))&C7108_AES_OP_DONE));
 
 
 	if ((mode == C7108_AES_CTRL_MODE_ECB)||
-	    (mode == C7108_AES_CTRL_MODE_CBC)) { 
+	    (mode == C7108_AES_CTRL_MODE_CBC)) {
 	    /* Save out key when the lock is held ... */
 	    c7108_aes_read_dkey(key);
 	}
-	
+
 	AES_UNLOCK();
 	return 0;
-	
+
 }
 
 /*
@@ -330,8 +330,8 @@ c7108_newsession(void *arg, u_int32_t *sid, struct cryptoini *cri)
 		c7108_sesnum = CRYPTO_SW_SESSIONS;
 	    } else
 		c7108_sesnum *= 2;
-	    
-	    swd = kmalloc(c7108_sesnum * sizeof(struct cipher_7108 *), 
+
+	    swd = kmalloc(c7108_sesnum * sizeof(struct cipher_7108 *),
 			  GFP_ATOMIC);
 	    if (swd == NULL) {
 		/* Reset session number */
@@ -343,23 +343,23 @@ c7108_newsession(void *arg, u_int32_t *sid, struct cryptoini *cri)
 		return ENOBUFS;
 	    }
 	    memset(swd, 0, c7108_sesnum * sizeof(struct cipher_7108 *));
-	    
+
 	    /* Copy existing sessions */
 	    if (c7108_sessions) {
 		memcpy(swd, c7108_sessions,
 		       (c7108_sesnum / 2) * sizeof(struct cipher_7108 *));
 		kfree(c7108_sessions);
 	    }
-	    
+
 	    c7108_sessions = swd;
 
 	}
-	
+
 	swd = &c7108_sessions[i];
 	*sid = i;
 
 	while (cri) {
-		*swd = (struct cipher_7108 *) 
+		*swd = (struct cipher_7108 *)
 		    kmalloc(sizeof(struct cipher_7108), GFP_ATOMIC);
 		if (*swd == NULL) {
 		    c7108_freesession(NULL, i);
@@ -402,7 +402,7 @@ c7108_newsession(void *arg, u_int32_t *sid, struct cryptoini *cri)
 			break;
 #endif
 		default:
-		        printk("unsupported crypto algorithm: %d\n", 
+		        printk("unsupported crypto algorithm: %d\n",
 			       cri->cri_alg);
 			return -EINVAL;
 			break;
@@ -410,12 +410,12 @@ c7108_newsession(void *arg, u_int32_t *sid, struct cryptoini *cri)
 
 
 		if (!algo || !*algo) {
-		    printk("cypher_7108_crypto: Unknown algo 0x%x\n", 
+		    printk("cypher_7108_crypto: Unknown algo 0x%x\n",
 			   cri->cri_alg);
 		    c7108_freesession(NULL, i);
 		    return EINVAL;
 		}
-		
+
 		if (xfm_type == HW_TYPE_CIPHER) {
 		    if (debug) {
 			dprintk("%s key:", __FUNCTION__);
@@ -425,7 +425,7 @@ c7108_newsession(void *arg, u_int32_t *sid, struct cryptoini *cri)
 			dprintk("\n");
 		    }
 
-		} else if (xfm_type == SW_TYPE_HMAC || 
+		} else if (xfm_type == SW_TYPE_HMAC ||
 			   xfm_type == SW_TYPE_HASH) {
 		    printk("cypher_7108_crypto: HMAC unsupported!\n");
 		    return -EINVAL;
@@ -436,10 +436,10 @@ c7108_newsession(void *arg, u_int32_t *sid, struct cryptoini *cri)
 		    c7108_freesession(NULL, i);
 		    return EINVAL;
 		}
-		
+
 		(*swd)->cri_alg = cri->cri_alg;
 		(*swd)->xfm_type = xfm_type;
-		
+
 		cri = cri->cri_next;
 		swd = &((*swd)->next);
 	}
@@ -522,7 +522,7 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 	if (crp->crp_flags & CRYPTO_F_SKBUF) {
 		skb = (struct sk_buff *) crp->crp_buf;
 		if (skb_shinfo(skb)->nr_frags >= SCATTERLIST_MAX) {
-			printk("%s,%d: %d nr_frags > SCATTERLIST_MAX", 
+			printk("%s,%d: %d nr_frags > SCATTERLIST_MAX",
 			       __FILE__, __LINE__,
 			       skb_shinfo(skb)->nr_frags);
 			goto done;
@@ -530,7 +530,7 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 	} else if (crp->crp_flags & CRYPTO_F_IOV) {
 		uiop = (struct uio *) crp->crp_buf;
 		if (uiop->uio_iovcnt > SCATTERLIST_MAX) {
-			printk("%s,%d: %d uio_iovcnt > SCATTERLIST_MAX", 
+			printk("%s,%d: %d uio_iovcnt > SCATTERLIST_MAX",
 			       __FILE__, __LINE__,
 			       uiop->uio_iovcnt);
 			goto done;
@@ -549,20 +549,20 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 	     * XXX between the various instances of an algorithm (so we can
 	     * XXX locate the correct crypto context).
 	     */
-	    for (sw = c7108_sessions[lid]; 
+	    for (sw = c7108_sessions[lid];
 		 sw && sw->cri_alg != crd->crd_alg;
 		 sw = sw->next)
 		;
-	    
+
 	    /* No such context ? */
 	    if (sw == NULL) {
 		crp->crp_etype = EINVAL;
 		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
 		goto done;
 	    }
-	    
+
 	    skip = crd->crd_skip;
-	    
+
 	    /*
 	     * setup the SG list skip from the start of the buffer
 	     */
@@ -570,7 +570,7 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 	    if (crp->crp_flags & CRYPTO_F_SKBUF) {
 		int i, len;
 		type = CRYPTO_BUF_SKBUF;
-		
+
 		sg_num = 0;
 		sg_len = 0;
 
@@ -587,7 +587,7 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 		    skip = 0;
 		} else
 		    skip -= skb_headlen(skb);
-		
+
 		for (i = 0; sg_len < crd->crd_len &&
 			 i < skb_shinfo(skb)->nr_frags &&
 			 sg_num < SCATTERLIST_MAX; i++) {
@@ -622,7 +622,7 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 			sg_set_page(&sg[sg_num], virt_to_page(uiop->uio_iov[sg_num].iov_base+skip), len, offset_in_page(uiop->uio_iov[sg_num].iov_base+skip));
 			sg_len += sg[sg_num].length;
 			skip = 0;
-		    } else 
+		    } else
 			skip -= uiop->uio_iov[sg_num].iov_len;
 		}
 	    } else {
@@ -638,8 +638,8 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 	    }
 	    if (sg_num > 0)
 		sg_mark_end(&sg[sg_num-1]);
-	    
-	    
+
+
 	    switch (sw->xfm_type) {
 
 	    case HW_TYPE_CIPHER: {
@@ -652,21 +652,21 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 
 		if (sg_len < blocksize) {
 		    crp->crp_etype = EINVAL;
-		    dprintk("%s,%d: EINVAL len %d < %d\n", 
+		    dprintk("%s,%d: EINVAL len %d < %d\n",
 			    __FILE__, __LINE__,
-			    sg_len, 
+			    sg_len,
 			    blocksize);
 		    goto done;
 		}
-		
+
 		if (ivsize > sizeof(iv)) {
 		    crp->crp_etype = EINVAL;
 		    dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
 		    goto done;
 		}
-		
+
 		if (crd->crd_flags & CRD_F_ENCRYPT) { /* encrypt */
-		    
+
 		    if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
 			ivp = crd->crd_iv;
 		    } else {
@@ -686,13 +686,13 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 				    (u8*)crd->crd_key, (u32*)hwkey);
 
 		    /* Encrypt SG list */
-		    for (i = 0; i < sg_num; i++) { 
-			sg[i].dma_address = 
-			    dma_map_single(NULL, 
+		    for (i = 0; i < sg_num; i++) {
+			sg[i].dma_address =
+			    dma_map_single(NULL,
 					   kmap(sg_page(&sg[i])) + sg[i].offset, sg_len, DMA_BIDIRECTIONAL);
-#if 0							   
+#if 0
 			printk("sg[%d]:0x%08x, off 0x%08x "
-			       "kmap 0x%08x phys 0x%08x\n", 
+			       "kmap 0x%08x phys 0x%08x\n",
 			       i, sg[i].page, sg[i].offset,
 			       kmap(sg[i].page) + sg[i].offset,
 			       sg[i].dma_address);
@@ -707,13 +707,13 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 					 ivp);
 
 			if ((c7108_crypto_mode == C7108_AES_CTRL_MODE_CBC)||
-			    (c7108_crypto_mode == C7108_AES_CTRL_MODE_ECB)) { 
+			    (c7108_crypto_mode == C7108_AES_CTRL_MODE_ECB)) {
 			    /* Read back expanded key and cache it in key
 			     * context.
 			     * NOTE: for ECB/CBC modes only (not CTR, CFB, OFB)
 			     *       where you set the key once.
 			     */
-			    c7108_cache_key(crd->crd_klen, 
+			    c7108_cache_key(crd->crd_klen,
 					    (u32*)hwkey, (u8*)crd->crd_key);
 #if 0
 			    printk("%s expanded key:", __FUNCTION__);
@@ -738,15 +738,15 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 				    (u8*)crd->crd_key, (u32*)hwkey);
 
 		    /* Decrypt SG list */
-		    for (i = 0; i < sg_num; i++) { 
-			sg[i].dma_address = 
-			    dma_map_single(NULL, 
+		    for (i = 0; i < sg_num; i++) {
+			sg[i].dma_address =
+			    dma_map_single(NULL,
 					   kmap(sg_page(&sg[i])) + sg[i].offset,
 					   sg_len, DMA_BIDIRECTIONAL);
 
 #if 0
 			printk("sg[%d]:0x%08x, off 0x%08x "
-			       "kmap 0x%08x phys 0x%08x\n", 
+			       "kmap 0x%08x phys 0x%08x\n",
 			       i, sg[i].page, sg[i].offset,
 			       kmap(sg[i].page) + sg[i].offset,
 			       sg[i].dma_address);
@@ -767,12 +767,12 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 		crp->crp_etype = EINVAL;
 		goto done;
 		break;
-		
+
 	    case SW_TYPE_COMP:
 		crp->crp_etype = EINVAL;
 		goto done;
 		break;
-		
+
 	    default:
 		/* Unknown/unsupported algorithm */
 		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
@@ -780,40 +780,40 @@ c7108_process(void *arg, struct cryptop *crp, int hint)
 		goto done;
 	    }
 	}
-	
+
 done:
 	crypto_done(crp);
 	return 0;
 }
 
-static struct {                                                                                                                 
-	softc_device_decl sc_dev;                                                                                               
+static struct {
+	softc_device_decl sc_dev;
 } a7108dev;
 
-static device_method_t a7108_methods = {                                                                                          
-/* crypto device methods */                                                                                             
-	DEVMETHOD(cryptodev_newsession, c7108_newsession),                                                                  
-	DEVMETHOD(cryptodev_freesession, c7108_freesession),                                                             
-	DEVMETHOD(cryptodev_process, c7108_process),                                                                     
-	DEVMETHOD(cryptodev_kprocess, NULL) 
-};   
+static device_method_t a7108_methods = {
+/* crypto device methods */
+	DEVMETHOD(cryptodev_newsession, c7108_newsession),
+	DEVMETHOD(cryptodev_freesession, c7108_freesession),
+	DEVMETHOD(cryptodev_process, c7108_process),
+	DEVMETHOD(cryptodev_kprocess, NULL)
+};
 
 static int
 cypher_7108_crypto_init(void)
 {
 	dprintk("%s(%p)\n", __FUNCTION__, cypher_7108_crypto_init);
-	
+
 	iobar = (unsigned long)ioremap(CCU_AES_REG_BASE, 0x4000);
-	printk("7108: AES @ 0x%08x (0x%08x phys) %s mode\n", 
-	       iobar, CCU_AES_REG_BASE, 
+	printk("7108: AES @ 0x%08x (0x%08x phys) %s mode\n",
+	       iobar, CCU_AES_REG_BASE,
 	       c7108_crypto_mode & C7108_AES_CTRL_MODE_CBC ? "CBC" :
-	       c7108_crypto_mode & C7108_AES_CTRL_MODE_ECB ? "ECB" : 
-	       c7108_crypto_mode & C7108_AES_CTRL_MODE_CTR ? "CTR" : 
-	       c7108_crypto_mode & C7108_AES_CTRL_MODE_CFB ? "CFB" : 
+	       c7108_crypto_mode & C7108_AES_CTRL_MODE_ECB ? "ECB" :
+	       c7108_crypto_mode & C7108_AES_CTRL_MODE_CTR ? "CTR" :
+	       c7108_crypto_mode & C7108_AES_CTRL_MODE_CFB ? "CFB" :
 	       c7108_crypto_mode & C7108_AES_CTRL_MODE_OFB ? "OFB" : "???");
 	csr_mutex  = SPIN_LOCK_UNLOCKED;
 
-	memset(&a7108dev, 0, sizeof(a7108dev));                                                                                     
+	memset(&a7108dev, 0, sizeof(a7108dev));
 	softc_device_init(&a7108dev, "aes7108", 0, a7108_methods);
 
        	c7108_id = crypto_get_driverid(softc_get_device(&a7108dev), CRYPTOCAP_F_HARDWARE);
diff --git a/crypto/ocf/c7108/aes-7108.h b/crypto/ocf/c7108/aes-7108.h
index 0c7bfcb..48711b4 100644
--- a/crypto/ocf/c7108/aes-7108.h
+++ b/crypto/ocf/c7108/aes-7108.h
@@ -30,32 +30,32 @@
 #define __AES_7108_H__
 
 /* Cypher 7108 AES Controller Hardware */
-#define CCU_REG_BASE       0x1b500000	
+#define CCU_REG_BASE       0x1b500000
 #define CCU_AES_REG_BASE   (CCU_REG_BASE + 0x100)
-#define C7108_AES_KEY0_LO        (0x0000) 
-#define C7108_AES_KEY0_HI        (0x0004) 
-#define C7108_AES_KEY1_LO        (0x0008) 
-#define C7108_AES_KEY1_HI        (0x000c) 
-#define C7108_AES_KEY2_LO        (0x0010) 
-#define C7108_AES_KEY2_HI        (0x0014) 
-#define C7108_AES_KEY3_LO        (0x0018) 
-#define C7108_AES_KEY3_HI        (0x001c) 
-#define C7108_AES_KEY4_LO        (0x0020) 
-#define C7108_AES_KEY4_HI        (0x0024) 
-#define C7108_AES_KEY5_LO        (0x0028) 
-#define C7108_AES_KEY5_HI        (0x002c) 
-#define C7108_AES_KEY6_LO        (0x0030) 
-#define C7108_AES_KEY6_HI        (0x0034) 
-#define C7108_AES_KEY7_LO        (0x0038) 
-#define C7108_AES_KEY7_HI        (0x003c) 
-#define C7108_AES_IV0_LO         (0x0040) 
-#define C7108_AES_IV0_HI         (0x0044) 
-#define C7108_AES_IV1_LO         (0x0048) 
-#define C7108_AES_IV1_HI         (0x004c) 
-#define C7108_AES_IV2_LO         (0x0050) 
-#define C7108_AES_IV2_HI         (0x0054) 
-#define C7108_AES_IV3_LO         (0x0058) 
-#define C7108_AES_IV3_HI         (0x005c) 
+#define C7108_AES_KEY0_LO        (0x0000)
+#define C7108_AES_KEY0_HI        (0x0004)
+#define C7108_AES_KEY1_LO        (0x0008)
+#define C7108_AES_KEY1_HI        (0x000c)
+#define C7108_AES_KEY2_LO        (0x0010)
+#define C7108_AES_KEY2_HI        (0x0014)
+#define C7108_AES_KEY3_LO        (0x0018)
+#define C7108_AES_KEY3_HI        (0x001c)
+#define C7108_AES_KEY4_LO        (0x0020)
+#define C7108_AES_KEY4_HI        (0x0024)
+#define C7108_AES_KEY5_LO        (0x0028)
+#define C7108_AES_KEY5_HI        (0x002c)
+#define C7108_AES_KEY6_LO        (0x0030)
+#define C7108_AES_KEY6_HI        (0x0034)
+#define C7108_AES_KEY7_LO        (0x0038)
+#define C7108_AES_KEY7_HI        (0x003c)
+#define C7108_AES_IV0_LO         (0x0040)
+#define C7108_AES_IV0_HI         (0x0044)
+#define C7108_AES_IV1_LO         (0x0048)
+#define C7108_AES_IV1_HI         (0x004c)
+#define C7108_AES_IV2_LO         (0x0050)
+#define C7108_AES_IV2_HI         (0x0054)
+#define C7108_AES_IV3_LO         (0x0058)
+#define C7108_AES_IV3_HI         (0x005c)
 
 #define C7108_AES_DMA_SRC0_LO    (0x0068) /* Bits 0:15 */
 #define C7108_AES_DMA_SRC0_HI    (0x006c) /* Bits 27:16 */
@@ -81,7 +81,7 @@
 
 /* AES Operation (crypt/decrypt), Bit 3 */
 #define C7108_AES_DECRYPT             (1<<3)   /* Clear for encrypt */
-#define C7108_AES_ENCRYPT              0       
+#define C7108_AES_ENCRYPT              0
 #define C7108_AES_INTR                (1<<13) /* Set on done trans from 0->1*/
 #define C7108_AES_GO                  (1<<14) /* Run */
 #define C7108_AES_OP_DONE             (1<<15) /* Set when complete */
diff --git a/crypto/ocf/criov.c b/crypto/ocf/criov.c
index eb0b677..cdc731e 100644
--- a/crypto/ocf/criov.c
+++ b/crypto/ocf/criov.c
@@ -1,8 +1,8 @@
 /*      $OpenBSD: criov.c,v 1.9 2002/01/29 15:48:29 jason Exp $	*/
 
 /*
- * Linux port done by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2007 David McCullough
+ * Linux port done by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2006-2010 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -34,6 +34,10 @@
 __FBSDID("$FreeBSD: src/sys/opencrypto/criov.c,v 1.5 2006/06/04 22:15:13 pjd Exp $");
  */
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#include <linux/config.h>
+#endif
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -152,7 +156,7 @@ skb_copy_bits_back(struct sk_buff *skb, int offset, caddr_t cp, int len)
 	offset -= skb_headlen(skb);
 	for (i = 0; len > 0 && i < skb_shinfo(skb)->nr_frags; i++) {
 		if (offset < skb_shinfo(skb)->frags[i].size) {
-			memcpy(page_address(skb_shinfo(skb)->frags[i].page.p) +
+			memcpy(page_address(skb_frag_page(&skb_shinfo(skb)->frags[i])) +
 					skb_shinfo(skb)->frags[i].page_offset,
 					cp, min_t(int, skb_shinfo(skb)->frags[i].size, len));
 			len -= skb_shinfo(skb)->frags[i].size;
diff --git a/crypto/ocf/crypto.c b/crypto/ocf/crypto.c
index e952de6..123140be 100644
--- a/crypto/ocf/crypto.c
+++ b/crypto/ocf/crypto.c
@@ -1,6 +1,6 @@
 /*-
- * Linux port done by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2007 David McCullough
+ * Linux port done by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2006-2010 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -62,6 +62,11 @@ __FBSDID("$FreeBSD: src/sys/opencrypto/crypto.c,v 1.27 2007/03/21 03:42:51 sam E
 __FBSDID("$FreeBSD: src/sys/opencrypto/crypto.c,v 1.16 2005/01/07 02:29:16 imp Exp $");
  */
 
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#include <linux/config.h>
+#endif
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/list.h>
@@ -69,7 +74,9 @@ __FBSDID("$FreeBSD: src/sys/opencrypto/crypto.c,v 1.16 2005/01/07 02:29:16 imp E
 #include <linux/wait.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
-#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,4)
+#include <linux/kthread.h>
+#endif
 #include <cryptodev.h>
 
 /*
@@ -77,7 +84,7 @@ __FBSDID("$FreeBSD: src/sys/opencrypto/crypto.c,v 1.16 2005/01/07 02:29:16 imp E
  * issue if we are linked into the kernel and a driver gets started before
  * us
  */
-int crypto_initted = 0;
+static int crypto_initted = 0;
 
 /*
  * Crypto drivers register themselves by allocating a slot in the
@@ -135,6 +142,9 @@ struct cryptocap {
 #define CRYPTOCAP_F_CLEANUP	0x80000000	/* needs resource cleanup */
 	int		cc_qblocked;		/* (q) symmetric q blocked */
 	int		cc_kqblocked;		/* (q) asymmetric q blocked */
+
+	int		cc_unqblocked;		/* (q) symmetric q blocked */
+	int		cc_unkqblocked;		/* (q) asymmetric q blocked */
 };
 static struct cryptocap *crypto_drivers = NULL;
 static int crypto_drivers_num = 0;
@@ -146,9 +156,8 @@ static int crypto_drivers_num = 0;
  * have one per-queue but having one simplifies handling of block/unblock
  * operations.
  */
-static	int crp_sleep = 0;
-static LIST_HEAD(crp_q);		/* request queues */
-static LIST_HEAD(crp_kq);
+static LIST_HEAD(crp_q);		/* crypto request queue */
+static LIST_HEAD(crp_kq);		/* asym request queue */
 
 static spinlock_t crypto_q_lock;
 
@@ -251,11 +260,25 @@ module_param(crypto_devallowsoft, int, 0644);
 MODULE_PARM_DESC(crypto_devallowsoft,
 	   "Enable/disable use of software crypto support");
 
-static pid_t	cryptoproc = (pid_t) -1;
-static struct	completion cryptoproc_exited;
+/*
+ * This parameter controls the maximum number of crypto operations to
+ * do consecutively in the crypto kernel thread before scheduling to allow
+ * other processes to run. Without it, it is possible to get into a
+ * situation where the crypto thread never allows any other processes to run.
+ * Default to 1000 which should be less than one second.
+ */
+static int crypto_max_loopcount = 1000;
+module_param(crypto_max_loopcount, int, 0644);
+MODULE_PARM_DESC(crypto_max_loopcount,
+	   "Maximum number of crypto ops to do before yielding to other processes");
+
+#ifndef CONFIG_NR_CPUS
+#define CONFIG_NR_CPUS 1
+#endif
+
+static struct task_struct *cryptoproc[CONFIG_NR_CPUS];
+static struct task_struct *cryptoretproc[CONFIG_NR_CPUS];
 static DECLARE_WAIT_QUEUE_HEAD(cryptoproc_wait);
-static pid_t	cryptoretproc = (pid_t) -1;
-static struct	completion cryptoretproc_exited;
 static DECLARE_WAIT_QUEUE_HEAD(cryptoretproc_wait);
 
 static	int crypto_proc(void *arg);
@@ -756,13 +779,14 @@ crypto_unblock(u_int32_t driverid, int what)
 	if (cap != NULL) {
 		if (what & CRYPTO_SYMQ) {
 			cap->cc_qblocked = 0;
+			cap->cc_unqblocked = 0;
 			crypto_all_qblocked = 0;
 		}
 		if (what & CRYPTO_ASYMQ) {
 			cap->cc_kqblocked = 0;
+			cap->cc_unkqblocked = 0;
 			crypto_all_kqblocked = 0;
 		}
-		if (crp_sleep)
 			wake_up_interruptible(&cryptoproc_wait);
 		err = 0;
 	} else
@@ -779,8 +803,7 @@ int
 crypto_dispatch(struct cryptop *crp)
 {
 	struct cryptocap *cap;
-	u_int32_t hid;
-	int result = 0;
+	int result = -1;
 	unsigned long q_flags;
 
 	dprintk("%s()\n", __FUNCTION__);
@@ -788,36 +811,81 @@ crypto_dispatch(struct cryptop *crp)
 
 	CRYPTO_Q_LOCK();
 	if (crypto_q_cnt >= crypto_q_max) {
-		CRYPTO_Q_UNLOCK();
 		cryptostats.cs_drops++;
+		CRYPTO_Q_UNLOCK();
 		return ENOMEM;
 	}
 	crypto_q_cnt++;
+
+	/* make sure we are starting a fresh run on this crp. */
+	crp->crp_flags &= ~CRYPTO_F_DONE;
+	crp->crp_etype = 0;
+
+#ifdef CONFIG_MV_CESA_OCF
+
 	CRYPTO_Q_UNLOCK();
 
-	hid = CRYPTO_SESID2HID(crp->crp_sid);
-	cap = crypto_checkdriver(hid);
 	/* warning: We are using the CRYPTO_F_BATCH to mark processing by HW,
  	   it should be disabled for software encryption */
 	if ((crp->crp_flags & CRYPTO_F_BATCH)) {
-        /* If should be done by HW - skip OCF queue */
+		int hid = CRYPTO_SESID2HID(crp->crp_sid);
+		cap = crypto_checkdriver(hid);
+		/* Driver cannot disappear when there is an active session. */
+		KASSERT(cap != NULL, ("%s: Driver disappeared.", __func__));
+
 		result = crypto_invoke(cap, crp, 0);
-		if (result != 0) {
+		if (result != 0)
             	    cryptostats.cs_drops++;
-		} 
 	} else {
+		CRYPTO_Q_LOCK();
+		TAILQ_INSERT_TAIL(&crp_q, crp, crp_next);
+		result = 0;
+		wake_up_interruptible(&cryptoproc_wait);
+		CRYPTO_Q_UNLOCK();
+		} 
+#else
+
 		/*
-		 * Caller marked the request as ``ok to delay'';
-		 * queue it for the dispatch thread.  This is desirable
-		 * when the operation is low priority and/or suitable
-		 * for batching.
+	 * Caller marked the request to be processed immediately; dispatch
+	 * it directly to the driver unless the driver is currently blocked.
 		 */
+	if ((crp->crp_flags & CRYPTO_F_BATCH) == 0) {
+		int hid = CRYPTO_SESID2HID(crp->crp_sid);
+		cap = crypto_checkdriver(hid);
+		/* Driver cannot disappear when there is an active session. */
+		KASSERT(cap != NULL, ("%s: Driver disappeared.", __func__));
+		if (!cap->cc_qblocked) {
+			crypto_all_qblocked = 0;
+			crypto_drivers[hid].cc_unqblocked = 1;
+			CRYPTO_Q_UNLOCK();
+			result = crypto_invoke(cap, crp, 0);
       		CRYPTO_Q_LOCK();
+			if (result == ERESTART)
+				if (crypto_drivers[hid].cc_unqblocked)
+					crypto_drivers[hid].cc_qblocked = 1;
+			crypto_drivers[hid].cc_unqblocked = 0;
+		}
+	}
+	if (result == ERESTART) {
+		/*
+		 * The driver ran out of resources, mark the
+		 * driver ``blocked'' for cryptop's and put
+		 * the request back in the queue.  It would
+		 * best to put the request back where we got
+		 * it but that's hard so for now we put it
+		 * at the front.  This should be ok; putting
+		 * it at the end does not work.
+		 */
+		list_add(&crp->crp_next, &crp_q);
+		cryptostats.cs_blocks++;
+		result = 0;
+	} else if (result == -1) {
 		TAILQ_INSERT_TAIL(&crp_q, crp, crp_next);
-		if (crp_sleep)
+		result = 0;
+	}
 			wake_up_interruptible(&cryptoproc_wait);
 		CRYPTO_Q_UNLOCK();
-	}
+#endif
 	
 	return result;
 }
@@ -838,7 +906,6 @@ crypto_kdispatch(struct cryptkop *krp)
 	if (error == ERESTART) {
 		CRYPTO_Q_LOCK();
 		TAILQ_INSERT_TAIL(&crp_kq, krp, krp_next);
-		if (crp_sleep)
 			wake_up_interruptible(&cryptoproc_wait);
 		CRYPTO_Q_UNLOCK();
 		error = 0;
@@ -1137,7 +1204,6 @@ crypto_done(struct cryptop *crp)
 		 * Normal case; queue the callback for the thread.
 		 */
 		CRYPTO_RETQ_LOCK();
-		if (CRYPTO_RETQ_EMPTY())
 			wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
 		TAILQ_INSERT_TAIL(&crp_ret_q, crp, crp_next);
 		CRYPTO_RETQ_UNLOCK();
@@ -1188,7 +1254,6 @@ crypto_kdone(struct cryptkop *krp)
 		 * Normal case; queue the callback for the thread.
 		 */
 		CRYPTO_RETQ_LOCK();
-		if (CRYPTO_RETQ_EMPTY())
 			wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
 		TAILQ_INSERT_TAIL(&crp_ret_kq, krp, krp_next);
 		CRYPTO_RETQ_UNLOCK();
@@ -1230,8 +1295,9 @@ crypto_proc(void *arg)
 	u_int32_t hid;
 	int result, hint;
 	unsigned long q_flags;
+	int loopcount = 0;
 
-	ocf_daemonize("crypto");
+	set_current_state(TASK_INTERRUPTIBLE);
 
 	CRYPTO_Q_LOCK();
 	for (;;) {
@@ -1290,7 +1356,7 @@ crypto_proc(void *arg)
 			hid = CRYPTO_SESID2HID(submit->crp_sid);
 			crypto_all_qblocked = 0;
 			list_del(&submit->crp_next);
-			crypto_drivers[hid].cc_qblocked = 1;
+			crypto_drivers[hid].cc_unqblocked = 1;
 			cap = crypto_checkdriver(hid);
 			CRYPTO_Q_UNLOCK();
 			KASSERT(cap != NULL, ("%s:%u Driver disappeared.",
@@ -1310,8 +1376,11 @@ crypto_proc(void *arg)
 				/* XXX validate sid again? */
 				list_add(&submit->crp_next, &crp_q);
 				cryptostats.cs_blocks++;
-			} else
+				if (crypto_drivers[hid].cc_unqblocked)
 				crypto_drivers[hid].cc_qblocked=0;
+				crypto_drivers[hid].cc_unqblocked=0;
+			}
+			crypto_drivers[hid].cc_unqblocked = 0;
 		}
 
 		crypto_all_kqblocked = !list_empty(&crp_kq);
@@ -1380,13 +1449,12 @@ crypto_proc(void *arg)
 					__FUNCTION__,
 					list_empty(&crp_q), crypto_all_qblocked,
 					list_empty(&crp_kq), crypto_all_kqblocked);
+			loopcount = 0;
 			CRYPTO_Q_UNLOCK();
-			crp_sleep = 1;
 			wait_event_interruptible(cryptoproc_wait,
 					!(list_empty(&crp_q) || crypto_all_qblocked) ||
 					!(list_empty(&crp_kq) || crypto_all_kqblocked) ||
-					cryptoproc == (pid_t) -1);
-			crp_sleep = 0;
+					kthread_should_stop());
 			if (signal_pending (current)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 				spin_lock_irq(&current->sigmask_lock);
@@ -1398,13 +1466,23 @@ crypto_proc(void *arg)
 			}
 			CRYPTO_Q_LOCK();
 			dprintk("%s - awake\n", __FUNCTION__);
-			if (cryptoproc == (pid_t) -1)
+			if (kthread_should_stop())
 				break;
 			cryptostats.cs_intrs++;
+		} else if (loopcount > crypto_max_loopcount) {
+			/*
+			 * Give other processes a chance to run if we've
+			 * been using the CPU exclusively for a while.
+			 */
+			loopcount = 0;
+			CRYPTO_Q_UNLOCK();
+			schedule();
+			CRYPTO_Q_LOCK();
 		}
+		loopcount++;
 	}
 	CRYPTO_Q_UNLOCK();
-	complete_and_exit(&cryptoproc_exited, 0);
+	return 0;
 }
 
 /*
@@ -1419,7 +1497,7 @@ crypto_ret_proc(void *arg)
 	struct cryptkop *krpt;
 	unsigned long  r_flags;
 
-	ocf_daemonize("crypto_ret");
+	set_current_state(TASK_INTERRUPTIBLE);
 
 	CRYPTO_RETQ_LOCK();
 	for (;;) {
@@ -1454,9 +1532,9 @@ crypto_ret_proc(void *arg)
 			dprintk("%s - sleeping\n", __FUNCTION__);
 			CRYPTO_RETQ_UNLOCK();
 			wait_event_interruptible(cryptoretproc_wait,
-					cryptoretproc == (pid_t) -1 ||
 					!list_empty(&crp_ret_q) ||
-					!list_empty(&crp_ret_kq));
+					!list_empty(&crp_ret_kq) ||
+					kthread_should_stop());
 			if (signal_pending (current)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 				spin_lock_irq(&current->sigmask_lock);
@@ -1468,7 +1546,7 @@ crypto_ret_proc(void *arg)
 			}
 			CRYPTO_RETQ_LOCK();
 			dprintk("%s - awake\n", __FUNCTION__);
-			if (cryptoretproc == (pid_t) -1) {
+			if (kthread_should_stop()) {
 				dprintk("%s - EXITING!\n", __FUNCTION__);
 				break;
 			}
@@ -1476,7 +1554,7 @@ crypto_ret_proc(void *arg)
 		}
 	}
 	CRYPTO_RETQ_UNLOCK();
-	complete_and_exit(&cryptoretproc_exited, 0);
+	return 0;
 }
 
 
@@ -1582,8 +1660,9 @@ int
 crypto_init(void)
 {
 	int error;
+	unsigned long cpu;
 
-	dprintk("%s(0x%x)\n", __FUNCTION__, (int) crypto_init);
+	dprintk("%s(%p)\n", __FUNCTION__, (void *) crypto_init);
 
 	if (crypto_initted)
 		return 0;
@@ -1624,26 +1703,29 @@ crypto_init(void)
 
 	memset(crypto_drivers, 0, crypto_drivers_num * sizeof(struct cryptocap));
 
-	init_completion(&cryptoproc_exited);
-	init_completion(&cryptoretproc_exited);
-
-	cryptoproc = 0; /* to avoid race condition where proc runs first */
-	cryptoproc = kernel_thread(crypto_proc, NULL, CLONE_FS|CLONE_FILES);
-	if (cryptoproc < 0) {
-		error = cryptoproc;
+	ocf_for_each_cpu(cpu) {
+		cryptoproc[cpu] = kthread_create(crypto_proc, (void *) cpu,
+									"ocf_%d", (int) cpu);
+		if (IS_ERR(cryptoproc[cpu])) {
+			error = PTR_ERR(cryptoproc[cpu]);
 		printk("crypto: crypto_init cannot start crypto thread; error %d",
 			error);
 		goto bad;
 	}
+		kthread_bind(cryptoproc[cpu], cpu);
+		wake_up_process(cryptoproc[cpu]);
 
-	cryptoretproc = 0; /* to avoid race condition where proc runs first */
-	cryptoretproc = kernel_thread(crypto_ret_proc, NULL, CLONE_FS|CLONE_FILES);
-	if (cryptoretproc < 0) {
-		error = cryptoretproc;
+		cryptoretproc[cpu] = kthread_create(crypto_ret_proc, (void *) cpu,
+									"ocf_ret_%d", (int) cpu);
+		if (IS_ERR(cryptoretproc[cpu])) {
+			error = PTR_ERR(cryptoretproc[cpu]);
 		printk("crypto: crypto_init cannot start cryptoret thread; error %d",
 				error);
 		goto bad;
 	}
+		kthread_bind(cryptoretproc[cpu], cpu);
+		wake_up_process(cryptoretproc[cpu]);
+	}
 
 	return 0;
 bad:
@@ -1655,34 +1737,17 @@ bad:
 static void
 crypto_exit(void)
 {
-	pid_t p;
-	unsigned long d_flags;
+	int cpu;
 
 	dprintk("%s()\n", __FUNCTION__);
 
 	/*
 	 * Terminate any crypto threads.
 	 */
-
-	CRYPTO_DRIVER_LOCK();
-	p = cryptoproc;
-	cryptoproc = (pid_t) -1;
-	kill_proc_info(SIGTERM, SEND_SIG_PRIV, p);
-	wake_up_interruptible(&cryptoproc_wait);
-	CRYPTO_DRIVER_UNLOCK();
-
-	wait_for_completion(&cryptoproc_exited);
-
-	CRYPTO_DRIVER_LOCK();
-	p = cryptoretproc;
-	cryptoretproc = (pid_t) -1;
-	kill_proc_info(SIGTERM, SEND_SIG_PRIV, p);
-	wake_up_interruptible(&cryptoretproc_wait);
-	CRYPTO_DRIVER_UNLOCK();
-
-	wait_for_completion(&cryptoretproc_exited);
-
-	/* XXX flush queues??? */
+	ocf_for_each_cpu(cpu) {
+		kthread_stop(cryptoproc[cpu]);
+		kthread_stop(cryptoretproc[cpu]);
+	}
 
 	/* 
 	 * Reclaim dynamically allocated resources.
@@ -1716,10 +1781,11 @@ EXPORT_SYMBOL(crypto_userasymcrypto);
 EXPORT_SYMBOL(crypto_getcaps);
 EXPORT_SYMBOL(crypto_find_driver);
 EXPORT_SYMBOL(crypto_find_device_byhid);
+EXPORT_SYMBOL(crypto_init);
 
 module_init(crypto_init);
 module_exit(crypto_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
 MODULE_DESCRIPTION("OCF (OpenBSD Cryptographic Framework)");
diff --git a/crypto/ocf/cryptocteon/README.txt b/crypto/ocf/cryptocteon/README.txt
new file mode 100644
index 0000000..807b2e5
--- /dev/null
+++ b/crypto/ocf/cryptocteon/README.txt
@@ -0,0 +1,11 @@
+
+You will need the CRYPTO package installed to build this driver,  and
+potentially the ADK.
+
+cavium_crypto sourced from:
+
+	adk/components/source/cavium_ipsec_kame/cavium_ipsec.c
+
+and significantly modified to suit use with OCF.  All original
+copyright/ownership headers retained.
+
diff --git a/crypto/ocf/cryptocteon/cavium_crypto.c b/crypto/ocf/cryptocteon/cavium_crypto.c
index ceaf77c..28054d1 100644
--- a/crypto/ocf/cryptocteon/cavium_crypto.c
+++ b/crypto/ocf/cryptocteon/cavium_crypto.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2003-2007 Cavium Networks (support@cavium.com). All rights
  * reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  * 1. Redistributions of source code must retain the above copyright notice,
@@ -16,7 +16,7 @@
  * This product includes software developed by Cavium Networks
  * 4. Cavium Networks' name may not be used to endorse or promote products
  * derived from this software without specific prior written permission.
- * 
+ *
  * This Software, including technical data, may be subject to U.S. export
  * control laws, including the U.S. Export Administration Act and its
  * associated regulations, and may be subject to export or import regulations
@@ -24,7 +24,7 @@
  * respects with all such regulations and acknowledge that you have the
  * responsibility to obtain licenses to export, re-export or import the
  * Software.
- * 
+ *
  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND
  * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES,
  * EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO THE
@@ -304,7 +304,7 @@ octo_calc_hash(__u8 auth, unsigned char *key, uint64_t *inner, uint64_t *outer)
     key1++;
     if (auth)
        CVMX_MT_HSH_STARTSHA((*key1 ^ xor2));
-    else 
+    else
        CVMX_MT_HSH_STARTMD5((*key1 ^ xor2));
 
     CVMX_MF_HSH_IV(outer[0], 0);
diff --git a/crypto/ocf/cryptodev.c b/crypto/ocf/cryptodev.c
index 2fa943c..10faffb 100644
--- a/crypto/ocf/cryptodev.c
+++ b/crypto/ocf/cryptodev.c
@@ -1,8 +1,8 @@
 /*	$OpenBSD: cryptodev.c,v 1.52 2002/06/19 07:22:46 deraadt Exp $	*/
 
 /*-
- * Linux port done by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2007 David McCullough
+ * Linux port done by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2006-2010 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -39,6 +39,10 @@
 __FBSDID("$FreeBSD: src/sys/opencrypto/cryptodev.c,v 1.34 2007/05/09 19:37:02 gnn Exp $");
  */
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#include <linux/config.h>
+#endif
 #include <linux/types.h>
 #include <linux/time.h>
 #include <linux/delay.h>
@@ -54,7 +58,6 @@ __FBSDID("$FreeBSD: src/sys/opencrypto/cryptodev.c,v 1.34 2007/05/09 19:37:02 gn
 #include <linux/file.h>
 #include <linux/mount.h>
 #include <linux/miscdevice.h>
-#include <linux/version.h>
 #include <asm/uaccess.h>
 
 #include <cryptodev.h>
@@ -74,6 +77,7 @@ struct csession_info {
 	u_int16_t	keysize;
 	/* u_int16_t	hashsize;  */
 	u_int16_t	authsize;
+	u_int16_t	authkey;
 	/* u_int16_t	ctxsize; */
 };
 
@@ -194,7 +198,7 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 
 	if (cse->uio.uio_iov[0].iov_base == NULL) {
 		dprintk("%s: iov_base kmalloc(%d) failed\n", __FUNCTION__,
-				cse->uio.uio_iov[0].iov_len);
+				(int)cse->uio.uio_iov[0].iov_len);
 		return (ENOMEM);
 	}
 
@@ -205,19 +209,23 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 		goto bail;
 	}
 
-	if (cse->info.authsize) {
+	if (cse->info.authsize && cse->info.blocksize) {
+		if (cop->op == COP_ENCRYPT) {
+			crde = crp->crp_desc;
+			crda = crde->crd_next;
+		} else {
 		crda = crp->crp_desc;
-		if (cse->info.blocksize)
 			crde = crda->crd_next;
+		}
+	} else if (cse->info.authsize) {
+		crda = crp->crp_desc;
+	} else if (cse->info.blocksize) {
+		crde = crp->crp_desc;
 	} else {
-		if (cse->info.blocksize)
-			crde = crp->crp_desc;
-		else {
 			dprintk("%s: bad request\n", __FUNCTION__);
 			error = EINVAL;
 			goto bail;
 		}
-	}
 
 	if ((error = copy_from_user(cse->uio.uio_iov[0].iov_base, cop->src,
 					cop->len))) {
@@ -297,7 +305,11 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 	 * entry and the crypto_done callback into us.
 	 */
 	error = crypto_dispatch(crp);
-	if (error == 0) {
+	if (error) {
+		dprintk("%s error in crypto_dispatch\n", __FUNCTION__);
+		goto bail;
+	}
+
 		dprintk("%s about to WAIT\n", __FUNCTION__);
 		/*
 		 * we really need to wait for driver to complete to maintain
@@ -318,7 +330,6 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 			}
 		} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
 		dprintk("%s finished WAITING error=%d\n", __FUNCTION__, error);
-	}
 
 	if (crp->crp_etype != 0) {
 		error = crp->crp_etype;
@@ -741,21 +752,27 @@ cryptodev_ioctl(
 			break;
 		case CRYPTO_MD5_HMAC:
 			info.authsize = MD5_HASH_LEN;
+			info.authkey = 16;
 			break;
 		case CRYPTO_SHA1_HMAC:
 			info.authsize = SHA1_HASH_LEN;
+			info.authkey = 20;
 			break;
 		case CRYPTO_SHA2_256_HMAC:
 			info.authsize = SHA2_256_HASH_LEN;
+			info.authkey = 32;
 			break;
 		case CRYPTO_SHA2_384_HMAC:
 			info.authsize = SHA2_384_HASH_LEN;
+			info.authkey = 48;
   			break;
 		case CRYPTO_SHA2_512_HMAC:
 			info.authsize = SHA2_512_HASH_LEN;
+			info.authkey = 64;
 			break;
 		case CRYPTO_RIPEMD160_HMAC:
 			info.authsize = RIPEMD160_HASH_LEN;
+			info.authkey = 20;
 			break;
 		default:
 			dprintk("%s(%s) - bad mac\n", __FUNCTION__, CIOCGSESSSTR);
@@ -787,10 +804,9 @@ cryptodev_ioctl(
 		if (info.authsize) {
 			cria.cri_alg = sop.mac;
 			cria.cri_klen = sop.mackeylen * 8;
-			if ((info.maxkey && sop.mackeylen > info.maxkey) ||
-					sop.keylen < info.minkey) {
-				dprintk("%s(%s) - mackeylen %d\n", __FUNCTION__, CIOCGSESSSTR,
-						sop.mackeylen);
+			if (info.authkey && sop.mackeylen != info.authkey) {
+				dprintk("%s(%s) - mackeylen %d != %d\n", __FUNCTION__,
+						CIOCGSESSSTR, sop.mackeylen, info.authkey);
 				error = EINVAL;
 				goto bail;
 			}
@@ -1049,5 +1065,5 @@ module_init(cryptodev_init);
 module_exit(cryptodev_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
 MODULE_DESCRIPTION("Cryptodev (user interface to OCF)");
diff --git a/crypto/ocf/cryptodev.h b/crypto/ocf/cryptodev.h
index 3ec926d..cca0ec8 100644
--- a/crypto/ocf/cryptodev.h
+++ b/crypto/ocf/cryptodev.h
@@ -2,8 +2,8 @@
 /*	$OpenBSD: cryptodev.h,v 1.31 2002/06/11 11:14:29 beck Exp $	*/
 
 /*-
- * Linux port done by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2007 David McCullough
+ * Linux port done by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2006-2010 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -156,7 +156,8 @@
 #define CRYPTO_SHA2_384			23
 #define CRYPTO_SHA2_512			24
 #define CRYPTO_RIPEMD160		25
-#define CRYPTO_ALGORITHM_MAX	25 /* Keep updated - see below */
+#define	CRYPTO_LZS_COMP			26
+#define CRYPTO_ALGORITHM_MAX	26 /* Keep updated - see above */
 
 /* Algorithm flags */
 #define CRYPTO_ALG_FLAG_SUPPORTED	0x01 /* Algorithm is supported */
diff --git a/crypto/ocf/cryptosoft.c b/crypto/ocf/cryptosoft.c
index 1486889..79bf76b 100644
--- a/crypto/ocf/cryptosoft.c
+++ b/crypto/ocf/cryptosoft.c
@@ -3,8 +3,8 @@
  * original cryptosoft for BSD by Angelos D. Keromytis (angelos@cis.upenn.edu)
  * but is mostly unrecognisable,
  *
- * Written by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2004-2007 David McCullough
+ * Written by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2004-2011 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  *
  * LICENSE TERMS
@@ -34,7 +34,8 @@
  * ---------------------------------------------------------------------------
  */
 
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -47,7 +48,14 @@
 #include <linux/mm.h>
 #include <linux/skbuff.h>
 #include <linux/random.h>
-#include <asm/scatterlist.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+#include <linux/scatterlist.h>
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+#include <crypto/hash.h>
+#endif
 
 #include <cryptodev.h>
 #include <uio.h>
@@ -58,19 +66,33 @@ struct {
 
 #define offset_in_page(p) ((unsigned long)(p) & ~PAGE_MASK)
 
-/* Software session entry */
+#define SW_TYPE_CIPHER		0x01
+#define SW_TYPE_HMAC		0x02
+#define SW_TYPE_HASH		0x04
+#define SW_TYPE_COMP		0x08
+#define SW_TYPE_BLKCIPHER	0x10
+#define SW_TYPE_ALG_MASK	0x1f
+
+#define SW_TYPE_ASYNC		0x8000
+
+#define SW_TYPE_INUSE		0x10000000
+
+/* We change some of the above if we have an async interface */
 
-#define SW_TYPE_CIPHER		0
-#define SW_TYPE_HMAC		1
-#define SW_TYPE_AUTH2		2
-#define SW_TYPE_HASH		3
-#define SW_TYPE_COMP		4
-#define SW_TYPE_BLKCIPHER	5
+#define SW_TYPE_ALG_AMASK	(SW_TYPE_ALG_MASK | SW_TYPE_ASYNC)
+
+#define SW_TYPE_ABLKCIPHER	(SW_TYPE_BLKCIPHER | SW_TYPE_ASYNC)
+#define SW_TYPE_AHASH		(SW_TYPE_HASH | SW_TYPE_ASYNC)
+#define SW_TYPE_AHMAC		(SW_TYPE_HMAC | SW_TYPE_ASYNC)
+
+#define SCATTERLIST_MAX 16
 
 struct swcr_data {
+	struct work_struct  workq;
 	int					sw_type;
 	int					sw_alg;
 	struct crypto_tfm	*sw_tfm;
+	spinlock_t			sw_tfm_lock;
 	union {
 		struct {
 			char *sw_key;
@@ -82,6 +104,23 @@ struct swcr_data {
 	struct swcr_data	*sw_next;
 };
 
+struct swcr_req {
+	struct swcr_data	*sw_head;
+	struct swcr_data	*sw;
+	struct cryptop		*crp;
+	struct cryptodesc	*crd;
+	struct scatterlist	 sg[SCATTERLIST_MAX];
+	unsigned char		 iv[EALG_MAX_BLOCK_LEN];
+	char				 result[HASH_MAX_LEN];
+	void				*crypto_req;
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static kmem_cache_t *swcr_req_cache;
+#else
+static struct kmem_cache *swcr_req_cache;
+#endif
+
 #ifndef CRYPTO_TFM_MODE_CBC
 /*
  * As of linux-2.6.21 this is no longer defined, and presumably no longer
@@ -103,8 +142,8 @@ struct swcr_data {
 		struct crypto_tfm *tfm;
 		void *info;
 	};
-	#define ecb(X)								#X
-	#define cbc(X)								#X
+	#define ecb(X)								#X , CRYPTO_TFM_MODE_ECB
+	#define cbc(X)								#X , CRYPTO_TFM_MODE_CBC
 	#define crypto_has_blkcipher(X, Y, Z)		crypto_alg_available(X, 0)
 	#define crypto_blkcipher_cast(X)			X
 	#define crypto_blkcipher_tfm(X)				X
@@ -116,13 +155,17 @@ struct swcr_data {
 				crypto_cipher_encrypt_iv((W)->tfm, X, Y, Z, (u8 *)((W)->info))
 	#define crypto_blkcipher_decrypt_iv(W, X, Y, Z)	\
 				crypto_cipher_decrypt_iv((W)->tfm, X, Y, Z, (u8 *)((W)->info))
+	#define crypto_blkcipher_set_flags(x, y)	/* nop */
+	#define crypto_free_blkcipher(x)			crypto_free_tfm(x)
+	#define crypto_free_comp					crypto_free_tfm
+	#define crypto_free_hash					crypto_free_tfm
 
 	/* Hash/HMAC/Digest */
 	struct hash_desc
 	{
 		struct crypto_tfm *tfm;
 	};
-	#define hmac(X)							#X
+	#define hmac(X)							#X , 0
 	#define crypto_has_hash(X, Y, Z)		crypto_alg_available(X, 0)
 	#define crypto_hash_cast(X)				X
 	#define crypto_hash_tfm(X)				X
@@ -139,53 +182,66 @@ struct swcr_data {
 	#define crypto_comp_tfm(X)				X
 	#define crypto_comp_cast(X)				X
 	#define crypto_alloc_comp(X, Y, Z)		crypto_alloc_tfm(X, mode)
+	#define plain(X)	#X , 0
 #else
-	#define ecb(X)	"ecb(" #X ")"
-	#define cbc(X)	"cbc(" #X ")"
-	#define hmac(X)	"hmac(" #X ")"
+	#define ecb(X)	"ecb(" #X ")" , 0
+	#define cbc(X)	"cbc(" #X ")" , 0
+	#define hmac(X)	"hmac(" #X ")" , 0
+	#define plain(X)	#X , 0
 #endif /* if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
 
-struct crypto_details
-{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+/* no ablkcipher in older kernels */
+#define crypto_alloc_ablkcipher(a,b,c)		(NULL)
+#define crypto_ablkcipher_tfm(x)			((struct crypto_tfm *)(x))
+#define crypto_ablkcipher_set_flags(a, b)	/* nop */
+#define crypto_ablkcipher_setkey(x, y, z)	(-EINVAL)
+#define	crypto_has_ablkcipher(a,b,c)		(0)
+#else
+#define	HAVE_ABLKCIPHER
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+/* no ahash in older kernels */
+#define crypto_ahash_tfm(x)					((struct crypto_tfm *)(x))
+#define	crypto_alloc_ahash(a,b,c)			(NULL)
+#define	crypto_ahash_digestsize(x)			0
+#else
+#define	HAVE_AHASH
+#endif
+
+struct crypto_details {
 	char *alg_name;
 	int mode;
 	int sw_type;
 };
 
-/*
- * This needs to be kept updated with CRYPTO_xxx list (cryptodev.h).
- * If the Algorithm is not supported, then insert a {NULL, 0, 0} entry.
- *
- * IMPORTANT: The index to the array IS CRYPTO_xxx.
- */
-static struct crypto_details crypto_details[CRYPTO_ALGORITHM_MAX + 1] = {
-	{ NULL,              0,                   0 },
-	/* CRYPTO_xxx index starts at 1 */
-	{ cbc(des),          CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
-	{ cbc(des3_ede),     CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
-	{ cbc(blowfish),     CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
-	{ cbc(cast5),        CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
-	{ cbc(skipjack),     CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
-	{ hmac(md5),         0,                   SW_TYPE_HMAC },
-	{ hmac(sha1),        0,                   SW_TYPE_HMAC },
-	{ hmac(ripemd160),   0,                   SW_TYPE_HMAC },
-	{ "md5-kpdk??",      0,                   SW_TYPE_HASH },
-	{ "sha1-kpdk??",     0,                   SW_TYPE_HASH },
-	{ cbc(aes),          CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
-	{ ecb(arc4),         CRYPTO_TFM_MODE_ECB, SW_TYPE_BLKCIPHER },
-	{ "md5",             0,                   SW_TYPE_HASH },
-	{ "sha1",            0,                   SW_TYPE_HASH },
-	{ hmac(digest_null), 0,                   SW_TYPE_HMAC },
-	{ cbc(cipher_null),  CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
-	{ "deflate",         0,                   SW_TYPE_COMP },
-	{ hmac(sha256),      0,                   SW_TYPE_HMAC },
-	{ hmac(sha384),      0,                   SW_TYPE_HMAC },
-	{ hmac(sha512),      0,                   SW_TYPE_HMAC },
-	{ cbc(camellia),     CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
-	{ "sha256",          0,                   SW_TYPE_HASH },
-	{ "sha384",          0,                   SW_TYPE_HASH },
-	{ "sha512",          0,                   SW_TYPE_HASH },
-	{ "ripemd160",       0,                   SW_TYPE_HASH },
+static struct crypto_details crypto_details[] = {
+	[CRYPTO_DES_CBC]         = { cbc(des),          SW_TYPE_BLKCIPHER, },
+	[CRYPTO_3DES_CBC]        = { cbc(des3_ede),     SW_TYPE_BLKCIPHER, },
+	[CRYPTO_BLF_CBC]         = { cbc(blowfish),     SW_TYPE_BLKCIPHER, },
+	[CRYPTO_CAST_CBC]        = { cbc(cast5),        SW_TYPE_BLKCIPHER, },
+	[CRYPTO_SKIPJACK_CBC]    = { cbc(skipjack),     SW_TYPE_BLKCIPHER, },
+	[CRYPTO_MD5_HMAC]        = { hmac(md5),         SW_TYPE_HMAC, },
+	[CRYPTO_SHA1_HMAC]       = { hmac(sha1),        SW_TYPE_HMAC, },
+	[CRYPTO_RIPEMD160_HMAC]  = { hmac(ripemd160),   SW_TYPE_HMAC, },
+	[CRYPTO_MD5_KPDK]        = { plain(md5-kpdk),   SW_TYPE_HASH, },
+	[CRYPTO_SHA1_KPDK]       = { plain(sha1-kpdk),  SW_TYPE_HASH, },
+	[CRYPTO_AES_CBC]         = { cbc(aes),          SW_TYPE_BLKCIPHER, },
+	[CRYPTO_ARC4]            = { ecb(arc4),         SW_TYPE_BLKCIPHER, },
+	[CRYPTO_MD5]             = { plain(md5),        SW_TYPE_HASH, },
+	[CRYPTO_SHA1]            = { plain(sha1),       SW_TYPE_HASH, },
+	[CRYPTO_NULL_HMAC]       = { hmac(digest_null), SW_TYPE_HMAC, },
+	[CRYPTO_NULL_CBC]        = { cbc(cipher_null),  SW_TYPE_BLKCIPHER, },
+	[CRYPTO_DEFLATE_COMP]    = { plain(deflate),    SW_TYPE_COMP, },
+	[CRYPTO_SHA2_256_HMAC]   = { hmac(sha256),      SW_TYPE_HMAC, },
+	[CRYPTO_SHA2_384_HMAC]   = { hmac(sha384),      SW_TYPE_HMAC, },
+	[CRYPTO_SHA2_512_HMAC]   = { hmac(sha512),      SW_TYPE_HMAC, },
+	[CRYPTO_CAMELLIA_CBC]    = { cbc(camellia),     SW_TYPE_BLKCIPHER, },
+	[CRYPTO_SHA2_256]        = { plain(sha256),     SW_TYPE_HASH, },
+	[CRYPTO_SHA2_384]        = { plain(sha384),     SW_TYPE_HASH, },
+	[CRYPTO_SHA2_512]        = { plain(sha512),     SW_TYPE_HASH, },
+	[CRYPTO_RIPEMD160]       = { plain(ripemd160),  SW_TYPE_HASH, },
 };
 
 int32_t swcr_id = -1;
@@ -197,6 +253,16 @@ module_param(swcr_fail_if_compression_grows, int, 0644);
 MODULE_PARM_DESC(swcr_fail_if_compression_grows,
                 "Treat compression that results in more data as a failure");
 
+int swcr_no_ahash = 0;
+module_param(swcr_no_ahash, int, 0644);
+MODULE_PARM_DESC(swcr_no_ahash,
+                "Do not use async hash/hmac even if available");
+
+int swcr_no_ablk = 0;
+module_param(swcr_no_ablk, int, 0644);
+MODULE_PARM_DESC(swcr_no_ablk,
+                "Do not use async blk ciphers even if available");
+
 static struct swcr_data **swcr_sessions = NULL;
 static u_int32_t swcr_sesnum = 0;
 
@@ -216,6 +282,56 @@ int swcr_debug = 0;
 module_param(swcr_debug, int, 0644);
 MODULE_PARM_DESC(swcr_debug, "Enable debug");
 
+static void swcr_process_req(struct swcr_req *req);
+
+/*
+ * somethings just need to be run with user context no matter whether
+ * the kernel compression libs use vmalloc/vfree for example.
+ */
+
+typedef struct {
+	struct work_struct wq;
+	void	(*func)(void *arg);
+	void	*arg;
+} execute_later_t;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+static void
+doing_it_now(struct work_struct *wq)
+{
+	execute_later_t *w = container_of(wq, execute_later_t, wq);
+	(w->func)(w->arg);
+	kfree(w);
+}
+#else
+static void
+doing_it_now(void *arg)
+{
+	execute_later_t *w = (execute_later_t *) arg;
+	(w->func)(w->arg);
+	kfree(w);
+}
+#endif
+
+static void
+execute_later(void (fn)(void *), void *arg)
+{
+	execute_later_t *w;
+
+	w = (execute_later_t *) kmalloc(sizeof(execute_later_t), SLAB_ATOMIC);
+	if (w) {
+		memset(w, '\0', sizeof(w));
+		w->func = fn;
+		w->arg = arg;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+		INIT_WORK(&w->wq, doing_it_now);
+#else
+		INIT_WORK(&w->wq, doing_it_now, w);
+#endif
+		schedule_work(&w->wq);
+	}
+}
+
 /*
  * Generate a new software session.
  */
@@ -226,7 +342,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 	u_int32_t i;
 	int error;
 	char *algo;
-	int mode, sw_type;
+	int mode;
 
 	dprintk("%s()\n", __FUNCTION__);
 	if (sid == NULL || cri == NULL) {
@@ -283,7 +399,8 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		}
 		memset(*swd, 0, sizeof(struct swcr_data));
 
-		if (cri->cri_alg > CRYPTO_ALGORITHM_MAX) {
+		if (cri->cri_alg < 0 ||
+				cri->cri_alg>=sizeof(crypto_details)/sizeof(crypto_details[0])){
 			printk("cryptosoft: Unknown algorithm 0x%x\n", cri->cri_alg);
 			swcr_freesession(NULL, i);
 			return EINVAL;
@@ -297,7 +414,10 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		}
 
 		mode = crypto_details[cri->cri_alg].mode;
-		sw_type = crypto_details[cri->cri_alg].sw_type;
+		(*swd)->sw_type = crypto_details[cri->cri_alg].sw_type;
+		(*swd)->sw_alg = cri->cri_alg;
+
+		spin_lock_init(&(*swd)->sw_tfm_lock);
 
 		/* Algorithm specific configuration */
 		switch (cri->cri_alg) {
@@ -308,44 +428,78 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			break;
 		}
 
-		if (sw_type == SW_TYPE_BLKCIPHER) {
-			dprintk("%s crypto_alloc_blkcipher(%s, 0x%x)\n", __FUNCTION__,
+		if ((*swd)->sw_type & SW_TYPE_BLKCIPHER) {
+			dprintk("%s crypto_alloc_*blkcipher(%s, 0x%x)\n", __FUNCTION__,
 					algo, mode);
 
+			/* try async first */
+			(*swd)->sw_tfm = swcr_no_ablk ? NULL :
+					crypto_ablkcipher_tfm(crypto_alloc_ablkcipher(algo, 0, 0));
+			if ((*swd)->sw_tfm && !IS_ERR((*swd)->sw_tfm)) {
+				dprintk("%s %s cipher is async\n", __FUNCTION__, algo);
+				(*swd)->sw_type |= SW_TYPE_ASYNC;
+			} else {
 			(*swd)->sw_tfm = crypto_blkcipher_tfm(
-								crypto_alloc_blkcipher(algo, 0,
-									CRYPTO_ALG_ASYNC));
-			if (!(*swd)->sw_tfm) {
+						crypto_alloc_blkcipher(algo, 0, CRYPTO_ALG_ASYNC));
+				if ((*swd)->sw_tfm && !IS_ERR((*swd)->sw_tfm))
+					dprintk("%s %s cipher is sync\n", __FUNCTION__, algo);
+			}
+			if (!(*swd)->sw_tfm || IS_ERR((*swd)->sw_tfm)) {
+				int err;
 				dprintk("cryptosoft: crypto_alloc_blkcipher failed(%s,0x%x)\n",
 						algo,mode);
+				err = IS_ERR((*swd)->sw_tfm) ? -(PTR_ERR((*swd)->sw_tfm)) : EINVAL;
+				(*swd)->sw_tfm = NULL; /* ensure NULL */
 				swcr_freesession(NULL, i);
-				return EINVAL;
+				return err;
 			}
 
 			if (debug) {
 				dprintk("%s key:cri->cri_klen=%d,(cri->cri_klen + 7)/8=%d",
 						__FUNCTION__,cri->cri_klen,(cri->cri_klen + 7)/8);
 				for (i = 0; i < (cri->cri_klen + 7) / 8; i++)
-				{
-					dprintk("%s0x%x", (i % 8) ? " " : "\n    ",cri->cri_key[i]);
-				}
+					dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
+							cri->cri_key[i] & 0xff);
 				dprintk("\n");
 			}
+			if ((*swd)->sw_type & SW_TYPE_ASYNC) {
+				/* OCF doesn't enforce keys */
+				crypto_ablkcipher_set_flags(
+						__crypto_ablkcipher_cast((*swd)->sw_tfm),
+							CRYPTO_TFM_REQ_WEAK_KEY);
+				error = crypto_ablkcipher_setkey(
+							__crypto_ablkcipher_cast((*swd)->sw_tfm),
+								cri->cri_key, (cri->cri_klen + 7) / 8);
+			} else {
+				/* OCF doesn't enforce keys */
+				crypto_blkcipher_set_flags(
+						crypto_blkcipher_cast((*swd)->sw_tfm),
+							CRYPTO_TFM_REQ_WEAK_KEY);
 			error = crypto_blkcipher_setkey(
-						crypto_blkcipher_cast((*swd)->sw_tfm), cri->cri_key,
-							(cri->cri_klen + 7) / 8);
+							crypto_blkcipher_cast((*swd)->sw_tfm),
+								cri->cri_key, (cri->cri_klen + 7) / 8);
+			}
 			if (error) {
 				printk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n", error,
 						(*swd)->sw_tfm->crt_flags);
 				swcr_freesession(NULL, i);
 				return error;
 			}
-		} else if (sw_type == SW_TYPE_HMAC || sw_type == SW_TYPE_HASH) {
-			dprintk("%s crypto_alloc_hash(%s, 0x%x)\n", __FUNCTION__,
+		} else if ((*swd)->sw_type & (SW_TYPE_HMAC | SW_TYPE_HASH)) {
+			dprintk("%s crypto_alloc_*hash(%s, 0x%x)\n", __FUNCTION__,
 					algo, mode);
 
+			/* try async first */
+			(*swd)->sw_tfm = swcr_no_ahash ? NULL :
+					crypto_ahash_tfm(crypto_alloc_ahash(algo, 0, 0));
+			if ((*swd)->sw_tfm) {
+				dprintk("%s %s hash is async\n", __FUNCTION__, algo);
+				(*swd)->sw_type |= SW_TYPE_ASYNC;
+			} else {
+				dprintk("%s %s hash is sync\n", __FUNCTION__, algo);
 			(*swd)->sw_tfm = crypto_hash_tfm(
 								crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC));
+			}
 
 			if (!(*swd)->sw_tfm) {
 				dprintk("cryptosoft: crypto_alloc_hash failed(%s,0x%x)\n",
@@ -365,12 +519,14 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			memcpy((*swd)->u.hmac.sw_key, cri->cri_key, (*swd)->u.hmac.sw_klen);
 			if (cri->cri_mlen) {
 				(*swd)->u.hmac.sw_mlen = cri->cri_mlen;
+			} else if ((*swd)->sw_type & SW_TYPE_ASYNC) {
+				(*swd)->u.hmac.sw_mlen = crypto_ahash_digestsize(
+						__crypto_ahash_cast((*swd)->sw_tfm));
 			} else {
-				(*swd)->u.hmac.sw_mlen =
-						crypto_hash_digestsize(
+				(*swd)->u.hmac.sw_mlen = crypto_hash_digestsize(
 								crypto_hash_cast((*swd)->sw_tfm));
 			}
-		} else if (sw_type == SW_TYPE_COMP) {
+		} else if ((*swd)->sw_type & SW_TYPE_COMP) {
 			(*swd)->sw_tfm = crypto_comp_tfm(
 					crypto_alloc_comp(algo, 0, CRYPTO_ALG_ASYNC));
 			if (!(*swd)->sw_tfm) {
@@ -386,14 +542,11 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 				return ENOBUFS;
 			}
 		} else {
-			printk("cryptosoft: Unhandled sw_type %d\n", sw_type);
+			printk("cryptosoft: Unhandled sw_type %d\n", (*swd)->sw_type);
 			swcr_freesession(NULL, i);
 			return EINVAL;
 		}
 
-		(*swd)->sw_alg = cri->cri_alg;
-		(*swd)->sw_type = sw_type;
-
 		cri = cri->cri_next;
 		swd = &((*swd)->sw_next);
 	}
@@ -422,9 +575,39 @@ swcr_freesession(device_t dev, u_int64_t tid)
 
 	while ((swd = swcr_sessions[sid]) != NULL) {
 		swcr_sessions[sid] = swd->sw_next;
-		if (swd->sw_tfm)
+		if (swd->sw_tfm) {
+			switch (swd->sw_type & SW_TYPE_ALG_AMASK) {
+#ifdef HAVE_AHASH
+			case SW_TYPE_AHMAC:
+			case SW_TYPE_AHASH:
+				crypto_free_ahash(__crypto_ahash_cast(swd->sw_tfm));
+				break;
+#endif
+#ifdef HAVE_ABLKCIPHER
+			case SW_TYPE_ABLKCIPHER:
+				crypto_free_ablkcipher(__crypto_ablkcipher_cast(swd->sw_tfm));
+				break;
+#endif
+			case SW_TYPE_BLKCIPHER:
+				crypto_free_blkcipher(crypto_blkcipher_cast(swd->sw_tfm));
+				break;
+			case SW_TYPE_HMAC:
+			case SW_TYPE_HASH:
+				crypto_free_hash(crypto_hash_cast(swd->sw_tfm));
+				break;
+			case SW_TYPE_COMP:
+				if (in_interrupt())
+					execute_later((void (*)(void *))crypto_free_comp, (void *)crypto_comp_cast(swd->sw_tfm));
+				else
+					crypto_free_comp(crypto_comp_cast(swd->sw_tfm));
+				break;
+			default:
 			crypto_free_tfm(swd->sw_tfm);
-		if (swd->sw_type == SW_TYPE_COMP) {
+				break;
+			}
+			swd->sw_tfm = NULL;
+		}
+		if (swd->sw_type & SW_TYPE_COMP) {
 			if (swd->u.sw_comp_buf)
 				kfree(swd->u.sw_comp_buf);
 		} else {
@@ -436,66 +619,86 @@ swcr_freesession(device_t dev, u_int64_t tid)
 	return 0;
 }
 
-/*
- * Process a software request.
- */
-static int
-swcr_process(device_t dev, struct cryptop *crp, int hint)
+static void swcr_process_req_complete(struct swcr_req *req)
 {
-	struct cryptodesc *crd;
-	struct swcr_data *sw;
-	u_int32_t lid;
-#define SCATTERLIST_MAX 16
-	struct scatterlist sg[SCATTERLIST_MAX];
-	int sg_num, sg_len, skip;
-	struct sk_buff *skb = NULL;
-	struct uio *uiop = NULL;
-
 	dprintk("%s()\n", __FUNCTION__);
-	/* Sanity check */
-	if (crp == NULL) {
-		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-		return EINVAL;
+
+	if (req->sw->sw_type & SW_TYPE_INUSE) {
+		unsigned long flags;
+		spin_lock_irqsave(&req->sw->sw_tfm_lock, flags);
+		req->sw->sw_type &= ~SW_TYPE_INUSE;
+		spin_unlock_irqrestore(&req->sw->sw_tfm_lock, flags);
 	}
 
-	crp->crp_etype = 0;
+	if (req->crp->crp_etype)
+		goto done;
 
-	if (crp->crp_desc == NULL || crp->crp_buf == NULL) {
-		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-		crp->crp_etype = EINVAL;
+	switch (req->sw->sw_type & SW_TYPE_ALG_AMASK) {
+#if defined(HAVE_AHASH)
+	case SW_TYPE_AHMAC:
+	case SW_TYPE_AHASH:
+		crypto_copyback(req->crp->crp_flags, req->crp->crp_buf,
+				req->crd->crd_inject, req->sw->u.hmac.sw_mlen, req->result);
+		ahash_request_free(req->crypto_req);
+		break;
+#endif
+#if defined(HAVE_ABLKCIPHER)
+	case SW_TYPE_ABLKCIPHER:
+		ablkcipher_request_free(req->crypto_req);
+		break;
+#endif
+	case SW_TYPE_CIPHER:
+	case SW_TYPE_HMAC:
+	case SW_TYPE_HASH:
+	case SW_TYPE_COMP:
+	case SW_TYPE_BLKCIPHER:
+		break;
+	default:
+		req->crp->crp_etype = EINVAL;
 		goto done;
 	}
 
-	lid = crp->crp_sid & 0xffffffff;
-	if (lid >= swcr_sesnum || lid == 0 || swcr_sessions == NULL ||
-			swcr_sessions[lid] == NULL) {
-		crp->crp_etype = ENOENT;
-		dprintk("%s,%d: ENOENT\n", __FILE__, __LINE__);
-		goto done;
+	req->crd = req->crd->crd_next;
+	if (req->crd) {
+		swcr_process_req(req);
+		return;
 	}
 
-	/*
-	 * do some error checking outside of the loop for SKB and IOV processing
-	 * this leaves us with valid skb or uiop pointers for later
-	 */
-	if (crp->crp_flags & CRYPTO_F_SKBUF) {
-		skb = (struct sk_buff *) crp->crp_buf;
-		if (skb_shinfo(skb)->nr_frags >= SCATTERLIST_MAX) {
-			printk("%s,%d: %d nr_frags > SCATTERLIST_MAX", __FILE__, __LINE__,
-					skb_shinfo(skb)->nr_frags);
-			goto done;
+done:
+	dprintk("%s crypto_done %p\n", __FUNCTION__, req);
+	crypto_done(req->crp);
+	kmem_cache_free(swcr_req_cache, req);
 		}
-	} else if (crp->crp_flags & CRYPTO_F_IOV) {
-		uiop = (struct uio *) crp->crp_buf;
-		if (uiop->uio_iovcnt > SCATTERLIST_MAX) {
-			printk("%s,%d: %d uio_iovcnt > SCATTERLIST_MAX", __FILE__, __LINE__,
-					uiop->uio_iovcnt);
-			goto done;
+
+#if defined(HAVE_ABLKCIPHER) || defined(HAVE_AHASH)
+static void swcr_process_callback(struct crypto_async_request *creq, int err)
+{
+	struct swcr_req *req = creq->data;
+
+	dprintk("%s()\n", __FUNCTION__);
+	if (err) {
+		if (err == -EINPROGRESS)
+			return;
+		dprintk("%s() fail %d\n", __FUNCTION__, -err);
+		req->crp->crp_etype = -err;
 		}
+
+	swcr_process_req_complete(req);
 	}
+#endif /* defined(HAVE_ABLKCIPHER) || defined(HAVE_AHASH) */
+
+
+static void swcr_process_req(struct swcr_req *req)
+{
+	struct swcr_data *sw;
+	struct cryptop *crp = req->crp;
+	struct cryptodesc *crd = req->crd;
+	struct sk_buff *skb = (struct sk_buff *) crp->crp_buf;
+	struct uio *uiop = (struct uio *) crp->crp_buf;
+	int sg_num, sg_len, skip;
+
+	dprintk("%s()\n", __FUNCTION__);
 
-	/* Go through crypto descriptors, processing as we go */
-	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
 		/*
 		 * Find the crypto context.
 		 *
@@ -506,8 +709,7 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 		 * XXX between the various instances of an algorithm (so we can
 		 * XXX locate the correct crypto context).
 		 */
-		for (sw = swcr_sessions[lid]; sw && sw->sw_alg != crd->crd_alg;
-				sw = sw->sw_next)
+	for (sw = req->sw_head; sw && sw->sw_alg != crd->crd_alg; sw = sw->sw_next)
 			;
 
 		/* No such context ? */
@@ -517,12 +719,37 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 			goto done;
 		}
 
+	/*
+	 * for some types we need to ensure only one user as info is stored in
+	 * the tfm during an operation that can get corrupted
+	 */
+	switch (sw->sw_type & SW_TYPE_ALG_AMASK) {
+#ifdef HAVE_AHASH
+	case SW_TYPE_AHMAC:
+	case SW_TYPE_AHASH:
+#endif
+	case SW_TYPE_HMAC:
+	case SW_TYPE_HASH: {
+		unsigned long flags;
+		spin_lock_irqsave(&sw->sw_tfm_lock, flags);
+		if (sw->sw_type & SW_TYPE_INUSE) {
+			spin_unlock_irqrestore(&sw->sw_tfm_lock, flags);
+			execute_later((void (*)(void *))swcr_process_req, (void *)req);
+			return;
+		}
+		sw->sw_type |= SW_TYPE_INUSE;
+		spin_unlock_irqrestore(&sw->sw_tfm_lock, flags);
+		} break;
+	}
+
+	req->sw = sw;
 		skip = crd->crd_skip;
 
 		/*
 		 * setup the SG list skip from the start of the buffer
 		 */
-		memset(sg, 0, sizeof(sg));
+	memset(req->sg, 0, sizeof(req->sg));
+	sg_init_table(req->sg, SCATTERLIST_MAX);
 		if (crp->crp_flags & CRYPTO_F_SKBUF) {
 			int i, len;
 
@@ -533,7 +760,7 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 				len = skb_headlen(skb) - skip;
 				if (len + sg_len > crd->crd_len)
 					len = crd->crd_len - sg_len;
-				sg_set_page(&sg[sg_num],
+			sg_set_page(&req->sg[sg_num],
 					virt_to_page(skb->data + skip), len,
 					offset_in_page(skb->data + skip));
 				sg_len += len;
@@ -549,8 +776,8 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 					len = skb_shinfo(skb)->frags[i].size - skip;
 					if (len + sg_len > crd->crd_len)
 						len = crd->crd_len - sg_len;
-					sg_set_page(&sg[sg_num],
-						skb_shinfo(skb)->frags[i].page,
+				sg_set_page(&req->sg[sg_num],
+					skb_frag_page(&skb_shinfo(skb)->frags[i]),
 						len,
 						skb_shinfo(skb)->frags[i].page_offset + skip);
 					sg_len += len;
@@ -563,14 +790,14 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 			int len;
 
 			sg_len = 0;
-			for (sg_num = 0; sg_len <= crd->crd_len &&
+		for (sg_num = 0; sg_len < crd->crd_len &&
 					sg_num < uiop->uio_iovcnt &&
 					sg_num < SCATTERLIST_MAX; sg_num++) {
 				if (skip <= uiop->uio_iov[sg_num].iov_len) {
 					len = uiop->uio_iov[sg_num].iov_len - skip;
 					if (len + sg_len > crd->crd_len)
 						len = crd->crd_len - sg_len;
-					sg_set_page(&sg[sg_num],
+				sg_set_page(&req->sg[sg_num],
 						virt_to_page(uiop->uio_iov[sg_num].iov_base+skip),
 						len,
 						offset_in_page(uiop->uio_iov[sg_num].iov_base+skip));
@@ -583,19 +810,165 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 			sg_len = (crp->crp_ilen - skip);
 			if (sg_len > crd->crd_len)
 				sg_len = crd->crd_len;
-			sg_set_page(&sg[0], virt_to_page(crp->crp_buf + skip),
+		sg_set_page(&req->sg[0], virt_to_page(crp->crp_buf + skip),
 				sg_len, offset_in_page(crp->crp_buf + skip));
 			sg_num = 1;
 		}
+	if (sg_num > 0)
+		sg_mark_end(&req->sg[sg_num-1]);
+
+	switch (sw->sw_type & SW_TYPE_ALG_AMASK) {
+
+#ifdef HAVE_AHASH
+	case SW_TYPE_AHMAC:
+	case SW_TYPE_AHASH:
+		{
+		int ret;
 
+		/* check we have room for the result */
+		if (crp->crp_ilen - crd->crd_inject < sw->u.hmac.sw_mlen) {
+			dprintk("cryptosoft: EINVAL crp_ilen=%d, len=%d, inject=%d "
+					"digestsize=%d\n", crp->crp_ilen, crd->crd_skip + sg_len,
+					crd->crd_inject, sw->u.hmac.sw_mlen);
+			crp->crp_etype = EINVAL;
+			goto done;
+		}
+
+		req->crypto_req =
+				ahash_request_alloc(__crypto_ahash_cast(sw->sw_tfm),GFP_ATOMIC);
+		if (!req->crypto_req) {
+			crp->crp_etype = ENOMEM;
+			dprintk("%s,%d: ENOMEM ahash_request_alloc", __FILE__, __LINE__);
+			goto done;
+		}
+
+		ahash_request_set_callback(req->crypto_req,
+				CRYPTO_TFM_REQ_MAY_BACKLOG, swcr_process_callback, req);
+
+		memset(req->result, 0, sizeof(req->result));
+
+		if (sw->sw_type & SW_TYPE_AHMAC)
+			crypto_ahash_setkey(__crypto_ahash_cast(sw->sw_tfm),
+					sw->u.hmac.sw_key, sw->u.hmac.sw_klen);
+		ahash_request_set_crypt(req->crypto_req, req->sg, req->result, sg_len);
+		ret = crypto_ahash_digest(req->crypto_req);
+		switch (ret) {
+		case -EINPROGRESS:
+		case -EBUSY:
+			return;
+		default:
+		case 0:
+			dprintk("hash OP %s %d\n", ret ? "failed" : "success", ret);
+			crp->crp_etype = ret;
+			goto done;
+		}
+		} break;
+#endif /* HAVE_AHASH */
+
+#ifdef HAVE_ABLKCIPHER
+	case SW_TYPE_ABLKCIPHER: {
+		int ret;
+		unsigned char *ivp = req->iv;
+		int ivsize =
+			crypto_ablkcipher_ivsize(__crypto_ablkcipher_cast(sw->sw_tfm));
+
+		if (sg_len < crypto_ablkcipher_blocksize(
+				__crypto_ablkcipher_cast(sw->sw_tfm))) {
+			crp->crp_etype = EINVAL;
+			dprintk("%s,%d: EINVAL len %d < %d\n", __FILE__, __LINE__,
+					sg_len, crypto_ablkcipher_blocksize(
+						__crypto_ablkcipher_cast(sw->sw_tfm)));
+			goto done;
+		}
+
+		if (ivsize > sizeof(req->iv)) {
+			crp->crp_etype = EINVAL;
+			dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+			goto done;
+		}
+
+		req->crypto_req = ablkcipher_request_alloc(
+				__crypto_ablkcipher_cast(sw->sw_tfm), GFP_ATOMIC);
+		if (!req->crypto_req) {
+			crp->crp_etype = ENOMEM;
+			dprintk("%s,%d: ENOMEM ablkcipher_request_alloc",
+					__FILE__, __LINE__);
+			goto done;
+		}
+
+		ablkcipher_request_set_callback(req->crypto_req,
+				CRYPTO_TFM_REQ_MAY_BACKLOG, swcr_process_callback, req);
+
+		if (crd->crd_flags & CRD_F_KEY_EXPLICIT) {
+			int i, error;
+
+			if (debug) {
+				dprintk("%s key:", __FUNCTION__);
+				for (i = 0; i < (crd->crd_klen + 7) / 8; i++)
+					dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
+							crd->crd_key[i] & 0xff);
+				dprintk("\n");
+			}
+			/* OCF doesn't enforce keys */
+			crypto_ablkcipher_set_flags(__crypto_ablkcipher_cast(sw->sw_tfm),
+					CRYPTO_TFM_REQ_WEAK_KEY);
+			error = crypto_ablkcipher_setkey(
+						__crypto_ablkcipher_cast(sw->sw_tfm), crd->crd_key,
+						(crd->crd_klen + 7) / 8);
+			if (error) {
+				dprintk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n",
+						error, sw->sw_tfm->crt_flags);
+				crp->crp_etype = -error;
+			}
+		}
+
+		if (crd->crd_flags & CRD_F_ENCRYPT) { /* encrypt */
+
+			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
+				ivp = crd->crd_iv;
+			else
+				get_random_bytes(ivp, ivsize);
+			/*
+			 * do we have to copy the IV back to the buffer ?
+			 */
+			if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
+				crypto_copyback(crp->crp_flags, crp->crp_buf,
+						crd->crd_inject, ivsize, (caddr_t)ivp);
+			}
+			ablkcipher_request_set_crypt(req->crypto_req, req->sg, req->sg,
+					sg_len, ivp);
+			ret = crypto_ablkcipher_encrypt(req->crypto_req);
+
+		} else { /*decrypt */
+
+			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
+				ivp = crd->crd_iv;
+			else
+				crypto_copydata(crp->crp_flags, crp->crp_buf,
+						crd->crd_inject, ivsize, (caddr_t)ivp);
+			ablkcipher_request_set_crypt(req->crypto_req, req->sg, req->sg,
+					sg_len, ivp);
+			ret = crypto_ablkcipher_decrypt(req->crypto_req);
+		}
+
+		switch (ret) {
+		case -EINPROGRESS:
+		case -EBUSY:
+			return;
+		default:
+		case 0:
+			dprintk("crypto OP %s %d\n", ret ? "failed" : "success", ret);
+			crp->crp_etype = ret;
+			goto done;
+		}
+		} break;
+#endif /* HAVE_ABLKCIPHER */
 
-		switch (sw->sw_type) {
 		case SW_TYPE_BLKCIPHER: {
 			unsigned char iv[EALG_MAX_BLOCK_LEN];
 			unsigned char *ivp = iv;
-			int ivsize = 
-				crypto_blkcipher_ivsize(crypto_blkcipher_cast(sw->sw_tfm));
 			struct blkcipher_desc desc;
+		int ivsize = crypto_blkcipher_ivsize(crypto_blkcipher_cast(sw->sw_tfm));
 
 			if (sg_len < crypto_blkcipher_blocksize(
 					crypto_blkcipher_cast(sw->sw_tfm))) {
@@ -619,9 +992,12 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 					dprintk("%s key:", __FUNCTION__);
 					for (i = 0; i < (crd->crd_klen + 7) / 8; i++)
 						dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
-								crd->crd_key[i]);
+							crd->crd_key[i] & 0xff);
 					dprintk("\n");
 				}
+			/* OCF doesn't enforce keys */
+			crypto_blkcipher_set_flags(crypto_blkcipher_cast(sw->sw_tfm),
+					CRYPTO_TFM_REQ_WEAK_KEY);
 				error = crypto_blkcipher_setkey(
 							crypto_blkcipher_cast(sw->sw_tfm), crd->crd_key,
 							(crd->crd_klen + 7) / 8);
@@ -650,7 +1026,7 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 							crd->crd_inject, ivsize, (caddr_t)ivp);
 				}
 				desc.info = ivp;
-				crypto_blkcipher_encrypt_iv(&desc, sg, sg, sg_len);
+			crypto_blkcipher_encrypt_iv(&desc, req->sg, req->sg, sg_len);
 
 			} else { /*decrypt */
 
@@ -661,9 +1037,10 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 							crd->crd_inject, ivsize, (caddr_t)ivp);
 				}
 				desc.info = ivp;
-				crypto_blkcipher_decrypt_iv(&desc, sg, sg, sg_len);
+			crypto_blkcipher_decrypt_iv(&desc, req->sg, req->sg, sg_len);
 			}
 			} break;
+
 		case SW_TYPE_HMAC:
 		case SW_TYPE_HASH:
 			{
@@ -672,10 +1049,9 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 
 			/* check we have room for the result */
 			if (crp->crp_ilen - crd->crd_inject < sw->u.hmac.sw_mlen) {
-				dprintk(
-			"cryptosoft: EINVAL crp_ilen=%d, len=%d, inject=%d digestsize=%d\n",
-						crp->crp_ilen, crd->crd_skip + sg_len, crd->crd_inject,
-						sw->u.hmac.sw_mlen);
+			dprintk("cryptosoft: EINVAL crp_ilen=%d, len=%d, inject=%d "
+					"digestsize=%d\n", crp->crp_ilen, crd->crd_skip + sg_len,
+					crd->crd_inject, sw->u.hmac.sw_mlen);
 				crp->crp_etype = EINVAL;
 				goto done;
 			}
@@ -685,18 +1061,18 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 
 			memset(result, 0, sizeof(result));
 
-			if (sw->sw_type == SW_TYPE_HMAC) {
+		if (sw->sw_type & SW_TYPE_HMAC) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 				crypto_hmac(sw->sw_tfm, sw->u.hmac.sw_key, &sw->u.hmac.sw_klen,
-						sg, sg_num, result);
+					req->sg, sg_num, result);
 #else
 				crypto_hash_setkey(desc.tfm, sw->u.hmac.sw_key,
 						sw->u.hmac.sw_klen);
-				crypto_hash_digest(&desc, sg, sg_len, result);
-#endif /* #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
+			crypto_hash_digest(&desc, req->sg, sg_len, result);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
 				
 			} else { /* SW_TYPE_HASH */
-				crypto_hash_digest(&desc, sg, sg_len, result);
+			crypto_hash_digest(&desc, req->sg, sg_len, result);
 			}
 
 			crypto_copyback(crp->crp_flags, crp->crp_buf,
@@ -723,13 +1099,13 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 
 				ibuf = obuf;
 				for (blk = 0; blk < sg_num; blk++) {
-					memcpy(obuf, sg_virt(&sg[blk]),
-							sg[blk].length);
-					obuf += sg[blk].length;
+				memcpy(obuf, sg_virt(&req->sg[blk]),
+						req->sg[blk].length);
+				obuf += req->sg[blk].length;
 				}
 				olen -= sg_len;
 			} else
-				ibuf = sg_virt(&sg[0]);
+			ibuf = sg_virt(&req->sg[0]);
 
 			if (crd->crd_flags & CRD_F_ENCRYPT) { /* compress */
 				ret = crypto_comp_compress(crypto_comp_cast(sw->sw_tfm),
@@ -764,8 +1140,6 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 						crd->crd_inject, olen, obuf);
 				crp->crp_olen = olen;
 			}
-
-
 			} break;
 
 		default:
@@ -774,13 +1148,90 @@ swcr_process(device_t dev, struct cryptop *crp, int hint)
 			crp->crp_etype = EINVAL;
 			goto done;
 		}
+
+done:
+	swcr_process_req_complete(req);
+}
+
+
+/*
+ * Process a crypto request.
+ */
+static int
+swcr_process(device_t dev, struct cryptop *crp, int hint)
+{
+	struct swcr_req *req = NULL;
+	u_int32_t lid;
+
+	dprintk("%s()\n", __FUNCTION__);
+	/* Sanity check */
+	if (crp == NULL) {
+		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+		return EINVAL;
 	}
 
+	crp->crp_etype = 0;
+
+	if (crp->crp_desc == NULL || crp->crp_buf == NULL) {
+		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+		crp->crp_etype = EINVAL;
+		goto done;
+	}
+
+	lid = crp->crp_sid & 0xffffffff;
+	if (lid >= swcr_sesnum || lid == 0 || swcr_sessions == NULL ||
+			swcr_sessions[lid] == NULL) {
+		crp->crp_etype = ENOENT;
+		dprintk("%s,%d: ENOENT\n", __FILE__, __LINE__);
+		goto done;
+	}
+
+	/*
+	 * do some error checking outside of the loop for SKB and IOV processing
+	 * this leaves us with valid skb or uiop pointers for later
+	 */
+	if (crp->crp_flags & CRYPTO_F_SKBUF) {
+		struct sk_buff *skb = (struct sk_buff *) crp->crp_buf;
+		if (skb_shinfo(skb)->nr_frags >= SCATTERLIST_MAX) {
+			printk("%s,%d: %d nr_frags > SCATTERLIST_MAX", __FILE__, __LINE__,
+					skb_shinfo(skb)->nr_frags);
+			goto done;
+		}
+	} else if (crp->crp_flags & CRYPTO_F_IOV) {
+		struct uio *uiop = (struct uio *) crp->crp_buf;
+		if (uiop->uio_iovcnt > SCATTERLIST_MAX) {
+			printk("%s,%d: %d uio_iovcnt > SCATTERLIST_MAX", __FILE__, __LINE__,
+					uiop->uio_iovcnt);
+			goto done;
+		}
+	}
+
+	/*
+	 * setup a new request ready for queuing
+	 */
+	req = kmem_cache_alloc(swcr_req_cache, SLAB_ATOMIC);
+	if (req == NULL) {
+		dprintk("%s,%d: ENOMEM\n", __FILE__, __LINE__);
+		crp->crp_etype = ENOMEM;
+		goto done;
+	}
+	memset(req, 0, sizeof(*req));
+
+	req->sw_head = swcr_sessions[lid];
+	req->crp = crp;
+	req->crd = crp->crp_desc;
+
+	swcr_process_req(req);
+	return 0;
+
 done:
 	crypto_done(crp);
+	if (req)
+		kmem_cache_free(swcr_req_cache, req);
 	return 0;
 }
 
+
 static int
 cryptosoft_init(void)
 {
@@ -789,24 +1240,34 @@ cryptosoft_init(void)
 
 	dprintk("%s(%p)\n", __FUNCTION__, cryptosoft_init);
 
+	swcr_req_cache = kmem_cache_create("cryptosoft_req",
+				sizeof(struct swcr_req), 0, SLAB_HWCACHE_ALIGN, NULL
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+				, NULL
+#endif
+				);
+	if (!swcr_req_cache) {
+		printk("cryptosoft: failed to create request cache\n");
+		return -ENOENT;
+	}
+
 	softc_device_init(&swcr_softc, "cryptosoft", 0, swcr_methods);
 
 	swcr_id = crypto_get_driverid(softc_get_device(&swcr_softc),
 			CRYPTOCAP_F_SOFTWARE | CRYPTOCAP_F_SYNC);
 	if (swcr_id < 0) {
-		printk("Software crypto device cannot initialize!");
+		printk("cryptosoft: Software crypto device cannot initialize!");
 		return -ENODEV;
 	}
 
 #define	REGISTER(alg) \
-		crypto_register(swcr_id, alg, 0,0);
+		crypto_register(swcr_id, alg, 0,0)
 
-	for (i = CRYPTO_ALGORITHM_MIN; i <= CRYPTO_ALGORITHM_MAX; ++i)
-	{
+	for (i = 0; i < sizeof(crypto_details)/sizeof(crypto_details[0]); i++) {
+		int found;
 		
 		algo = crypto_details[i].alg_name;
-		if (!algo || !*algo)
-		{
+		if (!algo || !*algo) {
 			dprintk("%s:Algorithm %d not supported\n", __FUNCTION__, i);
 			continue;
 		}
@@ -814,72 +1275,34 @@ cryptosoft_init(void)
 		mode = crypto_details[i].mode;
 		sw_type = crypto_details[i].sw_type;
 
-		switch (sw_type)
-		{
+		found = 0;
+		switch (sw_type & SW_TYPE_ALG_MASK) {
 			case SW_TYPE_CIPHER:
-				if (crypto_has_cipher(algo, 0, CRYPTO_ALG_ASYNC))
-				{
-					REGISTER(i);
-				}
-				else
-				{
-					dprintk("%s:CIPHER algorithm %d:'%s' not supported\n",
-								__FUNCTION__, i, algo);
-				}
+			found = crypto_has_cipher(algo, 0, CRYPTO_ALG_ASYNC);
 				break;
 			case SW_TYPE_HMAC:
-				if (crypto_has_hash(algo, 0, CRYPTO_ALG_ASYNC))
-				{
-					REGISTER(i);
-				}
-				else
-				{
-					dprintk("%s:HMAC algorithm %d:'%s' not supported\n",
-								__FUNCTION__, i, algo);
-				}
+			found = crypto_has_hash(algo, 0, swcr_no_ahash?CRYPTO_ALG_ASYNC:0);
 				break;
 			case SW_TYPE_HASH:
-				if (crypto_has_hash(algo, 0, CRYPTO_ALG_ASYNC))
-				{
-					REGISTER(i);
-				}
-				else
-				{
-					dprintk("%s:HASH algorithm %d:'%s' not supported\n",
-								__FUNCTION__, i, algo);
-				}
+			found = crypto_has_hash(algo, 0, swcr_no_ahash?CRYPTO_ALG_ASYNC:0);
 				break;
 			case SW_TYPE_COMP:
-				if (crypto_has_comp(algo, 0, CRYPTO_ALG_ASYNC))
-				{
-					REGISTER(i);
-				}
-				else
-				{
-					dprintk("%s:COMP algorithm %d:'%s' not supported\n",
-								__FUNCTION__, i, algo);
-				}
+			found = crypto_has_comp(algo, 0, CRYPTO_ALG_ASYNC);
 				break;
 			case SW_TYPE_BLKCIPHER:
-				if (crypto_has_blkcipher(algo, 0, CRYPTO_ALG_ASYNC))
-				{
+			found = crypto_has_blkcipher(algo, 0, CRYPTO_ALG_ASYNC);
+			if (!found && !swcr_no_ablk)
+				found = crypto_has_ablkcipher(algo, 0, 0);
+			break;
+		}
+		if (found) {
 					REGISTER(i);
-				}
-				else
-				{
-					dprintk("%s:BLKCIPHER algorithm %d:'%s' not supported\n",
-								__FUNCTION__, i, algo);
-				}
-				break;
-			default:
-				dprintk(
-				"%s:Algorithm Type %d not supported (algorithm %d:'%s')\n",
+		} else {
+			dprintk("%s:Algorithm Type %d not supported (algorithm %d:'%s')\n",
 					__FUNCTION__, sw_type, i, algo);
-				break;
 		}
 	}
-
-	return(0);
+	return 0;
 }
 
 static void
@@ -888,11 +1311,12 @@ cryptosoft_exit(void)
 	dprintk("%s()\n", __FUNCTION__);
 	crypto_unregister_all(swcr_id);
 	swcr_id = -1;
+	kmem_cache_destroy(swcr_req_cache);
 }
 
-module_init(cryptosoft_init);
+late_initcall(cryptosoft_init);
 module_exit(cryptosoft_exit);
 
 MODULE_LICENSE("Dual BSD/GPL");
-MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
 MODULE_DESCRIPTION("Cryptosoft (OCF module for kernel crypto)");
diff --git a/crypto/ocf/ep80579/Makefile b/crypto/ocf/ep80579/Makefile
index 19ff6eb..9aab295 100644
--- a/crypto/ocf/ep80579/Makefile
+++ b/crypto/ocf/ep80579/Makefile
@@ -13,7 +13,7 @@
 # 
 #   GPL LICENSE SUMMARY
 # 
-#   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+#   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
 # 
 #   This program is free software; you can redistribute it and/or modify 
 #   it under the terms of version 2 of the GNU General Public License as
@@ -35,7 +35,7 @@
 # 
 #   BSD LICENSE 
 # 
-#   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+#   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
 #   All rights reserved.
 # 
 #   Redistribution and use in source and binary forms, with or without 
@@ -65,43 +65,55 @@
 #   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 # 
 # 
-#  version: Security.L.1.0.130
+#  version: Security.L.1.0.2-229
 ############################################################################
 
 
 ####################Common variables and definitions########################
 
+ifndef ICP_ROOT
+$(warning ICP_ROOT is undefined. Please set the path to EP80579 release package directory \
+        "-> setenv ICP_ROOT <path>")
+all fastdep:
+	:
+else
+
+ifndef KERNEL_SOURCE_ROOT
+$(error KERNEL_SOURCE_ROOT is undefined. Please set the path to the kernel source directory \
+        "-> setenv KERNEL_SOURCE_ROOT <path>")
+endif
+
 # Ensure The ENV_DIR environmental var is defined.
 ifndef ICP_ENV_DIR
-$(error ICP_ENV_DIR is undefined. Please set the path to your environment makefile \
+$(error ICP_ENV_DIR is undefined. Please set the path to EP80579 driver environment.mk file \
         "-> setenv ICP_ENV_DIR <path>")
 endif
 
 #Add your project environment Makefile
-include $(ICP_ENV_DIR)/environment.mk
+include ${ICP_ENV_DIR}/environment.mk
 
 #include the makefile with all the default and common Make variable definitions
-include $(ICP_BUILDSYSTEM_PATH)/build_files/common.mk
+include ${ICP_BUILDSYSTEM_PATH}/build_files/common.mk
 
 #Add the name for the executable, Library or Module output definitions
 OUTPUT_NAME= icp_ocf
 
 # List of Source Files to be compiled 
-SOURCES= icp_common.c icp_sym.c icp_asym.c
+SOURCES= icp_common.c icp_sym.c icp_asym.c icp_ocf_linux.c
 
 #common includes between all supported OSes
-INCLUDES= -I $(ICP_API_DIR) -I$(ICP_LAC_API) \
--I$(ICP_OCF_SRC_DIR)
+INCLUDES= -I ${ICP_API_DIR} -I${ICP_LAC_API} \
+-I${ICP_OCF_SRC_DIR}
 
 # The location of the os level makefile needs to be changed.
-include $(ICP_ENV_DIR)/$(ICP_OS)_$(ICP_OS_LEVEL).mk
+include ${ICP_ENV_DIR}/${ICP_OS}_${ICP_OS_LEVEL}.mk
 
 # On the line directly below list the outputs you wish to build for,
-# e.g "lib_static lib_shared exe module" as show below
+# e.g "lib_static lib_shared exe module" as shown below
 install: module
 
 ###################Include rules makefiles########################
-include $(ICP_BUILDSYSTEM_PATH)/build_files/rules.mk
+include ${ICP_BUILDSYSTEM_PATH}/build_files/rules.mk
 ###################End of Rules inclusion#########################
 
-
+endif
diff --git a/crypto/ocf/ep80579/environment.mk b/crypto/ocf/ep80579/environment.mk
index a674b45..1a663e5 100644
--- a/crypto/ocf/ep80579/environment.mk
+++ b/crypto/ocf/ep80579/environment.mk
@@ -66,6 +66,9 @@ ICP_LAC_API=$(ICP_ROOT)/Acceleration/include/lac
 ICP_BTR_API=$(ICP_ROOT)/Acceleration/include/btr
 ICP_API_DIR=$(ICP_ROOT)/Acceleration/include
 ICP_OCF_SHIM_DIR?=$(KERNEL_SOURCE_ROOT)/crypto/ocf/
+ifeq ($(wildcard $(ICP_OCF_SHIM_DIR)),)
+ICP_OCF_SHIM_DIR?=$(ROOTDIR)/modules/ocf/
+endif
 
 ICP_OS_LEVEL?=kernel_space
 
diff --git a/crypto/ocf/ep80579/icp_asym.c b/crypto/ocf/ep80579/icp_asym.c
index 1a9bd28..7093dd8 100644
--- a/crypto/ocf/ep80579/icp_asym.c
+++ b/crypto/ocf/ep80579/icp_asym.c
@@ -5,7 +5,7 @@
  * 
  *   GPL LICENSE SUMMARY
  * 
- *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  * 
  *   This program is free software; you can redistribute it and/or modify 
  *   it under the terms of version 2 of the GNU General Public License as
@@ -27,7 +27,7 @@
  * 
  *   BSD LICENSE 
  * 
- *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  *   All rights reserved.
  * 
  *   Redistribution and use in source and binary forms, with or without 
@@ -57,7 +57,7 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * 
  * 
- *  version: Security.L.1.0.130
+ *  version: Security.L.1.0.2-229
  *
  ***************************************************************************/
 
@@ -81,8 +81,6 @@ to be changed.*/
 #define ICP_MOD_EXP_KRP_PARAM_MODULUS_INDEX			(2)
 #define ICP_MOD_EXP_KRP_PARAM_RESULT_INDEX			(3)
 
-#define SINGLE_BYTE_VALUE					(4)
-
 /*MOD EXP CRT buffer index values*/
 #define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_P_INDEX			(0)
 #define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_Q_INDEX			(1)
@@ -121,39 +119,45 @@ to be changed.*/
    and not set to zero outside of this module */
 #define CRYPTO_OP_SUCCESS					(0)
 
+/*Function to compute Diffie Hellman (DH) phase 1 or phase 2 key values*/
 static int icp_ocfDrvDHComputeKey(struct cryptkop *krp);
 
+/*Function to compute a Modular Exponentiation (Mod Exp)*/
 static int icp_ocfDrvModExp(struct cryptkop *krp);
 
+/*Function to compute a Mod Exp using the Chinease Remainder Theorem*/
 static int icp_ocfDrvModExpCRT(struct cryptkop *krp);
 
+/*Helper function to compute whether the first big number argument is less than
+ the second big number argument */
 static int
 icp_ocfDrvCheckALessThanB(CpaFlatBuffer * pK, CpaFlatBuffer * pQ, int *doCheck);
 
+/*Function to sign an input with DSA R and S keys*/
 static int icp_ocfDrvDsaSign(struct cryptkop *krp);
 
+/*Function to Verify a DSA buffer signature*/
 static int icp_ocfDrvDsaVerify(struct cryptkop *krp);
 
+/*Callback function for DH operation*/
 static void
 icp_ocfDrvDhP1CallBack(void *callbackTag,
 		       CpaStatus status,
 		       void *pOpData, CpaFlatBuffer * pLocalOctetStringPV);
 
+/*Callback function for ME operation*/
 static void
 icp_ocfDrvModExpCallBack(void *callbackTag,
 			 CpaStatus status,
 			 void *pOpData, CpaFlatBuffer * pResult);
 
+/*Callback function for ME CRT operation*/
 static void
 icp_ocfDrvModExpCRTCallBack(void *callbackTag,
 			    CpaStatus status,
 			    void *pOpData, CpaFlatBuffer * pOutputData);
 
-static void
-icp_ocfDrvDsaVerifyCallBack(void *callbackTag,
-			    CpaStatus status,
-			    void *pOpData, CpaBoolean verifyStatus);
-
+/*Callback function for DSA sign operation*/
 static void
 icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 			    CpaStatus status,
@@ -161,12 +165,18 @@ icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 			    CpaBoolean protocolStatus,
 			    CpaFlatBuffer * pR, CpaFlatBuffer * pS);
 
+/*Callback function for DSA Verify operation*/
+static void
+icp_ocfDrvDsaVerifyCallBack(void *callbackTag,
+			    CpaStatus status,
+			    void *pOpData, CpaBoolean verifyStatus);
+
 /* Name        : icp_ocfDrvPkeProcess
  *
  * Description : This function will choose which PKE process to follow
  * based on the input arguments
  */
-int icp_ocfDrvPkeProcess(device_t dev, struct cryptkop *krp, int hint)
+int icp_ocfDrvPkeProcess(icp_device_t dev, struct cryptkop *krp, int hint)
 {
 	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
 
@@ -176,7 +186,7 @@ int icp_ocfDrvPkeProcess(device_t dev, struct cryptkop *krp, int hint)
 		return EINVAL;
 	}
 
-	if (CPA_TRUE == atomic_read(&icp_ocfDrvIsExiting)) {
+	if (CPA_TRUE == icp_atomic_read(&icp_ocfDrvIsExiting)) {
 		krp->krp_status = ECANCELED;
 		return ECANCELED;
 	}
@@ -258,8 +268,7 @@ int icp_ocfDrvPkeProcess(device_t dev, struct cryptkop *krp, int hint)
  * It has been seen that in general we are passed little endian byte order
  * buffers, but LAC only accepts big endian byte order buffers.
  */
-static void inline
-icp_ocfDrvSwapBytes(u_int8_t * num, u_int32_t buff_len_bytes)
+static void inline icp_ocfDrvSwapBytes(u_int8_t * num, u_int32_t buff_len_bytes)
 {
 
 	int i;
@@ -319,7 +328,9 @@ static int icp_ocfDrvDHComputeKey(struct cryptkop *krp)
 
 	callbackTag = krp;
 
-	pPhase1OpData = kmem_cache_zalloc(drvDH_zone, GFP_KERNEL);
+/*All allocations are set to ICP_M_NOWAIT due to the possibility of getting
+called in interrupt context*/
+	pPhase1OpData = icp_kmem_cache_zalloc(drvDH_zone, ICP_M_NOWAIT);
 	if (NULL == pPhase1OpData) {
 		APRINTK("%s():Failed to get memory for key gen data\n",
 			__FUNCTION__);
@@ -327,11 +338,12 @@ static int icp_ocfDrvDHComputeKey(struct cryptkop *krp)
 		return ENOMEM;
 	}
 
-	pLocalOctetStringPV = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
+	pLocalOctetStringPV =
+	    icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
 	if (NULL == pLocalOctetStringPV) {
 		APRINTK("%s():Failed to get memory for pLocalOctetStringPV\n",
 			__FUNCTION__);
-		kmem_cache_free(drvDH_zone, pPhase1OpData);
+		ICP_CACHE_FREE(drvDH_zone, pPhase1OpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -379,7 +391,7 @@ static int icp_ocfDrvDHComputeKey(struct cryptkop *krp)
 		EPRINTK("%s(): DH Phase 1 Key Gen failed (%d).\n",
 			__FUNCTION__, lacStatus);
 		icp_ocfDrvFreeFlatBuffer(pLocalOctetStringPV);
-		kmem_cache_free(drvDH_zone, pPhase1OpData);
+		ICP_CACHE_FREE(drvDH_zone, pPhase1OpData);
 	}
 
 	return lacStatus;
@@ -418,7 +430,7 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 
 	callbackTag = krp;
 
-	pModExpOpData = kmem_cache_zalloc(drvLnModExp_zone, GFP_KERNEL);
+	pModExpOpData = icp_kmem_cache_zalloc(drvLnModExp_zone, ICP_M_NOWAIT);
 	if (NULL == pModExpOpData) {
 		APRINTK("%s():Failed to get memory for key gen data\n",
 			__FUNCTION__);
@@ -426,11 +438,11 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 		return ENOMEM;
 	}
 
-	pResult = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
+	pResult = icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
 	if (NULL == pResult) {
 		APRINTK("%s():Failed to get memory for ModExp result\n",
 			__FUNCTION__);
-		kmem_cache_free(drvLnModExp_zone, pModExpOpData);
+		ICP_CACHE_FREE(drvLnModExp_zone, pModExpOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -445,26 +457,7 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 	icp_ocfDrvSwapBytes(pModExpOpData->modulus.pData,
 			    pModExpOpData->modulus.dataLenInBytes);
 
-	/*OCF patch to Openswan Pluto regularly sends the base value as 2
-	   bits in size. In this case, it has been found it is better to
-	   use the base size memory space as the input buffer (if the number
-	   is in bits is less than a byte, the number of bits is the input
-	   value) */
-	if (krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_nbits <
-	    NUM_BITS_IN_BYTE) {
-		DPRINTK("%s : base is small (%d)\n", __FUNCTION__, krp->
-			krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_nbits);
-		pModExpOpData->base.dataLenInBytes = SINGLE_BYTE_VALUE;
-		pModExpOpData->base.pData =
-		    (uint8_t *) & (krp->
-				   krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].
-				   crp_nbits);
-		*((uint32_t *) pModExpOpData->base.pData) =
-		    htonl(*((uint32_t *) pModExpOpData->base.pData));
-
-	} else {
-
-		DPRINTK("%s : base is big (%d)\n", __FUNCTION__, krp->
+	DPRINTK("%s : base (%d)\n", __FUNCTION__, krp->
 			krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_nbits);
 		pModExpOpData->base.pData =
 		    krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_p;
@@ -473,7 +466,6 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 			      crp_nbits);
 		icp_ocfDrvSwapBytes(pModExpOpData->base.pData,
 				    pModExpOpData->base.dataLenInBytes);
-	}
 
 	pModExpOpData->exponent.pData =
 	    krp->krp_param[ICP_MOD_EXP_KRP_PARAM_EXPONENT_INDEX].crp_p;
@@ -499,7 +491,7 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 			__FUNCTION__, lacStatus);
 		krp->krp_status = ECANCELED;
 		icp_ocfDrvFreeFlatBuffer(pResult);
-		kmem_cache_free(drvLnModExp_zone, pModExpOpData);
+		ICP_CACHE_FREE(drvLnModExp_zone, pModExpOpData);
 	}
 
 	return lacStatus;
@@ -515,7 +507,6 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
  * numbers. Although basic primality checks are done in LAC, it is up to the
  * user to do any correct prime number checking before passing the inputs.
  */
-
 static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 {
 	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
@@ -527,7 +518,8 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 	   them here. */
 	callbackTag = krp;
 
-	rsaDecryptOpData = kmem_cache_zalloc(drvRSADecrypt_zone, GFP_KERNEL);
+	rsaDecryptOpData =
+	    icp_kmem_cache_zalloc(drvRSADecrypt_zone, ICP_M_NOWAIT);
 	if (NULL == rsaDecryptOpData) {
 		APRINTK("%s():Failed to get memory"
 			" for MOD EXP CRT Op data struct\n", __FUNCTION__);
@@ -536,11 +528,11 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 	}
 
 	rsaDecryptOpData->pRecipientPrivateKey
-	    = kmem_cache_zalloc(drvRSAPrivateKey_zone, GFP_KERNEL);
+	    = icp_kmem_cache_zalloc(drvRSAPrivateKey_zone, ICP_M_NOWAIT);
 	if (NULL == rsaDecryptOpData->pRecipientPrivateKey) {
 		APRINTK("%s():Failed to get memory for MOD EXP CRT"
 			" private key values struct\n", __FUNCTION__);
-		kmem_cache_free(drvRSADecrypt_zone, rsaDecryptOpData);
+		ICP_CACHE_FREE(drvRSADecrypt_zone, rsaDecryptOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -550,13 +542,13 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 	rsaDecryptOpData->pRecipientPrivateKey->
 	    privateKeyRepType = CPA_CY_RSA_PRIVATE_KEY_REP_TYPE_2;
 
-	pOutputData = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
+	pOutputData = icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
 	if (NULL == pOutputData) {
 		APRINTK("%s():Failed to get memory"
 			" for MOD EXP CRT output data\n", __FUNCTION__);
-		kmem_cache_free(drvRSAPrivateKey_zone,
+		ICP_CACHE_FREE(drvRSAPrivateKey_zone,
 				rsaDecryptOpData->pRecipientPrivateKey);
-		kmem_cache_free(drvRSADecrypt_zone, rsaDecryptOpData);
+		ICP_CACHE_FREE(drvRSADecrypt_zone, rsaDecryptOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -658,9 +650,9 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 			__FUNCTION__, lacStatus);
 		krp->krp_status = ECANCELED;
 		icp_ocfDrvFreeFlatBuffer(pOutputData);
-		kmem_cache_free(drvRSAPrivateKey_zone,
+		ICP_CACHE_FREE(drvRSAPrivateKey_zone,
 				rsaDecryptOpData->pRecipientPrivateKey);
-		kmem_cache_free(drvRSADecrypt_zone, rsaDecryptOpData);
+		ICP_CACHE_FREE(drvRSADecrypt_zone, rsaDecryptOpData);
 	}
 
 	return lacStatus;
@@ -747,7 +739,8 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 		return EDOM;
 	}
 
-	dsaRsSignOpData = kmem_cache_zalloc(drvDSARSSign_zone, GFP_KERNEL);
+	dsaRsSignOpData =
+	    icp_kmem_cache_zalloc(drvDSARSSign_zone, ICP_M_NOWAIT);
 	if (NULL == dsaRsSignOpData) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA RS Sign Op data struct\n", __FUNCTION__);
@@ -756,35 +749,35 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 	}
 
 	dsaRsSignOpData->K.pData =
-	    kmem_cache_alloc(drvDSARSSignKValue_zone, GFP_ATOMIC);
+	    icp_kmem_cache_alloc(drvDSARSSignKValue_zone, ICP_M_NOWAIT);
 
 	if (NULL == dsaRsSignOpData->K.pData) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA RS Sign Op Random value\n", __FUNCTION__);
-		kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
+		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
 
-	pR = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
+	pR = icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
 	if (NULL == pR) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA signature R\n", __FUNCTION__);
-		kmem_cache_free(drvDSARSSignKValue_zone,
+		ICP_CACHE_FREE(drvDSARSSignKValue_zone,
 				dsaRsSignOpData->K.pData);
-		kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
+		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
 
-	pS = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
+	pS = icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
 	if (NULL == pS) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA signature S\n", __FUNCTION__);
 		icp_ocfDrvFreeFlatBuffer(pR);
-		kmem_cache_free(drvDSARSSignKValue_zone,
+		ICP_CACHE_FREE(drvDSARSSignKValue_zone,
 				dsaRsSignOpData->K.pData);
-		kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
+		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -830,9 +823,9 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 				"value\n", __FUNCTION__);
 			icp_ocfDrvFreeFlatBuffer(pS);
 			icp_ocfDrvFreeFlatBuffer(pR);
-			kmem_cache_free(drvDSARSSignKValue_zone,
+			ICP_CACHE_FREE(drvDSARSSignKValue_zone,
 					dsaRsSignOpData->K.pData);
-			kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
+			ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 			krp->krp_status = EAGAIN;
 			return EAGAIN;
 		}
@@ -843,9 +836,9 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 				"value less than Q value\n", __FUNCTION__);
 			icp_ocfDrvFreeFlatBuffer(pS);
 			icp_ocfDrvFreeFlatBuffer(pR);
-			kmem_cache_free(drvDSARSSignKValue_zone,
+			ICP_CACHE_FREE(drvDSARSSignKValue_zone,
 					dsaRsSignOpData->K.pData);
-			kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
+			ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 			krp->krp_status = EAGAIN;
 			return EAGAIN;
 		}
@@ -869,13 +862,13 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 	icp_ocfDrvSwapBytes(dsaRsSignOpData->X.pData,
 			    dsaRsSignOpData->X.dataLenInBytes);
 
+	/*OpenSSL dgst parameter is left in big endian byte order,
+	   therefore no byte swap is required */
 	dsaRsSignOpData->M.pData =
 	    krp->krp_param[ICP_DSA_SIGN_KRP_PARAM_DGST_INDEX].crp_p;
 	BITS_TO_BYTES(dsaRsSignOpData->M.dataLenInBytes,
 		      krp->krp_param[ICP_DSA_SIGN_KRP_PARAM_DGST_INDEX].
 		      crp_nbits);
-	icp_ocfDrvSwapBytes(dsaRsSignOpData->M.pData,
-			    dsaRsSignOpData->M.dataLenInBytes);
 
 	/* Output Parameters */
 	pS->pData = krp->krp_param[ICP_DSA_SIGN_KRP_PARAM_S_RESULT_INDEX].crp_p;
@@ -899,9 +892,9 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 		krp->krp_status = ECANCELED;
 		icp_ocfDrvFreeFlatBuffer(pS);
 		icp_ocfDrvFreeFlatBuffer(pR);
-		kmem_cache_free(drvDSARSSignKValue_zone,
+		ICP_CACHE_FREE(drvDSARSSignKValue_zone,
 				dsaRsSignOpData->K.pData);
-		kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
+		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 	}
 
 	return lacStatus;
@@ -921,7 +914,8 @@ static int icp_ocfDrvDsaVerify(struct cryptkop *krp)
 
 	callbackTag = krp;
 
-	dsaVerifyOpData = kmem_cache_zalloc(drvDSAVerify_zone, GFP_KERNEL);
+	dsaVerifyOpData =
+	    icp_kmem_cache_zalloc(drvDSAVerify_zone, ICP_M_NOWAIT);
 	if (NULL == dsaVerifyOpData) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA Verify Op data struct\n", __FUNCTION__);
@@ -962,13 +956,13 @@ static int icp_ocfDrvDsaVerify(struct cryptkop *krp)
 	icp_ocfDrvSwapBytes(dsaVerifyOpData->Y.pData,
 			    dsaVerifyOpData->Y.dataLenInBytes);
 
+	/*OpenSSL dgst parameter is left in big endian byte order,
+	   therefore no byte swap is required */
 	dsaVerifyOpData->M.pData =
 	    krp->krp_param[ICP_DSA_VERIFY_KRP_PARAM_DGST_INDEX].crp_p;
 	BITS_TO_BYTES(dsaVerifyOpData->M.dataLenInBytes,
 		      krp->krp_param[ICP_DSA_VERIFY_KRP_PARAM_DGST_INDEX].
 		      crp_nbits);
-	icp_ocfDrvSwapBytes(dsaVerifyOpData->M.pData,
-			    dsaVerifyOpData->M.dataLenInBytes);
 
 	dsaVerifyOpData->R.pData =
 	    krp->krp_param[ICP_DSA_VERIFY_KRP_PARAM_SIG_R_INDEX].crp_p;
@@ -993,48 +987,13 @@ static int icp_ocfDrvDsaVerify(struct cryptkop *krp)
 	if (CPA_STATUS_SUCCESS != lacStatus) {
 		EPRINTK("%s(): DSA Verify Operation failed (%d).\n",
 			__FUNCTION__, lacStatus);
-		kmem_cache_free(drvDSAVerify_zone, dsaVerifyOpData);
+		ICP_CACHE_FREE(drvDSAVerify_zone, dsaVerifyOpData);
 		krp->krp_status = ECANCELED;
 	}
 
 	return lacStatus;
 }
 
-/* Name        : icp_ocfDrvReadRandom
- *
- * Description : This function will map RNG functionality calls from OCF
- * to the LAC API.
- */
-int icp_ocfDrvReadRandom(void *arg, uint32_t * buf, int maxwords)
-{
-	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
-	CpaCyRandGenOpData randGenOpData;
-	CpaFlatBuffer randData;
-
-	if (NULL == buf) {
-		APRINTK("%s(): Invalid input parameters\n", __FUNCTION__);
-		return EINVAL;
-	}
-
-	/* maxwords here is number of integers to generate data for */
-	randGenOpData.generateBits = CPA_TRUE;
-
-	randGenOpData.lenInBytes = maxwords * sizeof(uint32_t);
-
-	icp_ocfDrvPtrAndLenToFlatBuffer((Cpa8U *) buf,
-					randGenOpData.lenInBytes, &randData);
-
-	lacStatus = cpaCyRandGen(CPA_INSTANCE_HANDLE_SINGLE,
-				 NULL, NULL, &randGenOpData, &randData);
-	if (CPA_STATUS_SUCCESS != lacStatus) {
-		EPRINTK("%s(): icp_LacSymRandGen failed (%d). \n",
-			__FUNCTION__, lacStatus);
-		return RETURN_RAND_NUM_GEN_FAILED;
-	}
-
-	return randGenOpData.lenInBytes / sizeof(uint32_t);
-}
-
 /* Name        : icp_ocfDrvDhP1Callback
  *
  * Description : When this function returns it signifies that the LAC
@@ -1068,7 +1027,7 @@ icp_ocfDrvDhP1CallBack(void *callbackTag,
 		DPRINTK("%s(): Invalid input parameters - "
 			"pLocalOctetStringPV Data is NULL\n", __FUNCTION__);
 		memset(pPhase1OpData, 0, sizeof(CpaCyDhPhase1KeyGenOpData));
-		kmem_cache_free(drvDH_zone, pPhase1OpData);
+		ICP_CACHE_FREE(drvDH_zone, pPhase1OpData);
 		krp->krp_status = ECANCELED;
 		crypto_kdone(krp);
 		return;
@@ -1087,7 +1046,7 @@ icp_ocfDrvDhP1CallBack(void *callbackTag,
 
 	icp_ocfDrvFreeFlatBuffer(pLocalOctetStringPV);
 	memset(pPhase1OpData, 0, sizeof(CpaCyDhPhase1KeyGenOpData));
-	kmem_cache_free(drvDH_zone, pPhase1OpData);
+	ICP_CACHE_FREE(drvDH_zone, pPhase1OpData);
 
 	crypto_kdone(krp);
 
@@ -1128,7 +1087,7 @@ icp_ocfDrvModExpCallBack(void *callbackTag,
 			"pResult data is NULL\n", __FUNCTION__);
 		krp->krp_status = ECANCELED;
 		memset(pLnModExpOpData, 0, sizeof(CpaCyLnModExpOpData));
-		kmem_cache_free(drvLnModExp_zone, pLnModExpOpData);
+		ICP_CACHE_FREE(drvLnModExp_zone, pLnModExpOpData);
 		crypto_kdone(krp);
 		return;
 	}
@@ -1153,7 +1112,7 @@ icp_ocfDrvModExpCallBack(void *callbackTag,
 	}
 	icp_ocfDrvFreeFlatBuffer(pResult);
 	memset(pLnModExpOpData, 0, sizeof(CpaCyLnModExpOpData));
-	kmem_cache_free(drvLnModExp_zone, pLnModExpOpData);
+	ICP_CACHE_FREE(drvLnModExp_zone, pLnModExpOpData);
 
 	crypto_kdone(krp);
 
@@ -1196,10 +1155,10 @@ icp_ocfDrvModExpCRTCallBack(void *callbackTag,
 			"pOutputData is NULL\n", __FUNCTION__);
 		memset(pDecryptData->pRecipientPrivateKey, 0,
 		       sizeof(CpaCyRsaPrivateKey));
-		kmem_cache_free(drvRSAPrivateKey_zone,
+		ICP_CACHE_FREE(drvRSAPrivateKey_zone,
 				pDecryptData->pRecipientPrivateKey);
 		memset(pDecryptData, 0, sizeof(CpaCyRsaDecryptOpData));
-		kmem_cache_free(drvRSADecrypt_zone, pDecryptData);
+		ICP_CACHE_FREE(drvRSADecrypt_zone, pDecryptData);
 		krp->krp_status = ECANCELED;
 		crypto_kdone(krp);
 		return;
@@ -1218,10 +1177,10 @@ icp_ocfDrvModExpCRTCallBack(void *callbackTag,
 	icp_ocfDrvFreeFlatBuffer(pOutputData);
 	memset(pDecryptData->pRecipientPrivateKey, 0,
 	       sizeof(CpaCyRsaPrivateKey));
-	kmem_cache_free(drvRSAPrivateKey_zone,
+	ICP_CACHE_FREE(drvRSAPrivateKey_zone,
 			pDecryptData->pRecipientPrivateKey);
 	memset(pDecryptData, 0, sizeof(CpaCyRsaDecryptOpData));
-	kmem_cache_free(drvRSADecrypt_zone, pDecryptData);
+	ICP_CACHE_FREE(drvRSADecrypt_zone, pDecryptData);
 
 	crypto_kdone(krp);
 
@@ -1264,7 +1223,7 @@ icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 		DPRINTK("%s(): Invalid input parameter - "
 			"pR sign is NULL\n", __FUNCTION__);
 		icp_ocfDrvFreeFlatBuffer(pS);
-		kmem_cache_free(drvDSARSSign_zone, pSignData);
+		ICP_CACHE_FREE(drvDSARSSign_zone, pSignData);
 		krp->krp_status = ECANCELED;
 		crypto_kdone(krp);
 		return;
@@ -1274,7 +1233,7 @@ icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 		DPRINTK("%s(): Invalid input parameter - "
 			"pS sign is NULL\n", __FUNCTION__);
 		icp_ocfDrvFreeFlatBuffer(pR);
-		kmem_cache_free(drvDSARSSign_zone, pSignData);
+		ICP_CACHE_FREE(drvDSARSSign_zone, pSignData);
 		krp->krp_status = ECANCELED;
 		crypto_kdone(krp);
 		return;
@@ -1304,9 +1263,9 @@ icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 	icp_ocfDrvFreeFlatBuffer(pR);
 	icp_ocfDrvFreeFlatBuffer(pS);
 	memset(pSignData->K.pData, 0, pSignData->K.dataLenInBytes);
-	kmem_cache_free(drvDSARSSignKValue_zone, pSignData->K.pData);
+	ICP_CACHE_FREE(drvDSARSSignKValue_zone, pSignData->K.pData);
 	memset(pSignData, 0, sizeof(CpaCyDsaRSSignOpData));
-	kmem_cache_free(drvDSARSSign_zone, pSignData);
+	ICP_CACHE_FREE(drvDSARSSign_zone, pSignData);
 	crypto_kdone(krp);
 
 	return;
@@ -1368,7 +1327,7 @@ icp_ocfDrvDsaVerifyCallBack(void *callbackTag,
 	}
 
 	memset(pVerData, 0, sizeof(CpaCyDsaVerifyOpData));
-	kmem_cache_free(drvDSAVerify_zone, pVerData);
+	ICP_CACHE_FREE(drvDSAVerify_zone, pVerData);
 	crypto_kdone(krp);
 
 	return;
diff --git a/crypto/ocf/ep80579/icp_common.c b/crypto/ocf/ep80579/icp_common.c
index 461370c..9431a72d 100644
--- a/crypto/ocf/ep80579/icp_common.c
+++ b/crypto/ocf/ep80579/icp_common.c
@@ -1,11 +1,11 @@
-/***************************************************************************
+/*************************************************************************
  *
  * This file is provided under a dual BSD/GPLv2 license.  When using or 
  *   redistributing this file, you may do so under either license.
  * 
  *   GPL LICENSE SUMMARY
  * 
- *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  * 
  *   This program is free software; you can redistribute it and/or modify 
  *   it under the terms of version 2 of the GNU General Public License as
@@ -27,7 +27,7 @@
  * 
  *   BSD LICENSE 
  * 
- *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  *   All rights reserved.
  * 
  *   Redistribution and use in source and binary forms, with or without 
@@ -57,7 +57,7 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * 
  * 
- *  version: Security.L.1.0.130
+ *  version: Security.L.1.0.2-229
  *
  ***************************************************************************/
 
@@ -73,7 +73,7 @@
 
 #define ICP_OCF_COMP_NAME 			"ICP_OCF"
 #define ICP_OCF_VER_MAIN			(2)
-#define ICP_OCF_VER_MJR				(0)
+#define ICP_OCF_VER_MJR                         (1)
 #define ICP_OCF_VER_MNR 			(0)
 
 #define MAX_DEREG_RETRIES 			(100)
@@ -81,28 +81,47 @@
 #define DEFAULT_DEREG_DELAY_IN_JIFFIES		(10)
 
 /* This defines the maximum number of sessions possible between OCF
-   and the OCF Tolapai Driver. If set to zero, there is no limit. */
+   and the OCF EP80579 Driver. If set to zero, there is no limit. */
 #define DEFAULT_OCF_TO_DRV_MAX_SESSION_COUNT	(0)
 #define NUM_SUPPORTED_CAPABILITIES		(21)
 
+/*Slab zone names*/
+#define ICP_SESSION_DATA_NAME   "icp_ocf.SesDat"
+#define ICP_OP_DATA_NAME        "icp_ocf.OpDat"
+#define ICP_DH_NAME             "icp_ocf.DH"
+#define ICP_MODEXP_NAME         "icp_ocf.ModExp"
+#define ICP_RSA_DECRYPT_NAME    "icp_ocf.RSAdec"
+#define ICP_RSA_PKEY_NAME       "icp_ocf.RSApk"
+#define ICP_DSA_SIGN_NAME       "icp_ocf.DSAsg"
+#define ICP_DSA_VER_NAME        "icp_ocf.DSAver"
+#define ICP_RAND_VAL_NAME       "icp_ocf.DSArnd"
+#define ICP_FLAT_BUFF_NAME      "icp_ocf.FB"
+
 /*Slabs zones*/
-struct kmem_cache *drvSessionData_zone = NULL;
-struct kmem_cache *drvOpData_zone = NULL;
-struct kmem_cache *drvDH_zone = NULL;
-struct kmem_cache *drvLnModExp_zone = NULL;
-struct kmem_cache *drvRSADecrypt_zone = NULL;
-struct kmem_cache *drvRSAPrivateKey_zone = NULL;
-struct kmem_cache *drvDSARSSign_zone = NULL;
-struct kmem_cache *drvDSARSSignKValue_zone = NULL;
-struct kmem_cache *drvDSAVerify_zone = NULL;
+icp_kmem_cache drvSessionData_zone = NULL;
+icp_kmem_cache drvOpData_zone = NULL;
+icp_kmem_cache drvDH_zone = NULL;
+icp_kmem_cache drvLnModExp_zone = NULL;
+icp_kmem_cache drvRSADecrypt_zone = NULL;
+icp_kmem_cache drvRSAPrivateKey_zone = NULL;
+icp_kmem_cache drvDSARSSign_zone = NULL;
+icp_kmem_cache drvDSARSSignKValue_zone = NULL;
+icp_kmem_cache drvDSAVerify_zone = NULL;
 
 /*Slab zones for flatbuffers and bufferlist*/
-struct kmem_cache *drvFlatBuffer_zone = NULL;
+icp_kmem_cache drvFlatBuffer_zone = NULL;
+
+static inline int icp_cache_null_check(void)
+{
+	return (drvSessionData_zone && drvOpData_zone
+		&& drvDH_zone && drvLnModExp_zone && drvRSADecrypt_zone
+		&& drvRSAPrivateKey_zone && drvDSARSSign_zone
+		&& drvDSARSSign_zone && drvDSARSSignKValue_zone
+		&& drvDSAVerify_zone && drvFlatBuffer_zone);
+}
 
-static int icp_ocfDrvInit(void);
-static void icp_ocfDrvExit(void);
+/*Function to free all allocated slab caches before exiting the module*/
 static void icp_ocfDrvFreeCaches(void);
-static void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg);
 
 int32_t icp_ocfDrvDriverId = INVALID_DRIVER_ID;
 
@@ -115,66 +134,42 @@ int num_dereg_retries = DEFAULT_DEREG_RETRIES;
 int dereg_retry_delay_in_jiffies = DEFAULT_DEREG_DELAY_IN_JIFFIES;
 
 /* Module parameter - gives the maximum number of sessions possible between
-   OCF and the OCF Tolapai Driver. If set to zero, there is no limit.*/
+   OCF and the OCF EP80579 Driver. If set to zero, there is no limit.*/
 int max_sessions = DEFAULT_OCF_TO_DRV_MAX_SESSION_COUNT;
 
 /* This is set when the module is removed from the system, no further
    processing can take place if this is set */
-atomic_t icp_ocfDrvIsExiting = ATOMIC_INIT(0);
+icp_atomic_t icp_ocfDrvIsExiting = ICP_ATOMIC_INIT(0);
 
 /* This is used to show how many lac sessions were not deregistered*/
-atomic_t lac_session_failed_dereg_count = ATOMIC_INIT(0);
+icp_atomic_t lac_session_failed_dereg_count = ICP_ATOMIC_INIT(0);
 
 /* This is used to track the number of registered sessions between OCF and
- * and the OCF Tolapai driver, when max_session is set to value other than
+ * and the OCF EP80579 driver, when max_session is set to value other than
  * zero. This ensures that the max_session set for the OCF and the driver
  * is equal to the LAC registered sessions */
-atomic_t num_ocf_to_drv_registered_sessions = ATOMIC_INIT(0);
+icp_atomic_t num_ocf_to_drv_registered_sessions = ICP_ATOMIC_INIT(0);
 
 /* Head of linked list used to store session data */
-struct list_head icp_ocfDrvGlobalSymListHead;
-struct list_head icp_ocfDrvGlobalSymListHead_FreeMemList;
+icp_drvSessionListHead_t icp_ocfDrvGlobalSymListHead;
+icp_drvSessionListHead_t icp_ocfDrvGlobalSymListHead_FreeMemList;
 
-spinlock_t icp_ocfDrvSymSessInfoListSpinlock = SPIN_LOCK_UNLOCKED;
-rwlock_t icp_kmem_cache_destroy_alloc_lock = RW_LOCK_UNLOCKED;
+icp_spinlock_t icp_ocfDrvSymSessInfoListSpinlock;
 
-struct workqueue_struct *icp_ocfDrvFreeLacSessionWorkQ;
+/*Below pointer is only used in linux, FreeBSD uses the name to
+create its own variable name*/
+icp_workqueue *icp_ocfDrvFreeLacSessionWorkQ = NULL;
+ICP_WORKQUEUE_DEFINE_THREAD(icp_ocfDrvFreeLacSessionWorkQ);
 
 struct icp_drvBuffListInfo defBuffListInfo;
 
-static struct {
-	softc_device_decl sc_dev;
-} icpDev;
-
-static device_method_t icp_methods = {
-	/* crypto device methods */
-	DEVMETHOD(cryptodev_newsession, icp_ocfDrvNewSession),
-	DEVMETHOD(cryptodev_freesession, icp_ocfDrvFreeLACSession),
-	DEVMETHOD(cryptodev_process, icp_ocfDrvSymProcess),
-	DEVMETHOD(cryptodev_kprocess, icp_ocfDrvPkeProcess),
-};
-
-module_param(num_dereg_retries, int, S_IRUGO);
-module_param(dereg_retry_delay_in_jiffies, int, S_IRUGO);
-module_param(max_sessions, int, S_IRUGO);
-
-MODULE_PARM_DESC(num_dereg_retries,
-		 "Number of times to retry LAC Sym Session Deregistration. "
-		 "Default 10, Max 100");
-MODULE_PARM_DESC(dereg_retry_delay_in_jiffies, "Delay in jiffies "
-		 "(added to a schedule() function call) before a LAC Sym "
-		 "Session Dereg is retried. Default 10");
-MODULE_PARM_DESC(max_sessions, "This sets the maximum number of sessions "
-		 "between OCF and this driver. If this value is set to zero, "
-		 "max session count checking is disabled. Default is zero(0)");
-
 /* Name        : icp_ocfDrvInit
  *
  * Description : This function will register all the symmetric and asymmetric
  * functionality that will be accelerated by the hardware. It will also
  * get a unique driver ID from the OCF and initialise all slab caches
  */
-static int __init icp_ocfDrvInit(void)
+ICP_MODULE_INIT_FUNC(icp_ocfDrvInit)
 {
 	int ocfStatus = 0;
 
@@ -184,7 +179,7 @@ static int __init icp_ocfDrvInit(void)
 	if (MAX_DEREG_RETRIES < num_dereg_retries) {
 		EPRINTK("Session deregistration retry count set to greater "
 			"than %d", MAX_DEREG_RETRIES);
-		return -1;
+		icp_module_return_code(EINVAL);
 	}
 
 	/* Initialize and Start the Cryptographic component */
@@ -192,130 +187,133 @@ static int __init icp_ocfDrvInit(void)
 	    cpaCyStartInstance(CPA_INSTANCE_HANDLE_SINGLE)) {
 		EPRINTK("Failed to initialize and start the instance "
 			"of the Cryptographic component.\n");
-		return -1;
+		return icp_module_return_code(EINVAL);
 	}
 
+	icp_spin_lock_init(&icp_ocfDrvSymSessInfoListSpinlock);
+
 	/* Set the default size of BufferList to allocate */
 	memset(&defBuffListInfo, 0, sizeof(struct icp_drvBuffListInfo));
 	if (ICP_OCF_DRV_STATUS_SUCCESS !=
 	    icp_ocfDrvBufferListMemInfo(ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS,
 					&defBuffListInfo)) {
 		EPRINTK("Failed to get bufferlist memory info.\n");
-		return -1;
+		return icp_module_return_code(ENOMEM);
 	}
 
-	/*Register OCF Tolapai Driver with OCF */
-	memset(&icpDev, 0, sizeof(icpDev));
-	softc_device_init(&icpDev, "icp", 0, icp_methods);
-
-	icp_ocfDrvDriverId = crypto_get_driverid(softc_get_device(&icpDev),
-						 CRYPTOCAP_F_HARDWARE);
+	/*Register OCF EP80579 Driver with OCF */
+	icp_ocfDrvDriverId = ICP_CRYPTO_GET_DRIVERID();
 
 	if (icp_ocfDrvDriverId < 0) {
 		EPRINTK("%s : ICP driver failed to register with OCF!\n",
 			__FUNCTION__);
-		return -ENODEV;
+		return icp_module_return_code(ENODEV);
 	}
 
-	/*Create all the slab caches used by the OCF Tolapai Driver */
+	/*Create all the slab caches used by the OCF EP80579 Driver */
 	drvSessionData_zone =
-	    ICP_CACHE_CREATE("ICP Session Data", struct icp_drvSessionData);
-	ICP_CACHE_NULL_CHECK(drvSessionData_zone);
+	    ICP_CACHE_CREATE(ICP_SESSION_DATA_NAME, struct icp_drvSessionData);
 
 	/* 
 	 * Allocation of the OpData includes the allocation space for meta data.
 	 * The memory after the opData structure is reserved for this meta data.
 	 */
 	drvOpData_zone =
-	    kmem_cache_create("ICP Op Data", sizeof(struct icp_drvOpData) +
-	            defBuffListInfo.metaSize ,0, SLAB_HWCACHE_ALIGN, NULL, NULL);
-
-
-	ICP_CACHE_NULL_CHECK(drvOpData_zone);
+	    icp_kmem_cache_create(ICP_OP_DATA_NAME,
+				  sizeof(struct icp_drvOpData) +
+				  defBuffListInfo.metaSize,
+				  ICP_KERNEL_CACHE_ALIGN,
+				  ICP_KERNEL_CACHE_NOINIT);
 
-	drvDH_zone = ICP_CACHE_CREATE("ICP DH data", CpaCyDhPhase1KeyGenOpData);
-	ICP_CACHE_NULL_CHECK(drvDH_zone);
+	drvDH_zone = ICP_CACHE_CREATE(ICP_DH_NAME, CpaCyDhPhase1KeyGenOpData);
 
 	drvLnModExp_zone =
-	    ICP_CACHE_CREATE("ICP ModExp data", CpaCyLnModExpOpData);
-	ICP_CACHE_NULL_CHECK(drvLnModExp_zone);
+	    ICP_CACHE_CREATE(ICP_MODEXP_NAME, CpaCyLnModExpOpData);
 
 	drvRSADecrypt_zone =
-	    ICP_CACHE_CREATE("ICP RSA decrypt data", CpaCyRsaDecryptOpData);
-	ICP_CACHE_NULL_CHECK(drvRSADecrypt_zone);
+	    ICP_CACHE_CREATE(ICP_RSA_DECRYPT_NAME, CpaCyRsaDecryptOpData);
 
 	drvRSAPrivateKey_zone =
-	    ICP_CACHE_CREATE("ICP RSA private key data", CpaCyRsaPrivateKey);
-	ICP_CACHE_NULL_CHECK(drvRSAPrivateKey_zone);
+	    ICP_CACHE_CREATE(ICP_RSA_PKEY_NAME, CpaCyRsaPrivateKey);
 
 	drvDSARSSign_zone =
-	    ICP_CACHE_CREATE("ICP DSA Sign", CpaCyDsaRSSignOpData);
-	ICP_CACHE_NULL_CHECK(drvDSARSSign_zone);
+	    ICP_CACHE_CREATE(ICP_DSA_SIGN_NAME, CpaCyDsaRSSignOpData);
 
 	/*too awkward to use a macro here */
 	drvDSARSSignKValue_zone =
-	    kmem_cache_create("ICP DSA Sign Rand Val",
-			      DSA_RS_SIGN_PRIMEQ_SIZE_IN_BYTES, 0,
-			      SLAB_HWCACHE_ALIGN, NULL, NULL);
-	ICP_CACHE_NULL_CHECK(drvDSARSSignKValue_zone);
+	    ICP_CACHE_CREATE(ICP_RAND_VAL_NAME,
+			     DSA_RS_SIGN_PRIMEQ_SIZE_IN_BYTES);
 
 	drvDSAVerify_zone =
-	    ICP_CACHE_CREATE("ICP DSA Verify", CpaCyDsaVerifyOpData);
-	ICP_CACHE_NULL_CHECK(drvDSAVerify_zone);
+	    ICP_CACHE_CREATE(ICP_DSA_VER_NAME, CpaCyDsaVerifyOpData);
 
 	drvFlatBuffer_zone =
-	    ICP_CACHE_CREATE("ICP Flat Buffers", CpaFlatBuffer);
-	ICP_CACHE_NULL_CHECK(drvFlatBuffer_zone);
+	    ICP_CACHE_CREATE(ICP_FLAT_BUFF_NAME, CpaFlatBuffer);
+
+	if (0 == icp_cache_null_check()) {
+		icp_ocfDrvFreeCaches();
+		EPRINTK("%s() line %d: Not enough memory!\n",
+			__FUNCTION__, __LINE__);
+		return ENOMEM;
+	}
 
 	/* Register the ICP symmetric crypto support. */
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_NULL_CBC);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_DES_CBC);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_3DES_CBC);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_AES_CBC);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_ARC4);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_MD5);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_MD5_HMAC);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA1);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA1_HMAC);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_256);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_256_HMAC);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_384);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_384_HMAC);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_512);
-	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_512_HMAC);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_NULL_CBC, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_DES_CBC, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_3DES_CBC, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_AES_CBC, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_ARC4, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_MD5, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_MD5_HMAC, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA1, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA1_HMAC, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_256, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_256_HMAC,
+			     ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_384, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_384_HMAC,
+			     ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_512, ocfStatus);
+	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_512_HMAC,
+			     ocfStatus);
 
 	/* Register the ICP asymmetric algorithm support */
-	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_DH_COMPUTE_KEY);
-	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_MOD_EXP);
-	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_MOD_EXP_CRT);
-	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_DSA_SIGN);
-	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_DSA_VERIFY);
+	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_DH_COMPUTE_KEY,
+			      ocfStatus);
+	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_MOD_EXP, ocfStatus);
+	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_MOD_EXP_CRT, ocfStatus);
+	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_DSA_SIGN, ocfStatus);
+	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_DSA_VERIFY, ocfStatus);
 
 	/* Register the ICP random number generator support */
-	if (OCF_REGISTRATION_STATUS_SUCCESS ==
-	    crypto_rregister(icp_ocfDrvDriverId, icp_ocfDrvReadRandom, NULL)) {
-		ocfStatus++;
-	}
+	ICP_REG_RAND_WITH_OCF(icp_ocfDrvDriverId,
+			      icp_ocfDrvReadRandom, NULL, ocfStatus);
 
 	if (OCF_ZERO_FUNCTIONALITY_REGISTERED == ocfStatus) {
 		DPRINTK("%s: Failed to register any device capabilities\n",
 			__FUNCTION__);
 		icp_ocfDrvFreeCaches();
 		icp_ocfDrvDriverId = INVALID_DRIVER_ID;
-		return -ECANCELED;
+		return icp_module_return_code(ECANCELED);
 	}
 
 	DPRINTK("%s: Registered %d of %d device capabilities\n",
 		__FUNCTION__, ocfStatus, NUM_SUPPORTED_CAPABILITIES);
 
 /*Session data linked list used during module exit*/
-	INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead);
-	INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead_FreeMemList);
+	ICP_INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead);
+	ICP_INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead_FreeMemList);
 
-	icp_ocfDrvFreeLacSessionWorkQ =
-	    create_singlethread_workqueue("ocfLacDeregWorkQueue");
+	ICP_WORKQUEUE_CREATE(icp_ocfDrvFreeLacSessionWorkQ, "icpwq");
+	if (ICP_WORKQUEUE_NULL_CHECK(icp_ocfDrvFreeLacSessionWorkQ)) {
+		EPRINTK("%s: Failed to create single "
+			"thread workqueue\n", __FUNCTION__);
+		icp_ocfDrvFreeCaches();
+		icp_ocfDrvDriverId = INVALID_DRIVER_ID;
+		return icp_module_return_code(ENOMEM);
+	}
 
-	return 0;
+	return icp_module_return_code(0);
 }
 
 /* Name        : icp_ocfDrvExit
@@ -325,30 +323,45 @@ static int __init icp_ocfDrvInit(void)
  * and asymmetric functionality that can be accelerated by the hardware via OCF
  * and random number generation if it is enabled.
  */
-static void icp_ocfDrvExit(void)
+ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
 {
 	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
 	struct icp_drvSessionData *sessionData = NULL;
 	struct icp_drvSessionData *tempSessionData = NULL;
 	int i, remaining_delay_time_in_jiffies = 0;
+
+	/* For FreeBSD the invariant macro below makes function to return     */
+	/* with EBUSY value in the case of any session which has been regi-   */
+	/* stered with LAC not being deregistered.                            */
+	/* The Linux implementation is empty since it is purely to compensate */
+	/* for a limitation of the FreeBSD 7.1 Opencrypto framework.          */
+
+    ICP_MODULE_EXIT_INV();
+
 	/* There is a possibility of a process or new session command being   */
 	/* sent before this variable is incremented. The aim of this variable */
 	/* is to stop a loop of calls creating a deadlock situation which     */
 	/* would prevent the driver from exiting.                             */
-
-	atomic_inc(&icp_ocfDrvIsExiting);
+	icp_atomic_set(&icp_ocfDrvIsExiting, 1);
 
 	/*Existing sessions will be routed to another driver after these calls */
 	crypto_unregister_all(icp_ocfDrvDriverId);
 	crypto_runregister_all(icp_ocfDrvDriverId);
 
+	if (ICP_WORKQUEUE_NULL_CHECK(icp_ocfDrvFreeLacSessionWorkQ)) {
+		DPRINTK("%s: workqueue already "
+			"destroyed, therefore module exit "
+			" function already called. Exiting.\n", __FUNCTION__);
+		return ICP_MODULE_EXIT_FUNC_RETURN_VAL;
+	}
 	/*If any sessions are waiting to be deregistered, do that. This also 
 	   flushes the work queue */
-	destroy_workqueue(icp_ocfDrvFreeLacSessionWorkQ);
+	ICP_WORKQUEUE_DESTROY(icp_ocfDrvFreeLacSessionWorkQ);
 
 	/*ENTER CRITICAL SECTION */
-	spin_lock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
-	list_for_each_entry_safe(tempSessionData, sessionData,
+	icp_spin_lockbh_lock(&icp_ocfDrvSymSessInfoListSpinlock);
+
+	ICP_LIST_FOR_EACH_ENTRY_SAFE(tempSessionData, sessionData,
 				 &icp_ocfDrvGlobalSymListHead, listNode) {
 		for (i = 0; i < num_dereg_retries; i++) {
 			/*No harm if bad input - LAC will handle error cases */
@@ -361,7 +374,7 @@ static void icp_ocfDrvExit(void)
 					/* Succesfully deregistered */
 					break;
 				} else if (CPA_STATUS_RETRY != lacStatus) {
-					atomic_inc
+					icp_atomic_inc
 					    (&lac_session_failed_dereg_count);
 					break;
 				}
@@ -372,8 +385,9 @@ static void icp_ocfDrvExit(void)
 				    dereg_retry_delay_in_jiffies;
 				while (0 > remaining_delay_time_in_jiffies) {
 					remaining_delay_time_in_jiffies =
-					    schedule_timeout
-					    (remaining_delay_time_in_jiffies);
+					    icp_schedule_timeout
+					    (&icp_ocfDrvSymSessInfoListSpinlock,
+					     remaining_delay_time_in_jiffies);
 				}
 
 				DPRINTK
@@ -383,44 +397,48 @@ static void icp_ocfDrvExit(void)
 		}
 
 		/*remove from current list */
-		list_del(&(tempSessionData->listNode));
+		ICP_LIST_DEL(tempSessionData, listNode);
 		/*add to free mem linked list */
-		list_add(&(tempSessionData->listNode),
-			 &icp_ocfDrvGlobalSymListHead_FreeMemList);
+		ICP_LIST_ADD(tempSessionData,
+			     &icp_ocfDrvGlobalSymListHead_FreeMemList,
+			     listNode);
 
 	}
 
 	/*EXIT CRITICAL SECTION */
-	spin_unlock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
+	icp_spin_lockbh_unlock(&icp_ocfDrvSymSessInfoListSpinlock);
 
 	/*set back to initial values */
 	sessionData = NULL;
 	/*still have a reference in our list! */
 	tempSessionData = NULL;
 	/*free memory */
-	list_for_each_entry_safe(tempSessionData, sessionData,
+
+	ICP_LIST_FOR_EACH_ENTRY_SAFE(tempSessionData, sessionData,
 				 &icp_ocfDrvGlobalSymListHead_FreeMemList,
 				 listNode) {
 
-		list_del(&(tempSessionData->listNode));
+		ICP_LIST_DEL(tempSessionData, listNode);
 		/* Free allocated CpaCySymSessionCtx */
 		if (NULL != tempSessionData->sessHandle) {
-			kfree(tempSessionData->sessHandle);
+			icp_kfree(tempSessionData->sessHandle);
 		}
 		memset(tempSessionData, 0, sizeof(struct icp_drvSessionData));
-		kmem_cache_free(drvSessionData_zone, tempSessionData);
+		ICP_CACHE_FREE(drvSessionData_zone, tempSessionData);
 	}
 
-	if (0 != atomic_read(&lac_session_failed_dereg_count)) {
+	if (0 != icp_atomic_read(&lac_session_failed_dereg_count)) {
 		DPRINTK("%s(): %d LAC sessions were not deregistered "
 			"correctly. This is not a clean exit! \n",
 			__FUNCTION__,
-			atomic_read(&lac_session_failed_dereg_count));
+			icp_atomic_read(&lac_session_failed_dereg_count));
 	}
 
 	icp_ocfDrvFreeCaches();
 	icp_ocfDrvDriverId = INVALID_DRIVER_ID;
 
+	icp_spin_lock_destroy(&icp_ocfDrvSymSessInfoListSpinlock);
+
 	/* Shutdown the Cryptographic component */
 	lacStatus = cpaCyStopInstance(CPA_INSTANCE_HANDLE_SINGLE);
 	if (CPA_STATUS_SUCCESS != lacStatus) {
@@ -429,6 +447,7 @@ static void icp_ocfDrvExit(void)
 			__FUNCTION__, lacStatus);
 	}
 
+	return ICP_MODULE_EXIT_FUNC_RETURN_VAL;
 }
 
 /* Name        : icp_ocfDrvFreeCaches
@@ -437,9 +456,7 @@ static void icp_ocfDrvExit(void)
  */
 static void icp_ocfDrvFreeCaches(void)
 {
-	if (atomic_read(&icp_ocfDrvIsExiting) != CPA_TRUE) {
-		atomic_set(&icp_ocfDrvIsExiting, 1);
-	}
+	icp_atomic_set(&icp_ocfDrvIsExiting, 1);
 
 	/*Sym Zones */
 	ICP_CACHE_DESTROY(drvSessionData_zone);
@@ -465,7 +482,6 @@ static void icp_ocfDrvFreeCaches(void)
  * off to a work queue. If it fails, nothing more can be done and it
  * returns an error
  */
-
 int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister)
 {
 	struct icp_ocfDrvFreeLacSession *workstore = NULL;
@@ -475,11 +491,11 @@ int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister)
 
 	/*make sure the session is not available to be allocated during this
 	   process */
-	atomic_inc(&lac_session_failed_dereg_count);
+	icp_atomic_inc(&lac_session_failed_dereg_count);
 
 	/*Farm off to work queue */
 	workstore =
-	    kmalloc(sizeof(struct icp_ocfDrvFreeLacSession), GFP_ATOMIC);
+	    icp_kmalloc(sizeof(struct icp_ocfDrvFreeLacSession), ICP_M_NOWAIT);
 	if (NULL == workstore) {
 		DPRINTK("%s(): unable to free session - no memory available "
 			"for work queue\n", __FUNCTION__);
@@ -488,9 +504,11 @@ int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister)
 
 	workstore->sessionToDeregister = sessionToDeregister;
 
-	INIT_WORK(&(workstore->work), icp_ocfDrvDeferedFreeLacSessionProcess,
-		  workstore);
-	queue_work(icp_ocfDrvFreeLacSessionWorkQ, &(workstore->work));
+	icp_init_work(&(workstore->work),
+		      icp_ocfDrvDeferedFreeLacSessionTaskFn, workstore);
+
+	ICP_WORKQUEUE_ENQUEUE(icp_ocfDrvFreeLacSessionWorkQ,
+			      &(workstore->work));
 
 	return ICP_OCF_DRV_STATUS_SUCCESS;
 
@@ -503,7 +521,7 @@ int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister)
  * CPA_STATUS_RETRY message from the LAC component. This function is run in
  * Thread context because it is called from a worker thread
  */
-static void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
+void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 {
 	struct icp_ocfDrvFreeLacSession *workstore = NULL;
 	CpaCySymSessionCtx sessionToDeregister = NULL;
@@ -519,10 +537,10 @@ static void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 	}
 
 	sessionToDeregister = workstore->sessionToDeregister;
-	kfree(workstore);
+	icp_kfree(workstore);
 
 	/*if exiting, give deregistration one more blast only */
-	if (atomic_read(&icp_ocfDrvIsExiting) == CPA_TRUE) {
+	if (icp_atomic_read(&icp_ocfDrvIsExiting) == CPA_TRUE) {
 		lacStatus = cpaCySymRemoveSession(CPA_INSTANCE_HANDLE_SINGLE,
 						  sessionToDeregister);
 
@@ -533,7 +551,7 @@ static void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 			return;
 		}
 
-		atomic_dec(&lac_session_failed_dereg_count);
+		icp_atomic_dec(&lac_session_failed_dereg_count);
 		return;
 	}
 
@@ -542,7 +560,7 @@ static void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 						  sessionToDeregister);
 
 		if (lacStatus == CPA_STATUS_SUCCESS) {
-			atomic_dec(&lac_session_failed_dereg_count);
+			icp_atomic_dec(&lac_session_failed_dereg_count);
 			return;
 		}
 		if (lacStatus != CPA_STATUS_RETRY) {
@@ -554,16 +572,17 @@ static void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 		/*schedule_timout returns the time left for completion if this
 		   task is set to TASK_INTERRUPTIBLE */
 		remaining_delay_time_in_jiffies = dereg_retry_delay_in_jiffies;
-		while (0 > remaining_delay_time_in_jiffies) {
+		while (0 < remaining_delay_time_in_jiffies) {
 			remaining_delay_time_in_jiffies =
-			    schedule_timeout(remaining_delay_time_in_jiffies);
+			    icp_schedule_timeout(NULL,
+						 remaining_delay_time_in_jiffies);
 		}
 
 	}
 
 	DPRINTK("%s(): Unable to deregister session\n", __FUNCTION__);
 	DPRINTK("%s(): Number of unavailable LAC sessions = %d\n", __FUNCTION__,
-		atomic_read(&lac_session_failed_dereg_count));
+		icp_atomic_read(&lac_session_failed_dereg_count));
 }
 
 /* Name        : icp_ocfDrvPtrAndLenToFlatBuffer 
@@ -581,131 +600,6 @@ icp_ocfDrvPtrAndLenToFlatBuffer(void *pData, uint32_t len,
 	pFlatBuffer->dataLenInBytes = len;
 }
 
-/* Name        : icp_ocfDrvSingleSkBuffToFlatBuffer 
- *
- * Description : This function converts a single socket buffer (sk_buff)
- * structure to a Fredericksburg Flat Buffer (CpaFlatBuffer) format.
- *
- * This function assumes that the data passed in are valid.
- */
-static inline void
-icp_ocfDrvSingleSkBuffToFlatBuffer(struct sk_buff *pSkb,
-				   CpaFlatBuffer * pFlatBuffer)
-{
-	pFlatBuffer->pData = pSkb->data;
-	pFlatBuffer->dataLenInBytes = skb_headlen(pSkb);
-}
-
-/* Name        : icp_ocfDrvSkBuffToBufferList 
- *
- * Description : This function converts a socket buffer (sk_buff) structure to
- * Fredericksburg Scatter/Gather (CpaBufferList) buffer format.
- *
- * This function assumes that the bufferlist has been allocated with the correct
- * number of buffer arrays.
- * 
- */
-inline int
-icp_ocfDrvSkBuffToBufferList(struct sk_buff *pSkb, CpaBufferList * bufferList)
-{
-	CpaFlatBuffer *curFlatBuffer = NULL;
-	char *skbuffPageAddr = NULL;
-	struct sk_buff *pCurFrag = NULL;
-	struct skb_shared_info *pShInfo = NULL;
-	uint32_t page_offset = 0, i = 0;
-
-	DPRINTK("%s(): Entry Point\n", __FUNCTION__);
-
-	/*
-	 * In all cases, the first skb needs to be translated to FlatBuffer.
-	 * Perform a buffer translation for the first skbuff
-	 */
-	curFlatBuffer = bufferList->pBuffers;
-	icp_ocfDrvSingleSkBuffToFlatBuffer(pSkb, curFlatBuffer);
-
-	/* Set the userData to point to the original sk_buff */
-	bufferList->pUserData = (void *)pSkb;
-
-	/* We now know we'll have at least one element in the SGL */
-	bufferList->numBuffers = 1;
-
-	if (0 == skb_is_nonlinear(pSkb)) {
-		/* Is a linear buffer - therefore it's a single skbuff */
-		DPRINTK("%s(): Exit Point\n", __FUNCTION__);
-		return ICP_OCF_DRV_STATUS_SUCCESS;
-	}
-
-	curFlatBuffer++;
-	pShInfo = skb_shinfo(pSkb);
-	if (pShInfo->frag_list != NULL && pShInfo->nr_frags != 0) {
-		EPRINTK("%s():"
-			"Translation for a combination of frag_list "
-			"and frags[] array not supported!\n", __FUNCTION__);
-		return ICP_OCF_DRV_STATUS_FAIL;
-	} else if (pShInfo->frag_list != NULL) {
-		/*
-		 * Non linear skbuff supported through frag_list 
-		 * Perform translation for each fragment (sk_buff)
-		 * in the frag_list of the first sk_buff.
-		 */
-		for (pCurFrag = pShInfo->frag_list;
-		     pCurFrag != NULL; pCurFrag = pCurFrag->next) {
-			icp_ocfDrvSingleSkBuffToFlatBuffer(pCurFrag,
-							   curFlatBuffer);
-			curFlatBuffer++;
-			bufferList->numBuffers++;
-		}
-	} else if (pShInfo->nr_frags != 0) {
-		/*
-		 * Perform translation for each fragment in frags array
-		 * and add to the BufferList
-		 */
-		for (i = 0; i < pShInfo->nr_frags; i++) {
-			/* Get the page address and offset of this frag */
-			skbuffPageAddr = (char *)pShInfo->frags[i].page;
-			page_offset = pShInfo->frags[i].page_offset;
-
-			/* Convert a pointer and length to a flat buffer */
-			icp_ocfDrvPtrAndLenToFlatBuffer(skbuffPageAddr +
-							page_offset,
-							pShInfo->frags[i].size,
-							curFlatBuffer);
-			curFlatBuffer++;
-			bufferList->numBuffers++;
-		}
-	} else {
-		EPRINTK("%s():" "Could not recognize skbuff fragments!\n",
-			__FUNCTION__);
-		return ICP_OCF_DRV_STATUS_FAIL;
-	}
-
-	DPRINTK("%s(): Exit Point\n", __FUNCTION__);
-	return ICP_OCF_DRV_STATUS_SUCCESS;
-}
-
-/* Name        : icp_ocfDrvBufferListToSkBuff 
- *
- * Description : This function converts a Fredericksburg Scatter/Gather 
- * (CpaBufferList) buffer format to socket buffer structure.
- */
-inline int
-icp_ocfDrvBufferListToSkBuff(CpaBufferList * bufferList, struct sk_buff **skb)
-{
-	DPRINTK("%s(): Entry Point\n", __FUNCTION__);
-
-	/* Retrieve the orignal skbuff */
-	*skb = (struct sk_buff *)bufferList->pUserData;
-	if (NULL == *skb) {
-		EPRINTK("%s():"
-			"Error on converting from a BufferList. "
-			"The BufferList does not contain an sk_buff.\n",
-			__FUNCTION__);
-		return ICP_OCF_DRV_STATUS_FAIL;
-	}
-	DPRINTK("%s(): Exit Point\n", __FUNCTION__);
-	return ICP_OCF_DRV_STATUS_SUCCESS;
-}
-
 /* Name        : icp_ocfDrvPtrAndLenToBufferList
  *
  * Description : This function converts a "pointer and length" buffer
@@ -761,45 +655,6 @@ icp_ocfDrvBufferListMemInfo(uint16_t numBuffers,
 	return ICP_OCF_DRV_STATUS_SUCCESS;
 }
 
-/* Name        : icp_ocfDrvGetSkBuffFrags
- *
- * Description : This function will determine the number of 
- * fragments in a socket buffer(sk_buff).
- */
-inline uint16_t icp_ocfDrvGetSkBuffFrags(struct sk_buff * pSkb)
-{
-	uint16_t numFrags = 0;
-	struct sk_buff *pCurFrag = NULL;
-	struct skb_shared_info *pShInfo = NULL;
-
-	if (NULL == pSkb)
-		return 0;
-
-	numFrags = 1;
-	if (0 == skb_is_nonlinear(pSkb)) {
-		/* Linear buffer - it's a single skbuff */
-		return numFrags;
-	}
-
-	pShInfo = skb_shinfo(pSkb);
-	if (NULL != pShInfo->frag_list && 0 != pShInfo->nr_frags) {
-		EPRINTK("%s(): Combination of frag_list "
-			"and frags[] array not supported!\n", __FUNCTION__);
-		return 0;
-	} else if (0 != pShInfo->nr_frags) {
-		numFrags += pShInfo->nr_frags;
-		return numFrags;
-	} else if (NULL != pShInfo->frag_list) {
-		for (pCurFrag = pShInfo->frag_list;
-		     pCurFrag != NULL; pCurFrag = pCurFrag->next) {
-			numFrags++;
-		}
-		return numFrags;
-	} else {
-		return 0;
-	}
-}
-
 /* Name        : icp_ocfDrvFreeFlatBuffer
  *
  * Description : This function will deallocate flat buffer.
@@ -808,7 +663,7 @@ inline void icp_ocfDrvFreeFlatBuffer(CpaFlatBuffer * pFlatBuffer)
 {
 	if (pFlatBuffer != NULL) {
 		memset(pFlatBuffer, 0, sizeof(CpaFlatBuffer));
-		kmem_cache_free(drvFlatBuffer_zone, pFlatBuffer);
+		ICP_CACHE_FREE(drvFlatBuffer_zone, pFlatBuffer);
 	}
 }
 
@@ -819,12 +674,12 @@ inline void icp_ocfDrvFreeFlatBuffer(CpaFlatBuffer * pFlatBuffer)
  */
 inline int
 icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList,
-        const struct icp_drvOpData *pOpData)
+			struct icp_drvOpData *pOpData)
 {
 	Cpa32U metaSize = 0;
 
 	if (pBufferList->numBuffers <= ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS){
-	    void *pOpDataStartAddr = (void *)pOpData;
+		uint8_t *pOpDataStartAddr = (uint8_t *) pOpData;
 
 	    if (0 == defBuffListInfo.metaSize) {
 			pBufferList->pPrivateMetaData = NULL;
@@ -835,8 +690,9 @@ icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList,
 		 * op data.  It has been pre-allocated in memory just after the
 		 * icp_drvOpData structure.
 		 */
-		pBufferList->pPrivateMetaData = pOpDataStartAddr +
-		        sizeof(struct icp_drvOpData);
+		pBufferList->pPrivateMetaData = (void *)(pOpDataStartAddr +
+							 sizeof(struct
+								icp_drvOpData));
 	} else {
 		if (CPA_STATUS_SUCCESS !=
 		    cpaCyBufferListGetMetaSize(CPA_INSTANCE_HANDLE_SINGLE,
@@ -852,7 +708,8 @@ icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList,
 			return ICP_OCF_DRV_STATUS_SUCCESS;
 		}
 
-		pBufferList->pPrivateMetaData = kmalloc(metaSize, GFP_ATOMIC);
+		pBufferList->pPrivateMetaData =
+		    icp_kmalloc(metaSize, ICP_M_NOWAIT);
 	}
 	if (NULL == pBufferList->pPrivateMetaData) {
 		EPRINTK("%s() Failed to allocate pPrivateMetaData.\n",
@@ -880,12 +737,37 @@ inline void icp_ocfDrvFreeMetaData(CpaBufferList * pBufferList)
 	 * freed.
 	 */
 	if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS < pBufferList->numBuffers){
-		kfree(pBufferList->pPrivateMetaData);
+		icp_kfree(pBufferList->pPrivateMetaData);
 	}
 }
 
-module_init(icp_ocfDrvInit);
-module_exit(icp_ocfDrvExit);
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_AUTHOR("Intel");
-MODULE_DESCRIPTION("OCF Driver for Intel Quick Assist crypto acceleration");
+/* Module declaration, init and exit functions */
+ICP_DECLARE_MODULE(icp_ocf, icp_ocfDrvInit, icp_ocfDrvExit);
+ICP_MODULE_DESCRIPTION("OCF Driver for Intel Quick Assist crypto acceleration");
+ICP_MODULE_VERSION(icp_ocf, ICP_OCF_VER_MJR);
+ICP_MODULE_LICENSE("Dual BSD/GPL");
+ICP_MODULE_AUTHOR("Intel");
+
+/* Module parameters */
+ICP_MODULE_PARAM_INT(icp_ocf, num_dereg_retries,
+		     "Number of times to retry LAC Sym Session Deregistration. "
+		     "Default 10, Max 100");
+ICP_MODULE_PARAM_INT(icp_ocf, dereg_retry_delay_in_jiffies, "Delay in jiffies "
+		     "(added to a schedule() function call) before a LAC Sym "
+		     "Session Dereg is retried. Default 10");
+ICP_MODULE_PARAM_INT(icp_ocf, max_sessions,
+		     "This sets the maximum number of sessions "
+		     "between OCF and this driver. If this value is set to zero,"
+		     "max session count checking is disabled. Default is zero(0)");
+
+/* Module dependencies */
+#define MODULE_MIN_VER	1
+#define CRYPTO_MAX_VER	3
+#define LAC_MAX_VER	2
+
+ICP_MODULE_DEPEND(icp_ocf, crypto, MODULE_MIN_VER, MODULE_MIN_VER,
+		  CRYPTO_MAX_VER);
+ICP_MODULE_DEPEND(icp_ocf, cryptodev, MODULE_MIN_VER, MODULE_MIN_VER,
+		  CRYPTO_MAX_VER);
+ICP_MODULE_DEPEND(icp_ocf, icp_crypto, MODULE_MIN_VER, MODULE_MIN_VER,
+		  LAC_MAX_VER);
diff --git a/crypto/ocf/ep80579/icp_ocf.h b/crypto/ocf/ep80579/icp_ocf.h
index dff0a8b..c62b3ca 100644
--- a/crypto/ocf/ep80579/icp_ocf.h
+++ b/crypto/ocf/ep80579/icp_ocf.h
@@ -5,7 +5,7 @@
  * 
  *   GPL LICENSE SUMMARY
  * 
- *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  * 
  *   This program is free software; you can redistribute it and/or modify 
  *   it under the terms of version 2 of the GNU General Public License as
@@ -27,7 +27,7 @@
  * 
  *   BSD LICENSE 
  * 
- *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  *   All rights reserved.
  * 
  *   Redistribution and use in source and binary forms, with or without 
@@ -57,42 +57,34 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * 
  * 
- *  version: Security.L.1.0.130
+ *  version: Security.L.1.0.2-229
  *
  ***************************************************************************/
 
 /*
- * OCF drv driver header file for the Intel ICP processor.
+ * OCF driver header file for the Intel ICP processor.
  */
 
-#ifndef ICP_OCF_H
-#define ICP_OCF_H
+#ifndef ICP_OCF_H_
+#define ICP_OCF_H_
 
-#include <linux/crypto.h>
-#include <linux/delay.h>
-#include <linux/skbuff.h>
+#include <cpa.h>
+#include <cpa_cy_im.h>
+#include <cpa_cy_sym.h>
+#include <cpa_cy_rand.h>
+#include <cpa_cy_dh.h>
+#include <cpa_cy_rsa.h>
+#include <cpa_cy_ln.h>
+#include <cpa_cy_common.h>
+#include <cpa_cy_dsa.h>
 
-#include "cryptodev.h"
-#include "uio.h"
-
-#include "cpa.h"
-#include "cpa_cy_im.h"
-#include "cpa_cy_sym.h"
-#include "cpa_cy_rand.h"
-#include "cpa_cy_dh.h"
-#include "cpa_cy_rsa.h"
-#include "cpa_cy_ln.h"
-#include "cpa_cy_common.h"
-#include "cpa_cy_dsa.h"
+#include "icp_os.h"
 
 #define NUM_BITS_IN_BYTE (8)
 #define NUM_BITS_IN_BYTE_MINUS_ONE (NUM_BITS_IN_BYTE -1)
 #define INVALID_DRIVER_ID (-1)
 #define RETURN_RAND_NUM_GEN_FAILED (-1)
 
-/*This is define means only one operation can be chained to another
-(resulting in one chain of two operations)*/
-#define MAX_NUM_OF_CHAINED_OPS (1)
 /*This is the max block cipher initialisation vector*/
 #define MAX_IV_LEN_IN_BYTES (20)
 /*This is used to check whether the OCF to this driver session limit has
@@ -118,61 +110,10 @@
 #define ICP_OCF_PRINT_KERN_ALERT		(1)
 #define ICP_OCF_PRINT_KERN_ERRS			(1)
 
-/*DSA Prime Q size in bytes (as defined in the standard) */
-#define DSA_RS_SIGN_PRIMEQ_SIZE_IN_BYTES	(20)
-
-/*MACRO DEFINITIONS*/
-
-#define BITS_TO_BYTES(bytes, bits) 					\
-	bytes = (bits + NUM_BITS_IN_BYTE_MINUS_ONE) / NUM_BITS_IN_BYTE
-
-#define ICP_CACHE_CREATE(cache_ID, cache_name) 				\
-	kmem_cache_create(cache_ID, sizeof(cache_name),0, 		\
-		SLAB_HWCACHE_ALIGN, NULL, NULL);
-
-#define ICP_CACHE_NULL_CHECK(slab_zone)					\
-{									\
-	if(NULL == slab_zone){ 						\
-		icp_ocfDrvFreeCaches(); 				\
-		EPRINTK("%s() line %d: Not enough memory!\n", 		\
-			__FUNCTION__, __LINE__); 			\
-		return ENOMEM; 						\
-	}								\
-}
-
-#define ICP_CACHE_DESTROY(slab_zone) 	                                \
-{                                                                       \
-        if(NULL != slab_zone){						\
-                kmem_cache_destroy(slab_zone);				\
-                slab_zone = NULL;					\
-        }								\
-}
-
-#define ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(alg)			\
-{									\
-	if(OCF_REGISTRATION_STATUS_SUCCESS ==				\
-		crypto_register(icp_ocfDrvDriverId,			\
-				    alg,				\
-				    0,					\
-				    0)) {				\
-		ocfStatus++;						\
-	}								\
-}
-
-#define ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(alg)			\
-{									\
-	if(OCF_REGISTRATION_STATUS_SUCCESS ==				\
-		crypto_kregister(icp_ocfDrvDriverId,			\
-				      alg,				\
-				      0)){				\
-		ocfStatus++;						\
-	}								\
-}
-
 #if ICP_OCF_PRINT_DEBUG_MESSAGES == 1
 #define DPRINTK(args...)      \
 {			      \
-                printk(args); \
+                ICP_IPRINTK(args); \
 }
 
 #else				//ICP_OCF_PRINT_DEBUG_MESSAGES == 1
@@ -184,7 +125,7 @@
 #if ICP_OCF_PRINT_KERN_ALERT == 1
 #define APRINTK(args...)      						\
 {			      						\
-       printk(KERN_ALERT args);						\
+       ICP_APRINTK(args);						\
 }
 
 #else				//ICP_OCF_PRINT_KERN_ALERT == 1
@@ -196,7 +137,7 @@
 #if ICP_OCF_PRINT_KERN_ERRS == 1
 #define EPRINTK(args...)      \
 {			      \
-       printk(KERN_ERR args); \
+       ICP_EPRINTK(args); \
 }
 
 #else				//ICP_OCF_PRINT_KERN_ERRS == 1
@@ -207,47 +148,110 @@
 
 #define IPRINTK(args...)      \
 {			      \
-      printk(KERN_INFO args); \
+      ICP_IPRINTK(args); \
 }
 
-/*END OF MACRO DEFINITIONS*/
+/*DSA Prime Q size in bytes (as defined in the standard) */
+#define DSA_RS_SIGN_PRIMEQ_SIZE_IN_BYTES	(20)
+
+#define BITS_TO_BYTES(bytes, bits) 					\
+	bytes = (bits + NUM_BITS_IN_BYTE_MINUS_ONE) / NUM_BITS_IN_BYTE
 
 typedef enum {
 	ICP_OCF_DRV_ALG_CIPHER = 0,
 	ICP_OCF_DRV_ALG_HASH
 } icp_ocf_drv_alg_type_t;
 
-/* These are all defined in icp_common.c */
-extern atomic_t lac_session_failed_dereg_count;
-extern atomic_t icp_ocfDrvIsExiting;
-extern atomic_t num_ocf_to_drv_registered_sessions;
+typedef ICP_LIST_HEAD(icp_drvSessionListHead_s,
+		      icp_drvSessionData) icp_drvSessionListHead_t;
 
-/*These are use inputs used in icp_sym.c and icp_common.c
-  They are instantiated in icp_common.c*/
-extern int max_sessions;
+/*Values used to derisk chances of performs being called against
+deregistered sessions (for which the slab page has been reclaimed)
+This is not a fix - since page frames are reclaimed from a slab, one cannot
+rely on that memory not being re-used by another app.*/
+typedef enum {
+	ICP_SESSION_INITIALISED = 0x5C5C5C,
+	ICP_SESSION_RUNNING = 0x005C00,
+	ICP_SESSION_DEREGISTERED = 0xC5C5C5
+} usage_derisk;
+
+/* This struct is required for deferred session
+ deregistration as a work queue function can
+ only have one argument*/
+struct icp_ocfDrvFreeLacSession {
+	CpaCySymSessionCtx sessionToDeregister;
+	icp_workstruct work;
+};
+
+/*
+This is the OCF<->OCF_DRV session object:
+
+1.listNode
+  The first member is a listNode. These session objects are added to a linked
+  list in order to make it easier to remove them all at session exit time.
+
+2.inUse
+  The second member is used to give the session object state and derisk the
+  possibility of OCF batch calls executing against a deregistered session (as
+  described above).
+
+3.sessHandle
+  The third member is a LAC<->OCF_DRV session handle (initialised with the first
+  perform request for that session).
+
+4.lacSessCtx
+  The fourth is the LAC session context. All the parameters for this structure
+  are only known when the first perform request for this session occurs. That is
+  why the OCF EP80579 Driver only registers a new LAC session at perform time
+*/
+struct icp_drvSessionData {
+	ICP_LIST_ENTRY(icp_drvSessionData) listNode;
+	usage_derisk inUse;
+	CpaCySymSessionCtx sessHandle;
+	CpaCySymSessionSetupData lacSessCtx;
+};
+
+/* These are all defined in icp_common.c */
+extern icp_atomic_t lac_session_failed_dereg_count;
+extern icp_atomic_t icp_ocfDrvIsExiting;
+extern icp_atomic_t num_ocf_to_drv_registered_sessions;
 
 extern int32_t icp_ocfDrvDriverId;
-extern struct list_head icp_ocfDrvGlobalSymListHead;
-extern struct list_head icp_ocfDrvGlobalSymListHead_FreeMemList;
-extern struct workqueue_struct *icp_ocfDrvFreeLacSessionWorkQ;
-extern spinlock_t icp_ocfDrvSymSessInfoListSpinlock;
-extern rwlock_t icp_kmem_cache_destroy_alloc_lock;
+
+extern icp_drvSessionListHead_t icp_ocfDrvGlobalSymListHead;
+extern icp_drvSessionListHead_t icp_ocfDrvGlobalSymListHead_FreeMemList;
+extern icp_workqueue *icp_ocfDrvFreeLacSessionWorkQ;
+extern icp_spinlock_t icp_ocfDrvSymSessInfoListSpinlock;
 
 /*Slab zones for symettric functionality, instantiated in icp_common.c*/
-extern struct kmem_cache *drvSessionData_zone;
-extern struct kmem_cache *drvOpData_zone;
+extern icp_kmem_cache drvSessionData_zone;
+extern icp_kmem_cache drvOpData_zone;
 
 /*Slabs zones for asymettric functionality, instantiated in icp_common.c*/
-extern struct kmem_cache *drvDH_zone;
-extern struct kmem_cache *drvLnModExp_zone;
-extern struct kmem_cache *drvRSADecrypt_zone;
-extern struct kmem_cache *drvRSAPrivateKey_zone;
-extern struct kmem_cache *drvDSARSSign_zone;
-extern struct kmem_cache *drvDSARSSignKValue_zone;
-extern struct kmem_cache *drvDSAVerify_zone;
+extern icp_kmem_cache drvDH_zone;
+extern icp_kmem_cache drvLnModExp_zone;
+extern icp_kmem_cache drvRSADecrypt_zone;
+extern icp_kmem_cache drvRSAPrivateKey_zone;
+extern icp_kmem_cache drvDSARSSign_zone;
+extern icp_kmem_cache drvDSARSSignKValue_zone;
+extern icp_kmem_cache drvDSAVerify_zone;
+
+/* Module parameters defined in icp_cpmmon.c*/
+
+/* Module parameters - gives the number of times LAC deregistration shall be
+   re-tried */
+extern int num_dereg_retries;
+
+/* Module parameter - gives the delay time in jiffies before a LAC session
+   shall be attempted to be deregistered again */
+extern int dereg_retry_delay_in_jiffies;
+
+/* Module parameter - gives the maximum number of sessions possible between
+   OCF and the OCF EP80579 Driver. If set to zero, there is no limit.*/
+extern int max_sessions;
 
 /*Slab zones for flatbuffers and bufferlist*/
-extern struct kmem_cache *drvFlatBuffer_zone;
+extern icp_kmem_cache drvFlatBuffer_zone;
 
 #define ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS     (16)
 
@@ -257,19 +261,13 @@ struct icp_drvBuffListInfo {
 	Cpa32U metaOffset;
 	Cpa32U buffListSize;
 };
+
 extern struct icp_drvBuffListInfo defBuffListInfo;
 
-/*
-* This struct is used to keep a reference to the relevant node in the list
-* of sessionData structs, to the buffer type required by OCF and to the OCF
-* provided crp struct that needs to be returned. All this info is needed in
-* the callback function.
-*
-* IV can sometimes be stored in non-contiguous memory (e.g. skbuff
-* linked/frag list, therefore a contiguous memory space for the IV data must be
-* created and passed to LAC
-*
-*/
+/* This struct is used to keep a reference to the relevant node in the list
+   of sessionData structs, to the buffer type required by OCF and to the OCF
+   provided crp struct that needs to be returned. All this info is needed in
+   the callback function.*/
 struct icp_drvOpData {
 	CpaCySymOpData lacOpData;
 	uint32_t digestSizeInBytes;
@@ -281,83 +279,98 @@ struct icp_drvOpData {
 	CpaFlatBuffer bufferListArray[ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS];
 	CpaBoolean verifyResult;
 };
-/*Values used to derisk chances of performs being called against
-deregistered sessions (for which the slab page has been reclaimed)
-This is not a fix - since page frames are reclaimed from a slab, one cannot
-rely on that memory not being re-used by another app.*/
-typedef enum {
-	ICP_SESSION_INITIALISED = 0x5C5C5C,
-	ICP_SESSION_RUNNING = 0x005C00,
-	ICP_SESSION_DEREGISTERED = 0xC5C5C5
-} usage_derisk;
-
-/*
-This is the OCF<->OCF_DRV session object:
-
-1.The first member is a listNode. These session objects are added to a linked
-  list in order to make it easier to remove them all at session exit time.
-2.The second member is used to give the session object state and derisk the
-  possibility of OCF batch calls executing against a deregistered session (as
-  described above).
-3.The third member is a LAC<->OCF_DRV session handle (initialised with the first
-  perform request for that session).
-4.The fourth is the LAC session context. All the parameters for this structure
-  are only known when the first perform request for this session occurs. That is
-  why the OCF Tolapai Driver only registers a new LAC session at perform time
-*/
-struct icp_drvSessionData {
-	struct list_head listNode;
-	usage_derisk inUse;
-	CpaCySymSessionCtx sessHandle;
-	CpaCySymSessionSetupData lacSessCtx;
-};
 
-/* This struct is required for deferred session
- deregistration as a work queue function can
- only have one argument*/
-struct icp_ocfDrvFreeLacSession {
-	CpaCySymSessionCtx sessionToDeregister;
-	struct work_struct work;
-};
+/* Create a new session between OCF and this driver*/
+int icp_ocfDrvNewSession(icp_device_t dev, uint32_t * sild,
+			 struct cryptoini *cri);
 
-int icp_ocfDrvNewSession(device_t dev, uint32_t * sild, struct cryptoini *cri);
+/* Free a session between this driver and the Quick Assist Framework*/
+int icp_ocfDrvFreeLACSession(icp_device_t dev, uint64_t sid);
 
-int icp_ocfDrvFreeLACSession(device_t dev, uint64_t sid);
+/* Defer freeing a Quick Assist session*/
+void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg);
 
-int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint);
+/* Process OCF cryptographic request for a symmetric algorithm*/
+int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint);
 
-int icp_ocfDrvPkeProcess(device_t dev, struct cryptkop *krp, int hint);
+/* Process OCF cryptographic request for an asymmetric algorithm*/
+int icp_ocfDrvPkeProcess(icp_device_t dev, struct cryptkop *krp, int hint);
 
+/* Populate a buffer with random data*/
 int icp_ocfDrvReadRandom(void *arg, uint32_t * buf, int maxwords);
 
+/* Retry Quick Assist session deregistration*/
 int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister);
 
-int icp_ocfDrvSkBuffToBufferList(struct sk_buff *skb,
+/* Convert an OS scatter gather list to a CPA buffer list*/
+int icp_ocfDrvPacketBuffToBufferList(icp_packet_buffer_t * pPacketBuffer,
 				 CpaBufferList * bufferList);
 
-int icp_ocfDrvBufferListToSkBuff(CpaBufferList * bufferList,
-				 struct sk_buff **skb);
+/* Convert a CPA buffer list to an OS scatter gather list*/
+int icp_ocfDrvBufferListToPacketBuff(CpaBufferList * bufferList,
+				     icp_packet_buffer_t ** pPacketBuffer);
+
+/* Get the number of buffers in an OS scatter gather list*/
+uint16_t icp_ocfDrvGetPacketBuffFrags(icp_packet_buffer_t * pPacketBuffer);
 
+/* Convert a single OS buffer to a CPA Flat Buffer*/
+void icp_ocfDrvSinglePacketBuffToFlatBuffer(icp_packet_buffer_t * pPacketBuffer,
+					    CpaFlatBuffer * pFlatBuffer);
+
+/* Add pointer and length to a CPA Flat Buffer structure*/
 void icp_ocfDrvPtrAndLenToFlatBuffer(void *pData, uint32_t len,
 				     CpaFlatBuffer * pFlatBuffer);
 
+/* Convert pointer and length values to a CPA buffer list*/
 void icp_ocfDrvPtrAndLenToBufferList(void *pDataIn, uint32_t length,
 				     CpaBufferList * pBufferList);
 
+/* Convert a CPA buffer list to pointer and length values*/
 void icp_ocfDrvBufferListToPtrAndLen(CpaBufferList * pBufferList,
 				     void **ppDataOut, uint32_t * pLength);
 
+/* Set the number of flat buffers in bufferlist and the size of memory
+   to allocate for the pPrivateMetaData member of the CpaBufferList.*/
 int icp_ocfDrvBufferListMemInfo(uint16_t numBuffers,
 				struct icp_drvBuffListInfo *buffListInfo);
 
-uint16_t icp_ocfDrvGetSkBuffFrags(struct sk_buff *pSkb);
+/* Find pointer position of the digest within an OS scatter gather list*/
+uint8_t *icp_ocfDrvPacketBufferDigestPointerFind(struct icp_drvOpData
+						 *drvOpData,
+						 int offsetInBytes,
+						 uint32_t digestSizeInBytes);
+
+/*This top level function is used to find a pointer to where a digest is
+  stored/needs to be inserted. */
+uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData *drvOpData,
+				     struct cryptodesc *crp_desc);
 
+/* Free a CPA flat buffer*/
 void icp_ocfDrvFreeFlatBuffer(CpaFlatBuffer * pFlatBuffer);
 
+/* This function will allocate memory for the pPrivateMetaData
+   member of CpaBufferList. */
 int icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList, 
-                const struct icp_drvOpData *pOpData);
+			    struct icp_drvOpData *pOpData);
 
+/* Free data allocated for the pPrivateMetaData
+   member of CpaBufferList.*/
 void icp_ocfDrvFreeMetaData(CpaBufferList * pBufferList);
 
+#define ICP_CACHE_CREATE(cache_ID, cache_name) \
+	icp_kmem_cache_create(cache_ID, sizeof(cache_name),ICP_KERNEL_CACHE_ALIGN,\
+	ICP_KERNEL_CACHE_NOINIT)
+
+#define ICP_CACHE_FREE(args...) \
+	icp_kmem_cache_free (args)
+
+#define ICP_CACHE_DESTROY(slab_zone)\
+{\
+        if(NULL != slab_zone){\
+                icp_kmem_cache_destroy(slab_zone);\
+                slab_zone = NULL;\
+        }\
+}
+
 #endif
-/* ICP_OCF_H */
+/* ICP_OCF_H_ */
diff --git a/crypto/ocf/ep80579/icp_sym.c b/crypto/ocf/ep80579/icp_sym.c
index d632970..b5d2c73 100644
--- a/crypto/ocf/ep80579/icp_sym.c
+++ b/crypto/ocf/ep80579/icp_sym.c
@@ -5,7 +5,7 @@
  * 
  *   GPL LICENSE SUMMARY
  * 
- *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  * 
  *   This program is free software; you can redistribute it and/or modify 
  *   it under the terms of version 2 of the GNU General Public License as
@@ -27,7 +27,7 @@
  * 
  *   BSD LICENSE 
  * 
- *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  *   All rights reserved.
  * 
  *   Redistribution and use in source and binary forms, with or without 
@@ -57,7 +57,7 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * 
  * 
- *  version: Security.L.1.0.130
+ *  version: Security.L.1.0.2-229
  *
  ***************************************************************************/
 /*
@@ -96,38 +96,6 @@ static int
 icp_ocfDrvAlgorithmSetup(struct cryptoini *cri,
 			 CpaCySymSessionSetupData * lacSessCtx);
 
-/*This top level function is used to find a pointer to where a digest is 
-  stored/needs to be inserted. */
-static uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData *drvOpData,
-					    struct cryptodesc *crp_desc);
-
-/*This function is called when a digest pointer has to be found within a
-  SKBUFF.*/
-static inline uint8_t *icp_ocfDrvSkbuffDigestPointerFind(struct icp_drvOpData
-							 *drvOpData,
-							 int offsetInBytes,
-							 uint32_t
-							 digestSizeInBytes);
-
-/*The following two functions are called if the SKBUFF digest pointer is not 
-  positioned in the linear portion of the buffer (i.e. it is in a linked SKBUFF
-   or page fragment).*/
-/*This function takes care of the page fragment case.*/
-static inline uint8_t *icp_ocfDrvDigestSkbNRFragsCheck(struct sk_buff *skb,
-						       struct skb_shared_info
-						       *skb_shared,
-						       int offsetInBytes,
-						       uint32_t
-						       digestSizeInBytes);
-
-/*This function takes care of the linked list case.*/
-static inline uint8_t *icp_ocfDrvDigestSkbFragListCheck(struct sk_buff *skb,
-							struct skb_shared_info
-							*skb_shared,
-							int offsetInBytes,
-							uint32_t
-							digestSizeInBytes);
-
 /*This function is used to free an OCF->OCF_DRV session object*/
 static void icp_ocfDrvFreeOCFSession(struct icp_drvSessionData *sessionData);
 
@@ -142,7 +110,7 @@ static void icp_ocfDrvFreeOCFSession(struct icp_drvSessionData *sessionData);
  * Notes : The callbackTag is a pointer to an icp_drvOpData. This memory
  * object was passed to LAC for the cryptographic processing and contains all
  * the relevant information for cleaning up buffer handles etc. so that the
- * OCF Tolapai Driver portion of this crypto operation can be fully completed.
+ * OCF EP80579 Driver portion of this crypto operation can be fully completed.
  */
 static void
 icp_ocfDrvSymCallBack(void *callbackTag,
@@ -188,10 +156,11 @@ icp_ocfDrvSymCallBack(void *callbackTag,
 
 	if (CPA_STATUS_SUCCESS == status) {
 
-		if (temp_drvOpData->bufferType == CRYPTO_F_SKBUF) {
+		if (temp_drvOpData->bufferType == ICP_CRYPTO_F_PACKET_BUF) {
 			if (ICP_OCF_DRV_STATUS_SUCCESS !=
-			    icp_ocfDrvBufferListToSkBuff(pDstBuffer,
-							 (struct sk_buff **)
+			    icp_ocfDrvBufferListToPacketBuff(pDstBuffer,
+							     (icp_packet_buffer_t
+							      **)
 							 &(crp->crp_buf))) {
 				EPRINTK("%s(): BufferList to SkBuff "
 					"conversion error.\n", __FUNCTION__);
@@ -213,10 +182,10 @@ icp_ocfDrvSymCallBack(void *callbackTag,
 
 	if (temp_drvOpData->numBufferListArray >
 	    ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS) {
-		kfree(pDstBuffer->pBuffers);
+		icp_kfree(pDstBuffer->pBuffers);
 	}
 	icp_ocfDrvFreeMetaData(pDstBuffer);
-	kmem_cache_free(drvOpData_zone, temp_drvOpData);
+	ICP_CACHE_FREE(drvOpData_zone, temp_drvOpData);
 
 	/* Invoke the OCF callback function */
 	crypto_done(crp);
@@ -231,7 +200,8 @@ icp_ocfDrvSymCallBack(void *callbackTag,
  * Notes : LAC session registration happens during the first perform call.
  * That is the first time we know all information about a given session.
  */
-int icp_ocfDrvNewSession(device_t dev, uint32_t * sid, struct cryptoini *cri)
+int icp_ocfDrvNewSession(icp_device_t dev, uint32_t * sid,
+			 struct cryptoini *cri)
 {
 	struct icp_drvSessionData *sessionData = NULL;
 	uint32_t delete_session = 0;
@@ -258,44 +228,44 @@ int icp_ocfDrvNewSession(device_t dev, uint32_t * sid, struct cryptoini *cri)
 		return EINVAL;
 	}
 
-	sessionData = kmem_cache_zalloc(drvSessionData_zone, GFP_ATOMIC);
+	sessionData = icp_kmem_cache_zalloc(drvSessionData_zone, ICP_M_NOWAIT);
 	if (NULL == sessionData) {
 		DPRINTK("%s():No memory for Session Data\n", __FUNCTION__);
 		return ENOMEM;
 	}
 
 	/*ENTER CRITICAL SECTION */
-	spin_lock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
+	icp_spin_lockbh_lock(&icp_ocfDrvSymSessInfoListSpinlock);
 	/*put this check in the spinlock so no new sessions can be added to the
 	   linked list when we are exiting */
-	if (CPA_TRUE == atomic_read(&icp_ocfDrvIsExiting)) {
+	if (CPA_TRUE == icp_atomic_read(&icp_ocfDrvIsExiting)) {
 		delete_session++;
 
 	} else if (NO_OCF_TO_DRV_MAX_SESSIONS != max_sessions) {
-		if (atomic_read(&num_ocf_to_drv_registered_sessions) >=
+		if (icp_atomic_read(&num_ocf_to_drv_registered_sessions) >=
 		    (max_sessions -
-		     atomic_read(&lac_session_failed_dereg_count))) {
+		     icp_atomic_read(&lac_session_failed_dereg_count))) {
 			delete_session++;
 		} else {
-			atomic_inc(&num_ocf_to_drv_registered_sessions);
+			icp_atomic_inc(&num_ocf_to_drv_registered_sessions);
 			/* Add to session data linked list */
-			list_add(&(sessionData->listNode),
-				 &icp_ocfDrvGlobalSymListHead);
+			ICP_LIST_ADD(sessionData, &icp_ocfDrvGlobalSymListHead,
+				     listNode);
 		}
 
 	} else if (NO_OCF_TO_DRV_MAX_SESSIONS == max_sessions) {
-		list_add(&(sessionData->listNode),
-			 &icp_ocfDrvGlobalSymListHead);
+		ICP_LIST_ADD(sessionData, &icp_ocfDrvGlobalSymListHead,
+			     listNode);
 	}
 
 	sessionData->inUse = ICP_SESSION_INITIALISED;
 
 	/*EXIT CRITICAL SECTION */
-	spin_unlock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
+	icp_spin_lockbh_unlock(&icp_ocfDrvSymSessInfoListSpinlock);
 
 	if (delete_session) {
 		DPRINTK("%s():No Session handles available\n", __FUNCTION__);
-		kmem_cache_free(drvSessionData_zone, sessionData);
+		ICP_CACHE_FREE(drvSessionData_zone, sessionData);
 		return EPERM;
 	}
 
@@ -560,27 +530,27 @@ static void icp_ocfDrvFreeOCFSession(struct icp_drvSessionData *sessionData)
 	sessionData->inUse = ICP_SESSION_DEREGISTERED;
 
 	/*ENTER CRITICAL SECTION */
-	spin_lock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
+	icp_spin_lockbh_lock(&icp_ocfDrvSymSessInfoListSpinlock);
 
-	if (CPA_TRUE == atomic_read(&icp_ocfDrvIsExiting)) {
+	if (CPA_TRUE == icp_atomic_read(&icp_ocfDrvIsExiting)) {
 		/*If the Driver is exiting, allow that process to
 		   handle any deletions */
 		/*EXIT CRITICAL SECTION */
-		spin_unlock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
+		icp_spin_lockbh_unlock(&icp_ocfDrvSymSessInfoListSpinlock);
 		return;
 	}
 
-	atomic_dec(&num_ocf_to_drv_registered_sessions);
+	icp_atomic_dec(&num_ocf_to_drv_registered_sessions);
 
-	list_del(&(sessionData->listNode));
+	ICP_LIST_DEL(sessionData, listNode);
 
 	/*EXIT CRITICAL SECTION */
-	spin_unlock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
+	icp_spin_lockbh_unlock(&icp_ocfDrvSymSessInfoListSpinlock);
 
 	if (NULL != sessionData->sessHandle) {
-		kfree(sessionData->sessHandle);
+		icp_kfree(sessionData->sessHandle);
 	}
-	kmem_cache_free(drvSessionData_zone, sessionData);
+	ICP_CACHE_FREE(drvSessionData_zone, sessionData);
 }
 
 /* Name        : icp_ocfDrvFreeLACSession
@@ -588,7 +558,7 @@ static void icp_ocfDrvFreeOCFSession(struct icp_drvSessionData *sessionData)
  * Description : This attempts to deregister a LAC session. If it fails, the
  * deregistation retry function is called.
  */
-int icp_ocfDrvFreeLACSession(device_t dev, uint64_t sid)
+int icp_ocfDrvFreeLACSession(icp_device_t dev, uint64_t sid)
 {
 	CpaCySymSessionCtx sessionToDeregister = NULL;
 	struct icp_drvSessionData *sessionData = NULL;
@@ -604,14 +574,14 @@ int icp_ocfDrvFreeLACSession(device_t dev, uint64_t sid)
 
 	sessionToDeregister = sessionData->sessHandle;
 
-	if (ICP_SESSION_INITIALISED == sessionData->inUse) {
-		DPRINTK("%s() Session not registered with LAC\n", __FUNCTION__);
-	} else if (NULL == sessionData->sessHandle) {
-		EPRINTK
-		    ("%s(): OCF Free session called with Null Session Handle.\n",
-		     __FUNCTION__);
+	if ((ICP_SESSION_INITIALISED != sessionData->inUse) &&
+	    (ICP_SESSION_RUNNING != sessionData->inUse) &&
+	    (ICP_SESSION_DEREGISTERED != sessionData->inUse)) {
+		DPRINTK("%s() Session not initialised.\n", __FUNCTION__);
 		return EINVAL;
-	} else {
+	}
+
+	if (ICP_SESSION_RUNNING == sessionData->inUse) {
 		lacStatus = cpaCySymRemoveSession(CPA_INSTANCE_HANDLE_SINGLE,
 						  sessionToDeregister);
 		if (CPA_STATUS_RETRY == lacStatus) {
@@ -629,9 +599,12 @@ int icp_ocfDrvFreeLACSession(device_t dev, uint64_t sid)
 			DPRINTK("%s(): LAC failed to deregister the session. "
 				"localSessionId= %p, lacStatus = %d\n",
 				__FUNCTION__, sessionToDeregister, lacStatus);
-			atomic_inc(&lac_session_failed_dereg_count);
+			icp_atomic_inc(&lac_session_failed_dereg_count);
 			retval = EPERM;
 		}
+	} else {
+		DPRINTK("%s() Session not registered with LAC.\n",
+			__FUNCTION__);
 	}
 
 	icp_ocfDrvFreeOCFSession(sessionData);
@@ -668,13 +641,12 @@ static int icp_ocfDrvAlgCheck(struct cryptodesc *crp_desc)
  * to whether session paramaters have changed (e.g. alg chain order) are
  * done.
  */
-int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
+int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 {
 	struct icp_drvSessionData *sessionData = NULL;
 	struct icp_drvOpData *drvOpData = NULL;
 	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
 	Cpa32U sessionCtxSizeInBytes = 0;
-	uint16_t numBufferListArray = 0;
 
 	if (NULL == crp) {
 		DPRINTK("%s(): Invalid input parameters, cryptop is NULL\n",
@@ -696,7 +668,7 @@ int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
 		return EINVAL;
 	}
 
-	if (CPA_TRUE == atomic_read(&icp_ocfDrvIsExiting)) {
+	if (CPA_TRUE == icp_atomic_read(&icp_ocfDrvIsExiting)) {
 		crp->crp_etype = EFAULT;
 		return EFAULT;
 	}
@@ -793,14 +765,16 @@ int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
 		if (CPA_STATUS_SUCCESS != lacStatus) {
 			EPRINTK("%s(): cpaCySymSessionCtxGetSize failed - %d\n",
 				__FUNCTION__, lacStatus);
+			crp->crp_etype = EINVAL;
 			return EINVAL;
 		}
 		sessionData->sessHandle =
-		    kmalloc(sessionCtxSizeInBytes, GFP_ATOMIC);
+		    icp_kmalloc(sessionCtxSizeInBytes, ICP_M_NOWAIT);
 		if (NULL == sessionData->sessHandle) {
 			EPRINTK
 			    ("%s(): Failed to get memory for SymSessionCtx\n",
 			     __FUNCTION__);
+			crp->crp_etype = ENOMEM;
 			return ENOMEM;
 		}
 
@@ -812,13 +786,14 @@ int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
 		if (CPA_STATUS_SUCCESS != lacStatus) {
 			EPRINTK("%s(): cpaCySymInitSession failed -%d \n",
 				__FUNCTION__, lacStatus);
+			crp->crp_etype = EFAULT;
 			return EFAULT;
 		}
 
 		sessionData->inUse = ICP_SESSION_RUNNING;
 	}
 
-	drvOpData = kmem_cache_zalloc(drvOpData_zone, GFP_ATOMIC);
+	drvOpData = icp_kmem_cache_zalloc(drvOpData_zone, ICP_M_NOWAIT);
 	if (NULL == drvOpData) {
 		EPRINTK("%s():Failed to get memory for drvOpData\n",
 			__FUNCTION__);
@@ -835,28 +810,48 @@ int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
 	drvOpData->srcBuffer.pBuffers = drvOpData->bufferListArray;
 	drvOpData->numBufferListArray = ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS;
 
+	if (ICP_OCF_DRV_STATUS_SUCCESS !=
+	    icp_ocfDrvProcessDataSetup(drvOpData, drvOpData->crp->crp_desc)) {
+		crp->crp_etype = EINVAL;
+		goto err;
+	}
+
+	if (drvOpData->crp->crp_desc->crd_next != NULL) {
+		if (icp_ocfDrvProcessDataSetup(drvOpData, drvOpData->crp->
+					       crp_desc->crd_next)) {
+			crp->crp_etype = EINVAL;
+			goto err;
+		}
+
+	}
+
 	/* 
-	 * Allocate buffer list array memory allocation if the
-	 * data fragment is more than the default allocation
+	 * Allocate buffer list array memory if the data fragment is more than
+	 * the default number (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS) and not
+	 * calculated already
 	 */
-	if (crp->crp_flags & CRYPTO_F_SKBUF) {
-		numBufferListArray = icp_ocfDrvGetSkBuffFrags((struct sk_buff *)
+	if (crp->crp_flags & ICP_CRYPTO_F_PACKET_BUF) {
+		if (NULL == drvOpData->lacOpData.pDigestResult) {
+			drvOpData->numBufferListArray =
+			    icp_ocfDrvGetPacketBuffFrags((icp_packet_buffer_t *)
 							      crp->crp_buf);
-		if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS < numBufferListArray) {
+		}
+
+		if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS <
+		    drvOpData->numBufferListArray) {
 			DPRINTK("%s() numBufferListArray more than default\n",
 				__FUNCTION__);
 			drvOpData->srcBuffer.pBuffers = NULL;
 			drvOpData->srcBuffer.pBuffers =
-			    kmalloc(numBufferListArray *
-				    sizeof(CpaFlatBuffer), GFP_ATOMIC);
+			    icp_kmalloc(drvOpData->numBufferListArray *
+					sizeof(CpaFlatBuffer), ICP_M_NOWAIT);
 			if (NULL == drvOpData->srcBuffer.pBuffers) {
 				EPRINTK("%s() Failed to get memory for "
 					"pBuffers\n", __FUNCTION__);
-				kmem_cache_free(drvOpData_zone, drvOpData);
+				ICP_CACHE_FREE(drvOpData_zone, drvOpData);
 				crp->crp_etype = ENOMEM;
 				return ENOMEM;
 			}
-			drvOpData->numBufferListArray = numBufferListArray;
 		}
 	}
 
@@ -864,17 +859,18 @@ int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
 	 * Check the type of buffer structure we got and convert it into
 	 * CpaBufferList format.
 	 */
-	if (crp->crp_flags & CRYPTO_F_SKBUF) {
+	if (crp->crp_flags & ICP_CRYPTO_F_PACKET_BUF) {
 		if (ICP_OCF_DRV_STATUS_SUCCESS !=
-		    icp_ocfDrvSkBuffToBufferList((struct sk_buff *)crp->crp_buf,
+		    icp_ocfDrvPacketBuffToBufferList((icp_packet_buffer_t *)
+						     crp->crp_buf,
 						 &(drvOpData->srcBuffer))) {
-			EPRINTK("%s():Failed to translate from SK_BUF "
+			EPRINTK("%s():Failed to translate from packet buffer "
 				"to bufferlist\n", __FUNCTION__);
 			crp->crp_etype = EINVAL;
 			goto err;
 		}
 
-		drvOpData->bufferType = CRYPTO_F_SKBUF;
+		drvOpData->bufferType = ICP_CRYPTO_F_PACKET_BUF;
 	} else if (crp->crp_flags & CRYPTO_F_IOV) {
 		/* OCF only supports IOV of one entry. */
 		if (NUM_IOV_SUPPORTED ==
@@ -906,21 +902,6 @@ int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
 		drvOpData->bufferType = CRYPTO_BUF_CONTIG;
 	}
 
-	if (ICP_OCF_DRV_STATUS_SUCCESS !=
-	    icp_ocfDrvProcessDataSetup(drvOpData, drvOpData->crp->crp_desc)) {
-		crp->crp_etype = EINVAL;
-		goto err;
-	}
-
-	if (drvOpData->crp->crp_desc->crd_next != NULL) {
-		if (icp_ocfDrvProcessDataSetup(drvOpData, drvOpData->crp->
-					       crp_desc->crd_next)) {
-			crp->crp_etype = EINVAL;
-			goto err;
-		}
-
-	}
-
 	/* Allocate srcBuffer's private meta data */
 	if (ICP_OCF_DRV_STATUS_SUCCESS !=
 	    icp_ocfDrvAllocMetaData(&(drvOpData->srcBuffer), drvOpData)) {
@@ -941,7 +922,7 @@ int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
 		DPRINTK("%s(): cpaCySymPerformOp retry, lacStatus = %d\n",
 			__FUNCTION__, lacStatus);
 		memset(&(drvOpData->lacOpData), 0, sizeof(CpaCySymOpData));
-		crp->crp_etype = EINVAL;
+		crp->crp_etype = ERESTART;
 		goto err;
 	}
 	if (CPA_STATUS_SUCCESS != lacStatus) {
@@ -956,10 +937,10 @@ int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
 
       err:
 	if (drvOpData->numBufferListArray > ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS) {
-		kfree(drvOpData->srcBuffer.pBuffers);
+		icp_kfree(drvOpData->srcBuffer.pBuffers);
 	}
 	icp_ocfDrvFreeMetaData(&(drvOpData->srcBuffer));
-	kmem_cache_free(drvOpData_zone, drvOpData);
+	ICP_CACHE_FREE(drvOpData_zone, drvOpData);
 
 	return crp->crp_etype;
 }
@@ -1129,8 +1110,7 @@ static int icp_ocfDrvProcessDataSetup(struct icp_drvOpData *drvOpData,
  * must be traversed by the data length offset in order to find the digest start
  * address. Whether there is enough space for the digest must also be checked.
  */
-
-static uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData *drvOpData,
+uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData * drvOpData,
 					    struct cryptodesc *crp_desc)
 {
 
@@ -1138,21 +1118,10 @@ static uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData *drvOpData,
 	uint32_t digestSizeInBytes = drvOpData->digestSizeInBytes;
 	uint8_t *flat_buffer_base = NULL;
 	int flat_buffer_length = 0;
-	struct sk_buff *skb;
-
-	if (drvOpData->crp->crp_flags & CRYPTO_F_SKBUF) {
-		/*check if enough overall space to store hash */
-		skb = (struct sk_buff *)(drvOpData->crp->crp_buf);
 
-		if (skb->len < (offsetInBytes + digestSizeInBytes)) {
-			DPRINTK("%s() Not enough space for Digest"
-				" payload after the offset (%d), "
-				"digest size (%d) \n", __FUNCTION__,
-				offsetInBytes, digestSizeInBytes);
-			return NULL;
-		}
+	if (drvOpData->crp->crp_flags & ICP_CRYPTO_F_PACKET_BUF) {
 
-		return icp_ocfDrvSkbuffDigestPointerFind(drvOpData,
+		return icp_ocfDrvPacketBufferDigestPointerFind(drvOpData,
 							 offsetInBytes,
 							 digestSizeInBytes);
 
@@ -1182,201 +1151,3 @@ static uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData *drvOpData,
 	DPRINTK("%s() Should not reach this point\n", __FUNCTION__);
 	return NULL;
 }
-
-/* Name        : icp_ocfDrvSkbuffDigestPointerFind
- *
- * Description : This function is used by icp_ocfDrvDigestPointerFind to process
- * the non-linear portion of the skbuff if the fragmentation type is a linked
- * list (frag_list is not NULL in the skb_shared_info structure)
- */
-static inline uint8_t *icp_ocfDrvSkbuffDigestPointerFind(struct icp_drvOpData
-							 *drvOpData,
-							 int offsetInBytes,
-							 uint32_t
-							 digestSizeInBytes)
-{
-
-	struct sk_buff *skb = NULL;
-	struct skb_shared_info *skb_shared = NULL;
-
-	uint32_t skbuffisnonlinear = 0;
-
-	uint32_t skbheadlen = 0;
-
-	skb = (struct sk_buff *)(drvOpData->crp->crp_buf);
-	skbuffisnonlinear = skb_is_nonlinear(skb);
-
-	skbheadlen = skb_headlen(skb);
-
-	/*Linear skb checks */
-	if (skbheadlen > offsetInBytes) {
-
-		if (skbheadlen >= (offsetInBytes + digestSizeInBytes)) {
-			return (uint8_t *) (skb->data + offsetInBytes);
-		} else {
-			DPRINTK("%s() Auth payload stretches "
-				"accross contiguous memory\n", __FUNCTION__);
-			return NULL;
-		}
-	} else {
-		if (skbuffisnonlinear) {
-			offsetInBytes -= skbheadlen;
-		} else {
-			DPRINTK("%s() Offset outside of buffer boundaries\n",
-				__FUNCTION__);
-			return NULL;
-		}
-	}
-
-	/*Non Linear checks */
-	skb_shared = (struct skb_shared_info *)(skb->end);
-	if (unlikely(NULL == skb_shared)) {
-		DPRINTK("%s() skbuff shared info stucture is NULL! \n",
-			__FUNCTION__);
-		return NULL;
-	} else if ((0 != skb_shared->nr_frags) &&
-		   (skb_shared->frag_list != NULL)) {
-		DPRINTK("%s() skbuff nr_frags AND "
-			"frag_list not supported \n", __FUNCTION__);
-		return NULL;
-	}
-
-	/*TCP segmentation more likely than IP fragmentation */
-	if (likely(0 != skb_shared->nr_frags)) {
-		return icp_ocfDrvDigestSkbNRFragsCheck(skb, skb_shared,
-						       offsetInBytes,
-						       digestSizeInBytes);
-	} else if (skb_shared->frag_list != NULL) {
-		return icp_ocfDrvDigestSkbFragListCheck(skb, skb_shared,
-							offsetInBytes,
-							digestSizeInBytes);
-	} else {
-		DPRINTK("%s() skbuff is non-linear but does not show any "
-			"linked data\n", __FUNCTION__);
-		return NULL;
-	}
-
-}
-
-/* Name        : icp_ocfDrvDigestSkbNRFragsCheck
- *
- * Description : This function is used by icp_ocfDrvSkbuffDigestPointerFind to
- * process the non-linear portion of the skbuff, if the fragmentation type is
- * page fragments
- */
-static inline uint8_t *icp_ocfDrvDigestSkbNRFragsCheck(struct sk_buff *skb,
-						       struct skb_shared_info
-						       *skb_shared,
-						       int offsetInBytes,
-						       uint32_t
-						       digestSizeInBytes)
-{
-	int i = 0;
-	/*nr_frags starts from 1 */
-	if (MAX_SKB_FRAGS < skb_shared->nr_frags) {
-		DPRINTK("%s error processing skbuff "
-			"page frame -- MAX FRAGS exceeded \n", __FUNCTION__);
-		return NULL;
-	}
-
-	for (i = 0; i < skb_shared->nr_frags; i++) {
-
-		if (offsetInBytes >= skb_shared->frags[i].size) {
-			/*offset still greater than data position */
-			offsetInBytes -= skb_shared->frags[i].size;
-		} else {
-			/* found the page containing start of hash */
-
-			if (NULL == skb_shared->frags[i].page) {
-				DPRINTK("%s() Linked page is NULL!\n",
-					__FUNCTION__);
-				return NULL;
-			}
-
-			if (offsetInBytes + digestSizeInBytes >
-			    skb_shared->frags[i].size) {
-				DPRINTK("%s() Auth payload stretches accross "
-					"contiguous memory\n", __FUNCTION__);
-				return NULL;
-			} else {
-				return (uint8_t *) (skb_shared->frags[i].page +
-						    skb_shared->frags[i].
-						    page_offset +
-						    offsetInBytes);
-			}
-		}
-		/*only possible if internal page sizes are set wrong */
-		if (offsetInBytes < 0) {
-			DPRINTK("%s error processing skbuff page frame "
-				"-- offset calculation \n", __FUNCTION__);
-			return NULL;
-		}
-	}
-	/*only possible if internal page sizes are set wrong */
-	DPRINTK("%s error processing skbuff page frame "
-		"-- ran out of page fragments, remaining offset = %d \n",
-		__FUNCTION__, offsetInBytes);
-	return NULL;
-
-}
-
-/* Name        : icp_ocfDrvDigestSkbFragListCheck
- *
- * Description : This function is used by icp_ocfDrvSkbuffDigestPointerFind to 
- * process the non-linear portion of the skbuff, if the fragmentation type is 
- * a linked list
- * 
- */
-static inline uint8_t *icp_ocfDrvDigestSkbFragListCheck(struct sk_buff *skb,
-							struct skb_shared_info
-							*skb_shared,
-							int offsetInBytes,
-							uint32_t
-							digestSizeInBytes)
-{
-
-	struct sk_buff *skb_list = skb_shared->frag_list;
-	/*check added for readability */
-	if (NULL == skb_list) {
-		DPRINTK("%s error processing skbuff "
-			"-- no more list! \n", __FUNCTION__);
-		return NULL;
-	}
-
-	for (; skb_list; skb_list = skb_list->next) {
-		if (NULL == skb_list) {
-			DPRINTK("%s error processing skbuff "
-				"-- no more list! \n", __FUNCTION__);
-			return NULL;
-		}
-
-		if (offsetInBytes >= skb_list->len) {
-			offsetInBytes -= skb_list->len;
-
-		} else {
-			if (offsetInBytes + digestSizeInBytes > skb_list->len) {
-				DPRINTK("%s() Auth payload stretches accross "
-					"contiguous memory\n", __FUNCTION__);
-				return NULL;
-			} else {
-				return (uint8_t *)
-				    (skb_list->data + offsetInBytes);
-			}
-
-		}
-
-		/*This check is only needed if internal skb_list length values
-		   are set wrong. */
-		if (0 > offsetInBytes) {
-			DPRINTK("%s() error processing skbuff object -- offset "
-				"calculation \n", __FUNCTION__);
-			return NULL;
-		}
-
-	}
-
-	/*catch all for unusual for-loop exit. 
-	   This code should never be reached */
-	DPRINTK("%s() Catch-All hit! Process error.\n", __FUNCTION__);
-	return NULL;
-}
diff --git a/crypto/ocf/hifn/hifn7751.c b/crypto/ocf/hifn/hifn7751.c
index 6459f35..d554f16 100644
--- a/crypto/ocf/hifn/hifn7751.c
+++ b/crypto/ocf/hifn/hifn7751.c
@@ -46,7 +46,8 @@ __FBSDID("$FreeBSD: src/sys/dev/hifn/hifn7751.c,v 1.40 2007/03/21 03:42:49 sam E
 /*
  * Driver for various Hifn encryption processors.
  */
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -60,7 +61,6 @@ __FBSDID("$FreeBSD: src/sys/dev/hifn/hifn7751.c,v 1.40 2007/03/21 03:42:49 sam E
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/random.h>
-#include <linux/version.h>
 #include <linux/skbuff.h>
 #include <asm/io.h>
 
@@ -98,6 +98,10 @@ int hifn_maxbatch = 1;
 module_param(hifn_maxbatch, int, 0644);
 MODULE_PARM_DESC(hifn_maxbatch, "max ops to batch w/o interrupt");
 
+int hifn_cache_linesize = 0x10;
+module_param(hifn_cache_linesize, int, 0444);
+MODULE_PARM_DESC(hifn_cache_linesize, "PCI config cache line size");
+
 #ifdef MODULE_PARM
 char *hifn_pllconfig = NULL;
 MODULE_PARM(hifn_pllconfig, "s");
@@ -237,7 +241,7 @@ pci_map_skb(struct hifn_softc *sc,struct hifn_operand *buf,struct sk_buff *skb)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; ) {
 		buf->segs[buf->nsegs].ds_len = skb_shinfo(skb)->frags[i].size;
 		buf->segs[buf->nsegs].ds_addr = pci_map_single(sc->sc_pcidev,
-				page_address(skb_shinfo(skb)->frags[i].page) +
+				page_address(skb_frag_page(&skb_shinfo(skb)->frags[i])) +
 					skb_shinfo(skb)->frags[i].page_offset,
 				buf->segs[buf->nsegs].ds_len, PCI_DMA_BIDIRECTIONAL);
 		buf->mapsize += buf->segs[buf->nsegs].ds_len;
@@ -864,7 +868,9 @@ hifn_set_retry(struct hifn_softc *sc)
 	DPRINTF("%s()\n", __FUNCTION__);
 	/* NB: RETRY only responds to 8-bit reads/writes */
 	pci_write_config_byte(sc->sc_pcidev, HIFN_RETRY_TIMEOUT, 0);
-	pci_write_config_dword(sc->sc_pcidev, HIFN_TRDY_TIMEOUT, 0);
+	pci_write_config_byte(sc->sc_pcidev, HIFN_TRDY_TIMEOUT, 0);
+	/* piggy back the cache line setting here */
+	pci_write_config_byte(sc->sc_pcidev, PCI_CACHE_LINE_SIZE, hifn_cache_linesize);
 }
 
 /*
@@ -2369,11 +2375,6 @@ hifn_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 		case CRYPTO_DES_CBC:
 		case CRYPTO_3DES_CBC:
 		case CRYPTO_AES_CBC:
-			/* XXX this may read fewer, does it matter? */
-			read_random(ses->hs_iv,
-				c->cri_alg == CRYPTO_AES_CBC ?
-					HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH);
-			/*FALLTHROUGH*/
 		case CRYPTO_ARC4:
 			if (cry) {
 				DPRINTF("%s,%d: %s - EINVAL\n",__FILE__,__LINE__,__FUNCTION__);
@@ -2569,8 +2570,7 @@ hifn_process(device_t dev, struct cryptop *crp, int hint)
 				if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
 					bcopy(enccrd->crd_iv, cmd->iv, ivlen);
 				else
-					bcopy(sc->sc_sessions[session].hs_iv,
-					    cmd->iv, ivlen);
+					read_random(cmd->iv, ivlen);
 
 				if ((enccrd->crd_flags & CRD_F_IV_PRESENT)
 				    == 0) {
@@ -2775,7 +2775,7 @@ hifn_callback(struct hifn_softc *sc, struct hifn_command *cmd, u_int8_t *macbuf)
 	struct hifn_dma *dma = sc->sc_dma;
 	struct cryptop *crp = cmd->crp;
 	struct cryptodesc *crd;
-	int i, u, ivlen;
+	int i, u;
 
 	DPRINTF("%s()\n", __FUNCTION__);
 
@@ -2840,22 +2840,6 @@ hifn_callback(struct hifn_softc *sc, struct hifn_command *cmd, u_int8_t *macbuf)
 
 	hifnstats.hst_obytes += cmd->dst_mapsize;
 
-	if ((cmd->base_masks & (HIFN_BASE_CMD_CRYPT | HIFN_BASE_CMD_DECODE)) ==
-	    HIFN_BASE_CMD_CRYPT) {
-		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
-			if (crd->crd_alg != CRYPTO_DES_CBC &&
-			    crd->crd_alg != CRYPTO_3DES_CBC &&
-			    crd->crd_alg != CRYPTO_AES_CBC)
-				continue;
-			ivlen = ((crd->crd_alg == CRYPTO_AES_CBC) ?
-				HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH);
-			crypto_copydata(crp->crp_flags, crp->crp_buf,
-			    crd->crd_skip + crd->crd_len - ivlen, ivlen,
-			    cmd->softc->sc_sessions[cmd->session_num].hs_iv);
-			break;
-		}
-	}
-
 	if (macbuf != NULL) {
 		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
                         int len;
@@ -2966,5 +2950,5 @@ module_init(hifn_init);
 module_exit(hifn_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
 MODULE_DESCRIPTION("OCF driver for hifn PCI crypto devices");
diff --git a/crypto/ocf/hifn/hifn7751var.h b/crypto/ocf/hifn/hifn7751var.h
index 9a5f231..c5d30f9 100644
--- a/crypto/ocf/hifn/hifn7751var.h
+++ b/crypto/ocf/hifn/hifn7751var.h
@@ -113,7 +113,6 @@ struct hifn_dma {
 struct hifn_session {
 	int hs_used;
 	int hs_mlen;
-	u_int8_t hs_iv[HIFN_MAX_IV_LENGTH];
 };
 
 #define	HIFN_RING_SYNC(sc, r, i, f)					\
diff --git a/crypto/ocf/hifn/hifnHIPP.c b/crypto/ocf/hifn/hifnHIPP.c
index 45ad7ba..4d6950a 100644
--- a/crypto/ocf/hifn/hifnHIPP.c
+++ b/crypto/ocf/hifn/hifnHIPP.c
@@ -32,7 +32,8 @@
 /*
  * Driver for various Hifn encryption processors.
  */
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -46,7 +47,6 @@
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/random.h>
-#include <linux/version.h>
 #include <linux/skbuff.h>
 #include <linux/uio.h>
 #include <linux/sysfs.h>
diff --git a/crypto/ocf/ixp4xx/ixp4xx.c b/crypto/ocf/ixp4xx/ixp4xx.c
index fba31b0..948894a 100644
--- a/crypto/ocf/ixp4xx/ixp4xx.c
+++ b/crypto/ocf/ixp4xx/ixp4xx.c
@@ -3,8 +3,8 @@
  * This driver requires the IXP400 Access Library that is available
  * from Intel in order to operate (or compile).
  *
- * Written by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2007 David McCullough
+ * Written by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2006-2011 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  *
  * LICENSE TERMS
@@ -33,7 +33,8 @@
  * and/or fitness for purpose.
  */
 
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -373,9 +374,6 @@ ixp_freesession(device_t dev, u_int64_t tid)
 			ixCryptoAccCtxUnregister(ixp_sessions[sid]->ixp_ctx_id);
 			ixp_sessions[sid]->ixp_ctx_id = -1;
 		}
-
-		flush_scheduled_work();
-
 		kfree(ixp_sessions[sid]);
 	}
 	ixp_sessions[sid] = NULL;
@@ -448,15 +446,29 @@ ixp_q_process(struct ixp_q *q)
 	dprintk("%s(%p)\n", __FUNCTION__, q);
 
 	if (q->ixp_q_ccrd) {
+		if (q->ixp_q_ccrd->crd_flags & CRD_F_ENCRYPT) {
 		if (q->ixp_q_ccrd->crd_flags & CRD_F_IV_EXPLICIT) {
 			q->ixp_q_iv = q->ixp_q_ccrd->crd_iv;
 		} else {
 			q->ixp_q_iv = q->ixp_q_iv_data;
+				read_random(q->ixp_q_iv, ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen);
+			}
+			if ((q->ixp_q_ccrd->crd_flags & CRD_F_IV_PRESENT) == 0)
+				crypto_copyback(q->ixp_q_crp->crp_flags, q->ixp_q_crp->crp_buf,
+						q->ixp_q_ccrd->crd_inject,
+						ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen,
+						(caddr_t) q->ixp_q_iv);
+		} else {
+			if (q->ixp_q_ccrd->crd_flags & CRD_F_IV_EXPLICIT)
+				q->ixp_q_iv = q->ixp_q_ccrd->crd_iv;
+			else {
+				q->ixp_q_iv = q->ixp_q_iv_data;
 			crypto_copydata(q->ixp_q_crp->crp_flags, q->ixp_q_crp->crp_buf,
 					q->ixp_q_ccrd->crd_inject,
 					ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen,
 					(caddr_t) q->ixp_q_iv);
 		}
+		}
 
 		if (q->ixp_q_acrd) {
 			auth_off = q->ixp_q_acrd->crd_skip;
@@ -595,8 +607,7 @@ ixp_process_pending(void *arg)
 static void
 ixp_process_pending_wq(struct work_struct *work)
 {
-	struct ixp_data *ixp = container_of(work, struct ixp_data,
-								ixp_pending_work);
+	struct ixp_data *ixp = container_of(work, struct ixp_data, ixp_pending_work);
 	ixp_process_pending(ixp);
 }
 #endif
diff --git a/crypto/ocf/kirkwood/cesa/AES/mvAes.h b/crypto/ocf/kirkwood/cesa/AES/mvAes.h
index 07a8601..969727f 100644
--- a/crypto/ocf/kirkwood/cesa/AES/mvAes.h
+++ b/crypto/ocf/kirkwood/cesa/AES/mvAes.h
@@ -9,14 +9,14 @@
 
       April 15, 1998
 
-    This sample is to assist implementers developing to the Cryptographic 
-API Profile for AES Candidate Algorithm Submissions.  Please consult this 
+    This sample is to assist implementers developing to the Cryptographic
+API Profile for AES Candidate Algorithm Submissions.  Please consult this
 document as a cross-reference.
 
     ANY CHANGES, WHERE APPROPRIATE, TO INFORMATION PROVIDED IN THIS FILE
 MUST BE DOCUMENTED.  CHANGES ARE ONLY APPROPRIATE WHERE SPECIFIED WITH
-THE STRING "CHANGE POSSIBLE".  FUNCTION CALLS AND THEIR PARAMETERS CANNOT 
-BE CHANGED.  STRUCTURES CAN BE ALTERED TO ALLOW IMPLEMENTERS TO INCLUDE 
+THE STRING "CHANGE POSSIBLE".  FUNCTION CALLS AND THEIR PARAMETERS CANNOT
+BE CHANGED.  STRUCTURES CAN BE ALTERED TO ALLOW IMPLEMENTERS TO INCLUDE
 IMPLEMENTATION SPECIFIC INFORMATION.
 */
 
@@ -30,33 +30,33 @@ IMPLEMENTATION SPECIFIC INFORMATION.
 /*  Error Codes - CHANGE POSSIBLE: inclusion of additional error codes  */
 
 /*  Key direction is invalid, e.g., unknown value */
-#define     AES_BAD_KEY_DIR        -1  
+#define     AES_BAD_KEY_DIR        -1
 
 /*  Key material not of correct length */
-#define     AES_BAD_KEY_MAT        -2  
+#define     AES_BAD_KEY_MAT        -2
 
 /*  Key passed is not valid  */
-#define     AES_BAD_KEY_INSTANCE   -3  
+#define     AES_BAD_KEY_INSTANCE   -3
 
 /*  Params struct passed to cipherInit invalid */
-#define     AES_BAD_CIPHER_MODE    -4  
+#define     AES_BAD_CIPHER_MODE    -4
 
 /*  Cipher in wrong state (e.g., not initialized) */
-#define     AES_BAD_CIPHER_STATE   -5  
+#define     AES_BAD_CIPHER_STATE   -5
 
-#define     AES_BAD_CIPHER_INSTANCE   -7 
+#define     AES_BAD_CIPHER_INSTANCE   -7
 
 
 /*  Function protoypes  */
 /*  CHANGED: makeKey(): parameter blockLen added
                         this parameter is absolutely necessary if you want to
-			setup the round keys in a variable block length setting 
-	     cipherInit(): parameter blockLen added (for obvious reasons)		
+			setup the round keys in a variable block length setting
+	     cipherInit(): parameter blockLen added (for obvious reasons)
  */
 int     aesMakeKey(MV_U8 *expandedKey, MV_U8 *keyMaterial, int keyLen, int blockLen);
-int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLen, 
+int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLen,
                     MV_U32 *plain, int numBlocks, MV_U32 *cipher);
-int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLen, 
+int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLen,
                     MV_U32 *plain, int numBlocks, MV_U32 *cipher);
 
 
diff --git a/crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c b/crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c
index a65dc28..f71201e 100644
--- a/crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c
+++ b/crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c
@@ -23,14 +23,14 @@ void InvMixColumn(MV_U8 a[4][MAXBC]);
 
 
 #define mul(aa, bb) (mask[bb] & Alogtable[aa + Logtable[bb]])
-                         
+
 MV_U8 mul1(MV_U8 aa, MV_U8 bb)
 {
     return mask[bb] & Alogtable[aa + Logtable[bb]];
 }
 
 
-void KeyAddition(MV_U8 a[4][MAXBC], MV_U8 rk[4][MAXBC], MV_U8 BC) 
+void KeyAddition(MV_U8 a[4][MAXBC], MV_U8 rk[4][MAXBC], MV_U8 BC)
 {
 	/* Exor corresponding text input and round key input bytes
 	 */
@@ -46,7 +46,7 @@ void ShiftRow128Enc(MV_U8 a[4][MAXBC]) {
 	 * The other three rows are shifted a variable amount
 	 */
 	MV_U8 tmp[MAXBC];
-	
+
     tmp[0] = a[1][1];
     tmp[1] = a[1][2];
     tmp[2] = a[1][3];
@@ -83,14 +83,14 @@ void ShiftRow128Enc(MV_U8 a[4][MAXBC]) {
     a[3][2] = tmp[2];
     a[3][3] = tmp[3];
     */
-}  
+}
 
 void ShiftRow128Dec(MV_U8 a[4][MAXBC]) {
 	/* Row 0 remains unchanged
 	 * The other three rows are shifted a variable amount
 	 */
    	MV_U8 tmp[MAXBC];
-	
+
     tmp[0] = a[1][3];
     tmp[1] = a[1][0];
     tmp[2] = a[1][1];
@@ -129,24 +129,24 @@ void ShiftRow128Dec(MV_U8 a[4][MAXBC]) {
     a[3][2] = tmp[2];
     a[3][3] = tmp[3];
     */
-}  
+}
 
 void Substitution(MV_U8 a[4][MAXBC], MV_U8 box[256]) {
 	/* Replace every byte of the input by the byte at that place
 	 * in the nonlinear S-box
 	 */
 	int i, j;
-	
+
 	for(i = 0; i < 4; i++)
 		for(j = 0; j < 4; j++) a[i][j] = box[a[i][j]] ;
 }
-   
+
 void MixColumn(MV_U8 a[4][MAXBC], MV_U8 rk[4][MAXBC]) {
         /* Mix the four bytes of every column in a linear way
 	 */
 	MV_U8 b[4][MAXBC];
 	int i, j;
-		
+
 	for(j = 0; j < 4; j++){
         b[0][j] = mul(25,a[0][j]) ^ mul(1,a[1][j]) ^ a[2][j] ^ a[3][j];
         b[1][j] = mul(25,a[1][j]) ^ mul(1,a[2][j]) ^ a[3][j] ^ a[0][j];
@@ -164,7 +164,7 @@ void InvMixColumn(MV_U8 a[4][MAXBC]) {
 	 */
 	MV_U8 b[4][MAXBC];
 	int i, j;
-	
+
 	for(j = 0; j < 4; j++){
         b[0][j] = mul(223,a[0][j]) ^ mul(104,a[1][j]) ^ mul(238,a[2][j]) ^ mul(199,a[3][j]);
         b[1][j] = mul(223,a[1][j]) ^ mul(104,a[2][j]) ^ mul(238,a[3][j]) ^ mul(199,a[0][j]);
@@ -176,14 +176,14 @@ void InvMixColumn(MV_U8 a[4][MAXBC]) {
         ((MV_U32*)(&(a[i][0])))[0] = ((MV_U32*)(&(b[i][0])))[0];
 }
 
-int rijndaelKeySched (MV_U8 k[4][MAXKC], int keyBits, int blockBits, MV_U8 W[MAXROUNDS+1][4][MAXBC]) 
+int rijndaelKeySched (MV_U8 k[4][MAXKC], int keyBits, int blockBits, MV_U8 W[MAXROUNDS+1][4][MAXBC])
 {
 	/* Calculate the necessary round keys
 	 * The number of calculations depends on keyBits and blockBits
 	 */
 	int KC, BC, ROUNDS;
 	int i, j, t, rconpointer = 0;
-	MV_U8 tk[4][MAXKC];   
+	MV_U8 tk[4][MAXKC];
 
 	switch (keyBits) {
 	case 128: KC = 4; break;
@@ -206,7 +206,7 @@ int rijndaelKeySched (MV_U8 k[4][MAXKC], int keyBits, int blockBits, MV_U8 W[MAX
 	default : return (-3); /* this cannot happen */
 	}
 
-	
+
 	for(j = 0; j < KC; j++)
 		for(i = 0; i < 4; i++)
 			tk[i][j] = k[i][j];
@@ -214,7 +214,7 @@ int rijndaelKeySched (MV_U8 k[4][MAXKC], int keyBits, int blockBits, MV_U8 W[MAX
 	/* copy values into round key array */
 	for(j = 0; (j < KC) && (t < (ROUNDS+1)*BC); j++, t++)
 		for(i = 0; i < 4; i++) W[t / BC][i][t % BC] = tk[i][j];
-		
+
 	while (t < (ROUNDS+1)*BC) { /* while not enough round key material calculated */
 		/* calculate new values */
 		for(i = 0; i < 4; i++)
@@ -234,16 +234,16 @@ int rijndaelKeySched (MV_U8 k[4][MAXKC], int keyBits, int blockBits, MV_U8 W[MAX
 	/* copy values into round key array */
 	for(j = 0; (j < KC) && (t < (ROUNDS+1)*BC); j++, t++)
 		for(i = 0; i < 4; i++) W[t / BC][i][t % BC] = tk[i][j];
-	}		
+	}
 
 	return 0;
 }
-      
-        
+
+
 
 int rijndaelEncrypt128(MV_U8 a[4][MAXBC], MV_U8 rk[MAXROUNDS+1][4][MAXBC], int rounds)
 {
-	/* Encryption of one block. 
+	/* Encryption of one block.
 	 */
 	int r, BC, ROUNDS;
 
@@ -253,7 +253,7 @@ int rijndaelEncrypt128(MV_U8 a[4][MAXBC], MV_U8 rk[MAXROUNDS+1][4][MAXBC], int r
 	/* begin with a key addition
 	 */
 
-	KeyAddition(a,rk[0],BC); 
+	KeyAddition(a,rk[0],BC);
 
     /* ROUNDS-1 ordinary rounds
 	 */
@@ -263,7 +263,7 @@ int rijndaelEncrypt128(MV_U8 a[4][MAXBC], MV_U8 rk[MAXROUNDS+1][4][MAXBC], int r
 		MixColumn(a, rk[r]);
 		/*KeyAddition(a,rk[r],BC);*/
 	}
-	
+
 	/* Last round is special: there is no MixColumn
 	 */
 	Substitution(a,S);
@@ -271,19 +271,19 @@ int rijndaelEncrypt128(MV_U8 a[4][MAXBC], MV_U8 rk[MAXROUNDS+1][4][MAXBC], int r
 	KeyAddition(a,rk[ROUNDS],BC);
 
 	return 0;
-}   
+}
 
 
 int rijndaelDecrypt128(MV_U8 a[4][MAXBC], MV_U8 rk[MAXROUNDS+1][4][MAXBC], int rounds)
 {
 	int r, BC, ROUNDS;
-	
+
     BC = 4;
     ROUNDS = rounds;
 
 	/* To decrypt: apply the inverse operations of the encrypt routine,
 	 *             in opposite order
-	 * 
+	 *
 	 * (KeyAddition is an involution: it 's equal to its inverse)
 	 * (the inverse of Substitution with table S is Substitution with the inverse table of S)
 	 * (the inverse of Shiftrow is Shiftrow over a suitable distance)
@@ -294,23 +294,23 @@ int rijndaelDecrypt128(MV_U8 a[4][MAXBC], MV_U8 rk[MAXROUNDS+1][4][MAXBC], int r
 	 *   with extra KeyAddition
 	 */
 	KeyAddition(a,rk[ROUNDS],BC);
-    ShiftRow128Dec(a);               
+    ShiftRow128Dec(a);
 	Substitution(a,Si);
-	
+
 	/* ROUNDS-1 ordinary rounds
 	 */
 	for(r = ROUNDS-1; r > 0; r--) {
 		KeyAddition(a,rk[r],BC);
-		InvMixColumn(a);      
-		ShiftRow128Dec(a);               
+		InvMixColumn(a);
+		ShiftRow128Dec(a);
 		Substitution(a,Si);
 
 	}
-	
+
 	/* End with the extra key addition
 	 */
-	
-	KeyAddition(a,rk[0],BC);    
+
+	KeyAddition(a,rk[0],BC);
 
 	return 0;
 }
diff --git a/crypto/ocf/kirkwood/cesa/AES/mvAesApi.c b/crypto/ocf/kirkwood/cesa/AES/mvAesApi.c
index b432dc6..6127883 100644
--- a/crypto/ocf/kirkwood/cesa/AES/mvAesApi.c
+++ b/crypto/ocf/kirkwood/cesa/AES/mvAesApi.c
@@ -27,29 +27,29 @@ int     aesMakeKey(MV_U8 *expandedKey, MV_U8 *keyMaterial, int keyLen, int block
 	MV_U8   k[4][MAXKC];
     MV_U8   j;
 	int     i, rounds, KC;
-	
-	if (expandedKey == NULL) 
+
+	if (expandedKey == NULL)
     {
 		return AES_BAD_KEY_INSTANCE;
 	}
 
-	if (!((keyLen == 128) || (keyLen == 192) || (keyLen == 256))) 
-    { 
+	if (!((keyLen == 128) || (keyLen == 192) || (keyLen == 256)))
+    {
 		return AES_BAD_KEY_MAT;
 	}
 
-	if (keyMaterial == NULL) 
+	if (keyMaterial == NULL)
     {
 		return AES_BAD_KEY_MAT;
 	}
 
-	/* initialize key schedule: */ 
- 	for(i=0; i<keyLen/8; i++) 
+	/* initialize key schedule: */
+ 	for(i=0; i<keyLen/8; i++)
     {
 		j = keyMaterial[i];
-		k[i % 4][i / 4] = j; 
-	}	
-	
+		k[i % 4][i / 4] = j;
+	}
+
 	rijndaelKeySched (k, keyLen, blockLen, W);
 #ifdef MV_AES_DEBUG
     {
@@ -66,28 +66,28 @@ int     aesMakeKey(MV_U8 *expandedKey, MV_U8 *keyMaterial, int keyLen, int block
             mvOsPrintf("\n Round #%02d: ", i);
             for(x=0; x<MAXBC; x++)
             {
-                mvOsPrintf("%02x%02x%02x%02x ", 
+                mvOsPrintf("%02x%02x%02x%02x ",
                     W[i][0][x], W[i][1][x], W[i][2][x], W[i][3][x]);
             }
             mvOsPrintf("\n");
         }
     }
 #endif /* MV_AES_DEBUG */
-  	switch (keyLen) 
+  	switch (keyLen)
     {
-	    case 128: 
+	    case 128:
             rounds = 10;
-            KC = 4; 
+            KC = 4;
             break;
-	    case 192: 
+	    case 192:
             rounds = 12;
-            KC = 6; 
+            KC = 6;
             break;
-	    case 256: 
+	    case 256:
             rounds = 14;
-            KC = 8; 
+            KC = 8;
             break;
-	    default : 
+	    default :
             return (-1);
 	}
 
@@ -106,11 +106,11 @@ int     aesMakeKey(MV_U8 *expandedKey, MV_U8 *keyMaterial, int keyLen, int block
         }
     }
 
-	
+
 	return 0;
 }
 
-int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLen, 
+int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLen,
                         MV_U32 *plain, int numBlocks, MV_U32 *cipher)
 {
 	int     i, j, t;
@@ -122,7 +122,7 @@ int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
     outBuffer = (char*)cipher;
 
         /* check parameter consistency: */
-    if( (expandedKey == NULL) || ((keyLen != 128) && (keyLen != 192) && (keyLen != 256))) 
+    if( (expandedKey == NULL) || ((keyLen != 128) && (keyLen != 192) && (keyLen != 256)))
     {
         return AES_BAD_KEY_MAT;
     }
@@ -131,7 +131,7 @@ int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
         return AES_BAD_CIPHER_STATE;
     }
 
-	switch (keyLen) 
+	switch (keyLen)
     {
 	    case 128: rounds = 10; break;
 	    case 192: rounds = 12; break;
@@ -139,21 +139,21 @@ int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
 	    default : return (-3); /* this cannot happen */
 	}
 
-	
-	switch (mode) 
+
+	switch (mode)
     {
-	    case MODE_ECB: 
-		    for (i = 0; i < numBlocks; i++) 
+	    case MODE_ECB:
+		    for (i = 0; i < numBlocks; i++)
             {
-			    for (j = 0; j < 4; j++) 
+			    for (j = 0; j < 4; j++)
                 {
 				    for(t = 0; t < 4; t++)
 				        /* parse input stream into rectangular array */
 					    block[t][j] = input[16*i+4*j+t] & 0xFF;
-			    }                           
+			    }
 			    rijndaelEncrypt128(block, (MV_U8 (*)[4][MAXBC])expandedKey, rounds);
-			    for (j = 0; j < 4; j++) 
-                {           
+			    for (j = 0; j < 4; j++)
+                {
 				    /* parse rectangular array into output ciphertext bytes */
 				    for(t = 0; t < 4; t++)
                         outBuffer[16*i+4*j+t] = (MV_U8) block[t][j];
@@ -161,25 +161,25 @@ int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
 			    }
 		    }
 		    break;
-		
+
 	    case MODE_CBC:
-		    for (j = 0; j < 4; j++) 
+		    for (j = 0; j < 4; j++)
             {
 			    for(t = 0; t < 4; t++)
 			    /* parse initial value into rectangular array */
 					block[t][j] = IV[t+4*j] & 0xFF;
 			}
-		    for (i = 0; i < numBlocks; i++) 
+		    for (i = 0; i < numBlocks; i++)
             {
-			    for (j = 0; j < 4; j++) 
+			    for (j = 0; j < 4; j++)
                 {
 				    for(t = 0; t < 4; t++)
-				        /* parse input stream into rectangular array and exor with 
+				        /* parse input stream into rectangular array and exor with
 				        IV or the previous ciphertext */
 					    block[t][j] ^= input[16*i+4*j+t] & 0xFF;
 			    }
 			    rijndaelEncrypt128(block, (MV_U8 (*)[4][MAXBC])expandedKey, rounds);
-			    for (j = 0; j < 4; j++) 
+			    for (j = 0; j < 4; j++)
                 {
 				    /* parse rectangular array into output ciphertext bytes */
 				    for(t = 0; t < 4; t++)
@@ -187,26 +187,26 @@ int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
 			    }
 		    }
 		    break;
-	
+
 	    default: return AES_BAD_CIPHER_STATE;
 	}
-	
+
 	return 0;
 }
 
-int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLen, 
+int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLen,
                             MV_U32 *srcData, int numBlocks, MV_U32 *dstData)
 {
 	int     i, j, t;
 	MV_U8   block[4][MAXBC];
-    MV_U8   iv[4][MAXBC];    
+    MV_U8   iv[4][MAXBC];
     int     rounds;
     char    *input, *outBuffer;
 
     input = (char*)srcData;
     outBuffer = (char*)dstData;
 
-    if (expandedKey == NULL) 
+    if (expandedKey == NULL)
     {
 		return AES_BAD_KEY_MAT;
 	}
@@ -216,12 +216,12 @@ int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
     {
         return AES_BAD_KEY_MAT;
     }
-    if ((mode != MODE_ECB && mode != MODE_CBC)) 
+    if ((mode != MODE_ECB && mode != MODE_CBC))
     {
         return AES_BAD_CIPHER_STATE;
     }
 
-	switch (keyLen) 
+	switch (keyLen)
     {
 	    case 128: rounds = 10; break;
 	    case 192: rounds = 12; break;
@@ -229,13 +229,13 @@ int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
 	    default : return (-3); /* this cannot happen */
 	}
 
-	
-	switch (mode) 
+
+	switch (mode)
     {
-	    case MODE_ECB: 
-		    for (i = 0; i < numBlocks; i++) 
+	    case MODE_ECB:
+		    for (i = 0; i < numBlocks; i++)
             {
-			    for (j = 0; j < 4; j++) 
+			    for (j = 0; j < 4; j++)
                 {
 				    for(t = 0; t < 4; t++)
                     {
@@ -244,7 +244,7 @@ int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
                     }
 			    }
 			    rijndaelDecrypt128(block, (MV_U8 (*)[4][MAXBC])expandedKey, rounds);
-			    for (j = 0; j < 4; j++) 
+			    for (j = 0; j < 4; j++)
                 {
 				    /* parse rectangular array into output ciphertext bytes */
 				    for(t = 0; t < 4; t++)
@@ -252,10 +252,10 @@ int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
 			    }
 		    }
 		    break;
-		
+
 	    case MODE_CBC:
 		    /* first block */
-		    for (j = 0; j < 4; j++) 
+		    for (j = 0; j < 4; j++)
             {
 			    for(t = 0; t < 4; t++)
                 {
@@ -265,8 +265,8 @@ int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
                 }
 		    }
 		    rijndaelDecrypt128(block, (MV_U8 (*)[4][MAXBC])expandedKey, rounds);
-		
-		    for (j = 0; j < 4; j++) 
+
+		    for (j = 0; j < 4; j++)
             {
 			    /* exor the IV and parse rectangular array into output ciphertext bytes */
 			    for(t = 0; t < 4; t++)
@@ -275,11 +275,11 @@ int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
                     IV[t+4*j] = iv[t][j];
                 }
 		    }
-		
+
 		    /* next blocks */
-		    for (i = 1; i < numBlocks; i++) 
+		    for (i = 1; i < numBlocks; i++)
             {
-			    for (j = 0; j < 4; j++) 
+			    for (j = 0; j < 4; j++)
                 {
 				    for(t = 0; t < 4; t++)
                     {
@@ -289,10 +289,10 @@ int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
                     }
 			    }
 			    rijndaelDecrypt128(block, (MV_U8 (*)[4][MAXBC])expandedKey, rounds);
-			
-			    for (j = 0; j < 4; j++) 
+
+			    for (j = 0; j < 4; j++)
                 {
-				    /* exor previous ciphertext block and parse rectangular array 
+				    /* exor previous ciphertext block and parse rectangular array
 				       into output ciphertext bytes */
 				    for(t = 0; t < 4; t++)
                     {
@@ -302,10 +302,10 @@ int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
 			    }
 		    }
 		    break;
-	
+
 	    default: return AES_BAD_CIPHER_STATE;
 	}
-	
+
 	return 0;
 }
 
diff --git a/crypto/ocf/kirkwood/cesa/AES/mvAesBoxes.dat b/crypto/ocf/kirkwood/cesa/AES/mvAesBoxes.dat
new file mode 100644
index 0000000..6c12b06
--- /dev/null
+++ b/crypto/ocf/kirkwood/cesa/AES/mvAesBoxes.dat
@@ -0,0 +1,123 @@
+static MV_U8 mask[256] = {
+0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+
+static MV_U8 Logtable[256] = {
+  0,   0,  25,   1,  50,   2,  26, 198,  75, 199,  27, 104,  51, 238, 223,   3,
+100,   4, 224,  14,  52, 141, 129, 239,  76, 113,   8, 200, 248, 105,  28, 193,
+125, 194,  29, 181, 249, 185,  39, 106,  77, 228, 166, 114, 154, 201,   9, 120,
+101,  47, 138,   5,  33,  15, 225,  36,  18, 240, 130,  69,  53, 147, 218, 142,
+150, 143, 219, 189,  54, 208, 206, 148,  19,  92, 210, 241,  64,  70, 131,  56,
+102, 221, 253,  48, 191,   6, 139,  98, 179,  37, 226, 152,  34, 136, 145,  16,
+126, 110,  72, 195, 163, 182,  30,  66,  58, 107,  40,  84, 250, 133,  61, 186,
+ 43, 121,  10,  21, 155, 159,  94, 202,  78, 212, 172, 229, 243, 115, 167,  87,
+175,  88, 168,  80, 244, 234, 214, 116,  79, 174, 233, 213, 231, 230, 173, 232,
+ 44, 215, 117, 122, 235,  22,  11, 245,  89, 203,  95, 176, 156, 169,  81, 160,
+127,  12, 246, 111,  23, 196,  73, 236, 216,  67,  31,  45, 164, 118, 123, 183,
+204, 187,  62,  90, 251,  96, 177, 134,  59,  82, 161, 108, 170,  85,  41, 157,
+151, 178, 135, 144,  97, 190, 220, 252, 188, 149, 207, 205,  55,  63,  91, 209,
+ 83,  57, 132,  60,  65, 162, 109,  71,  20,  42, 158,  93,  86, 242, 211, 171,
+ 68,  17, 146, 217,  35,  32,  46, 137, 180, 124, 184,  38, 119, 153, 227, 165,
+103,  74, 237, 222, 197,  49, 254,  24,  13,  99, 140, 128, 192, 247, 112,   7,
+};
+
+static MV_U8 Alogtable[512] = {
+  1,   3,   5,  15,  17,  51,  85, 255,  26,  46, 114, 150, 161, 248,  19,  53,
+ 95, 225,  56,  72, 216, 115, 149, 164, 247,   2,   6,  10,  30,  34, 102, 170,
+229,  52,  92, 228,  55,  89, 235,  38, 106, 190, 217, 112, 144, 171, 230,  49,
+ 83, 245,   4,  12,  20,  60,  68, 204,  79, 209, 104, 184, 211, 110, 178, 205,
+ 76, 212, 103, 169, 224,  59,  77, 215,  98, 166, 241,   8,  24,  40, 120, 136,
+131, 158, 185, 208, 107, 189, 220, 127, 129, 152, 179, 206,  73, 219, 118, 154,
+181, 196,  87, 249,  16,  48,  80, 240,  11,  29,  39, 105, 187, 214,  97, 163,
+254,  25,  43, 125, 135, 146, 173, 236,  47, 113, 147, 174, 233,  32,  96, 160,
+251,  22,  58,  78, 210, 109, 183, 194,  93, 231,  50,  86, 250,  21,  63,  65,
+195,  94, 226,  61,  71, 201,  64, 192,  91, 237,  44, 116, 156, 191, 218, 117,
+159, 186, 213, 100, 172, 239,  42, 126, 130, 157, 188, 223, 122, 142, 137, 128,
+155, 182, 193,  88, 232,  35, 101, 175, 234,  37, 111, 177, 200,  67, 197,  84,
+252,  31,  33,  99, 165, 244,   7,   9,  27,  45, 119, 153, 176, 203,  70, 202,
+ 69, 207,  74, 222, 121, 139, 134, 145, 168, 227,  62,  66, 198,  81, 243,  14,
+ 18,  54,  90, 238,  41, 123, 141, 140, 143, 138, 133, 148, 167, 242,  13,  23,
+ 57,  75, 221, 124, 132, 151, 162, 253,  28,  36, 108, 180, 199,  82, 246,   1,
+
+       3,   5,  15,  17,  51,  85, 255,  26,  46, 114, 150, 161, 248,  19,  53,
+ 95, 225,  56,  72, 216, 115, 149, 164, 247,   2,   6,  10,  30,  34, 102, 170,
+229,  52,  92, 228,  55,  89, 235,  38, 106, 190, 217, 112, 144, 171, 230,  49,
+ 83, 245,   4,  12,  20,  60,  68, 204,  79, 209, 104, 184, 211, 110, 178, 205,
+ 76, 212, 103, 169, 224,  59,  77, 215,  98, 166, 241,   8,  24,  40, 120, 136,
+131, 158, 185, 208, 107, 189, 220, 127, 129, 152, 179, 206,  73, 219, 118, 154,
+181, 196,  87, 249,  16,  48,  80, 240,  11,  29,  39, 105, 187, 214,  97, 163,
+254,  25,  43, 125, 135, 146, 173, 236,  47, 113, 147, 174, 233,  32,  96, 160,
+251,  22,  58,  78, 210, 109, 183, 194,  93, 231,  50,  86, 250,  21,  63,  65,
+195,  94, 226,  61,  71, 201,  64, 192,  91, 237,  44, 116, 156, 191, 218, 117,
+159, 186, 213, 100, 172, 239,  42, 126, 130, 157, 188, 223, 122, 142, 137, 128,
+155, 182, 193,  88, 232,  35, 101, 175, 234,  37, 111, 177, 200,  67, 197,  84,
+252,  31,  33,  99, 165, 244,   7,   9,  27,  45, 119, 153, 176, 203,  70, 202,
+ 69, 207,  74, 222, 121, 139, 134, 145, 168, 227,  62,  66, 198,  81, 243,  14,
+ 18,  54,  90, 238,  41, 123, 141, 140, 143, 138, 133, 148, 167, 242,  13,  23,
+ 57,  75, 221, 124, 132, 151, 162, 253,  28,  36, 108, 180, 199,  82, 246,   1,
+
+};
+
+static MV_U8 S[256] = {
+ 99, 124, 119, 123, 242, 107, 111, 197,  48,   1, 103,  43, 254, 215, 171, 118,
+202, 130, 201, 125, 250,  89,  71, 240, 173, 212, 162, 175, 156, 164, 114, 192,
+183, 253, 147,  38,  54,  63, 247, 204,  52, 165, 229, 241, 113, 216,  49,  21,
+  4, 199,  35, 195,  24, 150,   5, 154,   7,  18, 128, 226, 235,  39, 178, 117,
+  9, 131,  44,  26,  27, 110,  90, 160,  82,  59, 214, 179,  41, 227,  47, 132,
+ 83, 209,   0, 237,  32, 252, 177,  91, 106, 203, 190,  57,  74,  76,  88, 207,
+208, 239, 170, 251,  67,  77,  51, 133,  69, 249,   2, 127,  80,  60, 159, 168,
+ 81, 163,  64, 143, 146, 157,  56, 245, 188, 182, 218,  33,  16, 255, 243, 210,
+205,  12,  19, 236,  95, 151,  68,  23, 196, 167, 126,  61, 100,  93,  25, 115,
+ 96, 129,  79, 220,  34,  42, 144, 136,  70, 238, 184,  20, 222,  94,  11, 219,
+224,  50,  58,  10,  73,   6,  36,  92, 194, 211, 172,  98, 145, 149, 228, 121,
+231, 200,  55, 109, 141, 213,  78, 169, 108,  86, 244, 234, 101, 122, 174,   8,
+186, 120,  37,  46,  28, 166, 180, 198, 232, 221, 116,  31,  75, 189, 139, 138,
+112,  62, 181, 102,  72,   3, 246,  14,  97,  53,  87, 185, 134, 193,  29, 158,
+225, 248, 152,  17, 105, 217, 142, 148, 155,  30, 135, 233, 206,  85,  40, 223,
+140, 161, 137,  13, 191, 230,  66, 104,  65, 153,  45,  15, 176,  84, 187,  22,
+};
+
+static MV_U8 Si[256] = {
+ 82,   9, 106, 213,  48,  54, 165,  56, 191,  64, 163, 158, 129, 243, 215, 251,
+124, 227,  57, 130, 155,  47, 255, 135,  52, 142,  67,  68, 196, 222, 233, 203,
+ 84, 123, 148,  50, 166, 194,  35,  61, 238,  76, 149,  11,  66, 250, 195,  78,
+  8,  46, 161, 102,  40, 217,  36, 178, 118,  91, 162,  73, 109, 139, 209,  37,
+114, 248, 246, 100, 134, 104, 152,  22, 212, 164,  92, 204,  93, 101, 182, 146,
+108, 112,  72,  80, 253, 237, 185, 218,  94,  21,  70,  87, 167, 141, 157, 132,
+144, 216, 171,   0, 140, 188, 211,  10, 247, 228,  88,   5, 184, 179,  69,   6,
+208,  44,  30, 143, 202,  63,  15,   2, 193, 175, 189,   3,   1,  19, 138, 107,
+ 58, 145,  17,  65,  79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115,
+150, 172, 116,  34, 231, 173,  53, 133, 226, 249,  55, 232,  28, 117, 223, 110,
+ 71, 241,  26, 113,  29,  41, 197, 137, 111, 183,  98,  14, 170,  24, 190,  27,
+252,  86,  62,  75, 198, 210, 121,  32, 154, 219, 192, 254, 120, 205,  90, 244,
+ 31, 221, 168,  51, 136,   7, 199,  49, 177,  18,  16,  89,  39, 128, 236,  95,
+ 96,  81, 127, 169,  25, 181,  74,  13,  45, 229, 122, 159, 147, 201, 156, 239,
+160, 224,  59,  77, 174,  42, 245, 176, 200, 235, 187,  60, 131,  83, 153,  97,
+ 23,  43,   4, 126, 186, 119, 214,  38, 225, 105,  20,  99,  85,  33,  12, 125,
+};
+
+/*
+static MV_U8 iG[4][4] = {
+{0x0e, 0x09, 0x0d, 0x0b},
+{0x0b, 0x0e, 0x09, 0x0d},
+{0x0d, 0x0b, 0x0e, 0x09},
+{0x09, 0x0d, 0x0b, 0x0e},
+};
+*/
+static MV_U32 rcon[30] = {
+  0x01,0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, };
diff --git a/crypto/ocf/kirkwood/cesa/mvCesa.c b/crypto/ocf/kirkwood/cesa/mvCesa.c
index 17ab086..61bcf5d 100644
--- a/crypto/ocf/kirkwood/cesa/mvCesa.c
+++ b/crypto/ocf/kirkwood/cesa/mvCesa.c
@@ -127,7 +127,7 @@ static INLINE void      mvCesaSramDescrBuild(MV_U32 config, int frag,
 
 static INLINE void      mvCesaSramSaUpdate(short sid, MV_DMA_DESC *pDmaDesc);
 
-static INLINE int       mvCesaDmaCopyPrepare(MV_CESA_MBUF* pMbuf, MV_U8* pSramBuf, 
+static INLINE int       mvCesaDmaCopyPrepare(MV_CESA_MBUF* pMbuf, MV_U8* pSramBuf,
                                 MV_DMA_DESC* pDmaDesc, MV_BOOL isToMbuf,
                                 int offset, int copySize, MV_BOOL skipFlush);
 
@@ -149,7 +149,7 @@ static MV_STATUS   mvCesaFragReqProcess(MV_CESA_REQ* pReq, MV_U8 frag);
 static INLINE MV_STATUS mvCesaParamCheck(MV_CESA_SA* pSA, MV_CESA_COMMAND *pCmd, MV_U8* pFixOffset);
 static INLINE MV_STATUS mvCesaFragParamCheck(MV_CESA_SA* pSA, MV_CESA_COMMAND *pCmd);
 
-static INLINE void      mvCesaFragSizeFind(MV_CESA_SA* pSA, MV_CESA_REQ* pReq, 
+static INLINE void      mvCesaFragSizeFind(MV_CESA_SA* pSA, MV_CESA_REQ* pReq,
                                int cryptoOffset, int macOffset,
                                int* pCopySize, int* pCryptoDataSize, int* pMacDataSize);
 static MV_STATUS        mvCesaMbufCacheUnmap(MV_CESA_MBUF* pMbuf, int offset, int size);
@@ -200,16 +200,16 @@ static INLINE void mvCesaReqProcessStart(MV_CESA_REQ* pReq)
 #if (MV_CESA_VERSION >= 2)
     /* Enable TDMA engine */
     MV_REG_WRITE(MV_CESA_TDMA_CURR_DESC_PTR_REG, 0);
-    MV_REG_WRITE(MV_CESA_TDMA_NEXT_DESC_PTR_REG, 
+    MV_REG_WRITE(MV_CESA_TDMA_NEXT_DESC_PTR_REG,
             (MV_U32)mvCesaVirtToPhys(&pReq->dmaDescBuf, pReq->dma[frag].pDmaFirst));
 #else
     /* Enable IDMA engine */
     MV_REG_WRITE(IDMA_CURR_DESC_PTR_REG(0), 0);
-    MV_REG_WRITE(IDMA_NEXT_DESC_PTR_REG(0), 
+    MV_REG_WRITE(IDMA_NEXT_DESC_PTR_REG(0),
             (MV_U32)mvCesaVirtToPhys(&pReq->dmaDescBuf, pReq->dma[frag].pDmaFirst));
 #endif /* MV_CESA_VERSION >= 2 */
 
-#if defined(MV_BRIDGE_SYNC_REORDER) 
+#if defined(MV_BRIDGE_SYNC_REORDER)
     mvOsBridgeReorderWA();
 #endif
 
@@ -232,7 +232,7 @@ static INLINE void mvCesaReqProcessStart(MV_CESA_REQ* pReq)
 *       numOfSession    - maximum number of supported sessions
 *       queueDepth      - number of elements in the request queue.
 *       pSramBase       - virtual address of Sram
-*	osHandle	- A handle used by the OS to allocate memory for the 
+*	osHandle	- A handle used by the OS to allocate memory for the
 *			  module (Passed to the OS Services layer)
 *
 * RETURN:
@@ -268,22 +268,22 @@ MV_STATUS mvCesaHalInit (int numOfSession, int queueDepth, char* pSramBase, MV_U
     cesaMaxSA = numOfSession;
 
     /* Allocate imag of sramSA in the DRAM */
-    cesaSramSaBuf.bufSize = sizeof(MV_CESA_SRAM_SA)*numOfSession + 
+    cesaSramSaBuf.bufSize = sizeof(MV_CESA_SRAM_SA)*numOfSession +
                                     CPU_D_CACHE_LINE_SIZE;
 
     cesaSramSaBuf.bufVirtPtr = mvOsIoCachedMalloc(osHandle,cesaSramSaBuf.bufSize,
 						  &cesaSramSaBuf.bufPhysAddr,
 						  &cesaSramSaBuf.memHandle);
-        
+
     if(cesaSramSaBuf.bufVirtPtr == NULL)
     {
-        mvOsPrintf("mvCesaInit: Can't allocate %d bytes for sramSA structures\n", 
+        mvOsPrintf("mvCesaInit: Can't allocate %d bytes for sramSA structures\n",
                     cesaSramSaBuf.bufSize);
         mvCesaFinish();
         return MV_NO_RESOURCE;
     }
-    memset(cesaSramSaBuf.bufVirtPtr, 0, cesaSramSaBuf.bufSize); 
-    pSramSA = (MV_CESA_SRAM_SA*)MV_ALIGN_UP((MV_ULONG)cesaSramSaBuf.bufVirtPtr, 
+    memset(cesaSramSaBuf.bufVirtPtr, 0, cesaSramSaBuf.bufSize);
+    pSramSA = (MV_CESA_SRAM_SA*)MV_ALIGN_UP((MV_ULONG)cesaSramSaBuf.bufVirtPtr,
                                                        CPU_D_CACHE_LINE_SIZE);
     for(i=0; i<numOfSession; i++)
     {
@@ -306,7 +306,7 @@ MV_STATUS mvCesaHalInit (int numOfSession, int queueDepth, char* pSramBase, MV_U
     cesaQueueDepth = queueDepth;
     cesaReqResources = queueDepth;
 #if (MV_CESA_VERSION >= 3)
-    cesaChainLength = MAX_CESA_CHAIN_LENGTH; 
+    cesaChainLength = MAX_CESA_CHAIN_LENGTH;
 #endif
     /* pSramBase must be 8 byte aligned */
     if( MV_IS_NOT_ALIGN((MV_ULONG)pSramBase, 8) )
@@ -317,7 +317,7 @@ MV_STATUS mvCesaHalInit (int numOfSession, int queueDepth, char* pSramBase, MV_U
         return MV_NOT_ALIGNED;
     }
     cesaSramVirtPtr = (MV_CESA_SRAM_MAP*)pSramBase;
-    
+
     cesaCryptEngBase = cryptEngBase;
 
     /*memset(cesaSramVirtPtr, 0, sizeof(MV_CESA_SRAM_MAP));*/
@@ -337,42 +337,42 @@ MV_STATUS mvCesaHalInit (int numOfSession, int queueDepth, char* pSramBase, MV_U
 
         pReq = &pCesaReqFirst[req];
 
-        pReq->cesaDescBuf.bufSize = sizeof(MV_CESA_DESC)*MV_CESA_MAX_REQ_FRAGS + 
+        pReq->cesaDescBuf.bufSize = sizeof(MV_CESA_DESC)*MV_CESA_MAX_REQ_FRAGS +
                                         CPU_D_CACHE_LINE_SIZE;
 
-	pReq->cesaDescBuf.bufVirtPtr = 
+	pReq->cesaDescBuf.bufVirtPtr =
 		mvOsIoCachedMalloc(osHandle,pReq->cesaDescBuf.bufSize,
 				   &pReq->cesaDescBuf.bufPhysAddr,
 				   &pReq->cesaDescBuf.memHandle);
 
         if(pReq->cesaDescBuf.bufVirtPtr == NULL)
         {
-            mvOsPrintf("mvCesaInit: req=%d, Can't allocate %d bytes for CESA descriptors\n", 
+            mvOsPrintf("mvCesaInit: req=%d, Can't allocate %d bytes for CESA descriptors\n",
                         req, pReq->cesaDescBuf.bufSize);
                 mvCesaFinish();
                 return MV_NO_RESOURCE;
             }
-        memset(pReq->cesaDescBuf.bufVirtPtr, 0, pReq->cesaDescBuf.bufSize); 
-        pReq->pCesaDesc = (MV_CESA_DESC*)MV_ALIGN_UP((MV_ULONG)pReq->cesaDescBuf.bufVirtPtr, 
+        memset(pReq->cesaDescBuf.bufVirtPtr, 0, pReq->cesaDescBuf.bufSize);
+        pReq->pCesaDesc = (MV_CESA_DESC*)MV_ALIGN_UP((MV_ULONG)pReq->cesaDescBuf.bufVirtPtr,
                                                                 CPU_D_CACHE_LINE_SIZE);
 
-        pReq->dmaDescBuf.bufSize = sizeof(MV_DMA_DESC)*MV_CESA_MAX_DMA_DESC*MV_CESA_MAX_REQ_FRAGS + 
+        pReq->dmaDescBuf.bufSize = sizeof(MV_DMA_DESC)*MV_CESA_MAX_DMA_DESC*MV_CESA_MAX_REQ_FRAGS +
                                     CPU_D_CACHE_LINE_SIZE;
 
-        pReq->dmaDescBuf.bufVirtPtr = 
+        pReq->dmaDescBuf.bufVirtPtr =
 		mvOsIoCachedMalloc(osHandle,pReq->dmaDescBuf.bufSize,
 				   &pReq->dmaDescBuf.bufPhysAddr,
 				   &pReq->dmaDescBuf.memHandle);
 
         if(pReq->dmaDescBuf.bufVirtPtr == NULL)
         {
-            mvOsPrintf("mvCesaInit: req=%d, Can't allocate %d bytes for DMA descriptor list\n", 
+            mvOsPrintf("mvCesaInit: req=%d, Can't allocate %d bytes for DMA descriptor list\n",
                         req, pReq->dmaDescBuf.bufSize);
             mvCesaFinish();
             return MV_NO_RESOURCE;
         }
-        memset(pReq->dmaDescBuf.bufVirtPtr, 0, pReq->dmaDescBuf.bufSize); 
-        pDmaDesc = (MV_DMA_DESC*)MV_ALIGN_UP((MV_ULONG)pReq->dmaDescBuf.bufVirtPtr, 
+        memset(pReq->dmaDescBuf.bufVirtPtr, 0, pReq->dmaDescBuf.bufSize);
+        pDmaDesc = (MV_DMA_DESC*)MV_ALIGN_UP((MV_ULONG)pReq->dmaDescBuf.bufVirtPtr,
                                                        CPU_D_CACHE_LINE_SIZE);
 
         for(frag=0; frag<MV_CESA_MAX_REQ_FRAGS; frag++)
@@ -381,18 +381,18 @@ MV_STATUS mvCesaHalInit (int numOfSession, int queueDepth, char* pSramBase, MV_U
 
             pDma->pDmaFirst = pDmaDesc;
             pDma->pDmaLast = NULL;
-            
+
             for(i=0; i<MV_CESA_MAX_DMA_DESC-1; i++)
             {
                 /* link all DMA descriptors together */
-                pDma->pDmaFirst[i].phyNextDescPtr = 
+                pDma->pDmaFirst[i].phyNextDescPtr =
                         MV_32BIT_LE(mvCesaVirtToPhys(&pReq->dmaDescBuf, &pDmaDesc[i+1]));
             }
             pDma->pDmaFirst[i].phyNextDescPtr = 0;
-            mvOsCacheFlush(NULL, &pDma->pDmaFirst[0], MV_CESA_MAX_DMA_DESC*sizeof(MV_DMA_DESC));        
+            mvOsCacheFlush(NULL, &pDma->pDmaFirst[0], MV_CESA_MAX_DMA_DESC*sizeof(MV_DMA_DESC));
 
             pDmaDesc += MV_CESA_MAX_DMA_DESC;
-        }        
+        }
     }
     /*mvCesaCryptoIvSet(NULL, MV_CESA_MAX_IV_LENGTH);*/
     descOffsetReg = (MV_U16)((MV_U8*)&cesaSramVirtPtr->desc - mvCesaSramAddrGet());
@@ -584,7 +584,7 @@ MV_STATUS   mvCesaSessionOpen(MV_CESA_OPEN_SESSION *pSession, short* pSid)
     int         digestSize;
 
     cesaStats.openedCount++;
-    
+
     /* Find free entry in SAD */
     for(sid=0; sid<cesaMaxSA; sid++)
     {
@@ -633,7 +633,7 @@ MV_STATUS   mvCesaSessionOpen(MV_CESA_OPEN_SESSION *pSession, short* pSid)
                 return MV_BAD_PARAM;
             }
             mvCesaHmacIvGet(pSession->macMode, pSession->macKey, pSession->macKeyLength,
-                            pCesaSAD[sid].pSramSA->macInnerIV, 
+                            pCesaSAD[sid].pSramSA->macInnerIV,
                             pCesaSAD[sid].pSramSA->macOuterIV);
             pCesaSAD[sid].macKeyLength = pSession->macKeyLength;
         }
@@ -730,24 +730,24 @@ MV_STATUS   mvCesaSessionOpen(MV_CESA_OPEN_SESSION *pSession, short* pSid)
                         pSession->cryptoKeyLength, pCesaSAD[sid].cryptoKeyLength);
             return MV_BAD_PARAM;
         }
-        
+
         /* Copy Crypto key */
         if( (pSession->cryptoAlgorithm == MV_CESA_CRYPTO_AES) &&
             (pSession->direction == MV_CESA_DIR_DECODE))
         {
             /* Crypto Key for AES decode is computed from original key material */
             /* and depend on cryptoKeyLength (128/192/256 bits) */
-            aesMakeKey(pCesaSAD[sid].pSramSA->cryptoKey, pSession->cryptoKey, 
+            aesMakeKey(pCesaSAD[sid].pSramSA->cryptoKey, pSession->cryptoKey,
                         pSession->cryptoKeyLength*8, MV_CESA_AES_BLOCK_SIZE*8);
         }
         else
         {
                 /*panic("mvCesaSessionOpen2");*/
-                memcpy(pCesaSAD[sid].pSramSA->cryptoKey, pSession->cryptoKey, 
+                memcpy(pCesaSAD[sid].pSramSA->cryptoKey, pSession->cryptoKey,
                     pCesaSAD[sid].cryptoKeyLength);
-            
+
         }
-        
+
         switch(pSession->cryptoMode)
         {
             case MV_CESA_CRYPTO_ECB:
@@ -776,11 +776,11 @@ MV_STATUS   mvCesaSessionOpen(MV_CESA_OPEN_SESSION *pSession, short* pSid)
                             pSession->cryptoMode);
                 return MV_BAD_PARAM;
         }
-        
+
         config |= (pSession->cryptoMode << MV_CESA_CRYPTO_MODE_BIT);
     }
     pCesaSAD[sid].config = config;
-    
+
     mvOsCacheFlush(NULL, pCesaSAD[sid].pSramSA, sizeof(MV_CESA_SRAM_SA));
     if(pSid != NULL)
         *pSid = sid;
@@ -958,7 +958,7 @@ MV_STATUS   mvCesaAction (MV_CESA_COMMAND *pCmd)
             if(status == MV_OK) {
 #if (MV_CESA_VERSION >= 3)
 		if(frag) {
-			pReq->dma[frag-1].pDmaLast->phyNextDescPtr = 
+			pReq->dma[frag-1].pDmaLast->phyNextDescPtr =
 				MV_32BIT_LE(mvCesaVirtToPhys(&pReq->dmaDescBuf, pReq->dma[frag].pDmaFirst));
 			mvOsCacheFlush(NULL, pReq->dma[frag-1].pDmaLast, sizeof(MV_DMA_DESC));
 		}
@@ -968,11 +968,11 @@ MV_STATUS   mvCesaAction (MV_CESA_COMMAND *pCmd)
         }
         pReq->frags.numFrag = frag;
 #if (MV_CESA_VERSION >= 3)
-	if(chainReqNum) {	
+	if(chainReqNum) {
 		chainReqNum += pReq->frags.numFrag;
 		if(chainReqNum >= MAX_CESA_CHAIN_LENGTH)
 			chainReqNum = MAX_CESA_CHAIN_LENGTH;
-	}		
+	}
 #endif
     }
 
@@ -992,14 +992,14 @@ MV_STATUS   mvCesaAction (MV_CESA_COMMAND *pCmd)
     /* Are we within chain bounderies and follows the first request ? */
     if((chainReqNum > 0) && (chainReqNum < MAX_CESA_CHAIN_LENGTH)) {
 	if(chainIndex) {
-		pFromReq = MV_CESA_REQ_PREV_PTR(pReq); 
+		pFromReq = MV_CESA_REQ_PREV_PTR(pReq);
 		pToReq = pReq;
 		pReq->state = MV_CESA_CHAIN;
 		/* assume concatenating is possible */
-		pFromReq->dma[pFromReq->frags.numFrag-1].pDmaLast->phyNextDescPtr = 
+		pFromReq->dma[pFromReq->frags.numFrag-1].pDmaLast->phyNextDescPtr =
 			MV_32BIT_LE(mvCesaVirtToPhys(&pToReq->dmaDescBuf, pToReq->dma[0].pDmaFirst));
 		mvOsCacheFlush(NULL, pFromReq->dma[pFromReq->frags.numFrag-1].pDmaLast, sizeof(MV_DMA_DESC));
-			
+
 		/* align active & next pointers */
 		if(pNextActiveChain->state != MV_CESA_PENDING)
 			pEndCurrChain = pNextActiveChain = MV_CESA_REQ_NEXT_PTR(pReq);
@@ -1020,7 +1020,7 @@ MV_STATUS   mvCesaAction (MV_CESA_COMMAND *pCmd)
 				pEndCurrChain = pNextActiveChain = pReq;
 			chainReqNum = 0;
 		}
-		
+
 		pReq = pCesaReqProcess;
 		if(pReq->state == MV_CESA_PENDING) {
 			pNextActiveChain = pReq;
@@ -1093,7 +1093,7 @@ MV_STATUS mvCesaReadyGet(MV_CESA_RESULT* pResult)
     if(isFirstReq == MV_TRUE) {
 	if(chainIndex == 0)
 		chainReqNum = 0;
-	
+
 	isFirstReq = MV_FALSE;
 
 	if(pNextActiveChain->state == MV_CESA_PENDING) {
@@ -1105,9 +1105,9 @@ MV_STATUS mvCesaReadyGet(MV_CESA_RESULT* pResult)
 		/* Update pNextActiveChain to next chain head */
 		   while(pNextActiveChain->state == MV_CESA_CHAIN)
 			pNextActiveChain = MV_CESA_REQ_NEXT_PTR(pNextActiveChain);
-    	}    
+    	}
     }
-    
+
     /* Check if there are more processed requests - can we remove pEndCurrChain ??? */
     if(pCesaReqProcess == pEndCurrChain) {
 		isFirstReq = MV_TRUE;
@@ -1145,7 +1145,7 @@ MV_STATUS mvCesaReadyGet(MV_CESA_RESULT* pResult)
 	frag = (pReq->frags.nextFrag - 1);
 
         /* Restore DMA descriptor list */
-        pReq->dma[frag].pDmaLast->phyNextDescPtr = 
+        pReq->dma[frag].pDmaLast->phyNextDescPtr =
                 MV_32BIT_LE(mvCesaVirtToPhys(&pReq->dmaDescBuf, &pReq->dma[frag].pDmaLast[1]));
         pReq->dma[frag].pDmaLast = NULL;
 
@@ -1198,7 +1198,7 @@ MV_STATUS mvCesaReadyGet(MV_CESA_RESULT* pResult)
         mvCesaMbufCacheUnmap(pReq->pCmd->pDst, 0, pReq->pCmd->pDst->mbufSize);
 
         /* Restore DMA descriptor list */
-        pReq->dma[0].pDmaLast->phyNextDescPtr = 
+        pReq->dma[0].pDmaLast->phyNextDescPtr =
                 MV_32BIT_LE(mvCesaVirtToPhys(&pReq->dmaDescBuf, &pReq->dma[0].pDmaLast[1]));
         pReq->dma[0].pDmaLast = NULL;
         if( ((pSA->config & MV_CESA_OPERATION_MASK) !=
@@ -1253,7 +1253,7 @@ MV_STATUS mvCesaReadyGet(MV_CESA_RESULT* pResult)
         /* Start process new request from the queue */
         mvCesaReqProcessStart(pCesaReqProcess);
     }
-#endif 
+#endif
     return readyStatus;
 }
 
@@ -1811,7 +1811,7 @@ static MV_STATUS   mvCesaFragReqProcess(MV_CESA_REQ* pReq, MV_U8 frag)
                                 MV_FALSE, pReq->frags.bufOffset, copySize, pCmd->skipFlush);
 
     /* Prepare CESA descriptor to copy from DRAM to SRAM by DMA */
-    mvCesaSramDescrBuild(config, frag, 
+    mvCesaSramDescrBuild(config, frag,
                 cryptoOffset + fixOffset, cryptoIvOffset + fixOffset,
                 cryptoDataSize, macOffset + fixOffset,
                 digestOffset + fixOffset, macDataSize, macTotalLen,
@@ -1832,7 +1832,7 @@ static MV_STATUS   mvCesaFragReqProcess(MV_CESA_REQ* pReq, MV_U8 frag)
     /* Next field of Last DMA descriptor must be NULL */
     pDmaDesc[i-1].phyNextDescPtr = 0;
     pReq->dma[frag].pDmaLast = &pDmaDesc[i-1];
-    mvOsCacheFlush(NULL, pReq->dma[frag].pDmaFirst, 
+    mvOsCacheFlush(NULL, pReq->dma[frag].pDmaFirst,
                     i*sizeof(MV_DMA_DESC));
 
     /*mvCesaDebugDescriptor(&cesaSramVirtPtr->desc[frag]);*/
@@ -1909,7 +1909,7 @@ static MV_STATUS   mvCesaReqProcess(MV_CESA_REQ* pReq)
                                 MV_FALSE, 0, pMbuf->mbufSize, pCmd->skipFlush);
 
     /* Prepare Security Accelerator descriptor to SRAM words 0 - 7 */
-    mvCesaSramDescrBuild(pSA->config, 0, pCmd->cryptoOffset + fixOffset, 
+    mvCesaSramDescrBuild(pSA->config, 0, pCmd->cryptoOffset + fixOffset,
                         pCmd->ivOffset + fixOffset, pCmd->cryptoLength,
                         pCmd->macOffset + fixOffset, pCmd->digestOffset + fixOffset,
                         pCmd->macLength, pCmd->macLength, pReq, &pDmaDesc[i]);
@@ -1930,7 +1930,7 @@ static MV_STATUS   mvCesaReqProcess(MV_CESA_REQ* pReq)
     pDmaDesc[i-1].phyNextDescPtr = 0;
     pReq->dma[0].pDmaLast = &pDmaDesc[i-1];
     mvOsCacheFlush(NULL, pReq->dma[0].pDmaFirst, i*sizeof(MV_DMA_DESC));
-            
+
     return MV_OK;
 }
 
@@ -1964,11 +1964,11 @@ static MV_STATUS   mvCesaReqProcess(MV_CESA_REQ* pReq)
 * RETURN:   None
 *
 *******************************************************************************/
-static void    mvCesaSramDescrBuild(MV_U32 config, int frag, 
+static void    mvCesaSramDescrBuild(MV_U32 config, int frag,
                              int cryptoOffset, int ivOffset, int cryptoLength,
                              int macOffset, int digestOffset, int macLength,
                              int macTotalLen, MV_CESA_REQ* pReq, MV_DMA_DESC* pDmaDesc)
-{    
+{
     MV_CESA_DESC*   pCesaDesc = &pReq->pCesaDesc[frag];
     MV_CESA_DESC*   pSramDesc = pSramDesc = &cesaSramVirtPtr->desc;
     MV_U16          sramBufOffset = (MV_U16)((MV_U8*)cesaSramVirtPtr->buf - mvCesaSramAddrGet());
@@ -1984,7 +1984,7 @@ static void    mvCesaSramDescrBuild(MV_U32 config, int frag,
         /* word 2 */
         pCesaDesc->cryptoDataLen = MV_16BIT_LE(cryptoLength);
         /* word 3 */
-        pCesaDesc->cryptoKeyOffset = MV_16BIT_LE((MV_U16)(cesaSramVirtPtr->sramSA.cryptoKey - 
+        pCesaDesc->cryptoKeyOffset = MV_16BIT_LE((MV_U16)(cesaSramVirtPtr->sramSA.cryptoKey -
                                                             mvCesaSramAddrGet()));
         /* word 4 */
         pCesaDesc->cryptoIvOffset  = MV_16BIT_LE((MV_U16)(cesaSramVirtPtr->cryptoIV -
@@ -2004,16 +2004,16 @@ static void    mvCesaSramDescrBuild(MV_U32 config, int frag,
         pCesaDesc->macDataLen = MV_16BIT_LE(macLength);
 
         /* word 7 */
-        pCesaDesc->macInnerIvOffset = MV_16BIT_LE((MV_U16)(cesaSramVirtPtr->sramSA.macInnerIV - 
+        pCesaDesc->macInnerIvOffset = MV_16BIT_LE((MV_U16)(cesaSramVirtPtr->sramSA.macInnerIV -
                                  mvCesaSramAddrGet()));
-        pCesaDesc->macOuterIvOffset = MV_16BIT_LE((MV_U16)(cesaSramVirtPtr->sramSA.macOuterIV - 
+        pCesaDesc->macOuterIvOffset = MV_16BIT_LE((MV_U16)(cesaSramVirtPtr->sramSA.macOuterIV -
                                  mvCesaSramAddrGet()));
     }
     /* Prepare DMA descriptor to CESA descriptor from DRAM to SRAM */
     pDmaDesc->phySrcAdd = MV_32BIT_LE(mvCesaVirtToPhys(&pReq->cesaDescBuf, pCesaDesc));
     pDmaDesc->phyDestAdd = MV_32BIT_LE(mvCesaSramVirtToPhys(NULL, (MV_U8*)pSramDesc));
     pDmaDesc->byteCnt = MV_32BIT_LE(sizeof(MV_CESA_DESC) | BIT31);
-                                
+
     /* flush Source buffer */
     mvOsCacheFlush(NULL, pCesaDesc, sizeof(MV_CESA_DESC));
 }
@@ -2076,7 +2076,7 @@ static INLINE void   mvCesaSramSaUpdate(short sid, MV_DMA_DESC *pDmaDesc)
 *
 *******************************************************************************/
 #ifndef MV_NETBSD
-static INLINE int    mvCesaDmaCopyPrepare(MV_CESA_MBUF* pMbuf, MV_U8* pSramBuf, 
+static INLINE int    mvCesaDmaCopyPrepare(MV_CESA_MBUF* pMbuf, MV_U8* pSramBuf,
                         MV_DMA_DESC* pDmaDesc, MV_BOOL isToMbuf,
                         int offset, int copySize, MV_BOOL skipFlush)
 {
@@ -2256,7 +2256,7 @@ static void    mvCesaHmacIvGet(MV_CESA_MAC_MODE macMode, unsigned char key[], in
     int             i, digestSize = 0;
 #if defined(MV_CPU_LE) || defined(MV_PPC)
     MV_U32          swapped32, val32, *pVal32;
-#endif 
+#endif
     for(i=0; i<keyLength; i++)
     {
         inner[i] = 0x36 ^ key[i];
@@ -2665,7 +2665,7 @@ static MV_STATUS    mvCesaCtrModePrepare(MV_CESA_COMMAND *pCtrModeCmd, MV_CESA_C
     pMbuf = pCtrModeCmd->pSrc;
 
     /* Allocate buffer for Key stream */
-    pBuf = mvOsIoCachedMalloc(cesaOsHandle,cryptoSize, 
+    pBuf = mvOsIoCachedMalloc(cesaOsHandle,cryptoSize,
 			      &pMbuf->pFrags[0].bufPhysAddr,
 			      &pMbuf->pFrags[0].memHandle);
     if(pBuf == NULL)
diff --git a/crypto/ocf/kirkwood/cesa/mvCesa.h b/crypto/ocf/kirkwood/cesa/mvCesa.h
index c0abc9b..115274f 100644
--- a/crypto/ocf/kirkwood/cesa/mvCesa.h
+++ b/crypto/ocf/kirkwood/cesa/mvCesa.h
@@ -242,7 +242,7 @@ void        mvCesaDebugSAD(int mode);
 #endif /* MV_CESA_VERSION >= 2 */
 
 #define MV_CESA_MAX_PKT_SIZE        (64 * 1024)
-#define MV_CESA_MAX_MBUF_FRAGS      20
+#define MV_CESA_MAX_MBUF_FRAGS      20
 
 #define MV_CESA_MAX_REQ_FRAGS       ( (MV_CESA_MAX_PKT_SIZE / MV_CESA_MAX_BUF_SIZE) + 1)
 
@@ -396,7 +396,7 @@ extern MV_U32		cesaChainLength;
 
 extern MV_CESA_SRAM_MAP*  cesaSramVirtPtr;
 extern MV_U32           cesaSramPhysAddr;
-
+
 static INLINE MV_ULONG  mvCesaVirtToPhys(MV_BUF_INFO* pBufInfo, void* pVirt)
 {
     return (pBufInfo->bufPhysAddr + ((MV_U8*)pVirt - pBufInfo->bufVirtPtr));
diff --git a/crypto/ocf/kirkwood/cesa/mvCesaDebug.c b/crypto/ocf/kirkwood/cesa/mvCesaDebug.c
index 31b78a8..0b7cb48 100644
--- a/crypto/ocf/kirkwood/cesa/mvCesaDebug.c
+++ b/crypto/ocf/kirkwood/cesa/mvCesaDebug.c
@@ -226,36 +226,36 @@ void    mvCesaDebugRegs(void)
                 MV_CESA_ISR_MASK_REG,
                 MV_REG_READ( MV_CESA_ISR_MASK_REG ) );
 #if (MV_CESA_VERSION >= 2)
-    mvOsPrintf("MV_CESA_TDMA_CTRL_REG               : 0x%X = 0x%08x\n", 
-                MV_CESA_TDMA_CTRL_REG, 
+    mvOsPrintf("MV_CESA_TDMA_CTRL_REG               : 0x%X = 0x%08x\n",
+                MV_CESA_TDMA_CTRL_REG,
                 MV_REG_READ( MV_CESA_TDMA_CTRL_REG ) );
 
-    mvOsPrintf("MV_CESA_TDMA_BYTE_COUNT_REG         : 0x%X = 0x%08x\n", 
-                MV_CESA_TDMA_BYTE_COUNT_REG, 
+    mvOsPrintf("MV_CESA_TDMA_BYTE_COUNT_REG         : 0x%X = 0x%08x\n",
+                MV_CESA_TDMA_BYTE_COUNT_REG,
                 MV_REG_READ( MV_CESA_TDMA_BYTE_COUNT_REG ) );
 
-    mvOsPrintf("MV_CESA_TDMA_SRC_ADDR_REG           : 0x%X = 0x%08x\n", 
-                MV_CESA_TDMA_SRC_ADDR_REG, 
+    mvOsPrintf("MV_CESA_TDMA_SRC_ADDR_REG           : 0x%X = 0x%08x\n",
+                MV_CESA_TDMA_SRC_ADDR_REG,
                 MV_REG_READ( MV_CESA_TDMA_SRC_ADDR_REG ) );
 
-    mvOsPrintf("MV_CESA_TDMA_DST_ADDR_REG           : 0x%X = 0x%08x\n", 
-                MV_CESA_TDMA_DST_ADDR_REG, 
+    mvOsPrintf("MV_CESA_TDMA_DST_ADDR_REG           : 0x%X = 0x%08x\n",
+                MV_CESA_TDMA_DST_ADDR_REG,
                 MV_REG_READ( MV_CESA_TDMA_DST_ADDR_REG ) );
 
-    mvOsPrintf("MV_CESA_TDMA_NEXT_DESC_PTR_REG      : 0x%X = 0x%08x\n", 
-                MV_CESA_TDMA_NEXT_DESC_PTR_REG, 
+    mvOsPrintf("MV_CESA_TDMA_NEXT_DESC_PTR_REG      : 0x%X = 0x%08x\n",
+                MV_CESA_TDMA_NEXT_DESC_PTR_REG,
                 MV_REG_READ( MV_CESA_TDMA_NEXT_DESC_PTR_REG ) );
 
-    mvOsPrintf("MV_CESA_TDMA_CURR_DESC_PTR_REG      : 0x%X = 0x%08x\n", 
-                MV_CESA_TDMA_CURR_DESC_PTR_REG, 
+    mvOsPrintf("MV_CESA_TDMA_CURR_DESC_PTR_REG      : 0x%X = 0x%08x\n",
+                MV_CESA_TDMA_CURR_DESC_PTR_REG,
                 MV_REG_READ( MV_CESA_TDMA_CURR_DESC_PTR_REG ) );
 
-    mvOsPrintf("MV_CESA_TDMA_ERROR_CAUSE_REG        : 0x%X = 0x%08x\n", 
-                MV_CESA_TDMA_ERROR_CAUSE_REG, 
+    mvOsPrintf("MV_CESA_TDMA_ERROR_CAUSE_REG        : 0x%X = 0x%08x\n",
+                MV_CESA_TDMA_ERROR_CAUSE_REG,
                 MV_REG_READ( MV_CESA_TDMA_ERROR_CAUSE_REG ) );
 
-    mvOsPrintf("MV_CESA_TDMA_ERROR_MASK_REG         : 0x%X = 0x%08x\n", 
-                MV_CESA_TDMA_ERROR_MASK_REG, 
+    mvOsPrintf("MV_CESA_TDMA_ERROR_MASK_REG         : 0x%X = 0x%08x\n",
+                MV_CESA_TDMA_ERROR_MASK_REG,
                 MV_REG_READ( MV_CESA_TDMA_ERROR_CAUSE_REG ) );
 
 #endif
@@ -271,7 +271,7 @@ void    mvCesaDebugStatus(void)
 #if (MV_CESA_VERSION >= 3)
     mvOsPrintf("chainLength=%u\n",cesaChainLength);
 #else
-   mvOsPrintf("\n"); 	
+   mvOsPrintf("\n");
 #endif
 
     mvOsPrintf("pSAD=%p, maxSA=%d, sizeSA=%ld bytes\n",
diff --git a/crypto/ocf/kirkwood/cesa/mvCesaRegs.h b/crypto/ocf/kirkwood/cesa/mvCesaRegs.h
index 6b7ce12..c6eecae 100644
--- a/crypto/ocf/kirkwood/cesa/mvCesaRegs.h
+++ b/crypto/ocf/kirkwood/cesa/mvCesaRegs.h
@@ -1,357 +1,357 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef __mvCesaRegs_h__
-#define __mvCesaRegs_h__
-
-#include "mvTypes.h"
-
-typedef struct
-{
-    /* word 0 */
-    MV_U32  config;
-    /* word 1 */    
-    MV_U16  cryptoSrcOffset;
-    MV_U16  cryptoDstOffset;
-    /* word 2 */    
-    MV_U16  cryptoDataLen;
-    MV_U16  reserved1;
-    /* word 3 */
-    MV_U16  cryptoKeyOffset;
-    MV_U16  reserved2;
-    /* word 4 */
-    MV_U16  cryptoIvOffset;
-    MV_U16  cryptoIvBufOffset;
-    /* word 5 */
-    MV_U16  macSrcOffset;
-    MV_U16  macTotalLen;
-    /* word 6 */
-    MV_U16  macDigestOffset;
-    MV_U16  macDataLen;
-    /* word 7 */
-    MV_U16  macInnerIvOffset;
-    MV_U16  macOuterIvOffset;
-
-} MV_CESA_DESC;
-
-/* operation */
-typedef enum 
-{
-    MV_CESA_MAC_ONLY         = 0,
-    MV_CESA_CRYPTO_ONLY      = 1,
-    MV_CESA_MAC_THEN_CRYPTO  = 2,
-    MV_CESA_CRYPTO_THEN_MAC  = 3,
-    
-    MV_CESA_MAX_OPERATION
-
-} MV_CESA_OPERATION;
-
-#define MV_CESA_OPERATION_OFFSET        0
-#define MV_CESA_OPERATION_MASK          (0x3 << MV_CESA_OPERATION_OFFSET)
-
-/* mac algorithm */
-typedef enum 
-{   
-    MV_CESA_MAC_NULL        = 0,
-    MV_CESA_MAC_MD5         = 4,
-    MV_CESA_MAC_SHA1        = 5,
-    MV_CESA_MAC_HMAC_MD5    = 6,
-    MV_CESA_MAC_HMAC_SHA1   = 7,
-
-} MV_CESA_MAC_MODE;
-
-#define MV_CESA_MAC_MODE_OFFSET         4
-#define MV_CESA_MAC_MODE_MASK           (0x7 << MV_CESA_MAC_MODE_OFFSET)
-
-typedef enum
-{
-    MV_CESA_MAC_DIGEST_FULL = 0,
-    MV_CESA_MAC_DIGEST_96B  = 1,
-
-} MV_CESA_MAC_DIGEST_SIZE;
-
-#define MV_CESA_MAC_DIGEST_SIZE_BIT     7
-#define MV_CESA_MAC_DIGEST_SIZE_MASK    (1 << MV_CESA_MAC_DIGEST_SIZE_BIT)
-
-
-typedef enum 
-{
-    MV_CESA_CRYPTO_NULL = 0,
-    MV_CESA_CRYPTO_DES  = 1,
-    MV_CESA_CRYPTO_3DES = 2,
-    MV_CESA_CRYPTO_AES  = 3,
-
-} MV_CESA_CRYPTO_ALG;
-
-#define MV_CESA_CRYPTO_ALG_OFFSET       8
-#define MV_CESA_CRYPTO_ALG_MASK         (0x3 << MV_CESA_CRYPTO_ALG_OFFSET)
-
-
-/* direction */
-typedef enum 
-{
-    MV_CESA_DIR_ENCODE = 0,
-    MV_CESA_DIR_DECODE = 1,
-
-} MV_CESA_DIRECTION;
-
-#define MV_CESA_DIRECTION_BIT           12
-#define MV_CESA_DIRECTION_MASK          (1 << MV_CESA_DIRECTION_BIT)
-
-/* crypto IV mode */
-typedef enum 
-{
-    MV_CESA_CRYPTO_ECB = 0,
-    MV_CESA_CRYPTO_CBC = 1,
-
-    /* NO HW Support */
-    MV_CESA_CRYPTO_CTR = 10,
-
-} MV_CESA_CRYPTO_MODE;
-
-#define MV_CESA_CRYPTO_MODE_BIT         16
-#define MV_CESA_CRYPTO_MODE_MASK        (1 << MV_CESA_CRYPTO_MODE_BIT)         
-
-/* 3DES mode */
-typedef enum 
-{
-    MV_CESA_CRYPTO_3DES_EEE = 0,
-    MV_CESA_CRYPTO_3DES_EDE = 1,
-
-} MV_CESA_CRYPTO_3DES_MODE;
-
-#define MV_CESA_CRYPTO_3DES_MODE_BIT    20
-#define MV_CESA_CRYPTO_3DES_MODE_MASK   (1 << MV_CESA_CRYPTO_3DES_MODE_BIT)
-
-
-/* AES Key Length */
-typedef enum 
-{
-    MV_CESA_CRYPTO_AES_KEY_128 = 0,
-    MV_CESA_CRYPTO_AES_KEY_192 = 1,
-    MV_CESA_CRYPTO_AES_KEY_256 = 2,
-
-} MV_CESA_CRYPTO_AES_KEY_LEN;
-
-#define MV_CESA_CRYPTO_AES_KEY_LEN_OFFSET   24
-#define MV_CESA_CRYPTO_AES_KEY_LEN_MASK     (0x3 << MV_CESA_CRYPTO_AES_KEY_LEN_OFFSET)
-
-/* Fragmentation mode */
-typedef enum 
-{
-    MV_CESA_FRAG_NONE   = 0,
-    MV_CESA_FRAG_FIRST  = 1,
-    MV_CESA_FRAG_LAST   = 2,
-    MV_CESA_FRAG_MIDDLE = 3,
-
-} MV_CESA_FRAG_MODE;
-
-#define MV_CESA_FRAG_MODE_OFFSET            30
-#define MV_CESA_FRAG_MODE_MASK              (0x3 << MV_CESA_FRAG_MODE_OFFSET)
-/*---------------------------------------------------------------------------*/
-
-/********** Security Accelerator Command Register **************/
-#define MV_CESA_CMD_REG                     (MV_CESA_REG_BASE + 0xE00)
-
-#define MV_CESA_CMD_CHAN_ENABLE_BIT         0  
-#define MV_CESA_CMD_CHAN_ENABLE_MASK        (1 << MV_CESA_CMD_CHAN_ENABLE_BIT)
-
-#define MV_CESA_CMD_CHAN_DISABLE_BIT        2  
-#define MV_CESA_CMD_CHAN_DISABLE_MASK       (1 << MV_CESA_CMD_CHAN_DISABLE_BIT)  
-
-/********** Security Accelerator Descriptor Pointers Register **********/
-#define MV_CESA_CHAN_DESC_OFFSET_REG        (MV_CESA_REG_BASE + 0xE04)
-
-/********** Security Accelerator Configuration Register **********/
-#define MV_CESA_CFG_REG                     (MV_CESA_REG_BASE + 0xE08)
-
-#define MV_CESA_CFG_STOP_DIGEST_ERR_BIT     0
-#define MV_CESA_CFG_STOP_DIGEST_ERR_MASK    (1 << MV_CESA_CFG_STOP_DIGEST_ERR_BIT)
-
-#define MV_CESA_CFG_WAIT_DMA_BIT            7
-#define MV_CESA_CFG_WAIT_DMA_MASK           (1 << MV_CESA_CFG_WAIT_DMA_BIT)
-          
-#define MV_CESA_CFG_ACT_DMA_BIT             9
-#define MV_CESA_CFG_ACT_DMA_MASK            (1 << MV_CESA_CFG_ACT_DMA_BIT)
-
-#define MV_CESA_CFG_CHAIN_MODE_BIT          11
-#define MV_CESA_CFG_CHAIN_MODE_MASK         (1 << MV_CESA_CFG_CHAIN_MODE_BIT)
-
-/********** Security Accelerator Status Register ***********/
-#define MV_CESA_STATUS_REG                  (MV_CESA_REG_BASE + 0xE0C)
-
-#define MV_CESA_STATUS_ACTIVE_BIT           0
-#define MV_CESA_STATUS_ACTIVE_MASK          (1 << MV_CESA_STATUS_ACTIVE_BIT)
-
-#define MV_CESA_STATUS_DIGEST_ERR_BIT       8
-#define MV_CESA_STATUS_DIGEST_ERR_MASK      (1 << MV_CESA_STATUS_DIGEST_ERR_BIT)
-
-
-/* Cryptographic Engines and Security Accelerator Interrupt Cause Register */
-#define MV_CESA_ISR_CAUSE_REG               (MV_CESA_REG_BASE + 0xE20)
-
-/* Cryptographic Engines and Security Accelerator Interrupt Mask Register */
-#define MV_CESA_ISR_MASK_REG                (MV_CESA_REG_BASE + 0xE24)
-
-#define MV_CESA_CAUSE_AUTH_MASK             (1 << 0)
-#define MV_CESA_CAUSE_DES_MASK              (1 << 1)
-#define MV_CESA_CAUSE_AES_ENCR_MASK         (1 << 2)
-#define MV_CESA_CAUSE_AES_DECR_MASK         (1 << 3)
-#define MV_CESA_CAUSE_DES_ALL_MASK          (1 << 4)
-
-#define MV_CESA_CAUSE_ACC_BIT               5
-#define MV_CESA_CAUSE_ACC_MASK              (1 << MV_CESA_CAUSE_ACC_BIT)
-
-#define MV_CESA_CAUSE_ACC_DMA_BIT           7
-#define MV_CESA_CAUSE_ACC_DMA_MASK          (1 << MV_CESA_CAUSE_ACC_DMA_BIT)
-#define MV_CESA_CAUSE_ACC_DMA_ALL_MASK      (3 << MV_CESA_CAUSE_ACC_DMA_BIT)
-
-#define MV_CESA_CAUSE_DMA_COMPL_BIT         9
-#define MV_CESA_CAUSE_DMA_COMPL_MASK        (1 << MV_CESA_CAUSE_DMA_COMPL_BIT)
-
-#define MV_CESA_CAUSE_DMA_OWN_ERR_BIT       10
-#define MV_CESA_CAUSE_DMA_OWN_ERR_MASK      (1 < MV_CESA_CAUSE_DMA_OWN_ERR_BIT)
-
-#define MV_CESA_CAUSE_DMA_CHAIN_PKT_BIT     11
-#define MV_CESA_CAUSE_DMA_CHAIN_PKT_MASK    (1 < MV_CESA_CAUSE_DMA_CHAIN_PKT_BIT)
-
-
-#define MV_CESA_AUTH_DATA_IN_REG            (MV_CESA_REG_BASE + 0xd38)
-#define MV_CESA_AUTH_BIT_COUNT_LOW_REG      (MV_CESA_REG_BASE + 0xd20)
-#define MV_CESA_AUTH_BIT_COUNT_HIGH_REG     (MV_CESA_REG_BASE + 0xd24)
-
-#define MV_CESA_AUTH_INIT_VAL_DIGEST_REG(i) (MV_CESA_REG_BASE + 0xd00 + (i<<2))
-
-#define MV_CESA_AUTH_INIT_VAL_DIGEST_A_REG  (MV_CESA_REG_BASE + 0xd00)
-#define MV_CESA_AUTH_INIT_VAL_DIGEST_B_REG  (MV_CESA_REG_BASE + 0xd04)
-#define MV_CESA_AUTH_INIT_VAL_DIGEST_C_REG  (MV_CESA_REG_BASE + 0xd08)
-#define MV_CESA_AUTH_INIT_VAL_DIGEST_D_REG  (MV_CESA_REG_BASE + 0xd0c)
-#define MV_CESA_AUTH_INIT_VAL_DIGEST_E_REG  (MV_CESA_REG_BASE + 0xd10)
-#define MV_CESA_AUTH_COMMAND_REG            (MV_CESA_REG_BASE + 0xd18)
-
-#define MV_CESA_AUTH_ALGORITHM_BIT          0
-#define MV_CESA_AUTH_ALGORITHM_MD5          (0<<AUTH_ALGORITHM_BIT)
-#define MV_CESA_AUTH_ALGORITHM_SHA1         (1<<AUTH_ALGORITHM_BIT)
-
-#define MV_CESA_AUTH_IV_MODE_BIT            1
-#define MV_CESA_AUTH_IV_MODE_INIT           (0<<AUTH_IV_MODE_BIT)
-#define MV_CESA_AUTH_IV_MODE_CONTINUE       (1<<AUTH_IV_MODE_BIT)
-
-#define MV_CESA_AUTH_DATA_BYTE_SWAP_BIT     2
-#define MV_CESA_AUTH_DATA_BYTE_SWAP_MASK    (1<<AUTH_DATA_BYTE_SWAP_BIT)
-
-
-#define MV_CESA_AUTH_IV_BYTE_SWAP_BIT       4
-#define MV_CESA_AUTH_IV_BYTE_SWAP_MASK      (1<<AUTH_IV_BYTE_SWAP_BIT)
-
-#define MV_CESA_AUTH_TERMINATION_BIT        31
-#define MV_CESA_AUTH_TERMINATION_MASK       (1<<AUTH_TERMINATION_BIT)
-
-
-/*************** TDMA Control Register ************************************************/
-#define MV_CESA_TDMA_CTRL_REG               (MV_CESA_TDMA_REG_BASE + 0x840)
-
-#define MV_CESA_TDMA_BURST_32B              3   
-#define MV_CESA_TDMA_BURST_128B             4   
-
-#define MV_CESA_TDMA_DST_BURST_OFFSET       0
-#define MV_CESA_TDMA_DST_BURST_ALL_MASK     (0x7<<MV_CESA_TDMA_DST_BURST_OFFSET)
-#define MV_CESA_TDMA_DST_BURST_MASK(burst)  ((burst)<<MV_CESA_TDMA_DST_BURST_OFFSET)
-
-#define MV_CESA_TDMA_OUTSTAND_READ_EN_BIT   4
-#define MV_CESA_TDMA_OUTSTAND_READ_EN_MASK  (1<<MV_CESA_TDMA_OUTSTAND_READ_EN_BIT)
-
-#define MV_CESA_TDMA_SRC_BURST_OFFSET       6
-#define MV_CESA_TDMA_SRC_BURST_ALL_MASK     (0x7<<MV_CESA_TDMA_SRC_BURST_OFFSET)
-#define MV_CESA_TDMA_SRC_BURST_MASK(burst)  ((burst)<<MV_CESA_TDMA_SRC_BURST_OFFSET)
-
-#define MV_CESA_TDMA_CHAIN_MODE_BIT         9
-#define MV_CESA_TDMA_NON_CHAIN_MODE_MASK    (1<<MV_CESA_TDMA_CHAIN_MODE_BIT)
-
-#define MV_CESA_TDMA_BYTE_SWAP_BIT	    11
-#define MV_CESA_TDMA_BYTE_SWAP_MASK	    (0 << MV_CESA_TDMA_BYTE_SWAP_BIT)
-#define MV_CESA_TDMA_NO_BYTE_SWAP_MASK	    (1 << MV_CESA_TDMA_BYTE_SWAP_BIT)		    	
-
-#define MV_CESA_TDMA_ENABLE_BIT		    12
-#define MV_CESA_TDMA_ENABLE_MASK            (1<<MV_CESA_TDMA_ENABLE_BIT)
-			    
-#define MV_CESA_TDMA_FETCH_NEXT_DESC_BIT    13	
-#define MV_CESA_TDMA_FETCH_NEXT_DESC_MASK   (1<<MV_CESA_TDMA_FETCH_NEXT_DESC_BIT)	
-
-#define MV_CESA_TDMA_CHAN_ACTIVE_BIT	    14    
-#define MV_CESA_TDMA_CHAN_ACTIVE_MASK       (1<<MV_CESA_TDMA_CHAN_ACTIVE_BIT)
-/*------------------------------------------------------------------------------------*/
-
-#define MV_CESA_TDMA_BYTE_COUNT_REG         (MV_CESA_TDMA_REG_BASE + 0x800)
-#define MV_CESA_TDMA_SRC_ADDR_REG           (MV_CESA_TDMA_REG_BASE + 0x810)
-#define MV_CESA_TDMA_DST_ADDR_REG           (MV_CESA_TDMA_REG_BASE + 0x820)
-#define MV_CESA_TDMA_NEXT_DESC_PTR_REG      (MV_CESA_TDMA_REG_BASE + 0x830)
-#define MV_CESA_TDMA_CURR_DESC_PTR_REG      (MV_CESA_TDMA_REG_BASE + 0x870)
-
-#define MV_CESA_TDMA_ERROR_CAUSE_REG        (MV_CESA_TDMA_REG_BASE + 0x8C0)
-#define MV_CESA_TDMA_ERROR_MASK_REG         (MV_CESA_TDMA_REG_BASE + 0x8C4)
-
-
-#endif /* __mvCesaRegs_h__ */ 
-
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __mvCesaRegs_h__
+#define __mvCesaRegs_h__
+
+#include "mvTypes.h"
+
+typedef struct
+{
+    /* word 0 */
+    MV_U32  config;
+    /* word 1 */
+    MV_U16  cryptoSrcOffset;
+    MV_U16  cryptoDstOffset;
+    /* word 2 */
+    MV_U16  cryptoDataLen;
+    MV_U16  reserved1;
+    /* word 3 */
+    MV_U16  cryptoKeyOffset;
+    MV_U16  reserved2;
+    /* word 4 */
+    MV_U16  cryptoIvOffset;
+    MV_U16  cryptoIvBufOffset;
+    /* word 5 */
+    MV_U16  macSrcOffset;
+    MV_U16  macTotalLen;
+    /* word 6 */
+    MV_U16  macDigestOffset;
+    MV_U16  macDataLen;
+    /* word 7 */
+    MV_U16  macInnerIvOffset;
+    MV_U16  macOuterIvOffset;
+
+} MV_CESA_DESC;
+
+/* operation */
+typedef enum
+{
+    MV_CESA_MAC_ONLY         = 0,
+    MV_CESA_CRYPTO_ONLY      = 1,
+    MV_CESA_MAC_THEN_CRYPTO  = 2,
+    MV_CESA_CRYPTO_THEN_MAC  = 3,
+
+    MV_CESA_MAX_OPERATION
+
+} MV_CESA_OPERATION;
+
+#define MV_CESA_OPERATION_OFFSET        0
+#define MV_CESA_OPERATION_MASK          (0x3 << MV_CESA_OPERATION_OFFSET)
+
+/* mac algorithm */
+typedef enum
+{
+    MV_CESA_MAC_NULL        = 0,
+    MV_CESA_MAC_MD5         = 4,
+    MV_CESA_MAC_SHA1        = 5,
+    MV_CESA_MAC_HMAC_MD5    = 6,
+    MV_CESA_MAC_HMAC_SHA1   = 7,
+
+} MV_CESA_MAC_MODE;
+
+#define MV_CESA_MAC_MODE_OFFSET         4
+#define MV_CESA_MAC_MODE_MASK           (0x7 << MV_CESA_MAC_MODE_OFFSET)
+
+typedef enum
+{
+    MV_CESA_MAC_DIGEST_FULL = 0,
+    MV_CESA_MAC_DIGEST_96B  = 1,
+
+} MV_CESA_MAC_DIGEST_SIZE;
+
+#define MV_CESA_MAC_DIGEST_SIZE_BIT     7
+#define MV_CESA_MAC_DIGEST_SIZE_MASK    (1 << MV_CESA_MAC_DIGEST_SIZE_BIT)
+
+
+typedef enum
+{
+    MV_CESA_CRYPTO_NULL = 0,
+    MV_CESA_CRYPTO_DES  = 1,
+    MV_CESA_CRYPTO_3DES = 2,
+    MV_CESA_CRYPTO_AES  = 3,
+
+} MV_CESA_CRYPTO_ALG;
+
+#define MV_CESA_CRYPTO_ALG_OFFSET       8
+#define MV_CESA_CRYPTO_ALG_MASK         (0x3 << MV_CESA_CRYPTO_ALG_OFFSET)
+
+
+/* direction */
+typedef enum
+{
+    MV_CESA_DIR_ENCODE = 0,
+    MV_CESA_DIR_DECODE = 1,
+
+} MV_CESA_DIRECTION;
+
+#define MV_CESA_DIRECTION_BIT           12
+#define MV_CESA_DIRECTION_MASK          (1 << MV_CESA_DIRECTION_BIT)
+
+/* crypto IV mode */
+typedef enum
+{
+    MV_CESA_CRYPTO_ECB = 0,
+    MV_CESA_CRYPTO_CBC = 1,
+
+    /* NO HW Support */
+    MV_CESA_CRYPTO_CTR = 10,
+
+} MV_CESA_CRYPTO_MODE;
+
+#define MV_CESA_CRYPTO_MODE_BIT         16
+#define MV_CESA_CRYPTO_MODE_MASK        (1 << MV_CESA_CRYPTO_MODE_BIT)
+
+/* 3DES mode */
+typedef enum
+{
+    MV_CESA_CRYPTO_3DES_EEE = 0,
+    MV_CESA_CRYPTO_3DES_EDE = 1,
+
+} MV_CESA_CRYPTO_3DES_MODE;
+
+#define MV_CESA_CRYPTO_3DES_MODE_BIT    20
+#define MV_CESA_CRYPTO_3DES_MODE_MASK   (1 << MV_CESA_CRYPTO_3DES_MODE_BIT)
+
+
+/* AES Key Length */
+typedef enum
+{
+    MV_CESA_CRYPTO_AES_KEY_128 = 0,
+    MV_CESA_CRYPTO_AES_KEY_192 = 1,
+    MV_CESA_CRYPTO_AES_KEY_256 = 2,
+
+} MV_CESA_CRYPTO_AES_KEY_LEN;
+
+#define MV_CESA_CRYPTO_AES_KEY_LEN_OFFSET   24
+#define MV_CESA_CRYPTO_AES_KEY_LEN_MASK     (0x3 << MV_CESA_CRYPTO_AES_KEY_LEN_OFFSET)
+
+/* Fragmentation mode */
+typedef enum
+{
+    MV_CESA_FRAG_NONE   = 0,
+    MV_CESA_FRAG_FIRST  = 1,
+    MV_CESA_FRAG_LAST   = 2,
+    MV_CESA_FRAG_MIDDLE = 3,
+
+} MV_CESA_FRAG_MODE;
+
+#define MV_CESA_FRAG_MODE_OFFSET            30
+#define MV_CESA_FRAG_MODE_MASK              (0x3 << MV_CESA_FRAG_MODE_OFFSET)
+/*---------------------------------------------------------------------------*/
+
+/********** Security Accelerator Command Register **************/
+#define MV_CESA_CMD_REG                     (MV_CESA_REG_BASE + 0xE00)
+
+#define MV_CESA_CMD_CHAN_ENABLE_BIT         0
+#define MV_CESA_CMD_CHAN_ENABLE_MASK        (1 << MV_CESA_CMD_CHAN_ENABLE_BIT)
+
+#define MV_CESA_CMD_CHAN_DISABLE_BIT        2
+#define MV_CESA_CMD_CHAN_DISABLE_MASK       (1 << MV_CESA_CMD_CHAN_DISABLE_BIT)
+
+/********** Security Accelerator Descriptor Pointers Register **********/
+#define MV_CESA_CHAN_DESC_OFFSET_REG        (MV_CESA_REG_BASE + 0xE04)
+
+/********** Security Accelerator Configuration Register **********/
+#define MV_CESA_CFG_REG                     (MV_CESA_REG_BASE + 0xE08)
+
+#define MV_CESA_CFG_STOP_DIGEST_ERR_BIT     0
+#define MV_CESA_CFG_STOP_DIGEST_ERR_MASK    (1 << MV_CESA_CFG_STOP_DIGEST_ERR_BIT)
+
+#define MV_CESA_CFG_WAIT_DMA_BIT            7
+#define MV_CESA_CFG_WAIT_DMA_MASK           (1 << MV_CESA_CFG_WAIT_DMA_BIT)
+
+#define MV_CESA_CFG_ACT_DMA_BIT             9
+#define MV_CESA_CFG_ACT_DMA_MASK            (1 << MV_CESA_CFG_ACT_DMA_BIT)
+
+#define MV_CESA_CFG_CHAIN_MODE_BIT          11
+#define MV_CESA_CFG_CHAIN_MODE_MASK         (1 << MV_CESA_CFG_CHAIN_MODE_BIT)
+
+/********** Security Accelerator Status Register ***********/
+#define MV_CESA_STATUS_REG                  (MV_CESA_REG_BASE + 0xE0C)
+
+#define MV_CESA_STATUS_ACTIVE_BIT           0
+#define MV_CESA_STATUS_ACTIVE_MASK          (1 << MV_CESA_STATUS_ACTIVE_BIT)
+
+#define MV_CESA_STATUS_DIGEST_ERR_BIT       8
+#define MV_CESA_STATUS_DIGEST_ERR_MASK      (1 << MV_CESA_STATUS_DIGEST_ERR_BIT)
+
+
+/* Cryptographic Engines and Security Accelerator Interrupt Cause Register */
+#define MV_CESA_ISR_CAUSE_REG               (MV_CESA_REG_BASE + 0xE20)
+
+/* Cryptographic Engines and Security Accelerator Interrupt Mask Register */
+#define MV_CESA_ISR_MASK_REG                (MV_CESA_REG_BASE + 0xE24)
+
+#define MV_CESA_CAUSE_AUTH_MASK             (1 << 0)
+#define MV_CESA_CAUSE_DES_MASK              (1 << 1)
+#define MV_CESA_CAUSE_AES_ENCR_MASK         (1 << 2)
+#define MV_CESA_CAUSE_AES_DECR_MASK         (1 << 3)
+#define MV_CESA_CAUSE_DES_ALL_MASK          (1 << 4)
+
+#define MV_CESA_CAUSE_ACC_BIT               5
+#define MV_CESA_CAUSE_ACC_MASK              (1 << MV_CESA_CAUSE_ACC_BIT)
+
+#define MV_CESA_CAUSE_ACC_DMA_BIT           7
+#define MV_CESA_CAUSE_ACC_DMA_MASK          (1 << MV_CESA_CAUSE_ACC_DMA_BIT)
+#define MV_CESA_CAUSE_ACC_DMA_ALL_MASK      (3 << MV_CESA_CAUSE_ACC_DMA_BIT)
+
+#define MV_CESA_CAUSE_DMA_COMPL_BIT         9
+#define MV_CESA_CAUSE_DMA_COMPL_MASK        (1 << MV_CESA_CAUSE_DMA_COMPL_BIT)
+
+#define MV_CESA_CAUSE_DMA_OWN_ERR_BIT       10
+#define MV_CESA_CAUSE_DMA_OWN_ERR_MASK      (1 < MV_CESA_CAUSE_DMA_OWN_ERR_BIT)
+
+#define MV_CESA_CAUSE_DMA_CHAIN_PKT_BIT     11
+#define MV_CESA_CAUSE_DMA_CHAIN_PKT_MASK    (1 < MV_CESA_CAUSE_DMA_CHAIN_PKT_BIT)
+
+
+#define MV_CESA_AUTH_DATA_IN_REG            (MV_CESA_REG_BASE + 0xd38)
+#define MV_CESA_AUTH_BIT_COUNT_LOW_REG      (MV_CESA_REG_BASE + 0xd20)
+#define MV_CESA_AUTH_BIT_COUNT_HIGH_REG     (MV_CESA_REG_BASE + 0xd24)
+
+#define MV_CESA_AUTH_INIT_VAL_DIGEST_REG(i) (MV_CESA_REG_BASE + 0xd00 + (i<<2))
+
+#define MV_CESA_AUTH_INIT_VAL_DIGEST_A_REG  (MV_CESA_REG_BASE + 0xd00)
+#define MV_CESA_AUTH_INIT_VAL_DIGEST_B_REG  (MV_CESA_REG_BASE + 0xd04)
+#define MV_CESA_AUTH_INIT_VAL_DIGEST_C_REG  (MV_CESA_REG_BASE + 0xd08)
+#define MV_CESA_AUTH_INIT_VAL_DIGEST_D_REG  (MV_CESA_REG_BASE + 0xd0c)
+#define MV_CESA_AUTH_INIT_VAL_DIGEST_E_REG  (MV_CESA_REG_BASE + 0xd10)
+#define MV_CESA_AUTH_COMMAND_REG            (MV_CESA_REG_BASE + 0xd18)
+
+#define MV_CESA_AUTH_ALGORITHM_BIT          0
+#define MV_CESA_AUTH_ALGORITHM_MD5          (0<<AUTH_ALGORITHM_BIT)
+#define MV_CESA_AUTH_ALGORITHM_SHA1         (1<<AUTH_ALGORITHM_BIT)
+
+#define MV_CESA_AUTH_IV_MODE_BIT            1
+#define MV_CESA_AUTH_IV_MODE_INIT           (0<<AUTH_IV_MODE_BIT)
+#define MV_CESA_AUTH_IV_MODE_CONTINUE       (1<<AUTH_IV_MODE_BIT)
+
+#define MV_CESA_AUTH_DATA_BYTE_SWAP_BIT     2
+#define MV_CESA_AUTH_DATA_BYTE_SWAP_MASK    (1<<AUTH_DATA_BYTE_SWAP_BIT)
+
+
+#define MV_CESA_AUTH_IV_BYTE_SWAP_BIT       4
+#define MV_CESA_AUTH_IV_BYTE_SWAP_MASK      (1<<AUTH_IV_BYTE_SWAP_BIT)
+
+#define MV_CESA_AUTH_TERMINATION_BIT        31
+#define MV_CESA_AUTH_TERMINATION_MASK       (1<<AUTH_TERMINATION_BIT)
+
+
+/*************** TDMA Control Register ************************************************/
+#define MV_CESA_TDMA_CTRL_REG               (MV_CESA_TDMA_REG_BASE + 0x840)
+
+#define MV_CESA_TDMA_BURST_32B              3
+#define MV_CESA_TDMA_BURST_128B             4
+
+#define MV_CESA_TDMA_DST_BURST_OFFSET       0
+#define MV_CESA_TDMA_DST_BURST_ALL_MASK     (0x7<<MV_CESA_TDMA_DST_BURST_OFFSET)
+#define MV_CESA_TDMA_DST_BURST_MASK(burst)  ((burst)<<MV_CESA_TDMA_DST_BURST_OFFSET)
+
+#define MV_CESA_TDMA_OUTSTAND_READ_EN_BIT   4
+#define MV_CESA_TDMA_OUTSTAND_READ_EN_MASK  (1<<MV_CESA_TDMA_OUTSTAND_READ_EN_BIT)
+
+#define MV_CESA_TDMA_SRC_BURST_OFFSET       6
+#define MV_CESA_TDMA_SRC_BURST_ALL_MASK     (0x7<<MV_CESA_TDMA_SRC_BURST_OFFSET)
+#define MV_CESA_TDMA_SRC_BURST_MASK(burst)  ((burst)<<MV_CESA_TDMA_SRC_BURST_OFFSET)
+
+#define MV_CESA_TDMA_CHAIN_MODE_BIT         9
+#define MV_CESA_TDMA_NON_CHAIN_MODE_MASK    (1<<MV_CESA_TDMA_CHAIN_MODE_BIT)
+
+#define MV_CESA_TDMA_BYTE_SWAP_BIT	    11
+#define MV_CESA_TDMA_BYTE_SWAP_MASK	    (0 << MV_CESA_TDMA_BYTE_SWAP_BIT)
+#define MV_CESA_TDMA_NO_BYTE_SWAP_MASK	    (1 << MV_CESA_TDMA_BYTE_SWAP_BIT)
+
+#define MV_CESA_TDMA_ENABLE_BIT		    12
+#define MV_CESA_TDMA_ENABLE_MASK            (1<<MV_CESA_TDMA_ENABLE_BIT)
+
+#define MV_CESA_TDMA_FETCH_NEXT_DESC_BIT    13
+#define MV_CESA_TDMA_FETCH_NEXT_DESC_MASK   (1<<MV_CESA_TDMA_FETCH_NEXT_DESC_BIT)
+
+#define MV_CESA_TDMA_CHAN_ACTIVE_BIT	    14
+#define MV_CESA_TDMA_CHAN_ACTIVE_MASK       (1<<MV_CESA_TDMA_CHAN_ACTIVE_BIT)
+/*------------------------------------------------------------------------------------*/
+
+#define MV_CESA_TDMA_BYTE_COUNT_REG         (MV_CESA_TDMA_REG_BASE + 0x800)
+#define MV_CESA_TDMA_SRC_ADDR_REG           (MV_CESA_TDMA_REG_BASE + 0x810)
+#define MV_CESA_TDMA_DST_ADDR_REG           (MV_CESA_TDMA_REG_BASE + 0x820)
+#define MV_CESA_TDMA_NEXT_DESC_PTR_REG      (MV_CESA_TDMA_REG_BASE + 0x830)
+#define MV_CESA_TDMA_CURR_DESC_PTR_REG      (MV_CESA_TDMA_REG_BASE + 0x870)
+
+#define MV_CESA_TDMA_ERROR_CAUSE_REG        (MV_CESA_TDMA_REG_BASE + 0x8C0)
+#define MV_CESA_TDMA_ERROR_MASK_REG         (MV_CESA_TDMA_REG_BASE + 0x8C4)
+
+
+#endif /* __mvCesaRegs_h__ */
+
diff --git a/crypto/ocf/kirkwood/cesa/mvCesaTest.c b/crypto/ocf/kirkwood/cesa/mvCesaTest.c
index 7463293..bbbc7ca 100644
--- a/crypto/ocf/kirkwood/cesa/mvCesaTest.c
+++ b/crypto/ocf/kirkwood/cesa/mvCesaTest.c
@@ -142,7 +142,7 @@ do {					\
 
 #if defined(CONFIG_MV646xx)
 #include "marvell_pic.h"
-#endif
+#endif
 
 #define MV_CESA_USE_TIMER_ID    0
 #define CESA_DEF_BUF_SIZE       1500
@@ -1524,7 +1524,7 @@ void    cesaTestPrintReq(int req, int offset, int size)
 {
     MV_CESA_MBUF*   pMbuf;
 
-    mvOsPrintf("cesaTestPrintReq: req=%d, offset=%d, size=%d\n", 
+    mvOsPrintf("cesaTestPrintReq: req=%d, offset=%d, size=%d\n",
                 req, offset, size);
     mvDebugMemDump(cesaCmdRing, 128, 4);
 
@@ -1558,7 +1558,7 @@ void    printTestResults(int idx, MV_STATUS status, int checkMode)
         (cesaError == 0)       &&
         (cesaReqIdError == 0) )
     {
-        mvOsPrintf("Passed, Rate=%3u.%u Mbps (%5u cpp)\n", 
+        mvOsPrintf("Passed, Rate=%3u.%u Mbps (%5u cpp)\n",
                      cesaRate, cesaRateAfterDot, cesaEndTicks - cesaBeginTicks);
     }
     else
@@ -2212,7 +2212,7 @@ void    cesaTestStart(int bufNum, int bufSize)
 #endif /* MV_VXWORKS */
 
 #if !defined(MV_NETBSD) && defined(__KERNEL__)
-        if( request_irq(CESA_IRQ, cesaTestReadyIsr, (SA_INTERRUPT) , "cesa_test", NULL ) ) 
+        if( request_irq(CESA_IRQ, cesaTestReadyIsr, (SA_INTERRUPT) , "cesa_test", NULL ) )
         {
             mvOsPrintf( "cannot assign irq\n" );
             /* !!!! Dima cesaTestCleanup();*/
diff --git a/crypto/ocf/kirkwood/cesa/mvLru.c b/crypto/ocf/kirkwood/cesa/mvLru.c
index 9ab29a8..4b5f877 100644
--- a/crypto/ocf/kirkwood/cesa/mvLru.c
+++ b/crypto/ocf/kirkwood/cesa/mvLru.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -92,10 +92,10 @@ MV_LRU_CACHE*   mvLruCacheInit(int numOfEntries)
     for(i=0; i<numOfEntries; i++)
     {
         pLruCache->table[i].next = i+1;
-        pLruCache->table[i].prev = i-1;         
+        pLruCache->table[i].prev = i-1;
     }
     pLruCache->least = 0;
-    pLruCache->most = numOfEntries-1;   
+    pLruCache->most = numOfEntries-1;
 
     return pLruCache;
 }
diff --git a/crypto/ocf/kirkwood/cesa/mvLru.h b/crypto/ocf/kirkwood/cesa/mvLru.h
index 896e7f8..39d2f89 100644
--- a/crypto/ocf/kirkwood/cesa/mvLru.h
+++ b/crypto/ocf/kirkwood/cesa/mvLru.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
diff --git a/crypto/ocf/kirkwood/cesa/mvMD5.c b/crypto/ocf/kirkwood/cesa/mvMD5.c
index 925c2ff..b012976 100644
--- a/crypto/ocf/kirkwood/cesa/mvMD5.c
+++ b/crypto/ocf/kirkwood/cesa/mvMD5.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,70 +19,54 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
-/*
- * This code implements the MD5 message-digest algorithm.
- * The algorithm is due to Ron Rivest.  This code was
- * written by Colin Plumb in 1993, no copyright is claimed.
- * This code is in the public domain; do with it what you wish.
- *
- * Equivalent code is available from RSA Data Security, Inc.
- * This code has been tested against that, and is equivalent,
- * except that you don't need to include two pages of legalese
- * with every copy.
- *
- * To compute the message digest of a chunk of bytes, declare an
- * MD5Context structure, pass it to MD5Init, call MD5Update as
- * needed on buffers full of bytes, and then call MD5Final, which
- * will fill a supplied 16-byte array with the digest.
- */
 
 #include "mvOs.h"
 #include "mvMD5.h"
 
 static void mvMD5Transform(MV_U32 buf[4], MV_U32 const in[MV_MD5_MAC_LEN]);
- 
+
 #ifdef  MV_CPU_LE
 #define mvByteReverse(buf, len)   /* Nothing */
 #else
@@ -95,7 +79,7 @@ static void mvByteReverse(unsigned char *buf, unsigned longs)
 {
     MV_U32 t;
 
-    do 
+    do
     {
         t = (MV_U32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
                       ((unsigned) buf[1] << 8 | buf[0]);
@@ -139,12 +123,12 @@ void    mvMD5Update(MV_MD5_CONTEXT *ctx, unsigned char const *buf, unsigned len)
 
     /* Handle any leading odd-sized chunks */
 
-    if (t) 
+    if (t)
     {
         unsigned char *p = (unsigned char *) ctx->in + t;
 
         t = 64 - t;
-        if (len < t) 
+        if (len < t)
         {
             memcpy(p, buf, len);
             return;
@@ -157,7 +141,7 @@ void    mvMD5Update(MV_MD5_CONTEXT *ctx, unsigned char const *buf, unsigned len)
     }
     /* Process data in 64-byte chunks */
 
-    while (len >= 64) 
+    while (len >= 64)
     {
         memcpy(ctx->in, buf, 64);
         mvByteReverse(ctx->in, MV_MD5_MAC_LEN);
@@ -192,7 +176,7 @@ void    mvMD5Final(unsigned char digest[MV_MD5_MAC_LEN], MV_MD5_CONTEXT *ctx)
     count = 64 - 1 - count;
 
     /* Pad out to 56 mod 64 */
-    if (count < 8) 
+    if (count < 8)
     {
         /* Two lots of padding:  Pad the first block to 64 bytes */
         memset(p, 0, count);
@@ -201,8 +185,8 @@ void    mvMD5Final(unsigned char digest[MV_MD5_MAC_LEN], MV_MD5_CONTEXT *ctx)
 
         /* Now fill the next block with 56 bytes */
         memset(ctx->in, 0, 56);
-    } 
-    else 
+    }
+    else
     {
         /* Pad block to 56 bytes */
         memset(p, 0, count - 8);
@@ -345,7 +329,7 @@ void    mvHmacMd5(unsigned char const* text, int text_len,
     memcpy(k_opad, key, key_len);
 
     /* XOR key with ipad and opad values */
-    for (i=0; i<64; i++) 
+    for (i=0; i<64; i++)
     {
 	    k_ipad[i] ^= 0x36;
 	    k_opad[i] ^= 0x5c;
diff --git a/crypto/ocf/kirkwood/cesa/mvMD5.h b/crypto/ocf/kirkwood/cesa/mvMD5.h
index d05c6b6..d20281e 100644
--- a/crypto/ocf/kirkwood/cesa/mvMD5.h
+++ b/crypto/ocf/kirkwood/cesa/mvMD5.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -68,16 +68,16 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvMD5.h"
 
 #define MV_MD5_MAC_LEN 16
- 
- 
-typedef struct 
+
+
+typedef struct
 {
     MV_U32 buf[4];
     MV_U32 bits[2];
     MV_U8  in[64];
 
 } MV_MD5_CONTEXT;
- 
+
 void mvMD5Init(MV_MD5_CONTEXT *context);
 void mvMD5Update(MV_MD5_CONTEXT *context, unsigned char const *buf,
                 unsigned len);
@@ -88,6 +88,6 @@ void mvMD5(unsigned char const *buf, unsigned len, unsigned char* digest);
 void mvHmacMd5(unsigned char const* text, int text_len,
                   unsigned char const* key, int key_len,
                   unsigned char* digest);
-  
+
 
 #endif /* __mvMD5_h__ */
diff --git a/crypto/ocf/kirkwood/cesa/mvSHA1.c b/crypto/ocf/kirkwood/cesa/mvSHA1.c
index b90ad2c..6342985 100644
--- a/crypto/ocf/kirkwood/cesa/mvSHA1.c
+++ b/crypto/ocf/kirkwood/cesa/mvSHA1.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,79 +19,66 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
-/*
- * SHA1 hash implementation and interface functions
- * Copyright (c) 2003-2005, Jouni Malinen <jkmaline@cc.hut.fi>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Alternatively, this software may be distributed under the terms of BSD
- * license.
- *
- * See README and COPYING for more details.
- */
 
 #include "mvOs.h"
 #include "mvSHA1.h"
 
-#define SHA1HANDSOFF  
+#define SHA1HANDSOFF
 
-typedef union 
+typedef union
 {
     MV_U8   c[64];
     MV_U32  l[16];
 
 } CHAR64LONG16;
 
-static void mvSHA1Transform(MV_U32 state[5], const MV_U8 *buffer); 
+static void mvSHA1Transform(MV_U32 state[5], const MV_U8 *buffer);
 
 #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
 
- 
+
 #ifdef MV_CPU_LE
 #define blk0(i) (block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) | \
         (rol(block->l[i], 8) & 0x00FF00FF))
@@ -181,7 +168,7 @@ void    mvSHA1Init(MV_SHA1_CTX* context)
 
 
 /* Run your data through this. */
-void    mvSHA1Update(MV_SHA1_CTX *context, MV_U8 const *data, 
+void    mvSHA1Update(MV_SHA1_CTX *context, MV_U8 const *data,
                      unsigned int len)
 {
     MV_U32 i, j;
@@ -190,11 +177,11 @@ void    mvSHA1Update(MV_SHA1_CTX *context, MV_U8 const *data,
     if ((context->count[0] += len << 3) < (len << 3))
             context->count[1]++;
     context->count[1] += (len >> 29);
-    if ((j + len) > 63) 
+    if ((j + len) > 63)
     {
         memcpy(&context->buffer[j], data, (i = 64-j));
         mvSHA1Transform(context->state, context->buffer);
-        for ( ; i + 63 < len; i += 64) 
+        for ( ; i + 63 < len; i += 64)
         {
             mvSHA1Transform(context->state, &data[i]);
         }
@@ -212,19 +199,19 @@ void    mvSHA1Final(MV_U8* digest, MV_SHA1_CTX* context)
     MV_U32  i;
     MV_U8   finalcount[8];
 
-    for (i = 0; i < 8; i++) 
+    for (i = 0; i < 8; i++)
     {
         finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)] >>
                       ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
     }
     mvSHA1Update(context, (const unsigned char *) "\200", 1);
-    while ((context->count[0] & 504) != 448) 
+    while ((context->count[0] & 504) != 448)
     {
         mvSHA1Update(context, (const unsigned char *) "\0", 1);
     }
     mvSHA1Update(context, finalcount, 8);  /* Should cause a mvSHA1Transform()
                                           */
-    for (i = 0; i < 20; i++) 
+    for (i = 0; i < 20; i++)
     {
         digest[i] = (unsigned char)
                     ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
@@ -238,7 +225,7 @@ void    mvSHA1Final(MV_U8* digest, MV_SHA1_CTX* context)
 
 #ifdef SHA1HANDSOFF  /* make SHA1Transform overwrite it's own static vars */
     mvSHA1Transform(context->state, context->buffer);
-#endif 
+#endif
 }
 
 
diff --git a/crypto/ocf/kirkwood/cesa/mvSHA1.h b/crypto/ocf/kirkwood/cesa/mvSHA1.h
index 17df9fc..1914f47 100644
--- a/crypto/ocf/kirkwood/cesa/mvSHA1.h
+++ b/crypto/ocf/kirkwood/cesa/mvSHA1.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -68,21 +68,21 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvSHA1.h"
 
 #define MV_SHA1_MAC_LEN 20
- 
- 
-typedef struct 
+
+
+typedef struct
 {
     MV_U32 state[5];
     MV_U32 count[2];
     MV_U8  buffer[64];
 
-} MV_SHA1_CTX; 
- 
+} MV_SHA1_CTX;
+
 void mvSHA1Init(MV_SHA1_CTX *context);
 void mvSHA1Update(MV_SHA1_CTX *context, MV_U8 const *buf, unsigned int len);
 void mvSHA1Final(MV_U8* digest, MV_SHA1_CTX *context);
 
 void mvSHA1(MV_U8 const *buf, unsigned int len, MV_U8* digest);
-  
+
 
 #endif /* __mvSHA1_h__ */
diff --git a/crypto/ocf/kirkwood/cesa_ocf_drv.c b/crypto/ocf/kirkwood/cesa_ocf_drv.c
index e689f24..430fb67 100644
--- a/crypto/ocf/kirkwood/cesa_ocf_drv.c
+++ b/crypto/ocf/kirkwood/cesa_ocf_drv.c
@@ -125,7 +125,7 @@ struct cesa_dev {
 #define DIGEST_BUF_SIZE	32
 struct cesa_ocf_process {
 	MV_CESA_COMMAND 			cesa_cmd;
-	MV_CESA_MBUF 				cesa_mbuf;	
+	MV_CESA_MBUF 				cesa_mbuf;
 	MV_BUF_INFO  				cesa_bufs[MV_CESA_MAX_MBUF_FRAGS];
 	char					digest[DIGEST_BUF_SIZE];
 	int					digest_len;
@@ -239,10 +239,10 @@ get_usec(unsigned int start)
 }
 
 #ifdef RT_DEBUG
-/* 
+/*
  * check that the crp action match the current session
  */
-static int 
+static int
 ocf_check_action(struct cryptop *crp, struct cesa_ocf_data *cesa_ocf_cur_ses) {
 	int count = 0;
 	int encrypt = 0, decrypt = 0, auth = 0;
@@ -254,7 +254,7 @@ ocf_check_action(struct cryptop *crp, struct cesa_ocf_data *cesa_ocf_cur_ses) {
 			printk("%s,%d: session mode is not supported.\n", __FILE__, __LINE__);
 			return 1;
 		}
-		
+
 		/* Encryption /Decryption */
 		if(crd->crd_alg == cesa_ocf_cur_ses->cipher_alg) {
 			/* check that the action is compatible with session */
@@ -295,7 +295,7 @@ ocf_check_action(struct cryptop *crp, struct cesa_ocf_data *cesa_ocf_cur_ses) {
 				return 1;
 			}
 			auth++;
-		} 
+		}
 		else {
 			printk("%s,%d: Alg isn't supported by this session.\n", __FILE__, __LINE__);
 			return 1;
@@ -309,7 +309,7 @@ ocf_check_action(struct cryptop *crp, struct cesa_ocf_data *cesa_ocf_cur_ses) {
 /*
  * Process a request.
  */
-static int 
+static int
 cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 {
 	struct cesa_ocf_process *cesa_ocf_cmd = NULL;
@@ -323,7 +323,7 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 	struct sk_buff *skb = NULL;
 	struct uio *uiop = NULL;
 	unsigned char *ivp;
-	MV_BUF_INFO *p_buf_info;	
+	MV_BUF_INFO *p_buf_info;
 	MV_CESA_MBUF *p_mbuf_info;
 	unsigned long flags;
 
@@ -365,9 +365,9 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 	}
 #endif
 
-	/* malloc a new  cesa process */	
+	/* malloc a new  cesa process */
 	cesa_ocf_cmd = kmalloc(sizeof(struct cesa_ocf_process), GFP_ATOMIC);
-	
+
         if (cesa_ocf_cmd == NULL) {
             	printk("%s,%d: ENOBUFS \n", __FILE__, __LINE__);
             	goto p_error;
@@ -388,19 +388,19 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 	/* we send the entire buffer to the HAL, even if only part of it should be encrypt/auth.  */
 	/* if not using seesions for both encrypt and auth, then it will be wiser to to copy only */
 	/* from skip to crd_len. 								  */
-	p_buf_info = cesa_ocf_cmd->cesa_bufs;	
+	p_buf_info = cesa_ocf_cmd->cesa_bufs;
 	p_mbuf_info = &cesa_ocf_cmd->cesa_mbuf;
 
-	p_buf_info += 2; /* save 2 first buffers for IV and digest - 
-			    we won't append them to the end since, they 
+	p_buf_info += 2; /* save 2 first buffers for IV and digest -
+			    we won't append them to the end since, they
 			    might be places in an unaligned addresses. */
-	
+
 	p_mbuf_info->pFrags = p_buf_info;
 	temp_len = 0;
 
 	/* handle SKB */
 	if (crp->crp_flags & CRYPTO_F_SKBUF) {
-		
+
 		dprintk("%s,%d: handle SKB.\n", __FILE__, __LINE__);
 		skb = (struct sk_buff *) crp->crp_buf;
 
@@ -427,7 +427,7 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 	}
 	/* handle UIO */
 	else if(crp->crp_flags & CRYPTO_F_IOV) {
-	
+
 		dprintk("%s,%d: handle UIO.\n", __FILE__, __LINE__);
 		uiop = (struct uio *) crp->crp_buf;
 
@@ -444,13 +444,13 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 			temp_len += p_buf_info->bufSize;
 			dprintk("%s,%d: buf %x-> addr %x, size %x \n"
 				, __FILE__, __LINE__, i, (unsigned int)p_buf_info->bufVirtPtr, p_buf_info->bufSize);
-			p_buf_info++;			
+			p_buf_info++;
 		}
 
 	}
 	/* handle CONTIG */
 	else {
-		dprintk("%s,%d: handle CONTIG.\n", __FILE__, __LINE__); 
+		dprintk("%s,%d: handle CONTIG.\n", __FILE__, __LINE__);
 		p_mbuf_info->numFrags = 1;
 		p_mbuf_info->mbufSize = crp->crp_ilen;
 		p_buf_info->bufVirtPtr = crp->crp_buf;
@@ -458,7 +458,7 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 		temp_len = crp->crp_ilen;
 		p_buf_info++;
 	}
-	
+
 	/* Support up to 64K why? cause! */
 	if(crp->crp_ilen > 64*1024) {
 		printk("%s,%d: buf too big %x \n", __FILE__, __LINE__, crp->crp_ilen);
@@ -467,19 +467,19 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 
 	if( temp_len != crp->crp_ilen ) {
 		printk("%s,%d: warning size don't match.(%x %x) \n", __FILE__, __LINE__, temp_len, crp->crp_ilen);
-	}	
+	}
 
 	cesa_cmd->pSrc = p_mbuf_info;
 	cesa_cmd->pDst = p_mbuf_info;
-	
+
 	/* restore p_buf_info to point to first available buf */
-	p_buf_info = cesa_ocf_cmd->cesa_bufs;	
-	p_buf_info += 1; 
+	p_buf_info = cesa_ocf_cmd->cesa_bufs;
+	p_buf_info += 1;
 
 
         /* Go through crypto descriptors, processing as we go */
         for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
-		
+
 		/* Encryption /Decryption */
 		if(crd->crd_alg == cesa_ocf_cur_ses->cipher_alg) {
 
@@ -509,11 +509,11 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 					else {
 						dprintk("%s,%d: don't copy the IV back to the buffer \n", __FILE__, __LINE__);
 						p_mbuf_info->numFrags++;
-						p_mbuf_info->mbufSize += cesa_ocf_cur_ses->ivlen; 
+						p_mbuf_info->mbufSize += cesa_ocf_cur_ses->ivlen;
 						p_mbuf_info->pFrags = p_buf_info;
 
 						p_buf_info->bufVirtPtr = ivp;
-						p_buf_info->bufSize = cesa_ocf_cur_ses->ivlen; 
+						p_buf_info->bufSize = cesa_ocf_cur_ses->ivlen;
 						p_buf_info--;
 
 						/* offsets */
@@ -521,8 +521,8 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 						cesa_cmd->cryptoOffset += cesa_ocf_cur_ses->ivlen;
 						if(auth) {
 							cesa_cmd->macOffset += cesa_ocf_cur_ses->ivlen;
-							cesa_cmd->digestOffset += cesa_ocf_cur_ses->ivlen; 
-						}	
+							cesa_cmd->digestOffset += cesa_ocf_cur_ses->ivlen;
+						}
 					}
                                 }
 				else {					/* random IV */
@@ -536,11 +536,11 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 					/* given by the session to the ivOffset  	*/
 					if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
 						cesa_cmd->ivOffset = crd->crd_inject;
-					} 
+					}
 					else {
 						/* if IV isn't copy, then how will the user know which IV did we use??? */
 						printk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-						goto p_error; 
+						goto p_error;
 					}
 				}
 			}
@@ -553,13 +553,13 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 				if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
 					dprintk("%s,%d: IV from USER \n", __FILE__, __LINE__);
 					/* append the IV buf to the mbuf */
-					cesa_cmd->ivFromUser = 1;	
+					cesa_cmd->ivFromUser = 1;
 					p_mbuf_info->numFrags++;
-					p_mbuf_info->mbufSize += cesa_ocf_cur_ses->ivlen; 
+					p_mbuf_info->mbufSize += cesa_ocf_cur_ses->ivlen;
 					p_mbuf_info->pFrags = p_buf_info;
 
 					p_buf_info->bufVirtPtr = crd->crd_iv;
-					p_buf_info->bufSize = cesa_ocf_cur_ses->ivlen; 
+					p_buf_info->bufSize = cesa_ocf_cur_ses->ivlen;
 					p_buf_info--;
 
 					/* offsets */
@@ -567,7 +567,7 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 					cesa_cmd->cryptoOffset += cesa_ocf_cur_ses->ivlen;
 					if(auth) {
 						cesa_cmd->macOffset += cesa_ocf_cur_ses->ivlen;
-						cesa_cmd->digestOffset += cesa_ocf_cur_ses->ivlen; 
+						cesa_cmd->digestOffset += cesa_ocf_cur_ses->ivlen;
 					}
                                 }
 				else {
@@ -587,7 +587,7 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 
 			/* digest + mac */
 			cesa_cmd->digestOffset = crd->crd_inject;
-		} 
+		}
 		else {
 			printk("%s,%d: Alg isn't supported by this session.\n", __FILE__, __LINE__);
 			goto p_error;
@@ -617,9 +617,9 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 		if(auth && (encrypt || decrypt)) {
 			MV_CESA_COMMAND	*cesa_cmd_wa;
 
-			/* malloc a new cesa process and init it */	
+			/* malloc a new cesa process and init it */
 			cesa_ocf_cmd_wa = kmalloc(sizeof(struct cesa_ocf_process), GFP_ATOMIC);
-	
+
         		if (cesa_ocf_cmd_wa == NULL) {
             			printk("%s,%d: ENOBUFS \n", __FILE__, __LINE__);
             			goto p_error;
@@ -666,7 +666,7 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 
 		}
 		/* action not allowed and can't split */
-		else 
+		else
 #endif
 		{
 			goto p_error;
@@ -681,7 +681,7 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 		if(cesa_ocf_cmd_wa)
 			kfree(cesa_ocf_cmd_wa);
 		return ERESTART;
-	} 
+	}
 	else if((status != MV_NO_MORE) && (status != MV_OK)) {
                 printk("%s,%d: cesa action failed, status = 0x%x\n", __FILE__, __LINE__, status);
 		goto p_error;
@@ -704,7 +704,7 @@ p_error:
 }
 
 /*
- * cesa callback. 
+ * cesa callback.
  */
 static void
 cesa_callback(unsigned long dummy)
@@ -721,13 +721,13 @@ cesa_callback(unsigned long dummy)
 	disable_irq(cesa_device.irq);
 #endif
     while(MV_TRUE) {
-	
+
 		 /* Get Ready requests */
 		spin_lock(&cesa_lock);
 		status = mvCesaReadyGet(&result[res_idx]);
 		spin_unlock(&cesa_lock);
 
-	        cesaTestTraceAdd(2);	
+	        cesaTestTraceAdd(2);
 
 		    if(status != MV_OK) {
 #ifdef CESA_OCF_POLLING
@@ -741,7 +741,7 @@ cesa_callback(unsigned long dummy)
 	        res_idx++;
 		    break;
 	    }
-	
+
 	for(i = 0; i < res_idx; i++) {
 
 		if(!result[i].pReqPrv) {
@@ -750,16 +750,16 @@ cesa_callback(unsigned long dummy)
 		}
 
 		cesa_ocf_cmd = result[i].pReqPrv;
-		crp = cesa_ocf_cmd->crp; 
+		crp = cesa_ocf_cmd->crp;
 
 		// ignore HMAC error.
 		//if(result->retCode)
-		//	crp->crp_etype = EIO;	
-	
-#if  defined(CESA_OCF_POLLING) 
+		//	crp->crp_etype = EIO;
+
+#if  defined(CESA_OCF_POLLING)
 		if(!cesa_ocf_cmd->need_cb){
 			cesa_interrupt_polling();
-		}	
+		}
 #endif
 		if(cesa_ocf_cmd->need_cb) {
 			if(debug) {
@@ -792,7 +792,7 @@ cesa_interrupt_polling(void)
 		cause &= MV_CESA_CAUSE_ACC_DMA_ALL_MASK;
 
 	} while (cause == 0);
-		
+
 	/* clear interrupts */
     	MV_REG_WRITE(MV_CESA_ISR_CAUSE_REG, 0);
 
@@ -824,12 +824,12 @@ cesa_interrupt_handler(int irq, void *arg)
 		dprintk("%s,%d: cesaTestReadyIsr: cause=0x%x\n", __FILE__, __LINE__, cause);
         	return IRQ_HANDLED;
     	}
-	
+
 	/* clear interrupts */
     	MV_REG_WRITE(MV_CESA_ISR_CAUSE_REG, 0);
 
 	cesaTestTraceAdd(1);
-#ifdef CESA_OCF_TASKLET	
+#ifdef CESA_OCF_TASKLET
 	tasklet_hi_schedule(&cesa_ocf_tasklet);
 #else
 	cesa_callback(0);
@@ -840,7 +840,7 @@ cesa_interrupt_handler(int irq, void *arg)
 /*
  * Open a session.
  */
-static int 
+static int
 /*cesa_ocf_newsession(void *arg, u_int32_t *sid, struct cryptoini *cri)*/
 cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 {
@@ -875,7 +875,7 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
                 return ENOBUFS;
         }
 	dprintk("%s,%d: new session %d \n", __FILE__, __LINE__, i);
-	
+
         *sid = i;
         cesa_ocf_cur_ses = cesa_ocf_sessions[i];
         memset(cesa_ocf_cur_ses, 0, sizeof(struct cesa_ocf_data));
@@ -885,10 +885,10 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 	cesa_ocf_cur_ses->frag_wa_decrypt = -1;
 	cesa_ocf_cur_ses->frag_wa_auth = -1;
 
-	/* init the session */	
+	/* init the session */
 	memset(cesa_ses, 0, sizeof(MV_CESA_OPEN_SESSION));
 	count = 1;
-        while (cri) {	
+        while (cri) {
 		if(count > 2) {
         		printk("%s,%d: don't support more then 2 operations\n", __FILE__, __LINE__);
         		goto error;
@@ -949,14 +949,14 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			}
 			cesa_ses->macKeyLength = cri->cri_klen/8;
 			memcpy(cesa_ses->macKey, cri->cri_key, cri->cri_klen/8);
-			cesa_ses->digestSize = cesa_ocf_cur_ses->digestlen; 
+			cesa_ses->digestSize = cesa_ocf_cur_ses->digestlen;
 			auth += count;
 			break;
                 case CRYPTO_SHA1:
                 case CRYPTO_SHA1_HMAC:
 			dprintk("%s,%d: (%d) %sSHA1 CBC \n", __FILE__, __LINE__, count, (cri->cri_alg != CRYPTO_SHA1)? "H-":" ");
                         cesa_ocf_cur_ses->auth_alg = cri->cri_alg;
-			cesa_ocf_cur_ses->digestlen = (cri->cri_alg == CRYPTO_SHA1)? MV_CESA_SHA1_DIGEST_SIZE : 12; 
+			cesa_ocf_cur_ses->digestlen = (cri->cri_alg == CRYPTO_SHA1)? MV_CESA_SHA1_DIGEST_SIZE : 12;
 			cesa_ses->macMode = (cri->cri_alg == CRYPTO_SHA1)? MV_CESA_MAC_SHA1 : MV_CESA_MAC_HMAC_SHA1;
 			if(cri->cri_klen/8 > MV_CESA_MAX_CRYPTO_KEY_LENGTH) {
         			printk("%s,%d: MAC key too long. \n", __FILE__, __LINE__);
@@ -998,7 +998,7 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
     		if(status != MV_OK) {
         		printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
         		goto error;
-    		}	
+    		}
 		/* decrypt session */
 		if( cesa_ses->operation == MV_CESA_MAC_THEN_CRYPTO ) {
 			cesa_ses->operation = MV_CESA_CRYPTO_THEN_MAC;
@@ -1015,7 +1015,7 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 
 		/* preapre one action sessions for case we will need to split an action */
 #ifdef CESA_OCF_SPLIT
-		if(( cesa_ses->operation == MV_CESA_MAC_THEN_CRYPTO ) || 
+		if(( cesa_ses->operation == MV_CESA_MAC_THEN_CRYPTO ) ||
 			( cesa_ses->operation == MV_CESA_CRYPTO_THEN_MAC )) {
 			/* open one session for encode and one for decode */
 			cesa_ses->operation = MV_CESA_CRYPTO_ONLY;
@@ -1032,7 +1032,7 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
         			printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
         			goto error;
     			}
-			/* open one session for auth */	
+			/* open one session for auth */
 			cesa_ses->operation = MV_CESA_MAC_ONLY;
 			cesa_ses->direction = MV_CESA_DIR_ENCODE;
 			status = mvCesaSessionOpen(cesa_ses, &cesa_ocf_cur_ses->frag_wa_auth);
@@ -1052,11 +1052,11 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			goto error;
     		}
 	}
-	
+
         return 0;
 error:
      	cesa_ocf_freesession(NULL, *sid);
-      	return EINVAL;	
+      	return EINVAL;
 
 }
 
@@ -1112,12 +1112,12 @@ static void __init
 setup_tdma_mbus_windows(struct cesa_dev *dev)
 {
     int i;
-    
+
     for (i = 0; i < 4; i++) {
         writel(0, dev->reg + WINDOW_BASE(i));
         writel(0, dev->reg + WINDOW_CTRL(i));
     }
-    
+
     for (i = 0; i < dev->plat_data->dram->num_cs; i++) {
         struct mbus_dram_window *cs = dev->plat_data->dram->cs + i;
         writel(
@@ -1129,7 +1129,7 @@ setup_tdma_mbus_windows(struct cesa_dev *dev)
         writel(cs->base, dev->reg + WINDOW_BASE(i));
     }
 }
-                                        
+
 /*
  * our driver startup and shutdown routines
  */
@@ -1141,7 +1141,7 @@ mv_cesa_ocf_init(struct platform_device *pdev)
 	{
 		dprintk("CESA is not mapped to this CPU\n");
 		return -ENODEV;
-	}		
+	}
 #endif
 
 	dprintk("%s\n", __FUNCTION__);
@@ -1168,13 +1168,13 @@ mv_cesa_ocf_init(struct platform_device *pdev)
 	{
 		struct resource *res;
 		res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "sram");
-		
+
 		if (!res)
 			return -ENXIO;
-		
+
 		cesa_device.sram = ioremap(res->start, res->end - res->start + 1);
 		res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "regs");
-		
+
 		if (!res) {
 		        iounmap(cesa_device.sram);
 			return -ENXIO;
@@ -1182,11 +1182,11 @@ mv_cesa_ocf_init(struct platform_device *pdev)
                 cesa_device.reg = ioremap(res->start, res->end - res->start + 1);
 		cesa_device.irq = platform_get_irq(pdev, 0);
 		cesa_device.plat_data = pdev->dev.platform_data;
-	        setup_tdma_mbus_windows(&cesa_device);	
-		
+	        setup_tdma_mbus_windows(&cesa_device);
+
 	}
-	
-	
+
+
 	if( MV_OK != mvCesaInit(CESA_OCF_MAX_SES*5, CESA_Q_SIZE, cesa_device.reg,
 				NULL) ) {
             	printk("%s,%d: mvCesaInit Failed. \n", __FILE__, __LINE__);
@@ -1235,11 +1235,11 @@ mv_cesa_ocf_exit(struct platform_device *pdev)
 	iounmap(cesa_device.reg);
 	iounmap(cesa_device.sram);
 	free_irq(cesa_device.irq, NULL);
-	
+
 	/* mask and clear Int */
 	MV_REG_WRITE( MV_CESA_ISR_MASK_REG, 0);
 	MV_REG_WRITE( MV_CESA_ISR_CAUSE_REG, 0);
-    	
+
 
 	if( MV_OK != mvCesaFinish() ) {
             	printk("%s,%d: mvCesaFinish Failed. \n", __FILE__, __LINE__);
@@ -1260,7 +1260,7 @@ void cesa_ocf_debug(void)
         {
             mvOsPrintf("%02d.  %d   0x%04x   0x%04x   0x%02x   0x%02x   %02d   0x%06x  %p  %p  %p\n",
                 j, cesaTestTrace[j].type, cesaTestTrace[j].realCause,
-                cesaTestTrace[j].idmaCause, 
+                cesaTestTrace[j].idmaCause,
                 cesaTestTrace[j].resources, cesaTestTrace[j].timeStamp,
                 cesaTestTrace[j].pReqReady, cesaTestTrace[j].pReqProcess, cesaTestTrace[j].pReqEmpty);
             j++;
diff --git a/crypto/ocf/kirkwood/mvHal/common/mv802_3.h b/crypto/ocf/kirkwood/mvHal/common/mv802_3.h
index 3769dde..b03cdbd 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mv802_3.h
+++ b/crypto/ocf/kirkwood/mvHal/common/mv802_3.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -133,7 +133,7 @@ enum {
   MV_IP_PROTO_ESP	= 50,   /* Encapsulation Security Payload protocol */
   MV_IP_PROTO_AH	= 51,   /* Authentication Header protocol       */
   MV_IP_PROTO_BEETPH	= 94,   /* IP option pseudo header for BEET     */
-  MV_IP_PROTO_PIM	= 103, 
+  MV_IP_PROTO_PIM	= 103,
   MV_IP_PROTO_COMP	= 108,  /* Compression Header protocol          */
   MV_IP_PROTO_ZERO_HOP	= 114,  /* Any 0 hop protocol (IANA)            */
   MV_IP_PROTO_SCTP	= 132,  /* Stream Control Transport Protocol    */
@@ -156,13 +156,13 @@ typedef struct
     MV_U32  srcIP;
     MV_U32  dstIP;
 
-} MV_IP_HEADER; 
+} MV_IP_HEADER;
 
 typedef struct
-{       
+{
     MV_U32 spi;
     MV_U32 seqNum;
-} MV_ESP_HEADER; 
+} MV_ESP_HEADER;
 
 #define MV_ICMP_ECHOREPLY          0       /* Echo Reply                   */
 #define MV_ICMP_DEST_UNREACH       3       /* Destination Unreachable      */
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvCommon.c b/crypto/ocf/kirkwood/mvHal/common/mvCommon.c
index dc0e0cf..0605391 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvCommon.c
+++ b/crypto/ocf/kirkwood/mvHal/common/mvCommon.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -74,7 +74,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *		This function convert MAC format string to hex.
 *
 * INPUT:
-*       macStr - MAC address string. Fornat of address string is 
+*       macStr - MAC address string. Fornat of address string is
 *                uu:vv:ww:xx:yy:zz, where ":" can be any delimiter.
 *
 * OUTPUT:
@@ -199,14 +199,14 @@ MV_VOID mvHexToBin(const char* pHexStr, MV_U8* pBin, int size)
   	int     j, i;
     char    tmp[3];
     MV_U8   byte;
-    
+
     for(j=0, i=0; j<size; j++, i+=2)
     {
         tmp[0] = pHexStr[i];
         tmp[1] = pHexStr[i+1];
         tmp[2] = '\0';
         byte = (MV_U8) (strtol(tmp, NULL, 16) & 0xFF);
-        pBin[j] =  byte;     
+        pBin[j] =  byte;
     }
 }
 
@@ -237,7 +237,7 @@ void    mvBinToHex(const MV_U8* bin, char* hexStr, int size)
 void    mvBinToAscii(const MV_U8* bin, char* asciiStr, int size)
 {
 	int i;
- 
+
     for(i=0; i<size; i++)
     {
         mvOsSPrintf(&asciiStr[i*2], "%c", bin[i]);
@@ -246,7 +246,7 @@ void    mvBinToAscii(const MV_U8* bin, char* asciiStr, int size)
 }
 
 /*******************************************************************************
-* mvLog2 - 
+* mvLog2 -
 *
 * DESCRIPTION:
 *	Calculate the Log2 of a given number.
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvCommon.h b/crypto/ocf/kirkwood/mvHal/common/mvCommon.h
index c8e9ce1..5caf47c 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvCommon.h
+++ b/crypto/ocf/kirkwood/mvHal/common/mvCommon.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -76,7 +76,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                     ((X&0xf0) >> 4) |    \
                                     ((X&0xf00) << 4) |   \
                                     ((X&0xf000) >> 4))
-        
+
 /* 32bit nibble swap. For example 0x12345678 -> 0x21436587                  */
 #define MV_NIBBLE_SWAP_32BIT(X)    (((X&0xf) << 4) |       \
                                     ((X&0xf0) >> 4) |      \
@@ -108,14 +108,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 /* Endianess macros.                                                        */
 #if defined(MV_CPU_LE)
-    #define MV_16BIT_LE(X)  (X) 
+    #define MV_16BIT_LE(X)  (X)
     #define MV_32BIT_LE(X)  (X)
     #define MV_64BIT_LE(X)  (X)
     #define MV_16BIT_BE(X)  MV_BYTE_SWAP_16BIT(X)
     #define MV_32BIT_BE(X)  MV_BYTE_SWAP_32BIT(X)
     #define MV_64BIT_BE(X)  MV_BYTE_SWAP_64BIT(X)
 #elif defined(MV_CPU_BE)
-    #define MV_16BIT_LE(X)  MV_BYTE_SWAP_16BIT(X) 
+    #define MV_16BIT_LE(X)  MV_BYTE_SWAP_16BIT(X)
     #define MV_32BIT_LE(X)  MV_BYTE_SWAP_32BIT(X)
     #define MV_64BIT_LE(X)  MV_BYTE_SWAP_64BIT(X)
     #define MV_16BIT_BE(X)  (X)
@@ -123,7 +123,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     #define MV_64BIT_BE(X)  (X)
 #else
     #error "CPU endianess isn't defined!\n"
-#endif 
+#endif
 
 
 /* Bit field definitions */
@@ -214,7 +214,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* Cache configuration options for memory (DRAM, SRAM, ... ) */
 
 /* Memory uncached, HW or SW cache coherency is not needed */
-#define MV_UNCACHED             0   
+#define MV_UNCACHED             0
 /* Memory cached, HW cache coherency supported in WriteThrough mode */
 #define MV_CACHE_COHER_HW_WT    1
 /* Memory cached, HW cache coherency supported in WriteBack mode */
@@ -222,7 +222,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* Memory cached, No HW cache coherency, Cache coherency must be in SW */
 #define MV_CACHE_COHER_SW       3
 
-               
+
 /* Macro for testing aligment. Positive if number is NOT aligned   */
 #define MV_IS_NOT_ALIGN(number, align)      ((number) & ((align) - 1))
 
@@ -240,7 +240,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* Bit fields manipulation macros                                           */
 
 /* An integer word which its 'x' bit is set                                 */
-#define MV_BIT_MASK(bitNum)         (1 << (bitNum) )     
+#define MV_BIT_MASK(bitNum)         (1 << (bitNum) )
 
 /* Checks wheter bit 'x' in integer word is set                             */
 #define MV_BIT_CHECK(word, bitNum)  ( (word) & MV_BIT_MASK(bitNum) )
@@ -255,10 +255,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_BIT_INV(word, bitNum)    ( (word) ^= MV_BIT_MASK(bitNum) )
 
 /* Get the min between 'a' or 'b'                                           */
-#define MV_MIN(a,b)    (((a) < (b)) ? (a) : (b)) 
+#define MV_MIN(a,b)    (((a) < (b)) ? (a) : (b))
 
 /* Get the max between 'a' or 'b'                                           */
-#define MV_MAX(a,b)    (((a) < (b)) ? (b) : (a)) 
+#define MV_MAX(a,b)    (((a) < (b)) ? (b) : (a))
 
 /* Temporary */
 #define mvOsDivide(num, div)        \
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvDebug.c b/crypto/ocf/kirkwood/mvHal/common/mvDebug.c
index 087f36d..d98a9e4 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvDebug.c
+++ b/crypto/ocf/kirkwood/mvHal/common/mvDebug.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -71,13 +71,13 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvDebug.h"
 
 /* Global variables effect on behave MV_DEBUG_PRINT and MV_DEBUG_CODE macros
- * mvDebug  - map of bits (one for each module) bit=1 means enable 
+ * mvDebug  - map of bits (one for each module) bit=1 means enable
  *          debug code and messages for this module
  * mvModuleDebug - array of 32 bits varables one for each module
  */
 MV_U32    mvDebug = 0;
 MV_U32    mvDebugModules[MV_MODULE_MAX];
- 
+
 /* Init mvModuleDebug array to default values */
 void    mvDebugInit(void)
 {
@@ -90,29 +90,29 @@ void    mvDebugInit(void)
         mvDebug |= MV_BIT_MASK(bit);
     }
 }
- 
+
 void    mvDebugModuleEnable(MV_MODULE_ID module, MV_BOOL isEnable)
-{    
+{
     if (isEnable)
     {
-       MV_BIT_SET(mvDebug, module);               
+       MV_BIT_SET(mvDebug, module);
     }
     else
-       MV_BIT_CLEAR(mvDebug, module);                   
+       MV_BIT_CLEAR(mvDebug, module);
 }
- 
+
 void    mvDebugModuleSetFlags(MV_MODULE_ID module, MV_U32 flags)
-{ 
+{
     mvDebugModules[module] |= flags;
 }
 
 void    mvDebugModuleClearFlags(MV_MODULE_ID module, MV_U32 flags)
-{ 
+{
     mvDebugModules[module] &= ~flags;
 }
 
-/* Dump memory in specific format: 
- * address: X1X1X1X1 X2X2X2X2 ... X8X8X8X8 
+/* Dump memory in specific format:
+ * address: X1X1X1X1 X2X2X2X2 ... X8X8X8X8
  */
 void mvDebugMemDump(void* addr, int size, int access)
 {
@@ -199,15 +199,15 @@ void mvDebugPrintBufInfo(BUF_INFO* pBufInfo, int size, int access)
 		return;
 	}
     mvOsPrintf("\n*** pBufInfo=0x%x, cmdSts=0x%08x, pBuf=0x%x, bufSize=%d\n",
-               (unsigned int)pBufInfo, 
-			   (unsigned int)pBufInfo->cmdSts, 
-			   (unsigned int)pBufInfo->pBuff, 
+               (unsigned int)pBufInfo,
+			   (unsigned int)pBufInfo->cmdSts,
+			   (unsigned int)pBufInfo->pBuff,
 			   (unsigned int)pBufInfo->bufSize);
     mvOsPrintf("pData=0x%x, byteCnt=%d, pNext=0x%x, uInfo1=0x%x, uInfo2=0x%x\n",
-               (unsigned int)pBufInfo->pData, 
-			   (unsigned int)pBufInfo->byteCnt, 
+               (unsigned int)pBufInfo->pData,
+			   (unsigned int)pBufInfo->byteCnt,
 			   (unsigned int)pBufInfo->pNextBufInfo,
-               (unsigned int)pBufInfo->userInfo1, 
+               (unsigned int)pBufInfo->userInfo1,
 			   (unsigned int)pBufInfo->userInfo2);
     if(pBufInfo->pData != NULL)
     {
@@ -227,13 +227,13 @@ void mvDebugPrintPktInfo(MV_PKT_INFO* pPktInfo, int size, int access)
 		return;
 	}
     mvOsPrintf("\npPkt=%p, stat=0x%08x, numFr=%d, size=%d, pFr=%p, osInfo=0x%lx\n",
-                pPktInfo, pPktInfo->status, pPktInfo->numFrags, pPktInfo->pktSize, 
+                pPktInfo, pPktInfo->status, pPktInfo->numFrags, pPktInfo->pktSize,
                 pPktInfo->pFrags, pPktInfo->osInfo);
-    
+
     for(frag=0; frag<pPktInfo->numFrags; frag++)
     {
-        mvOsPrintf("#%2d. bufVirt=%p, bufSize=%d\n", 
-                    frag, pPktInfo->pFrags[frag].bufVirtPtr, 
+        mvOsPrintf("#%2d. bufVirt=%p, bufSize=%d\n",
+                    frag, pPktInfo->pFrags[frag].bufVirtPtr,
                     pPktInfo->pFrags[frag].bufSize);
         if(size > 0)
         {
@@ -242,7 +242,7 @@ void mvDebugPrintPktInfo(MV_PKT_INFO* pPktInfo, int size, int access)
             size -= len;
         }
     }
-    
+
 }
 
 void    mvDebugPrintIpAddr(MV_U32 ipAddr)
@@ -294,7 +294,7 @@ void mvDebugPrintTimeEntry(MV_DEBUG_TIMES* pTimeEntry, MV_BOOL isTitle)
         mvOsPrintf("%-11s     %6u          0x%08lx        %6lu     %6lu    %6lu\n",
                 pTimeEntry->name, num, pTimeEntry->total, pTimeEntry->total/num,
                 pTimeEntry->min, pTimeEntry->max);
-    }   
+    }
 }
 
 /* Update MV_DEBUG_TIMES entry */
@@ -302,25 +302,25 @@ void mvDebugUpdateTimeEntry(MV_DEBUG_TIMES* pTimeEntry)
 {
     MV_U32  delta;
 
-    if(pTimeEntry->left > 0)                                        
-    {                                                                           
-        if(pTimeEntry->end <= pTimeEntry->begin)       
-        {                                                                       
+    if(pTimeEntry->left > 0)
+    {
+        if(pTimeEntry->end <= pTimeEntry->begin)
+        {
             delta = pTimeEntry->begin - pTimeEntry->end;
         }
         else
         {
             delta = ((MV_U32)0x10000 - pTimeEntry->end) + pTimeEntry->begin;
         }
-        pTimeEntry->total += delta;             
+        pTimeEntry->total += delta;
 
-        if(delta < pTimeEntry->min)    
-            pTimeEntry->min = delta;    
+        if(delta < pTimeEntry->min)
+            pTimeEntry->min = delta;
 
-        if(delta > pTimeEntry->max)    
-            pTimeEntry->max = delta;      
+        if(delta > pTimeEntry->max)
+            pTimeEntry->max = delta;
 
-        pTimeEntry->left--;                                                                                                                 
+        pTimeEntry->left--;
     }
 }
 
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvDebug.h b/crypto/ocf/kirkwood/mvHal/common/mvDebug.h
index e4975be..ed07a1f 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvDebug.h
+++ b/crypto/ocf/kirkwood/mvHal/common/mvDebug.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -70,12 +70,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* includes */
 #include "mvTypes.h"
 
-typedef enum 
+typedef enum
 {
     MV_MODULE_INVALID  = -1,
     MV_MODULE_ETH      = 0,
     MV_MODULE_IDMA,
-    MV_MODULE_XOR, 
+    MV_MODULE_XOR,
     MV_MODULE_TWASI,
     MV_MODULE_MGI,
     MV_MODULE_USB,
@@ -83,7 +83,7 @@ typedef enum
 
     MV_MODULE_MAX
 }MV_MODULE_ID;
- 
+
 /* Define generic flags useful for most of modules */
 #define MV_DEBUG_FLAG_ALL   (0)
 #define MV_DEBUG_FLAG_INIT  (1 << 0)
@@ -96,12 +96,12 @@ typedef enum
 #define MV_DEBUG_FLAG_IOCTL (1 << 7)
 #define MV_DEBUG_FLAG_STATS (1 << 8)
 
-extern MV_U32  mvDebug; 
+extern MV_U32  mvDebug;
 extern MV_U32  mvDebugModules[MV_MODULE_MAX];
 
 #ifdef MV_DEBUG
 # define MV_DEBUG_PRINT(module, flags, msg)     mvOsPrintf msg
-# define MV_DEBUG_CODE(module, flags, code)     code 
+# define MV_DEBUG_CODE(module, flags, code)     code
 #elif defined(MV_RT_DEBUG)
 # define MV_DEBUG_PRINT(module, flags, msg)                    \
     if( (mvDebug & (1<<(module))) &&                           \
@@ -139,8 +139,8 @@ typedef struct {
 
 /****** Error Recording ******/
 
-/* Dump memory in specific format: 
- * address: X1X1X1X1 X2X2X2X2 ... X8X8X8X8 
+/* Dump memory in specific format:
+ * address: X1X1X1X1 X2X2X2X2 ... X8X8X8X8
  */
 void mvDebugMemDump(void* addr, int size, int access);
 
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvDeviceId.h b/crypto/ocf/kirkwood/mvHal/common/mvDeviceId.h
index 4782094..4f4eb47 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvDeviceId.h
+++ b/crypto/ocf/kirkwood/mvHal/common/mvDeviceId.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer. 
+        this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -83,7 +83,7 @@ extern "C" {
 /* Disco-6 */
 #define MV64660_DEV_ID          	0x6460
 
-/* Orion */        
+/* Orion */
 #define MV_1181_DEV_ID          	0x1181
 #define MV_5181_DEV_ID          	0x5181
 #define MV_5281_DEV_ID          	0x5281
@@ -155,7 +155,7 @@ extern "C" {
 
 #define MV_6180_A1_REV              0x3
 #define MV_6180_A1_ID               ((MV_6180_DEV_ID << 16) | MV_6180_A1_REV)
-#define MV_6180_A1_NAME             "88F6180 A1" 
+#define MV_6180_A1_NAME             "88F6180 A1"
 
 #define MV_88F6XXX_A0_REV         	0x2
 #define MV_88F6XXX_A1_REV         	0x3
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvHalVer.h b/crypto/ocf/kirkwood/mvHal/common/mvHalVer.h
index 3bfcfe1..1849198 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvHalVer.h
+++ b/crypto/ocf/kirkwood/mvHal/common/mvHalVer.h
@@ -1,73 +1,73 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-
-#ifndef __INCmvHalVerh
-#define __INCmvHalVerh
-
-/* Defines */
-#define MV_HAL_VERSION			"FEROCEON_HAL_3_1_7"
-#define MV_RELEASE_BASELINE		"SoCandControllers_FEROCEON_RELEASE_7_9_2009_KW_4_3_4_DD_2_1_4_6183_1_1_4"
-
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvHalVerh
+#define __INCmvHalVerh
+
+/* Defines */
+#define MV_HAL_VERSION			"FEROCEON_HAL_3_1_7"
+#define MV_RELEASE_BASELINE		"SoCandControllers_FEROCEON_RELEASE_7_9_2009_KW_4_3_4_DD_2_1_4_6183_1_1_4"
+
 #endif /* __INCmvHalVerh */
\ No newline at end of file
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvStack.c b/crypto/ocf/kirkwood/mvHal/common/mvStack.c
index 41ca7ce..c640049 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvStack.c
+++ b/crypto/ocf/kirkwood/mvHal/common/mvStack.c
@@ -1,24 +1,24 @@
-/******************************************************************************* 
-*                   Copyright 2003, Marvell Semiconductor Israel LTD.          * 
-* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL.                      * 
-* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  * 
-* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        * 
-* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     * 
-* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       * 
-* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   * 
-*                                                                              * 
-* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, * 
-* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL    * 
-* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K.  * 
-* (MJKK), MARVELL SEMICONDUCTOR ISRAEL LTD (MSIL).                             * 
+/*******************************************************************************
+*                   Copyright 2003, Marvell Semiconductor Israel LTD.          *
+* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL.                      *
+* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
+* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
+* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
+* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
+* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
+*                                                                              *
+* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, *
+* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL    *
+* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K.  *
+* (MJKK), MARVELL SEMICONDUCTOR ISRAEL LTD (MSIL).                             *
 ********************************************************************************
 * mvQueue.c
 *
-* FILENAME:    $Workfile: mvStack.c $                     
-* REVISION:    $Revision: 1.1 $                              
-* LAST UPDATE: $Modtime:  $                  
-*                                                          
-* DESCRIPTION:                                             
+* FILENAME:    $Workfile: mvStack.c $
+* REVISION:    $Revision: 1.1 $
+* LAST UPDATE: $Modtime:  $
+*
+* DESCRIPTION:
 *     This file implements simple Stack LIFO functionality.
 *******************************************************************************/
 
@@ -88,7 +88,7 @@ void    mvStackStatus(void* stackHndl, MV_BOOL isPrintElements)
     MV_STACK*   pStack = (MV_STACK*)stackHndl;
 
     mvOsPrintf("StackHandle=%p, pElements=%p, numElements=%d, stackIdx=%d\n",
-                stackHndl, pStack->stackElements, pStack->numOfElements, 
+                stackHndl, pStack->stackElements, pStack->numOfElements,
                 pStack->stackIdx);
     if(isPrintElements == MV_TRUE)
     {
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvStack.h b/crypto/ocf/kirkwood/mvHal/common/mvStack.h
index e247e61..9e13771 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvStack.h
+++ b/crypto/ocf/kirkwood/mvHal/common/mvStack.h
@@ -1,16 +1,16 @@
-/******************************************************************************* 
-*                   Copyright 2003, Marvell Semiconductor Israel LTD.          * 
-* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL.                      * 
-* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  * 
-* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        * 
-* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     * 
-* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       * 
-* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   * 
-*                                                                              * 
-* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, * 
-* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL    * 
-* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K.  * 
-* (MJKK), MARVELL SEMICONDUCTOR ISRAEL LTD (MSIL).                             * 
+/*******************************************************************************
+*                   Copyright 2003, Marvell Semiconductor Israel LTD.          *
+* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL.                      *
+* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
+* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
+* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
+* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
+* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
+*                                                                              *
+* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, *
+* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL    *
+* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K.  *
+* (MJKK), MARVELL SEMICONDUCTOR ISRAEL LTD (MSIL).                             *
 ********************************************************************************
 * mvStack.h - Header File for :
 *
@@ -36,7 +36,7 @@
 
 /* typedefs */
 /* Data structure describes general purpose Stack */
-typedef struct 
+typedef struct
 {
     int     stackIdx;
     int     numOfElements;
@@ -44,7 +44,7 @@ typedef struct
 } MV_STACK;
 
 static INLINE MV_BOOL mvStackIsFull(void* stackHndl)
-{	
+{
     MV_STACK*   pStack = (MV_STACK*)stackHndl;
 
     if(pStack->stackIdx == pStack->numOfElements)
@@ -54,7 +54,7 @@ static INLINE MV_BOOL mvStackIsFull(void* stackHndl)
 }
 
 static INLINE MV_BOOL mvStackIsEmpty(void* stackHndl)
-{	
+{
     MV_STACK*   pStack = (MV_STACK*)stackHndl;
 
     if(pStack->stackIdx == 0)
@@ -71,7 +71,7 @@ static INLINE MV_BOOL mvStackIsEmpty(void* stackHndl)
  *						MV_OK   - Success. Element is put to stack.
  */
 static INLINE void mvStackPush(void* stackHndl, MV_U32 value)
-{	
+{
     MV_STACK*   pStack = (MV_STACK*)stackHndl;
 
 #ifdef MV_RT_DEBUG
diff --git a/crypto/ocf/kirkwood/mvHal/dbg-trace.c b/crypto/ocf/kirkwood/mvHal/dbg-trace.c
index 644fd02..6576d35 100644
--- a/crypto/ocf/kirkwood/mvHal/dbg-trace.c
+++ b/crypto/ocf/kirkwood/mvHal/dbg-trace.c
@@ -87,7 +87,7 @@ void TRC_OUTPUT(void)
                 uoffs = (p->tv.tv_usec - ((plast)->tv.tv_usec));
             else
                 uoffs = (1000000 - ((plast)->tv.tv_usec)) +
-                    ((p->tv.tv_sec - ((plast)->tv.tv_sec) - 1) * 1000000) + 
+                    ((p->tv.tv_sec - ((plast)->tv.tv_sec) - 1) * 1000000) +
                     p->tv.tv_usec;
                         printk("%03d: [+%ld usec]", j, (unsigned long)uoffs);
             if(trc_callback1)
diff --git a/crypto/ocf/kirkwood/mvHal/dbg-trace.h b/crypto/ocf/kirkwood/mvHal/dbg-trace.h
index a5aac26..e3dd480 100644
--- a/crypto/ocf/kirkwood/mvHal/dbg-trace.h
+++ b/crypto/ocf/kirkwood/mvHal/dbg-trace.h
@@ -3,7 +3,7 @@
 #define _MV_DBG_TRCE_H_
 
 #ifdef CONFIG_MV_DBG_TRACE
-void TRC_INIT(void *callback1, void *callback2, 
+void TRC_INIT(void *callback1, void *callback2,
     unsigned char callback1_param, unsigned char callback2_param);
 void TRC_REC(char *fmt,...);
 void TRC_OUTPUT(void);
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.c b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.c
index 5f62784..0efeee2 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.c
@@ -360,7 +360,7 @@ MV_BOARD_MAC_SPEED      mvBoardMacSpeedGet(MV_U32 ethPortNum)
 *       None.
 *
 * RETURN:
-*       the number of the IRQ for the link status indication, -1 if the port 
+*       the number of the IRQ for the link status indication, -1 if the port
 *	number is wrong or if not relevant.
 *
 *******************************************************************************/
@@ -378,7 +378,7 @@ MV_32	mvBoardLinkStatusIrqGet(MV_U32 ethPortNum)
 }
 
 /*******************************************************************************
-* mvBoardSwitchPortGet - Get the mapping between the board connector and the 
+* mvBoardSwitchPortGet - Get the mapping between the board connector and the
 * Ethernet Switch port
 *
 * DESCRIPTION:
@@ -443,7 +443,7 @@ MV_32	mvBoardSwitchCpuPortGet(MV_U32 ethPortNum)
 }
 
 /*******************************************************************************
-* mvBoardIsSwitchConnected - Get switch connection status 
+* mvBoardIsSwitchConnected - Get switch connection status
 * DESCRIPTION:
 *       This routine returns port's connection status
 *
@@ -472,8 +472,8 @@ MV_32	mvBoardIsSwitchConnected(MV_U32 ethPortNum)
 		mvOsPrintf("mvBoardIsSwitchConnected: Illegal port number(%u)\n", ethPortNum);
 		return MV_ERROR;
 	}
-	
-	if((MV_32)(BOARD_INFO(boardId)->pSwitchInfo))	
+
+	if((MV_32)(BOARD_INFO(boardId)->pSwitchInfo))
 	return (MV_32)(BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].switchOnPort == ethPortNum);
 	else
 		return 0;
@@ -516,8 +516,8 @@ MV_32	mvBoardSmiScanModeGet(MV_U32 ethPortNum)
 * OUTPUT:
 *       None.
 *
-* RETURN: Return MV_TRUE and parameters in case board need spesific phy init, 
-* 	  otherwise return MV_FALSE. 
+* RETURN: Return MV_TRUE and parameters in case board need spesific phy init,
+* 	  otherwise return MV_FALSE.
 *
 *
 *******************************************************************************/
@@ -597,7 +597,7 @@ static MV_U32  mvBoard6180SysClkGet(MV_VOID)
 	sysClkRate = MV_REG_READ(MPP_SAMPLE_AT_RESET);
 	sysClkRate = sysClkRate & MSAR_CPUCLCK_MASK_6180;
 	sysClkRate = sysClkRate >> MSAR_CPUCLCK_OFFS_6180;
-			
+
 	sysClkRate = _cpu6180_ddr_l2_CLK[sysClkRate].ddrClk;
 
 	return sysClkRate;
@@ -1031,7 +1031,7 @@ MV_VOID mvBoardMppGroupIdUpdate(MV_VOID)
 	MV_BOARD_MPP_TYPE_CLASS mppGroupType;
 	MV_U32 devId;
 	MV_U32 maxMppGrp = 1;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -1046,7 +1046,7 @@ MV_VOID mvBoardMppGroupIdUpdate(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			maxMppGrp = MV_6180_MPP_MAX_MODULE;
-			break;		
+			break;
 	}
 
 	for (devClass = 0; devClass < maxMppGrp; devClass++)
@@ -1087,7 +1087,7 @@ MV_VOID mvBoardMppGroupIdUpdate(MV_VOID)
 			else
 				/* The module bay is empty */
 				mppGroupType = MV_BOARD_OTHER;
-			
+
 			/* Update MPP group type */
 			mvBoardMppGroupTypeSet(devClass, mppGroupType);
 		}
@@ -1095,7 +1095,7 @@ MV_VOID mvBoardMppGroupIdUpdate(MV_VOID)
 		/* Update MPP output voltage for RGMII 1.8V. Set port to GMII for GMII module */
 		if ((mvBoardMppGroupTypeGet(devClass) == MV_BOARD_RGMII))
 			MV_REG_BIT_SET(MPP_OUTPUT_DRIVE_REG,MPP_1_8_RGMII1_OUTPUT_DRIVE | MPP_1_8_RGMII0_OUTPUT_DRIVE);
-        	else 
+        	else
 		{
 			if ((mvBoardMppGroupTypeGet(devClass) == MV_BOARD_GMII))
         		{
@@ -1115,7 +1115,7 @@ MV_VOID mvBoardMppGroupIdUpdate(MV_VOID)
 }
 
 /*******************************************************************************
-* mvBoardMppGroupTypeGet 
+* mvBoardMppGroupTypeGet
 *
 * DESCRIPTION:
 *
@@ -1140,7 +1140,7 @@ MV_BOARD_MPP_TYPE_CLASS mvBoardMppGroupTypeGet(MV_BOARD_MPP_GROUP_CLASS mppGroup
 		return MV_ERROR;
 
 	}
-	
+
 	if (mppGroupClass == MV_BOARD_MPP_GROUP_1)
 		return BOARD_INFO(boardId)->pBoardMppTypeValue[0].boardMppGroup1;
 	else
@@ -1148,7 +1148,7 @@ MV_BOARD_MPP_TYPE_CLASS mvBoardMppGroupTypeGet(MV_BOARD_MPP_GROUP_CLASS mppGroup
 }
 
 /*******************************************************************************
-* mvBoardMppGroupTypeSet 
+* mvBoardMppGroupTypeSet
 *
 * DESCRIPTION:
 *
@@ -1204,7 +1204,7 @@ MV_VOID mvBoardMppMuxSet(MV_VOID)
 	MV_U32 maxMppGrp = 1;
     MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -1219,7 +1219,7 @@ MV_VOID mvBoardMppMuxSet(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			maxMppGrp = MV_6180_MPP_MAX_MODULE;
-			break;		
+			break;
 	}
 
 	for (devClass = 0; devClass < maxMppGrp; devClass++)
@@ -1243,7 +1243,7 @@ MV_VOID mvBoardMppMuxSet(MV_VOID)
 		}
 	}
 
-	/* TWSI init */    	
+	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
@@ -1253,7 +1253,7 @@ MV_VOID mvBoardMppMuxSet(MV_VOID)
     	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(MV_BOARD_MUX_I2C_ADDR_ENTRY);
     	twsiSlave.slaveAddr.type = mvBoardTwsiExpAddrTypeGet(MV_BOARD_MUX_I2C_ADDR_ENTRY);
     	twsiSlave.validOffset = MV_TRUE;
-	/* Offset is the first command after the address which indicate the register number to be read 
+	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
     	twsiSlave.offset = 2;
     	twsiSlave.moreThen256 = MV_FALSE;
@@ -1266,7 +1266,7 @@ MV_VOID mvBoardMppMuxSet(MV_VOID)
         	return;
     	}
     	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
-    	
+
 	/* Change twsi exp to output */
     	twsiSlave.offset = 6;
 	muxVal = 0;
@@ -1276,7 +1276,7 @@ MV_VOID mvBoardMppMuxSet(MV_VOID)
         	return;
     	}
     	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
-	
+
 }
 
 /*******************************************************************************
@@ -1304,7 +1304,7 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	MV_U32 maxMppGrp = 1;
     	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -1319,7 +1319,7 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
             break;
 		case MV_6180_DEV_ID:
 			maxMppGrp = MV_6180_MPP_MAX_MODULE;
-			break;		
+			break;
 	}
 
 	for (devClass = 0; devClass < maxMppGrp; devClass++)
@@ -1332,7 +1332,7 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	if(devClass == maxMppGrp)
 		return;		/* TDM module not found */
 
-	/* TWSI init */    	
+	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
@@ -1342,7 +1342,7 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
     	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(devClass);
     	twsiSlave.slaveAddr.type = ADDR7_BIT;
     	twsiSlave.validOffset = MV_TRUE;
-	/* Offset is the first command after the address which indicate the register number to be read 
+	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
     	twsiSlave.offset = 3;
     	twsiSlave.moreThen256 = MV_FALSE;
@@ -1362,7 +1362,7 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
         	return;
     	}
     	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
-    	
+
 	/* Change twsi exp to output */
     	twsiSlave.offset = 7;
 	muxVal = 0xfe;
@@ -1418,8 +1418,8 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 		else /* FXO - issue reset via TDM_CODEC_RST*/
 		{
 		   /* change MPP44 type to TDM_CODEC_RST(0x2) */
-		   MV_REG_WRITE(MPP_CONTROL_REG5, ((MV_REG_READ(MPP_CONTROL_REG5) & 0xFFF0FFFF)  | BIT17));	
-		}	
+		   MV_REG_WRITE(MPP_CONTROL_REG5, ((MV_REG_READ(MPP_CONTROL_REG5) & 0xFFF0FFFF)  | BIT17));
+		}
 	}
 
 	mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
@@ -1436,7 +1436,7 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	/* change MPP38 type to GPIO(0x0) & polarity for TDM_STROBE */
 	MV_REG_WRITE(MPP_CONTROL_REG4, (MV_REG_READ(MPP_CONTROL_REG4) & 0xF0FFFFFF));
 	mvGppPolaritySet(1, MV_GPP6, 0);
-	
+
 	twsiSlave.offset = 6;
 	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(2);
 
@@ -1463,10 +1463,10 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 #endif
     	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
 
-	
+
 }
 /*******************************************************************************
-* mvBoardVoiceConnModeGet - return SLIC/DAA connection & interrupt modes  
+* mvBoardVoiceConnModeGet - return SLIC/DAA connection & interrupt modes
 *
 * DESCRIPTION:
 *
@@ -1504,7 +1504,7 @@ MV_VOID mvBoardVoiceConnModeGet(MV_32* connMode, MV_32* irqMode)
 			mvOsPrintf("mvBoardVoiceAssembleModeGet: TDM not supported(boardId=0x%x)\n",mvBoardIdGet());
 	}
 		return;
-	
+
 }
 
 /*******************************************************************************
@@ -1527,7 +1527,7 @@ MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
 	MV_BOARD_MPP_TYPE_CLASS mppGroupType;
 	MV_U32 devId;
 	MV_U32 maxMppGrp = 1;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -1542,7 +1542,7 @@ MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			maxMppGrp = MV_6180_MPP_MAX_MODULE;
-			break;		
+			break;
 	}
 
 	for (devClass = 0; devClass < maxMppGrp; devClass++)
@@ -1676,7 +1676,7 @@ MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
 	devEntry = boardGetDevEntry(devNum,devClass);
 	if (devEntry != NULL)
 	{
-		return 8; 
+		return 8;
 	}
 
 	return 0xFFFFFFFF;
@@ -2088,7 +2088,7 @@ MV_32 mvBoardNandWidthGet(void)
 		if (devWidth != MV_ERROR)
 			return (devWidth / 8);
 	}
-		
+
 	/* NAND wasn't found */
 	return MV_ERROR;
 }
@@ -2168,7 +2168,7 @@ MV_BOARD_MODULE_ID_CLASS mvBoarModuleTypeGet(MV_BOARD_MPP_GROUP_CLASS devClass)
 	MV_TWSI_ADDR slave;
     	MV_U8 data;
 
-	/* TWSI init */    	
+	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
@@ -2178,7 +2178,7 @@ MV_BOARD_MODULE_ID_CLASS mvBoarModuleTypeGet(MV_BOARD_MPP_GROUP_CLASS devClass)
     	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(devClass);
     	twsiSlave.slaveAddr.type = mvBoardTwsiExpAddrTypeGet(devClass);
     	twsiSlave.validOffset = MV_TRUE;
-	/* Offset is the first command after the address which indicate the register number to be read 
+	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
     	twsiSlave.offset = 0;
     	twsiSlave.moreThen256 = MV_FALSE;
@@ -2191,12 +2191,12 @@ MV_BOARD_MODULE_ID_CLASS mvBoarModuleTypeGet(MV_BOARD_MPP_GROUP_CLASS devClass)
         	return MV_ERROR;
     	}
     	DB(mvOsPrintf("Board: Read MPP module ID succeded\n"));
-	
+
 	return data;
 }
 
 /*******************************************************************************
-* mvBoarTwsiSatRGet - 
+* mvBoarTwsiSatRGet -
 *
 * DESCRIPTION:
 *
@@ -2217,7 +2217,7 @@ MV_U8 mvBoarTwsiSatRGet(MV_U8 devNum, MV_U8 regNum)
 	MV_TWSI_ADDR slave;
     	MV_U8 data;
 
-	/* TWSI init */    	
+	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
@@ -2237,12 +2237,12 @@ MV_U8 mvBoarTwsiSatRGet(MV_U8 devNum, MV_U8 regNum)
         	return MV_ERROR;
     	}
     	DB(mvOsPrintf("Board: Read S@R succeded\n"));
-	
+
 	return data;
 }
 
 /*******************************************************************************
-* mvBoarTwsiSatRSet - 
+* mvBoarTwsiSatRSet -
 *
 * DESCRIPTION:
 *
@@ -2263,8 +2263,8 @@ MV_STATUS mvBoarTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
 {
     	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
-	
-	/* TWSI init */    	
+
+	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
@@ -2284,7 +2284,7 @@ MV_STATUS mvBoarTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
         	return MV_ERROR;
     	}
     	DB(mvOsPrintf("Board: Write S@R succeded\n"));
-	
+
 	return MV_OK;
 }
 
@@ -2338,11 +2338,11 @@ MV_STATUS mvBoardFanPowerControl(MV_BOOL mode)
 	MV_U8 val = 1, twsiVal;
    	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
-	
+
 	if(mvBoardIdGet() != RD_88F6281A_ID)
         return MV_ERROR;
 
-	/* TWSI init */    	
+	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
@@ -2352,7 +2352,7 @@ MV_STATUS mvBoardFanPowerControl(MV_BOOL mode)
     	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(1);
     	twsiSlave.slaveAddr.type = ADDR7_BIT;
     	twsiSlave.validOffset = MV_TRUE;
-	/* Offset is the first command after the address which indicate the register number to be read 
+	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
     	twsiSlave.offset = 3;
     	twsiSlave.moreThen256 = MV_FALSE;
@@ -2369,7 +2369,7 @@ MV_STATUS mvBoardFanPowerControl(MV_BOOL mode)
         	return MV_ERROR;
     	}
     	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
-    	
+
 	/* Change twsi exp to output */
     	twsiSlave.offset = 7;
         mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
@@ -2403,11 +2403,11 @@ MV_STATUS mvBoardHDDPowerControl(MV_BOOL mode)
 	MV_U8 val = 1, twsiVal;
    	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
-	
+
 	if(mvBoardIdGet() != RD_88F6281A_ID)
         return MV_ERROR;
 
-	/* TWSI init */    	
+	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
@@ -2417,7 +2417,7 @@ MV_STATUS mvBoardHDDPowerControl(MV_BOOL mode)
     	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(1);
     	twsiSlave.slaveAddr.type = ADDR7_BIT;
     	twsiSlave.validOffset = MV_TRUE;
-	/* Offset is the first command after the address which indicate the register number to be read 
+	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
     	twsiSlave.offset = 3;
     	twsiSlave.moreThen256 = MV_FALSE;
@@ -2433,7 +2433,7 @@ MV_STATUS mvBoardHDDPowerControl(MV_BOOL mode)
         	return MV_ERROR;
     	}
     	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
-    	
+
 	/* Change twsi exp to output */
     	twsiSlave.offset = 7;
         mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
@@ -2467,11 +2467,11 @@ MV_STATUS mvBoardSDioWPControl(MV_BOOL mode)
 	MV_U8 val = 1, twsiVal;
    	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
-	
+
 	if(mvBoardIdGet() != RD_88F6281A_ID)
         return MV_ERROR;
 
-	/* TWSI init */    	
+	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
@@ -2481,7 +2481,7 @@ MV_STATUS mvBoardSDioWPControl(MV_BOOL mode)
     	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(0);
     	twsiSlave.slaveAddr.type = ADDR7_BIT;
     	twsiSlave.validOffset = MV_TRUE;
-	/* Offset is the first command after the address which indicate the register number to be read 
+	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
     	twsiSlave.offset = 3;
     	twsiSlave.moreThen256 = MV_FALSE;
@@ -2497,7 +2497,7 @@ MV_STATUS mvBoardSDioWPControl(MV_BOOL mode)
         	return MV_ERROR;
     	}
     	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
-    	
+
 	/* Change twsi exp to output */
     	twsiSlave.offset = 7;
         mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.h b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.h
index dead633..b7ee2e7 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.h
@@ -161,7 +161,7 @@ typedef enum _devTwsiBoardClass
 	BOARD_TWSI_AUDIO_DEC,
 	BOARD_TWSI_OTHER
 }MV_BOARD_TWSI_CLASS;
-	
+
 typedef enum _devGppBoardClass
 {
 	BOARD_GPP_RTC,
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.c b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.c
index e256c4f..e5246f3 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -94,20 +94,20 @@ MV_BOARD_TWSI_INFO	db88f6281AInfoBoardTwsiDev[] =
 	{BOARD_TWSI_AUDIO_DEC, 0x4A, ADDR7_BIT}
 	};
 
-MV_BOARD_MAC_INFO db88f6281AInfoBoardMacInfo[] = 
+MV_BOARD_MAC_INFO db88f6281AInfoBoardMacInfo[] =
 	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
 	{
 	{BOARD_MAC_SPEED_AUTO, 0x8},
 	{BOARD_MAC_SPEED_AUTO, 0x9}
-	}; 
+	};
 
-MV_BOARD_MPP_TYPE_INFO db88f6281AInfoBoardMppTypeInfo[] = 
+MV_BOARD_MPP_TYPE_INFO db88f6281AInfoBoardMppTypeInfo[] =
 	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
  		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
 	{{MV_BOARD_AUTO, MV_BOARD_AUTO}
-	}; 
+	};
 
-MV_BOARD_GPP_INFO db88f6281AInfoBoardGppInfo[] = 
+MV_BOARD_GPP_INFO db88f6281AInfoBoardGppInfo[] =
 	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
 	{
 	{BOARD_GPP_TSU_DIRCTION, 33}
@@ -116,28 +116,28 @@ MV_BOARD_GPP_INFO db88f6281AInfoBoardGppInfo[] =
 	{BOARD_GPP_USB_VBUS, 49}*/
 	};
 
-MV_DEV_CS_INFO db88f6281AInfoBoardDeCsInfo[] = 
-		/*{deviceCS, params, devType, devWidth}*/			   
+MV_DEV_CS_INFO db88f6281AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
 #if defined(MV_NAND) && defined(MV_NAND_BOOT)
-		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */         
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
 #elif defined(MV_NAND) && defined(MV_SPI_BOOT)
 		 {
          {0, N_A, BOARD_DEV_NAND_FLASH, 8},	   /* NAND DEV */
          {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
          };
 #else
-	 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */         
+	 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
 #endif
 
-MV_BOARD_MPP_INFO	db88f6281AInfoBoardMppConfigValue[] = 
+MV_BOARD_MPP_INFO	db88f6281AInfoBoardMppConfigValue[] =
 	{{{
-	DB_88F6281A_MPP0_7,		
-	DB_88F6281A_MPP8_15,		
-	DB_88F6281A_MPP16_23,		
-	DB_88F6281A_MPP24_31,		
-	DB_88F6281A_MPP32_39,		
-	DB_88F6281A_MPP40_47,		
-	DB_88F6281A_MPP48_55		
+	DB_88F6281A_MPP0_7,
+	DB_88F6281A_MPP8_15,
+	DB_88F6281A_MPP16_23,
+	DB_88F6281A_MPP24_31,
+	DB_88F6281A_MPP32_39,
+	DB_88F6281A_MPP40_47,
+	DB_88F6281A_MPP48_55
 	}}};
 
 
@@ -152,14 +152,14 @@ MV_BOARD_INFO db88f6281AInfo = {
 	DB_88F6281A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
 	db88f6281AInfoBoardDeCsInfo,
 	DB_88F6281A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
-	db88f6281AInfoBoardTwsiDev,					
+	db88f6281AInfoBoardTwsiDev,
 	DB_88F6281A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
 	db88f6281AInfoBoardMacInfo,
 	DB_88F6281A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
 	db88f6281AInfoBoardGppInfo,
-	DB_88F6281A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */              
+	DB_88F6281A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
 	NULL,
-	0,						/* ledsPolarity */		
+	0,						/* ledsPolarity */
 	DB_88F6281A_OE_LOW,				/* gppOutEnLow */
 	DB_88F6281A_OE_HIGH,				/* gppOutEnHigh */
 	DB_88F6281A_OE_VAL_LOW,				/* gppOutValLow */
@@ -185,14 +185,14 @@ MV_BOARD_INFO db88f6281AInfo = {
 #endif
 #define RD_88F6281A_BOARD_DEBUG_LED_NUM		0x0
 
-MV_BOARD_MAC_INFO rd88f6281AInfoBoardMacInfo[] = 
+MV_BOARD_MAC_INFO rd88f6281AInfoBoardMacInfo[] =
 	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
 	{{BOARD_MAC_SPEED_1000M, 0xa},
     {BOARD_MAC_SPEED_AUTO, 0xb}
-	}; 
+	};
 
-MV_BOARD_SWITCH_INFO rd88f6281AInfoBoardSwitchInfo[] = 
-	/* MV_32 linkStatusIrq, {MV_32 qdPort0, MV_32 qdPort1, MV_32 qdPort2, MV_32 qdPort3, MV_32 qdPort4}, 
+MV_BOARD_SWITCH_INFO rd88f6281AInfoBoardSwitchInfo[] =
+	/* MV_32 linkStatusIrq, {MV_32 qdPort0, MV_32 qdPort1, MV_32 qdPort2, MV_32 qdPort3, MV_32 qdPort4},
 		MV_32 qdCpuPort, MV_32 smiScanMode, MV_32 switchOnPort} */
 	{{38, {0, 1, 2, 3, -1}, 5, 2, 0},
 	 {-1, {-1}, -1, -1, -1}};
@@ -204,12 +204,12 @@ MV_BOARD_TWSI_INFO	rd88f6281AInfoBoardTwsiDev[] =
 	{BOARD_DEV_TWSI_EXP, 0x27, ADDR7_BIT}
 	};
 
-MV_BOARD_MPP_TYPE_INFO rd88f6281AInfoBoardMppTypeInfo[] = 
+MV_BOARD_MPP_TYPE_INFO rd88f6281AInfoBoardMppTypeInfo[] =
 	{{MV_BOARD_RGMII, MV_BOARD_TDM}
-	}; 
+	};
 
-MV_DEV_CS_INFO rd88f6281AInfoBoardDeCsInfo[] = 
-		/*{deviceCS, params, devType, devWidth}*/			   
+MV_DEV_CS_INFO rd88f6281AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
 #if defined(MV_NAND) && defined(MV_NAND_BOOT)
 		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
 #elif defined(MV_NAND) && defined(MV_SPI_BOOT)
@@ -218,10 +218,10 @@ MV_DEV_CS_INFO rd88f6281AInfoBoardDeCsInfo[] =
          {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
          };
 #else
-		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */         
+		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
 #endif
 
-MV_BOARD_GPP_INFO rd88f6281AInfoBoardGppInfo[] = 
+MV_BOARD_GPP_INFO rd88f6281AInfoBoardGppInfo[] =
 	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
 	{{BOARD_GPP_SDIO_DETECT, 28},
     {BOARD_GPP_USB_OC, 29},
@@ -230,15 +230,15 @@ MV_BOARD_GPP_INFO rd88f6281AInfoBoardGppInfo[] =
     {BOARD_GPP_USB_VBUS, 49}
 	};
 
-MV_BOARD_MPP_INFO	rd88f6281AInfoBoardMppConfigValue[] = 
+MV_BOARD_MPP_INFO	rd88f6281AInfoBoardMppConfigValue[] =
 	{{{
-	RD_88F6281A_MPP0_7,		
-	RD_88F6281A_MPP8_15,		
-	RD_88F6281A_MPP16_23,		
-	RD_88F6281A_MPP24_31,		
-	RD_88F6281A_MPP32_39,		
-	RD_88F6281A_MPP40_47,		
-	RD_88F6281A_MPP48_55		
+	RD_88F6281A_MPP0_7,
+	RD_88F6281A_MPP8_15,
+	RD_88F6281A_MPP16_23,
+	RD_88F6281A_MPP24_31,
+	RD_88F6281A_MPP32_39,
+	RD_88F6281A_MPP40_47,
+	RD_88F6281A_MPP48_55
 	}}};
 
 MV_BOARD_INFO rd88f6281AInfo = {
@@ -252,14 +252,14 @@ MV_BOARD_INFO rd88f6281AInfo = {
 	RD_88F6281A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
 	rd88f6281AInfoBoardDeCsInfo,
 	RD_88F6281A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
-	rd88f6281AInfoBoardTwsiDev,					
+	rd88f6281AInfoBoardTwsiDev,
 	RD_88F6281A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
 	rd88f6281AInfoBoardMacInfo,
 	RD_88F6281A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
 	rd88f6281AInfoBoardGppInfo,
-	RD_88F6281A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */              
+	RD_88F6281A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
 	NULL,
-	0,										/* ledsPolarity */		
+	0,										/* ledsPolarity */
 	RD_88F6281A_OE_LOW,				/* gppOutEnLow */
 	RD_88F6281A_OE_HIGH,				/* gppOutEnHigh */
 	RD_88F6281A_OE_VAL_LOW,				/* gppOutValLow */
@@ -297,21 +297,21 @@ MV_BOARD_TWSI_INFO	db88f6192AInfoBoardTwsiDev[] =
 	{BOARD_TWSI_AUDIO_DEC, 0x4A, ADDR7_BIT}
 	};
 
-MV_BOARD_MAC_INFO db88f6192AInfoBoardMacInfo[] = 
+MV_BOARD_MAC_INFO db88f6192AInfoBoardMacInfo[] =
 	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
 	{
 	{BOARD_MAC_SPEED_AUTO, 0x8},
 	{BOARD_MAC_SPEED_AUTO, 0x9}
-	}; 
+	};
 
-MV_BOARD_MPP_TYPE_INFO db88f6192AInfoBoardMppTypeInfo[] = 
+MV_BOARD_MPP_TYPE_INFO db88f6192AInfoBoardMppTypeInfo[] =
 	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
  		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
 	{{MV_BOARD_AUTO, MV_BOARD_OTHER}
-	}; 
+	};
 
-MV_DEV_CS_INFO db88f6192AInfoBoardDeCsInfo[] = 
-		/*{deviceCS, params, devType, devWidth}*/			   
+MV_DEV_CS_INFO db88f6192AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
 #if defined(MV_NAND) && defined(MV_NAND_BOOT)
 		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
 #elif defined(MV_NAND) && defined(MV_SPI_BOOT)
@@ -320,10 +320,10 @@ MV_DEV_CS_INFO db88f6192AInfoBoardDeCsInfo[] =
          {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
          };
 #else
-		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */         
+		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
 #endif
 
-MV_BOARD_GPP_INFO db88f6192AInfoBoardGppInfo[] = 
+MV_BOARD_GPP_INFO db88f6192AInfoBoardGppInfo[] =
 	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
 	{
     {BOARD_GPP_SDIO_WP, 20},
@@ -331,12 +331,12 @@ MV_BOARD_GPP_INFO db88f6192AInfoBoardGppInfo[] =
 	{BOARD_GPP_SDIO_DETECT, 23},
 	};
 
-MV_BOARD_MPP_INFO	db88f6192AInfoBoardMppConfigValue[] = 
+MV_BOARD_MPP_INFO	db88f6192AInfoBoardMppConfigValue[] =
 	{{{
-	DB_88F6192A_MPP0_7,		
-	DB_88F6192A_MPP8_15,		
-	DB_88F6192A_MPP16_23,		
-	DB_88F6192A_MPP24_31,		
+	DB_88F6192A_MPP0_7,
+	DB_88F6192A_MPP8_15,
+	DB_88F6192A_MPP16_23,
+	DB_88F6192A_MPP24_31,
 	DB_88F6192A_MPP32_35
 	}}};
 
@@ -351,14 +351,14 @@ MV_BOARD_INFO db88f6192AInfo = {
 	DB_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
 	db88f6192AInfoBoardDeCsInfo,
 	DB_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
-	db88f6192AInfoBoardTwsiDev,					
+	db88f6192AInfoBoardTwsiDev,
 	DB_88F6192A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
 	db88f6192AInfoBoardMacInfo,
 	DB_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
 	db88f6192AInfoBoardGppInfo,
-	DB_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */              
+	DB_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
 	NULL,
-	0,										/* ledsPolarity */		
+	0,										/* ledsPolarity */
 	DB_88F6192A_OE_LOW,				/* gppOutEnLow */
 	DB_88F6192A_OE_HIGH,				/* gppOutEnHigh */
 	DB_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
@@ -381,14 +381,14 @@ MV_BOARD_INFO db88f6190AInfo = {
 	DB_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
 	db88f6192AInfoBoardDeCsInfo,
 	DB_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
-	db88f6192AInfoBoardTwsiDev,					
+	db88f6192AInfoBoardTwsiDev,
 	DB_88F6190A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
 	db88f6192AInfoBoardMacInfo,
 	DB_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
 	db88f6192AInfoBoardGppInfo,
-	DB_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */              
+	DB_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
 	NULL,
-	0,										/* ledsPolarity */		
+	0,										/* ledsPolarity */
 	DB_88F6192A_OE_LOW,				/* gppOutEnLow */
 	DB_88F6192A_OE_HIGH,				/* gppOutEnHigh */
 	DB_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
@@ -410,22 +410,22 @@ MV_BOARD_INFO db88f6190AInfo = {
 MV_U8	rd88f6192AInfoBoardDebugLedIf[] =
 	{17, 28, 29};
 
-MV_BOARD_MAC_INFO rd88f6192AInfoBoardMacInfo[] = 
+MV_BOARD_MAC_INFO rd88f6192AInfoBoardMacInfo[] =
 	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
 	{{BOARD_MAC_SPEED_AUTO, 0x8}
-	}; 
+	};
 
-MV_BOARD_MPP_TYPE_INFO rd88f6192AInfoBoardMppTypeInfo[] = 
+MV_BOARD_MPP_TYPE_INFO rd88f6192AInfoBoardMppTypeInfo[] =
 	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
  		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
 	{{MV_BOARD_OTHER, MV_BOARD_OTHER}
-	}; 
+	};
 
-MV_DEV_CS_INFO rd88f6192AInfoBoardDeCsInfo[] = 
-		/*{deviceCS, params, devType, devWidth}*/			   
+MV_DEV_CS_INFO rd88f6192AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
 		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
 
-MV_BOARD_GPP_INFO rd88f6192AInfoBoardGppInfo[] = 
+MV_BOARD_GPP_INFO rd88f6192AInfoBoardGppInfo[] =
 	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
 	{
 	{BOARD_GPP_USB_VBUS_EN, 10},
@@ -444,12 +444,12 @@ MV_BOARD_GPP_INFO rd88f6192AInfoBoardGppInfo[] =
 	{BOARD_GPP_FAN_POWER, 35}
 	};
 
-MV_BOARD_MPP_INFO	rd88f6192AInfoBoardMppConfigValue[] = 
+MV_BOARD_MPP_INFO	rd88f6192AInfoBoardMppConfigValue[] =
 	{{{
-	RD_88F6192A_MPP0_7,		
-	RD_88F6192A_MPP8_15,		
-	RD_88F6192A_MPP16_23,		
-	RD_88F6192A_MPP24_31,		
+	RD_88F6192A_MPP0_7,
+	RD_88F6192A_MPP8_15,
+	RD_88F6192A_MPP16_23,
+	RD_88F6192A_MPP24_31,
 	RD_88F6192A_MPP32_35
 	}}};
 
@@ -464,14 +464,14 @@ MV_BOARD_INFO rd88f6192AInfo = {
 	RD_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
 	rd88f6192AInfoBoardDeCsInfo,
 	RD_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
-	NULL,					
+	NULL,
 	RD_88F6192A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
 	rd88f6192AInfoBoardMacInfo,
 	RD_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
 	rd88f6192AInfoBoardGppInfo,
-	RD_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */              
+	RD_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
 	rd88f6192AInfoBoardDebugLedIf,
-	0,										/* ledsPolarity */		
+	0,										/* ledsPolarity */
 	RD_88F6192A_OE_LOW,				/* gppOutEnLow */
 	RD_88F6192A_OE_HIGH,				/* gppOutEnHigh */
 	RD_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
@@ -492,14 +492,14 @@ MV_BOARD_INFO rd88f6190AInfo = {
 	RD_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
 	rd88f6192AInfoBoardDeCsInfo,
 	RD_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
-	NULL,					
+	NULL,
 	RD_88F6192A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
 	rd88f6192AInfoBoardMacInfo,
 	RD_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
 	rd88f6192AInfoBoardGppInfo,
-	RD_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */              
+	RD_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
 	rd88f6192AInfoBoardDebugLedIf,
-	0,										/* ledsPolarity */		
+	0,										/* ledsPolarity */
 	RD_88F6192A_OE_LOW,				/* gppOutEnLow */
 	RD_88F6192A_OE_HIGH,				/* gppOutEnHigh */
 	RD_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
@@ -528,38 +528,38 @@ MV_BOARD_TWSI_INFO	db88f6180AInfoBoardTwsiDev[] =
 	{BOARD_TWSI_AUDIO_DEC, 0x4A, ADDR7_BIT}
 	};
 
-MV_BOARD_MAC_INFO db88f6180AInfoBoardMacInfo[] = 
+MV_BOARD_MAC_INFO db88f6180AInfoBoardMacInfo[] =
 	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
 	{{BOARD_MAC_SPEED_AUTO, 0x8}
-	}; 
+	};
 
-MV_BOARD_GPP_INFO db88f6180AInfoBoardGppInfo[] = 
+MV_BOARD_GPP_INFO db88f6180AInfoBoardGppInfo[] =
 	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
 	{
 	/* Muxed with TDM/Audio module via IOexpender
 	{BOARD_GPP_USB_VBUS, 6} */
 	};
 
-MV_BOARD_MPP_TYPE_INFO db88f6180AInfoBoardMppTypeInfo[] = 
+MV_BOARD_MPP_TYPE_INFO db88f6180AInfoBoardMppTypeInfo[] =
 	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
  		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
 	{{MV_BOARD_OTHER, MV_BOARD_AUTO}
-	}; 
+	};
 
-MV_DEV_CS_INFO db88f6180AInfoBoardDeCsInfo[] = 
-		/*{deviceCS, params, devType, devWidth}*/			   
+MV_DEV_CS_INFO db88f6180AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
 #if defined(MV_NAND_BOOT)
-		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */         
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
 #else
-		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */         
+		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
 #endif
 
-MV_BOARD_MPP_INFO	db88f6180AInfoBoardMppConfigValue[] = 
+MV_BOARD_MPP_INFO	db88f6180AInfoBoardMppConfigValue[] =
 	{{{
-	DB_88F6180A_MPP0_7,		
+	DB_88F6180A_MPP0_7,
 	DB_88F6180A_MPP8_15,
     DB_88F6180A_MPP16_23,
-    DB_88F6180A_MPP24_31,		
+    DB_88F6180A_MPP24_31,
     DB_88F6180A_MPP32_39,
     DB_88F6180A_MPP40_44
 	}}};
@@ -575,14 +575,14 @@ MV_BOARD_INFO db88f6180AInfo = {
 	DB_88F6180A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
 	db88f6180AInfoBoardDeCsInfo,
 	DB_88F6180A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
-	db88f6180AInfoBoardTwsiDev,					
+	db88f6180AInfoBoardTwsiDev,
 	DB_88F6180A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
 	db88f6180AInfoBoardMacInfo,
 	DB_88F6180A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
 	NULL,
-	DB_88F6180A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */              
+	DB_88F6180A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
 	NULL,
-	0,										/* ledsPolarity */		
+	0,										/* ledsPolarity */
 	DB_88F6180A_OE_LOW,				/* gppOutEnLow */
 	DB_88F6180A_OE_HIGH,				/* gppOutEnHigh */
 	DB_88F6180A_OE_VAL_LOW,				/* gppOutValLow */
@@ -611,10 +611,10 @@ MV_BOARD_INFO db88f6180AInfo = {
 MV_U8	rd88f6281APcacInfoBoardDebugLedIf[] =
 	{38, 39, 40, 41};
 
-MV_BOARD_MAC_INFO rd88f6281APcacInfoBoardMacInfo[] = 
+MV_BOARD_MAC_INFO rd88f6281APcacInfoBoardMacInfo[] =
 	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
 	{{BOARD_MAC_SPEED_AUTO, 0x8}
-	}; 
+	};
 
 MV_BOARD_TWSI_INFO	rd88f6281APcacInfoBoardTwsiDev[] =
 	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
@@ -622,12 +622,12 @@ MV_BOARD_TWSI_INFO	rd88f6281APcacInfoBoardTwsiDev[] =
 	{BOARD_TWSI_OTHER, 0xa7, ADDR7_BIT}
 	};
 
-MV_BOARD_MPP_TYPE_INFO rd88f6281APcacInfoBoardMppTypeInfo[] = 
+MV_BOARD_MPP_TYPE_INFO rd88f6281APcacInfoBoardMppTypeInfo[] =
 	{{MV_BOARD_OTHER, MV_BOARD_OTHER}
-	}; 
+	};
 
-MV_DEV_CS_INFO rd88f6281APcacInfoBoardDeCsInfo[] = 
-		/*{deviceCS, params, devType, devWidth}*/			   
+MV_DEV_CS_INFO rd88f6281APcacInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
 #if defined(MV_NAND) && defined(MV_NAND_BOOT)
 		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
 #elif defined(MV_NAND) && defined(MV_SPI_BOOT)
@@ -636,18 +636,18 @@ MV_DEV_CS_INFO rd88f6281APcacInfoBoardDeCsInfo[] =
          {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
          };
 #else
-	 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */         
+	 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
 #endif
 
-MV_BOARD_MPP_INFO	rd88f6281APcacInfoBoardMppConfigValue[] = 
+MV_BOARD_MPP_INFO	rd88f6281APcacInfoBoardMppConfigValue[] =
 	{{{
-	RD_88F6281A_PCAC_MPP0_7,		
-	RD_88F6281A_PCAC_MPP8_15,		
-	RD_88F6281A_PCAC_MPP16_23,		
-	RD_88F6281A_PCAC_MPP24_31,		
-	RD_88F6281A_PCAC_MPP32_39,		
-	RD_88F6281A_PCAC_MPP40_47,		
-	RD_88F6281A_PCAC_MPP48_55		
+	RD_88F6281A_PCAC_MPP0_7,
+	RD_88F6281A_PCAC_MPP8_15,
+	RD_88F6281A_PCAC_MPP16_23,
+	RD_88F6281A_PCAC_MPP24_31,
+	RD_88F6281A_PCAC_MPP32_39,
+	RD_88F6281A_PCAC_MPP40_47,
+	RD_88F6281A_PCAC_MPP48_55
 	}}};
 
 MV_BOARD_INFO rd88f6281APcacInfo = {
@@ -661,14 +661,14 @@ MV_BOARD_INFO rd88f6281APcacInfo = {
 	RD_88F6281A_PCAC_BOARD_DEVICE_CONFIG_NUM,	/* numBoardDevIf */
 	rd88f6281APcacInfoBoardDeCsInfo,
 	RD_88F6281A_PCAC_BOARD_TWSI_DEF_NUM,		/* numBoardTwsiDev */
-	rd88f6281APcacInfoBoardTwsiDev,					
+	rd88f6281APcacInfoBoardTwsiDev,
 	RD_88F6281A_PCAC_BOARD_MAC_INFO_NUM,		/* numBoardMacInfo */
 	rd88f6281APcacInfoBoardMacInfo,
 	RD_88F6281A_PCAC_BOARD_GPP_INFO_NUM,		/* numBoardGppInfo */
 	0,
-	RD_88F6281A_PCAC_BOARD_DEBUG_LED_NUM,		/* activeLedsNumber */              
+	RD_88F6281A_PCAC_BOARD_DEBUG_LED_NUM,		/* activeLedsNumber */
 	NULL,
-	0,										/* ledsPolarity */		
+	0,										/* ledsPolarity */
 	RD_88F6281A_PCAC_OE_LOW,			/* gppOutEnLow */
 	RD_88F6281A_PCAC_OE_HIGH,			/* gppOutEnHigh */
 	RD_88F6281A_PCAC_OE_VAL_LOW,			/* gppOutValLow */
@@ -693,31 +693,31 @@ MV_BOARD_INFO rd88f6281APcacInfo = {
 MV_U8	sheevaPlugInfoBoardDebugLedIf[] =
 	{49};
 
-MV_BOARD_MAC_INFO sheevaPlugInfoBoardMacInfo[] = 
+MV_BOARD_MAC_INFO sheevaPlugInfoBoardMacInfo[] =
     /* {{MV_BOARD_MAC_SPEED	boardMacSpeed,	MV_U8	boardEthSmiAddr}} */
-	{{BOARD_MAC_SPEED_AUTO, 0x0}}; 
+	{{BOARD_MAC_SPEED_AUTO, 0x0}};
 
 MV_BOARD_TWSI_INFO	sheevaPlugInfoBoardTwsiDev[] =
 	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
 	{{BOARD_TWSI_OTHER, 0x0, ADDR7_BIT}};
 
-MV_BOARD_MPP_TYPE_INFO sheevaPlugInfoBoardMppTypeInfo[] = 
+MV_BOARD_MPP_TYPE_INFO sheevaPlugInfoBoardMppTypeInfo[] =
 	{{MV_BOARD_OTHER, MV_BOARD_OTHER}
-	}; 
+	};
 
-MV_DEV_CS_INFO sheevaPlugInfoBoardDeCsInfo[] = 
-		/*{deviceCS, params, devType, devWidth}*/			   
+MV_DEV_CS_INFO sheevaPlugInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
 		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
 
-MV_BOARD_MPP_INFO	sheevaPlugInfoBoardMppConfigValue[] = 
+MV_BOARD_MPP_INFO	sheevaPlugInfoBoardMppConfigValue[] =
 	{{{
-	RD_SHEEVA_PLUG_MPP0_7,		
-	RD_SHEEVA_PLUG_MPP8_15,		
-	RD_SHEEVA_PLUG_MPP16_23,		
-	RD_SHEEVA_PLUG_MPP24_31,		
-	RD_SHEEVA_PLUG_MPP32_39,		
-	RD_SHEEVA_PLUG_MPP40_47,		
-	RD_SHEEVA_PLUG_MPP48_55		
+	RD_SHEEVA_PLUG_MPP0_7,
+	RD_SHEEVA_PLUG_MPP8_15,
+	RD_SHEEVA_PLUG_MPP16_23,
+	RD_SHEEVA_PLUG_MPP24_31,
+	RD_SHEEVA_PLUG_MPP32_39,
+	RD_SHEEVA_PLUG_MPP40_47,
+	RD_SHEEVA_PLUG_MPP48_55
 	}}};
 
 MV_BOARD_INFO sheevaPlugInfo = {
@@ -731,14 +731,14 @@ MV_BOARD_INFO sheevaPlugInfo = {
 	SHEEVA_PLUG_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
 	sheevaPlugInfoBoardDeCsInfo,
 	SHEEVA_PLUG_BOARD_TWSI_DEF_NUM,			    /* numBoardTwsiDev */
-	sheevaPlugInfoBoardTwsiDev,					
+	sheevaPlugInfoBoardTwsiDev,
 	SHEEVA_PLUG_BOARD_MAC_INFO_NUM,			    /* numBoardMacInfo */
 	sheevaPlugInfoBoardMacInfo,
 	SHEEVA_PLUG_BOARD_GPP_INFO_NUM,			    /* numBoardGppInfo */
 	0,
-	SHEEVA_PLUG_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */              
+	SHEEVA_PLUG_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
 	sheevaPlugInfoBoardDebugLedIf,
-	0,										/* ledsPolarity */		
+	0,										/* ledsPolarity */
 	RD_SHEEVA_PLUG_OE_LOW,				            /* gppOutEnLow */
 	RD_SHEEVA_PLUG_OE_HIGH,				        /* gppOutEnHigh */
 	RD_SHEEVA_PLUG_OE_VAL_LOW,				        /* gppOutValLow */
@@ -768,20 +768,20 @@ MV_BOARD_INFO sheevaPlugInfo = {
 MV_U8	dbCustomerInfoBoardDebugLedIf[] =
 	{0};
 
-MV_BOARD_MAC_INFO dbCustomerInfoBoardMacInfo[] = 
+MV_BOARD_MAC_INFO dbCustomerInfoBoardMacInfo[] =
     /* {{MV_BOARD_MAC_SPEED	boardMacSpeed,	MV_U8	boardEthSmiAddr}} */
-	{{BOARD_MAC_SPEED_AUTO, 0x0}}; 
+	{{BOARD_MAC_SPEED_AUTO, 0x0}};
 
 MV_BOARD_TWSI_INFO	dbCustomerInfoBoardTwsiDev[] =
 	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
 	{{BOARD_TWSI_OTHER, 0x0, ADDR7_BIT}};
 
-MV_BOARD_MPP_TYPE_INFO dbCustomerInfoBoardMppTypeInfo[] = 
+MV_BOARD_MPP_TYPE_INFO dbCustomerInfoBoardMppTypeInfo[] =
 	{{MV_BOARD_OTHER, MV_BOARD_OTHER}
-	}; 
+	};
 
-MV_DEV_CS_INFO dbCustomerInfoBoardDeCsInfo[] = 
-		/*{deviceCS, params, devType, devWidth}*/			   
+MV_DEV_CS_INFO dbCustomerInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
 #if defined(MV_NAND) && defined(MV_NAND_BOOT)
 		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
 #elif defined(MV_NAND) && defined(MV_SPI_BOOT)
@@ -790,18 +790,18 @@ MV_DEV_CS_INFO dbCustomerInfoBoardDeCsInfo[] =
          {2, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
          };
 #else
-		 {{2, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */         
+		 {{2, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
 #endif
 
-MV_BOARD_MPP_INFO	dbCustomerInfoBoardMppConfigValue[] = 
+MV_BOARD_MPP_INFO	dbCustomerInfoBoardMppConfigValue[] =
 	{{{
-	DB_CUSTOMER_MPP0_7,		
-	DB_CUSTOMER_MPP8_15,		
-	DB_CUSTOMER_MPP16_23,		
-	DB_CUSTOMER_MPP24_31,		
-	DB_CUSTOMER_MPP32_39,		
-	DB_CUSTOMER_MPP40_47,		
-	DB_CUSTOMER_MPP48_55		
+	DB_CUSTOMER_MPP0_7,
+	DB_CUSTOMER_MPP8_15,
+	DB_CUSTOMER_MPP16_23,
+	DB_CUSTOMER_MPP24_31,
+	DB_CUSTOMER_MPP32_39,
+	DB_CUSTOMER_MPP40_47,
+	DB_CUSTOMER_MPP48_55
 	}}};
 
 MV_BOARD_INFO dbCustomerInfo = {
@@ -815,14 +815,14 @@ MV_BOARD_INFO dbCustomerInfo = {
 	DB_CUSTOMER_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
 	dbCustomerInfoBoardDeCsInfo,
 	DB_CUSTOMER_BOARD_TWSI_DEF_NUM,			    /* numBoardTwsiDev */
-	dbCustomerInfoBoardTwsiDev,					
+	dbCustomerInfoBoardTwsiDev,
 	DB_CUSTOMER_BOARD_MAC_INFO_NUM,			    /* numBoardMacInfo */
 	dbCustomerInfoBoardMacInfo,
 	DB_CUSTOMER_BOARD_GPP_INFO_NUM,			    /* numBoardGppInfo */
 	0,
-	DB_CUSTOMER_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */              
+	DB_CUSTOMER_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
 	NULL,
-	0,										/* ledsPolarity */		
+	0,										/* ledsPolarity */
 	DB_CUSTOMER_OE_LOW,				            /* gppOutEnLow */
 	DB_CUSTOMER_OE_HIGH,				        /* gppOutEnHigh */
 	DB_CUSTOMER_OE_VAL_LOW,				        /* gppOutValLow */
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.h b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.h
index 0372eee..1f5c197 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.h
@@ -244,7 +244,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define RD_SHEEVA_PLUG_OE_LOW                   0x0
 #define RD_SHEEVA_PLUG_OE_HIGH                  0x0
 #define RD_SHEEVA_PLUG_OE_VAL_LOW               (BIT29)
-#define RD_SHEEVA_PLUG_OE_VAL_HIGH              ((~(BIT17 | BIT16 | BIT15)) | BIT14) 
+#define RD_SHEEVA_PLUG_OE_VAL_HIGH              ((~(BIT17 | BIT16 | BIT15)) | BIT14)
 
 /* DB-CUSTOMER */
 #define DB_CUSTOMER_MPP0_7                	    0x21111111
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.c b/crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.c
index fed0fa1..9bb8607 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -73,7 +73,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 	#define DB(x)	x
 #else
 	#define DB(x)
-#endif	
+#endif
 
 /* locals */
 
@@ -103,7 +103,7 @@ static MV_U32 mvCpu6180PclkGet(MV_VOID)
 	tmpPClkRate = MV_REG_READ(MPP_SAMPLE_AT_RESET);
 	tmpPClkRate = tmpPClkRate & MSAR_CPUCLCK_MASK_6180;
 	tmpPClkRate = tmpPClkRate >> MSAR_CPUCLCK_OFFS_6180;
-			
+
 	tmpPClkRate = cpu6180_ddr_l2_CLK[tmpPClkRate].cpuClk;
 
 	return tmpPClkRate;
@@ -129,96 +129,6 @@ MV_U32 mvCpuPclkGet(MV_VOID)
 #endif
 }
 
-/*******************************************************************************
-* mvCpuL2ClkGet - Get the CPU L2 (CPU bus clock)
-*
-* DESCRIPTION:
-*       This routine extract the CPU L2 clock.
-*
-* RETURN:
-*       32bit clock cycles in Hertz.
-*
-*******************************************************************************/
-static MV_U32  mvCpu6180L2ClkGet(MV_VOID)
-{
-	MV_U32 	L2ClkRate=0;
-	MV_CPU_ARM_CLK _cpu6180_ddr_l2_CLK[] = MV_CPU6180_DDR_L2_CLCK_TBL;
-
-	L2ClkRate = MV_REG_READ(MPP_SAMPLE_AT_RESET);
-	L2ClkRate = L2ClkRate & MSAR_CPUCLCK_MASK_6180;
-	L2ClkRate = L2ClkRate >> MSAR_CPUCLCK_OFFS_6180;
-			
-	L2ClkRate = _cpu6180_ddr_l2_CLK[L2ClkRate].l2Clk;
-
-	return L2ClkRate;
-
-}
-
-MV_U32  mvCpuL2ClkGet(MV_VOID)
-{
-#ifdef L2CLK_AUTO_DETECT
-	MV_U32 L2ClkRate, tmp, pClkRate, indexL2Rtio;
-	MV_U32 L2Rtio[][2] = MV_L2_CLCK_RTIO_TBL;
-
-	if(mvCtrlModelGet() == MV_6180_DEV_ID)
-		return mvCpu6180L2ClkGet();
-
-	pClkRate = mvCpuPclkGet();
-
-	tmp = MV_REG_READ(MPP_SAMPLE_AT_RESET);
-	indexL2Rtio = MSAR_L2CLCK_EXTRACT(tmp);
-
-	L2ClkRate = ((pClkRate * L2Rtio[indexL2Rtio][1]) / L2Rtio[indexL2Rtio][0]);
-
-	return L2ClkRate;
-#else
-	return MV_BOARD_DEFAULT_L2CLK;
-#endif
-}
-
-
-/*******************************************************************************
-* mvCpuNameGet - Get CPU name
-*
-* DESCRIPTION:
-*       This function returns a string describing the CPU model and revision.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
-*
-* RETURN:
-*       None.
-*******************************************************************************/
-MV_VOID mvCpuNameGet(char *pNameBuff)
-{
-    MV_U32 cpuModel;
-    
-    cpuModel = mvOsCpuPartGet();
-
-    /* The CPU module is indicated in the Processor Version Register (PVR) */
-    switch(cpuModel)
-    {
-        case CPU_PART_MRVL131:
-            mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell Feroceon",mvOsCpuRevGet());
-            break;
-        case CPU_PART_ARM926:
-            mvOsSPrintf(pNameBuff, "%s (Rev %d)", "ARM926",mvOsCpuRevGet());
-            break;
-	case CPU_PART_ARM946:
-		mvOsSPrintf(pNameBuff, "%s (Rev %d)", "ARM946",mvOsCpuRevGet());
-		break;
-        default:
-            mvOsSPrintf(pNameBuff,"??? (0x%04x) (Rev %d)",cpuModel,mvOsCpuRevGet());
-            break;
-    }  /* switch  */
-
-    return;
-}
-
-
 #define MV_PROC_STR_SIZE 50
 
 static void mvCpuIfGetL2EccMode(MV_8 *buf)
@@ -291,20 +201,20 @@ static void mvCpuIfPrintCpuRegs(void)
 MV_U32 mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index)
 {
   MV_U32 count = 0;
-  
+
   MV_8 L2_ECC_str[MV_PROC_STR_SIZE];
   MV_8 L2_En_str[MV_PROC_STR_SIZE];
   MV_8 L2_Prefetch_str[MV_PROC_STR_SIZE];
   MV_8 Write_Alloc_str[MV_PROC_STR_SIZE];
   MV_8 Cpu_Stream_str[MV_PROC_STR_SIZE];
-  
+
   mvCpuIfGetL2Mode(L2_En_str);
-  mvCpuIfGetL2EccMode(L2_ECC_str); 
+  mvCpuIfGetL2EccMode(L2_ECC_str);
   mvCpuIfGetL2PrefetchMode(L2_Prefetch_str);
   mvCpuIfGetWriteAllocMode(Write_Alloc_str);
   mvCpuIfGetCpuStreamMode(Cpu_Stream_str);
   mvCpuIfPrintCpuRegs();
-  
+
   count += mvOsSPrintf(buffer + count + index, "%s\n", L2_En_str);
   count += mvOsSPrintf(buffer + count + index, "%s\n", L2_ECC_str);
   count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Prefetch_str);
@@ -312,9 +222,3 @@ MV_U32 mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index)
   count += mvOsSPrintf(buffer + count + index, "%s\n", Cpu_Stream_str);
   return count;
 }
-
-MV_U32 whoAmI(MV_VOID)
-{
-	return 0;
-}
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.h b/crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.h
index 7f58b03..dd3a70e 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/cpu/mvCpu.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -79,7 +79,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_CPU_ARM_CLK_DDR_OFF	    4
 
 #ifndef MV_ASMLANGUAGE
-typedef struct _mvCpuArmClk 
+typedef struct _mvCpuArmClk
 {
 	MV_U32	      cpuClk;	  /* CPU clock in MHz */
 	MV_U32	      ddrClk;	  /* DDR clock in MHz */
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c
index fbe7c56..fcc66c4 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -86,7 +86,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #else
 	#define DB(x)
 #endif
-	
+
 /* Default Attributes array */
 MV_TARGET_ATTRIB	mvTargetDefaultsArray[] = TARGETS_DEF_ARRAY;
 extern MV_TARGET 	*sampleAtResetTargetArray;
@@ -120,7 +120,7 @@ MV_STATUS mvCtrlAddrDecToReg(MV_ADDR_WIN *pAddrDecWin, MV_DEC_REGS *pAddrDecRegs
 {
 
 	MV_U32 baseToReg=0 , sizeToReg=0;
-    
+
 	/* BaseLow[31:16] => base register [31:16]		*/
 	baseToReg = pAddrDecWin->baseLow & CTRL_DEC_BASE_MASK;
 
@@ -130,7 +130,7 @@ MV_STATUS mvCtrlAddrDecToReg(MV_ADDR_WIN *pAddrDecWin, MV_DEC_REGS *pAddrDecRegs
 
 	/* Get size register value according to window size						*/
 	sizeToReg = ctrlSizeToReg(pAddrDecWin->size, CTRL_DEC_SIZE_ALIGNMENT);
-	
+
 	/* Size parameter validity check.                                   */
 	if (-1 == sizeToReg)
 	{
@@ -140,7 +140,7 @@ MV_STATUS mvCtrlAddrDecToReg(MV_ADDR_WIN *pAddrDecWin, MV_DEC_REGS *pAddrDecRegs
 	/* set size */
 	pAddrDecRegs->sizeReg &= ~CTRL_DEC_SIZE_MASK;
 	pAddrDecRegs->sizeReg |= (sizeToReg << CTRL_DEC_SIZE_OFFS);
-	
+
 
 	return MV_OK;
 
@@ -150,7 +150,7 @@ MV_STATUS mvCtrlAddrDecToReg(MV_ADDR_WIN *pAddrDecWin, MV_DEC_REGS *pAddrDecRegs
 * mvCtrlRegToAddrDec - Extract address decode struct from registers.
 *
 * DESCRIPTION:
-*       This function extract address decode struct from address decode 
+*       This function extract address decode struct from address decode
 *       registers given as parameters.
 *
 * INPUT:
@@ -166,8 +166,8 @@ MV_STATUS mvCtrlAddrDecToReg(MV_ADDR_WIN *pAddrDecWin, MV_DEC_REGS *pAddrDecRegs
 MV_STATUS mvCtrlRegToAddrDec(MV_DEC_REGS *pAddrDecRegs, MV_ADDR_WIN *pAddrDecWin)
 {
 	MV_U32 sizeRegVal;
-	
-	sizeRegVal = (pAddrDecRegs->sizeReg & CTRL_DEC_SIZE_MASK) >> 
+
+	sizeRegVal = (pAddrDecRegs->sizeReg & CTRL_DEC_SIZE_MASK) >>
 					CTRL_DEC_SIZE_OFFS;
 
 	pAddrDecWin->size = ctrlRegToSize(sizeRegVal, CTRL_DEC_SIZE_ALIGNMENT);
@@ -180,11 +180,11 @@ MV_STATUS mvCtrlRegToAddrDec(MV_DEC_REGS *pAddrDecRegs, MV_ADDR_WIN *pAddrDecWin
 	pAddrDecWin->baseHigh =  0;
 
 	return MV_OK;
-    
+
 }
 
 /*******************************************************************************
-* mvCtrlAttribGet - 
+* mvCtrlAttribGet -
 *
 * DESCRIPTION:
 *
@@ -208,7 +208,7 @@ MV_STATUS mvCtrlAttribGet(MV_TARGET target,
 }
 
 /*******************************************************************************
-* mvCtrlGetAttrib - 
+* mvCtrlGetAttrib -
 *
 * DESCRIPTION:
 *
@@ -236,61 +236,61 @@ MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib)
 
 	return target;
 }
-
-MV_STATUS mvCtrlAddrDecToParams(MV_DEC_WIN *pAddrDecWin, 
-                                MV_DEC_WIN_PARAMS *pWinParam)
-{
-	MV_U32 baseToReg=0, sizeToReg=0;
-    
-	/* BaseLow[31:16] => base register [31:16]		*/
-	baseToReg = pAddrDecWin->addrWin.baseLow & CTRL_DEC_BASE_MASK;
-
-	/* Write to address decode Base Address Register                  */
-	pWinParam->baseAddr &= ~CTRL_DEC_BASE_MASK;
-	pWinParam->baseAddr |= baseToReg;
-
-	/* Get size register value according to window size						*/
-	sizeToReg = ctrlSizeToReg(pAddrDecWin->addrWin.size, CTRL_DEC_SIZE_ALIGNMENT);
-	
-	/* Size parameter validity check.                                   */
-	if (-1 == sizeToReg)
-	{
-        mvOsPrintf("mvCtrlAddrDecToParams: ERR. ctrlSizeToReg failed.\n");
-		return MV_BAD_PARAM;
-	}
-    pWinParam->size = sizeToReg;
-
-    pWinParam->attrib   = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(pAddrDecWin->target)].attrib;
-    pWinParam->targetId = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(pAddrDecWin->target)].targetId;
-
-    return MV_OK;
-}
-
-MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam, 
-                                MV_DEC_WIN *pAddrDecWin)
-{
-    MV_TARGET_ATTRIB    targetAttrib;
-
-    pAddrDecWin->addrWin.baseLow = pWinParam->baseAddr;
-	
-	/* Upper 32bit address base is supported under PCI High Address remap */
-	pAddrDecWin->addrWin.baseHigh = 0;	
-
-	/* Prepare sizeReg to ctrlRegToSize function */
-    pAddrDecWin->addrWin.size = ctrlRegToSize(pWinParam->size, CTRL_DEC_SIZE_ALIGNMENT);
-
-	if (-1 == pAddrDecWin->addrWin.size)
-	{
-		DB(mvOsPrintf("mvCtrlParamsToAddrDec: ERR. ctrlRegToSize failed.\n"));
-		return MV_BAD_PARAM;
-	}
-    targetAttrib.targetId = pWinParam->targetId;
-    targetAttrib.attrib = pWinParam->attrib;
-
-    pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
-
-    return MV_OK;
-}
-
-
-
+
+MV_STATUS mvCtrlAddrDecToParams(MV_DEC_WIN *pAddrDecWin,
+                                MV_DEC_WIN_PARAMS *pWinParam)
+{
+	MV_U32 baseToReg=0, sizeToReg=0;
+
+	/* BaseLow[31:16] => base register [31:16]		*/
+	baseToReg = pAddrDecWin->addrWin.baseLow & CTRL_DEC_BASE_MASK;
+
+	/* Write to address decode Base Address Register                  */
+	pWinParam->baseAddr &= ~CTRL_DEC_BASE_MASK;
+	pWinParam->baseAddr |= baseToReg;
+
+	/* Get size register value according to window size						*/
+	sizeToReg = ctrlSizeToReg(pAddrDecWin->addrWin.size, CTRL_DEC_SIZE_ALIGNMENT);
+
+	/* Size parameter validity check.                                   */
+	if (-1 == sizeToReg)
+	{
+        mvOsPrintf("mvCtrlAddrDecToParams: ERR. ctrlSizeToReg failed.\n");
+		return MV_BAD_PARAM;
+	}
+    pWinParam->size = sizeToReg;
+
+    pWinParam->attrib   = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(pAddrDecWin->target)].attrib;
+    pWinParam->targetId = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(pAddrDecWin->target)].targetId;
+
+    return MV_OK;
+}
+
+MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam,
+                                MV_DEC_WIN *pAddrDecWin)
+{
+    MV_TARGET_ATTRIB    targetAttrib;
+
+    pAddrDecWin->addrWin.baseLow = pWinParam->baseAddr;
+
+	/* Upper 32bit address base is supported under PCI High Address remap */
+	pAddrDecWin->addrWin.baseHigh = 0;
+
+	/* Prepare sizeReg to ctrlRegToSize function */
+    pAddrDecWin->addrWin.size = ctrlRegToSize(pWinParam->size, CTRL_DEC_SIZE_ALIGNMENT);
+
+	if (-1 == pAddrDecWin->addrWin.size)
+	{
+		DB(mvOsPrintf("mvCtrlParamsToAddrDec: ERR. ctrlRegToSize failed.\n"));
+		return MV_BAD_PARAM;
+	}
+    targetAttrib.targetId = pWinParam->targetId;
+    targetAttrib.attrib = pWinParam->attrib;
+
+    pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
+
+    return MV_OK;
+}
+
+
+
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.h
index 946737f..3e2a1a3 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -158,23 +158,23 @@ typedef struct _mvTargetAttrib
 	MV_TARGET_ID 		targetId; 		/* Target Id of this MV_TARGET */
 
 }MV_TARGET_ATTRIB;
-
-
-/* This structure describes address decode window                           */
-typedef struct _mvDecWin 
-{
-    MV_TARGET       target;         /* Target for addr decode window        */
-    MV_ADDR_WIN     addrWin;        /* Address window of target             */
-    MV_BOOL     	enable;         /* Window enable/disable                */
-}MV_DEC_WIN;
-
-typedef struct _mvDecWinParams
-{
-    MV_TARGET_ID    targetId;   /* Target ID field */
-    MV_U8           attrib;     /* Attribute field */
-    MV_U32          baseAddr;   /* Base address in register format */
-    MV_U32          size;       /* Size in register format */
-}MV_DEC_WIN_PARAMS;
+
+
+/* This structure describes address decode window                           */
+typedef struct _mvDecWin
+{
+    MV_TARGET       target;         /* Target for addr decode window        */
+    MV_ADDR_WIN     addrWin;        /* Address window of target             */
+    MV_BOOL     	enable;         /* Window enable/disable                */
+}MV_DEC_WIN;
+
+typedef struct _mvDecWinParams
+{
+    MV_TARGET_ID    targetId;   /* Target ID field */
+    MV_U8           attrib;     /* Attribute field */
+    MV_U32          baseAddr;   /* Base address in register format */
+    MV_U32          size;       /* Size in register format */
+}MV_DEC_WIN_PARAMS;
 
 
 /* mvCtrlEnvAddrDec API list */
@@ -191,11 +191,11 @@ MV_STATUS mvCtrlAttribGet(MV_TARGET target,
 MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib);
 
 
-MV_STATUS mvCtrlAddrDecToParams(MV_DEC_WIN *pAddrDecWin, 
-                                MV_DEC_WIN_PARAMS *pWinParam);
+MV_STATUS mvCtrlAddrDecToParams(MV_DEC_WIN *pAddrDecWin,
+                                MV_DEC_WIN_PARAMS *pWinParam);
 
-MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam, 
-                                MV_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam,
+                                MV_DEC_WIN *pAddrDecWin);
 
 
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAsm.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAsm.h
index 6f6367a..3576f25 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAsm.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAsm.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c
index adf451d..15db1e6 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -106,7 +106,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 	#define DB(x)	x
 #else
 	#define DB(x)
-#endif	
+#endif
 
 /*******************************************************************************
 * mvCtrlEnvInit - Initialize Marvell controller environment.
@@ -116,7 +116,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *       internal/external environment. For example
 *       1) MPP settings according to board MPP macros.
 *		NOTE: It is the user responsibility to shut down all DMA channels
-*		in device and disable controller sub units interrupts during 
+*		in device and disable controller sub units interrupts during
 *		boot process.
 *
 * INPUT:
@@ -157,12 +157,12 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			maxMppGrp = MV_6180_MPP_MAX_GROUP;
-			break;		
+			break;
 	}
-	
+
 	/* MPP Init */
 	/* We split mpp init to 3 phases:
-	 * 1. We init mpp[19:0] from the board info. mpp[23:20] will be over write 
+	 * 1. We init mpp[19:0] from the board info. mpp[23:20] will be over write
 	 * in phase 2.
 	 * 2. We detect the mpp group type and according the mpp values [35:20].
 	 * 3. We detect the mpp group type and according the mpp values [49:36].
@@ -194,7 +194,7 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 			mppVal |= bootVal;
 		    }
 		}
-		
+
 		if (mppGroup == 2)
 		{
 		    bootVal = MV_REG_READ(mvCtrlMppRegGet(mppGroup));
@@ -238,7 +238,7 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
     			mppVal = mppGroup1[mppGroupType][i];
     			i++;
     		}
-    
+
     		/* Group 2 is shared mpp[23:16] */
     		if (mppGroup == 2)
     		{
@@ -247,14 +247,14 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
     			bootVal &= 0xffff;
     			mppVal |= bootVal;
     		}
-    
+
     		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
     	}
     }
 
 	if ((devId == MV_6192_DEV_ID) || (devId == MV_6190_DEV_ID))
 		return MV_OK;
- 	
+
 	/* Mpp phase 3 */
 	mppGroupType = mvBoardMppGroupTypeGet(MV_BOARD_MPP_GROUP_2);
 	/* Read MPP group from board level and assign to MPP register */
@@ -330,7 +330,7 @@ MV_U32 mvCtrlMppRegGet(MV_U32 mppGroup)
         }
         return ret;
 }
-#if defined(MV_INCLUDE_PEX) 
+#if defined(MV_INCLUDE_PEX)
 /*******************************************************************************
 * mvCtrlPexMaxIfGet - Get Marvell controller number of PEX interfaces.
 *
@@ -344,7 +344,7 @@ MV_U32 mvCtrlMppRegGet(MV_U32 mppGroup)
 *       None.
 *
 * RETURN:
-*       Marvell controller number of PEX interfaces. If controller 
+*       Marvell controller number of PEX interfaces. If controller
 *		ID is undefined the function returns '0'.
 *
 *******************************************************************************/
@@ -375,7 +375,7 @@ MV_U32 mvCtrlPexMaxIfGet(MV_VOID)
 MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
 {
 	MV_U32 devId;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -390,7 +390,7 @@ MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			return MV_6180_ETH_MAX_PORTS;
-			break;		
+			break;
 	}
 	return 0;
 
@@ -416,7 +416,7 @@ MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
 *******************************************************************************/
 MV_U32 mvCtrlXorMaxChanGet(MV_VOID)
 {
-	return MV_XOR_MAX_CHAN; 
+	return MV_XOR_MAX_CHAN;
 }
 #endif
 
@@ -462,7 +462,7 @@ MV_U32 mvCtrlUsbMaxGet(void)
 MV_U32	  mvCtrlNandSupport(MV_VOID)
 {
 	MV_U32 devId;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -477,7 +477,7 @@ MV_U32	  mvCtrlNandSupport(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			return MV_6180_NAND;
-			break;		
+			break;
 	}
 	return 0;
 
@@ -503,7 +503,7 @@ MV_U32	  mvCtrlNandSupport(MV_VOID)
 MV_U32	  mvCtrlSdioSupport(MV_VOID)
 {
 	MV_U32 devId;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -518,7 +518,7 @@ MV_U32	  mvCtrlSdioSupport(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			return MV_6180_SDIO;
-			break;		
+			break;
 	}
 	return 0;
 
@@ -544,7 +544,7 @@ MV_U32	  mvCtrlSdioSupport(MV_VOID)
 MV_U32	  mvCtrlTsSupport(MV_VOID)
 {
 	MV_U32 devId;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -559,7 +559,7 @@ MV_U32	  mvCtrlTsSupport(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			return MV_6180_TS;
-			break;		
+			break;
 	}
 	return 0;
 }
@@ -584,7 +584,7 @@ MV_U32	  mvCtrlTsSupport(MV_VOID)
 MV_U32	  mvCtrlAudioSupport(MV_VOID)
 {
 	MV_U32 devId;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -599,7 +599,7 @@ MV_U32	  mvCtrlAudioSupport(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			return MV_6180_AUDIO;
-			break;		
+			break;
 	}
 	return 0;
 
@@ -625,7 +625,7 @@ MV_U32	  mvCtrlAudioSupport(MV_VOID)
 MV_U32	  mvCtrlTdmSupport(MV_VOID)
 {
 	MV_U32 devId;
-	
+
 	devId = mvCtrlModelGet();
 
 	switch(devId){
@@ -640,7 +640,7 @@ MV_U32	  mvCtrlTdmSupport(MV_VOID)
             break;
 		case MV_6180_DEV_ID:
 			return MV_6180_TDM;
-			break;		
+			break;
 	}
 	return 0;
 
@@ -661,13 +661,13 @@ MV_U32	  mvCtrlTdmSupport(MV_VOID)
 *       None.
 *
 * RETURN:
-*       16bit desscribing Marvell controller ID 
+*       16bit desscribing Marvell controller ID
 *
 *******************************************************************************/
 MV_U16 mvCtrlModelGet(MV_VOID)
 {
 	MV_U32 devId;
-	
+
 	devId = MV_REG_READ(CHIP_BOND_REG);
 	devId &= PCKG_OPT_MASK;
 
@@ -703,7 +703,7 @@ MV_U16 mvCtrlModelGet(MV_VOID)
 *       None.
 *
 * RETURN:
-*       8bit desscribing Marvell controller revision number 
+*       8bit desscribing Marvell controller revision number
 *
 *******************************************************************************/
 MV_U8 mvCtrlRevGet(MV_VOID)
@@ -738,14 +738,14 @@ MV_U8 mvCtrlRevGet(MV_VOID)
 *       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
 *
 * RETURN:
-*       
+*
 *       MV_ERROR if informantion can not be read.
 *******************************************************************************/
 MV_STATUS mvCtrlNameGet(char *pNameBuff)
 {
-	mvOsSPrintf (pNameBuff, "%s%x Rev %d", SOC_NAME_PREFIX, 
-				mvCtrlModelGet(), mvCtrlRevGet()); 
-	
+	mvOsSPrintf (pNameBuff, "%s%x Rev %d", SOC_NAME_PREFIX,
+				mvCtrlModelGet(), mvCtrlRevGet());
+
 	return MV_OK;
 }
 
@@ -756,7 +756,7 @@ MV_STATUS mvCtrlNameGet(char *pNameBuff)
 *       This function returns 32bit value describing both Device ID and Revision
 *       as defined in PCI Express Device and Vendor ID Register and device revision
 *	    as defined in PCI Express Class Code and Revision ID Register.
-     
+
 *
 * INPUT:
 *       None.
@@ -786,7 +786,7 @@ MV_U32	mvCtrlModelRevGet(MV_VOID)
 *       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
 *
 * RETURN:
-*       
+*
 *       MV_ERROR if informantion can not be read.
 *******************************************************************************/
 
@@ -796,16 +796,16 @@ MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff)
         switch (mvCtrlModelRevGet())
         {
         case MV_6281_A0_ID:
-                mvOsSPrintf (pNameBuff, "%s",MV_6281_A0_NAME); 
+                mvOsSPrintf (pNameBuff, "%s",MV_6281_A0_NAME);
                 break;
         case MV_6192_A0_ID:
-                mvOsSPrintf (pNameBuff, "%s",MV_6192_A0_NAME); 
+                mvOsSPrintf (pNameBuff, "%s",MV_6192_A0_NAME);
                 break;
         case MV_6180_A0_ID:
-                mvOsSPrintf (pNameBuff, "%s",MV_6180_A0_NAME); 
+                mvOsSPrintf (pNameBuff, "%s",MV_6180_A0_NAME);
                 break;
         case MV_6190_A0_ID:
-                mvOsSPrintf (pNameBuff, "%s",MV_6190_A0_NAME); 
+                mvOsSPrintf (pNameBuff, "%s",MV_6190_A0_NAME);
                 break;
         case MV_6281_A1_ID:
                 mvOsSPrintf (pNameBuff, "%s",MV_6281_A1_NAME);
@@ -842,14 +842,14 @@ MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff)
 *       None.
 *
 * RETURN:
-*       
+*
 *       MV_TRUE if address window overlaps, MV_FALSE otherwise.
 *******************************************************************************/
 MV_STATUS ctrlWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2)
 {
     MV_U32 winBase1, winBase2;
     MV_U32 winTop1, winTop2;
-    
+
 	/* check if we have overflow than 4G*/
 	if (((0xffffffff - pAddrWin1->baseLow) < pAddrWin1->size-1)||
 	   ((0xffffffff - pAddrWin2->baseLow) < pAddrWin2->size-1))
@@ -862,7 +862,7 @@ MV_STATUS ctrlWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2)
     winTop1  = winBase1 + pAddrWin1->size-1;
     winTop2  = winBase2 + pAddrWin2->size-1;
 
-    
+
     if (((winBase1 <= winTop2 ) && ( winTop2 <= winTop1)) ||
         ((winBase1 <= winBase2) && (winBase2 <= winTop1)))
     {
@@ -889,19 +889,19 @@ MV_STATUS ctrlWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2)
 *       None.
 *
 * RETURN:
-*       
+*
 *       MV_TRUE if found win1 inside win2, MV_FALSE otherwise.
 *******************************************************************************/
 MV_STATUS ctrlWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2)
 {
     MV_U32 winBase1, winBase2;
     MV_U32 winTop1, winTop2;
-    
+
     winBase1 = pAddrWin1->baseLow;
     winBase2 = pAddrWin2->baseLow;
     winTop1  = winBase1 + pAddrWin1->size -1;
     winTop2  = winBase2 + pAddrWin2->size -1;
-    
+
     if (((winBase1 >= winBase2 ) && ( winBase1 <= winTop2)) ||
         ((winTop1  >= winBase2) && (winTop1 <= winTop2)))
     {
@@ -987,13 +987,13 @@ MV_VOID mvCtrlAddrDecShow(MV_VOID)
 /*******************************************************************************
 * ctrlSizeToReg - Extract size value for register assignment.
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *       Address decode size parameter must be programed from LSB to MSB as
-*       sequence of 1's followed by sequence of 0's. The number of 1's 
-*       specifies the size of the window in 64 KB granularity (e.g. a 
+*       sequence of 1's followed by sequence of 0's. The number of 1's
+*       specifies the size of the window in 64 KB granularity (e.g. a
 *       value of 0x00ff specifies 256x64k = 16 MB).
-*       This function extract the size value from the size parameter according 
-*		to given aligment paramter. For example for size 0x1000000 (16MB) and 
+*       This function extract the size value from the size parameter according
+*		to given aligment paramter. For example for size 0x1000000 (16MB) and
 *		aligment 0x10000 (64KB) the function will return 0x00FF.
 *
 * INPUT:
@@ -1004,7 +1004,7 @@ MV_VOID mvCtrlAddrDecShow(MV_VOID)
 *       None.
 *
 * RETURN:
-*       32bit describing size register value correspond to size parameter. 
+*       32bit describing size register value correspond to size parameter.
 *		If value is '-1' size parameter or aligment are invalid.
 *******************************************************************************/
 MV_U32	ctrlSizeToReg(MV_U32 size, MV_U32 alignment)
@@ -1017,53 +1017,53 @@ MV_U32	ctrlSizeToReg(MV_U32 size, MV_U32 alignment)
 		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size is zero or not aligned.\n"));
 		return -1;
 	}
-	
+
 	/* Take out the "alignment" portion out of the size parameter */
 	alignment--;	/* Now the alignmet is a sequance of '1' (e.g. 0xffff) 		*/
 					/* and size is 0x1000000 (16MB) for example	*/
 	while(alignment & 1)	/* Check that alignmet LSB is set	*/
 	{
-		size = (size >> 1); /* If LSB is set, move 'size' one bit to right	*/	
+		size = (size >> 1); /* If LSB is set, move 'size' one bit to right	*/
 		alignment = (alignment >> 1);
 	}
-	
+
 	/* If after the alignment first '0' was met we still have '1' in 		*/
 	/* it then aligment is invalid (not power of 2) 				*/
 	if (alignment)
 	{
-		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", 
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n",
 			(MV_U32)alignment));
 		return -1;
 	}
 
 	/* Now the size is shifted right according to aligment: 0x0100			*/
 	size--;         /* Now the size is a sequance of '1': 0x00ff 			*/
-    
+
 	retVal = size ;
-	
+
 	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's		*/
 	while(size & 1)	/* Check that LSB is set	*/
 	{
-		size = (size >> 1); /* If LSB is set, move one bit to the right		*/	
+		size = (size >> 1); /* If LSB is set, move one bit to the right		*/
 	}
 
     if (size) /* Sequance of 1's is over. Check that we have no other 1's		*/
 	{
-		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size parameter 0x%x invalid.\n", 
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size parameter 0x%x invalid.\n",
                                                                         size));
 		return -1;
 	}
-	
+
     return retVal;
-	
+
 }
 
 /*******************************************************************************
 * ctrlRegToSize - Extract size value from register value.
 *
-* DESCRIPTION:		
-*       This function extract a size value from the register size parameter 
-*		according to given aligment paramter. For example for register size 
+* DESCRIPTION:
+*       This function extract a size value from the register size parameter
+*		according to given aligment paramter. For example for register size
 *		value 0xff and aligment 0x10000 the function will return 0x01000000.
 *
 * INPUT:
@@ -1074,42 +1074,42 @@ MV_U32	ctrlSizeToReg(MV_U32 size, MV_U32 alignment)
 *       None.
 *
 * RETURN:
-*       32bit describing size. 
+*       32bit describing size.
 *		If value is '-1' size parameter or aligment are invalid.
 *******************************************************************************/
 MV_U32	ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
 {
    	MV_U32 temp;
 
-	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's		*/ 
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's		*/
 	temp = regSize;		/* Now the size is a sequance of '1': 0x00ff		*/
-	
+
 	while(temp & 1)	/* Check that LSB is set					*/
 	{
-		temp = (temp >> 1); /* If LSB is set, move one bit to the right		*/	
+		temp = (temp >> 1); /* If LSB is set, move one bit to the right		*/
 	}
 
     if (temp) /* Sequance of 1's is over. Check that we have no other 1's		*/
 	{
-		DB(mvOsPrintf("ctrlRegToSize: ERR. Size parameter 0x%x invalid.\n", 
+		DB(mvOsPrintf("ctrlRegToSize: ERR. Size parameter 0x%x invalid.\n",
 					regSize));
 	   	return -1;
 	}
-	
+
 
 	/* Check that aligment is a power of two					*/
 	temp = alignment - 1;/* Now the alignmet is a sequance of '1' (0xffff) 		*/
-					
+
 	while(temp & 1)	/* Check that alignmet LSB is set				*/
 	{
-		temp = (temp >> 1); /* If LSB is set, move 'size' one bit to right	*/	
+		temp = (temp >> 1); /* If LSB is set, move 'size' one bit to right	*/
 	}
-	
+
 	/* If after the 'temp' first '0' was met we still have '1' in 'temp'		*/
 	/* then 'temp' is invalid (not power of 2) 					*/
 	if (temp)
 	{
-		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", 
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n",
 					alignment));
 		return -1;
 	}
@@ -1121,21 +1121,21 @@ MV_U32	ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
 
 	while(alignment & 1)	/* Check that alignmet LSB is set			*/
 	{
-		regSize   = (regSize << 1); /* LSB is set, move 'size' one bit left	*/	
+		regSize   = (regSize << 1); /* LSB is set, move 'size' one bit left	*/
 		alignment = (alignment >> 1);
 	}
-		
-    return regSize;	
+
+    return regSize;
 }
 
 
 /*******************************************************************************
-* ctrlSizeRegRoundUp - Round up given size 
+* ctrlSizeRegRoundUp - Round up given size
 *
-* DESCRIPTION:		
-*       This function round up a given size to a size that fits the 
+* DESCRIPTION:
+*       This function round up a given size to a size that fits the
 *       restrictions of size format given an aligment parameter.
-*		to given aligment paramter. For example for size parameter 0xa1000 and 
+*		to given aligment paramter. For example for size parameter 0xa1000 and
 *		aligment 0x1000 the function will return 0xFF000.
 *
 * INPUT:
@@ -1146,19 +1146,19 @@ MV_U32	ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
 *       None.
 *
 * RETURN:
-*       32bit describing size value correspond to size in register.  
+*       32bit describing size value correspond to size in register.
 *******************************************************************************/
 MV_U32	ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment)
 {
 	MV_U32 msbBit = 0;
     MV_U32 retSize;
-	
+
     /* Check if size parameter is already comply with restriction		*/
 	if (!(-1 == ctrlSizeToReg(size, alignment)))
 	{
 		return size;
 	}
-    
+
     while(size)
 	{
 		size = (size >> 1);
@@ -1166,7 +1166,7 @@ MV_U32	ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment)
 	}
 
     retSize = (1 << msbBit);
-    
+
     if (retSize < alignment)
     {
         return alignment;
@@ -1177,16 +1177,16 @@ MV_U32	ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment)
     }
 }
 /*******************************************************************************
-* mvCtrlSysRstLengthCounterGet - Return number of milliseconds the reset button 
+* mvCtrlSysRstLengthCounterGet - Return number of milliseconds the reset button
 * 				 was pressed and clear counter
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *
 * INPUT:
 *
 * OUTPUT:
 *
-* RETURN: number of milliseconds the reset button was pressed 
+* RETURN: number of milliseconds the reset button was pressed
 *******************************************************************************/
 MV_U32	mvCtrlSysRstLengthCounterGet(MV_VOID)
 {
@@ -1196,12 +1196,12 @@ MV_U32	mvCtrlSysRstLengthCounterGet(MV_VOID)
 		Count = (MV_REG_READ(SYSRST_LENGTH_COUNTER_REG) & SLCR_COUNT_MASK);
 		Count = (Count / (MV_BOARD_REFCLK_25MHZ / 1000));
 		/* clear counter for next boot */
-		MV_REG_BIT_SET(SYSRST_LENGTH_COUNTER_REG, SLCR_CLR_MASK);	
+		MV_REG_BIT_SET(SYSRST_LENGTH_COUNTER_REG, SLCR_CLR_MASK);
 	}
 
 	DB(mvOsPrintf("mvCtrlSysRstLengthCounterGet: Reset button was pressed for %u milliseconds\n", Count));
 
-	return Count;		
+	return Count;
 }
 
 MV_BOOL	  mvCtrlIsBootFromSPI(MV_VOID)
@@ -1215,7 +1215,7 @@ MV_BOOL	  mvCtrlIsBootFromSPI(MV_VOID)
         else
             return MV_FALSE;
     }
-    satr = satr & MSAR_BOOT_MODE_MASK;    
+    satr = satr & MSAR_BOOT_MODE_MASK;
     if (satr == MSAR_BOOT_SPI_WITH_BOOTROM)
         return MV_TRUE;
     else
@@ -1229,7 +1229,7 @@ MV_BOOL	  mvCtrlIsBootFromSPIUseNAND(MV_VOID)
         return MV_FALSE;
     satr = MV_REG_READ(MPP_SAMPLE_AT_RESET);
     satr = satr & MSAR_BOOT_MODE_MASK;
-    
+
     if (satr == MSAR_BOOT_SPI_USE_NAND_WITH_BOOTROM)
         return MV_TRUE;
     else
@@ -1247,7 +1247,7 @@ MV_BOOL	  mvCtrlIsBootFromNAND(MV_VOID)
         else
             return MV_FALSE;
     }
-    satr = satr & MSAR_BOOT_MODE_MASK;    
+    satr = satr & MSAR_BOOT_MODE_MASK;
     if ((satr == MSAR_BOOT_NAND_WITH_BOOTROM))
         return MV_TRUE;
     else
@@ -1258,7 +1258,7 @@ MV_BOOL	  mvCtrlIsBootFromNAND(MV_VOID)
 /*******************************************************************************
 * mvCtrlPwrSaveOn - Set Power save mode
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *
 * INPUT:
 *
@@ -1294,7 +1294,7 @@ MV_VOID   mvCtrlPwrSaveOn(MV_VOID)
 /*******************************************************************************
 * mvCtrlPwrSaveOff - Go out of power save mode
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *
 * INPUT:
 *
@@ -1328,7 +1328,7 @@ MV_VOID   mvCtrlPwrSaveOff(MV_VOID)
 /*******************************************************************************
 * mvCtrlPwrClckSet - Set Power State for specific Unit
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *
 * INPUT:
 *
@@ -1459,7 +1459,7 @@ MV_VOID   mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
 /*******************************************************************************
 * mvCtrlPwrClckGet - Get Power State of specific Unit
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *
 * INPUT:
 *
@@ -1563,12 +1563,12 @@ MV_BOOL		mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
 	}
 
 
-	return state;	
+	return state;
 }
 /*******************************************************************************
 * mvCtrlPwrMemSet - Set Power State for memory on specific Unit
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *
 * INPUT:
 *
@@ -1674,7 +1674,7 @@ MV_VOID   mvCtrlPwrMemSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
 /*******************************************************************************
 * mvCtrlPwrMemGet - Get Power State of memory on specific Unit
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *
 * INPUT:
 *
@@ -1760,7 +1760,7 @@ MV_BOOL		mvCtrlPwrMemGet(MV_UNIT_ID unitId, MV_U32 index)
 	}
 
 
-	return state;	
+	return state;
 }
 #else
 MV_VOID   mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable) {return;}
@@ -1771,7 +1771,7 @@ MV_BOOL	  mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index) {return MV_TRUE;}
 /*******************************************************************************
 * mvMPPConfigToSPI - Change MPP[3:0] configuration to SPI mode
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *
 * INPUT:
 *
@@ -1790,7 +1790,7 @@ MV_VOID   mvMPPConfigToSPI(MV_VOID)
     bootVal = MV_REG_READ(mvCtrlMppRegGet(0));
     bootVal &= 0xffff000f;
         mppVal |= bootVal;
-    
+
     MV_REG_WRITE(mvCtrlMppRegGet(0), mppVal);
 }
 
@@ -1798,7 +1798,7 @@ MV_VOID   mvMPPConfigToSPI(MV_VOID)
 /*******************************************************************************
 * mvMPPConfigToDefault - Change MPP[7:0] configuration to default configuration
 *
-* DESCRIPTION:		
+* DESCRIPTION:
 *
 * INPUT:
 *
@@ -1818,7 +1818,7 @@ MV_VOID   mvMPPConfigToDefault(MV_VOID)
     mppVal &= ~0xffff000f;
     bootVal &= 0xffff000f;
         mppVal |= bootVal;
-    
+
     MV_REG_WRITE(mvCtrlMppRegGet(0), mppVal);
 }
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h
index 6e2e813..ec098f8 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -71,7 +71,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvCommon.h"
 #include "mvTypes.h"
 #include "mvOs.h"
-#include "boardEnv/mvBoardEnvLib.h"			
+#include "boardEnv/mvBoardEnvLib.h"
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "ctrlEnv/mvCtrlEnvRegs.h"
 #include "ctrlEnv/mvCtrlEnvAddrDec.h"
@@ -85,7 +85,7 @@ typedef enum _mvCachePolicy
 {
     NO_COHERENCY,   /* No HW cache coherency support                        */
     WT_COHERENCY,   /* HW cache coherency supported in Write Through policy */
-    WB_COHERENCY    /* HW cache coherency supported in Write Back policy    */   
+    WB_COHERENCY    /* HW cache coherency supported in Write Back policy    */
 }MV_CACHE_POLICY;
 
 
@@ -94,7 +94,7 @@ typedef enum _mvCachePolicy
 /* data swap types. Below is an example of the data 0x0011223344556677      */
 typedef enum _mvSwapType
 {
-    MV_BYTE_SWAP,       /* Byte Swap                77 66 55 44 33 22 11 00 */             
+    MV_BYTE_SWAP,       /* Byte Swap                77 66 55 44 33 22 11 00 */
     MV_NO_SWAP,         /* No swapping              00 11 22 33 44 55 66 77 */
     MV_BYTE_WORD_SWAP,  /* Both byte and word swap  33 22 11 00 77 66 55 44 */
     MV_WORD_SWAP,       /* Word swap                44 55 66 77 00 11 22 33 */
@@ -128,7 +128,7 @@ MV_U32	  mvCtrlPexMaxIfGet(MV_VOID);
 
 #define   mvCtrlPciIfMaxIfGet()	(0)
 
-#if defined(MV_INCLUDE_GIG_ETH) 
+#if defined(MV_INCLUDE_GIG_ETH)
 MV_U32	  mvCtrlEthMaxPortGet(MV_VOID);
 #endif
 #if defined(MV_INCLUDE_XOR)
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h
index ae3f141..2ea281a 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer. 
+        this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -203,7 +203,7 @@ extern "C" {
 #define SLCR_COUNT_OFFS				0
 #define SLCR_COUNT_MASK				(0x1FFFFFFF << SLCR_COUNT_OFFS)
 #define SLCR_CLR_OFFS				31
-#define SLCR_CLR_MASK				(1 << SLCR_CLR_OFFS)			
+#define SLCR_CLR_MASK				(1 << SLCR_CLR_OFFS)
 #define PCKG_OPT_MASK				0x3
 #define MPP_OUTPUT_DRIVE_REG			0x100E0
 #define MPP_RGMII0_OUTPUT_DRIVE_OFFS            7
@@ -304,7 +304,7 @@ extern "C" {
                     MSAR_BOOT_MODE_6180(MV_REG_READ(MPP_SAMPLE_AT_RESET)): \
                     ((MV_REG_READ(MPP_SAMPLE_AT_RESET) & MSAR_BOOT_MODE_MASK)\
                      >> MSAR_BOOT_MODE_OFFS)]:(target))
-					
+
 #define TCLK_TO_COUNTER_RATIO   1   /* counters running in Tclk */
 
 #define BOOT_TARGETS_NAME_ARRAY {       \
@@ -331,9 +331,9 @@ extern "C" {
 
 
 /* For old competability */
-#define DEVICE_CS0		NFLASH_CS  
-#define DEVICE_CS1  		SPI_CS 
-#define DEVICE_CS2  		BOOT_ROM_CS 
+#define DEVICE_CS0		NFLASH_CS
+#define DEVICE_CS1  		SPI_CS
+#define DEVICE_CS2  		BOOT_ROM_CS
 #define DEVICE_CS3  		DEV_BOOCS
 #define MV_BOOTDEVICE_INDEX   	0
 
@@ -344,7 +344,7 @@ extern "C" {
 #define PCI_IF0_IO		PEX0_IO
 
 
-/* This enumerator defines the Marvell controller target ID      */ 
+/* This enumerator defines the Marvell controller target ID      */
 typedef enum _mvTargetId
 {
     DRAM_TARGET_ID  = 0 ,    /* Port 0 -> DRAM interface         */
@@ -362,20 +362,20 @@ typedef enum _mvTargetId
 typedef enum _mvTarget
 {
     TBL_TERM = -1, 	/* none valid target, used as targets list terminator*/
-    SDRAM_CS0,      	/* SDRAM chip select 0                          */  
-    SDRAM_CS1,      	/* SDRAM chip select 1                          */  
-    SDRAM_CS2,      	/* SDRAM chip select 2                          */  
-    SDRAM_CS3,      	/* SDRAM chip select 3                          */  
+    SDRAM_CS0,      	/* SDRAM chip select 0                          */
+    SDRAM_CS1,      	/* SDRAM chip select 1                          */
+    SDRAM_CS2,      	/* SDRAM chip select 2                          */
+    SDRAM_CS3,      	/* SDRAM chip select 3                          */
     PEX0_MEM,		/* PCI Express 0 Memory				*/
     PEX0_IO,		/* PCI Express 0 IO				*/
-    INTER_REGS,     	/* Internal registers                           */  
-    NFLASH_CS,     	/* NFLASH_CS					*/  
-    SPI_CS,     	/* SPI_CS					*/  
-    BOOT_ROM_CS,        /* BOOT_ROM_CS                                  */  
-    DEV_BOOCS,     	/* DEV_BOOCS					*/  
-    CRYPT_ENG,      	/* Crypto Engine				*/  
+    INTER_REGS,     	/* Internal registers                           */
+    NFLASH_CS,     	/* NFLASH_CS					*/
+    SPI_CS,     	/* SPI_CS					*/
+    BOOT_ROM_CS,        /* BOOT_ROM_CS                                  */
+    DEV_BOOCS,     	/* DEV_BOOCS					*/
+    CRYPT_ENG,      	/* Crypto Engine				*/
 #ifdef MV_INCLUDE_SAGE
-    SAGE_UNIT,      	/* SAGE Unit					*/  
+    SAGE_UNIT,      	/* SAGE Unit					*/
 #endif
     MAX_TARGETS
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvSpec.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvSpec.h
index e41d80a..a474f76 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer. 
+        this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -132,7 +132,7 @@ extern "C" {
 
 /* This define describes the maximum number of supported PEX Interfaces 	*/
 #define MV_INCLUDE_PEX0
-#define MV_DISABLE_PEX_DEVICE_BAR 
+#define MV_DISABLE_PEX_DEVICE_BAR
 #define MV_PEX_MAX_IF		1
 #define MV_PEX_START_IF		MV_PCI_MAX_IF
 
@@ -231,7 +231,7 @@ extern "C" {
 
 #ifndef MV_ASMLANGUAGE
 
-/* This enumerator defines the Marvell Units ID      */ 
+/* This enumerator defines the Marvell Units ID      */
 typedef enum _mvUnitId
 {
     DRAM_UNIT_ID,
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.h
index 1b352a1..647e061 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -75,7 +75,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #if defined(MV_88F1181)
 /* This enumerator defines the Marvell controller possible MBUS arbiter     */
-/* target ports. It is used to define crossbar priority scheame (pizza)     */ 
+/* target ports. It is used to define crossbar priority scheame (pizza)     */
 typedef enum _mvMBusArbTargetId
 {
     DRAM_MBUS_ARB_TARGET = 0,    /* Port 0 -> DRAM interface         */
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h
index 97dc631..518b9d1 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -84,7 +84,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* AHB_TO_MBUS_WIN_CTRL_REG (ATMWCR)*/
 #define ATMWCR_WIN_ENABLE					BIT0	/* Window Enable */
 
-#define ATMWCR_WIN_TARGET_OFFS			4 /* The target interface associated 
+#define ATMWCR_WIN_TARGET_OFFS			4 /* The target interface associated
 											 with this window*/
 #define ATMWCR_WIN_TARGET_MASK			(0xf << ATMWCR_WIN_TARGET_OFFS)
 
@@ -92,7 +92,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 											 Associated with this window */
 #define ATMWCR_WIN_ATTR_MASK				(0xff << ATMWCR_WIN_ATTR_OFFS)
 
-											 
+
 /*
 Used with the Base register to set the address window size and location
 Must be programed from LSB to MSB as sequence of 1s followed
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c
index 872dc6e..8a72ded 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c
@@ -476,7 +476,7 @@ MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target,MV_BOOL enable)
 	MV_CPU_DEC_WIN addrDecWin;
 
 	target = MV_CHANGE_BOOT_CS(target);
-	
+
 	/* Check parameters */
 	if (target >= MAX_TARGETS)
 	{
@@ -1024,7 +1024,7 @@ MV_VOID mvCpuIfEnablePex(MV_U32 pexIf, MV_PEX_TYPE pexType)
 
 	}
 	else
-	{	
+	{
 		MV_REG_BIT_SET(PEX_CTRL_REG(pexIf),PXCR_DEV_TYPE_CTRL_MASK);
 	}
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.h
index 224ed07..1c5a8e4 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -80,7 +80,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 /* typedefs */
 /* This structure describes CPU interface address decode window               */
-typedef struct _mvCpuIfDecWin 
+typedef struct _mvCpuIfDecWin
 {
 	MV_ADDR_WIN   addrWin;    /* An address window*/
 	MV_U32		  winNum;	  /* Window Number in the AHB To Mbus bridge */
@@ -108,7 +108,7 @@ MV_VOID   mvCpuIfEnablePex(MV_U32 pexIf, MV_PEX_TYPE pexType);
 #endif
 #if defined(MV_INCLUDE_PCI)
 MV_U32    mvCpuIfPciRemap(MV_TARGET pciTarget, MV_ADDR_WIN *pAddrDecWin);
-#endif                                               
+#endif
 MV_U32 	  mvCpuIfPciIfRemap(MV_TARGET pciTarget, MV_ADDR_WIN *pAddrDecWin);
 
 MV_VOID   mvCpuIfAddDecShow(MV_VOID);
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfInit.S b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfInit.S
new file mode 100644
index 0000000..b7efda0
--- /dev/null
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfInit.S
@@ -0,0 +1,163 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#define MV_ASMLANGUAGE
+#include "mvOsAsm.h"
+#include "mvDeviceId.h"
+#include "mvCtrlEnvRegs.h"
+#include "mvCpuIfRegs.h"
+#include "mvCtrlEnvAsm.h"
+
+
+/*******************************************************************************
+* mvCpuIfPreInit - Make early initialization of CPU interface.
+*
+* DESCRIPTION:
+*       The function will initialize the CPU interface parameters that must
+*       be initialize before any BUS activity towards the DDR interface,
+*       which means it must be executed from ROM. Because of that, the function
+*       is implemented in assembly code.
+*       The function configure the following CPU config register parameters:
+*       1) CPU2MbusLTickDrv
+*       2) CPU2MbusLTickSample.
+*       NOTE: This function must be called AFTER the internal register
+*       base is modified to INTER_REGS_BASE.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*       r11 holds return function address.
+*******************************************************************************/
+#define MV88F6281_PCKG_OPT	2
+#define MV88F6192_PCKG_OPT	1
+#define MV88F6180_PCKG_OPT	0
+
+	.globl _mvCpuIfPreInit
+_mvCpuIfPreInit:
+
+        mov     r11, LR     		/* Save link register */
+
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r4, r5);
+
+        /* goto calcConfigReg if device is 6281 */
+        ldr     r5, =MV88F6281_PCKG_OPT
+        cmp     r4, r5
+        beq     calcConfigReg
+
+        /* goto calcConfigReg if device is 6192/6190 */
+        ldr     r5, =MV88F6192_PCKG_OPT
+        cmp     r4, r5
+        beq     calcConfigReg
+
+        /* Else 6180 */
+        /* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+        ldr    r5, =MSAR_CPUCLCK_MASK_6180
+        and    r5, r4, r5
+	    mov    r5, r5, lsr #MSAR_CPUCLCK_OFFS_6180
+
+        ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+        cmp    r5, #CPU_2_DDR_CLK_1x3_1
+        beq    setConfigReg
+
+        ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+        cmp    r5, #CPU_2_DDR_CLK_1x4_1
+        beq    setConfigReg
+        b    setConfigReg
+
+calcConfigReg:
+        /* Get the "sample on reset" register */
+	    MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+        ldr    r5, =MSAR_DDRCLCK_RTIO_MASK
+        and    r5, r4, r5
+	    mov    r5, r5, lsr #MSAR_DDRCLCK_RTIO_OFFS
+
+        ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+        cmp    r5, #CPU_2_DDR_CLK_1x3
+        beq    setConfigReg
+
+        ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+        cmp    r5, #CPU_2_DDR_CLK_1x4
+        beq    setConfigReg
+
+        /* Else */
+        ldr    r4, =0
+
+setConfigReg:
+        /* Read CPU Config register */
+        MV_REG_READ_ASM (r7, r5, CPU_CONFIG_REG)
+        ldr    r5, =~(CCR_CPU_2_MBUSL_TICK_DRV_MASK | CCR_CPU_2_MBUSL_TICK_SMPL_MASK)
+        and    r7, r7, r5       /* Clear register fields */
+        orr    r7, r7, r4       /* Set the values according to the findings */
+        MV_REG_WRITE_ASM (r7, r5, CPU_CONFIG_REG)
+
+done:
+        mov     PC, r11         /* r11 is saved link register */
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h
index 8cfeee2..20b4a46 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -113,7 +113,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define CCR_INCR_EN				BIT4
 
 
-#define CCR_NCB_BLOCKING_OFFS			5			
+#define CCR_NCB_BLOCKING_OFFS			5
 #define CCR_NCB_BLOCKING_MASK			(1 << CCR_NCB_BLOCKING_OFFS)
 #define CCR_NCB_BLOCKING_NON			(0 << CCR_NCB_BLOCKING_OFFS)
 #define CCR_NCB_BLOCKING_EN			(1 << CCR_NCB_BLOCKING_OFFS)
@@ -190,7 +190,7 @@ while ARM boot is still in progress
 #define CRMR_WD_RST_OUT_OFFS			1
 #define CRMR_WD_RST_OUT_MASK			BIT1
 #define CRMR_WD_RST_OUT_ENABLE			(1 << CRMR_WD_RST_OUT_OFFS)
-#define CRMR_WD_RST_OUT_DISBALE			(0 << CRMR_WD_RST_OUT_OFFS)			
+#define CRMR_WD_RST_OUT_DISBALE			(0 << CRMR_WD_RST_OUT_OFFS)
 
 #define CRMR_SOFT_RST_OUT_OFFS			2
 #define CRMR_SOFT_RST_OUT_MASK			BIT2
@@ -222,18 +222,18 @@ while ARM boot is still in progress
 
 #define CAMCIR_ARM_TIMER0_INT_REQ_OFFS		1
 #define CAMCIR_ARM_TIMER0_INT_REQ_MASK		BIT1
-#define CAMCIR_ARM_TIMER0_INT_REQ_EN		(1 << CAMCIR_ARM_TIMER0_INT_REQ_OFFS) 
+#define CAMCIR_ARM_TIMER0_INT_REQ_EN		(1 << CAMCIR_ARM_TIMER0_INT_REQ_OFFS)
 #define CAMCIR_ARM_TIMER0_INT_REQ_DIS		(0 << CAMCIR_ARM_TIMER0_INT_REQ_OFFS)
 
 #define CAMCIR_ARM_TIMER1_INT_REQ_OFFS		2
 #define CAMCIR_ARM_TIMER1_INT_REQ_MASK		BIT2
-#define CAMCIR_ARM_TIMER1_INT_REQ_EN		(1 << CAMCIR_ARM_TIMER1_INT_REQ_OFFS) 
-#define CAMCIR_ARM_TIMER1_INT_REQ_DIS		(0 << CAMCIR_ARM_TIMER1_INT_REQ_OFFS) 
+#define CAMCIR_ARM_TIMER1_INT_REQ_EN		(1 << CAMCIR_ARM_TIMER1_INT_REQ_OFFS)
+#define CAMCIR_ARM_TIMER1_INT_REQ_DIS		(0 << CAMCIR_ARM_TIMER1_INT_REQ_OFFS)
 
 #define CAMCIR_ARM_WD_TIMER_INT_REQ_OFFS 	3
 #define CAMCIR_ARM_WD_TIMER_INT_REQ_MASK 	BIT3
-#define CAMCIR_ARM_WD_TIMER_INT_REQ_EN	 	(1 << CAMCIR_ARM_WD_TIMER_INT_REQ_OFFS) 
-#define CAMCIR_ARM_WD_TIMER_INT_REQ_DIS	 	(0 << CAMCIR_ARM_WD_TIMER_INT_REQ_OFFS) 
+#define CAMCIR_ARM_WD_TIMER_INT_REQ_EN	 	(1 << CAMCIR_ARM_WD_TIMER_INT_REQ_OFFS)
+#define CAMCIR_ARM_WD_TIMER_INT_REQ_DIS	 	(0 << CAMCIR_ARM_WD_TIMER_INT_REQ_OFFS)
 
 /* CPU FTDLL Config register (CFCR) fields */
 #define CFCR_FTDLL_ICACHE_TAG_OFFS		0
@@ -290,13 +290,13 @@ while ARM boot is still in progress
 
 /* CPU control register map */
 /* Set bits means value is about to change according to new value */
-#define CPU_CONFIG_DEFAULT_MASK         	(CCR_VEC_INIT_LOC_MASK  | CCR_AHB_ERROR_PROP_MASK)      
+#define CPU_CONFIG_DEFAULT_MASK         	(CCR_VEC_INIT_LOC_MASK  | CCR_AHB_ERROR_PROP_MASK)
 
 #define CPU_CONFIG_DEFAULT                      (CCR_VEC_INIT_LOC_FF00)
-                 
+
 /* CPU Control and status defaults */
 #define CPU_CTRL_STAT_DEFAULT_MASK              (CCSR_PCI_ACCESS_MASK)
-                                                                        
+
 
 #define CPU_CTRL_STAT_DEFAULT                   (CCSR_PCI_ACCESS_ENABLE)
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c
index 769475f..8475956 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -67,10 +67,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * mvAudioWinSet - Set AUDIO target address window
 *
 * DESCRIPTION:
-*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0) 
-*       address window, also known as address decode window. 
-*       After setting this target window, the AUDIO will be able to access the 
-*       target within the address window. 
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0)
+*       address window, also known as address decode window.
+*       After setting this target window, the AUDIO will be able to access the
+*       target within the address window.
 *
 * INPUT:
 *       winNum      - AUDIO target address decode window number.
@@ -81,7 +81,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * RETURN:
 *       MV_ERROR if address window overlapps with other address decode windows.
-*       MV_BAD_PARAM if base address is invalid parameter or target is 
+*       MV_BAD_PARAM if base address is invalid parameter or target is
 *       unknown.
 *
 *******************************************************************************/
@@ -96,14 +96,14 @@ MV_STATUS mvAudioWinSet(MV_U32 winNum, MV_AUDIO_DEC_WIN *pAddrDecWin)
         mvOsPrintf("%s: ERR. Invalid win num %d\n",__FUNCTION__, winNum);
         return MV_BAD_PARAM;
     }
-    
+
     /* check if address is aligned to the size */
     if(MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size))
     {
 		mvOsPrintf("mvAudioWinSet:Error setting AUDIO window %d to "\
 			   "target %s.\nAddress 0x%08x is unaligned to size 0x%x.\n",
 			   winNum,
-			   mvCtrlTargetNameGet(pAddrDecWin->target), 
+			   mvCtrlTargetNameGet(pAddrDecWin->target),
 			   pAddrDecWin->addrWin.baseLow,
 			   pAddrDecWin->addrWin.size);
 		return MV_ERROR;
@@ -119,7 +119,7 @@ MV_STATUS mvAudioWinSet(MV_U32 winNum, MV_AUDIO_DEC_WIN *pAddrDecWin)
     }
 
     mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
-                                                                                                                         
+
     /* set attributes */
     decRegs.sizeReg &= ~MV_AUDIO_WIN_ATTR_MASK;
     decRegs.sizeReg |= (targetAttribs.attrib << MV_AUDIO_WIN_ATTR_OFFSET);
@@ -139,7 +139,7 @@ MV_STATUS mvAudioWinSet(MV_U32 winNum, MV_AUDIO_DEC_WIN *pAddrDecWin)
 
     MV_REG_WRITE( MV_AUDIO_WIN_CTRL_REG(winNum), decRegs.sizeReg);
     MV_REG_WRITE( MV_AUDIO_WIN_BASE_REG(winNum), decRegs.baseReg);
-    
+
     return MV_OK;
 }
 
@@ -163,34 +163,34 @@ MV_STATUS mvAudioWinGet(MV_U32 winNum, MV_AUDIO_DEC_WIN *pAddrDecWin)
 {
     MV_DEC_REGS         decRegs;
     MV_TARGET_ATTRIB    targetAttrib;
-                                                                                                                         
+
     /* Parameter checking   */
     if (winNum >= MV_AUDIO_MAX_ADDR_DECODE_WIN)
     {
-        mvOsPrintf("%s : ERR. Invalid winNum %d\n", 
+        mvOsPrintf("%s : ERR. Invalid winNum %d\n",
                     __FUNCTION__,  winNum);
         return MV_NOT_SUPPORTED;
     }
 
     decRegs.baseReg = MV_REG_READ( MV_AUDIO_WIN_BASE_REG(winNum) );
     decRegs.sizeReg = MV_REG_READ( MV_AUDIO_WIN_CTRL_REG(winNum) );
- 
+
     if (MV_OK != mvCtrlRegToAddrDec(&decRegs, &pAddrDecWin->addrWin) )
     {
         mvOsPrintf("%s: mvCtrlRegToAddrDec Failed\n", __FUNCTION__);
-        return MV_ERROR; 
+        return MV_ERROR;
     }
-       
+
     /* attrib and targetId */
-    targetAttrib.attrib = (decRegs.sizeReg & MV_AUDIO_WIN_ATTR_MASK) >> 
+    targetAttrib.attrib = (decRegs.sizeReg & MV_AUDIO_WIN_ATTR_MASK) >>
 		MV_AUDIO_WIN_ATTR_OFFSET;
-    targetAttrib.targetId = (decRegs.sizeReg & MV_AUDIO_WIN_TARGET_MASK) >> 
+    targetAttrib.targetId = (decRegs.sizeReg & MV_AUDIO_WIN_TARGET_MASK) >>
 		MV_AUDIO_WIN_TARGET_OFFSET;
- 
+
     pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
 
     /* Check if window is enabled   */
-    if(decRegs.sizeReg & MV_AUDIO_WIN_ENABLE_MASK) 
+    if(decRegs.sizeReg & MV_AUDIO_WIN_ENABLE_MASK)
     {
         pAddrDecWin->enable = MV_TRUE;
     }
@@ -222,7 +222,7 @@ MV_VOID mvAudioAddrDecShow(MV_VOID)
 	MV_AUDIO_DEC_WIN win;
 	int i;
 
-	if (MV_FALSE == mvCtrlPwrClckGet(AUDIO_UNIT_ID, 0)) 
+	if (MV_FALSE == mvCtrlPwrClckGet(AUDIO_UNIT_ID, 0))
 		return;
 
 
@@ -245,7 +245,7 @@ MV_VOID mvAudioAddrDecShow(MV_VOID)
                     mvOsOutput( "...." );
 
                     mvSizePrint( win.addrWin.size );
-    
+
 		    mvOsOutput( "\n" );
                 }
 		else
@@ -265,7 +265,7 @@ MV_VOID mvAudioAddrDecShow(MV_VOID)
 *
 *
 * OUTPUT:
-*     
+*
 *
 * RETURN:
 *       MV_ERROR if register parameters are invalid.
@@ -297,13 +297,13 @@ MV_STATUS mvAudioInit(MV_VOID)
 		/* first get attributes from CPU If */
 		status = mvCpuIfTargetWinGet(SDRAM_CS0,
 									 &cpuAddrDecWin);
-	
+
 		if (MV_OK != status)
 		{
 				mvOsPrintf("%s: ERR. mvCpuIfTargetWinGet failed\n", __FUNCTION__);
 			return MV_ERROR;
 		}
-	
+
 		if (cpuAddrDecWin.enable == MV_TRUE)
 		{
 			audioWin.addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh;
@@ -311,7 +311,7 @@ MV_STATUS mvAudioInit(MV_VOID)
 			audioWin.addrWin.size     = cpuAddrDecWin.addrWin.size;
 			audioWin.enable           = MV_TRUE;
 			audioWin.target           = SDRAM_CS0;
-	
+
 			if(MV_OK != mvAudioWinSet(winNum, &audioWin))
 			{
 				return MV_ERROR;
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h
index f59eb9a..216d797 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -108,7 +108,7 @@ typedef struct _mvAudioDecWin
     MV_TARGET     target;
     MV_ADDR_WIN   addrWin;    /* An address window*/
     MV_BOOL       enable;     /* Address decode window is enabled/disabled    */
- 
+
 } MV_AUDIO_DEC_WIN;
 
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.c
index 84d0cd0..9b50bae 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.c
@@ -103,28 +103,28 @@ MV_TARGET tdmaAddrDecPrioTable[] =
 *
 *******************************************************************************/
 static MV_STATUS mvCesaWinGet(MV_U32 winNum, MV_DEC_WIN *pDecWin)
-{                                                                                                                         
+{
     MV_DEC_WIN_PARAMS   winParam;
     MV_U32              sizeReg, baseReg;
 
     /* Parameter checking   */
     if (winNum >= MV_CESA_TDMA_ADDR_DEC_WIN)
     {
-        mvOsPrintf("%s : ERR. Invalid winNum %d\n", 
+        mvOsPrintf("%s : ERR. Invalid winNum %d\n",
                     __FUNCTION__, winNum);
         return MV_NOT_SUPPORTED;
     }
 
     baseReg = MV_REG_READ( MV_CESA_TDMA_BASE_ADDR_REG(winNum) );
     sizeReg = MV_REG_READ( MV_CESA_TDMA_WIN_CTRL_REG(winNum) );
- 
+
    /* Check if window is enabled   */
-    if(sizeReg & MV_CESA_TDMA_WIN_ENABLE_MASK) 
+    if(sizeReg & MV_CESA_TDMA_WIN_ENABLE_MASK)
     {
         pDecWin->enable = MV_TRUE;
 
         /* Extract window parameters from registers */
-        winParam.targetId = (sizeReg & MV_CESA_TDMA_WIN_TARGET_MASK) >> MV_CESA_TDMA_WIN_TARGET_OFFSET; 
+        winParam.targetId = (sizeReg & MV_CESA_TDMA_WIN_TARGET_MASK) >> MV_CESA_TDMA_WIN_TARGET_OFFSET;
         winParam.attrib   = (sizeReg & MV_CESA_TDMA_WIN_ATTR_MASK) >> MV_CESA_TDMA_WIN_ATTR_OFFSET;
         winParam.size     = (sizeReg & MV_CESA_TDMA_WIN_SIZE_MASK) >> MV_CESA_TDMA_WIN_SIZE_OFFSET;
         winParam.baseAddr = (baseReg & MV_CESA_TDMA_WIN_BASE_MASK);
@@ -134,7 +134,7 @@ static MV_STATUS mvCesaWinGet(MV_U32 winNum, MV_DEC_WIN *pDecWin)
         {
             mvOsPrintf("Failed to translate register parameters to CESA address" \
                        " decode window structure\n");
-            return MV_ERROR;        
+            return MV_ERROR;
         }
     }
     else
@@ -148,10 +148,10 @@ static MV_STATUS mvCesaWinGet(MV_U32 winNum, MV_DEC_WIN *pDecWin)
 * cesaWinOverlapDetect - Detect CESA TDMA address windows overlapping
 *
 * DESCRIPTION:
-*       An unpredicted behaviur is expected in case TDMA address decode 
+*       An unpredicted behaviur is expected in case TDMA address decode
 *       windows overlapps.
-*       This function detects TDMA address decode windows overlapping of a 
-*       specified window. The function does not check the window itself for 
+*       This function detects TDMA address decode windows overlapping of a
+*       specified window. The function does not check the window itself for
 *       overlapping. The function also skipps disabled address decode windows.
 *
 * INPUT:
@@ -163,8 +163,8 @@ static MV_STATUS mvCesaWinGet(MV_U32 winNum, MV_DEC_WIN *pDecWin)
 *
 * RETURN:
 *       MV_TRUE     - if the given address window overlap current address
-*                   decode map, 
-*       MV_FALSE    - otherwise, MV_ERROR if reading invalid data 
+*                   decode map,
+*       MV_FALSE    - otherwise, MV_ERROR if reading invalid data
 *                   from registers.
 *
 *******************************************************************************/
@@ -172,7 +172,7 @@ static MV_STATUS cesaWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
 {
     MV_U32          winNumIndex;
     MV_DEC_WIN      addrDecWin;
-    
+
     for(winNumIndex=0; winNumIndex<MV_CESA_TDMA_ADDR_DEC_WIN; winNumIndex++)
     {
         /* Do not check window itself       */
@@ -197,7 +197,7 @@ static MV_STATUS cesaWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
         if (MV_TRUE == ctrlWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
         {
             return MV_TRUE;
-        }        
+        }
     }
     return MV_FALSE;
 }
@@ -206,10 +206,10 @@ static MV_STATUS cesaWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
 * mvCesaTdmaWinSet - Set CESA TDMA target address window
 *
 * DESCRIPTION:
-*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0) 
-*       address window, also known as address decode window. 
-*       After setting this target window, the CESA TDMA will be able to access the 
-*       target within the address window. 
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0)
+*       address window, also known as address decode window.
+*       After setting this target window, the CESA TDMA will be able to access the
+*       target within the address window.
 *
 * INPUT:
 *       winNum      - CESA TDMA target address decode window number.
@@ -220,7 +220,7 @@ static MV_STATUS cesaWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
 *
 * RETURN:
 *       MV_ERROR        - if address window overlapps with other address decode windows.
-*       MV_BAD_PARAM    - if base address is invalid parameter or target is 
+*       MV_BAD_PARAM    - if base address is invalid parameter or target is
 *                       unknown.
 *
 *******************************************************************************/
@@ -228,7 +228,7 @@ static MV_STATUS mvCesaTdmaWinSet(MV_U32 winNum, MV_DEC_WIN *pDecWin)
 {
     MV_DEC_WIN_PARAMS   winParams;
     MV_U32              sizeReg, baseReg;
-    
+
     /* Parameter checking   */
     if (winNum >= MV_CESA_TDMA_ADDR_DEC_WIN)
     {
@@ -249,7 +249,7 @@ static MV_STATUS mvCesaTdmaWinSet(MV_U32 winNum, MV_DEC_WIN *pDecWin)
         mvOsPrintf("mvCesaTdmaWinSet: Error setting CESA TDMA window %d to "\
                    "target %s.\nAddress 0x%08x is unaligned to size 0x%x.\n",
                    winNum,
-                   mvCtrlTargetNameGet(pDecWin->target), 
+                   mvCtrlTargetNameGet(pDecWin->target),
                    pDecWin->addrWin.baseLow,
                    pDecWin->addrWin.size);
         return MV_ERROR;
@@ -276,11 +276,11 @@ static MV_STATUS mvCesaTdmaWinSet(MV_U32 winNum, MV_DEC_WIN *pDecWin)
     }
 
     /* Update Base value  */
-    baseReg = (winParams.baseAddr & MV_CESA_TDMA_WIN_BASE_MASK);     
+    baseReg = (winParams.baseAddr & MV_CESA_TDMA_WIN_BASE_MASK);
 
     MV_REG_WRITE( MV_CESA_TDMA_WIN_CTRL_REG(winNum), sizeReg);
     MV_REG_WRITE( MV_CESA_TDMA_BASE_ADDR_REG(winNum), baseReg);
-        
+
     return MV_OK;
 }
 
@@ -301,11 +301,11 @@ static MV_STATUS   mvCesaTdmaAddrDecInit (void)
 
     /* Go through all windows in user table until table terminator      */
     winNum = 0;
-    while( (tdmaAddrDecPrioTable[winPrioIndex] != TBL_TERM) && 
+    while( (tdmaAddrDecPrioTable[winPrioIndex] != TBL_TERM) &&
            (winNum < MV_CESA_TDMA_ADDR_DEC_WIN) )    {
 
         /* first get attributes from CPU If */
-        status = mvCpuIfTargetWinGet(tdmaAddrDecPrioTable[winPrioIndex], 
+        status = mvCpuIfTargetWinGet(tdmaAddrDecPrioTable[winPrioIndex],
                                      &cpuAddrDecWin);
         if(MV_NO_SUCH == status){
 	    winPrioIndex++;
@@ -326,10 +326,10 @@ static MV_STATUS   mvCesaTdmaAddrDecInit (void)
             cesaWin.enable           = MV_TRUE;
             cesaWin.target           = tdmaAddrDecPrioTable[winPrioIndex];
 
-#if defined(MV646xx) 
+#if defined(MV646xx)
             /* Get the default attributes for that target window */
             mvCtrlDefAttribGet(cesaWin.target, &cesaWin.addrWinAttr);
-#endif /* MV646xx */ 
+#endif /* MV646xx */
 
             if(MV_OK != mvCesaTdmaWinSet(winNum, &cesaWin))
             {
@@ -369,14 +369,14 @@ MV_STATUS mvCesaInit (int numOfSession, int queueDepth, char* pSramBase, void *o
     }
 #else
         cesaCryptEngBase = (MV_U32)pSramBase;
-#endif     
+#endif
 
 #if 0 /* Already done in the platform init */
 #if (MV_CESA_VERSION >= 2)
     mvCesaTdmaAddrDecInit();
 #endif /* MV_CESA_VERSION >= 2 */
 #endif
-	return mvCesaHalInit(numOfSession, queueDepth, pSramBase, cesaCryptEngBase, 
+	return mvCesaHalInit(numOfSession, queueDepth, pSramBase, cesaCryptEngBase,
 			     osHandle);
 
 }
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.h
index 73bcdc5..9bc3fee 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.h
@@ -82,10 +82,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_CESA_TDMA_WIN_ENABLE_BIT         0
 #define MV_CESA_TDMA_WIN_ENABLE_MASK        (1 << MV_CESA_TDMA_WIN_ENABLE_BIT)
 
-#define MV_CESA_TDMA_WIN_TARGET_OFFSET      4 
+#define MV_CESA_TDMA_WIN_TARGET_OFFSET      4
 #define MV_CESA_TDMA_WIN_TARGET_MASK        (0xf << MV_CESA_TDMA_WIN_TARGET_OFFSET)
 
-#define MV_CESA_TDMA_WIN_ATTR_OFFSET        8 
+#define MV_CESA_TDMA_WIN_ATTR_OFFSET        8
 #define MV_CESA_TDMA_WIN_ATTR_MASK          (0xff << MV_CESA_TDMA_WIN_ATTR_OFFSET)
 
 #define MV_CESA_TDMA_WIN_SIZE_OFFSET        16
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.c
index 6f76c2c..f2e34ad 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -81,7 +81,7 @@ static MV_BOOL sdramIfWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin);
 /*******************************************************************************
 * mvDramIfWinSet - Set DRAM interface address decode window
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *       This function sets DRAM interface address decode window.
 *
 * INPUT:
@@ -119,7 +119,7 @@ MV_STATUS mvDramIfWinSet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 	{
 		mvOsPrintf("mvDramIfWinSet:Error setting DRAM interface window %d."\
 				   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
-                   target, 
+                   target,
 				   pAddrDecWin->addrWin.baseLow,
 				   pAddrDecWin->addrWin.size);
 		return MV_ERROR;
@@ -168,13 +168,13 @@ MV_STATUS mvDramIfWinSet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 
 	/* Write to address decode Size Register                        	*/
 	MV_REG_WRITE(SDRAM_SIZE_REG(0,target), sizeReg);
-	
+
 	return MV_OK;
 }
 /*******************************************************************************
 * mvDramIfWinGet - Get DRAM interface address decode window
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *       This function gets DRAM interface address decode window.
 *
 * INPUT:
@@ -227,7 +227,7 @@ MV_STATUS mvDramIfWinGet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 	}
 	else
 	{
-		pAddrDecWin->enable = MV_FALSE;			
+		pAddrDecWin->enable = MV_FALSE;
 	}
 
 	return MV_OK;
@@ -235,7 +235,7 @@ MV_STATUS mvDramIfWinGet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 /*******************************************************************************
 * mvDramIfWinEnable - Enable/Disable SDRAM address decode window
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *		This function enable/Disable SDRAM address decode window.
 *
 * INPUT:
@@ -259,11 +259,11 @@ MV_STATUS mvDramIfWinEnable(MV_TARGET target, MV_BOOL enable)
 		return MV_ERROR;
 	}
 
-	if (enable == MV_TRUE) 
+	if (enable == MV_TRUE)
 	{   /* First check for overlap with other enabled windows				*/
 		if (MV_OK != mvDramIfWinGet(target, &addrDecWin))
 		{
-			mvOsPrintf("mvDramIfWinEnable:ERR. Getting target %d failed.\n", 
+			mvOsPrintf("mvDramIfWinEnable:ERR. Getting target %d failed.\n",
                                                                         target);
 			return MV_ERROR;
 		}
@@ -292,12 +292,12 @@ MV_STATUS mvDramIfWinEnable(MV_TARGET target, MV_BOOL enable)
 * sdramIfWinOverlap - Check if an address window overlap an SDRAM address window
 *
 * DESCRIPTION:
-*		This function scan each SDRAM address decode window to test if it 
-*		overlapps the given address windoow 
+*		This function scan each SDRAM address decode window to test if it
+*		overlapps the given address windoow
 *
 * INPUT:
 *       target      - SDRAM target where the function skips checking.
-*       pAddrDecWin - The tested address window for overlapping with 
+*       pAddrDecWin - The tested address window for overlapping with
 *					  SDRAM windows.
 *
 * OUTPUT:
@@ -312,7 +312,7 @@ static MV_BOOL sdramIfWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
 {
 	MV_TARGET	targetNum;
 	MV_DRAM_DEC_WIN 	addrDecWin;
-	
+
 	for(targetNum = SDRAM_CS0; targetNum < MV_DRAM_MAX_CS ; targetNum++)
 	{
 		/* don't check our winNum or illegal targets */
@@ -320,29 +320,29 @@ static MV_BOOL sdramIfWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
 		{
 			continue;
 		}
-		
+
 		/* Get window parameters 	*/
 		if (MV_OK != mvDramIfWinGet(targetNum, &addrDecWin))
 		{
 			mvOsPrintf("sdramIfWinOverlap: ERR. TargetWinGet failed\n");
 			return MV_ERROR;
 		}
-	
+
 		/* Do not check disabled windows	*/
 		if (MV_FALSE == addrDecWin.enable)
 		{
 			continue;
 		}
-	
+
 		if(MV_TRUE == ctrlWinOverlapTest(pAddrWin, &addrDecWin.addrWin))
-		{                    
+		{
 			mvOsPrintf(
-			"sdramIfWinOverlap: Required target %d overlap winNum %d\n", 
+			"sdramIfWinOverlap: Required target %d overlap winNum %d\n",
 			target, targetNum);
-			return MV_TRUE;           
+			return MV_TRUE;
 		}
 	}
-	
+
 	return MV_FALSE;
 }
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.h
index 7bd9c9d..f16b947 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -67,7 +67,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define __sysDram
 
 /* This structure describes CPU interface address decode window               */
-typedef struct _mvDramIfDecWin 
+typedef struct _mvDramIfDecWin
 {
 	MV_ADDR_WIN   addrWin;    /* An address window*/
 	MV_BOOL       enable;     /* Address decode window is enabled/disabled    */
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysGbe.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysGbe.c
index 7f6e4a5..d29d281 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysGbe.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysGbe.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -72,7 +72,7 @@ typedef struct _mvEthDecWin
     MV_TARGET     target;
     MV_ADDR_WIN   addrWin;  /* An address window*/
     MV_BOOL       enable;   /* Address decode window is enabled/disabled */
-  
+
 }MV_ETH_DEC_WIN;
 
 MV_TARGET ethAddrDecPrioTap[] =
@@ -111,12 +111,12 @@ static MV_STATUS   ethWinOverlapDetect(int port, MV_U32 winNum, MV_ADDR_WIN *pAd
 static MV_STATUS   mvEthWinSet(int port, MV_U32 winNum, MV_ETH_DEC_WIN *pAddrDecWin);
 static MV_STATUS   mvEthWinGet(int port, MV_U32 winNum, MV_ETH_DEC_WIN *pAddrDecWin);
 
-                                                                                                                             
+
 /*******************************************************************************
-* mvEthWinInit - Initialize ETH address decode windows 
+* mvEthWinInit - Initialize ETH address decode windows
 *
 * DESCRIPTION:
-*               This function initialize ETH window decode unit. It set the 
+*               This function initialize ETH window decode unit. It set the
 *               default address decode windows of the unit.
 *
 * INPUT:
@@ -157,11 +157,11 @@ MV_STATUS 	mvEthWinInit (int port)
     MV_REG_WRITE(ETH_BASE_ADDR_ENABLE_REG(port), regVal);
 
    /* Go through all windows in user table until table terminator      */
-    for (winNum=0; ((ethAddrDecPrioTap[winPrioIndex] != TBL_TERM) && 
+    for (winNum=0; ((ethAddrDecPrioTap[winPrioIndex] != TBL_TERM) &&
                     (winNum < ETH_MAX_DECODE_WIN)); )
     {
         /* first get attributes from CPU If */
-        status = mvCpuIfTargetWinGet(ethAddrDecPrioTap[winPrioIndex], 
+        status = mvCpuIfTargetWinGet(ethAddrDecPrioTap[winPrioIndex],
                                      &cpuAddrDecWin);
 
         if(MV_NO_SUCH == status)
@@ -230,14 +230,14 @@ MV_STATUS mvEthWinSet(int port, MV_U32 winNum, MV_ETH_DEC_WIN *pAddrDecWin)
 {
     MV_TARGET_ATTRIB    targetAttribs;
     MV_DEC_REGS         decRegs;
-    
+
     /* Parameter checking   */
     if (winNum >= ETH_MAX_DECODE_WIN)
     {
         mvOsPrintf("mvEthWinSet: ERR. Invalid win num %d\n",winNum);
         return MV_BAD_PARAM;
-    }    
-    
+    }
+
     /* Check if the requested window overlapps with current windows     */
     if (MV_TRUE == ethWinOverlapDetect(port, winNum, &pAddrDecWin->addrWin))
     {
@@ -251,45 +251,45 @@ MV_STATUS mvEthWinSet(int port, MV_U32 winNum, MV_ETH_DEC_WIN *pAddrDecWin)
 		mvOsPrintf("mvEthWinSet: Error setting Ethernet window %d to "\
 				   "target %s.\nAddress 0x%08x is unaligned to size 0x%x.\n",
 				   winNum,
-				   mvCtrlTargetNameGet(pAddrDecWin->target), 
+				   mvCtrlTargetNameGet(pAddrDecWin->target),
 				   pAddrDecWin->addrWin.baseLow,
 				   pAddrDecWin->addrWin.size);
 		return MV_ERROR;
 	}
 
-    
+
     decRegs.baseReg = MV_REG_READ(ETH_WIN_BASE_REG(port, winNum));
     decRegs.sizeReg = MV_REG_READ(ETH_WIN_SIZE_REG(port, winNum));
-    
+
     if (MV_OK != mvCtrlAddrDecToReg(&(pAddrDecWin->addrWin),&decRegs))
     {
         mvOsPrintf("mvEthWinSet:mvCtrlAddrDecToReg Failed\n");
         return MV_ERROR;
     }
-    
+
     mvCtrlAttribGet(pAddrDecWin->target,&targetAttribs);
-    
+
     /* set attributes */
     decRegs.baseReg &= ~ETH_WIN_ATTR_MASK;
     decRegs.baseReg |= targetAttribs.attrib << ETH_WIN_ATTR_OFFS;
     /* set target ID */
     decRegs.baseReg &= ~ETH_WIN_TARGET_MASK;
     decRegs.baseReg |= targetAttribs.targetId << ETH_WIN_TARGET_OFFS;
-    
+
     /* for the safe side we disable the window before writing the new
     values */
     mvEthWinEnable(port, winNum, MV_FALSE);
     MV_REG_WRITE(ETH_WIN_BASE_REG(port, winNum), decRegs.baseReg);
-    
+
     /* Write to address decode Size Register                            */
     MV_REG_WRITE(ETH_WIN_SIZE_REG(port, winNum), decRegs.sizeReg);
-    
+
     /* Enable address decode target window                              */
     if (pAddrDecWin->enable == MV_TRUE)
     {
             mvEthWinEnable(port, winNum, MV_TRUE);
     }
-    
+
     return MV_OK;
 }
 
@@ -313,31 +313,31 @@ MV_STATUS mvEthWinGet(int port, MV_U32 winNum, MV_ETH_DEC_WIN *pAddrDecWin)
 {
     MV_DEC_REGS decRegs;
     MV_TARGET_ATTRIB targetAttrib;
-    
+
     /* Parameter checking   */
     if (winNum >= ETH_MAX_DECODE_WIN)
     {
         mvOsPrintf("mvEthWinGet: ERR. Invalid winNum %d\n", winNum);
         return MV_NOT_SUPPORTED;
     }
-    
+
     decRegs.baseReg =  MV_REG_READ(ETH_WIN_BASE_REG(port, winNum));
     decRegs.sizeReg = MV_REG_READ(ETH_WIN_SIZE_REG(port, winNum));
-    
+
     if (MV_OK != mvCtrlRegToAddrDec(&decRegs,&(pAddrDecWin->addrWin)))
     {
         mvOsPrintf("mvAhbToMbusWinGet: mvCtrlRegToAddrDec Failed \n");
         return MV_ERROR;
     }
-    
+
     /* attrib and targetId */
-    targetAttrib.attrib = 
+    targetAttrib.attrib =
      (decRegs.baseReg & ETH_WIN_ATTR_MASK) >> ETH_WIN_ATTR_OFFS;
-    targetAttrib.targetId = 
+    targetAttrib.targetId =
      (decRegs.baseReg & ETH_WIN_TARGET_MASK) >> ETH_WIN_TARGET_OFFS;
-    
+
     pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
-    
+
     /* Check if window is enabled   */
     if (~(MV_REG_READ(ETH_BASE_ADDR_ENABLE_REG(port))) & (1 << winNum) )
     {
@@ -347,7 +347,7 @@ MV_STATUS mvEthWinGet(int port, MV_U32 winNum, MV_ETH_DEC_WIN *pAddrDecWin)
     {
         pAddrDecWin->enable = MV_FALSE;
     }
-    
+
         return MV_OK;
 }
 
@@ -408,7 +408,7 @@ MV_STATUS mvEthWinEnable(int port, MV_U32 winNum,MV_BOOL enable)
     }
     return MV_OK;
 }
- 
+
 /*******************************************************************************
 * mvEthWinTargetGet - Get Window number associated with target
 *
@@ -447,17 +447,17 @@ MV_U32  mvEthWinTargetGet(int port, MV_TARGET target)
             if (decWin.target == target)
             {
                 return winNum;
-            }  
+            }
         }
     }
     return 0xFFFFFFFF;
 }
- 
+
 /*******************************************************************************
 * mvEthProtWinSet - Set access protection of Ethernet to target window.
 *
 * DESCRIPTION:
-*       Each Ethernet port can be configured with access attributes for each 
+*       Each Ethernet port can be configured with access attributes for each
 *       of the Ethenret to target windows (address decode windows). This
 *       function sets access attributes to a given window for the given channel.
 *
@@ -474,7 +474,7 @@ MV_U32  mvEthWinTargetGet(int port, MV_TARGET target)
 *
 *******************************************************************************/
 MV_STATUS mvEthProtWinSet(MV_U32 portNo, MV_U32 winNum, MV_ACCESS_RIGHTS access)
-{    
+{
     MV_U32 protReg;
 
     /* Parameter checking   */
@@ -483,7 +483,7 @@ MV_STATUS mvEthProtWinSet(MV_U32 portNo, MV_U32 winNum, MV_ACCESS_RIGHTS access)
         mvOsPrintf("mvEthProtWinSet:ERR. Invalid port number %d\n", portNo);
         return MV_ERROR;
     }
-    
+
     if (winNum >= ETH_MAX_DECODE_WIN)
     {
             mvOsPrintf("mvEthProtWinSet:ERR. Invalid winNum%d\n",winNum);
@@ -497,18 +497,18 @@ MV_STATUS mvEthProtWinSet(MV_U32 portNo, MV_U32 winNum, MV_ACCESS_RIGHTS access)
     }
     /* Read current protection register */
     protReg = MV_REG_READ(ETH_ACCESS_PROTECT_REG(portNo));
-                          
+
     /* Clear protection window field */
     protReg &= ~(ETH_PROT_WIN_MASK(winNum));
 
     /* Set new protection field value */
     protReg |= (access << (ETH_PROT_WIN_OFFS(winNum)));
-    
+
     /* Write protection register back   */
     MV_REG_WRITE(ETH_ACCESS_PROTECT_REG(portNo), protReg);
 
     return MV_OK;
-}               
+}
 
 /*******************************************************************************
 * ethWinOverlapDetect - Detect ETH address windows overlapping
@@ -538,10 +538,10 @@ static MV_STATUS ethWinOverlapDetect(int port, MV_U32 winNum, MV_ADDR_WIN *pAddr
     MV_U32              baseAddrEnableReg;
     MV_U32              winNumIndex;
     MV_ETH_DEC_WIN      addrDecWin;
-                                                                                                                             
+
     /* Read base address enable register. Do not check disabled windows     */
     baseAddrEnableReg = MV_REG_READ(ETH_BASE_ADDR_ENABLE_REG(port));
-                                                                                                                             
+
     for (winNumIndex=0; winNumIndex<ETH_MAX_DECODE_WIN; winNumIndex++)
     {
         /* Do not check window itself           */
@@ -549,20 +549,20 @@ static MV_STATUS ethWinOverlapDetect(int port, MV_U32 winNum, MV_ADDR_WIN *pAddr
         {
             continue;
         }
-    
+
         /* Do not check disabled windows        */
         if (baseAddrEnableReg & (1 << winNumIndex))
         {
             continue;
         }
-    
+
         /* Get window parameters        */
         if (MV_OK != mvEthWinGet(port, winNumIndex, &addrDecWin))
         {
             mvOsPrintf("ethWinOverlapDetect: ERR. TargetWinGet failed\n");
             return MV_ERROR;
         }
-/*    
+/*
         mvOsPrintf("ethWinOverlapDetect:\n
             winNumIndex =%d baseHigh =0x%x baseLow=0x%x size=0x%x enable=0x%x\n",
             winNumIndex,
@@ -635,7 +635,7 @@ void    mvEthAddrDecShow(void)
     for(port=0; port<mvCtrlEthMaxPortGet(); port++)
     {
 	if (MV_FALSE == mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port)) continue;
-    
+
         mvEthPortAddrDecShow(port);
     }
 }
@@ -648,7 +648,7 @@ void    mvEthInit(void)
     /* Power down all existing ports */
     for(port=0; port<mvCtrlEthMaxPortGet(); port++)
     {
-	    if (MV_FALSE == mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port)) 
+	    if (MV_FALSE == mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port))
             continue;
 
         mvEthPortPowerUp(port);
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysGbe.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysGbe.h
index 615af51..aac5517 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysGbe.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysGbe.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer. 
+        this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -85,10 +85,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* Ethernet Port Access Protect (EPAP) register */
 
 /* The target associated with this window*/
-#define ETH_WIN_TARGET_OFFS             0 
+#define ETH_WIN_TARGET_OFFS             0
 #define ETH_WIN_TARGET_MASK             (0xf << ETH_WIN_TARGET_OFFS)
 /* The target attributes Associated with window */
-#define ETH_WIN_ATTR_OFFS               8 
+#define ETH_WIN_ATTR_OFFS               8
 #define ETH_WIN_ATTR_MASK               (0xff << ETH_WIN_ATTR_OFFS)
 
 /* Ethernet Port Access Protect Register (EPAPR) */
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.c
index b0cb466..65a9740 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -72,10 +72,10 @@ typedef struct _pexWinToTarget
 
 }PEX_WIN_TO_TARGET;
 
-/* this array is a priority array that define How Pex windows should be 
+/* this array is a priority array that define How Pex windows should be
 configured , We have only 6 Pex Windows that can be configured , but we
 have maximum of 9 CPU target windows ! the following array is a priority
-array where the lowest index has the highest priotiy and the highest 
+array where the lowest index has the highest priotiy and the highest
 index has the lowest priority of being cnfigured */
 
 MV_U32	pexDevBarPrioTable[] =
@@ -88,7 +88,7 @@ MV_U32	pexDevBarPrioTable[] =
 #endif
 #if defined(MV_INCLUDE_DEVICE_CS2)
     DEVICE_CS2,
-#endif                                               
+#endif
 #if defined(MV_INCLUDE_DEVICE_CS3)
     DEVICE_CS3,
 #endif
@@ -133,10 +133,10 @@ const MV_8* pexBarNameGet( MV_U32 bar );
 *
 * DESCRIPTION:
 *
-* This function is responsible of intialization of the Pex Interface , It 
+* This function is responsible of intialization of the Pex Interface , It
 * configure the Pex Bars and Windows in the following manner:
 *
-*  Assumptions : 
+*  Assumptions :
 *				Bar0 is always internal registers bar
 *			    Bar1 is always the DRAM bar
 *				Bar2 is always the Device bar
@@ -144,11 +144,11 @@ const MV_8* pexBarNameGet( MV_U32 bar );
 *  1) Sets the Internal registers bar base by obtaining the base from
 *	  the CPU Interface
 *  2) Sets the DRAM bar base and size by getting the base and size from
-*     the CPU Interface when the size is the sum of all enabled DRAM 
+*     the CPU Interface when the size is the sum of all enabled DRAM
 *	  chip selects and the base is the base of CS0 .
-*  3) Sets the Device bar base and size by getting these values from the 
+*  3) Sets the Device bar base and size by getting these values from the
 *     CPU Interface when the base is the base of the lowest base of the
-*     Device chip selects, and the 
+*     Device chip selects, and the
 *
 *
 * INPUT:
@@ -173,7 +173,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 	MV_TARGET 		target;
 	MV_U32			pexCurrWin=0;
 	MV_U32			status;
-	/* default and exapntion rom 
+	/* default and exapntion rom
 	are always configured */
 
 #ifndef MV_DISABLE_PEX_DEVICE_BAR
@@ -188,7 +188,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 		mvOsPrintf("mvPexInit: ERR. Invalid PEX interface %d\n", pexIf);
 		return MV_BAD_PARAM;
 	}
-	
+
 	/* Enabled CPU access to PCI-Express */
 	mvCpuIfEnablePex(pexIf, pexType);
 
@@ -203,7 +203,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 				mvOsPrintf("mvPexInit:mvPexBarEnable bar =%d failed \n",bar);
 				return MV_ERROR;
 			}
-			
+
 		}
 
 	}
@@ -248,7 +248,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 		mvOsPrintf("mvPexInit: ERR. mvPexBarSet %d failed\n", bar);
 		return MV_ERROR;
 	}
-	
+
 /******************************************************************************/
 /*                                DRAM bar                                    */
 /******************************************************************************/
@@ -256,7 +256,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 	bar = PEX_DRAM_BAR;
 
 	pexBar.addrWin.size = 0;
-	
+
 	for (target = SDRAM_CS0;target < MV_DRAM_MAX_CS; target++ )
 	{
 
@@ -274,7 +274,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 			return MV_ERROR;
 		}
 		if (addrDecWin.enable == MV_TRUE)
-		{				
+		{
 			/* the base is the base of DRAM CS0 always */
 			if (SDRAM_CS0 == target )
 			{
@@ -287,13 +287,13 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 			DRAM chips selecs */
 			pexBar.addrWin.size += addrDecWin.addrWin.size;
 
-			/* set a Pex window for this target ! 
-			DRAM CS always will have a Pex Window , and is not a 
+			/* set a Pex window for this target !
+			DRAM CS always will have a Pex Window , and is not a
 			part of the priority table */
 			pexWin.addrWin.baseHigh = addrDecWin.addrWin.baseHigh;
 			pexWin.addrWin.baseLow = addrDecWin.addrWin.baseLow;
 			pexWin.addrWin.size = addrDecWin.addrWin.size;
-			
+
 			/* we disable the windows at first because we are not
 			sure that it is witihin bar boundries */
 			pexWin.enable =MV_FALSE;
@@ -315,7 +315,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 		pexBar.addrWin.size = ctrlSizeRegRoundUp(pexBar.addrWin.size,
 												 PXBCR_BAR_SIZE_ALIGNMENT);
 	}
-    
+
 	/* check if the size and base are valid */
 	if (MV_TRUE == pexBarOverlapDetect(pexIf,bar,&pexBar.addrWin))
 	{
@@ -326,14 +326,14 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 	else
 	{
 		pexBar.enable = MV_TRUE;
-        
+
 		/* configure the bar */
 		if (MV_OK != mvPexBarSet(pexIf, bar, &pexBar))
 		{
 			mvOsPrintf("mvPexInit: ERR. mvPexBarSet %d failed\n", bar);
 			return MV_ERROR;
 		}
-	
+
 		/* after the bar was configured then we enable the Pex windows*/
 		for (winNum = 0;winNum < pexCurrWin ;winNum++)
 		{
@@ -342,7 +342,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 				mvOsPrintf("mvPexInit: Can't enable window =%d\n",winNum);
 				return MV_ERROR;
 			}
-	
+
 		}
 	}
 
@@ -351,7 +351,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 /******************************************************************************/
 
 /* Open the Device BAR for non linux only */
-#ifndef MV_DISABLE_PEX_DEVICE_BAR 
+#ifndef MV_DISABLE_PEX_DEVICE_BAR
 
 	/* then device  bar*/
 	bar = PEX_DEVICE_BAR;
@@ -379,7 +379,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 		}
 
 		if (addrDecWin.enable == MV_TRUE)
-		{				
+		{
 			/* get the minimum base */
 			if (addrDecWin.addrWin.baseLow < pexBar.addrWin.baseLow)
 			{
@@ -405,8 +405,8 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 				{
 					/*found it */
 
-					/* if the index of this target in the prio table is valid 
-					then we set the Pex window for this target, a valid index is 
+					/* if the index of this target in the prio table is valid
+					then we set the Pex window for this target, a valid index is
 					an index that is lower than the number of the windows that
 					was not configured yet */
 
@@ -418,7 +418,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 						pexWin.addrWin.baseHigh = addrDecWin.addrWin.baseHigh;
 						pexWin.addrWin.baseLow = addrDecWin.addrWin.baseLow;
 						pexWin.addrWin.size = addrDecWin.addrWin.size;
-						
+
 						/* we disable the windows at first because we are not
 						sure that it is witihin bar boundries */
 						pexWin.enable = MV_FALSE;
@@ -492,13 +492,13 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 *       N/A
 *
 * RETURN:
-*       MV_OK if PEX BAR target window was set correctly, 
-*		MV_BAD_PARAM on bad params 
-*       MV_ERROR otherwise 
+*       MV_OK if PEX BAR target window was set correctly,
+*		MV_BAD_PARAM on bad params
+*       MV_ERROR otherwise
 *       (e.g. address window overlapps with other active PEX target window).
 *
 *******************************************************************************/
-MV_STATUS mvPexTargetWinSet(MV_U32 pexIf, MV_U32 winNum, 
+MV_STATUS mvPexTargetWinSet(MV_U32 pexIf, MV_U32 winNum,
                             MV_PEX_DEC_WIN *pAddrDecWin)
 {
 
@@ -533,7 +533,7 @@ MV_STATUS mvPexTargetWinSet(MV_U32 pexIf, MV_U32 winNum,
 			mvOsPrintf("mvPexTargetWinSet: ERR. Target %d overlap\n", winNum);
 			return MV_BAD_PARAM;
 		}
-	
+
 		/* 2) Check if the requested window overlaps with current windows  */
 		if (MV_FALSE == pexIsWinWithinBar(pexIf,&pAddrDecWin->addrWin))
 		{
@@ -547,7 +547,7 @@ MV_STATUS mvPexTargetWinSet(MV_U32 pexIf, MV_U32 winNum,
 
 
 	/* read base register*/
-	
+
 	if (winRegInfo.baseLowRegOffs)
 	{
 		decRegs.baseReg = MV_REG_READ(winRegInfo.baseLowRegOffs);
@@ -565,11 +565,11 @@ MV_STATUS mvPexTargetWinSet(MV_U32 pexIf, MV_U32 winNum,
 	{
 		decRegs.sizeReg =0;
 	}
-	
+
 	if (MV_OK != mvCtrlAddrDecToReg(&(pAddrDecWin->addrWin),&decRegs))
 	{
 		mvOsPrintf("mvPexTargetWinSet:mvCtrlAddrDecToReg Failed\n");
-		return MV_ERROR;		
+		return MV_ERROR;
 	}
 
 	/* enable\Disable */
@@ -652,7 +652,7 @@ MV_STATUS mvPexTargetWinSet(MV_U32 pexIf, MV_U32 winNum,
 *       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
 *
 *******************************************************************************/
-MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum, 
+MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum,
                             MV_PEX_DEC_WIN *pAddrDecWin)
 {
 	MV_TARGET_ATTRIB targetAttrib;
@@ -710,7 +710,7 @@ MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum,
 	}
 	else
 	{
-		pAddrDecWin->enable = MV_FALSE;	  
+		pAddrDecWin->enable = MV_FALSE;
 
 	}
 
@@ -727,17 +727,17 @@ MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum,
 	if ((decRegs.sizeReg & PXWCR_WIN_BAR_MAP_MASK) == PXWCR_WIN_BAR_MAP_BAR1 )
 	{
 		pAddrDecWin->targetBar = 1;
-	} 
-	else if ((decRegs.sizeReg & PXWCR_WIN_BAR_MAP_MASK) == 
+	}
+	else if ((decRegs.sizeReg & PXWCR_WIN_BAR_MAP_MASK) ==
 			 PXWCR_WIN_BAR_MAP_BAR2 )
 	{
 		pAddrDecWin->targetBar = 2;
 	}
 
 	/* attrib and targetId */
-	pAddrDecWin->attrib = (decRegs.sizeReg & PXWCR_ATTRIB_MASK) >> 
+	pAddrDecWin->attrib = (decRegs.sizeReg & PXWCR_ATTRIB_MASK) >>
 													PXWCR_ATTRIB_OFFS;
-	pAddrDecWin->targetId = (decRegs.sizeReg & PXWCR_TARGET_MASK) >> 
+	pAddrDecWin->targetId = (decRegs.sizeReg & PXWCR_TARGET_MASK) >>
 													PXWCR_TARGET_OFFS;
 
 	targetAttrib.attrib = pAddrDecWin->attrib;
@@ -755,9 +755,9 @@ MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum,
 *
 * DESCRIPTION:
 *       This function enable/disable a PEX BAR window.
-*       if parameter 'enable' == MV_TRUE the routine will enable the 
-*       window, thus enabling PEX accesses for that BAR (before enabling the 
-*       window it is tested for overlapping). Otherwise, the window will 
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling PEX accesses for that BAR (before enabling the
+*       window it is tested for overlapping). Otherwise, the window will
 *       be disabled.
 *
 * INPUT:
@@ -864,7 +864,7 @@ MV_STATUS mvPexTargetWinEnable(MV_U32 pexIf,MV_U32 winNum, MV_BOOL enable)
 *       The PEX interface supports remap of the BAR original address window.
 *       For each BAR it is possible to define a remap address. For example
 *       an address 0x12345678 that hits BAR 0x10 (SDRAM CS[0]) will be modified
-*       according to remap register but will also be targeted to the 
+*       according to remap register but will also be targeted to the
 *       SDRAM CS[0].
 *
 * INPUT:
@@ -879,22 +879,22 @@ MV_STATUS mvPexTargetWinEnable(MV_U32 pexIf,MV_U32 winNum, MV_BOOL enable)
 *       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
 *
 *******************************************************************************/
-MV_STATUS mvPexTargetWinRemap(MV_U32 pexIf, MV_U32 winNum, 
+MV_STATUS mvPexTargetWinRemap(MV_U32 pexIf, MV_U32 winNum,
                            MV_PEX_REMAP_WIN *pAddrWin)
 {
 
 	PEX_WIN_REG_INFO winRegInfo;
-	
+
 	/* Parameter checking   */
 	if (pexIf >= mvCtrlPexMaxIfGet())
 	{
-		mvOsPrintf("mvPexTargetWinRemap: ERR. Invalid PEX interface num %d\n", 
+		mvOsPrintf("mvPexTargetWinRemap: ERR. Invalid PEX interface num %d\n",
 																		pexIf);
 		return MV_BAD_PARAM;
 	}
 	if (MV_PEX_WIN_DEFAULT == winNum)
 	{
-		mvOsPrintf("mvPexTargetWinRemap: ERR. Invalid PEX win num %d\n", 
+		mvOsPrintf("mvPexTargetWinRemap: ERR. Invalid PEX win num %d\n",
 																		winNum);
 		return MV_BAD_PARAM;
 
@@ -908,7 +908,7 @@ MV_STATUS mvPexTargetWinRemap(MV_U32 pexIf, MV_U32 winNum,
 				   winNum,
                    pAddrWin->addrWin.baseLow,
 				   pAddrWin->addrWin.size);
-		
+
 		return MV_ERROR;
 	}
 
@@ -916,7 +916,7 @@ MV_STATUS mvPexTargetWinRemap(MV_U32 pexIf, MV_U32 winNum,
 
 	/* Set remap low register value */
 	MV_REG_WRITE(winRegInfo.remapLowRegOffs, pAddrWin->addrWin.baseLow);
-	
+
 	/* Skip base high settings if the BAR has only base low (32-bit)		*/
 	if (0 != winRegInfo.remapHighRegOffs)
 	{
@@ -937,7 +937,7 @@ MV_STATUS mvPexTargetWinRemap(MV_U32 pexIf, MV_U32 winNum,
 }
 
 /*******************************************************************************
-* mvPexTargetWinRemapEnable - 
+* mvPexTargetWinRemapEnable -
 *
 * DESCRIPTION:
 *
@@ -950,21 +950,21 @@ MV_STATUS mvPexTargetWinRemap(MV_U32 pexIf, MV_U32 winNum,
 *
 *******************************************************************************/
 
-MV_STATUS mvPexTargetWinRemapEnable(MV_U32 pexIf, MV_U32 winNum, 
+MV_STATUS mvPexTargetWinRemapEnable(MV_U32 pexIf, MV_U32 winNum,
                            MV_BOOL enable)
 {
 	PEX_WIN_REG_INFO winRegInfo;
-	
+
 	/* Parameter checking   */
 	if (pexIf >= mvCtrlPexMaxIfGet())
 	{
-		mvOsPrintf("mvPexTargetWinRemap: ERR. Invalid PEX interface num %d\n", 
+		mvOsPrintf("mvPexTargetWinRemap: ERR. Invalid PEX interface num %d\n",
 																		pexIf);
 		return MV_BAD_PARAM;
 	}
 	if (MV_PEX_WIN_DEFAULT == winNum)
 	{
-		mvOsPrintf("mvPexTargetWinRemap: ERR. Invalid PEX win num %d\n", 
+		mvOsPrintf("mvPexTargetWinRemap: ERR. Invalid PEX win num %d\n",
 																		winNum);
 		return MV_BAD_PARAM;
 
@@ -987,7 +987,7 @@ MV_STATUS mvPexTargetWinRemapEnable(MV_U32 pexIf, MV_U32 winNum,
 }
 
 /*******************************************************************************
-*  mvPexBarSet - Set PEX bar address and size 
+*  mvPexBarSet - Set PEX bar address and size
 *
 * DESCRIPTION:
 *
@@ -1020,7 +1020,7 @@ MV_STATUS mvPexBarSet(MV_U32 pexIf,
 		mvOsPrintf("mvPexBarSet: ERR. Invalid bar number %d\n", barNum);
 		return MV_BAD_PARAM;
 	}
-	
+
 
 	if (pAddrWin->addrWin.size == 0)
 	{
@@ -1046,7 +1046,7 @@ MV_STATUS mvPexBarSet(MV_U32 pexIf,
 
 	/* Get size register value according to window size						*/
 	sizeToReg = ctrlSizeToReg(pAddrWin->addrWin.size, PXBCR_BAR_SIZE_ALIGNMENT);
-	
+
 	/* Read bar size */
 	if (PEX_INTER_REGS_BAR != barNum) /* internal registers have no size */
 	{
@@ -1058,10 +1058,10 @@ MV_STATUS mvPexBarSet(MV_U32 pexIf,
 			mvOsPrintf("mvPexBarSet: ERR. Target BAR %d size invalid.\n",barNum);
 			return MV_BAD_PARAM;
 		}
-	
+
 		regSize &= ~PXBCR_BAR_SIZE_MASK;
 		regSize |= (sizeToReg << PXBCR_BAR_SIZE_OFFS) ;
-	
+
 		MV_REG_WRITE(PEX_BAR_CTRL_REG(pexIf,barNum),regSize);
 
 	}
@@ -1107,7 +1107,7 @@ MV_STATUS mvPexBarSet(MV_U32 pexIf,
 	/* lastly enable the Bar */
 	if (pAddrWin->enable == MV_TRUE)
 	{
-		if (PEX_INTER_REGS_BAR != barNum) /* internal registers 
+		if (PEX_INTER_REGS_BAR != barNum) /* internal registers
 												are enabled always */
 		{
 			MV_REG_BIT_SET(PEX_BAR_CTRL_REG(pexIf,barNum),PXBCR_BAR_EN);
@@ -1115,7 +1115,7 @@ MV_STATUS mvPexBarSet(MV_U32 pexIf,
 	}
 	else if (MV_FALSE == pAddrWin->enable)
 	{
-		if (PEX_INTER_REGS_BAR != barNum) /* internal registers 
+		if (PEX_INTER_REGS_BAR != barNum) /* internal registers
 												are enabled always */
 		{
 			MV_REG_BIT_RESET(PEX_BAR_CTRL_REG(pexIf,barNum),PXBCR_BAR_EN);
@@ -1162,7 +1162,7 @@ MV_STATUS mvPexBarGet(MV_U32 pexIf,
 	}
 
 	/* read base low */
-	pAddrWin->addrWin.baseLow = 
+	pAddrWin->addrWin.baseLow =
 		MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf,PEX_MV_BAR_BASE(barNum)));
 
 
@@ -1177,7 +1177,7 @@ MV_STATUS mvPexBarGet(MV_U32 pexIf,
 
 
 	/* read base high */
-	pAddrWin->addrWin.baseHigh = 
+	pAddrWin->addrWin.baseHigh =
 		MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf,PEX_MV_BAR_BASE_HIGH(barNum)));
 
 
@@ -1195,7 +1195,7 @@ MV_STATUS mvPexBarGet(MV_U32 pexIf,
 		{
 			pAddrWin->enable = MV_FALSE;
 		}
-			
+
 		/* now get the size */
 		pAddrWin->addrWin.size &= PXBCR_BAR_SIZE_MASK;
 		pAddrWin->addrWin.size >>= PXBCR_BAR_SIZE_OFFS;
@@ -1215,7 +1215,7 @@ MV_STATUS mvPexBarGet(MV_U32 pexIf,
 }
 
 /*******************************************************************************
-*  mvPexBarEnable - 
+*  mvPexBarEnable -
 *
 * DESCRIPTION:
 *
@@ -1303,7 +1303,7 @@ MV_STATUS mvPexBarEnable(MV_U32 pexIf, MV_U32 barNum, MV_BOOL enable)
 * pexWinOverlapDetect - Detect address windows overlapping
 *
 * DESCRIPTION:
-*       This function detects address window overlapping of a given address 
+*       This function detects address window overlapping of a given address
 *       window in PEX BARs.
 *
 * INPUT:
@@ -1325,7 +1325,7 @@ static MV_BOOL pexWinOverlapDetect(MV_U32 pexIf,
     MV_U32 		   win;
 	MV_PEX_DEC_WIN addrDecWin;
 
-	
+
 	for(win = 0; win < PEX_MAX_TARGET_WIN -2 ; win++)
     {
         /* don't check our target or illegal targets */
@@ -1333,7 +1333,7 @@ static MV_BOOL pexWinOverlapDetect(MV_U32 pexIf,
         {
             continue;
         }
-        
+
 		/* Get window parameters 	*/
 		if (MV_OK != mvPexTargetWinGet(pexIf, win, &addrDecWin))
 		{
@@ -1348,15 +1348,15 @@ static MV_BOOL pexWinOverlapDetect(MV_U32 pexIf,
 			continue;
 		}
 
-        
+
         if(MV_TRUE == ctrlWinOverlapTest(pAddrWin, &addrDecWin.addrWin))
-		{                    
-			mvOsPrintf("pexWinOverlapDetect: winNum %d overlap current %d\n", 
+		{
+			mvOsPrintf("pexWinOverlapDetect: winNum %d overlap current %d\n",
 															winNum, win);
-			return MV_TRUE;           
+			return MV_TRUE;
 		}
     }
-    
+
 	return MV_FALSE;
 }
 
@@ -1383,27 +1383,27 @@ static MV_BOOL pexIsWinWithinBar(MV_U32 pexIf,
 
 	for(bar = 0; bar < PEX_MAX_BARS; bar++)
     {
-        
+
 		/* Get window parameters 	*/
 		if (MV_OK != mvPexBarGet(pexIf, bar, &addrDecWin))
 		{
 			mvOsPrintf("pexIsWinWithinBar: ERR. mvPexBarGet failed\n");
             return MV_ERROR;
 		}
-		
+
 		/* Do not check disabled bars	*/
 		if (MV_FALSE == addrDecWin.enable)
 		{
 			continue;
 		}
 
-        
+
         if(MV_TRUE == ctrlWinWithinWinTest(pAddrWin, &addrDecWin.addrWin))
-		{                    
+		{
 			return MV_TRUE;
 		}
     }
-    
+
 	return MV_FALSE;
 
 }
@@ -1412,7 +1412,7 @@ static MV_BOOL pexIsWinWithinBar(MV_U32 pexIf,
 * pexBarOverlapDetect - Detect address windows overlapping
 *
 * DESCRIPTION:
-*       This function detects address window overlapping of a given address 
+*       This function detects address window overlapping of a given address
 *       window in PEX BARs.
 *
 * INPUT:
@@ -1434,7 +1434,7 @@ static MV_BOOL pexBarOverlapDetect(MV_U32 pexIf,
     MV_U32 		   bar;
 	MV_PEX_BAR barDecWin;
 
-	
+
 	for(bar = 0; bar < PEX_MAX_BARS; bar++)
     {
         /* don't check our target or illegal targets */
@@ -1442,7 +1442,7 @@ static MV_BOOL pexBarOverlapDetect(MV_U32 pexIf,
         {
             continue;
         }
-        
+
 		/* Get window parameters 	*/
 		if (MV_OK != mvPexBarGet(pexIf, bar, &barDecWin))
 		{
@@ -1458,13 +1458,13 @@ static MV_BOOL pexBarOverlapDetect(MV_U32 pexIf,
 
 
         if(MV_TRUE == ctrlWinOverlapTest(pAddrWin, &barDecWin.addrWin))
-		{                    
-			mvOsPrintf("pexBarOverlapDetect: winNum %d overlap current %d\n", 
+		{
+			mvOsPrintf("pexBarOverlapDetect: winNum %d overlap current %d\n",
 															barNum, bar);
-			return MV_TRUE;           
+			return MV_TRUE;
 		}
     }
-    
+
 	return MV_FALSE;
 }
 
@@ -1498,7 +1498,7 @@ static MV_STATUS pexBarIsValid(MV_U32 baseLow, MV_U32 size)
 	{
 		return MV_TRUE;
 	}
-	
+
 	return MV_TRUE;
 }
 
@@ -1506,13 +1506,13 @@ static MV_STATUS pexBarIsValid(MV_U32 baseLow, MV_U32 size)
 * pexBarRegInfoGet - Get BAR register information
 *
 * DESCRIPTION:
-* 		PEX BARs registers offsets are inconsecutive. 
+* 		PEX BARs registers offsets are inconsecutive.
 *		This function gets a PEX BAR register information like register offsets
 *		and function location of the BAR.
 *
 * INPUT:
 *       pexIf - PEX interface number.
-*		bar	  - The PEX BAR in question.	
+*		bar	  - The PEX BAR in question.
 *
 * OUTPUT:
 *       pBarRegInfo - BAR register info struct.
@@ -1521,7 +1521,7 @@ static MV_STATUS pexBarIsValid(MV_U32 baseLow, MV_U32 size)
 *		MV_BAD_PARAM when bad parameters ,MV_ERROR on error ,othewise MV_OK
 *
 *******************************************************************************/
-static MV_STATUS pexWinRegInfoGet(MV_U32 pexIf, 
+static MV_STATUS pexWinRegInfoGet(MV_U32 pexIf,
 								  MV_U32 winNum,
 								  PEX_WIN_REG_INFO *pWinRegInfo)
 {
@@ -1582,13 +1582,13 @@ static MV_STATUS pexWinRegInfoGet(MV_U32 pexIf,
 *******************************************************************************/
 const MV_8* pexBarNameGet( MV_U32 bar )
 {
-	switch( bar ) 
+	switch( bar )
 	{
-		case PEX_INTER_REGS_BAR: 
+		case PEX_INTER_REGS_BAR:
 			return "Internal Regs Bar0....";
-		case PEX_DRAM_BAR: 
+		case PEX_DRAM_BAR:
 			return "DRAM Bar1.............";
-		case PEX_DEVICE_BAR: 
+		case PEX_DEVICE_BAR:
 			return "Devices Bar2..........";
 		default:
 			 return "Bar unknown";
@@ -1626,7 +1626,7 @@ MV_VOID mvPexAddrDecShow(MV_VOID)
 
 		mvOsOutput( "\nPex Bars \n\n");
 
-		for( bar = 0; bar < PEX_MAX_BARS; bar++ ) 
+		for( bar = 0; bar < PEX_MAX_BARS; bar++ )
 		{
 			memset( &pexBar, 0, sizeof(MV_PEX_BAR) );
 
@@ -1669,7 +1669,7 @@ MV_VOID mvPexAddrDecShow(MV_VOID)
 
 			}
 		}
-	
+
 		memset( &win, 0,sizeof(MV_PEX_DEC_WIN) );
 
 		mvOsOutput( "default win - " );
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.h
index 3505613..dbe0ca5 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -206,13 +206,13 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 
-/*PEX_MEMORY_BAR_BASE_ADDR(barNum) (PXMBBA)*/ 
+/*PEX_MEMORY_BAR_BASE_ADDR(barNum) (PXMBBA)*/
 /* PCI Express BAR0 Internal Register*/
 /*PEX BAR0_INTER_REG (PXBIR)*/
 
 #define PXBIR_IOSPACE			BIT0	/* Memory Space Indicator */
 
-#define PXBIR_TYPE_OFFS			1	   /* BAR Type/Init Val. */ 
+#define PXBIR_TYPE_OFFS			1	   /* BAR Type/Init Val. */
 #define PXBIR_TYPE_MASK			(0x3 << PXBIR_TYPE_OFFS)
 #define PXBIR_TYPE_32BIT_ADDR	(0x0 << PXBIR_TYPE_OFFS)
 #define PXBIR_TYPE_64BIT_ADDR	(0x2 << PXBIR_TYPE_OFFS)
@@ -225,14 +225,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 /* PCI Express BAR0 Internal (High) Register*/
-/*PEX BAR0_INTER_REG_HIGH (PXBIRH)*/      
+/*PEX BAR0_INTER_REG_HIGH (PXBIRH)*/
 
 #define PXBIRH_BASE_OFFS			0		/* Base address. Bits [63:32] */
 #define PXBIRH_BASE_MASK			(0xffffffff << PBBHR_BASE_OFFS)
 
 
 #define PEX_BAR_DEFAULT_ATTRIB		0xc /* Memory - Prefetch - 64 bit address */
-#define PEX_BAR0_DEFAULT_ATTRIB	    PEX_BAR_DEFAULT_ATTRIB  
+#define PEX_BAR0_DEFAULT_ATTRIB	    PEX_BAR_DEFAULT_ATTRIB
 #define PEX_BAR1_DEFAULT_ATTRIB		PEX_BAR_DEFAULT_ATTRIB
 #define PEX_BAR2_DEFAULT_ATTRIB		PEX_BAR_DEFAULT_ATTRIB
 
@@ -244,7 +244,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define PXBR_IOSPACE			BIT0	/* Memory Space Indicator */
 
-#define PXBR_TYPE_OFFS			1	   /* BAR Type/Init Val. */ 
+#define PXBR_TYPE_OFFS			1	   /* BAR Type/Init Val. */
 #define PXBR_TYPE_MASK			(0x3 << PXBR_TYPE_OFFS)
 #define PXBR_TYPE_32BIT_ADDR	(0x0 << PXBR_TYPE_OFFS)
 #define PXBR_TYPE_64BIT_ADDR	(0x2 << PXBR_TYPE_OFFS)
@@ -270,16 +270,16 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define PXERBAR_EXPROMEN		BIT0	/* Expansion ROM Enable */
 
 #define PXERBAR_BASE_512K_OFFS		19		/* Expansion ROM Base Address */
-#define PXERBAR_BASE_512K_MASK		(0x1fff << PXERBAR_BASE_512K_OFFS) 	
+#define PXERBAR_BASE_512K_MASK		(0x1fff << PXERBAR_BASE_512K_OFFS)
 
 #define PXERBAR_BASE_1MB_OFFS		20		/* Expansion ROM Base Address */
-#define PXERBAR_BASE_1MB_MASK		(0xfff << PXERBAR_BASE_1MB_OFFS) 	
+#define PXERBAR_BASE_1MB_MASK		(0xfff << PXERBAR_BASE_1MB_OFFS)
 
 #define PXERBAR_BASE_2MB_OFFS		21		/* Expansion ROM Base Address */
-#define PXERBAR_BASE_2MB_MASK		(0x7ff << PXERBAR_BASE_2MB_OFFS) 	
+#define PXERBAR_BASE_2MB_MASK		(0x7ff << PXERBAR_BASE_2MB_OFFS)
 
 #define PXERBAR_BASE_4MB_OFFS		22		/* Expansion ROM Base Address */
-#define PXERBAR_BASE_4MB_MASK		(0x3ff << PXERBAR_BASE_4MB_OFFS) 	
+#define PXERBAR_BASE_4MB_MASK		(0x3ff << PXERBAR_BASE_4MB_OFFS)
 
 /* PEX Bar attributes */
 typedef struct _mvPexBar
@@ -315,22 +315,22 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType);
 
 
 /* mvPexTargetWinSet - Set PEX to peripheral target address window BAR*/
-MV_STATUS mvPexTargetWinSet(MV_U32 pexIf, MV_U32 winNum, 
+MV_STATUS mvPexTargetWinSet(MV_U32 pexIf, MV_U32 winNum,
                             MV_PEX_DEC_WIN *pAddrDecWin);
 
 /* mvPexTargetWinGet - Get PEX to peripheral target address window*/
-MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum, 
+MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum,
                             MV_PEX_DEC_WIN *pAddrDecWin);
 
 /* mvPexTargetWinEnable - Enable/disable a PEX BAR window*/
 MV_STATUS mvPexTargetWinEnable(MV_U32 pexIf,MV_U32 winNum, MV_BOOL enable);
 
 /* mvPexTargetWinRemap - Set PEX to target address window remap.*/
-MV_STATUS mvPexTargetWinRemap(MV_U32 pexIf, MV_U32 winNum, 
+MV_STATUS mvPexTargetWinRemap(MV_U32 pexIf, MV_U32 winNum,
                            MV_PEX_REMAP_WIN *pAddrWin);
 
 /* mvPexTargetWinRemapEnable -enable\disable a PEX Window remap.*/
-MV_STATUS mvPexTargetWinRemapEnable(MV_U32 pexIf, MV_U32 winNum, 
+MV_STATUS mvPexTargetWinRemapEnable(MV_U32 pexIf, MV_U32 winNum,
                            MV_BOOL enable);
 
 /* mvPexBarSet - Set PEX bar address and size */
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.c
index f100a12..4c0485f 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -97,10 +97,10 @@ MV_TARGET sataAddrDecPrioTab[] =
 * sataWinOverlapDetect - Detect SATA address windows overlapping
 *
 * DESCRIPTION:
-*       An unpredicted behaviur is expected in case SATA address decode 
+*       An unpredicted behaviur is expected in case SATA address decode
 *       windows overlapps.
-*       This function detects SATA address decode windows overlapping of a 
-*       specified window. The function does not check the window itself for 
+*       This function detects SATA address decode windows overlapping of a
+*       specified window. The function does not check the window itself for
 *       overlapping. The function also skipps disabled address decode windows.
 *
 * INPUT:
@@ -112,11 +112,11 @@ MV_TARGET sataAddrDecPrioTab[] =
 *
 * RETURN:
 *       MV_TRUE if the given address window overlap current address
-*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data 
+*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data
 *       from registers.
 *
 *******************************************************************************/
-static MV_STATUS sataWinOverlapDetect(int dev, MV_U32 winNum, 
+static MV_STATUS sataWinOverlapDetect(int dev, MV_U32 winNum,
 				      MV_ADDR_WIN *pAddrWin)
 {
     MV_U32          winNumIndex;
@@ -146,7 +146,7 @@ static MV_STATUS sataWinOverlapDetect(int dev, MV_U32 winNum,
         if (MV_TRUE == ctrlWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
         {
             return MV_TRUE;
-        }        
+        }
     }
     return MV_FALSE;
 }
@@ -156,10 +156,10 @@ static MV_STATUS sataWinOverlapDetect(int dev, MV_U32 winNum,
 * mvSataWinSet - Set SATA target address window
 *
 * DESCRIPTION:
-*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0) 
-*       address window, also known as address decode window. 
-*       After setting this target window, the SATA will be able to access the 
-*       target within the address window. 
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0)
+*       address window, also known as address decode window.
+*       After setting this target window, the SATA will be able to access the
+*       target within the address window.
 *
 * INPUT:
 *       winNum      - SATA target address decode window number.
@@ -170,7 +170,7 @@ static MV_STATUS sataWinOverlapDetect(int dev, MV_U32 winNum,
 *
 * RETURN:
 *       MV_ERROR if address window overlapps with other address decode windows.
-*       MV_BAD_PARAM if base address is invalid parameter or target is 
+*       MV_BAD_PARAM if base address is invalid parameter or target is
 *       unknown.
 *
 *******************************************************************************/
@@ -185,7 +185,7 @@ MV_STATUS mvSataWinSet(int dev, MV_U32 winNum, MV_SATA_DEC_WIN *pAddrDecWin)
         mvOsPrintf("%s: ERR. Invalid win num %d\n",__FUNCTION__, winNum);
         return MV_BAD_PARAM;
     }
-    
+
     /* Check if the requested window overlapps with current windows         */
     if (MV_TRUE == sataWinOverlapDetect(dev, winNum, &pAddrDecWin->addrWin))
     {
@@ -199,7 +199,7 @@ MV_STATUS mvSataWinSet(int dev, MV_U32 winNum, MV_SATA_DEC_WIN *pAddrDecWin)
 	mvOsPrintf("mvSataWinSet:Error setting SATA window %d to "\
 		   "target %s.\nAddress 0x%08x is unaligned to size 0x%x.\n",
 		   winNum,
-		   mvCtrlTargetNameGet(pAddrDecWin->target), 
+		   mvCtrlTargetNameGet(pAddrDecWin->target),
 		   pAddrDecWin->addrWin.baseLow,
 		   pAddrDecWin->addrWin.size);
 	return MV_ERROR;
@@ -215,7 +215,7 @@ MV_STATUS mvSataWinSet(int dev, MV_U32 winNum, MV_SATA_DEC_WIN *pAddrDecWin)
     }
 
     mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
-                                                                                                                         
+
     /* set attributes */
     decRegs.sizeReg &= ~MV_SATA_WIN_ATTR_MASK;
     decRegs.sizeReg |= (targetAttribs.attrib << MV_SATA_WIN_ATTR_OFFSET);
@@ -235,7 +235,7 @@ MV_STATUS mvSataWinSet(int dev, MV_U32 winNum, MV_SATA_DEC_WIN *pAddrDecWin)
 
     MV_REG_WRITE( MV_SATA_WIN_CTRL_REG(dev, winNum), decRegs.sizeReg);
     MV_REG_WRITE( MV_SATA_WIN_BASE_REG(dev, winNum), decRegs.baseReg);
-    
+
     return MV_OK;
 }
 
@@ -259,34 +259,34 @@ MV_STATUS mvSataWinGet(int dev, MV_U32 winNum, MV_SATA_DEC_WIN *pAddrDecWin)
 {
     MV_DEC_REGS         decRegs;
     MV_TARGET_ATTRIB    targetAttrib;
-                                                                                                                         
+
     /* Parameter checking   */
     if (winNum >= MV_SATA_MAX_ADDR_DECODE_WIN)
     {
-        mvOsPrintf("%s (dev=%d): ERR. Invalid winNum %d\n", 
+        mvOsPrintf("%s (dev=%d): ERR. Invalid winNum %d\n",
                     __FUNCTION__, dev, winNum);
         return MV_NOT_SUPPORTED;
     }
 
     decRegs.baseReg = MV_REG_READ( MV_SATA_WIN_BASE_REG(dev, winNum) );
     decRegs.sizeReg = MV_REG_READ( MV_SATA_WIN_CTRL_REG(dev, winNum) );
- 
+
     if (MV_OK != mvCtrlRegToAddrDec(&decRegs, &pAddrDecWin->addrWin) )
     {
         mvOsPrintf("%s: mvCtrlRegToAddrDec Failed\n", __FUNCTION__);
-        return MV_ERROR; 
+        return MV_ERROR;
     }
-       
+
     /* attrib and targetId */
-    targetAttrib.attrib = (decRegs.sizeReg & MV_SATA_WIN_ATTR_MASK) >> 
+    targetAttrib.attrib = (decRegs.sizeReg & MV_SATA_WIN_ATTR_MASK) >>
 		MV_SATA_WIN_ATTR_OFFSET;
-    targetAttrib.targetId = (decRegs.sizeReg & MV_SATA_WIN_TARGET_MASK) >> 
+    targetAttrib.targetId = (decRegs.sizeReg & MV_SATA_WIN_TARGET_MASK) >>
 		MV_SATA_WIN_TARGET_OFFSET;
- 
+
     pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
 
     /* Check if window is enabled   */
-    if(decRegs.sizeReg & MV_SATA_WIN_ENABLE_MASK) 
+    if(decRegs.sizeReg & MV_SATA_WIN_ENABLE_MASK)
     {
         pAddrDecWin->enable = MV_TRUE;
     }
@@ -322,7 +322,7 @@ MV_VOID mvSataAddrDecShow(MV_VOID)
 
     for( j = 0; j < MV_SATA_MAX_CHAN; j++ )
     {
-	if (MV_FALSE == mvCtrlPwrClckGet(SATA_UNIT_ID, j)) 
+	if (MV_FALSE == mvCtrlPwrClckGet(SATA_UNIT_ID, j))
 		return;
 
 	mvOsOutput( "\n" );
@@ -344,7 +344,7 @@ MV_VOID mvSataAddrDecShow(MV_VOID)
                     mvOsOutput( "...." );
 
                     mvSizePrint( win.addrWin.size );
-    
+
 		    mvOsOutput( "\n" );
                 }
 		else
@@ -365,7 +365,7 @@ MV_VOID mvSataAddrDecShow(MV_VOID)
 *
 *
 * OUTPUT:
-*     
+*
 *
 * RETURN:
 *       MV_ERROR if register parameters are invalid.
@@ -387,7 +387,7 @@ MV_STATUS mvSataWinInit(MV_VOID)
         regVal &= ~MV_SATA_WIN_ENABLE_MASK;
         MV_REG_WRITE(MV_SATA_WIN_CTRL_REG(0, winNum), regVal);
     }
-    
+
     winNum = 0;
     while( (sataAddrDecPrioTab[winPrioIndex] != TBL_TERM) &&
            (winNum < MV_SATA_MAX_ADDR_DECODE_WIN) )
@@ -414,7 +414,7 @@ MV_STATUS mvSataWinInit(MV_VOID)
             sataWin.addrWin.size     = cpuAddrDecWin.addrWin.size;
             sataWin.enable           = MV_TRUE;
             sataWin.target           = sataAddrDecPrioTab[winPrioIndex];
-            
+
             if(MV_OK != mvSataWinSet(0/*dev*/, winNum, &sataWin))
             {
                 return MV_ERROR;
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.h
index 325fb8d..e401992 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.h
@@ -1,128 +1,128 @@
-
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-#ifndef __INCMVSysSataAddrDech
-#define __INCMVSysSataAddrDech
-
-#include "mvCommon.h"
-#include "ctrlEnv/mvCtrlEnvLib.h"
-#include "ctrlEnv/sys/mvCpuIf.h"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct _mvSataDecWin
-{
-    MV_TARGET     target;
-    MV_ADDR_WIN   addrWin;    /* An address window*/
-    MV_BOOL       enable;     /* Address decode window is enabled/disabled    */
- 
-} MV_SATA_DEC_WIN;
-
-
-#define MV_SATA_MAX_ADDR_DECODE_WIN 4
-
-#define MV_SATA_WIN_CTRL_REG(dev, win)        (SATA_REG_BASE + 0x30 + ((win)<<4))
-#define MV_SATA_WIN_BASE_REG(dev, win)        (SATA_REG_BASE + 0x34 + ((win)<<4))
-
-/* BITs in Bridge Interrupt Cause and Mask registers */
-#define MV_SATA_ADDR_DECODE_ERROR_BIT        0
-#define MV_SATA_ADDR_DECODE_ERROR_MASK       (1<<MV_SATA_ADDR_DECODE_ERROR_BIT)
-
-/* BITs in Windows 0-3 Control and Base Registers */
-#define MV_SATA_WIN_ENABLE_BIT               0
-#define MV_SATA_WIN_ENABLE_MASK              (1<<MV_SATA_WIN_ENABLE_BIT)
-
-#define MV_SATA_WIN_TARGET_OFFSET            4
-#define MV_SATA_WIN_TARGET_MASK              (0xF<<MV_SATA_WIN_TARGET_OFFSET)
-
-#define MV_SATA_WIN_ATTR_OFFSET              8
-#define MV_SATA_WIN_ATTR_MASK                (0xFF<<MV_SATA_WIN_ATTR_OFFSET)
-
-#define MV_SATA_WIN_SIZE_OFFSET              16
-#define MV_SATA_WIN_SIZE_MASK                (0xFFFF<<MV_SATA_WIN_SIZE_OFFSET)
-
-#define MV_SATA_WIN_BASE_OFFSET              16
-#define MV_SATA_WIN_BASE_MASK                (0xFFFF<<MV_SATA_WIN_BASE_OFFSET)
-
-MV_STATUS mvSataWinGet(int dev, MV_U32 winNum, MV_SATA_DEC_WIN *pAddrDecWin);
-MV_STATUS mvSataWinSet(int dev, MV_U32 winNum, MV_SATA_DEC_WIN *pAddrDecWin);
-MV_STATUS mvSataWinByTargetGet(MV_TARGET target, MV_SATA_DEC_WIN *pAddrDecWin);
-MV_STATUS mvSataWinInit(MV_VOID);
-MV_VOID   mvSataAddrDecShow(MV_VOID);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif
-
-
-
-
-
+
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCMVSysSataAddrDech
+#define __INCMVSysSataAddrDech
+
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _mvSataDecWin
+{
+    MV_TARGET     target;
+    MV_ADDR_WIN   addrWin;    /* An address window*/
+    MV_BOOL       enable;     /* Address decode window is enabled/disabled    */
+
+} MV_SATA_DEC_WIN;
+
+
+#define MV_SATA_MAX_ADDR_DECODE_WIN 4
+
+#define MV_SATA_WIN_CTRL_REG(dev, win)        (SATA_REG_BASE + 0x30 + ((win)<<4))
+#define MV_SATA_WIN_BASE_REG(dev, win)        (SATA_REG_BASE + 0x34 + ((win)<<4))
+
+/* BITs in Bridge Interrupt Cause and Mask registers */
+#define MV_SATA_ADDR_DECODE_ERROR_BIT        0
+#define MV_SATA_ADDR_DECODE_ERROR_MASK       (1<<MV_SATA_ADDR_DECODE_ERROR_BIT)
+
+/* BITs in Windows 0-3 Control and Base Registers */
+#define MV_SATA_WIN_ENABLE_BIT               0
+#define MV_SATA_WIN_ENABLE_MASK              (1<<MV_SATA_WIN_ENABLE_BIT)
+
+#define MV_SATA_WIN_TARGET_OFFSET            4
+#define MV_SATA_WIN_TARGET_MASK              (0xF<<MV_SATA_WIN_TARGET_OFFSET)
+
+#define MV_SATA_WIN_ATTR_OFFSET              8
+#define MV_SATA_WIN_ATTR_MASK                (0xFF<<MV_SATA_WIN_ATTR_OFFSET)
+
+#define MV_SATA_WIN_SIZE_OFFSET              16
+#define MV_SATA_WIN_SIZE_MASK                (0xFFFF<<MV_SATA_WIN_SIZE_OFFSET)
+
+#define MV_SATA_WIN_BASE_OFFSET              16
+#define MV_SATA_WIN_BASE_MASK                (0xFFFF<<MV_SATA_WIN_BASE_OFFSET)
+
+MV_STATUS mvSataWinGet(int dev, MV_U32 winNum, MV_SATA_DEC_WIN *pAddrDecWin);
+MV_STATUS mvSataWinSet(int dev, MV_U32 winNum, MV_SATA_DEC_WIN *pAddrDecWin);
+MV_STATUS mvSataWinByTargetGet(MV_TARGET target, MV_SATA_DEC_WIN *pAddrDecWin);
+MV_STATUS mvSataWinInit(MV_VOID);
+MV_VOID   mvSataAddrDecShow(MV_VOID);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
+
+
+
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c
index 6d2a919..682f6f1 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -97,10 +97,10 @@ MV_TARGET sdmmcAddrDecPrioTab[] =
 * sdmmcWinOverlapDetect - Detect SDMMC address windows overlapping
 *
 * DESCRIPTION:
-*       An unpredicted behaviur is expected in case SDMMC address decode 
+*       An unpredicted behaviur is expected in case SDMMC address decode
 *       windows overlapps.
-*       This function detects SDMMC address decode windows overlapping of a 
-*       specified window. The function does not check the window itself for 
+*       This function detects SDMMC address decode windows overlapping of a
+*       specified window. The function does not check the window itself for
 *       overlapping. The function also skipps disabled address decode windows.
 *
 * INPUT:
@@ -112,11 +112,11 @@ MV_TARGET sdmmcAddrDecPrioTab[] =
 *
 * RETURN:
 *       MV_TRUE if the given address window overlap current address
-*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data 
+*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data
 *       from registers.
 *
 *******************************************************************************/
-static MV_STATUS sdmmcWinOverlapDetect(int dev, MV_U32 winNum, 
+static MV_STATUS sdmmcWinOverlapDetect(int dev, MV_U32 winNum,
 				      MV_ADDR_WIN *pAddrWin)
 {
     MV_U32          winNumIndex;
@@ -146,7 +146,7 @@ static MV_STATUS sdmmcWinOverlapDetect(int dev, MV_U32 winNum,
         if (MV_TRUE == ctrlWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
         {
             return MV_TRUE;
-        }        
+        }
     }
     return MV_FALSE;
 }
@@ -156,10 +156,10 @@ static MV_STATUS sdmmcWinOverlapDetect(int dev, MV_U32 winNum,
 * mvSdmmcWinSet - Set SDMMC target address window
 *
 * DESCRIPTION:
-*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0) 
-*       address window, also known as address decode window. 
-*       After setting this target window, the SDMMC will be able to access the 
-*       target within the address window. 
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0)
+*       address window, also known as address decode window.
+*       After setting this target window, the SDMMC will be able to access the
+*       target within the address window.
 *
 * INPUT:
 *       winNum      - SDMMC target address decode window number.
@@ -170,7 +170,7 @@ static MV_STATUS sdmmcWinOverlapDetect(int dev, MV_U32 winNum,
 *
 * RETURN:
 *       MV_ERROR if address window overlapps with other address decode windows.
-*       MV_BAD_PARAM if base address is invalid parameter or target is 
+*       MV_BAD_PARAM if base address is invalid parameter or target is
 *       unknown.
 *
 *******************************************************************************/
@@ -185,7 +185,7 @@ MV_STATUS mvSdmmcWinSet(int dev, MV_U32 winNum, MV_SDMMC_DEC_WIN *pAddrDecWin)
         mvOsPrintf("%s: ERR. Invalid win num %d\n",__FUNCTION__, winNum);
         return MV_BAD_PARAM;
     }
-    
+
     /* Check if the requested window overlapps with current windows         */
     if (MV_TRUE == sdmmcWinOverlapDetect(dev, winNum, &pAddrDecWin->addrWin))
     {
@@ -199,7 +199,7 @@ MV_STATUS mvSdmmcWinSet(int dev, MV_U32 winNum, MV_SDMMC_DEC_WIN *pAddrDecWin)
 	mvOsPrintf("mvSdmmcWinSet:Error setting SDMMC window %d to "\
 		   "target %s.\nAddress 0x%08x is unaligned to size 0x%x.\n",
 		   winNum,
-		   mvCtrlTargetNameGet(pAddrDecWin->target), 
+		   mvCtrlTargetNameGet(pAddrDecWin->target),
 		   pAddrDecWin->addrWin.baseLow,
 		   pAddrDecWin->addrWin.size);
 	return MV_ERROR;
@@ -215,7 +215,7 @@ MV_STATUS mvSdmmcWinSet(int dev, MV_U32 winNum, MV_SDMMC_DEC_WIN *pAddrDecWin)
     }
 
     mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
-                                                                                                                         
+
     /* set attributes */
     decRegs.sizeReg &= ~MV_SDMMC_WIN_ATTR_MASK;
     decRegs.sizeReg |= (targetAttribs.attrib << MV_SDMMC_WIN_ATTR_OFFSET);
@@ -235,7 +235,7 @@ MV_STATUS mvSdmmcWinSet(int dev, MV_U32 winNum, MV_SDMMC_DEC_WIN *pAddrDecWin)
 
     MV_REG_WRITE( MV_SDMMC_WIN_CTRL_REG(dev, winNum), decRegs.sizeReg);
     MV_REG_WRITE( MV_SDMMC_WIN_BASE_REG(dev, winNum), decRegs.baseReg);
-    
+
     return MV_OK;
 }
 
@@ -259,34 +259,34 @@ MV_STATUS mvSdmmcWinGet(int dev, MV_U32 winNum, MV_SDMMC_DEC_WIN *pAddrDecWin)
 {
     MV_DEC_REGS         decRegs;
     MV_TARGET_ATTRIB    targetAttrib;
-                                                                                                                         
+
     /* Parameter checking   */
     if (winNum >= MV_SDMMC_MAX_ADDR_DECODE_WIN)
     {
-        mvOsPrintf("%s (dev=%d): ERR. Invalid winNum %d\n", 
+        mvOsPrintf("%s (dev=%d): ERR. Invalid winNum %d\n",
                     __FUNCTION__, dev, winNum);
         return MV_NOT_SUPPORTED;
     }
 
     decRegs.baseReg = MV_REG_READ( MV_SDMMC_WIN_BASE_REG(dev, winNum) );
     decRegs.sizeReg = MV_REG_READ( MV_SDMMC_WIN_CTRL_REG(dev, winNum) );
- 
+
     if (MV_OK != mvCtrlRegToAddrDec(&decRegs, &pAddrDecWin->addrWin) )
     {
         mvOsPrintf("%s: mvCtrlRegToAddrDec Failed\n", __FUNCTION__);
-        return MV_ERROR; 
+        return MV_ERROR;
     }
-       
+
     /* attrib and targetId */
-    targetAttrib.attrib = (decRegs.sizeReg & MV_SDMMC_WIN_ATTR_MASK) >> 
+    targetAttrib.attrib = (decRegs.sizeReg & MV_SDMMC_WIN_ATTR_MASK) >>
 		MV_SDMMC_WIN_ATTR_OFFSET;
-    targetAttrib.targetId = (decRegs.sizeReg & MV_SDMMC_WIN_TARGET_MASK) >> 
+    targetAttrib.targetId = (decRegs.sizeReg & MV_SDMMC_WIN_TARGET_MASK) >>
 		MV_SDMMC_WIN_TARGET_OFFSET;
- 
+
     pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
 
     /* Check if window is enabled   */
-    if(decRegs.sizeReg & MV_SDMMC_WIN_ENABLE_MASK) 
+    if(decRegs.sizeReg & MV_SDMMC_WIN_ENABLE_MASK)
     {
         pAddrDecWin->enable = MV_TRUE;
     }
@@ -320,7 +320,7 @@ MV_VOID mvSdmmcAddrDecShow(MV_VOID)
 
 
 
-	if (MV_FALSE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0)) 
+	if (MV_FALSE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0))
 		return;
 
 	mvOsOutput( "\n" );
@@ -342,7 +342,7 @@ MV_VOID mvSdmmcAddrDecShow(MV_VOID)
                     mvOsOutput( "...." );
 
                     mvSizePrint( win.addrWin.size );
-    
+
 		    mvOsOutput( "\n" );
                 }
 		else
@@ -362,7 +362,7 @@ MV_VOID mvSdmmcAddrDecShow(MV_VOID)
 *
 *
 * OUTPUT:
-*     
+*
 *
 * RETURN:
 *       MV_ERROR if register parameters are invalid.
@@ -384,7 +384,7 @@ MV_STATUS mvSdmmcWinInit(MV_VOID)
         regVal &= ~MV_SDMMC_WIN_ENABLE_MASK;
         MV_REG_WRITE(MV_SDMMC_WIN_CTRL_REG(0, winNum), regVal);
     }
-    
+
     winNum = 0;
     while( (sdmmcAddrDecPrioTab[winPrioIndex] != TBL_TERM) &&
            (winNum < MV_SDMMC_MAX_ADDR_DECODE_WIN) )
@@ -411,7 +411,7 @@ MV_STATUS mvSdmmcWinInit(MV_VOID)
             sdmmcWin.addrWin.size     = cpuAddrDecWin.addrWin.size;
             sdmmcWin.enable           = MV_TRUE;
             sdmmcWin.target           = sdmmcAddrDecPrioTab[winPrioIndex];
-            
+
             if(MV_OK != mvSdmmcWinSet(0/*dev*/, winNum, &sdmmcWin))
             {
                 return MV_ERROR;
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h
index 4c50a2b..f8357c1 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h
@@ -1,125 +1,125 @@
-
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-#ifndef __INCMVSysSdmmcAddrDech
-#define __INCMVSysSdmmcAddrDech
-
-#include "mvCommon.h"
-#include "ctrlEnv/mvCtrlEnvLib.h"
-#include "ctrlEnv/sys/mvCpuIf.h"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct _mvSdmmcDecWin
-{
-    MV_TARGET     target;
-    MV_ADDR_WIN   addrWin;    /* An address window*/
-    MV_BOOL       enable;     /* Address decode window is enabled/disabled    */
- 
-} MV_SDMMC_DEC_WIN;
-
-
-#define MV_SDMMC_MAX_ADDR_DECODE_WIN 4
-
-#define MV_SDMMC_WIN_CTRL_REG(dev, win)        (MV_SDIO_REG_BASE + 0x108 + ((win)<<3))
-#define MV_SDMMC_WIN_BASE_REG(dev, win)        (MV_SDIO_REG_BASE + 0x10c + ((win)<<3))
-
-
-/* BITs in Windows 0-3 Control and Base Registers */
-#define MV_SDMMC_WIN_ENABLE_BIT               0
-#define MV_SDMMC_WIN_ENABLE_MASK              (1<<MV_SDMMC_WIN_ENABLE_BIT)
-
-#define MV_SDMMC_WIN_TARGET_OFFSET            4
-#define MV_SDMMC_WIN_TARGET_MASK              (0xF<<MV_SDMMC_WIN_TARGET_OFFSET)
-
-#define MV_SDMMC_WIN_ATTR_OFFSET              8
-#define MV_SDMMC_WIN_ATTR_MASK                (0xFF<<MV_SDMMC_WIN_ATTR_OFFSET)
-
-#define MV_SDMMC_WIN_SIZE_OFFSET              16
-#define MV_SDMMC_WIN_SIZE_MASK                (0xFFFF<<MV_SDMMC_WIN_SIZE_OFFSET)
-
-#define MV_SDMMC_WIN_BASE_OFFSET              16
-#define MV_SDMMC_WIN_BASE_MASK                (0xFFFF<<MV_SDMMC_WIN_BASE_OFFSET)
-
-MV_STATUS mvSdmmcWinGet(int dev, MV_U32 winNum, MV_SDMMC_DEC_WIN *pAddrDecWin);
-MV_STATUS mvSdmmcWinSet(int dev, MV_U32 winNum, MV_SDMMC_DEC_WIN *pAddrDecWin);
-MV_STATUS mvSdmmcWinByTargetGet(MV_TARGET target, MV_SDMMC_DEC_WIN *pAddrDecWin);
-MV_STATUS mvSdmmcWinInit(MV_VOID);
-MV_VOID   mvSdmmcAddrDecShow(MV_VOID);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif
-
-
-
-
-
+
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCMVSysSdmmcAddrDech
+#define __INCMVSysSdmmcAddrDech
+
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _mvSdmmcDecWin
+{
+    MV_TARGET     target;
+    MV_ADDR_WIN   addrWin;    /* An address window*/
+    MV_BOOL       enable;     /* Address decode window is enabled/disabled    */
+
+} MV_SDMMC_DEC_WIN;
+
+
+#define MV_SDMMC_MAX_ADDR_DECODE_WIN 4
+
+#define MV_SDMMC_WIN_CTRL_REG(dev, win)        (MV_SDIO_REG_BASE + 0x108 + ((win)<<3))
+#define MV_SDMMC_WIN_BASE_REG(dev, win)        (MV_SDIO_REG_BASE + 0x10c + ((win)<<3))
+
+
+/* BITs in Windows 0-3 Control and Base Registers */
+#define MV_SDMMC_WIN_ENABLE_BIT               0
+#define MV_SDMMC_WIN_ENABLE_MASK              (1<<MV_SDMMC_WIN_ENABLE_BIT)
+
+#define MV_SDMMC_WIN_TARGET_OFFSET            4
+#define MV_SDMMC_WIN_TARGET_MASK              (0xF<<MV_SDMMC_WIN_TARGET_OFFSET)
+
+#define MV_SDMMC_WIN_ATTR_OFFSET              8
+#define MV_SDMMC_WIN_ATTR_MASK                (0xFF<<MV_SDMMC_WIN_ATTR_OFFSET)
+
+#define MV_SDMMC_WIN_SIZE_OFFSET              16
+#define MV_SDMMC_WIN_SIZE_MASK                (0xFFFF<<MV_SDMMC_WIN_SIZE_OFFSET)
+
+#define MV_SDMMC_WIN_BASE_OFFSET              16
+#define MV_SDMMC_WIN_BASE_MASK                (0xFFFF<<MV_SDMMC_WIN_BASE_OFFSET)
+
+MV_STATUS mvSdmmcWinGet(int dev, MV_U32 winNum, MV_SDMMC_DEC_WIN *pAddrDecWin);
+MV_STATUS mvSdmmcWinSet(int dev, MV_U32 winNum, MV_SDMMC_DEC_WIN *pAddrDecWin);
+MV_STATUS mvSdmmcWinByTargetGet(MV_TARGET target, MV_SDMMC_DEC_WIN *pAddrDecWin);
+MV_STATUS mvSdmmcWinInit(MV_VOID);
+MV_VOID   mvSdmmcAddrDecShow(MV_VOID);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
+
+
+
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c
index ecf6944..680f710 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c
@@ -1,462 +1,462 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#include "mvSysTdm.h"
-
-
-/* defines  */
-#ifdef MV_DEBUG
-	#define DB(x)	x
-#else
-	#define DB(x)
-#endif	
-
-static MV_TARGET tdmAddrDecPrioTap[] =
-{
-        PEX0_MEM,
-        SDRAM_CS0,
-        SDRAM_CS1,
-        SDRAM_CS2,
-        SDRAM_CS3,
-        DEVICE_CS0,
-        DEVICE_CS1,
-        DEVICE_CS2,
-        DEV_BOOCS,
-        PEX0_IO,
-        TBL_TERM
-};
-
-static MV_STATUS tdmWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin);
-
-/*******************************************************************************
-* mvTdmWinInit - Initialize TDM address decode windows 
-*
-* DESCRIPTION:
-*               This function initialize TDM window decode unit. It set the 
-*               default address decode
-*               windows of the unit.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_ERROR if setting fail.
-*******************************************************************************/
-
-MV_STATUS mvTdmWinInit(void)
-{
-	MV_U32 		winNum;
-	MV_U32		winPrioIndex = 0;
-	MV_CPU_DEC_WIN cpuAddrDecWin;
-	MV_TDM_DEC_WIN tdmWin;
-	MV_STATUS status;
-
-	/*Disable all windows*/	
-	for (winNum = 0; winNum < TDM_MBUS_MAX_WIN; winNum++)
-	{
-		mvTdmWinEnable(winNum, MV_FALSE);
-	}
-
-	for (winNum = 0; ((tdmAddrDecPrioTap[winPrioIndex] != TBL_TERM) && 
-					  (winNum < TDM_MBUS_MAX_WIN)); )
-	{	
-		status = mvCpuIfTargetWinGet(tdmAddrDecPrioTap[winPrioIndex], 
-									 &cpuAddrDecWin);
-        if (MV_NO_SUCH == status)
-        {
-            winPrioIndex++;
-            continue;
-        }
-		if (MV_OK != status)
-		{
-			mvOsPrintf("mvTdmInit: ERR. mvCpuIfTargetWinGet failed\n");
-			return MV_ERROR;
-		}
-
-        if (cpuAddrDecWin.enable == MV_TRUE)
-		{
-			tdmWin.addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh;
-			tdmWin.addrWin.baseLow = cpuAddrDecWin.addrWin.baseLow;
-			tdmWin.addrWin.size = cpuAddrDecWin.addrWin.size;
-			tdmWin.enable = MV_TRUE;
-		    tdmWin.target = tdmAddrDecPrioTap[winPrioIndex];
-		    if (MV_OK != mvTdmWinSet(winNum, &tdmWin))
-		    {
-			    return MV_ERROR;
-		    }
-		    winNum++;
-		}
-		winPrioIndex++;			
-    }
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvTdmWinSet - Set TDM target address window
-*
-* DESCRIPTION:
-*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0)
-*       address window, also known as address decode window.
-*       After setting this target window, the TDM will be able to access the
-*       target within the address window.
-*
-* INPUT:
-*       winNum      - TDM to target address decode window number.
-*       pAddrDecWin - TDM target window data structure.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_ERROR if address window overlapps with other address decode windows.
-*       MV_BAD_PARAM if base address is invalid parameter or target is
-*       unknown.
-*
-*******************************************************************************/
-
-MV_STATUS mvTdmWinSet(MV_U32 winNum, MV_TDM_DEC_WIN *pAddrDecWin)
-{
-	MV_TARGET_ATTRIB targetAttribs;
-	MV_DEC_REGS decRegs;
-	MV_U32 ctrlReg = 0;
-
-    /* Parameter checking   */
-    if (winNum >= TDM_MBUS_MAX_WIN)
-    {
-		mvOsPrintf("mvTdmWinSet: ERR. Invalid win num %d\n",winNum);
-        return MV_BAD_PARAM;
-    }
-    
-    /* Check if the requested window overlapps with current windows         */
-    if (MV_TRUE == tdmWinOverlapDetect(winNum, &pAddrDecWin->addrWin))
-   	{
-       	mvOsPrintf("mvTdmWinSet: ERR. Window %d overlap\n", winNum);
-		return MV_ERROR;
-	}
-
-	/* check if address is aligned to the size */
-	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size))
-	{
-		mvOsPrintf("mvTdmWinSet: Error setting TDM window %d to "\
-				   "target %s.\nAddress 0x%08x is unaligned to size 0x%x.\n",
-				   winNum,
-				   mvCtrlTargetNameGet(pAddrDecWin->target), 
-				   pAddrDecWin->addrWin.baseLow,
-				   pAddrDecWin->addrWin.size);
-		return MV_ERROR;
-	}
-
-	decRegs.baseReg = MV_REG_READ(TDM_WIN_BASE_REG(winNum));
-	decRegs.sizeReg = (MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_SIZE_MASK) >>  TDM_WIN_SIZE_OFFS;
-
-	if (MV_OK != mvCtrlAddrDecToReg(&(pAddrDecWin->addrWin),&decRegs))
-	{
-			mvOsPrintf("mvTdmWinSet: mvCtrlAddrDecToReg Failed\n");
-			return MV_ERROR;
-	}
-	
-	mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
-	
-	/* for the safe side we disable the window before writing the new
-	values */
-	mvTdmWinEnable(winNum, MV_FALSE);
-
-	ctrlReg |= (targetAttribs.attrib << TDM_WIN_ATTRIB_OFFS);
-	ctrlReg |= (targetAttribs.targetId << TDM_WIN_TARGET_OFFS);
-	ctrlReg |= (decRegs.sizeReg & TDM_WIN_SIZE_MASK);
-
-	/* Write to address base and control registers  */
-	MV_REG_WRITE(TDM_WIN_BASE_REG(winNum), decRegs.baseReg);
-	MV_REG_WRITE(TDM_WIN_CTRL_REG(winNum), ctrlReg);  
-	/* Enable address decode target window  */
-	if (pAddrDecWin->enable == MV_TRUE)
-	{
-		mvTdmWinEnable(winNum, MV_TRUE);
-	}    
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvTdmWinGet - Get peripheral target address window.
-*
-* DESCRIPTION:
-*               Get TDM peripheral target address window.
-*
-* INPUT:
-*       winNum - TDM to target address decode window number.
-*
-* OUTPUT:
-*       pAddrDecWin - TDM target window data structure.
-*
-* RETURN:
-*       MV_ERROR if register parameters are invalid.
-*
-*******************************************************************************/
-
-MV_STATUS mvTdmWinGet(MV_U32 winNum, MV_TDM_DEC_WIN *pAddrDecWin)
-{
-
-	MV_DEC_REGS decRegs;
-	MV_TARGET_ATTRIB targetAttrib;
-
-	/* Parameter checking   */
-	if (winNum >= TDM_MBUS_MAX_WIN)
-	{
-		mvOsPrintf("mvTdmWinGet: ERR. Invalid winNum %d\n", winNum);
-		return MV_NOT_SUPPORTED;
-	}
-	
-	decRegs.baseReg =  MV_REG_READ(TDM_WIN_BASE_REG(winNum));                                                                           
-	decRegs.sizeReg = (MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_SIZE_MASK) >>  TDM_WIN_SIZE_OFFS;
- 
-	if (MV_OK != mvCtrlRegToAddrDec(&decRegs,&(pAddrDecWin->addrWin)))
-	{
-		mvOsPrintf("mvTdmWinGet: mvCtrlRegToAddrDec Failed \n");
-		return MV_ERROR;
-	}
-	 
-	/* attrib and targetId */
-	targetAttrib.attrib = 
-		(MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_ATTRIB_MASK) >>  TDM_WIN_ATTRIB_OFFS;
-	targetAttrib.targetId = 
-		(MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_TARGET_MASK) >>  TDM_WIN_TARGET_OFFS;
-	 
-	pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
-
-	/* Check if window is enabled   */
-	if (MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_ENABLE_MASK)
-	{
-		pAddrDecWin->enable = MV_TRUE;
-	}
-	else
-	{
-		pAddrDecWin->enable = MV_FALSE;
-	}
-	
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvTdmWinEnable - Enable/disable a TDM to target address window
-*
-* DESCRIPTION:
-*       This function enable/disable a TDM to target address window.
-*       According to parameter 'enable' the routine will enable the
-*       window, thus enabling TDM accesses (before enabling the window it is
-*       tested for overlapping). Otherwise, the window will be disabled.
-*
-* INPUT:
-*       winNum - TDM to target address decode window number.
-*       enable - Enable/disable parameter.
-*
-* OUTPUT:
-*       N/A
-*
-* RETURN:
-*       MV_ERROR if decode window number was wrong or enabled window overlapps.
-*
-*******************************************************************************/
-MV_STATUS mvTdmWinEnable(int winNum, MV_BOOL enable)
-{
-	MV_TDM_DEC_WIN addrDecWin;
-
-	if (MV_TRUE == enable)
-	{
-		if (winNum >= TDM_MBUS_MAX_WIN)
-		{
-			mvOsPrintf("mvTdmWinEnable:ERR. Invalid winNum%d\n",winNum);
-			return MV_ERROR;
-		}	
-		
-		/* First check for overlap with other enabled windows				*/
-		/* Get current window */
-		if (MV_OK != mvTdmWinGet(winNum, &addrDecWin))
-		{
-			mvOsPrintf("mvTdmWinEnable:ERR. targetWinGet fail\n");
-			return MV_ERROR;
-		}
-		/* Check for overlapping */
-		if (MV_FALSE == tdmWinOverlapDetect(winNum, &(addrDecWin.addrWin)))
-		{
-			/* No Overlap. Enable address decode target window */
-			MV_REG_BIT_SET(TDM_WIN_CTRL_REG(winNum), TDM_WIN_ENABLE_MASK);
-		}
-		else
-		{   /* Overlap detected	*/
-			mvOsPrintf("mvTdmWinEnable:ERR. Overlap detected\n");
-			return MV_ERROR;
-		}
-	}
-	else
-	{
-		MV_REG_BIT_RESET(TDM_WIN_CTRL_REG(winNum), TDM_WIN_ENABLE_MASK);	
-	}
-	return MV_OK;
-}
-
-
-/*******************************************************************************
-* tdmWinOverlapDetect - Detect TDM address windows overlapping
-*
-* DESCRIPTION:
-*       An unpredicted behaviour is expected in case TDM address decode 
-*       windows overlapps.
-*       This function detects TDM address decode windows overlapping of a 
-*       specified window. The function does not check the window itself for 
-*       overlapping. The function also skipps disabled address decode windows.
-*
-* INPUT:
-*       winNum      - address decode window number.
-*       pAddrDecWin - An address decode window struct.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_TRUE if the given address window overlap current address
-*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data 
-*       from registers.
-*
-*******************************************************************************/
-static MV_STATUS tdmWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
-{
-    MV_U32      	winNumIndex;
-    MV_TDM_DEC_WIN  	addrDecWin;
-
-    for (winNumIndex = 0; winNumIndex < TDM_MBUS_MAX_WIN; winNumIndex++)
-    {
-		/* Do not check window itself		*/
-        if (winNumIndex == winNum)
-		{
-			continue;
-		}
-		/* Do not check disabled windows	*/
-		if (MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_ENABLE_MASK)
-		{
-			/* Get window parameters 	*/
-			if (MV_OK != mvTdmWinGet(winNumIndex, &addrDecWin))
-			{
-				DB(mvOsPrintf("dmaWinOverlapDetect: ERR. TargetWinGet failed\n"));
-            		return MV_ERROR;
-			}
-
-			if (MV_TRUE == ctrlWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
-			{
-				return MV_TRUE;
-			}        
-		}
-    }
-	return MV_FALSE;
-}
-
-/*******************************************************************************
-* mvTdmAddrDecShow - Print the TDM address decode map.
-*
-* DESCRIPTION:
-*       This function print the TDM address decode map.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-MV_VOID mvTdmAddrDecShow(MV_VOID)
-{
-	MV_TDM_DEC_WIN win;
-	int i;
-
-	mvOsOutput( "\n" );
-	mvOsOutput( "TDM:\n" );
-	mvOsOutput( "----\n" );
-
-	for( i = 0; i < TDM_MBUS_MAX_WIN; i++ )
-	{
-		memset( &win, 0, sizeof(MV_TDM_DEC_WIN) );
-
-		mvOsOutput( "win%d - ", i );
-
-		if (mvTdmWinGet(i, &win ) == MV_OK )
-		{
-			if( win.enable )
-			{
-                mvOsOutput( "%s base %08x, ",
-                mvCtrlTargetNameGet(win.target), win.addrWin.baseLow);
-                mvOsOutput( "...." );
-                mvSizePrint( win.addrWin.size );
-				mvOsOutput( "\n" );
-			}
-			else
-				mvOsOutput( "disable\n" );
-		}
-	}
-}
-
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvSysTdm.h"
+
+
+/* defines  */
+#ifdef MV_DEBUG
+	#define DB(x)	x
+#else
+	#define DB(x)
+#endif
+
+static MV_TARGET tdmAddrDecPrioTap[] =
+{
+        PEX0_MEM,
+        SDRAM_CS0,
+        SDRAM_CS1,
+        SDRAM_CS2,
+        SDRAM_CS3,
+        DEVICE_CS0,
+        DEVICE_CS1,
+        DEVICE_CS2,
+        DEV_BOOCS,
+        PEX0_IO,
+        TBL_TERM
+};
+
+static MV_STATUS tdmWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin);
+
+/*******************************************************************************
+* mvTdmWinInit - Initialize TDM address decode windows
+*
+* DESCRIPTION:
+*               This function initialize TDM window decode unit. It set the
+*               default address decode
+*               windows of the unit.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if setting fail.
+*******************************************************************************/
+
+MV_STATUS mvTdmWinInit(void)
+{
+	MV_U32 		winNum;
+	MV_U32		winPrioIndex = 0;
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_TDM_DEC_WIN tdmWin;
+	MV_STATUS status;
+
+	/*Disable all windows*/
+	for (winNum = 0; winNum < TDM_MBUS_MAX_WIN; winNum++)
+	{
+		mvTdmWinEnable(winNum, MV_FALSE);
+	}
+
+	for (winNum = 0; ((tdmAddrDecPrioTap[winPrioIndex] != TBL_TERM) &&
+					  (winNum < TDM_MBUS_MAX_WIN)); )
+	{
+		status = mvCpuIfTargetWinGet(tdmAddrDecPrioTap[winPrioIndex],
+									 &cpuAddrDecWin);
+        if (MV_NO_SUCH == status)
+        {
+            winPrioIndex++;
+            continue;
+        }
+		if (MV_OK != status)
+		{
+			mvOsPrintf("mvTdmInit: ERR. mvCpuIfTargetWinGet failed\n");
+			return MV_ERROR;
+		}
+
+        if (cpuAddrDecWin.enable == MV_TRUE)
+		{
+			tdmWin.addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh;
+			tdmWin.addrWin.baseLow = cpuAddrDecWin.addrWin.baseLow;
+			tdmWin.addrWin.size = cpuAddrDecWin.addrWin.size;
+			tdmWin.enable = MV_TRUE;
+		    tdmWin.target = tdmAddrDecPrioTap[winPrioIndex];
+		    if (MV_OK != mvTdmWinSet(winNum, &tdmWin))
+		    {
+			    return MV_ERROR;
+		    }
+		    winNum++;
+		}
+		winPrioIndex++;
+    }
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvTdmWinSet - Set TDM target address window
+*
+* DESCRIPTION:
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0)
+*       address window, also known as address decode window.
+*       After setting this target window, the TDM will be able to access the
+*       target within the address window.
+*
+* INPUT:
+*       winNum      - TDM to target address decode window number.
+*       pAddrDecWin - TDM target window data structure.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if address window overlapps with other address decode windows.
+*       MV_BAD_PARAM if base address is invalid parameter or target is
+*       unknown.
+*
+*******************************************************************************/
+
+MV_STATUS mvTdmWinSet(MV_U32 winNum, MV_TDM_DEC_WIN *pAddrDecWin)
+{
+	MV_TARGET_ATTRIB targetAttribs;
+	MV_DEC_REGS decRegs;
+	MV_U32 ctrlReg = 0;
+
+    /* Parameter checking   */
+    if (winNum >= TDM_MBUS_MAX_WIN)
+    {
+		mvOsPrintf("mvTdmWinSet: ERR. Invalid win num %d\n",winNum);
+        return MV_BAD_PARAM;
+    }
+
+    /* Check if the requested window overlapps with current windows         */
+    if (MV_TRUE == tdmWinOverlapDetect(winNum, &pAddrDecWin->addrWin))
+   	{
+       	mvOsPrintf("mvTdmWinSet: ERR. Window %d overlap\n", winNum);
+		return MV_ERROR;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size))
+	{
+		mvOsPrintf("mvTdmWinSet: Error setting TDM window %d to "\
+				   "target %s.\nAddress 0x%08x is unaligned to size 0x%x.\n",
+				   winNum,
+				   mvCtrlTargetNameGet(pAddrDecWin->target),
+				   pAddrDecWin->addrWin.baseLow,
+				   pAddrDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	decRegs.baseReg = MV_REG_READ(TDM_WIN_BASE_REG(winNum));
+	decRegs.sizeReg = (MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_SIZE_MASK) >>  TDM_WIN_SIZE_OFFS;
+
+	if (MV_OK != mvCtrlAddrDecToReg(&(pAddrDecWin->addrWin),&decRegs))
+	{
+			mvOsPrintf("mvTdmWinSet: mvCtrlAddrDecToReg Failed\n");
+			return MV_ERROR;
+	}
+
+	mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
+
+	/* for the safe side we disable the window before writing the new
+	values */
+	mvTdmWinEnable(winNum, MV_FALSE);
+
+	ctrlReg |= (targetAttribs.attrib << TDM_WIN_ATTRIB_OFFS);
+	ctrlReg |= (targetAttribs.targetId << TDM_WIN_TARGET_OFFS);
+	ctrlReg |= (decRegs.sizeReg & TDM_WIN_SIZE_MASK);
+
+	/* Write to address base and control registers  */
+	MV_REG_WRITE(TDM_WIN_BASE_REG(winNum), decRegs.baseReg);
+	MV_REG_WRITE(TDM_WIN_CTRL_REG(winNum), ctrlReg);
+	/* Enable address decode target window  */
+	if (pAddrDecWin->enable == MV_TRUE)
+	{
+		mvTdmWinEnable(winNum, MV_TRUE);
+	}
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvTdmWinGet - Get peripheral target address window.
+*
+* DESCRIPTION:
+*               Get TDM peripheral target address window.
+*
+* INPUT:
+*       winNum - TDM to target address decode window number.
+*
+* OUTPUT:
+*       pAddrDecWin - TDM target window data structure.
+*
+* RETURN:
+*       MV_ERROR if register parameters are invalid.
+*
+*******************************************************************************/
+
+MV_STATUS mvTdmWinGet(MV_U32 winNum, MV_TDM_DEC_WIN *pAddrDecWin)
+{
+
+	MV_DEC_REGS decRegs;
+	MV_TARGET_ATTRIB targetAttrib;
+
+	/* Parameter checking   */
+	if (winNum >= TDM_MBUS_MAX_WIN)
+	{
+		mvOsPrintf("mvTdmWinGet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	decRegs.baseReg =  MV_REG_READ(TDM_WIN_BASE_REG(winNum));
+	decRegs.sizeReg = (MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_SIZE_MASK) >>  TDM_WIN_SIZE_OFFS;
+
+	if (MV_OK != mvCtrlRegToAddrDec(&decRegs,&(pAddrDecWin->addrWin)))
+	{
+		mvOsPrintf("mvTdmWinGet: mvCtrlRegToAddrDec Failed \n");
+		return MV_ERROR;
+	}
+
+	/* attrib and targetId */
+	targetAttrib.attrib =
+		(MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_ATTRIB_MASK) >>  TDM_WIN_ATTRIB_OFFS;
+	targetAttrib.targetId =
+		(MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_TARGET_MASK) >>  TDM_WIN_TARGET_OFFS;
+
+	pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
+
+	/* Check if window is enabled   */
+	if (MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_ENABLE_MASK)
+	{
+		pAddrDecWin->enable = MV_TRUE;
+	}
+	else
+	{
+		pAddrDecWin->enable = MV_FALSE;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvTdmWinEnable - Enable/disable a TDM to target address window
+*
+* DESCRIPTION:
+*       This function enable/disable a TDM to target address window.
+*       According to parameter 'enable' the routine will enable the
+*       window, thus enabling TDM accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       winNum - TDM to target address decode window number.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if decode window number was wrong or enabled window overlapps.
+*
+*******************************************************************************/
+MV_STATUS mvTdmWinEnable(int winNum, MV_BOOL enable)
+{
+	MV_TDM_DEC_WIN addrDecWin;
+
+	if (MV_TRUE == enable)
+	{
+		if (winNum >= TDM_MBUS_MAX_WIN)
+		{
+			mvOsPrintf("mvTdmWinEnable:ERR. Invalid winNum%d\n",winNum);
+			return MV_ERROR;
+		}
+
+		/* First check for overlap with other enabled windows				*/
+		/* Get current window */
+		if (MV_OK != mvTdmWinGet(winNum, &addrDecWin))
+		{
+			mvOsPrintf("mvTdmWinEnable:ERR. targetWinGet fail\n");
+			return MV_ERROR;
+		}
+		/* Check for overlapping */
+		if (MV_FALSE == tdmWinOverlapDetect(winNum, &(addrDecWin.addrWin)))
+		{
+			/* No Overlap. Enable address decode target window */
+			MV_REG_BIT_SET(TDM_WIN_CTRL_REG(winNum), TDM_WIN_ENABLE_MASK);
+		}
+		else
+		{   /* Overlap detected	*/
+			mvOsPrintf("mvTdmWinEnable:ERR. Overlap detected\n");
+			return MV_ERROR;
+		}
+	}
+	else
+	{
+		MV_REG_BIT_RESET(TDM_WIN_CTRL_REG(winNum), TDM_WIN_ENABLE_MASK);
+	}
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* tdmWinOverlapDetect - Detect TDM address windows overlapping
+*
+* DESCRIPTION:
+*       An unpredicted behaviour is expected in case TDM address decode
+*       windows overlapps.
+*       This function detects TDM address decode windows overlapping of a
+*       specified window. The function does not check the window itself for
+*       overlapping. The function also skipps disabled address decode windows.
+*
+* INPUT:
+*       winNum      - address decode window number.
+*       pAddrDecWin - An address decode window struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlap current address
+*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data
+*       from registers.
+*
+*******************************************************************************/
+static MV_STATUS tdmWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
+{
+    MV_U32      	winNumIndex;
+    MV_TDM_DEC_WIN  	addrDecWin;
+
+    for (winNumIndex = 0; winNumIndex < TDM_MBUS_MAX_WIN; winNumIndex++)
+    {
+		/* Do not check window itself		*/
+        if (winNumIndex == winNum)
+		{
+			continue;
+		}
+		/* Do not check disabled windows	*/
+		if (MV_REG_READ(TDM_WIN_CTRL_REG(winNum)) & TDM_WIN_ENABLE_MASK)
+		{
+			/* Get window parameters 	*/
+			if (MV_OK != mvTdmWinGet(winNumIndex, &addrDecWin))
+			{
+				DB(mvOsPrintf("dmaWinOverlapDetect: ERR. TargetWinGet failed\n"));
+            		return MV_ERROR;
+			}
+
+			if (MV_TRUE == ctrlWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
+			{
+				return MV_TRUE;
+			}
+		}
+    }
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvTdmAddrDecShow - Print the TDM address decode map.
+*
+* DESCRIPTION:
+*       This function print the TDM address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvTdmAddrDecShow(MV_VOID)
+{
+	MV_TDM_DEC_WIN win;
+	int i;
+
+	mvOsOutput( "\n" );
+	mvOsOutput( "TDM:\n" );
+	mvOsOutput( "----\n" );
+
+	for( i = 0; i < TDM_MBUS_MAX_WIN; i++ )
+	{
+		memset( &win, 0, sizeof(MV_TDM_DEC_WIN) );
+
+		mvOsOutput( "win%d - ", i );
+
+		if (mvTdmWinGet(i, &win ) == MV_OK )
+		{
+			if( win.enable )
+			{
+                mvOsOutput( "%s base %08x, ",
+                mvCtrlTargetNameGet(win.target), win.addrWin.baseLow);
+                mvOsOutput( "...." );
+                mvSizePrint( win.addrWin.size );
+				mvOsOutput( "\n" );
+			}
+			else
+				mvOsOutput( "disable\n" );
+		}
+	}
+}
+
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h
index 0d3140f..3603095 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -73,7 +73,7 @@ typedef struct _mvTdmDecWin
 {
         MV_TARGET     target;
         MV_ADDR_WIN   addrWin; /* An address window*/
-        MV_BOOL       enable;  /* Address decode window is enabled/disabled */ 
+        MV_BOOL       enable;  /* Address decode window is enabled/disabled */
 } MV_TDM_DEC_WIN;
 
 MV_STATUS mvTdmWinInit(MV_VOID);
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.c
index 4415c7c..1e58a60 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.c
@@ -71,7 +71,7 @@ typedef struct _mvTsuDecWin
         MV_TARGET     target;
         MV_ADDR_WIN   addrWin; /* An address window*/
         MV_BOOL       enable;  /* Address decode window is enabled/disabled */
- 
+
 }MV_TSU_DEC_WIN;
 
 
@@ -207,7 +207,7 @@ MV_STATUS mvTsuWinInit(void)
 *       None.
 *
 * RETURN:
-*       MV_ERROR	- if address window overlapps with other address decode 
+*       MV_ERROR	- if address window overlapps with other address decode
 *			windows.
 *       MV_BAD_PARAM	- if base address is invalid parameter or target is
 *       		unknown.
@@ -223,7 +223,7 @@ MV_STATUS mvTsuWinSet(MV_U32 winNum, MV_TSU_DEC_WIN *pAddrDecWin)
 	{
 		mvOsPrintf("mvTsuWinSet: ERR. Invalid win num %d\n",winNum);
 		return MV_BAD_PARAM;
-	}    
+	}
 
 	/* Check if the requested window overlapps with current windows     */
 	if(MV_TRUE == tsuWinOverlapDetect(winNum, &pAddrDecWin->addrWin))
@@ -245,15 +245,15 @@ MV_STATUS mvTsuWinSet(MV_U32 winNum, MV_TSU_DEC_WIN *pAddrDecWin)
 
 	decRegs.baseReg = MV_REG_READ(MV_TSU_WIN_BASE_REG(winNum));
 	decRegs.sizeReg = MV_REG_READ(MV_TSU_WIN_CTRL_REG(winNum));
-    
+
 	if(MV_OK != mvCtrlAddrDecToReg(&(pAddrDecWin->addrWin),&decRegs))
 	{
 		mvOsPrintf("mvTsuWinSet: mvCtrlAddrDecToReg Failed\n");
 		return MV_ERROR;
 	}
-    
+
 	mvCtrlAttribGet(pAddrDecWin->target,&targetAttribs);
-    
+
 	/* set attributes */
 	decRegs.sizeReg &= ~TSU_WIN_CTRL_ATTR_MASK;
 	decRegs.sizeReg |= targetAttribs.attrib << TSU_WIN_CTRL_ATTR_OFFS;
@@ -307,9 +307,9 @@ MV_STATUS mvTsuWinGet(MV_U32 winNum, MV_TSU_DEC_WIN *pAddrDecWin)
 		return MV_NOT_SUPPORTED;
 	}
 
-	decRegs.baseReg = MV_REG_READ(MV_TSU_WIN_BASE_REG(winNum));                                                                           
+	decRegs.baseReg = MV_REG_READ(MV_TSU_WIN_BASE_REG(winNum));
 	decRegs.sizeReg = MV_REG_READ(MV_TSU_WIN_CTRL_REG(winNum));
- 
+
 	if(MV_OK != mvCtrlRegToAddrDec(&decRegs,&(pAddrDecWin->addrWin)))
 	{
 		mvOsPrintf("mvTsuWinGet: mvCtrlRegToAddrDec Failed \n");
@@ -317,9 +317,9 @@ MV_STATUS mvTsuWinGet(MV_U32 winNum, MV_TSU_DEC_WIN *pAddrDecWin)
 	}
 
 	/* attrib and targetId */
-	targetAttrib.attrib = 
+	targetAttrib.attrib =
 		(decRegs.sizeReg & TSU_WIN_CTRL_ATTR_MASK) >> TSU_WIN_CTRL_ATTR_OFFS;
-	targetAttrib.targetId = 
+	targetAttrib.targetId =
 		(decRegs.sizeReg & TSU_WIN_CTRL_TARGET_MASK) >> TSU_WIN_CTRL_TARGET_OFFS;
 
 	pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
@@ -333,7 +333,7 @@ MV_STATUS mvTsuWinGet(MV_U32 winNum, MV_TSU_DEC_WIN *pAddrDecWin)
 	{
 		pAddrDecWin->enable = MV_FALSE;
 	}
-	
+
 	return MV_OK;
 }
 
@@ -529,7 +529,7 @@ void mvTsuAddrDecShow(void)
 	MV_TSU_DEC_WIN  win;
 	int             i;
 
-	if (MV_FALSE == mvCtrlPwrClckGet(TS_UNIT_ID, 0)) 
+	if (MV_FALSE == mvCtrlPwrClckGet(TS_UNIT_ID, 0))
 		return;
 
 	mvOsOutput( "\n" );
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.h
index 4282589..1478b09 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer. 
+        this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysUsb.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysUsb.h
index 07f98de..b712900 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysUsb.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysUsb.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer. 
+        this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -82,7 +82,7 @@ extern "C" {
 /*******************************************/
 #define MV_USB_BRIDGE_CTRL_REG(dev)              (USB_REG_BASE(dev) + 0x300)
 
-#define MV_USB_WIN_CTRL_REG(dev, win)        (USB_REG_BASE(dev) + 0x320 + ((win)<<4)) 
+#define MV_USB_WIN_CTRL_REG(dev, win)        (USB_REG_BASE(dev) + 0x320 + ((win)<<4))
 #define MV_USB_WIN_BASE_REG(dev, win)        (USB_REG_BASE(dev) + 0x324 + ((win)<<4))
 
 /* BITs in Windows 0-3 Control and Base Registers */
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.c
index f9d0ab3..9f0a52a 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -70,12 +70,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 	#define DB(x)	x
 #else
 	#define DB(x)
-#endif	
+#endif
 
 
 static MV_STATUS xorWinOverlapDetect(MV_U32 unit,MV_U32 winNum, MV_ADDR_WIN *pAddrWin);
 
-MV_TARGET xorAddrDecPrioTap[] = 
+MV_TARGET xorAddrDecPrioTap[] =
 {
 #if defined(MV_INCLUDE_DEVICE_CS0)
     DEVICE_CS0,
@@ -100,7 +100,7 @@ MV_TARGET xorAddrDecPrioTap[] =
 #endif
 #if defined(MV_INCLUDE_CESA)
    CRYPT_ENG,
-#endif 
+#endif
 	TBL_TERM
 };
 static MV_STATUS mvXorInitWinsUnit (MV_U32 unit)
@@ -118,13 +118,13 @@ static MV_STATUS mvXorInitWinsUnit (MV_U32 unit)
 	{
 	    mvXorTargetWinEnable(unit,winNum, MV_FALSE);
 	}
-	
+
 	/* Go through all windows in user table until table terminator			*/
 	for (winNum = 0; ((xorAddrDecPrioTap[winPrioIndex] != TBL_TERM) &&
 					(winNum < XOR_MAX_ADDR_DEC_WIN));)
 	{
 		/* first get attributes from CPU If */
-		status = mvCpuIfTargetWinGet(xorAddrDecPrioTap[winPrioIndex], 
+		status = mvCpuIfTargetWinGet(xorAddrDecPrioTap[winPrioIndex],
 									 &cpuAddrDecWin);
 
         if(MV_NO_SUCH == status)
@@ -138,16 +138,16 @@ static MV_STATUS mvXorInitWinsUnit (MV_U32 unit)
 			return MV_ERROR;
 		}
 
-	
+
         if (cpuAddrDecWin.enable == MV_TRUE)
 		{
 
 			addrDecWin.target           = xorAddrDecPrioTap[winPrioIndex];
-			addrDecWin.addrWin.baseLow  = cpuAddrDecWin.addrWin.baseLow; 
-			addrDecWin.addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh; 
-			addrDecWin.addrWin.size     = cpuAddrDecWin.addrWin.size;    
+			addrDecWin.addrWin.baseLow  = cpuAddrDecWin.addrWin.baseLow;
+			addrDecWin.addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh;
+			addrDecWin.addrWin.size     = cpuAddrDecWin.addrWin.size;
 			addrDecWin.enable           = MV_TRUE;
-	
+
 			if (MV_OK != mvXorTargetWinSet(unit,winNum, &addrDecWin))
 			{
 				DB(mvOsPrintf("mvXorInit: ERR. mvDmaTargetWinSet failed\n"));
@@ -155,10 +155,10 @@ static MV_STATUS mvXorInitWinsUnit (MV_U32 unit)
 			}
 			winNum++;
 		}
-		winPrioIndex++;	
-        
+		winPrioIndex++;
+
 	}
-    
+
 	return MV_OK;
 }
 
@@ -189,8 +189,8 @@ MV_STATUS mvXorInit (MV_VOID)
 	for(i = 0; i < MV_XOR_MAX_UNIT; i++)
 	    mvXorInitWinsUnit(i);
 
-	mvXorHalInit(MV_XOR_MAX_CHAN);	
-    
+	mvXorHalInit(MV_XOR_MAX_CHAN);
+
 	return MV_OK;
 }
 
@@ -198,9 +198,9 @@ MV_STATUS mvXorInit (MV_VOID)
 * mvXorTargetWinSet - Set XOR target address window
 *
 * DESCRIPTION:
-*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0) 
-*       address window. After setting this target window, the XOR will be 
-*       able to access the target within the address window. 
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0)
+*       address window. After setting this target window, the XOR will be
+*       able to access the target within the address window.
 *
 * INPUT:
 *	    winNum - One of the possible XOR memory decode windows.
@@ -221,7 +221,7 @@ MV_STATUS mvXorTargetWinSet(MV_U32 unit, MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDec
     MV_DEC_REGS xorDecRegs;
 	MV_TARGET_ATTRIB targetAttribs;
     MV_U32      chan;
-    
+
     /* Parameter checking */
     if (winNum >= XOR_MAX_ADDR_DEC_WIN)
     {
@@ -232,13 +232,13 @@ MV_STATUS mvXorTargetWinSet(MV_U32 unit, MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDec
     {
         DB(mvOsPrintf("%s: ERR. pAddrDecWin is NULL pointer\n", __FUNCTION__ ));
         return MV_BAD_PTR;
-    }                                         
+    }
     /* Check if the requested window overlaps with current windows */
     if (MV_TRUE == xorWinOverlapDetect(unit, winNum, &pAddrDecWin->addrWin))
     {
 	DB(mvOsPrintf("%s: ERR. Window %d overlap\n",__FUNCTION__,winNum));
 	return MV_ERROR;
-    }                              
+    }
 
     xorDecRegs.baseReg = MV_REG_READ(XOR_BASE_ADDR_REG(unit,winNum));
     xorDecRegs.sizeReg = MV_REG_READ(XOR_SIZE_MASK_REG(unit,winNum));
@@ -249,7 +249,7 @@ MV_STATUS mvXorTargetWinSet(MV_U32 unit, MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDec
 		DB(mvOsPrintf("%s: ERR. Invalid addr dec window\n",__FUNCTION__));
         return MV_BAD_PARAM;
 	}
-    
+
 
 	mvCtrlAttribGet(pAddrDecWin->target,&targetAttribs);
 
@@ -263,10 +263,10 @@ MV_STATUS mvXorTargetWinSet(MV_U32 unit, MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDec
 
     /* Write to address decode Base Address Register */
 	MV_REG_WRITE(XOR_BASE_ADDR_REG(unit,winNum), xorDecRegs.baseReg);
-    
+
     /* Write to Size Register */
 	MV_REG_WRITE(XOR_SIZE_MASK_REG(unit,winNum), xorDecRegs.sizeReg);
-    
+
     for (chan = 0; chan < MV_XOR_MAX_CHAN_PER_UNIT; chan++)
     {
         if (pAddrDecWin->enable)
@@ -306,7 +306,7 @@ MV_STATUS mvXorTargetWinGet(MV_U32 unit,MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDecW
     MV_DEC_REGS xorDecRegs;
 	MV_TARGET_ATTRIB targetAttrib;
     MV_U32      chan=0,chanWinEn;
-    
+
     /* Parameter checking */
     if (winNum >= XOR_MAX_ADDR_DEC_WIN)
     {
@@ -321,11 +321,11 @@ MV_STATUS mvXorTargetWinGet(MV_U32 unit,MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDecW
     }
 
     chanWinEn = MV_REG_READ(XOR_WINDOW_CTRL_REG(unit,0)) & XEXWCR_WIN_EN_MASK(winNum);
-    
+
     for (chan = 0; chan < MV_XOR_MAX_CHAN_PER_UNIT; chan++) /* we should scan here all channels per unit */
     {
     	/* Check if enable bit is equal for all channels */
-        if ((MV_REG_READ(XOR_WINDOW_CTRL_REG(unit,chan)) & 
+        if ((MV_REG_READ(XOR_WINDOW_CTRL_REG(unit,chan)) &
              XEXWCR_WIN_EN_MASK(winNum)) != chanWinEn)
         {
             mvOsPrintf("%s: ERR. Window enable field must be equal in "
@@ -346,9 +346,9 @@ MV_STATUS mvXorTargetWinGet(MV_U32 unit,MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDecW
 	}
 
 	/* attrib and targetId */
-	targetAttrib.attrib = 
+	targetAttrib.attrib =
 		(xorDecRegs.baseReg & XEBARX_ATTR_MASK) >> XEBARX_ATTR_OFFS;
-	targetAttrib.targetId = 
+	targetAttrib.targetId =
 		(xorDecRegs.baseReg & XEBARX_TARGET_MASK) >> XEBARX_TARGET_OFFS;
 
 
@@ -359,7 +359,7 @@ MV_STATUS mvXorTargetWinGet(MV_U32 unit,MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDecW
 		pAddrDecWin->enable = MV_TRUE;
 	}
 	else pAddrDecWin->enable = MV_FALSE;
-	
+
     return MV_OK;
 }
 
@@ -368,8 +368,8 @@ MV_STATUS mvXorTargetWinGet(MV_U32 unit,MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDecW
 *
 * DESCRIPTION:
 *       This function enable/disable a XOR address decode window.
-*       if parameter 'enable' == MV_TRUE the routine will enable the 
-*       window, thus enabling XOR accesses (before enabling the window it is 
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling XOR accesses (before enabling the window it is
 *       tested for overlapping). Otherwise, the window will be disabled.
 *
 * INPUT:
@@ -387,15 +387,15 @@ MV_STATUS mvXorTargetWinEnable(MV_U32 unit,MV_U32 winNum, MV_BOOL enable)
 {
 	MV_XOR_DEC_WIN  addrDecWin;
     MV_U32          chan;
-    
-	/* Parameter checking   */               
+
+	/* Parameter checking   */
     if (winNum >= XOR_MAX_ADDR_DEC_WIN)
     {
         DB(mvOsPrintf("%s: ERR. Invalid winNum%d\n", __FUNCTION__, winNum));
         return MV_ERROR;
     }
 
-	if (enable == MV_TRUE) 
+	if (enable == MV_TRUE)
 	{
 		/* Get current window */
 	    if (MV_OK != mvXorTargetWinGet(unit,winNum, &addrDecWin))
@@ -432,7 +432,7 @@ MV_STATUS mvXorTargetWinEnable(MV_U32 unit,MV_U32 winNum, MV_BOOL enable)
 
 	}
 
-	return MV_OK;                  
+	return MV_OK;
 }
 
 /*******************************************************************************
@@ -441,7 +441,7 @@ MV_STATUS mvXorTargetWinEnable(MV_U32 unit,MV_U32 winNum, MV_BOOL enable)
 *
 * DESCRIPTION:
 *       Each engine can be configured with access attributes for each of the
-*       memory spaces. This function sets access attributes 
+*       memory spaces. This function sets access attributes
 *       to a given window for the given engine
 *
 * INPUTS:
@@ -457,11 +457,11 @@ MV_STATUS mvXorTargetWinEnable(MV_U32 unit,MV_U32 winNum, MV_BOOL enable)
 *       MV_BAD_PARAM if parameters to function invalid, MV_OK otherwise.
 *
 *******************************************************************************/
-MV_STATUS mvXorProtWinSet (MV_U32 unit,MV_U32 chan, MV_U32 winNum, MV_BOOL access, 
+MV_STATUS mvXorProtWinSet (MV_U32 unit,MV_U32 chan, MV_U32 winNum, MV_BOOL access,
                            MV_BOOL write)
 {
     MV_U32 temp;
-    
+
     /* Parameter checking   */
     if (chan >= MV_XOR_MAX_CHAN_PER_UNIT)
     {
@@ -474,7 +474,7 @@ MV_STATUS mvXorProtWinSet (MV_U32 unit,MV_U32 chan, MV_U32 winNum, MV_BOOL acces
         return MV_BAD_PARAM;
     }
 
-    temp = MV_REG_READ(XOR_WINDOW_CTRL_REG(unit,chan)) & 
+    temp = MV_REG_READ(XOR_WINDOW_CTRL_REG(unit,chan)) &
         (~XEXWCR_WIN_ACC_MASK(winNum));
 
     /* if access is disable */
@@ -529,7 +529,7 @@ MV_STATUS mvXorPciRemap(MV_U32 unit,MV_U32 winNum, MV_U32 addrHigh)
     }
 
     MV_REG_WRITE(XOR_HIGH_ADDR_REMAP_REG(unit,winNum), addrHigh);
-    
+
 	return MV_OK;
 }
 
@@ -537,10 +537,10 @@ MV_STATUS mvXorPciRemap(MV_U32 unit,MV_U32 winNum, MV_U32 addrHigh)
 * xorWinOverlapDetect - Detect XOR address windows overlaping
 *
 * DESCRIPTION:
-*       An unpredicted behaviour is expected in case XOR address decode 
+*       An unpredicted behaviour is expected in case XOR address decode
 *       windows overlaps.
-*       This function detects XOR address decode windows overlaping of a 
-*       specified window. The function does not check the window itself for 
+*       This function detects XOR address decode windows overlaping of a
+*       specified window. The function does not check the window itself for
 *       overlaping. The function also skipps disabled address decode windows.
 *
 * INPUT:
@@ -552,7 +552,7 @@ MV_STATUS mvXorPciRemap(MV_U32 unit,MV_U32 winNum, MV_U32 addrHigh)
 *
 * RETURN:
 *       MV_TRUE if the given address window overlap current address
-*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data 
+*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data
 *       from registers.
 *
 *******************************************************************************/
@@ -567,7 +567,7 @@ static MV_STATUS xorWinOverlapDetect(MV_U32 unit,MV_U32 winNum, MV_ADDR_WIN *pAd
 		DB(mvOsPrintf("%s: ERR. pAddrWin is NULL pointer\n", __FUNCTION__ ));
 		return MV_BAD_PTR;
 	}
-    
+
 	for (chan = 0; chan < MV_XOR_MAX_CHAN_PER_UNIT; chan++)
 	{
 		/* Read base address enable register. Do not check disabled windows	*/
@@ -580,27 +580,27 @@ static MV_STATUS xorWinOverlapDetect(MV_U32 unit,MV_U32 winNum, MV_ADDR_WIN *pAd
 			{
 				continue;
 			}
-    
+
 			/* Do not check disabled windows */
 			if ((baseAddrEnableReg & XEXWCR_WIN_EN_MASK(winNumIndex)) == 0)
 			{
 				continue;
 			}
-    
+
 			/* Get window parameters */
 			if (MV_OK != mvXorTargetWinGet(unit,winNumIndex, &addrDecWin))
 			{
 				DB(mvOsPrintf("%s: ERR. TargetWinGet failed\n", __FUNCTION__ ));
 				return MV_ERROR;
 			}
-            
+
 			if (MV_TRUE == ctrlWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
 			{
 				return MV_TRUE;
 			}
 		}
 	}
-	
+
 	return MV_FALSE;
 }
 
@@ -627,7 +627,7 @@ static MV_VOID mvXorAddrDecShowUnit(MV_U32 unit)
 				mvCtrlTargetNameGet(win.target), win.addrWin.baseLow );
 
 				mvSizePrint( win.addrWin.size );
-				
+
                 mvOsOutput( "\n" );
 			}
 			else
@@ -658,5 +658,5 @@ MV_VOID mvXorAddrDecShow(MV_VOID)
 
 	for( i = 0; i < MV_XOR_MAX_UNIT; i++ )
 	    mvXorAddrDecShowUnit(i);
-	
+
 }
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.h
index 73b2d9e..0a7be8f 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -78,7 +78,7 @@ extern "C" {
 #define XOR_MAX_ADDR_DEC_WIN	8	/* Maximum address decode windows		*/
 #define XOR_MAX_REMAP_WIN       4	/* Maximum address arbiter windows		*/
 
-/* XOR Engine Address Decoding Register Map */                  
+/* XOR Engine Address Decoding Register Map */
 #define XOR_WINDOW_CTRL_REG(unit,chan)     (XOR_UNIT_BASE(unit)+(0x240 + ((chan) * 4)))
 #define XOR_BASE_ADDR_REG(unit,winNum)     (XOR_UNIT_BASE(unit)+(0x250 + ((winNum) * 4)))
 #define XOR_SIZE_MASK_REG(unit,winNum)     (XOR_UNIT_BASE(unit)+(0x270 + ((winNum) * 4)))
@@ -117,7 +117,7 @@ typedef struct _mvXorDecWin
     MV_TARGET     target;
     MV_ADDR_WIN   addrWin; /* An address window*/
     MV_BOOL       enable;  /* Address decode window is enabled/disabled */
- 
+
 }MV_XOR_DEC_WIN;
 
 MV_STATUS   mvXorInit (MV_VOID);
@@ -125,9 +125,9 @@ MV_STATUS   mvXorTargetWinSet(MV_U32 unit, MV_U32 winNum,
 			      MV_XOR_DEC_WIN *pAddrDecWin);
 MV_STATUS   mvXorTargetWinGet(MV_U32 unit, MV_U32 winNum,
 			      MV_XOR_DEC_WIN *pAddrDecWin);
-MV_STATUS   mvXorTargetWinEnable(MV_U32 unit, 
+MV_STATUS   mvXorTargetWinEnable(MV_U32 unit,
 			      MV_U32 winNum, MV_BOOL enable);
-MV_STATUS   mvXorProtWinSet (MV_U32 unit,MV_U32 chan, MV_U32 winNum, MV_BOOL access, 
+MV_STATUS   mvXorProtWinSet (MV_U32 unit,MV_U32 chan, MV_U32 winNum, MV_BOOL access,
                              MV_BOOL write);
 MV_STATUS   mvXorPciRemap(MV_U32 unit, MV_U32 winNum, MV_U32 addrHigh);
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.c b/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.c
index 80325fc..a327944 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,57 +19,57 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
 
 #include "device/mvDevice.h"
 
-/* defines  */       
-#ifdef MV_DEBUG         
+/* defines  */
+#ifdef MV_DEBUG
 	#define DB(x)	x
-#else                
-	#define DB(x)    
-#endif	             
+#else
+	#define DB(x)
+#endif
 
 
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.h b/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.h
index 9350779..a8a382b 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDeviceRegs.h b/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDeviceRegs.h
index 80778ad..599dfe3 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDeviceRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDeviceRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -89,7 +89,7 @@ typedef enum _mvDevice
 	MV_DEV_MAX_CS = MV_DEVICE_MAX_CS
 }MV_DEVICE;
 
- 
+
 #endif /* MV_ASMLANGUAGE */
 
 
diff --git a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c
index 75f7e88..749b885 100644
--- a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c
+++ b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -13,24 +13,24 @@ Marvell copyright notice above.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
 /*******************************************************************************
 * mvOsCpuArchLib.c - Marvell CPU architecture library
 *
 * DESCRIPTION:
-*       This library introduce Marvell API for OS dependent CPU architecture 
-*       APIs. This library introduce single CPU architecture services APKI 
+*       This library introduce Marvell API for OS dependent CPU architecture
+*       APIs. This library introduce single CPU architecture services APKI
 *       cross OS.
 *
 * DEPENDENCIES:
@@ -74,19 +74,19 @@ void* mvOsIoUncachedMalloc( void* osHandle, MV_U32 size, MV_ULONG* pPhyAddr,
 {
     return pci_alloc_consistent( osHandle, size, (dma_addr_t *)pPhyAddr );
 }
- 
+
 void mvOsIoUncachedFree( void* osHandle, MV_U32 size, MV_ULONG phyAddr, void* pVirtAddr,
 			 MV_U32 memHandle)
 {
     return pci_free_consistent( osHandle, size, pVirtAddr, (dma_addr_t)phyAddr );
-} 
-                                                                                                                                               
+}
+
 void mvOsIoCachedFree( void* osHandle, MV_U32 size, MV_ULONG phyAddr, void* pVirtAddr,
 		       MV_U32 memHandle )
 {
     return kfree( pVirtAddr );
 }
- 
+
 int mvOsRand(void)
 {
     int rand;
@@ -95,7 +95,7 @@ int mvOsRand(void)
 }
 
 /*******************************************************************************
-* mvOsCpuVerGet() - 
+* mvOsCpuVerGet() -
 *
 * DESCRIPTION:
 *
@@ -114,7 +114,7 @@ MV_U32 mvOsCpuRevGet( MV_VOID )
 	return ((read_p15_c0() & ARM_ID_REVISION_MASK ) >> ARM_ID_REVISION_OFFS);
 }
 /*******************************************************************************
-* mvOsCpuPartGet() - 
+* mvOsCpuPartGet() -
 *
 * DESCRIPTION:
 *
@@ -133,7 +133,7 @@ MV_U32 mvOsCpuPartGet( MV_VOID )
 	return ((read_p15_c0() & ARM_ID_PART_NUM_MASK ) >> ARM_ID_PART_NUM_OFFS);
 }
 /*******************************************************************************
-* mvOsCpuArchGet() - 
+* mvOsCpuArchGet() -
 *
 * DESCRIPTION:
 *
@@ -152,7 +152,7 @@ MV_U32 mvOsCpuArchGet( MV_VOID )
     return ((read_p15_c0() & ARM_ID_ARCH_MASK ) >> ARM_ID_ARCH_OFFS);
 }
 /*******************************************************************************
-* mvOsCpuVarGet() - 
+* mvOsCpuVarGet() -
 *
 * DESCRIPTION:
 *
@@ -171,7 +171,7 @@ MV_U32 mvOsCpuVarGet( MV_VOID )
     return ((read_p15_c0() & ARM_ID_VAR_MASK ) >> ARM_ID_VAR_OFFS);
 }
 /*******************************************************************************
-* mvOsCpuAsciiGet() - 
+* mvOsCpuAsciiGet() -
 *
 * DESCRIPTION:
 *
diff --git a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h
index 8da562a..9122a52 100644
--- a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h
+++ b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -13,22 +13,22 @@ Marvell copyright notice above.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
 #ifndef _MV_OS_LNX_H_
 #define _MV_OS_LNX_H_
-                                                                                                                                               
-                                                                                                                                               
+
+
 #ifdef __KERNEL__
 /* for kernel space */
 #include <linux/autoconf.h>
@@ -51,21 +51,21 @@ disclaimer.
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
-  
+
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/hardirq.h>
 #include <asm/dma.h>
 #include <asm/io.h>
- 
+
 #include <linux/random.h>
 
 #include "dbg-trace.h"
 
 extern void mv_early_printk(char *fmt,...);
 
-#define MV_ASM              __asm__ __volatile__  
+#define MV_ASM              __asm__ __volatile__
 #define INLINE              inline
 #define MV_TRC_REC	        TRC_REC
 #define mvOsPrintf          printk
@@ -84,41 +84,41 @@ extern void mv_early_printk(char *fmt,...);
 #define mvCopyFromOs        copy_from_user
 #define mvCopyToOs          copy_to_user
 
- 
+
 #include "mvTypes.h"
 #include "mvCommon.h"
-  
+
 #ifdef MV_NDEBUG
 #define mvOsAssert(cond)
 #else
 #define mvOsAssert(cond) { do { if(!(cond)) { BUG(); } }while(0); }
 #endif /* MV_NDEBUG */
- 
+
 #else /* __KERNEL__ */
- 
+
 /* for user space applications */
 #include <stdlib.h>
 #include <stdio.h>
 #include <assert.h>
 #include <string.h>
- 
+
 #define INLINE inline
 #define mvOsPrintf printf
 #define mvOsOutput printf
 #define mvOsMalloc(_size_) malloc(_size_)
 #define mvOsFree free
 #define mvOsAssert(cond) assert(cond)
- 
-#endif /* __KERNEL__ */                                                                                                                                               
+
+#endif /* __KERNEL__ */
 #define mvOsIoVirtToPhy(pDev, pVirtAddr)                            \
     pci_map_single( (pDev), (pVirtAddr), 0, PCI_DMA_BIDIRECTIONAL )
 
 #define mvOsCacheClear(pDev, p, size )                              \
     pci_map_single( (pDev), (p), (size), PCI_DMA_BIDIRECTIONAL)
- 
+
 #define mvOsCacheFlush(pDev, p, size )                              \
     pci_map_single( (pDev), (p), (size), PCI_DMA_TODEVICE)
- 
+
 #define mvOsCacheInvalidate(pDev, p, size)                          \
     pci_map_single( (pDev), (p), (size), PCI_DMA_FROMDEVICE )
 
@@ -156,7 +156,7 @@ extern void mv_early_printk(char *fmt,...);
 #define MV_16BIT_LE_FAST(val)            MV_16BIT_LE(val)
 #define MV_32BIT_BE_FAST(val)            MV_32BIT_BE(val)
 #define MV_16BIT_BE_FAST(val)            MV_16BIT_BE(val)
-    
+
 /* 32 and 16 bit read/write in big/little endian mode */
 
 /* 16bit write in little endian mode */
@@ -265,7 +265,7 @@ static __inline void mvOsBridgeReorderWA(void)
   __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr)); \
 }
 #endif
- 
+
 #ifdef CONFIG_L2_CACHE_ENABLE
 #define mvOsCacheLineInv(handle,addr)                           \
 {                                                               \
@@ -295,7 +295,7 @@ static __inline void mvOsBridgeReorderWA(void)
   __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 1" : : "r" (addr));\
   __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr)); \
 }
-#endif 
+#endif
 
 static __inline void mvOsPrefetch(const void *ptr)
 {
@@ -321,7 +321,7 @@ static __inline void mvOsPrefetch(const void *ptr)
 /* register manipulations  */
 
 /******************************************************************************
-* This debug function enable the write of each register that u-boot access to 
+* This debug function enable the write of each register that u-boot access to
 * to an array in the DRAM, the function record only MV_REG_WRITE access.
 * The function could not be operate when booting from flash.
 * In order to print the array we use the printreg command.
@@ -351,7 +351,7 @@ extern int reg_arry_index;
 #define MV_REG_WRITE(offset, val)    \
         MV_MEMIO_LE32_WRITE((INTER_REGS_BASE | (offset)), (val));
 #endif
-                                                
+
 #define MV_REG_BYTE_READ(offset)        \
         (MV_MEMIO8_READ((INTER_REGS_BASE | (offset))))
 
@@ -384,7 +384,7 @@ extern int reg_arry_index;
          (MV_MEMIO32_READ(INTER_REGS_BASE | (offset)) | \
           MV_32BIT_LE_FAST(bitMask))))
 #endif
-        
+
 #if defined(REG_DEBUG)
 #define MV_REG_BIT_RESET(offset,bitMask)                \
         (MV_MEMIO32_WRITE((INTER_REGS_BASE | (offset)), \
diff --git a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOsSata.h b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOsSata.h
index c925a9e..170481a 100644
--- a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOsSata.h
+++ b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOsSata.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -13,20 +13,20 @@ Marvell copyright notice above.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
 /*******************************************************************************
-* mvOsLinux.h - O.S. interface header file for Linux  
+* mvOsLinux.h - O.S. interface header file for Linux
 *
 * DESCRIPTION:
 *       This header file contains OS dependent definition under Linux
diff --git a/crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h b/crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h
index d761060..116b941 100644
--- a/crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h
+++ b/crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h
@@ -4,16 +4,16 @@ Copyright (C) Marvell International Ltd. and its affiliates
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 *******************************************************************************/
@@ -198,7 +198,7 @@ disclaimer.
 #else
  #define ETH_DESCR_CONFIG_STR    "Cached descriptors in DRAM"
 #endif
-#else 
+#else
  #error "Ethernet descriptors location undefined"
 #endif /* ETH_DESCR_IN_SRAM or ETH_DESCR_IN_SDRAM*/
 
@@ -212,7 +212,7 @@ disclaimer.
 #ifndef MV_CACHE_COHER_SW
 /* Taken from mvCommon.h */
 /* Memory uncached, HW or SW cache coherency is not needed */
-#define MV_UNCACHED             0   
+#define MV_UNCACHED             0
 /* Memory cached, HW cache coherency supported in WriteThrough mode */
 #define MV_CACHE_COHER_HW_WT    1
 /* Memory cached, HW cache coherency supported in WriteBack mode */
@@ -247,7 +247,7 @@ disclaimer.
 
 /* port's default queueus */
 #define ETH_DEF_TXQ         0
-#define ETH_DEF_RXQ         0 
+#define ETH_DEF_RXQ         0
 
 #define MV_ETH_RX_Q_NUM     CONFIG_MV_ETH_RX_Q_NUM
 #define MV_ETH_TX_Q_NUM     CONFIG_MV_ETH_TX_Q_NUM
@@ -272,7 +272,7 @@ disclaimer.
 #endif
 
 #if defined(CONFIG_MV_TDM_5CHANNELS)
- #define MV_TDM_5CHANNELS 
+ #define MV_TDM_5CHANNELS
 #endif
 
 #if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
@@ -284,10 +284,10 @@ disclaimer.
 /* IMPORTANT: We are using mask register for that purpose. Before writing     */
 /* to units mask register, make sure main maks register is set to disable     */
 /* all interrupts.                                                            */
-#define DRAM_BUF_REG0   0x30810 /* sdram bank 0 size            */  
+#define DRAM_BUF_REG0   0x30810 /* sdram bank 0 size            */
 #define DRAM_BUF_REG1   0x30820 /* sdram config                 */
 #define DRAM_BUF_REG2   0x30830 /* sdram mode                   */
-#define DRAM_BUF_REG3   0x308c4 /* dunit control low            */          
+#define DRAM_BUF_REG3   0x308c4 /* dunit control low            */
 #define DRAM_BUF_REG4   0x60a90 /* sdram address control        */
 #define DRAM_BUF_REG5   0x60a94 /* sdram timing control low     */
 #define DRAM_BUF_REG6   0x60a98 /* sdram timing control high    */
@@ -344,7 +344,7 @@ disclaimer.
 /* PEX Work arround */
 /* the target we will use for the workarround */
 #define PEX_CONFIG_RW_WA_TARGET PEX0_MEM
-/*a flag that indicates if we are going to use the 
+/*a flag that indicates if we are going to use the
 size and base of the target we using for the workarround
 window */
 #define PEX_CONFIG_RW_WA_USE_ORIGINAL_WIN_VALUES 1
@@ -369,7 +369,7 @@ otherwise the following defines will be ignored */
 /* PEX-PCI\PCI-PCI Bridge*/
 #define PCI0_IF_PTP		0		/* Bridge exist on pciIf0*/
 
- 
+
 
 #endif /* __INCmvSysHwConfigh */
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c b/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c
index 717c150..4fe2e9c 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -65,20 +65,20 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvCntmr.h"
 #include "cpu/mvCpu.h"
 
-/* defines  */       
-#ifdef MV_DEBUG         
+/* defines  */
+#ifdef MV_DEBUG
 	#define DB(x)	x
-#else                
-	#define DB(x)    
-#endif	             
+#else
+	#define DB(x)
+#endif
 
 extern unsigned int whoAmI(void);
 
 /*******************************************************************************
-* mvCntmrLoad - 
+* mvCntmrLoad -
 *
 * DESCRIPTION:
-*       Load an init Value to a given counter/timer 
+*       Load an init Value to a given counter/timer
 *
 * INPUT:
 *       countNum - counter number
@@ -107,10 +107,10 @@ MV_STATUS mvCntmrLoad(MV_U32 countNum, MV_U32 value)
 }
 
 /*******************************************************************************
-* mvCntmrRead - 
+* mvCntmrRead -
 *
 * DESCRIPTION:
-*  	Returns the value of the given Counter/Timer     
+*  	Returns the value of the given Counter/Timer
 *
 * INPUT:
 *       countNum - counter number
@@ -127,10 +127,10 @@ MV_U32 mvCntmrRead(MV_U32 countNum)
 }
 
 /*******************************************************************************
-* mvCntmrWrite - 
+* mvCntmrWrite -
 *
 * DESCRIPTION:
-*  	Returns the value of the given Counter/Timer     
+*  	Returns the value of the given Counter/Timer
 *
 * INPUT:
 *       countNum - counter number
@@ -148,14 +148,14 @@ void mvCntmrWrite(MV_U32 countNum,MV_U32 countVal)
 }
 
 /*******************************************************************************
-* mvCntmrCtrlSet - 
+* mvCntmrCtrlSet -
 *
 * DESCRIPTION:
-*  	Set the Control to a given counter/timer     
+*  	Set the Control to a given counter/timer
 *
 * INPUT:
 *       countNum - counter number
-*		pCtrl - pointer to MV_CNTMR_CTRL structure 
+*		pCtrl - pointer to MV_CNTMR_CTRL structure
 *
 * OUTPUT:
 *       None.
@@ -178,7 +178,7 @@ MV_STATUS mvCntmrCtrlSet(MV_U32 countNum, MV_CNTMR_CTRL *pCtrl)
 	/* read control register */
 	cntmrCtrl = MV_REG_READ(CNTMR_CTRL_REG);
 
-	
+
 	if (pCtrl->enable)	/* enable counter\timer */
 	{
 		cntmrCtrl |= CTCR_ARM_TIMER_EN(countNum);
@@ -190,7 +190,7 @@ MV_STATUS mvCntmrCtrlSet(MV_U32 countNum, MV_CNTMR_CTRL *pCtrl)
 
 	if ( pCtrl->autoEnable ) /* Auto mode */
 	{
-		cntmrCtrl |= CTCR_ARM_TIMER_AUTO_EN(countNum);		
+		cntmrCtrl |= CTCR_ARM_TIMER_AUTO_EN(countNum);
 
 	}
 	else 	/* no auto mode */
@@ -205,14 +205,14 @@ MV_STATUS mvCntmrCtrlSet(MV_U32 countNum, MV_CNTMR_CTRL *pCtrl)
 }
 
 /*******************************************************************************
-* mvCntmrCtrlGet - 
+* mvCntmrCtrlGet -
 *
 * DESCRIPTION:
-*  	Get the Control value of a given counter/timer     
+*  	Get the Control value of a given counter/timer
 *
 * INPUT:
 *       countNum - counter number
-*		pCtrl - pointer to MV_CNTMR_CTRL structure 
+*		pCtrl - pointer to MV_CNTMR_CTRL structure
 *
 * OUTPUT:
 *       Counter\Timer control value
@@ -257,10 +257,10 @@ MV_STATUS mvCntmrCtrlGet(MV_U32 countNum, MV_CNTMR_CTRL *pCtrl)
 }
 
 /*******************************************************************************
-* mvCntmrEnable - 
+* mvCntmrEnable -
 *
 * DESCRIPTION:
-*  	Set the Enable-Bit to logic '1' ==> starting the counter     
+*  	Set the Enable-Bit to logic '1' ==> starting the counter
 *
 * INPUT:
 *       countNum - counter number
@@ -296,10 +296,10 @@ MV_STATUS mvCntmrEnable(MV_U32 countNum)
 }
 
 /*******************************************************************************
-* mvCntmrDisable - 
+* mvCntmrDisable -
 *
 * DESCRIPTION:
-*  	Stop the counter/timer running, and returns its Value     
+*  	Stop the counter/timer running, and returns its Value
 *
 * INPUT:
 *       countNum - counter number
@@ -334,15 +334,15 @@ MV_STATUS mvCntmrDisable(MV_U32 countNum)
 }
 
 /*******************************************************************************
-* mvCntmrStart - 
+* mvCntmrStart -
 *
 * DESCRIPTION:
-*  	Combined all the sub-operations above to one function: Load,setMode,Enable     
+*  	Combined all the sub-operations above to one function: Load,setMode,Enable
 *
 * INPUT:
 *       countNum - counter number
 *		value - value of the counter\timer to be set
-*		pCtrl - pointer to MV_CNTMR_CTRL structure 
+*		pCtrl - pointer to MV_CNTMR_CTRL structure
 *
 * OUTPUT:
 *       None.
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.h b/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.h
index b911d0f..7a2b925 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -75,10 +75,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* This enumerator describe counters\watchdog numbers       */
 typedef enum _mvCntmrID
 {
-	TIMER0 = 0,               
+	TIMER0 = 0,
 	TIMER1,
 	WATCHDOG,
-	TIMER2,               
+	TIMER2,
 	TIMER3,
 }MV_CNTMR_ID;
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmrRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmrRegs.h
index b69bc66..1cd9041 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmrRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmrRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -91,12 +91,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define WATCHDOG_NUM			2
 #define TIMER2_NUM				3
 #define TIMER3_NUM				4
-	
+
 #define CTCR_ARM_TIMER_EN_OFFS(cntr)	(cntr * 2)
 #define CTCR_ARM_TIMER_EN_MASK(cntr)	(1 << CTCR_ARM_TIMER_EN_OFFS)
 #define CTCR_ARM_TIMER_EN(cntr)			(1 << CTCR_ARM_TIMER_EN_OFFS(cntr))
 #define CTCR_ARM_TIMER_DIS(cntr)		(0 << CTCR_ARM_TIMER_EN_OFFS(cntr))
-	
+
 #define CTCR_ARM_TIMER_AUTO_OFFS(cntr)	((cntr * 2) + 1)
 #define CTCR_ARM_TIMER_AUTO_MASK(cntr)	BIT1
 #define CTCR_ARM_TIMER_AUTO_EN(cntr)	(1 << CTCR_ARM_TIMER_AUTO_OFFS(cntr))
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.c b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.c
index 609e674..03d6d09 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.c
@@ -19,11 +19,11 @@
 
 
 const static MV_CPU_CNTRS_OPS  mvCpuCntrsOpsTbl[MV_CPU_CNTRS_NUM][MV_CPU_CNTRS_OPS_NUM] =
-{   
+{
     /*0*/
-    {   
+    {
         MV_CPU_CNTRS_CYCLES,            MV_CPU_CNTRS_DCACHE_READ_HIT,       MV_CPU_CNTRS_DCACHE_READ_MISS,
-        MV_CPU_CNTRS_DCACHE_WRITE_HIT,  MV_CPU_CNTRS_DCACHE_WRITE_MISS,     MV_CPU_CNTRS_INSTRUCTIONS, 
+        MV_CPU_CNTRS_DCACHE_WRITE_HIT,  MV_CPU_CNTRS_DCACHE_WRITE_MISS,     MV_CPU_CNTRS_INSTRUCTIONS,
         MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_INVALID,
         MV_CPU_CNTRS_MMU_READ_LATENCY,  MV_CPU_CNTRS_ICACHE_READ_LATENCY,   MV_CPU_CNTRS_WB_WRITE_LATENCY,
         MV_CPU_CNTRS_LDM_STM_HOLD,      MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_INVALID,
@@ -31,18 +31,18 @@ const static MV_CPU_CNTRS_OPS  mvCpuCntrsOpsTbl[MV_CPU_CNTRS_NUM][MV_CPU_CNTRS_O
         MV_CPU_CNTRS_BRANCH_PREDICT_COUNT,
     },
     /*1*/
-    {   
+    {
         MV_CPU_CNTRS_CYCLES,            MV_CPU_CNTRS_ICACHE_READ_MISS,      MV_CPU_CNTRS_DCACHE_READ_MISS,
         MV_CPU_CNTRS_DCACHE_WRITE_MISS, MV_CPU_CNTRS_ITLB_MISS,             MV_CPU_CNTRS_SINGLE_ISSUE,
-        MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_BRANCH_RETIRED,        MV_CPU_CNTRS_INVALID, 
+        MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_BRANCH_RETIRED,        MV_CPU_CNTRS_INVALID,
         MV_CPU_CNTRS_MMU_READ_BEAT,     MV_CPU_CNTRS_ICACHE_READ_LATENCY,   MV_CPU_CNTRS_WB_WRITE_BEAT,
         MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_IS_HOLD,               MV_CPU_CNTRS_DATA_READ_ACCESS,
         MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_INVALID,
         MV_CPU_CNTRS_INVALID,
     },
-    /*2*/   
+    /*2*/
     {
-        MV_CPU_CNTRS_CYCLES,            MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_DCACHE_ACCESS, 
+        MV_CPU_CNTRS_CYCLES,            MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_DCACHE_ACCESS,
         MV_CPU_CNTRS_DTLB_MISS,         MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_INVALID,
         MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_BRANCH_PREDICT_MISS,   MV_CPU_CNTRS_WB_WRITE_BEAT,
         MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_DCACHE_READ_LATENCY,   MV_CPU_CNTRS_DCACHE_WRITE_LATENCY,
@@ -50,10 +50,10 @@ const static MV_CPU_CNTRS_OPS  mvCpuCntrsOpsTbl[MV_CPU_CNTRS_NUM][MV_CPU_CNTRS_O
         MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_INVALID,
         MV_CPU_CNTRS_INVALID,
     },
-    /*3*/   
+    /*3*/
     {
         MV_CPU_CNTRS_CYCLES,            MV_CPU_CNTRS_DCACHE_READ_MISS,      MV_CPU_CNTRS_DCACHE_WRITE_MISS,
-        MV_CPU_CNTRS_TLB_MISS,          MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_INVALID, 
+        MV_CPU_CNTRS_TLB_MISS,          MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_INVALID,
         MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_BRANCH_TAKEN,          MV_CPU_CNTRS_WB_FULL_CYCLES,
         MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_DCACHE_READ_BEAT,      MV_CPU_CNTRS_DCACHE_WRITE_BEAT,
         MV_CPU_CNTRS_INVALID,           MV_CPU_CNTRS_INVALID,               MV_CPU_CNTRS_BIU_ANY_ACCESS,
@@ -69,7 +69,7 @@ MV_CPU_CNTRS_EVENT*   mvCpuCntrsEventTbl[128];
 void mvCpuCntrsReset(void)
 {
     MV_U32 reg = 0;
-   
+
     MV_ASM ("mcr p15, 0, %0, c15, c13, 0" : : "r" (reg));
     MV_ASM ("mcr p15, 0, %0, c15, c13, 1" : : "r" (reg));
     MV_ASM ("mcr p15, 0, %0, c15, c13, 2" : : "r" (reg));
@@ -79,7 +79,7 @@ void mvCpuCntrsReset(void)
     MV_ASM ("mcr p15, 0, %0, c15, c13, 6" : : "r" (reg));
     MV_ASM ("mcr p15, 0, %0, c15, c13, 7" : : "r" (reg));
 }
-               
+
 void program_counter(int counter, int op)
 {
     MV_U32 reg =  (1 << op) | 0x1; /*enable*/
@@ -119,7 +119,7 @@ void mvCpuCntrsEventClear(MV_CPU_CNTRS_EVENT* pEvent)
     pEvent->num_of_measurements = 0;
 }
 
-                                                                                                              
+
 MV_CPU_CNTRS_EVENT* mvCpuCntrsEventCreate(char* name, MV_U32 print_threshold)
 {
     int                     i;
@@ -146,8 +146,8 @@ void    mvCpuCntrsEventDelete(MV_CPU_CNTRS_EVENT* event)
         mvOsFree(event);
 }
 
-                                                                                     
-MV_STATUS   mvCpuCntrsProgram(int counter, MV_CPU_CNTRS_OPS op, 
+
+MV_STATUS   mvCpuCntrsProgram(int counter, MV_CPU_CNTRS_OPS op,
                                  char* name, MV_U32 overhead)
 {
     int     i;
@@ -175,13 +175,13 @@ void    mvCpuCntrsShow(MV_CPU_CNTRS_EVENT* pEvent)
     int     i;
     MV_U64  counters_avg;
 
-    if(pEvent->num_of_measurements < pEvent->avg_sample_count) 
+    if(pEvent->num_of_measurements < pEvent->avg_sample_count)
         return;
 
     mvOsPrintf("%16s: ", pEvent->name);
     for(i=0; i<MV_CPU_CNTRS_NUM; i++)
     {
-        counters_avg = mvOsDivMod64(pEvent->counters_sum[i], 
+        counters_avg = mvOsDivMod64(pEvent->counters_sum[i],
                                   pEvent->num_of_measurements, NULL);
         if(counters_avg >= mvCpuCntrsTbl[i].overhead)
             counters_avg -= mvCpuCntrsTbl[i].overhead;
@@ -201,7 +201,7 @@ void    mvCpuCntrsStatus(void)
 
     for(i=0; i<MV_CPU_CNTRS_NUM; i++)
     {
-        mvOsPrintf("#%d: %s, overhead=%d\n", 
+        mvOsPrintf("#%d: %s, overhead=%d\n",
             i, mvCpuCntrsTbl[i].name, mvCpuCntrsTbl[i].overhead);
     }
 }
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h
index 8d49af0..3428a71 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -13,16 +13,16 @@ Marvell copyright notice above.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
 #ifndef __mvCpuCntrs_h__
@@ -80,7 +80,7 @@ typedef struct
     MV_CPU_CNTRS_OPS    operation;
     int                 opIdx;
     MV_U32              overhead;
-    
+
 } MV_CPU_CNTRS_ENTRY;
 
 
@@ -98,7 +98,7 @@ typedef struct
 extern MV_CPU_CNTRS_ENTRY  mvCpuCntrsTbl[MV_CPU_CNTRS_NUM];
 
 
-MV_STATUS           mvCpuCntrsProgram(int counter, MV_CPU_CNTRS_OPS op, 
+MV_STATUS           mvCpuCntrsProgram(int counter, MV_CPU_CNTRS_OPS op,
                                       char* name, MV_U32 overhead);
 void                mvCpuCntrsInit(void);
 MV_CPU_CNTRS_EVENT* mvCpuCntrsEventCreate(char* name, MV_U32 print_threshold);
@@ -114,7 +114,7 @@ static INLINE MV_U64 mvCpuCntrsRead(const int counter)
 {
     MV_U32 low = 0, high = 0;
     MV_U32 ll = 0;
-    
+
     switch(counter)
     {
         case 0:
@@ -179,11 +179,11 @@ static INLINE void mvCpuCntrsReadAfter(MV_CPU_CNTRS_EVENT* pEvent)
     pEvent->counters_after[0] = mvCpuCntrsRead(0);
     pEvent->counters_after[3] = mvCpuCntrsRead(3);
     pEvent->counters_after[1] = mvCpuCntrsRead(1);
-#endif 
+#endif
 
     for(i=0; i<MV_CPU_CNTRS_NUM; i++)
     {
-        pEvent->counters_sum[i] += (pEvent->counters_after[i] - pEvent->counters_before[i]);	
+        pEvent->counters_sum[i] += (pEvent->counters_after[i] - pEvent->counters_before[i]);
     }
     pEvent->num_of_measurements++;
 }
@@ -196,7 +196,7 @@ static INLINE void mvCpuCntrsReadAfter(MV_CPU_CNTRS_EVENT* pEvent)
 #define MV_CPU_CNTRS_START(event)	mvCpuCntrsReadBefore(event)
 
 #define MV_CPU_CNTRS_STOP(event)	mvCpuCntrsReadAfter(event)
-			
+
 #define MV_CPU_CNTRS_SHOW(event)	mvCpuCntrsShow(event)
 
 #else
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.c b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.c
index 0333862..2401002 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.c
@@ -26,13 +26,13 @@ MV_CPU_L2_CNTRS_EVENT*  mvCpuL2CntrsEventTbl[128];
 void mvCpuL2CntrsReset(void)
 {
     MV_U32 reg = 0;
-   
+
     MV_ASM ("mcr p15, 6, %0, c15, c13, 0" : : "r" (reg));
     MV_ASM ("mcr p15, 6, %0, c15, c13, 1" : : "r" (reg));
     MV_ASM ("mcr p15, 6, %0, c15, c13, 2" : : "r" (reg));
     MV_ASM ("mcr p15, 6, %0, c15, c13, 3" : : "r" (reg));
 }
-               
+
 static void mvCpuL2CntrConfig(int counter, int op)
 {
     MV_U32 reg =  (1 << op) | 0x1; /*enable*/
@@ -64,7 +64,7 @@ void mvCpuL2CntrsEventClear(MV_CPU_L2_CNTRS_EVENT* pEvent)
     pEvent->num_of_measurements = 0;
 }
 
-                                                                                                              
+
 MV_CPU_L2_CNTRS_EVENT* mvCpuL2CntrsEventCreate(char* name, MV_U32 print_threshold)
 {
     int                     i;
@@ -91,8 +91,8 @@ void    mvCpuL2CntrsEventDelete(MV_CPU_L2_CNTRS_EVENT* event)
         mvOsFree(event);
 }
 
-                                                                                     
-MV_STATUS   mvCpuL2CntrsProgram(int counter, MV_CPU_L2_CNTRS_OPS op, 
+
+MV_STATUS   mvCpuL2CntrsProgram(int counter, MV_CPU_L2_CNTRS_OPS op,
                                  char* name, MV_U32 overhead)
 {
     strncpy(mvCpuL2CntrsTbl[counter].name, name, sizeof(mvCpuL2CntrsTbl[counter].name));
@@ -110,13 +110,13 @@ void    mvCpuL2CntrsShow(MV_CPU_L2_CNTRS_EVENT* pEvent)
     int     i;
     MV_U64  counters_avg;
 
-    if(pEvent->num_of_measurements < pEvent->avg_sample_count) 
+    if(pEvent->num_of_measurements < pEvent->avg_sample_count)
         return;
 
     mvOsPrintf("%16s: ", pEvent->name);
     for(i=0; i<MV_CPU_L2_CNTRS_NUM; i++)
     {
-        counters_avg = mvOsDivMod64(pEvent->counters_sum[i], 
+        counters_avg = mvOsDivMod64(pEvent->counters_sum[i],
                                     pEvent->num_of_measurements, NULL);
 
         if(counters_avg >= mvCpuL2CntrsTbl[i].overhead)
@@ -137,7 +137,7 @@ void    mvCpuL2CntrsStatus(void)
 
     for(i=0; i<MV_CPU_L2_CNTRS_NUM; i++)
     {
-        mvOsPrintf("#%d: %s, overhead=%d\n", 
+        mvOsPrintf("#%d: %s, overhead=%d\n",
             i, mvCpuL2CntrsTbl[i].name, mvCpuL2CntrsTbl[i].overhead);
     }
 }
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h
index 570d701..77ba5e5 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -13,16 +13,16 @@ Marvell copyright notice above.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
 #ifndef __mvCpuL2Cntrs_h__
@@ -58,7 +58,7 @@ typedef struct
     MV_CPU_L2_CNTRS_OPS operation;
     int                 opIdx;
     MV_U32              overhead;
-    
+
 } MV_CPU_L2_CNTRS_ENTRY;
 
 
@@ -74,7 +74,7 @@ typedef struct
 } MV_CPU_L2_CNTRS_EVENT;
 
 
-MV_STATUS               mvCpuL2CntrsProgram(int counter, MV_CPU_L2_CNTRS_OPS op, 
+MV_STATUS               mvCpuL2CntrsProgram(int counter, MV_CPU_L2_CNTRS_OPS op,
                                         char* name, MV_U32 overhead);
 void                    mvCpuL2CntrsInit(void);
 MV_CPU_L2_CNTRS_EVENT*  mvCpuL2CntrsEventCreate(char* name, MV_U32 print_threshold);
@@ -86,7 +86,7 @@ void 			mvCpuL2CntrsEventClear(MV_CPU_L2_CNTRS_EVENT* pEvent);
 static INLINE MV_U64 mvCpuL2CntrsRead(const int counter)
 {
     MV_U32 low = 0, high = 0;
-    
+
     switch(counter)
     {
         case 0:
@@ -118,10 +118,10 @@ static INLINE void mvCpuL2CntrsReadAfter(MV_CPU_L2_CNTRS_EVENT* pEvent)
 {
     int i;
 
-    for(i=0; i<MV_CPU_L2_CNTRS_NUM; i++) 
+    for(i=0; i<MV_CPU_L2_CNTRS_NUM; i++)
     {
         pEvent->counters_after[i] = mvCpuL2CntrsRead(i);
-        pEvent->counters_sum[i] += (pEvent->counters_after[i] - pEvent->counters_before[i]);	
+        pEvent->counters_sum[i] += (pEvent->counters_after[i] - pEvent->counters_before[i]);
     }
     pEvent->num_of_measurements++;
 }
@@ -134,7 +134,7 @@ static INLINE void mvCpuL2CntrsReadAfter(MV_CPU_L2_CNTRS_EVENT* pEvent)
 #define MV_CPU_L2_CNTRS_START(event)	mvCpuL2CntrsReadBefore(event)
 
 #define MV_CPU_L2_CNTRS_STOP(event)	    mvCpuL2CntrsReadAfter(event)
-			
+
 #define MV_CPU_L2_CNTRS_SHOW(event)	    mvCpuL2CntrsShow(event)
 
 #else
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c
index d1b8a3d..413dca3 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -72,17 +72,17 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define DB(x)
 #endif
 
-static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo, 
+static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo,
                                             MV_DRAM_BANK_INFO *pBankInfo);
 static MV_U32  cas2ps(MV_U8 spd_byte);
 /*******************************************************************************
 * mvDramBankGet - Get the DRAM bank paramters.
 *
 * DESCRIPTION:
-*       This function retrieves DRAM bank parameters as described in 
-*       DRAM_BANK_INFO struct to the controller DRAM unit. In case the board 
+*       This function retrieves DRAM bank parameters as described in
+*       DRAM_BANK_INFO struct to the controller DRAM unit. In case the board
 *       has its DRAM on DIMMs it will use its EEPROM to extract SPD data
-*       from it. Otherwise, if the DRAM is soldered on board, the function 
+*       from it. Otherwise, if the DRAM is soldered on board, the function
 *       should insert its bank information into MV_DRAM_BANK_INFO struct.
 *
 * INPUT:
@@ -99,13 +99,13 @@ MV_STATUS mvDramBankInfoGet(MV_U32 bankNum, MV_DRAM_BANK_INFO *pBankInfo)
 {
     MV_DIMM_INFO dimmInfo;
 
-    DB(mvOsPrintf("Dram: mvDramBankInfoGet bank %d\n", bankNum)); 
+    DB(mvOsPrintf("Dram: mvDramBankInfoGet bank %d\n", bankNum));
     /* zero pBankInfo structure */
     memset(pBankInfo, 0, sizeof(*pBankInfo));
 
     if((NULL == pBankInfo) || (bankNum >= MV_DRAM_MAX_CS ))
     {
-        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n")); 
+        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n"));
         return MV_BAD_PARAM;
     }
     if( MV_OK != dimmSpdGet((MV_U32)(bankNum/2), &dimmInfo))
@@ -121,7 +121,7 @@ MV_STATUS mvDramBankInfoGet(MV_U32 bankNum, MV_DRAM_BANK_INFO *pBankInfo)
 
     /* convert Dimm info to Bank info */
     cpyDimm2BankInfo(&dimmInfo, pBankInfo);
-    
+
     return MV_OK;
 }
 
@@ -141,49 +141,49 @@ MV_STATUS mvDramBankInfoGet(MV_U32 bankNum, MV_DRAM_BANK_INFO *pBankInfo)
 *       None.
 *
 *******************************************************************************/
-static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo, 
+static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo,
                                                 MV_DRAM_BANK_INFO *pBankInfo)
 {
-    pBankInfo->memoryType = pDimmInfo->memoryType;        
+    pBankInfo->memoryType = pDimmInfo->memoryType;
 
     /* DIMM dimensions */
     pBankInfo->numOfRowAddr = pDimmInfo->numOfRowAddr;
     pBankInfo->numOfColAddr = pDimmInfo->numOfColAddr;
     pBankInfo->dataWidth = pDimmInfo->dataWidth;
-    pBankInfo->errorCheckType = pDimmInfo->errorCheckType;             
+    pBankInfo->errorCheckType = pDimmInfo->errorCheckType;
     pBankInfo->sdramWidth = pDimmInfo->sdramWidth;
-    pBankInfo->errorCheckDataWidth = pDimmInfo->errorCheckDataWidth;   
+    pBankInfo->errorCheckDataWidth = pDimmInfo->errorCheckDataWidth;
     pBankInfo->numOfBanksOnEachDevice = pDimmInfo->numOfBanksOnEachDevice;
     pBankInfo->suportedCasLatencies = pDimmInfo->suportedCasLatencies;
     pBankInfo->refreshInterval = pDimmInfo->refreshInterval;
- 
+
     /* DIMM timing parameters */
     pBankInfo->minCycleTimeAtMaxCasLatPs = pDimmInfo->minCycleTimeAtMaxCasLatPs;
-    pBankInfo->minCycleTimeAtMaxCasLatMinus1Ps = 
+    pBankInfo->minCycleTimeAtMaxCasLatMinus1Ps =
                                     pDimmInfo->minCycleTimeAtMaxCasLatMinus1Ps;
-    pBankInfo->minCycleTimeAtMaxCasLatMinus2Ps = 
+    pBankInfo->minCycleTimeAtMaxCasLatMinus2Ps =
                                     pDimmInfo->minCycleTimeAtMaxCasLatMinus2Ps;
 
-    pBankInfo->minRowPrechargeTime     = pDimmInfo->minRowPrechargeTime;     
+    pBankInfo->minRowPrechargeTime     = pDimmInfo->minRowPrechargeTime;
     pBankInfo->minRowActiveToRowActive = pDimmInfo->minRowActiveToRowActive;
-    pBankInfo->minRasToCasDelay        = pDimmInfo->minRasToCasDelay;       
-    pBankInfo->minRasPulseWidth        = pDimmInfo->minRasPulseWidth;       
+    pBankInfo->minRasToCasDelay        = pDimmInfo->minRasToCasDelay;
+    pBankInfo->minRasPulseWidth        = pDimmInfo->minRasPulseWidth;
     pBankInfo->minWriteRecoveryTime    = pDimmInfo->minWriteRecoveryTime;
     pBankInfo->minWriteToReadCmdDelay  = pDimmInfo->minWriteToReadCmdDelay;
     pBankInfo->minReadToPrechCmdDelay  = pDimmInfo->minReadToPrechCmdDelay;
     pBankInfo->minRefreshToActiveCmd   = pDimmInfo->minRefreshToActiveCmd;
-               
+
     /* Parameters calculated from the extracted DIMM information */
     pBankInfo->size = pDimmInfo->size/pDimmInfo->numOfModuleBanks;
-    pBankInfo->deviceDensity = pDimmInfo->deviceDensity;              
+    pBankInfo->deviceDensity = pDimmInfo->deviceDensity;
     pBankInfo->numberOfDevices = pDimmInfo->numberOfDevices /
                                  pDimmInfo->numOfModuleBanks;
- 
+
     /* DIMM attributes (MV_TRUE for yes) */
 
     if ((pDimmInfo->memoryType == MEM_TYPE_SDRAM) ||
         (pDimmInfo->memoryType == MEM_TYPE_DDR1)   )
-    {   
+    {
         if (pDimmInfo->dimmAttributes & BIT1)
             pBankInfo->registeredAddrAndControlInputs = MV_TRUE;
         else
@@ -220,7 +220,7 @@ MV_STATUS dimmSpdCpy(MV_VOID)
 {
     MV_U32 i;
     MV_U32 spdChecksum;
-     
+
     MV_TWSI_SLAVE twsiSlave;
     MV_U8 data[SPD_SIZE];
 
@@ -242,15 +242,15 @@ MV_STATUS dimmSpdCpy(MV_VOID)
         return MV_FAIL;
     }
     DB(puts("DRAM: Reading dimm info succeded.\n"));
-    
+
     /* calculate SPD checksum */
     spdChecksum = 0;
-    
+
     for(i = 0 ; i <= 62 ; i++)
     {
         spdChecksum += data[i];
     }
-    
+
     if ((spdChecksum & 0xff) != data[63])
     {
         DB(mvOsPrintf("DRAM: Warning. Wrong SPD Checksum %2x, expValue=%2x\n",
@@ -279,7 +279,7 @@ MV_STATUS dimmSpdCpy(MV_VOID)
 	}
 	mvOsDelay(5);
     }
-    
+
     DB(puts("DRAM: Reading dimm info succeded.\n"));
     return MV_OK;
 }
@@ -305,13 +305,13 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
     MV_U32 i;
     MV_U32 density = 1;
     MV_U32 spdChecksum;
-     
+
     MV_TWSI_SLAVE twsiSlave;
     MV_U8 data[SPD_SIZE];
 
     if((NULL == pDimmInfo)|| (dimmNum >= MAX_DIMM_NUM))
     {
-        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n")); 
+        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n"));
         return MV_BAD_PARAM;
     }
 
@@ -334,15 +334,15 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
         return MV_FAIL;
     }
     DB(puts("DRAM: Reading dimm info succeded.\n"));
-    
+
     /* calculate SPD checksum */
     spdChecksum = 0;
-    
+
         for(i = 0 ; i <= 62 ; i++)
         {
         spdChecksum += data[i];
     }
-    
+
     if ((spdChecksum & 0xff) != data[63])
     {
         DB(mvOsPrintf("DRAM: Warning. Wrong SPD Checksum %2x, expValue=%2x\n",
@@ -382,20 +382,20 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
             return MV_ERROR;
     }
 
-    
+
     /* Number Of Row Addresses */
     pDimmInfo->numOfRowAddr = data[DIMM_ROW_NUM];
     DB(mvOsPrintf("DRAM numOfRowAddr[3]         %d\n",pDimmInfo->numOfRowAddr));
-        
+
     /* Number Of Column Addresses */
     pDimmInfo->numOfColAddr = data[DIMM_COL_NUM];
     DB(mvOsPrintf("DRAM numOfColAddr[4]         %d\n",pDimmInfo->numOfColAddr));
-        
+
     /* Number Of Module Banks */
     pDimmInfo->numOfModuleBanks = data[DIMM_MODULE_BANK_NUM];
-    DB(mvOsPrintf("DRAM numOfModuleBanks[5]     0x%x\n", 
+    DB(mvOsPrintf("DRAM numOfModuleBanks[5]     0x%x\n",
                                                   pDimmInfo->numOfModuleBanks));
-        
+
     /* Number of module banks encoded differently for DDR2 */
     if (pDimmInfo->memoryType == MEM_TYPE_DDR2)
         pDimmInfo->numOfModuleBanks = (pDimmInfo->numOfModuleBanks & 0x7)+1;
@@ -403,156 +403,156 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
     /* Data Width */
     pDimmInfo->dataWidth = data[DIMM_DATA_WIDTH];
     DB(mvOsPrintf("DRAM dataWidth[6]            0x%x\n", pDimmInfo->dataWidth));
-        
+
     /* Minimum Cycle Time At Max CasLatancy */
     pDimmInfo->minCycleTimeAtMaxCasLatPs = cas2ps(data[DIMM_MIN_CC_AT_MAX_CAS]);
 
     /* Error Check Type */
     pDimmInfo->errorCheckType = data[DIMM_ERR_CHECK_TYPE];
-    DB(mvOsPrintf("DRAM errorCheckType[11]      0x%x\n", 
+    DB(mvOsPrintf("DRAM errorCheckType[11]      0x%x\n",
                                                     pDimmInfo->errorCheckType));
 
     /* Refresh Interval */
     pDimmInfo->refreshInterval = data[DIMM_REFRESH_INTERVAL];
-    DB(mvOsPrintf("DRAM refreshInterval[12]     0x%x\n", 
+    DB(mvOsPrintf("DRAM refreshInterval[12]     0x%x\n",
                                                    pDimmInfo->refreshInterval));
-    
+
     /* Sdram Width */
     pDimmInfo->sdramWidth = data[DIMM_SDRAM_WIDTH];
     DB(mvOsPrintf("DRAM sdramWidth[13]          0x%x\n",pDimmInfo->sdramWidth));
-        
+
     /* Error Check Data Width */
     pDimmInfo->errorCheckDataWidth = data[DIMM_ERR_CHECK_DATA_WIDTH];
-    DB(mvOsPrintf("DRAM errorCheckDataWidth[14] 0x%x\n", 
+    DB(mvOsPrintf("DRAM errorCheckDataWidth[14] 0x%x\n",
                                                pDimmInfo->errorCheckDataWidth));
-    
+
     /* Burst Length Supported */
     /*     SDRAM/DDR1:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  * 
-                    *********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  *
+                    *********************************************************/
     /*     DDR2:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  * 
-                    *********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  *
+                    *********************************************************/
 
     pDimmInfo->burstLengthSupported = data[DIMM_BURST_LEN_SUP];
-    DB(mvOsPrintf("DRAM burstLengthSupported[16] 0x%x\n", 
+    DB(mvOsPrintf("DRAM burstLengthSupported[16] 0x%x\n",
                                               pDimmInfo->burstLengthSupported));
-    
+
     /* Number Of Banks On Each Device */
     pDimmInfo->numOfBanksOnEachDevice = data[DIMM_DEV_BANK_NUM];
-    DB(mvOsPrintf("DRAM numOfBanksOnEachDevice[17] 0x%x\n", 
+    DB(mvOsPrintf("DRAM numOfBanksOnEachDevice[17] 0x%x\n",
                                             pDimmInfo->numOfBanksOnEachDevice));
-    
+
     /* Suported Cas Latencies */
-                   
+
     /*      SDRAM:
-            *******-******-******-******-******-******-******-******* 
-            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-            *******-******-******-******-******-******-******-******* 
-    CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  * 
-            ********************************************************/ 
+            *******-******-******-******-******-******-******-*******
+            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+            *******-******-******-******-******-******-******-*******
+    CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  *
+            ********************************************************/
 
     /*     DDR 1:
-            *******-******-******-******-******-******-******-******* 
-            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-            *******-******-******-******-******-******-******-******* 
-    CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  * 
+            *******-******-******-******-******-******-******-*******
+            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+            *******-******-******-******-******-******-******-*******
+    CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  *
             *********************************************************/
 
     /*     DDR 2:
-            *******-******-******-******-******-******-******-******* 
-            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-            *******-******-******-******-******-******-******-******* 
-    CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  * 
+            *******-******-******-******-******-******-******-*******
+            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+            *******-******-******-******-******-******-******-*******
+    CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  *
             *********************************************************/
-    
+
     pDimmInfo->suportedCasLatencies = data[DIMM_SUP_CAL];
-    DB(mvOsPrintf("DRAM suportedCasLatencies[18]    0x%x\n", 
+    DB(mvOsPrintf("DRAM suportedCasLatencies[18]    0x%x\n",
                                               pDimmInfo->suportedCasLatencies));
 
     /* For DDR2 only, get the DIMM type information */
     if (pDimmInfo->memoryType == MEM_TYPE_DDR2)
-    {   
+    {
         pDimmInfo->dimmTypeInfo = data[DIMM_DDR2_TYPE_INFORMATION];
-        DB(mvOsPrintf("DRAM dimmTypeInfo[20] (DDR2) 0x%x\n", 
+        DB(mvOsPrintf("DRAM dimmTypeInfo[20] (DDR2) 0x%x\n",
                                                       pDimmInfo->dimmTypeInfo));
     }
 
     /* SDRAM Modules Attributes */
     pDimmInfo->dimmAttributes = data[DIMM_BUF_ADDR_CONT_IN];
-    DB(mvOsPrintf("DRAM dimmAttributes[21]          0x%x\n",    
+    DB(mvOsPrintf("DRAM dimmAttributes[21]          0x%x\n",
                                                     pDimmInfo->dimmAttributes));
-    
+
     /* Minimum Cycle Time At Max CasLatancy Minus 1*/
-    pDimmInfo->minCycleTimeAtMaxCasLatMinus1Ps = 
+    pDimmInfo->minCycleTimeAtMaxCasLatMinus1Ps =
                                     cas2ps(data[DIMM_MIN_CC_AT_MAX_CAS_MINUS1]);
 
     /* Minimum Cycle Time At Max CasLatancy Minus 2*/
-    pDimmInfo->minCycleTimeAtMaxCasLatMinus2Ps = 
+    pDimmInfo->minCycleTimeAtMaxCasLatMinus2Ps =
                                     cas2ps(data[DIMM_MIN_CC_AT_MAX_CAS_MINUS2]);
 
     pDimmInfo->minRowPrechargeTime = data[DIMM_MIN_ROW_PRECHARGE_TIME];
-    DB(mvOsPrintf("DRAM minRowPrechargeTime[27]     0x%x\n", 
+    DB(mvOsPrintf("DRAM minRowPrechargeTime[27]     0x%x\n",
                                                pDimmInfo->minRowPrechargeTime));
     pDimmInfo->minRowActiveToRowActive = data[DIMM_MIN_ROW_ACTIVE_TO_ROW_ACTIVE];
-    DB(mvOsPrintf("DRAM minRowActiveToRowActive[28] 0x%x\n", 
+    DB(mvOsPrintf("DRAM minRowActiveToRowActive[28] 0x%x\n",
                                            pDimmInfo->minRowActiveToRowActive));
     pDimmInfo->minRasToCasDelay = data[DIMM_MIN_RAS_TO_CAS_DELAY];
-    DB(mvOsPrintf("DRAM minRasToCasDelay[29]        0x%x\n", 
+    DB(mvOsPrintf("DRAM minRasToCasDelay[29]        0x%x\n",
                                                   pDimmInfo->minRasToCasDelay));
     pDimmInfo->minRasPulseWidth = data[DIMM_MIN_RAS_PULSE_WIDTH];
-    DB(mvOsPrintf("DRAM minRasPulseWidth[30]        0x%x\n", 
+    DB(mvOsPrintf("DRAM minRasPulseWidth[30]        0x%x\n",
                                                   pDimmInfo->minRasPulseWidth));
-        
+
     /* DIMM Bank Density */
     pDimmInfo->dimmBankDensity = data[DIMM_BANK_DENSITY];
-    DB(mvOsPrintf("DRAM dimmBankDensity[31]         0x%x\n", 
+    DB(mvOsPrintf("DRAM dimmBankDensity[31]         0x%x\n",
                                                    pDimmInfo->dimmBankDensity));
 
     /* Only DDR2 includes Write Recovery Time field. Other SDRAM ignore     */
     pDimmInfo->minWriteRecoveryTime = data[DIMM_MIN_WRITE_RECOVERY_TIME];
-    DB(mvOsPrintf("DRAM minWriteRecoveryTime[36]    0x%x\n", 
+    DB(mvOsPrintf("DRAM minWriteRecoveryTime[36]    0x%x\n",
                                               pDimmInfo->minWriteRecoveryTime));
-    
+
     /* Only DDR2 includes Internal Write To Read Command Delay field.       */
     pDimmInfo->minWriteToReadCmdDelay = data[DIMM_MIN_WRITE_TO_READ_CMD_DELAY];
-    DB(mvOsPrintf("DRAM minWriteToReadCmdDelay[37]  0x%x\n", 
+    DB(mvOsPrintf("DRAM minWriteToReadCmdDelay[37]  0x%x\n",
                                             pDimmInfo->minWriteToReadCmdDelay));
-    
+
     /* Only DDR2 includes Internal Read To Precharge Command Delay field.   */
     pDimmInfo->minReadToPrechCmdDelay = data[DIMM_MIN_READ_TO_PRECH_CMD_DELAY];
-    DB(mvOsPrintf("DRAM minReadToPrechCmdDelay[38]  0x%x\n",    
+    DB(mvOsPrintf("DRAM minReadToPrechCmdDelay[38]  0x%x\n",
                                             pDimmInfo->minReadToPrechCmdDelay));
-    
+
     /* Only DDR2 includes Minimum Refresh to Activate/Refresh Command field */
     pDimmInfo->minRefreshToActiveCmd = data[DIMM_MIN_REFRESH_TO_ACTIVATE_CMD];
-    DB(mvOsPrintf("DRAM minRefreshToActiveCmd[42]   0x%x\n", 
+    DB(mvOsPrintf("DRAM minRefreshToActiveCmd[42]   0x%x\n",
                                              pDimmInfo->minRefreshToActiveCmd));
-                 
+
     /* calculating the sdram density. Representing device density from      */
     /* bit 20 to allow representation of 4GB and above.                     */
     /* For example, if density is 512Mbit 0x20000000, will be represent in  */
     /* deviceDensity by 0x20000000 >> 16 --> 0x00000200. Another example    */
     /* is density 8GB 0x200000000 >> 16 --> 0x00002000.                     */
     density = (1 << ((pDimmInfo->numOfRowAddr + pDimmInfo->numOfColAddr) - 20));
-    pDimmInfo->deviceDensity = density * 
-                                pDimmInfo->numOfBanksOnEachDevice * 
+    pDimmInfo->deviceDensity = density *
+                                pDimmInfo->numOfBanksOnEachDevice *
                                 pDimmInfo->sdramWidth;
     DB(mvOsPrintf("DRAM deviceDensity           %d\n",pDimmInfo->deviceDensity));
-    
+
     /* Number of devices includeing Error correction */
-    pDimmInfo->numberOfDevices = (pDimmInfo->dataWidth/pDimmInfo->sdramWidth) * 
+    pDimmInfo->numberOfDevices = (pDimmInfo->dataWidth/pDimmInfo->sdramWidth) *
                                   pDimmInfo->numOfModuleBanks;
-    DB(mvOsPrintf("DRAM numberOfDevices         %d\n",  
+    DB(mvOsPrintf("DRAM numberOfDevices         %d\n",
                                                    pDimmInfo->numberOfDevices));
 
-    pDimmInfo->size = 0; 
+    pDimmInfo->size = 0;
 
     /* Note that pDimmInfo->size is in MB units */
     if (pDimmInfo->memoryType == MEM_TYPE_SDRAM)
@@ -569,9 +569,9 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
             pDimmInfo->size += 64;                  /* Equal to 64MB    */
         else if (pDimmInfo->dimmBankDensity & BIT5)
             pDimmInfo->size += 128;                 /* Equal to 128MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT6) 
+        else if (pDimmInfo->dimmBankDensity & BIT6)
             pDimmInfo->size += 256;                 /* Equal to 256MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT7) 
+        else if (pDimmInfo->dimmBankDensity & BIT7)
             pDimmInfo->size += 512;                 /* Equal to 512MB   */
     }
     else if (pDimmInfo->memoryType == MEM_TYPE_DDR1)
@@ -588,9 +588,9 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
             pDimmInfo->size += 64;                  /* Equal to 64MB    */
         else if (pDimmInfo->dimmBankDensity & BIT5)
             pDimmInfo->size += 128;                 /* Equal to 128MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT6) 
+        else if (pDimmInfo->dimmBankDensity & BIT6)
             pDimmInfo->size += 256;                 /* Equal to 256MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT7) 
+        else if (pDimmInfo->dimmBankDensity & BIT7)
             pDimmInfo->size += 512;                 /* Equal to 512MB   */
     }
     else /* if (dimmInfo.memoryType == MEM_TYPE_DDR2) */
@@ -607,12 +607,12 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
             pDimmInfo->size += 16384;               /* Equal to 16GB    */
         else if (pDimmInfo->dimmBankDensity & BIT5)
             pDimmInfo->size += 128;                 /* Equal to 128MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT6) 
+        else if (pDimmInfo->dimmBankDensity & BIT6)
             pDimmInfo->size += 256;                 /* Equal to 256MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT7) 
+        else if (pDimmInfo->dimmBankDensity & BIT7)
             pDimmInfo->size += 512;                 /* Equal to 512MB   */
     }
-    
+
     pDimmInfo->size *= pDimmInfo->numOfModuleBanks;
 
     DB(mvOsPrintf("Dram: dimm size    %dMB \n",pDimmInfo->size));
@@ -649,7 +649,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
     busClkPs = 1000000000 / (mvBoardSysClkGet() / 100);  /* in 10 ps units */
 
     spdRawData = dimmInfo.spdRawData;
-    
+
     if(MV_OK != dimmSpdGet(dimmNum, &dimmInfo))
     {
         mvOsOutput("ERROR: Could not read SPD information!\n");
@@ -683,20 +683,20 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
     {
     	temp |= spdRawData[95+i] << 8*i;
     }
-    mvOsOutput("DIMM Serial No.                 %ld (%lx)\n", (long)temp, 
+    mvOsOutput("DIMM Serial No.                 %ld (%lx)\n", (long)temp,
                                     (long)temp);
 
     /* find Manufac-Data of Dimm Module */
-    mvOsOutput("Manufactoring Date:             Year 20%d%d/ ww %d%d\n", 
-                        ((spdRawData[93] & 0xf0) >> 4), (spdRawData[93] & 0xf), 
-                        ((spdRawData[94] & 0xf0) >> 4), (spdRawData[94] & 0xf)); 
+    mvOsOutput("Manufactoring Date:             Year 20%d%d/ ww %d%d\n",
+                        ((spdRawData[93] & 0xf0) >> 4), (spdRawData[93] & 0xf),
+                        ((spdRawData[94] & 0xf0) >> 4), (spdRawData[94] & 0xf));
     /* find modul_revision of Dimm Module */
-    mvOsOutput("Module Revision:                %d.%d\n", 
-                                                spdRawData[91], spdRawData[92]); 
+    mvOsOutput("Module Revision:                %d.%d\n",
+                                                spdRawData[91], spdRawData[92]);
 
     /* find manufac_place of Dimm Module */
     mvOsOutput("manufac_place:                  %d\n", spdRawData[72]);
-    
+
     /* go over the first 35 I2C data bytes */
     for(i = 2 ; i <= 35 ; i++)
        switch(i)
@@ -714,29 +714,29 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
 /*----------------------------------------------------------------------------*/
 
             case 3:  /* Number Of Row Addresses */
-                mvOsOutput("Module Number of row addresses: %d\n", 
+                mvOsOutput("Module Number of row addresses: %d\n",
                                                         dimmInfo.numOfRowAddr);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 4:  /* Number Of Column Addresses */
-                mvOsOutput("Module Number of col addresses: %d\n", 
+                mvOsOutput("Module Number of col addresses: %d\n",
                                                         dimmInfo.numOfColAddr);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 5:  /* Number Of Module Banks */
-                mvOsOutput("Number of Banks on Mod.:        %d\n",  
+                mvOsOutput("Number of Banks on Mod.:        %d\n",
                                                     dimmInfo.numOfModuleBanks);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 6:  /* Data Width */
-                mvOsOutput("Module Data Width:              %d bit\n",  
+                mvOsOutput("Module Data Width:              %d bit\n",
                                                            dimmInfo.dataWidth);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 8:  /* Voltage Interface */
                 switch(spdRawData[i])
                 {
@@ -767,11 +767,11 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 9:  /* Minimum Cycle Time At Max CasLatancy */
                 leftOfPoint = (spdRawData[i] & 0xf0) >> 4;
                 rightOfPoint = (spdRawData[i] & 0x0f) * 10;
-                
+
                 /* DDR2 addition of right of point */
                 if ((spdRawData[i] & 0x0f) == 0xA)
                 {
@@ -793,10 +793,10 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 10: /* Clock To Data Out */
                 div = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 10:100;
-                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                 leftOfPoint     = time_tmp / div;
                 rightOfPoint    = time_tmp % div;
@@ -804,27 +804,27 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 11: /* Error Check Type */
-                mvOsOutput("Error Check Type (0=NONE):      %d\n", 
+                mvOsOutput("Error Check Type (0=NONE):      %d\n",
                                                       dimmInfo.errorCheckType);
                 break;
 /*----------------------------------------------------------------------------*/
 
             case 12: /* Refresh Interval */
-                mvOsOutput("Refresh Rate:                   %x\n", 
+                mvOsOutput("Refresh Rate:                   %x\n",
                                                      dimmInfo.refreshInterval);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 13: /* Sdram Width */
-                mvOsOutput("Sdram Width:                    %d bits\n",     
+                mvOsOutput("Sdram Width:                    %d bits\n",
                                                           dimmInfo.sdramWidth);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 14: /* Error Check Data Width */
-                mvOsOutput("Error Check Data Width:         %d bits\n", 
+                mvOsOutput("Error Check Data Width:         %d bits\n",
                                                  dimmInfo.errorCheckDataWidth);
                 break;
 /*----------------------------------------------------------------------------*/
@@ -833,25 +833,25 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 if ((dimmInfo.memoryType == MEM_TYPE_SDRAM) ||
                     (dimmInfo.memoryType == MEM_TYPE_DDR1))
                 {
-                    mvOsOutput("Minimum Clk Delay back to back: %d\n", 
+                    mvOsOutput("Minimum Clk Delay back to back: %d\n",
                                                                 spdRawData[i]);
                 }
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 16: /* Burst Length Supported */
     /*     SDRAM/DDR1:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  * 
-                    *********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  *
+                    *********************************************************/
     /*     DDR2:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  * 
-                    *********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  *
+                    *********************************************************/
                 mvOsOutput("Burst Length Supported: ");
                 if ((dimmInfo.memoryType == MEM_TYPE_SDRAM) ||
                     (dimmInfo.memoryType == MEM_TYPE_DDR1))
@@ -863,40 +863,40 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 if (dimmInfo.burstLengthSupported & BIT2)
                     mvOsOutput("4, ");
-                if (dimmInfo.burstLengthSupported & BIT3) 
+                if (dimmInfo.burstLengthSupported & BIT3)
                     mvOsOutput("8, ");
-                
+
                 mvOsOutput(" Bit \n");
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 17: /* Number Of Banks On Each Device */
-                mvOsOutput("Number Of Banks On Each Chip:   %d\n",  
+                mvOsOutput("Number Of Banks On Each Chip:   %d\n",
                                               dimmInfo.numOfBanksOnEachDevice);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 18: /* Suported Cas Latencies */
-                   
+
             /*      SDRAM:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-            CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  * 
-                    ********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+            CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  *
+                    ********************************************************/
 
             /*     DDR 1:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-            CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  * 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+            CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  *
                     *********************************************************/
 
             /*     DDR 2:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-            CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  * 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+            CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  *
                     *********************************************************/
 
                 mvOsOutput("Suported Cas Latencies: (CL) 			");
@@ -932,14 +932,14 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                     if (dimmInfo.suportedCasLatencies & BIT4)
                         mvOsOutput("4, ");
                     if (dimmInfo.suportedCasLatencies & BIT5)
-                        mvOsOutput("5, ");		
+                        mvOsOutput("5, ");
                 }
                 else
-                    mvOsOutput("?.?, ");		
+                    mvOsOutput("?.?, ");
                 mvOsOutput("\n");
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 20:   /* DDR2 DIMM type info */
                 if (dimmInfo.memoryType == MEM_TYPE_DDR2)
                 {
@@ -947,16 +947,16 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput("Registered DIMM (RDIMM)\n");
                     else if (dimmInfo.dimmTypeInfo & (BIT1 | BIT5))
                         mvOsOutput("Unbuffered DIMM (UDIMM)\n");
-                    else 
+                    else
                         mvOsOutput("Unknown DIMM type.\n");
                 }
 
                 break;
 /*----------------------------------------------------------------------------*/
-   
+
             case 21: /* SDRAM Modules Attributes */
                 mvOsOutput("\nModule Attributes (SPD Byte 21): \n");
-                
+
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
                     if (dimmInfo.dimmAttributes & BIT0)
@@ -968,7 +968,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput(" Registered Addr/Control Input: Yes\n");
                     else
                         mvOsOutput(" Registered Addr/Control Input: No\n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT2)
                         mvOsOutput(" On-Card PLL (clock):           Yes \n");
                     else
@@ -978,17 +978,17 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput(" Bufferd DQMB Input:            Yes \n");
                     else
                         mvOsOutput(" Bufferd DQMB Inputs:           No \n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT4)
                         mvOsOutput(" Registered DQMB Inputs:        Yes \n");
                     else
                         mvOsOutput(" Registered DQMB Inputs:        No \n");
- 
+
                     if (dimmInfo.dimmAttributes & BIT5)
                         mvOsOutput(" Differential Clock Input:      Yes \n");
                     else
                         mvOsOutput(" Differential Clock Input:      No \n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT6)
                         mvOsOutput(" redundant Row Addressing:      Yes \n");
                     else
@@ -998,24 +998,24 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 {
                     if (dimmInfo.dimmAttributes & BIT0)
                         mvOsOutput(" Buffered Addr/Control Input:   Yes\n");
-                    else 
+                    else
                         mvOsOutput(" Buffered Addr/Control Input:   No\n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT1)
                         mvOsOutput(" Registered Addr/Control Input: Yes\n");
                     else
                         mvOsOutput(" Registered Addr/Control Input: No\n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT2)
                         mvOsOutput(" On-Card PLL (clock):           Yes \n");
                     else
                         mvOsOutput(" On-Card PLL (clock):           No \n");
-            
+
                     if (dimmInfo.dimmAttributes & BIT3)
                         mvOsOutput(" FET Switch On-Card Enabled:    Yes \n");
                     else
                         mvOsOutput(" FET Switch On-Card Enabled:    No \n");
-                    
+
                     if (dimmInfo.dimmAttributes & BIT4)
                         mvOsOutput(" FET Switch External Enabled:   Yes \n");
                     else
@@ -1028,12 +1028,12 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* if (dimmInfo.memoryType == MEM_TYPE_DDR2) */
                 {
-                    mvOsOutput(" Number of Active Registers on the DIMM: %d\n", 
+                    mvOsOutput(" Number of Active Registers on the DIMM: %d\n",
                                         (dimmInfo.dimmAttributes & 0x3) + 1);
-            
-                    mvOsOutput(" Number of PLLs on the DIMM: %d\n", 
+
+                    mvOsOutput(" Number of PLLs on the DIMM: %d\n",
                                       ((dimmInfo.dimmAttributes) >> 2) & 0x3);
-               
+
                     if (dimmInfo.dimmAttributes & BIT4)
                         mvOsOutput(" FET Switch External Enabled:   Yes \n");
                     else
@@ -1044,7 +1044,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                     else
                         mvOsOutput(" Analysis probe installed:      No \n");
                 }
-                
+
                 break;
 /*----------------------------------------------------------------------------*/
 
@@ -1056,28 +1056,28 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput(" Early Ras Precharge:           Yes \n");
                     else
                         mvOsOutput(" Early Ras Precharge:           No \n");
-                                                        
-                    if ( spdRawData[i] & BIT1 )                 
+
+                    if ( spdRawData[i] & BIT1 )
                         mvOsOutput(" AutoPreCharge:                 Yes \n");
                     else
                         mvOsOutput(" AutoPreCharge:                 No \n");
-                                                            
-                    if ( spdRawData[i] & BIT2 )                 
+
+                    if ( spdRawData[i] & BIT2 )
                         mvOsOutput(" Precharge All:                 Yes \n");
                     else
                         mvOsOutput(" Precharge All:                 No \n");
-                                                        
-                    if ( spdRawData[i] & BIT3 )                 
+
+                    if ( spdRawData[i] & BIT3 )
                         mvOsOutput(" Write 1/ReadBurst:             Yes \n");
                     else
                         mvOsOutput(" Write 1/ReadBurst:             No \n");
-                                                        
-                    if ( spdRawData[i] & BIT4 )                 
+
+                    if ( spdRawData[i] & BIT4 )
                         mvOsOutput(" lower VCC tolerance:           5%%\n");
                     else
                         mvOsOutput(" lower VCC tolerance:           10%%\n");
-                                                        
-                    if ( spdRawData[i] & BIT5 )                 
+
+                    if ( spdRawData[i] & BIT5 )
                         mvOsOutput(" upper VCC tolerance:           5%%\n");
                     else
                         mvOsOutput(" upper VCC tolerance:           10%%\n");
@@ -1091,7 +1091,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
 
                     if ( !(spdRawData[i] & BIT4) )
                         mvOsOutput(" lower VCC tolerance:           0.2V\n");
-   
+
                     if ( !(spdRawData[i] & BIT5) )
                         mvOsOutput(" upper VCC tolerance:           0.2V\n");
 
@@ -1114,12 +1114,12 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 23:
             /* Minimum Cycle Time At Maximum Cas Latancy Minus 1 (2nd highest CL) */
                 leftOfPoint = (spdRawData[i] & 0xf0) >> 4;
                 rightOfPoint = (spdRawData[i] & 0x0f) * 10;
-                
+
                 /* DDR2 addition of right of point */
                 if ((spdRawData[i] & 0x0f) == 0xA)
                 {
@@ -1143,10 +1143,10 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                            leftOfPoint, rightOfPoint );
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 24: /* Clock To Data Out 2nd highest Cas Latency Value*/
                 div = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 10:100;
-                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                     ((spdRawData[i] & 0x0f));
                 leftOfPoint     = time_tmp / div;
                 rightOfPoint    = time_tmp % div;
@@ -1154,19 +1154,19 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
-            case 25: 
+
+            case 25:
             /* Minimum Cycle Time At Maximum Cas Latancy Minus 2 (3rd highest CL) */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
                     leftOfPoint = (spdRawData[i] & 0xfc) >> 2;
                     rightOfPoint = (spdRawData[i] & 0x3) * 25;
                 }
-                else    /* DDR1 or DDR2 */ 
+                else    /* DDR1 or DDR2 */
                 {
                     leftOfPoint = (spdRawData[i] & 0xf0) >> 4;
                     rightOfPoint = (spdRawData[i] & 0x0f) * 10;
-                    
+
                     /* DDR2 addition of right of point */
                     if ((spdRawData[i] & 0x0f) == 0xA)
                     {
@@ -1185,21 +1185,21 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         rightOfPoint = 75;
                     }
                 }
-                mvOsOutput("Minimum Cycle Time At 3rd highest CasLatancy" 
+                mvOsOutput("Minimum Cycle Time At 3rd highest CasLatancy"
                            "(0 = Not supported): %d.%d [ns]\n",
                            leftOfPoint, rightOfPoint );
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 26: /* Clock To Data Out 3rd highest Cas Latency Value*/
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
                     leftOfPoint = (spdRawData[i] & 0xfc) >> 2;
                     rightOfPoint = (spdRawData[i] & 0x3) * 25;
                 }
-                else    /* DDR1 or DDR2 */ 
+                else    /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint     = 0;
                     rightOfPoint    = time_tmp;
@@ -1208,62 +1208,62 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                                                   leftOfPoint, rightOfPoint );
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 27: /* Minimum Row Precharge Time */
                 shift = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 0:2;
-                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0xff : 0xfc;
-                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0x00 : 0x03;
                 leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> shift);
                 rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;
                 temp = ((leftOfPoint*100) + rightOfPoint);/* in 10ps Intervals*/
-                trp_clocks = (temp + (busClkPs-1)) /  busClkPs;    
-                mvOsOutput("Minimum Row Precharge Time [ns]: 		%d.%d = " 
-                           "in Clk cycles %d\n", 
+                trp_clocks = (temp + (busClkPs-1)) /  busClkPs;
+                mvOsOutput("Minimum Row Precharge Time [ns]: 		%d.%d = "
+                           "in Clk cycles %d\n",
                            leftOfPoint, rightOfPoint, trp_clocks);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 28: /* Minimum Row Active to Row Active Time */
                 shift = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 0:2;
-                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0xff : 0xfc;
-                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0x00 : 0x03;
                 leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> shift);
                 rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;
                 temp = ((leftOfPoint*100) + rightOfPoint);/* in 100ns Interval*/
                 trrd_clocks = (temp + (busClkPs-1)) / busClkPs;
-                mvOsOutput("Minimum Row Active -To- Row Active Delay [ns]: " 
+                mvOsOutput("Minimum Row Active -To- Row Active Delay [ns]: "
                            "%d.%d = in Clk cycles %d\n",
                             leftOfPoint, rightOfPoint, trp_clocks);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 29: /* Minimum Ras-To-Cas Delay */
                 shift = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 0:2;
-                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0xff : 0xfc;
-                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0x00 : 0x03;
                 leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> shift);
-                rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;  
+                rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;
                 temp = ((leftOfPoint*100) + rightOfPoint);/* in 100ns Interval*/
                 trcd_clocks = (temp + (busClkPs-1) )/ busClkPs;
                 mvOsOutput("Minimum Ras-To-Cas Delay [ns]: 			%d.%d = "
-                           "in Clk cycles %d\n", 
+                           "in Clk cycles %d\n",
                            leftOfPoint, rightOfPoint, trp_clocks);
                 break;
 /*----------------------------------------------------------------------------*/
-   
+
             case 30: /* Minimum Ras Pulse Width */
                 tras_clocks = (cas2ps(spdRawData[i])+(busClkPs-1)) / busClkPs;
                 mvOsOutput("Minimum Ras Pulse Width [ns]: 			%d = "
                            "in Clk cycles %d\n", spdRawData[i], tras_clocks);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 31: /* Module Bank Density */
                 mvOsOutput("Module Bank Density (more than 1= Multisize-Module):");
 
@@ -1281,9 +1281,9 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput("64MB, ");
                     if (dimmInfo.dimmBankDensity & BIT5)
                         mvOsOutput("128MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT6) 
+                    if (dimmInfo.dimmBankDensity & BIT6)
                         mvOsOutput("256MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT7) 
+                    if (dimmInfo.dimmBankDensity & BIT7)
                         mvOsOutput("512MB, ");
                 }
                 else if (dimmInfo.memoryType == MEM_TYPE_DDR1)
@@ -1300,9 +1300,9 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput("64MB, ");
                     if (dimmInfo.dimmBankDensity & BIT5)
                         mvOsOutput("128MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT6) 
+                    if (dimmInfo.dimmBankDensity & BIT6)
                         mvOsOutput("256MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT7) 
+                    if (dimmInfo.dimmBankDensity & BIT7)
                         mvOsOutput("512MB, ");
                 }
                 else /* if (dimmInfo.memoryType == MEM_TYPE_DDR2) */
@@ -1319,15 +1319,15 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput("16GB, ");
                     if (dimmInfo.dimmBankDensity & BIT5)
                     mvOsOutput("128MB, ");
-                        if (dimmInfo.dimmBankDensity & BIT6) 
+                        if (dimmInfo.dimmBankDensity & BIT6)
                     mvOsOutput("256MB, ");
-                        if (dimmInfo.dimmBankDensity & BIT7) 
+                        if (dimmInfo.dimmBankDensity & BIT7)
                     mvOsOutput("512MB, ");
                 }
                 mvOsOutput("\n");
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 32: /* Address And Command Setup Time (measured in ns/1000) */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
@@ -1340,16 +1340,16 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100; 
+                    rightOfPoint = time_tmp % 100;
                 }
                 mvOsOutput("Address And Command Setup Time [ns]: 		%d.%d\n",
                                                      leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 33: /* Address And Command Hold Time */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
@@ -1362,16 +1362,16 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100;                 
+                    rightOfPoint = time_tmp % 100;
                 }
                 mvOsOutput("Address And Command Hold Time [ns]: 		%d.%d\n",
                                                    leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 34: /* Data Input Setup Time */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
@@ -1384,16 +1384,16 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100;                 
+                    rightOfPoint = time_tmp % 100;
                 }
-                mvOsOutput("Data Input Setup Time [ns]: 			%d.%d\n", 
+                mvOsOutput("Data Input Setup Time [ns]: 			%d.%d\n",
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 35: /* Data Input Hold Time */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
@@ -1406,25 +1406,25 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100;                 
+                    rightOfPoint = time_tmp % 100;
                 }
-                mvOsOutput("Data Input Hold Time [ns]: 			%d.%d\n\n", 
+                mvOsOutput("Data Input Hold Time [ns]: 			%d.%d\n\n",
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 36: /* Relevant for DDR2 only: Write Recovery Time */
                 leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> 2);
-                rightOfPoint = (spdRawData[i] & maskRightOfPoint) * 25;  
-                mvOsOutput("Write Recovery Time [ns]: 			%d.%d\n", 
+                rightOfPoint = (spdRawData[i] & maskRightOfPoint) * 25;
+                mvOsOutput("Write Recovery Time [ns]: 			%d.%d\n",
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
         }
-    
+
 }
 
 
@@ -1452,12 +1452,12 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
 static MV_U32  cas2ps(MV_U8 spd_byte)
 {
     MV_U32 ns, ns10;
-    
+
     /* isolate upper nibble */
     ns = (spd_byte >> 4) & 0x0F;
     /* isolate lower nibble */
     ns10 = (spd_byte & 0x0F);
-    
+
     if( ns10 < 10 ) {
         ns10 *= 10;
     }
@@ -1469,11 +1469,11 @@ static MV_U32  cas2ps(MV_U8 spd_byte)
         ns10 = 66;
     else if( ns10 == 13 )
         ns10 = 75;
-    else 
+    else
     {
         mvOsOutput("cas2ps Err. unsupported cycle time.\n");
     }
-    
+
     return (ns*1000 + ns10*10);
 }
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.h
index 678e224..584cdd5 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -105,10 +105,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define DIMM_MEM_TYPE_SDRAM					0x4
 #define DIMM_MEM_TYPE_DDR1 					0x7
 #define DIMM_MEM_TYPE_DDR2 					0x8
-        
+
 #define DIMM_MODULE_MANU_OFFS 		64
 #define DIMM_MODULE_MANU_SIZE 		8
-#define DIMM_MODULE_VEN_OFFS 		73 
+#define DIMM_MODULE_VEN_OFFS 		73
 #define DIMM_MODULE_VEN_SIZE 		25
 #define DIMM_MODULE_ID_OFFS 		99
 #define DIMM_MODULE_ID_SIZE 		18
@@ -116,30 +116,30 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* enumeration for voltage levels. */
 typedef enum _mvDimmVoltageIf
 {
-    TTL_5V_TOLERANT, 
-    LVTTL, 
-    HSTL_1_5V, 
-    SSTL_3_3V, 
-    SSTL_2_5V, 
-    VOLTAGE_UNKNOWN, 
+    TTL_5V_TOLERANT,
+    LVTTL,
+    HSTL_1_5V,
+    SSTL_3_3V,
+    SSTL_2_5V,
+    VOLTAGE_UNKNOWN,
 } MV_DIMM_VOLTAGE_IF;
 
 
 /* enumaration for SDRAM CAS Latencies. */
 typedef enum _mvDimmSdramCas
 {
-    SD_CL_1 =1,  
-    SD_CL_2,  
-    SD_CL_3, 
-    SD_CL_4, 
-    SD_CL_5, 
-    SD_CL_6, 
-    SD_CL_7, 
+    SD_CL_1 =1,
+    SD_CL_2,
+    SD_CL_3,
+    SD_CL_4,
+    SD_CL_5,
+    SD_CL_6,
+    SD_CL_7,
     SD_FAULT
 }MV_DIMM_SDRAM_CAS;
 
 
-/* DIMM information structure */                                                    
+/* DIMM information structure */
 typedef struct _mvDimmInfo
 {
     MV_MEMORY_TYPE  memoryType; 	/* DDR or SDRAM */
@@ -163,7 +163,7 @@ typedef struct _mvDimmInfo
     MV_U32  dimmAttributes;
 
     /* DIMM timing parameters */
-    MV_U32  minCycleTimeAtMaxCasLatPs;	
+    MV_U32  minCycleTimeAtMaxCasLatPs;
     MV_U32  minCycleTimeAtMaxCasLatMinus1Ps;
     MV_U32  minCycleTimeAtMaxCasLatMinus2Ps;
 	MV_U32  minRowPrechargeTime;
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c
index 12fb26a..569ee43 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -92,33 +92,33 @@ static MV_U32 sdramModeRegCalc(MV_U32 minCas);
 static MV_U32 sdramExtModeRegCalc(MV_DRAM_BANK_INFO *pBankInfo);
 static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo);
 static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk);
-static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk, 
+static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk,
 						 MV_U32 forcedCl);
-static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, 
+static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 									  MV_U32 minCas, MV_U32 busClk);
-static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, 
+static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 									   MV_U32 busClk);
 
 /*******************************************************************************
 * mvDramIfDetect - Prepare DRAM interface configuration values.
 *
 * DESCRIPTION:
-*       This function implements the full DRAM detection and timing 
+*       This function implements the full DRAM detection and timing
 *       configuration for best system performance.
-*       Since this routine runs from a ROM device (Boot Flash), its stack 
-*       resides on RAM, that might be the system DRAM. Changing DRAM 
+*       Since this routine runs from a ROM device (Boot Flash), its stack
+*       resides on RAM, that might be the system DRAM. Changing DRAM
 *       configuration values while keeping vital data in DRAM is risky. That
-*       is why the function does not preform the configuration setting but 
-*       prepare those in predefined 32bit registers (in this case IDMA 
+*       is why the function does not preform the configuration setting but
+*       prepare those in predefined 32bit registers (in this case IDMA
 *       registers are used) for other routine to perform the settings.
-*       The function will call for board DRAM SPD information for each DRAM 
-*       chip select. The function will then analyze those SPD parameters of 
-*       all DRAM banks in order to decide on DRAM configuration compatible 
+*       The function will call for board DRAM SPD information for each DRAM
+*       chip select. The function will then analyze those SPD parameters of
+*       all DRAM banks in order to decide on DRAM configuration compatible
 *       for all DRAM banks.
 *       The function will set the CPU DRAM address decode registers.
 *       Note: This routine prepares values that will overide configuration of
 *       mvDramBasicAsmInit().
-*       
+*
 * INPUT:
 *       forcedCl - Forced CAL Latency. If equal to zero, do not force.
 *
@@ -140,13 +140,13 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 	dramDecWin.addrWin.baseHigh = 0;
 
 	busClk = mvBoardSysClkGet();
-	
+
 	if (0 == busClk)
 	{
 		mvOsPrintf("Dram: ERR. Can't detect system clock! \n");
 		return MV_ERROR;
 	}
-	
+
 	/* Close DRAM banks except bank 0 (in case code is excecuting from it...) */
 #if defined(MV_INCLUDE_SDRAM_CS1)
 	for(i= SDRAM_CS1; i < MV_DRAM_MAX_CS; i++)
@@ -154,9 +154,9 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 #endif
 
 	/* we will use bank 0 as the representative of the all the DRAM banks,  */
-	/* since bank 0 must exist.                                             */	
+	/* since bank 0 must exist.                                             */
 	for(i = 0; i < MV_DRAM_MAX_CS; i++)
-	{ 
+	{
 		/* if Bank exist */
 		if(MV_OK == mvDramBankInfoGet(i, &bankInfo[i]))
 		{
@@ -167,7 +167,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 				return MV_ERROR;
 			}
 			/* All banks must support registry in order to activate it */
-			if(bankInfo[i].registeredAddrAndControlInputs != 
+			if(bankInfo[i].registeredAddrAndControlInputs !=
 			   bankInfo[0].registeredAddrAndControlInputs)
 			{
 				mvOsPrintf("Dram: ERR. different Registered settings !!!\n");
@@ -178,10 +178,10 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 			/* Note that the size in Bank info is in MB units 			*/
 			/* Note that the Dimm width might be different then the device DRAM width */
 			temp = MV_REG_READ(SDRAM_CONFIG_REG);
-			
+
 			deviceW = ((temp & SDRAM_DWIDTH_MASK) == SDRAM_DWIDTH_16BIT )? 16 : 32;
 			dimmW = bankInfo[0].dataWidth - (bankInfo[0].dataWidth % 16);
-			size = ((bankInfo[i].size << 20) / (dimmW/deviceW)); 
+			size = ((bankInfo[i].size << 20) / (dimmW/deviceW));
 
 			/* We can not change DRAM window settings while excecuting  	*/
 			/* code from it. That is why we skip the DRAM CS[0], saving     */
@@ -189,7 +189,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 			if(i == SDRAM_CS0)
 			{
 				MV_U32 sizeToReg;
-				
+
 				/* Translate the given window size to register format */
 				sizeToReg = ctrlSizeToReg(size, SCSR_SIZE_ALIGNMENT);
 
@@ -200,7 +200,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 							   ,i);
 					return MV_BAD_PARAM;
 				}
-                
+
 				/* Size is located at upper 16 bits */
 				sizeToReg <<= SCSR_SIZE_OFFS;
 
@@ -214,15 +214,15 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 				dramDecWin.addrWin.baseLow = base;
 				dramDecWin.addrWin.size = size;
 				dramDecWin.enable = MV_TRUE;
-				
+
 				if (MV_OK != mvDramIfWinSet(SDRAM_CS0 + i, &dramDecWin))
 				{
-					mvOsPrintf("Dram: ERR. Fail to set bank %d!!!\n", 
+					mvOsPrintf("Dram: ERR. Fail to set bank %d!!!\n",
 							   SDRAM_CS0 + i);
 					return MV_ERROR;
 				}
 			}
-			
+
 			base += size;
 
 			/* update the suportedCasLatencies mask */
@@ -246,7 +246,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 
 	/* calculate minimum CAS */
 	minCas = minCasCalc(&bankInfo[0], busClk, forcedCl);
-	if (0 == minCas) 
+	if (0 == minCas)
 	{
 		mvOsOutput("Dram: Warn: Could not find CAS compatible to SysClk %dMhz\n",
 				   (busClk / 1000000));
@@ -272,7 +272,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 	}
 	MV_REG_WRITE(DRAM_BUF_REG1, temp);
 
-	/* calc SDRAM_MODE_REG  and save it to temp register */ 
+	/* calc SDRAM_MODE_REG  and save it to temp register */
 	temp = sdramModeRegCalc(minCas);
 	if(-1 == temp)
 	{
@@ -281,7 +281,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 	}
 	MV_REG_WRITE(DRAM_BUF_REG2, temp);
 
-	/* calc SDRAM_EXTENDED_MODE_REG  and save it to temp register */ 
+	/* calc SDRAM_EXTENDED_MODE_REG  and save it to temp register */
 	temp = sdramExtModeRegCalc(&bankInfo[0]);
 	if(-1 == temp)
 	{
@@ -291,13 +291,13 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 	MV_REG_WRITE(DRAM_BUF_REG10, temp);
 
 	/* calc D_UNIT_CONTROL_LOW  and save it to temp register */
-	temp = dunitCtrlLowRegCalc(&bankInfo[0], minCas); 
+	temp = dunitCtrlLowRegCalc(&bankInfo[0], minCas);
 	if(-1 == temp)
 	{
 		mvOsPrintf("Dram: ERR. dunitCtrlLowRegCalc failed !!!\n");
 		return MV_ERROR;
 	}
-	MV_REG_WRITE(DRAM_BUF_REG3, temp); 
+	MV_REG_WRITE(DRAM_BUF_REG3, temp);
 
 	/* calc SDRAM_ADDR_CTRL_REG  and save it to temp register */
 	temp = sdramAddrCtrlRegCalc(&bankInfo[0]);
@@ -331,7 +331,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 	{
 		sdramDDr2OdtConfig(bankInfo);
 	}
-	
+
 	/* Note that DDR SDRAM Address/Control and Data pad calibration     */
 	/* settings is done in mvSdramIfConfig.s                            */
 
@@ -357,34 +357,34 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl)
 *		supported by banks is incompatible with system bus clock frequancy.
 *
 *******************************************************************************/
-static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk, 
+static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk,
 						 MV_U32 forcedCl)
 {
 	MV_U32 count = 1, j;
 	MV_U32 busClkPs = 1000000000 / (busClk / 1000);  /* in ps units */
 	MV_U32 startBit, stopBit;
-	
+
 	/*     DDR 1:
-			*******-******-******-******-******-******-******-******* 
-			* bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-			*******-******-******-******-******-******-******-******* 
-	CAS	=	* TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  * 
+			*******-******-******-******-******-******-******-*******
+			* bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+			*******-******-******-******-******-******-******-*******
+	CAS	=	* TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  *
 			*********************************************************/
-	
+
 	/*     DDR 2:
-			*******-******-******-******-******-******-******-******* 
-			* bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-			*******-******-******-******-******-******-******-******* 
-	CAS	=	* TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  * 
+			*******-******-******-******-******-******-******-*******
+			* bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+			*******-******-******-******-******-******-******-*******
+	CAS	=	* TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  *
 			*********************************************************/
-	
-	
+
+
 	/* If we are asked to use the forced CAL */
 	if (forcedCl)
 	{
-		mvOsPrintf("DRAM: Using forced CL %d.%d\n", (forcedCl / 10), 
+		mvOsPrintf("DRAM: Using forced CL %d.%d\n", (forcedCl / 10),
 													(forcedCl % 10));
-	
+
 		if (MV_REG_READ(SDRAM_CONFIG_REG) & SDRAM_DTYPE_DDR2)
 		{
 			if (forcedCl == 30)
@@ -393,7 +393,7 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk,
 				pBankInfo->suportedCasLatencies = 0x10;
 			else
 			{
-				mvOsPrintf("Forced CL %d.%d not supported. Set default CL 4\n", 
+				mvOsPrintf("Forced CL %d.%d not supported. Set default CL 4\n",
 						   (forcedCl / 10), (forcedCl % 10));
 				pBankInfo->suportedCasLatencies = 0x10;
 			}
@@ -412,19 +412,19 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk,
 				pBankInfo->suportedCasLatencies = 0x40;
 			else
 			{
-				mvOsPrintf("Forced CL %d.%d not supported. Set default CL 3\n", 
+				mvOsPrintf("Forced CL %d.%d not supported. Set default CL 3\n",
 						   (forcedCl / 10), (forcedCl % 10));
 				pBankInfo->suportedCasLatencies = 0x10;
 			}
 		}
-	
-		return pBankInfo->suportedCasLatencies;        
-	}   
-	
+
+		return pBankInfo->suportedCasLatencies;
+	}
+
 	/* go over the supported cas mask from Max Cas down and check if the 	*/
 	/* SysClk stands in its time requirments.								*/
-	
-	
+
+
 	DB(mvOsPrintf("Dram: minCasCalc supported mask = %x busClkPs = %x \n",
 								pBankInfo->suportedCasLatencies,busClkPs ));
 	for(j = 7; j > 0; j--)
@@ -434,31 +434,31 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk,
 			/* Reset the bits for CL incompatible for the sysClk            */
 			switch (count)
 			{
-				case 1: 
-					if (pBankInfo->minCycleTimeAtMaxCasLatPs > busClkPs) 
+				case 1:
+					if (pBankInfo->minCycleTimeAtMaxCasLatPs > busClkPs)
 						pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
 					count++;
 					break;
-				case 2: 
+				case 2:
 					if (pBankInfo->minCycleTimeAtMaxCasLatMinus1Ps > busClkPs)
 						pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
 					count++;
 					break;
-				case 3: 
+				case 3:
 					if (pBankInfo->minCycleTimeAtMaxCasLatMinus2Ps > busClkPs)
 						pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
 					count++;
 					break;
-				default: 
+				default:
 					pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
 					break;
 			}
 		}
 	}
-	
+
 	DB(mvOsPrintf("Dram: minCasCalc support = %x (after SysCC calc)\n",
 				  pBankInfo->suportedCasLatencies ));
-	
+
 	/* SDRAM DDR1 controller supports CL 1.5 to 3.5 */
 	/* SDRAM DDR2 controller supports CL 3 to 5     */
 	if (MV_REG_READ(SDRAM_CONFIG_REG) & SDRAM_DTYPE_DDR2)
@@ -471,7 +471,7 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk,
 		startBit = 1;   /* DDR1 support CL start with CL1.5 (bit 3) */
 		stopBit  = 4;   /* DDR1 support CL stops with CL3 (bit 4)   */
 	}
-	
+
 	for(j = startBit; j <= stopBit ; j++)
 	{
 		if((pBankInfo->suportedCasLatencies >> j) & BIT0 )
@@ -480,8 +480,8 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk,
 			return (BIT0 << j);
 		}
 	}
-	
-	return 0; 
+
+	return 0;
 }
 
 /*******************************************************************************
@@ -504,11 +504,11 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
 {
 	MV_U32 sdramConfig = 0;
 	MV_U32 refreshPeriod;
-	
+
 	busClk /= 1000000; /* we work with busClk in MHz */
-	
+
 	sdramConfig = MV_REG_READ(SDRAM_CONFIG_REG);
-	
+
 	/* figure out the memory refresh internal */
 	switch (pBankInfo->refreshInterval & 0xf)
 	{
@@ -534,27 +534,27 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
 			mvOsPrintf("Dram: ERR. DRAM refresh period is unknown!\n");
 			return -1;
 	}
-	
+
 	/* Now the refreshPeriod is in register format value */
 	refreshPeriod = (busClk * refreshPeriod) / 1000;
-	
-	DB(mvOsPrintf("Dram: sdramConfigRegCalc calculated refresh interval %0x\n", 
+
+	DB(mvOsPrintf("Dram: sdramConfigRegCalc calculated refresh interval %0x\n",
 				  refreshPeriod));
 
 	/* make sure the refresh value is only 14 bits */
 	if(refreshPeriod > SDRAM_REFRESH_MAX)
 	{
 		refreshPeriod = SDRAM_REFRESH_MAX;
-		DB(mvOsPrintf("Dram: sdramConfigRegCalc adjusted refresh interval %0x\n", 
+		DB(mvOsPrintf("Dram: sdramConfigRegCalc adjusted refresh interval %0x\n",
 					  refreshPeriod));
 	}
-	
+
 	/* Clear the refresh field */
 	sdramConfig &= ~SDRAM_REFRESH_MASK;
-	
+
 	/* Set new value to refresh field */
 	sdramConfig |= (refreshPeriod & SDRAM_REFRESH_MASK);
-	
+
 	/*  registered DRAM ? */
 	if ( pBankInfo->registeredAddrAndControlInputs )
 	{
@@ -562,10 +562,10 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
 		sdramConfig |= SDRAM_REGISTERED;
 		mvOsPrintf("DRAM Attribute: Registered address and control inputs.\n");
 	}
-	
+
 	/* set DDR SDRAM devices configuration */
 	sdramConfig &= ~SDRAM_DCFG_MASK;    /* Clear Dcfg field */
-	
+
 	switch (pBankInfo->sdramWidth)
 	{
 		case 8:  /* memory is x8 */
@@ -583,11 +583,11 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
 
 	/* Set static default settings */
 	sdramConfig |= SDRAM_CONFIG_DV;
-	
+
 	DB(mvOsPrintf("Dram: sdramConfigRegCalc set sdramConfig to 0x%x\n",
 				  sdramConfig));
-	
-	return sdramConfig;  
+
+	return sdramConfig;
 }
 
 /*******************************************************************************
@@ -597,7 +597,7 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
 *			on the bank info parameters and the minCas.
 *
 * INPUT:
-*	minCas	  - minimum CAS supported. 
+*	minCas	  - minimum CAS supported.
 *
 * OUTPUT:
 *       None
@@ -609,27 +609,27 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
 static MV_U32 sdramModeRegCalc(MV_U32 minCas)
 {
 	MV_U32 sdramMode;
-		
+
 	sdramMode = MV_REG_READ(SDRAM_MODE_REG);
-	
+
 	/* Clear CAS Latency field */
 	sdramMode &= ~SDRAM_CL_MASK;
-	
+
 	mvOsPrintf("DRAM CAS Latency ");
-	
+
 	if (MV_REG_READ(SDRAM_CONFIG_REG) & SDRAM_DTYPE_DDR2)
-	{            	
+	{
 		switch (minCas)
 		{
-			case DDR2_CL_3: 
+			case DDR2_CL_3:
 				sdramMode |= SDRAM_DDR2_CL_3;
 				mvOsPrintf("3.\n");
 				break;
-			case DDR2_CL_4: 
+			case DDR2_CL_4:
 				sdramMode |= SDRAM_DDR2_CL_4;
 				mvOsPrintf("4.\n");
 				break;
-			case DDR2_CL_5: 
+			case DDR2_CL_5:
 				sdramMode |= SDRAM_DDR2_CL_5;
 				mvOsPrintf("5.\n");
 				break;
@@ -642,34 +642,34 @@ static MV_U32 sdramModeRegCalc(MV_U32 minCas)
 	else	/* DDR1 */
 	{
 		switch (minCas)
-		{			
-			case DDR1_CL_1_5: 
+		{
+			case DDR1_CL_1_5:
 				sdramMode |= SDRAM_DDR1_CL_1_5;
 				mvOsPrintf("1.5\n");
 				break;
-			case DDR1_CL_2: 
+			case DDR1_CL_2:
 				sdramMode |= SDRAM_DDR1_CL_2;
 				mvOsPrintf("2\n");
-				break;            
-			case DDR1_CL_2_5: 
+				break;
+			case DDR1_CL_2_5:
 				sdramMode |= SDRAM_DDR1_CL_2_5;
 				mvOsPrintf("2.5\n");
 				break;
-			case DDR1_CL_3: 
+			case DDR1_CL_3:
 				sdramMode |= SDRAM_DDR1_CL_3;
 				mvOsPrintf("3\n");
 				break;
-			case DDR1_CL_4: 
+			case DDR1_CL_4:
 				sdramMode |= SDRAM_DDR1_CL_4;
 				mvOsPrintf("4\n");
 				break;
 			default:
 				mvOsPrintf("\nsdramModeRegCalc ERROR: Max. CL out of range\n");
-				return -1;	
+				return -1;
 		}
-		sdramMode |= DDR1_MODE_REG_DV;		
+		sdramMode |= DDR1_MODE_REG_DV;
 	}
-	
+
 	DB(mvOsPrintf("nsdramModeRegCalc register 0x%x\n", sdramMode ));
 
 	return sdramMode;
@@ -678,7 +678,7 @@ static MV_U32 sdramModeRegCalc(MV_U32 minCas)
 /*******************************************************************************
 * sdramExtModeRegCalc - Calculate sdram Extended mode register
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *		Return sdram Extended mode register value based
 *		on the bank info parameters and bank presence.
 *
@@ -706,31 +706,31 @@ static MV_U32 sdramExtModeRegCalc(MV_DRAM_BANK_INFO *pBankInfo)
 				populateBanks |= (1 << bankNum);
 			}
 		}
-	
+
 		switch(populateBanks)
 		{
 			case(BANK_PRESENT_CS0):
 				return DDR_SDRAM_EXT_MODE_CS0_DV;
-		
+
 			case(BANK_PRESENT_CS0_CS1):
 				return DDR_SDRAM_EXT_MODE_CS0_DV;
-		
+
 			case(BANK_PRESENT_CS0_CS2):
 				return DDR_SDRAM_EXT_MODE_CS0_CS2_DV;
-		
+
 			case(BANK_PRESENT_CS0_CS1_CS2):
 				return DDR_SDRAM_EXT_MODE_CS0_CS2_DV;
-		
+
 			case(BANK_PRESENT_CS0_CS2_CS3):
 				return DDR_SDRAM_EXT_MODE_CS0_CS2_DV;
-		
+
 			case(BANK_PRESENT_CS0_CS2_CS3_CS4):
 				return DDR_SDRAM_EXT_MODE_CS0_CS2_DV;
-		
+
 			default:
 				mvOsPrintf("sdramExtModeRegCalc: Invalid DRAM bank presence\n");
 				return -1;
-		} 
+		}
 	}
 	return 0;
 }
@@ -743,7 +743,7 @@ static MV_U32 sdramExtModeRegCalc(MV_DRAM_BANK_INFO *pBankInfo)
 *
 * INPUT:
 *	pBankInfo - sdram bank parameters
-*	minCas	  - minimum CAS supported. 
+*	minCas	  - minimum CAS supported.
 *
 * OUTPUT:
 *       None
@@ -755,19 +755,19 @@ static MV_U32 sdramExtModeRegCalc(MV_DRAM_BANK_INFO *pBankInfo)
 static MV_U32 dunitCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas)
 {
 	MV_U32 dunitCtrlLow;
-	
+
 	dunitCtrlLow = MV_REG_READ(SDRAM_DUNIT_CTRL_REG);
-	
+
 	/* Clear StBurstDel field */
 	dunitCtrlLow &= ~SDRAM_ST_BURST_DEL_MASK;
-	
+
 #ifdef MV_88W8660
 	/* Clear address/control output timing field */
 	dunitCtrlLow &= ~SDRAM_CTRL_POS_RISE;
 #endif /* MV_88W8660 */
 
 	DB(mvOsPrintf("Dram: dunitCtrlLowRegCalc\n"));
-	
+
 	/* For proper sample of read data set the Dunit Control register's      */
 	/* stBurstDel bits [27:24]                                              */
 			/********-********-********-********-********-*********
@@ -777,27 +777,27 @@ Not Reg.	*  0011  |  0011  |  0100  |  0100  |  0101  |  TBD   *
 			*********-********-********-********-********-*********
 Registered	*  0100  |  0100  |  0101  |  0101  |  0110  |  TBD   *
 			*********-********-********-********-********-*********/
-    
+
 	if (MV_REG_READ(SDRAM_CONFIG_REG) & SDRAM_DTYPE_DDR2)
 	{
 		switch (minCas)
 		{
-			case DDR2_CL_3: 
+			case DDR2_CL_3:
 					/* registerd DDR SDRAM? */
-				if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE) 		
+				if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
 					dunitCtrlLow |= 0x5 << SDRAM_ST_BURST_DEL_OFFS;
 				else
 					dunitCtrlLow |= 0x4 << SDRAM_ST_BURST_DEL_OFFS;
 				break;
-			case DDR2_CL_4: 
+			case DDR2_CL_4:
 				/* registerd DDR SDRAM? */
-				if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE) 		
+				if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
 					dunitCtrlLow |= 0x6 << SDRAM_ST_BURST_DEL_OFFS;
 				else
-					dunitCtrlLow |= 0x5 << SDRAM_ST_BURST_DEL_OFFS;	
+					dunitCtrlLow |= 0x5 << SDRAM_ST_BURST_DEL_OFFS;
 				break;
 			default:
-				mvOsPrintf("Dram: dunitCtrlLowRegCalc Max. CL out of range %d\n", 
+				mvOsPrintf("Dram: dunitCtrlLowRegCalc Max. CL out of range %d\n",
 						   minCas);
 				return -1;
 		}
@@ -806,53 +806,53 @@ Registered	*  0100  |  0100  |  0101  |  0101  |  0110  |  TBD   *
 	{
 		switch (minCas)
 		{
-			case DDR1_CL_1_5: 
+			case DDR1_CL_1_5:
 				/* registerd DDR SDRAM? */
 				if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
 					dunitCtrlLow |= 0x4 << SDRAM_ST_BURST_DEL_OFFS;
 				else
 					dunitCtrlLow |= 0x3 << SDRAM_ST_BURST_DEL_OFFS;
 				break;
-			case DDR1_CL_2: 
+			case DDR1_CL_2:
 				/* registerd DDR SDRAM? */
 				if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
 					dunitCtrlLow |= 0x4 << SDRAM_ST_BURST_DEL_OFFS;
 				else
 					dunitCtrlLow |= 0x3 << SDRAM_ST_BURST_DEL_OFFS;
 				break;
-			case DDR1_CL_2_5: 
+			case DDR1_CL_2_5:
 				/* registerd DDR SDRAM? */
 				if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
 					dunitCtrlLow |= 0x5 << SDRAM_ST_BURST_DEL_OFFS;
 				else
-					dunitCtrlLow |= 0x4 << SDRAM_ST_BURST_DEL_OFFS;	
+					dunitCtrlLow |= 0x4 << SDRAM_ST_BURST_DEL_OFFS;
 				break;
-			case DDR1_CL_3: 
+			case DDR1_CL_3:
 				/* registerd DDR SDRAM? */
 				if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
 					dunitCtrlLow |= 0x5 << SDRAM_ST_BURST_DEL_OFFS;
 				else
-					dunitCtrlLow |= 0x4 << SDRAM_ST_BURST_DEL_OFFS;	
+					dunitCtrlLow |= 0x4 << SDRAM_ST_BURST_DEL_OFFS;
 				break;
-			case DDR1_CL_4: 
+			case DDR1_CL_4:
 				/* registerd DDR SDRAM? */
 				if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
 					dunitCtrlLow |= 0x6 << SDRAM_ST_BURST_DEL_OFFS;
 				else
-					dunitCtrlLow |= 0x5 << SDRAM_ST_BURST_DEL_OFFS;	
+					dunitCtrlLow |= 0x5 << SDRAM_ST_BURST_DEL_OFFS;
 				break;
 			default:
-				mvOsPrintf("Dram: dunitCtrlLowRegCalc Max. CL out of range %d\n", 
+				mvOsPrintf("Dram: dunitCtrlLowRegCalc Max. CL out of range %d\n",
 						   minCas);
 				return -1;
 	}
-	
+
 	}
 	DB(mvOsPrintf("Dram: Reg dunit control low = %x\n", dunitCtrlLow ));
 
 	return dunitCtrlLow;
-}  
-                                                                    
+}
+
 /*******************************************************************************
 * sdramAddrCtrlRegCalc - Calculate sdram address control register
 *
@@ -872,18 +872,18 @@ Registered	*  0100  |  0100  |  0101  |  0101  |  0110  |  TBD   *
 static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo)
 {
 	MV_U32 addrCtrl = 0;
-	
+
 	/* Set Address Control register static configuration bits */
 	addrCtrl = MV_REG_READ(SDRAM_ADDR_CTRL_REG);
-	
+
 	/* Set address control default value */
-	addrCtrl |= SDRAM_ADDR_CTRL_DV;  
-	
+	addrCtrl |= SDRAM_ADDR_CTRL_DV;
+
 	/* Clear DSize field */
 	addrCtrl &= ~SDRAM_DSIZE_MASK;
-	
+
 	/* Note that density is in MB units */
-	switch (pBankInfo->deviceDensity) 
+	switch (pBankInfo->deviceDensity)
 	{
 		case 128:                 /* 128 Mbit */
 			DB(mvOsPrintf("DRAM Device Density 128Mbit\n"));
@@ -902,7 +902,7 @@ static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo)
                        pBankInfo->deviceDensity);
 			return -1;
 	}
-     
+
 	/* SDRAM address control */
 	DB(mvOsPrintf("Dram: setting sdram address control with: %x \n", addrCtrl));
 
@@ -912,8 +912,8 @@ static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo)
 /*******************************************************************************
 * sdramTimeCtrlLowRegCalc - Calculate sdram timing control low register
 *
-* DESCRIPTION: 
-*       This function calculates sdram timing control low register 
+* DESCRIPTION:
+*       This function calculates sdram timing control low register
 *       optimized value based on the bank info parameters and the minCas.
 *
 * INPUT:
@@ -927,7 +927,7 @@ static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo)
 *       sdram timinf control low reg value.
 *
 *******************************************************************************/
-static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, 
+static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
                                                 MV_U32 minCas, MV_U32 busClk)
 {
 	MV_U32 tRp  = 0;
@@ -937,11 +937,11 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 	MV_U32 tWr  = 0;
 	MV_U32 tWtr = 0;
 	MV_U32 tRtp = 0;
-	
+
 	MV_U32 bankNum;
-	
+
 	busClk = busClk / 1000000;    /* In MHz */
-	
+
 	/* Scan all DRAM banks to find maximum timing values */
 	for (bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
 	{
@@ -950,13 +950,13 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 		tRcd = MV_MAX(tRcd, pBankInfo[bankNum].minRasToCasDelay);
 		tRas = MV_MAX(tRas, pBankInfo[bankNum].minRasPulseWidth);
 	}
-	
+
 	/* Extract timing (in ns) from SPD value. We ignore the tenth ns part.  */
 	/* by shifting the data two bits right.                                 */
 	tRp  = tRp  >> 2;    /* For example 0x50 -> 20ns                        */
 	tRrd = tRrd >> 2;
 	tRcd = tRcd >> 2;
-	
+
 	/* Extract clock cycles from time parameter. We need to round up        */
 	tRp  = ((busClk * tRp)  / 1000) + (((busClk * tRp)  % 1000) ? 1 : 0);
 	/* Micron work around for 133MHz */
@@ -972,7 +972,7 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 	DB(mvOsPrintf("tRcd = %d ", tRcd));
 	tRas = ((busClk * tRas) / 1000) + (((busClk * tRas) % 1000) ? 1 : 0);
 	DB(mvOsPrintf("tRas = %d ", tRas));
-	
+
 	/* tWr and tWtr is different for DDR1 and DDR2. tRtp is only for DDR2   */
 	if (MV_REG_READ(SDRAM_CONFIG_REG) & SDRAM_DTYPE_DDR2)
 	{
@@ -983,13 +983,13 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 			tWtr = MV_MAX(tWtr, pBankInfo[bankNum].minWriteToReadCmdDelay);
 			tRtp = MV_MAX(tRtp, pBankInfo[bankNum].minReadToPrechCmdDelay);
 		}
-		
+
 		/* Extract timing (in ns) from SPD value. We ignore the tenth ns    */
 		/* part by shifting the data two bits right.                        */
 		tWr  = tWr  >> 2;    /* For example 0x50 -> 20ns                    */
 		tWtr = tWtr >> 2;
 		tRtp = tRtp >> 2;
-	
+
 		/* Extract clock cycles from time parameter. We need to round up    */
 		tWr  = ((busClk * tWr)  / 1000) + (((busClk * tWr)  % 1000) ? 1 : 0);
 		DB(mvOsPrintf("tWr = %d ", tWr));
@@ -1005,9 +1005,9 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 		DB(mvOsPrintf("tRtp = %d ", tRtp));
 	}
 	else
-	{    
+	{
 		tWr  = ((busClk*SDRAM_TWR) / 1000) + (((busClk*SDRAM_TWR) % 1000)?1:0);
-		
+
 		if ((200 == busClk) || ((100 == busClk) && (DDR1_CL_1_5 == minCas)))
 		{
 			tWtr = 2;
@@ -1016,12 +1016,12 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 		{
 			tWtr = 1;
 		}
-		
+
 		tRtp = 2; /* Must be set to 0x1 (two cycles) when using DDR1 */
 	}
-	
+
 	DB(mvOsPrintf("tWtr = %d\n", tWtr));
-	
+
 	/* Note: value of 0 in register means one cycle, 1 means two and so on  */
 	return (((tRp  - 1) << SDRAM_TRP_OFFS)	|
 			((tRrd - 1) << SDRAM_TRRD_OFFS)	|
@@ -1035,8 +1035,8 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 /*******************************************************************************
 * sdramTimeCtrlHighRegCalc - Calculate sdram timing control high register
 *
-* DESCRIPTION: 
-*       This function calculates sdram timing control high register 
+* DESCRIPTION:
+*       This function calculates sdram timing control high register
 *       optimized value based on the bank info parameters and the bus clock.
 *
 * INPUT:
@@ -1050,21 +1050,21 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 *       sdram timinf control high reg value.
 *
 *******************************************************************************/
-static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, 
+static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
                                                                 MV_U32 busClk)
 {
 	MV_U32 tRfc;
 	MV_U32 timeNs = 0;
 	int bankNum;
 	MV_U32 sdramTw2wCyc = 0;
-	
+
 	busClk = busClk / 1000000;    /* In MHz */
-	
+
 	/* tRfc is different for DDR1 and DDR2. */
 	if (MV_REG_READ(SDRAM_CONFIG_REG) & SDRAM_DTYPE_DDR2)
 	{
 		MV_U32 bankNum;
-	
+
 		/* Scan all DRAM banks to find maximum timing values */
 		for (bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
 			timeNs = MV_MAX(timeNs,  pBankInfo[bankNum].minRefreshToActiveCmd);
@@ -1087,12 +1087,12 @@ static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 			}
 		}
 	}
-	
+
 	tRfc = ((busClk * timeNs)  / 1000) + (((busClk * timeNs)  % 1000) ? 1 : 0);
-	
+
 	DB(mvOsPrintf("Dram  Timing High: tRfc = %d\n", tRfc));
 
-	
+
 	/* Represent the populate banks in binary form */
 	for(bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
 	{
@@ -1100,7 +1100,7 @@ static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 			sdramTw2wCyc++;
 	}
 
-	/* If we have more the 1 bank then we need the TW2W in 1 for ODT switch */	
+	/* If we have more the 1 bank then we need the TW2W in 1 for ODT switch */
 	if (sdramTw2wCyc > 1)
 		sdramTw2wCyc = 1;
 	else
@@ -1112,24 +1112,24 @@ static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo,
 			((SDRAM_TR2WW2R_CYC - 1)		<< SDRAM_TR2W_W2R_OFFS)	|
 			(((tRfc - 1) >> 4)				<< SDRAM_TRFC_EXT_OFFS)	|
 			(sdramTw2wCyc					<< SDRAM_TW2W_OFFS));
-	
+
 }
 
 /*******************************************************************************
 * sdramDDr2OdtConfig - Set DRAM DDR2 On Die Termination registers.
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *       This function config DDR2 On Die Termination (ODT) registers.
 *	ODT configuration is done according to DIMM presence:
-*	
-*       Presence	  Ctrl Low    Ctrl High  Dunit Ctrl   Ext Mode  
-*	CS0	         0x84210000  0x00000000  0x0000780F  0x00000440 
-*	CS0+CS1          0x84210000  0x00000000  0x0000780F  0x00000440 
-*	CS0+CS2	    	 0x030C030C  0x00000000  0x0000740F  0x00000404 
-*	CS0+CS1+CS2	 0x030C030C  0x00000000  0x0000740F  0x00000404 
-*	CS0+CS2+CS3	 0x030C030C  0x00000000  0x0000740F  0x00000404 
-*	CS0+CS1+CS2+CS3  0x030C030C  0x00000000  0x0000740F  0x00000404 
-*		
+*
+*       Presence	  Ctrl Low    Ctrl High  Dunit Ctrl   Ext Mode
+*	CS0	         0x84210000  0x00000000  0x0000780F  0x00000440
+*	CS0+CS1          0x84210000  0x00000000  0x0000780F  0x00000440
+*	CS0+CS2	    	 0x030C030C  0x00000000  0x0000740F  0x00000404
+*	CS0+CS1+CS2	 0x030C030C  0x00000000  0x0000740F  0x00000404
+*	CS0+CS2+CS3	 0x030C030C  0x00000000  0x0000740F  0x00000404
+*	CS0+CS1+CS2+CS3  0x030C030C  0x00000000  0x0000740F  0x00000404
+*
 * INPUT:
 *		pBankInfo - bank info parameters.
 *
@@ -1144,7 +1144,7 @@ static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo)
 	MV_U32 populateBanks = 0;
 	MV_U32 odtCtrlLow, odtCtrlHigh, dunitOdtCtrl;
 	int bankNum;
-	
+
 	/* Represent the populate banks in binary form */
 	for(bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
 	{
@@ -1153,7 +1153,7 @@ static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo)
 				populateBanks |= (1 << bankNum);
 			}
 		}
-	
+
 	switch(populateBanks)
 	{
 		case(BANK_PRESENT_CS0):
@@ -1189,7 +1189,7 @@ static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo)
 		default:
 			mvOsPrintf("sdramDDr2OdtConfig: Invalid DRAM bank presence\n");
 			return;
-	} 
+	}
 	MV_REG_WRITE(DRAM_BUF_REG7, odtCtrlLow);
 	MV_REG_WRITE(DRAM_BUF_REG8, odtCtrlHigh);
 	MV_REG_WRITE(DRAM_BUF_REG9, dunitOdtCtrl);
@@ -1200,7 +1200,7 @@ static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo)
 /*******************************************************************************
 * mvDramIfWinSet - Set DRAM interface address decode window
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *       This function sets DRAM interface address decode window.
 *
 * INPUT:
@@ -1238,7 +1238,7 @@ MV_STATUS mvDramIfWinSet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 	{
 		mvOsPrintf("mvDramIfWinSet:Error setting DRAM interface window %d."\
 				   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
-                   target, 
+                   target,
 				   pAddrDecWin->addrWin.baseLow,
 				   pAddrDecWin->addrWin.size);
 		return MV_ERROR;
@@ -1287,13 +1287,13 @@ MV_STATUS mvDramIfWinSet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 
 	/* Write to address decode Size Register                        	*/
 	MV_REG_WRITE(SDRAM_SIZE_REG(target), sizeReg);
-	
+
 	return MV_OK;
 }
 /*******************************************************************************
 * mvDramIfWinGet - Get DRAM interface address decode window
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *       This function gets DRAM interface address decode window.
 *
 * INPUT:
@@ -1347,7 +1347,7 @@ MV_STATUS mvDramIfWinGet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 	}
 	else
 	{
-		pAddrDecWin->enable = MV_FALSE;			
+		pAddrDecWin->enable = MV_FALSE;
 	}
 
 	return MV_OK;
@@ -1355,7 +1355,7 @@ MV_STATUS mvDramIfWinGet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 /*******************************************************************************
 * mvDramIfWinEnable - Enable/Disable SDRAM address decode window
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *		This function enable/Disable SDRAM address decode window.
 *
 * INPUT:
@@ -1379,11 +1379,11 @@ MV_STATUS mvDramIfWinEnable(MV_TARGET target,MV_BOOL enable)
 		return MV_ERROR;
 	}
 
-	if (enable == MV_TRUE) 
+	if (enable == MV_TRUE)
 	{   /* First check for overlap with other enabled windows				*/
 		if (MV_OK != mvDramIfWinGet(target, &addrDecWin))
 		{
-			mvOsPrintf("mvDramIfWinEnable:ERR. Getting target %d failed.\n", 
+			mvOsPrintf("mvDramIfWinEnable:ERR. Getting target %d failed.\n",
                                                                         target);
 			return MV_ERROR;
 		}
@@ -1412,12 +1412,12 @@ MV_STATUS mvDramIfWinEnable(MV_TARGET target,MV_BOOL enable)
 * sdramIfWinOverlap - Check if an address window overlap an SDRAM address window
 *
 * DESCRIPTION:
-*		This function scan each SDRAM address decode window to test if it 
-*		overlapps the given address windoow 
+*		This function scan each SDRAM address decode window to test if it
+*		overlapps the given address windoow
 *
 * INPUT:
 *       target      - SDRAM target where the function skips checking.
-*       pAddrDecWin - The tested address window for overlapping with 
+*       pAddrDecWin - The tested address window for overlapping with
 *					  SDRAM windows.
 *
 * OUTPUT:
@@ -1432,7 +1432,7 @@ static MV_BOOL sdramIfWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
 {
 	MV_TARGET	targetNum;
 	MV_DRAM_DEC_WIN 	addrDecWin;
-	
+
 	for(targetNum = SDRAM_CS0; targetNum < MV_DRAM_MAX_CS ; targetNum++)
 	{
 		/* don't check our winNum or illegal targets */
@@ -1440,29 +1440,29 @@ static MV_BOOL sdramIfWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
 		{
 			continue;
 		}
-		
+
 		/* Get window parameters 	*/
 		if (MV_OK != mvDramIfWinGet(targetNum, &addrDecWin))
 		{
 			mvOsPrintf("sdramIfWinOverlap: ERR. TargetWinGet failed\n");
 			return MV_ERROR;
 		}
-	
+
 		/* Do not check disabled windows	*/
 		if (MV_FALSE == addrDecWin.enable)
 		{
 			continue;
 		}
-	
+
 		if(MV_TRUE == ctrlWinOverlapTest(pAddrWin, &addrDecWin.addrWin))
-		{                    
+		{
 			mvOsPrintf(
-			"sdramIfWinOverlap: Required target %d overlap winNum %d\n", 
+			"sdramIfWinOverlap: Required target %d overlap winNum %d\n",
 			target, targetNum);
-			return MV_TRUE;           
+			return MV_TRUE;
 		}
 	}
-	
+
 	return MV_FALSE;
 }
 
@@ -1479,14 +1479,14 @@ static MV_BOOL sdramIfWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
 *       None.
 *
 * RETURN:
-*       DRAM bank size. If bank is disabled the function return '0'. In case 
+*       DRAM bank size. If bank is disabled the function return '0'. In case
 *		or paramter is invalid, the function returns -1.
 *
 *******************************************************************************/
 MV_32 mvDramIfBankSizeGet(MV_U32 bankNum)
 {
     MV_DRAM_DEC_WIN 	addrDecWin;
-	
+
 	/* Check parameters */
 	if (!MV_TARGET_IS_DRAM(bankNum))
 	{
@@ -1499,7 +1499,7 @@ MV_32 mvDramIfBankSizeGet(MV_U32 bankNum)
 		mvOsPrintf("sdramIfWinOverlap: ERR. TargetWinGet failed\n");
 		return -1;
 	}
-	
+
 	if (MV_TRUE == addrDecWin.enable)
 	{
 		return addrDecWin.addrWin.size;
@@ -1524,14 +1524,14 @@ MV_32 mvDramIfBankSizeGet(MV_U32 bankNum)
 *       None.
 *
 * RETURN:
-*       DRAM total size. In case or paramter is invalid, the function 
+*       DRAM total size. In case or paramter is invalid, the function
 *		returns -1.
 *
 *******************************************************************************/
 MV_32 mvDramIfSizeGet(MV_VOID)
 {
 	MV_U32 totalSize = 0, bankSize = 0, bankNum;
-	
+
 	for(bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
 	{
 		bankSize = mvDramIfBankSizeGet(bankNum);
@@ -1546,9 +1546,9 @@ MV_32 mvDramIfSizeGet(MV_VOID)
 			totalSize += bankSize;
 		}
 	}
-	
+
 	DB(mvOsPrintf("Dram: Total DRAM size is 0x%x \n",totalSize));
-	
+
 	return totalSize;
 }
 
@@ -1565,14 +1565,14 @@ MV_32 mvDramIfSizeGet(MV_VOID)
 *       None.
 *
 * RETURN:
-*       DRAM bank size. If bank is disabled or paramter is invalid, the 
+*       DRAM bank size. If bank is disabled or paramter is invalid, the
 *		function returns -1.
 *
 *******************************************************************************/
 MV_32 mvDramIfBankBaseGet(MV_U32 bankNum)
 {
     MV_DRAM_DEC_WIN 	addrDecWin;
-	
+
 	/* Check parameters */
 	if (!MV_TARGET_IS_DRAM(bankNum))
 	{
@@ -1585,7 +1585,7 @@ MV_32 mvDramIfBankBaseGet(MV_U32 bankNum)
 		mvOsPrintf("sdramIfWinOverlap: ERR. TargetWinGet failed\n");
 		return -1;
 	}
-	
+
 	if (MV_TRUE == addrDecWin.enable)
 	{
 		return addrDecWin.addrWin.baseLow;
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.h
index 8bfa3e8..c50de76 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -93,20 +93,20 @@ typedef enum _mvMemoryType
 /* enumeration for DDR1 supported CAS Latencies */
 typedef enum _mvDimmDdr1Cas
 {
-    DDR1_CL_1_5  = 0x02, 
-    DDR1_CL_2    = 0x04, 
-    DDR1_CL_2_5  = 0x08, 
-    DDR1_CL_3    = 0x10, 
-    DDR1_CL_4    = 0x40, 
+    DDR1_CL_1_5  = 0x02,
+    DDR1_CL_2    = 0x04,
+    DDR1_CL_2_5  = 0x08,
+    DDR1_CL_3    = 0x10,
+    DDR1_CL_4    = 0x40,
     DDR1_CL_FAULT
 } MV_DIMM_DDR1_CAS;
 
 /* enumeration for DDR2 supported CAS Latencies */
 typedef enum _mvDimmDdr2Cas
 {
-    DDR2_CL_3    = 0x08, 
-    DDR2_CL_4    = 0x10, 
-    DDR2_CL_5    = 0x20, 
+    DDR2_CL_3    = 0x08,
+    DDR2_CL_4    = 0x10,
+    DDR2_CL_5    = 0x20,
     DDR2_CL_FAULT
 } MV_DIMM_DDR2_CAS;
 
@@ -128,7 +128,7 @@ typedef struct _mvDramBankInfo
     MV_U32  refreshInterval;
 
     /* DIMM timing parameters */
-    MV_U32  minCycleTimeAtMaxCasLatPs;	
+    MV_U32  minCycleTimeAtMaxCasLatPs;
     MV_U32  minCycleTimeAtMaxCasLatMinus1Ps;
     MV_U32  minCycleTimeAtMaxCasLatMinus2Ps;
 	MV_U32  minRowPrechargeTime;
@@ -139,7 +139,7 @@ typedef struct _mvDramBankInfo
     MV_U32  minWriteToReadCmdDelay; /* DDR2 only */
     MV_U32  minReadToPrechCmdDelay; /* DDR2 only */
     MV_U32  minRefreshToActiveCmd;  /* DDR2 only */
-                      
+
     /* Parameters calculated from the extracted DIMM information */
     MV_U32  size;
     MV_U32  deviceDensity;           	/* 16,64,128,256 or 512 Mbit */
@@ -147,11 +147,11 @@ typedef struct _mvDramBankInfo
 
     /* DIMM attributes (MV_TRUE for yes) */
     MV_BOOL registeredAddrAndControlInputs;
-     
+
 }MV_DRAM_BANK_INFO;
 
 /* This structure describes CPU interface address decode window               */
-typedef struct _mvDramIfDecWin 
+typedef struct _mvDramIfDecWin
 {
 	MV_ADDR_WIN   addrWin;    /* An address window*/
 	MV_BOOL       enable;     /* Address decode window is enabled/disabled    */
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfBasicInit.S b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfBasicInit.S
new file mode 100644
index 0000000..f2a9365
--- /dev/null
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfBasicInit.S
@@ -0,0 +1,988 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#define MV_ASMLANGUAGE
+#include "mvSysHwConfig.h"
+#include "mvOsAsm.h"
+#include "mvBoardEnvSpec.h"
+#include "mvCpuIfRegs.h"
+#include "mvDramIfConfig.h"
+#include "mvDramIfRegs.h"
+#include "pex/mvPexRegs.h"
+#include "pci/mvPciRegs.h"
+#include "mvCtrlEnvSpec.h"
+#include "mvCtrlEnvAsm.h"
+#include "cpu/mvCpuArm.h"
+#include "mvCommon.h"
+
+/* defines */
+
+#if !defined(MV_INC_BOARD_DDIM)
+.globl dramBoot1
+dramBoot1:
+        .word   0
+
+/******************************************************************************
+*
+*
+*
+*
+*******************************************************************************/
+#if defined(DB_PRPMC) || defined(DB_PEX_PCI) || defined(DB_MNG)
+
+/* PEX_PCI and PRPMC boards 256 MB*/
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x0fff0001
+#define STATIC_SDRAM_CONFIG	     		0x03248400
+#define STATIC_SDRAM_MODE	     		0x62
+#define STATIC_DUNIT_CTRL_LOW	     		0x4041000
+#define STATIC_SDRAM_ADDR_CTRL	     		0x00000020
+#define STATIC_SDRAM_TIME_CTRL_LOW     		0x11602220
+#define STATIC_SDRAM_TIME_CTRL_HI	     	0x0000030F
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x0
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x0
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0
+#define STATIC_SDRAM_EXT_MODE          		0x0
+
+#elif defined(DB_FPGA)
+
+/* FPGA DC boards 256 MB*/
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x0fff0001
+#define STATIC_SDRAM_CONFIG	     		0x03208400	/* 32bit */
+#define STATIC_SDRAM_MODE	     		0x22
+#define STATIC_DUNIT_CTRL_LOW	     		0x03041000
+#define STATIC_SDRAM_ADDR_CTRL	     		0x00000020
+#define STATIC_SDRAM_TIME_CTRL_LOW     		0x11112220
+#define STATIC_SDRAM_TIME_CTRL_HI	     	0x0000000D
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x0
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x0
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0
+#define STATIC_SDRAM_EXT_MODE          		0x1
+
+#elif  defined(RD_88F6183GP) || defined(DB_CUSTOMER)
+
+/* Customer 1 DDR2 2 devices 512Mbit by 16 bit */
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x07ff0001
+#define STATIC_SDRAM_CONFIG	     		0x03158400
+#define STATIC_SDRAM_MODE	     		0x452
+#define STATIC_DUNIT_CTRL_LOW	     		0x06041000
+#define STATIC_SDRAM_ADDR_CTRL	     		0x00000020
+#define STATIC_SDRAM_TIME_CTRL_LOW     		0x11912220
+#define STATIC_SDRAM_TIME_CTRL_HI	     	0x00000502
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x00010000
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000002
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x00000601
+#define STATIC_SDRAM_EXT_MODE          		0x00000440
+
+
+#elif  defined(RD_88F6183AP)
+
+/* DDR2 1 devices 512Mbit by 16 bit */
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x03ff0001
+#define STATIC_SDRAM_CONFIG	     		0x1f154400
+#define STATIC_SDRAM_MODE	     		0x432
+#define STATIC_DUNIT_CTRL_LOW	     		0x04041000
+#define STATIC_SDRAM_ADDR_CTRL	     		0x00000020
+#define STATIC_SDRAM_TIME_CTRL_LOW     		0x11912220
+#define STATIC_SDRAM_TIME_CTRL_HI	     	0x00000502
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x00010000
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000002
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x00000601
+#define STATIC_SDRAM_EXT_MODE          		0x00000440
+
+/* 6082L MARVELL DIMM */
+#elif  defined(DB_88F6082LBP)
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x07ff0001
+#define STATIC_SDRAM_CONFIG	     		0x7f158400
+#define STATIC_SDRAM_MODE	     		0x432
+#define STATIC_DUNIT_CTRL_LOW	     		0x04041040
+#define STATIC_SDRAM_ADDR_CTRL	     		0x00000020
+#define STATIC_SDRAM_TIME_CTRL_LOW     		0x11612220
+#define STATIC_SDRAM_TIME_CTRL_HI	     	0x00000501
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x00010000
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000002
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x00000a01
+#define STATIC_SDRAM_EXT_MODE          		0x00000440
+
+#elif  defined(RD_88W8660_AP82S)
+
+/* Shark RD */
+
+#if defined(MV_DRAM_32M)
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x01ff0001
+#define STATIC_SDRAM_ADDR_CTRL	     		0x00000010
+#elif defined(MV_DRAM_16M)
+
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x00ff0001
+#define STATIC_SDRAM_ADDR_CTRL	     		0x00000000
+
+#else
+#error "NO DDR size selected"
+#endif
+
+#define STATIC_SDRAM_CONFIG	     		0x03144400
+#define STATIC_SDRAM_MODE	     		0x62
+#define STATIC_DUNIT_CTRL_LOW	     		0x4041000
+
+#define STATIC_SDRAM_TIME_CTRL_LOW     		0x11602220
+#define STATIC_SDRAM_TIME_CTRL_HI	     	0x0000040b
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x0
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x0
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0
+#define STATIC_SDRAM_EXT_MODE          		0x0
+
+#elif defined(RD_88W8660)
+
+/* Shark RD */
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x03ff0001
+#define STATIC_SDRAM_CONFIG	     		0x03144400
+#define STATIC_SDRAM_MODE	     		0x62
+#define STATIC_DUNIT_CTRL_LOW	     		0x4041000
+#define STATIC_SDRAM_ADDR_CTRL	     		0x00000010
+#define STATIC_SDRAM_TIME_CTRL_LOW     		0x11602220
+#define STATIC_SDRAM_TIME_CTRL_HI	     	0x0000040b
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x0
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x0
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0
+#define STATIC_SDRAM_EXT_MODE          		0x0
+
+#else /* NAS */
+
+
+#if defined(RD_88F5182)
+
+#if defined(MV_88F5082)
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x3ff0001
+#define STATIC_SDRAM_ADDR_CTRL	    	 	0x20
+#else
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x7ff0001
+#define STATIC_SDRAM_ADDR_CTRL	    	 	0x20
+#endif
+
+#elif defined(RD_88F5182_3)
+
+#if defined(MV_88F5082)
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x3ff0001
+#define STATIC_SDRAM_ADDR_CTRL	    	 	0x20
+#else
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x7ff0001
+#define STATIC_SDRAM_ADDR_CTRL	    	 	0x20
+#endif
+
+#else
+
+#define STATIC_SDRAM0_BANK0_SIZE	     	0x1ff0001
+#define STATIC_SDRAM_ADDR_CTRL	    	 	0x0
+
+#endif
+
+#if defined(MV_88F5082)
+#define STATIC_SDRAM_CONFIG	     		0x3144400
+#else
+#define STATIC_SDRAM_CONFIG	     		0x3148400
+#endif
+#define STATIC_SDRAM_MODE	     		0x62
+#define STATIC_DUNIT_CTRL_LOW	     		0x4041000
+#define STATIC_SDRAM_TIME_CTRL_LOW     		0x11602220
+#define STATIC_SDRAM_TIME_CTRL_HI	     	0x40c
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x0
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x0
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0
+#define STATIC_SDRAM_EXT_MODE          		0x0
+
+#endif
+
+	.globl _mvDramIfStaticInit
+_mvDramIfStaticInit:
+
+	mov     r11, LR     		/* Save link register */
+	mov	r10, r2
+
+        /* If we boot from NAND jump to DRAM sddress */
+
+        mov     r5, #1
+        ldr     r6, =dramBoot1
+        str     r5, [r6]                /* We started executing from DRAM */
+
+        ldr     r6, dramBoot1
+        cmp     r6, #0
+        bne     1f
+
+
+	/* set all dram windows to 0 */
+	mov	r6, #0
+	MV_REG_WRITE_ASM(r6, r5, 0x1504)
+	MV_REG_WRITE_ASM(r6, r5, 0x150c)
+	MV_REG_WRITE_ASM(r6, r5, 0x1514)
+	MV_REG_WRITE_ASM(r6, r5, 0x151c)
+
+	/* set all dram configuration in temp registers */
+	ldr	r6, = STATIC_SDRAM0_BANK0_SIZE
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG0)
+	ldr	r6, = STATIC_SDRAM_CONFIG
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG1)
+	ldr	r6, = STATIC_SDRAM_MODE
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG2)
+	ldr	r6, = STATIC_DUNIT_CTRL_LOW
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG3)
+	ldr	r6, = STATIC_SDRAM_ADDR_CTRL
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG4)
+	ldr	r6, = STATIC_SDRAM_TIME_CTRL_LOW
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG5)
+	ldr	r6, = STATIC_SDRAM_TIME_CTRL_HI
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG6)
+	ldr	r6, = STATIC_SDRAM_ODT_CTRL_LOW
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG7)
+	ldr	r6, = STATIC_SDRAM_ODT_CTRL_HI
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG8)
+	ldr	r6, = STATIC_SDRAM_DUNIT_ODT_CTRL
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG9)
+	ldr	r6, = STATIC_SDRAM_EXT_MODE
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG10)
+
+	mov 	sp, #0
+	bl	_mvDramIfConfig
+1:
+	mov 	r2, r10
+	mov     PC, r11         	/* r11 is saved link register */
+
+#else  /* #if !defined(MV_INC_BOARD_DDIM) */
+
+.globl dramBoot1
+dramBoot1:
+        .word   0
+
+/*******************************************************************************
+* mvDramIfBasicInit - Basic initialization of DRAM interface
+*
+* DESCRIPTION:
+*       The function will initialize the DRAM for basic usage. The function
+*       will use the TWSI assembly API to extract DIMM parameters according
+*       to which DRAM interface will be initialized.
+*       The function referes to the following DRAM parameters:
+*       1) DIMM is registered or not.
+*       2) DIMM width detection.
+*       3) DIMM density.
+*
+* INPUT:
+*       r3 - required size for initial DRAM.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*       Note:
+*       r4 holds I2C EEPROM address
+*       r5 holds SDRAM register base address
+*	r7 holds returned values
+*       r8 holds SDRAM various configuration registers value.
+*       r11 holds return function address.
+*******************************************************************************/
+/* Setting the offsets of the I2C registers */
+#define NUM_OF_ROWS_OFFSET            3
+#define NUM_OF_COLS_OFFSET            4
+#define NUM_OF_RANKS		      5
+#define SDRAM_WIDTH_OFFSET           13
+#define NUM_OF_BANKS_OFFSET          17
+#define SUPPORTED_CL_OFFSET          18
+#define DIMM_TYPE_INFO_OFFSET        20         /* DDR2 only    */
+#define SDRAM_MODULES_ATTR_OFFSET    21
+
+#define DRAM_DEV_DENSITY_128M        0x080
+#define DRAM_DEV_DENSITY_256M        0x100
+#define DRAM_DEV_DENSITY_512M        0x200
+       .globl _mvDramIfBasicInit
+       .extern _i2cInit
+
+_mvDramIfBasicInit:
+
+        mov     r11, LR     		/* Save link register */
+
+        mov     r5, #1
+        ldr     r8, =dramBoot1
+        str     r5, [r8]                /* We started executing from DRAM */
+
+        /* If we boot from NAND jump to DRAM sddress */
+        ldr     r8, dramBoot1
+        cmp     r8, #0
+        movne   pc, r11
+
+
+
+        bl      _i2cInit                /* Initialize TWSI master             */
+
+        /* Get default SDRAM Config values */
+        MV_REG_READ_ASM (r8, r5, SDRAM_CONFIG_REG)
+        bic     r8, r8, #SDRAM_DCFG_MASK
+
+
+        /* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r4, r5);
+
+        /* Return if OrionN */
+        ldr     r5, =MV_5180_DEV_ID
+        cmp     r4, r5
+        beq     cat_through_end
+
+        /* Return if Orion1 */
+        ldr     r5, =MV_5181_DEV_ID
+        cmp     r4, r5
+        beq     cat_through_end
+
+        /* Return if Nas */
+        ldr     r5, =MV_5182_DEV_ID
+        cmp     r4, r5
+        beq     cat_through_end
+
+        /* Return if Shark */
+        ldr     r5, =MV_8660_DEV_ID
+        cmp     r4, r5
+        beq     cat_through_end
+
+        /* goto calcConfigReg if bigger than Orion2*/
+        ldr     r5, =MV_5281_DEV_ID
+        cmp     r4, r5
+        bne     cat_through
+
+cat_through:
+        /* set cat through - for better performance - in orion2 b0 and higher*/
+        orr     r8, r8, #SDRAM_CATTHR_EN
+
+cat_through_end:
+
+
+        /* Get registered/non registered info from DIMM */
+	bl  	_is_Registered
+        beq     nonRegistered
+
+setRegistered:
+        orr     r8, r8, #SDRAM_REGISTERED   /* Set registered bit(17)         */
+
+nonRegistered:
+	/* Get SDRAM width */
+	bl 	_get_width
+
+        orr     r6, r8, #SDRAM_DCFG_X16_DEV /* x16 devices  */
+        cmp     r7, #16
+        beq     setConfigReg
+
+        orr     r6, r8, #SDRAM_DCFG_X8_DEV  /* x8 devices   */
+        cmp     r7, #8
+        beq     setConfigReg
+
+        /* This is an error. return */
+        b       exit_ddrAutoConfig
+
+setConfigReg:
+        mov     r8, r6
+        ldr     r6, =SDRAM_CONFIG_DV
+        orr     r8, r8, r6              /* Add default settings */
+        mov     r6, r8                  /* Do not swap r8 content */
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_CONFIG_REG)
+
+        /* Set maximum CL supported by DIMM */
+	bl	_get_CAL
+
+        /* r7 is DIMM supported CAS (e.g: 3 --> 0x1C)                         */
+        clz     r6, r7
+        rsb     r6, r6, #31     /* r6 = the bit number of MAX CAS supported   */
+
+        /* Check the DDR version */
+        tst     r8, #SDRAM_DTYPE_DDR2
+        bne     casDdr2
+
+casDdr1:
+        ldr	r7, =3		/* stBurstDel field value	*/
+	ldr     r8, =0x52       /* Assuming MAX CL = 1.5        */
+        cmp     r6, #1          /* If CL = 1.5 break            */
+        beq     setModeReg
+
+        ldr	r7, =3		/* stBurstDel field value	*/
+	ldr     r8, =0x22       /* Assuming MAX CL = 2          */
+        cmp     r6, #2          /* If CL = 2 break              */
+        beq     setModeReg
+
+        ldr	r7, =4		/* stBurstDel field value	*/
+	ldr     r8, =0x62       /* Assuming MAX CL = 2.5        */
+        cmp     r6, #3          /* If CL = 2.5 break            */
+        beq     setModeReg
+
+        ldr	r7, =4		/* stBurstDel field value	*/
+	ldr     r8, =0x32       /* Assuming MAX CL = 3          */
+        cmp     r6, #4          /* If CL = 3 break              */
+        beq     setModeReg
+
+        ldr	r7, =5		/* stBurstDel field value	*/
+	ldr     r8, =0x42       /* Assuming MAX CL = 4          */
+        cmp     r6, #6          /* If CL = 4 break              */
+        b       setModeReg
+
+        b       exit_ddrAutoConfig      /* This is an error !!  */
+
+casDdr2:
+        ldr	r7, =4		/* stBurstDel field value	*/
+	ldr     r8, =0x32      /* Assuming MAX CL = 3           */
+        cmp     r6, #3          /* If CL = 3 break              */
+        beq     casDdr2Cont
+
+        ldr	r7, =5		/* stBurstDel field value	*/
+	ldr     r8, =0x42      /* Assuming MAX CL = 4           */
+        cmp     r6, #4          /* If CL = 4 break              */
+        beq     casDdr2Cont
+
+        /* CL 5 currently unsupported. We use CL 4 instead      */
+        ldr	r7, =5		/* stBurstDel field value	*/
+	ldr     r8, =0x42      /* Assuming MAX CL = 5           */
+        cmp     r6, #5          /* If CL = 5 break              */
+        beq     casDdr2Cont
+
+        b       exit_ddrAutoConfig      /* This is an error !!  */
+casDdr2Cont:
+        /* Write recovery for auto-precharge relevant only in DDR2 */
+        orr     r8, r8, #0x400   /* Default value */
+
+setModeReg:
+        /* The CPU must not attempt to change the SDRAM Mode register setting */
+        /* prior to DRAM controller completion of the DRAM initialization     */
+        /* sequence. To guarantee this restriction, it is recommended that    */
+        /* the CPU sets the SDRAM Operation register to NOP command, performs */
+        /* read polling until the register is back in Normal operation value, */
+        /* and then sets SDRAM Mode register to it's new value.               */
+
+	/* write 'nop' to SDRAM operation */
+        mov     r6, #0x5                 /* 'NOP' command              */
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_OPERATION_REG)
+
+        /* poll SDRAM operation. Make sure its back to normal operation       */
+_sdramOpPoll1:
+        ldr     r6, [r5]
+        cmp     r6, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll1
+
+        /* Now its safe to write new value to SDRAM Mode register             */
+        MV_REG_WRITE_ASM (r8, r5, SDRAM_MODE_REG)
+
+        /* Make the Dunit write the DRAM its new mode                         */
+        mov     r6, #0x3                 /* Mode Register Set command  */
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_OPERATION_REG)
+
+        /* poll SDRAM operation. Make sure its back to normal operation       */
+_sdramOpPoll2:
+        ldr     r6, [r5]
+        cmp     r6, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll2
+
+	/* Set Dunit control register according to max CL detected	      */
+	/* If we use registered DIMM, add 1 to stBurstDel		      */
+        MV_REG_READ_ASM (r6, r5, SDRAM_CONFIG_REG)
+	tst	r6, #SDRAM_REGISTERED
+	beq	setDunitReg
+	add	r7, r7, #1
+
+setDunitReg:
+        ldr     r6, =SDRAM_DUNIT_CTRL_LOW_DV
+        orr	r6, r6, r7, LSL #SDRAM_ST_BURST_DEL_OFFS
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
+
+
+        /* DIMM density configuration*/
+        /* Density = (1 << (rowNum + colNum)) * dramWidth * dramBankNum       */
+Density:
+	bl 	_getDensity
+	mov 	r8, r7
+        mov     r8, r8, LSR #20 /* Move density 20 bits to the right  */
+                                /* For example 0x10000000 --> 0x1000 */
+
+        mov     r6, #0x00
+        cmp     r8, #DRAM_DEV_DENSITY_128M
+        beq     densCont
+
+        mov     r6, #0x10
+        cmp     r8, #DRAM_DEV_DENSITY_256M
+        beq     densCont
+
+        mov     r6, #0x20
+        cmp     r8, #DRAM_DEV_DENSITY_512M
+        beq     densCont
+
+        /* This is an error. return */
+        b       exit_ddrAutoConfig
+
+densCont:
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_ADDR_CTRL_REG)
+
+        /* Config DDR2 registers (Extended mode, ODTs and pad calibration)    */
+        MV_REG_READ_ASM (r8, r5, SDRAM_CONFIG_REG)
+        tst     r8, #SDRAM_DTYPE_DDR2
+        beq     _extModeODTEnd
+
+
+	/* Set DDR Extended Mode register for working with CS[0]	      */
+        /* write 'nop' to SDRAM operation */
+        mov     r6, #0x5                 /* 'NOP' command              */
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_OPERATION_REG)
+
+        /* poll SDRAM operation. Make sure its back to normal operation       */
+_sdramOpPoll3:
+        ldr     r6, [r5]
+        cmp     r6, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll3
+
+        /* Now its safe to write new value to SDRAM Extended Mode register    */
+        ldr	r6, =DDR_SDRAM_EXT_MODE_CS0_DV
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_EXTENDED_MODE_REG)
+
+        /* Make the Dunit write the DRAM its new extended mode                */
+        mov     r6, #0x4                /* Extended Mode Register Set command */
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_OPERATION_REG)
+
+        /* poll SDRAM operation. Make sure its back to normal operation       */
+_sdramOpPoll4:
+        ldr     r6, [r5]
+        cmp     r6, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll4
+
+	/* ODT configuration is done for single bank CS[0] only		      */
+        /* Config DDR2 On Die Termination (ODT) registers */
+        ldr     r6, =DDR2_ODT_CTRL_LOW_CS0_DV
+        MV_REG_WRITE_ASM (r6, r5, DDR2_SDRAM_ODT_CTRL_LOW_REG)
+
+        ldr     r6, =DDR2_ODT_CTRL_HIGH_CS0_DV
+        MV_REG_WRITE_ASM (r6, r5, DDR2_SDRAM_ODT_CTRL_HIGH_REG)
+
+        ldr     r6, =DDR2_DUNIT_ODT_CTRL_CS0_DV
+        MV_REG_WRITE_ASM (r6, r5, DDR2_DUNIT_ODT_CONTROL_REG)
+
+
+        /* we will check what device we are running and perform
+        Initialization according to device value */
+
+_extModeODTEnd:
+
+        /* Implement Guideline (GL# MEM-2) P_CAL Automatic Calibration  */
+        /* Does Not Work for Address/Control and Data Pads.             */
+        /* Relevant for: 88F5181-A1/B0 and 88F5281-A0                   */
+
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r6, r5);
+        /* Read device revision */
+	MV_CTRL_REV_GET_ASM(r8, r5);
+
+	/* Continue if OrionN */
+        ldr     r5, =MV_5180_DEV_ID
+        cmp     r6, r5
+        bne     1f
+        b     glMem2End
+1:
+
+	/* Continue if Orion1 and device revision B1 */
+        ldr     r5, =MV_5181_DEV_ID
+        cmp     r6, r5
+        bne     1f
+
+        cmp     r8, #MV_5181_B1_REV
+        bge     glMem2End
+        b       glMem2Start
+1:
+
+        /* Orion NAS */
+        ldr     r5, =MV_5182_DEV_ID
+        cmp     r6, r5
+        beq     glMem2Start
+
+        /* Orion Shark */
+        ldr     r5, =MV_8660_DEV_ID
+        cmp     r6, r5
+        beq     glMem2Start
+
+	b	glMem2End
+
+glMem2Start:
+
+        /* DDR SDRAM Address/Control Pads Calibration                   */
+        MV_REG_READ_ASM (r6, r5, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+        /* Set Bit [31] to make the register writable                   */
+        orr   r8, r6, #SDRAM_WR_EN
+
+        MV_REG_WRITE_ASM (r8, r5, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+        bic   r6, r6, #SDRAM_WR_EN      /* Make register read-only      */
+        bic   r6, r6, #SDRAM_TUNE_EN    /* Disable auto calibration     */
+        bic   r6, r6, #SDRAM_DRVN_MASK  /* Clear r5[5:0]<DrvN>          */
+        bic   r6, r6, #SDRAM_DRVP_MASK  /* Clear r5[11:6]<DrvP>         */
+
+        /* Get the final N locked value of driving strength [22:17]     */
+        mov   r5, r6
+        mov   r5, r5, LSL #9
+        mov   r5, r5, LSR #26    /* r5[5:0]<DrvN>  = r6[22:17]<LockN>   */
+        orr   r5, r5, r5, LSL #6 /* r5[11:6]<DrvP> = r5[5:0]<DrvN>      */
+
+        /* Write to both <DrvN> bits [5:0] and <DrvP> bits [11:6]       */
+        orr   r6, r6, r5
+
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+
+        /* DDR SDRAM Data Pads Calibration                              */
+        MV_REG_READ_ASM (r6, r5, SDRAM_DATA_PADS_CAL_REG)
+
+        /* Set Bit [31] to make the register writable                   */
+        orr   r8, r6, #SDRAM_WR_EN
+
+        MV_REG_WRITE_ASM (r8, r5, SDRAM_DATA_PADS_CAL_REG)
+
+        bic   r6, r6, #SDRAM_WR_EN      /* Make register read-only      */
+        bic   r6, r6, #SDRAM_TUNE_EN    /* Disable auto calibration     */
+        bic   r6, r6, #SDRAM_DRVN_MASK  /* Clear r5[5:0]<DrvN>          */
+        bic   r6, r6, #SDRAM_DRVP_MASK  /* Clear r5[11:6]<DrvP>         */
+
+        /* Get the final N locked value of driving strength [22:17]     */
+        mov   r5, r6
+        mov   r5, r5, LSL #9
+        mov   r5, r5, LSR #26
+        orr   r5, r5, r5, LSL #6 /* r5[5:0] = r6[22:17]<LockN>  */
+
+        /* Write to both <DrvN> bits [5:0] and <DrvP> bits [11:6]       */
+        orr   r6, r6, r5
+
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_DATA_PADS_CAL_REG)
+
+glMem2End:
+        /* Implement Guideline (GL# MEM-3) Drive Strength Value         */
+        /* Relevant for: 88F5181-A1/B0/B1 and 88F5281-A0/B0             */
+
+        /* Get SDRAM Config value */
+        MV_REG_READ_ASM (r8, r5, SDRAM_CONFIG_REG)
+
+        /* Get DIMM type */
+        tst     r8, #SDRAM_DTYPE_DDR2
+        beq     ddr1StrengthVal
+
+ddr2StrengthVal:
+        ldr     r4, =DDR2_ADDR_CTRL_PAD_STRENGTH_TYPICAL_DV
+        ldr     r8, =DDR2_DATA_PAD_STRENGTH_TYPICAL_DV
+        b       setDrvStrength
+ddr1StrengthVal:
+        ldr     r4, =DDR1_ADDR_CTRL_PAD_STRENGTH_TYPICAL_DV
+        ldr     r8, =DDR1_DATA_PAD_STRENGTH_TYPICAL_DV
+
+setDrvStrength:
+        /* DDR SDRAM Address/Control Pads Calibration                   */
+        MV_REG_READ_ASM (r6, r5, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+        orr   r6, r6, #SDRAM_WR_EN      /* Make register writeable      */
+
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+        HTOLL(r6,r5)
+
+        bic   r6, r6, #SDRAM_WR_EN      /* Make register read-only      */
+        bic   r6, r6, #SDRAM_PRE_DRIVER_STRENGTH_MASK
+        orr   r6, r4, r6                /* Set default value for DDR    */
+
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+
+        /* DDR SDRAM Data Pads Calibration                              */
+        MV_REG_READ_ASM (r6, r5, SDRAM_DATA_PADS_CAL_REG)
+
+        orr   r6, r6, #SDRAM_WR_EN      /* Make register writeable      */
+
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_DATA_PADS_CAL_REG)
+        HTOLL(r6,r5)
+
+        bic   r6, r6, #SDRAM_WR_EN      /* Make register read-only      */
+        bic   r6, r6, #SDRAM_PRE_DRIVER_STRENGTH_MASK
+        orr   r6, r8, r6                /* Set default value for DDR    */
+
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_DATA_PADS_CAL_REG)
+
+
+        /* Implement Guideline (GL# MEM-4) DQS Reference Delay Tuning   */
+        /* Relevant for: 88F5181-A1/B0/B1 and 88F5281-A0/B0             */
+        /* Get the "sample on reset" register for the DDR frequancy     */
+
+#if defined(MV_RUN_FROM_FLASH)
+	/* Calc the absolute address of the _cpuARMDDRCLK[] in the boot flash */
+	ldr   r7, = _cpuARMDDRCLK
+	ldr	r4, =_start
+	ldr	r4, [r4]
+	sub   r7, r7, r4
+         ldr   r4, = Lrom_start_of_data
+         ldr	r4, [r4]
+         add   r7, r4, r7
+#else
+	/* Calc the absolute address of the _cpuARMDDRCLK[] in the boot flash */
+	ldr     r7, = _cpuARMDDRCLK
+	ldr	r4, =_start
+	sub     r7, r7, r4
+	add	r7, r7, #CFG_MONITOR_BASE
+#endif
+        /* Get the "sample on reset" register for the DDR frequancy     */
+        MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+        ldr     r5, =MSAR_ARMDDRCLCK_MASK
+        and     r5, r4, r5
+#if 0 /* YOTAM TO BE FIX */
+	mov    r5, r5, LSR #MSAR_ARMDDRCLCK_OFFS
+#endif
+
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r6, r8);
+
+        /* Continue if TC90 */
+        ldr     r8, =MV_1281_DEV_ID
+        cmp     r6, r6
+        beq     armClkMsb
+
+        /* Continue if Orion2 */
+        ldr     r8, =MV_5281_DEV_ID
+        cmp     r6, r8
+#if 0 /* YOTAM TO BE FIX */
+        bne     1f
+#endif
+
+armClkMsb:
+#if 0 /* YOTAM TO BE FIX */
+        tst    r4, #MSAR_ARMDDRCLCK_H_MASK
+        beq    1f
+        orr    r5, r5, #BIT4
+1:
+	ldr    r4, =MV_CPU_ARM_CLK_ELM_SIZE
+	mul    r5, r4, r5
+	add    r7, r7, r5
+	add    r7, r7, #MV_CPU_ARM_CLK_DDR_OFF
+	ldr    r5, [r7]
+#endif
+
+        /* Get SDRAM Config value */
+        MV_REG_READ_ASM (r8, r4, SDRAM_CONFIG_REG)
+
+        /* Get DIMM type */
+        tst     r8, #SDRAM_DTYPE_DDR2
+        beq     ddr1FtdllVal
+
+ddr2FtdllVal:
+        ldr    r4, =FTDLL_DDR2_250MHZ
+	ldr    r7, =_250MHz
+        cmp    r5, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_200MHZ
+	ldr    r7, =_200MHz
+        cmp    r5, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_166MHZ
+	ldr    r7, =_166MHz
+        cmp    r5, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_133MHZ
+        b       setFtdllReg
+
+ddr1FtdllVal:
+        ldr    r4, =FTDLL_DDR1_200MHZ
+	ldr    r7, =_200MHz
+        cmp    r5, r7
+        beq    setFtdllReg
+        ldr    r4, =FTDLL_DDR1_166MHZ
+	ldr    r7, =_166MHz
+        cmp    r5, r7
+        beq    setFtdllReg
+        ldr    r4, =FTDLL_DDR1_133MHZ
+	ldr    r7, =_133MHz
+        cmp    r5, r7
+        beq    setFtdllReg
+        ldr    r4, =0
+
+setFtdllReg:
+
+#if !defined(MV_88W8660) && !defined(MV_88F6183) && !defined(MV_88F6183L)
+        MV_REG_READ_ASM (r8, r5, SDRAM_FTDLL_CONFIG_REG)
+        orr    r8, r8, r4
+        MV_REG_WRITE_ASM (r8, r5, SDRAM_FTDLL_CONFIG_REG)
+        bic   r8, r8, #1
+        MV_REG_WRITE_ASM (r8, r5, SDRAM_FTDLL_CONFIG_REG)
+#endif /* !defined(MV_88W8660) && !defined(MV_88F6183) && !defined(MV_88F6183L)*/
+
+
+setTimingReg:
+        /* Set default Timing parameters */
+        MV_REG_READ_ASM (r8, r5, SDRAM_CONFIG_REG)
+        tst     r8, #SDRAM_DTYPE_DDR2
+        bne     ddr2TimeParam
+
+ddr1TimeParam:
+        ldr     r6, =DDR1_TIMING_LOW_DV
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_TIMING_CTRL_LOW_REG)
+        ldr     r6, =DDR1_TIMING_HIGH_DV
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_TIMING_CTRL_HIGH_REG)
+        b       timeParamDone
+
+ddr2TimeParam:
+        ldr     r6, =DDR2_TIMING_LOW_DV
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_TIMING_CTRL_LOW_REG)
+        ldr     r6, =DDR2_TIMING_HIGH_DV
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_TIMING_CTRL_HIGH_REG)
+
+timeParamDone:
+        /* Open CS[0] window to requested size and enable it. Disable other   */
+	/* windows 							      */
+        ldr	r6, =SCBAR_BASE_MASK
+        sub     r3, r3, #1
+        and	r3, r3, r6
+	orr	r3, r3, #1	/* Enable bank */
+        MV_REG_WRITE_ASM (r3, r5, SDRAM_SIZE_REG(0))
+        ldr	r6, =0
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(1))
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(2))
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(3))
+
+exit_ddrAutoConfig:
+        mov     PC, r11         /* r11 is saved link register */
+
+
+/***************************************************************************************/
+/*       r4 holds I2C EEPROM address
+ *       r7 holds I2C EEPROM offset parameter for i2cRead and its --> returned value
+ *       r8 holds SDRAM various configuration registers value.
+ *	r13 holds Link register
+ */
+/**************************/
+_getDensity:
+	mov     r13, LR                            /* Save link register */
+
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR       /* reading from DIMM0      */
+        mov     r7, #NUM_OF_ROWS_OFFSET            /* offset  3               */
+        bl      _i2cRead
+        mov     r8, r7                             /* r8 save number of rows  */
+
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR       /* reading from DIMM0      */
+        mov     r7, #NUM_OF_COLS_OFFSET            /* offset  4               */
+        bl      _i2cRead
+        add     r8, r8, r7                         /* r8 = number of rows + number of col */
+
+        mov     r7, #0x1
+        mov     r8, r7, LSL r8                     /* r8 = (1 << r8)          */
+
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR       /* reading from DIMM0      */
+        mov     r7, #SDRAM_WIDTH_OFFSET            /* offset 13 */
+        bl      _i2cRead
+        mul     r8, r7, r8
+
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR       /* reading from DIMM0      */
+        mov     r7, #NUM_OF_BANKS_OFFSET           /* offset 17               */
+        bl      _i2cRead
+        mul     r7, r8, r7
+
+	mov     PC, r13
+
+/**************************/
+_get_width:
+	mov     r13, LR                 /* Save link register */
+
+        /* Get SDRAM width (SPD offset 13) */
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+        mov     r7, #SDRAM_WIDTH_OFFSET
+        bl      _i2cRead                /* result in r7                       */
+
+	mov     PC, r13
+
+/**************************/
+_get_CAL:
+	mov     r13, LR                 /* Save link register */
+
+        /* Set maximum CL supported by DIMM */
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+        mov     r7, #SUPPORTED_CL_OFFSET     /* offset  18 */
+        bl      _i2cRead
+
+	mov     PC, r13
+
+/**************************/
+/* R8 - sdram configuration register.
+ * Return value in flag if no-registered then Z-flag is set
+ */
+_is_Registered:
+	mov     r13, LR                 /* Save link register */
+
+        /* Get registered/non registered info from DIMM */
+        tst     r8, #SDRAM_DTYPE_DDR2
+        bne     regDdr2
+
+regDdr1:
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+        mov     r7, #SDRAM_MODULES_ATTR_OFFSET
+        bl      _i2cRead                /* result in r7                       */
+        tst     r7, #0x2
+	b	exit
+regDdr2:
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+        mov     r7, #DIMM_TYPE_INFO_OFFSET
+        bl      _i2cRead                /* result in r7                       */
+        tst     r7, #0x11               /* DIMM type = regular RDIMM (0x01)   */
+                                        /* or Mini-RDIMM (0x10)               */
+exit:
+        mov     PC, r13
+
+
+#endif
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S
new file mode 100644
index 0000000..efb088e
--- /dev/null
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S
@@ -0,0 +1,668 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvDramIfBasicAsm.s
+*
+* DESCRIPTION:
+*       Memory full detection and best timing configuration is done in
+*       C code. C runtime environment requires a stack. This module API
+*       initialize DRAM interface chip select 0 for basic functionality for
+*       the use of stack.
+*       The module API assumes DRAM information is stored in I2C EEPROM reside
+*       in a given I2C address MV_BOARD_DIMM0_I2C_ADDR. The I2C EEPROM
+*       internal data structure is assumed to be orgenzied in common DRAM
+*       vendor SPD structure.
+*       NOTE: DFCDL values are assumed to be already initialized prior to
+*       this module API activity.
+*
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+/* includes */
+#define MV_ASMLANGUAGE
+#include "mvOsAsm.h"
+#include "mvSysHwConfig.h"
+#include "mvDramIfRegs.h"
+#include "mvDramIfConfig.h"
+#include "mvCpuIfRegs.h"
+#include "pex/mvPexRegs.h"
+#include "pci/mvPciRegs.h"
+#include "mvCtrlEnvSpec.h"
+#include "mvCtrlEnvAsm.h"
+#include "cpu/mvCpuArm.h"
+#include "mvCommon.h"
+
+/* defines  */
+
+/* locals   */
+.data
+.globl _mvDramIfConfig
+
+.text
+
+/*******************************************************************************
+* _mvDramIfConfig - Basic DRAM interface initialization.
+*
+* DESCRIPTION:
+*       The function will initialize the following DRAM parameters using the
+*       values prepared by mvDramIfDetect routine. Values are located
+*       in predefined registers.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+
+_mvDramIfConfig:
+
+        /* Save register on stack */
+	cmp	sp, #0
+	beq	no_stack_s
+save_on_stack:
+        stmdb	sp!, {r1, r2, r3, r4, r7, r11}
+no_stack_s:
+
+	/* 1) Write to SDRAM coniguration register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG1)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_CONFIG_REG)
+        str     r4, [r1]
+
+	/* 2) Write Dunit control low register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG3)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_DUNIT_CTRL_REG)
+        str     r4, [r1]
+
+        /* 3) Write SDRAM address control register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG4)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_ADDR_CTRL_REG)
+        str     r4, [r1]
+
+        /* 4) Write SDRAM bank 0 size register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG0)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_SIZE_REG(0))
+        str     r4, [r1]
+
+        /* 5) Write SDRAM open pages control register */
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_OPEN_PAGE_CTRL_REG)
+        ldr     r4, =SDRAM_OPEN_PAGES_CTRL_REG_DV
+        str     r4, [r1]
+
+        /* 6) Write SDRAM timing Low register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG5)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_TIMING_CTRL_LOW_REG)
+        str     r4, [r1]
+
+        /* 7) Write SDRAM timing High register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG6)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_TIMING_CTRL_HIGH_REG)
+        str     r4, [r1]
+
+        /* 8) Write SDRAM mode register */
+        /* The CPU must not attempt to change the SDRAM Mode register setting */
+        /* prior to DRAM controller completion of the DRAM initialization     */
+        /* sequence. To guarantee this restriction, it is recommended that    */
+        /* the CPU sets the SDRAM Operation register to NOP command, performs */
+        /* read polling until the register is back in Normal operation value, */
+        /* and then sets SDRAM Mode register to its new value.               */
+
+	/* 8.1 write 'nop' to SDRAM operation */
+        mov     r4, #0x5                 /* 'NOP' command              */
+        MV_REG_WRITE_ASM(r4, r1, SDRAM_OPERATION_REG)
+
+        /* 8.2 poll SDRAM operation. Make sure its back to normal operation   */
+_sdramOpPoll1:
+        ldr     r4, [r1]
+        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll1
+
+        /* 8.3 Now its safe to write new value to SDRAM Mode register         */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG2)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_MODE_REG)
+        str     r4, [r1]
+
+        /* 8.4 Make the Dunit write the DRAM its new mode                     */
+        mov     r4, #0x3                 /* Mode Register Set command  */
+        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_REG)
+
+        /* 8.5 poll SDRAM operation. Make sure its back to normal operation   */
+_sdramOpPoll2:
+        ldr     r4, [r1]
+        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll2
+
+#ifndef DB_FPGA
+        /* Config DDR2 registers (Extended mode, ODTs and pad calibration)    */
+        MV_REG_READ_ASM (r4, r1, SDRAM_CONFIG_REG)
+        tst     r4, #SDRAM_DTYPE_DDR2
+        beq     _extModeODTEnd
+#endif /* DB_FPGA */
+
+        /* 9) Write SDRAM Extended mode register This operation should be     */
+        /*    done for each memory bank                                       */
+        /* write 'nop' to SDRAM operation */
+        mov     r4, #0x5                 /* 'NOP' command              */
+        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_REG)
+
+        /* poll SDRAM operation. Make sure its back to normal operation   */
+_sdramOpPoll3:
+        ldr     r4, [r1]
+        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll3
+
+        /* Now its safe to write new value to SDRAM Extended Mode register    */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG10)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_EXTENDED_MODE_REG)
+        str     r4, [r1]
+
+        /* Go over each of the Banks */
+        ldr     r3, =0          /* r3 = DRAM bank Num */
+
+extModeLoop:
+        /* Set the SDRAM Operation Control to each of the DRAM banks          */
+        mov     r2, r3   /* Do not swap the bank counter value */
+        MV_REG_WRITE_ASM (r2, r1, SDRAM_OPERATION_CTRL_REG)
+
+        /* Make the Dunit write the DRAM its new mode                     */
+        mov     r4, #0x4        /* Extended Mode Register Set command  */
+        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_REG)
+
+        /* poll SDRAM operation. Make sure its back to normal operation   */
+_sdramOpPoll4:
+        ldr     r4, [r1]
+        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll4
+#ifndef DB_FPGA
+        add     r3, r3, #1
+        cmp     r3, #4         /* 4 = Number of banks */
+        bne     extModeLoop
+
+extModeEnd:
+        /* Config DDR2 On Die Termination (ODT) registers */
+        /* Write SDRAM DDR2 ODT control low register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG7)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + DDR2_SDRAM_ODT_CTRL_LOW_REG)
+        str     r4, [r1]
+
+        /* Write SDRAM DDR2 ODT control high register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG8)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + DDR2_SDRAM_ODT_CTRL_HIGH_REG)
+        str     r4, [r1]
+
+        /* Write SDRAM DDR2 Dunit ODT control register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG9)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + DDR2_DUNIT_ODT_CONTROL_REG)
+        str     r4, [r1]
+
+#endif /* DB_FPGA */
+_extModeODTEnd:
+#ifndef DB_FPGA
+        /* Implement Guideline (GL# MEM-2) P_CAL Automatic Calibration  */
+        /* Does Not Work for Address/Control and Data Pads.             */
+        /* Relevant for: 88F5181-A1/B0 and 88F5281-A0                   */
+
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r3, r1);
+        /* Read device revision */
+	MV_CTRL_REV_GET_ASM(r2, r1);
+
+	/* Continue if OrionN */
+        ldr     r1, =MV_5180_DEV_ID
+        cmp     r3, r1
+        bne     1f
+        b     glMem2End
+1:
+        /* Continue if Orion1 and device revision B1 */
+        ldr     r1, =MV_5181_DEV_ID
+        cmp     r3, r1
+        bne     1f
+
+        cmp     r2, #MV_5181_B1_REV
+        bge     glMem2End
+        b       glMem2Start
+1:
+
+        /* Orion NAS */
+        ldr     r1, =MV_5182_DEV_ID
+        cmp     r3, r1
+        beq     glMem2Start
+
+        /* Orion NAS */
+        ldr     r1, =MV_5082_DEV_ID
+        cmp     r3, r1
+        beq     glMem2Start
+
+        /* Orion Shark */
+        ldr     r1, =MV_8660_DEV_ID
+        cmp     r3, r1
+        beq     glMem2Start
+
+	b	glMem2End
+
+glMem2Start:
+
+        /* DDR SDRAM Address/Control Pads Calibration                         */
+        MV_REG_READ_ASM (r3, r1, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+        /* Set Bit [31] to make the register writable                   */
+        orr   r2, r3, #SDRAM_WR_EN
+
+        MV_REG_WRITE_ASM (r2, r1, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+        bic   r3, r3, #SDRAM_WR_EN      /* Make register read-only      */
+        bic   r3, r3, #SDRAM_TUNE_EN    /* Disable auto calibration     */
+        bic   r3, r3, #SDRAM_DRVN_MASK  /* Clear r1[5:0]<DrvN>          */
+        bic   r3, r3, #SDRAM_DRVP_MASK  /* Clear r1[11:6]<DrvP>         */
+
+        /* Get the final N locked value of driving strength [22:17]     */
+        mov   r1, r3
+        mov   r1, r1, LSL #9
+        mov   r1, r1, LSR #26    /* r1[5:0]<DrvN>  = r3[22:17]<LockN>   */
+        orr   r1, r1, r1, LSL #6 /* r1[11:6]<DrvP> = r1[5:0]<DrvN>      */
+
+        /* Write to both <DrvN> bits [5:0] and <DrvP> bits [11:6]       */
+        orr   r3, r3, r1
+
+        MV_REG_WRITE_ASM (r3, r1, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+
+        /* DDR SDRAM Data Pads Calibration                         	*/
+        MV_REG_READ_ASM (r3, r1, SDRAM_DATA_PADS_CAL_REG)
+
+        /* Set Bit [31] to make the register writable                   */
+        orr   r2, r3, #SDRAM_WR_EN
+
+        MV_REG_WRITE_ASM (r2, r1, SDRAM_DATA_PADS_CAL_REG)
+
+        bic   r3, r3, #SDRAM_WR_EN      /* Make register read-only      */
+        bic   r3, r3, #SDRAM_TUNE_EN    /* Disable auto calibration     */
+        bic   r3, r3, #SDRAM_DRVN_MASK  /* Clear r1[5:0]<DrvN>          */
+        bic   r3, r3, #SDRAM_DRVP_MASK  /* Clear r1[11:6]<DrvP>         */
+
+        /* Get the final N locked value of driving strength [22:17]     */
+        mov   r1, r3
+        mov   r1, r1, LSL #9
+        mov   r1, r1, LSR #26
+        orr   r1, r1, r1, LSL #6 /* r1[5:0] = r3[22:17]<LockN>  */
+
+        /* Write to both <DrvN> bits [5:0] and <DrvP> bits [11:6]       */
+        orr   r3, r3, r1
+
+        MV_REG_WRITE_ASM (r3, r1, SDRAM_DATA_PADS_CAL_REG)
+
+glMem2End:
+
+
+        /* Implement Guideline (GL# MEM-3) Drive Strength Value         */
+        /* Relevant for: 88F5181-A1/B0/B1, 88F5281-A0/B0/C/D, 88F5182,  */
+	/* 88F5082, 88F5181L, 88F6082/L, 88F6183, 88F6183L */
+
+        /* Get SDRAM Config value */
+        MV_REG_READ_ASM (r2, r1, SDRAM_CONFIG_REG)
+
+        /* Get DIMM type */
+        tst     r2, #SDRAM_DTYPE_DDR2
+        beq     ddr1StrengthVal
+
+ddr2StrengthVal:
+        ldr     r4, =DDR2_ADDR_CTRL_PAD_STRENGTH_TYPICAL_DV
+        ldr     r2, =DDR2_DATA_PAD_STRENGTH_TYPICAL_DV
+        b       setDrvStrength
+ddr1StrengthVal:
+        ldr     r4, =DDR1_ADDR_CTRL_PAD_STRENGTH_TYPICAL_DV
+        ldr     r2, =DDR1_DATA_PAD_STRENGTH_TYPICAL_DV
+
+setDrvStrength:
+        /* DDR SDRAM Address/Control Pads Calibration                   */
+        MV_REG_READ_ASM (r3, r1, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+        orr   r3, r3, #SDRAM_WR_EN      /* Make register writeable      */
+
+        MV_REG_WRITE_ASM (r3, r1, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+        HTOLL(r3,r1)
+
+        bic   r3, r3, #SDRAM_WR_EN      /* Make register read-only      */
+        bic   r3, r3, #SDRAM_PRE_DRIVER_STRENGTH_MASK
+        orr   r3, r4, r3                /* Set default value for DDR    */
+
+        MV_REG_WRITE_ASM (r3, r1, SDRAM_ADDR_CTRL_PADS_CAL_REG)
+
+
+        /* DDR SDRAM Data Pads Calibration                         	      */
+        MV_REG_READ_ASM (r3, r1, SDRAM_DATA_PADS_CAL_REG)
+
+        orr   r3, r3, #SDRAM_WR_EN      /* Make register writeable      */
+
+        MV_REG_WRITE_ASM (r3, r1, SDRAM_DATA_PADS_CAL_REG)
+        HTOLL(r3,r1)
+
+        bic   r3, r3, #SDRAM_WR_EN      /* Make register read-only      */
+        bic   r3, r3, #SDRAM_PRE_DRIVER_STRENGTH_MASK
+        orr   r3, r2, r3                /* Set default value for DDR    */
+
+        MV_REG_WRITE_ASM (r3, r1, SDRAM_DATA_PADS_CAL_REG)
+
+#if !defined(MV_88W8660) && !defined(MV_88F6183) && !defined(MV_88F6183L)
+        /* Implement Guideline (GL# MEM-4) DQS Reference Delay Tuning   */
+        /* Relevant for: 88F5181-A1/B0/B1 and 88F5281-A0/B0/C/D, 88F5182 */
+	/* 88F5082, 88F5181L, 88F6082/L */
+
+	/* Calc the absolute address of the _cpuARMDDRCLK[] in the boot flash */
+	ldr     r7, = _cpuARMDDRCLK
+	ldr	r4, =_start
+	sub     r7, r7, r4
+	add	r7, r7, #CFG_MONITOR_BASE
+
+        /* Get the "sample on reset" register for the DDR frequancy     */
+        MV_REG_READ_ASM (r4, r1, MPP_SAMPLE_AT_RESET)
+        ldr     r1, =MSAR_ARMDDRCLCK_MASK
+        and     r1, r4, r1
+#if 0 /* YOTAM TO BE FIX */
+	mov    r1, r1, LSR #MSAR_ARMDDRCLCK_OFFS
+#endif
+
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r3, r2);
+
+        /* Continue if TC90 */
+        ldr     r2, =MV_1281_DEV_ID
+        cmp     r3, r2
+        beq     armClkMsb
+
+        /* Continue if Orion2 */
+        ldr     r2, =MV_5281_DEV_ID
+        cmp     r3, r2
+#if 0 /* YOTAM TO BE FIX */
+        bne     1f
+#endif
+
+armClkMsb:
+#if 0 /* YOTAM TO BE FIX */
+	tst    r4, #MSAR_ARMDDRCLCK_H_MASK
+        beq    1f
+        orr    r1, r1, #BIT4
+1:
+	ldr    r4, =MV_CPU_ARM_CLK_ELM_SIZE
+	mul    r1, r4, r1
+	add    r7, r7, r1
+	add    r7, r7, #MV_CPU_ARM_CLK_DDR_OFF
+	ldr    r1, [r7]
+#endif
+
+        /* Get SDRAM Config value */
+        MV_REG_READ_ASM (r2, r4, SDRAM_CONFIG_REG)
+
+        /* Get DIMM type */
+        tst     r2, #SDRAM_DTYPE_DDR2
+        beq     ddr1FtdllVal
+
+ddr2FtdllVal:
+        ldr     r2, =MV_5281_DEV_ID
+        cmp     r3, r2
+	bne	2f
+    	MV_CTRL_REV_GET_ASM(r3, r2)
+        cmp     r3, #MV_5281_D0_REV
+        beq     orin2_d0_ddr2_ftdll_val
+        cmp     r3, #MV_5281_D1_REV
+        beq     orin2_d1_ddr2_ftdll_val
+        cmp     r3, #MV_5281_D2_REV
+        beq     orin2_d1_ddr2_ftdll_val
+	b	ddr2_default_val
+
+/* Set Orion 2 D1 ftdll values for DDR2 */
+orin2_d1_ddr2_ftdll_val:
+	ldr    r4, =FTDLL_DDR2_250MHZ_5281_D1
+	ldr    r7, =_250MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_200MHZ_5281_D1
+	ldr    r7, =_200MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_166MHZ_5281_D0
+	ldr    r7, =_166MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+	b	ddr2_default_val
+
+/* Set Orion 2 D0 ftdll values for DDR2 */
+orin2_d0_ddr2_ftdll_val:
+	ldr    r4, =FTDLL_DDR2_250MHZ_5281_D0
+	ldr    r7, =_250MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_200MHZ_5281_D0
+	ldr    r7, =_200MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_166MHZ_5281_D0
+	ldr    r7, =_166MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+	b       ddr2_default_val
+2:
+        ldr     r2, =MV_5182_DEV_ID
+        cmp     r3, r2
+	bne	3f
+
+/* Set Orion nas ftdll values for DDR2 */
+orin_nas_ftdll_val:
+        ldr     r4, =FTDLL_DDR2_166MHZ_5182
+	ldr    r7, =_166MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+
+/* default values for all other devices */
+3:
+ddr2_default_val:
+        ldr    r4, =FTDLL_DDR2_250MHZ
+	ldr    r7, =_250MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_200MHZ
+	ldr    r7, =_200MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_166MHZ
+	ldr    r7, =_166MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR2_133MHZ
+	ldr    r7, =_133MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+        ldr    r4, =0
+        b       setFtdllReg
+
+ddr1FtdllVal:
+        ldr     r2, =MV_5281_DEV_ID
+        cmp     r3, r2
+	bne	2f
+    	MV_CTRL_REV_GET_ASM(r3, r2)
+        cmp     r3, #MV_5281_D0_REV
+        bge     orin2_ddr1_ftdll_val
+	b	ddr1_default_val
+
+/* Set Orion 2 D0 and above ftdll values for DDR1 */
+orin2_ddr1_ftdll_val:
+        ldr     r4, =FTDLL_DDR1_200MHZ_5281_D0
+	ldr    r7, =_200MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+        ldr     r4, =FTDLL_DDR1_166MHZ_5281_D0
+	ldr    r7, =_166MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+	b       ddr1_default_val
+2:
+        ldr     r2, =MV_5181_DEV_ID
+        cmp     r3, r2
+	bne	3f
+    	MV_CTRL_REV_GET_ASM(r3, r2)
+        cmp     r3, #MV_5181_B1_REV
+        bge     orin1_ddr1_ftdll_val
+	b	ddr1_default_val
+
+/* Set Orion 1 ftdll values for DDR1 */
+orin1_ddr1_ftdll_val:
+        ldr     r4, =FTDLL_DDR1_166MHZ_5181_B1
+	ldr    r7, =_166MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+3:
+ddr1_default_val:
+        ldr    r4, =FTDLL_DDR1_133MHZ
+	ldr    r7, =_133MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+
+        ldr    r4, =FTDLL_DDR1_166MHZ
+	ldr    r7, =_166MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+
+        ldr    r4, =FTDLL_DDR1_200MHZ
+	ldr    r7, =_200MHz
+        cmp    r1, r7
+        beq    setFtdllReg
+
+        ldr    r4, =0
+
+setFtdllReg:
+
+        MV_REG_WRITE_ASM (r4, r1, SDRAM_FTDLL_CONFIG_REG)
+        HTOLL(r4,r1)
+        bic   r4, r4, #1
+        MV_REG_WRITE_ASM (r4, r1, SDRAM_FTDLL_CONFIG_REG)
+
+#endif /* !defined(MV_88W8660) && !defined(MV_88F6183) && !defined(MV_88F6183L) */
+#endif /* DB_FPGA */
+
+restoreTmpRegs:
+        /* Restore the registers we used to save the DDR detect values */
+
+        ldr     r4, =DRAM_BUF_REG0_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG0)
+
+        ldr     r4, =DRAM_BUF_REG1_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG1)
+
+        ldr     r4, =DRAM_BUF_REG2_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG2)
+
+        ldr     r4, =DRAM_BUF_REG3_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG3)
+
+        ldr     r4, =DRAM_BUF_REG4_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG4)
+
+        ldr     r4, =DRAM_BUF_REG5_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG5)
+
+        ldr     r4, =DRAM_BUF_REG6_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG6)
+
+        ldr     r4, =DRAM_BUF_REG7_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG7)
+
+        ldr     r4, =DRAM_BUF_REG8_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG8)
+
+        ldr     r4, =DRAM_BUF_REG9_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG9)
+
+        ldr     r4, =DRAM_BUF_REG10_DV
+        MV_REG_WRITE_ASM (r4, r1, DRAM_BUF_REG10)
+
+
+        /* Restore registers */
+        /* Save register on stack */
+	cmp	sp, #0
+	beq	no_stack_l
+load_from_stack:
+        ldmia	sp!, {r1, r2, r3, r4, r7, r11}
+no_stack_l:
+
+        mov     pc, lr
+
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.h
index a7c6644..8ad869e 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -83,7 +83,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 		 SDRAM_LOCKEN_ENABLE)
 
 #define SDRAM_ADDR_CTRL_DV	    0
-		
+
 #define SDRAM_TIMING_CTRL_LOW_REG_DV 	\
 		((0x2 << SDRAM_TRCD_OFFS)	|	\
 		 (0x2 << SDRAM_TRP_OFFS)	|	\
@@ -96,7 +96,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 					( 0x2 << SDRAM_TRFC_EXT_OFFS)	|\
 					( 0x1 << SDRAM_TW2W_OFFS))
 
-#define SDRAM_OPEN_PAGES_CTRL_REG_DV	SDRAM_OPEN_PAGE_EN	
+#define SDRAM_OPEN_PAGES_CTRL_REG_DV	SDRAM_OPEN_PAGE_EN
 
 /* DDR2 ODT default register values */
 
@@ -124,8 +124,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 		(1 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
 #define DDR2_ADDR_CTRL_PAD_STRENGTH_TYPICAL_DV	\
 		(3 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
-		
-		
+
+
 #define DDR1_DATA_PAD_STRENGTH_TYPICAL_DV		\
 		(1 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
 #define DDR2_DATA_PAD_STRENGTH_TYPICAL_DV		\
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfRegs.h
index e9cd7c4..2ff0db4 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -69,11 +69,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* DDR SDRAM Controller Address Decode Registers */
 /* SDRAM CSn Base Address Register (SCBAR) */
 #define SDRAM_BASE_ADDR_REG(csNum)	(0x1500 + (csNum * 8))
-#define SCBAR_BASE_OFFS				16 
+#define SCBAR_BASE_OFFS				16
 #define SCBAR_BASE_MASK				(0xffff << SCBAR_BASE_OFFS)
-#define SCBAR_BASE_ALIGNMENT		0x10000 
+#define SCBAR_BASE_ALIGNMENT		0x10000
 
-/* SDRAM CSn Size Register (SCSR) */		  
+/* SDRAM CSn Size Register (SCSR) */
 #define SDRAM_SIZE_REG(csNum)	(0x1504 + (csNum * 8))
 #define SCSR_WIN_EN					BIT0
 #define SCSR_SIZE_OFFS				16
@@ -212,9 +212,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define SDRAM_WR_MAX		7
 #define SDRAM_WR_MASK		(SDRAM_WR_MAX << SDRAM_WR_OFFS)
 #define SDRAM_PD_OFFS		12
-#define SDRAM_PD_MASK		(1 << SDRAM_PD_OFFS) 
-#define SDRAM_PD_FAST_EXIT	(0 << SDRAM_PD_OFFS) 
-#define SDRAM_PD_SLOW_EXIT	(1 << SDRAM_PD_OFFS) 
+#define SDRAM_PD_MASK		(1 << SDRAM_PD_OFFS)
+#define SDRAM_PD_FAST_EXIT	(0 << SDRAM_PD_OFFS)
+#define SDRAM_PD_SLOW_EXIT	(1 << SDRAM_PD_OFFS)
 
 /* DDR SDRAM Extended Mode register (DSEMR) */
 #define SDRAM_EXTENDED_MODE_REG	0x1420
@@ -247,7 +247,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 /* Dunit FTDLL Configuration Register */
 #define SDRAM_FTDLL_CONFIG_REG			0x1484
-  
+
 /* Pads Calibration register */
 #define SDRAM_ADDR_CTRL_PADS_CAL_REG	0x14c0
 #define SDRAM_DATA_PADS_CAL_REG		0x14c4
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c
index a214c95..27e7042 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -116,7 +116,7 @@ MV_U32 mvDramCsSizeGet(MV_U32 csNum)
 {
 	MV_DRAM_BANK_INFO bankInfo;
 	MV_U32  size, deviceW, dimmW;
-#ifdef MV78XX0	
+#ifdef MV78XX0
 	MV_U32  temp;
 #endif
 
@@ -126,14 +126,14 @@ MV_U32 mvDramCsSizeGet(MV_U32 csNum)
 			return 0;
 
 		/* Note that the Dimm width might be different then the device DRAM width */
-#ifdef MV78XX0	
+#ifdef MV78XX0
 		temp = MV_REG_READ(SDRAM_CONFIG_REG);
 		deviceW = ((temp & SDRAM_DWIDTH_MASK) == SDRAM_DWIDTH_32BIT )? 32 : 64;
 #else
 		deviceW = 16 /* KW family */;
 #endif
 		dimmW = bankInfo.dataWidth - (bankInfo.dataWidth % 16);
-		size = ((bankInfo.size << 20) / (dimmW/deviceW)); 
+		size = ((bankInfo.size << 20) / (dimmW/deviceW));
 		return size;
 	}
 	else
@@ -143,22 +143,22 @@ MV_U32 mvDramCsSizeGet(MV_U32 csNum)
 * mvDramIfDetect - Prepare DRAM interface configuration values.
 *
 * DESCRIPTION:
-*       This function implements the full DRAM detection and timing 
+*       This function implements the full DRAM detection and timing
 *       configuration for best system performance.
-*       Since this routine runs from a ROM device (Boot Flash), its stack 
-*       resides on RAM, that might be the system DRAM. Changing DRAM 
+*       Since this routine runs from a ROM device (Boot Flash), its stack
+*       resides on RAM, that might be the system DRAM. Changing DRAM
 *       configuration values while keeping vital data in DRAM is risky. That
-*       is why the function does not preform the configuration setting but 
-*       prepare those in predefined 32bit registers (in this case IDMA 
+*       is why the function does not preform the configuration setting but
+*       prepare those in predefined 32bit registers (in this case IDMA
 *       registers are used) for other routine to perform the settings.
-*       The function will call for board DRAM SPD information for each DRAM 
-*       chip select. The function will then analyze those SPD parameters of 
-*       all DRAM banks in order to decide on DRAM configuration compatible 
+*       The function will call for board DRAM SPD information for each DRAM
+*       chip select. The function will then analyze those SPD parameters of
+*       all DRAM banks in order to decide on DRAM configuration compatible
 *       for all DRAM banks.
 *       The function will set the CPU DRAM address decode registers.
 *       Note: This routine prepares values that will overide configuration of
 *       mvDramBasicAsmInit().
-*       
+*
 * INPUT:
 *       forcedCl - Forced CAL Latency. If equal to zero, do not force.
 *       eccDisable - Force down the ECC.
@@ -186,7 +186,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 		};
 	MV_U32  busClk, deviceW, dimmW;
 	MV_U32 numOfAllDevices = 0;
-	MV_STATUS TTMode; 
+	MV_STATUS TTMode;
 #ifndef MV_STATIC_DRAM_ON_BOARD
 	MV_DRAM_BANK_INFO bankInfo[MV_DRAM_MAX_CS];
 	MV_U32  size, base = 0, i, j, temp, busClkPs;
@@ -202,14 +202,14 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 		mvOsPrintf("Dram: ERR. Can't detect system clock! \n");
 		return MV_ERROR;
 	}
-	
+
 #ifndef MV_STATIC_DRAM_ON_BOARD
 
 	busClkPs = 1000000000 / (busClk / 1000);  /* in ps units */
 	/* we will use bank 0 as the representative of the all the DRAM banks,  */
-	/* since bank 0 must exist.                                             */	
+	/* since bank 0 must exist.                                             */
 	for(i = 0; i < MV_DRAM_MAX_CS; i++)
-	{ 
+	{
 		/* if Bank exist */
 		if(MV_OK == mvDramBankInfoGet(i, &bankInfo[i]))
 		{
@@ -229,7 +229,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 			}
 
 			/* All banks must support registry in order to activate it */
-			if(bankInfo[i].registeredAddrAndControlInputs != 
+			if(bankInfo[i].registeredAddrAndControlInputs !=
 			   bankInfo[0].registeredAddrAndControlInputs)
 			{
 				mvOsOutput("Dram: ERR. different Registered settings !!!\n");
@@ -237,7 +237,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 			}
 
 			/* All banks must support same ECC mode */
-			if(bankInfo[i].errorCheckType != 
+			if(bankInfo[i].errorCheckType !=
 			   bankInfo[0].errorCheckType)
 			{
 				mvOsOutput("Dram: ERR. different ECC settings !!!\n");
@@ -291,21 +291,21 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 	for(j = 0; j < MV_DRAM_MAX_CS; j++)
 	{
 		i = MV_DRAM_CS_order[j];
-		
+
         	if (0 == bankInfo[i].size)
 			continue;
 
 			/* Init the CPU window decode */
 			/* Note that the Dimm width might be different then the device DRAM width */
-#ifdef MV78XX0	
+#ifdef MV78XX0
 			temp = MV_REG_READ(SDRAM_CONFIG_REG);
 			deviceW = ((temp & SDRAM_DWIDTH_MASK) == SDRAM_DWIDTH_32BIT )? 32 : 64;
 #else
 			deviceW = 16 /* KW family */;
 #endif
 			dimmW = bankInfo[0].dataWidth - (bankInfo[0].dataWidth % 16);
-			size = ((bankInfo[i].size << 20) / (dimmW/deviceW)); 
-		
+			size = ((bankInfo[i].size << 20) / (dimmW/deviceW));
+
 			/* We can not change DRAM window settings while excecuting  	*/
 			/* code from it. That is why we skip the DRAM CS[0], saving     */
 			/* it to the ROM configuration routine				*/
@@ -335,7 +335,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 				dramDecWin.addrWin.size = size;
 				dramDecWin.enable = MV_TRUE;
 				DB(mvOsPrintf("Dram: Enable window %d base 0x%x, size=0x%x\n",i, base, size));
-				
+
 				/* Check if the DRAM size is more then 3GByte */
 				if (base < 0xC0000000)
 				{
@@ -347,7 +347,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 					}
 				}
 			}
-			
+
 			base += size;
 
 			/* update the suportedCasLatencies mask */
@@ -356,7 +356,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 
 	/* calculate minimum CAS */
 	minCas = minCasCalc(&bankInfo[0], &bankInfo[2], busClk, forcedCl);
-	if (0 == minCas) 
+	if (0 == minCas)
 	{
 		mvOsOutput("Dram: Warn: Could not find CAS compatible to SysClk %dMhz\n",
 				   (busClk / 1000000));
@@ -374,15 +374,15 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 	}
 
 	/* check if ECC is enabled by the user */
-	if(eccDisable)	
-	{	
+	if(eccDisable)
+	{
 		/* turn off ECC*/
 		temp &= ~BIT18;
 	}
 	DB(mvOsPrintf("Dram: sdramConfigRegCalc - %x\n",temp);)
 	MV_REG_WRITE(DRAM_BUF_REG1, temp);
-	
-	/* calc SDRAM_MODE_REG  and save it to temp register */ 
+
+	/* calc SDRAM_MODE_REG  and save it to temp register */
 	temp = sdramModeRegCalc(minCas);
     	if(-1 == temp)
 	{
@@ -392,7 +392,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 	DB(mvOsPrintf("Dram: sdramModeRegCalc - %x\n",temp);)
 	MV_REG_WRITE(DRAM_BUF_REG2, temp);
 
-	/* calc SDRAM_EXTENDED_MODE_REG  and save it to temp register */ 
+	/* calc SDRAM_EXTENDED_MODE_REG  and save it to temp register */
 	temp = sdramExtModeRegCalc(&bankInfo[0], busClk);
 	if(-1 == temp)
 	{
@@ -415,17 +415,17 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 		}
 	}
 
-  	temp = dunitCtrlLowRegCalc(&bankInfo[0], minCas, busClk, TTMode ); 
+  	temp = dunitCtrlLowRegCalc(&bankInfo[0], minCas, busClk, TTMode );
    	if(-1 == temp)
 	{
 		mvOsOutput("Dram: ERR. dunitCtrlLowRegCalc failed !!!\n");
 		return MV_ERROR;
 	}
 	DB(mvOsPrintf("Dram: dunitCtrlLowRegCalc - %x\n",temp);)
-  	MV_REG_WRITE(DRAM_BUF_REG3, temp); 
+  	MV_REG_WRITE(DRAM_BUF_REG3, temp);
 
 	/* calc D_UNIT_CONTROL_HIGH  and save it to temp register */
-  	temp = dunitCtrlHighRegCalc(&bankInfo[0], busClk); 
+  	temp = dunitCtrlHighRegCalc(&bankInfo[0], busClk);
    	if(-1 == temp)
 	{
 		mvOsOutput("Dram: ERR. dunitCtrlHighRegCalc failed !!!\n");
@@ -433,12 +433,12 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 	}
 	DB(mvOsPrintf("Dram: dunitCtrlHighRegCalc - %x\n",temp);)
 	/* check if ECC is enabled by the user */
-	if(eccDisable)	
-	{	
+	if(eccDisable)
+	{
 		/* turn off sample stage if no ecc */
 		temp &= ~SDRAM__D2P_EN;;
 	}
-  	MV_REG_WRITE(DRAM_BUF_REG13, temp); 
+  	MV_REG_WRITE(DRAM_BUF_REG13, temp);
 
 	/* calc SDRAM_ADDR_CTRL_REG  and save it to temp register */
 	temp = sdramAddrCtrlRegCalc(&bankInfo[0],&bankInfo[2]);
@@ -492,7 +492,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 	DB(mvOsPrintf("Dram: sdramDdr2TimeHiRegCalc - %x\n",temp);)
 	MV_REG_WRITE(DRAM_BUF_REG12, temp);
 #endif
-	
+
 	/* Note that DDR SDRAM Address/Control and Data pad calibration     */
 	/* settings is done in mvSdramIfConfig.s                            */
 
@@ -513,7 +513,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 *       None.
 *
 * RETURN:
-*       DRAM bank size. If bank is disabled or paramter is invalid, the 
+*       DRAM bank size. If bank is disabled or paramter is invalid, the
 *		function returns -1.
 *
 *******************************************************************************/
@@ -537,7 +537,7 @@ MV_U32 mvDramIfBankBaseGet(MV_U32 bankNum)
 *       None.
 *
 * RETURN:
-*       DRAM bank size. If bank is disabled the function return '0'. In case 
+*       DRAM bank size. If bank is disabled the function return '0'. In case
 *		or paramter is invalid, the function returns -1.
 *
 *******************************************************************************/
@@ -562,17 +562,17 @@ MV_U32 mvDramIfBankSizeGet(MV_U32 bankNum)
 *       None.
 *
 * RETURN:
-*       DRAM total size. In case or paramter is invalid, the function 
+*       DRAM total size. In case or paramter is invalid, the function
 *		returns -1.
 *
 *******************************************************************************/
 MV_U32 mvDramIfSizeGet(MV_VOID)
 {
 	MV_U32 size = 0, i;
-	
+
 	for(i = 0; i < MV_DRAM_MAX_CS; i++)
 		size += mvDramIfBankSizeGet(i);
-	
+
 	DB(mvOsPrintf("Dram: mvDramIfSizeGet size is %x \n",size));
 	return size;
 }
@@ -581,7 +581,7 @@ MV_U32 mvDramIfSizeGet(MV_VOID)
 * mvDramIfSingleBitErrThresholdSet - Set single bit ECC threshold.
 *
 * DESCRIPTION:
-*       The ECC single bit error threshold is the number of single bit 
+*       The ECC single bit error threshold is the number of single bit
 *       errors to happen before the Dunit generates an interrupt.
 *       This function set single bit ECC threshold.
 *
@@ -597,7 +597,7 @@ MV_U32 mvDramIfSizeGet(MV_VOID)
 *******************************************************************************/
 MV_STATUS mvDramIfSingleBitErrThresholdSet(MV_U32 threshold)
 {
-    MV_U32 regVal; 
+    MV_U32 regVal;
 
     if (threshold > SECR_THRECC_MAX)
     {
@@ -640,23 +640,23 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO *pBankIn
 	MV_U32 busClkPs = 1000000000 / (busClk / 1000);  /* in ps units */
 	MV_U32 startBit, stopBit;
 	MV_U32 minCas0 = 0, minCas2 = 0;
-	
-	
+
+
 	/*     DDR 2:
-			*******-******-******-******-******-******-******-******* 
-			* bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-			*******-******-******-******-******-******-******-******* 
-	CAS	=	* TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  * 
-	Disco VI=	* TBD  | TBD  |  5   |  4   |  3   |  TBD   | TBD | TBD * 
-	Disco Duo=	* TBD  |   6  |  5   |  4   |  3   |  TBD   | TBD | TBD * 
+			*******-******-******-******-******-******-******-*******
+			* bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+			*******-******-******-******-******-******-******-*******
+	CAS	=	* TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  *
+	Disco VI=	* TBD  | TBD  |  5   |  4   |  3   |  TBD   | TBD | TBD *
+	Disco Duo=	* TBD  |   6  |  5   |  4   |  3   |  TBD   | TBD | TBD *
 			*********************************************************/
-	
-	
+
+
 	/* If we are asked to use the forced CAL  we change the suported CAL to be forcedCl only */
 	if (forcedCl)
 	{
 		mvOsOutput("DRAM: Using forced CL %d.%d\n", (forcedCl / 10), (forcedCl % 10));
-	
+
 			if (forcedCl == 30)
 				pBankInfo->suportedCasLatencies = 0x08;
 			else if (forcedCl == 40)
@@ -667,14 +667,14 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO *pBankIn
 				pBankInfo->suportedCasLatencies = 0x40;
 			else
 			{
-				mvOsPrintf("Forced CL %d.%d not supported. Set default CL 4\n", 
+				mvOsPrintf("Forced CL %d.%d not supported. Set default CL 4\n",
 						   (forcedCl / 10), (forcedCl % 10));
 				pBankInfo->suportedCasLatencies = 0x10;
 			}
 
-		return pBankInfo->suportedCasLatencies;        
-	}   
-	
+		return pBankInfo->suportedCasLatencies;
+	}
+
 	/* go over the supported cas mask from Max Cas down and check if the 	*/
 	/* SysClk stands in its time requirments.				*/
 
@@ -688,28 +688,28 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO *pBankIn
 			/* Reset the bits for CL incompatible for the sysClk */
 			switch (count)
 			{
-				case 1: 
-					if (pBankInfo->minCycleTimeAtMaxCasLatPs > busClkPs) 
+				case 1:
+					if (pBankInfo->minCycleTimeAtMaxCasLatPs > busClkPs)
 						pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
 					count++;
 					break;
-				case 2: 
+				case 2:
 					if (pBankInfo->minCycleTimeAtMaxCasLatMinus1Ps > busClkPs)
 						pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
 					count++;
 					break;
-				case 3: 
+				case 3:
 					if (pBankInfo->minCycleTimeAtMaxCasLatMinus2Ps > busClkPs)
 						pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
 					count++;
 					break;
-				default: 
+				default:
 					pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
 					break;
 			}
 		}
 	}
-	
+
 	DB(mvOsPrintf("Dram: minCasCalc support = %x (after SysCC calc)\n",
 											pBankInfo->suportedCasLatencies ));
 
@@ -723,28 +723,28 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO *pBankIn
 			/* Reset the bits for CL incompatible for the sysClk */
 			switch (count)
 			{
-				case 1: 
-					if (pBankInfo2->minCycleTimeAtMaxCasLatPs > busClkPs) 
+				case 1:
+					if (pBankInfo2->minCycleTimeAtMaxCasLatPs > busClkPs)
 						pBankInfo2->suportedCasLatencies &= ~(BIT0 << j);
 					count++;
 					break;
-				case 2: 
+				case 2:
 					if (pBankInfo2->minCycleTimeAtMaxCasLatMinus1Ps > busClkPs)
 						pBankInfo2->suportedCasLatencies &= ~(BIT0 << j);
 					count++;
 					break;
-				case 3: 
+				case 3:
 					if (pBankInfo2->minCycleTimeAtMaxCasLatMinus2Ps > busClkPs)
 						pBankInfo2->suportedCasLatencies &= ~(BIT0 << j);
 					count++;
 					break;
-				default: 
+				default:
 					pBankInfo2->suportedCasLatencies &= ~(BIT0 << j);
 					break;
 			}
 		}
 	}
-	
+
 	DB(mvOsPrintf("Dram2: minCasCalc support = %x (after SysCC calc)\n",
 									pBankInfo2->suportedCasLatencies ));
 
@@ -770,13 +770,13 @@ static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO *pBankIn
 			break;
 		}
 	}
-	
+
 	if (minCas2 > minCas0)
 		return minCas2;
 	else
 		return minCas0;
-	
-	return 0; 
+
+	return 0;
 }
 
 /*******************************************************************************
@@ -800,11 +800,11 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO
 {
 	MV_U32 sdramConfig = 0;
 	MV_U32 refreshPeriod;
-	
+
 	busClk /= 1000000; /* we work with busClk in MHz */
-	
+
 	sdramConfig = MV_REG_READ(SDRAM_CONFIG_REG);
-	
+
 	/* figure out the memory refresh internal */
 	switch (pBankInfo->refreshInterval & 0xf)
 	{
@@ -830,27 +830,27 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO
 				mvOsPrintf("Dram: ERR. DRAM refresh period is unknown!\n");
 				return -1;
     }
-	
+
 	/* Now the refreshPeriod is in register format value */
 	refreshPeriod = (busClk * refreshPeriod) / 1000;
-	
-	DB(mvOsPrintf("Dram: sdramConfigRegCalc calculated refresh interval %0x\n", 
+
+	DB(mvOsPrintf("Dram: sdramConfigRegCalc calculated refresh interval %0x\n",
 				  refreshPeriod));
 
 	/* make sure the refresh value is only 14 bits */
 	if(refreshPeriod > SDRAM_REFRESH_MAX)
 	{
 		refreshPeriod = SDRAM_REFRESH_MAX;
-		DB(mvOsPrintf("Dram: sdramConfigRegCalc adjusted refresh interval %0x\n", 
+		DB(mvOsPrintf("Dram: sdramConfigRegCalc adjusted refresh interval %0x\n",
 					  refreshPeriod));
 	}
-	
+
 	/* Clear the refresh field */
 	sdramConfig &= ~SDRAM_REFRESH_MASK;
-	
+
 	/* Set new value to refresh field */
 	sdramConfig |= (refreshPeriod & SDRAM_REFRESH_MASK);
-	
+
 	/*  registered DRAM ? */
 	if ( pBankInfo->registeredAddrAndControlInputs )
 	{
@@ -863,25 +863,25 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO
 	sdramConfig &= ~SDRAM_ECC_MASK;    /* Clear ECC field */
 	sdramConfig &= ~SDRAM_IERR_MASK;    /* Clear IErr field */
 
-	if ( pBankInfo->errorCheckType ) 
+	if ( pBankInfo->errorCheckType )
 	{
 		sdramConfig |= SDRAM_ECC_EN;
-		sdramConfig |= SDRAM_IERR_REPORTE; 
+		sdramConfig |= SDRAM_IERR_REPORTE;
                 DB(mvOsPrintf("Dram: mvDramIfDetect Enabling ECC\n"));
 	}
 	else
 	{
                 sdramConfig |= SDRAM_ECC_DIS;
-		sdramConfig |= SDRAM_IERR_IGNORE; 
+		sdramConfig |= SDRAM_IERR_IGNORE;
                 DB(mvOsPrintf("Dram: mvDramIfDetect Disabling ECC!\n"));
 	}
 	/* Set static default settings */
 	sdramConfig |= SDRAM_CONFIG_DV;
-	
+
 	DB(mvOsPrintf("Dram: sdramConfigRegCalc set sdramConfig to 0x%x\n",
 				  sdramConfig));
-	
- 	return sdramConfig;  
+
+ 	return sdramConfig;
 }
 
 /*******************************************************************************
@@ -891,7 +891,7 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO
 *			on the bank info parameters and the minCas.
 *
 * INPUT:
-*	minCas	  - minimum CAS supported. 
+*	minCas	  - minimum CAS supported.
 *
 * OUTPUT:
 *       None
@@ -903,29 +903,29 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO
 static MV_U32 sdramModeRegCalc(MV_U32 minCas)
 {
 	MV_U32 sdramMode;
-		
+
 	sdramMode = MV_REG_READ(SDRAM_MODE_REG);
-	
+
 	/* Clear CAS Latency field */
 	sdramMode &= ~SDRAM_CL_MASK;
-	
+
 	DB(mvOsPrintf("DRAM CAS Latency ");)
-	
+
 		switch (minCas)
 		{
-			case DDR2_CL_3: 
+			case DDR2_CL_3:
 				sdramMode |= SDRAM_DDR2_CL_3;
 				DB(mvOsPrintf("3.\n");)
 				break;
-			case DDR2_CL_4: 
+			case DDR2_CL_4:
 				sdramMode |= SDRAM_DDR2_CL_4;
 				DB(mvOsPrintf("4.\n");)
 				break;
-			case DDR2_CL_5: 
+			case DDR2_CL_5:
 				sdramMode |= SDRAM_DDR2_CL_5;
 				DB(mvOsPrintf("5.\n");)
 				break;
-			case DDR2_CL_6: 
+			case DDR2_CL_6:
 				sdramMode |= SDRAM_DDR2_CL_6;
 				DB(mvOsPrintf("6.\n");)
 				break;
@@ -941,7 +941,7 @@ static MV_U32 sdramModeRegCalc(MV_U32 minCas)
 /*******************************************************************************
 * sdramExtModeRegCalc - Calculate sdram Extended mode register
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *		Return sdram Extended mode register value based
 *		on the bank info parameters and bank presence.
 *
@@ -969,13 +969,13 @@ static MV_U32 sdramExtModeRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
 				populateBanks |= (1 << bankNum);
 			}
 		}
-	
+
 		switch(populateBanks)
 		{
 			case(BANK_PRESENT_CS0):
 			case(BANK_PRESENT_CS0_CS1):
 				return DDR_SDRAM_EXT_MODE_CS0_CS1_DV;
-		
+
 			case(BANK_PRESENT_CS0_CS2):
 			case(BANK_PRESENT_CS0_CS1_CS2):
 			case(BANK_PRESENT_CS0_CS2_CS3):
@@ -984,11 +984,11 @@ static MV_U32 sdramExtModeRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
 				    return DDR_SDRAM_EXT_MODE_FAST_CS0_CS1_CS2_CS3_DV;
 				else
 				    return DDR_SDRAM_EXT_MODE_CS0_CS1_CS2_CS3_DV;
-		
+
 			default:
 				mvOsOutput("sdramExtModeRegCalc: Invalid DRAM bank presence\n");
 				return -1;
-		} 
+		}
 	return 0;
 }
 
@@ -1000,7 +1000,7 @@ static MV_U32 sdramExtModeRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
 *
 * INPUT:
 *	pBankInfo - sdram bank parameters
-*	minCas	  - minimum CAS supported. 
+*	minCas	  - minimum CAS supported.
 *
 * OUTPUT:
 *       None
@@ -1014,14 +1014,14 @@ static MV_U32 dunitCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, M
 	MV_U32 dunitCtrlLow, cl;
 	MV_U32 sbOutR[4]={3,5,7,9} ;
 	MV_U32 sbOutU[4]={1,3,5,7} ;
-	
+
     	dunitCtrlLow = MV_REG_READ(SDRAM_DUNIT_CTRL_REG);
 
         DB(mvOsPrintf("Dram: dunitCtrlLowRegCalc\n"));
 
 	/* Clear StBurstOutDel field */
 	dunitCtrlLow &= ~SDRAM_SB_OUT_MASK;
-	
+
 	/* Clear StBurstInDel field */
 	dunitCtrlLow &= ~SDRAM_SB_IN_MASK;
 
@@ -1034,14 +1034,14 @@ static MV_U32 dunitCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, M
 	{
 		dunitCtrlLow |= SDRAM_2T_MODE;
 	}
-	
+
 	/* For proper sample of read data set the Dunit Control register's      */
 	/* stBurstInDel bits [27:24]                                            */
 	/*		200MHz - 267MHz None reg  = CL + 1			*/
 	/*		200MHz - 267MHz reg	  = CL + 2			*/
 	/*		> 267MHz None reg  = CL + 2			*/
 	/*		> 267MHz reg	  = CL + 3			*/
-	
+
 	/* For proper sample of read data set the Dunit Control register's      */
 	/* stBurstOutDel bits [23:20]                                           */
 			/********-********-********-********-
@@ -1051,9 +1051,9 @@ static MV_U32 dunitCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, M
 			*********-********-********-********-
 	Registered	*  0011  |  0101  |  0111  |  1001  |
 			*********-********-********-********/
-    
+
 		/* Set Dunit Control low default value */
-		dunitCtrlLow |= SDRAM_DUNIT_CTRL_LOW_DDR2_DV; 
+		dunitCtrlLow |= SDRAM_DUNIT_CTRL_LOW_DDR2_DV;
 
 		switch (minCas)
 		{
@@ -1092,14 +1092,14 @@ static MV_U32 dunitCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, M
 			else
 				cl = cl + 2;
 		}
-		
+
         DB(mvOsPrintf("dunitCtrlLowRegCalc: SDRAM_SB_IN_DEL_OFFS = %d \n", cl));
 		dunitCtrlLow |= cl << SDRAM_SB_IN_DEL_OFFS;
 
 	DB(mvOsPrintf("Dram: Reg dunit control low = %x\n", dunitCtrlLow ));
 
 	return dunitCtrlLow;
-}  
+}
 
 /*******************************************************************************
 * dunitCtrlHighRegCalc - Calculate sdram dunit control high register
@@ -1108,7 +1108,7 @@ static MV_U32 dunitCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, M
 *			on the bus clock.
 *
 * INPUT:
-*	busClk	  - DRAM frequency. 
+*	busClk	  - DRAM frequency.
 *
 * OUTPUT:
 *       None
@@ -1121,12 +1121,12 @@ static MV_U32 dunitCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32  busClk)
 {
 	MV_U32 dunitCtrlHigh;
 	dunitCtrlHigh = MV_REG_READ(SDRAM_DUNIT_CTRL_HI_REG);
-	if(busClk > MV_BOARD_SYSCLK_300MHZ) 
+	if(busClk > MV_BOARD_SYSCLK_300MHZ)
 		dunitCtrlHigh |= SDRAM__P2D_EN;
 	else
 		dunitCtrlHigh &= ~SDRAM__P2D_EN;
 
-	if(busClk > MV_BOARD_SYSCLK_267MHZ) 
+	if(busClk > MV_BOARD_SYSCLK_267MHZ)
 	    dunitCtrlHigh |= (SDRAM__WR_MESH_DELAY_EN | SDRAM__PUP_ZERO_SKEW_EN | SDRAM__ADD_HALF_FCC_EN);
 
 	/* If ECC support we turn on D2P sample */
@@ -1156,7 +1156,7 @@ static MV_U32 dunitCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32  busClk)
 static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_DRAM_BANK_INFO *pBankInfoDIMM1)
 {
 	MV_U32 addrCtrl = 0;
-	
+
 	if (pBankInfoDIMM1->size)
 	{
 		switch (pBankInfoDIMM1->sdramWidth)
@@ -1199,7 +1199,7 @@ static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_DRAM_BANK_IN
 	}
 
 	/* Note that density is in MB units */
-	switch (pBankInfo->deviceDensity) 
+	switch (pBankInfo->deviceDensity)
 	{
 		case 256:                 /* 256 Mbit */
 			DB(mvOsPrintf("DRAM Device Density 256Mbit\n"));
@@ -1225,7 +1225,7 @@ static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_DRAM_BANK_IN
 
 	if (pBankInfoDIMM1->size)
 	{
-		switch (pBankInfoDIMM1->deviceDensity) 
+		switch (pBankInfoDIMM1->deviceDensity)
 		{
 			case 256:                 /* 256 Mbit */
 				DB(mvOsPrintf("DIMM2: DRAM Device Density 256Mbit\n"));
@@ -1258,13 +1258,13 @@ static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_DRAM_BANK_IN
 /*******************************************************************************
 * sdramTimeCtrlLowRegCalc - Calculate sdram timing control low register
 *
-* DESCRIPTION: 
-*       This function calculates sdram timing control low register 
+* DESCRIPTION:
+*       This function calculates sdram timing control low register
 *       optimized value based on the bank info parameters and the minCas.
 *
 * INPUT:
 *	    pBankInfo - sdram bank parameters
-*	minCas	  - minimum CAS supported. 
+*	minCas	  - minimum CAS supported.
 *       busClk    - Bus clock
 *
 * OUTPUT:
@@ -1284,9 +1284,9 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCa
     MV_U32 tWtr = 0;
     MV_U32 tRtp = 0;
     MV_U32 timeCtrlLow = 0;
-	
+
     MV_U32 bankNum;
-    
+
     busClk = busClk / 1000000;    /* In MHz */
 
     /* Scan all DRAM banks to find maximum timing values */
@@ -1303,7 +1303,7 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCa
     tRp  = tRp  >> 2;    /* For example 0x50 -> 20ns                        */
     tRrd = tRrd >> 2;
     tRcd = tRcd >> 2;
-	
+
     /* Extract clock cycles from time parameter. We need to round up        */
     tRp  = ((busClk * tRp)  / 1000) + (((busClk * tRp)  % 1000) ? 1 : 0);
     DB(mvOsPrintf("Dram  Timing Low: tRp = %d ", tRp));
@@ -1325,7 +1325,7 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCa
 	    tWtr = MV_MAX(tWtr, pBankInfo[bankNum].minWriteToReadCmdDelay);
 	    tRtp = MV_MAX(tRtp, pBankInfo[bankNum].minReadToPrechCmdDelay);
 	}
-	
+
 	/* Extract timing (in ns) from SPD value. We ignore the tenth ns    */
 	/* part by shifting the data two bits right.                        */
 	tWr  = tWr  >> 2;    /* For example 0x50 -> 20ns                    */
@@ -1353,7 +1353,7 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCa
 		    ((tWr  - 1) << SDRAM_TWR_OFFS)  |
 		    ((tWtr - 1) << SDRAM_TWTR_OFFS)	|
 		    ((tRtp - 1) << SDRAM_TRTP_OFFS));
-	
+
 	/* Check extended tRas bit */
 	if ((tRas - 1) & BIT4)
 	    timeCtrlLow |= (1 << SDRAM_EXT_TRAS_OFFS);
@@ -1364,8 +1364,8 @@ static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCa
 /*******************************************************************************
 * sdramTimeCtrlHighRegCalc - Calculate sdram timing control high register
 *
-* DESCRIPTION: 
-*       This function calculates sdram timing control high register 
+* DESCRIPTION:
+*       This function calculates sdram timing control high register
 *       optimized value based on the bank info parameters and the bus clock.
 *
 * INPUT:
@@ -1385,15 +1385,15 @@ static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busC
 	MV_U32 timingHigh;
 	MV_U32 timeNs = 0;
 	MV_U32 bankNum;
-	
+
 	busClk = busClk / 1000000;    /* In MHz */
 
 	/* Set DDR timing high register static configuration bits */
 	timingHigh = MV_REG_READ(SDRAM_TIMING_CTRL_HIGH_REG);
-	
+
 	/* Set DDR timing high register default value */
-	timingHigh |= SDRAM_TIMING_CTRL_HIGH_REG_DV;  
-	
+	timingHigh |= SDRAM_TIMING_CTRL_HIGH_REG_DV;
+
 	/* Clear tRfc field */
 	timingHigh &= ~SDRAM_TRFC_MASK;
 
@@ -1401,7 +1401,7 @@ static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busC
 	for (bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
 	{
 		timeNs = MV_MAX(timeNs,  pBankInfo[bankNum].minRefreshToActiveCmd);
-		DB(mvOsPrintf("Dram:  Timing High: minRefreshToActiveCmd = %d\n", 
+		DB(mvOsPrintf("Dram:  Timing High: minRefreshToActiveCmd = %d\n",
 				pBankInfo[bankNum].minRefreshToActiveCmd));
 	}
 	if(busClk >= 333 && mvCtrlModelGet() == MV_78XX0_A1_REV)
@@ -1414,7 +1414,7 @@ static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busC
 	DB(mvOsPrintf("Dram:  Timing High: tRfc = %d\n", tRfc));
 	timingHigh |= (((tRfc - 1) & SDRAM_TRFC_MASK) << SDRAM_TRFC_OFFS);
 	DB(mvOsPrintf("Dram:  Timing High: tRfc = %d\n", tRfc));
-	
+
 	/* SDRAM timing high */
 	DB(mvOsPrintf("Dram: setting timing high with: %x \n", timingHigh));
 
@@ -1423,9 +1423,9 @@ static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busC
 /*******************************************************************************
 * sdramDDr2OdtConfig - Set DRAM DDR2 On Die Termination registers.
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *       This function config DDR2 On Die Termination (ODT) registers.
-*	
+*
 * INPUT:
 *		pBankInfo - bank info parameters.
 *
@@ -1440,7 +1440,7 @@ static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo)
 	MV_U32 populateBanks = 0;
 	MV_U32 odtCtrlLow, odtCtrlHigh, dunitOdtCtrl;
 	int bankNum;
-	
+
 	/* Represent the populate banks in binary form */
 	for(bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
 	{
@@ -1449,7 +1449,7 @@ static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo)
 				populateBanks |= (1 << bankNum);
 			}
 		}
-	
+
 	switch(populateBanks)
 	{
 		case(BANK_PRESENT_CS0):
@@ -1492,11 +1492,11 @@ static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo)
 /*******************************************************************************
 * sdramDdr2TimeLoRegCalc - Set DDR2 DRAM Timing Low registers.
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *       This function config DDR2 DRAM Timing low registers.
-*	
+*
 * INPUT:
-*	minCas	  - minimum CAS supported. 
+*	minCas	  - minimum CAS supported.
 *
 * OUTPUT:
 *       None
@@ -1511,8 +1511,8 @@ static MV_U32 sdramDdr2TimeLoRegCalc(MV_U32 minCas)
 
 	/* read and clear the feilds we are going to set */
 	ddr2TimeLoReg = MV_REG_READ(SDRAM_DDR2_TIMING_LO_REG);
-	ddr2TimeLoReg &= ~(SD2TLR_TODT_ON_RD_MASK	| 
-			   SD2TLR_TODT_OFF_RD_MASK	| 
+	ddr2TimeLoReg &= ~(SD2TLR_TODT_ON_RD_MASK	|
+			   SD2TLR_TODT_OFF_RD_MASK	|
 			   SD2TLR_TODT_ON_CTRL_RD_MASK	|
 			   SD2TLR_TODT_OFF_CTRL_RD_MASK);
 
@@ -1553,11 +1553,11 @@ static MV_U32 sdramDdr2TimeLoRegCalc(MV_U32 minCas)
 /*******************************************************************************
 * sdramDdr2TimeHiRegCalc - Set DDR2 DRAM Timing High registers.
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *       This function config DDR2 DRAM Timing high registers.
-*	
+*
 * INPUT:
-*	minCas	  - minimum CAS supported. 
+*	minCas	  - minimum CAS supported.
 *
 * OUTPUT:
 *       None
@@ -1595,7 +1595,7 @@ static MV_U32 sdramDdr2TimeHiRegCalc(MV_U32 minCas)
 	}
 	else
 	{
-		mvOsOutput("sdramDdr2TimeHiRegCalc: CAS latency %d unsupported. using CAS latency 4\n", 
+		mvOsOutput("sdramDdr2TimeHiRegCalc: CAS latency %d unsupported. using CAS latency 4\n",
 				minCas);
 		cl = 4;
 	}
@@ -1615,7 +1615,7 @@ static MV_U32 sdramDdr2TimeHiRegCalc(MV_U32 minCas)
 /*******************************************************************************
 * mvDramIfCalGet - Get CAS Latency
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *       This function get the CAS Latency.
 *
 * INPUT:
@@ -1631,38 +1631,38 @@ static MV_U32 sdramDdr2TimeHiRegCalc(MV_U32 minCas)
 MV_U32 mvDramIfCalGet(void)
 {
 	MV_U32 sdramCasLat, casLatMask;
-	
+
     casLatMask = (MV_REG_READ(SDRAM_MODE_REG) & SDRAM_CL_MASK);
 
     switch (casLatMask)
     {
-        case SDRAM_DDR2_CL_3: 
+        case SDRAM_DDR2_CL_3:
             sdramCasLat = 30;
             break;
-        case SDRAM_DDR2_CL_4: 
+        case SDRAM_DDR2_CL_4:
             sdramCasLat = 40;
             break;
-        case SDRAM_DDR2_CL_5: 
+        case SDRAM_DDR2_CL_5:
             sdramCasLat = 50;
             break;
-        case SDRAM_DDR2_CL_6: 
+        case SDRAM_DDR2_CL_6:
             sdramCasLat = 60;
             break;
         default:
             mvOsOutput("mvDramIfCalGet: Err, unknown DDR2 CAL\n");
             return -1;
-    }                                  
-    
+    }
+
     return sdramCasLat;
 }
 
 
 /*******************************************************************************
-* mvDramIfSelfRefreshSet - Put the dram in self refresh mode - 
+* mvDramIfSelfRefreshSet - Put the dram in self refresh mode -
 *
-* DESCRIPTION: 
+* DESCRIPTION:
 *               add support in power management.
-*                          
+*
 *
 * INPUT:
 *       None
@@ -1705,7 +1705,7 @@ static void mvDramIfDimGetSPDversion(MV_U32 *pMajor, MV_U32 *pMinor, MV_U32 bank
 	MV_DIMM_INFO dimmInfo;
 	if (bankNum >= MV_DRAM_MAX_CS )
 	{
-		DB(mvOsPrintf("Dram: mvDramIfDimGetSPDversion bad params \n")); 
+		DB(mvOsPrintf("Dram: mvDramIfDimGetSPDversion bad params \n"));
 		return ;
 	}
 	memset(&dimmInfo,0,sizeof(dimmInfo));
@@ -1737,15 +1737,15 @@ void mvDramIfShow(void)
 {
     int i, sdramCasLat, sdramCsSize;
 	MV_U32 Major=0, Minor=0;
-    
+
     mvOsOutput("DRAM Controller info:\n");
-    
+
     mvOsOutput("Total DRAM ");
     mvSizePrint(mvDramIfSizeGet());
     mvOsOutput("\n");
 
 	for(i = 0; i < MV_DRAM_MAX_CS; i++)
-	{ 
+	{
         sdramCsSize = mvDramIfBankSizeGet(i);
         if (sdramCsSize)
         {
@@ -1769,7 +1769,7 @@ void mvDramIfShow(void)
     {
         mvOsOutput("ECC Disabled, ");
     }
-    
+
     if (MV_REG_READ(SDRAM_CONFIG_REG) & SDRAM_REGISTERED)
     {
         mvOsOutput("Registered DIMM\n");
@@ -1783,7 +1783,7 @@ void mvDramIfShow(void)
 }
 /*******************************************************************************
 * mvDramIfGetFirstCS - find the  DRAM bank on the lower address
-* 
+*
 *
 * DESCRIPTION:
 *       This function return the fisrt CS on address 0
@@ -1807,8 +1807,8 @@ MV_U32 mvDramIfGetFirstCS(void)
 		mvDramBankInfoGet(SDRAM_CS0, &bankInfo[SDRAM_CS0]);
 #ifdef MV_INCLUDE_SDRAM_CS2
 		mvDramBankInfoGet(SDRAM_CS2, &bankInfo[SDRAM_CS2]);
-#endif 
-		
+#endif
+
 #ifdef MV_INCLUDE_SDRAM_CS2
 		if (bankInfo[SDRAM_CS0].size <  bankInfo[SDRAM_CS2].size)
 		{
@@ -1825,14 +1825,14 @@ MV_U32 mvDramIfGetFirstCS(void)
 #ifdef MV_INCLUDE_SDRAM_CS2
 		DRAM_CS_Order[2] = SDRAM_CS2;
 		DRAM_CS_Order[3] = SDRAM_CS3;
-#endif	
+#endif
 		return SDRAM_CS0;
 	}
 	return DRAM_CS_Order[0];
 }
 /*******************************************************************************
-* mvDramIfGetCSorder - 
-* 
+* mvDramIfGetCSorder -
+*
 *
 * DESCRIPTION:
 *       This function return the fisrt CS on address 0
@@ -1845,7 +1845,7 @@ MV_U32 mvDramIfGetFirstCS(void)
 *
 * RETURN:
 *       SDRAM_CS0 or SDRAM_CS2
-* 
+*
 * NOTE: mvDramIfGetFirstCS must be caled before this subroutine
 *******************************************************************************/
 MV_U32 mvDramIfGetCSorder(MV_U32 csOrder )
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.h
index 23f2e54..3ceeae6 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -99,10 +99,10 @@ typedef enum _mvMemoryType
 /* enumeration for DDR2 supported CAS Latencies */
 typedef enum _mvDimmDdr2Cas
 {
-    DDR2_CL_3    = 0x08, 
-    DDR2_CL_4    = 0x10, 
-    DDR2_CL_5    = 0x20, 
-    DDR2_CL_6    = 0x40, 
+    DDR2_CL_3    = 0x08,
+    DDR2_CL_4    = 0x10,
+    DDR2_CL_5    = 0x20,
+    DDR2_CL_6    = 0x40,
     DDR2_CL_FAULT
 } MV_DIMM_DDR2_CAS;
 
@@ -124,7 +124,7 @@ typedef struct _mvDramBankInfo
     MV_U32  refreshInterval;
 
     /* DIMM timing parameters */
-    MV_U32  minCycleTimeAtMaxCasLatPs;	
+    MV_U32  minCycleTimeAtMaxCasLatPs;
     MV_U32  minCycleTimeAtMaxCasLatMinus1Ps;
     MV_U32  minCycleTimeAtMaxCasLatMinus2Ps;
     MV_U32  minRowPrechargeTime;
@@ -135,7 +135,7 @@ typedef struct _mvDramBankInfo
     MV_U32  minWriteToReadCmdDelay; /* DDR2 only */
     MV_U32  minReadToPrechCmdDelay; /* DDR2 only */
     MV_U32  minRefreshToActiveCmd;  /* DDR2 only */
-                      
+
     /* Parameters calculated from the extracted DIMM information */
     MV_U32  size;
     MV_U32  deviceDensity;           	/* 16,64,128,256 or 512 Mbit */
@@ -144,7 +144,7 @@ typedef struct _mvDramBankInfo
     /* DIMM attributes (MV_TRUE for yes) */
     MV_BOOL registeredAddrAndControlInputs;
     MV_BOOL registeredDQMBinputs;
-     
+
 }MV_DRAM_BANK_INFO;
 
 #include "ddr2/spd/mvSpd.h"
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S
new file mode 100644
index 0000000..c6a4493
--- /dev/null
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S
@@ -0,0 +1,986 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#define	_ASMLANGUAGE
+#define MV_ASMLANGUAGE
+#include "mvSysHwConfig.h"
+#include "mvOsAsm.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "mvDramIfConfig.h"
+#include "mvDramIfRegs.h"
+#include "pex/mvPexRegs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvAsm.h"
+#include "mvCommon.h"
+
+/* defines */
+
+#if defined(MV_STATIC_DRAM_ON_BOARD)
+.globl dramBoot1
+dramBoot1:
+        .word   0
+
+/******************************************************************************
+*
+*
+*
+*
+*******************************************************************************/
+#if defined(DB_MV78XX0) || defined(DB_MV88F632X)
+/* DDR2 boards 512MB 333MHz */
+#define STATIC_SDRAM0_BANK0_SIZE		0x1ffffff1 /*	0x1504	*/
+#define STATIC_SDRAM_CONFIG	     		0x43048C30 /*	0x1400  */
+#define STATIC_SDRAM_MODE	     		0x00000652 /*	0x141c  */
+#define STATIC_DUNIT_CTRL_LOW			0x38543000 /*   0x1404  */
+#define STATIC_DUNIT_CTRL_HI			0x0000FFFF /*   0x1424  */
+#define STATIC_SDRAM_ADDR_CTRL			0x00000088 /*   0x1410  */
+#define STATIC_SDRAM_TIME_CTRL_LOW		0x22125441 /*   0x1408  */
+#define STATIC_SDRAM_TIME_CTRL_HI		0x00000A29 /*   0x140c  */
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000E80F /*   0x149c  */
+#define STATIC_SDRAM_EXT_MODE          		0x00000040 /*   0x1420  */
+#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */
+#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */
+
+#elif defined(RD_MV78XX0_AMC)
+/* On board DDR2 512MB 400MHz CL5 */
+#define STATIC_SDRAM0_BANK0_SIZE		0x1ffffff1 /*	0x1504	*/
+#define STATIC_SDRAM_CONFIG	     		0x43008C30 /*	0x1400  */
+#define STATIC_SDRAM_MODE	     		0x00000652 /*	0x141c  */
+#define STATIC_DUNIT_CTRL_LOW			0x38543000 /*   0x1404  */
+#define STATIC_DUNIT_CTRL_HI			0x0000F07F /*   0x1424  */
+#define STATIC_SDRAM_ADDR_CTRL			0x000000DD /*   0x1410  */
+#define STATIC_SDRAM_TIME_CTRL_LOW		0x23135441 /*   0x1408  */
+#define STATIC_SDRAM_TIME_CTRL_HI		0x00000A32 /*   0x140c  */
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000EB0F /*   0x149c  */
+#define STATIC_SDRAM_EXT_MODE          		0x00000040 /*   0x1420  */
+#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */
+#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */
+
+#elif defined(RD_MV78XX0_H3C)
+/* DDR2 boards 512MB 333MHz */
+#define STATIC_SDRAM0_BANK0_SIZE		0x1ffffff1 /*	0x1504	*/
+#define STATIC_SDRAM_CONFIG	     		0x43048a25 /*	0x1400  */
+#define STATIC_SDRAM_MODE	     		0x00000652 /*	0x141c  */
+#define STATIC_DUNIT_CTRL_LOW			0x38543000 /*   0x1404  */
+#define STATIC_DUNIT_CTRL_HI			0x0000F07F /*   0x1424  */
+#define STATIC_SDRAM_ADDR_CTRL			0x00000088 /*   0x1410  */
+#define STATIC_SDRAM_TIME_CTRL_LOW		0x2202444e /*   0x1408  */
+#define STATIC_SDRAM_TIME_CTRL_HI		0x00000A22 /*   0x140c  */
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000EB0F /*   0x149c  */
+#define STATIC_SDRAM_EXT_MODE          		0x00000040 /*   0x1420  */
+#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */
+#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */
+
+#elif defined(RD_MV78XX0_PCAC)
+/* DDR2 boards 256MB 200MHz */
+#define STATIC_SDRAM0_BANK0_SIZE		0x0ffffff1 /*	0x1504	*/
+#define STATIC_SDRAM_CONFIG	     		0x43000a25 /*	0x1400  */
+#define STATIC_SDRAM_MODE	     		0x00000652 /*	0x141c  */
+#define STATIC_DUNIT_CTRL_LOW			0x38543000 /*   0x1404  */
+#define STATIC_DUNIT_CTRL_HI			0x0000F07F /*   0x1424  */
+#define STATIC_SDRAM_ADDR_CTRL			0x000000DD /*   0x1410  */
+#define STATIC_SDRAM_TIME_CTRL_LOW		0x2202444e /*   0x1408  */
+#define STATIC_SDRAM_TIME_CTRL_HI		0x00000822 /*   0x140c  */
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000EB0F /*   0x149c  */
+#define STATIC_SDRAM_EXT_MODE          		0x00000040 /*   0x1420  */
+#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */
+#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */
+
+#else
+/* DDR2 MV88F6281 boards 256MB 400MHz */
+#define STATIC_SDRAM0_BANK0_SIZE		0x0FFFFFF1 /*	0x1504	*/
+#define STATIC_SDRAM_CONFIG	     		0x43000c30 /*	0x1400  */
+#define STATIC_SDRAM_MODE	     		0x00000C52 /*	0x141c  */
+#define STATIC_DUNIT_CTRL_LOW			0x39543000 /*   0x1404  */
+#define STATIC_DUNIT_CTRL_HI			0x0000F1FF /*   0x1424  */
+#define STATIC_SDRAM_ADDR_CTRL			0x000000cc /*   0x1410  */
+#define STATIC_SDRAM_TIME_CTRL_LOW		0x22125451 /*   0x1408  */
+#define STATIC_SDRAM_TIME_CTRL_HI		0x00000A33 /*   0x140c  */
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x003C0000 /*   0x1494  */
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000F80F /*   0x149c  */
+#define STATIC_SDRAM_EXT_MODE          		0x00000042 /*   0x1420  */
+#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */
+#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */
+#endif /* MV78XX0 */
+
+	.globl _mvDramIfStaticInit
+_mvDramIfStaticInit:
+
+	mov     r11, LR     		/* Save link register */
+	mov	r10, r2
+
+#ifdef MV78XX0
+        MV_REG_READ_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
+	orr	r6, r6, #BIT4	/* Enable 2T mode */
+	bic	r6, r6, #BIT6	/* clear ctrlPos */
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
+#endif
+
+     	/*DDR SDRAM Initialization Control */
+	ldr	r6, =DSICR_INIT_EN
+	MV_REG_WRITE_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
+2:	MV_REG_READ_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
+         and    r6, r6, #DSICR_INIT_EN
+         cmp    r6, #0
+         bne 2b
+
+        /* If we boot from NAND jump to DRAM address */
+        mov     r5, #1
+        ldr     r6, =dramBoot1
+        str     r5, [r6]                /* We started executing from DRAM */
+
+        ldr     r6, dramBoot1
+        cmp     r6, #0
+        bne     1f
+
+	/* set all dram windows to 0 */
+	mov	r6, #0
+	MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,0))
+	MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,1))
+	MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,2))
+	MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,3))
+	ldr	r6, = STATIC_SDRAM0_BANK0_SIZE
+	MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,0))
+
+
+	/* set all dram configuration in temp registers */
+	ldr	r6, = STATIC_SDRAM0_BANK0_SIZE
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG0)
+	ldr	r6, = STATIC_SDRAM_CONFIG
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG1)
+	ldr	r6, = STATIC_SDRAM_MODE
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG2)
+	ldr	r6, = STATIC_DUNIT_CTRL_LOW
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG3)
+	ldr	r6, = STATIC_SDRAM_ADDR_CTRL
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG4)
+	ldr	r6, = STATIC_SDRAM_TIME_CTRL_LOW
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG5)
+	ldr	r6, = STATIC_SDRAM_TIME_CTRL_HI
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG6)
+	ldr	r6, = STATIC_SDRAM_ODT_CTRL_LOW
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG7)
+	ldr	r6, = STATIC_SDRAM_ODT_CTRL_HI
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG8)
+	ldr	r6, = STATIC_SDRAM_DUNIT_ODT_CTRL
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG9)
+	ldr	r6, = STATIC_SDRAM_EXT_MODE
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG10)
+	ldr	r6, = STATIC_SDRAM_DDR2_TIMING_LO
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG11)
+	ldr	r6, = STATIC_SDRAM_DDR2_TIMING_HI
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG12)
+#ifndef MV_NAND_BOOT
+	ldr	r6, = STATIC_DUNIT_CTRL_HI
+	MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG13)
+#endif
+
+	ldr	sp,=0
+	bl	_mvDramIfConfig
+	ldr	r0, =0
+#ifdef MV78XX0
+	bl	_mvDramIfEccMemInit
+#endif
+1:
+	mov 	r2, r10
+	mov     PC, r11         	/* r11 is saved link register */
+
+#else  /* #if defined(MV_STATIC_DRAM_ON_BOARD) */
+
+.globl dramBoot1
+dramBoot1:
+        .word   0
+
+/*******************************************************************************
+* mvDramIfBasicInit - Basic initialization of DRAM interface
+*
+* DESCRIPTION:
+*       The function will initialize the DRAM for basic usage. The function
+*       will use the TWSI assembly API to extract DIMM parameters according
+*       to which DRAM interface will be initialized.
+*       The function referes to the following DRAM parameters:
+*       1) DIMM is registered or not.
+*       2) DIMM width detection.
+*       3) DIMM density.
+*
+* INPUT:
+*       r3 - required size for initial DRAM.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*       Note:
+*       r4 holds I2C EEPROM address
+*       r5 holds SDRAM register base address
+*	r7 holds returned values
+*       r8 holds SDRAM various configuration registers value.
+*       r11 holds return function address.
+*******************************************************************************/
+/* Setting the offsets of the I2C registers */
+#define DIMM_TYPE_OFFSET	      2
+#define NUM_OF_ROWS_OFFSET            3
+#define NUM_OF_COLS_OFFSET            4
+#define NUM_OF_RANKS		      5
+#define DIMM_CONFIG_TYPE             11
+#define SDRAM_WIDTH_OFFSET           13
+#define NUM_OF_BANKS_OFFSET          17
+#define SUPPORTED_CL_OFFSET          18
+#define DIMM_TYPE_INFO_OFFSET        20         /* DDR2 only    */
+#define SDRAM_MODULES_ATTR_OFFSET    21
+#define RANK_SIZE_OFFSET             31
+
+#define DRAM_DEV_DENSITY_128M         128
+#define DRAM_DEV_DENSITY_256M         256
+#define DRAM_DEV_DENSITY_512M         512
+#define DRAM_DEV_DENSITY_1G          1024
+#define DRAM_DEV_DENSITY_2G          2048
+
+#define DRAM_RANK_DENSITY_128M       0x20
+#define DRAM_RANK_DENSITY_256M       0x40
+#define DRAM_RANK_DENSITY_512M       0x80
+#define DRAM_RANK_DENSITY_1G	     0x1
+#define DRAM_RANK_DENSITY_2G	     0x2
+
+       .globl _mvDramIfBasicInit
+       .extern _i2cInit
+_mvDramIfBasicInit:
+
+        mov     r11, LR     		/* Save link register */
+
+	/* Set Dunit high control register	      */
+        MV_REG_READ_ASM (r6, r5, SDRAM_DUNIT_CTRL_HI_REG)
+	orr	r6, r6, #BIT7 /* SDRAM__D2P_EN */
+	orr	r6, r6, #BIT8 /* SDRAM__P2D_EN */
+#ifdef MV78XX0
+	orr	r6, r6, #BIT9 /* SDRAM__ADD_HALF_FCC_EN */
+	orr	r6, r6, #BIT10 /* SDRAM__PUP_ZERO_SKEW_EN */
+	orr	r6, r6, #BIT11 /* SDRAM__WR_MASH_DELAY_EN */
+#endif
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_DUNIT_CTRL_HI_REG)
+
+#ifdef MV78XX0
+        MV_REG_READ_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
+	orr	r6, r6, #BIT4	/* Enable 2T mode */
+	bic	r6, r6, #BIT6	/* clear ctrlPos */
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
+#endif
+
+     	/*DDR SDRAM Initialization Control */
+	ldr	r6, =DSICR_INIT_EN
+	MV_REG_WRITE_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
+2:	MV_REG_READ_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
+         and    r6, r6, #DSICR_INIT_EN
+         cmp    r6, #0
+         bne 2b
+
+        mov     r5, #1
+        ldr     r8, =dramBoot1
+        str     r5, [r8]                /* We started executing from DRAM */
+
+        /* If we boot from NAND jump to DRAM address */
+        ldr     r8, dramBoot1
+        cmp     r8, #0
+        movne   pc, r11
+
+        bl      _i2cInit                /* Initialize TWSI master             */
+
+        /* Check if we have more then 1 dimm */
+	ldr	r6, =0
+	MV_REG_WRITE_ASM (r6, r1, DRAM_BUF_REG14)
+#ifdef MV78XX0
+	bl _is_Second_Dimm_Exist
+	beq single_dimm
+	ldr	r6, =1
+	MV_REG_WRITE_ASM (r6, r1, DRAM_BUF_REG14)
+single_dimm:
+        bl      _i2cInit                /* Initialize TWSI master             */
+#endif
+
+        /* Get default SDRAM Config values */
+        MV_REG_READ_ASM (r8, r5, SDRAM_CONFIG_REG)
+
+        /* Get registered/non registered info from DIMM */
+	bl  	_is_Registered
+        beq     nonRegistered
+
+setRegistered:
+        orr     r8, r8, #SDRAM_REGISTERED   /* Set registered bit(17)         */
+nonRegistered:
+#ifdef MV78XX0
+        /* Get ECC/non ECC info from DIMM */
+	bl  	_is_Ecc
+        beq     setConfigReg
+
+setEcc:
+        orr     r8, r8, #SDRAM_ECC_EN   /* Set ecc bit(18)         */
+#endif
+setConfigReg:
+        MV_REG_WRITE_ASM (r8, r5, DRAM_BUF_REG1)
+
+        /* Set maximum CL supported by DIMM */
+	bl	_get_CAL
+
+        /* r7 is DIMM supported CAS (e.g: 3 --> 0x1C)                         */
+        clz     r6, r7
+        rsb     r6, r6, #31     /* r6 = the bit number of MAX CAS supported   */
+
+casDdr2:
+	ldr     r7, =0x41        /* stBurstInDel|stBurstOutDel field value     */
+	ldr     r3, =0x53       /* stBurstInDel|stBurstOutDel registered value*/
+	ldr     r8, =0x32      /* Assuming MAX CL = 3           */
+        cmp     r6, #3          /* If CL = 3 break              */
+        beq     casDdr2Cont
+
+	ldr     r7, =0x53        /* stBurstInDel|stBurstOutDel field value     */
+	ldr     r3, =0x65       /* stBurstInDel|stBurstOutDel registered value*/
+	ldr     r8, =0x42      /* Assuming MAX CL = 4           */
+        cmp     r6, #4          /* If CL = 4 break              */
+        beq     casDdr2Cont
+
+	ldr     r7, =0x65        /* stBurstInDel|stBurstOutDel field value     */
+	ldr     r3, =0x77       /* stBurstInDel|stBurstOutDel registered value*/
+	ldr     r8, =0x52      /* Assuming MAX CL = 5           */
+        cmp     r6, #5          /* If CL = 5 break              */
+        beq     casDdr2Cont
+
+	ldr     r7, =0x77        /* stBurstInDel|stBurstOutDel field value     */
+	ldr     r3, =0x89       /* stBurstInDel|stBurstOutDel registered value*/
+	ldr     r8, =0x62      /* Assuming MAX CL = 6           */
+        cmp     r6, #6          /* If CL = 5 break              */
+        beq     casDdr2Cont
+
+        /* This is an error. return */
+        b       exit_ddrAutoConfig      /* This is an error !!  */
+casDdr2Cont:
+
+        /* Get default SDRAM Mode values */
+        MV_REG_READ_ASM (r6, r5, SDRAM_MODE_REG)
+        bic     r6, r6, #(BIT6 | BIT5 | BIT4) /* Clear CL filed */
+	orr	r6, r6, r8
+        MV_REG_WRITE_ASM (r6, r5, DRAM_BUF_REG2)
+
+	/* Set Dunit control register according to max CL detected	      */
+        MV_REG_READ_ASM (r6, r5, DRAM_BUF_REG1)
+	tst	r6, #SDRAM_REGISTERED
+	beq	setDunitReg
+	mov	r7, r3
+
+setDunitReg:
+#ifdef MV78XX0
+        /* Set SDRAM Extended Mode register for double DIMM */
+	/* Check DRAM frequency for more then 267MHz set ODT Rtt to 50ohm */
+
+        MV_REG_READ_ASM (r4, r5, CPU_RESET_SAMPLE_L_REG)
+	ldr	r5, =MSAR_SYSCLCK_MASK
+	and	r4, r4, r5
+	ldr	r5, =MSAR_SYSCLCK_333
+	cmp	r4, r5
+	ble	Clock333
+	add r7, r7, #0x10
+Clock333:
+#endif
+
+        MV_REG_READ_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
+	bic	r6, r6, #(0xff << 20) /* Clear SBout and SBin */
+	orr	r6, r6, #BIT4	/* Enable 2T mode */
+	bic	r6, r6, #BIT6	/* clear ctrlPos */
+	orr	r6, r6, r7, LSL #20
+        MV_REG_WRITE_ASM (r6, r5, DRAM_BUF_REG3)
+
+	/* Set Dunit high control register	      */
+        MV_REG_READ_ASM (r6, r5, SDRAM_DUNIT_CTRL_HI_REG)
+	orr	r6, r6, #BIT7 /* SDRAM__D2P_EN */
+	orr	r6, r6, #BIT8 /* SDRAM__P2D_EN */
+#ifdef MV78XX0
+	orr	r6, r6, #BIT9 /* SDRAM__ADD_HALF_FCC_EN */
+	orr	r6, r6, #BIT10 /* SDRAM__PUP_ZERO_SKEW_EN */
+	orr	r6, r6, #BIT11 /* SDRAM__WR_MASH_DELAY_EN */
+#endif
+        MV_REG_WRITE_ASM (r6, r5, DRAM_BUF_REG13)
+
+        /* DIMM density configuration*/
+        /* Density = (1 << (rowNum + colNum)) * dramWidth * dramBankNum       */
+Density:
+	/* Get bank 0 and 1 density */
+	ldr	r6, =0
+	bl 	_getDensity
+
+	mov 	r8, r7
+        mov     r8, r8, LSR #20 /* Move density 20 bits to the right  */
+                                /* For example 0x10000000 --> 0x1000 */
+
+        mov     r3, #(SDRAM_DSIZE_256Mb(0) | SDRAM_DSIZE_256Mb(1))
+        cmp     r8, #DRAM_DEV_DENSITY_256M
+        beq     get_bank_2_density
+
+        mov     r3, #(SDRAM_DSIZE_512Mb(0) | SDRAM_DSIZE_512Mb(1))
+        cmp     r8, #DRAM_DEV_DENSITY_512M
+        beq     get_bank_2_density
+
+        mov     r3, #(SDRAM_DSIZE_1Gb(0) | SDRAM_DSIZE_1Gb(1))
+        cmp     r8, #DRAM_DEV_DENSITY_1G
+        beq     get_bank_2_density
+
+        mov     r3, #(SDRAM_DSIZE_2Gb(0) | SDRAM_DSIZE_2Gb(1))
+        cmp     r8, #DRAM_DEV_DENSITY_2G
+        beq     get_bank_2_density
+
+        /* This is an error. return */
+        b       exit_ddrAutoConfig
+
+get_bank_2_density:
+	/* Check for second dimm */
+	MV_REG_READ_ASM (r6, r1, DRAM_BUF_REG14)
+	cmp	r6, #1
+	bne 	get_width
+
+	/* Get bank 2 and 3 density */
+	ldr	r6, =2
+	bl 	_getDensity
+
+	mov 	r8, r7
+        mov     r8, r8, LSR #20 /* Move density 20 bits to the right  */
+                                /* For example 0x10000000 --> 0x1000 */
+
+        orr     r3, r3, #(SDRAM_DSIZE_256Mb(2) | SDRAM_DSIZE_256Mb(3))
+        cmp     r8, #DRAM_DEV_DENSITY_256M
+        beq     get_width
+
+        and     r3, r3, #~(SDRAM_DSIZE_MASK(2) | SDRAM_DSIZE_MASK(3))
+        orr     r3, r3, #(SDRAM_DSIZE_512Mb(2) | SDRAM_DSIZE_512Mb(3))
+        cmp     r8, #DRAM_DEV_DENSITY_512M
+        beq     get_width
+
+        and     r3, r3, #~(SDRAM_DSIZE_MASK(2) | SDRAM_DSIZE_MASK(3))
+        orr     r3, r3, #(SDRAM_DSIZE_1Gb(2) | SDRAM_DSIZE_1Gb(3))
+        cmp     r8, #DRAM_DEV_DENSITY_1G
+        beq     get_width
+
+        and     r3, r3, #~(SDRAM_DSIZE_MASK(2) | SDRAM_DSIZE_MASK(3))
+        orr     r3, r3, #(SDRAM_DSIZE_2Gb(2) | SDRAM_DSIZE_2Gb(3))
+        cmp     r8, #DRAM_DEV_DENSITY_2G
+        beq     get_width
+
+        /* This is an error. return */
+        b       exit_ddrAutoConfig
+
+	/* Get SDRAM width */
+get_width:
+	/* Get bank 0 and 1 width */
+	ldr	r6, =0
+	bl 	_get_width
+
+        cmp     r7, #8           /* x8 devices   */
+        beq     get_bank_2_width
+
+        orr     r3, r3, #(SDRAM_ADDRSEL_X16(0) | SDRAM_ADDRSEL_X16(1)) /* x16 devices  */
+        cmp     r7, #16
+        beq     get_bank_2_width
+
+        /* This is an error. return */
+        b       exit_ddrAutoConfig
+
+get_bank_2_width:
+	/* Check for second dimm */
+	MV_REG_READ_ASM (r6, r1, DRAM_BUF_REG14)
+	cmp	r6, #1
+	bne 	densCont
+
+	/* Get bank 2 and 3 width */
+	ldr	r6, =2
+	bl 	_get_width
+
+        cmp     r7, #8           /* x8 devices   */
+        beq     densCont
+
+        orr     r3, r3, #(SDRAM_ADDRSEL_X16(2) | SDRAM_ADDRSEL_X16(3)) /* x16 devices  */
+        cmp     r7, #16
+        beq     densCont
+
+        /* This is an error. return */
+        b       exit_ddrAutoConfig
+
+densCont:
+        MV_REG_WRITE_ASM (r3, r5, DRAM_BUF_REG4)
+
+        /* Set SDRAM timing control low register */
+	ldr	r4, =SDRAM_TIMING_CTRL_LOW_REG_DEFAULT
+        /* MV_REG_READ_ASM (r4, r5, SDRAM_TIMING_CTRL_LOW_REG) */
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG5)
+
+        /* Set SDRAM timing control high register */
+	ldr	r6, =SDRAM_TIMING_CTRL_HIGH_REG_DEFAULT
+
+    MV_REG_READ_ASM (r4, r5, CPU_RESET_SAMPLE_L_REG)
+	ldr	r5, =MSAR_SYSCLCK_MASK
+	and	r4, r4, r5
+	ldr	r5, =MSAR_SYSCLCK_333
+	cmp	r4, r5
+	blt	timingHighClock333
+    orr r6, r6, #BIT9
+
+timingHighClock333:
+    /* MV_REG_READ_ASM (r6, r5, SDRAM_TIMING_CTRL_HIGH_REG) */
+    MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG6)
+
+	/* Check for second dimm */
+	MV_REG_READ_ASM (r6, r1, DRAM_BUF_REG14)
+	cmp	r6, #1
+	bne 	single_dimm_odt
+
+        /* Set SDRAM ODT control low register for double DIMM*/
+        ldr	r4, =DDR2_ODT_CTRL_LOW_CS0_CS1_CS2_CS3_DV
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG7)
+
+        /* Set DUNIT ODT control register for double DIMM */
+        ldr	r4, =DDR2_DUNIT_ODT_CTRL_CS0_CS1_CS2_CS3_DV
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG9)
+
+#ifdef MV78XX0
+        /* Set SDRAM Extended Mode register for double DIMM */
+	/* Check DRAM frequency for more then 267MHz set ODT Rtt to 50ohm */
+
+        MV_REG_READ_ASM (r4, r5, CPU_RESET_SAMPLE_L_REG)
+	ldr	r5, =MSAR_SYSCLCK_MASK
+	and	r4, r4, r5
+	ldr	r5, =MSAR_SYSCLCK_267
+	cmp	r4, r5
+	beq	slow_dram_clock_rtt
+	ldr	r5, =MSAR_SYSCLCK_300
+	cmp	r4, r5
+	beq	slow_dram_clock_rtt
+	ldr	r5, =MSAR_SYSCLCK_333
+	cmp	r4, r5
+	beq	fast_dram_clock_rtt
+	ldr	r5, =MSAR_SYSCLCK_400
+	cmp	r4, r5
+	beq	fast_dram_clock_rtt
+
+	b	slow_dram_clock_rtt
+
+fast_dram_clock_rtt:
+        ldr	r4, =DDR_SDRAM_EXT_MODE_FAST_CS0_CS1_CS2_CS3_DV
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG10)
+	b odt_config_end
+#endif
+slow_dram_clock_rtt:
+        ldr	r4, =DDR_SDRAM_EXT_MODE_CS0_CS1_CS2_CS3_DV
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG10)
+	b odt_config_end
+
+single_dimm_odt:
+        /* Set SDRAM ODT control low register */
+        ldr	r4, =DDR2_ODT_CTRL_LOW_CS0_CS1_DV
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG7)
+
+        /* Set DUNIT ODT control register */
+        ldr	r4, =DDR2_DUNIT_ODT_CTRL_CS0_CS1_DV
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG9)
+
+        /* Set SDRAM Extended Mode register */
+        ldr	r4, =DDR_SDRAM_EXT_MODE_CS0_CS1_DV
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG10)
+
+odt_config_end:
+        /* SDRAM ODT control high register is left as default */
+        MV_REG_READ_ASM (r4, r5, DDR2_SDRAM_ODT_CTRL_HIGH_REG)
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG8)
+
+        /*Read CL and set the DDR2 registers accordingly */
+        MV_REG_READ_ASM (r6, r5, DRAM_BUF_REG2)
+        and r6, r6, #SDRAM_CL_MASK
+        mov r4, r6
+        orr r4, r4, r6, LSL #4
+        orr r4, r4, r6, LSL #8
+        orr r4, r4, r6, LSL #12
+        mov r5, #0x30000
+        add r4, r4, r5
+        sub r4, r4, #0x30
+        /* Set SDRAM Ddr2 Timing Low register */
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG11)
+
+        /* Set SDRAM Ddr2 Timing High register */
+        mov r4, r4, LSR #4
+        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG12)
+
+timeParamDone:
+	/* Close all windows */
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
+        and	r6, r6,#~SCSR_SIZE_MASK
+        and	r6, r6,#~1
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,1))
+        and	r6, r6,#~SCSR_SIZE_MASK
+        and	r6, r6,#~1
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,1))
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
+        and	r6, r6,#~SCSR_SIZE_MASK
+        and	r6, r6,#~1
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,3))
+        and	r6, r6,#~SCSR_SIZE_MASK
+        and	r6, r6,#~1
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,3))
+
+        /* Set sdram bank 0 size and enable it */
+	ldr	r6, =0
+	bl _mvDramIfGetDimmSizeFromSpd
+#ifdef MV78XX0
+	/* Check DRAM width */
+        MV_REG_READ_ASM (r4, r5, SDRAM_CONFIG_REG)
+	ldr	r5, =SDRAM_DWIDTH_MASK
+	and	r4, r4, r5
+	ldr	r5, =SDRAM_DWIDTH_64BIT
+	cmp	r4, r5
+	beq	dram_64bit_width
+	/* Utilize only 32bit width */
+	mov	r8, r8, LSR #1
+#else
+	/* Utilize only 16bit width */
+	mov	r8, r8, LSR #2
+#endif
+dram_64bit_width:
+	/* Update first dimm size return value R8 */
+        MV_REG_READ_ASM (r5, r6, SDRAM_SIZE_REG(0,0))
+        ldr	r6, =~SCSR_SIZE_MASK
+	and	r5, r5, r6
+	orr	r5, r5, r8
+        MV_REG_WRITE_ASM(r5, r8, SDRAM_SIZE_REG(0,0))
+
+	/* Clear bank 2 size */
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
+        and	r6, r6,#~SCSR_SIZE_MASK
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
+
+	/* Check for second dimm */
+	MV_REG_READ_ASM (r6, r1, DRAM_BUF_REG14)
+	cmp	r6, #1
+	bne 	defualt_order
+
+        /* Set sdram bank 2 size */
+	ldr	r6, =2
+	bl _mvDramIfGetDimmSizeFromSpd
+#ifdef MV78XX0
+	/* Check DRAM width */
+        MV_REG_READ_ASM (r4, r5, SDRAM_CONFIG_REG)
+	ldr	r5, =SDRAM_DWIDTH_MASK
+	and	r4, r4, r5
+	ldr	r5, =SDRAM_DWIDTH_64BIT
+	cmp	r4, r5
+	beq	dram_64bit_width2
+	/* Utilize only 32bit width */
+	mov	r8, r8, LSR #1
+#else
+	/* Utilize only 16bit width */
+	mov	r8, r8, LSR #2
+#endif
+dram_64bit_width2:
+	/* Update first dimm size return value R8 */
+        MV_REG_READ_ASM (r5, r6, SDRAM_SIZE_REG(0,2))
+        ldr	r6, =~SCSR_SIZE_MASK
+	and	r5, r5, r6
+	orr	r5, r5, r8
+        MV_REG_WRITE_ASM(r5, r8, SDRAM_SIZE_REG(0,2))
+
+	/* Close windows 1 and 3 */
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,1))
+        and	r6, r6,#~1
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,1))
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,3))
+        and	r6, r6,#~1
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,3))
+
+	/* Check dimm size for setting dram bank order */
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
+        MV_REG_READ_ASM (r4, r5, SDRAM_SIZE_REG(0,2))
+        and	r6, r6,#SCSR_SIZE_MASK
+        and	r4, r4,#SCSR_SIZE_MASK
+	cmp	r6, r4
+	bge	defualt_order
+
+	/* Bank 2 is biger then bank 0 */
+	ldr	r6,=0
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_BASE_ADDR_REG(0,2))
+
+	/* Open win 2 */
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
+        orr	r6, r6,#1
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
+
+	ldr	sp,=0
+	bl	_mvDramIfConfig
+#ifdef MV78XX0
+	/* Init ECC on CS 2 */
+	ldr	r0, =2
+	bl	_mvDramIfEccMemInit
+#endif
+        mov     PC, r11         /* r11 is saved link register */
+
+defualt_order:
+
+	/* Open win 0 */
+        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
+        orr	r6, r6,#1
+        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
+
+	ldr	sp,=0
+	bl	_mvDramIfConfig
+#ifdef MV78XX0
+	/* Init ECC on CS 0 */
+	ldr	r0, =0
+	bl	_mvDramIfEccMemInit
+#endif
+exit_ddrAutoConfig:
+        mov     PC, r11         /* r11 is saved link register */
+
+
+/***************************************************************************************/
+/*       r4 holds I2C EEPROM address
+ *       r7 holds I2C EEPROM offset parameter for i2cRead and its --> returned value
+ *       r8 holds SDRAM various configuration registers value.
+ *	r13 holds Link register
+ */
+/**************************/
+_getDensity:
+	mov     r13, LR                            /* Save link register */
+
+	/* Read SPD rank size from DIMM0 */
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR       /* reading from DIMM0      */
+
+	cmp	r6, #0
+	beq	1f
+
+	/* Read SPD rank size from DIMM1 */
+        mov     r4, #MV_BOARD_DIMM1_I2C_ADDR /* reading from DIMM1            */
+
+1:
+        mov     r7, #NUM_OF_ROWS_OFFSET            /* offset  3               */
+        bl      _i2cRead
+        mov     r8, r7                             /* r8 save number of rows  */
+
+        mov     r7, #NUM_OF_COLS_OFFSET            /* offset  4               */
+        bl      _i2cRead
+        add     r8, r8, r7                         /* r8 = number of rows + number of col */
+
+        mov     r7, #0x1
+        mov     r8, r7, LSL r8                     /* r8 = (1 << r8)          */
+
+        mov     r7, #SDRAM_WIDTH_OFFSET            /* offset 13 */
+        bl      _i2cRead
+        mul     r8, r7, r8
+
+        mov     r7, #NUM_OF_BANKS_OFFSET           /* offset 17               */
+        bl      _i2cRead
+        mul     r7, r8, r7
+
+	mov     PC, r13
+
+/**************************/
+_get_width:
+	mov     r13, LR                 /* Save link register */
+
+	/* Read SPD rank size from DIMM0 */
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+
+	cmp	r6, #0
+	beq	1f
+
+	/* Read SPD rank size from DIMM1 */
+        mov     r4, #MV_BOARD_DIMM1_I2C_ADDR /* reading from DIMM1            */
+
+1:
+        /* Get SDRAM width (SPD offset 13) */
+        mov     r7, #SDRAM_WIDTH_OFFSET
+        bl      _i2cRead                /* result in r7                       */
+
+	mov     PC, r13
+
+/**************************/
+_get_CAL:
+	mov     r13, LR                 /* Save link register */
+
+        /* Set maximum CL supported by DIMM */
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+        mov     r7, #SUPPORTED_CL_OFFSET     /* offset  18 */
+        bl      _i2cRead
+
+	mov     PC, r13
+
+/**************************/
+/* R8 - sdram configuration register.
+ * Return value in flag if no-registered then Z-flag is set
+ */
+_is_Registered:
+	mov     r13, LR                 /* Save link register */
+#if defined(MV645xx)
+        /* Get registered/non registered info from DIMM */
+        tst     r8, #SDRAM_DTYPE_DDR2
+        bne     regDdr2
+
+regDdr1:
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+        mov     r7, #SDRAM_MODULES_ATTR_OFFSET
+        bl      _i2cRead                /* result in r7                       */
+
+        tst     r7, #0x2
+	b	exit
+#endif
+regDdr2:
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+        mov     r7, #DIMM_TYPE_INFO_OFFSET
+        bl      _i2cRead                /* result in r7                       */
+
+        tst     r7, #0x11               /* DIMM type = regular RDIMM (0x01)   */
+                                        /* or Mini-RDIMM (0x10)               */
+exit:
+        mov     PC, r13
+
+
+/**************************/
+/* Return value in flag if no-Ecc then Z-flag is set */
+_is_Ecc:
+	mov     r13, LR                 /* Save link register */
+
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+        mov     r7, #DIMM_CONFIG_TYPE
+        bl      _i2cRead                /* result in r7                       */
+
+        tst     r7, #0x2               /* bit 1 -> Data ECC */
+        mov     PC, r13
+
+/**************************/
+/* Return value in flag if no second DIMM then Z-flag is set */
+_is_Second_Dimm_Exist:
+	mov     r13, LR                 /* Save link register */
+
+        mov     r4, #MV_BOARD_DIMM1_I2C_ADDR /* reading from DIMM0            */
+        mov     r7, #DIMM_TYPE_OFFSET
+        bl      _i2cRead                /* result in r7                       */
+
+     	tst     r7, #0x8               /* bit3 is '1' -> DDR 2 */
+        mov     PC, r13
+
+/*******************************************************************************
+* _mvDramIfGetDimmSizeFromSpd  - read bank 0 dram's size
+*
+* DESCRIPTION:
+*       The function will read the bank 0 dram size(SPD version 1.0 and above )
+*
+* INPUT:
+*       r6 - dram bank number.
+*
+* OUTPUT:
+*	none
+*/
+_mvDramIfGetDimmSizeFromSpd:
+
+	mov     r13, LR                 /* Save link register */
+
+	/* Read SPD rank size from DIMM0 */
+        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
+
+	cmp	r6, #0
+	beq	1f
+
+	/* Read SPD rank size from DIMM1 */
+        mov     r4, #MV_BOARD_DIMM1_I2C_ADDR /* reading from DIMM1            */
+
+1:
+        mov     r7, #RANK_SIZE_OFFSET	/* offset  31 */
+        bl      _i2cRead
+
+pass_read:
+      	ldr     r8, =(0x7 << SCSR_SIZE_OFFS)
+        cmp	r7, #DRAM_RANK_DENSITY_128M
+        beq     endDimmSize
+
+      	ldr     r8, =(0xf << SCSR_SIZE_OFFS)
+        cmp	r7, #DRAM_RANK_DENSITY_256M
+        beq     endDimmSize
+
+        ldr     r8, =(0x1f << SCSR_SIZE_OFFS)
+        cmp	r7, #DRAM_RANK_DENSITY_512M
+        beq     endDimmSize
+
+        ldr     r8, =(0x3f << SCSR_SIZE_OFFS)
+        cmp	r7, #DRAM_RANK_DENSITY_1G
+        beq     endDimmSize
+
+        ldr     r8, =(0x7f  << SCSR_SIZE_OFFS)     /* DRAM_RANK_DENSITY_2G */
+endDimmSize:
+        mov     PC, r13
+#endif
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S
new file mode 100644
index 0000000..38060d9
--- /dev/null
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S
@@ -0,0 +1,528 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvDramIfBasicAsm.s
+*
+* DESCRIPTION:
+*       Memory full detection and best timing configuration is done in
+*       C code. C runtime environment requires a stack. This module API
+*       initialize DRAM interface chip select 0 for basic functionality for
+*       the use of stack.
+*       The module API assumes DRAM information is stored in I2C EEPROM reside
+*       in a given I2C address MV_BOARD_DIMM0_I2C_ADDR. The I2C EEPROM
+*       internal data structure is assumed to be orgenzied in common DRAM
+*       vendor SPD structure.
+*       NOTE: DFCDL values are assumed to be already initialized prior to
+*       this module API activity.
+*
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+/* includes */
+#define	_ASMLANGUAGE
+#define MV_ASMLANGUAGE
+#include "mvOsAsm.h"
+#include "mvSysHwConfig.h"
+#include "mvDramIfRegs.h"
+#include "mvDramIfConfig.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "pex/mvPexRegs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvCommon.h"
+
+/* defines  */
+
+/* locals   */
+.data
+.globl _mvDramIfConfig
+.text
+.globl _mvDramIfMemInit
+
+/*******************************************************************************
+* _mvDramIfConfig - Basic DRAM interface initialization.
+*
+* DESCRIPTION:
+*       The function will initialize the following DRAM parameters using the
+*       values prepared by mvDramIfDetect routine. Values are located
+*       in predefined registers.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+
+_mvDramIfConfig:
+
+        /* Save register on stack */
+	cmp	sp, #0
+	beq	no_stack_s
+save_on_stack:
+        stmdb	sp!, {r1, r2, r3, r4}
+no_stack_s:
+
+	/* Dunit FTDLL Configuration Register */
+	/* 0) Write to SDRAM FTDLL coniguration register */
+        ldr     r4, = SDRAM_FTDLL_REG_DEFAULT_LEFT;
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_FTDLL_CONFIG_LEFT_REG)
+        str     r4, [r1]
+        ldr     r4, = SDRAM_FTDLL_REG_DEFAULT_RIGHT;
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_FTDLL_CONFIG_RIGHT_REG)
+        str     r4, [r1]
+        ldr     r4, = SDRAM_FTDLL_REG_DEFAULT_UP;
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_FTDLL_CONFIG_UP_REG)
+        str     r4, [r1]
+
+	/* 1) Write to SDRAM coniguration register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG1)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_CONFIG_REG)
+        str     r4, [r1]
+
+	/* 2) Write Dunit control low register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG3)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_DUNIT_CTRL_REG)
+        str     r4, [r1]
+
+	/* 2) Write Dunit control high register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG13)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_DUNIT_CTRL_HI_REG)
+        str     r4, [r1]
+
+        /* 3) Write SDRAM address control register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG4)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_ADDR_CTRL_REG)
+        str     r4, [r1]
+#if defined(MV_STATIC_DRAM_ON_BOARD)
+        /* 4) Write SDRAM bank 0 size register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG0)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_SIZE_REG(0,0))
+        str     r4, [r1]
+#endif
+
+        /* 5) Write SDRAM open pages control register */
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_OPEN_PAGE_CTRL_REG)
+        ldr     r4, =SDRAM_OPEN_PAGES_CTRL_REG_DV
+        str     r4, [r1]
+
+        /* 6) Write SDRAM timing Low register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG5)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_TIMING_CTRL_LOW_REG)
+        str     r4, [r1]
+
+        /* 7) Write SDRAM timing High register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG6)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_TIMING_CTRL_HIGH_REG)
+        str     r4, [r1]
+
+        /* Config DDR2 On Die Termination (ODT) registers */
+        /* Write SDRAM DDR2 ODT control low register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG7)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + DDR2_SDRAM_ODT_CTRL_LOW_REG)
+        str     r4, [r1]
+
+        /* Write SDRAM DDR2 ODT control high register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG8)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + DDR2_SDRAM_ODT_CTRL_HIGH_REG)
+        str     r4, [r1]
+
+        /* Write SDRAM DDR2 Dunit ODT control register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG9)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + DDR2_DUNIT_ODT_CONTROL_REG)
+        str     r4, [r1]
+
+        /* Write DDR2 SDRAM timing Low register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG11)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_DDR2_TIMING_LO_REG)
+        str     r4, [r1]
+
+        /* Write DDR2 SDRAM timing High register */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG12)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_DDR2_TIMING_HI_REG)
+        str     r4, [r1]
+
+        /* 8) Write SDRAM mode register */
+        /* The CPU must not attempt to change the SDRAM Mode register setting */
+        /* prior to DRAM controller completion of the DRAM initialization     */
+        /* sequence. To guarantee this restriction, it is recommended that    */
+        /* the CPU sets the SDRAM Operation register to NOP command, performs */
+        /* read polling until the register is back in Normal operation value, */
+        /* and then sets SDRAM Mode register to its new value.               */
+
+	/* 8.1 write 'nop' to SDRAM operation */
+        mov     r4, #0x5                 /* 'NOP' command              */
+        MV_REG_WRITE_ASM(r4, r1, SDRAM_OPERATION_REG)
+
+        /* 8.2 poll SDRAM operation. Make sure its back to normal operation   */
+_sdramOpPoll1:
+        ldr     r4, [r1]
+        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll1
+
+        /* 8.3 Now its safe to write new value to SDRAM Mode register         */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG2)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_MODE_REG)
+        str     r4, [r1]
+
+        /* 8.4 Make the Dunit write the DRAM its new mode                     */
+        mov     r4, #0x3                 /* Mode Register Set command  */
+        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_REG)
+
+        /* 8.5 poll SDRAM operation. Make sure its back to normal operation   */
+_sdramOpPoll2:
+        ldr     r4, [r1]
+        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll2
+
+        /* Now its safe to write new value to SDRAM Extended Mode regist */
+        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG10)
+        ldr     r4, [r1]
+        ldr     r1, =(INTER_REGS_BASE + SDRAM_EXTENDED_MODE_REG)
+        str     r4, [r1]
+
+        /* 9) Write SDRAM Extended mode register This operation should be     */
+        /*    done for each memory bank                                       */
+        /* write 'nop' to SDRAM operation */
+        mov     r4, #0x5                 /* 'NOP' command              */
+        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_REG)
+
+        /* poll SDRAM operation. Make sure its back to normal operation   */
+_sdramOpPoll3:
+        ldr     r4, [r1]
+        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll3
+        /* Go over each of the Banks */
+        ldr     r3, =0          /* r3 = DRAM bank Num */
+
+extModeLoop:
+        /* Set the SDRAM Operation Control to each of the DRAM banks          */
+        mov     r4, r3   /* Do not swap the bank counter value */
+        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_CTRL_REG)
+
+        /* Make the Dunit write the DRAM its new mode                     */
+        mov     r4, #0x4        /* Extended Mode Register Set command  */
+        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_REG)
+
+        /* poll SDRAM operation. Make sure its back to normal operation   */
+_sdramOpPoll4:
+        ldr     r4, [r1]
+        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
+        bne     _sdramOpPoll4
+
+        add     r3, r3, #1
+        cmp     r3, #4         /* 4 = Number of banks */
+        bne     extModeLoop
+
+extModeEnd:
+cmp	sp, #0
+	beq	no_stack_l
+	mov     r1, LR                        	/* Save link register */
+#if defined(MV78XX0)
+	bl   	_mvDramIfMemInit
+#endif
+	mov	LR,r1				/* restore link register */
+load_from_stack:
+	/* Restore registers */
+        ldmia	sp!, {r1, r2, r3, r4}
+no_stack_l:
+
+        mov     pc, lr
+
+
+/*******************************************************************************
+* _mvDramIfEccMemInit - Basic DRAM ECC initialization.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+#define XOR_CHAN0         0   /* XOR channel 0 used for memory initialization */
+#define XOR_UNIT0         0   /* XOR unit 0 used for memory initialization */
+#define XOR_ADDR_DEC_WIN0 0   /* Enable DRAM access using XOR decode window 0 */
+/* XOR engine register offsets macros */
+#define XOR_CONFIG_REG(chan)                (XOR_UNIT_BASE(0) + 0x10 + ((chan)    * 4))
+#define XOR_ACTIVATION_REG(chan)            (XOR_UNIT_BASE(0) + 0x20 + ((chan)    * 4))
+#define XOR_CAUSE_REG			            (XOR_UNIT_BASE(0) + 0x30)
+#define XOR_ERROR_CAUSE_REG                 (XOR_UNIT_BASE(0) + 0x50)
+#define XOR_ERROR_ADDR_REG                  (XOR_UNIT_BASE(0) + 0x60)
+#define XOR_INIT_VAL_LOW_REG                (XOR_UNIT_BASE(0) + 0x2E0)
+#define XOR_INIT_VAL_HIGH_REG               (XOR_UNIT_BASE(0) + 0x2E4)
+#define XOR_DST_PTR_REG(chan)               (XOR_UNIT_BASE(0) + 0x2B0 + ((chan)    * 4))
+#define XOR_BLOCK_SIZE_REG(chan)            (XOR_UNIT_BASE(0) + 0x2C0 + ((chan)    * 4))
+
+/* XOR Engine Address Decoding Register Map */
+#define XOR_WINDOW_CTRL_REG(unit,chan)     (XOR_UNIT_BASE(unit)+(0x240 + ((chan) * 4)))
+#define XOR_BASE_ADDR_REG(unit,winNum)     (XOR_UNIT_BASE(unit)+(0x250 + ((winNum) * 4)))
+#define XOR_SIZE_MASK_REG(unit,winNum)     (XOR_UNIT_BASE(unit)+(0x270 + ((winNum) * 4)))
+
+.globl _mvDramIfEccMemInit
+/*******************************************************************************
+* _mvDramIfEccMemInit  - mem init for dram cs
+*
+* DESCRIPTION:
+*       This function will clean the cs by ussing the XOR mem init.
+*
+* INPUT:
+*       r0 - dram bank number.
+*
+* OUTPUT:
+*	none
+*/
+_mvDramIfEccMemInit:
+
+        /* Save register on stack */
+	cmp	sp, #0
+	beq	no_stack_s1
+save_on_stack1:
+        stmdb	sp!, {r0,r1, r2, r3, r4, r5, r6}
+no_stack_s1:
+
+	ldr	r1, = 0
+
+        /* Disable all XOR address decode windows to avoid possible overlap */
+        MV_REG_WRITE_ASM (r1, r5, (XOR_WINDOW_CTRL_REG(XOR_UNIT0,XOR_CHAN0)))
+
+        /* Init r5 to first XOR_SIZE_MASK_REG */
+		mov		r5, r0, LSL #3
+        add     r5, r5,#0x1500
+        add     r5, r5,#0x04
+        add     r5, r5,#(INTER_REGS_BASE)
+        ldr     r6, [r5]
+        HTOLL(r6,r5)
+        MV_REG_WRITE_ASM (r6, r5, XOR_SIZE_MASK_REG(XOR_UNIT0,XOR_ADDR_DEC_WIN0))
+
+	mov		r5, r0, LSL #3
+        add     r5, r5,#0x1500
+        add     r5, r5,#(INTER_REGS_BASE)
+        ldr     r6, [r5]
+        /* Update destination & size */
+        MV_REG_WRITE_ASM(r6, r5, XOR_DST_PTR_REG(XOR_CHAN0))
+        HTOLL(r6,r5)
+        /* Init r6 to first XOR_BASE_ADDR_REG */
+	ldr	r4, = 0xf
+	ldr	r5, = 0x1
+	mov	r5, r5, LSL r0
+	bic	r4, r4, r5
+	mov 	r4, r4, LSL #8
+
+        orr	r6, r6, r4
+        MV_REG_WRITE_ASM (r6, r5, XOR_BASE_ADDR_REG(XOR_UNIT0,XOR_ADDR_DEC_WIN0))
+
+	ldr	r6, = 0xff0001
+        MV_REG_WRITE_ASM (r6, r5, XOR_WINDOW_CTRL_REG(XOR_UNIT0,XOR_CHAN0))
+
+        /* Configure XOR engine for memory init function.           */
+        MV_REG_READ_ASM (r6, r5, XOR_CONFIG_REG(XOR_CHAN0))
+        and	r6, r6, #~0x7        	/* Clear operation mode field      */
+        orr     r6, r6, #0x4             /* Set operation to memory init    */
+        MV_REG_WRITE_ASM(r6, r5, XOR_CONFIG_REG(XOR_CHAN0))
+
+        /* Set initVal in the XOR Engine Initial Value Registers       */
+	ldr	r6, = 0xfeedfeed
+        MV_REG_WRITE_ASM(r6, r5, XOR_INIT_VAL_LOW_REG)
+	ldr	r6, = 0xfeedfeed
+        MV_REG_WRITE_ASM(r6, r5, XOR_INIT_VAL_HIGH_REG)
+
+        /* Set block size using DRAM bank size  */
+
+	mov	r5, r0, LSL #3
+        add     r5, r5,#0x1500
+        add     r5, r5,#0x04
+        add     r5, r5,#(INTER_REGS_BASE)
+
+        ldr     r6, [r5]
+        HTOLL(r6,r5)
+	and	r6, r6, #SCSR_SIZE_MASK
+	mov	r5, r6, LSR #SCSR_SIZE_OFFS
+        add	r5, r5, #1
+	mov	r6, r5, LSL #SCSR_SIZE_OFFS
+        MV_REG_WRITE_ASM(r6, r5, XOR_BLOCK_SIZE_REG(XOR_CHAN0))
+
+        /* Clean interrupt cause*/
+        MV_REG_WRITE_ASM(r1, r5, XOR_CAUSE_REG)
+
+        /* Clean error interrupt cause*/
+        MV_REG_READ_ASM(r6, r5, XOR_ERROR_CAUSE_REG)
+        MV_REG_READ_ASM(r6, r5, XOR_ERROR_ADDR_REG)
+
+        /* Start transfer */
+        MV_REG_READ_ASM (r6, r5, XOR_ACTIVATION_REG(XOR_CHAN0))
+        orr     r6, r6, #0x1 /* Preform start command      */
+        MV_REG_WRITE_ASM(r6, r5, XOR_ACTIVATION_REG(XOR_CHAN0))
+
+        /* Wait for engine to finish */
+waitForComplete:
+        MV_REG_READ_ASM(r6, r5, XOR_CAUSE_REG)
+        and   	r6, r6, #2
+	cmp	r6, #0
+        beq     waitForComplete
+
+        /* Clear all error report registers */
+        MV_REG_WRITE_ASM(r1, r5, SDRAM_SINGLE_BIT_ERR_CNTR_REG)
+        MV_REG_WRITE_ASM(r1, r5, SDRAM_DOUBLE_BIT_ERR_CNTR_REG)
+
+        MV_REG_WRITE_ASM(r1, r5, SDRAM_ERROR_CAUSE_REG)
+
+	cmp	sp, #0
+	beq	no_stack_l1
+load_from_stack1:
+        ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6}
+no_stack_l1:
+        mov     pc, lr
+
+
+/*******************************************************************************
+* mvDramIfMemInit - Use XOR to clear all memory.
+*
+* DESCRIPTION:
+*       Use assembler function _mvDramIfEccMemInit to fill all memory with FEADFEAD pattern.
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+#if defined(MV78XX0)
+
+_mvDramIfMemInit:
+        stmdb	sp!, {r0,r1, r2, r3, r4, r5, r6}
+	mov     r6, LR                 /* Save link register */
+    	/* Check if dram bank 0 has to be init for ECC */
+	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,0))
+	and 	r3, r0, #SCSR_WIN_EN
+        cmp     r3, #0
+	beq   	no_bank_0
+	MV_REG_READ_ASM(r0, r5,  SDRAM_BASE_ADDR_REG(0,0))
+        cmp     r0, #0
+	beq   	no_bank_0
+	mov	r0,#0
+	bl	_mvDramIfEccMemInit
+
+no_bank_0:
+    	/* Check if dram bank 1 has to be init for ECC */
+        MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,1))
+	and 	r0, r0, #SCSR_WIN_EN
+        cmp     r0, #0
+	beq   	no_bank_1
+	mov	r0,#1
+	bl	_mvDramIfEccMemInit
+no_bank_1:
+    	/* Check if dram bank 2 has to be init for ECC */
+    	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,2))
+	and 	r0, r0, #SCSR_WIN_EN
+        cmp     r0, #0
+	beq   	no_bank_2
+	MV_REG_READ_ASM(r0, r5,  SDRAM_BASE_ADDR_REG(0,2))
+        cmp     r0, #0
+	beq   	no_bank_2
+	mov	r0,#2
+	bl	_mvDramIfEccMemInit
+
+no_bank_2:
+    	/* Check if dram bank 3 has to be init for ECC */
+	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,3))
+	and 	r0, r0, #SCSR_WIN_EN
+	cmp     r0, #0
+	beq   	no_bank_3
+	mov	r0,#3
+	bl	_mvDramIfEccMemInit
+no_bank_3:
+	mov     LR ,r6                /* restore link register */
+	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6}
+	mov     pc, lr
+#endif
+
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.h
index 6141c46..ccfd491 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -84,7 +84,7 @@ extern "C" {
 		 (BIT28 | BIT29))
 
 #define SDRAM_ADDR_CTRL_DV	    2
-		
+
 #define SDRAM_TIMING_CTRL_LOW_REG_DV 	\
 		((0x2 << SDRAM_TRCD_OFFS) | 	\
 		 (0x2 << SDRAM_TRP_OFFS)  | 	\
@@ -99,7 +99,7 @@ extern "C" {
 		 (0x0 << SDRAM_TR2W_W2R_OFFS)	|	\
 		 (0x1 << SDRAM_TW2W_OFFS))
 
-#define SDRAM_OPEN_PAGES_CTRL_REG_DV 	SDRAM_OPEN_PAGE_EN	
+#define SDRAM_OPEN_PAGES_CTRL_REG_DV 	SDRAM_OPEN_PAGE_EN
 
 /* Presence	     Ctrl Low    Ctrl High  Dunit Ctrl   Ext Mode     */
 /* CS0              0x84210000  0x00000000  0x0000780F  0x00000440    */
@@ -132,7 +132,7 @@ extern "C" {
 /* DDR SDRAM Adderss/Control and Data Pads Calibration default values */
 #define DDR2_ADDR_CTRL_PAD_STRENGTH_TYPICAL_DV	\
 		(3 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
-		
+
 #define DDR2_DATA_PAD_STRENGTH_TYPICAL_DV		\
 		(3 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfRegs.h
index 369eda6..58175f6 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -72,12 +72,12 @@ extern "C" {
 /* DDR SDRAM Controller Address Decode Registers */
  /* SDRAM CSn Base Address Register (SCBAR) */
 #define SDRAM_BASE_ADDR_REG(cpu,csNum)	(0x1500 + ((csNum) * 8) + ((cpu) * 0x70))
-#define SCBAR_BASE_OFFS			16 
+#define SCBAR_BASE_OFFS			16
 #define SCBAR_BASE_MASK			(0xffff << SCBAR_BASE_OFFS)
-#define SCBAR_BASE_ALIGNMENT		0x10000 
+#define SCBAR_BASE_ALIGNMENT		0x10000
 
-/* SDRAM CSn Size Register (SCSR) */		  
-#define SDRAM_SIZE_REG(cpu,csNum)	(0x1504 + ((csNum) * 8) + ((cpu) * 0x70)) 
+/* SDRAM CSn Size Register (SCSR) */
+#define SDRAM_SIZE_REG(cpu,csNum)	(0x1504 + ((csNum) * 8) + ((cpu) * 0x70))
 #define SCSR_SIZE_OFFS			24
 #define SCSR_SIZE_MASK			(0xff << SCSR_SIZE_OFFS)
 #define SCSR_SIZE_ALIGNMENT		0x1000000
@@ -262,9 +262,9 @@ extern "C" {
 #define SDRAM_WR_5_CYC				(4 << SDRAM_WR_OFFS)
 #define SDRAM_WR_6_CYC				(5 << SDRAM_WR_OFFS)
 #define SDRAM_PD_OFFS				12
-#define SDRAM_PD_MASK				(1 << SDRAM_PD_OFFS) 
-#define SDRAM_PD_FAST_EXIT			(0 << SDRAM_PD_OFFS) 
-#define SDRAM_PD_SLOW_EXIT			(1 << SDRAM_PD_OFFS) 
+#define SDRAM_PD_MASK				(1 << SDRAM_PD_OFFS)
+#define SDRAM_PD_FAST_EXIT			(0 << SDRAM_PD_OFFS)
+#define SDRAM_PD_SLOW_EXIT			(1 << SDRAM_PD_OFFS)
 
 /* DDR SDRAM Extended Mode register (DSEMR) */
 #define SDRAM_EXTENDED_MODE_REG		(DRAM_BASE + 0x1420)
@@ -296,7 +296,7 @@ extern "C" {
 #define SDRAM_FTDLL_CONFIG_LEFT_REG		(DRAM_BASE + 0x1484)
 #define SDRAM_FTDLL_CONFIG_RIGHT_REG		(DRAM_BASE + 0x161C)
 #define SDRAM_FTDLL_CONFIG_UP_REG		(DRAM_BASE + 0x1620)
-  
+
 /* Pads Calibration register */
 #define SDRAM_ADDR_CTRL_PADS_CAL_REG	(DRAM_BASE + 0x14c0)
 #define SDRAM_DATA_PADS_CAL_REG		    (DRAM_BASE + 0x14c4)
@@ -344,8 +344,8 @@ extern "C" {
 #define DSOCR_ODT_EN_MASK           (0x3 << DSOCR_ODT_EN_OFFS)
 /* For ctrl parameters see DDR2 SDRAM ODT Control (High) Register (0x1498) above. */
 #define DSOCR_ODT_EN(ctrl)         	(ctrl << DSOCR_ODT_EN_OFFS)
-#define DSOCR_ODT_SEL_DISABLE	    0	
-#define DSOCR_ODT_SEL_75_OHM	    2	
+#define DSOCR_ODT_SEL_DISABLE	    0
+#define DSOCR_ODT_SEL_75_OHM	    2
 #define DSOCR_ODT_SEL_150_OHM	    1
 #define DSOCR_ODT_SEL_50_OHM        3
 #define DSOCR_DQ_ODT_SEL_OFFS       10
@@ -390,7 +390,7 @@ extern "C" {
 /* SDRAM Error Address Register (SEAR) */
 #define SEAR_ERR_TYPE_OFFS			0
 #define SEAR_ERR_TYPE_MASK      	(1 << SEAR_ERR_TYPE_OFFS)
-#define SEAR_ERR_TYPE_SINGLE    	0	
+#define SEAR_ERR_TYPE_SINGLE    	0
 #define SEAR_ERR_TYPE_DOUBLE    	(1 << SEAR_ERR_TYPE_OFFS)
 #define SEAR_ERR_CS_OFFS			1
 #define SEAR_ERR_CS_MASK			(3 << SEAR_ERR_CS_OFFS)
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfStaticInit.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfStaticInit.h
index f3bf83b..6df9666 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfStaticInit.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfStaticInit.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -68,70 +68,70 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #ifdef MV_STATIC_DRAM_ON_BOARD
 #define STATIC_DRAM_BANK_1
-#undef	STATIC_DRAM_BANK_2             
-#undef	STATIC_DRAM_BANK_3                         
-#undef 	STATIC_DRAM_BANK_4             
+#undef	STATIC_DRAM_BANK_2
+#undef	STATIC_DRAM_BANK_3
+#undef 	STATIC_DRAM_BANK_4
 
 
 #ifdef MV_DIMM_TS256MLQ72V5U
-#define	STATIC_DRAM_BANK_2             
-#define	STATIC_DRAM_BANK_3                         
-#undef 	STATIC_DRAM_BANK_4             
-
-#define STATIC_SDRAM_CONFIG_REG		    0x4724481A  /* offset 0x1400 - DMA reg-0xf1000814 */ 
-#define STATIC_SDRAM_DUNIT_CTRL_REG         0x37707450  /* offset 0x1404 - DMA reg-0xf100081c */ 
-#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    0x11A13330  /* offset 0x1408 - DMA reg-0xf1000824 */ 
-#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG   0x00000601  /* offset 0x140c - DMA reg-0xf1000828 */ 
-#define STATIC_SDRAM_ADDR_CTRL_REG          0x00001CB2  /* offset 0x1410 - DMA reg-0xf1000820 */ 
-#define STATIC_SDRAM_MODE_REG               0x00000642  /* offset 0x141c - DMA reg-0xf1000818 */ 
-#define STATIC_SDRAM_ODT_CTRL_LOW	    0x030C030C /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	    0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    	    0x0000740F /*   0x149c  */  
-#define STATIC_SDRAM_EXT_MODE          	    0x00000404 /*   0x1420  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO         0x00074410 /*   0x1428  */  
-#define STATIC_SDRAM_DDR2_TIMING_HI         0x00007441 /*   0x147C  */  
-
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0       0x3FFF /* size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_RANK1_SIZE_DIMM0       0x3FFF /* size bank1 dimm0   */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM1       0x3FFF /* size bank0 dimm1   */ 
-#define STATIC_SDRAM_RANK1_SIZE_DIMM1       0x0	   /* size bank1 dimm1   */ 
+#define	STATIC_DRAM_BANK_2
+#define	STATIC_DRAM_BANK_3
+#undef 	STATIC_DRAM_BANK_4
+
+#define STATIC_SDRAM_CONFIG_REG		    0x4724481A  /* offset 0x1400 - DMA reg-0xf1000814 */
+#define STATIC_SDRAM_DUNIT_CTRL_REG         0x37707450  /* offset 0x1404 - DMA reg-0xf100081c */
+#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    0x11A13330  /* offset 0x1408 - DMA reg-0xf1000824 */
+#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG   0x00000601  /* offset 0x140c - DMA reg-0xf1000828 */
+#define STATIC_SDRAM_ADDR_CTRL_REG          0x00001CB2  /* offset 0x1410 - DMA reg-0xf1000820 */
+#define STATIC_SDRAM_MODE_REG               0x00000642  /* offset 0x141c - DMA reg-0xf1000818 */
+#define STATIC_SDRAM_ODT_CTRL_LOW	    0x030C030C /*   0x1494  */
+#define STATIC_SDRAM_ODT_CTRL_HI	    0x00000000 /*   0x1498  */
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    	    0x0000740F /*   0x149c  */
+#define STATIC_SDRAM_EXT_MODE          	    0x00000404 /*   0x1420  */
+#define STATIC_SDRAM_DDR2_TIMING_LO         0x00074410 /*   0x1428  */
+#define STATIC_SDRAM_DDR2_TIMING_HI         0x00007441 /*   0x147C  */
+
+#define STATIC_SDRAM_RANK0_SIZE_DIMM0       0x3FFF /* size bank0 dimm0   - DMA reg-0xf1000810 */
+#define STATIC_SDRAM_RANK1_SIZE_DIMM0       0x3FFF /* size bank1 dimm0   */
+#define STATIC_SDRAM_RANK0_SIZE_DIMM1       0x3FFF /* size bank0 dimm1   */
+#define STATIC_SDRAM_RANK1_SIZE_DIMM1       0x0	   /* size bank1 dimm1   */
 
 #endif /* TS256MLQ72V5U */
 
 
 #ifdef MV_MT9VDDT3272AG
 /* one DIMM 256M  */
-#define STATIC_SDRAM_CONFIG_REG		    0x5820040d  /* offset 0x1400 - DMA reg-0xf1000814 */ 
-#define STATIC_SDRAM_DUNIT_CTRL_REG         0xC4000540  /* offset 0x1404 - DMA reg-0xf100081c */ 
-#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    0x01602220  /* offset 0x1408 - DMA reg-0xf1000824 */ 
-#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG   0x0000000b  /* offset 0x140c - DMA reg-0xf1000828 */ 
-#define STATIC_SDRAM_ADDR_CTRL_REG          0x00000012  /* offset 0x1410 - DMA reg-0xf1000820 */ 
-#define STATIC_SDRAM_MODE_REG               0x00000062  /* offset 0x141c - DMA reg-0xf1000818 */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0       0x0fff /* size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM1       0x0    /* size bank0 dimm1   */ 
+#define STATIC_SDRAM_CONFIG_REG		    0x5820040d  /* offset 0x1400 - DMA reg-0xf1000814 */
+#define STATIC_SDRAM_DUNIT_CTRL_REG         0xC4000540  /* offset 0x1404 - DMA reg-0xf100081c */
+#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    0x01602220  /* offset 0x1408 - DMA reg-0xf1000824 */
+#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG   0x0000000b  /* offset 0x140c - DMA reg-0xf1000828 */
+#define STATIC_SDRAM_ADDR_CTRL_REG          0x00000012  /* offset 0x1410 - DMA reg-0xf1000820 */
+#define STATIC_SDRAM_MODE_REG               0x00000062  /* offset 0x141c - DMA reg-0xf1000818 */
+#define STATIC_SDRAM_RANK0_SIZE_DIMM0       0x0fff /* size bank0 dimm0   - DMA reg-0xf1000810 */
+#define STATIC_SDRAM_RANK0_SIZE_DIMM1       0x0    /* size bank0 dimm1   */
 
 #endif /* MV_MT9VDDT3272AG */
 
 
 
 #ifdef MV_D27RB12P
-/* 
+/*
 Two DIMM 512M + ECC enabled, Registered DIMM  CAS Latency 2.5
 */
 
-#define STATIC_SDRAM_CONFIG_REG		    0x6826081E  /* offset 0x1400 - DMA reg-0xf1000814 */ 
-#define STATIC_SDRAM_DUNIT_CTRL_REG         0xC5000540  /* offset 0x1404 - DMA reg-0xf100081c */ 
-#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    0x01501220  /* offset 0x1408 - DMA reg-0xf1000824 */ 
-#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG   0x00000009  /* offset 0x140c - DMA reg-0xf1000828 */ 
-#define STATIC_SDRAM_ADDR_CTRL_REG          0x00000012  /* offset 0x1410 - DMA reg-0xf1000820 */ 
-#define STATIC_SDRAM_MODE_REG               0x00000062  /* offset 0x141c - DMA reg-0xf1000818 */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0       0x0FFF /* size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM1       0x0FFF    /* size bank0 dimm1   */ 
+#define STATIC_SDRAM_CONFIG_REG		    0x6826081E  /* offset 0x1400 - DMA reg-0xf1000814 */
+#define STATIC_SDRAM_DUNIT_CTRL_REG         0xC5000540  /* offset 0x1404 - DMA reg-0xf100081c */
+#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    0x01501220  /* offset 0x1408 - DMA reg-0xf1000824 */
+#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG   0x00000009  /* offset 0x140c - DMA reg-0xf1000828 */
+#define STATIC_SDRAM_ADDR_CTRL_REG          0x00000012  /* offset 0x1410 - DMA reg-0xf1000820 */
+#define STATIC_SDRAM_MODE_REG               0x00000062  /* offset 0x141c - DMA reg-0xf1000818 */
+#define STATIC_SDRAM_RANK0_SIZE_DIMM0       0x0FFF /* size bank0 dimm0   - DMA reg-0xf1000810 */
+#define STATIC_SDRAM_RANK0_SIZE_DIMM1       0x0FFF    /* size bank0 dimm1   */
 
-#define STATIC_DRAM_BANK_2             
+#define STATIC_DRAM_BANK_2
 
-#define STATIC_DRAM_BANK_3                         
-#define STATIC_DRAM_BANK_4             
+#define STATIC_DRAM_BANK_3
+#define STATIC_DRAM_BANK_4
 
 #endif /*  mv_D27RB12P  */
 
@@ -141,9 +141,9 @@ Two DIMM 512M + ECC enabled, Registered DIMM  CAS Latency 2.5
 #define STATIC_DIMM_INFO_BANK0_SIZE		256
 /* DDR2 boards 256 MB*/
 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0       	0x00000fff /* size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_CONFIG_REG	     		0x07190618	
-#define STATIC_SDRAM_MODE_REG	     		0x00000432	
+#define STATIC_SDRAM_RANK0_SIZE_DIMM0       	0x00000fff /* size bank0 dimm0   - DMA reg-0xf1000810 */
+#define STATIC_SDRAM_CONFIG_REG	     		0x07190618
+#define STATIC_SDRAM_MODE_REG	     		0x00000432
 #define STATIC_SDRAM_DUNIT_CTRL_REG     	0xf4a03440
 #define STATIC_SDRAM_ADDR_CTRL_REG	     	0x00000022
 #define STATIC_SDRAM_TIMING_CTRL_LOW_REG    	0x11712220
@@ -156,21 +156,21 @@ Two DIMM 512M + ECC enabled, Registered DIMM  CAS Latency 2.5
 #define STATIC_SDRAM_DDR2_TIMING_HI         	0x00006330
 #endif /* RD_MV645XX */
 
-#if MV_DIMM_M3783354CZ3_CE6 
-
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0		0x00000FFF /* 0x2010 size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_CONFIG_REG	     		0x07190618 /*   0x1400  */ 
-#define STATIC_SDRAM_MODE_REG	     		0x00000432 /*   0x141c  */  
-#define STATIC_SDRAM_DUNIT_CTRL_REG     	0xf4a03440 /*   0x1404  */  
-#define STATIC_SDRAM_ADDR_CTRL_REG	     	0x00000022 /*   0x1410  */  
-#define STATIC_SDRAM_TIMING_CTRL_LOW_REG	0x11712220 /*   0x1408  */  
-#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG	0x00000504 /*   0x140c  */  
-#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000780f /*   0x149c  */  
-#define STATIC_SDRAM_EXT_MODE          		0x00000440 /*   0x1420  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO		0x00063300 /*   0x1428  */  
-#define STATIC_SDRAM_DDR2_TIMING_HI		0x00006330 /*   0x147C  */  
+#if MV_DIMM_M3783354CZ3_CE6
+
+#define STATIC_SDRAM_RANK0_SIZE_DIMM0		0x00000FFF /* 0x2010 size bank0 dimm0   - DMA reg-0xf1000810 */
+#define STATIC_SDRAM_CONFIG_REG	     		0x07190618 /*   0x1400  */
+#define STATIC_SDRAM_MODE_REG	     		0x00000432 /*   0x141c  */
+#define STATIC_SDRAM_DUNIT_CTRL_REG     	0xf4a03440 /*   0x1404  */
+#define STATIC_SDRAM_ADDR_CTRL_REG	     	0x00000022 /*   0x1410  */
+#define STATIC_SDRAM_TIMING_CTRL_LOW_REG	0x11712220 /*   0x1408  */
+#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG	0x00000504 /*   0x140c  */
+#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */
+#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */
+#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000780f /*   0x149c  */
+#define STATIC_SDRAM_EXT_MODE          		0x00000440 /*   0x1420  */
+#define STATIC_SDRAM_DDR2_TIMING_LO		0x00063300 /*   0x1428  */
+#define STATIC_SDRAM_DDR2_TIMING_HI		0x00006330 /*   0x147C  */
 
 #endif /* MV_DIMM_M3783354CZ3_CE6 */
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c
index 7a26f90..856bd9e 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -72,17 +72,17 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define DB(x)
 #endif
 
-static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo, 
+static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo,
                                             MV_DRAM_BANK_INFO *pBankInfo);
 static MV_U32  cas2ps(MV_U8 spd_byte);
 /*******************************************************************************
 * mvDramBankGet - Get the DRAM bank paramters.
 *
 * DESCRIPTION:
-*       This function retrieves DRAM bank parameters as described in 
-*       DRAM_BANK_INFO struct to the controller DRAM unit. In case the board 
+*       This function retrieves DRAM bank parameters as described in
+*       DRAM_BANK_INFO struct to the controller DRAM unit. In case the board
 *       has its DRAM on DIMMs it will use its EEPROM to extract SPD data
-*       from it. Otherwise, if the DRAM is soldered on board, the function 
+*       from it. Otherwise, if the DRAM is soldered on board, the function
 *       should insert its bank information into MV_DRAM_BANK_INFO struct.
 *
 * INPUT:
@@ -99,12 +99,12 @@ MV_STATUS mvDramBankInfoGet(MV_U32 bankNum, MV_DRAM_BANK_INFO *pBankInfo)
 {
     MV_DIMM_INFO dimmInfo;
 
-    DB(mvOsPrintf("Dram: mvDramBankInfoGet bank %d\n", bankNum)); 
+    DB(mvOsPrintf("Dram: mvDramBankInfoGet bank %d\n", bankNum));
     /* zero pBankInfo structure */
 
     if((NULL == pBankInfo) || (bankNum >= MV_DRAM_MAX_CS ))
     {
-        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n")); 
+        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n"));
         return MV_BAD_PARAM;
     }
     memset(pBankInfo, 0, sizeof(*pBankInfo));
@@ -140,49 +140,49 @@ MV_STATUS mvDramBankInfoGet(MV_U32 bankNum, MV_DRAM_BANK_INFO *pBankInfo)
 *       None.
 *
 *******************************************************************************/
-static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo, 
+static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo,
                                                 MV_DRAM_BANK_INFO *pBankInfo)
 {
-    pBankInfo->memoryType = pDimmInfo->memoryType;        
+    pBankInfo->memoryType = pDimmInfo->memoryType;
 
     /* DIMM dimensions */
     pBankInfo->numOfRowAddr = pDimmInfo->numOfRowAddr;
     pBankInfo->numOfColAddr = pDimmInfo->numOfColAddr;
     pBankInfo->dataWidth = pDimmInfo->dataWidth;
-    pBankInfo->errorCheckType = pDimmInfo->errorCheckType;             
+    pBankInfo->errorCheckType = pDimmInfo->errorCheckType;
     pBankInfo->sdramWidth = pDimmInfo->sdramWidth;
-    pBankInfo->errorCheckDataWidth = pDimmInfo->errorCheckDataWidth;   
+    pBankInfo->errorCheckDataWidth = pDimmInfo->errorCheckDataWidth;
     pBankInfo->numOfBanksOnEachDevice = pDimmInfo->numOfBanksOnEachDevice;
     pBankInfo->suportedCasLatencies = pDimmInfo->suportedCasLatencies;
     pBankInfo->refreshInterval = pDimmInfo->refreshInterval;
- 
+
     /* DIMM timing parameters */
     pBankInfo->minCycleTimeAtMaxCasLatPs = pDimmInfo->minCycleTimeAtMaxCasLatPs;
-    pBankInfo->minCycleTimeAtMaxCasLatMinus1Ps = 
+    pBankInfo->minCycleTimeAtMaxCasLatMinus1Ps =
                                     pDimmInfo->minCycleTimeAtMaxCasLatMinus1Ps;
-    pBankInfo->minCycleTimeAtMaxCasLatMinus2Ps = 
+    pBankInfo->minCycleTimeAtMaxCasLatMinus2Ps =
                                     pDimmInfo->minCycleTimeAtMaxCasLatMinus2Ps;
 
-    pBankInfo->minRowPrechargeTime     = pDimmInfo->minRowPrechargeTime;     
+    pBankInfo->minRowPrechargeTime     = pDimmInfo->minRowPrechargeTime;
     pBankInfo->minRowActiveToRowActive = pDimmInfo->minRowActiveToRowActive;
-    pBankInfo->minRasToCasDelay        = pDimmInfo->minRasToCasDelay;       
-    pBankInfo->minRasPulseWidth        = pDimmInfo->minRasPulseWidth;       
+    pBankInfo->minRasToCasDelay        = pDimmInfo->minRasToCasDelay;
+    pBankInfo->minRasPulseWidth        = pDimmInfo->minRasPulseWidth;
     pBankInfo->minWriteRecoveryTime    = pDimmInfo->minWriteRecoveryTime;
     pBankInfo->minWriteToReadCmdDelay  = pDimmInfo->minWriteToReadCmdDelay;
     pBankInfo->minReadToPrechCmdDelay  = pDimmInfo->minReadToPrechCmdDelay;
     pBankInfo->minRefreshToActiveCmd   = pDimmInfo->minRefreshToActiveCmd;
-               
+
     /* Parameters calculated from the extracted DIMM information */
     pBankInfo->size = pDimmInfo->size/pDimmInfo->numOfModuleBanks;
-    pBankInfo->deviceDensity = pDimmInfo->deviceDensity;              
+    pBankInfo->deviceDensity = pDimmInfo->deviceDensity;
     pBankInfo->numberOfDevices = pDimmInfo->numberOfDevices /
                                  pDimmInfo->numOfModuleBanks;
- 
+
     /* DIMM attributes (MV_TRUE for yes) */
 
     if ((pDimmInfo->memoryType == MEM_TYPE_SDRAM) ||
         (pDimmInfo->memoryType == MEM_TYPE_DDR1)   )
-    {   
+    {
         if (pDimmInfo->dimmAttributes & BIT1)
             pBankInfo->registeredAddrAndControlInputs = MV_TRUE;
         else
@@ -218,7 +218,7 @@ MV_STATUS dimmSpdCpy(MV_VOID)
 {
     MV_U32 i;
     MV_U32 spdChecksum;
-     
+
     MV_TWSI_SLAVE twsiSlave;
     MV_U8 data[SPD_SIZE];
 
@@ -239,15 +239,15 @@ MV_STATUS dimmSpdCpy(MV_VOID)
         return MV_FAIL;
     }
     DB(puts("DRAM: Reading dimm info succeded.\n"));
-    
+
     /* calculate SPD checksum */
     spdChecksum = 0;
-    
+
     for(i = 0 ; i <= 62 ; i++)
     {
         spdChecksum += data[i];
     }
-    
+
     if ((spdChecksum & 0xff) != data[63])
     {
         DB(mvOsPrintf("DRAM: Warning. Wrong SPD Checksum %2x, expValue=%2x\n",
@@ -275,7 +275,7 @@ MV_STATUS dimmSpdCpy(MV_VOID)
 	}
 	mvOsDelay(5);
     }
-    
+
     DB(puts("DRAM: Reading dimm info succeded.\n"));
     return MV_OK;
 }
@@ -301,13 +301,13 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
     MV_U32 i;
     MV_U32 density = 1;
     MV_U32 spdChecksum;
-     
+
     MV_TWSI_SLAVE twsiSlave;
     MV_U8 data[SPD_SIZE];
 
     if((NULL == pDimmInfo)|| (dimmNum >= MAX_DIMM_NUM))
     {
-        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n")); 
+        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n"));
         return MV_BAD_PARAM;
     }
 
@@ -329,15 +329,15 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
         return MV_FAIL;
     }
     DB(puts("DRAM: Reading dimm info succeded.\n"));
-    
+
     /* calculate SPD checksum */
     spdChecksum = 0;
-    
+
         for(i = 0 ; i <= 62 ; i++)
         {
         spdChecksum += data[i];
     }
-    
+
     if ((spdChecksum & 0xff) != data[63])
     {
         DB(mvOsPrintf("DRAM: Warning. Wrong SPD Checksum %2x, expValue=%2x\n",
@@ -377,20 +377,20 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
             return MV_ERROR;
     }
 
-    
+
     /* Number Of Row Addresses */
     pDimmInfo->numOfRowAddr = data[DIMM_ROW_NUM];
     DB(mvOsPrintf("DRAM numOfRowAddr[3]         %d\n",pDimmInfo->numOfRowAddr));
-        
+
     /* Number Of Column Addresses */
     pDimmInfo->numOfColAddr = data[DIMM_COL_NUM];
     DB(mvOsPrintf("DRAM numOfColAddr[4]         %d\n",pDimmInfo->numOfColAddr));
-        
+
     /* Number Of Module Banks */
     pDimmInfo->numOfModuleBanks = data[DIMM_MODULE_BANK_NUM];
-    DB(mvOsPrintf("DRAM numOfModuleBanks[5]     0x%x\n", 
+    DB(mvOsPrintf("DRAM numOfModuleBanks[5]     0x%x\n",
                                                   pDimmInfo->numOfModuleBanks));
-        
+
     /* Number of module banks encoded differently for DDR2 */
     if (pDimmInfo->memoryType == MEM_TYPE_DDR2)
         pDimmInfo->numOfModuleBanks = (pDimmInfo->numOfModuleBanks & 0x7)+1;
@@ -398,156 +398,156 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
     /* Data Width */
     pDimmInfo->dataWidth = data[DIMM_DATA_WIDTH];
     DB(mvOsPrintf("DRAM dataWidth[6]            0x%x\n", pDimmInfo->dataWidth));
-        
+
     /* Minimum Cycle Time At Max CasLatancy */
     pDimmInfo->minCycleTimeAtMaxCasLatPs = cas2ps(data[DIMM_MIN_CC_AT_MAX_CAS]);
 
     /* Error Check Type */
     pDimmInfo->errorCheckType = data[DIMM_ERR_CHECK_TYPE];
-    DB(mvOsPrintf("DRAM errorCheckType[11]      0x%x\n", 
+    DB(mvOsPrintf("DRAM errorCheckType[11]      0x%x\n",
                                                     pDimmInfo->errorCheckType));
 
     /* Refresh Interval */
     pDimmInfo->refreshInterval = data[DIMM_REFRESH_INTERVAL];
-    DB(mvOsPrintf("DRAM refreshInterval[12]     0x%x\n", 
+    DB(mvOsPrintf("DRAM refreshInterval[12]     0x%x\n",
                                                    pDimmInfo->refreshInterval));
-    
+
     /* Sdram Width */
     pDimmInfo->sdramWidth = data[DIMM_SDRAM_WIDTH];
     DB(mvOsPrintf("DRAM sdramWidth[13]          0x%x\n",pDimmInfo->sdramWidth));
-        
+
     /* Error Check Data Width */
     pDimmInfo->errorCheckDataWidth = data[DIMM_ERR_CHECK_DATA_WIDTH];
-    DB(mvOsPrintf("DRAM errorCheckDataWidth[14] 0x%x\n", 
+    DB(mvOsPrintf("DRAM errorCheckDataWidth[14] 0x%x\n",
                                                pDimmInfo->errorCheckDataWidth));
-    
+
     /* Burst Length Supported */
     /*     SDRAM/DDR1:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  * 
-                    *********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  *
+                    *********************************************************/
     /*     DDR2:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  * 
-                    *********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  *
+                    *********************************************************/
 
     pDimmInfo->burstLengthSupported = data[DIMM_BURST_LEN_SUP];
-    DB(mvOsPrintf("DRAM burstLengthSupported[16] 0x%x\n", 
+    DB(mvOsPrintf("DRAM burstLengthSupported[16] 0x%x\n",
                                               pDimmInfo->burstLengthSupported));
-    
+
     /* Number Of Banks On Each Device */
     pDimmInfo->numOfBanksOnEachDevice = data[DIMM_DEV_BANK_NUM];
-    DB(mvOsPrintf("DRAM numOfBanksOnEachDevice[17] 0x%x\n", 
+    DB(mvOsPrintf("DRAM numOfBanksOnEachDevice[17] 0x%x\n",
                                             pDimmInfo->numOfBanksOnEachDevice));
-    
+
     /* Suported Cas Latencies */
-                   
+
     /*      SDRAM:
-            *******-******-******-******-******-******-******-******* 
-            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-            *******-******-******-******-******-******-******-******* 
-    CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  * 
-            ********************************************************/ 
+            *******-******-******-******-******-******-******-*******
+            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+            *******-******-******-******-******-******-******-*******
+    CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  *
+            ********************************************************/
 
     /*     DDR 1:
-            *******-******-******-******-******-******-******-******* 
-            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-            *******-******-******-******-******-******-******-******* 
-    CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  * 
+            *******-******-******-******-******-******-******-*******
+            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+            *******-******-******-******-******-******-******-*******
+    CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  *
             *********************************************************/
 
     /*     DDR 2:
-            *******-******-******-******-******-******-******-******* 
-            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-            *******-******-******-******-******-******-******-******* 
-    CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  * 
+            *******-******-******-******-******-******-******-*******
+            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+            *******-******-******-******-******-******-******-*******
+    CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  *
             *********************************************************/
-    
+
     pDimmInfo->suportedCasLatencies = data[DIMM_SUP_CAL];
-    DB(mvOsPrintf("DRAM suportedCasLatencies[18]    0x%x\n", 
+    DB(mvOsPrintf("DRAM suportedCasLatencies[18]    0x%x\n",
                                               pDimmInfo->suportedCasLatencies));
 
     /* For DDR2 only, get the DIMM type information */
     if (pDimmInfo->memoryType == MEM_TYPE_DDR2)
-    {   
+    {
         pDimmInfo->dimmTypeInfo = data[DIMM_DDR2_TYPE_INFORMATION];
-        DB(mvOsPrintf("DRAM dimmTypeInfo[20] (DDR2) 0x%x\n", 
+        DB(mvOsPrintf("DRAM dimmTypeInfo[20] (DDR2) 0x%x\n",
                                                       pDimmInfo->dimmTypeInfo));
     }
 
     /* SDRAM Modules Attributes */
     pDimmInfo->dimmAttributes = data[DIMM_BUF_ADDR_CONT_IN];
-    DB(mvOsPrintf("DRAM dimmAttributes[21]          0x%x\n",    
+    DB(mvOsPrintf("DRAM dimmAttributes[21]          0x%x\n",
                                                     pDimmInfo->dimmAttributes));
-    
+
     /* Minimum Cycle Time At Max CasLatancy Minus 1*/
-    pDimmInfo->minCycleTimeAtMaxCasLatMinus1Ps = 
+    pDimmInfo->minCycleTimeAtMaxCasLatMinus1Ps =
                                     cas2ps(data[DIMM_MIN_CC_AT_MAX_CAS_MINUS1]);
 
     /* Minimum Cycle Time At Max CasLatancy Minus 2*/
-    pDimmInfo->minCycleTimeAtMaxCasLatMinus2Ps = 
+    pDimmInfo->minCycleTimeAtMaxCasLatMinus2Ps =
                                     cas2ps(data[DIMM_MIN_CC_AT_MAX_CAS_MINUS2]);
 
     pDimmInfo->minRowPrechargeTime = data[DIMM_MIN_ROW_PRECHARGE_TIME];
-    DB(mvOsPrintf("DRAM minRowPrechargeTime[27]     0x%x\n", 
+    DB(mvOsPrintf("DRAM minRowPrechargeTime[27]     0x%x\n",
                                                pDimmInfo->minRowPrechargeTime));
     pDimmInfo->minRowActiveToRowActive = data[DIMM_MIN_ROW_ACTIVE_TO_ROW_ACTIVE];
-    DB(mvOsPrintf("DRAM minRowActiveToRowActive[28] 0x%x\n", 
+    DB(mvOsPrintf("DRAM minRowActiveToRowActive[28] 0x%x\n",
                                            pDimmInfo->minRowActiveToRowActive));
     pDimmInfo->minRasToCasDelay = data[DIMM_MIN_RAS_TO_CAS_DELAY];
-    DB(mvOsPrintf("DRAM minRasToCasDelay[29]        0x%x\n", 
+    DB(mvOsPrintf("DRAM minRasToCasDelay[29]        0x%x\n",
                                                   pDimmInfo->minRasToCasDelay));
     pDimmInfo->minRasPulseWidth = data[DIMM_MIN_RAS_PULSE_WIDTH];
-    DB(mvOsPrintf("DRAM minRasPulseWidth[30]        0x%x\n", 
+    DB(mvOsPrintf("DRAM minRasPulseWidth[30]        0x%x\n",
                                                   pDimmInfo->minRasPulseWidth));
-        
+
     /* DIMM Bank Density */
     pDimmInfo->dimmBankDensity = data[DIMM_BANK_DENSITY];
-    DB(mvOsPrintf("DRAM dimmBankDensity[31]         0x%x\n", 
+    DB(mvOsPrintf("DRAM dimmBankDensity[31]         0x%x\n",
                                                    pDimmInfo->dimmBankDensity));
 
     /* Only DDR2 includes Write Recovery Time field. Other SDRAM ignore     */
     pDimmInfo->minWriteRecoveryTime = data[DIMM_MIN_WRITE_RECOVERY_TIME];
-    DB(mvOsPrintf("DRAM minWriteRecoveryTime[36]    0x%x\n", 
+    DB(mvOsPrintf("DRAM minWriteRecoveryTime[36]    0x%x\n",
                                               pDimmInfo->minWriteRecoveryTime));
-    
+
     /* Only DDR2 includes Internal Write To Read Command Delay field.       */
     pDimmInfo->minWriteToReadCmdDelay = data[DIMM_MIN_WRITE_TO_READ_CMD_DELAY];
-    DB(mvOsPrintf("DRAM minWriteToReadCmdDelay[37]  0x%x\n", 
+    DB(mvOsPrintf("DRAM minWriteToReadCmdDelay[37]  0x%x\n",
                                             pDimmInfo->minWriteToReadCmdDelay));
-    
+
     /* Only DDR2 includes Internal Read To Precharge Command Delay field.   */
     pDimmInfo->minReadToPrechCmdDelay = data[DIMM_MIN_READ_TO_PRECH_CMD_DELAY];
-    DB(mvOsPrintf("DRAM minReadToPrechCmdDelay[38]  0x%x\n",    
+    DB(mvOsPrintf("DRAM minReadToPrechCmdDelay[38]  0x%x\n",
                                             pDimmInfo->minReadToPrechCmdDelay));
-    
+
     /* Only DDR2 includes Minimum Refresh to Activate/Refresh Command field */
     pDimmInfo->minRefreshToActiveCmd = data[DIMM_MIN_REFRESH_TO_ACTIVATE_CMD];
-    DB(mvOsPrintf("DRAM minRefreshToActiveCmd[42]   0x%x\n", 
+    DB(mvOsPrintf("DRAM minRefreshToActiveCmd[42]   0x%x\n",
                                              pDimmInfo->minRefreshToActiveCmd));
-                 
+
     /* calculating the sdram density. Representing device density from      */
     /* bit 20 to allow representation of 4GB and above.                     */
     /* For example, if density is 512Mbit 0x20000000, will be represent in  */
     /* deviceDensity by 0x20000000 >> 16 --> 0x00000200. Another example    */
     /* is density 8GB 0x200000000 >> 16 --> 0x00002000.                     */
     density = (1 << ((pDimmInfo->numOfRowAddr + pDimmInfo->numOfColAddr) - 20));
-    pDimmInfo->deviceDensity = density * 
-                                pDimmInfo->numOfBanksOnEachDevice * 
+    pDimmInfo->deviceDensity = density *
+                                pDimmInfo->numOfBanksOnEachDevice *
                                 pDimmInfo->sdramWidth;
     DB(mvOsPrintf("DRAM deviceDensity           %d\n",pDimmInfo->deviceDensity));
-    
+
     /* Number of devices includeing Error correction */
-    pDimmInfo->numberOfDevices = (pDimmInfo->dataWidth/pDimmInfo->sdramWidth) * 
+    pDimmInfo->numberOfDevices = (pDimmInfo->dataWidth/pDimmInfo->sdramWidth) *
                                   pDimmInfo->numOfModuleBanks;
-    DB(mvOsPrintf("DRAM numberOfDevices         %d\n",  
+    DB(mvOsPrintf("DRAM numberOfDevices         %d\n",
                                                    pDimmInfo->numberOfDevices));
 
-    pDimmInfo->size = 0; 
+    pDimmInfo->size = 0;
 
     /* Note that pDimmInfo->size is in MB units */
     if (pDimmInfo->memoryType == MEM_TYPE_SDRAM)
@@ -564,9 +564,9 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
             pDimmInfo->size += 64;                  /* Equal to 64MB    */
         else if (pDimmInfo->dimmBankDensity & BIT5)
             pDimmInfo->size += 128;                 /* Equal to 128MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT6) 
+        else if (pDimmInfo->dimmBankDensity & BIT6)
             pDimmInfo->size += 256;                 /* Equal to 256MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT7) 
+        else if (pDimmInfo->dimmBankDensity & BIT7)
             pDimmInfo->size += 512;                 /* Equal to 512MB   */
     }
     else if (pDimmInfo->memoryType == MEM_TYPE_DDR1)
@@ -583,9 +583,9 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
             pDimmInfo->size += 64;                  /* Equal to 64MB    */
         else if (pDimmInfo->dimmBankDensity & BIT5)
             pDimmInfo->size += 128;                 /* Equal to 128MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT6) 
+        else if (pDimmInfo->dimmBankDensity & BIT6)
             pDimmInfo->size += 256;                 /* Equal to 256MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT7) 
+        else if (pDimmInfo->dimmBankDensity & BIT7)
             pDimmInfo->size += 512;                 /* Equal to 512MB   */
     }
     else /* if (dimmInfo.memoryType == MEM_TYPE_DDR2) */
@@ -602,12 +602,12 @@ MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
             pDimmInfo->size += 16384;               /* Equal to 16GB    */
         else if (pDimmInfo->dimmBankDensity & BIT5)
             pDimmInfo->size += 128;                 /* Equal to 128MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT6) 
+        else if (pDimmInfo->dimmBankDensity & BIT6)
             pDimmInfo->size += 256;                 /* Equal to 256MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT7) 
+        else if (pDimmInfo->dimmBankDensity & BIT7)
             pDimmInfo->size += 512;                 /* Equal to 512MB   */
     }
-    
+
     pDimmInfo->size *= pDimmInfo->numOfModuleBanks;
 
     DB(mvOsPrintf("Dram: dimm size    %dMB \n",pDimmInfo->size));
@@ -644,7 +644,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
     busClkPs = 1000000000 / (mvBoardSysClkGet() / 100);  /* in 10 ps units */
 
     spdRawData = dimmInfo.spdRawData;
-    
+
     if(MV_OK != dimmSpdGet(dimmNum, &dimmInfo))
     {
         mvOsOutput("ERROR: Could not read SPD information!\n");
@@ -678,20 +678,20 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
     {
     	temp |= spdRawData[95+i] << 8*i;
     }
-    mvOsOutput("DIMM Serial No.                 %ld (%lx)\n", (long)temp, 
+    mvOsOutput("DIMM Serial No.                 %ld (%lx)\n", (long)temp,
                                     (long)temp);
 
     /* find Manufac-Data of Dimm Module */
-    mvOsOutput("Manufactoring Date:             Year 20%d%d/ ww %d%d\n", 
-                        ((spdRawData[93] & 0xf0) >> 4), (spdRawData[93] & 0xf), 
-                        ((spdRawData[94] & 0xf0) >> 4), (spdRawData[94] & 0xf)); 
+    mvOsOutput("Manufactoring Date:             Year 20%d%d/ ww %d%d\n",
+                        ((spdRawData[93] & 0xf0) >> 4), (spdRawData[93] & 0xf),
+                        ((spdRawData[94] & 0xf0) >> 4), (spdRawData[94] & 0xf));
     /* find modul_revision of Dimm Module */
-    mvOsOutput("Module Revision:                %d.%d\n", 
-               spdRawData[62]/10, spdRawData[62]%10); 
+    mvOsOutput("Module Revision:                %d.%d\n",
+               spdRawData[62]/10, spdRawData[62]%10);
 
     /* find manufac_place of Dimm Module */
     mvOsOutput("manufac_place:                  %d\n", spdRawData[72]);
-    
+
     /* go over the first 35 I2C data bytes */
     for(i = 2 ; i <= 35 ; i++)
        switch(i)
@@ -709,29 +709,29 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
 /*----------------------------------------------------------------------------*/
 
             case 3:  /* Number Of Row Addresses */
-                mvOsOutput("Module Number of row addresses: %d\n", 
+                mvOsOutput("Module Number of row addresses: %d\n",
                                                         dimmInfo.numOfRowAddr);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 4:  /* Number Of Column Addresses */
-                mvOsOutput("Module Number of col addresses: %d\n", 
+                mvOsOutput("Module Number of col addresses: %d\n",
                                                         dimmInfo.numOfColAddr);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 5:  /* Number Of Module Banks */
-                mvOsOutput("Number of Banks on Mod.:        %d\n",  
+                mvOsOutput("Number of Banks on Mod.:        %d\n",
                                                     dimmInfo.numOfModuleBanks);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 6:  /* Data Width */
-                mvOsOutput("Module Data Width:              %d bit\n",  
+                mvOsOutput("Module Data Width:              %d bit\n",
                                                            dimmInfo.dataWidth);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 8:  /* Voltage Interface */
                 switch(spdRawData[i])
                 {
@@ -762,11 +762,11 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 9:  /* Minimum Cycle Time At Max CasLatancy */
                 leftOfPoint = (spdRawData[i] & 0xf0) >> 4;
                 rightOfPoint = (spdRawData[i] & 0x0f) * 10;
-                
+
                 /* DDR2 addition of right of point */
                 if ((spdRawData[i] & 0x0f) == 0xA)
                 {
@@ -788,10 +788,10 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 10: /* Clock To Data Out */
                 div = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 10:100;
-                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                 leftOfPoint     = time_tmp / div;
                 rightOfPoint    = time_tmp % div;
@@ -799,27 +799,27 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 11: /* Error Check Type */
-                mvOsOutput("Error Check Type (0=NONE):      %d\n", 
+                mvOsOutput("Error Check Type (0=NONE):      %d\n",
                                                       dimmInfo.errorCheckType);
                 break;
 /*----------------------------------------------------------------------------*/
 
             case 12: /* Refresh Interval */
-                mvOsOutput("Refresh Rate:                   %x\n", 
+                mvOsOutput("Refresh Rate:                   %x\n",
                                                      dimmInfo.refreshInterval);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 13: /* Sdram Width */
-                mvOsOutput("Sdram Width:                    %d bits\n",     
+                mvOsOutput("Sdram Width:                    %d bits\n",
                                                           dimmInfo.sdramWidth);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 14: /* Error Check Data Width */
-                mvOsOutput("Error Check Data Width:         %d bits\n", 
+                mvOsOutput("Error Check Data Width:         %d bits\n",
                                                  dimmInfo.errorCheckDataWidth);
                 break;
 /*----------------------------------------------------------------------------*/
@@ -828,25 +828,25 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 if ((dimmInfo.memoryType == MEM_TYPE_SDRAM) ||
                     (dimmInfo.memoryType == MEM_TYPE_DDR1))
                 {
-                    mvOsOutput("Minimum Clk Delay back to back: %d\n", 
+                    mvOsOutput("Minimum Clk Delay back to back: %d\n",
                                                                 spdRawData[i]);
                 }
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 16: /* Burst Length Supported */
     /*     SDRAM/DDR1:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  * 
-                    *********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  *
+                    *********************************************************/
     /*     DDR2:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  * 
-                    *********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  *
+                    *********************************************************/
                 mvOsOutput("Burst Length Supported: ");
                 if ((dimmInfo.memoryType == MEM_TYPE_SDRAM) ||
                     (dimmInfo.memoryType == MEM_TYPE_DDR1))
@@ -858,40 +858,40 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 if (dimmInfo.burstLengthSupported & BIT2)
                     mvOsOutput("4, ");
-                if (dimmInfo.burstLengthSupported & BIT3) 
+                if (dimmInfo.burstLengthSupported & BIT3)
                     mvOsOutput("8, ");
-                
+
                 mvOsOutput(" Bit \n");
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 17: /* Number Of Banks On Each Device */
-                mvOsOutput("Number Of Banks On Each Chip:   %d\n",  
+                mvOsOutput("Number Of Banks On Each Chip:   %d\n",
                                               dimmInfo.numOfBanksOnEachDevice);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 18: /* Suported Cas Latencies */
-                   
+
             /*      SDRAM:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-            CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  * 
-                    ********************************************************/ 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+            CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  *
+                    ********************************************************/
 
             /*     DDR 1:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-            CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  * 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+            CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  *
                     *********************************************************/
 
             /*     DDR 2:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-            CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  * 
+                    *******-******-******-******-******-******-******-*******
+                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 *
+                    *******-******-******-******-******-******-******-*******
+            CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  *
                     *********************************************************/
 
                 mvOsOutput("Suported Cas Latencies: (CL) 			");
@@ -927,14 +927,14 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                     if (dimmInfo.suportedCasLatencies & BIT4)
                         mvOsOutput("4, ");
                     if (dimmInfo.suportedCasLatencies & BIT5)
-                        mvOsOutput("5, ");		
+                        mvOsOutput("5, ");
                 }
                 else
-                    mvOsOutput("?.?, ");		
+                    mvOsOutput("?.?, ");
                 mvOsOutput("\n");
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 20:   /* DDR2 DIMM type info */
                 if (dimmInfo.memoryType == MEM_TYPE_DDR2)
                 {
@@ -942,16 +942,16 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput("Registered DIMM (RDIMM)\n");
                     else if (dimmInfo.dimmTypeInfo & (BIT1 | BIT5))
                         mvOsOutput("Unbuffered DIMM (UDIMM)\n");
-                    else 
+                    else
                         mvOsOutput("Unknown DIMM type.\n");
                 }
 
                 break;
 /*----------------------------------------------------------------------------*/
-   
+
             case 21: /* SDRAM Modules Attributes */
                 mvOsOutput("\nModule Attributes (SPD Byte 21): \n");
-                
+
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
                     if (dimmInfo.dimmAttributes & BIT0)
@@ -963,7 +963,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput(" Registered Addr/Control Input: Yes\n");
                     else
                         mvOsOutput(" Registered Addr/Control Input: No\n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT2)
                         mvOsOutput(" On-Card PLL (clock):           Yes \n");
                     else
@@ -973,17 +973,17 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput(" Bufferd DQMB Input:            Yes \n");
                     else
                         mvOsOutput(" Bufferd DQMB Inputs:           No \n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT4)
                         mvOsOutput(" Registered DQMB Inputs:        Yes \n");
                     else
                         mvOsOutput(" Registered DQMB Inputs:        No \n");
- 
+
                     if (dimmInfo.dimmAttributes & BIT5)
                         mvOsOutput(" Differential Clock Input:      Yes \n");
                     else
                         mvOsOutput(" Differential Clock Input:      No \n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT6)
                         mvOsOutput(" redundant Row Addressing:      Yes \n");
                     else
@@ -993,24 +993,24 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 {
                     if (dimmInfo.dimmAttributes & BIT0)
                         mvOsOutput(" Buffered Addr/Control Input:   Yes\n");
-                    else 
+                    else
                         mvOsOutput(" Buffered Addr/Control Input:   No\n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT1)
                         mvOsOutput(" Registered Addr/Control Input: Yes\n");
                     else
                         mvOsOutput(" Registered Addr/Control Input: No\n");
-   
+
                     if (dimmInfo.dimmAttributes & BIT2)
                         mvOsOutput(" On-Card PLL (clock):           Yes \n");
                     else
                         mvOsOutput(" On-Card PLL (clock):           No \n");
-            
+
                     if (dimmInfo.dimmAttributes & BIT3)
                         mvOsOutput(" FET Switch On-Card Enabled:    Yes \n");
                     else
                         mvOsOutput(" FET Switch On-Card Enabled:    No \n");
-                    
+
                     if (dimmInfo.dimmAttributes & BIT4)
                         mvOsOutput(" FET Switch External Enabled:   Yes \n");
                     else
@@ -1023,12 +1023,12 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* if (dimmInfo.memoryType == MEM_TYPE_DDR2) */
                 {
-                    mvOsOutput(" Number of Active Registers on the DIMM: %d\n", 
+                    mvOsOutput(" Number of Active Registers on the DIMM: %d\n",
                                         (dimmInfo.dimmAttributes & 0x3) + 1);
-            
-                    mvOsOutput(" Number of PLLs on the DIMM: %d\n", 
+
+                    mvOsOutput(" Number of PLLs on the DIMM: %d\n",
                                       ((dimmInfo.dimmAttributes) >> 2) & 0x3);
-               
+
                     if (dimmInfo.dimmAttributes & BIT4)
                         mvOsOutput(" FET Switch External Enabled:   Yes \n");
                     else
@@ -1039,7 +1039,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                     else
                         mvOsOutput(" Analysis probe installed:      No \n");
                 }
-                
+
                 break;
 /*----------------------------------------------------------------------------*/
 
@@ -1051,28 +1051,28 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput(" Early Ras Precharge:           Yes \n");
                     else
                         mvOsOutput(" Early Ras Precharge:           No \n");
-                                                        
-                    if ( spdRawData[i] & BIT1 )                 
+
+                    if ( spdRawData[i] & BIT1 )
                         mvOsOutput(" AutoPreCharge:                 Yes \n");
                     else
                         mvOsOutput(" AutoPreCharge:                 No \n");
-                                                            
-                    if ( spdRawData[i] & BIT2 )                 
+
+                    if ( spdRawData[i] & BIT2 )
                         mvOsOutput(" Precharge All:                 Yes \n");
                     else
                         mvOsOutput(" Precharge All:                 No \n");
-                                                        
-                    if ( spdRawData[i] & BIT3 )                 
+
+                    if ( spdRawData[i] & BIT3 )
                         mvOsOutput(" Write 1/ReadBurst:             Yes \n");
                     else
                         mvOsOutput(" Write 1/ReadBurst:             No \n");
-                                                        
-                    if ( spdRawData[i] & BIT4 )                 
+
+                    if ( spdRawData[i] & BIT4 )
                         mvOsOutput(" lower VCC tolerance:           5%%\n");
                     else
                         mvOsOutput(" lower VCC tolerance:           10%%\n");
-                                                        
-                    if ( spdRawData[i] & BIT5 )                 
+
+                    if ( spdRawData[i] & BIT5 )
                         mvOsOutput(" upper VCC tolerance:           5%%\n");
                     else
                         mvOsOutput(" upper VCC tolerance:           10%%\n");
@@ -1086,7 +1086,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
 
                     if ( !(spdRawData[i] & BIT4) )
                         mvOsOutput(" lower VCC tolerance:           0.2V\n");
-   
+
                     if ( !(spdRawData[i] & BIT5) )
                         mvOsOutput(" upper VCC tolerance:           0.2V\n");
 
@@ -1109,12 +1109,12 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 23:
             /* Minimum Cycle Time At Maximum Cas Latancy Minus 1 (2nd highest CL) */
                 leftOfPoint = (spdRawData[i] & 0xf0) >> 4;
                 rightOfPoint = (spdRawData[i] & 0x0f) * 10;
-                
+
                 /* DDR2 addition of right of point */
                 if ((spdRawData[i] & 0x0f) == 0xA)
                 {
@@ -1138,10 +1138,10 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                            leftOfPoint, rightOfPoint );
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 24: /* Clock To Data Out 2nd highest Cas Latency Value*/
                 div = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 10:100;
-                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                     ((spdRawData[i] & 0x0f));
                 leftOfPoint     = time_tmp / div;
                 rightOfPoint    = time_tmp % div;
@@ -1149,19 +1149,19 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
-            case 25: 
+
+            case 25:
             /* Minimum Cycle Time At Maximum Cas Latancy Minus 2 (3rd highest CL) */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
                     leftOfPoint = (spdRawData[i] & 0xfc) >> 2;
                     rightOfPoint = (spdRawData[i] & 0x3) * 25;
                 }
-                else    /* DDR1 or DDR2 */ 
+                else    /* DDR1 or DDR2 */
                 {
                     leftOfPoint = (spdRawData[i] & 0xf0) >> 4;
                     rightOfPoint = (spdRawData[i] & 0x0f) * 10;
-                    
+
                     /* DDR2 addition of right of point */
                     if ((spdRawData[i] & 0x0f) == 0xA)
                     {
@@ -1180,21 +1180,21 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         rightOfPoint = 75;
                     }
                 }
-                mvOsOutput("Minimum Cycle Time At 3rd highest CasLatancy" 
+                mvOsOutput("Minimum Cycle Time At 3rd highest CasLatancy"
                            "(0 = Not supported): %d.%d [ns]\n",
                            leftOfPoint, rightOfPoint );
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 26: /* Clock To Data Out 3rd highest Cas Latency Value*/
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
                     leftOfPoint = (spdRawData[i] & 0xfc) >> 2;
                     rightOfPoint = (spdRawData[i] & 0x3) * 25;
                 }
-                else    /* DDR1 or DDR2 */ 
+                else    /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint     = 0;
                     rightOfPoint    = time_tmp;
@@ -1203,62 +1203,62 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                                                   leftOfPoint, rightOfPoint );
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 27: /* Minimum Row Precharge Time */
                 shift = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 0:2;
-                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0xff : 0xfc;
-                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0x00 : 0x03;
                 leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> shift);
                 rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;
                 temp = ((leftOfPoint*100) + rightOfPoint);/* in 10ps Intervals*/
-                trp_clocks = (temp + (busClkPs-1)) /  busClkPs;    
-                mvOsOutput("Minimum Row Precharge Time [ns]: 		%d.%d = " 
-                           "in Clk cycles %d\n", 
+                trp_clocks = (temp + (busClkPs-1)) /  busClkPs;
+                mvOsOutput("Minimum Row Precharge Time [ns]: 		%d.%d = "
+                           "in Clk cycles %d\n",
                            leftOfPoint, rightOfPoint, trp_clocks);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 28: /* Minimum Row Active to Row Active Time */
                 shift = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 0:2;
-                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0xff : 0xfc;
-                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0x00 : 0x03;
                 leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> shift);
                 rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;
                 temp = ((leftOfPoint*100) + rightOfPoint);/* in 100ns Interval*/
                 trrd_clocks = (temp + (busClkPs-1)) / busClkPs;
-                mvOsOutput("Minimum Row Active -To- Row Active Delay [ns]: " 
+                mvOsOutput("Minimum Row Active -To- Row Active Delay [ns]: "
                            "%d.%d = in Clk cycles %d\n",
                             leftOfPoint, rightOfPoint, trp_clocks);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 29: /* Minimum Ras-To-Cas Delay */
                 shift = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 0:2;
-                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0xff : 0xfc;
-                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
+                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ?
                                                                     0x00 : 0x03;
                 leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> shift);
-                rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;  
+                rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;
                 temp = ((leftOfPoint*100) + rightOfPoint);/* in 100ns Interval*/
                 trcd_clocks = (temp + (busClkPs-1) )/ busClkPs;
                 mvOsOutput("Minimum Ras-To-Cas Delay [ns]: 			%d.%d = "
-                           "in Clk cycles %d\n", 
+                           "in Clk cycles %d\n",
                            leftOfPoint, rightOfPoint, trp_clocks);
                 break;
 /*----------------------------------------------------------------------------*/
-   
+
             case 30: /* Minimum Ras Pulse Width */
                 tras_clocks = (cas2ps(spdRawData[i])+(busClkPs-1)) / busClkPs;
                 mvOsOutput("Minimum Ras Pulse Width [ns]: 			%d = "
                            "in Clk cycles %d\n", spdRawData[i], tras_clocks);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 31: /* Module Bank Density */
                 mvOsOutput("Module Bank Density (more than 1= Multisize-Module):");
 
@@ -1276,9 +1276,9 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput("64MB, ");
                     if (dimmInfo.dimmBankDensity & BIT5)
                         mvOsOutput("128MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT6) 
+                    if (dimmInfo.dimmBankDensity & BIT6)
                         mvOsOutput("256MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT7) 
+                    if (dimmInfo.dimmBankDensity & BIT7)
                         mvOsOutput("512MB, ");
                 }
                 else if (dimmInfo.memoryType == MEM_TYPE_DDR1)
@@ -1295,9 +1295,9 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput("64MB, ");
                     if (dimmInfo.dimmBankDensity & BIT5)
                         mvOsOutput("128MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT6) 
+                    if (dimmInfo.dimmBankDensity & BIT6)
                         mvOsOutput("256MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT7) 
+                    if (dimmInfo.dimmBankDensity & BIT7)
                         mvOsOutput("512MB, ");
                 }
                 else /* if (dimmInfo.memoryType == MEM_TYPE_DDR2) */
@@ -1314,15 +1314,15 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                         mvOsOutput("16GB, ");
                     if (dimmInfo.dimmBankDensity & BIT5)
                     mvOsOutput("128MB, ");
-                        if (dimmInfo.dimmBankDensity & BIT6) 
+                        if (dimmInfo.dimmBankDensity & BIT6)
                     mvOsOutput("256MB, ");
-                        if (dimmInfo.dimmBankDensity & BIT7) 
+                        if (dimmInfo.dimmBankDensity & BIT7)
                     mvOsOutput("512MB, ");
                 }
                 mvOsOutput("\n");
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 32: /* Address And Command Setup Time (measured in ns/1000) */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
@@ -1335,16 +1335,16 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100; 
+                    rightOfPoint = time_tmp % 100;
                 }
                 mvOsOutput("Address And Command Setup Time [ns]: 		%d.%d\n",
                                                      leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 33: /* Address And Command Hold Time */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
@@ -1357,16 +1357,16 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100;                 
+                    rightOfPoint = time_tmp % 100;
                 }
                 mvOsOutput("Address And Command Hold Time [ns]: 		%d.%d\n",
                                                    leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 34: /* Data Input Setup Time */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
@@ -1379,16 +1379,16 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100;                 
+                    rightOfPoint = time_tmp % 100;
                 }
-                mvOsOutput("Data Input Setup Time [ns]: 			%d.%d\n", 
+                mvOsOutput("Data Input Setup Time [ns]: 			%d.%d\n",
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 35: /* Data Input Hold Time */
                 if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
                 {
@@ -1401,25 +1401,25 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
                 }
                 else /* DDR1 or DDR2 */
                 {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
+                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) +
                                                       ((spdRawData[i] & 0x0f));
                     leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100;                 
+                    rightOfPoint = time_tmp % 100;
                 }
-                mvOsOutput("Data Input Hold Time [ns]: 			%d.%d\n\n", 
+                mvOsOutput("Data Input Hold Time [ns]: 			%d.%d\n\n",
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
-    
+
             case 36: /* Relevant for DDR2 only: Write Recovery Time */
                 leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> 2);
-                rightOfPoint = (spdRawData[i] & maskRightOfPoint) * 25;  
-                mvOsOutput("Write Recovery Time [ns]: 			%d.%d\n", 
+                rightOfPoint = (spdRawData[i] & maskRightOfPoint) * 25;
+                mvOsOutput("Write Recovery Time [ns]: 			%d.%d\n",
                                                     leftOfPoint, rightOfPoint);
                 break;
 /*----------------------------------------------------------------------------*/
         }
-    
+
 }
 
 
@@ -1447,12 +1447,12 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
 static MV_U32  cas2ps(MV_U8 spd_byte)
 {
     MV_U32 ns, ns10;
-    
+
     /* isolate upper nibble */
     ns = (spd_byte >> 4) & 0x0F;
     /* isolate lower nibble */
     ns10 = (spd_byte & 0x0F);
-    
+
     if( ns10 < 10 ) {
         ns10 *= 10;
     }
@@ -1464,11 +1464,11 @@ static MV_U32  cas2ps(MV_U8 spd_byte)
         ns10 = 66;
     else if( ns10 == 13 )
         ns10 = 75;
-    else 
+    else
     {
         mvOsOutput("cas2ps Err. unsupported cycle time.\n");
     }
-    
+
     return (ns*1000 + ns10*10);
 }
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.h
index f955466..9a4d7f0 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -106,10 +106,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define DIMM_MEM_TYPE_SDRAM					0x4
 #define DIMM_MEM_TYPE_DDR1 					0x7
 #define DIMM_MEM_TYPE_DDR2 					0x8
-        
+
 #define DIMM_MODULE_MANU_OFFS 		64
 #define DIMM_MODULE_MANU_SIZE 		8
-#define DIMM_MODULE_VEN_OFFS 		73 
+#define DIMM_MODULE_VEN_OFFS 		73
 #define DIMM_MODULE_VEN_SIZE 		25
 #define DIMM_MODULE_ID_OFFS 		99
 #define DIMM_MODULE_ID_SIZE 		18
@@ -117,30 +117,30 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* enumeration for voltage levels. */
 typedef enum _mvDimmVoltageIf
 {
-    TTL_5V_TOLERANT, 
-    LVTTL, 
-    HSTL_1_5V, 
-    SSTL_3_3V, 
-    SSTL_2_5V, 
-    VOLTAGE_UNKNOWN, 
+    TTL_5V_TOLERANT,
+    LVTTL,
+    HSTL_1_5V,
+    SSTL_3_3V,
+    SSTL_2_5V,
+    VOLTAGE_UNKNOWN,
 } MV_DIMM_VOLTAGE_IF;
 
 
 /* enumaration for SDRAM CAS Latencies. */
 typedef enum _mvDimmSdramCas
 {
-    SD_CL_1 =1,  
-    SD_CL_2,  
-    SD_CL_3, 
-    SD_CL_4, 
-    SD_CL_5, 
-    SD_CL_6, 
-    SD_CL_7, 
+    SD_CL_1 =1,
+    SD_CL_2,
+    SD_CL_3,
+    SD_CL_4,
+    SD_CL_5,
+    SD_CL_6,
+    SD_CL_7,
     SD_FAULT
 }MV_DIMM_SDRAM_CAS;
 
 
-/* DIMM information structure */                                                    
+/* DIMM information structure */
 typedef struct _mvDimmInfo
 {
     MV_MEMORY_TYPE  memoryType; 	/* DDR or SDRAM */
@@ -164,7 +164,7 @@ typedef struct _mvDimmInfo
     MV_U32  dimmAttributes;
 
     /* DIMM timing parameters */
-    MV_U32  minCycleTimeAtMaxCasLatPs;	
+    MV_U32  minCycleTimeAtMaxCasLatPs;
     MV_U32  minCycleTimeAtMaxCasLatMinus1Ps;
     MV_U32  minCycleTimeAtMaxCasLatMinus2Ps;
 	MV_U32  minRowPrechargeTime;
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c
index d24e788..617e35f 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer. 
+        this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -78,7 +78,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *       internal data needed for its operations.
 *
 *       Supported Features:
-*       - OS independent. All required OS services are implemented via external 
+*       - OS independent. All required OS services are implemented via external
 *       OS dependent components (like osLayer or ethOsg)
 *       - The user is free from Rx/Tx queue managing.
 *       - Simple Gigabit Ethernet port operation API.
@@ -131,7 +131,7 @@ static MV_BOOL ethSetSpecialMcastAddr(int ethPortNum, MV_U8 lastByte, int queue)
 static MV_BOOL ethSetOtherMcastAddr(int ethPortNum, MV_U8 crc8, int queue);
 
 static void    ethFreeDescrMemory(ETH_PORT_CTRL* pEthPortCtrl, MV_BUF_INFO* pDescBuf);
-static MV_U8*  ethAllocDescrMemory(ETH_PORT_CTRL* pEthPortCtrl, int size, 
+static MV_U8*  ethAllocDescrMemory(ETH_PORT_CTRL* pEthPortCtrl, int size,
                                    MV_ULONG* pPhysAddr, MV_U32 *memHandle);
 
 static MV_U32 mvEthMruGet(MV_U32 maxRxPktSize);
@@ -150,7 +150,7 @@ static void mvEthPortSgmiiConfig(int port);
 * DESCRIPTION:
 *       This function initialize the Giga Ethernet unit.
 *       1) Configure Address decode windows of the unit
-*       2) Set registers to HW default values. 
+*       2) Set registers to HW default values.
 *       3) Clear and Disable interrupts
 *
 * INPUT:  NONE
@@ -177,7 +177,7 @@ void    mvEthHalInit(void)
 	if (MV_FALSE == mvSocUnitIsMappedToThisCpu(GIGA0+port))
 	{
 		    continue;
-	}		
+	}
 #endif
 
 	/* Skip power down ports */
@@ -202,7 +202,7 @@ void    mvEthHalInit(void)
 }
 
 /*******************************************************************************
-* mvEthMemAttrGet - Define properties (SRAM/DRAM, SW_COHER / HW_COHER / UNCACHED) 
+* mvEthMemAttrGet - Define properties (SRAM/DRAM, SW_COHER / HW_COHER / UNCACHED)
 *                       of of memory location for RX and TX descriptors.
 *
 * DESCRIPTION:
@@ -211,7 +211,7 @@ void    mvEthHalInit(void)
 *       - If ETH_DESCR_IN_SDRAM defined, allocate from SDRAM memory.
 *
 * INPUT:
-*   MV_BOOL* pIsSram - place of descriptors: 
+*   MV_BOOL* pIsSram - place of descriptors:
 *                      MV_TRUE  - in SRAM
 *                      MV_FALSE - in DRAM
 *   MV_BOOL* pIsSwCoher - cache coherency of descriptors:
@@ -226,9 +226,9 @@ void   mvEthMemAttrGet(MV_BOOL* pIsSram, MV_BOOL* pIsSwCoher)
     MV_BOOL isSram, isSwCoher;
 
     isSram = MV_FALSE;
-#if (ETHER_DRAM_COHER == MV_CACHE_COHER_SW) 
+#if (ETHER_DRAM_COHER == MV_CACHE_COHER_SW)
     isSwCoher = MV_TRUE;
-#else 
+#else
     isSwCoher = MV_FALSE;
 #endif
 
@@ -236,9 +236,9 @@ void   mvEthMemAttrGet(MV_BOOL* pIsSram, MV_BOOL* pIsSwCoher)
     if( mvCtrlSramSizeGet() > 0)
     {
         isSram = MV_TRUE;
-        #if (INTEG_SRAM_COHER == MV_CACHE_COHER_SW) 
+        #if (INTEG_SRAM_COHER == MV_CACHE_COHER_SW)
             isSwCoher = MV_TRUE;
-        #else 
+        #else
             isSwCoher = MV_FALSE;
         #endif
     }
@@ -264,9 +264,9 @@ void   mvEthMemAttrGet(MV_BOOL* pIsSram, MV_BOOL* pIsSwCoher)
 *       This function initialize the ethernet port.
 *       1) Allocate and initialize internal port Control structure.
 *       2) Create RX and TX descriptor rings for default RX and TX queues
-*       3) Disable RX and TX operations, clear cause registers and 
+*       3) Disable RX and TX operations, clear cause registers and
 *          mask all interrupts.
-*       4) Set all registers to default values and clean all MAC tables. 
+*       4) Set all registers to default values and clean all MAC tables.
 *
 * INPUT:
 *       int             portNo          - Ethernet port number
@@ -284,7 +284,7 @@ void*   mvEthPortInit(int portNo, MV_ETH_PORT_INIT *pEthPortInit)
     ETH_PORT_CTRL*  pPortCtrl;
 
     /* Check validity of parameters */
-    if( (portNo >= (int)mvCtrlEthMaxPortGet()) || 
+    if( (portNo >= (int)mvCtrlEthMaxPortGet()) ||
         (pEthPortInit->rxDefQ   >= MV_ETH_RX_Q_NUM)  ||
         (pEthPortInit->maxRxPktSize < 1518) )
     {
@@ -293,13 +293,13 @@ void*   mvEthPortInit(int portNo, MV_ETH_PORT_INIT *pEthPortInit)
     }
     if( (pEthPortInit->rxDescrNum[pEthPortInit->rxDefQ]) == 0)
     {
-        mvOsPrintf("EthPort #%d: rxDefQ (%d) must be created\n", 
+        mvOsPrintf("EthPort #%d: rxDefQ (%d) must be created\n",
                     portNo, pEthPortInit->rxDefQ);
         return NULL;
     }
 
     pPortCtrl = (ETH_PORT_CTRL*)mvOsMalloc( sizeof(ETH_PORT_CTRL) );
-    if(pPortCtrl == NULL)   
+    if(pPortCtrl == NULL)
     {
        mvOsPrintf("EthDrv: Can't allocate %dB for port #%d control structure!\n",
                    (int)sizeof(ETH_PORT_CTRL), portNo);
@@ -343,16 +343,16 @@ void*   mvEthPortInit(int portNo, MV_ETH_PORT_INIT *pEthPortInit)
         /* Allocate memory for RX descriptors */
         descSize = ((pPortCtrl->rxQueueConfig[queue].descrNum * ETH_RX_DESC_ALIGNED_SIZE) +
                                                         CPU_D_CACHE_LINE_SIZE);
- 
-        pPortCtrl->rxQueue[queue].descBuf.bufVirtPtr = 
-                        ethAllocDescrMemory(pPortCtrl, descSize, 
+
+        pPortCtrl->rxQueue[queue].descBuf.bufVirtPtr =
+                        ethAllocDescrMemory(pPortCtrl, descSize,
 					    &pPortCtrl->rxQueue[queue].descBuf.bufPhysAddr,
 					    &pPortCtrl->rxQueue[queue].descBuf.memHandle);
         pPortCtrl->rxQueue[queue].descBuf.bufSize = descSize;
         if(pPortCtrl->rxQueue[queue].descBuf.bufVirtPtr == NULL)
         {
-            mvOsPrintf("EthPort #%d, rxQ=%d: Can't allocate %d bytes in %s for %d RX descr\n", 
-                        pPortCtrl->portNo, queue, descSize, 
+            mvOsPrintf("EthPort #%d, rxQ=%d: Can't allocate %d bytes in %s for %d RX descr\n",
+                        pPortCtrl->portNo, queue, descSize,
                         ethDescInSram ? "SRAM" : "DRAM",
                         pPortCtrl->rxQueueConfig[queue].descrNum);
             return NULL;
@@ -369,15 +369,15 @@ void*   mvEthPortInit(int portNo, MV_ETH_PORT_INIT *pEthPortInit)
         /* Allocate memory for TX descriptors */
         descSize = ((pPortCtrl->txQueueConfig[queue].descrNum * ETH_TX_DESC_ALIGNED_SIZE) +
                                                         CPU_D_CACHE_LINE_SIZE);
- 
-        pPortCtrl->txQueue[queue].descBuf.bufVirtPtr = 
+
+        pPortCtrl->txQueue[queue].descBuf.bufVirtPtr =
 		ethAllocDescrMemory(pPortCtrl, descSize,
 				    &pPortCtrl->txQueue[queue].descBuf.bufPhysAddr,
 				    &pPortCtrl->txQueue[queue].descBuf.memHandle);
         pPortCtrl->txQueue[queue].descBuf.bufSize = descSize;
         if(pPortCtrl->txQueue[queue].descBuf.bufVirtPtr == NULL)
         {
-            mvOsPrintf("EthPort #%d, txQ=%d: Can't allocate %d bytes in %s for %d TX descr\n", 
+            mvOsPrintf("EthPort #%d, txQ=%d: Can't allocate %d bytes in %s for %d TX descr\n",
                         pPortCtrl->portNo, queue, descSize, ethDescInSram ? "SRAM" : "DRAM",
                         pPortCtrl->txQueueConfig[queue].descrNum);
             return NULL;
@@ -450,12 +450,12 @@ void    mvEthPortFinish(void* pPortHndl)
 * INPUT:
 *       void*   pEthPortHndl  - Ethernet port handler
 *
-* RETURN:   MV_STATUS  
+* RETURN:   MV_STATUS
 *               MV_OK - Success, Others - Failure
 * NOTE:
 *   This function update all the port configuration except those set
 *   Initialy by the OsGlue by MV_ETH_PORT_INIT.
-*   This function can be called after portDown to return the port setting 
+*   This function can be called after portDown to return the port setting
 *   to defaults.
 *******************************************************************************/
 MV_STATUS   mvEthDefaultsSet(void* pPortHndl)
@@ -523,15 +523,15 @@ MV_STATUS   mvEthDefaultsSet(void* pPortHndl)
 
 #else /* MV_CPU_LE */
     /* little endian */
-    portSdmaCfgReg |= (ETH_RX_NO_DATA_SWAP_MASK | 
-                       ETH_TX_NO_DATA_SWAP_MASK | 
+    portSdmaCfgReg |= (ETH_RX_NO_DATA_SWAP_MASK |
+                       ETH_TX_NO_DATA_SWAP_MASK |
                        ETH_NO_DESC_SWAP_MASK);
 #endif /* MV_CPU_BE / MV_CPU_LE */
 
     pPortCtrl->portRxQueueCmdReg = 0;
     pPortCtrl->portTxQueueCmdReg = 0;
 
-#if (MV_ETH_VERSION >= 4) 
+#if (MV_ETH_VERSION >= 4)
     if(pPortCtrl->portConfig.ejpMode == MV_TRUE)
     {
         MV_REG_WRITE(ETH_TXQ_CMD_1_REG(ethPortNo), ETH_TX_EJP_ENABLE_MASK);
@@ -554,15 +554,15 @@ MV_STATUS   mvEthDefaultsSet(void* pPortHndl)
 
     /* Update value of PortConfig register accordingly with all RxQueue types */
     pPortCtrl->portConfig.rxArpQ = pPortCtrl->portConfig.rxDefQ;
-    pPortCtrl->portConfig.rxBpduQ = pPortCtrl->portConfig.rxDefQ; 
-    pPortCtrl->portConfig.rxTcpQ = pPortCtrl->portConfig.rxDefQ; 
-    pPortCtrl->portConfig.rxUdpQ = pPortCtrl->portConfig.rxDefQ; 
+    pPortCtrl->portConfig.rxBpduQ = pPortCtrl->portConfig.rxDefQ;
+    pPortCtrl->portConfig.rxTcpQ = pPortCtrl->portConfig.rxDefQ;
+    pPortCtrl->portConfig.rxUdpQ = pPortCtrl->portConfig.rxDefQ;
 
     portCfgReg &= ~ETH_DEF_RX_QUEUE_ALL_MASK;
     portCfgReg |= ETH_DEF_RX_QUEUE_MASK(pPortCtrl->portConfig.rxDefQ);
-    
+
     portCfgReg &= ~ETH_DEF_RX_ARP_QUEUE_ALL_MASK;
-    portCfgReg |= ETH_DEF_RX_ARP_QUEUE_MASK(pPortCtrl->portConfig.rxArpQ); 
+    portCfgReg |= ETH_DEF_RX_ARP_QUEUE_MASK(pPortCtrl->portConfig.rxArpQ);
 
     portCfgReg &= ~ETH_DEF_RX_BPDU_QUEUE_ALL_MASK;
     portCfgReg |= ETH_DEF_RX_BPDU_QUEUE_MASK(pPortCtrl->portConfig.rxBpduQ);
@@ -586,7 +586,7 @@ MV_STATUS   mvEthDefaultsSet(void* pPortHndl)
 
             MV_REG_WRITE(ETH_TXQ_TOKEN_COUNT_REG(ethPortNo, queue),
                          0x3fffffff);
-            MV_REG_WRITE(ETH_TXQ_TOKEN_CFG_REG(ethPortNo, queue), 
+            MV_REG_WRITE(ETH_TXQ_TOKEN_CFG_REG(ethPortNo, queue),
                          0x03ffffff);
         }
         else
@@ -614,7 +614,7 @@ MV_STATUS   mvEthDefaultsSet(void* pPortHndl)
 
     /* Assign port SDMA configuration */
     MV_REG_WRITE(ETH_SDMA_CONFIG_REG(ethPortNo), portSdmaCfgReg);
-    
+
     /* Turn off the port/queue bandwidth limitation */
     MV_REG_WRITE(ETH_MAX_TRANSMIT_UNIT_REG(ethPortNo), 0x0);
 
@@ -645,15 +645,15 @@ MV_STATUS   mvEthPortUp(void* pEthPortHndl)
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pEthPortHndl;
 
     ethPortNo = pPortCtrl->portNo;
-    
-    if( (pPortCtrl->portState != MV_ACTIVE) && 
+
+    if( (pPortCtrl->portState != MV_ACTIVE) &&
         (pPortCtrl->portState != MV_PAUSED) )
     {
-        mvOsPrintf("ethDrv port%d: Unexpected port state %d\n", 
+        mvOsPrintf("ethDrv port%d: Unexpected port state %d\n",
                         ethPortNo, pPortCtrl->portState);
         return MV_BAD_STATE;
     }
-    
+
     ethPortNo = pPortCtrl->portNo;
 
     /* Enable port RX. */
@@ -700,8 +700,8 @@ MV_STATUS   mvEthPortDown(void* pEthPortHndl)
     if(regData != 0)
     {
         /* Issue stop command for active channels only */
-        MV_REG_WRITE(ETH_TX_QUEUE_COMMAND_REG(ethPortNum), 
-                            (regData << ETH_TXQ_DISABLE_OFFSET) ); 
+        MV_REG_WRITE(ETH_TX_QUEUE_COMMAND_REG(ethPortNum),
+                            (regData << ETH_TXQ_DISABLE_OFFSET) );
     }
 
     /* Force link down */
@@ -716,13 +716,13 @@ MV_STATUS   mvEthPortDown(void* pEthPortHndl)
     {
         if(mDelay >= RX_DISABLE_TIMEOUT_MSEC)
         {
-            mvOsPrintf("ethPort_%d: TIMEOUT for RX stopped !!! rxQueueCmd - 0x08%x\n", 
+            mvOsPrintf("ethPort_%d: TIMEOUT for RX stopped !!! rxQueueCmd - 0x08%x\n",
                         ethPortNum, regData);
             break;
         }
         mvOsDelay(1);
         mDelay++;
-        
+
         /* Check port RX Command register that all Rx queues are stopped */
         regData = MV_REG_READ(ETH_RX_QUEUE_COMMAND_REG(ethPortNum));
     }
@@ -734,7 +734,7 @@ MV_STATUS   mvEthPortDown(void* pEthPortHndl)
     {
         if(mDelay >= TX_DISABLE_TIMEOUT_MSEC)
         {
-            mvOsPrintf("ethPort_%d: TIMEOUT for TX stoped !!! txQueueCmd - 0x08%x\n", 
+            mvOsPrintf("ethPort_%d: TIMEOUT for TX stoped !!! txQueueCmd - 0x08%x\n",
                         ethPortNum, regData);
             break;
         }
@@ -745,7 +745,7 @@ MV_STATUS   mvEthPortDown(void* pEthPortHndl)
         regData = MV_REG_READ(ETH_TX_QUEUE_COMMAND_REG(ethPortNum));
     }
     while(regData & 0xFF);
-    
+
     /* Double check to Verify that TX FIFO is Empty */
     mDelay = 0;
     while(MV_TRUE)
@@ -754,7 +754,7 @@ MV_STATUS   mvEthPortDown(void* pEthPortHndl)
         {
             if(mDelay >= TX_FIFO_EMPTY_TIMEOUT_MSEC)
             {
-                mvOsPrintf("\n ethPort_%d: TIMEOUT for TX FIFO empty !!! portStatus - 0x08%x\n", 
+                mvOsPrintf("\n ethPort_%d: TIMEOUT for TX FIFO empty !!! portStatus - 0x08%x\n",
                             ethPortNum, regData);
                 break;
             }
@@ -763,7 +763,7 @@ MV_STATUS   mvEthPortDown(void* pEthPortHndl)
 
             regData = MV_REG_READ(ETH_PORT_STATUS_REG(ethPortNum));
         }
-        while( ((regData & ETH_TX_FIFO_EMPTY_MASK) == 0) || 
+        while( ((regData & ETH_TX_FIFO_EMPTY_MASK) == 0) ||
                ((regData & ETH_TX_IN_PROGRESS_MASK) != 0) );
 
         if(mDelay >= TX_FIFO_EMPTY_TIMEOUT_MSEC)
@@ -771,14 +771,14 @@ MV_STATUS   mvEthPortDown(void* pEthPortHndl)
 
         /* Double check */
         regData = MV_REG_READ(ETH_PORT_STATUS_REG(ethPortNum));
-        if( ((regData & ETH_TX_FIFO_EMPTY_MASK) != 0) && 
+        if( ((regData & ETH_TX_FIFO_EMPTY_MASK) != 0) &&
             ((regData & ETH_TX_IN_PROGRESS_MASK) == 0) )
         {
             break;
         }
         else
             mvOsPrintf("ethPort_%d: TX FIFO Empty double check failed. %d msec, portStatus=0x%x\n",
-                                ethPortNum, mDelay, regData);     
+                                ethPortNum, mDelay, regData);
     }
 
     /* Do NOT force link down */
@@ -793,7 +793,7 @@ MV_STATUS   mvEthPortDown(void* pEthPortHndl)
 
     pPortCtrl->portState = MV_PAUSED;
 
-    return MV_OK;   
+    return MV_OK;
 }
 
 
@@ -836,7 +836,7 @@ MV_STATUS   mvEthPortEnable(void* pEthPortHndl)
     /* If Link is UP, Start RX and TX traffic */
     if( MV_REG_READ( ETH_PORT_STATUS_REG(ethPortNo) ) & ETH_LINK_UP_MASK)
         return( mvEthPortUp(pEthPortHndl) );
-    
+
     return MV_NOT_READY;
 }
 
@@ -861,8 +861,8 @@ MV_STATUS   mvEthPortDisable(void* pEthPortHndl)
     unsigned int    regData;
     volatile int    mvDelay;
 
-    if(pPortCtrl->portState == MV_ACTIVE)           
-    {    
+    if(pPortCtrl->portState == MV_ACTIVE)
+    {
         /* Stop RX and TX activities */
         mvEthPortDown(pEthPortHndl);
     }
@@ -896,7 +896,7 @@ MV_STATUS   mvEthPortDisable(void* pEthPortHndl)
 *
 * RETURN:
 *       MV_EMPTY    - There is no more buffers in this queue.
-*       MV_OK       - Buffer detached from the queue and pPktInfo structure 
+*       MV_OK       - Buffer detached from the queue and pPktInfo structure
 *                   filled with relevant information.
 *
 *******************************************************************************/
@@ -907,7 +907,7 @@ MV_PKT_INFO*    mvEthPortForceTxDone(void* pEthPortHndl, int txQueue)
     MV_PKT_INFO*    pPktInfo;
     ETH_TX_DESC*    pTxDesc;
     int             port = pPortCtrl->portNo;
-       
+
     pQueueCtrl = &pPortCtrl->txQueue[txQueue];
 
     while( (pQueueCtrl->pUsedDescr != pQueueCtrl->pCurrentDescr) ||
@@ -929,15 +929,15 @@ MV_PKT_INFO*    mvEthPortForceTxDone(void* pEthPortHndl, int txQueue)
         pQueueCtrl->pUsedDescr = TX_NEXT_DESC_PTR(pTxDesc, pQueueCtrl);
 
         if (pPktInfo)
-		if (pPktInfo->status  & ETH_TX_LAST_DESC_MASK) 
+		if (pPktInfo->status  & ETH_TX_LAST_DESC_MASK)
             		return pPktInfo;
-    }   
-    MV_REG_WRITE( ETH_TX_CUR_DESC_PTR_REG(port, txQueue), 
+    }
+    MV_REG_WRITE( ETH_TX_CUR_DESC_PTR_REG(port, txQueue),
                     (MV_U32)ethDescVirtToPhy(pQueueCtrl, pQueueCtrl->pCurrentDescr) );
     return NULL;
 }
 
-        
+
 
 /*******************************************************************************
 * mvEthPortForceRx - Get next buffer from RX queue in spite of buffer ownership.
@@ -955,7 +955,7 @@ MV_PKT_INFO*    mvEthPortForceTxDone(void* pEthPortHndl, int txQueue)
 *
 * RETURN:
 *       MV_EMPTY    - There is no more buffers in this queue.
-*       MV_OK       - Buffer detached from the queue and pBufInfo structure 
+*       MV_OK       - Buffer detached from the queue and pBufInfo structure
 *                   filled with relevant information.
 *
 *******************************************************************************/
@@ -966,12 +966,12 @@ MV_PKT_INFO*    mvEthPortForceRx(void* pEthPortHndl, int rxQueue)
     ETH_RX_DESC*    pRxDesc;
     MV_PKT_INFO*    pPktInfo;
     int             port = pPortCtrl->portNo;
-       
+
     pQueueCtrl = &pPortCtrl->rxQueue[rxQueue];
 
     if(pQueueCtrl->resource == 0)
     {
-        MV_REG_WRITE( ETH_RX_CUR_DESC_PTR_REG(port, rxQueue), 
+        MV_REG_WRITE( ETH_RX_CUR_DESC_PTR_REG(port, rxQueue),
                     (MV_U32)ethDescVirtToPhy(pQueueCtrl, pQueueCtrl->pCurrentDescr) );
 
         return NULL;
@@ -987,7 +987,7 @@ MV_PKT_INFO*    mvEthPortForceRx(void* pEthPortHndl, int rxQueue)
     ETH_DESCR_FLUSH_INV(pPortCtrl, pRxDesc);
 
     pQueueCtrl->pCurrentDescr = RX_NEXT_DESC_PTR(pRxDesc, pQueueCtrl);
-    return pPktInfo;    
+    return pPktInfo;
 }
 
 
@@ -1035,13 +1035,13 @@ static MV_U32 mvEthMruGet(MV_U32 maxRxPktSize)
 *
 * INPUT:
 *       void*           pPortHndl   - Ethernet Port handler.
-*       MV_U32          uSec        - Number of micro seconds between 
+*       MV_U32          uSec        - Number of micro seconds between
 *                                   RX interrupts
 *
 * RETURN:
 *       None.
 *
-* COMMENT:     
+* COMMENT:
 *   1 sec           - TCLK_RATE clocks
 *   1 uSec          - TCLK_RATE / 1,000,000 clocks
 *
@@ -1051,7 +1051,7 @@ static MV_U32 mvEthMruGet(MV_U32 maxRxPktSize)
 *       None.
 *
 *******************************************************************************/
-MV_U32    mvEthRxCoalSet (void* pPortHndl, MV_U32 uSec) 
+MV_U32    mvEthRxCoalSet (void* pPortHndl, MV_U32 uSec)
 {
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pPortHndl;
     MV_U32          coal = ((uSec * (mvBoardTclkGet() / 1000000)) / 64);
@@ -1085,20 +1085,20 @@ MV_U32    mvEthRxCoalSet (void* pPortHndl, MV_U32 uSec)
 *
 * INPUT:
 *       void*           pPortHndl    - Ethernet Port handler.
-*       MV_U32          uSec        - Number of micro seconds between 
+*       MV_U32          uSec        - Number of micro seconds between
 *                                   RX interrupts
 *
 * RETURN:
 *       None.
 *
-* COMMENT:     
+* COMMENT:
 *   1 sec           - TCLK_RATE clocks
 *   1 uSec          - TCLK_RATE / 1,000,000 clocks
 *
 *   Register Value for N micro seconds -  ((N * ( (TCLK_RATE / 1,000,000)) / 64)
 *
 *******************************************************************************/
-MV_U32    mvEthTxCoalSet(void* pPortHndl, MV_U32 uSec) 
+MV_U32    mvEthTxCoalSet(void* pPortHndl, MV_U32 uSec)
 {
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pPortHndl;
     MV_U32          coal = ((uSec * (mvBoardTclkGet() / 1000000)) / 64);
@@ -1109,7 +1109,7 @@ MV_U32    mvEthTxCoalSet(void* pPortHndl, MV_U32 uSec)
     regVal |= ETH_TX_INTR_COAL_MASK(coal);
 
     /* Set TX Coalescing mechanism */
-    MV_REG_WRITE (ETH_TX_FIFO_URGENT_THRESH_REG(pPortCtrl->portNo), regVal); 
+    MV_REG_WRITE (ETH_TX_FIFO_URGENT_THRESH_REG(pPortCtrl->portNo), regVal);
     return coal;
 }
 
@@ -1132,7 +1132,7 @@ MV_U32    mvEthTxCoalSet(void* pPortHndl, MV_U32 uSec)
 *       MV_STATUS   MV_OK  - success
 *                   Others - failure.
 *
-* COMMENT:     
+* COMMENT:
 *   1 sec           - TCLK_RATE clocks
 *   1 uSec          - TCLK_RATE / 1,000,000 clocks
 *
@@ -1173,10 +1173,10 @@ MV_STATUS   mvEthCoalGet(void* pPortHndl, MV_U32* pRxCoal, MV_U32* pTxCoal)
 }
 
 /*******************************************************************************
-* mvEthMaxRxSizeSet - 
+* mvEthMaxRxSizeSet -
 *
 * DESCRIPTION:
-*       Change maximum receive size of the port. This configuration will take place 
+*       Change maximum receive size of the port. This configuration will take place
 *       after next call of ethPortSetDefaults() function.
 *
 * INPUT:
@@ -1190,7 +1190,7 @@ MV_STATUS   mvEthMaxRxSizeSet(void* pPortHndl, int maxRxSize)
 
     if((maxRxSize < 1518) || (maxRxSize & ~ETH_RX_BUFFER_MASK))
        return MV_BAD_PARAM;
-    
+
     pPortCtrl->portConfig.maxRxPktSize = maxRxSize;
 
     portSerialCtrlReg =  MV_REG_READ(ETH_PORT_SERIAL_CTRL_REG(pPortCtrl->portNo));
@@ -1216,9 +1216,9 @@ MV_STATUS   mvEthMaxRxSizeSet(void* pPortHndl, int maxRxSize)
 * INPUT:
 *       void*       pEthPortHndl    - Ethernet Port handler.
 *       MV_BOOL     isPromisc       - Promiscous mode
-*                                   MV_TRUE  - accept all Broadcast, Multicast 
+*                                   MV_TRUE  - accept all Broadcast, Multicast
 *                                              and Unicast packets
-*                                   MV_FALSE - accept all Broadcast, 
+*                                   MV_FALSE - accept all Broadcast,
 *                                              specially added Multicast and
 *                                              single Unicast packets
 *
@@ -1250,7 +1250,7 @@ MV_STATUS   mvEthRxFilterModeSet(void* pEthPortHndl, MV_BOOL isPromisc)
         /* Clear all mcastCount */
         memset(pPortCtrl->mcastCount, 0, sizeof(pPortCtrl->mcastCount));
     }
-    MV_REG_WRITE(ETH_PORT_CONFIG_REG(pPortCtrl->portNo), portCfgReg);        
+    MV_REG_WRITE(ETH_PORT_CONFIG_REG(pPortCtrl->portNo), portCfgReg);
 
     /* Set Special Multicast and Other Multicast tables */
     mvEthSetSpecialMcastTable(pPortCtrl->portNo, queue);
@@ -1453,7 +1453,7 @@ MV_U8   mvEthMcastCrc8Get(MV_U8* pAddr)
 * INPUT:
 *       void*   pEthPortHndl    - Ethernet port handler.
 *       MV_U8*  pAddr           - Address to be set
-*       int     queue           - RX queue to capture all packets with this 
+*       int     queue           - RX queue to capture all packets with this
 *                               Multicast MAC address.
 *                               -1 means delete this Multicast address.
 *
@@ -1468,7 +1468,7 @@ MV_STATUS   mvEthMcastAddrSet(void* pPortHndl, MV_U8 *pAddr, int queue)
 
     if(queue >= MV_ETH_RX_Q_NUM)
     {
-        mvOsPrintf("ethPort %d: RX queue #%d is out of range\n", 
+        mvOsPrintf("ethPort %d: RX queue #%d is out of range\n",
                     pPortCtrl->portNo, queue);
         return MV_BAD_PARAM;
     }
@@ -1523,10 +1523,10 @@ MV_STATUS   mvEthMcastAddrSet(void* pPortHndl, MV_U8 *pAddr, int queue)
 * ethSetUcastTable - Unicast address settings.
 *
 * DESCRIPTION:
-*      Set all entries in the Unicast MAC Table queue==-1 means reject all 
+*      Set all entries in the Unicast MAC Table queue==-1 means reject all
 * INPUT:
 *
-* RETURN: 
+* RETURN:
 *
 *******************************************************************************/
 static void    ethSetUcastTable(int portNo, int queue)
@@ -1557,7 +1557,7 @@ static void    ethSetUcastTable(int portNo, int queue)
 *   Set all entries to the Special Multicast MAC Table. queue==-1 means reject all
 * INPUT:
 *
-* RETURN: 
+* RETURN:
 *
 *******************************************************************************/
 MV_VOID    mvEthSetSpecialMcastTable(int portNo, int queue)
@@ -1579,7 +1579,7 @@ MV_VOID    mvEthSetSpecialMcastTable(int portNo, int queue)
 
     for (offset=0; offset<=0xFC; offset+=4)
     {
-        MV_REG_WRITE((ETH_DA_FILTER_SPEC_MCAST_BASE(portNo) + 
+        MV_REG_WRITE((ETH_DA_FILTER_SPEC_MCAST_BASE(portNo) +
                       offset), regValue);
     }
 }
@@ -1591,7 +1591,7 @@ MV_VOID    mvEthSetSpecialMcastTable(int portNo, int queue)
 *   Set all entries to the Other Multicast MAC Table. queue==-1 means reject all
 * INPUT:
 *
-* RETURN: 
+* RETURN:
 *
 *******************************************************************************/
 MV_VOID    mvEthSetOtherMcastTable(int portNo, int queue)
@@ -1613,7 +1613,7 @@ MV_VOID    mvEthSetOtherMcastTable(int portNo, int queue)
 
     for (offset=0; offset<=0xFC; offset+=4)
     {
-        MV_REG_WRITE((ETH_DA_FILTER_OTH_MCAST_BASE(portNo) + 
+        MV_REG_WRITE((ETH_DA_FILTER_OTH_MCAST_BASE(portNo) +
                       offset), regValue);
     }
 }
@@ -1653,9 +1653,9 @@ static MV_BOOL ethSetUcastAddr(int portNo, MV_U8 lastNibble, int queue)
     regOffset = lastNibble % 4;     /* Entry offset within the above register */
 
 
-    unicastReg = MV_REG_READ( (ETH_DA_FILTER_UCAST_BASE(portNo) + 
+    unicastReg = MV_REG_READ( (ETH_DA_FILTER_UCAST_BASE(portNo) +
                                tblOffset));
-                 
+
 
     if(queue == -1)
     {
@@ -1710,7 +1710,7 @@ static MV_BOOL ethSetSpecialMcastAddr(int ethPortNum, MV_U8 lastByte, int queue)
     regOffset = lastByte % 4;       /* Entry offset within the above register */
 
     smcTableReg = MV_REG_READ((ETH_DA_FILTER_SPEC_MCAST_BASE(ethPortNum) + tblOffset*4));
-    
+
     if(queue == -1)
     {
         /* Clear accepts frame bit at specified Special DA table entry */
@@ -1721,7 +1721,7 @@ static MV_BOOL ethSetSpecialMcastAddr(int ethPortNum, MV_U8 lastByte, int queue)
         smcTableReg &= ~(0xFF << (8 * regOffset));
         smcTableReg |= ((0x01 | (queue<<1)) << (8 * regOffset));
     }
-    MV_REG_WRITE((ETH_DA_FILTER_SPEC_MCAST_BASE(ethPortNum) + 
+    MV_REG_WRITE((ETH_DA_FILTER_SPEC_MCAST_BASE(ethPortNum) +
                   tblOffset*4), smcTableReg);
 
     return MV_TRUE;
@@ -1776,7 +1776,7 @@ static MV_BOOL ethSetOtherMcastAddr(int ethPortNum, MV_U8 crc8, int queue)
         omcTableReg |= ((0x01 | (queue<<1)) << (8 * regOffset));
     }
 
-    MV_REG_WRITE((ETH_DA_FILTER_OTH_MCAST_BASE(ethPortNum) + tblOffset), 
+    MV_REG_WRITE((ETH_DA_FILTER_OTH_MCAST_BASE(ethPortNum) + tblOffset),
                     omcTableReg);
 
     return MV_TRUE;
@@ -1793,7 +1793,7 @@ static MV_BOOL ethSetOtherMcastAddr(int ethPortNum, MV_U8 crc8, int queue)
 *
 * DESCRIPTION:
 *       This function reads a MIB counter of a specific ethernet port.
-*       NOTE - Read from ETH_MIB_GOOD_OCTETS_RECEIVED_LOW or 
+*       NOTE - Read from ETH_MIB_GOOD_OCTETS_RECEIVED_LOW or
 *              ETH_MIB_GOOD_OCTETS_SENT_LOW counters will return 64 bits value,
 *              so pHigh32 pointer should not be NULL in this case.
 *
@@ -1809,7 +1809,7 @@ static MV_BOOL ethSetOtherMcastAddr(int ethPortNum, MV_U8 crc8, int queue)
 *       32 low sgnificant bits of MIB counter value.
 *
 *******************************************************************************/
-MV_U32  mvEthMibCounterRead(void* pPortHandle, unsigned int mibOffset, 
+MV_U32  mvEthMibCounterRead(void* pPortHandle, unsigned int mibOffset,
                             MV_U32* pHigh32)
 {
     int             portNo;
@@ -1819,10 +1819,10 @@ MV_U32  mvEthMibCounterRead(void* pPortHandle, unsigned int mibOffset,
     portNo = pPortCtrl->portNo;
 
     valLow32 = MV_REG_READ(ETH_MIB_COUNTERS_BASE(portNo) + mibOffset);
-    
+
     /* Implement FEr ETH. Erroneous Value when Reading the Upper 32-bits    */
     /* of a 64-bit MIB Counter.                                             */
-    if( (mibOffset == ETH_MIB_GOOD_OCTETS_RECEIVED_LOW) || 
+    if( (mibOffset == ETH_MIB_GOOD_OCTETS_RECEIVED_LOW) ||
         (mibOffset == ETH_MIB_GOOD_OCTETS_SENT_LOW) )
     {
         valHigh32 = MV_REG_READ(ETH_MIB_COUNTERS_BASE(portNo) + mibOffset + 4);
@@ -1857,7 +1857,7 @@ void  mvEthMibCountersClear(void* pPortHandle)
     for(i=ETH_MIB_GOOD_OCTETS_RECEIVED_LOW; i<ETH_MIB_LATE_COLLISION; i+=4)
         dummy = MV_REG_READ((ETH_MIB_COUNTERS_BASE(portNo) + i));
 }
-    
+
 
 /******************************************************************************/
 /*                        RX Dispatching configuration routines               */
@@ -1876,7 +1876,7 @@ int     mvEthTosToRxqGet(void* pPortHandle, int tos)
     }
     regIdx  = mvOsDivide(tos>>2, 10);
     regOffs = mvOsReminder(tos>>2, 10);
-    
+
     regValue = MV_REG_READ(ETH_DIFF_SERV_PRIO_REG(pPortCtrl->portNo, regIdx) );
     rxq = (regValue >> (regOffs*3));
     rxq &= 0x7;
@@ -1893,7 +1893,7 @@ int     mvEthTosToRxqGet(void* pPortHandle, int tos)
 *       void*   pPortHandle - Pointer to port specific handler;
 *       int     tos         - TOS value in the IP header of the packet
 *       int     rxq         - RX Queue for packets with the configured TOS value
-*                           Negative value (-1) means no special processing for these packets, 
+*                           Negative value (-1) means no special processing for these packets,
 *                           so they will be processed as regular packets.
 *
 * RETURN:   MV_STATUS
@@ -1916,7 +1916,7 @@ MV_STATUS   mvEthTosToRxqSet(void* pPortHandle, int tos, int rxq)
     }
     regIdx  = mvOsDivide(tos>>2, 10);
     regOffs = mvOsReminder(tos>>2, 10);
-    
+
     regValue = MV_REG_READ(ETH_DIFF_SERV_PRIO_REG(pPortCtrl->portNo, regIdx) );
     regValue &= ~(0x7 << (regOffs*3));
     regValue |= (rxq << (regOffs*3));
@@ -1926,7 +1926,7 @@ MV_STATUS   mvEthTosToRxqSet(void* pPortHandle, int tos, int rxq)
 }
 
 /*******************************************************************************
-* mvEthVlanPrioRxQueue - Configure RX queue to capture VLAN tagged packets with 
+* mvEthVlanPrioRxQueue - Configure RX queue to capture VLAN tagged packets with
 *                        special priority bits [0-2]
 *
 * DESCRIPTION:
@@ -1935,12 +1935,12 @@ MV_STATUS   mvEthTosToRxqSet(void* pPortHandle, int tos, int rxq)
 *       void*   pPortHandle - Pointer to port specific handler;
 *       int     bpduQueue   - Special queue to capture VLAN tagged packets with special
 *                           priority.
-*                           Negative value (-1) means no special processing for these packets, 
+*                           Negative value (-1) means no special processing for these packets,
 *                           so they will be processed as regular packets.
 *
 * RETURN:   MV_STATUS
 *       MV_OK       - Success
-*       MV_FAIL     - Failed. 
+*       MV_FAIL     - Failed.
 *
 *******************************************************************************/
 MV_STATUS   mvEthVlanPrioRxQueue(void* pPortHandle, int vlanPrio, int vlanPrioQueue)
@@ -1958,7 +1958,7 @@ MV_STATUS   mvEthVlanPrioRxQueue(void* pPortHandle, int vlanPrio, int vlanPrioQu
         mvOsPrintf("ethDrv: vlanPrio=%d is out of range\n", vlanPrio);
         return MV_BAD_PARAM;
     }
-  
+
     vlanPrioReg = MV_REG_READ(ETH_VLAN_TAG_TO_PRIO_REG(pPortCtrl->portNo));
     vlanPrioReg &= ~(0x7 << (vlanPrio*3));
     vlanPrioReg |= (vlanPrioQueue << (vlanPrio*3));
@@ -1972,21 +1972,21 @@ MV_STATUS   mvEthVlanPrioRxQueue(void* pPortHandle, int vlanPrio, int vlanPrioQu
 * mvEthBpduRxQueue - Configure RX queue to capture BPDU packets.
 *
 * DESCRIPTION:
-*       This function defines processing of BPDU packets. 
-*   BPDU packets can be accepted and captured to one of RX queues 
-*   or can be processing as regular Multicast packets. 
+*       This function defines processing of BPDU packets.
+*   BPDU packets can be accepted and captured to one of RX queues
+*   or can be processing as regular Multicast packets.
 *
 * INPUT:
 *       void*   pPortHandle - Pointer to port specific handler;
-*       int     bpduQueue   - Special queue to capture BPDU packets (DA is equal to 
-*                           01-80-C2-00-00-00 through 01-80-C2-00-00-FF, 
-*                           except for the Flow-Control Pause packets). 
-*                           Negative value (-1) means no special processing for BPDU, 
+*       int     bpduQueue   - Special queue to capture BPDU packets (DA is equal to
+*                           01-80-C2-00-00-00 through 01-80-C2-00-00-FF,
+*                           except for the Flow-Control Pause packets).
+*                           Negative value (-1) means no special processing for BPDU,
 *                           packets so they will be processed as regular Multicast packets.
 *
 * RETURN:   MV_STATUS
 *       MV_OK       - Success
-*       MV_FAIL     - Failed. 
+*       MV_FAIL     - Failed.
 *
 *******************************************************************************/
 MV_STATUS   mvEthBpduRxQueue(void* pPortHandle, int bpduQueue)
@@ -2000,7 +2000,7 @@ MV_STATUS   mvEthBpduRxQueue(void* pPortHandle, int bpduQueue)
         mvOsPrintf("ethDrv: RX queue #%d is out of range\n", bpduQueue);
         return MV_BAD_PARAM;
     }
-  
+
     portCfgExtReg = MV_REG_READ(ETH_PORT_CONFIG_EXTEND_REG(pPortCtrl->portNo));
 
     portCfgReg = MV_REG_READ(ETH_PORT_CONFIG_REG(pPortCtrl->portNo));
@@ -2032,18 +2032,18 @@ MV_STATUS   mvEthBpduRxQueue(void* pPortHandle, int bpduQueue)
 * mvEthArpRxQueue - Configure RX queue to capture ARP packets.
 *
 * DESCRIPTION:
-*       This function defines processing of ARP (type=0x0806) packets. 
-*   ARP packets can be accepted and captured to one of RX queues 
-*   or can be processed as other Broadcast packets. 
+*       This function defines processing of ARP (type=0x0806) packets.
+*   ARP packets can be accepted and captured to one of RX queues
+*   or can be processed as other Broadcast packets.
 *
 * INPUT:
 *       void*   pPortHandle - Pointer to port specific handler;
-*       int     arpQueue    - Special queue to capture ARP packets (type=0x806). 
+*       int     arpQueue    - Special queue to capture ARP packets (type=0x806).
 *                           Negative value (-1) means discard ARP packets
 *
 * RETURN:   MV_STATUS
 *       MV_OK       - Success
-*       MV_FAIL     - Failed. 
+*       MV_FAIL     - Failed.
 *
 *******************************************************************************/
 MV_STATUS   mvEthArpRxQueue(void* pPortHandle, int arpQueue)
@@ -2083,19 +2083,19 @@ MV_STATUS   mvEthArpRxQueue(void* pPortHandle, int arpQueue)
 * mvEthTcpRxQueue - Configure RX queue to capture TCP packets.
 *
 * DESCRIPTION:
-*       This function defines processing of TCP packets. 
-*   TCP packets can be accepted and captured to one of RX queues 
-*   or can be processed as regular Unicast packets. 
+*       This function defines processing of TCP packets.
+*   TCP packets can be accepted and captured to one of RX queues
+*   or can be processed as regular Unicast packets.
 *
 * INPUT:
 *       void*   pPortHandle - Pointer to port specific handler;
-*       int     tcpQueue    - Special queue to capture TCP packets. Value "-1" 
-*                           means no special processing for TCP packets, 
+*       int     tcpQueue    - Special queue to capture TCP packets. Value "-1"
+*                           means no special processing for TCP packets,
 *                           so they will be processed as regular
 *
 * RETURN:   MV_STATUS
 *       MV_OK       - Success
-*       MV_FAIL     - Failed. 
+*       MV_FAIL     - Failed.
 *
 *******************************************************************************/
 MV_STATUS   mvEthTcpRxQueue(void* pPortHandle, int tcpQueue)
@@ -2134,19 +2134,19 @@ MV_STATUS   mvEthTcpRxQueue(void* pPortHandle, int tcpQueue)
 * mvEthUdpRxQueue - Configure RX queue to capture UDP packets.
 *
 * DESCRIPTION:
-*       This function defines processing of UDP packets. 
-*   TCP packets can be accepted and captured to one of RX queues 
-*   or can be processed as regular Unicast packets. 
+*       This function defines processing of UDP packets.
+*   TCP packets can be accepted and captured to one of RX queues
+*   or can be processed as regular Unicast packets.
 *
 * INPUT:
 *       void*   pPortHandle - Pointer to port specific handler;
-*       int     udpQueue    - Special queue to capture UDP packets. Value "-1" 
-*                           means no special processing for UDP packets, 
+*       int     udpQueue    - Special queue to capture UDP packets. Value "-1"
+*                           means no special processing for UDP packets,
 *                           so they will be processed as regular
 *
 * RETURN:   MV_STATUS
 *       MV_OK       - Success
-*       MV_FAIL     - Failed. 
+*       MV_FAIL     - Failed.
 *
 *******************************************************************************/
 MV_STATUS   mvEthUdpRxQueue(void* pPortHandle, int udpQueue)
@@ -2168,7 +2168,7 @@ MV_STATUS   mvEthUdpRxQueue(void* pPortHandle, int udpQueue)
         portCfgReg &= ~ETH_DEF_RX_UDP_QUEUE_ALL_MASK;
         portCfgReg |= ETH_DEF_RX_UDP_QUEUE_MASK(pPortCtrl->portConfig.rxUdpQ);
 
-        portCfgReg |= ETH_CAPTURE_UDP_FRAMES_ENABLE_MASK;        
+        portCfgReg |= ETH_CAPTURE_UDP_FRAMES_ENABLE_MASK;
     }
     else
     {
@@ -2192,7 +2192,7 @@ MV_STATUS   mvEthUdpRxQueue(void* pPortHandle, int udpQueue)
 * DESCRIPTION:
 *       This function configure the port to work with desirable Duplex and Speed.
 *       Changing of these parameters are allowed only when port is disabled.
-*       This function disable the port if was enabled, change duplex and speed 
+*       This function disable the port if was enabled, change duplex and speed
 *       and, enable the port back if needed.
 *
 * INPUT:
@@ -2205,17 +2205,17 @@ MV_STATUS   mvEthUdpRxQueue(void* pPortHandle, int udpQueue)
 *       MV_OUT_OF_RANGE - Failed. Port is out of valid range
 *       MV_NOT_FOUND    - Failed. Port is not initialized.
 *       MV_BAD_PARAM    - Input parameters (speed/duplex) in conflict.
-*       MV_BAD_VALUE    - Value of one of input parameters (speed, duplex) 
+*       MV_BAD_VALUE    - Value of one of input parameters (speed, duplex)
 *                       is not valid
 *
 *******************************************************************************/
-MV_STATUS   mvEthSpeedDuplexSet(void* pPortHandle, MV_ETH_PORT_SPEED speed, 
+MV_STATUS   mvEthSpeedDuplexSet(void* pPortHandle, MV_ETH_PORT_SPEED speed,
                                 MV_ETH_PORT_DUPLEX duplex)
 {
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pPortHandle;
     int             port = pPortCtrl->portNo;
     MV_U32      portSerialCtrlReg;
-    
+
     if( (port < 0) || (port >= (int)mvCtrlEthMaxPortGet()) )
         return MV_OUT_OF_RANGE;
 
@@ -2286,9 +2286,9 @@ MV_STATUS   mvEthSpeedDuplexSet(void* pPortHandle, MV_ETH_PORT_SPEED speed,
 * mvEthFlowCtrlSet - Set Flow Control of the port.
 *
 * DESCRIPTION:
-*       This function configure the port to work with desirable Duplex and 
-*       Speed. Changing of these parameters are allowed only when port is 
-*       disabled. This function disable the port if was enabled, change 
+*       This function configure the port to work with desirable Duplex and
+*       Speed. Changing of these parameters are allowed only when port is
+*       disabled. This function disable the port if was enabled, change
 *       duplex and speed and, enable the port back if needed.
 *
 * INPUT:
@@ -2307,7 +2307,7 @@ MV_STATUS   mvEthFlowCtrlSet(void* pPortHandle, MV_ETH_PORT_FC flowControl)
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pPortHandle;
     int             port = pPortCtrl->portNo;
     MV_U32      portSerialCtrlReg;
-    
+
     if( (port < 0) || (port >= (int)mvCtrlEthMaxPortGet() ) )
         return MV_OUT_OF_RANGE;
 
@@ -2371,7 +2371,7 @@ MV_STATUS mvEthHeaderModeSet(void* pPortHandle, MV_ETH_HEADER_MODE headerMode)
     int             port = pPortCtrl->portNo;
     MV_U32			mvHeaderReg;
     MV_U32          numRxQ = MV_ETH_RX_Q_NUM;
-    
+
     if((port < 0) || (port >= mvCtrlEthMaxPortGet()))
         return MV_OUT_OF_RANGE;
 
@@ -2432,7 +2432,7 @@ MV_STATUS mvEthHeaderModeSet(void* pPortHandle, MV_ETH_HEADER_MODE headerMode)
 * mvEthEjpModeSet - Enable / Disable EJP policy for TX.
 *
 * DESCRIPTION:
-*       This function 
+*       This function
 *
 * INPUT:
 *       void*           pPortHandle - Pointer to port specific handler;
@@ -2446,18 +2446,18 @@ MV_STATUS mvEthHeaderModeSet(void* pPortHandle, MV_ETH_HEADER_MODE headerMode)
 * RETURN:   None.
 *
 *******************************************************************************/
-MV_STATUS    mvEthEjpModeSet(void* pPortHandle, int mode) 
+MV_STATUS    mvEthEjpModeSet(void* pPortHandle, int mode)
 {
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pPortHandle;
     int             port = pPortCtrl->portNo;
-    
+
     if((port < 0) || (port >= mvCtrlEthMaxPortGet()))
         return MV_OUT_OF_RANGE;
 
     pPortCtrl = ethPortCtrl[port];
     if(pPortCtrl == NULL)
         return MV_NOT_FOUND;
-    
+
     pPortCtrl->portConfig.ejpMode = mode;
     if(mode)
     {
@@ -2469,8 +2469,8 @@ MV_STATUS    mvEthEjpModeSet(void* pPortHandle, int mode)
         /* EJP disabled */
         MV_REG_WRITE(ETH_TXQ_CMD_1_REG(port), 0);
     }
-    mvOsPrintf("eth_%d: EJP %s - ETH_TXQ_CMD_1_REG: 0x%x = 0x%08x\n", 
-        port, mode ? "Enabled" : "Disabled", ETH_TXQ_CMD_1_REG(port), 
+    mvOsPrintf("eth_%d: EJP %s - ETH_TXQ_CMD_1_REG: 0x%x = 0x%08x\n",
+        port, mode ? "Enabled" : "Disabled", ETH_TXQ_CMD_1_REG(port),
                     MV_REG_READ(ETH_TXQ_CMD_1_REG(port)));
 
     return MV_OK;
@@ -2481,14 +2481,14 @@ MV_STATUS    mvEthEjpModeSet(void* pPortHandle, int mode)
 * mvEthStatusGet - Get major properties of the port .
 *
 * DESCRIPTION:
-*       This function get major properties of the port (link, speed, duplex, 
+*       This function get major properties of the port (link, speed, duplex,
 *       flowControl, etc) and return them using the single structure.
 *
 * INPUT:
 *       void*           pPortHandle - Pointer to port specific handler;
 *
 * OUTPUT:
-*       MV_ETH_PORT_STATUS* pStatus - Pointer to structure, were port status 
+*       MV_ETH_PORT_STATUS* pStatus - Pointer to structure, were port status
 *                                   will be placed.
 *
 * RETURN:   None.
@@ -2510,18 +2510,18 @@ void    mvEthStatusGet(void* pPortHandle, MV_ETH_PORT_STATUS* pStatus)
     else
         pStatus->speed = MV_ETH_SPEED_10;
 
-    if(regValue & ETH_LINK_UP_MASK) 
+    if(regValue & ETH_LINK_UP_MASK)
         pStatus->isLinkUp = MV_TRUE;
     else
         pStatus->isLinkUp = MV_FALSE;
 
-    if(regValue & ETH_FULL_DUPLEX_MASK) 
-        pStatus->duplex = MV_ETH_DUPLEX_FULL; 
+    if(regValue & ETH_FULL_DUPLEX_MASK)
+        pStatus->duplex = MV_ETH_DUPLEX_FULL;
     else
-        pStatus->duplex = MV_ETH_DUPLEX_HALF; 
+        pStatus->duplex = MV_ETH_DUPLEX_HALF;
 
 
-    if(regValue & ETH_ENABLE_RCV_FLOW_CTRL_MASK) 
+    if(regValue & ETH_ENABLE_RCV_FLOW_CTRL_MASK)
         pStatus->flowControl = MV_ETH_FC_ENABLE;
     else
         pStatus->flowControl = MV_ETH_FC_DISABLE;
@@ -2542,7 +2542,7 @@ void    mvEthStatusGet(void* pPortHandle, MV_ETH_PORT_STATUS* pStatus)
 *
 * INPUT:
 *       void*   pPortHandle     - Pointer to port specific handler;
-*       int     phyAddr         - PHY address       
+*       int     phyAddr         - PHY address
 *
 * RETURN:
 *       None.
@@ -2619,11 +2619,11 @@ int     mvEthPhyAddrGet(void* pPortHandle)
 *******************************************************************************/
 static void ethInitRxDescRing(ETH_PORT_CTRL* pPortCtrl, int queue)
 {
-    ETH_RX_DESC     *pRxDescBase, *pRxDesc, *pRxPrevDesc; 
+    ETH_RX_DESC     *pRxDescBase, *pRxDesc, *pRxPrevDesc;
     int             ix, rxDescNum = pPortCtrl->rxQueueConfig[queue].descrNum;
     ETH_QUEUE_CTRL  *pQueueCtrl = &pPortCtrl->rxQueue[queue];
 
-    /* Make sure descriptor address is cache line size aligned  */        
+    /* Make sure descriptor address is cache line size aligned  */
     pRxDescBase = (ETH_RX_DESC*)MV_ALIGN_UP((MV_ULONG)pQueueCtrl->descBuf.bufVirtPtr,
                                      CPU_D_CACHE_LINE_SIZE);
 
@@ -2654,7 +2654,7 @@ static void ethInitRxDescRing(ETH_PORT_CTRL* pPortCtrl, int queue)
 
     pQueueCtrl->pCurrentDescr = pRxDescBase;
     pQueueCtrl->pUsedDescr = pRxDescBase;
-    
+
     pQueueCtrl->pFirstDescr = pRxDescBase;
     pQueueCtrl->pLastDescr = pRxDesc;
     pQueueCtrl->resource = 0;
@@ -2729,12 +2729,12 @@ void ethResetRxDescRing(void* pPortHndl, int queue)
 *******************************************************************************/
 static void ethInitTxDescRing(ETH_PORT_CTRL* pPortCtrl, int queue)
 {
-    ETH_TX_DESC     *pTxDescBase, *pTxDesc, *pTxPrevDesc; 
+    ETH_TX_DESC     *pTxDescBase, *pTxDesc, *pTxPrevDesc;
     int             ix, txDescNum = pPortCtrl->txQueueConfig[queue].descrNum;
     ETH_QUEUE_CTRL  *pQueueCtrl = &pPortCtrl->txQueue[queue];
 
     /* Make sure descriptor address is cache line size aligned  */
-    pTxDescBase = (ETH_TX_DESC*)MV_ALIGN_UP((MV_ULONG)pQueueCtrl->descBuf.bufVirtPtr, 
+    pTxDescBase = (ETH_TX_DESC*)MV_ALIGN_UP((MV_ULONG)pQueueCtrl->descBuf.bufVirtPtr,
                                      CPU_D_CACHE_LINE_SIZE);
 
     pTxDesc      = (ETH_TX_DESC*)pTxDescBase;
@@ -2766,7 +2766,7 @@ static void ethInitTxDescRing(ETH_PORT_CTRL* pPortCtrl, int queue)
 
     pQueueCtrl->pCurrentDescr = pTxDescBase;
     pQueueCtrl->pUsedDescr = pTxDescBase;
-    
+
     pQueueCtrl->pFirstDescr = pTxDescBase;
     pQueueCtrl->pLastDescr = pTxDesc;
     /* Leave one TX descriptor out of use */
@@ -2778,7 +2778,7 @@ void ethResetTxDescRing(void* pPortHndl, int queue)
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pPortHndl;
     ETH_QUEUE_CTRL* pQueueCtrl = &pPortCtrl->txQueue[queue];
     ETH_TX_DESC*    pTxDesc = (ETH_TX_DESC*)pQueueCtrl->pFirstDescr;
-    
+
     pQueueCtrl->resource = 0;
     if(pQueueCtrl->pFirstDescr != NULL)
     {
@@ -2811,7 +2811,7 @@ void ethResetTxDescRing(void* pPortHndl, int queue)
         /* Update TX Command register */
         pPortCtrl->portTxQueueCmdReg &=  MV_32BIT_LE_FAST(~(1 << queue));
         /* update HW */
-        MV_REG_WRITE( ETH_TX_CUR_DESC_PTR_REG(pPortCtrl->portNo, queue), 0 );    
+        MV_REG_WRITE( ETH_TX_CUR_DESC_PTR_REG(pPortCtrl->portNo, queue), 0 );
     }
 }
 
@@ -2829,7 +2829,7 @@ void ethResetTxDescRing(void* pPortHndl, int queue)
 * RETURN: None
 *
 *******************************************************************************/
-static MV_U8*  ethAllocDescrMemory(ETH_PORT_CTRL* pPortCtrl, int descSize, 
+static MV_U8*  ethAllocDescrMemory(ETH_PORT_CTRL* pPortCtrl, int descSize,
                             MV_ULONG* pPhysAddr, MV_U32 *memHandle)
 {
     MV_U8*  pVirt;
@@ -2863,7 +2863,7 @@ static MV_U8*  ethAllocDescrMemory(ETH_PORT_CTRL* pPortCtrl, int descSize,
 *
 * INPUT:
 *       void* pVirtAddr - virtual pointer to memory allocated for RX and TX
-*                       desriptors.        
+*                       desriptors.
 *
 * RETURN: None
 *
@@ -2882,14 +2882,14 @@ void    ethFreeDescrMemory(ETH_PORT_CTRL* pPortCtrl, MV_BUF_INFO* pDescBuf)
 #endif /* ETH_DESCR_IN_SRAM */
 
 #ifdef ETH_DESCR_UNCACHED
-    mvOsIoUncachedFree(pPortCtrl->osHandle, pDescBuf->bufSize, pDescBuf->bufPhysAddr, 
+    mvOsIoUncachedFree(pPortCtrl->osHandle, pDescBuf->bufSize, pDescBuf->bufPhysAddr,
                      pDescBuf->bufVirtPtr,pDescBuf->memHandle);
 #else
-    mvOsIoCachedFree(pPortCtrl->osHandle, pDescBuf->bufSize, pDescBuf->bufPhysAddr, 
+    mvOsIoCachedFree(pPortCtrl->osHandle, pDescBuf->bufSize, pDescBuf->bufPhysAddr,
                      pDescBuf->bufVirtPtr,pDescBuf->memHandle);
 #endif /* ETH_DESCR_UNCACHED */
 }
-                                                                                                                             
+
 /******************************************************************************/
 /*                Other Functions                                         */
 /******************************************************************************/
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.c b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.c
index f533475..62edcb5 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer. 
+        this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -123,7 +123,7 @@ void     ethEjpModeSet(int port, int mode)
         mvEthEjpModeSet(pHndl, mode);
     }
 }
-#endif /* (MV_ETH_VERSION >= 4) */
+#endif /* (MV_ETH_VERSION >= 4) */
 
 void    ethBpduRxQ(int port, int bpduQueue)
 {
@@ -174,11 +174,11 @@ void    ethTxPolicyRegs(int port)
     int             queue;
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)mvEthPortHndlGet(port);
 
-    if(pPortCtrl == NULL) 
+    if(pPortCtrl == NULL)
     {
         return;
     }
-    mvOsPrintf("Port #%d TX Policy: EJP=%d, TXQs: ", 
+    mvOsPrintf("Port #%d TX Policy: EJP=%d, TXQs: ",
                 port, pPortCtrl->portConfig.ejpMode);
     for(queue=0; queue<MV_ETH_TX_Q_NUM; queue++)
     {
@@ -189,46 +189,46 @@ void    ethTxPolicyRegs(int port)
 
     mvOsPrintf("\n\t TX policy Port #%d configuration registers\n", port);
 
-    mvOsPrintf("ETH_TX_QUEUE_COMMAND_REG            : 0x%X = 0x%08x\n", 
-                ETH_TX_QUEUE_COMMAND_REG(port), 
-                MV_REG_READ( ETH_TX_QUEUE_COMMAND_REG(port) ) );    
-    
-    mvOsPrintf("ETH_TX_FIXED_PRIO_CFG_REG           : 0x%X = 0x%08x\n", 
-                ETH_TX_FIXED_PRIO_CFG_REG(port), 
+    mvOsPrintf("ETH_TX_QUEUE_COMMAND_REG            : 0x%X = 0x%08x\n",
+                ETH_TX_QUEUE_COMMAND_REG(port),
+                MV_REG_READ( ETH_TX_QUEUE_COMMAND_REG(port) ) );
+
+    mvOsPrintf("ETH_TX_FIXED_PRIO_CFG_REG           : 0x%X = 0x%08x\n",
+                ETH_TX_FIXED_PRIO_CFG_REG(port),
                 MV_REG_READ( ETH_TX_FIXED_PRIO_CFG_REG(port) ) );
 
-    mvOsPrintf("ETH_TX_TOKEN_RATE_CFG_REG           : 0x%X = 0x%08x\n", 
-                ETH_TX_TOKEN_RATE_CFG_REG(port), 
+    mvOsPrintf("ETH_TX_TOKEN_RATE_CFG_REG           : 0x%X = 0x%08x\n",
+                ETH_TX_TOKEN_RATE_CFG_REG(port),
                 MV_REG_READ( ETH_TX_TOKEN_RATE_CFG_REG(port) ) );
 
-    mvOsPrintf("ETH_MAX_TRANSMIT_UNIT_REG           : 0x%X = 0x%08x\n", 
-                ETH_MAX_TRANSMIT_UNIT_REG(port), 
+    mvOsPrintf("ETH_MAX_TRANSMIT_UNIT_REG           : 0x%X = 0x%08x\n",
+                ETH_MAX_TRANSMIT_UNIT_REG(port),
                 MV_REG_READ( ETH_MAX_TRANSMIT_UNIT_REG(port) ) );
 
-    mvOsPrintf("ETH_TX_TOKEN_BUCKET_SIZE_REG        : 0x%X = 0x%08x\n", 
-                ETH_TX_TOKEN_BUCKET_SIZE_REG(port), 
+    mvOsPrintf("ETH_TX_TOKEN_BUCKET_SIZE_REG        : 0x%X = 0x%08x\n",
+                ETH_TX_TOKEN_BUCKET_SIZE_REG(port),
                 MV_REG_READ( ETH_TX_TOKEN_BUCKET_SIZE_REG(port) ) );
 
-    mvOsPrintf("ETH_TX_TOKEN_BUCKET_COUNT_REG       : 0x%X = 0x%08x\n", 
-                ETH_TX_TOKEN_BUCKET_COUNT_REG(port), 
-                MV_REG_READ( ETH_TX_TOKEN_BUCKET_COUNT_REG(port) ) );
-
+    mvOsPrintf("ETH_TX_TOKEN_BUCKET_COUNT_REG       : 0x%X = 0x%08x\n",
+                ETH_TX_TOKEN_BUCKET_COUNT_REG(port),
+                MV_REG_READ( ETH_TX_TOKEN_BUCKET_COUNT_REG(port) ) );
+
     for(queue=0; queue<MV_ETH_MAX_TXQ; queue++)
     {
         mvOsPrintf("\n\t TX policy Port #%d, Queue #%d configuration registers\n", port, queue);
 
-        mvOsPrintf("ETH_TXQ_TOKEN_COUNT_REG             : 0x%X = 0x%08x\n", 
-                ETH_TXQ_TOKEN_COUNT_REG(port, queue), 
+        mvOsPrintf("ETH_TXQ_TOKEN_COUNT_REG             : 0x%X = 0x%08x\n",
+                ETH_TXQ_TOKEN_COUNT_REG(port, queue),
                 MV_REG_READ( ETH_TXQ_TOKEN_COUNT_REG(port, queue) ) );
 
-        mvOsPrintf("ETH_TXQ_TOKEN_CFG_REG               : 0x%X = 0x%08x\n", 
-                ETH_TXQ_TOKEN_CFG_REG(port, queue), 
+        mvOsPrintf("ETH_TXQ_TOKEN_CFG_REG               : 0x%X = 0x%08x\n",
+                ETH_TXQ_TOKEN_CFG_REG(port, queue),
                 MV_REG_READ( ETH_TXQ_TOKEN_CFG_REG(port, queue) ) );
 
-        mvOsPrintf("ETH_TXQ_ARBITER_CFG_REG             : 0x%X = 0x%08x\n", 
-                ETH_TXQ_ARBITER_CFG_REG(port, queue), 
+        mvOsPrintf("ETH_TXQ_ARBITER_CFG_REG             : 0x%X = 0x%08x\n",
+                ETH_TXQ_ARBITER_CFG_REG(port, queue),
                 MV_REG_READ( ETH_TXQ_ARBITER_CFG_REG(port, queue) ) );
-    }
+    }
     mvOsPrintf("\n");
 }
 
@@ -237,95 +237,95 @@ void    ethPortRegs(int port)
 {
     mvOsPrintf("\n\t ethGiga #%d port Registers:\n", port);
 
-    mvOsPrintf("ETH_PORT_STATUS_REG                 : 0x%X = 0x%08x\n", 
-                ETH_PORT_STATUS_REG(port), 
+    mvOsPrintf("ETH_PORT_STATUS_REG                 : 0x%X = 0x%08x\n",
+                ETH_PORT_STATUS_REG(port),
                 MV_REG_READ( ETH_PORT_STATUS_REG(port) ) );
 
-    mvOsPrintf("ETH_PORT_SERIAL_CTRL_REG            : 0x%X = 0x%08x\n", 
-                ETH_PORT_SERIAL_CTRL_REG(port), 
+    mvOsPrintf("ETH_PORT_SERIAL_CTRL_REG            : 0x%X = 0x%08x\n",
+                ETH_PORT_SERIAL_CTRL_REG(port),
                 MV_REG_READ( ETH_PORT_SERIAL_CTRL_REG(port) ) );
 
-    mvOsPrintf("ETH_PORT_CONFIG_REG                 : 0x%X = 0x%08x\n", 
-                ETH_PORT_CONFIG_REG(port), 
-                MV_REG_READ( ETH_PORT_CONFIG_REG(port) ) );    
+    mvOsPrintf("ETH_PORT_CONFIG_REG                 : 0x%X = 0x%08x\n",
+                ETH_PORT_CONFIG_REG(port),
+                MV_REG_READ( ETH_PORT_CONFIG_REG(port) ) );
 
-    mvOsPrintf("ETH_PORT_CONFIG_EXTEND_REG          : 0x%X = 0x%08x\n", 
-                ETH_PORT_CONFIG_EXTEND_REG(port), 
-                MV_REG_READ( ETH_PORT_CONFIG_EXTEND_REG(port) ) );    
+    mvOsPrintf("ETH_PORT_CONFIG_EXTEND_REG          : 0x%X = 0x%08x\n",
+                ETH_PORT_CONFIG_EXTEND_REG(port),
+                MV_REG_READ( ETH_PORT_CONFIG_EXTEND_REG(port) ) );
 
-    mvOsPrintf("ETH_SDMA_CONFIG_REG                 : 0x%X = 0x%08x\n", 
-                ETH_SDMA_CONFIG_REG(port), 
-                MV_REG_READ( ETH_SDMA_CONFIG_REG(port) ) );    
+    mvOsPrintf("ETH_SDMA_CONFIG_REG                 : 0x%X = 0x%08x\n",
+                ETH_SDMA_CONFIG_REG(port),
+                MV_REG_READ( ETH_SDMA_CONFIG_REG(port) ) );
 
-    mvOsPrintf("ETH_TX_FIFO_URGENT_THRESH_REG       : 0x%X = 0x%08x\n", 
-                ETH_TX_FIFO_URGENT_THRESH_REG(port), 
-                MV_REG_READ( ETH_TX_FIFO_URGENT_THRESH_REG(port) ) );    
+    mvOsPrintf("ETH_TX_FIFO_URGENT_THRESH_REG       : 0x%X = 0x%08x\n",
+                ETH_TX_FIFO_URGENT_THRESH_REG(port),
+                MV_REG_READ( ETH_TX_FIFO_URGENT_THRESH_REG(port) ) );
 
-    mvOsPrintf("ETH_RX_QUEUE_COMMAND_REG            : 0x%X = 0x%08x\n", 
-                ETH_RX_QUEUE_COMMAND_REG(port), 
-                MV_REG_READ( ETH_RX_QUEUE_COMMAND_REG(port) ) );    
+    mvOsPrintf("ETH_RX_QUEUE_COMMAND_REG            : 0x%X = 0x%08x\n",
+                ETH_RX_QUEUE_COMMAND_REG(port),
+                MV_REG_READ( ETH_RX_QUEUE_COMMAND_REG(port) ) );
 
-    mvOsPrintf("ETH_TX_QUEUE_COMMAND_REG            : 0x%X = 0x%08x\n", 
-                ETH_TX_QUEUE_COMMAND_REG(port), 
-                MV_REG_READ( ETH_TX_QUEUE_COMMAND_REG(port) ) );    
+    mvOsPrintf("ETH_TX_QUEUE_COMMAND_REG            : 0x%X = 0x%08x\n",
+                ETH_TX_QUEUE_COMMAND_REG(port),
+                MV_REG_READ( ETH_TX_QUEUE_COMMAND_REG(port) ) );
 
-    mvOsPrintf("ETH_INTR_CAUSE_REG                  : 0x%X = 0x%08x\n", 
-                ETH_INTR_CAUSE_REG(port), 
-                MV_REG_READ( ETH_INTR_CAUSE_REG(port) ) );    
+    mvOsPrintf("ETH_INTR_CAUSE_REG                  : 0x%X = 0x%08x\n",
+                ETH_INTR_CAUSE_REG(port),
+                MV_REG_READ( ETH_INTR_CAUSE_REG(port) ) );
 
-    mvOsPrintf("ETH_INTR_EXTEND_CAUSE_REG           : 0x%X = 0x%08x\n", 
-                ETH_INTR_CAUSE_EXT_REG(port), 
-                MV_REG_READ( ETH_INTR_CAUSE_EXT_REG(port) ) );    
+    mvOsPrintf("ETH_INTR_EXTEND_CAUSE_REG           : 0x%X = 0x%08x\n",
+                ETH_INTR_CAUSE_EXT_REG(port),
+                MV_REG_READ( ETH_INTR_CAUSE_EXT_REG(port) ) );
 
-    mvOsPrintf("ETH_INTR_MASK_REG                   : 0x%X = 0x%08x\n", 
-                ETH_INTR_MASK_REG(port), 
-                MV_REG_READ( ETH_INTR_MASK_REG(port) ) );    
+    mvOsPrintf("ETH_INTR_MASK_REG                   : 0x%X = 0x%08x\n",
+                ETH_INTR_MASK_REG(port),
+                MV_REG_READ( ETH_INTR_MASK_REG(port) ) );
 
-    mvOsPrintf("ETH_INTR_EXTEND_MASK_REG            : 0x%X = 0x%08x\n", 
-                ETH_INTR_MASK_EXT_REG(port), 
-                MV_REG_READ( ETH_INTR_MASK_EXT_REG(port) ) );    
+    mvOsPrintf("ETH_INTR_EXTEND_MASK_REG            : 0x%X = 0x%08x\n",
+                ETH_INTR_MASK_EXT_REG(port),
+                MV_REG_READ( ETH_INTR_MASK_EXT_REG(port) ) );
 
-    mvOsPrintf("ETH_RX_DESCR_STAT_CMD_REG           : 0x%X = 0x%08x\n", 
-                ETH_RX_DESCR_STAT_CMD_REG(port, 0), 
-                MV_REG_READ( ETH_RX_DESCR_STAT_CMD_REG(port, 0) ) );    
+    mvOsPrintf("ETH_RX_DESCR_STAT_CMD_REG           : 0x%X = 0x%08x\n",
+                ETH_RX_DESCR_STAT_CMD_REG(port, 0),
+                MV_REG_READ( ETH_RX_DESCR_STAT_CMD_REG(port, 0) ) );
 
-    mvOsPrintf("ETH_RX_BYTE_COUNT_REG               : 0x%X = 0x%08x\n", 
-                ETH_RX_BYTE_COUNT_REG(port, 0), 
-                MV_REG_READ( ETH_RX_BYTE_COUNT_REG(port, 0) ) );    
+    mvOsPrintf("ETH_RX_BYTE_COUNT_REG               : 0x%X = 0x%08x\n",
+                ETH_RX_BYTE_COUNT_REG(port, 0),
+                MV_REG_READ( ETH_RX_BYTE_COUNT_REG(port, 0) ) );
 
-    mvOsPrintf("ETH_RX_BUF_PTR_REG                  : 0x%X = 0x%08x\n", 
-                ETH_RX_BUF_PTR_REG(port, 0), 
-                MV_REG_READ( ETH_RX_BUF_PTR_REG(port, 0) ) );    
+    mvOsPrintf("ETH_RX_BUF_PTR_REG                  : 0x%X = 0x%08x\n",
+                ETH_RX_BUF_PTR_REG(port, 0),
+                MV_REG_READ( ETH_RX_BUF_PTR_REG(port, 0) ) );
 
-    mvOsPrintf("ETH_RX_CUR_DESC_PTR_REG             : 0x%X = 0x%08x\n", 
-                ETH_RX_CUR_DESC_PTR_REG(port, 0), 
-                MV_REG_READ( ETH_RX_CUR_DESC_PTR_REG(port, 0) ) );    
+    mvOsPrintf("ETH_RX_CUR_DESC_PTR_REG             : 0x%X = 0x%08x\n",
+                ETH_RX_CUR_DESC_PTR_REG(port, 0),
+                MV_REG_READ( ETH_RX_CUR_DESC_PTR_REG(port, 0) ) );
 }
 
 
 /* Print Giga Ethernet UNIT registers */
 void    ethRegs(int port)
 {
-    mvOsPrintf("ETH_PHY_ADDR_REG               : 0x%X = 0x%08x\n", 
-                ETH_PHY_ADDR_REG(port), 
-                MV_REG_READ(ETH_PHY_ADDR_REG(port)) );    
-
-    mvOsPrintf("ETH_UNIT_INTR_CAUSE_REG        : 0x%X = 0x%08x\n", 
-                ETH_UNIT_INTR_CAUSE_REG(port), 
-                MV_REG_READ( ETH_UNIT_INTR_CAUSE_REG(port)) );    
-
-    mvOsPrintf("ETH_UNIT_INTR_MASK_REG         : 0x%X = 0x%08x\n", 
-                ETH_UNIT_INTR_MASK_REG(port), 
-                MV_REG_READ( ETH_UNIT_INTR_MASK_REG(port)) );    
-
-    mvOsPrintf("ETH_UNIT_ERROR_ADDR_REG        : 0x%X = 0x%08x\n", 
-                ETH_UNIT_ERROR_ADDR_REG(port), 
-                MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG(port)) );    
-
-    mvOsPrintf("ETH_UNIT_INT_ADDR_ERROR_REG    : 0x%X = 0x%08x\n", 
-                ETH_UNIT_INT_ADDR_ERROR_REG(port), 
-                MV_REG_READ(ETH_UNIT_INT_ADDR_ERROR_REG(port)) );    
-    
+    mvOsPrintf("ETH_PHY_ADDR_REG               : 0x%X = 0x%08x\n",
+                ETH_PHY_ADDR_REG(port),
+                MV_REG_READ(ETH_PHY_ADDR_REG(port)) );
+
+    mvOsPrintf("ETH_UNIT_INTR_CAUSE_REG        : 0x%X = 0x%08x\n",
+                ETH_UNIT_INTR_CAUSE_REG(port),
+                MV_REG_READ( ETH_UNIT_INTR_CAUSE_REG(port)) );
+
+    mvOsPrintf("ETH_UNIT_INTR_MASK_REG         : 0x%X = 0x%08x\n",
+                ETH_UNIT_INTR_MASK_REG(port),
+                MV_REG_READ( ETH_UNIT_INTR_MASK_REG(port)) );
+
+    mvOsPrintf("ETH_UNIT_ERROR_ADDR_REG        : 0x%X = 0x%08x\n",
+                ETH_UNIT_ERROR_ADDR_REG(port),
+                MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG(port)) );
+
+    mvOsPrintf("ETH_UNIT_INT_ADDR_ERROR_REG    : 0x%X = 0x%08x\n",
+                ETH_UNIT_INT_ADDR_ERROR_REG(port),
+                MV_REG_READ(ETH_UNIT_INT_ADDR_ERROR_REG(port)) );
+
 }
 
 /******************************************************************************/
@@ -369,29 +369,29 @@ void    ethPortCounters(int port)
 
     mvOsPrintf("\n\t Port #%d MIB Counters\n\n", port);
 
-    mvOsPrintf("GoodFramesReceived          = %u\n", 
+    mvOsPrintf("GoodFramesReceived          = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_GOOD_FRAMES_RECEIVED, NULL));
-    mvOsPrintf("BadFramesReceived           = %u\n", 
+    mvOsPrintf("BadFramesReceived           = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_BAD_FRAMES_RECEIVED, NULL));
-    mvOsPrintf("BroadcastFramesReceived     = %u\n", 
+    mvOsPrintf("BroadcastFramesReceived     = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_BROADCAST_FRAMES_RECEIVED, NULL));
-    mvOsPrintf("MulticastFramesReceived     = %u\n", 
+    mvOsPrintf("MulticastFramesReceived     = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_MULTICAST_FRAMES_RECEIVED, NULL));
 
-    regValue = mvEthMibCounterRead(pHndl, ETH_MIB_GOOD_OCTETS_RECEIVED_LOW, 
+    regValue = mvEthMibCounterRead(pHndl, ETH_MIB_GOOD_OCTETS_RECEIVED_LOW,
                                  &regValHigh);
-    mvOsPrintf("GoodOctetsReceived          = 0x%08x%08x\n", 
+    mvOsPrintf("GoodOctetsReceived          = 0x%08x%08x\n",
                regValHigh, regValue);
 
     mvOsPrintf("\n");
-    mvOsPrintf("GoodFramesSent              = %u\n", 
+    mvOsPrintf("GoodFramesSent              = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_GOOD_FRAMES_SENT, NULL));
-    mvOsPrintf("BroadcastFramesSent         = %u\n", 
+    mvOsPrintf("BroadcastFramesSent         = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_BROADCAST_FRAMES_SENT, NULL));
-    mvOsPrintf("MulticastFramesSent         = %u\n", 
+    mvOsPrintf("MulticastFramesSent         = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_MULTICAST_FRAMES_SENT, NULL));
 
-    regValue = mvEthMibCounterRead(pHndl, ETH_MIB_GOOD_OCTETS_SENT_LOW, 
+    regValue = mvEthMibCounterRead(pHndl, ETH_MIB_GOOD_OCTETS_SENT_LOW,
                                  &regValHigh);
     mvOsPrintf("GoodOctetsSent              = 0x%08x%08x\n", regValHigh, regValue);
 
@@ -424,7 +424,7 @@ void    ethPortCounters(int port)
 
     regValue = mvEthMibCounterRead(pHndl, ETH_MIB_OVERSIZE_RECEIVED, NULL);
     mvOsPrintf("OversizeFramesReceived      = %u\n", regValue);
-    
+
     regValue = mvEthMibCounterRead(pHndl, ETH_MIB_JABBER_RECEIVED, NULL);
     mvOsPrintf("JabbersReceived             = %u\n", regValue);
 
@@ -468,17 +468,17 @@ void    ethPortRmonCounters(int port)
 
     mvOsPrintf("\n\t Port #%d RMON MIB Counters\n\n", port);
 
-    mvOsPrintf("64 ByteFramesReceived           = %u\n", 
+    mvOsPrintf("64 ByteFramesReceived           = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_FRAMES_64_OCTETS, NULL));
-    mvOsPrintf("65...127 ByteFramesReceived     = %u\n", 
+    mvOsPrintf("65...127 ByteFramesReceived     = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_FRAMES_65_TO_127_OCTETS, NULL));
-    mvOsPrintf("128...255 ByteFramesReceived    = %u\n", 
+    mvOsPrintf("128...255 ByteFramesReceived    = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_FRAMES_128_TO_255_OCTETS, NULL));
-    mvOsPrintf("256...511 ByteFramesReceived    = %u\n", 
+    mvOsPrintf("256...511 ByteFramesReceived    = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_FRAMES_256_TO_511_OCTETS, NULL));
-    mvOsPrintf("512...1023 ByteFramesReceived   = %u\n", 
+    mvOsPrintf("512...1023 ByteFramesReceived   = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_FRAMES_512_TO_1023_OCTETS, NULL));
-    mvOsPrintf("1024...Max ByteFramesReceived   = %u\n", 
+    mvOsPrintf("1024...Max ByteFramesReceived   = %u\n",
               mvEthMibCounterRead(pHndl, ETH_MIB_FRAMES_1024_TO_MAX_OCTETS, NULL));
 }
 
@@ -495,7 +495,7 @@ void    ethPortStatus(int port)
 }
 
 /* Print port queues information */
-void    ethPortQueues(int port, int rxQueue, int txQueue, int mode)  
+void    ethPortQueues(int port, int rxQueue, int txQueue, int mode)
 {
     void*   pHndl;
 
@@ -527,10 +527,10 @@ void    ethPortUcastShow(int port)
 
     macL = MV_REG_READ(ETH_MAC_ADDR_LOW_REG(port));
     macH = MV_REG_READ(ETH_MAC_ADDR_HIGH_REG(port));
- 
-    mvOsPrintf("\n\t Port #%d Unicast MAC table: %02x:%02x:%02x:%02x:%02x:%02x\n\n", 
+
+    mvOsPrintf("\n\t Port #%d Unicast MAC table: %02x:%02x:%02x:%02x:%02x:%02x\n\n",
                 port, ((macH >> 24) & 0xff), ((macH >> 16) & 0xff),
-                      ((macH >> 8) & 0xff), (macH  & 0xff), 
+                      ((macH >> 8) & 0xff), (macH  & 0xff),
                       ((macL >> 8) & 0xff), (macL  & 0xff) );
 
     for (i=0; i<4; i++)
@@ -540,11 +540,11 @@ void    ethPortUcastShow(int port)
         {
             MV_U8   macEntry = (unicastReg >> (8*j)) & 0xFF;
 
-            mvOsPrintf("%X: %8s, Q = %d\n", i*4+j, 
+            mvOsPrintf("%X: %8s, Q = %d\n", i*4+j,
                 (macEntry & BIT0) ? "Accept" : "Reject", (macEntry >> 1) & 0x7);
         }
     }
-} 
+}
 
 void    ethMcastAdd(int port, char* macStr, int queue)
 {
@@ -564,7 +564,7 @@ void    ethPortMcast(int port)
     int     tblIdx, regIdx;
     MV_U32  regVal;
 
-    mvOsPrintf("\n\t Port #%d Special (IP) Multicast table: 01:00:5E:00:00:XX\n\n", 
+    mvOsPrintf("\n\t Port #%d Special (IP) Multicast table: 01:00:5E:00:00:XX\n\n",
                 port);
 
     for(tblIdx=0; tblIdx<(256/4); tblIdx++)
@@ -574,7 +574,7 @@ void    ethPortMcast(int port)
         {
             if((regVal & (0x01 << (regIdx*8))) != 0)
             {
-                mvOsPrintf("0x%02X: Accepted, rxQ = %d\n", 
+                mvOsPrintf("0x%02X: Accepted, rxQ = %d\n",
                     tblIdx*4+regIdx, ((regVal >> (regIdx*8+1)) & 0x07));
             }
         }
@@ -587,7 +587,7 @@ void    ethPortMcast(int port)
         {
             if((regVal & (0x01 << (regIdx*8))) != 0)
             {
-                mvOsPrintf("Crc8=0x%02X: Accepted, rxQ = %d\n", 
+                mvOsPrintf("Crc8=0x%02X: Accepted, rxQ = %d\n",
                     tblIdx*4+regIdx, ((regVal >> (regIdx*8+1)) & 0x07));
             }
         }
@@ -606,10 +606,10 @@ void    mvEthPortShow(void* pHndl)
 
     regValue = MV_REG_READ( ETH_PORT_STATUS_REG(port) );
 
-    mvOsPrintf("\n\t ethGiga #%d port Status: 0x%04x = 0x%08x\n\n", 
+    mvOsPrintf("\n\t ethGiga #%d port Status: 0x%04x = 0x%08x\n\n",
                 port, ETH_PORT_STATUS_REG(port), regValue);
 
-    mvOsPrintf("descInSram=%d, descSwCoher=%d\n", 
+    mvOsPrintf("descInSram=%d, descSwCoher=%d\n",
                 ethDescInSram, ethDescSwCoher);
 
     if(regValue & ETH_GMII_SPEED_1000_MASK)
@@ -624,38 +624,38 @@ void    mvEthPortShow(void* pHndl)
     /* Link, Speed, Duplex, FlowControl */
     mvOsPrintf("Link=%s, Speed=%d, Duplex=%s, RxFlowControl=%s",
                 (regValue & ETH_LINK_UP_MASK) ? "UP" : "DOWN",
-                speed, 
+                speed,
                 (regValue & ETH_FULL_DUPLEX_MASK) ? "FULL" : "HALF",
                 (regValue & ETH_ENABLE_RCV_FLOW_CTRL_MASK) ? "ENABLE" : "DISABLE");
 
     mvOsPrintf("\n");
 
-    mvOsPrintf("RxCoal = %d usec, TxCoal = %d usec\n", 
+    mvOsPrintf("RxCoal = %d usec, TxCoal = %d usec\n",
                 rxCoal, txCoal);
 
-    mvOsPrintf("rxDefQ=%d, arpQ=%d, bpduQ=%d, tcpQ=%d, udpQ=%d\n\n",
-                pPortCtrl->portConfig.rxDefQ, pPortCtrl->portConfig.rxArpQ, 
-                pPortCtrl->portConfig.rxBpduQ, 
-                pPortCtrl->portConfig.rxTcpQ, pPortCtrl->portConfig.rxUdpQ); 
-
+    mvOsPrintf("rxDefQ=%d, arpQ=%d, bpduQ=%d, tcpQ=%d, udpQ=%d\n\n",
+                pPortCtrl->portConfig.rxDefQ, pPortCtrl->portConfig.rxArpQ,
+                pPortCtrl->portConfig.rxBpduQ,
+                pPortCtrl->portConfig.rxTcpQ, pPortCtrl->portConfig.rxUdpQ);
+
     /* Print all RX and TX queues */
     for(queue=0; queue<MV_ETH_RX_Q_NUM; queue++)
     {
-        mvOsPrintf("RX Queue #%d: base=0x%lx, free=%d\n", 
+        mvOsPrintf("RX Queue #%d: base=0x%lx, free=%d\n",
                     queue, (MV_ULONG)pPortCtrl->rxQueue[queue].pFirstDescr,
                     mvEthRxResourceGet(pPortCtrl, queue) );
     }
     mvOsPrintf("\n");
     for(queue=0; queue<MV_ETH_TX_Q_NUM; queue++)
     {
-        mvOsPrintf("TX Queue #%d: base=0x%lx, free=%d\n", 
+        mvOsPrintf("TX Queue #%d: base=0x%lx, free=%d\n",
                 queue, (MV_ULONG)pPortCtrl->txQueue[queue].pFirstDescr,
                 mvEthTxResourceGet(pPortCtrl, queue) );
     }
 }
 
 /* Print RX and TX queue of the Ethernet port */
-void    mvEthQueuesShow(void* pHndl, int rxQueue, int txQueue, int mode)  
+void    mvEthQueuesShow(void* pHndl, int rxQueue, int txQueue, int mode)
 {
     ETH_PORT_CTRL   *pPortCtrl = (ETH_PORT_CTRL*)pHndl;
     ETH_QUEUE_CTRL  *pQueueCtrl;
@@ -669,30 +669,30 @@ void    mvEthQueuesShow(void* pHndl, int rxQueue, int txQueue, int mode)
         pQueueCtrl = &(pPortCtrl->rxQueue[rxQueue]);
         mvOsPrintf("Port #%d, RX Queue #%d\n\n", port, rxQueue);
 
-        mvOsPrintf("CURR_RX_DESC_PTR        : 0x%X = 0x%08x\n", 
-            ETH_RX_CUR_DESC_PTR_REG(port, rxQueue), 
+        mvOsPrintf("CURR_RX_DESC_PTR        : 0x%X = 0x%08x\n",
+            ETH_RX_CUR_DESC_PTR_REG(port, rxQueue),
             MV_REG_READ( ETH_RX_CUR_DESC_PTR_REG(port, rxQueue)));
 
 
         if(pQueueCtrl->pFirstDescr != NULL)
         {
             mvOsPrintf("pFirstDescr=0x%lx, pLastDescr=0x%lx, numOfResources=%d\n",
-                (MV_ULONG)pQueueCtrl->pFirstDescr, (MV_ULONG)pQueueCtrl->pLastDescr, 
+                (MV_ULONG)pQueueCtrl->pFirstDescr, (MV_ULONG)pQueueCtrl->pLastDescr,
                 pQueueCtrl->resource);
             mvOsPrintf("pCurrDescr: 0x%lx, pUsedDescr: 0x%lx\n",
-                (MV_ULONG)pQueueCtrl->pCurrentDescr, 
+                (MV_ULONG)pQueueCtrl->pCurrentDescr,
                 (MV_ULONG)pQueueCtrl->pUsedDescr);
 
             if(mode == 1)
             {
                 pRxDescr = (ETH_RX_DESC*)pQueueCtrl->pFirstDescr;
-                i = 0; 
-                do 
+                i = 0;
+                do
                 {
-                    mvOsPrintf("%3d. desc=%08x (%08x), cmd=%08x, data=%4d, buf=%4d, buf=%08x, pkt=%lx, os=%lx\n", 
-                                i, (MV_U32)pRxDescr, (MV_U32)ethDescVirtToPhy(pQueueCtrl, (MV_U8*)pRxDescr), 
-                                pRxDescr->cmdSts, pRxDescr->byteCnt, (MV_U32)pRxDescr->bufSize, 
-                                (unsigned int)pRxDescr->bufPtr, (MV_ULONG)pRxDescr->returnInfo,
+                    mvOsPrintf("%3d. desc=%08x (%08x), cmd=%08x, data=%4d, buf=%4d, buf=%08x, pkt=%lx, os=%lx\n",
+                                i, (MV_U32)pRxDescr, (MV_U32)ethDescVirtToPhy(pQueueCtrl, (MV_U8*)pRxDescr),
+                                pRxDescr->cmdSts, pRxDescr->byteCnt, (MV_U32)pRxDescr->bufSize,
+                                (unsigned int)pRxDescr->bufPtr, (MV_ULONG)pRxDescr->returnInfo,
                                 ((MV_PKT_INFO*)pRxDescr->returnInfo)->osInfo);
 
                     ETH_DESCR_INV(pPortCtrl, pRxDescr);
@@ -711,29 +711,29 @@ void    mvEthQueuesShow(void* pHndl, int rxQueue, int txQueue, int mode)
         mvOsPrintf("Port #%d, TX Queue #%d\n\n", port, txQueue);
 
         regValue = MV_REG_READ( ETH_TX_CUR_DESC_PTR_REG(port, txQueue));
-        mvOsPrintf("CURR_TX_DESC_PTR        : 0x%X = 0x%08x\n", 
+        mvOsPrintf("CURR_TX_DESC_PTR        : 0x%X = 0x%08x\n",
                     ETH_TX_CUR_DESC_PTR_REG(port, txQueue), regValue);
 
         if(pQueueCtrl->pFirstDescr != NULL)
         {
             mvOsPrintf("pFirstDescr=0x%lx, pLastDescr=0x%lx, numOfResources=%d\n",
-                       (MV_ULONG)pQueueCtrl->pFirstDescr, 
-                       (MV_ULONG)pQueueCtrl->pLastDescr, 
+                       (MV_ULONG)pQueueCtrl->pFirstDescr,
+                       (MV_ULONG)pQueueCtrl->pLastDescr,
                         pQueueCtrl->resource);
             mvOsPrintf("pCurrDescr: 0x%lx, pUsedDescr: 0x%lx\n",
-                       (MV_ULONG)pQueueCtrl->pCurrentDescr, 
+                       (MV_ULONG)pQueueCtrl->pCurrentDescr,
                        (MV_ULONG)pQueueCtrl->pUsedDescr);
 
             if(mode == 1)
             {
                 pTxDescr = (ETH_TX_DESC*)pQueueCtrl->pFirstDescr;
-                i = 0; 
-                do 
+                i = 0;
+                do
                 {
-                    mvOsPrintf("%3d. desc=%08x (%08x), cmd=%08x, data=%4d, buf=%08x, pkt=%lx, os=%lx\n", 
-                                i, (MV_U32)pTxDescr, (MV_U32)ethDescVirtToPhy(pQueueCtrl, (MV_U8*)pTxDescr), 
-                                pTxDescr->cmdSts, pTxDescr->byteCnt, 
-                                (MV_U32)pTxDescr->bufPtr, (MV_ULONG)pTxDescr->returnInfo,
+                    mvOsPrintf("%3d. desc=%08x (%08x), cmd=%08x, data=%4d, buf=%08x, pkt=%lx, os=%lx\n",
+                                i, (MV_U32)pTxDescr, (MV_U32)ethDescVirtToPhy(pQueueCtrl, (MV_U8*)pTxDescr),
+                                pTxDescr->cmdSts, pTxDescr->byteCnt,
+                                (MV_U32)pTxDescr->bufPtr, (MV_ULONG)pTxDescr->returnInfo,
                                 pTxDescr->returnInfo ? (((MV_PKT_INFO*)pTxDescr->returnInfo)->osInfo) : 0x0);
 
                     ETH_DESCR_INV(pPortCtrl, pTxDescr);
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.h b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.h
index f026f96..4a90043 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthDebug.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -122,7 +122,7 @@ void    ethRxCoal(int port, int usec);
 void    ethTxCoal(int port, int usec);
 #if (MV_ETH_VERSION >= 4)
 void     ethEjpModeSet(int port, int mode);
-#endif /* (MV_ETH_VERSION >= 4) */
+#endif /* (MV_ETH_VERSION >= 4) */
 
 void    ethBpduRxQ(int port, int bpduQueue);
 void    ethArpRxQ(int port, int arpQueue);
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h
index f4cae50..83ad6ad 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -66,7 +66,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * mvEth.h - Header File for : Marvell Gigabit Ethernet Controller
 *
 * DESCRIPTION:
-*       This header file contains macros typedefs and function declaration specific to 
+*       This header file contains macros typedefs and function declaration specific to
 *       the Marvell Gigabit Ethernet Controller.
 *
 * DEPENDENCIES:
@@ -129,11 +129,11 @@ static INLINE int      mvEthPortTxEnable(void* pPortHndl, int queue, int max_dee
             int count = 0;
 
             while( (txEnReg & MV_32BIT_LE_FAST(ETH_TXQ_ENABLE_MASK)) != 0)
-            {   
+            {
                 count++;
                 if(count > 10000)
                 {
-                    mvOsPrintf("mvEthPortTxEnable: timeout - TXQ_CMD=0x%08x\n", 
+                    mvOsPrintf("mvEthPortTxEnable: timeout - TXQ_CMD=0x%08x\n",
                                 MV_REG_READ(ETH_TX_QUEUE_COMMAND_REG(pPortCtrl->portNo)) );
                     break;
                 }
@@ -215,7 +215,7 @@ static INLINE int      mvEthPortTxEnable(void* pPortHndl, int queue, int max_dee
             BIT9                                        |   \
             ETH_IN_BAND_AN_EN_MASK                      |   \
             ETH_DO_NOT_FORCE_LINK_FAIL_MASK             |   \
-            ETH_MAX_RX_PACKET_1552BYTE                  
+            ETH_MAX_RX_PACKET_1552BYTE
 
 /* Function headers: */
 MV_VOID     mvEthSetSpecialMcastTable(int portNo, int queue);
@@ -245,7 +245,7 @@ static INLINE int     mvEthTxResourceGet(void* pPortHndl, int txQueue)
 {
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pPortHndl;
 
-    return (pPortCtrl->txQueue[txQueue].resource);      
+    return (pPortCtrl->txQueue[txQueue].resource);
 }
 
 /* Get number of Free resources in specific RX queue */
@@ -253,7 +253,7 @@ static INLINE int     mvEthRxResourceGet(void* pPortHndl, int rxQueue)
 {
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pPortHndl;
 
-    return (pPortCtrl->rxQueue[rxQueue].resource);      
+    return (pPortCtrl->rxQueue[rxQueue].resource);
 }
 
 static INLINE int     mvEthTxQueueIsFull(void* pPortHndl, int txQueue)
@@ -272,7 +272,7 @@ static INLINE int     mvEthRxQueueIsFull(void* pPortHndl, int rxQueue)
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pPortHndl;
     ETH_QUEUE_CTRL* pQueueCtrl = &pPortCtrl->rxQueue[rxQueue];
 
-    if( (pQueueCtrl->pUsedDescr == pQueueCtrl->pCurrentDescr) && 
+    if( (pQueueCtrl->pUsedDescr == pQueueCtrl->pCurrentDescr) &&
         (pQueueCtrl->resource != 0) )
         return MV_TRUE;
 
@@ -307,7 +307,7 @@ static INLINE int     mvEthRxQueueIsEmpty(void* pPortHndl, int rxQueue)
 * mvEthPortTx - Send an Ethernet packet
 *
 * DESCRIPTION:
-*       This routine send a given packet described by pPktInfo parameter. 
+*       This routine send a given packet described by pPktInfo parameter.
 *       Single buffer only.
 *
 * INPUT:
@@ -389,7 +389,7 @@ static INLINE MV_STATUS   mvEthPortTx(void* pEthPortHndl, int txQueue, MV_PKT_IN
 *
 * DESCRIPTION:
 *       This routine send a given packet described by pBufInfo parameter. It
-*       supports transmitting of a packet spaned over multiple buffers. 
+*       supports transmitting of a packet spaned over multiple buffers.
 *
 * INPUT:
 *       void*       pEthPortHndl  - Ethernet Port handler.
@@ -432,13 +432,13 @@ static INLINE MV_STATUS   mvEthPortSgTx(void* pEthPortHndl, int txQueue, MV_PKT_
 
     bufCount = 0;
     while(MV_TRUE)
-    {   
+    {
         if(pBufInfo[bufCount].dataSize <= MIN_TX_BUFF_LOAD)
         {
             /* Buffers with a payload smaller than MIN_TX_BUFF_LOAD (8 bytes) must be aligned    */
             /* to 64-bit boundary. Two options here:                                             */
             /* 1) Usually, copy the payload to the reserved 8 bytes inside descriptor.           */
-            /* 2) In the Half duplex workaround, the reserved 8 bytes inside descriptor are used */ 
+            /* 2) In the Half duplex workaround, the reserved 8 bytes inside descriptor are used */
             /*    as a pointer to the aligned buffer, copy the small payload to this buffer.     */
             pTxBuf = ((MV_U8*)pTxCurrDesc)+TX_BUF_OFFSET_IN_DESC;
             mvOsBCopy(pBufInfo[bufCount].bufVirtPtr, pTxBuf, pBufInfo[bufCount].dataSize);
@@ -472,7 +472,7 @@ static INLINE MV_STATUS   mvEthPortSgTx(void* pEthPortHndl, int txQueue, MV_PKT_
     }
     /* Set last desc with DMA ownership and interrupt enable. */
     pTxCurrDesc->returnInfo = (MV_ULONG)pPktInfo;
-    if(bufCount == 1) 
+    if(bufCount == 1)
     {
         /* There is only one buffer in the packet */
         /* The OSG might set some bits for checksum offload, so add them to first descriptor */
@@ -532,7 +532,7 @@ static INLINE MV_STATUS   mvEthPortSgTx(void* pEthPortHndl, int txQueue, MV_PKT_
 *       MV_NOT_FOUND    - No transmitted packets to return. Transmit in progress.
 *       MV_EMPTY        - No transmitted packets to return. TX Queue is empty.
 *       MV_ERROR        - Unexpected Fatal error.
-*       MV_OK           - There is transmitted packet in the queue, 
+*       MV_OK           - There is transmitted packet in the queue,
 *                       'pPktInfo' filled with relevant information.
 *
 *******************************************************************************/
@@ -555,7 +555,7 @@ static INLINE MV_PKT_INFO*    mvEthPortTxDone(void* pEthPortHndl, int txQueue)
         /* No more used descriptors */
         commandStatus = pTxUsedDesc->cmdSts;
         if (commandStatus  & (ETH_BUFFER_OWNED_BY_DMA))
-        {    
+        {
             ETH_DESCR_INV(pPortCtrl, pTxUsedDesc);
             return NULL;
         }
@@ -566,10 +566,10 @@ static INLINE MV_PKT_INFO*    mvEthPortTxDone(void* pEthPortHndl, int txQueue)
         }
         pQueueCtrl->resource++;
         pQueueCtrl->pUsedDescr = TX_NEXT_DESC_PTR(pTxUsedDesc, pQueueCtrl);
-        if(commandStatus & (ETH_TX_LAST_DESC_MASK)) 
+        if(commandStatus & (ETH_TX_LAST_DESC_MASK))
         {
             pPktInfo = (MV_PKT_INFO*)pTxUsedDesc->returnInfo;
-            pPktInfo->status  = commandStatus;            
+            pPktInfo->status  = commandStatus;
             return pPktInfo;
         }
         pTxUsedDesc = pQueueCtrl->pUsedDescr;
@@ -628,7 +628,7 @@ static INLINE MV_PKT_INFO*    mvEthPortRx(void* pEthPortHndl, int rxQueue)
         }
 
         /* Valid RX only if FIRST and LAST bits are set */
-        if( (commandStatus & (ETH_RX_LAST_DESC_MASK | ETH_RX_FIRST_DESC_MASK)) == 
+        if( (commandStatus & (ETH_RX_LAST_DESC_MASK | ETH_RX_FIRST_DESC_MASK)) ==
                              (ETH_RX_LAST_DESC_MASK | ETH_RX_FIRST_DESC_MASK) )
         {
             pPktInfo = (MV_PKT_INFO*)pRxCurrDesc->returnInfo;
@@ -651,7 +651,7 @@ static INLINE MV_PKT_INFO*    mvEthPortRx(void* pEthPortHndl, int rxQueue)
 
 #ifdef ETH_DEBUG
             mvOsPrintf("ethDrv: Unexpected Jumbo frame: "
-                       "status=0x%08x, byteCnt=%d, pData=0x%x\n", 
+                       "status=0x%08x, byteCnt=%d, pData=0x%x\n",
                         commandStatus, pRxCurrDesc->byteCnt, pRxCurrDesc->bufPtr);
 #endif /* ETH_DEBUG */
 
@@ -661,7 +661,7 @@ static INLINE MV_PKT_INFO*    mvEthPortRx(void* pEthPortHndl, int rxQueue)
             pRxUsedDesc->bufSize    = pRxCurrDesc->bufSize & ETH_RX_BUFFER_MASK;
 
             /* Return the descriptor to DMA ownership */
-            pRxUsedDesc->cmdSts = ETH_BUFFER_OWNED_BY_DMA | 
+            pRxUsedDesc->cmdSts = ETH_BUFFER_OWNED_BY_DMA |
                                   ETH_RX_ENABLE_INTERRUPT_MASK;
 
             /* Flush descriptor and CPU pipe */
@@ -669,7 +669,7 @@ static INLINE MV_PKT_INFO*    mvEthPortRx(void* pEthPortHndl, int rxQueue)
 
             /* Move the used descriptor pointer to the next descriptor */
             pQueueCtrl->pUsedDescr = RX_NEXT_DESC_PTR(pRxUsedDesc, pQueueCtrl);
-            pQueueCtrl->pCurrentDescr = RX_NEXT_DESC_PTR(pRxCurrDesc, pQueueCtrl);            
+            pQueueCtrl->pCurrentDescr = RX_NEXT_DESC_PTR(pRxCurrDesc, pQueueCtrl);
         }
     }
 }
@@ -678,7 +678,7 @@ static INLINE MV_PKT_INFO*    mvEthPortRx(void* pEthPortHndl, int rxQueue)
 * mvEthPortRxDone - Returns a Rx buffer back to the Rx ring.
 *
 * DESCRIPTION:
-*       This routine returns a Rx buffer back to the Rx ring. 
+*       This routine returns a Rx buffer back to the Rx ring.
 *
 * INPUT:
 *       void*       pEthPortHndl    - Ethernet Port handler.
@@ -687,11 +687,11 @@ static INLINE MV_PKT_INFO*    mvEthPortRx(void* pEthPortHndl, int rxQueue)
 *
 * RETURN:
 *       MV_ERROR        - Unexpected Fatal error.
-*       MV_OUT_OF_RANGE - RX queue is already FULL, so this buffer can't be 
+*       MV_OUT_OF_RANGE - RX queue is already FULL, so this buffer can't be
 *                       returned to this queue.
 *       MV_FULL         - Buffer returned successfully and RX queue became full.
 *                       More buffers should not be returned at the time.
-*       MV_OK           - Buffer returned successfully and there are more free 
+*       MV_OK           - Buffer returned successfully and there are more free
 *                       places in the queue.
 *
 *******************************************************************************/
@@ -700,18 +700,18 @@ static INLINE MV_STATUS   mvEthPortRxDone(void* pEthPortHndl, int rxQueue, MV_PK
     ETH_RX_DESC*    pRxUsedDesc;
     ETH_QUEUE_CTRL* pQueueCtrl;
     ETH_PORT_CTRL*  pPortCtrl = (ETH_PORT_CTRL*)pEthPortHndl;
-            
+
     pQueueCtrl = &pPortCtrl->rxQueue[rxQueue];
 
     /* Get 'used' Rx descriptor */
     pRxUsedDesc = pQueueCtrl->pUsedDescr;
 
     /* Check that ring is not FULL */
-    if( (pQueueCtrl->pUsedDescr == pQueueCtrl->pCurrentDescr) && 
+    if( (pQueueCtrl->pUsedDescr == pQueueCtrl->pCurrentDescr) &&
         (pQueueCtrl->resource != 0) )
     {
-        mvOsPrintf("%s %d: out of range Error resource=%d, curr=%p, used=%p\n", 
-                    __FUNCTION__, pPortCtrl->portNo, pQueueCtrl->resource, 
+        mvOsPrintf("%s %d: out of range Error resource=%d, curr=%p, used=%p\n",
+                    __FUNCTION__, pPortCtrl->portNo, pQueueCtrl->resource,
                     pQueueCtrl->pCurrentDescr, pQueueCtrl->pUsedDescr);
         return MV_OUT_OF_RANGE;
     }
@@ -737,9 +737,9 @@ static INLINE MV_STATUS   mvEthPortRxDone(void* pEthPortHndl, int rxQueue, MV_PK
 
     /* Move the used descriptor pointer to the next descriptor */
     pQueueCtrl->pUsedDescr = RX_NEXT_DESC_PTR(pRxUsedDesc, pQueueCtrl);
-    
+
     /* If ring became Full return MV_FULL */
-    if(pQueueCtrl->pUsedDescr == pQueueCtrl->pCurrentDescr) 
+    if(pQueueCtrl->pUsedDescr == pQueueCtrl->pCurrentDescr)
         return MV_FULL;
 
     return MV_OK;
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthRegs.h
index 7b9f052..b610dd2 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer. 
+        this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -136,7 +136,7 @@ extern "C" {
 #define ETH_TXQ_TOKEN_CFG_REG(port, q)      (ETH_REG_BASE(port) + 0x704 + ((q)<<4))
 #define ETH_TXQ_ARBITER_CFG_REG(port, q)    (ETH_REG_BASE(port) + 0x708 + ((q)<<4))
 
-#if (MV_ETH_VERSION >= 4) 
+#if (MV_ETH_VERSION >= 4)
 #define ETH_TXQ_CMD_1_REG(port)             (ETH_REG_BASE(port) + 0x4E4)
 #define ETH_EJP_TX_HI_IPG_REG(port)         (ETH_REG_BASE(port) + 0x7A8)
 #define ETH_EJP_TX_LO_IPG_REG(port)         (ETH_REG_BASE(port) + 0x7B8)
@@ -152,9 +152,9 @@ extern "C" {
 #define ETH_DA_FILTER_UCAST_BASE(port)      (ETH_REG_BASE(port) + 0x1600)
 
 /* Phy address register definitions */
-#define ETH_PHY_ADDR_OFFS          0                                       
+#define ETH_PHY_ADDR_OFFS          0
 #define ETH_PHY_ADDR_MASK          (0x1f <<ETH_PHY_ADDR_OFFS)
-                                 
+
 /* MIB Counters register definitions */
 #define ETH_MIB_GOOD_OCTETS_RECEIVED_LOW    0x0
 #define ETH_MIB_GOOD_OCTETS_RECEIVED_HIGH   0x4
@@ -207,7 +207,7 @@ extern "C" {
 #define ETH_TXQ_DISABLE_OFFSET              8
 #define ETH_TXQ_DISABLE_MASK                (0x000000FF << ETH_TXQ_DISABLE_OFFSET)
 
-#if (MV_ETH_VERSION >= 4) 
+#if (MV_ETH_VERSION >= 4)
 #define ETH_TX_EJP_RESET_BIT                0
 #define ETH_TX_EJP_RESET_MASK               (1 << ETH_TX_EJP_RESET_BIT)
 
@@ -221,7 +221,7 @@ extern "C" {
 /***** BITs of Ethernet Port Status reg (PSR) *****/
 #define ETH_LINK_UP_BIT                     1
 #define ETH_LINK_UP_MASK                    (1<<ETH_LINK_UP_BIT)
-                     
+
 #define ETH_FULL_DUPLEX_BIT                 2
 #define ETH_FULL_DUPLEX_MASK                (1<<ETH_FULL_DUPLEX_BIT)
 
@@ -305,7 +305,7 @@ extern "C" {
 #define ETH_QUEUE_ENABLE_ALL_MASK           (0xFF<<ETH_QUEUE_ENABLE_OFFSET)
 #define ETH_QUEUE_ENABLE_MASK(queue)        (1<<((queue)+ETH_QUEUE_ENABLE_OFFSET))
 
-#define ETH_QUEUE_DISABLE_OFFSET            8 
+#define ETH_QUEUE_DISABLE_OFFSET            8
 #define ETH_QUEUE_DISABLE_ALL_MASK          (0xFF<<ETH_QUEUE_DISABLE_OFFSET)
 #define ETH_QUEUE_DISABLE_MASK(queue)       (1<<((queue)+ETH_QUEUE_DISABLE_OFFSET))
 
@@ -314,7 +314,7 @@ extern "C" {
 #define ETH_RX_FRAME_INTERRUPT_BIT          0
 #define ETH_RX_FRAME_INTERRUPT_MASK         (1<<ETH_RX_FRAME_INTERRUPT_BIT)
 
-#define ETH_BURST_SIZE_1_64BIT_VALUE        0   
+#define ETH_BURST_SIZE_1_64BIT_VALUE        0
 #define ETH_BURST_SIZE_2_64BIT_VALUE        1
 #define ETH_BURST_SIZE_4_64BIT_VALUE        2
 #define ETH_BURST_SIZE_8_64BIT_VALUE        3
@@ -346,7 +346,7 @@ extern "C" {
 #define ETH_TX_BURST_SIZE_MASK(burst)       ((burst)<<ETH_TX_BURST_SIZE_OFFSET)
 
 #define ETH_RX_INTR_COAL_MSB_BIT            25
-#define ETH_RX_INTR_COAL_MSB_MASK           (1<<ETH_RX_INTR_COAL_MSB_BIT)  
+#define ETH_RX_INTR_COAL_MSB_MASK           (1<<ETH_RX_INTR_COAL_MSB_BIT)
 
 /* BITs Port #x Tx FIFO Urgent Threshold (PxTFUT) */
 #define ETH_TX_INTR_COAL_OFFSET             4
@@ -389,10 +389,10 @@ extern "C" {
 #define ETH_DISABLE_SPEED_AUTO_NEG_BIT      13
 #define ETH_DISABLE_SPEED_AUTO_NEG_MASK     (1<<ETH_DISABLE_SPEED_AUTO_NEG_BIT)
 
-#define ETH_DTE_ADVERT_BIT                  14    
-#define ETH_DTE_ADVERT_MASK                 (1<<ETH_DTE_ADVERT_BIT)    
+#define ETH_DTE_ADVERT_BIT                  14
+#define ETH_DTE_ADVERT_MASK                 (1<<ETH_DTE_ADVERT_BIT)
 
-#define ETH_MII_PHY_MODE_BIT                15  
+#define ETH_MII_PHY_MODE_BIT                15
 #define ETH_MII_PHY_MODE_MAC                (0<<ETH_MII_PHY_MODE_BIT)
 #define ETH_MII_PHY_MODE_PHY                (1<<ETH_MII_PHY_MODE_BIT)
 
@@ -446,7 +446,7 @@ extern "C" {
 #define ETH_SGMII_MODE_BIT                  12
 #define ETH_1000BaseX_MODE_MASK             (0<<ETH_SGMII_MODE_BIT)
 #define ETH_SGMII_MODE_MASK                 (1<<ETH_SGMII_MODE_BIT)
-            
+
 #define ETH_MGMII_MODE_BIT                  13
 
 #define ETH_EN_MII_ODD_PRE_BIT		    22
@@ -510,7 +510,7 @@ typedef struct _ethTxDesc
 #define ETH_ERROR_SUMMARY_BIT               0
 #define ETH_ERROR_SUMMARY_MASK              (1<<ETH_ERROR_SUMMARY_BIT)
 
-#define ETH_BUFFER_OWNER_BIT                31             
+#define ETH_BUFFER_OWNER_BIT                31
 #define ETH_BUFFER_OWNED_BY_DMA             (1<<ETH_BUFFER_OWNER_BIT)
 #define ETH_BUFFER_OWNED_BY_HOST            (0<<ETH_BUFFER_OWNER_BIT)
 
@@ -625,12 +625,12 @@ typedef struct _ethTxDesc
 
 #define ETH_CAUSE_RX_READY_OFFSET           2
 #define ETH_CAUSE_RX_READY_BIT(queue)       (ETH_CAUSE_RX_READY_OFFSET + (queue))
-#define ETH_CAUSE_RX_READY_MASK(queue)      (1 << (ETH_CAUSE_RX_READY_BIT(queue))) 
+#define ETH_CAUSE_RX_READY_MASK(queue)      (1 << (ETH_CAUSE_RX_READY_BIT(queue)))
 
 #define ETH_CAUSE_RX_ERROR_SUM_BIT          10
 #define ETH_CAUSE_RX_ERROR_OFFSET           11
 #define ETH_CAUSE_RX_ERROR_BIT(queue)       (ETH_CAUSE_RX_ERROR_OFFSET + (queue))
-#define ETH_CAUSE_RX_ERROR_MASK(queue)      (1 << (ETH_CAUSE_RX_ERROR_BIT(queue))) 
+#define ETH_CAUSE_RX_ERROR_MASK(queue)      (1 << (ETH_CAUSE_RX_ERROR_BIT(queue)))
 
 #define ETH_CAUSE_TX_END_BIT                19
 #define ETH_CAUSE_SUM_BIT                   31
@@ -639,13 +639,13 @@ typedef struct _ethTxDesc
 #define ETH_CAUSE_TX_BUF_OFFSET             0
 #define ETH_CAUSE_TX_BUF_BIT(queue)         (ETH_CAUSE_TX_BUF_OFFSET + (queue))
 #define ETH_CAUSE_TX_BUF_MASK(queue)        (1 << (ETH_CAUSE_TX_BUF_BIT(queue)))
-         
+
 #define ETH_CAUSE_TX_ERROR_OFFSET           8
 #define ETH_CAUSE_TX_ERROR_BIT(queue)       (ETH_CAUSE_TX_ERROR_OFFSET + (queue))
 #define ETH_CAUSE_TX_ERROR_MASK(queue)      (1 << (ETH_CAUSE_TX_ERROR_BIT(queue)))
 
 #define ETH_CAUSE_PHY_STATUS_CHANGE_BIT     16
-#define ETH_CAUSE_RX_OVERRUN_BIT            18          
+#define ETH_CAUSE_RX_OVERRUN_BIT            18
 #define ETH_CAUSE_TX_UNDERRUN_BIT           19
 #define ETH_CAUSE_LINK_STATE_CHANGE_BIT     20
 #define ETH_CAUSE_INTERNAL_ADDR_ERR_BIT     23
@@ -677,20 +677,20 @@ typedef struct _ethTxDesc
 #define ETH_ETHERNET_PAD_CLIB_DRVN_OFFS		0
 #define ETH_ETHERNET_PAD_CLIB_DRVN_MASK		(0x1F << ETH_ETHERNET_PAD_CLIB_DRVN_OFFS)
 
-#define ETH_ETHERNET_PAD_CLIB_DRVP_OFFS         5                      
+#define ETH_ETHERNET_PAD_CLIB_DRVP_OFFS         5
 #define ETH_ETHERNET_PAD_CLIB_DRVP_MASK         (0x1F << ETH_ETHERNET_PAD_CLIB_DRVP_OFFS)
- 
-#define ETH_ETHERNET_PAD_CLIB_TUNEEN_OFFS       16                      
-#define ETH_ETHERNET_PAD_CLIB_TUNEEN_MASK       (0x1 << ETH_ETHERNET_PAD_CLIB_TUNEEN_OFFS) 
 
-#define ETH_ETHERNET_PAD_CLIB_LOCKN_OFFS        17                   
-#define ETH_ETHERNET_PAD_CLIB_LOCKN_MASK        (0x1F << ETH_ETHERNET_PAD_CLIB_LOCKN_OFFS) 
+#define ETH_ETHERNET_PAD_CLIB_TUNEEN_OFFS       16
+#define ETH_ETHERNET_PAD_CLIB_TUNEEN_MASK       (0x1 << ETH_ETHERNET_PAD_CLIB_TUNEEN_OFFS)
+
+#define ETH_ETHERNET_PAD_CLIB_LOCKN_OFFS        17
+#define ETH_ETHERNET_PAD_CLIB_LOCKN_MASK        (0x1F << ETH_ETHERNET_PAD_CLIB_LOCKN_OFFS)
 
-#define ETH_ETHERNET_PAD_CLIB_OFFST_OFFS        24                   
-#define ETH_ETHERNET_PAD_CLIB_OFFST_MASK        (0x1F << ETH_ETHERNET_PAD_CLIB_OFFST_OFFS) 
+#define ETH_ETHERNET_PAD_CLIB_OFFST_OFFS        24
+#define ETH_ETHERNET_PAD_CLIB_OFFST_MASK        (0x1F << ETH_ETHERNET_PAD_CLIB_OFFST_OFFS)
 
-#define ETH_ETHERNET_PAD_CLIB_WR_EN_OFFS        31                   
-#define ETH_ETHERNET_PAD_CLIB_WR_EN_MASK        (0x1  << ETH_ETHERNET_PAD_CLIB_WR_EN_OFFS) 
+#define ETH_ETHERNET_PAD_CLIB_WR_EN_OFFS        31
+#define ETH_ETHERNET_PAD_CLIB_WR_EN_MASK        (0x1  << ETH_ETHERNET_PAD_CLIB_WR_EN_OFFS)
 
 
 #ifdef __cplusplus
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h
index c42ed1a..f078398 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,51 +19,51 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
 
 /*******************************************************************************
-* mvEth.h - Header File for : Ethernet Controller 
+* mvEth.h - Header File for : Ethernet Controller
 *
 * DESCRIPTION:
 *       This header file contains macros typedefs and function declaration for
@@ -96,7 +96,7 @@ typedef enum
     MV_ETH_SPEED_10,
     MV_ETH_SPEED_100,
     MV_ETH_SPEED_1000
-    
+
 } MV_ETH_PORT_SPEED;
 
 typedef enum
@@ -104,7 +104,7 @@ typedef enum
     MV_ETH_DUPLEX_AN,
     MV_ETH_DUPLEX_HALF,
     MV_ETH_DUPLEX_FULL
-    
+
 } MV_ETH_PORT_DUPLEX;
 
 typedef enum
@@ -119,7 +119,7 @@ typedef enum
 typedef enum
 {
     MV_ETH_PRIO_FIXED = 0,  /* Fixed priority mode */
-    MV_ETH_PRIO_WRR   = 1   /* Weighted round robin priority mode */    
+    MV_ETH_PRIO_WRR   = 1   /* Weighted round robin priority mode */
 } MV_ETH_PRIO_MODE;
 
 /* Ethernet port specific infomation */
@@ -166,9 +166,9 @@ typedef struct
 
 typedef enum
 {
-	MV_ETH_DISABLE_HEADER_MODE = 0, 
-	MV_ETH_ENABLE_HEADER_MODE_PRI_2_1 = 1, 
-	MV_ETH_ENABLE_HEADER_MODE_PRI_DBNUM = 2, 
+	MV_ETH_DISABLE_HEADER_MODE = 0,
+	MV_ETH_ENABLE_HEADER_MODE_PRI_2_1 = 1,
+	MV_ETH_ENABLE_HEADER_MODE_PRI_DBNUM = 2,
 	MV_ETH_ENABLE_HEADER_MODE_PRI_SPID = 3
 } MV_ETH_HEADER_MODE;
 
@@ -205,12 +205,12 @@ MV_STATUS   mvEthMacAddrSet(void* pPortHandle, MV_U8* pMacAddr, int queue);
 MV_STATUS   mvEthMcastAddrSet(void* pPortHandle, MV_U8 *pAddr, int queue);
 
 /* MIB Counters APIs */
-MV_U32      mvEthMibCounterRead(void* pPortHndl, unsigned int mibOffset, 
+MV_U32      mvEthMibCounterRead(void* pPortHndl, unsigned int mibOffset,
                                MV_U32* pHigh32);
 void        mvEthMibCountersClear(void* pPortHandle);
 
 /* TX Scheduling configuration routines */
-MV_STATUS   mvEthTxQueueConfig(void* pPortHandle, int txQueue,                          
+MV_STATUS   mvEthTxQueueConfig(void* pPortHandle, int txQueue,
                                MV_ETH_PRIO_MODE txPrioMode, int txQuota);
 
 /* RX Dispatching configuration routines */
@@ -220,7 +220,7 @@ MV_STATUS   mvEthTosToRxqSet(void* pPortHandle, int tos, int rxq);
 int         mvEthTosToRxqGet(void* pPortHandle, int tos);
 
 /* Speed, Duplex, FlowControl routines */
-MV_STATUS   mvEthSpeedDuplexSet(void* pPortHandle, MV_ETH_PORT_SPEED speed, 
+MV_STATUS   mvEthSpeedDuplexSet(void* pPortHandle, MV_ETH_PORT_SPEED speed,
                                                    MV_ETH_PORT_DUPLEX duplex);
 
 MV_STATUS   mvEthFlowCtrlSet(void* pPortHandle, MV_ETH_PORT_FC flowControl);
@@ -281,7 +281,7 @@ void        mvEthPortPowerUp(int port);
 
 
 /* Queue specific information */
-typedef struct 
+typedef struct
 {
     void*       pFirstDescr;
     void*       pLastDescr;
@@ -312,7 +312,7 @@ typedef struct _ethPortCtrl
     MV_U8           mcastCount[256];
     MV_U32*         hashPtr;
     void 	    *osHandle;
-} ETH_PORT_CTRL; 
+} ETH_PORT_CTRL;
 
 /************** MACROs ****************/
 
@@ -331,7 +331,7 @@ typedef struct _ethPortCtrl
         mvOsCacheInvalidate (NULL, (pAddr), (size));                            \
         /*CPU_PIPE_FLUSH;*/
 #else
-#   define ETH_PACKET_CACHE_INVALIDATE(pAddr, size)    
+#   define ETH_PACKET_CACHE_INVALIDATE(pAddr, size)
 #endif /* ETHER_DRAM_COHER == MV_CACHE_COHER_SW && !UNCACHED_RX_BUFFERS */
 
 #ifdef ETH_DESCR_UNCACHED
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c
index 889d4d9..ce0d65d 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,57 +19,57 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
 
 #include "gpp/mvGpp.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
-/* defines  */       
-#ifdef MV_DEBUG         
+/* defines  */
+#ifdef MV_DEBUG
 	#define DB(x)	x
-#else                
-	#define DB(x)    
-#endif	             
+#else
+	#define DB(x)
+#endif
 
 static MV_VOID gppRegSet(MV_U32 group, MV_U32 regOffs,MV_U32 mask,MV_U32 value);
 
@@ -89,7 +89,7 @@ static MV_VOID gppRegSet(MV_U32 group, MV_U32 regOffs,MV_U32 mask,MV_U32 value);
 *
 * EXAMPLE:
 *       Set GPP8 to input and GPP15 to output.
-*       mvGppTypeSet(0, (GPP8 | GPP15), 
+*       mvGppTypeSet(0, (GPP8 | GPP15),
 *                    ((MV_GPP_IN & GPP8) | (MV_GPP_OUT & GPP15)) );
 *
 * RETURN:
@@ -133,7 +133,7 @@ MV_STATUS mvGppTypeSet(MV_U32 group, MV_U32 mask, MV_U32 value)
 *
 * EXAMPLE:
 *       Set GPP8 to be static and GPP15 to be blinking.
-*       mvGppBlinkEn(0, (GPP8 | GPP15), 
+*       mvGppBlinkEn(0, (GPP8 | GPP15),
 *                    ((MV_GPP_OUT_STATIC & GPP8) | (MV_GPP_OUT_BLINK & GPP15)) );
 *
 * RETURN:
@@ -169,7 +169,7 @@ MV_STATUS mvGppBlinkEn(MV_U32 group, MV_U32 mask, MV_U32 value)
 *
 * EXAMPLE:
 *       Set GPP8 to the actual pin value and GPP15 to be inverted.
-*       mvGppPolaritySet(0, (GPP8 | GPP15), 
+*       mvGppPolaritySet(0, (GPP8 | GPP15),
 *                    ((MV_GPP_IN_ORIGIN & GPP8) | (MV_GPP_IN_INVERT & GPP15)) );
 *
 * RETURN:
@@ -197,7 +197,7 @@ MV_STATUS mvGppPolaritySet(MV_U32 group, MV_U32 mask, MV_U32 value)
 *
 * INPUT:
 *       group - GPP group number
-*       mask  - 32bit mask value. Each set bit in the mask means that the 
+*       mask  - 32bit mask value. Each set bit in the mask means that the
 *               returned value is valid for it.
 *
 * OUTPUT:
@@ -221,7 +221,7 @@ MV_U32  mvGppPolarityGet(MV_U32 group, MV_U32 mask)
 		return MV_ERROR;
 	}
     regVal = MV_REG_READ(GPP_DATA_IN_POL_REG(group));
-    
+
     return (regVal & mask);
 }
 
@@ -233,7 +233,7 @@ MV_U32  mvGppPolarityGet(MV_U32 group, MV_U32 mask)
 *
 * INPUT:
 *       group - GPP group number
-*       mask  - 32bit mask value. Each set bit in the mask means that the 
+*       mask  - 32bit mask value. Each set bit in the mask means that the
 *               returned value is valid for it.
 *
 * OUTPUT:
@@ -267,8 +267,8 @@ MV_U32 mvGppValueGet(MV_U32 group, MV_U32 mask)
 *
 * INPUT:
 *       group - GPP group number
-*       mask  - 32bit mask value. Each set bit in the mask means that the 
-*               value of corresponding GPP will be set accordingly. Other GPP 
+*       mask  - 32bit mask value. Each set bit in the mask means that the
+*               value of corresponding GPP will be set accordingly. Other GPP
 *               are not affected.
 *       value - 32bit value that describes GPP value per pin.
 *
@@ -328,10 +328,10 @@ MV_STATUS mvGppValueSet (MV_U32 group, MV_U32 mask, MV_U32 value)
 *       This function set a specific GPP pin on a specific GPP register
 *
 * INPUT:
-*		regOffs - GPP Register offset 
+*		regOffs - GPP Register offset
 *       group - GPP group number
-*       mask  - 32bit mask value. Each set bit in the mask means that the 
-*               value of corresponding GPP will be set accordingly. Other GPP 
+*       mask  - 32bit mask value. Each set bit in the mask means that the
+*               value of corresponding GPP will be set accordingly. Other GPP
 *               are not affected.
 *       value - 32bit value that describes GPP value per pin.
 *
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h
index 526d324..a777a2a 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -114,5 +114,5 @@ MV_U32 mvGppValueGet(MV_U32 group, MV_U32 mask);
 /* mvGppValueSet - Set a GPP Pin list value. */
 MV_STATUS mvGppValueSet (MV_U32 group, MV_U32 mask, MV_U32 value);
 
-#endif /* #ifndef __INCmvGppH */ 
+#endif /* #ifndef __INCmvGppH */
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGppRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGppRegs.h
index b6fec34..14b199f 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGppRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGppRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -100,7 +100,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 /* registers offsets */
-   
+
 #define GPP_DATA_OUT_REG(grp)			((grp == 0) ? 0x10100 : 0x10140)
 #define GPP_DATA_OUT_EN_REG(grp)		((grp == 0) ? 0x10104 : 0x10144)
 #define GPP_BLINK_EN_REG(grp)			((grp == 0) ? 0x10108 : 0x10148)
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c
index 672d3e3..5ee430c 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -70,13 +70,13 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #endif
 
 
-/* defines  */       
-#ifdef MV_DEBUG         
+/* defines  */
+#ifdef MV_DEBUG
 	#define DB(x)	x
-#else                
-	#define DB(x)    
-#endif	             
-					 
+#else
+	#define DB(x)
+#endif
+
 
 /*******************************************************************************
 * mvPciInit - Initialize PCI interfaces
@@ -102,9 +102,9 @@ MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
 	if (PCI_IF_TYPE_CONVEN_PCIX == pciIfType)
 	{
 		#if defined(MV_INCLUDE_PCI)
-		
+
         MV_PCI_MOD pciMod;
-		
+
         if (PCI_IF_MODE_HOST == pciIfmode)
         {
             pciMod = MV_PCI_MOD_HOST;
@@ -115,11 +115,11 @@ MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
         }
         else
         {
-            mvOsPrintf("%s: ERROR!!! Bus %d mode %d neither host nor device!\n", 
+            mvOsPrintf("%s: ERROR!!! Bus %d mode %d neither host nor device!\n",
                         __FUNCTION__, pciIf, pciIfmode);
             return MV_FAIL;
         }
-        
+
         return mvPciInit(pciIf - MV_PCI_START_IF, pciMod);
 		#else
 		return MV_OK;
@@ -128,9 +128,9 @@ MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
 	else if (PCI_IF_TYPE_PEX == pciIfType)
 	{
 		#if defined(MV_INCLUDE_PEX)
-		
+
         MV_PEX_TYPE pexType;
-		
+
         if (PCI_IF_MODE_HOST == pciIfmode)
         {
             pexType = MV_PEX_ROOT_COMPLEX;
@@ -168,9 +168,9 @@ MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
 *
 * DESCRIPTION:
 *       This function performs a 32 bit read from PCI configuration space.
-*       It supports both type 0 and type 1 of Configuration Transactions 
-*       (local and over bridge). In order to read from local bus segment, use 
-*       bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers 
+*       It supports both type 0 and type 1 of Configuration Transactions
+*       (local and over bridge). In order to read from local bus segment, use
+*       bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers
 *       will result configuration transaction of type 1 (over bridge).
 *
 * INPUT:
@@ -178,7 +178,7 @@ MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
 *       bus     - PCI segment bus number.
 *       dev     - PCI device number.
 *       func    - Function number.
-*       regOffs - Register offset.       
+*       regOffs - Register offset.
 *
 * OUTPUT:
 *       None.
@@ -187,7 +187,7 @@ MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
 *       32bit register data, 0xffffffff on error
 *
 *******************************************************************************/
-MV_U32 mvPciIfConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, 
+MV_U32 mvPciIfConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
                         MV_U32 regOff)
 {
 	PCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);
@@ -197,7 +197,7 @@ MV_U32 mvPciIfConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 		#if defined(MV_INCLUDE_PCI)
 		return mvPciConfigRead(pciIf - MV_PCI_START_IF,
 								bus,
-								dev, 
+								dev,
                                 func,
 								regOff);
 		#else
@@ -209,7 +209,7 @@ MV_U32 mvPciIfConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 		#if defined(MV_INCLUDE_PEX)
 		return mvPexConfigRead(pciIf - MV_PEX_START_IF,
 								bus,
-								dev, 
+								dev,
                                 func,
 								regOff);
 		#else
@@ -231,9 +231,9 @@ MV_U32 mvPciIfConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *
 * DESCRIPTION:
 *       This function performs a 32 bit write to PCI configuration space.
-*       It supports both type 0 and type 1 of Configuration Transactions 
-*       (local and over bridge). In order to write to local bus segment, use 
-*       bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers 
+*       It supports both type 0 and type 1 of Configuration Transactions
+*       (local and over bridge). In order to write to local bus segment, use
+*       bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers
 *       will result configuration transaction of type 1 (over bridge).
 *
 * INPUT:
@@ -241,7 +241,7 @@ MV_U32 mvPciIfConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *       bus     - PCI segment bus number.
 *       dev     - PCI device number.
 *       func    - Function number.
-*       regOffs - Register offset.       
+*       regOffs - Register offset.
 *       data    - 32bit data.
 *
 * OUTPUT:
@@ -251,7 +251,7 @@ MV_U32 mvPciIfConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
 *
 *******************************************************************************/
-MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, 
+MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev,
                            MV_U32 func, MV_U32 regOff, MV_U32 data)
 {
 	PCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);
@@ -261,7 +261,7 @@ MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev,
 		#if defined(MV_INCLUDE_PCI)
 		return mvPciConfigWrite(pciIf - MV_PCI_START_IF,
 								bus,
-								dev, 
+								dev,
                                 func,
 								regOff,
 								data);
@@ -274,7 +274,7 @@ MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev,
 		#if defined(MV_INCLUDE_PEX)
 		return mvPexConfigWrite(pciIf - MV_PEX_START_IF,
 								bus,
-								dev, 
+								dev,
                                 func,
 								regOff,
 								data);
@@ -296,9 +296,9 @@ MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev,
 * mvPciMasterEnable - Enable/disale PCI interface master transactions.
 *
 * DESCRIPTION:
-*       This function performs read modified write to PCI command status 
-*       (offset 0x4) to set/reset bit 2. After this bit is set, the PCI 
-*       master is allowed to gain ownership on the bus, otherwise it is 
+*       This function performs read modified write to PCI command status
+*       (offset 0x4) to set/reset bit 2. After this bit is set, the PCI
+*       master is allowed to gain ownership on the bus, otherwise it is
 *       incapable to do so.
 *
 * INPUT:
@@ -349,10 +349,10 @@ MV_STATUS mvPciIfMasterEnable(MV_U32 pciIf, MV_BOOL enable)
 * mvPciSlaveEnable - Enable/disale PCI interface slave transactions.
 *
 * DESCRIPTION:
-*       This function performs read modified write to PCI command status 
-*       (offset 0x4) to set/reset bit 0 and 1. After those bits are set, 
-*       the PCI slave is allowed to respond to PCI IO space access (bit 0) 
-*       and PCI memory space access (bit 1). 
+*       This function performs read modified write to PCI command status
+*       (offset 0x4) to set/reset bit 0 and 1. After those bits are set,
+*       the PCI slave is allowed to respond to PCI IO space access (bit 0)
+*       and PCI memory space access (bit 1).
 *
 * INPUT:
 *       pciIf  - PCI interface number.
@@ -413,7 +413,7 @@ MV_STATUS mvPciIfSlaveEnable(MV_U32 pciIf,MV_U32 bus, MV_U32 dev, MV_BOOL enable
 *       None.
 *
 * RETURN:
-*       MV_NOT_ALLOWED in case PCI interface is PCI-X. 
+*       MV_NOT_ALLOWED in case PCI interface is PCI-X.
 *		MV_BAD_PARAM on bad parameters ,
 *       otherwise MV_OK
 *
@@ -426,7 +426,7 @@ MV_STATUS mvPciIfLocalBusNumSet(MV_U32 pciIf, MV_U32 busNum)
 	{
 		#if defined(MV_INCLUDE_PCI)
 		return mvPciLocalBusNumSet(pciIf - MV_PCI_START_IF,
-								busNum);	
+								busNum);
 		#else
 		return MV_OK;
 		#endif
@@ -523,7 +523,7 @@ MV_STATUS mvPciIfLocalDevNumSet(MV_U32 pciIf, MV_U32 devNum)
 	{
 		#if defined(MV_INCLUDE_PCI)
 		return mvPciLocalDevNumSet(pciIf - MV_PCI_START_IF,
-								devNum);	
+								devNum);
 		#else
 		return MV_OK;
 		#endif
@@ -593,7 +593,7 @@ MV_U32 mvPciIfLocalDevNumGet(MV_U32 pciIf)
 }
 
 /*******************************************************************************
-* mvPciIfTypeGet - 
+* mvPciIfTypeGet -
 *
 * DESCRIPTION:
 *
@@ -629,7 +629,7 @@ PCI_IF_TYPE mvPciIfTypeGet(MV_U32 pciIf)
 }
 
 /*******************************************************************************
-* mvPciIfTypeGet - 
+* mvPciIfTypeGet -
 *
 * DESCRIPTION:
 *
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h
index 9c2d160..5f7caaa 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -107,7 +107,7 @@ MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev,
 MV_STATUS mvPciIfMasterEnable(MV_U32 pciIf, MV_BOOL enable);
 
 /* mvPciIfSlaveEnable - Enable/disale PCI interface slave transactions.*/
-MV_STATUS mvPciIfSlaveEnable(MV_U32 pciIf,MV_U32 bus, MV_U32 dev, 
+MV_STATUS mvPciIfSlaveEnable(MV_U32 pciIf,MV_U32 bus, MV_U32 dev,
 							 MV_BOOL enable);
 
 /* mvPciIfLocalBusNumSet - Set PCI interface local bus number.*/
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h
index 08d4d2d..c9638d1 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -128,7 +128,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define PSCR_SYSERR			BIT30	/* Signalled system error 	*/
 #define PSCR_DET_PARERR		BIT31	/* Detect Parity Error 		*/
 
-/* 	PCI configuration register offset=0x08 fields 
+/* 	PCI configuration register offset=0x08 fields
 	(PCI_CLASS_CODE_AND_REVISION_ID)(PCCRI) 				*/
 
 #define PCCRIR_REVID_OFFS		0		/* Revision ID */
@@ -146,12 +146,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define PCCRIR_BASE_CLASS_OFFS	24		/* Base Class*/
 #define PCCRIR_BASE_CLASS_MASK	(0xff << PCCRIR_BASE_CLASS_OFFS)
 
-/* 	PCI configuration register offset=0x0C fields 
+/* 	PCI configuration register offset=0x0C fields
 	(PCI_BIST_HEADER_TYPE_LATENCY_TIMER_CACHE_LINE)(PBHTLTCL) 				*/
 
 #define PBHTLTCLR_CACHELINE_OFFS		0	/* Specifies the cache line size */
 #define PBHTLTCLR_CACHELINE_MASK		(0xff << PBHTLTCLR_CACHELINE_OFFS)
-	
+
 #define PBHTLTCLR_LATTIMER_OFFS			8	/* latency timer */
 #define PBHTLTCLR_LATTIMER_MASK			(0xff << PBHTLTCLR_LATTIMER_OFFS)
 
@@ -176,19 +176,19 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* PCI Bar Base Low Register (PBBLR) */
 #define PBBLR_IOSPACE			BIT0	/* Memory Space Indicator */
 
-#define PBBLR_TYPE_OFFS			1	   /* BAR Type/Init Val. */ 
+#define PBBLR_TYPE_OFFS			1	   /* BAR Type/Init Val. */
 #define PBBLR_TYPE_MASK			(0x3 << PBBLR_TYPE_OFFS)
 #define PBBLR_TYPE_32BIT_ADDR	(0x0 << PBBLR_TYPE_OFFS)
 #define PBBLR_TYPE_64BIT_ADDR	(0x2 << PBBLR_TYPE_OFFS)
 
 #define PBBLR_PREFETCH_EN		BIT3 	/* Prefetch Enable */
 
-				
+
 #define PBBLR_MEM_BASE_OFFS		4	/* Memory Bar Base address. Corresponds to
 									address bits [31:4] */
 #define PBBLR_MEM_BASE_MASK		(0xfffffff << PBBLR_MEM_BASE_OFFS)
 
-#define PBBLR_IO_BASE_OFFS		2	/* IO Bar Base address. Corresponds to 
+#define PBBLR_IO_BASE_OFFS		2	/* IO Bar Base address. Corresponds to
 										address bits [31:2] */
 #define PBBLR_IO_BASE_MASK		(0x3fffffff << PBBLR_IO_BASE_OFFS)
 
@@ -203,7 +203,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define PBBHR_BASE_MASK			(0xffffffff << PBBHR_BASE_OFFS)
 
 
-/* 	PCI configuration register offset=0x2C fields 
+/* 	PCI configuration register offset=0x2C fields
 	(PCI_SUBSYSTEM_ID_AND_SUBSYSTEM_VENDOR_ID)(PSISVI) 				*/
 
 #define PSISVIR_VENID_OFFS	0	/* Subsystem Manufacturer Vendor ID Number */
@@ -212,21 +212,21 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define PSISVIR_DEVID_OFFS	16	/* Subsystem Device ID Number */
 #define PSISVIR_DEVID_MASK	(0xffff << PSISVIR_DEVID_OFFS)
 
-/* 	PCI configuration register offset=0x30 fields 
+/* 	PCI configuration register offset=0x30 fields
 	(PCI_EXPANSION_ROM_BASE_ADDR_REG)(PERBA) 				*/
 
 #define PERBAR_EXPROMEN		BIT0	/* Expansion ROM Enable */
 
 #define PERBAR_BASE_OFFS		12		/* Expansion ROM Base Address */
-#define PERBAR_BASE_MASK		(0xfffff << PERBAR_BASE_OFFS) 	
+#define PERBAR_BASE_MASK		(0xfffff << PERBAR_BASE_OFFS)
 
-/* 	PCI configuration register offset=0x34 fields 
+/* 	PCI configuration register offset=0x34 fields
 	(PCI_CAPABILTY_LIST_POINTER)(PCLP) 				*/
 
 #define PCLPR_CAPPTR_OFFS	0		/* Capability List Pointer */
 #define PCLPR_CAPPTR_MASK	(0xff << PCLPR_CAPPTR_OFFS)
 
-/* 	PCI configuration register offset=0x3C fields 
+/* 	PCI configuration register offset=0x3C fields
 	(PCI_INTERRUPT_PIN_AND_LINE)(PIPL) 				*/
 
 #define PIPLR_INTLINE_OFFS	0	/* Interrupt line (IRQ) */
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/pci_util/mvPciUtils.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/pci_util/mvPciUtils.h
index 2ee0b17..e255203 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/pci_util/mvPciUtils.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/pci_util/mvPciUtils.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -65,8 +65,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef __INCmvPciUtilsh
 #define __INCmvPciUtilsh
 
-/* 
-This module only support scanning of Header type 00h of pci devices 
+/*
+This module only support scanning of Header type 00h of pci devices
 There is no suppotr for Header type 01h of pci devices  ( PCI bridges )
 */
 
@@ -178,14 +178,14 @@ There is no suppotr for Header type 01h of pci devices  ( PCI bridges )
 
 typedef enum _mvPciBarMapping
 {
-    PCI_MEMORY_BAR, 
-    PCI_IO_BAR, 
+    PCI_MEMORY_BAR,
+    PCI_IO_BAR,
     PCI_NO_MAPPING
 }MV_PCI_BAR_MAPPING;
 
 typedef enum _mvPciBarType
 {
-    PCI_32BIT_BAR, 
+    PCI_32BIT_BAR,
     PCI_64BIT_BAR
 }MV_PCI_BAR_TYPE;
 
@@ -253,7 +253,7 @@ typedef struct _mvPciDevice
 	MV_U32			venID;		/* Pci agent Vendor ID */
     MV_U32			deviceID;	/* Pci agent Device ID */
 
-    MV_BOOL			isFastB2BCapable;	/* Capability of Fast Back to Back 
+    MV_BOOL			isFastB2BCapable;	/* Capability of Fast Back to Back
 										   transactions */
 	MV_BOOL			isCapListSupport;	/* Support of Capability list */
 	MV_BOOL			is66MHZCapable;		/* 66MHZ support */
@@ -271,13 +271,13 @@ typedef struct _mvPciDevice
 	MV_U32			p2pSecLatencyTimer;	/* P2P Econdary Latency Timer*/
 	MV_U32			p2pIObase;			/* P2P IO Base */
 	MV_U32			p2pIOLimit;			/* P2P IO Linit */
-	MV_BOOL			bIO32;	
+	MV_BOOL			bIO32;
 	MV_U32			p2pSecStatus;		/* P2P Secondary Status */
 	MV_U32			p2pMemBase;			/* P2P Memory Space */
 	MV_U32			p2pMemLimit;		/* P2P Memory Limit*/
 	MV_U32			p2pPrefMemBase;		/* P2P Prefetchable Mem Base*/
 	MV_U32			p2pPrefMemLimit;	/* P2P Prefetchable Memory Limit*/
-	MV_BOOL			bPrefMem64;	
+	MV_BOOL			bPrefMem64;
 	MV_U32			p2pPrefBaseUpper32Bits;/* P2P Prefetchable upper 32 bits*/
 	MV_U32			p2pPrefLimitUpper32Bits;/* P2P prefetchable limit upper 32*/
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c
index 4a08734..aec8af7 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -65,13 +65,13 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "ctrlEnv/mvCtrlEnvLib.h"
 
-/* defines  */       
-#ifdef MV_DEBUG         
+/* defines  */
+#ifdef MV_DEBUG
 	#define DB(x)	x
-#else                
-	#define DB(x)    
-#endif	             
-					 
+#else
+	#define DB(x)
+#endif
+
 
 
 MV_VOID mvPciHalInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod)
@@ -81,10 +81,10 @@ MV_VOID mvPciHalInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod)
 
                 mvPciLocalBusNumSet(pciIf, PCI_HOST_BUS_NUM(pciIf));
                 mvPciLocalDevNumSet(pciIf, PCI_HOST_DEV_NUM(pciIf));
-        
+
                 /* Local device master Enable */
                 mvPciMasterEnable(pciIf, MV_TRUE);
-        
+
                 /* Local device slave Enable */
                 mvPciSlaveEnable(pciIf, mvPciLocalBusNumGet(pciIf),
                                                  mvPciLocalDevNumGet(pciIf), MV_TRUE);
@@ -97,7 +97,7 @@ MV_VOID mvPciHalInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod)
 * mvPciCommandSet - Set PCI comman register value.
 *
 * DESCRIPTION:
-*       This function sets a given PCI interface with its command register 
+*       This function sets a given PCI interface with its command register
 *       value.
 *
 * INPUT:
@@ -129,18 +129,18 @@ MV_STATUS mvPciCommandSet(MV_U32 pciIf, MV_U32 command)
 	MV_REG_WRITE(PCI_CMD_REG(pciIf), command);
 
     /* Upodate device max outstanding split tarnsaction */
-    if ((command & PCR_CPU_TO_PCI_ORDER_EN) && 
+    if ((command & PCR_CPU_TO_PCI_ORDER_EN) &&
         (command & PCR_PCI_TO_CPU_ORDER_EN))
     {
         /* Read PCI-X command register */
         regVal = mvPciConfigRead (pciIf, locBusNum, locDevNum, 0, PCIX_COMMAND);
-                        
+
         /* clear bits 22:20 */
         regVal &= 0xff8fffff;
 
         /* set reset value */
         regVal |= (0x3 << 20);
-        
+
         /* Write back the value */
         mvPciConfigWrite (pciIf, locBusNum, locDevNum, 0, PCIX_COMMAND, regVal);
     }
@@ -185,7 +185,7 @@ MV_STATUS mvPciModeGet(MV_U32 pciIf, MV_PCI_MODE *pPciMode)
 
 	/* Read pci mode register */
 	pciMode = MV_REG_READ(PCI_MODE_REG(pciIf));
-	
+
 	switch (pciMode & PMR_PCI_MODE_MASK)
 	{
 		case PMR_PCI_MODE_CONV:
@@ -199,22 +199,22 @@ MV_STATUS mvPciModeGet(MV_U32 pciIf, MV_PCI_MODE *pPciMode)
 			{
 				pPciMode->pciSpeed = 33000000; /* 33MHZ */
 			}
-			
+
 			break;
-		
-		case PMR_PCI_MODE_PCIX_66MHZ:	
+
+		case PMR_PCI_MODE_PCIX_66MHZ:
 			pPciMode->pciType  = MV_PCIX;
-			pPciMode->pciSpeed = 66000000; /* 66MHZ */	
+			pPciMode->pciSpeed = 66000000; /* 66MHZ */
 			break;
-		
-		case PMR_PCI_MODE_PCIX_100MHZ:	
+
+		case PMR_PCI_MODE_PCIX_100MHZ:
 			pPciMode->pciType  = MV_PCIX;
-			pPciMode->pciSpeed = 100000000; /* 100MHZ */	
+			pPciMode->pciSpeed = 100000000; /* 100MHZ */
 			break;
-		
-		case PMR_PCI_MODE_PCIX_133MHZ:	
+
+		case PMR_PCI_MODE_PCIX_133MHZ:
 			pPciMode->pciType  = MV_PCIX;
-			pPciMode->pciSpeed = 133000000; /* 133MHZ */	
+			pPciMode->pciSpeed = 133000000; /* 133MHZ */
 			break;
 
 		default:
@@ -229,18 +229,18 @@ MV_STATUS mvPciModeGet(MV_U32 pciIf, MV_PCI_MODE *pPciMode)
 		case PMR_PCI_64_64BIT:
 			pPciMode->pciWidth = MV_PCI_64;
 			break;
-		
+
 		case PMR_PCI_64_32BIT:
             pPciMode->pciWidth = MV_PCI_32;
             break;
-		
+
 		default:
 			{
 				mvOsPrintf("mvPciModeGet: ERR. Non existing mode !!\n");
 				return MV_ERROR;
 			}
 	}
-	
+
 	return MV_OK;
 }
 
@@ -248,7 +248,7 @@ MV_STATUS mvPciModeGet(MV_U32 pciIf, MV_PCI_MODE *pPciMode)
 * mvPciRetrySet - Set PCI retry counters
 *
 * DESCRIPTION:
-*       This function specifies the number of times the PCI controller 
+*       This function specifies the number of times the PCI controller
 *       retries a transaction before it quits.
 *       Applies to the PCI Master when acting as a requester.
 *       Applies to the PCI slave when acting as a completer (PCI-X mode).
@@ -256,7 +256,7 @@ MV_STATUS mvPciModeGet(MV_U32 pciIf, MV_PCI_MODE *pPciMode)
 *
 * INPUT:
 *       pciIf   - PCI interface number.
-*       counter - Number of times PCI controller retry. Use counter value 
+*       counter - Number of times PCI controller retry. Use counter value
 *                 up to PRR_RETRY_CNTR_MAX.
 *
 * OUTPUT:
@@ -306,15 +306,15 @@ MV_STATUS mvPciRetrySet(MV_U32 pciIf, MV_U32 counter)
 *       In conventional PCI mode:
 *       Specifies the number of PCLK cycles the PCI slave keeps a non-accessed
 *       read buffers (non-completed delayed read) before invalidate the buffer.
-*       Set to '0' to disable the timer. The PCI slave waits for delayed 
+*       Set to '0' to disable the timer. The PCI slave waits for delayed
 *       read completion forever.
 *       In PCI-X mode:
 *       Specifies the number of PCLK cycles the PCI master waits for split
 *       completion transaction, before it invalidates the pre-allocated read
 *       buffer.
-*       Set to '0' to disable the timer. The PCI master waits for split 
+*       Set to '0' to disable the timer. The PCI master waits for split
 *       completion forever.
-*       NOTE: Must be set to a number greater than MV_PCI_MAX_DISCARD_CLK, 
+*       NOTE: Must be set to a number greater than MV_PCI_MAX_DISCARD_CLK,
 *       unless using the "wait for ever" setting 0x0.
 *       NOTE: Must not be updated while there are pending read requests.
 *
@@ -336,14 +336,14 @@ MV_STATUS mvPciDiscardTimerSet(MV_U32 pciIf, MV_U32 pClkCycles)
 	/* Parameter checking   */
 	if (pciIf >= mvCtrlPciMaxIfGet())
 	{
-		mvOsPrintf("mvPciDiscardTimerSet: ERR. Invalid PCI interface %d\n", 
+		mvOsPrintf("mvPciDiscardTimerSet: ERR. Invalid PCI interface %d\n",
 																		pciIf);
 		return MV_BAD_PARAM;
 	}
 
 	if (pClkCycles >= PDTR_TIMER_MIN)
 	{
-		mvOsPrintf("mvPciDiscardTimerSet: ERR. Invalid Clk value: %d\n", 	
+		mvOsPrintf("mvPciDiscardTimerSet: ERR. Invalid Clk value: %d\n",
 																   pClkCycles);
 		return MV_BAD_PARAM;
 
@@ -370,7 +370,7 @@ MV_STATUS mvPciDiscardTimerSet(MV_U32 pciIf, MV_U32 pClkCycles)
 *
 * DESCRIPTION:
 *       This fuction enable/disables a given PCI interface arbiter.
-*       NOTE: Arbiter setting can not be changed while in work. It should only 
+*       NOTE: Arbiter setting can not be changed while in work. It should only
 *             be set once.
 * INPUT:
 *       pciIf  - PCI interface number.
@@ -393,30 +393,30 @@ MV_STATUS mvPciArbEnable(MV_U32 pciIf, MV_BOOL enable)
 		mvOsPrintf("mvPciArbEnable: ERR. Invalid PCI interface %d\n", pciIf);
 		return MV_ERROR;
 	}
-    	
+
     /* Set PCI Arbiter Control register according to default configuration 	*/
 	regVal = MV_REG_READ(PCI_ARBITER_CTRL_REG(pciIf));
 
 	/* Make sure arbiter disabled before changing its values */
-	MV_REG_BIT_RESET(PCI_ARBITER_CTRL_REG(pciIf), PACR_ARB_ENABLE); 
+	MV_REG_BIT_RESET(PCI_ARBITER_CTRL_REG(pciIf), PACR_ARB_ENABLE);
 
-	regVal &= ~PCI_ARBITER_CTRL_DEFAULT_MASK;	
+	regVal &= ~PCI_ARBITER_CTRL_DEFAULT_MASK;
 
 	regVal |= PCI_ARBITER_CTRL_DEFAULT;		/* Set default configuration	*/
 
 	if (MV_TRUE == enable)
 	{
-		regVal |= PACR_ARB_ENABLE; 
+		regVal |= PACR_ARB_ENABLE;
 	}
 	else
 	{
-		regVal &= ~PACR_ARB_ENABLE; 
+		regVal &= ~PACR_ARB_ENABLE;
 	}
 
 	/* Write to register 										            */
 	MV_REG_WRITE(PCI_ARBITER_CTRL_REG(pciIf), regVal);
 
-	return MV_OK;	
+	return MV_OK;
 }
 
 
@@ -429,8 +429,8 @@ MV_STATUS mvPciArbEnable(MV_U32 pciIf, MV_BOOL enable)
 *
 * INPUT:
 *       pciIf        - PCI interface number.
-*       pciAgentMask - When a bit in the mask is set to '1', parking on 
-*                      the associated PCI master is disabled. Mask bit 
+*       pciAgentMask - When a bit in the mask is set to '1', parking on
+*                      the associated PCI master is disabled. Mask bit
 *                      refers to bit 0 - 6. For example disable parking on PCI
 *                      agent 3 set pciAgentMask 0x4 (bit 3 is set).
 *
@@ -456,13 +456,13 @@ MV_STATUS mvPciArbParkDis(MV_U32 pciIf, MV_U32 pciAgentMask)
 	pciArbiterCtrl = MV_REG_READ(PCI_ARBITER_CTRL_REG(pciIf));
 
 	/* Arbiter must be disabled before changing parking */
-	MV_REG_BIT_RESET(PCI_ARBITER_CTRL_REG(pciIf), PACR_ARB_ENABLE); 
+	MV_REG_BIT_RESET(PCI_ARBITER_CTRL_REG(pciIf), PACR_ARB_ENABLE);
 
 	/* do the change */
     pciArbiterCtrl &= ~PACR_PARK_DIS_MASK;
 	pciArbiterCtrl |= (pciAgentMask << PACR_PARK_DIS_OFFS);
 
-	/* writing new value ( if th earbiter was enabled before the change		*/ 
+	/* writing new value ( if th earbiter was enabled before the change		*/
 	/* here it will be reenabled 											*/
 	MV_REG_WRITE(PCI_ARBITER_CTRL_REG(pciIf), pciArbiterCtrl);
 
@@ -474,11 +474,11 @@ MV_STATUS mvPciArbParkDis(MV_U32 pciIf, MV_U32 pciAgentMask)
 * mvPciArbBrokDetectSet - Set PCI arbiter broken detection
 *
 * DESCRIPTION:
-*       This function sets the maximum number of cycles that the arbiter 
-*       waits for a PCI master to respond to its grant assertion. If a 
-*       PCI agent fails to respond within this time, the PCI arbiter aborts 
+*       This function sets the maximum number of cycles that the arbiter
+*       waits for a PCI master to respond to its grant assertion. If a
+*       PCI agent fails to respond within this time, the PCI arbiter aborts
 *       the transaction and performs a new arbitration cycle.
-*       NOTE: Value must be greater than '1' for conventional PCI and 
+*       NOTE: Value must be greater than '1' for conventional PCI and
 *       greater than '5' for PCI-X.
 *
 * INPUT:
@@ -501,7 +501,7 @@ MV_STATUS mvPciArbBrokDetectSet(MV_U32 pciIf, MV_U32 pClkCycles)
 	/* Parameter checking   */
 	if (pciIf >= mvCtrlPciMaxIfGet())
 	{
-		mvOsPrintf("mvPciArbBrokDetectSet: ERR. Invalid PCI interface %d\n", 
+		mvOsPrintf("mvPciArbBrokDetectSet: ERR. Invalid PCI interface %d\n",
 																		pciIf);
 		return MV_BAD_PARAM;
 	}
@@ -512,12 +512,12 @@ MV_STATUS mvPciArbBrokDetectSet(MV_U32 pciIf, MV_U32 pClkCycles)
 
 	if (PMR_PCI_MODE_CONV == pciMode)
 	{
-		if (pClkCycles < PACR_BROKEN_VAL_CONV_MIN) 
+		if (pClkCycles < PACR_BROKEN_VAL_CONV_MIN)
 			return MV_ERROR;
 	}
 	else
 	{
-		if (pClkCycles < PACR_BROKEN_VAL_PCIX_MIN) 
+		if (pClkCycles < PACR_BROKEN_VAL_PCIX_MIN)
 			return MV_ERROR;
 	}
 
@@ -529,7 +529,7 @@ MV_STATUS mvPciArbBrokDetectSet(MV_U32 pciIf, MV_U32 pClkCycles)
 	pciArbiterCtrl |= pClkCycles;
 
 	/* Arbiter must be disabled before changing broken detection */
-	MV_REG_BIT_RESET(PCI_ARBITER_CTRL_REG(pciIf), PACR_ARB_ENABLE); 
+	MV_REG_BIT_RESET(PCI_ARBITER_CTRL_REG(pciIf), PACR_ARB_ENABLE);
 
 	/* writing new value ( if th earbiter was enabled before the change 	*/
 	/* here it will be reenabled 											*/
@@ -546,9 +546,9 @@ MV_STATUS mvPciArbBrokDetectSet(MV_U32 pciIf, MV_U32 pClkCycles)
 *
 * DESCRIPTION:
 *       This function performs a 32 bit read from PCI configuration space.
-*       It supports both type 0 and type 1 of Configuration Transactions 
-*       (local and over bridge). In order to read from local bus segment, use 
-*       bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers 
+*       It supports both type 0 and type 1 of Configuration Transactions
+*       (local and over bridge). In order to read from local bus segment, use
+*       bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers
 *       will result configuration transaction of type 1 (over bridge).
 *
 * INPUT:
@@ -556,7 +556,7 @@ MV_STATUS mvPciArbBrokDetectSet(MV_U32 pciIf, MV_U32 pClkCycles)
 *       bus     - PCI segment bus number.
 *       dev     - PCI device number.
 *       func    - Function number.
-*       regOffs - Register offset.       
+*       regOffs - Register offset.
 *
 * OUTPUT:
 *       None.
@@ -565,7 +565,7 @@ MV_STATUS mvPciArbBrokDetectSet(MV_U32 pciIf, MV_U32 pClkCycles)
 *       32bit register data, 0xffffffff on error
 *
 *******************************************************************************/
-MV_U32 mvPciConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, 
+MV_U32 mvPciConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
                         MV_U32 regOff)
 {
 	MV_U32 pciData = 0;
@@ -585,13 +585,13 @@ MV_U32 mvPciConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 		DB(mvOsPrintf("mvPciConfigRead: ERR. device number illigal %d\n", dev));
 		return 0xFFFFFFFF;
 	}
-	
+
 	if (func >= MAX_PCI_FUNCS)
 	{
 		DB(mvOsPrintf("mvPciConfigRead: ERR. function number illigal %d\n", func));
 		return 0xFFFFFFFF;
 	}
-	
+
 	if (bus >= MAX_PCI_BUSSES)
 	{
 		DB(mvOsPrintf("mvPciConfigRead: ERR. bus number illigal %d\n", bus));
@@ -605,8 +605,8 @@ MV_U32 mvPciConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 	pciData |= (func << PCAR_FUNC_NUM_OFFS);
 	pciData |= (regOff & PCAR_REG_NUM_MASK);
 
-	pciData |= PCAR_CONFIG_EN; 
-	
+	pciData |= PCAR_CONFIG_EN;
+
 	/* Write the address to the PCI configuration address register */
 	MV_REG_WRITE(PCI_CONFIG_ADDR_REG(pciIf), pciData);
 
@@ -627,9 +627,9 @@ MV_U32 mvPciConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *
 * DESCRIPTION:
 *       This function performs a 32 bit write to PCI configuration space.
-*       It supports both type 0 and type 1 of Configuration Transactions 
-*       (local and over bridge). In order to write to local bus segment, use 
-*       bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers 
+*       It supports both type 0 and type 1 of Configuration Transactions
+*       (local and over bridge). In order to write to local bus segment, use
+*       bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers
 *       will result configuration transaction of type 1 (over bridge).
 *
 * INPUT:
@@ -637,7 +637,7 @@ MV_U32 mvPciConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *       bus     - PCI segment bus number.
 *       dev     - PCI device number.
 *       func    - Function number.
-*       regOffs - Register offset.       
+*       regOffs - Register offset.
 *       data    - 32bit data.
 *
 * OUTPUT:
@@ -647,7 +647,7 @@ MV_U32 mvPciConfigRead (MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
 *
 *******************************************************************************/
-MV_STATUS mvPciConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, 
+MV_STATUS mvPciConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev,
                            MV_U32 func, MV_U32 regOff, MV_U32 data)
 {
 	MV_U32 pciData = 0;
@@ -657,7 +657,7 @@ MV_STATUS mvPciConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev,
 	{
 		if (pciIf >= mvCtrlPciMaxIfGet())
 		{
-			mvOsPrintf("mvPciConfigWrite: ERR. Invalid PCI interface %d\n", 
+			mvOsPrintf("mvPciConfigWrite: ERR. Invalid PCI interface %d\n",
 																		pciIf);
 			return 0xFFFFFFFF;
 		}
@@ -688,7 +688,7 @@ MV_STATUS mvPciConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev,
 	pciData |= (regOff & PCAR_REG_NUM_MASK);
 
 	pciData |= PCAR_CONFIG_EN;
-	
+
 	/* Write the address to the PCI configuration address register */
 	MV_REG_WRITE(PCI_CONFIG_ADDR_REG(pciIf), pciData);
 
@@ -709,9 +709,9 @@ MV_STATUS mvPciConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev,
 * mvPciMasterEnable - Enable/disale PCI interface master transactions.
 *
 * DESCRIPTION:
-*       This function performs read modified write to PCI command status 
-*       (offset 0x4) to set/reset bit 2. After this bit is set, the PCI 
-*       master is allowed to gain ownership on the bus, otherwise it is 
+*       This function performs read modified write to PCI command status
+*       (offset 0x4) to set/reset bit 2. After this bit is set, the PCI
+*       master is allowed to gain ownership on the bus, otherwise it is
 *       incapable to do so.
 *
 * INPUT:
@@ -741,7 +741,7 @@ MV_STATUS mvPciMasterEnable(MV_U32 pciIf, MV_BOOL enable)
 
 	localBus = mvPciLocalBusNumGet(pciIf);
 	localDev = mvPciLocalDevNumGet(pciIf);
-	
+
 	RegOffs = PCI_STATUS_AND_COMMAND;
 
 	pciCommandStatus = mvPciConfigRead(pciIf, localBus, localDev, 0, RegOffs);
@@ -765,10 +765,10 @@ MV_STATUS mvPciMasterEnable(MV_U32 pciIf, MV_BOOL enable)
 * mvPciSlaveEnable - Enable/disale PCI interface slave transactions.
 *
 * DESCRIPTION:
-*       This function performs read modified write to PCI command status 
-*       (offset 0x4) to set/reset bit 0 and 1. After those bits are set, 
-*       the PCI slave is allowed to respond to PCI IO space access (bit 0) 
-*       and PCI memory space access (bit 1). 
+*       This function performs read modified write to PCI command status
+*       (offset 0x4) to set/reset bit 0 and 1. After those bits are set,
+*       the PCI slave is allowed to respond to PCI IO space access (bit 0)
+*       and PCI memory space access (bit 1).
 *
 * INPUT:
 *       pciIf  - PCI interface number.
@@ -801,14 +801,14 @@ MV_STATUS mvPciSlaveEnable(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_BOOL enable)
 	}
 
 	RegOffs = PCI_STATUS_AND_COMMAND;
-	
+
 	pciCommandStatus=mvPciConfigRead(pciIf, bus, dev, 0, RegOffs);
 
     if (MV_TRUE == enable)
 	{
 		pciCommandStatus |= (PSCR_IO_EN | PSCR_MEM_EN);
 	}
-	else                             
+	else
 	{
 		pciCommandStatus &= ~(PSCR_IO_EN | PSCR_MEM_EN);
 	}
@@ -833,7 +833,7 @@ MV_STATUS mvPciSlaveEnable(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_BOOL enable)
 *       None.
 *
 * RETURN:
-*       MV_NOT_ALLOWED in case PCI interface is PCI-X. 
+*       MV_NOT_ALLOWED in case PCI interface is PCI-X.
 *       MV_BAD_PARAM on bad parameters ,
 *       otherwise MV_OK
 *
@@ -920,7 +920,7 @@ MV_U32 mvPciLocalBusNumGet(MV_U32 pciIf)
 	{
 		if (pciIf >= mvCtrlPciMaxIfGet())
 		{
-			mvOsPrintf("mvPciLocalBusNumGet: ERR. Invalid PCI interface %d\n", 
+			mvOsPrintf("mvPciLocalBusNumGet: ERR. Invalid PCI interface %d\n",
 													   					pciIf);
 			return 0xFFFFFFFF;
 		}
@@ -966,12 +966,12 @@ MV_STATUS mvPciLocalDevNumSet(MV_U32 pciIf, MV_U32 devNum)
 	}
 	if (devNum >= MAX_PCI_DEVICES)
 	{
-		mvOsPrintf("mvPciLocalDevNumSet: ERR. device number illigal %d\n", 
+		mvOsPrintf("mvPciLocalDevNumSet: ERR. device number illigal %d\n",
 																	   devNum);
 		return MV_BAD_PARAM;
 
 	}
-	
+
 	localBus = mvPciLocalBusNumGet(pciIf);
 	localDev = mvPciLocalDevNumGet(pciIf);
 
@@ -1024,17 +1024,17 @@ MV_U32 mvPciLocalDevNumGet(MV_U32 pciIf)
 	MV_U32 pciP2PConfig;
 
 	/* Parameter checking   */
-	
+
 	if (PCI_DEFAULT_IF != pciIf)
 	{
 		if (pciIf >= mvCtrlPciMaxIfGet())
 		{
-			mvOsPrintf("mvPciLocalDevNumGet: ERR. Invalid PCI interface %d\n", 
+			mvOsPrintf("mvPciLocalDevNumGet: ERR. Invalid PCI interface %d\n",
 																   		pciIf);
 			return 0xFFFFFFFF;
 		}
 	}
-	
+
 	pciP2PConfig  = MV_REG_READ(PCI_P2P_CONFIG_REG(pciIf));
 
 	pciP2PConfig &= PPCR_DEV_NUM_MASK;
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h
index 4746336..2f4ee1e 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -80,11 +80,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  Power Management
  Compact PCI Hot Swap
  Header retarget
- 
-Registers not supported: 
+
+Registers not supported:
 1) PCI DLL Status and Control (PCI0 0x1D20, PCI1 0x1DA0)
 2) PCI/MPP Pads Calibration (CI0/MPP[31:16] 0x1D1C, PCI1/MPP[15:0] 0X1D9C)
-*/  
+*/
 
 /* defines */
 /* The number of supported PCI interfaces depend on Marvell controller 		*/
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h
index 89d0ef1..69fe7e5 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -77,7 +77,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* This enumerator described the possible PCI slave targets.    	   */
 /* PCI slave targets are designated memory/IO address spaces that the  */
 /* PCI slave targets can access. They are also refered as "targets"    */
-/* this enumeratoe order is determined by the content of : 
+/* this enumeratoe order is determined by the content of :
 		PCI_BASE_ADDR_ENABLE_REG 				 					*/
 
 
@@ -101,7 +101,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 							(0x31e04 + ((pciIf) * 0x80) + ((targetWin) * 0x10))
 #define PCI_ACCESS_CTRL_SIZE_REG(pciIf, targetWin)	\
 							(0x31e08 + ((pciIf) * 0x80) + ((targetWin) * 0x10))
-							
+
 #define PCI_DLL_CTRL_REG(pciIf)	   		 		(0x31d20  + ((pciIf) * 0x80))
 
 /* PCI Dll Control (PDC)*/
@@ -276,16 +276,16 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* PCI Configuration Address Register (PCAR) */
 #define PCAR_REG_NUM_OFFS			2
 #define PCAR_REG_NUM_MASK			(0x3F << PCAR_REG_NUM_OFFS)
-		
+
 #define PCAR_FUNC_NUM_OFFS			8
 #define PCAR_FUNC_NUM_MASK			(0x7 << PCAR_FUNC_NUM_OFFS)
-		
+
 #define PCAR_DEVICE_NUM_OFFS		11
 #define PCAR_DEVICE_NUM_MASK		(0x1F << PCAR_DEVICE_NUM_OFFS)
-		
+
 #define PCAR_BUS_NUM_OFFS			16
 #define PCAR_BUS_NUM_MASK			(0xFF << PCAR_BUS_NUM_OFFS)
-		
+
 #define PCAR_CONFIG_EN				BIT31
 
 
@@ -400,8 +400,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                  PCR_MASTER_DAC_EN                      |       \
                  PCR_MASTER_M64_ALLIGN          |       \
                  PCR_ERRORS_PROPAGATION_EN)
-                 
-                 
+
+
 #define PCI_ARBITER_CTRL_DEFAULT_MASK   0x801fc07a
 #define PCI_ARBITER_CTRL_DEFAULT        \
         (PACR_BROKEN_VAL_PCIX_MIN << PACR_BROKEN_VAL_OFFS)
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c
index 068aac2..5a30c93 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -66,23 +66,23 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "ctrlEnv/mvCtrlEnvLib.h"
 
-/* defines  */       
-#ifdef MV_DEBUG         
+/* defines  */
+#ifdef MV_DEBUG
 #define DB(x)	x
-#else                
-#define DB(x)    
-#endif	             
+#else
+#define DB(x)
+#endif
 
 MV_STATUS mvPexHalInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 {
 	MV_PEX_MODE pexMode;
 	MV_U32 regVal;
 	MV_U32	status;
- 
+
     /* First implement Guideline (GL# PCI Express-2) Wrong Default Value    */
     /* to Transmitter Output Current (TXAMP) Relevant for: 88F5181-A1/B0/B1 */
     /* and 88F5281-B0 and above, 88F5182, 88F5082, 88F5181L, 88F6082/L      */
- 
+
     if ((mvCtrlModelGet() != MV_1281_DEV_ID) &&
 	(mvCtrlModelGet() != MV_6281_DEV_ID) &&
 	(mvCtrlModelGet() != MV_6192_DEV_ID) &&
@@ -148,10 +148,10 @@ MV_STATUS mvPexHalInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
         {
                 mvPexLocalBusNumSet(pexIf, PEX_HOST_BUS_NUM(pexIf));
                 mvPexLocalDevNumSet(pexIf, PEX_HOST_DEV_NUM(pexIf));
-        
+
                 /* Local device master Enable */
                 mvPexMasterEnable(pexIf, MV_TRUE);
-        
+
                 /* Local device slave Enable */
                 mvPexSlaveEnable(pexIf, mvPexLocalBusNumGet(pexIf),
                                                  mvPexLocalDevNumGet(pexIf), MV_TRUE);
@@ -161,7 +161,7 @@ MV_STATUS mvPexHalInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 		MV_REG_WRITE(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_STATUS_AND_COMMAND), status);
         }
 
-        /* now wait 500 ms to be sure the link is valid (spec compliant) */ 
+        /* now wait 500 ms to be sure the link is valid (spec compliant) */
         mvOsDelay(500);
 	/* Check if we have link */
 	if (MV_REG_READ(PEX_STATUS_REG(pexIf)) & PXSR_DL_DOWN)
@@ -231,17 +231,17 @@ MV_U32 mvPexModeGet(MV_U32 pexIf,MV_PEX_MODE *pexMode)
     if (MV_REG_READ(PEX_STATUS_REG(pexIf)) & PXSR_DL_DOWN)
     {
         pexMode->pexLinkUp = MV_FALSE;
-        
+
         /* If there is no link, the auto negotiation data is worthless */
         pexMode->pexWidth  = MV_PEX_WITDH_INVALID;
-    }   
+    }
     else
     {
         pexMode->pexLinkUp = MV_TRUE;
 
         /* We have link. The link width is now valid */
         pexData = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_LINK_CTRL_STAT_REG));
-        pexMode->pexWidth = ((pexData & PXLCSR_NEG_LNK_WDTH_MASK) >> 
+        pexMode->pexWidth = ((pexData & PXLCSR_NEG_LNK_WDTH_MASK) >>
                              PXLCSR_NEG_LNK_WDTH_OFFS);
     }
 
@@ -256,9 +256,9 @@ MV_U32 mvPexModeGet(MV_U32 pexIf,MV_PEX_MODE *pexMode)
 *
 * DESCRIPTION:
 *       This function performs a 32 bit read from PEX configuration space.
-*       It supports both type 0 and type 1 of Configuration Transactions 
-*       (local and over bridge). In order to read from local bus segment, use 
-*       bus number retrieved from mvPexLocalBusNumGet(). Other bus numbers 
+*       It supports both type 0 and type 1 of Configuration Transactions
+*       (local and over bridge). In order to read from local bus segment, use
+*       bus number retrieved from mvPexLocalBusNumGet(). Other bus numbers
 *       will result configuration transaction of type 1 (over bridge).
 *
 * INPUT:
@@ -266,7 +266,7 @@ MV_U32 mvPexModeGet(MV_U32 pexIf,MV_PEX_MODE *pexMode)
 *       bus     - PEX segment bus number.
 *       dev     - PEX device number.
 *       func    - Function number.
-*       regOffs - Register offset.       
+*       regOffs - Register offset.
 *
 * OUTPUT:
 *       None.
@@ -275,7 +275,7 @@ MV_U32 mvPexModeGet(MV_U32 pexIf,MV_PEX_MODE *pexMode)
 *       32bit register data, 0xffffffff on error
 *
 *******************************************************************************/
-MV_U32 mvPexConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func, 
+MV_U32 mvPexConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
                         MV_U32 regOff)
 {
 #if defined(PCIE_VIRTUAL_BRIDGE_SUPPORT)
@@ -304,25 +304,25 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 		DB(mvOsPrintf("mvPexConfigRead: ERR. device number illigal %d\n", dev));
 		return 0xFFFFFFFF;
 	}
-	
+
 	if (func >= MAX_PEX_FUNCS)
 	{
 		DB(mvOsPrintf("mvPexConfigRead: ERR. function num illigal %d\n", func));
 		return 0xFFFFFFFF;
 	}
-	
+
 	if (bus >= MAX_PEX_BUSSES)
 	{
 		DB(mvOsPrintf("mvPexConfigRead: ERR. bus number illigal %d\n", bus));
 		return MV_ERROR;
 	}
-    	     
+
     DB(mvOsPrintf("mvPexConfigRead: pexIf %d, bus %d, dev %d, func %d, regOff 0x%x\n",
                    pexIf, bus, dev, func, regOff));
-	
+
 	localDev = mvPexLocalDevNumGet(pexIf);
 	localBus = mvPexLocalBusNumGet(pexIf);
-                                     
+
     /* Speed up the process. In case on no link, return MV_ERROR */
     if ((dev != localDev) || (bus != localBus))
     {
@@ -335,25 +335,25 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
     }
 
     /* in PCI Express we have only one device number */
-	/* and this number is the first number we encounter 
+	/* and this number is the first number we encounter
 	else that the localDev*/
 	/* spec pex define return on config read/write on any device */
 	if (bus == localBus)
 	{
 		if (localDev == 0)
 		{
-			/* if local dev is 0 then the first number we encounter 
+			/* if local dev is 0 then the first number we encounter
 			after 0 is 1 */
 			if ((dev != 1)&&(dev != localDev))
 			{
 				return MV_ERROR;
-			}	
+			}
 		}
 		else
 		{
-			/* if local dev is not 0 then the first number we encounter 
+			/* if local dev is not 0 then the first number we encounter
 			is 0 */
-	
+
 			if ((dev != 0)&&(dev != localDev))
 			{
 				return MV_ERROR;
@@ -364,25 +364,25 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 			return MV_ERROR;
 		}
 	}
-    
-    
+
+
 	/* Creating PEX address to be passed */
 	pexData = (bus << PXCAR_BUS_NUM_OFFS);
 	pexData |= (dev << PXCAR_DEVICE_NUM_OFFS);
 	pexData |= (func << PXCAR_FUNC_NUM_OFFS);
 	pexData |= (regOff & PXCAR_REG_NUM_MASK); /* lgacy register space */
 	/* extended register space */
-	pexData |=(((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >> 
+	pexData |=(((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >>
 				PXCAR_REAL_EXT_REG_NUM_OFFS) << PXCAR_EXT_REG_NUM_OFFS);
 
-	pexData |= PXCAR_CONFIG_EN; 
-	
+	pexData |= PXCAR_CONFIG_EN;
+
 	/* Write the address to the PEX configuration address register */
 	MV_REG_WRITE(PEX_CFG_ADDR_REG(pexIf), pexData);
 
 	DB(mvOsPrintf("mvPexConfigRead:address pexData=%x ",pexData));
-    
-	
+
+
 	/* In order to let the PEX controller absorbed the address of the read 	*/
 	/* transaction we perform a validity check that the address was written */
 	if(pexData != MV_REG_READ(PEX_CFG_ADDR_REG(pexIf)))
@@ -391,14 +391,14 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 	}
 
 	/* cleaning Master Abort */
-	MV_REG_BIT_SET(PEX_CFG_DIRECT_ACCESS(pexIf,PEX_STATUS_AND_COMMAND), 
+	MV_REG_BIT_SET(PEX_CFG_DIRECT_ACCESS(pexIf,PEX_STATUS_AND_COMMAND),
 				   PXSAC_MABORT);
 #if 0
 	/* Guideline (GL# PCI Express-1) Erroneous Read Data on Configuration   */
 	/* This guideline is relevant for all devices except of the following devices:
 	   88F5281-BO and above, 88F5181L-A0 and above, 88F1281 A0 and above
 	   88F6183 A0 and above, 88F6183L  */
-	if ( ( (dev != localDev) || (bus != localBus) ) && 
+	if ( ( (dev != localDev) || (bus != localBus) ) &&
 		(
 		!(MV_5281_DEV_ID == mvCtrlModelGet())&&
 		!((MV_5181_DEV_ID == mvCtrlModelGet())&& (mvCtrlRevGet() >= MV_5181L_A0_REV))&&
@@ -408,25 +408,25 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 		!(MV_6281_DEV_ID == mvCtrlModelGet())&&
 		!(MV_6192_DEV_ID == mvCtrlModelGet())&&
 		!(MV_6190_DEV_ID == mvCtrlModelGet())&&
-        !(MV_6180_DEV_ID == mvCtrlModelGet())&& 
-		!(MV_78XX0_DEV_ID == mvCtrlModelGet()) 
+        !(MV_6180_DEV_ID == mvCtrlModelGet())&&
+		!(MV_78XX0_DEV_ID == mvCtrlModelGet())
 		))
 	{
 
 		/* PCI-Express configuration read work-around */
 
-		/* we will use one of the Punit (AHBToMbus) windows to access the xbar 
+		/* we will use one of the Punit (AHBToMbus) windows to access the xbar
 		and read the data from there */
 		/*
-		Need to configure the 2 free Punit (AHB to MBus bridge) 
+		Need to configure the 2 free Punit (AHB to MBus bridge)
 		address decoding windows:
-		Configure the flash Window to handle Configuration space requests 
+		Configure the flash Window to handle Configuration space requests
 		for PEX0/1:
-		1.    write 0x7931/0x7941 to the flash window and the size, 
+		1.    write 0x7931/0x7941 to the flash window and the size,
 		      79-xbar attr (pci cfg), 3/4-xbar target (pex0/1), 1-WinEn
-		2.    write base to flash window 
-		
-		Configuration transactions from the CPU should write/read the data 
+		2.    write base to flash window
+
+		Configuration transactions from the CPU should write/read the data
 		to/from address of the form:
 		addr[31:28] = 0x5 (for PEX0) or 0x6 (for PEX1)
 		addr[27:24] = extended register number
@@ -443,10 +443,10 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 			MV_U32 pciAddr=0;
 			MV_U32 remapLow=0,remapHigh=0;
 
-			/* 
-			We will use DEV_CS2\Flash window for this workarround 
+			/*
+			We will use DEV_CS2\Flash window for this workarround
 			*/
-            
+
 			winNum = mvAhbToMbusWinTargetGet(PEX_CONFIG_RW_WA_TARGET);
 
 			/* save remap values if exist */
@@ -456,7 +456,7 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 				remapHigh = MV_REG_READ(AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum));
 
 			}
-			
+
 
 			/* save the original window values */
 			mvAhbToMbusWinGet(winNum,&originWin);
@@ -466,12 +466,12 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 				/* set the window as xbar window */
 				if (pexIf)
 				{
-					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum), 
+					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum),
 					(0x7931 | (((originWin.addrWin.size >> 16)-1) ) << 16));
 				}
 				else
 				{
-					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum), 
+					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum),
 					(0x7941 | (((originWin.addrWin.size >> 16)-1) ) << 16));
 				}
 
@@ -481,19 +481,19 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 				/*pciAddr = originWin.addrWin.baseLow;*/
 				pciAddr = (MV_U32)CPU_MEMIO_UNCACHED_ADDR(
 					(MV_U32)originWin.addrWin.baseLow);
-			
+
 			}
 			else
 			{
 				/* set the window as xbar window */
 				if (pexIf)
 				{
-					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum), 
+					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum),
 					(0x7931 | (((PEX_CONFIG_RW_WA_SIZE >> 16)-1) ) << 16));
 				}
 				else
 				{
-					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum), 
+					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum),
 					(0x7941 | (((PEX_CONFIG_RW_WA_SIZE >> 16)-1) ) << 16));
 				}
 
@@ -502,8 +502,8 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 
 				pciAddr = (MV_U32)CPU_MEMIO_UNCACHED_ADDR(PEX_CONFIG_RW_WA_BASE);
 			}
-			
-			
+
+
 			/* remap should be as base */
 			if ((1 == winNum)||(0 == winNum))
 			{
@@ -518,7 +518,7 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 			pciAddr |= (func << 8);
 			pciAddr |= (regOff & PXCAR_REG_NUM_MASK); /* lgacy register space */
 
-			pexData = *(MV_U32*)pciAddr; 
+			pexData = *(MV_U32*)pciAddr;
 			pexData = MV_32BIT_LE(pexData); /* Data always in LE */
 
 			/* restore the original window values */
@@ -542,7 +542,7 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 	}
 
 	DB(mvOsPrintf("mvPexConfigRead: got : %x \n",pexData));
-	
+
 	return pexData;
 
 }
@@ -552,9 +552,9 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *
 * DESCRIPTION:
 *       This function performs a 32 bit write to PEX configuration space.
-*       It supports both type 0 and type 1 of Configuration Transactions 
-*       (local and over bridge). In order to write to local bus segment, use 
-*       bus number retrieved from mvPexLocalBusNumGet(). Other bus numbers 
+*       It supports both type 0 and type 1 of Configuration Transactions
+*       (local and over bridge). In order to write to local bus segment, use
+*       bus number retrieved from mvPexLocalBusNumGet(). Other bus numbers
 *       will result configuration transaction of type 1 (over bridge).
 *
 * INPUT:
@@ -562,7 +562,7 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *       bus     - PEX segment bus number.
 *       dev     - PEX device number.
 *       func    - Function number.
-*       regOffs - Register offset.       
+*       regOffs - Register offset.
 *       data    - 32bit data.
 *
 * OUTPUT:
@@ -572,7 +572,7 @@ MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
 *
 *******************************************************************************/
-MV_STATUS mvPexConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, 
+MV_STATUS mvPexConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
                            MV_U32 func, MV_U32 regOff, MV_U32 data)
 {
 #if defined(PCIE_VIRTUAL_BRIDGE_SUPPORT)
@@ -591,7 +591,7 @@ MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
 	{
 		if (pexIf >= mvCtrlPexMaxIfGet())
 		{
-			mvOsPrintf("mvPexConfigWrite: ERR. Invalid PEX interface %d\n", 
+			mvOsPrintf("mvPexConfigWrite: ERR. Invalid PEX interface %d\n",
 																		pexIf);
 			return MV_ERROR;
 		}
@@ -620,9 +620,9 @@ MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
 	localDev = mvPexLocalDevNumGet(pexIf);
 	localBus = mvPexLocalBusNumGet(pexIf);
 
-	
+
 	/* in PCI Express we have only one device number other than ourselves*/
-	/* and this number is the first number we encounter 
+	/* and this number is the first number we encounter
 		else than the localDev that can be any valid dev number*/
 	/* pex spec define return on config read/write on any device */
 	if (bus == localBus)
@@ -630,26 +630,26 @@ MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
 
 		if (localDev == 0)
 		{
-			/* if local dev is 0 then the first number we encounter 
+			/* if local dev is 0 then the first number we encounter
 			after 0 is 1 */
 			if ((dev != 1)&&(dev != localDev))
 			{
 				return MV_ERROR;
 			}
-	
+
 		}
 		else
 		{
-			/* if local dev is not 0 then the first number we encounter 
+			/* if local dev is not 0 then the first number we encounter
 			is 0 */
-	
+
 			if ((dev != 0)&&(dev != localDev))
 			{
 				return MV_ERROR;
 			}
 		}
 
-		
+
 	}
 
 	/* if we are not accessing ourselves , then check the link */
@@ -675,12 +675,12 @@ MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
 	pexData |= (func << PXCAR_FUNC_NUM_OFFS);
 	pexData |= (regOff & PXCAR_REG_NUM_MASK); /* lgacy register space */
 	/* extended register space */
-	pexData |=(((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >> 
+	pexData |=(((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >>
 				PXCAR_REAL_EXT_REG_NUM_OFFS) << PXCAR_EXT_REG_NUM_OFFS);
-	pexData |= PXCAR_CONFIG_EN; 
-	
+	pexData |= PXCAR_CONFIG_EN;
+
 	DB(mvOsPrintf("mvPexConfigWrite: If=%x bus=%x func=%x dev=%x regOff=%x data=%x \n",
-		   pexIf,bus,func,dev,regOff,data,pexData) ); 
+		   pexIf,bus,func,dev,regOff,data,pexData) );
 
 	/* Write the address to the PEX configuration address register */
 	MV_REG_WRITE(PEX_CFG_ADDR_REG(pexIf), pexData);
@@ -706,9 +706,9 @@ MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
 * mvPexMasterEnable - Enable/disale PEX interface master transactions.
 *
 * DESCRIPTION:
-*       This function performs read modified write to PEX command status 
-*       (offset 0x4) to set/reset bit 2. After this bit is set, the PEX 
-*       master is allowed to gain ownership on the bus, otherwise it is 
+*       This function performs read modified write to PEX command status
+*       (offset 0x4) to set/reset bit 2. After this bit is set, the PEX
+*       master is allowed to gain ownership on the bus, otherwise it is
 *       incapable to do so.
 *
 * INPUT:
@@ -737,7 +737,7 @@ MV_STATUS mvPexMasterEnable(MV_U32 pexIf, MV_BOOL enable)
 
 	localBus = mvPexLocalBusNumGet(pexIf);
 	localDev = mvPexLocalDevNumGet(pexIf);
-	
+
 	pexCommandStatus = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf,
 							    PEX_STATUS_AND_COMMAND));
 
@@ -751,7 +751,7 @@ MV_STATUS mvPexMasterEnable(MV_U32 pexIf, MV_BOOL enable)
 		pexCommandStatus &= ~PXSAC_MASTER_EN;
 	}
 
-	
+
 	MV_REG_WRITE(PEX_CFG_DIRECT_ACCESS(pexIf,PEX_STATUS_AND_COMMAND),
 				 pexCommandStatus);
 
@@ -763,10 +763,10 @@ MV_STATUS mvPexMasterEnable(MV_U32 pexIf, MV_BOOL enable)
 * mvPexSlaveEnable - Enable/disale PEX interface slave transactions.
 *
 * DESCRIPTION:
-*       This function performs read modified write to PEX command status 
-*       (offset 0x4) to set/reset bit 0 and 1. After those bits are set, 
-*       the PEX slave is allowed to respond to PEX IO space access (bit 0) 
-*       and PEX memory space access (bit 1). 
+*       This function performs read modified write to PEX command status
+*       (offset 0x4) to set/reset bit 0 and 1. After those bits are set,
+*       the PEX slave is allowed to respond to PEX IO space access (bit 0)
+*       and PEX memory space access (bit 1).
 *
 * INPUT:
 *       pexIf  - PEX interface number.
@@ -798,16 +798,16 @@ MV_STATUS mvPexSlaveEnable(MV_U32 pexIf, MV_U32 bus,MV_U32 dev, MV_BOOL enable)
 
 	}
 
-	
+
 	RegOffs = PEX_STATUS_AND_COMMAND;
-	
+
 	pexCommandStatus = mvPexConfigRead(pexIf, bus, dev, 0, RegOffs);
 
     if (MV_TRUE == enable)
 	{
 		pexCommandStatus |= (PXSAC_IO_EN | PXSAC_MEM_EN);
 	}
-	else                             
+	else
 	{
 		pexCommandStatus &= ~(PXSAC_IO_EN | PXSAC_MEM_EN);
 	}
@@ -833,7 +833,7 @@ MV_STATUS mvPexSlaveEnable(MV_U32 pexIf, MV_U32 bus,MV_U32 dev, MV_BOOL enable)
 *       None.
 *
 * RETURN:
-*       MV_NOT_ALLOWED in case PEX interface is PEX-X. 
+*       MV_NOT_ALLOWED in case PEX interface is PEX-X.
 *		MV_BAD_PARAM on bad parameters ,
 *       otherwise MV_OK
 *
@@ -931,7 +931,7 @@ MV_U32 mvPexLocalBusNumGet(MV_U32 pexIf)
 *       None.
 *
 * RETURN:
-*       MV_NOT_ALLOWED in case PEX interface is PEX-X. 
+*       MV_NOT_ALLOWED in case PEX interface is PEX-X.
 *		MV_BAD_PARAM on bad parameters ,
 *       otherwise MV_OK
 *
@@ -950,12 +950,12 @@ MV_STATUS mvPexLocalDevNumSet(MV_U32 pexIf, MV_U32 devNum)
 	}
 	if (devNum >= MAX_PEX_DEVICES)
 	{
-		mvOsPrintf("mvPexLocalDevNumSet: ERR. device number illigal %d\n", 
+		mvOsPrintf("mvPexLocalDevNumSet: ERR. device number illigal %d\n",
 																	   devNum);
 		return MV_BAD_PARAM;
 
 	}
-	
+
 	localBus = mvPexLocalBusNumGet(pexIf);
 	localDev = mvPexLocalDevNumGet(pexIf);
 
@@ -993,17 +993,17 @@ MV_U32 mvPexLocalDevNumGet(MV_U32 pexIf)
 	MV_U32 pexStatus;
 
 	/* Parameter checking   */
-	
+
 	if (PEX_DEFAULT_IF != pexIf)
 	{
 		if (pexIf >= mvCtrlPexMaxIfGet())
 		{
-			mvOsPrintf("mvPexLocalDevNumGet: ERR. Invalid PEX interface %d\n", 
+			mvOsPrintf("mvPexLocalDevNumGet: ERR. Invalid PEX interface %d\n",
 																   		pexIf);
 			return 0xFFFFFFFF;
 		}
 	}
-	
+
 	pexStatus  = MV_REG_READ(PEX_STATUS_REG(pexIf));
 
 	pexStatus &= PXSR_PEX_DEV_NUM_MASK;
@@ -1022,7 +1022,7 @@ MV_VOID mvPexPhyRegRead(MV_U32 pexIf, MV_U32 regOffset, MV_U16 *value)
 	}
 	regAddr = (BIT31 | ((regOffset & 0x3fff) << 16));
 	MV_REG_WRITE(PEX_PHY_ACCESS_REG(pexIf), regAddr);
-	*value = MV_REG_READ(PEX_PHY_ACCESS_REG(pexIf)); 
+	*value = MV_REG_READ(PEX_PHY_ACCESS_REG(pexIf));
 }
 
 
@@ -1071,7 +1071,7 @@ MV_STATUS mvPexActiveStateLinkPMEnable(MV_U32 pexIf, MV_BOOL enable)
 		reg |= PXPMER_L1_ASPM_EN_MASK;
 	MV_REG_WRITE(PEX_PWR_MNG_EXT_REG(pexIf), reg);
 
-	/* Enable / Disable L0/1 entry */ 
+	/* Enable / Disable L0/1 entry */
 	reg = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_LINK_CTRL_STAT_REG))
 			& ~PXLCSR_ASPM_CNT_MASK;
 	if(enable == MV_TRUE)
@@ -1120,7 +1120,7 @@ MV_BOOL mvPexIsPowerUp(MV_U32 pexIf)
 		mvOsPrintf("mvPexIsPowerUp: ERR. Invalid PEX interface %d\n", pexIf);
 		return MV_FALSE;
 	}
-	return mvCtrlPwrClckGet(PEX_UNIT_ID, pexIf);	
+	return mvCtrlPwrClckGet(PEX_UNIT_ID, pexIf);
 }
 
 
@@ -1131,7 +1131,7 @@ MV_VOID mvPexPowerDown(MV_U32 pexIf)
 		(mvCtrlModelGet() == MV_78100_DEV_ID) ||
 		(mvCtrlModelGet() == MV_78200_DEV_ID) )
 	{
-		mvCtrlPwrClckSet(PEX_UNIT_ID, pexIf, MV_FALSE);	
+		mvCtrlPwrClckSet(PEX_UNIT_ID, pexIf, MV_FALSE);
 	}
 	else
 	{
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.h
index d8f1cdd..3845962 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -73,7 +73,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 /* NOTE not supported in this driver:*/
-  
+
 
 /* defines */
 /* The number of supported PEX interfaces depend on Marvell controller 		*/
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h
index 8ac1698..713a294 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -112,7 +112,7 @@ the upper 4 bits of the full register address */
 #define PXCAR_REAL_EXT_REG_NUM_OFFS     8
 #define PXCAR_REAL_EXT_REG_NUM_MASK     (0xF << PXCAR_REAL_EXT_REG_NUM_OFFS)
 
-/* The traditional PCI spec defined 6-bit field to describe register offset.*/ 
+/* The traditional PCI spec defined 6-bit field to describe register offset.*/
 /* The new PCI Express extend the register offset by an extra 4-bits.       */
 /* The below macro assign 10-bit register offset into the apprpreate        */
 /* fields in the CFG_ADDR_REG                                               */
@@ -140,9 +140,9 @@ emulation messages.
 Mask bit per cause bit. If a bit is set to 1, the corresponding event is
 enabled. Mask does not affect setting of the Interrupt Cause register bits;
 it only affects the assertion of the interrupt .*/
-                                          
 
-#define PXICR_MDIS_CAUSE			BIT1  /* Attempt to generate PCI transaction 
+
+#define PXICR_MDIS_CAUSE			BIT1  /* Attempt to generate PCI transaction
                                              while master is disabled */
 #define PXICR_ERR_WRTO_REG_CAUSE	BIT3  /* Erroneous write attempt to
                                              PCI Express internal register*/
@@ -197,10 +197,10 @@ it only affects the assertion of the interrupt .*/
 #define PXCR_DEV_TYPE_CTRL_MASK			BIT1
 #define PXCR_DEV_TYPE_CTRL_CMPLX		(1 << PXCR_DEV_TYPE_CTRL_OFFS)
 #define PXCR_DEV_TYPE_CTRL_POINT		(0 << PXCR_DEV_TYPE_CTRL_OFFS)
-#define PXCR_CFG_MAP_TO_MEM_EN			BIT2  /* Configuration Header Mapping 
+#define PXCR_CFG_MAP_TO_MEM_EN			BIT2  /* Configuration Header Mapping
 											   to Memory Space Enable         */
 
-#define PXCR_CFG_MAP_TO_MEM_EN			BIT2 /* Configuration Header Mapping 
+#define PXCR_CFG_MAP_TO_MEM_EN			BIT2 /* Configuration Header Mapping
 											   to Memory Space Enable*/
 
 #define PXCR_RSRV1_OFFS					5
@@ -262,7 +262,7 @@ it only affects the assertion of the interrupt .*/
 
 #define PXFCR_CH_INIT_FC_OFFS			16 /* Completion Headers Flow Control
 											  Credit Initial Value Infinite*/
-										
+
 #define PXFCR_CH_INIT_FC_MASK			(0xff << PXFCR_CH_INIT_FC_OFFS)
 
 #define PXFCR_FC_UPDATE_TO_OFFS			24 /* Flow Control Update Timeout */
@@ -383,7 +383,7 @@ it only affects the assertion of the interrupt .*/
 
 
 /* PCI Express Class Code and Revision ID Register*/
-/*PEX_CLASS_CODE_AND_REVISION_ID (PXCCARI)*/       
+/*PEX_CLASS_CODE_AND_REVISION_ID (PXCCARI)*/
 
 #define PXCCARI_REVID_OFFS		0		/* Revision ID */
 #define PXCCARI_REVID_MASK		(0xff << PXCCARI_REVID_OFFS)
@@ -402,7 +402,7 @@ it only affects the assertion of the interrupt .*/
 
 
 /* PCI Express BIST, Header Type and Cache Line Size Register*/
-/*PEX_BIST_HDR_TYPE_LAT_TMR_CACHE_LINE (PXBHTLTCL)*/ 
+/*PEX_BIST_HDR_TYPE_LAT_TMR_CACHE_LINE (PXBHTLTCL)*/
 
 #define PXBHTLTCL_CACHELINE_OFFS		0	/* Specifies the cache line size */
 #define PXBHTLTCL_CACHELINE_MASK		(0xff << PXBHTLTCL_CACHELINE_OFFS)
@@ -423,8 +423,8 @@ it only affects the assertion of the interrupt .*/
 
 #define PXBHTLTCL_BISTACT			BIT30	/* BIST Activate bit */
 #define PXBHTLTCL_BISTCAP			BIT31	/* BIST Capable Bit */
-#define PXBHTLTCL_BISTCAP_OFFS		31	
-#define PXBHTLTCL_BISTCAP_MASK		BIT31	
+#define PXBHTLTCL_BISTCAP_OFFS		31
+#define PXBHTLTCL_BISTCAP_MASK		BIT31
 #define PXBHTLTCL_BISTCAP_VAL		0
 
 
@@ -502,7 +502,7 @@ it only affects the assertion of the interrupt .*/
 #define PXPMSC_PM_DATA_MASK			(0xff << PXPMSC_PM_DATA_OFFS)
 
 
-/* PCI Express MSI Message Control Register*/								 
+/* PCI Express MSI Message Control Register*/
 /*PEX_MSI_MESSAGE_CONTROL (PXMMC)*/
 
 #define PXMMC_CAP_ID_OFFS			0 /* Capability ID */
@@ -525,7 +525,7 @@ it only affects the assertion of the interrupt .*/
 /* PCI Express MSI Message Address Register*/
 /*PEX_MSI_MESSAGE_ADDR (PXMMA)*/
 
-#define PXMMA_MSI_ADDR_OFFS			2 /* Message Address  corresponds to 
+#define PXMMA_MSI_ADDR_OFFS			2 /* Message Address  corresponds to
 										Address[31:2] of the MSI MWr TLP*/
 #define PXMMA_MSI_ADDR_MASK			(0x3fffffff << PXMMA_MSI_ADDR_OFFS)
 
@@ -533,7 +533,7 @@ it only affects the assertion of the interrupt .*/
 /* PCI Express MSI Message Address (High) Register */
 /*PEX_MSI_MESSAGE_HIGH_ADDR (PXMMHA)*/
 
-#define PXMMA_MSI_ADDR_H_OFFS		0 /* Message Upper Address corresponds to 
+#define PXMMA_MSI_ADDR_H_OFFS		0 /* Message Upper Address corresponds to
 											Address[63:32] of the MSI MWr TLP*/
 #define PXMMA_MSI_ADDR_H_MASK		(0xffffffff << PXMMA_MSI_ADDR_H_OFFS )
 
@@ -545,7 +545,7 @@ it only affects the assertion of the interrupt .*/
 #define PXMMD_MSI_DATA_MASK 		(0xffff << PXMMD_MSI_DATA_OFFS )
 
 
-/* PCI Express Capability Register*/								 
+/* PCI Express Capability Register*/
 /*PEX_CAPABILITY_REG (PXCR)*/
 
 #define PXCR_CAP_ID_OFFS			0	/* Capability ID*/
@@ -585,14 +585,14 @@ it only affects the assertion of the interrupt .*/
 
 #define PXDCR_EP_L1_ACC_LAT_OFFS 			9 /* Endpoint L1 Acceptable Latency*/
 #define PXDCR_EP_L1_ACC_LAT_MASK			(0x7 << PXDCR_EP_L1_ACC_LAT_OFFS)
-#define PXDCR_EP_L1_ACC_LAT_64NS_LESS       (0x0 << PXDCR_EP_L1_ACC_LAT_OFFS) 
-#define PXDCR_EP_L1_ACC_LAT_64NS_128NS      (0x1 << PXDCR_EP_L1_ACC_LAT_OFFS) 
-#define PXDCR_EP_L1_ACC_LAT_128NS_256NS     (0x2 << PXDCR_EP_L1_ACC_LAT_OFFS) 
-#define PXDCR_EP_L1_ACC_LAT_256NS_512NS     (0x3 << PXDCR_EP_L1_ACC_LAT_OFFS) 
-#define PXDCR_EP_L1_ACC_LAT_512NS_1US       (0x4 << PXDCR_EP_L1_ACC_LAT_OFFS) 
-#define PXDCR_EP_L1_ACC_LAT_1US_2US         (0x5 << PXDCR_EP_L1_ACC_LAT_OFFS) 
-#define PXDCR_EP_L1_ACC_LAT_2US_4US         (0x6 << PXDCR_EP_L1_ACC_LAT_OFFS) 
-#define PXDCR_EP_L1_ACC_LAT_4US_MORE        (0x7 << PXDCR_EP_L1_ACC_LAT_OFFS) 
+#define PXDCR_EP_L1_ACC_LAT_64NS_LESS       (0x0 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXDCR_EP_L1_ACC_LAT_64NS_128NS      (0x1 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXDCR_EP_L1_ACC_LAT_128NS_256NS     (0x2 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXDCR_EP_L1_ACC_LAT_256NS_512NS     (0x3 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXDCR_EP_L1_ACC_LAT_512NS_1US       (0x4 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXDCR_EP_L1_ACC_LAT_1US_2US         (0x5 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXDCR_EP_L1_ACC_LAT_2US_4US         (0x6 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXDCR_EP_L1_ACC_LAT_4US_MORE        (0x7 << PXDCR_EP_L1_ACC_LAT_OFFS)
 
 
 #define PXDCR_ATT_BUT_PRS_OFFS				12 /* Attention Button Present*/
@@ -607,7 +607,7 @@ it only affects the assertion of the interrupt .*/
 #define PXDCR_PWR_IND_PRS_MASK       		BIT14
 #define PXDCR_PWR_IND_PRS_IMPLEMENTED		BIT14
 
-#define PXDCR_CAP_SPL_VAL_OFFS				18 /*Captured Slot Power Limit 
+#define PXDCR_CAP_SPL_VAL_OFFS				18 /*Captured Slot Power Limit
 												 Value*/
 #define PXDCR_CAP_SPL_VAL_MASK				(0xff << PXDCR_CAP_SPL_VAL_OFFS)
 
@@ -621,7 +621,7 @@ it only affects the assertion of the interrupt .*/
 #define PXDCSR_COR_ERR_REP_EN		BIT0 /* Correctable Error Reporting Enable*/
 #define PXDCSR_NF_ERR_REP_EN		BIT1 /* Non-Fatal Error Reporting Enable*/
 #define PXDCSR_F_ERR_REP_EN			BIT2 /* Fatal Error Reporting Enable*/
-#define PXDCSR_UR_REP_EN			BIT3 /* Unsupported Request (UR) 
+#define PXDCSR_UR_REP_EN			BIT3 /* Unsupported Request (UR)
 													Reporting Enable*/
 #define PXDCSR_EN_RO 				BIT4 /* Enable Relaxed Ordering*/
 
@@ -664,13 +664,13 @@ it only affects the assertion of the interrupt .*/
 
 #define PXLCR_L0S_EXT_LAT_OFFS 			12 /* L0s Exit Latency*/
 #define PXLCR_L0S_EXT_LAT_MASK			(0x7 << PXLCR_L0S_EXT_LAT_OFFS)
-#define PXLCR_L0S_EXT_LAT_64NS_LESS     (0x0 << PXDCR_EP_L1_ACC_LAT_OFFS)  
-#define PXLCR_L0S_EXT_LAT_64NS_128NS   	(0x1 << PXDCR_EP_L1_ACC_LAT_OFFS)  
-#define PXLCR_L0S_EXT_LAT_128NS_256NS   (0x2 << PXDCR_EP_L1_ACC_LAT_OFFS)  
-#define PXLCR_L0S_EXT_LAT_256NS_512NS   (0x3 << PXDCR_EP_L1_ACC_LAT_OFFS)  
-#define PXLCR_L0S_EXT_LAT_512NS_1US     (0x4 << PXDCR_EP_L1_ACC_LAT_OFFS)  
-#define PXLCR_L0S_EXT_LAT_1US_2US       (0x5 << PXDCR_EP_L1_ACC_LAT_OFFS)  
-#define PXLCR_L0S_EXT_LAT_2US_4US       (0x6 << PXDCR_EP_L1_ACC_LAT_OFFS)  
+#define PXLCR_L0S_EXT_LAT_64NS_LESS     (0x0 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXLCR_L0S_EXT_LAT_64NS_128NS   	(0x1 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXLCR_L0S_EXT_LAT_128NS_256NS   (0x2 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXLCR_L0S_EXT_LAT_256NS_512NS   (0x3 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXLCR_L0S_EXT_LAT_512NS_1US     (0x4 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXLCR_L0S_EXT_LAT_1US_2US       (0x5 << PXDCR_EP_L1_ACC_LAT_OFFS)
+#define PXLCR_L0S_EXT_LAT_2US_4US       (0x6 << PXDCR_EP_L1_ACC_LAT_OFFS)
 
 #define PXLCR_POR_TNUM_OFFS 			24 /* Port Number */
 #define PXLCR_POR_TNUM_MASK				(0xff << PXLCR_POR_TNUM_OFFS)
@@ -708,8 +708,8 @@ it only affects the assertion of the interrupt .*/
 #define PXLCSR_SLT_CLK_CFG_MASK		BIT28
 #define PXLCSR_SLT_CLK_CFG_INDPNT	(0x0 << PXLCSR_SLT_CLK_CFG_OFFS)
 #define PXLCSR_SLT_CLK_CFG_REF		(0x1 << PXLCSR_SLT_CLK_CFG_OFFS)
-								
-/* PCI Express Advanced Error Report Header Register */								 
+
+/* PCI Express Advanced Error Report Header Register */
 /*PEX_ADV_ERR_RPRT_HDR_TRGT_REG (PXAERHTR)*/
 
 /* PCI Express Uncorrectable Error Status Register*/
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c
index 19c871a..59d0383 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c
@@ -1,313 +1,313 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#include "mvPex.h"
-
-//#define MV_DEBUG
-/* defines  */       
-#ifdef MV_DEBUG         
-	#define DB(x)	x
-#else                
-	#define DB(x)    
-#endif	             
-
-/* locals */         
-typedef struct
-{
-	MV_U32 data;
-	MV_U32 mask;
-}PEX_HEADER_DATA;
-
-/* local function forwad decleration */
-MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func, 
-                        MV_U32 regOff);
-MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, 
-                           MV_U32 func, MV_U32 regOff, MV_U32 data);
-void resetPexConfig(MV_U32 pexIf, MV_U32 bus, MV_U32 dev);
-
-
-PEX_HEADER_DATA configHdr[16] = 
-{
-{0x888811ab, 0x00000000}, /*[device ID, vendor ID] */
-{0x00100007, 0x0000ffff}, /*[status register, command register] */  
-{0x0604000e, 0x00000000}, /*[programming interface, sub class code, class code, revision ID] */
-{0x00010008, 0x00000000},  /*[BIST, header type, latency time, cache line] */
-{0x00000000, 0x00000000},  /*[base address 0] */             
-{0x00000000, 0x00000000},  /*[base address 1] */             
-{0x00000000, 0x00ffffff},  /*[secondary latency timersubordinate bus number, secondary bus number, primary bus number] */         
-{0x0000f101, 0x00000000},  /*[secondary status ,IO limit, IO base] */
-{0x9ff0a000, 0x00000000},  /*[memory limit, memory base] */                
-{0x0001fff1, 0x00000000},  /*[prefetch memory limit, prefetch memory base] */       
-{0xffffffff, 0x00000000},  /*[prefetch memory base upper] */ 
-{0x00000000, 0x00000000},  /*[prefetch memory limit upper] */
-{0xeffff000, 0x00000000},  /*[IO limit upper 16 bits, IO base upper 16 bits] */      
-{0x00000000, 0x00000000},  /*[reserved, capability pointer] */ 
-{0x00000000, 0x00000000},  /*[expansion ROM base address] */ 
-{0x00000000, 0x000000FF},  /*[bridge control, interrupt pin, interrupt line] */             
-};
-
-
-#define HEADER_WRITE(data, offset) configHdr[offset/4].data = ((configHdr[offset/4].data & ~configHdr[offset/4].mask) | \
-																(data & configHdr[offset/4].mask))
-#define HEADER_READ(offset) configHdr[offset/4].data
-
-/*******************************************************************************
-* mvVrtBrgPexInit - Initialize PEX interfaces
-*
-* DESCRIPTION:
-*
-* This function is responsible of intialization of the Pex Interface , It 
-* configure the Pex Bars and Windows in the following manner:
-*
-*  Assumptions : 
-*				Bar0 is always internal registers bar
-*			    Bar1 is always the DRAM bar
-*				Bar2 is always the Device bar
-*
-*  1) Sets the Internal registers bar base by obtaining the base from
-*	  the CPU Interface
-*  2) Sets the DRAM bar base and size by getting the base and size from
-*     the CPU Interface when the size is the sum of all enabled DRAM 
-*	  chip selects and the base is the base of CS0 .
-*  3) Sets the Device bar base and size by getting these values from the 
-*     CPU Interface when the base is the base of the lowest base of the
-*     Device chip selects, and the 
-*
-*
-* INPUT:
-*
-*       pexIf   -  PEX interface number.
-*
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
-*
-*******************************************************************************/
-MV_STATUS mvPexVrtBrgInit(MV_U32 pexIf)
-{
-	/* reset PEX tree to recover previous U-boot/Boot configurations */
-	MV_U32 localBus = mvPexLocalBusNumGet(pexIf);
-
-
-	resetPexConfig(pexIf, localBus, 1);
-	return MV_OK;
-}
-
-
-MV_U32 mvPexVrtBrgConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func, 
-                        MV_U32 regOff)
-{
-	
-	MV_U32 localBus = mvPexLocalBusNumGet(pexIf);
-	MV_U32 localDev = mvPexLocalDevNumGet(pexIf);
-	MV_U32 val;  
-	if(bus == localBus)
-	{
-		if(dev > 1)
-		{
-/* on the local device allow only device #0 & #1 */
-			return 0xffffffff;
-		}
-		else
-		if (dev == localDev)
-		{
-			/* read the memory controller registers */
-			return mvPexHwConfigRead (pexIf, bus, dev, func, regOff);
-		}
-		else
-		{
-			/* access the virtual brg header */
-			return HEADER_READ(regOff);
-		}
-	}
-	else
-	if(bus == (localBus + 1))
-	{
-		/* access the device behind the virtual bridge */
-		if((dev == localDev) || (dev > 1))
-		{
-			return 0xffffffff;
-		}
-		else
-		{
-			/* access the device behind the virtual bridge, in this case 
-			*  change the bus number to the local bus number in order to 
-			*  generate type 0 config cycle
-			*/			
-			mvPexLocalBusNumSet(pexIf, bus);
-			mvPexLocalDevNumSet(pexIf, 1);
-			val = mvPexHwConfigRead (pexIf, bus, 0, func, regOff);
-			mvPexLocalBusNumSet(pexIf, localBus);
-			mvPexLocalDevNumSet(pexIf, localDev);
-			return val;
-		}
-	}
-	/* for all other devices use the HW function to get the 
-	*  requested registers
-	*/
-	mvPexLocalDevNumSet(pexIf, 1);
-	val = mvPexHwConfigRead (pexIf, bus, dev, func, regOff);
-	mvPexLocalDevNumSet(pexIf, localDev);	
-	return val;
-}
-
-
-MV_STATUS mvPexVrtBrgConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, 
-                           MV_U32 func, MV_U32 regOff, MV_U32 data)
-{
-	MV_U32 localBus = mvPexLocalBusNumGet(pexIf);
-	MV_U32 localDev = mvPexLocalDevNumGet(pexIf);
-	MV_STATUS	status;
-
-	if(bus == localBus)
-	{
-		if(dev > 1)
-		{
-			/* on the local device allow only device #0 & #1 */
-			return MV_ERROR;
-		}
-		else
-		if (dev == localDev)
-		{
-			/* read the memory controller registers */
-			return mvPexHwConfigWrite (pexIf, bus, dev, func, regOff, data);			
-		}
-		else
-		{
-			/* access the virtual brg header */
-			HEADER_WRITE(data, regOff);
-			return MV_OK;
-		}
-	}
-	else
-	if(bus == (localBus + 1))
-	{
-		/* access the device behind the virtual bridge */
-		if((dev == localDev) || (dev > 1))
-		{
-			return MV_ERROR;
-		}
-		else
-		{
-			/* access the device behind the virtual bridge, in this case 
-			*  change the bus number to the local bus number in order to 
-			*  generate type 0 config cycle
-			*/
-			//return mvPexHwConfigWrite (pexIf, localBus, dev, func, regOff, data);
-			mvPexLocalBusNumSet(pexIf, bus);
-			mvPexLocalDevNumSet(pexIf, 1);
-			status = mvPexHwConfigWrite (pexIf, bus, 0, func, regOff, data);
-			mvPexLocalBusNumSet(pexIf, localBus);
-			mvPexLocalDevNumSet(pexIf, localDev);
-			return status;
-
-		}
-	}
-	/* for all other devices use the HW function to get the 
-	*  requested registers
-	*/
-	mvPexLocalDevNumSet(pexIf, 1);
-	status = mvPexHwConfigWrite (pexIf, bus, dev, func, regOff, data);
-	mvPexLocalDevNumSet(pexIf, localDev);
-	return status;
-}
-
-
-
-
-void resetPexConfig(MV_U32 pexIf, MV_U32 bus, MV_U32 dev)
-{
-	MV_U32 tData;
-	MV_U32 i;
-
-	/* restore the PEX configuration to initialization state */
-	/* in case PEX P2P call recursive and reset config */
-	tData = mvPexHwConfigRead (pexIf, bus, dev, 0x0, 0x0);
-	if(tData != 0xffffffff)
-	{
-		/* agent had been found - check whether P2P */
-		tData = mvPexHwConfigRead (pexIf, bus, dev, 0x0, 0x8);
-		if((tData & 0xffff0000) == 0x06040000)
-		{/* P2P */
-			/* get the sec bus and the subordinate */
-			MV_U32 secBus;	
-			tData = mvPexHwConfigRead (pexIf, bus, dev, 0x0, 0x18);
-			secBus = ((tData >> 8) & 0xff);
-			/* now scan on sec bus */
-			for(i = 0;i < 0xff;i++)
-			{
-				resetPexConfig(pexIf, secBus, i);
-			}
-			/* now reset this device */
-			DB(mvOsPrintf("Reset bus %d dev %d\n", bus, dev));
-			mvPexHwConfigWrite(pexIf, bus, dev, 0x0, 0x18, 0x0); 
-			DB(mvOsPrintf("Reset bus %d dev %d\n", bus, dev));
-		}
-	}
-}
-
-
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvPex.h"
+
+//#define MV_DEBUG
+/* defines  */
+#ifdef MV_DEBUG
+	#define DB(x)	x
+#else
+	#define DB(x)
+#endif
+
+/* locals */
+typedef struct
+{
+	MV_U32 data;
+	MV_U32 mask;
+}PEX_HEADER_DATA;
+
+/* local function forwad decleration */
+MV_U32 mvPexHwConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
+                        MV_U32 regOff);
+MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
+                           MV_U32 func, MV_U32 regOff, MV_U32 data);
+void resetPexConfig(MV_U32 pexIf, MV_U32 bus, MV_U32 dev);
+
+
+PEX_HEADER_DATA configHdr[16] =
+{
+{0x888811ab, 0x00000000}, /*[device ID, vendor ID] */
+{0x00100007, 0x0000ffff}, /*[status register, command register] */
+{0x0604000e, 0x00000000}, /*[programming interface, sub class code, class code, revision ID] */
+{0x00010008, 0x00000000},  /*[BIST, header type, latency time, cache line] */
+{0x00000000, 0x00000000},  /*[base address 0] */
+{0x00000000, 0x00000000},  /*[base address 1] */
+{0x00000000, 0x00ffffff},  /*[secondary latency timersubordinate bus number, secondary bus number, primary bus number] */
+{0x0000f101, 0x00000000},  /*[secondary status ,IO limit, IO base] */
+{0x9ff0a000, 0x00000000},  /*[memory limit, memory base] */
+{0x0001fff1, 0x00000000},  /*[prefetch memory limit, prefetch memory base] */
+{0xffffffff, 0x00000000},  /*[prefetch memory base upper] */
+{0x00000000, 0x00000000},  /*[prefetch memory limit upper] */
+{0xeffff000, 0x00000000},  /*[IO limit upper 16 bits, IO base upper 16 bits] */
+{0x00000000, 0x00000000},  /*[reserved, capability pointer] */
+{0x00000000, 0x00000000},  /*[expansion ROM base address] */
+{0x00000000, 0x000000FF},  /*[bridge control, interrupt pin, interrupt line] */
+};
+
+
+#define HEADER_WRITE(data, offset) configHdr[offset/4].data = ((configHdr[offset/4].data & ~configHdr[offset/4].mask) | \
+																(data & configHdr[offset/4].mask))
+#define HEADER_READ(offset) configHdr[offset/4].data
+
+/*******************************************************************************
+* mvVrtBrgPexInit - Initialize PEX interfaces
+*
+* DESCRIPTION:
+*
+* This function is responsible of intialization of the Pex Interface , It
+* configure the Pex Bars and Windows in the following manner:
+*
+*  Assumptions :
+*				Bar0 is always internal registers bar
+*			    Bar1 is always the DRAM bar
+*				Bar2 is always the Device bar
+*
+*  1) Sets the Internal registers bar base by obtaining the base from
+*	  the CPU Interface
+*  2) Sets the DRAM bar base and size by getting the base and size from
+*     the CPU Interface when the size is the sum of all enabled DRAM
+*	  chip selects and the base is the base of CS0 .
+*  3) Sets the Device bar base and size by getting these values from the
+*     CPU Interface when the base is the base of the lowest base of the
+*     Device chip selects, and the
+*
+*
+* INPUT:
+*
+*       pexIf   -  PEX interface number.
+*
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
+*
+*******************************************************************************/
+MV_STATUS mvPexVrtBrgInit(MV_U32 pexIf)
+{
+	/* reset PEX tree to recover previous U-boot/Boot configurations */
+	MV_U32 localBus = mvPexLocalBusNumGet(pexIf);
+
+
+	resetPexConfig(pexIf, localBus, 1);
+	return MV_OK;
+}
+
+
+MV_U32 mvPexVrtBrgConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
+                        MV_U32 regOff)
+{
+
+	MV_U32 localBus = mvPexLocalBusNumGet(pexIf);
+	MV_U32 localDev = mvPexLocalDevNumGet(pexIf);
+	MV_U32 val;
+	if(bus == localBus)
+	{
+		if(dev > 1)
+		{
+/* on the local device allow only device #0 & #1 */
+			return 0xffffffff;
+		}
+		else
+		if (dev == localDev)
+		{
+			/* read the memory controller registers */
+			return mvPexHwConfigRead (pexIf, bus, dev, func, regOff);
+		}
+		else
+		{
+			/* access the virtual brg header */
+			return HEADER_READ(regOff);
+		}
+	}
+	else
+	if(bus == (localBus + 1))
+	{
+		/* access the device behind the virtual bridge */
+		if((dev == localDev) || (dev > 1))
+		{
+			return 0xffffffff;
+		}
+		else
+		{
+			/* access the device behind the virtual bridge, in this case
+			*  change the bus number to the local bus number in order to
+			*  generate type 0 config cycle
+			*/
+			mvPexLocalBusNumSet(pexIf, bus);
+			mvPexLocalDevNumSet(pexIf, 1);
+			val = mvPexHwConfigRead (pexIf, bus, 0, func, regOff);
+			mvPexLocalBusNumSet(pexIf, localBus);
+			mvPexLocalDevNumSet(pexIf, localDev);
+			return val;
+		}
+	}
+	/* for all other devices use the HW function to get the
+	*  requested registers
+	*/
+	mvPexLocalDevNumSet(pexIf, 1);
+	val = mvPexHwConfigRead (pexIf, bus, dev, func, regOff);
+	mvPexLocalDevNumSet(pexIf, localDev);
+	return val;
+}
+
+
+MV_STATUS mvPexVrtBrgConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
+                           MV_U32 func, MV_U32 regOff, MV_U32 data)
+{
+	MV_U32 localBus = mvPexLocalBusNumGet(pexIf);
+	MV_U32 localDev = mvPexLocalDevNumGet(pexIf);
+	MV_STATUS	status;
+
+	if(bus == localBus)
+	{
+		if(dev > 1)
+		{
+			/* on the local device allow only device #0 & #1 */
+			return MV_ERROR;
+		}
+		else
+		if (dev == localDev)
+		{
+			/* read the memory controller registers */
+			return mvPexHwConfigWrite (pexIf, bus, dev, func, regOff, data);
+		}
+		else
+		{
+			/* access the virtual brg header */
+			HEADER_WRITE(data, regOff);
+			return MV_OK;
+		}
+	}
+	else
+	if(bus == (localBus + 1))
+	{
+		/* access the device behind the virtual bridge */
+		if((dev == localDev) || (dev > 1))
+		{
+			return MV_ERROR;
+		}
+		else
+		{
+			/* access the device behind the virtual bridge, in this case
+			*  change the bus number to the local bus number in order to
+			*  generate type 0 config cycle
+			*/
+			//return mvPexHwConfigWrite (pexIf, localBus, dev, func, regOff, data);
+			mvPexLocalBusNumSet(pexIf, bus);
+			mvPexLocalDevNumSet(pexIf, 1);
+			status = mvPexHwConfigWrite (pexIf, bus, 0, func, regOff, data);
+			mvPexLocalBusNumSet(pexIf, localBus);
+			mvPexLocalDevNumSet(pexIf, localDev);
+			return status;
+
+		}
+	}
+	/* for all other devices use the HW function to get the
+	*  requested registers
+	*/
+	mvPexLocalDevNumSet(pexIf, 1);
+	status = mvPexHwConfigWrite (pexIf, bus, dev, func, regOff, data);
+	mvPexLocalDevNumSet(pexIf, localDev);
+	return status;
+}
+
+
+
+
+void resetPexConfig(MV_U32 pexIf, MV_U32 bus, MV_U32 dev)
+{
+	MV_U32 tData;
+	MV_U32 i;
+
+	/* restore the PEX configuration to initialization state */
+	/* in case PEX P2P call recursive and reset config */
+	tData = mvPexHwConfigRead (pexIf, bus, dev, 0x0, 0x0);
+	if(tData != 0xffffffff)
+	{
+		/* agent had been found - check whether P2P */
+		tData = mvPexHwConfigRead (pexIf, bus, dev, 0x0, 0x8);
+		if((tData & 0xffff0000) == 0x06040000)
+		{/* P2P */
+			/* get the sec bus and the subordinate */
+			MV_U32 secBus;
+			tData = mvPexHwConfigRead (pexIf, bus, dev, 0x0, 0x18);
+			secBus = ((tData >> 8) & 0xff);
+			/* now scan on sec bus */
+			for(i = 0;i < 0xff;i++)
+			{
+				resetPexConfig(pexIf, secBus, i);
+			}
+			/* now reset this device */
+			DB(mvOsPrintf("Reset bus %d dev %d\n", bus, dev));
+			mvPexHwConfigWrite(pexIf, bus, dev, 0x0, 0x18, 0x0);
+			DB(mvOsPrintf("Reset bus %d dev %d\n", bus, dev));
+		}
+	}
+}
+
+
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.h
index 82eb72d..0741713 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.h
@@ -1,82 +1,82 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef __INCVRTBRGPEXH
-#define __INCVRTBRGPEXH
-
-
-/* Global Functions prototypes */
-/* mvPexInit - Initialize PEX interfaces*/
-MV_STATUS mvPexVrtBrgInit(MV_U32 pexIf);
-
-/* mvPexConfigRead - Read from configuration space */
-MV_U32 mvPexVrtBrgConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
-						MV_U32 func,MV_U32 regOff);
-
-/* mvPexConfigWrite - Write to configuration space */
-MV_STATUS mvPexVrtBrgConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
-                           MV_U32 func, MV_U32 regOff, MV_U32 data);
-
-
-#endif /* #ifndef __INCPEXH */
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCVRTBRGPEXH
+#define __INCVRTBRGPEXH
+
+
+/* Global Functions prototypes */
+/* mvPexInit - Initialize PEX interfaces*/
+MV_STATUS mvPexVrtBrgInit(MV_U32 pexIf);
+
+/* mvPexConfigRead - Read from configuration space */
+MV_U32 mvPexVrtBrgConfigRead (MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
+						MV_U32 func,MV_U32 regOff);
+
+/* mvPexConfigWrite - Write to configuration space */
+MV_STATUS mvPexVrtBrgConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
+                           MV_U32 func, MV_U32 regOff, MV_U32 data);
+
+
+#endif /* #ifndef __INCPEXH */
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c b/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c
index 6c5bc19..2643699 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c
@@ -567,8 +567,8 @@ MV_STATUS mvSFlashSectorErase (MV_SFLASH_INFO * pFlinfo, MV_U32 secNumber)
         DB(mvOsPrintf("%s WARNING: Invaild parameter sector number!\n", __FUNCTION__);)
         return MV_BAD_PARAM;
     }
-    
-    /* we don't want to access SPI in direct mode from in-direct API, 
+
+    /* we don't want to access SPI in direct mode from in-direct API,
 	becasue of timing issue between CS asserts. */
 #if 0
     /* First compare to FF and check if erase is needed */
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.h b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.h
index 74859f0..5991e38 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h
index 658159a..e943787 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c
index 0bf8b75..c01be0f 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c
@@ -95,19 +95,19 @@ static MV_BOOL twsiTimeoutChk(MV_U32 timeout, const MV_8 *pString)
 		return MV_TRUE;
 	}
 	return MV_FALSE;
-	
+
 }
 /*******************************************************************************
 * mvTwsiStartBitSet - Set start bit on the bus
 *
 * DESCRIPTION:
-*       This routine sets the start bit on the TWSI bus. 
-*       The routine first checks for interrupt flag condition, then it sets 
-*       the start bit  in the TWSI Control register. 
-*       If the interrupt flag condition check previously was set, the function 
+*       This routine sets the start bit on the TWSI bus.
+*       The routine first checks for interrupt flag condition, then it sets
+*       the start bit  in the TWSI Control register.
+*       If the interrupt flag condition check previously was set, the function
 *       will clear it.
-*       The function then wait for the start bit to be cleared by the HW. 
-*       Then it waits for the interrupt flag to be set and eventually, the 
+*       The function then wait for the start bit to be cleared by the HW.
+*       Then it waits for the interrupt flag to be set and eventually, the
 *       TWSI status is checked to be 0x8 or 0x10(repeated start bit).
 *
 * INPUT:
@@ -133,18 +133,18 @@ MV_STATUS mvTwsiStartBitSet(MV_U8 chanNum)
 	/* set start Bit */
     	temp = MV_REG_READ(TWSI_CONTROL_REG(chanNum));
 	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), temp | TWSI_CONTROL_START_BIT);
-	
+
 	/* in case that the int flag was set before i.e. repeated start bit */
 	if(isIntFlag){
 		DB(mvOsPrintf("TWSI: mvTwsiStartBitSet repeated start Bit\n"));
 		twsiIntFlgClr(chanNum);
 	}
-	
+
    	/* wait for interrupt */
 	timeout = 0;
 	while(!twsiMainIntGet(chanNum) && (timeout++ < TWSI_TIMEOUT_VALUE));
-	
-	/* check for timeout */	
+
+	/* check for timeout */
 	if(MV_TRUE == twsiTimeoutChk(timeout,"TWSI: mvTwsiStartBitSet ERROR - Start Clear bit TimeOut .\n"))
 		return MV_TIMEOUT;
 
@@ -154,7 +154,7 @@ MV_STATUS mvTwsiStartBitSet(MV_U8 chanNum)
 	{
 		mvOsPrintf("TWSI: mvTwsiStartBitSet ERROR - start bit didn't went down\n");
 		return MV_FAIL;
-	}	
+	}
 
 	/* check the status */
 	temp = twsiStsGet(chanNum);
@@ -164,7 +164,7 @@ MV_STATUS mvTwsiStartBitSet(MV_U8 chanNum)
 		return MV_FAIL;
 	}
 
-	return MV_OK;	
+	return MV_OK;
 
 }
 
@@ -172,8 +172,8 @@ MV_STATUS mvTwsiStartBitSet(MV_U8 chanNum)
 * mvTwsiStopBitSet - Set stop bit on the bus
 *
 * DESCRIPTION:
-*       This routine set the stop bit on the TWSI bus. 
-*       The function then wait for the stop bit to be cleared by the HW. 
+*       This routine set the stop bit on the TWSI bus.
+*       The function then wait for the stop bit to be cleared by the HW.
 *       Finally the function checks for status of 0xF8.
 *
 * INPUT:
@@ -195,7 +195,7 @@ MV_STATUS mvTwsiStopBitSet(MV_U8 chanNum)
     	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), temp | TWSI_CONTROL_STOP_BIT);
 
 	twsiIntFlgClr(chanNum);
-		
+
    	/* wait for stop bit to come down */
 	timeout = 0;
 	while( ((MV_REG_READ(TWSI_CONTROL_REG(chanNum)) & TWSI_CONTROL_STOP_BIT) != 0) && (timeout++ < TWSI_TIMEOUT_VALUE));
@@ -203,14 +203,14 @@ MV_STATUS mvTwsiStopBitSet(MV_U8 chanNum)
 	/* check for timeout */
 	if(MV_TRUE == twsiTimeoutChk(timeout,"TWSI: mvTwsiStopBitSet ERROR - Stop bit TimeOut .\n"))
 		return MV_TIMEOUT;
-	
+
 	/* check that the stop bit went down */
-	if((MV_REG_READ(TWSI_CONTROL_REG(chanNum)) & TWSI_CONTROL_STOP_BIT) != 0)	
+	if((MV_REG_READ(TWSI_CONTROL_REG(chanNum)) & TWSI_CONTROL_STOP_BIT) != 0)
 	{
 		mvOsPrintf("TWSI: mvTwsiStopBitSet ERROR - stop bit didn't went down. \n");
 		return MV_FAIL;
 	}
-	
+
 	/* check the status */
 	temp = twsiStsGet(chanNum);
 	if( temp != TWSI_NO_REL_STS_INT_FLAG_IS_KEPT_0){
@@ -226,7 +226,7 @@ MV_STATUS mvTwsiStopBitSet(MV_U8 chanNum)
 *
 * DESCRIPTION:
 *       This routine returns the twsi interrupt flag value.
-*       
+*
 * INPUT:
 *       None.
 *
@@ -240,13 +240,13 @@ MV_STATUS mvTwsiStopBitSet(MV_U8 chanNum)
 static MV_BOOL twsiMainIntGet(MV_U8 chanNum)
 {
 	MV_U32 temp;
-	
+
 	/* get the int flag bit */
 
 	temp = MV_REG_READ(TWSI_CPU_MAIN_INT_CAUSE_REG);
 	if (temp & (TWSI0_CPU_MAIN_INT_BIT << chanNum))
 	    return MV_TRUE;
-    
+
 	return MV_FALSE;
 }
 /*******************************************************************************
@@ -254,7 +254,7 @@ static MV_BOOL twsiMainIntGet(MV_U8 chanNum)
 *
 * DESCRIPTION:
 *       This routine clears the interrupt flag. It does NOT poll the interrupt
-*       to make sure the clear. After clearing the interrupt, it waits for at 
+*       to make sure the clear. After clearing the interrupt, it waits for at
 *       least 1 miliseconds.
 *
 * INPUT:
@@ -279,7 +279,7 @@ static MV_VOID twsiIntFlgClr(MV_U8 chanNum)
 
 	/* wait for 1 mili sec for the clear to take effect */
    	mvOsDelay(1);
-	
+
 	return;
 }
 
@@ -324,7 +324,7 @@ static MV_VOID twsiAckBitSet(MV_U8 chanNum)
 *	 parameter based on Tclk frequancy and enables TWSI slave.
 *       -Set the ack bit.
 *	-Assign the TWSI slave address according to the TWSI address Type.
-*       
+*
 *
 * INPUT:
 *	chanNum - TWSI channel
@@ -375,7 +375,7 @@ MV_U32 mvTwsiInit(MV_U8 chanNum, MV_HZ frequancy, MV_U32 Tclk, MV_TWSI_ADDR *pTw
     	MV_REG_WRITE(TWSI_STATUS_BAUDE_RATE_REG(chanNum),val);
 
     	/* Enable the TWSI and slave */
-	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), TWSI_CONTROL_ENA | TWSI_CONTROL_ACK); 
+	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), TWSI_CONTROL_ENA | TWSI_CONTROL_ACK);
 
 	/* set the TWSI slave address */
 	if( pTwsiAddr->type == ADDR10_BIT )/* 10 Bit deviceAddress */
@@ -391,7 +391,7 @@ MV_U32 mvTwsiInit(MV_U8 chanNum, MV_HZ frequancy, MV_U32 Tclk, MV_TWSI_ADDR *pTw
 		MV_REG_WRITE(TWSI_SLAVE_ADDR_REG(chanNum),val);
 
          	/* writing the 8 least significant bits of the 10 bit address*/
-        	val = (pTwsiAddr->address << TWSI_EXTENDED_SLAVE_OFFS) & TWSI_EXTENDED_SLAVE_MASK;  
+        	val = (pTwsiAddr->address << TWSI_EXTENDED_SLAVE_OFFS) & TWSI_EXTENDED_SLAVE_MASK;
         	MV_REG_WRITE(TWSI_EXTENDED_SLAVE_ADDR_REG(chanNum), val);
     	}
     	else /*7 bit address*/
@@ -407,9 +407,9 @@ MV_U32 mvTwsiInit(MV_U8 chanNum, MV_HZ frequancy, MV_U32 Tclk, MV_TWSI_ADDR *pTw
 	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), val | TWSI_CONTROL_INT_ENA);
 	/* Add delay of 1ms */
 	mvOsDelay(1);
-	
+
    return actualFreq;
-} 
+}
 
 
 /*******************************************************************************
@@ -509,15 +509,15 @@ MV_STATUS mvTwsiAddrSet(MV_U8 chanNum, MV_TWSI_ADDR *pTwsiAddr, MV_TWSI_CMD comm
 *
 * DESCRIPTION:
 *       There are two address phases:
-*       1) Write '11110' to data register bits [7:3] and 10-bit address MSB 
-*          (bits [9:8]) to data register bits [2:1] plus a write(0) or read(1) bit 
-*          to the Data register. Then it clears interrupt flag which drive 
-*          the address on the TWSI bus. The function then waits for interrupt 
+*       1) Write '11110' to data register bits [7:3] and 10-bit address MSB
+*          (bits [9:8]) to data register bits [2:1] plus a write(0) or read(1) bit
+*          to the Data register. Then it clears interrupt flag which drive
+*          the address on the TWSI bus. The function then waits for interrupt
 *          flag to be active and status 0x18 (write) or 0x40 (read) to be set.
-*       2) write the rest of 10-bit address to data register and clears 
-*          interrupt flag which drive the address on the TWSI bus. The 
-*          function then waits for interrupt flag to be active and status 
-*          0xD0 (write) or 0xE0 (read) to be set. 
+*       2) write the rest of 10-bit address to data register and clears
+*          interrupt flag which drive the address on the TWSI bus. The
+*          function then waits for interrupt flag to be active and status
+*          0xD0 (write) or 0xE0 (read) to be set.
 *
 * INPUT:
 *	chanNum - TWSI channel
@@ -556,10 +556,10 @@ static MV_STATUS twsiAddr10BitSet(MV_U8 chanNum, MV_U32 deviceAddress,MV_TWSI_CM
 	/* check for timeout */
 	if(MV_TRUE == twsiTimeoutChk(timeout,"TWSI: twsiAddr10BitSet ERROR - 1st addr (10Bit) Int TimeOut.\n"))
 		return MV_TIMEOUT;
-	
+
 	/* check the status */
 	val = twsiStsGet(chanNum);
-	if(( (val != TWSI_AD_PLS_RD_BIT_TRA_ACK_REC) && (command == MV_TWSI_READ ) ) || 
+	if(( (val != TWSI_AD_PLS_RD_BIT_TRA_ACK_REC) && (command == MV_TWSI_READ ) ) ||
 	   ( (val != TWSI_AD_PLS_WR_BIT_TRA_ACK_REC) && (command == MV_TWSI_WRITE) ))
 	{
 		mvOsPrintf("TWSI: twsiAddr10BitSet ERROR - status %x 1st addr (10 Bit) in %s mode.\n"\
@@ -581,17 +581,17 @@ static MV_STATUS twsiAddr10BitSet(MV_U8 chanNum, MV_U32 deviceAddress,MV_TWSI_CM
 	/* check for timeout */
 	if(MV_TRUE == twsiTimeoutChk(timeout,"TWSI: twsiAddr10BitSet ERROR - 2nd (10 Bit) Int TimOut.\n"))
 		return MV_TIMEOUT;
-	
+
 	/* check the status */
 	val = twsiStsGet(chanNum);
-	if(( (val != TWSI_SEC_AD_PLS_RD_BIT_TRA_ACK_REC) && (command == MV_TWSI_READ ) ) || 
+	if(( (val != TWSI_SEC_AD_PLS_RD_BIT_TRA_ACK_REC) && (command == MV_TWSI_READ ) ) ||
 	   ( (val != TWSI_SEC_AD_PLS_WR_BIT_TRA_ACK_REC) && (command == MV_TWSI_WRITE) ))
 	{
 		mvOsPrintf("TWSI: twsiAddr10BitSet ERROR - status %x 2nd addr(10 Bit) in %s mode.\n"\
 						,val, ((command==MV_TWSI_WRITE)?"Write":"Read") );
 		return MV_FAIL;
 	}
-	
+
 	return MV_OK;
 }
 
@@ -599,8 +599,8 @@ static MV_STATUS twsiAddr10BitSet(MV_U8 chanNum, MV_U32 deviceAddress,MV_TWSI_CM
 * twsiAddr7BitSet - Set 7 Bit address on TWSI bus.
 *
 * DESCRIPTION:
-*       This function writes 7 bit address plus a write or read bit to the 
-*       Data register. Then it clears interrupt flag which drive the address on 
+*       This function writes 7 bit address plus a write or read bit to the
+*       Data register. Then it clears interrupt flag which drive the address on
 *       the TWSI bus. The function then waits for interrupt flag to be active
 *       and status 0x18 (write) or 0x40 (read) to be set.
 *
@@ -624,7 +624,7 @@ static MV_STATUS twsiAddr7BitSet(MV_U8 chanNum, MV_U32 deviceAddress,MV_TWSI_CMD
 	/* set the address */
 	val = (deviceAddress << TWSI_DATA_ADDR_7BIT_OFFS) & TWSI_DATA_ADDR_7BIT_MASK;
 	/* set command */
-	val |= command;	
+	val |= command;
 	MV_REG_WRITE(TWSI_DATA_REG(chanNum), val);
 	/* WA add a delay */
 	mvOsDelay(1);
@@ -639,10 +639,10 @@ static MV_STATUS twsiAddr7BitSet(MV_U8 chanNum, MV_U32 deviceAddress,MV_TWSI_CMD
 	/* check for timeout */
 	if(MV_TRUE == twsiTimeoutChk(timeout,"TWSI: twsiAddr7BitSet ERROR - Addr (7 Bit) int TimeOut.\n"))
 		return MV_TIMEOUT;
-	
+
 	/* check the status */
 	val = twsiStsGet(chanNum);
-	if(( (val != TWSI_AD_PLS_RD_BIT_TRA_ACK_REC) && (command == MV_TWSI_READ ) ) || 
+	if(( (val != TWSI_AD_PLS_RD_BIT_TRA_ACK_REC) && (command == MV_TWSI_READ ) ) ||
 	   ( (val != TWSI_AD_PLS_WR_BIT_TRA_ACK_REC) && (command == MV_TWSI_WRITE) ))
 	{
 		/* only in debug, since in boot we try to read the SPD of both DRAM, and we don't
@@ -651,7 +651,7 @@ static MV_STATUS twsiAddr7BitSet(MV_U8 chanNum, MV_U32 deviceAddress,MV_TWSI_CMD
 						,val,((command==MV_TWSI_WRITE)?"Write":"Read") ));
 		return MV_FAIL;
 	}
-	
+
 	return MV_OK;
 }
 
@@ -662,11 +662,11 @@ static MV_STATUS twsiAddr7BitSet(MV_U8 chanNum, MV_U32 deviceAddress,MV_TWSI_CMD
 *       This function writes a given data block to TWSI bus in 8 bit granularity.
 *	first The function waits for interrupt flag to be active then
 *       For each 8-bit data:
-*        The function writes data to data register. It then clears 
-*        interrupt flag which drives the data on the TWSI bus. 
-*        The function then waits for interrupt flag to be active and status 
-*        0x28 to be set. 
-*      
+*        The function writes data to data register. It then clears
+*        interrupt flag which drives the data on the TWSI bus.
+*        The function then waits for interrupt flag to be active and status
+*        0x28 to be set.
+*
 *
 * INPUT:
 *	chanNum - TWSI channel
@@ -718,12 +718,12 @@ static MV_STATUS twsiDataTransmit(MV_U8 chanNum, MV_U8 *pBlock, MV_U32 blockSize
 
 		/* check the status */
 		temp = twsiStsGet(chanNum);
-		if(temp != TWSI_M_TRAN_DATA_BYTE_ACK_REC) 
+		if(temp != TWSI_M_TRAN_DATA_BYTE_ACK_REC)
 		{
 			mvOsPrintf("TWSI: twsiDataTransmit ERROR - status %x in write trans\n",temp);
 			return MV_FAIL;
 		}
-		
+
 	}
 
 	return MV_OK;
@@ -733,16 +733,16 @@ static MV_STATUS twsiDataTransmit(MV_U8 chanNum, MV_U8 *pBlock, MV_U32 blockSize
 * twsiDataReceive - Receive data block from TWSI bus.
 *
 * DESCRIPTION:
-*       This function receive data block from TWSI bus in 8bit granularity 
+*       This function receive data block from TWSI bus in 8bit granularity
 *       into pBlock buffer.
 *	first The function waits for interrupt flag to be active then
 *       For each 8-bit data:
-*        It clears the interrupt flag which allows the next data to be 
+*        It clears the interrupt flag which allows the next data to be
 *        received from TWSI bus.
 *	 The function waits for interrupt flag to be active,
-*	 and status reg is 0x50. 
-*	 Then the function reads data from data register, and copies it to 
-*	 the given buffer. 
+*	 and status reg is 0x50.
+*	 Then the function reads data from data register, and copies it to
+*	 the given buffer.
 *
 * INPUT:
 *	chanNum - TWSI channel
@@ -801,7 +801,7 @@ static MV_STATUS twsiDataReceive(MV_U8 chanNum, MV_U8 *pBlock, MV_U32 blockSize)
 			mvOsPrintf("TWSI: twsiDataReceive ERROR - status %x in Rd Terminate\n",temp);
 			return MV_FAIL;
 		}
-		
+
 		/* read the data*/
 		*pBlock = (MV_U8)MV_REG_READ(TWSI_DATA_REG(chanNum));
 		DB(mvOsPrintf("TWSI: twsiDataReceive  place %d read %x \n",\
@@ -822,7 +822,7 @@ static MV_STATUS twsiDataReceive(MV_U8 chanNum, MV_U8 *pBlock, MV_U32 blockSize)
 *       The function support TWSI targets that have inside address space (for
 *       example EEPROMs). The function:
 *       1) Convert the given offset into pBlock and size.
-*		in case the offset should be set to a TWSI slave which support 
+*		in case the offset should be set to a TWSI slave which support
 *		more then 256 bytes offset, the offset setting will be done
 *		in 2 transactions.
 *       2) Use twsiDataTransmit to place those on the bus.
@@ -830,7 +830,7 @@ static MV_STATUS twsiDataReceive(MV_U8 chanNum, MV_U8 *pBlock, MV_U32 blockSize)
 * INPUT:
 *	chanNum - TWSI channel
 *       offset - offset to be set on the EEPROM device.
-*	moreThen256 - whether the EEPROM device support more then 256 byte offset. 
+*	moreThen256 - whether the EEPROM device support more then 256 byte offset.
 *
 * OUTPUT:
 *       None.
@@ -878,8 +878,8 @@ static MV_STATUS twsiTargetOffsSet(MV_U8 chanNum, MV_U32 offset, MV_BOOL moreThe
 *
 * INPUT:
 *	chanNum - TWSI channel
-*      	pTwsiSlave - Twsi Slave structure. 
-*       blockSize - number of bytes to read.	
+*      	pTwsiSlave - Twsi Slave structure.
+*       blockSize - number of bytes to read.
 *
 * OUTPUT:
 *      	pBlock - Data block.
@@ -899,36 +899,36 @@ MV_STATUS mvTwsiRead(MV_U8 chanNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *pBlock, MV
 		mvTwsiStopBitSet(chanNum);
 		 return MV_FAIL;
 	}
-	
+
 	DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiStartBitSet\n"));
-	
+
 	/* in case offset exsist (i.e. eeprom ) */
 	if(MV_TRUE == pTwsiSlave->validOffset)
 	{
-		if(MV_OK != mvTwsiAddrSet(chanNum, &(pTwsiSlave->slaveAddr), MV_TWSI_WRITE)) 
+		if(MV_OK != mvTwsiAddrSet(chanNum, &(pTwsiSlave->slaveAddr), MV_TWSI_WRITE))
 		{
 			mvTwsiStopBitSet(chanNum);
 			return MV_FAIL;
-		} 
+		}
 		DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiAddrSet\n"));
-		if(MV_OK != twsiTargetOffsSet(chanNum, pTwsiSlave->offset, pTwsiSlave->moreThen256)) 
+		if(MV_OK != twsiTargetOffsSet(chanNum, pTwsiSlave->offset, pTwsiSlave->moreThen256))
 		{
 			mvTwsiStopBitSet(chanNum);
 			return MV_FAIL;
 		}
 		DB(mvOsPrintf("TWSI: mvTwsiEepromRead after twsiTargetOffsSet\n"));
-		if(MV_OK != mvTwsiStartBitSet(chanNum)) 
+		if(MV_OK != mvTwsiStartBitSet(chanNum))
 		{
 			mvTwsiStopBitSet(chanNum);
 			return MV_FAIL;
 		}
 		DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiStartBitSet\n"));
 	}
-	if(MV_OK != mvTwsiAddrSet(chanNum, &(pTwsiSlave->slaveAddr), MV_TWSI_READ)) 
+	if(MV_OK != mvTwsiAddrSet(chanNum, &(pTwsiSlave->slaveAddr), MV_TWSI_READ))
 	{
 		mvTwsiStopBitSet(chanNum);
 		return MV_FAIL;
-	} 
+	}
 	DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiAddrSet\n"));
 	if(MV_OK != twsiDataReceive(chanNum, pBlock, blockSize))
 	{
@@ -963,8 +963,8 @@ MV_STATUS mvTwsiRead(MV_U8 chanNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *pBlock, MV
 *
 * INPUT:
 *	chanNum - TWSI channel
-*      	eepromAddress - eeprom address. 
-*       blockSize - number of bytes to write.	
+*      	eepromAddress - eeprom address.
+*       blockSize - number of bytes to write.
 *      	pBlock - Data block.
 *
 * OUTPUT:
@@ -983,7 +983,7 @@ MV_STATUS mvTwsiWrite(MV_U8 chanNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *pBlock, M
 	if((NULL == pBlock) || (NULL == pTwsiSlave))
 		return MV_BAD_PARAM;
 
-	if(MV_OK != mvTwsiStartBitSet(chanNum)) 
+	if(MV_OK != mvTwsiStartBitSet(chanNum))
 	{
 		mvTwsiStopBitSet(chanNum);
 		return MV_FAIL;
@@ -1000,20 +1000,20 @@ MV_STATUS mvTwsiWrite(MV_U8 chanNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *pBlock, M
 	/* in case offset exsist (i.e. eeprom ) */
 	if(MV_TRUE == pTwsiSlave->validOffset)
 	{
-		if(MV_OK != twsiTargetOffsSet(chanNum, pTwsiSlave->offset, pTwsiSlave->moreThen256)) 
+		if(MV_OK != twsiTargetOffsSet(chanNum, pTwsiSlave->offset, pTwsiSlave->moreThen256))
 		{
 			mvTwsiStopBitSet(chanNum);
 			return MV_FAIL;
 		}
 		DB(mvOsPrintf("TWSI: mvTwsiEepromWrite after twsiTargetOffsSet\n"));
 	}
-	if(MV_OK != twsiDataTransmit(chanNum, pBlock, blockSize)) 
+	if(MV_OK != twsiDataTransmit(chanNum, pBlock, blockSize))
 	{
 		mvTwsiStopBitSet(chanNum);
 		return MV_FAIL;
 	}
 	DB(mvOsPrintf("TWSI: mvTwsiEepromWrite after twsiDataTransmit\n"));
-	if(MV_OK != mvTwsiStopBitSet(chanNum)) 
+	if(MV_OK != mvTwsiStopBitSet(chanNum))
 	{
 		return MV_FAIL;
 	}
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h
index bd5b6d0..9017ff1 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -108,7 +108,7 @@ MV_STATUS mvTwsiStartBitSet(MV_U8 chanNum);
 MV_STATUS mvTwsiStopBitSet(MV_U8 chanNum);
 MV_STATUS mvTwsiAddrSet(MV_U8 chanNum, MV_TWSI_ADDR *twsiAddr, MV_TWSI_CMD command);
 
-MV_U32 mvTwsiInit(MV_U8 chanNum, MV_KHZ frequancy, MV_U32 Tclk, MV_TWSI_ADDR *twsiAddr, MV_BOOL generalCallEnable); 
+MV_U32 mvTwsiInit(MV_U8 chanNum, MV_KHZ frequancy, MV_U32 Tclk, MV_TWSI_ADDR *twsiAddr, MV_BOOL generalCallEnable);
 MV_STATUS mvTwsiRead (MV_U8 chanNum, MV_TWSI_SLAVE *twsiSlave, MV_U8 *pBlock, MV_U32 blockSize);
 MV_STATUS mvTwsiWrite(MV_U8 chanNum, MV_TWSI_SLAVE *twsiSlave, MV_U8 *pBlock, MV_U32 blockSize);
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiEeprom.S b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiEeprom.S
new file mode 100644
index 0000000..1a67798
--- /dev/null
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiEeprom.S
@@ -0,0 +1,457 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+/* includes */
+#define MV_ASMLANGUAGE
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "mvOsAsm.h"
+#include "mvTwsiSpec.h"
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "mvCommon.h"
+
+#define I2C_CH MV_BOARD_DIMM_I2C_CHANNEL
+
+/* defines */
+/* defines  */
+
+
+        .data
+        .global _i2cInit
+        .global _i2cRead
+
+        .text
+
+/*******************************************************************************
+* _i2cInit - Initialize TWSI interface
+*
+* DESCRIPTION:
+*       The function performs TWSI interface initialization. It resets the
+*       TWSI state machine and initialize its clock to 100KHz assuming Tclock
+*       of 133MHz.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+_i2cInit:
+        mov     r9, LR     /* Save link register */
+        mov     r0, #0     /* Make sure r0 is zero */
+
+        /* Reset the i2c Mechanism first */
+        MV_REG_WRITE_ASM (r0, r1, TWSI_SOFT_RESET_REG(I2C_CH))
+
+        bl      _twsiDelay
+        bl      _twsiDelay
+
+        /* Initializing the I2C mechanism. Assuming Tclock frequency          */
+        /* of 166MHz. The I2C frequency in that case will be 100KHz.          */
+        /* For this settings, M = 9 and N = 3. Set the baud-rate with the     */
+        /* value of 0x2b (freq of ==> 100KHz                                  */
+        /* see spec for more details about the calculation of this value)     */
+        mov     r6, #(9 << 3 | 3)
+        MV_REG_WRITE_ASM (r6, r1, TWSI_STATUS_BAUDE_RATE_REG(I2C_CH))
+
+        /* Enable the I2C master */
+	/* Enable TWSI interrupt in main mask reg */
+        mov     r6, #0xC4
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+
+        /* Let the slow TWSI machine get used to the idea that it is enabled  */
+        bl      _twsiDelay
+
+
+        mov     PC, r9         /* r9 is saved link register */
+
+/*******************************************************************************
+* _twsiDelay - Perform delay.
+*
+* DESCRIPTION:
+*       The function performs a delay to enable TWSI logic to stable.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+_twsiDelay:
+        mov     r10, #0x100000 /*was 0x400*/
+
+_twsiDelayLoop:
+        subs    r10, r10, #1
+        bne     _twsiDelayLoop
+
+        mov     PC, LR
+
+/*******************************************************************************
+* _i2cRead - Read byte from I2C EEPROM device.
+*
+* DESCRIPTION:
+*       The function returns a byte from I2C EEPROM device.
+*       The EEPROM device is 7-bit address type.
+*
+* INPUT:
+*       r4 has the DIMM0 base address with shift 1 bit to the left
+*       r7 has the EEPROM offset
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       r4 returns '0' if address can not be read.
+*       r7 has byte value in case read is successful.
+*
+*******************************************************************************/
+_i2cRead:
+        mov     r9, LR     /* Save link register */
+
+        /* Transmit the device address and desired offset within the EEPROM. */
+
+        /* Generate Start Bit */
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        orr     r6, r6, #TWSI_CONTROL_START_BIT
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+
+        /* Wait for the interrupt flag (bit3) to be set  */
+        mov     r10, #0x50000
+loop_1:
+        subs    r10, r10, #1
+        beq     loop_1_timeout
+#ifdef MV78XX0
+        MV_REG_READ_ASM (r6, r1, CPU_INT_LOW_REG(I2C_CH))
+        tst     r6, #BIT2
+#else
+        MV_REG_READ_ASM (r6, r1, CPU_MAIN_INT_CAUSE_REG)
+        tst     r6, #BIT5
+#endif
+        beq     loop_1
+
+loop_1_timeout:
+
+        /* Wait for the start bit to be reset by HW */
+        mov     r10, #0x50000
+loop_2:
+        subs    r10, r10, #1
+        beq     loop_2_timeout
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        tst     r6, #TWSI_CONTROL_START_BIT
+        bne     loop_2
+
+loop_2_timeout:
+
+        /* Wait for the status TWSI_START_CONDITION_TRA = 0x8 */
+        mov     r10, #0x50000
+loop_3:
+        subs    r10, r10, #1
+        beq     loop_3_timeout
+        MV_REG_READ_ASM (r6, r1, TWSI_STATUS_BAUDE_RATE_REG(I2C_CH))
+        cmp     r6, #0x08
+        bne     loop_3
+
+loop_3_timeout:
+
+        /* writing the address of (DIMM0/1 << 1) with write indication */
+        mov     r6, r4, LSL #1 /* Write operation address bit 0 must be 0 */
+        MV_REG_WRITE_ASM (r6, r1, TWSI_DATA_REG(I2C_CH))
+
+        bl      _twsiDelay
+        /* Clear the interrupt flag */
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bic     r6, r6, #TWSI_CONTROL_INT_FLAG_SET
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bl      _twsiDelay
+
+        /* Waiting for the interrupt flag to be set which means that the
+           address has been transmitted                                  */
+loop_4:
+#ifdef MV78XX0
+        MV_REG_READ_ASM (r6, r1, CPU_INT_LOW_REG(I2C_CH))
+        tst     r6, #BIT2
+#else
+        MV_REG_READ_ASM (r6, r1, CPU_MAIN_INT_CAUSE_REG)
+        tst     r6, #BIT5
+#endif
+        beq     loop_4       /* if tst = 0, then the bit is not set yet */
+
+        /* Wait for status TWSI_ADDR_PLUS_WRITE_BIT_TRA_ACK_REC = 0x18 */
+        mov     r10, #0x50000         /* Set r10 to 0x50000 =~ 328,000 */
+
+loop_5:
+        subs    r10, r10, #1          /* timeout count down         */
+        bne     testStatus
+        mov     r4, #0                /* r4 = 0 -> operation failed */
+        b       exit_i2cRead          /* Exit if timeout (No DIMM)  */
+
+testStatus:
+        MV_REG_READ_ASM (r6, r1, TWSI_STATUS_BAUDE_RATE_REG(I2C_CH))
+        cmp     r6, #0x18
+        bne     loop_5
+
+
+        /* check if the offset is bigger than 256 byte*/
+        tst     r7, #0x80000000
+        bne     great_than_256
+
+        /* Write the offset to be read from the DIMM EEPROM */
+        MV_REG_WRITE_ASM (r7, r1, TWSI_DATA_REG(I2C_CH))
+
+        b after_offset
+
+great_than_256:
+        mov     r10, r7, LSR #8
+        and     r10, r10, #0xff
+        /* Write the offset0 to be read from the  EEPROM */
+        MV_REG_WRITE_ASM (r10, r1, TWSI_DATA_REG(I2C_CH))
+
+        /* Clear the interrupt flag ==> signaling that the address can now
+           be transmited                                                    */
+
+        bl      _twsiDelay
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bic     r6, r6, #TWSI_CONTROL_INT_FLAG_SET
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bl      _twsiDelay
+
+        /* Wait for the interrupt to be set again ==> address has transmited */
+loop_6_1:
+#ifdef MV78XX0
+        MV_REG_READ_ASM (r6, r1, CPU_INT_LOW_REG(I2C_CH))
+        tst     r6, #BIT2
+#else
+        MV_REG_READ_ASM (r6, r1, CPU_MAIN_INT_CAUSE_REG)
+        tst     r6, #BIT5
+#endif
+        beq     loop_6_1
+
+        /* Wait for status TWSI_MAS_TRAN_DATA_BYTE_ACK_REC = 0x28 */
+loop_7_1:
+        MV_REG_READ_ASM (r6, r1, TWSI_STATUS_BAUDE_RATE_REG(I2C_CH))
+        cmp     r6, #0x28
+        bne     loop_7_1
+
+
+        mov     r10, r7
+        and     r10, r10, #0xff
+        /* Write the offset1 to be read from the  EEPROM */
+        MV_REG_WRITE_ASM (r10, r1, TWSI_DATA_REG(I2C_CH))
+
+
+
+after_offset:
+
+        /* Clear the interrupt flag ==> signaling that the address can now
+           be transmited                                                    */
+
+        bl      _twsiDelay
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bic     r6, r6, #TWSI_CONTROL_INT_FLAG_SET
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bl      _twsiDelay
+
+        /* Wait for the interrupt to be set again ==> address has transmited */
+loop_6:
+#ifdef MV78XX0
+        MV_REG_READ_ASM (r6, r1, CPU_INT_LOW_REG(I2C_CH))
+        tst     r6, #BIT2
+#else
+        MV_REG_READ_ASM (r6, r1, CPU_MAIN_INT_CAUSE_REG)
+        tst     r6, #BIT5
+#endif
+        beq     loop_6
+
+        /* Wait for status TWSI_MAS_TRAN_DATA_BYTE_ACK_REC = 0x28 */
+loop_7:
+        MV_REG_READ_ASM (r6, r1, TWSI_STATUS_BAUDE_RATE_REG(I2C_CH))
+        cmp     r6, #0x28
+        bne     loop_7
+
+        /* Retransmit the device address with read indication to get the data */
+
+        /* generate a repeated start bit */
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        orr     r6, r6, #TWSI_CONTROL_START_BIT
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+
+
+        /* Clear the interrupt flag ==> the start bit will be transmitted. */
+        bl      _twsiDelay
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bic     r6, r6, #TWSI_CONTROL_INT_FLAG_SET
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bl      _twsiDelay
+
+       /* Wait for the interrupt flag (bit3) to be set */
+loop_9:
+#ifdef MV78XX0
+        MV_REG_READ_ASM (r6, r1, CPU_INT_LOW_REG(I2C_CH))
+        tst     r6, #BIT2
+#else
+        MV_REG_READ_ASM (r6, r1, CPU_MAIN_INT_CAUSE_REG)
+        tst     r6, #BIT5
+#endif
+        beq     loop_9
+
+        /* Wait for the start bit to be reset by HW */
+loop_8:
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        tst     r6, #TWSI_CONTROL_START_BIT
+        bne     loop_8
+
+        /* Wait for status TWSI_REPEATED_START_CONDITION_TRA = 0x10 */
+loop_10:
+        MV_REG_READ_ASM (r6, r1, TWSI_STATUS_BAUDE_RATE_REG(I2C_CH))
+        cmp     r6, #0x10
+        bne     loop_10
+
+        /* Writing the address of (DIMM0<<1) with read indication (bit0 is 1) */
+        mov     r6, r4, LSL #1
+        orr     r6, r6, #1     /* Read operation address bit 0 must be 1 */
+        MV_REG_WRITE_ASM (r6, r1, TWSI_DATA_REG(I2C_CH))
+
+        /* Clear the interrupt flag ==> the address will be transmitted */
+        bl      _twsiDelay
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bic     r6, r6, #TWSI_CONTROL_INT_FLAG_SET
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bl      _twsiDelay
+
+        /* Wait for the interrupt flag (bit3) to be set as a result of
+           transmitting the address.                                     */
+loop_11:
+#ifdef MV78XX0
+        MV_REG_READ_ASM (r6, r1, CPU_INT_LOW_REG(I2C_CH))
+        tst     r6, #BIT2
+#else
+        MV_REG_READ_ASM (r6, r1, CPU_MAIN_INT_CAUSE_REG)
+        tst     r6, #BIT5
+#endif
+        beq     loop_11
+
+         /* Wait for status TWSI_ADDR_PLUS_READ_BIT_TRA_ACK_REC = 0x40 */
+loop_12:
+        MV_REG_READ_ASM (r6, r1, TWSI_STATUS_BAUDE_RATE_REG(I2C_CH))
+        cmp     r6, #0x40
+        bne     loop_12
+
+        /* Clear the interrupt flag and the Acknoledge bit */
+        bl      _twsiDelay
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bic     r6, r6, #(TWSI_CONTROL_INT_FLAG_SET | TWSI_CONTROL_ACK)
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bl      _twsiDelay
+
+        /* Wait for the interrupt flag (bit3) to be set */
+loop_14:
+#ifdef MV78XX0
+        MV_REG_READ_ASM (r6, r1, CPU_INT_LOW_REG(I2C_CH))
+        tst     r6, #BIT2
+#else
+        MV_REG_READ_ASM (r6, r1, CPU_MAIN_INT_CAUSE_REG)
+        tst     r6, #BIT5
+#endif
+        beq     loop_14
+
+        /* Wait for status TWSI_MAS_REC_READ_DATA_ACK_NOT_TRA = 0x58 */
+loop_15:
+        MV_REG_READ_ASM (r6, r1, TWSI_STATUS_BAUDE_RATE_REG(I2C_CH))
+        cmp     r6, #0x58
+        bne     loop_15
+
+        /* Store the data in r7. */
+        MV_REG_READ_ASM (r7, r1, TWSI_DATA_REG(I2C_CH))
+
+        /* Generate stop bit */
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        orr     r6, r6, #TWSI_CONTROL_STOP_BIT
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+
+
+        /* Clear the interrupt flag  */
+        bl      _twsiDelay
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bic     r6, r6, #TWSI_CONTROL_INT_FLAG_SET
+        MV_REG_WRITE_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        bl      _twsiDelay
+
+        /* Wait for the stop bit to be reset by HW */
+loop_16:
+        MV_REG_READ_ASM (r6, r1, TWSI_CONTROL_REG(I2C_CH))
+        tst     r6, #TWSI_CONTROL_INT_FLAG_SET
+        bne     loop_16
+
+exit_i2cRead:
+        mov     PC, r9         /* r9 is saved link register */
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiSpec.h b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiSpec.h
index d0c2b9e..0df960a 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiSpec.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsiSpec.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -103,7 +103,7 @@ extern "C" {
 #define TWSI_CONTROL_ACK            	BIT2
 #define TWSI_CONTROL_INT_FLAG_SET   	BIT3
 #define TWSI_CONTROL_STOP_BIT    	BIT4
-#define TWSI_CONTROL_START_BIT 		BIT5 
+#define TWSI_CONTROL_START_BIT 		BIT5
 #define TWSI_CONTROL_ENA     		BIT6
 #define TWSI_CONTROL_INT_ENA    	BIT7
 
@@ -117,7 +117,7 @@ extern "C" {
 #define TWSI_SOFT_RESET_REG(chanNum)	(TWSI_SLAVE_BASE(chanNum) + 0x1c)
 
 /* defines */
-#define TWSI_TIMEOUT_VALUE 		0x500 
+#define TWSI_TIMEOUT_VALUE 		0x500
 
 /* TWSI status codes */
 #define TWSI_BUS_ERROR                                            0x00
diff --git a/crypto/ocf/ocf-bench.c b/crypto/ocf/ocf-bench.c
index 5eef6b1..f3fe9d0 100644
--- a/crypto/ocf/ocf-bench.c
+++ b/crypto/ocf/ocf-bench.c
@@ -1,7 +1,7 @@
 /*
  * A loadable module that benchmarks the OCF crypto speed from kernel space.
  *
- * Copyright (C) 2004-2007 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2004-2010 David McCullough <david_mccullough@mcafee.com>
  *
  * LICENSE TERMS
  *
@@ -30,7 +30,8 @@
  */
 
 
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -40,7 +41,6 @@
 #include <linux/wait.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
-#include <linux/version.h>
 #include <linux/interrupt.h>
 #include <cryptodev.h>
 
@@ -67,23 +67,39 @@
 /*
  * the number of simultaneously active requests
  */
-static int request_q_len = 20;
+static int request_q_len = 40;
 module_param(request_q_len, int, 0);
 MODULE_PARM_DESC(request_q_len, "Number of outstanding requests");
+
 /*
  * how many requests we want to have processed
  */
 static int request_num = 1024;
 module_param(request_num, int, 0);
 MODULE_PARM_DESC(request_num, "run for at least this many requests");
+
 /*
  * the size of each request
  */
-static int request_size = 1500;
+static int request_size = 1488;
 module_param(request_size, int, 0);
 MODULE_PARM_DESC(request_size, "size of each request");
 
 /*
+ * OCF batching of requests
+ */
+static int request_batch = 1;
+module_param(request_batch, int, 0);
+MODULE_PARM_DESC(request_batch, "enable OCF request batching");
+
+/*
+ * OCF immediate callback on completion
+ */
+static int request_cbimm = 1;
+module_param(request_cbimm, int, 0);
+MODULE_PARM_DESC(request_cbimm, "enable OCF immediate callback on completion");
+
+/*
  * a structure for each request
  */
 typedef struct  {
@@ -96,6 +112,7 @@ typedef struct  {
 
 static request_t *requests;
 
+static spinlock_t ocfbench_counter_lock;
 static int outstanding;
 static int total;
 
@@ -105,6 +122,8 @@ static int total;
  */
 
 static uint64_t ocf_cryptoid;
+static unsigned long jstart, jstop;
+
 static int ocf_init(void);
 static int ocf_cb(struct cryptop *crp);
 static void ocf_request(void *arg);
@@ -128,13 +147,15 @@ ocf_init(void)
 	cria.cri_klen = 20 * 8;
 	cria.cri_key  = "0123456789abcdefghij";
 
-	crie.cri_alg  = CRYPTO_3DES_CBC;
+	//crie.cri_alg  = CRYPTO_3DES_CBC;
+	crie.cri_alg  = CRYPTO_AES_CBC;
 	crie.cri_klen = 24 * 8;
 	crie.cri_key  = "0123456789abcdefghijklmn";
 
 	crie.cri_next = &cria;
 
-	error = crypto_newsession(&ocf_cryptoid, &crie, 0);
+	error = crypto_newsession(&ocf_cryptoid, &crie,
+				CRYPTOCAP_F_HARDWARE | CRYPTOCAP_F_SOFTWARE);
 	if (error) {
 		printk("crypto_newsession failed %d\n", error);
 		return -1;
@@ -146,23 +167,23 @@ static int
 ocf_cb(struct cryptop *crp)
 {
 	request_t *r = (request_t *) crp->crp_opaque;
+	unsigned long flags;
 
 	if (crp->crp_etype)
 		printk("Error in OCF processing: %d\n", crp->crp_etype);
-	total++;
 	crypto_freereq(crp);
 	crp = NULL;
 
-	if (total > request_num) {
+	/* do all requests  but take at least 1 second */
+	spin_lock_irqsave(&ocfbench_counter_lock, flags);
+	total++;
+	if (total > request_num && jstart + HZ < jiffies) {
 		outstanding--;
+		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return 0;
 	}
+	spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-	INIT_WORK(&r->work, ocf_request_wq);
-#else
-	INIT_WORK(&r->work, ocf_request, r);
-#endif
 	schedule_work(&r->work);
 	return 0;
 }
@@ -174,9 +195,12 @@ ocf_request(void *arg)
 	request_t *r = arg;
 	struct cryptop *crp = crypto_getreq(2);
 	struct cryptodesc *crde, *crda;
+	unsigned long flags;
 
 	if (!crp) {
+		spin_lock_irqsave(&ocfbench_counter_lock, flags);
 		outstanding--;
+		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return;
 	}
 
@@ -195,12 +219,17 @@ ocf_request(void *arg)
 	crde->crd_flags = CRD_F_IV_EXPLICIT | CRD_F_ENCRYPT;
 	crde->crd_len = request_size;
 	crde->crd_inject = request_size;
-	crde->crd_alg = CRYPTO_3DES_CBC;
+	//crde->crd_alg = CRYPTO_3DES_CBC;
+	crde->crd_alg = CRYPTO_AES_CBC;
 	crde->crd_key = "0123456789abcdefghijklmn";
 	crde->crd_klen = 24 * 8;
 
 	crp->crp_ilen = request_size + 64;
-	crp->crp_flags = CRYPTO_F_CBIMM;
+	crp->crp_flags = 0;
+	if (request_batch)
+		crp->crp_flags |= CRYPTO_F_BATCH;
+	if (request_cbimm)
+		crp->crp_flags |= CRYPTO_F_CBIMM;
 	crp->crp_buf = (caddr_t) r->buffer;
 	crp->crp_callback = ocf_cb;
 	crp->crp_sid = ocf_cryptoid;
@@ -217,6 +246,12 @@ ocf_request_wq(struct work_struct *work)
 }
 #endif
 
+static void
+ocf_done(void)
+{
+	crypto_freesession(ocf_cryptoid);
+}
+
 /*************************************************************************/
 #ifdef BENCH_IXP_ACCESS_LIB
 /*************************************************************************/
@@ -303,24 +338,25 @@ ixp_perform_cb(
 	IxCryptoAccStatus status)
 {
 	request_t *r = NULL;
+	unsigned long flags;
 
+	/* do all requests  but take at least 1 second */
+	spin_lock_irqsave(&ocfbench_counter_lock, flags);
 	total++;
-	if (total > request_num) {
+	if (total > request_num && jstart + HZ < jiffies) {
 		outstanding--;
+		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return;
 	}
 
 	if (!sbufp || !(r = IX_MBUF_PRIV(sbufp))) {
 		printk("crappo %p %p\n", sbufp, r);
 		outstanding--;
+		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return;
 	}
+	spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-	INIT_WORK(&r->work, ixp_request_wq);
-#else
-	INIT_WORK(&r->work, ixp_request, r);
-#endif
 	schedule_work(&r->work);
 }
 
@@ -329,6 +365,7 @@ ixp_request(void *arg)
 {
 	request_t *r = arg;
 	IxCryptoAccStatus status;
+	unsigned long flags;
 
 	memset(&r->mbuf, 0, sizeof(r->mbuf));
 	IX_MBUF_MLEN(&r->mbuf) = IX_MBUF_PKT_LEN(&r->mbuf) = request_size + 64;
@@ -338,7 +375,9 @@ ixp_request(void *arg)
 			0, request_size, 0, request_size, request_size, r->buffer);
 	if (IX_CRYPTO_ACC_STATUS_SUCCESS != status) {
 		printk("status1 = %d\n", status);
+		spin_lock_irqsave(&ocfbench_counter_lock, flags);
 		outstanding--;
+		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return;
 	}
 	return;
@@ -353,6 +392,12 @@ ixp_request_wq(struct work_struct *work)
 }
 #endif
 
+static void
+ixp_done(void)
+{
+	/* we should free the session here but I am lazy :-) */
+}
+
 /*************************************************************************/
 #endif /* BENCH_IXP_ACCESS_LIB */
 /*************************************************************************/
@@ -360,7 +405,9 @@ ixp_request_wq(struct work_struct *work)
 int
 ocfbench_init(void)
 {
-	int i, jstart, jstop;
+	int i;
+	unsigned long mbps;
+	unsigned long flags;
 
 	printk("Crypto Speed tests\n");
 
@@ -372,6 +419,11 @@ ocfbench_init(void)
 
 	for (i = 0; i < request_q_len; i++) {
 		/* +64 for return data */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+		INIT_WORK(&requests[i].work, ocf_request_wq);
+#else
+		INIT_WORK(&requests[i].work, ocf_request, &requests[i]);
+#endif
 		requests[i].buffer = kmalloc(request_size + 128, GFP_DMA);
 		if (!requests[i].buffer) {
 			printk("malloc failed\n");
@@ -384,19 +436,31 @@ ocfbench_init(void)
 	 * OCF benchmark
 	 */
 	printk("OCF: testing ...\n");
-	ocf_init();
+	if (ocf_init() == -1)
+		return -EINVAL;
+
+	spin_lock_init(&ocfbench_counter_lock);
 	total = outstanding = 0;
 	jstart = jiffies;
 	for (i = 0; i < request_q_len; i++) {
+		spin_lock_irqsave(&ocfbench_counter_lock, flags);
 		outstanding++;
+		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		ocf_request(&requests[i]);
 	}
 	while (outstanding > 0)
 		schedule();
 	jstop = jiffies;
 
-	printk("OCF: %d requests of %d bytes in %d jiffies\n", total, request_size,
-			jstop - jstart);
+	mbps = 0;
+	if (jstop > jstart) {
+		mbps = (unsigned long) total * (unsigned long) request_size * 8;
+		mbps /= ((jstop - jstart) * 1000) / HZ;
+	}
+	printk("OCF: %d requests of %d bytes in %d jiffies (%d.%03d Mbps)\n",
+			total, request_size, (int)(jstop - jstart),
+			((int)mbps) / 1000, ((int)mbps) % 1000);
+	ocf_done();
 
 #ifdef BENCH_IXP_ACCESS_LIB
 	/*
@@ -407,15 +471,29 @@ ocfbench_init(void)
 	total = outstanding = 0;
 	jstart = jiffies;
 	for (i = 0; i < request_q_len; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+		INIT_WORK(&requests[i].work, ixp_request_wq);
+#else
+		INIT_WORK(&requests[i].work, ixp_request, &requests[i]);
+#endif
+		spin_lock_irqsave(&ocfbench_counter_lock, flags);
 		outstanding++;
+		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		ixp_request(&requests[i]);
 	}
 	while (outstanding > 0)
 		schedule();
 	jstop = jiffies;
 
-	printk("IXP: %d requests of %d bytes in %d jiffies\n", total, request_size,
-			jstop - jstart);
+	mbps = 0;
+	if (jstop > jstart) {
+		mbps = (unsigned long) total * (unsigned long) request_size * 8;
+		mbps /= ((jstop - jstart) * 1000) / HZ;
+	}
+	printk("IXP: %d requests of %d bytes in %d jiffies (%d.%03d Mbps)\n",
+			total, request_size, jstop - jstart,
+			((int)mbps) / 1000, ((int)mbps) % 1000);
+	ixp_done();
 #endif /* BENCH_IXP_ACCESS_LIB */
 
 	for (i = 0; i < request_q_len; i++)
@@ -432,5 +510,5 @@ module_init(ocfbench_init);
 module_exit(ocfbench_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
 MODULE_DESCRIPTION("Benchmark various in-kernel crypto speeds");
diff --git a/crypto/ocf/ocf-compat.h b/crypto/ocf/ocf-compat.h
index 53f8b0c8..4ad1223 100644
--- a/crypto/ocf/ocf-compat.h
+++ b/crypto/ocf/ocf-compat.h
@@ -4,8 +4,8 @@
 /*
  * Provide compat routines for older linux kernels and BSD kernels
  *
- * Written by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2007 David McCullough <david_mccullough@securecomputing.com>
+ * Written by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2010 David McCullough <david_mccullough@mcafee.com>
  *
  * LICENSE TERMS
  *
@@ -34,6 +34,11 @@
  */
 /****************************************************************************/
 #ifdef __KERNEL__
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#include <linux/config.h>
+#endif
+
 /*
  * fake some BSD driver interface stuff specifically for OCF use
  */
@@ -184,11 +189,33 @@ struct ocf_device {
 #define DMA_32BIT_MASK  0x00000000ffffffffULL
 #endif
 
+#ifndef htole32
 #define htole32(x)	cpu_to_le32(x)
+#endif
+#ifndef htobe32
 #define htobe32(x)	cpu_to_be32(x)
+#endif
+#ifndef htole16
 #define htole16(x)	cpu_to_le16(x)
+#endif
+#ifndef htobe16
 #define htobe16(x)	cpu_to_be16(x)
+#endif
 
+/* older kernels don't have these */
+
+#include <asm/irq.h>
+#if !defined(IRQ_NONE) && !defined(IRQ_RETVAL)
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define IRQ_WAKE_THREAD
+#define IRQ_RETVAL
+#define irqreturn_t void
+typedef irqreturn_t (*irq_handler_t)(int irq, void *arg, struct pt_regs *regs);
+#endif
+#ifndef IRQF_SHARED
+#define IRQF_SHARED	SA_SHIRQ
+#endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 # define strlcpy(dest,src,len) \
@@ -199,8 +226,13 @@ struct ocf_device {
 #define MAX_ERRNO	4095
 #endif
 #ifndef IS_ERR_VALUE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,5)
+#include <linux/err.h>
+#endif
+#ifndef IS_ERR_VALUE
 #define IS_ERR_VALUE(x) ((unsigned long)(x) >= (unsigned long)-MAX_ERRNO)
 #endif
+#endif
 
 /*
  * common debug for all
@@ -237,6 +269,7 @@ struct ocf_device {
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
 
+#include <linux/mm.h>
 #include <asm/scatterlist.h>
 
 static inline void sg_set_page(struct scatterlist *sg,  struct page *page,
@@ -252,6 +285,85 @@ static inline void *sg_virt(struct scatterlist *sg)
 	return page_address(sg->page) + sg->offset;
 }
 
+#define sg_init_table(sg, n)
+
+#define sg_mark_end(sg)
+
+#endif
+
+#ifndef late_initcall
+#define late_initcall(init) module_init(init)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4) || !defined(CONFIG_SMP)
+#define ocf_for_each_cpu(cpu) for ((cpu) = 0; (cpu) == 0; (cpu)++)
+#else
+#define ocf_for_each_cpu(cpu) for_each_present_cpu(cpu)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+#include <linux/sched.h>
+#define	kill_proc(p,s,v)	send_sig(s,find_task_by_vpid(p),0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4)
+
+struct ocf_thread {
+	struct task_struct	*task;
+	int					(*func)(void *arg);
+	void				*arg;
+};
+
+/* thread startup helper func */
+static inline int ocf_run_thread(void *arg)
+{
+	struct ocf_thread *t = (struct ocf_thread *) arg;
+	if (!t)
+		return -1; /* very bad */
+	t->task = current;
+	daemonize();
+	spin_lock_irq(&current->sigmask_lock);
+	sigemptyset(&current->blocked);
+	recalc_sigpending(current);
+	spin_unlock_irq(&current->sigmask_lock);
+	return (*t->func)(t->arg);
+}
+
+#define kthread_create(f,a,fmt...) \
+	({ \
+		struct ocf_thread t; \
+		pid_t p; \
+		t.task = NULL; \
+		t.func = (f); \
+		t.arg = (a); \
+		p = kernel_thread(ocf_run_thread, &t, CLONE_FS|CLONE_FILES); \
+		while (p != (pid_t) -1 && t.task == NULL) \
+			schedule(); \
+		if (t.task) \
+			snprintf(t.task->comm, sizeof(t.task->comm), fmt); \
+		(t.task); \
+	})
+
+#define kthread_bind(t,cpu)	/**/
+
+#define kthread_should_stop()	(strcmp(current->comm, "stopping") == 0)
+
+#define kthread_stop(t) \
+	({ \
+		strcpy((t)->comm, "stopping"); \
+		kill_proc((t)->pid, SIGTERM, 1); \
+		do { \
+			schedule(); \
+		} while (kill_proc((t)->pid, SIGTERM, 1) == 0); \
+	})
+
+#else
+#include <linux/kthread.h>
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)
+#define	skb_frag_page(x)	((x)->page)
 #endif
 
 #endif /* __KERNEL__ */
diff --git a/crypto/ocf/ocfnull/ocfnull.c b/crypto/ocf/ocfnull/ocfnull.c
index b4ad84c..5fe6893 100644
--- a/crypto/ocf/ocfnull/ocfnull.c
+++ b/crypto/ocf/ocfnull/ocfnull.c
@@ -4,8 +4,8 @@
  * zero cost encryption,  of course you will need to run it at both ends
  * since it does no crypto at all.
  *
- * Written by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2007 David McCullough 
+ * Written by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2006-2010 David McCullough
  *
  * LICENSE TERMS
  *
@@ -33,7 +33,8 @@
  * and/or fitness for purpose.
  */
 
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -199,5 +200,5 @@ module_init(null_init);
 module_exit(null_exit);
 
 MODULE_LICENSE("Dual BSD/GPL");
-MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
 MODULE_DESCRIPTION("ocfnull - claims a lot but does nothing");
diff --git a/crypto/ocf/pasemi/pasemi.c b/crypto/ocf/pasemi/pasemi.c
index c3bb931..1b4333c 100644
--- a/crypto/ocf/pasemi/pasemi.c
+++ b/crypto/ocf/pasemi/pasemi.c
@@ -17,7 +17,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -237,11 +238,6 @@ pasemi_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 
 	if (encini) {
 		ses->ccmd = ccmd;
-
-		/* get an IV */
-		/* XXX may read fewer than requested */
-		get_random_bytes(ses->civ, sizeof(ses->civ));
-
 		ses->keysz = (encini->cri_klen - 63) / 64;
 		memcpy(ses->key, encini->cri_key, (ses->keysz + 1) * 8);
 
@@ -448,6 +444,8 @@ pasemi_process(device_t dev, struct cryptop *crp, int hint)
 		if (enccrd->crd_flags & CRD_F_ENCRYPT) {
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
 				memcpy(ivp, enccrd->crd_iv, ivsize);
+			else
+				read_random(ivp, ivsize);
 			/* If IV is not present in the buffer already, it has to be copied there */
 			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0)
 				crypto_copyback(crp->crp_flags, crp->crp_buf,
diff --git a/crypto/ocf/random.c b/crypto/ocf/random.c
index 118575a..4bb773f 100644
--- a/crypto/ocf/random.c
+++ b/crypto/ocf/random.c
@@ -5,8 +5,8 @@
  *
  * This should be fast and callable from timers/interrupts
  *
- * Written by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2007 David McCullough
+ * Written by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2006-2010 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  *
  * LICENSE TERMS
@@ -35,7 +35,8 @@
  * and/or fitness for purpose.
  */
 
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -45,7 +46,6 @@
 #include <linux/wait.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
-#include <linux/version.h>
 #include <linux/unistd.h>
 #include <linux/poll.h>
 #include <linux/random.h>
@@ -172,7 +172,7 @@ crypto_runregister_all(u_int32_t driverid)
 
 	spin_lock_irqsave(&random_lock, flags);
 	if (list_empty(&random_ops) && started)
-		kill_proc_info(SIGKILL, SEND_SIG_PRIV, randomproc);
+		kill_proc(randomproc, SIGKILL, 1);
 	spin_unlock_irqrestore(&random_lock, flags);
 	return(0);
 }
diff --git a/crypto/ocf/rndtest.c b/crypto/ocf/rndtest.c
index 34b68d8..7bed6a1 100644
--- a/crypto/ocf/rndtest.c
+++ b/crypto/ocf/rndtest.c
@@ -1,8 +1,8 @@
 /*	$OpenBSD$	*/
 
 /*
- * OCF/Linux port done by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2007 David McCullough
+ * OCF/Linux port done by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2006-2010 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -36,14 +36,14 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
 #include <linux/list.h>
 #include <linux/wait.h>
 #include <linux/time.h>
-#include <linux/version.h>
 #include <linux/unistd.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
diff --git a/crypto/ocf/safe/safe.c b/crypto/ocf/safe/safe.c
index a77e3a2..141640e 100644
--- a/crypto/ocf/safe/safe.c
+++ b/crypto/ocf/safe/safe.c
@@ -1,6 +1,6 @@
 /*-
- * Linux port done by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2004-2007 David McCullough
+ * Linux port done by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2004-2010 David McCullough
  * The license and original author are listed below.
  *
  * Copyright (c) 2003 Sam Leffler, Errno Consulting
@@ -31,7 +31,8 @@
 __FBSDID("$FreeBSD: src/sys/dev/safe/safe.c,v 1.18 2007/03/21 03:42:50 sam Exp $");
  */
 
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -46,7 +47,6 @@ __FBSDID("$FreeBSD: src/sys/dev/safe/safe.c,v 1.18 2007/03/21 03:42:50 sam Exp $
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/random.h>
-#include <linux/version.h>
 #include <linux/skbuff.h>
 #include <asm/io.h>
 
@@ -77,40 +77,11 @@ __FBSDID("$FreeBSD: src/sys/dev/safe/safe.c,v 1.18 2007/03/21 03:42:50 sam Exp $
  */
 #define HMAC_HACK 1
 #ifdef HMAC_HACK
-#define LITTLE_ENDIAN 1234
-#define BIG_ENDIAN 4321
-#ifdef __LITTLE_ENDIAN
-#define BYTE_ORDER LITTLE_ENDIAN
-#endif
-#ifdef __BIG_ENDIAN
-#define BYTE_ORDER BIG_ENDIAN
-#endif
+#include <safe/hmachack.h>
 #include <safe/md5.h>
 #include <safe/md5.c>
 #include <safe/sha1.h>
 #include <safe/sha1.c>
-
-u_int8_t hmac_ipad_buffer[64] = {
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
-};
-
-u_int8_t hmac_opad_buffer[64] = {
-    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
-    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
-    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
-    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
-    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
-    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
-    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
-    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C
-};
 #endif /* HMAC_HACK */
 
 /* add proc entry for this */
@@ -237,7 +208,7 @@ pci_map_skb(struct safe_softc *sc,struct safe_operand *buf,struct sk_buff *skb)
 
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		pci_map_linear(sc, buf,
-				page_address(skb_shinfo(skb)->frags[i].page) +
+				page_address(skb_frag_page(&skb_shinfo(skb)->frags[i])) +
 				                        skb_shinfo(skb)->frags[i].page_offset,
 				skb_shinfo(skb)->frags[i].size);
 	}
@@ -561,10 +532,6 @@ safe_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 	ses->ses_used = 1;
 
 	if (encini) {
-		/* get an IV */
-		/* XXX may read fewer than requested */
-		read_random(ses->ses_iv, sizeof(ses->ses_iv));
-
 		ses->ses_klen = encini->cri_klen;
 		if (encini->cri_key != NULL)
 			safe_setup_enckey(ses, encini->cri_key);
@@ -627,7 +594,7 @@ safe_process(device_t dev, struct cryptop *crp, int hint)
 	struct safe_ringentry *re;
 	struct safe_sarec *sa;
 	struct safe_pdesc *pd;
-	u_int32_t cmd0, cmd1, staterec;
+	u_int32_t cmd0, cmd1, staterec, rand_iv[4];
 	unsigned long flags;
 
 	DPRINTF(("%s()\n", __FUNCTION__));
@@ -776,7 +743,7 @@ safe_process(device_t dev, struct cryptop *crp, int hint)
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
 				iv = enccrd->crd_iv;
 			else
-				iv = (caddr_t) ses->ses_iv;
+				read_random((iv = (caddr_t) &rand_iv[0]), sizeof(rand_iv));
 			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
 				crypto_copyback(crp->crp_flags, crp->crp_buf,
 				    enccrd->crd_inject, ivsize, iv);
@@ -1126,31 +1093,6 @@ safe_callback(struct safe_softc *sc, struct safe_ringentry *re)
 		return;
 	}
 
-	if (re->re_flags & SAFE_QFLAGS_COPYOUTIV) {
-		/* copy out IV for future use */
-		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
-			int i;
-			int ivsize;
-
-			if (crd->crd_alg == CRYPTO_DES_CBC ||
-			    crd->crd_alg == CRYPTO_3DES_CBC) {
-				ivsize = 2*sizeof(u_int32_t);
-			} else if (crd->crd_alg == CRYPTO_AES_CBC) {
-				ivsize = 4*sizeof(u_int32_t);
-			} else
-				continue;
-			crypto_copydata(crp->crp_flags, crp->crp_buf,
-			    crd->crd_skip + crd->crd_len - ivsize, ivsize,
-			    (caddr_t)sc->sc_sessions[re->re_sesn].ses_iv);
-			for (i = 0;
-					i < ivsize/sizeof(sc->sc_sessions[re->re_sesn].ses_iv[0]);
-					i++)
-				sc->sc_sessions[re->re_sesn].ses_iv[i] =
-					cpu_to_le32(sc->sc_sessions[re->re_sesn].ses_iv[i]);
-			break;
-		}
-	}
-
 	if (re->re_flags & SAFE_QFLAGS_COPYOUTICV) {
 		/* copy out ICV result */
 		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
@@ -2284,5 +2226,5 @@ module_init(safe_init);
 module_exit(safe_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
 MODULE_DESCRIPTION("OCF driver for safenet PCI crypto devices");
diff --git a/crypto/ocf/safe/safevar.h b/crypto/ocf/safe/safevar.h
index f5b7394..11d8304 100644
--- a/crypto/ocf/safe/safevar.h
+++ b/crypto/ocf/safe/safevar.h
@@ -1,6 +1,6 @@
 /*-
  * The linux port of this code done by David McCullough
- * Copyright (C) 2004-2007 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2004-2010 David McCullough <david_mccullough@mcafee.com>
  * The license and original author are listed below.
  *
  * Copyright (c) 2003 Sam Leffler, Errno Consulting
@@ -145,7 +145,6 @@ struct safe_session {
 	u_int32_t	ses_mlen;		/* hmac length in bytes */
 	u_int32_t	ses_hminner[5];		/* hmac inner state */
 	u_int32_t	ses_hmouter[5];		/* hmac outer state */
-	u_int32_t	ses_iv[4];		/* DES/3DES/AES iv */
 };
 
 struct safe_pkq {
diff --git a/crypto/ocf/talitos/talitos.c b/crypto/ocf/talitos/talitos.c
index eaf3f30..c4bc8c0 100644
--- a/crypto/ocf/talitos/talitos.c
+++ b/crypto/ocf/talitos/talitos.c
@@ -8,7 +8,7 @@
  *
  * This code written by Kim A. B. Phillips <kim.phillips@freescale.com>
  * some code copied from files with the following:
- * Copyright (C) 2004-2007 David McCullough <david_mccullough@securecomputing.com
+ * Copyright (C) 2004-2007 David McCullough <david_mccullough@mcafee.com>
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -107,7 +107,8 @@
  * o add statistics
  */
 
-#ifndef AUTOCONF_INCLUDED
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -120,7 +121,6 @@
 #include <linux/dma-mapping.h>  /* dma_map_single() */
 #include <linux/moduleparam.h>
 
-#include <linux/version.h>
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
 #include <linux/platform_device.h>
 #endif
@@ -418,10 +418,6 @@ talitos_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 	ses->ses_used = 1;
 
 	if (encini) {
-		/* get an IV */
-		/* XXX may read fewer than requested */
-		read_random(ses->ses_iv, sizeof(ses->ses_iv));
-
 		ses->ses_klen = (encini->cri_klen + 7) / 8;
 		memcpy(ses->ses_key, encini->cri_key, ses->ses_klen);
 		if (macini) {
@@ -511,6 +507,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 	int hmac_key, hmac_data, cipher_iv, cipher_key, 
 		in_fifo, out_fifo, cipher_iv_out;
 	static int chsel = -1;
+	u_int32_t rand_iv[4];
 
 	DPRINTF("%s()\n", __FUNCTION__);
 
@@ -752,7 +749,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
 				iv = enccrd->crd_iv;
 			else
-				iv = (caddr_t) ses->ses_iv;
+				read_random((iv = (caddr_t) rand_iv), sizeof(rand_iv));
 			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
 				crypto_copyback(crp->crp_flags, crp->crp_buf,
 				    enccrd->crd_inject, ivsize, iv);
@@ -761,9 +758,8 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			td->hdr |= TALITOS_DIR_INBOUND; 
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT) {
 				iv = enccrd->crd_iv;
-				bcopy(enccrd->crd_iv, iv, ivsize);
 			} else {
-				iv = (caddr_t) ses->ses_iv;
+				iv = (caddr_t) rand_iv;
 				crypto_copydata(crp->crp_flags, crp->crp_buf,
 				    enccrd->crd_inject, ivsize, iv);
 			}
diff --git a/crypto/ocf/talitos/talitos_soft.h b/crypto/ocf/talitos/talitos_soft.h
index 79efdbd..eda9c2e 100644
--- a/crypto/ocf/talitos/talitos_soft.h
+++ b/crypto/ocf/talitos/talitos_soft.h
@@ -69,7 +69,6 @@ struct talitos_session {
 	u_int32_t	ses_key[8];		/* DES/3DES/AES key */
 	u_int32_t	ses_hmac[5];		/* hmac inner state */
 	u_int32_t	ses_hmac_len;		/* hmac length */
-	u_int32_t	ses_iv[4];		/* DES/3DES/AES iv */
 	u_int32_t	ses_mlen;		/* desired hash result len (12=ipsec or 16) */
 };
 
diff --git a/crypto/ocf/ubsec_ssb/bsdqueue.h b/crypto/ocf/ubsec_ssb/bsdqueue.h
index 6010552..98f9234 100644
--- a/crypto/ocf/ubsec_ssb/bsdqueue.h
+++ b/crypto/ocf/ubsec_ssb/bsdqueue.h
@@ -36,7 +36,7 @@
 #define _BSD_SYS_QUEUE_H_
 
 /*
- * This file defines five types of data structures: singly-linked lists, 
+ * This file defines five types of data structures: singly-linked lists,
  * lists, simple queues, tail queues, and circular queues.
  *
  *
@@ -95,15 +95,15 @@
 struct name {                               \
     struct type *slh_first; /* first element */         \
 }
- 
+
 #define BSD_SLIST_HEAD_INITIALIZER(head)                    \
     { NULL }
- 
+
 #define BSD_SLIST_ENTRY(type)                       \
 struct {                                \
     struct type *sle_next;  /* next element */          \
 }
- 
+
 /*
  * Singly-linked List access methods.
  */
@@ -318,8 +318,8 @@ struct {                                \
     struct type **tqe_prev; /* address of previous next element */  \
 }
 
-/* 
- * tail queue access methods 
+/*
+ * tail queue access methods
  */
 #define BSD_TAILQ_FIRST(head)       ((head)->tqh_first)
 #define BSD_TAILQ_END(head)         NULL
@@ -426,7 +426,7 @@ struct {                                \
 }
 
 /*
- * Circular queue access methods 
+ * Circular queue access methods
  */
 #define BSD_CIRCLEQ_FIRST(head)     ((head)->cqh_first)
 #define BSD_CIRCLEQ_LAST(head)      ((head)->cqh_last)
diff --git a/crypto/ocf/ubsec_ssb/ubsec_ssb.c b/crypto/ocf/ubsec_ssb/ubsec_ssb.c
index f5d7762..1333b27 100644
--- a/crypto/ocf/ubsec_ssb/ubsec_ssb.c
+++ b/crypto/ocf/ubsec_ssb/ubsec_ssb.c
@@ -5,7 +5,7 @@
  * Copyright (c) 2000 Jason L. Wright (jason@thought.net)
  * Copyright (c) 2000 Theo de Raadt (deraadt@openbsd.org)
  * Copyright (c) 2001 Patrik Lindergren (patrik@ipunplugged.com)
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -64,7 +64,7 @@
  */
 //#include "bsdqueue.h"
 
-/* 
+/*
  * OCF
  */
 #include <cryptodev.h>
@@ -101,23 +101,23 @@
 #endif
 
 /*
- * Prototypes 
+ * Prototypes
  */
 static irqreturn_t ubsec_ssb_isr(int, void *, struct pt_regs *);
 static int __devinit ubsec_ssb_probe(struct ssb_device *sdev,
     const struct ssb_device_id *ent);
 static void __devexit ubsec_ssb_remove(struct ssb_device *sdev);
-int ubsec_attach(struct ssb_device *sdev, const struct ssb_device_id *ent, 
+int ubsec_attach(struct ssb_device *sdev, const struct ssb_device_id *ent,
     struct device *self);
-static void ubsec_setup_mackey(struct ubsec_session *ses, int algo, 
+static void ubsec_setup_mackey(struct ubsec_session *ses, int algo,
     caddr_t key, int klen);
-static int dma_map_skb(struct ubsec_softc *sc, 
+static int dma_map_skb(struct ubsec_softc *sc,
     struct ubsec_dma_alloc* q_map, struct sk_buff *skb, int *mlen);
-static int dma_map_uio(struct ubsec_softc *sc, 
+static int dma_map_uio(struct ubsec_softc *sc,
     struct ubsec_dma_alloc *q_map, struct uio *uio, int *mlen);
-static void dma_unmap(struct ubsec_softc *sc, 
+static void dma_unmap(struct ubsec_softc *sc,
     struct ubsec_dma_alloc *q_map, int mlen);
-static int ubsec_dmamap_aligned(struct ubsec_softc *sc, 
+static int ubsec_dmamap_aligned(struct ubsec_softc *sc,
     const struct ubsec_dma_alloc *q_map, int mlen);
 
 #ifdef UBSEC_DEBUG
@@ -200,7 +200,7 @@ static device_method_t ubsec_ssb_methods = {
 };
 
 #ifdef UBSEC_DEBUG
-static int 
+static int
 proc_read(char *buf, char **start, off_t offset,
     int size, int *peof, void *data)
 {
@@ -210,15 +210,15 @@ proc_read(char *buf, char **start, off_t offset,
     struct ubsec_q *q;
     struct ubsec_dma *dmap;
 #endif
-   
+
     while ((i < UBSEC_SSB_MAX_CHIPS) && (ubsec_chip_idx[i] != NULL))
     {
         struct ubsec_softc *sc = ubsec_chip_idx[i];
-        
+
         stat = READ_REG(sc, BS_STAT);
         ctrl = READ_REG(sc, BS_CTRL);
-        ret = snprintf((buf + byteswritten), 
-            (size - byteswritten) , 
+        ret = snprintf((buf + byteswritten),
+            (size - byteswritten) ,
             "DEV %d, DMASTAT %08x, DMACTRL %08x\n", i, stat, ctrl);
 
         byteswritten += ret;
@@ -276,7 +276,7 @@ dma_map_skb(struct ubsec_softc *sc, struct ubsec_dma_alloc* q_map, struct sk_buf
                          skb->data,
                          skb_headlen(skb),
                          DMA_BIDIRECTIONAL);
-    
+
     q_map[i].dma_paddr = tmp;
     q_map[i].dma_vaddr = skb->data;
     q_map[i].dma_size = skb_headlen(skb);
@@ -292,18 +292,18 @@ dma_map_skb(struct ubsec_softc *sc, struct ubsec_dma_alloc* q_map, struct sk_buf
 #endif
 
 
-    /* all other data packages */    
+    /* all other data packages */
     for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 
 #ifdef UBSEC_VERBOSE_DEBUG
-        DPRINTF("%s - map %d 0x%x %d\n", __FUNCTION__, i + 1, 
+        DPRINTF("%s - map %d 0x%x %d\n", __FUNCTION__, i + 1,
             (unsigned int)page_address(skb_frag_page(&skb_shinfo(skb)->frags[i])) +
             skb_shinfo(skb)->frags[i].page_offset, skb_shinfo(skb)->frags[i].size);
 #endif
 
         tmp = dma_map_single(sc->sc_dv,
                              page_address(skb_frag_page(&skb_shinfo(skb)->frags[i])) +
-                                 skb_shinfo(skb)->frags[i].page_offset, 
+                                 skb_shinfo(skb)->frags[i].page_offset,
                              skb_shinfo(skb)->frags[i].size,
                              DMA_BIDIRECTIONAL);
 
@@ -482,9 +482,9 @@ ubsec_setup_mackey(struct ubsec_session *ses, int algo, caddr_t key, int klen)
 }
 #undef N
 
-static int 
-__devinit ubsec_ssb_probe(struct ssb_device *sdev, 
-    const struct ssb_device_id *ent) 
+static int
+__devinit ubsec_ssb_probe(struct ssb_device *sdev,
+    const struct ssb_device_id *ent)
 {
     int err;
 
@@ -498,7 +498,7 @@ __devinit ubsec_ssb_probe(struct ssb_device *sdev,
 	goto err_out;
     }
 
-    err = request_irq(sdev->irq, (irq_handler_t)ubsec_ssb_isr, 
+    err = request_irq(sdev->irq, (irq_handler_t)ubsec_ssb_isr,
         IRQF_DISABLED | IRQF_SHARED, DRV_MODULE_NAME, sdev);
     if (err) {
         dev_err(sdev->dev, "Could not request irq\n");
@@ -506,7 +506,7 @@ __devinit ubsec_ssb_probe(struct ssb_device *sdev,
     }
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
-    err = dma_set_mask(sdev->dma_dev, DMA_BIT_MASK(32)) || 
+    err = dma_set_mask(sdev->dma_dev, DMA_BIT_MASK(32)) ||
 	  dma_set_coherent_mask(sdev->dma_dev, DMA_BIT_MASK(32));
 #else
     err = ssb_dma_set_mask(sdev, DMA_32BIT_MASK);
@@ -534,7 +534,7 @@ __devinit ubsec_ssb_probe(struct ssb_device *sdev,
     {
         procdebug->read_proc = proc_read;
         procdebug->data = NULL;
-    } else 
+    } else
         DPRINTF("Unable to create proc file.\n");
 #endif
 
@@ -608,7 +608,7 @@ static void __devexit ubsec_ssb_remove(struct ssb_device *sdev) {
 
 
 int
-ubsec_attach(struct ssb_device *sdev, const struct ssb_device_id *ent, 
+ubsec_attach(struct ssb_device *sdev, const struct ssb_device_id *ent,
     struct device *self)
 {
     struct ubsec_softc *sc = NULL;
@@ -708,8 +708,8 @@ ubsec_attach(struct ssb_device *sdev, const struct ssb_device_id *ent,
 /*
  * UBSEC Interrupt routine
  */
-static irqreturn_t 
-ubsec_ssb_isr(int irq, void *arg, struct pt_regs *regs) 
+static irqreturn_t
+ubsec_ssb_isr(int irq, void *arg, struct pt_regs *regs)
 {
     struct ubsec_softc *sc = NULL;
     volatile u_int32_t stat;
@@ -798,7 +798,7 @@ ubsec_feed(struct ubsec_softc *sc)
 {
 #ifdef UBSEC_VERBOSE_DEBUG
     static int max;
-#endif 
+#endif
     struct ubsec_q *q, *q2;
     int npkts, i;
     void *v;
@@ -835,8 +835,8 @@ ubsec_feed(struct ubsec_softc *sc)
     --sc->sc_nqueue;
 
 #if 0
-    /* 
-     * XXX 
+    /*
+     * XXX
      * We use dma_map_single() - no sync required!
      */
 
@@ -912,7 +912,7 @@ feed1:
         WRITE_REG(sc, BS_MCR1, q->q_dma->d_alloc.dma_paddr +
             offsetof(struct ubsec_dmachunk, d_mcr));
 #ifdef UBSEC_VERBOSE_DEBUG
-        DPRINTF("feed (2): q->chip %p %08x %08x\n", q, 
+        DPRINTF("feed (2): q->chip %p %08x %08x\n", q,
             (u_int32_t)q->q_dma->d_alloc.dma_paddr,
             (u_int32_t)(q->q_dma->d_alloc.dma_paddr +
             offsetof(struct ubsec_dmachunk, d_mcr)));
@@ -1014,7 +1014,7 @@ ubsec_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
             bcopy(encini->cri_key, &ses->ses_key[0], 8);
             bcopy(encini->cri_key, &ses->ses_key[2], 8);
             bcopy(encini->cri_key, &ses->ses_key[4], 8);
-            ses->ses_keysize = 192; /* Fake! Actually its only 64bits .. 
+            ses->ses_keysize = 192; /* Fake! Actually its only 64bits ..
                                        oh no it is even less: 54bits. */
         } else if(encini->cri_alg == CRYPTO_3DES_CBC) {
             bcopy(encini->cri_key, ses->ses_key, 24);
@@ -1056,7 +1056,7 @@ ubsec_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
                 printk(KERN_ERR DRV_MODULE_NAME ": unsupported hash operation with mac/hash len: %d\n", ses->ses_mlen);
                 return (EINVAL);
             }
-            
+
         }
 
         if (macini->cri_key != NULL) {
@@ -1184,7 +1184,7 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
             maccrd = crd1;
             enccrd = NULL;
         } else if (crd1->crd_alg == CRYPTO_DES_CBC ||
-            crd1->crd_alg == CRYPTO_3DES_CBC || 
+            crd1->crd_alg == CRYPTO_3DES_CBC ||
             crd1->crd_alg == CRYPTO_AES_CBC) {
             maccrd = NULL;
             enccrd = crd1;
@@ -1410,8 +1410,8 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
            goto errout;
     }
 
-    /* 
-     * Check alignment 
+    /*
+     * Check alignment
      */
     nicealign = ubsec_dmamap_aligned(sc, q->q_src_map, q->q_src_len);
 
@@ -1642,7 +1642,7 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
             if ((i + 1) == q->q_dst_len) {
                 if (maccrd)
                     /* Authentication:
-                     * The last fragment of the output buffer 
+                     * The last fragment of the output buffer
                      * contains the HMAC. */
                     pb->pb_next = htole32(dmap->d_alloc.dma_paddr +
                         offsetof(struct ubsec_dmachunk, d_macbuf[0]));
@@ -1664,16 +1664,16 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
         if (enccrd != NULL &&
             enccrd->crd_alg == CRYPTO_AES_CBC)
         {
-            struct ubsec_pktctx_aes128 *ctxaes128;    
-            struct ubsec_pktctx_aes192 *ctxaes192;    
-            struct ubsec_pktctx_aes256 *ctxaes256;    
+            struct ubsec_pktctx_aes128 *ctxaes128;
+            struct ubsec_pktctx_aes192 *ctxaes192;
+            struct ubsec_pktctx_aes256 *ctxaes256;
 
             switch(ses->ses_keysize)
             {
                 /* AES 128bit */
                 case 128:
                 ctxaes128 = (struct ubsec_pktctx_aes128 *)
-                    (dmap->d_alloc.dma_vaddr + 
+                    (dmap->d_alloc.dma_vaddr +
                     offsetof(struct ubsec_dmachunk, d_ctx));
 
                 ctxaes128->pc_len = htole16(sizeof(struct ubsec_pktctx_aes128));
@@ -1693,7 +1693,7 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
                 /* AES 192bit */
                 case 192:
                 ctxaes192 = (struct ubsec_pktctx_aes192 *)
-                    (dmap->d_alloc.dma_vaddr + 
+                    (dmap->d_alloc.dma_vaddr +
                     offsetof(struct ubsec_dmachunk, d_ctx));
 
                 ctxaes192->pc_len = htole16(sizeof(struct ubsec_pktctx_aes192));
@@ -1713,7 +1713,7 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
                 /* AES 256bit */
                 case 256:
                 ctxaes256 = (struct ubsec_pktctx_aes256 *)
-                    (dmap->d_alloc.dma_vaddr + 
+                    (dmap->d_alloc.dma_vaddr +
                     offsetof(struct ubsec_dmachunk, d_ctx));
 
                 ctxaes256->pc_len = htole16(sizeof(struct ubsec_pktctx_aes256));
@@ -1732,7 +1732,7 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
 
             }
         } else {
-            /* 
+            /*
              * [3]DES / MD5_HMAC / SHA1_HMAC
              *
              * MD5_HMAC / SHA1_HMAC can use the IPSEC 3DES operation without
@@ -1742,7 +1742,7 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
 
             ctxdes = (struct ubsec_pktctx_des *)(dmap->d_alloc.dma_vaddr +
                 offsetof(struct ubsec_dmachunk, d_ctx));
-            
+
             ctxdes->pc_len = htole16(sizeof(struct ubsec_pktctx_des));
             ctxdes->pc_type = ctx.pc_type;
             ctxdes->pc_flags = ctx.pc_flags;
@@ -1752,7 +1752,7 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
             for (i = 0; i < 5; i++)
                 ctxdes->pc_hminner[i] = ctx.pc_hminner[i];
             for (i = 0; i < 5; i++)
-                ctxdes->pc_hmouter[i] = ctx.pc_hmouter[i];   
+                ctxdes->pc_hmouter[i] = ctx.pc_hmouter[i];
             ctxdes->pc_iv[0] = ctx.pc_iv[0];
             ctxdes->pc_iv[1] = ctx.pc_iv[1];
         }
@@ -1767,7 +1767,7 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
 
         ctxs = (struct ubsec_pktctx *)(dmap->d_alloc.dma_vaddr +
                     offsetof(struct ubsec_dmachunk, d_ctx));
- 
+
         /* transform generic context into small context */
         for (i = 0; i < 6; i++)
             ctxs->pc_deskey[i] = ctx.pc_key[i];
@@ -1798,7 +1798,7 @@ ubsec_process(device_t dev, struct cryptop *crp, int hint)
 #endif
     spin_unlock_irqrestore(&sc->sc_ringmtx, flags);
     //spin_unlock_irq(&sc->sc_ringmtx);
-    
+
     return (0);
 
 errout:
@@ -1928,7 +1928,7 @@ ubsec_callback(struct ubsec_softc *sc, struct ubsec_q *q)
                 crypto_copydata(crp->crp_flags, (caddr_t)crp->crp_buf,
                     crd->crd_skip + crd->crd_len - ivsize, ivsize,
                     (caddr_t)sc->sc_sessions[q->q_sesn].ses_iv);
-                    
+
             }
             break;
         }
@@ -1951,7 +1951,7 @@ ubsec_callback(struct ubsec_softc *sc, struct ubsec_q *q)
                 (caddr_t)dmap->d_dma->d_macbuf);
 #endif
             crypto_copyback(crp->crp_flags, crp->crp_buf,
-                crd->crd_inject, 
+                crd->crd_inject,
                 sc->sc_sessions[q->q_sesn].ses_mlen,
                 (caddr_t)dmap->d_dma->d_macbuf);
 #if 0
@@ -2003,10 +2003,10 @@ ubsec_mcopy(struct sk_buff *srcm, struct sk_buff *dstm, int hoffset, int toffset
 }
 
 int
-ubsec_dma_malloc(struct ubsec_softc *sc, struct ubsec_dma_alloc *dma, 
+ubsec_dma_malloc(struct ubsec_softc *sc, struct ubsec_dma_alloc *dma,
     size_t size, int mapflags)
 {
-    dma->dma_vaddr = dma_alloc_coherent(sc->sc_dv, 
+    dma->dma_vaddr = dma_alloc_coherent(sc->sc_dv,
         size, &dma->dma_paddr, GFP_KERNEL);
 
     if (likely(dma->dma_vaddr))
@@ -2023,7 +2023,7 @@ ubsec_dma_malloc(struct ubsec_softc *sc, struct ubsec_dma_alloc *dma,
 void
 ubsec_dma_free(struct ubsec_softc *sc, struct ubsec_dma_alloc *dma)
 {
-    dma_free_coherent(sc->sc_dv, dma->dma_size, dma->dma_vaddr, 
+    dma_free_coherent(sc->sc_dv, dma->dma_size, dma->dma_vaddr,
         dma->dma_paddr);
 }
 
@@ -2117,7 +2117,7 @@ ubsec_free_q(struct ubsec_softc *sc, struct ubsec_q *q)
         if(q->q_stacked_mcr[i]) {
             q2 = q->q_stacked_mcr[i];
 
-            if ((q2->q_dst_m != NULL) && (q2->q_src_m != q2->q_dst_m)) 
+            if ((q2->q_dst_m != NULL) && (q2->q_src_m != q2->q_dst_m))
 #ifdef NOTYET
                 m_freem(q2->q_dst_m);
 #else
@@ -2125,9 +2125,9 @@ ubsec_free_q(struct ubsec_softc *sc, struct ubsec_q *q)
 #endif
 
             crp = (struct cryptop *)q2->q_crp;
-            
+
             BSD_SIMPLEQ_INSERT_TAIL(&sc->sc_freequeue, q2, q_next);
-            
+
             crp->crp_etype = EFAULT;
             crypto_done(crp);
         } else {
@@ -2146,9 +2146,9 @@ ubsec_free_q(struct ubsec_softc *sc, struct ubsec_q *q)
 #endif
 
     crp = (struct cryptop *)q->q_crp;
-    
+
     BSD_SIMPLEQ_INSERT_TAIL(&sc->sc_freequeue, q, q_next);
-    
+
     crp->crp_etype = EFAULT;
     crypto_done(crp);
     return(0);
diff --git a/crypto/ocf/uio.h b/crypto/ocf/uio.h
index e82e46c..03a6249 100644
--- a/crypto/ocf/uio.h
+++ b/crypto/ocf/uio.h
@@ -8,8 +8,8 @@
  * with the BSD cryptodev,  we need to keep this around.  Perhaps this can
  * be moved back into the linux/uio.h
  *
- * Linux port done by David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2007 David McCullough
+ * Linux port done by David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2006-2010 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  *
  * LICENSE TERMS
-- 
1.7.5.4

