From e33fe38452780c7105f36d9edacc7c708bea7fbf Mon Sep 17 00:00:00 2001
From: Dovrat <dovrat@marvell.com>
Date: Tue, 8 Apr 2014 16:56:21 +0300
Subject: [PATCH 1541/1825] mv_qm.h moved to qm directory, added error message
 to bm code, fixed some input verification
 variables pr_info was splitted to multiple lines

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 86ed4fbcd638f311f57ae197cc22b03f516639c7

Change-Id: I18e53b8baa35a639ffe105cdc2925b2ffe055413
Signed-off-by: Dovrat <dovrat@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7001
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/bm/mv_bm.c |  326 ++++++-----
 drivers/net/ethernet/marvell/pp3/bm/mv_bm.h |   21 +-
 drivers/net/ethernet/marvell/pp3/bm/mv_qm.h |  879 ---------------------------
 3 files changed, 192 insertions(+), 1034 deletions(-)
 delete mode 100644 drivers/net/ethernet/marvell/pp3/bm/mv_qm.h

diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c
index fda771b..6e88dfd 100644
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c
+++ b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c
@@ -69,12 +69,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 #include "bm/mv_bm.h"
-#include "bm/mv_qm.h"
+#include "qm/mv_qm.h"
 #include "bm/mv_bm_regs.h"
 
 int bm_open(void)
 {
-	int rc = -BM_INPUT_NOT_IN_RANGE;
+	int rc = !OK;
 
 	rc = bm_reg_address_alias_init();
 	if (rc != OK)
@@ -86,17 +86,13 @@ int bm_open(void)
 	if (rc != OK)
 		return rc;
 	rc = bm_pid_bid_init();
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
 /*BM User Application Interface*/
 int bm_attr_all_pools_def_set(void)
 {
-	int rc = -BM_INPUT_NOT_IN_RANGE;
+	int rc = !OK;
 	u32 arDomain, awDomain, arCache, awCache, arQOS, awQOS;
 
 	arDomain = 0;
@@ -110,10 +106,6 @@ int bm_attr_all_pools_def_set(void)
 	if (rc != OK)
 		return rc;
 	rc = bm_attr_gp_pool_set(arDomain, awDomain, arCache, awCache, arQOS, awQOS);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -126,19 +118,32 @@ int bm_attr_qm_pool_set(u32 arDomain, u32 awDomain, u32 arCache, u32 awCache, u3
 	struct bm_dram_cache_conf  reg_dram_cache_conf;
 	struct bm_dram_qos_conf    reg_dram_qos_conf;
 
-	if ((arDomain < BM_ADOMAIN_MIN) || (arDomain > BM_ADOMAIN_MAX))
+	pr_info("bm_attr_qm_pool_set %d %d %d %d %d %d\n", arDomain, awDomain, arCache, awCache, arQOS, awQOS);
+
+	if ((arDomain < BM_ADOMAIN_MIN) || (arDomain > BM_ADOMAIN_MAX)) {
+		pr_err("arDomain is not in range\n");
 		return rc;
-	if ((awDomain < BM_ADOMAIN_MIN) || (awDomain > BM_ADOMAIN_MAX))
+	}
+	if ((awDomain < BM_ADOMAIN_MIN) || (awDomain > BM_ADOMAIN_MAX)) {
+		pr_err("awDomain is not in range\n");
 		return rc;
-	if ((arCache  <  BM_ACACHE_MIN) || (arCache  >  BM_ACACHE_MAX))
+	}
+	if ((arCache  <  BM_ACACHE_MIN) || (arCache  >  BM_ACACHE_MAX)) {
+		pr_err("arCache is not in range\n");
 		return rc;
-	if ((awCache  <  BM_ACACHE_MIN) || (awCache  >  BM_ACACHE_MAX))
+	}
+	if ((awCache  <  BM_ACACHE_MIN) || (awCache  >  BM_ACACHE_MAX)) {
+		pr_err("awCache is not in range\n");
 		return rc;
-	if ((arQOS    <    BM_AQOS_MIN) || (arQOS    >    BM_AQOS_MAX))
+	}
+	if ((arQOS    <    BM_AQOS_MIN) || (arQOS    >    BM_AQOS_MAX)) {
+		pr_err("arQOS is not in range\n");
 		return rc;
-	if ((awQOS    <    BM_AQOS_MIN) || (awQOS    >    BM_AQOS_MAX))
+	}
+	if ((awQOS    <    BM_AQOS_MIN) || (awQOS    >    BM_AQOS_MAX)) {
+		pr_err("awQOS is not in range\n");
 		return rc;
-
+	}
 	rc = bm_enable_status_get(&bm_req_rcv_en);
 	if (rc != OK)
 		return rc;
@@ -186,10 +191,6 @@ int bm_attr_qm_pool_set(u32 arDomain, u32 awDomain, u32 arCache, u32 awCache, u3
 	reg_dram_qos_conf.dwm_awqos_b0       = awQOS;
 	reg_dram_qos_conf.drm_arqos_b0       = arQOS;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_dram_qos_conf);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -202,18 +203,30 @@ int bm_attr_gp_pool_set(u32 arDomain, u32 awDomain, u32 arCache, u32 awCache, u3
 	struct bm_dram_cache_conf  reg_dram_cache_conf;
 	struct bm_dram_qos_conf    reg_dram_qos_conf;
 
-	if ((arDomain < BM_ADOMAIN_MIN) || (arDomain > BM_ADOMAIN_MAX))
+	if ((arDomain < BM_ADOMAIN_MIN) || (arDomain > BM_ADOMAIN_MAX)) {
+		pr_err("arDomain is not in range\n");
 		return rc;
-	if ((awDomain < BM_ADOMAIN_MIN) || (awDomain > BM_ADOMAIN_MAX))
+	}
+	if ((awDomain < BM_ADOMAIN_MIN) || (awDomain > BM_ADOMAIN_MAX)) {
+		pr_err("awDomain is not in range\n");
 		return rc;
-	if ((arCache  <  BM_ACACHE_MIN) || (arCache  >  BM_ACACHE_MAX))
+	}
+	if ((arCache  <  BM_ACACHE_MIN) || (arCache  >  BM_ACACHE_MAX)) {
+		pr_err("arCache is not in range\n");
 		return rc;
-	if ((awCache  <  BM_ACACHE_MIN) || (awCache  >  BM_ACACHE_MAX))
+	}
+	if ((awCache  <  BM_ACACHE_MIN) || (awCache  >  BM_ACACHE_MAX)) {
+		pr_err("awCache is not in range\n");
 		return rc;
-	if ((arQOS    <    BM_AQOS_MIN) || (arQOS    >    BM_AQOS_MAX))
+	}
+	if ((arQOS    <    BM_AQOS_MIN) || (arQOS    >    BM_AQOS_MAX)) {
+		pr_err("arQOS is not in range\n");
 		return rc;
-	if ((awQOS    <    BM_AQOS_MIN) || (awQOS    >    BM_AQOS_MAX))
+	}
+	if ((awQOS    <    BM_AQOS_MIN) || (awQOS    >    BM_AQOS_MAX)) {
+		pr_err("awQOS is not in range\n");
 		return rc;
+	}
 
 	rc = bm_enable_status_get(&bm_req_rcv_en);
 	if (rc != OK)
@@ -262,10 +275,6 @@ int bm_attr_gp_pool_set(u32 arDomain, u32 awDomain, u32 arCache, u32 awCache, u3
 	reg_dram_qos_conf.dwm_awqos_bgp       = awQOS;
 	reg_dram_qos_conf.drm_arqos_bgp       = arQOS;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_dram_qos_conf);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -304,10 +313,6 @@ int bm_qm_gpm_pools_def_quick_init(u32 num_of_buffers, u32 *qece_base_address, u
 
 	rc = bm_qm_gpm_pools_quick_init(num_of_buffers, qece_base_address, pl_base_address,
 		ae_thr, af_thr,	cache_vmid, cache_attr, cache_so_thr, cache_si_thr, cache_num_of_buffers);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -327,10 +332,6 @@ int bm_qm_dram_pools_def_quick_init(u32 num_of_buffers, u32 *qece_base_address,
 	rc = bm_qm_dram_pools_quick_init(num_of_buffers, qece_base_address,
 				pl_base_address, ae_thr, af_thr,
 				cache_vmid, cache_attr, cache_so_thr, cache_si_thr, cache_num_of_buffers);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -344,54 +345,107 @@ int bm_qm_gpm_pools_quick_init(u32 num_of_buffers, u32 *qece_base_address,
 	struct mv_word40 base_address;
 	u32 granularity_of_pe_in_dram, granularity_of_pe_in_cache;
 
+	pr_info("%s:\n", __func__);
+	pr_info("  num_of_buffers    %d\n", num_of_buffers);
+	pr_info("  qece_base_address %x pl_base_address %x\n",
+		((struct mv_word40 *)qece_base_address)->lo, ((struct mv_word40 *)pl_base_address)->hi);
+	pr_info("  ae_thr            %d af_thr          %d\n", ae_thr, af_thr);
+	pr_info("  cache_vmid        %d cache_attr      %d\n", cache_vmid, cache_attr);
+	pr_info("  cache_so_thr      %d cache_si_thr    %d  cache_num_of_buffers %d\n",
+		cache_so_thr, cache_si_thr, cache_num_of_buffers);
+
 	granularity_of_pe_in_dram  = GRANULARITY_OF_64_BYTES / QM_PE_SIZE_IN_BYTES_IN_DRAM;		/* 64/4 */
 	granularity_of_pe_in_cache = GRANULARITY_OF_64_BYTES / QM_PE_SIZE_IN_BYTES_IN_CACHE;	/* 64/8 */
 
-	if       ((num_of_buffers % granularity_of_pe_in_dram)  != 0)
+	if       ((num_of_buffers % granularity_of_pe_in_dram)  != 0) {
+		pr_err("number of buffer should be multiplication of %d\n", granularity_of_pe_in_dram);
 		return rc;  /*qm PE are always 22bits which is 4Bytes */
-	if               ((ae_thr % granularity_of_pe_in_dram)  != 0)
+	}
+	if               ((ae_thr % granularity_of_pe_in_dram)  != 0) {
+		pr_err("almost empty threhold should be multiplication of %d\n", granularity_of_pe_in_dram);
 		return rc;
-	if               ((af_thr % granularity_of_pe_in_dram)  != 0)
+	}
+	if               ((af_thr % granularity_of_pe_in_dram)  != 0) {
+		pr_err("almost full threhold should be multiplication of %d\n", granularity_of_pe_in_dram);
 		return rc;
-	if ((cache_num_of_buffers % granularity_of_pe_in_cache) != 0)
+	}
+	if ((cache_num_of_buffers % granularity_of_pe_in_cache) != 0) {
+		pr_err("number of buffer in cahce should be multiplication of %d\n", granularity_of_pe_in_cache);
 		return rc;
-	if (ae_thr       >= af_thr)
+	}
+	if (af_thr       < ae_thr) {
+		pr_err("almost full should be larger than almost empty\n");
 		return rc;
-	if (cache_so_thr >= cache_si_thr + 16)
+	}
+	if (cache_so_thr < cache_si_thr + 16) {
+		pr_err("cache swap out threshold should be larger than cache swap in plus 16\n");
 		return rc;
-	if ((num_of_buffers       < BM_NUM_OF_BUFFERS_QM_MIN) || (num_of_buffers > BM_NUM_OF_BUFFERS_QM_GPM_MAX))
+	}
+	if ((num_of_buffers < BM_NUM_OF_BUFFERS_QM_MIN) || (num_of_buffers > BM_NUM_OF_BUFFERS_QM_GPM_MAX)) {
+		pr_err("number of buffer should be in the range %d ... %d\n",
+			BM_NUM_OF_BUFFERS_QM_MIN, BM_NUM_OF_BUFFERS_QM_GPM_MAX);
 		return rc;
+	}
 /*	if ((qece_base_address_hi <  BM_DRAM_ADDRESS_HI_MIN) || (qece_base_address_hi >  BM_DRAM_ADDRESS_HI_MAX)) */
 	if ((((struct mv_word40 *)qece_base_address)->hi < BM_DRAM_ADDRESS_HI_MIN) ||
-		(((struct mv_word40 *)qece_base_address)->hi > BM_DRAM_ADDRESS_HI_MAX))
+		(((struct mv_word40 *)qece_base_address)->hi > BM_DRAM_ADDRESS_HI_MAX)) {
+		pr_err("problem with qece base address\n");
 		return rc;
+	}
 /*	if ((qece_base_address_lo <  BM_DRAM_ADDRESS_LO_MIN) || (qece_base_address_lo >  BM_DRAM_ADDRESS_LO_MAX)) */
 	if ((((struct mv_word40 *)qece_base_address)->lo < BM_DRAM_ADDRESS_LO_MIN) ||
-		(((struct mv_word40 *)qece_base_address)->lo > BM_DRAM_ADDRESS_LO_MAX))
+		(((struct mv_word40 *)qece_base_address)->lo > BM_DRAM_ADDRESS_LO_MAX)) {
+		pr_err("problem with qece base address\n");
 		return rc;
+	}
 /*	if ((pl_base_address_hi   <  BM_DRAM_ADDRESS_HI_MIN) || (pl_base_address_hi   >  BM_DRAM_ADDRESS_HI_MAX)) */
 	if ((((struct mv_word40 *)pl_base_address)->hi < BM_DRAM_ADDRESS_HI_MIN) ||
-		(((struct mv_word40 *)pl_base_address)->hi > BM_DRAM_ADDRESS_HI_MAX))
+		(((struct mv_word40 *)pl_base_address)->hi > BM_DRAM_ADDRESS_HI_MAX)) {
+		pr_err("problem with pl base address\n");
 		return rc;
+	}
 /*	if ((pl_base_address_lo   <  BM_DRAM_ADDRESS_LO_MIN) || (pl_base_address_lo   >  BM_DRAM_ADDRESS_LO_MAX)) */
 	if ((((struct mv_word40 *)pl_base_address)->lo < BM_DRAM_ADDRESS_LO_MIN) ||
-		(((struct mv_word40 *)pl_base_address)->lo > BM_DRAM_ADDRESS_LO_MAX))
+		(((struct mv_word40 *)pl_base_address)->lo > BM_DRAM_ADDRESS_LO_MAX)) {
+		pr_err("problem with pl base address\n");
 		return rc;
-	if ((ae_thr               <           BM_AE_THR_MIN) || (ae_thr               >           BM_AE_THR_MAX))
+	}
+	if ((ae_thr       <       BM_AE_THR_MIN) || (ae_thr       >       BM_AE_THR_MAX)) {
+		pr_err("almost empty threhold should be in the rage %d ... %d\n",
+			BM_AE_THR_MIN, BM_AE_THR_MAX);
 		return rc;
-	if ((af_thr               <           BM_AF_THR_MIN) || (af_thr               >           BM_AF_THR_MAX))
+	}
+	if ((af_thr       <       BM_AF_THR_MIN) || (af_thr       >       BM_AF_THR_MAX)) {
+		pr_err("almost full threhold should be in the rage %d ... %d\n",
+			BM_AF_THR_MIN, BM_AF_THR_MAX);
 		return rc;
-	if ((cache_vmid           <             BM_VMID_MIN) || (cache_vmid           >             BM_VMID_MAX))
+	}
+	if ((cache_vmid   <         BM_VMID_MIN) || (cache_vmid   >         BM_VMID_MAX)) {
+		pr_err("cache vmid should be in the rage %d ... %d\n",
+			BM_VMID_MIN, BM_VMID_MAX);
 		return rc;
-	if ((cache_attr           <       BM_CACHE_ATTR_MIN) || (cache_attr           >       BM_CACHE_ATTR_MAX))
+	}
+	if ((cache_attr   <   BM_CACHE_ATTR_MIN) || (cache_attr   >   BM_CACHE_ATTR_MAX)) {
+		pr_err("cache attr should be in the rage %d ... %d\n",
+			BM_CACHE_ATTR_MIN, BM_CACHE_ATTR_MAX);
 		return rc;
-	if ((cache_so_thr         <     BM_CACHE_SO_THR_MIN) || (cache_so_thr         >     BM_CACHE_SO_THR_MAX))
+	}
+	if ((cache_so_thr < BM_CACHE_SO_THR_MIN) || (cache_so_thr > BM_CACHE_SO_THR_MAX)) {
+		pr_err("cache swap out threshold should be in the rage %d ... %d\n",
+			BM_CACHE_SO_THR_MIN, BM_CACHE_SO_THR_MAX);
 		return rc;
-	if ((cache_si_thr         <     BM_CACHE_SI_THR_MIN) || (cache_si_thr         >     BM_CACHE_SI_THR_MAX))
+	}
+	if ((cache_si_thr < BM_CACHE_SI_THR_MIN) || (cache_si_thr > BM_CACHE_SI_THR_MAX)) {
+		pr_err("cache swap in threshold should be in the rage %d ... %d\n",
+			BM_CACHE_SI_THR_MIN, BM_CACHE_SI_THR_MAX);
 		return rc;
+	}
 	if ((cache_num_of_buffers < BM_CACHE_NUM_OF_BUFFERS_QM_MIN)	||
-		(cache_num_of_buffers > BM_CACHE_NUM_OF_BUFFERS_QM_MAX))
+		(cache_num_of_buffers > BM_CACHE_NUM_OF_BUFFERS_QM_MAX)) {
+		pr_err("cache number of buffers should be in the rage %d ... %d\n",
+			BM_CACHE_NUM_OF_BUFFERS_QM_MIN, BM_CACHE_NUM_OF_BUFFERS_QM_MAX);
 		return rc;
+	}
 
 	rc = bm_enable_status_get(&bm_req_rcv_en);
 	if (rc != OK)
@@ -441,10 +495,6 @@ int bm_qm_gpm_pools_quick_init(u32 num_of_buffers, u32 *qece_base_address,
 	if (rc != OK)
 		return rc;
 	rc = bm_pool_enable(pool, quick_init);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -469,40 +519,49 @@ int bm_qm_dram_pools_quick_init(u32 num_of_buffers, u32 *qece_base_address,
 		return rc;
 	if ((cache_num_of_buffers % granularity_of_pe_in_cache) != 0)
 		return rc;
-	if (ae_thr       >= af_thr)
+	if (af_thr       < ae_thr)
 		return rc;
-	if (cache_so_thr >= cache_si_thr + 16)
+	if (cache_so_thr < cache_si_thr + 16)
 		return rc;
 
 	if ((num_of_buffers < BM_NUM_OF_BUFFERS_QM_MIN) || (num_of_buffers > BM_NUM_OF_BUFFERS_QM_DRAM_MAX))
 		return rc;
 /*	if ((qece_base_address_hi <  BM_DRAM_ADDRESS_HI_MIN) || (qece_base_address_hi >  BM_DRAM_ADDRESS_HI_MAX)) */
 	if ((((struct mv_word40 *)qece_base_address)->hi < BM_DRAM_ADDRESS_HI_MIN) ||
-		(((struct mv_word40 *)qece_base_address)->hi > BM_DRAM_ADDRESS_HI_MAX))
+		(((struct mv_word40 *)qece_base_address)->hi > BM_DRAM_ADDRESS_HI_MAX)) {
+		pr_err("problem with qece base address\n");
 		return rc;
+	}
 /*	if ((qece_base_address_lo <  BM_DRAM_ADDRESS_LO_MIN) || (qece_base_address_lo >  BM_DRAM_ADDRESS_LO_MAX)) */
 	if ((((struct mv_word40 *)qece_base_address)->lo < BM_DRAM_ADDRESS_LO_MIN) ||
-		(((struct mv_word40 *)qece_base_address)->lo > BM_DRAM_ADDRESS_LO_MAX))
+		(((struct mv_word40 *)qece_base_address)->lo > BM_DRAM_ADDRESS_LO_MAX)) {
+		pr_err("problem with qece base address\n");
 		return rc;
+	}
 /*	if ((pl_base_address_hi   <  BM_DRAM_ADDRESS_HI_MIN) || (pl_base_address_hi   >  BM_DRAM_ADDRESS_HI_MAX)) */
 	if ((((struct mv_word40 *)pl_base_address)->hi < BM_DRAM_ADDRESS_HI_MIN) ||
-		(((struct mv_word40 *)pl_base_address)->hi > BM_DRAM_ADDRESS_HI_MAX))
+		(((struct mv_word40 *)pl_base_address)->hi > BM_DRAM_ADDRESS_HI_MAX)) {
+		pr_err("problem with pl base address\n");
 		return rc;
+	}
 /*	if ((pl_base_address_lo   <  BM_DRAM_ADDRESS_LO_MIN) || (pl_base_address_lo   >  BM_DRAM_ADDRESS_LO_MAX)) */
 	if ((((struct mv_word40 *)pl_base_address)->hi < BM_DRAM_ADDRESS_LO_MIN) ||
-		(((struct mv_word40 *)pl_base_address)->hi > BM_DRAM_ADDRESS_LO_MAX))
+		(((struct mv_word40 *)pl_base_address)->hi > BM_DRAM_ADDRESS_LO_MAX)) {
+		pr_err("problem with pl base address\n");
 		return rc;
-	if ((ae_thr               <           BM_AE_THR_MIN) || (ae_thr               >           BM_AE_THR_MAX))
+	}
+
+	if ((ae_thr       <       BM_AE_THR_MIN) || (ae_thr       >       BM_AE_THR_MAX))
 		return rc;
-	if ((af_thr               <           BM_AF_THR_MIN) || (af_thr               >           BM_AF_THR_MAX))
+	if ((af_thr       <       BM_AF_THR_MIN) || (af_thr       >       BM_AF_THR_MAX))
 		return rc;
-	if ((cache_vmid           <             BM_VMID_MIN) || (cache_vmid           >             BM_VMID_MAX))
+	if ((cache_vmid   <         BM_VMID_MIN) || (cache_vmid   >         BM_VMID_MAX))
 		return rc;
-	if ((cache_attr           <       BM_CACHE_ATTR_MIN) || (cache_attr           >       BM_CACHE_ATTR_MAX))
+	if ((cache_attr   <   BM_CACHE_ATTR_MIN) || (cache_attr   >   BM_CACHE_ATTR_MAX))
 		return rc;
-	if ((cache_so_thr         <     BM_CACHE_SO_THR_MIN) || (cache_so_thr         >     BM_CACHE_SO_THR_MAX))
+	if ((cache_so_thr < BM_CACHE_SO_THR_MIN) || (cache_so_thr > BM_CACHE_SO_THR_MAX))
 		return rc;
-	if ((cache_si_thr         <     BM_CACHE_SI_THR_MIN) || (cache_si_thr         >     BM_CACHE_SI_THR_MAX))
+	if ((cache_si_thr < BM_CACHE_SI_THR_MIN) || (cache_si_thr > BM_CACHE_SI_THR_MAX))
 		return rc;
 	if ((cache_num_of_buffers < BM_CACHE_NUM_OF_BUFFERS_QM_MIN)	||
 		(cache_num_of_buffers > BM_CACHE_NUM_OF_BUFFERS_QM_MAX))
@@ -581,10 +640,6 @@ int bm_qm_dram_pools_quick_init(u32 num_of_buffers, u32 *qece_base_address,
 	((struct mv_word40 *)qece_base_address)->lo = base_address.lo;
 
 	rc = qm_pfe_base_address_pool_set(pl_base_address, qece_base_address);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -646,10 +701,6 @@ int bm_gp_pool_def_basic_init(u32 pool, u32 num_of_buffers, u32 *base_address, u
 	rc = bm_gp_pool_basic_init(pool, num_of_buffers, base_address, pe_size, pool_pair,
 					ae_thr, af_thr, cache_vmid, cache_attr, cache_so_thr, cache_si_thr,
 					cache_num_of_buffers);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -685,9 +736,9 @@ int bm_gp_pool_basic_init(u32 pool, u32 num_of_buffers, u32 *base_address,
 		return rc;
 	if ((cache_num_of_buffers % granularity_of_pe_in_cache) != 0)
 		return rc;
-	if (ae_thr       >= af_thr)
+	if (af_thr       < ae_thr)
 		return rc;
-	if (cache_so_thr >= cache_si_thr + 16)
+	if (cache_so_thr < cache_si_thr + 16)
 		return rc;
 
 
@@ -699,12 +750,16 @@ int bm_gp_pool_basic_init(u32 pool, u32 num_of_buffers, u32 *base_address,
 		return rc;
 /*	if ((base_address_hi      <  BM_DRAM_ADDRESS_HI_MIN) || (base_address_hi      >  BM_DRAM_ADDRESS_HI_MAX)) */
 	if ((((struct mv_word40 *)base_address)->hi < BM_DRAM_ADDRESS_HI_MIN) ||
-		(((struct mv_word40 *)base_address)->hi > BM_DRAM_ADDRESS_HI_MAX))
+		(((struct mv_word40 *)base_address)->hi > BM_DRAM_ADDRESS_HI_MAX)) {
+		pr_err("problem with qece base address\n");
 		return rc;
+	}
 /*	if ((base_address_lo      <  BM_DRAM_ADDRESS_LO_MIN) || (base_address_lo      >  BM_DRAM_ADDRESS_LO_MAX)) */
 	if ((((struct mv_word40 *)base_address)->lo < BM_DRAM_ADDRESS_LO_MIN) ||
-		(((struct mv_word40 *)base_address)->lo > BM_DRAM_ADDRESS_LO_MAX))
+		(((struct mv_word40 *)base_address)->lo > BM_DRAM_ADDRESS_LO_MAX)) {
+		pr_err("problem with qece base address\n");
 		return rc;
+	}
 	if ((pe_size              <          BM_PE_SIZE_MIN) || (pe_size              >          BM_PE_SIZE_MAX))
 		return rc;
 	if ((pool_pair            <        BM_POOL_PAIR_MIN) || (pool_pair            >        BM_POOL_PAIR_MAX))
@@ -741,17 +796,13 @@ int bm_gp_pool_basic_init(u32 pool, u32 num_of_buffers, u32 *base_address,
 	if (rc != OK)
 		return rc;
 	rc = bm_pool_enable(pool, quick_init);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
 int bm_enable(void)
 {
 	u32 reg_base_address, reg_size, reg_offset;
-	int rc = -BM_INPUT_NOT_IN_RANGE;
+	int rc = !OK;
 	struct bm_common_general_conf          reg_common_general_conf;
 	u32 bm_req_rcv_en;
 
@@ -773,17 +824,13 @@ int bm_enable(void)
 	reg_common_general_conf.drm_si_decide_extra_fill = 0;
 	reg_common_general_conf.bm_req_rcv_en = 1;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_common_general_conf);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
 int bm_disable(void)
 {
 	u32 reg_base_address, reg_size, reg_offset;
-	int rc = -BM_INPUT_NOT_IN_RANGE;
+	int rc = !OK;
 	struct bm_common_general_conf          reg_common_general_conf;
 	u32 pool;
 
@@ -806,6 +853,7 @@ int bm_disable(void)
 	rc = bm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_common_general_conf);
 	if (rc != OK)
 		return rc;
+	reg_common_general_conf.drm_si_decide_extra_fill = 0;
 	reg_common_general_conf.bm_req_rcv_en = 1;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_common_general_conf);
 	if (rc != OK)
@@ -873,12 +921,9 @@ int bm_vmid_set(u32 bm_vmid)
 	rc =  bm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_common_general_conf);
 	if (rc != OK)
 		return rc;
+	reg_common_general_conf.drm_si_decide_extra_fill = 0;
 	reg_common_general_conf.dm_vmid = bm_vmid;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_common_general_conf);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -913,10 +958,6 @@ int bm_gp_pool_def_quick_init(u32 pool, u32 num_of_buffers, u32 fill_level,
 	rc = bm_gp_pool_quick_init(pool, num_of_buffers, fill_level, base_address,
 					pe_size, pool_pair, ae_thr, af_thr,
 					cache_vmid, cache_attr, cache_so_thr, cache_si_thr, cache_num_of_buffers);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -955,9 +996,9 @@ int bm_gp_pool_quick_init(u32 pool, u32 num_of_buffers, u32 fill_level, u32 *bas
 	if ((cache_num_of_buffers % granularity_of_pe_in_cache) != 0)
 		return rc;
 
-	if (ae_thr       >= af_thr)
+	if (af_thr       < ae_thr)
 		return rc;
-	if (cache_so_thr >= cache_si_thr + 16)
+	if (cache_so_thr < cache_si_thr + 16)
 		return rc;
 
 	if ((pool                 <          BM_POOL_GP_MIN) || (pool                 >          BM_POOL_GP_MAX))
@@ -974,21 +1015,21 @@ int bm_gp_pool_quick_init(u32 pool, u32 num_of_buffers, u32 fill_level, u32 *bas
 	if ((((struct mv_word40 *)base_address)->lo < BM_DRAM_ADDRESS_LO_MIN) ||
 		(((struct mv_word40 *)base_address)->lo > BM_DRAM_ADDRESS_LO_MAX))
 		return rc;
-	if ((pe_size              <          BM_PE_SIZE_MIN) || (pe_size              >          BM_PE_SIZE_MAX))
+	if ((pe_size      <      BM_PE_SIZE_MIN) || (pe_size      >      BM_PE_SIZE_MAX))
 		return rc;
-	if ((pool_pair            <        BM_POOL_PAIR_MIN) || (pool_pair            >        BM_POOL_PAIR_MAX))
+	if ((pool_pair    <    BM_POOL_PAIR_MIN) || (pool_pair    >    BM_POOL_PAIR_MAX))
 		return rc;
-	if ((ae_thr               <           BM_AE_THR_MIN) || (ae_thr               >           BM_AE_THR_MAX))
+	if ((ae_thr       <       BM_AE_THR_MIN) || (ae_thr       >       BM_AE_THR_MAX))
 		return rc;
-	if ((af_thr               <           BM_AF_THR_MIN) || (af_thr               >           BM_AF_THR_MAX))
+	if ((af_thr       <       BM_AF_THR_MIN) || (af_thr       >       BM_AF_THR_MAX))
 		return rc;
-	if ((cache_vmid           <             BM_VMID_MIN) || (cache_vmid           >             BM_VMID_MAX))
+	if ((cache_vmid   <         BM_VMID_MIN) || (cache_vmid   >         BM_VMID_MAX))
 		return rc;
-	if ((cache_attr           <       BM_CACHE_ATTR_MIN) || (cache_attr           >       BM_CACHE_ATTR_MAX))
+	if ((cache_attr   <   BM_CACHE_ATTR_MIN) || (cache_attr   >   BM_CACHE_ATTR_MAX))
 		return rc;
-	if ((cache_so_thr         <     BM_CACHE_SO_THR_MIN) || (cache_so_thr         >     BM_CACHE_SI_THR_MAX))
+	if ((cache_so_thr < BM_CACHE_SO_THR_MIN) || (cache_so_thr > BM_CACHE_SI_THR_MAX))
 		return rc;
-	if ((cache_si_thr         <     BM_CACHE_SI_THR_MIN) || (cache_si_thr         >     BM_CACHE_SI_THR_MAX))
+	if ((cache_si_thr < BM_CACHE_SI_THR_MIN) || (cache_si_thr > BM_CACHE_SI_THR_MAX))
 		return rc;
 	if ((cache_num_of_buffers < BM_CACHE_NUM_OF_BUFFERS_GP_MIN)	||
 		(cache_num_of_buffers > BM_CACHE_NUM_OF_BUFFERS_GP_MAX))
@@ -1026,7 +1067,7 @@ int bm_gp_pool_quick_init(u32 pool, u32 num_of_buffers, u32 fill_level, u32 *bas
 int bm_global_registers_dump(void)
 {
 	u32 reg_base_address, reg_size, reg_offset;
-	int rc = -BM_INPUT_NOT_IN_RANGE;
+	int rc = !OK;
 	char reg_name[50];
 
 	struct bm_sys_nrec_common_d0_st  reg_sys_nrec_common_d0_st;
@@ -1167,11 +1208,11 @@ int bm_global_registers_dump(void)
 	reg_size   =   bm_reg_size.dram_domain_conf;
 	reg_offset = bm_reg_offset.dram_domain_conf * 0;
 
+	pr_info("\n");
 	rc =  bm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_dram_domain_conf);
 	if (rc != OK)
 		return rc;
 
-	pr_info("\n");
 	rc =  bm_register_name_get(reg_base_address, reg_offset, reg_name);
 	if (rc != OK)
 		return rc;
@@ -1188,11 +1229,11 @@ int bm_global_registers_dump(void)
 	reg_size   =   bm_reg_size.dram_cache_conf;
 	reg_offset = bm_reg_offset.dram_cache_conf * 0;
 
+	pr_info("\n");
 	rc =  bm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_dram_cache_conf);
 	if (rc != OK)
 		return rc;
 
-	pr_info("\n");
 	rc =  bm_register_name_get(reg_base_address, reg_offset, reg_name);
 	if (rc != OK)
 		return rc;
@@ -1209,11 +1250,11 @@ int bm_global_registers_dump(void)
 	reg_size   =   bm_reg_size.dram_qos_conf;
 	reg_offset = bm_reg_offset.dram_qos_conf * 0;
 
+	pr_info("\n");
 	rc =  bm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_dram_qos_conf);
 	if (rc != OK)
 		return rc;
 
-	pr_info("\n");
 	rc =  bm_register_name_get(reg_base_address, reg_offset, reg_name);
 	if (rc != OK)
 		return rc;
@@ -1229,11 +1270,11 @@ int bm_global_registers_dump(void)
 	reg_size   =   bm_reg_size.dm_axi_fifos_st;
 	reg_offset = bm_reg_offset.dm_axi_fifos_st * 0;
 
+	pr_info("\n");
 	rc =  bm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_dm_axi_fifos_st);
 	if (rc != OK)
 		return rc;
 
-	pr_info("\n");
 	rc =  bm_register_name_get(reg_base_address, reg_offset, reg_name);
 	if (rc != OK)
 		return rc;
@@ -1253,11 +1294,11 @@ int bm_global_registers_dump(void)
 	reg_size   =   bm_reg_size.drm_pend_fifo_st;
 	reg_offset = bm_reg_offset.drm_pend_fifo_st * 0;
 
+	pr_info("\n");
 	rc =  bm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_drm_pend_fifo_st);
 	if (rc != OK)
 		return rc;
 
-	pr_info("\n");
 	rc =  bm_register_name_get(reg_base_address, reg_offset, reg_name);
 	if (rc != OK)
 		return rc;
@@ -1271,11 +1312,11 @@ int bm_global_registers_dump(void)
 	reg_size   =   bm_reg_size.dm_axi_wr_pend_fifo_st;
 	reg_offset = bm_reg_offset.dm_axi_wr_pend_fifo_st * 0;
 
+	pr_info("\n");
 	rc =  bm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_dm_axi_wr_pend_fifo_st);
 	if (rc != OK)
 		return rc;
 
-	pr_info("\n");
 	rc =  bm_register_name_get(reg_base_address, reg_offset, reg_name);
 	if (rc != OK)
 		return rc;
@@ -1289,11 +1330,11 @@ int bm_global_registers_dump(void)
 	reg_size   =   bm_reg_size.bm_idle_st;
 	reg_offset = bm_reg_offset.bm_idle_st * 0;
 
+	pr_info("\n");
 	rc =  bm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_bm_idle_st);
 	if (rc != OK)
 		return rc;
 
-	pr_info("\n");
 	rc =  bm_register_name_get(reg_base_address, reg_offset, reg_name);
 	if (rc != OK)
 		return rc;
@@ -1842,7 +1883,7 @@ int bm_pool_status_get(u32 pool, u32 *pool_nempty, u32 *dpool_ae, u32 *dpool_af)
 int bm_idle_debug(void)
 {
 	u32 reg_base_address, reg_size, reg_offset;
-	int rc = -BM_INPUT_NOT_IN_RANGE;
+	int rc = !OK;
 	u32 bid;
 	struct bm_b_bank_req_fifos_st          reg_b_bank_req_fifos_st;
 	struct bm_b0_past_alc_fifos_st         reg_b0_past_alc_fifos_st;
@@ -2009,7 +2050,7 @@ int bm_idle_debug(void)
 	return rc;
 }
 
-/*Errors and interrupts handling Â– TBD*/
+/*Errors and interrupts handling – TBD*/
 /*
 1.	bm_inter_read(u32 group, u32 *dataPtr)
 2.	bm_inter_clean(u32 group)
@@ -2033,7 +2074,7 @@ e.	common_general_conf: field drm_si_decide_extra_fill. According to Koby this i
 int bm_error_dump(void)
 {
 	u32 reg_base_address, reg_size, reg_offset;
-	int rc = -BM_INPUT_NOT_IN_RANGE;
+	int rc = !OK;
 	u32 bid, error_sum_bit;
 	struct bm_b_sys_rec_bank_intr_cause     reg_b_sys_rec_bank_intr_cause;
 	struct bm_sw_debug_rec_intr_cause       reg_sw_debug_rec_intr_cause;
@@ -2498,7 +2539,7 @@ int bm_pool_dram_set(u32 pool, u32 num_of_buffers, u32 pe_size, u32 *base_addres
 	if ((((struct mv_word40 *)base_address)->lo % GRANULARITY_OF_64_BYTES) != 0)
 		return rc;
 
-	if (ae_thr       >= af_thr)
+	if (af_thr       < ae_thr)
 		return rc;
 
 	if ((pool            <            BM_POOL_MIN) || (pool            >            BM_POOL_MAX))
@@ -2558,14 +2599,10 @@ int bm_pool_dram_set(u32 pool, u32 num_of_buffers, u32 pe_size, u32 *base_addres
 	} else
 		return rc;
 
-	tab_dpr_d_mng_ball_stat.dram_ae_thr	=    ae_thr / UNIT_OF_64_BYTES;
-	tab_dpr_d_mng_ball_stat.dram_af_thr	=    af_thr / UNIT_OF_64_BYTES;
+	tab_dpr_d_mng_ball_stat.dram_ae_thr	= dram_ae_thr / UNIT_OF_64_BYTES;
+	tab_dpr_d_mng_ball_stat.dram_af_thr	= dram_af_thr / UNIT_OF_64_BYTES;
 	tab_dpr_d_mng_ball_stat.dram_size   = dram_size / UNIT_OF_64_BYTES;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&tab_dpr_d_mng_ball_stat);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -2633,10 +2670,6 @@ int bm_pool_fill_level_set(u32 pool, u32 num_of_buffers, u32 pe_size, u32 quick_
 		dram_fill	= BM_GP_PE_UNITS_TO_BYTES(num_of_buffers, pe_size);
 	tab_tpr_drw_mng_ball_dyn.dram_fill	= dram_fill/UNIT_OF__8_BYTES;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&tab_tpr_drw_mng_ball_dyn);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -2718,10 +2751,6 @@ int bm_gp_pool_pe_size_set(u32 pool, u32 pe_size)
 
 	reg_bgp_pool_conf.pe_size	= pe_size;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_bgp_pool_conf);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -2751,10 +2780,6 @@ int bm_gp_pool_pair_set(u32 pool, u32 pool_pair)
 
 	reg_bgp_pool_n_conf.pool_in_pairs	= pool_pair;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_bgp_pool_n_conf);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
@@ -2779,7 +2804,7 @@ int bm_pool_cache_set(u32 pool, u32 cache_vmid, u32 cache_attr, u32 cache_so_thr
 
 	if ((cache_num_of_buffers % granularity_of_pe_in_cache) != 0)
 		return rc;
-	if (cache_so_thr >= cache_si_thr + 16)
+	if (cache_so_thr < cache_si_thr + 16)
 		return rc;
 
 	if ((pool                 <          BM_POOL_MIN) || (pool                 >          BM_POOL_MAX))
@@ -2863,12 +2888,11 @@ int bm_pool_cache_set(u32 pool, u32 cache_vmid, u32 cache_attr, u32 cache_so_thr
 	if (rc != OK)
 		return rc;
 	cache_start  = cache_end_max[bid] + 1;
-	cache_end    = cache_start + (cache_num_of_buffers / granularity_of_pe_in_cache - 1);
-	cache_end    = cache_start + (cache_num_of_buffers / granularity_of_pe_in_cache - 1);
+	cache_end    = cache_start + (cache_num_of_buffers / granularity_of_pe_in_cache) - 1;
 
-	if ((cache_start <     BM_START_MIN) || (cache_start  >    BM_START_MAX))
+	if ((cache_start < BM_CACHE_START_MIN) || (cache_start  > BM_CACHE_START_MAX))
 		return rc;
-	if ((cache_end   < BM_CACHE_END_MIN) || (cache_end    >    BM_CACHE_END_MAX))
+	if ((cache_end   <   BM_CACHE_END_MIN) || (cache_end    >   BM_CACHE_END_MAX))
 		return rc;
 
 	tab_dpr_c_mng_stat.cache_start  = cache_start / UNIT_OF_64_BYTES;
@@ -2878,10 +2902,6 @@ int bm_pool_cache_set(u32 pool, u32 cache_vmid, u32 cache_attr, u32 cache_so_thr
 	tab_dpr_c_mng_stat.cache_attr   = cache_attr;
 	tab_dpr_c_mng_stat.cache_vmid   = cache_vmid;
 	rc = bm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&tab_dpr_c_mng_stat);
-	if (rc != OK)
-		return rc;
-
-	rc = OK;
 	return rc;
 }
 
diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
index fe00c13..5ed89a1 100644
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
+++ b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
@@ -174,8 +174,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define BM_PID_LOCAL_MIN			BM_PID_LOCAL_QM_MIN
 #define BM_PID_LOCAL_MAX			BM_PID_LOCAL_GP_MAX
 
-#define BM_ACACHE_MIN				0x00000020	/*  32 */
-#define BM_ACACHE_MAX				0x0000007F	/* 127 */
+/*
+ * domain read/write for any pool in the range 0 to 3 (2 bits)
+ * Cache read/write for any pool in the range 0 to 15 (4 bits)
+ * QOS read/write for any pool in the range 0 to 3 (2 bits)
+*/
+
+#define BM_ACACHE_MIN				0
+#define BM_ACACHE_MAX				0x0000000F	/* 15 */
 #define BM_ADOMAIN_MIN				         0
 #define BM_ADOMAIN_MAX				0x00000003	/*   3 */
 #define BM_AQOS_MIN					         0
@@ -225,6 +231,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define BM_CACHE_SI_THR_MAX			(cache_num_of_buffers - 0x00000010)	/* cache_num_of_buffers - 16 */
 #define BM_CACHE_SO_THR_MIN			0x00000018	/*  24 */
 #define BM_CACHE_SO_THR_MAX			(cache_num_of_buffers - 0x00000008)	/* cache_num_of_buffers -  8 */
+#define BM_CACHE_START_MIN			         0
+#define BM_CACHE_START_MAX			0xFFFFFFFF
 #define BM_CACHE_END_MIN			0x00000020	/*  32 */
 #define BM_CACHE_END_MAX			0x0000007F	/* 127 */
 
@@ -755,5 +763,14 @@ int bm_per_pool_advanced_debug(u32 pool, u32 line);
  *		0 - success
 int bm_debug(void);
  */
+/*
+ BM sysFS function
+*/
+
+int mv_pp3_bm_sysfs_init(struct kobject *neta_kobj);
+
+int mv_pp3_bm_sysfs_exit(struct kobject *emac_kobj);
+
 
 #endif /* MV_BM_H */
+
diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_qm.h b/drivers/net/ethernet/marvell/pp3/bm/mv_qm.h
deleted file mode 100644
index 06cf72e..0000000
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_qm.h
+++ /dev/null
@@ -1,879 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS;OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef	__MV_QM_H__
-#define	__MV_QM_H__
-
-#include "common/mv_sw_if.h"
-#include "common/mv_hw_if.h"
-
-/* Error Codes */
-#define QM_WRONG_MEMORY_TYPE           -EINVAL
-#define QM_ALIAS_ERROR                 -EINVAL
-#define QM_INPUT_NOT_IN_RANGE          -EINVAL
-
-/* Input definitions*/
-#define GPM_MEMORY_TYPE				 0
-#define DRAM_MEMORY_TYPE			 1
-#define GRANULARITY_OF_16_BYTES		16
-
-#define QM_QUEUE_PROFILE_INVALID			0x00000000	/*    0 */
-#define QM_QUEUE_PROFILE_0					0x00000001	/*    1 */
-#define QM_QUEUE_PROFILE_1					0x00000002	/*    2 */
-#define QM_QUEUE_PROFILE_2					0x00000003	/*    3 */
-#define QM_QUEUE_PROFILE_3					0x00000004	/*    4 */
-#define QM_QUEUE_PROFILE_4					0x00000005	/*    5 */
-#define QM_QUEUE_PROFILE_5					0x00000006	/*    6 */
-#define QM_QUEUE_PROFILE_6					0x00000007	/*    7 */
-
-
-/* Default values */
-#define QM_THR_HI_DEF			0x0000000C	/*  12 */
-#define QM_THR_LO_DEF			0x00000018	/*  24 */
-#define QM_GPM_QE_THR_HI_DEF	QM_THR_HI_DEF
-#define QM_GPM_QE_THR_LO_DEF	QM_THR_LO_DEF
-#define QM_GPM_PL_THR_HI_DEF	QM_THR_HI_DEF
-#define QM_GPM_PL_THR_LO_DEF	QM_THR_LO_DEF
-#define QM_DRAM_QE_THR_HI_DEF	QM_THR_HI_DEF
-#define QM_DRAM_QE_THR_LO_DEF	QM_THR_LO_DEF
-#define QM_DRAM_PL_THR_HI_DEF	QM_THR_HI_DEF
-#define QM_DRAM_PL_THR_LO_DEF	QM_THR_LO_DEF
-
-#define QM_POOL0_SID_NUM_DEF	QM_POOL0_SID_NUM_MAX
-#define QM_POOL1_SID_NUM_DEF	QM_POOL1_SID_NUM_MIN
-
-#define QM_CLASS_ARR_CMAC_EMAC_DEF	input_port	/*    0 */
-#define QM_CLASS_ARR_HMAC_DEF		0x00000008	/*    8 */
-#define QM_CLASS_ARR_PPC_DEF		0x00000009	/*    9 */
-#define QM_PORT_ARR_DEF				         0	/*    0 */
-#define QM_ARRAYS_SIZE_DEF			0x0000005A	/*   90 */
-
-#define QM_PORT_DEPTH_ARR_PPC0_DEF		    (2 * QM_SIZE_OF_PORT_DEPTH_ARR_PPC_IN_BYTES)	/* 2*144B */
-#define QM_PORT_DEPTH_ARR_PPC1_DEF		    (1 * QM_SIZE_OF_PORT_DEPTH_ARR_PPC_IN_BYTES)	/* 1*144B */
-#define QM_PORT_DEPTH_ARR_EMAC_DEF		  (160 * QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES)	/*  2560B */
-#define QM_PORT_DEPTH_ARR_CMAC0_DEF		  (160 * QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES)	/*  2560B */
-#define QM_PORT_DEPTH_ARR_CMAC1_DEF		   (32 * QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES)	/*   512B */
-#define QM_PORT_DEPTH_ARR_HMAC_DEF		   (32 * QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES)	/*   512B */
-
-#define QM_PORT_CREDIT_THR_ARR_EMAC_DEF		  (152 * QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES)	/*  2432B */
-#define QM_PORT_CREDIT_THR_ARR_CMAC0_DEF	  (152 * QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES)	/*  2432B */
-#define QM_PORT_CREDIT_THR_ARR_CMAC1_DEF	   (24 * QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES)	/*   384B */
-#define QM_PORT_CREDIT_THR_ARR_HMAC_DEF		   (24 * QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES)	/*   384B */
-
-#define QM_PORT_PPC_ARR_PPC0_DEF	    1	/* packets are processed by data        PPC */
-#define QM_PORT_PPC_ARR_PPC1_DEF	    2	/* packets are processed by maintenance PPC */
-
-#define QM_SWF_AWQOS_DEF			0x00000001	/*    1 */
-#define QM_RDMA_AWQOS_DEF			0x00000001	/*    1 */
-#define QM_HWF_QE_CE_AWQOS_DEF		0x00000001	/*    1 */
-#define QM_HWF_SFH_PL_AWQOS_DEF		0x00000001	/*    1 */
-
-#define QM_SWF_AWCACHE_DEF			0x0000000B	/*   11 */
-#define QM_RDMA_AWCACHE_DEF			0x0000000B	/*   11 */
-#define QM_HWF_QE_CE_AWCACHE_DEF	0x00000003	/*    3 */
-#define QM_HWF_SFH_PL_AWCACHE_DEF	0x00000003	/*    3 */
-
-#define QM_SWF_AWDOMAIN_DEF			0x00000002	/*    2 */
-#define QM_RDMA_AWDOMAIN_DEF		0x00000002	/*    2 */
-#define QM_HWF_QE_CE_AWDOMAIN_DEF	         0	/*    0 */
-#define QM_HWF_SFH_PL_AWDOMAIN_DEF	         0	/*    0 */
-
-#define QM_SWF_ARQOS_DEF			0x00000001	/*    1 */
-#define QM_RDMA_ARQOS_DEF			0x00000001	/*    1 */
-#define QM_HWF_QE_CE_ARQOS_DEF		0x00000001	/*    1 */
-#define QM_HWF_SFH_PL_ARQOS_DEF		0x00000001	/*    1 */
-
-#define QM_SWF_ARCACHE_DEF			0x0000000B	/*   11 */
-#define QM_RDMA_ARCACHE_DEF			0x0000000B	/*   11 */
-#define QM_HWF_QE_CE_ARCACHE_DEF	0x00000003	/*    3 */
-#define QM_HWF_SFH_PL_ARCACHE_DEF	0x00000003	/*    3 */
-
-#define QM_SWF_ARDOMAIN_DEF			0x00000002	/*    2 */
-#define QM_RDMA_ARDOMAIN_DEF		0x00000002	/*    2 */
-#define QM_HWF_QE_CE_ARDOMAIN_DEF	         0	/*    0 */
-#define QM_HWF_SFH_PL_ARDOMAIN_DEF	         0	/*    0 */
-
-/* Range Definitions */
-#define QM_QUEUE_MIN			         0	/*    0 */
-#define QM_QUEUE_MAX			0x00000200	/*  512 */
-#define QM_PORT_MIN				         0	/*    0 */
-#define QM_PORT_MAX				0x0000000F	/*   15 */
-#define QM_PORT_PPC_MIN			QM_PORT_MIN
-#define QM_PORT_PPC_MAX			0x00000002	/*    2 */
-#define QM_PORT_MAC_MIN			0x00000003	/*    3 */
-#define QM_PORT_MAC_MAX			0x0000000A	/*   10 */
-#define QM_QUEUE_PROFILE_MIN	         1	/*    1 */
-#define QM_QUEUE_PROFILE_MAX	0x00000007	/*    7 */
-
-#define QM_PPC_MIN				         0
-#define QM_PPC_MAX				0x7FFFFFFF
-#define QM_BASE_MIN				         0
-#define QM_BASE_MAX				0x7FFFFFFF
-#define QM_SIZE_MIN				         0
-#define QM_SIZE_MAX				0x7FFFFFFF
-
-#define QM_VMID_MIN				         0	/*   0 */
-#define QM_VMID_MAX				0x0000003F	/*  63 */
-#define QM_THR_MIN				         0	/*   0 */
-#define QM_THR_MAX				0x00000020	/*  32 */
-#define QM_GPM_QE_THR_HI_MIN	QM_THR_MIN
-#define QM_GPM_QE_THR_HI_MAX	QM_THR_MAX
-#define QM_GPM_QE_THR_LO_MIN	QM_THR_MIN
-#define QM_GPM_QE_THR_LO_MAX	QM_THR_MAX
-#define QM_GPM_PL_THR_HI_MIN	QM_THR_MIN
-#define QM_GPM_PL_THR_HI_MAX	QM_THR_MAX
-#define QM_GPM_PL_THR_LO_MIN	QM_THR_MIN
-#define QM_GPM_PL_THR_LO_MAX	QM_THR_MAX
-#define QM_DRAM_QE_THR_HI_MIN	QM_THR_MIN
-#define QM_DRAM_QE_THR_HI_MAX	QM_THR_MAX
-#define QM_DRAM_QE_THR_LO_MIN	QM_THR_MIN
-#define QM_DRAM_QE_THR_LO_MAX	QM_THR_MAX
-#define QM_DRAM_PL_THR_HI_MIN	QM_THR_MIN
-#define QM_DRAM_PL_THR_HI_MAX	QM_THR_MAX
-#define QM_DRAM_PL_THR_LO_MIN	QM_THR_MIN
-#define QM_DRAM_PL_THR_LO_MAX	QM_THR_MAX
-#define QM_POOL_SID_NUM_MIN		         0
-#define QM_POOL_SID_NUM_MAX		0x00001000	/* 4096 */
-
-#define QM_POOL0_SID_NUM_MIN	QM_POOL_SID_NUM_MIN
-#define QM_POOL0_SID_NUM_MAX	QM_POOL_SID_NUM_MAX
-#define QM_POOL1_SID_NUM_MIN	QM_POOL_SID_NUM_MIN
-#define QM_POOL1_SID_NUM_MAX	QM_POOL_SID_NUM_MAX
-
-#define QM_CLASS_ARR_MIN		         0	/*    0 */
-#define QM_CLASS_ARR_MAX		0x00000009	/*    9 */
-#define QM_PORT_ARR_MIN			         0	/*    0 */
-#define QM_PORT_ARR_MAX			0x00000001	/*    1 */
-#define QM_ARRAYS_SIZE_MIN		0x0000005A	/*   90 */
-#define QM_ARRAYS_SIZE_MAX		0x00000120	/*  288 */
-
-#define QM_INPUT_PORT_CMAC_EMAC_MIN	         0	/*    0 */
-#define QM_INPUT_PORT_CMAC_EMAC_MAX	0x00000007	/*    7 */
-#define QM_INPUT_PORT_HMAC_MIN		0x00000008	/*    8 */
-#define QM_INPUT_PORT_HMAC_MAX		0x00000047	/*   71 */
-#define QM_INPUT_PORT_PPC_MIN		0x00000048	/*   72 */
-#define QM_INPUT_PORT_PPC_MAX		0x00000059	/*   89 */
-
-#define QM_MEMORY_TYPE_MIN		         0
-#define QM_MEMORY_TYPE_MAX		         1
-
-#define QM_SIZE_OF_PORT_DEPTH_ARR_PPC_IN_BYTES		0x00000090	/*  144 */
-#define QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES		0x00000010	/*   16 */
-#define QM_SIZE_OF_PORT_CREDIT_THR_ARR_MAC_IN_BYTES	0x00000010	/*   16 */
-
-#define QM_PORT_DEPTH_ARR_MIN			     0	/*     0 */
-#define QM_PORT_DEPTH_ARR_SUM_MAX	0x00004000	/* 16384 */
-
-#define QM_PORT_CREDIT_THR_ARR_MIN	GRANULARITY_OF_16_BYTES	/*     16 */
-#define QM_PORT_CREDIT_THR_ARR_MAX	(data_fifo_depth_p - 8 * GRANULARITY_OF_16_BYTES)	/* 8 * 16 */
-
-#define QM_SWF_ARDOMAIN_MIN				         0	/*    0 */
-#define QM_SWF_ARDOMAIN_MAX				0x00000003	/*    3 */
-#define QM_SWF_ARCACHE_MIN				         0	/*    0 */
-#define QM_SWF_ARCACHE_MAX				0x0000000F	/*   15 */
-#define QM_SWF_ARQOS_MIN					     0	/*    0 */
-#define QM_SWF_ARQOS_MAX				0x00000003	/*    3 */
-
-#define QM_RDMA_ARDOMAIN_MIN			         0	/*    0 */
-#define QM_RDMA_ARDOMAIN_MAX			0x00000003	/*    3 */
-#define QM_RDMA_ARCACHE_MIN				         0	/*    0 */
-#define QM_RDMA_ARCACHE_MAX				0x0000000F	/*   15 */
-#define QM_RDMA_ARQOS_MIN					     0	/*    0 */
-#define QM_RDMA_ARQOS_MAX				0x00000003	/*    3 */
-
-#define QM_HWF_QE_CE_ARDOMAIN_MIN		         0	/*    0 */
-#define QM_HWF_QE_CE_ARDOMAIN_MAX		0x00000003	/*    3 */
-#define QM_HWF_QE_CE_ARCACHE_MIN		         0	/*    0 */
-#define QM_HWF_QE_CE_ARCACHE_MAX		0x0000000F	/*   15 */
-#define QM_HWF_QE_CE_ARQOS_MIN				     0	/*    0 */
-#define QM_HWF_QE_CE_ARQOS_MAX			0x00000003	/*    3 */
-
-#define QM_HWF_SFH_PL_ARQOS_MIN			         0	/*    0 */
-#define QM_HWF_SFH_PL_ARQOS_MAX			0x00000003	/*    3 */
-#define QM_HWF_SFH_PL_ARCACHE_MIN		         0	/*    0 */
-#define QM_HWF_SFH_PL_ARCACHE_MAX		0x0000000F	/*   15 */
-#define QM_HWF_SFH_PL_ARDOMAIN_MIN			     0	/*    0 */
-#define QM_HWF_SFH_PL_ARDOMAIN_MAX		0x00000003	/*    3 */
-
-#define QM_SWF_AWDOMAIN_MIN				         0	/*    0 */
-#define QM_SWF_AWDOMAIN_MAX				0x00000003	/*    3 */
-#define QM_SWF_AWCACHE_MIN				         0	/*    0 */
-#define QM_SWF_AWCACHE_MAX				0x0000000F	/*   15 */
-#define QM_SWF_AWQOS_MIN					     0	/*    0 */
-#define QM_SWF_AWQOS_MAX				0x00000003	/*    3 */
-
-#define QM_RDMA_AWDOMAIN_MIN			         0	/*    0 */
-#define QM_RDMA_AWDOMAIN_MAX			0x00000003	/*    3 */
-#define QM_RDMA_AWCACHE_MIN				         0	/*    0 */
-#define QM_RDMA_AWCACHE_MAX				0x0000000F	/*   15 */
-#define QM_RDMA_AWQOS_MIN					     0	/*    0 */
-#define QM_RDMA_AWQOS_MAX				0x00000003	/*    3 */
-
-#define QM_HWF_QE_CE_AWDOMAIN_MIN		         0	/*    0 */
-#define QM_HWF_QE_CE_AWDOMAIN_MAX		0x00000003	/*    3 */
-#define QM_HWF_QE_CE_AWCACHE_MIN		         0	/*    0 */
-#define QM_HWF_QE_CE_AWCACHE_MAX		0x0000000F	/*   15 */
-#define QM_HWF_QE_CE_AWQOS_MIN				     0	/*    0 */
-#define QM_HWF_QE_CE_AWQOS_MAX			0x00000003	/*    3 */
-
-#define QM_HWF_SFH_PL_AWQOS_MIN			         0	/*    0 */
-#define QM_HWF_SFH_PL_AWQOS_MAX			0x00000003	/*    3 */
-#define QM_HWF_SFH_PL_AWCACHE_MIN		         0	/*    0 */
-#define QM_HWF_SFH_PL_AWCACHE_MAX		0x0000000F	/*   15 */
-#define QM_HWF_SFH_PL_AWDOMAIN_MIN			     0	/*    0 */
-#define QM_HWF_SFH_PL_AWDOMAIN_MAX		0x00000003	/*    3 */
-
-#define QM_LOW_THRESHOLD_MIN				     0
-#define QM_LOW_THRESHOLD_MAX			0x7FFFFFFF
-#define QM_PAUSE_THRESHOLD_MIN			         0
-#define QM_PAUSE_THRESHOLD_MAX			0x7FFFFFFF
-#define QM_HIGH_THRESHOLD_MIN			         0
-#define QM_HIGH_THRESHOLD_MAX			0x7FFFFFFF
-#define QM_TRAFFIC_SOURCE_MIN			         0
-#define QM_TRAFFIC_SOURCE_MAX			0x7FFFFFFF
-#define QM_HOST_MIN				         0
-#define QM_HOST_MAX				         1
-#define QM_REORDER_CLASS_MIN	         0
-#define QM_REORDER_CLASS_MAX	        64
-#define QM_SID_MIN				         0
-#define QM_SID_MAX				0x7FFFFFFF
-#define QM_CMD_MIN				         0
-#define QM_CMD_MAX				0x7FFFFFFF
-
-/* typedef void *      qm_handle;*/
-
-/**
- *
- *  Return values:
- *		0 - success
- */
-int qm_open(void);
-
-/**
- *
- *  Return values:
- *		0 - success
- */
-int qm_close(void);
-
-/**
- *
- *  Return values:
- *		0 - success
- */
-int qm_restart(void);
-
-/**
- *  Set base address in Dram for pool
- *
- *  Return values:
- *		0 - success
- */
-int qm_pfe_base_address_pool_set(
-							u32 *pl_base_address, /* Payload DRAM base address */
-							u32 *qece_base_address);/* QE/CE DRAM base address */
-
-/**
- *  Enables QM,
- *  Configure DMA with GPM pool thresholds with default values
- *  Return values:
- *		0 - success
- */
-int qm_dma_gpm_pools_def_enable(void);
-
-/**
- *  Enables QM,
- *  Configure DMA with GPM pool thresholds
- *  Return values:
- *		0 - success
- */
-int qm_dma_gpm_pools_enable(
-				u32 qece_thr_hi, /* GPM qe pool (pool 0) high 32bits threshold */
-				u32 qece_thr_lo, /* GPM qe pool (pool 0) low 32bits threshold */
-				u32 pl_thr_hi, /* GPM payload pool (pool 1) hi 32bits threshold */
-				u32 pl_thr_lo);/* GPM payload pool (pool 1) low 32bits threshold */
-
-/**
- *  Configure DMA with DRAM pool thresholds with default values
- *  Return values:
- *		0 - success
- */
-int qm_dma_dram_pools_def_enable(void);
-
-/**
- *  Configure DMA with DRAM pool thresholds
- *  Return values:
- *		0 - success
- */
-int qm_dma_dram_pools_enable(
-				u32 qece_thr_hi, /* DRAM qe pool (pool 2) high 32bits threshold */
-				u32 qece_thr_lo, /* DRAM qe pool (pool 2) low 32bits threshold */
-				u32 pl_thr_hi, /* DRAM payload pool (pool 3) hi 32bits threshold */
-				u32 pl_thr_lo);/* DRAM payload pool (pool 3) low 32bits threshold */
-
-/**
- *  Configures for each queue in DMA if the queue resides in GPM or in DRAM
- *  Return values:
- *		0 - success
- */
-int qm_dma_queue_memory_type_set(
-				u32 queue, /* Queue number 0 to 511 */
-				u32 memory_type);/* Memory type 0 - for DRAM 1 - for GPM */
-
-/**
- *  Disable prefetching of BM from DMA and PFE - TBD
- *  Return values:
- *		0 - success
-int qm_disable(void);
-TBD - ask yuval peleg defined bits to stops and bit to check if it is stopped
-*/
-
-/**
- *  verify if there is any Queue (0 to 511),
- *  that has a queue length larger than 0
- *  Return values:
- *		0 - success
- */
-int qm_packets_in_queues(
-				u32 *status);
-
-/**
- *  Set default for QM units for mandatory parameters
- *  Return values:
- *		0 - success
- */
-int qm_default_set(void);
-
-/**
- *  Set SID number for each pool (0 and 1) in REORDER unit with default values
- *  Return values:
- *		0 - success
- */
-int qm_ru_pool_sid_number_def_set(void);
-
-/**
- *  Set SID number for each pool (0 and 1) in REORDER unit
- *  Return values:
- *		0 - success
- */
-int qm_ru_pool_sid_number_set(
-				u32 pool0_sid_num, /* SID number fo pool 0. Total number of SID is 4k */
-				u32 pool1_sid_num);/* SID number fo pool 1. Total number of SID is 4k */
-
-/**
- * Configure REORDER with class command when permission is granted with default values.
- *  Return values:
- *		0 - success
- */
-int qm_ru_port_to_class_def_set(void);
-
-/**
- * Configure REORDER with class command when permission is granted.
- *  Return values:
- *		0 - success
- */
-int qm_ru_port_to_class_set(
-				u32 *port_class_arr, /* class number in reorder unit. 0 to 63 */
-				u32 *port_pool_arr, /* holds pool  values which are either 0 or 1 */
-				u32 input_port);/* input port that arrive with the packet. 0 to 287 */
-/*
-				u32 reorder_class, / * class number in reorder unit. 0 to 63 * /
-				u32 input_port, / * input port that arrive with the packet. 0 to 287 * /
-*/
-
-/**
- *  Configure DQF fifo base and depth thresholds with default values
- *  Return values:
- *		0 - success
- */
-int qm_dqf_port_data_fifo_def_set(void);
-
-/**
- *  Configure DQF fifo base and depth thresholds
- *  Return values:
- *		0 - success
- */
-int qm_dqf_port_data_fifo_set(
-				u32 *port_depth_arr);/* holds depth in Bytes for ports 0 to 15 */
-
-/**
- *  Configure DQF fifo credit thresholds with default values
- *  Return values:
- *		0 - success
- */
-int qm_dqf_port_credit_thr_def_set(void);
-
-/**
- *  Configure DQF fifo credit thresholds
- *  Return values:
- *		0 - success
- */
-int qm_dqf_port_credit_thr_set(
-				u32 *port_credit_thr_arr);/* Configures credits thresholds for xMac input ports */
-
-/**
- *  Configure DQF for each port which PPC (data or maintenance) handles the packet,
- *  relevant only for PPC port with default values.
- *  Return values:
- *		0 - success
- */
-int qm_dqf_port_ppc_map_def_set(void);
-
-/**
- *  Configure DQF for each port which PPC (data or maintenance) handles the packet,
- *  relevant only for PPC port.
- *  Return values:
- *		0 - success
- */
-int qm_dqf_port_ppc_map_set(
-				u32 *port_ppc_arr, /* holds indication which PPC process packets from this port */
-				u32 port);/* input ports */
-
-/**
- *  Configure DMA QOS write attributes with default values.
- *  Return values:
- *		0 - success
- */
-int qm_dma_qos_attr_def_set(void);
-
-/**
- *  Configure DMA QOS write attributes.
- *  Return values:
- *		0 - success
- */
-int qm_dma_qos_attr_set(
-				u32 swf_awqos,
-				u32 rdma_awqos,
-				u32 hwf_qe_ce_awqos,
-				u32 hwf_sfh_pl_awqos);
-
-/**
- *  Configure DMA CACHE write attributes with default values.
- *  Return values:
- *		0 - success
- */
-int qm_dma_cache_attr_def_set(void);
-
-/**
- *  Configure DMA CACHE write attributes.
- *  Return values:
- *		0 - success
- */
-int qm_dma_cache_attr_set(
-				u32 swf_awcache,
-				u32 rdma_awcache,
-				u32 hwf_qe_ce_awcache,
-				u32 hwf_sfh_pl_awcache);
-
-/**
- *  Configure DMA DOMAIN write attributes with default values.
- *  Return values:
- *		0 - success
- */
-int qm_dma_domain_attr_def_set(void);
-
-/**
- *  Configure DMA DOMAIN write attributes.
- *  Return values:
- *		0 - success
- */
-int qm_dma_domain_attr_set(
-				u32 swf_awdomain,
-				u32 rdma_awdomain,
-				u32 hwf_qe_ce_awdomain,
-				u32 hwf_sfh_pl_awdomain);
-
-/**
- *  Configure PFE QOS read attributes with default values.
- *  Return values:
- *		0 - success
- */
-int qm_pfe_qos_attr_def_set(void);
-
-/**
- *  Configure PFE QOS read attributes.
- *  Return values:
- *		0 - success
- */
-int qm_pfe_qos_attr_set(
-				u32 swf_arqos,
-				u32 rdma_arqos,
-				u32 hwf_qe_ce_arqos,
-				u32 hwf_sfh_pl_arqos);
-
-/**
- *  Configure PFE CACHE read attributes with default values.
- *  Return values:
- *		0 - success
- */
-int qm_pfe_cache_attr_def_set(void);
-
-/**
- *  Configure PFE CACHE read attributes.
- *  Return values:
- *		0 - success
- */
-int qm_pfe_cache_attr_set(
-				u32 swf_arcache,
-				u32 rdma_arcache,
-				u32 hwf_qe_ce_arcache,
-				u32 hwf_sfh_pl_arcache);
-
-/**
- *  Configure PFE DOMAIN read attributes with default values.
- *  Return values:
- *		0 - success
- */
-int qm_pfe_domain_attr_def_set(void);
-
-/**
- *  Configure PFE DOMAIN read attributes.
- *  Return values:
- *		0 - success
- */
-int qm_pfe_domain_attr_set(
-				u32 swf_ardomain,
-				u32 rdma_ardomain,
-				u32 hwf_qe_ce_ardomain,
-				u32 hwf_sfh_pl_ardomain);
-
-/**
- *  Configures per queue threshold profile with default values.
- *  Return values:
- *		0 - success
- */
-int qm_ql_q_profile_def_set(void);
-
-/**
- *  Configures per queue threshold profile.
- *  Return values:
- *		0 - success
- */
-int qm_ql_q_profile_set(
-				u32 queue_profile,
-				u32 queue);
-
-/**
- *  Configures QL threshold for pause, on (low) and off (high)
- *  and the to whom to send it (source) with default values.
- *  Return values:
- *		0 - success
- */
-int qm_ql_thr_def_set(void);
-
-/**
- *  Configures QL threshold for pause, on (low) and off (high)
- *  and the to whom to send it (source).
- *  Return values:
- *		0 - success
- */
-int qm_ql_thr_set(
-				u32 low_threshold,
-				u32 pause_threshold,
-				u32 high_threshold,
-				u32 traffic_source,
-				u32 queue_profile);
-
-
-/**
- *  Configure DMA write attributes for software forwarding mode
- *  Return values:
- *		0 - success
- */
-int qm_axi_swf_write_attr_set(
-						u32 qos,
-						u32 cache,
-						u32 domain);
-
-/**
- *  Configure DMA write attributes for rdma mode
- *  Return values:
- *		0 - success
- */
-int qm_axi_rdma_write_attr_set(
-						u32 qos,
-						u32 cache,
-						u32 domain);
-
-/**
- *  Configure DMA write attributes for hardware forwarding mode for qe/ce
- *  Return values:
- *		0 - success
- */
-int qm_axi_hwf_qece_write_attr_set(
-						u32 qos,
-						u32 cache,
-						u32 domain);
-
-/**
- *  Configure DMA write attributes for hardware forwarding mode for payload
- *  Return values:
- *		0 - success
- */
-int qm_axi_hwf_pyl_write_attr_set(
-						u32 qos,
-						u32 cache,
-						u32 domain);
-
-
-/**
- *  Initiate QM DRAM pools
- *	Configures BM for pool initialization and enable the pool.  Doesn't configure cache parameters.
- *  This function is a super set of several bm function that are listed below
- *  Note: No change can be made to pool after this function is called.
- *  Return values:
- *		0 - success
- */
-int qm_dram_qm_pool_quick_init(
-		u32 pool, /* pool number: 2 or 3 */
-		u32 num_of_buffers,  /* number of buffers/PEs in pool max pool = 2M x 8B*/
-		u32 base_address_hi, /* hi part of DRAM base address */
-		u32 base_address_lo, /* low part of DRAM base address */
-		u32 ae_thr, /* almost empty threshold for pool */
-		u32 af_thr);/* almost full threshold for pool */
-
-/**
- *  Enables DMA and PFE by configuring the registers that represents GPM and DRAM thresholds
- *  Note: BM is not enabled from here since BM should be enabled the last
- *  Return values:
- *		0 - success
- */
-int qm_enable(
-			u32 gpm_qe_thr_hi,
-			u32 gpm_qe_thr_lo,
-			u32 gpm_pl_thr_hi,
-			u32 gpm_pl_thr_lo,
-			u32 dram_qe_thr_hi,
-			u32 dram_qe_thr_lo,
-			u32 dram_pl_thr_hi,
-			u32 dram_pl_thr_lo);
-
-
-/**
- *  Get Idle status from DMA
- *  Return values:
- *		0 - success
- */
-int qm_idle_status_get(
-			u32 *dma_status);/* DMA status is output to the called */
-
-/**
- *  Set VMID in DMA and PFE
- *  Return values:
- *		0 - success
- */
-int qm_vmid_set(u32 qm_vmid);/* VMID value for DAM and PFE */
-int dma_vmid_set(u32 qm_vmid);/* VMID value for DAM and PFE */
-int pfe_vmid_set(u32 qm_vmid);/* VMID value for DAM and PFE */
-
-
-/**
- *  Interupts handling - TBD
- *  Return values:
- *		0 - success
- */
-int qm_inter_read(
-					u32 group,
-					u32 *dataPtr);
-
-/**
- *  Interupts handling - TBD
- *  Return values:
- *		0 - success
- */
-int qm_inter_clean(
-					u32 group);
-
-/**
- *  Interupts handling - TBD
- *  Return values:
- *		0 - success
- */
-int qm_inter_mask(
-					u32 group,
-					u32 mask);
-
-/**
- *  Errors handling - TBD
- *  Return values:
- *		0 - success
- */
-int qm_error_read(
-					u32 group,
-					u32 *dataPtr);
-
-/**
- *  Errors handling - TBD
- *  Return values:
- *		0 - success
- */
-int qm_error_clean(
-					u32 group);
-
-/**
- *  Errors handling - TBD
- *  Return values:
- *		0 - success
- */
-int qm_error_mask(
-					u32 group,
-					u32 mask);
-
-/**
- *  Dump registers values from all modules apart of BM
- *  Return values:
- *		0 - success
- */
-int qm_debug_dump_registers(void);
-
-/**
- *  Configre PFE to start Flushing Queue. This process takes a while.
- *  Indication for its completion is when Queue is empty
- *  Return values:
- *		0 - success
- */
-int qm_queue_flush_start(
-						u32 queue);/* queue number from 0 to 511 */
-
-/**
- *  Configure PFE to stop Flushing Queue.
- *  Return values:
- *		0 - success
- */
-int qm_queue_flush_stop(u32 queue);
-
-/**
- *  Configre PFE to start Flushing Port. This process takes a while.
- *  Indication for its completion is when Port is empty
- *  Return values:
- *		0 - success
- */
-int qm_port_flush_start(
-							u32 port);/* port number from 0 to 15 */
-
-/**
- *  Configure PFE to stop Flushing Port.
- *  Return values:
- *		0 - success
- */
-int qm_port_flush_stop(
-						u32 port);/* port number from 0 to 15 */
-
-/**
- *  Get from DQF read and write pointers for specific port
- *  Return values:
- *		0 - success
- */
-int qm_port_fifo_ptr_get(
-						u32 port, /* port number 0 to 15 */
-						u32 *read,
-						u32 *write);
-
-/**
- *  Configures QL thresholds for EMAC and HMAC (configured per source )
- *  Return values:
- *		0 - success
- */
-int qm_ql_source_thr_set(
-				u32 low, /* low threshold: beneath it will turn ON*/
-				u32 pause, /* pause threshold above it will send PAUSE*/
-				u32 high, /* high threshold above it will turn OFF*/
-				u32 source);/* source 0 to 6 */
-
-/**
- *  Get head of class from REORDER unit
- *  Return values:
- *		0 - success
- */
-int qm_class_head_get(
-					u32 reorder_class, /* class number in reorder unit. 0 to 63 */
-					u32 *head);/* output to caller */
-
-/**
- * Configure REORDER with class command when permission is granted.
- *  Return values:
- *		0 - success
- */
-int qm_class_cmd_set(
-					u32 host,
-					u32 reorder_class, /* class number in reorder unit. 0 to 63 */
-					u32 sid, /* sid is in the range 0 to 4k */
-					u32 cmd);/* cmd is either update or release */
-
-/**
- *  Write QM register
- *  Return values:
- *		0 - success
- */
-int qm_register_write(u32 base_address, u32 offset, u32 wordsNumber, u32 *dataPtr);
-
-/**
- *  Read QM register
- *  Return values:
- *		0 - success
- */
-int qm_register_read(u32 base_address, u32 offset, u32 wordsNumber, u32 *dataPtr);
-
-
-#endif /* MV_QM_H */
-- 
1.7.5.4

