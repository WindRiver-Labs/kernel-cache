From 6d524c97c7347211b59752ff2c390f69817c6052 Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Mon, 22 Jul 2013 10:20:10 +0300
Subject: [PATCH 0867/1825] alp: tdm: support legacy tdm 2ch unit

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit ca0083ef9cc51ec19956ecef2871941bb8d415dc

        - Add support for lagacy tdm 2ch unit.
        - Remove redundant slic driver code.
        - Support zarlink ve880 external slic driver
        - Fixed support for zarlink mv_voice_tool.

Change-Id: Ided244b296d3b04f92f8c2c1502a973b1c66a06b
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2793
Reviewed-by: Igor Patrik <igorp@marvell.com>
Tested-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/avanta_lp_defconfig               |    3 +-
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   27 +
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |   10 +-
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.c     |   24 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |  120 +++
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |    7 +
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h       |   27 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |    2 +-
 arch/arm/mach-avantalp/config/mvSysTdmConfig.h     |   98 ++-
 arch/arm/mach-avantalp/fiq.c                       |    2 +
 arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c        |   31 +-
 arch/arm/plat-armada/include/plat/drv_dxt_if.h     |   87 ++
 arch/arm/plat-armada/include/plat/silabs_if.h      |   84 ++
 arch/arm/plat-armada/include/plat/zarlink_if.h     |   83 ++
 .../plat-armada/mv_drivers_lsp/mv_phone/Kconfig    |  168 ++--
 .../plat-armada/mv_drivers_lsp/mv_phone/Makefile   |   87 +--
 .../mv_drivers_lsp/mv_phone/slic/drv_dxt_if.c      |  163 ++++
 .../mv_drivers_lsp/mv_phone/slic/silabs_if.c       |  120 +++
 .../mv_drivers_lsp/mv_phone/slic/vpapi_dev.c       | 1024 -------------------
 .../mv_drivers_lsp/mv_phone/slic/vpapi_dev.h       |  265 -----
 .../mv_drivers_lsp/mv_phone/slic/zarlink_if.c      |   98 ++
 .../mv_drivers_lsp/mv_phone/spi/spi_dev.c          |  259 +++++
 .../mv_drivers_lsp/mv_phone/spi/spi_dev.h          |   94 ++
 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.c |  157 ---
 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.h |   70 --
 .../plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c  |   32 +-
 .../plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h  |   18 +-
 .../mv_drivers_lsp/mv_phone/tdm/tdm_if.c           |  411 ++++++--
 .../mv_drivers_lsp/mv_phone/tdm/tdm_if.h           |    9 +
 .../mv_drivers_lsp/mv_phone/tdm/test/Makefile      |    4 +-
 .../mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c     |  171 +++--
 .../mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h     |   12 +-
 .../plat-armada/mv_drivers_lsp/mv_phone/tdm_if.c   |  449 ---------
 .../plat-armada/mv_drivers_lsp/mv_phone/tdm_if.h   |  116 ---
 .../mv_drivers_lsp/mv_phone/test/Makefile          |    9 -
 .../mv_drivers_lsp/mv_phone/test/tdm_dev.c         |  367 -------
 .../mv_drivers_lsp/mv_phone/test/tdm_dev.h         |   87 --
 .../mv_drivers_lsp/mv_phone/vpapi_dev.c            | 1027 --------------------
 .../mv_drivers_lsp/mv_phone/vpapi_dev.h            |  266 -----
 .../mv_hal/voiceband/commUnit/mvCommUnit.c         |   13 +-
 .../mv_hal/voiceband/commUnit/mvCommUnit.h         |    2 +-
 arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c  |  238 ++++-
 arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h  |   25 +-
 .../mv_hal/voiceband/tdm/mvTdmAddrDec.c            |    2 +-
 drivers/staging/telephony/Makefile                 |    4 +
 tools/voice/zarlink/kernel/Makefile                |   15 +-
 46 files changed, 2110 insertions(+), 4277 deletions(-)
 create mode 100644 arch/arm/plat-armada/include/plat/drv_dxt_if.h
 create mode 100644 arch/arm/plat-armada/include/plat/silabs_if.h
 create mode 100644 arch/arm/plat-armada/include/plat/zarlink_if.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/drv_dxt_if.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/silabs_if.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/zarlink_if.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/spi/spi_dev.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/spi/spi_dev.h
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.h
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm_if.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm_if.h
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/Makefile
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/tdm_dev.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/tdm_dev.h
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/vpapi_dev.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/vpapi_dev.h

diff --git a/arch/arm/configs/avanta_lp_defconfig b/arch/arm/configs/avanta_lp_defconfig
index 7da9d20..ca06cff 100644
--- a/arch/arm/configs/avanta_lp_defconfig
+++ b/arch/arm/configs/avanta_lp_defconfig
@@ -14,7 +14,6 @@ CONFIG_MODULE_UNLOAD=y
 CONFIG_PARTITION_ADVANCED=y
 CONFIG_ARCH_AVANTA_LP=y
 # CONFIG_MV_INCLUDE_CESA is not set
-# CONFIG_MV_INCLUDE_TDM is not set
 CONFIG_MV_ETH_TXQ=8
 # CONFIG_NET_SKB_RECYCLE is not set
 # CONFIG_MV_INCLUDE_LEGACY_NAND is not set
@@ -136,6 +135,8 @@ CONFIG_RTC_CLASS=y
 CONFIG_DMADEVICES=y
 CONFIG_MV_XOR=y
 CONFIG_DMATEST=m
+CONFIG_STAGING=y
+CONFIG_PHONE=y
 CONFIG_EXT2_FS=y
 CONFIG_EXT3_FS=y
 # CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index ca0ad2a..eb72dba 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -1640,6 +1640,33 @@ MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId)
 }
 
 /*******************************************************************************
+* mvBoardTdmSpiIdGet
+*
+* DESCRIPTION:
+*	Return SPI port ID per board.
+*
+* INPUT:
+*	None
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	SPI port ID.
+*
+*******************************************************************************/
+MV_U8 mvBoardTdmSpiIdGet(MV_VOID)
+{
+	MV_16 index;
+
+	index = board->boardTdmInfoIndex;
+	if (index == -1)
+		return 0;
+
+	return board->pBoardTdmSpiInfo[0].spiId;
+}
+
+/*******************************************************************************
 * mvBoardConfigurationPrint
 *
 * DESCRIPTION:
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index 21ad4aa..743985c 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -257,10 +257,11 @@ typedef struct {
 } MV_BOARD_TDM_SPI_INFO;
 
 typedef enum {
-	BOARD_TDM_SLIC_880 = 0,
-	BOARD_TDM_SLIC_792,
-	BOARD_TDM_SLIC_3215,
-	BOARD_TDM_SLIC_OTHER,
+	BOARD_SLIC_880 = 0,
+	BOARD_SLIC_792,
+	BOARD_SLIC_SSI,
+	BOARD_SLIC_ISI,
+	BOARD_SLIC_ZSI,
 	BOARD_TDM_SLIC_COUNT
 } MV_BOARD_TDM_SLIC_TYPE;
 
@@ -408,6 +409,7 @@ MV_U32 mvBoardGppConfigGet(void);
 MV_32 mvBoardTdmSpiModeGet(MV_VOID);
 MV_U8 mvBoardTdmDevicesCountGet(void);
 MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId);
+MV_U8 mvBoardTdmSpiIdGet(MV_VOID);
 MV_VOID mvBoardConfigurationPrint(MV_VOID);
 MV_VOID mvBoardOtherModuleTypePrint(MV_VOID);
 MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
index a08899d..5e3970e 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
@@ -214,6 +214,10 @@ MV_BOARD_MPP_INFO db88f6660InfoBoardMppConfigValue[] = {
 	 } }
 };
 
+MV_BOARD_TDM_INFO db88f6660Tdm880[] = { {0} };
+
+MV_BOARD_TDM_SPI_INFO db88f6660TdmSpiInfo[] = { {1} };
+
 MV_BOARD_INFO db88f6660_board_info = {
 	.boardName			= "DB-88F6660",
 	.numBoardMppTypeValue		= ARRSZ(db88f6660InfoBoardModTypeInfo),
@@ -255,9 +259,9 @@ MV_BOARD_INFO db88f6660_board_info = {
 	.switchforceLinkMask		= 0x0,
 
 	/* TDM */
-	.numBoardTdmInfo		= {},
-	.pBoardTdmInt2CsInfo		= {},
-	.boardTdmInfoIndex		= -1,
+	.numBoardTdmInfo		= {1},
+	.pBoardTdmInt2CsInfo		= {db88f6660Tdm880},
+	.boardTdmInfoIndex		= 0,
 
 	.pBoardSpecInit			= NULL,
 
@@ -265,6 +269,8 @@ MV_BOARD_INFO db88f6660_board_info = {
 	.nandFlashReadParams		= 0,
 	.nandFlashWriteParams		= 0,
 	.nandFlashControl		= 0,
+	.pBoardTdmSpiInfo		= db88f6660TdmSpiInfo,
+
 	/* NOR init params */
 	.norFlashReadParams		= 0,
 	.norFlashWriteParams		= 0,
@@ -326,6 +332,10 @@ MV_BOARD_MPP_INFO db88f6650InfoBoardMppConfigValue[] = {
 	 } }
 };
 
+MV_BOARD_TDM_INFO db88f6650Tdm880[] = { {0} };
+
+MV_BOARD_TDM_SPI_INFO db88f6650TdmSpiInfo[] = { {1} };
+
 MV_BOARD_INFO db88f6650_board_info = {
 	.boardName			= "DB-88F6650",
 	.numBoardMppTypeValue		= ARRSZ(db88f6650InfoBoardModTypeInfo),
@@ -367,9 +377,9 @@ MV_BOARD_INFO db88f6650_board_info = {
 	.switchforceLinkMask		= 0x0,
 
 	/* TDM */
-	.numBoardTdmInfo		= {},
-	.pBoardTdmInt2CsInfo		= {},
-	.boardTdmInfoIndex		= -1,
+	.numBoardTdmInfo		= {1},
+	.pBoardTdmInt2CsInfo		= {db88f6650Tdm880},
+	.boardTdmInfoIndex		= 0,
 
 	.pBoardSpecInit			= NULL,
 
@@ -377,6 +387,8 @@ MV_BOARD_INFO db88f6650_board_info = {
 	.nandFlashReadParams		= 0,
 	.nandFlashWriteParams		= 0,
 	.nandFlashControl		= 0,
+	.pBoardTdmSpiInfo		= db88f6650TdmSpiInfo,
+
 	/* NOR init params */
 	.norFlashReadParams		= 0,
 	.norFlashWriteParams		= 0,
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index 8498642..d1ea1b3 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -318,6 +318,10 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 	 */
 	MV_REG_BIT_SET(PUP_EN_REG, BIT4);
 
+#if defined(MV_INCLUDE_TDM)
+	mvCtrlTdmClkCtrlConfig();
+#endif
+
 	return MV_OK;
 }
 
@@ -998,6 +1002,120 @@ MV_U32 mvCtrlSdioSupport(MV_VOID)
 
 #endif
 
+#if defined(MV_INCLUDE_TDM)
+/*******************************************************************************
+* mvCtrlTdmClkCtrlSet - Set TDM Clock Out Divider Control register
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCtrlTdmClkCtrlConfig(MV_VOID)
+{
+	MV_U32 clkReg, pcmClkFreq;
+
+#if defined(MV_TDM_PCM_CLK_8MHZ)
+	pcmClkFreq = DCO_CLK_DIV_RATIO_8M;
+#elif defined(MV_TDM_PCM_CLK_4MHZ)
+	pcmClkFreq = DCO_CLK_DIV_RATIO_4M;
+#elif defined(MV_TDM_PCM_CLK_2MHZ)
+	pcmClkFreq = DCO_CLK_DIV_RATIO_2M;
+#else
+	pcmClkFreq = DCO_CLK_DIV_RATIO_8M;
+#endif
+
+	/* Reload new DCO source ratio */
+	clkReg = MV_REG_READ(CORE_DIVCLK_CTRL_REG);
+	MV_REG_WRITE(CORE_DIVCLK_CTRL_REG,
+		     MV_BIT_CLEAR(clkReg, DCO_CLK_DIV_MOD_OFFS));
+	mvOsUDelay(1);
+
+	clkReg = MV_REG_READ(CORE_DIVCLK_CTRL_REG);
+	MV_REG_WRITE(CORE_DIVCLK_CTRL_REG,
+		     MV_BIT_SET(clkReg, DCO_CLK_DIV_MOD_OFFS));
+	mvOsUDelay(1);
+
+	clkReg = MV_REG_READ(CORE_DIVCLK_CTRL_REG);
+	MV_REG_WRITE(CORE_DIVCLK_CTRL_REG,
+		     MV_BIT_CLEAR(clkReg, DCO_CLK_DIV_MOD_OFFS));
+	mvOsUDelay(1);
+
+	clkReg = MV_REG_READ(CORE_DIVCLK_CTRL_REG);
+	MV_REG_WRITE(CORE_DIVCLK_CTRL_REG,
+		     MV_BIT_SET(clkReg, DCO_CLK_DIV_RESET_OFFS));
+	mvOsUDelay(1);
+
+	/* Set DCO correction to 0PPM */
+	clkReg = MV_REG_READ(DCO_MOD_CTRL_REG);
+	MV_REG_WRITE(DCO_MOD_CTRL_REG,
+		     (clkReg & ~DCO_MOD_CTRL_MASK) | DCO_MOD_CTRL_BASE_VAL);
+	mvOsUDelay(1);
+
+	/* Set DCO source ratio */
+	clkReg = MV_REG_READ(CORE_DIVCLK_CTRL_REG);
+	MV_REG_WRITE(CORE_DIVCLK_CTRL_REG,
+		     (clkReg & ~DCO_CLK_DIV_RATIO_MASK) | pcmClkFreq);
+	mvOsUDelay(1);
+}
+
+#if defined(MV_TDM_USE_DCO)
+/*******************************************************************************
+* mvCtrlTdmClkCtrlGet - Get DCO correction ratio
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_32 mvCtrlTdmClkCtrlGet(MV_VOID)
+{
+	MV_32 val;
+
+	/* Get DCO correction */
+	val = ((((MV_REG_READ(DCO_MOD_CTRL_REG)) & DCO_MOD_CTRL_MASK) >> DCO_MOD_CTRL_OFFS) - DCO_MOD_CTRL_BASE);
+
+	return val;
+}
+
+/*******************************************************************************
+* mvCtrlTdmClkCtrlSet - Set DCO correction ratio
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Current DCO correction.
+*
+*******************************************************************************/
+MV_VOID mvCtrlTdmClkCtrlSet(MV_32 correction)
+{
+	/* Set DCO correction to correction * 1PPM */
+	MV_REG_WRITE(DCO_MOD_CTRL_REG,
+		     ((MV_REG_READ(DCO_MOD_CTRL_REG) & ~DCO_MOD_CTRL_MASK) |
+		     (((DCO_MOD_CTRL_BASE_VAL >> DCO_MOD_CTRL_OFFS) + correction) << DCO_MOD_CTRL_OFFS)));
+}
+#endif /* MV_TDM_USE_DCO */
+
 /*******************************************************************************
 * mvCtrlTdmSupport - Return if this controller has integrated TDM flash support
 *
@@ -1099,6 +1217,8 @@ MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
 *       16bit desscribing Marvell controller ID
 *
 *******************************************************************************/
+#endif /* MV_INCLUDE_TDM */
+
 MV_U16 mvCtrlModelGet(MV_VOID)
 {
 #ifdef CONFIG_MACH_AVANTA_LP_FPGA
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
index d5eab12..0a4af2e 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -310,10 +310,17 @@ MV_U32 mvCtrlUsbMaxGet(MV_VOID);
 #if defined(MV_INCLUDE_SDIO)
 MV_U32 mvCtrlSdioSupport(MV_VOID);
 #endif
+#if defined(MV_INCLUDE_TDM)
 MV_U32 mvCtrlTdmSupport(MV_VOID);
 MV_U32 mvCtrlTdmMaxGet(MV_VOID);
 MV_TDM_UNIT_TYPE mvCtrlTdmUnitTypeGet(MV_VOID);
 MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID);
+MV_VOID mvCtrlTdmClkCtrlConfig(MV_VOID);
+#if defined(MV_TDM_USE_DCO)
+MV_32 mvCtrlTdmClkCtrlGet(MV_VOID);
+MV_VOID mvCtrlTdmClkCtrlSet(MV_32 correction);
+#endif
+#endif
 MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel);
 MV_U16 mvCtrlModelGet(MV_VOID);
 MV_U32 mvCtrlRevGet(MV_VOID);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
index 272912c..82e4734 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -81,7 +81,7 @@ extern "C" {
 #define PCCRIR_REVID_MASK                       (0xff << PCCRIR_REVID_OFFS)
 
 /* Controler environment registers offsets */
-#define MV_TDM_IRQ_NUM                          56
+#define MV_TDM_IRQ_NUM                          59
 
 /* CIB registers offsets */
 #define MV_CIB_CTRL_CFG_REG                     (MV_COHERENCY_FABRIC_OFFSET + 0x80)
@@ -153,6 +153,31 @@ extern "C" {
 /*****************/
 #define PUP_EN_REG                              0x1864C
 
+/* Core DivClk Control Register */
+#define CORE_DIVCLK_CTRL_REG			0x18730
+
+/* DCO clock apply/reset bits */
+#define DCO_CLK_DIV_MOD_OFFS			24
+#define DCO_CLK_DIV_APPLY			(0x1 << DCO_CLK_DIV_MOD_OFFS)
+#define DCO_CLK_DIV_RESET_OFFS			25
+#define DCO_CLK_DIV_RESET			(0x1 << DCO_CLK_DIV_RESET_OFFS)
+
+/* DCO clock ratio is 48Mhz/x */
+#define DCO_CLK_DIV_RATIO_OFFS			26
+#define DCO_CLK_DIV_RATIO_MASK			(BIT26 | BIT27 | BIT28 | BIT29 | BIT30 | BIT31)
+#define DCO_CLK_DIV_RATIO_8M			(0x6 << DCO_CLK_DIV_RATIO_OFFS)
+#define DCO_CLK_DIV_RATIO_4M			(0xc << DCO_CLK_DIV_RATIO_OFFS)
+#define DCO_CLK_DIV_RATIO_2M			(0x18 << DCO_CLK_DIV_RATIO_OFFS)
+
+
+/* DCO Control Register [13:2], Value range: 0x20-0xFE0, 0x1 = 1.27PPM */
+#define DCO_MOD_CTRL_REG			0x18794
+#define DCO_MOD_CTRL_MASK			(BIT2 | BIT3 | BIT4 | BIT5 | BIT6 | BIT7 | BIT8 | BIT9 | BIT10 | BIT11 | BIT12 | BIT13)
+#define DCO_MOD_CTRL_OFFS			0x2
+#define DCO_MOD_CTRL_BASE			0x800
+#define DCO_MOD_CTRL_BASE_VAL			(0x800 << DCO_MOD_CTRL_OFFS)
+
+
 /* Extract CPU, L2, DDR clocks SAR value from
 ** SAR bits 24-27
 */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index f94dd25..05876f6 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -137,7 +137,7 @@ extern "C" {
 #define MV_CESA_TDMA_REGS_OFFSET(chanNum)       (0x90000 + (chanNum * 0x2000))
 #define MV_CESA_REGS_OFFSET(chanNum)            (0x9D000 + (chanNum * 0x2000))
 #define MV_SATA_REGS_OFFSET                     (0xA0000)
-#define MV_COMM_UNIT_REGS_OFFSET                (0xB0000)
+#define MV_TDM_REGS_OFFSET			(0xB0000)
 #define MV_NFC_REGS_OFFSET                      (0xD0000)
 #define MV_SDMMC_REGS_OFFSET                    (0xD4000)
 
diff --git a/arch/arm/mach-avantalp/config/mvSysTdmConfig.h b/arch/arm/mach-avantalp/config/mvSysTdmConfig.h
index e7abb9e..07402f0 100644
--- a/arch/arm/mach-avantalp/config/mvSysTdmConfig.h
+++ b/arch/arm/mach-avantalp/config/mvSysTdmConfig.h
@@ -1,22 +1,67 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
+
 /*******************************************************************************
 * mvSysTdmConfig.h - Marvell TDM unit specific configurations
 *
@@ -43,6 +88,14 @@ disclaimer.
 	#define MV_COMM_UNIT_REGS_BASE	MV_COMM_UNIT_REGS_OFFSET
 #endif
 
+#ifdef CONFIG_MV_TDM_USE_DCO
+	#define MV_TDM_USE_DCO
+#endif
+
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	#define MV_TDM_EXT_STATS
+#endif
+
 /* SLIC vendor */
 #if defined(CONFIG_SILABS_SLIC_SUPPORT)
 	#define SILABS_SLIC_SUPPORT
@@ -50,19 +103,26 @@ disclaimer.
 		#define SILABS_SLIC_3215
 	#elif defined(CONFIG_SILABS_SLIC_3217)
 		#define SILABS_SLIC_3217
+	#elif defined(CONFIG_SILAB_SLIC_SI3226)
+		#define SI3226X
 	#endif
 #elif defined(CONFIG_ZARLINK_SLIC_SUPPORT)
 	#define ZARLINK_SLIC_SUPPORT
-	#if defined(CONFIG_ZARLINK_SLIC_VE880)
-		#define ZARLINK_SLIC_VE880
-		#define SLIC_TIMER_EVENT_SUPPORT
-	#elif defined(CONFIG_ZARLINK_SLIC_VE792)
-		#define ZARLINK_SLIC_VE792
-	#endif
-#else
-	#define SILABS_SLIC_3215_OLD_SUPPORT
+	#define SLIC_TIMER_EVENT_SUPPORT
+#else /* CONFIG_LANTIQ_SLIC_SUPPORT */
+	#define LANTIQ_SLIC_SUPPORT
 #endif
 
-#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE_ARMADA)
- #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+	#define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#endif
+
+#if defined(CONFIG_MV_TDM_PCM_CLK_8MHZ)
+	#define MV_TDM_PCM_CLK_8MHZ
+#elif defined(CONFIG_MV_TDM_PCM_CLK_4MHZ)
+	#define MV_TDM_PCM_CLK_4MHZ
+#elif defined(CONFIG_MV_TDM_PCM_CLK_2MHZ)
+	#define MV_TDM_PCM_CLK_2MHZ
+#else
+	#define MV_TDM_PCM_CLK_8MHZ
 #endif
diff --git a/arch/arm/mach-avantalp/fiq.c b/arch/arm/mach-avantalp/fiq.c
index 2f45eca..e47f17a 100644
--- a/arch/arm/mach-avantalp/fiq.c
+++ b/arch/arm/mach-avantalp/fiq.c
@@ -53,6 +53,7 @@ request_fiq(unsigned int intr_nr, irq_handler_t handler, unsigned long flags,
 	gic_unmask_fiq(intr_nr);
 	return 0;
 }
+EXPORT_SYMBOL(request_fiq);
 
 void free_fiq(unsigned int irq, void *dev_id)
 {
@@ -60,3 +61,4 @@ void free_fiq(unsigned int irq, void *dev_id)
 	gic_set_nonsecure(irq);
 	fiq_handlers[irq] = NULL;
 }
+EXPORT_SYMBOL(free_fiq);
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c
index 83c9d59..2aaabe1 100644
--- a/arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c
@@ -108,6 +108,15 @@ MV_STATUS mvSysTdmInit(MV_TDM_PARAMS* tdmParams)
 	if(status == MV_OK) {
 		halData.spiMode = mvBoardTdmSpiModeGet();
 		halData.model = mvCtrlModelGet();
+		halData.ctrlRev = mvCtrlRevGet();
+#if defined(MV_TDM_PCM_CLK_8MHZ)
+		halData.frameTs = MV_FRAME_128TS;
+#elif defined(MV_TDM_PCM_CLK_4MHZ)
+		halData.frameTs = MV_FRAME_64TS;
+#else /* MV_TDM_PCM_CLK_2MHZ */
+		halData.frameTs = MV_FRAME_32TS;
+#endif
+
 #ifdef MV_TDM_SUPPORT
 		status = mvTdmHalInit (tdmParams, &halData);
 #else
@@ -115,9 +124,9 @@ MV_STATUS mvSysTdmInit(MV_TDM_PARAMS* tdmParams)
 		status = mvCommUnitHalInit (tdmParams, &halData);
 		
 		/* Issue SLIC reset */
-		mvGppValueSet(0, BIT24, 0);
-		mvOsDelay(1);
-		mvGppValueSet(0, BIT24, BIT24);
+		mvGppValueSet(0, BIT25, 0);
+		mvOsUDelay(60);
+		mvGppValueSet(0, BIT25, BIT25);
 #endif
 	}
 
@@ -126,7 +135,7 @@ MV_STATUS mvSysTdmInit(MV_TDM_PARAMS* tdmParams)
 
 MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
 {
-#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT) && !defined(SILABS_SLIC_SUPPORT) && !defined(LANTIQ_SLIC_SUPPORT)
 
 	if((cmdSize > 4) || (dataSize > MAX_DATA_LENGTH))
 	{
@@ -136,12 +145,12 @@ MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dat
 
 	mvTdmSpiRead(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
 
-#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT || SILABS_SLIC_SUPPORT || LANTIQ_SLIC_SUPPORT */
 
 	/* Set SPI parameters(lineId = devId) */
-	mvSpiParamsSet(0, mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+	mvSpiParamsSet(mvBoardTdmSpiIdGet(), mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
 	
-	if(MV_OK != mvSpiWriteThenRead (0, cmdBuff, cmdSize, dataBuff, dataSize, 0))
+	if (MV_OK != mvSpiWriteThenRead(mvBoardTdmSpiIdGet(), cmdBuff, cmdSize, dataBuff, dataSize, 0))
 		printk("SPI read failed !!!\n");
 
 #endif /* MV_TDM_SUPPORT */
@@ -162,7 +171,7 @@ MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dat
 *******************************************************************************/
 MV_VOID mvSysTdmSpiWrite(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
 {
-#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT) && !defined(SILABS_SLIC_SUPPORT) && !defined(LANTIQ_SLIC_SUPPORT)
 
 	if((cmdSize > 3) || (dataSize > MAX_DATA_LENGTH))
 	{
@@ -172,12 +181,12 @@ MV_VOID mvSysTdmSpiWrite(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* da
 
 	mvTdmSpiWrite(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
 
-#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT || SILABS_SLIC_SUPPORT || LANTIQ_SLIC_SUPPORT */
 	
 	/* Set SPI parameters(lineId = devId) */
-	mvSpiParamsSet(0, mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+	mvSpiParamsSet(mvBoardTdmSpiIdGet(), mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
 
-	if(MV_OK != mvSpiWriteThenWrite (0, cmdBuff, cmdSize, dataBuff, dataSize))
+	if (MV_OK != mvSpiWriteThenWrite(mvBoardTdmSpiIdGet(), cmdBuff, cmdSize, dataBuff, dataSize))
 		printk("SPI write failed !!!\n");
 
 #endif /* MV_TDM_SUPPORT */
diff --git a/arch/arm/plat-armada/include/plat/drv_dxt_if.h b/arch/arm/plat-armada/include/plat/drv_dxt_if.h
new file mode 100644
index 0000000..9f8e036
--- /dev/null
+++ b/arch/arm/plat-armada/include/plat/drv_dxt_if.h
@@ -0,0 +1,87 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#ifndef __PLAT_DRV_DXT_IF_H
+#define __PLAT_DRV_DXT_IF_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+
+/* Interface to drv_dxt driver */
+extern void drv_dxt_if_enable_irq(unsigned int irq);
+extern void drv_dxt_if_disable_irq(unsigned int irq);
+
+extern int drv_dxt_if_request_irq(unsigned int irq, irq_handler_t handler,
+			      unsigned long flags, const char *name, void *dev);
+extern void drv_dxt_if_free_irq(unsigned int irq, void *dev);
+
+extern void drv_dxt_if_spi_cs_set(unsigned int dev_no, unsigned int hi_lo);
+extern int drv_dxt_if_spi_ll_read_write(unsigned char *tx_data,
+	    unsigned int tx_size, unsigned char *rx_data, unsigned int rx_size);
+
+/* Internal hooks */
+extern void drv_dxt_if_signal_interrupt(void);
+
+#endif
diff --git a/arch/arm/plat-armada/include/plat/silabs_if.h b/arch/arm/plat-armada/include/plat/silabs_if.h
new file mode 100644
index 0000000..7e2c7d3
--- /dev/null
+++ b/arch/arm/plat-armada/include/plat/silabs_if.h
@@ -0,0 +1,84 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#ifndef __PLAT_SILABS_IF_H
+#define __PLAT_SILABS_IF_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+
+/* Interface to Silabs SLIC driver */
+extern void silabs_if_enable_irq(unsigned int device);
+extern void silabs_if_disable_irq(unsigned int device);
+
+extern void silabs_if_spi_init(unsigned int line);
+extern void silabs_if_spi_read(unsigned int line,
+		unsigned char *cmd, unsigned char cmd_size,
+		unsigned char *data, unsigned char data_size);
+extern void silabs_if_spi_write(unsigned int line,
+		unsigned char *cmd, unsigned char cmd_size,
+		unsigned char *data, unsigned char data_size);
+
+#endif
diff --git a/arch/arm/plat-armada/include/plat/zarlink_if.h b/arch/arm/plat-armada/include/plat/zarlink_if.h
new file mode 100644
index 0000000..f839b3e
--- /dev/null
+++ b/arch/arm/plat-armada/include/plat/zarlink_if.h
@@ -0,0 +1,83 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#ifndef __PLAT_ZARLINK_IF_H
+#define __PLAT_ZARLINK_IF_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+
+/* Interface to Zarlink SLIC driver */
+extern void zarlink_if_enable_irq(unsigned int device);
+extern void zarlink_if_disable_irq(unsigned int device);
+
+extern void zarlink_if_spi_read(unsigned int line,
+		unsigned char *cmd, unsigned char cmd_size,
+		unsigned char *data, unsigned char data_size);
+extern void zarlink_if_spi_write(unsigned int line,
+		unsigned char *cmd, unsigned char cmd_size,
+		unsigned char *data, unsigned char data_size);
+
+#endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig
index b83fe67..21879bd 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig
@@ -4,168 +4,150 @@ menu "Telephony options"
 config  MV_PHONE
 	bool "Support for Marvell telephony(VoIP)"
 	depends on MV_INCLUDE_TDM && PHONE
+	select MV_TDM_USE_DCO if ARCH_AVANTA_LP
 	default y
 	---help---
-	  Choosing this option enables the Marvell telephony underlying
-	  support for various VoIP applications.
-	  Note, kernel Telephony subsystem must be chosen too.
+	Choosing this option enables the Marvell telephony underlying
+	support for various VoIP applications.
+	Note, kernel Telephony subsystem must be chosen too.
+
+config MV_TDM_USE_DCO
+	bool
+	default y
 
 choice
 	prompt "TDM Unit"
 	depends on MV_PHONE
-	default MV_TDM_SUPPORT_ARMADA
+	default MV_TDM_SUPPORT
 
-config MV_TDM_SUPPORT_ARMADA
+config MV_TDM_SUPPORT
 	bool "Support legacy TDM(2 channels)"
-	select MV_TDM_SUPPORT
+	---help---
+	Choosing this option enables Marvell 2CH TDM voice interface.
 
-config MV_COMM_UNIT_SUPPORT_ARMADA
-	depends on ARCH_FEROCEON_KW2 || ARCH_ARMADA_XP
+config MV_COMM_UNIT_SUPPORT
+	depends on ARCH_FEROCEON_KW2
 	bool "Support CommUnit(up to 32 channels)"
-	select MV_COMM_UNIT_SUPPORT
+	---help---
+	Choosing this option enables Marvell 32CH CommUnit voice interface.
 
 endchoice
 
-config MV_TDM_SUPPORT
-	depends on MV_TDM_SUPPORT_ARMADA
-	bool
-
-config MV_COMM_UNIT_SUPPORT
-	depends on MV_COMM_UNIT_SUPPORT_ARMADA
-	bool
-
 choice
 	prompt "SLIC Vendor"
 	depends on MV_PHONE
-	default ZARLINK_SLIC_SUPPORT_ARMADA
+	default ZARLINK_SLIC_SUPPORT
+
+config LANTIQ_SLIC_SUPPORT
+	bool "Support Lantiq devices"
+	---help---
+	Choosing this option enables Lantiq external SLIC device.
 
-#config SILABS_SLIC_SUPPORT_ARMADA
-#	bool "Support Silicon Labs devices"
-#	select SILABS_SLIC_SUPPORT
+config SILABS_SLIC_SUPPORT
+	bool "Support Silicon Labs devices"
+	---help---
+	Choosing this option enables Silabs external SLIC device.
 
-config ZARLINK_SLIC_SUPPORT_ARMADA
+config ZARLINK_SLIC_SUPPORT
 	bool "Support Zarlink/Legirity devices"
-	select ZARLINK_SLIC_SUPPORT
+
 
 endchoice
 
-#config SILABS_SLIC_SUPPORT
-#	depends on SILABS_SLIC_SUPPORT_ARMADA
-#	bool
+choice
+	prompt "SLIC Device"
+	depends on MV_PHONE && LANTIQ_SLIC_SUPPORT
+	default LANTIQ_SLIC_DUSLIC_XT
+
+config LANTIQ_SLIC_DUSLIC_XT
+	bool "Support Lantiq DUSLIC-xT SLIC family"
 
-config ZARLINK_SLIC_SUPPORT
-	depends on ZARLINK_SLIC_SUPPORT_ARMADA
-	bool
+endchoice
 
 choice
 	prompt "SLIC Device"
 	depends on MV_PHONE && SILABS_SLIC_SUPPORT
+	default SILAB_SLIC_EXTERNAL_DRIVER
 
-config SILABS_SLIC_3215
-	bool "Support Silicon Labs 3215 device"
-
-config SILABS_SLIC_3217
-	bool "Support Silicon Labs 3217 device"
+config SILAB_SLIC_EXTERNAL_DRIVER
+	bool "Support Silicon Labs SLIC external driver modules"
 
 endchoice
 
 choice
 	prompt "SLIC Device"
 	depends on MV_PHONE && ZARLINK_SLIC_SUPPORT
-	default ZARLINK_SLIC_VE880_ARMADA
-
-config ZARLINK_SLIC_VE880_ARMADA
-	bool "Support Zarlink VE880 SLIC family"
-	select ZARLINK_SLIC_VE880
+	default ZARLINK_SLIC_EXTERNAL_DRIVER
 
-config ZARLINK_SLIC_VE792_ARMADA
-	bool "Support Zarlink VE792 SLIC family"
-	select ZARLINK_SLIC_VE792
+config ZARLINK_SLIC_EXTERNAL_DRIVER
+	bool "Support Zarlink SLIC external driver modules"
+	---help---
+	Choosing this option enables Zarlink external slic driver support.
 
 endchoice
 
-config ZARLINK_SLIC_VE880
-	depends on ZARLINK_SLIC_VE880_ARMADA
-	bool
-
-config ZARLINK_SLIC_VE792
-	depends on ZARLINK_SLIC_VE792_ARMADA
-	bool
-
 choice
 	prompt "PCM Clock Frequency"
 	depends on MV_PHONE
-	default MV_TDM_PCM_CLK_8MHZ_ARMADA
+	default MV_TDM_PCM_CLK_8MHZ
 	---help---
 	This menu selects the PCM clock frequency generated by the TDM master.
 	SLIC should be configured accordingly in order to maintain bus coherency.
 
-config MV_TDM_PCM_CLK_8MHZ_ARMADA
+config MV_TDM_PCM_CLK_8MHZ
 	bool "Support 8MHz PCM clock"
-	select MV_TDM_PCM_CLK_8MHZ
+	---help---
+	Choosing this option selects 8MHz PCM clock frequency.
 
-config MV_TDM_PCM_CLK_4MHZ_ARMADA
+config MV_TDM_PCM_CLK_4MHZ
 	bool "Support 4MHz PCM clock"
-	select MV_TDM_PCM_CLK_4MHZ
+	---help---
+	Choosing this option selects 4MHz PCM clock frequency.
 
-config MV_TDM_PCM_CLK_2MHZ_ARMADA
+config MV_TDM_PCM_CLK_2MHZ
 	bool "Support 2MHz PCM clock"
-	select MV_TDM_PCM_CLK_2MHZ
+	---help---
+	Choosing this option selects 2MHz PCM clock frequency.
 
 endchoice
 
-config MV_TDM_PCM_CLK_8MHZ
-	depends on MV_TDM_PCM_CLK_8MHZ_ARMADA
-	bool
-
-config MV_TDM_PCM_CLK_4MHZ
-	depends on MV_TDM_PCM_CLK_4MHZ_ARMADA
-	bool
-
-config MV_TDM_PCM_CLK_2MHZ
-	depends on MV_TDM_PCM_CLK_2MHZ_ARMADA
-	bool
-
 choice 
 	prompt "TDM voice processing"
 	depends on MV_PHONE
-	default MV_TDM_DUMMY_ARMADA
+	default MV_TDM_DUMMY
 
-config MV_TDM_DUMMY_ARMADA
+config MV_TDM_DUMMY
 	bool "Support TDM voice processing in softIRQ"
-	select MV_TDM_DUMMY
-
-config MV_PHONE_USE_IRQ_PROCESSING_ARMADA
-	bool "Support Rx/Tx processing in interrupt context"
-	depends on MV_PHONE
-	select MV_PHONE_USE_IRQ_PROCESSING
 	---help---
-	Choosing this option supports Rx/Tx voice processing in interrupt context, otherwise
-	processing is performed in tasklet context.
-
-endchoice
-
-config MV_TDM_DUMMY
-	depends on MV_TDM_DUMMY_ARMADA
-	bool
+	Choosing this option enables TDM voice processing in softIRQ.
 
 config MV_PHONE_USE_IRQ_PROCESSING
-	depends on MV_PHONE_USE_IRQ_PROCESSING_ARMADA
-	bool
+	bool "Support TDM voice processing in IRQ"
+	---help---
+	Choosing this option enables TDM voice processing in IRQ.
 
-config MV_TDM_USE_EXTERNAL_PCLK_SOURCE_ARMADA
-	bool "Support PCLK from external source"
-	depends on MV_PHONE
-	default n
+config MV_PHONE_USE_FIQ_PROCESSING
+	bool "Support TDM voice processing in FIQ"
 	---help---
-	Choosing this option enables TDM unit to use PCLK supplied by external source.
+	Choosing this option enables TDM voice processing in FIQ.
+
+endchoice
 
 config MV_PHONE_USE_SLIC_LIBS
 	bool "Use binary SLIC drivers"
-	depends on MV_PHONE
+	depends on MV_PHONE && !LANTIQ_SLIC_SUPPORT && \
+		   !ZARLINK_SLIC_EXTERNAL_DRIVER && !SILAB_SLIC_EXTERNAL_DRIVER
 	default y
 	---help---
 	Unselect this option only if you have source code of SLIC drivers.
 	If unsure, say "y"
 
+config MV_TDM_EXT_STATS
+	bool "Enable legacy TDM extended statistics"
+	depends on MV_TDM_SUPPORT
+	default n
+	---help---
+	Choosing this option will export extended statistics to procfs.
+	This is relevant only for the legacy TDM unit.
+
 endmenu
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
index 7bbfe78..42f8e33 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
@@ -1,15 +1,17 @@
 
+
 #
 # Makefile for the Marvell Phone Device Driver
 #
 #
 
-ifeq ($(CONFIG_PLAT_ARMADA),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 VB_SRC_PATH = ../../mv_hal/voiceband
 LSP_TDM_PATH = tdm
+LSP_SPI_PATH = spi
 LSP_SLIC_PATH = slic
 LSP_TDM_TEST_PATH = tdm/test
 
@@ -22,90 +24,37 @@ else # CONFIG_MV_COMM_UNIT_SUPPORT
 endif
 
 PHONE_OBJS += $(LSP_TDM_PATH)/tdm_if.o $(LSP_TDM_PATH)/tal.o ../../../../../$(MACHINE)/mv_hal_if/mvSysTdm.o
+PHONE_OBJS += $(LSP_SPI_PATH)/spi_dev.o
 
 EXTRA_CFLAGS += -DMV_KERNEL_SLIC_SUPPORT
 
-# Silabs support
-ifeq ($(CONFIG_SILABS_SLIC_SUPPORT),y)
-
-	SILABS_BASE_PATH = $(VB_SRC_PATH)/slic/silabs/
-	SILABS_SRC_PATH = $(SILABS_BASE_PATH)/src
-	SILABS_CUSTOM_PATH = $(SILABS_BASE_PATH)/custom
-	EXTRA_CFLAGS += -I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/silabs/inc \
-			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/silabs/custom
-
-
-SILABS_OBJS = $(SILABS_SRC_PATH)/proslic.o $(SILABS_SRC_PATH)/proslic_version.o
-
-ifeq ($(CONFIG_SILABS_SLIC_3215),y)
-	SILABS_OBJS += $(SILABS_CUSTOM_PATH)/si321x_constants.o $(SILABS_SRC_PATH)/si321x_intf.o
+# Lantiq support
+ifeq ($(CONFIG_LANTIQ_SLIC_SUPPORT), y)
+	PHONE_OBJS += $(LSP_SLIC_PATH)/drv_dxt_if.o
 endif
 
-ifeq ($(CONFIG_SILABS_SLIC_3217),y)
-	SILABS_OBJS += $(SILABS_SRC_PATH)/si3217x_intf.o $(SILABS_CUSTOM_PATH)/si3217x_patch_B_BB_2009MAY22.o \
-		       $(SILABS_CUSTOM_PATH)/si3217x_BKBT_constants.o  #$(SILABS_CUSTOM_PATH)/si3217x_FLBK_constants.o
+# Silabs support
+ifeq ($(CONFIG_SILABS_SLIC_SUPPORT),y)
+ifeq ($(CONFIG_SILAB_SLIC_EXTERNAL_DRIVER),y)
+PHONE_OBJS += $(LSP_SLIC_PATH)/silabs_if.o
 endif
-
 endif
 
 # Zarlink support
 ifeq ($(CONFIG_ZARLINK_SLIC_SUPPORT),y)
-
-ifeq ($(CONFIG_ZARLINK_SLIC_VE880),y)
-	ZARLINK_BASE_PATH = $(VB_SRC_PATH)/slic/zarlink/api_lib
-	ZARLINK_COMMON_SRC_PATH = $(ZARLINK_BASE_PATH)/common
-	ZARLINK_ARCH_MARVELL_PATH = $(VB_SRC_PATH)/slic/zarlink/arch_marvell
-	ZARLINK_VP880API_SRC_PATH = $(ZARLINK_BASE_PATH)/vp880_api
-
-	EXTRA_CFLAGS += -I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/api_lib/includes \
-			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/arch_marvell \
-			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/api_lib/vp880_api
-
-	ZARLINK_OBJS =  $(ZARLINK_COMMON_SRC_PATH)/vp_api.o  $(ZARLINK_COMMON_SRC_PATH)/vp_api_common.o \
-			$(ZARLINK_COMMON_SRC_PATH)/vp_api_cslac_seq.o $(ZARLINK_COMMON_SRC_PATH)/vp_debug.o \
-			$(ZARLINK_ARCH_MARVELL_PATH)/sys_service.o $(ZARLINK_ARCH_MARVELL_PATH)/vp_hal.o \
-			$(ZARLINK_VP880API_SRC_PATH)/apiCal.o $(ZARLINK_VP880API_SRC_PATH)/apicnt.o \
-			$(ZARLINK_VP880API_SRC_PATH)/apiInit.o $(ZARLINK_VP880API_SRC_PATH)/apiquery.o \
-			$(ZARLINK_VP880API_SRC_PATH)/apiseq.o
-
-	SLIC_LIB_NAME=zarlink_880.lib
-endif
-
-ifeq ($(CONFIG_ZARLINK_SLIC_VE792),y)
-
-	ZARLINK_BASE_PATH = $(VB_SRC_PATH)/slic/zarlink/vp792_api_lib
-	ZARLINK_COMMON_SRC_PATH = $(ZARLINK_BASE_PATH)/common
-	ZARLINK_ARCH_MARVELL_PATH = $(VB_SRC_PATH)/slic/zarlink/arch_marvell
-	ZARLINK_VP792API_SRC_PATH = $(ZARLINK_BASE_PATH)/vp792_api
-
-	EXTRA_CFLAGS += -I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/vp792_api_lib/includes \
-			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/arch_marvell \
-			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/vp792_api_lib/vp792_api
-
-	ZARLINK_OBJS =  $(ZARLINK_COMMON_SRC_PATH)/vp_api_config.o  $(ZARLINK_COMMON_SRC_PATH)/vp_api_common.o \
-			$(ZARLINK_COMMON_SRC_PATH)/vp_api_init.o  $(ZARLINK_COMMON_SRC_PATH)/vp_api_query.o \
-			$(ZARLINK_COMMON_SRC_PATH)/vp_api_control.o $(ZARLINK_COMMON_SRC_PATH)/vp_debug.o \
-			$(ZARLINK_ARCH_MARVELL_PATH)/sys_service.o $(ZARLINK_ARCH_MARVELL_PATH)/vp_hal.o \
-			$(ZARLINK_VP792API_SRC_PATH)/vp792_common.o $(ZARLINK_VP792API_SRC_PATH)/vp792_config.o \
-			$(ZARLINK_VP792API_SRC_PATH)/vp792_control.o $(ZARLINK_VP792API_SRC_PATH)/vp792_init.o \
-			$(ZARLINK_VP792API_SRC_PATH)/vp792_query.o $(ZARLINK_VP792API_SRC_PATH)/vp792_firmware.o \
-			$(ZARLINK_ARCH_MARVELL_PATH)/Le71HP0410G_init.o
-
-	SLIC_LIB_NAME=zarlink_792.lib
-
+ifeq ($(CONFIG_ZARLINK_SLIC_EXTERNAL_DRIVER),y)
+PHONE_OBJS += $(LSP_SLIC_PATH)/zarlink_if.o
 endif
-
-PHONE_OBJS += $(LSP_SLIC_PATH)/vpapi_dev.o
-
 endif
 
+mv_phone-objs := $(PHONE_OBJS)
 ifeq ($(CONFIG_MV_PHONE_USE_SLIC_LIBS),y)
+mv_phone-objs += lib.a
 $(obj)/lib.a:
 	cp $(obj)/$(LSP_SLIC_PATH)/libs/$(SLIC_LIB_NAME) $(obj)/lib.a
+
 else
-	lib-$(CONFIG_ZARLINK_SLIC_SUPPORT) := $(ZARLINK_OBJS) $(SILABS_OBJS)
+	lib-y := $(ZARLINK_OBJS)
 endif
 
 obj-y := mv_phone.o $(LSP_TDM_TEST_PATH)/
-
-mv_phone-objs := $(PHONE_OBJS) lib.a
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/drv_dxt_if.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/drv_dxt_if.c
new file mode 100644
index 0000000..11002c9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/drv_dxt_if.c
@@ -0,0 +1,163 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <plat/drv_dxt_if.h>
+
+#include "voiceband/mvSysTdmSpi.h"
+
+static int drv_dxt_spi_cs;
+static int drv_dxt_irq;
+static int drv_dxt_irq_dev;
+static irq_handler_t drv_dxt_irq_handler;
+
+void
+drv_dxt_if_signal_interrupt(void)
+{
+	if (drv_dxt_irq_handler == NULL)
+		return;
+
+	drv_dxt_irq_handler(drv_dxt_irq, drv_dxt_irq_dev);
+}
+
+void
+drv_dxt_if_enable_irq(unsigned int irq)
+{
+	/* We have only one TDM channel */
+	mvSysTdmIntEnable(0);
+}
+EXPORT_SYMBOL(drv_dxt_if_enable_irq);
+
+void
+drv_dxt_if_disable_irq(unsigned int irq)
+{
+	/* We have only one TDM channel */
+	mvSysTdmIntDisable(0);
+}
+EXPORT_SYMBOL(drv_dxt_if_disable_irq);
+
+int
+drv_dxt_if_request_irq(unsigned int irq, irq_handler_t handler,
+			unsigned long flags, const char *name, void *dev)
+{
+	drv_dxt_irq = irq;
+	drv_dxt_irq_dev = dev;
+	drv_dxt_irq_handler = handler;
+
+	return 0;
+}
+EXPORT_SYMBOL(drv_dxt_if_request_irq);
+
+void
+drv_dxt_if_free_irq(unsigned int irq, void *dev)
+{
+	drv_dxt_irq_handler = NULL;
+}
+EXPORT_SYMBOL(drv_dxt_if_free_irq);
+
+void
+drv_dxt_if_spi_cs_set(unsigned int dev_no, unsigned int hi_lo)
+{
+	if (hi_lo == 0)
+		drv_dxt_spi_cs = dev_no;
+	else
+		drv_dxt_spi_cs = -1;
+}
+EXPORT_SYMBOL(drv_dxt_if_spi_cs_set);
+
+int
+drv_dxt_if_spi_ll_read_write(unsigned char *tx_data, unsigned int tx_size,
+				 unsigned char *rx_data, unsigned int rx_size)
+{
+	uint16_t *ptr;
+	int i;
+
+	if ((tx_size & 1) || (rx_size & 1)) {
+		pr_err("drv_dxt_if: SPI transfer is not word aligned!\n");
+		return 0;
+	}
+
+	ptr = (uint16_t *)tx_data;
+	for (i = 0; i < tx_size / 2; i++, ptr++)
+		*ptr = htons(*ptr);
+
+	if (rx_data != NULL && rx_size != 0) {
+		mvSysTdmSpiRead(drv_dxt_spi_cs, tx_data, tx_size,
+							rx_data, rx_size);
+	} else if (tx_data != NULL && tx_size > 2) {
+		mvSysTdmSpiWrite(drv_dxt_spi_cs, tx_data, 2,
+						tx_data + 2, tx_size - 2);
+	} else {
+		pr_err("drv_dxt_if: Unsupported SPI access mode!\n");
+	}
+
+	ptr = (uint16_t *)rx_data;
+	for (i = 0; i < rx_size / 2; i++, ptr++)
+		*ptr = htons(*ptr);
+
+	return 0;
+}
+EXPORT_SYMBOL(drv_dxt_if_spi_ll_read_write);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/silabs_if.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/silabs_if.c
new file mode 100644
index 0000000..fab0330
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/silabs_if.c
@@ -0,0 +1,120 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <plat/silabs_if.h>
+
+#include "boardEnv/mvBoardEnvLib.h"
+#include "voiceband/mvSysTdmSpi.h"
+#include "spi/mvSpi.h"
+
+void silabs_if_enable_irq(unsigned int device)
+{
+	mvSysTdmIntEnable(device);
+}
+EXPORT_SYMBOL(silabs_if_enable_irq);
+
+void silabs_if_disable_irq(unsigned int device)
+{
+	mvSysTdmIntDisable(device);
+}
+EXPORT_SYMBOL(silabs_if_disable_irq);
+
+void silabs_if_spi_init(unsigned int line)
+{
+	MV_SPI_IF_PARAMS ifParams;
+	MV_SPI_TIMING_PARAMS tmngParams;
+
+	ifParams.clockPolLow = 1;
+	ifParams.clockPhase = SPI_CLK_BEGIN_CYC;
+	ifParams.txMsbFirst = 0;
+	ifParams.rxMsbFirst = 0;
+
+	tmngParams.tcsh = 0x3F;
+	tmngParams.tmisoSample = 0;
+	tmngParams.tcsSetup = 0x4;
+	tmngParams.tcsHold = 0x4;
+
+	mvSpiIfConfigSet(line, &ifParams);
+	mvSpiTimingParamsSet(line, &tmngParams);
+}
+EXPORT_SYMBOL(silabs_if_spi_init);
+
+void silabs_if_spi_read(unsigned int line,
+	unsigned char *cmd, unsigned char cmd_size,
+	unsigned char *data, unsigned char data_size)
+{
+	mvSysTdmSpiRead(line, cmd, cmd_size, data, data_size);
+}
+EXPORT_SYMBOL(silabs_if_spi_read);
+
+void silabs_if_spi_write(unsigned int line,
+	unsigned char *cmd, unsigned char cmd_size,
+	unsigned char *data, unsigned char data_size)
+{
+	mvSysTdmSpiWrite(line, cmd, cmd_size, data, data_size);
+}
+EXPORT_SYMBOL(silabs_if_spi_write);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.c
deleted file mode 100644
index 87add03..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.c
+++ /dev/null
@@ -1,1024 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include <linux/poll.h>
-#include <linux/miscdevice.h>
-#include <linux/slab.h>
-#include <linux/version.h>
-#include "vpapi_dev.h"
-
-/* Defines */
-#define GET_DEV_STATUS(deviceId)	vpapi_dev_status[deviceId]
-#define GET_LINE_STATUS(lineId)		vpapi_line_status[lineId]
-#define REGISTER_DEVICE(deviceId)	\
-	vpapi_dev_status[deviceId] = 1;
-#define REGISTER_LINE(lineId)		\
-	vpapi_line_status[lineId] = 1;
-
-#define MAX_PROFILE_SIZE		128
-#define GET_DEVICE(lineId)		(lineId/MAX_LINES_PER_DEVICE)
-#define GET_LINE(lineId)		(lineId % MAX_LINES_PER_DEVICE)
-#define MAX_EVENT_QUEUE_SIZE		256
-#define VPAPI_TICK_TIMER_PERIOD		1
-#define VPAPI_MOD_NAME                  "vpapi"
-
-/* VE880 */
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-
-#define MAX_DEVICES			2
-#define MAX_LINES			4
-#define MAX_LINES_PER_DEVICE		2
-
-static VpDevCtxType pDevCtx[MAX_DEVICES];
-static VpLineCtxType pLineCtx[MAX_DEVICES][MAX_LINES_PER_DEVICE];
-static Vp880DeviceObjectType pDevObj[MAX_DEVICES];
-static Vp880LineObjectType pLineObj[MAX_DEVICES][MAX_LINES_PER_DEVICE];
-
-/* VE792 */
-#elif defined(CONFIG_ZARLINK_SLIC_VE792)
-
-#define MAX_DEVICES			4
-#define MAX_LINES			32
-#define MAX_LINES_PER_DEVICE		8
-
-static VpDevCtxType pDevCtx[MAX_DEVICES];
-static VpLineCtxType pLineCtx[MAX_DEVICES][MAX_LINES_PER_DEVICE];
-static Vp792DeviceObjectType pDevObj[MAX_DEVICES];
-static Vp792LineObjectType pLineObj[MAX_DEVICES][MAX_LINES_PER_DEVICE];
-
-extern int BattOn(int vbhSetting, int vblSetting, int vbpSetting);
-extern int BattOff(void);
-
-#endif
-
-static void vpapi_tick_handler(unsigned long data);
-static ssize_t vpapi_read(struct file *file, char __user *buf, size_t size, loff_t * ppos);
-static ssize_t vpapi_write(struct file *file, const char __user *buf, size_t size, loff_t * ppos);
-static unsigned int vpapi_poll(struct file *pFile, poll_table *pPollTable);
-static int vpapi_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg);
-#ifdef HAVE_UNLOCKED_IOCTL
-static long vpapi_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
-#endif
-static int vpapi_open(struct inode *pInode, struct file *pFile);
-static int vpapi_release(struct inode *pInode, struct file *pFile);
-//static int __init vpapi_module_init(void);
-//static void __exit vpapi_module_exit(void);
-
-/* VP-API-II Dispatchers */
-static int vpapi_make_dev_object(unsigned long arg);
-static int vpapi_make_line_object(unsigned long arg);
-static int vpapi_map_line_id(unsigned long arg);
-static int vpapi_map_slac_id(unsigned long arg);
-static int vpapi_free_line_context(unsigned long arg);
-static int vpapi_init_device(unsigned long arg);
-static int vpapi_cal_line(unsigned long arg);
-static int vpapi_set_line_state(unsigned long arg);
-static int vpapi_set_option(unsigned long arg);
-int vpapi_get_event(unsigned long arg);
-#if defined(CONFIG_ZARLINK_SLIC_VE792)
-static int vpapi_batt_on(unsigned long arg);
-static int vpapi_batt_off(unsigned long arg);
-#endif
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-static int vpapi_reg_read(unsigned long arg);
-static int vpapi_reg_write(unsigned long arg);
-#endif
-
-/* Enumurators */
-typedef struct {
-	unsigned char valid;		/* valid event */
-	VpEventType vp_event;
-} vpapi_event;
-
-
-/* Structs */
-static struct file_operations vpapi_fops = {
-    owner:      THIS_MODULE,
-    llseek:     NULL,
-    read:       vpapi_read,
-    write:      vpapi_write,
-    poll:       vpapi_poll,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
-    ioctl:	vpapi_ioctl,
-#endif
-#ifdef HAVE_UNLOCKED_IOCTL
-    unlocked_ioctl: vpapi_unlocked_ioctl,
-#endif
-    open:       vpapi_open,
-    release:    vpapi_release,
-    fasync:     NULL
-};
-
-/* Globals */
-static DEFINE_SPINLOCK(vpapi_lock);
-static DECLARE_WAIT_QUEUE_HEAD(vpapi_wait);
-static atomic_t event_count;
-static atomic_t vpapi_init;
-static atomic_t vpapi_in_ioctl;
-static vpapi_event event_queue[MAX_EVENT_QUEUE_SIZE];
-static u8 vpapi_dev_status[MAX_DEVICES];
-static u8 vpapi_line_status[MAX_LINES];
-static volatile u32 next_event = 0, curr_event = 0;
-static struct timer_list vpapi_timer;
-static u16 total_devs = 0, total_lines = 0;
-
-
-static struct miscdevice vpapi_misc_dev = {
-	.minor = SLICDEV_MINOR,
-	.name = VPAPI_MOD_NAME,
-	.fops = &vpapi_fops,
-};
-
-static ssize_t vpapi_read(struct file *file, char __user *buf, size_t size, loff_t * ppos)
-{
-	return 0;
-}
-
-static ssize_t vpapi_write(struct file *file, const char __user *buf, size_t size, loff_t * ppos)
-{
-	return 0;
-}
-
-static unsigned int vpapi_poll(struct file *pFile, poll_table *pPollTable)
-{
-	int mask = 0;
-
-	poll_wait(pFile, &vpapi_wait, pPollTable);
-
-	if(atomic_read(&event_count) > 0) {
-		mask |= POLLPRI;
-	}
-
-	return mask;
-}
-
-static int vpapi_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg)
-{
-	int ret = 0;
-
-	/* Argument checking */
-	if (_IOC_TYPE(cmd) != VPAPI_MOD_IOCTL_MAGIC) {
-		printk("%s: invalid VPAPI MOD Magic Num %i %i\n", __func__, _IOC_TYPE(cmd), VPAPI_MOD_IOCTL_MAGIC);
-		return -ENOTTY;
-	}
-
-	if ((_IOC_NR(cmd) > VPAPI_MOD_IOCTL_MAX) || (_IOC_NR(cmd) < VPAPI_MOD_IOCTL_MIN)) {
-		printk("%s: invalid VPAPI MOD IOCTL request\n", __func__);
-		return -ENOTTY;
-	}
-
-	if (_IOC_DIR(cmd) & _IOC_READ) {
-		ret = !access_ok(VERIFY_WRITE, (void __user*)arg, _IOC_SIZE(cmd));
-	}
-	else if (_IOC_DIR(cmd) & _IOC_WRITE) {
-		ret = !access_ok(VERIFY_READ, (void __user*)arg, _IOC_SIZE(cmd));
-	}
-
-	if (ret) {
-		printk("%s: invalid VPAPI MOD access type %i from cmd %i\n", __func__, _IOC_DIR(cmd), cmd);
-		return -EFAULT;
-	}
-
-#if defined(SLIC_TIMER_EVENT_SUPPORT)
-	/* Disable timer routine processing */
-	atomic_set(&vpapi_in_ioctl, 1);
-#endif
-
-	switch (cmd) {
-		case VPAPI_MOD_IOX_MK_DEV_OBJ:
-			//printk("ioctl: VPAPI_MOD_IOX_MK_DEV_OBJ\n");
-			ret = vpapi_make_dev_object(arg);
-			break;
-
-		case VPAPI_MOD_IOX_MK_LN_OBJ:
-			//printk("ioctl: VPAPI_MOD_IOX_MK_LN_OBJ\n");
-			ret = vpapi_make_line_object(arg);
-			break;
-
-		case VPAPI_MOD_IOX_MAP_LN_ID:
-			//printk("ioctl: VPAPI_MOD_IOX_MAP_LN_ID\n");
-			ret = vpapi_map_line_id(arg);
-			break;
-
-		case VPAPI_MOD_IOX_MAP_SLAC_ID:
-			//printk("ioctl: VPAPI_MOD_IOX_MAP_SLAC_ID\n");
-			ret  = vpapi_map_slac_id(arg);
-			break;
-
-		case VPAPI_MOD_IOX_FREE_LN_CTX:
-			//printk("ioctl: VPAPI_MOD_IOX_FREE_LN_CTX\n");
-			ret = vpapi_free_line_context(arg);
-			break;
-
-		case VPAPI_MOD_IOX_INIT_DEV:
-			//printk("ioctl: VPAPI_MOD_IOX_INIT_DEV\n");
-			ret = vpapi_init_device(arg);
-			break;
-
-		case VPAPI_MOD_IOX_CAL_LN:
-			//printk("ioctl: VPAPI_MOD_IOX_CAL_LN\n");
-			ret = vpapi_cal_line(arg);
-			break;
-
-		case VPAPI_MOD_IOX_SET_LN_ST:
-			//printk("ioctl: VPAPI_MOD_IOX_SET_LN_ST\n");
-			ret = vpapi_set_line_state(arg);
-			break;
-
-		case VPAPI_MOD_IOX_SET_OPTION:
-			//printk("ioctl: VPAPI_MOD_IOX_SET_OPTION\n");
-			ret = vpapi_set_option(arg);
-			break;
-
-		case VPAPI_MOD_IOX_GET_EVENT:
-			//printk("ioctl: VPAPI_MOD_IOX_GET_EVENT\n");
-			ret = vpapi_get_event(arg);
-			break;
-
-#if defined(CONFIG_ZARLINK_SLIC_VE792)
-		case VPAPI_MOD_IOX_BATT_ON:
-			//printk("ioctl: VPAPI_MOD_IOX_BATT_ON\n");
-			ret = vpapi_batt_on(arg);
-			break;
-
-		case VPAPI_MOD_IOX_BATT_OFF:
-			//printk("ioctl: VPAPI_MOD_IOX_BATT_OFF\n");
-			ret = vpapi_batt_off(arg);
-			break;
-#endif
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-		case VPAPI_MOD_IOX_REG_READ:
-			ret = vpapi_reg_read(arg);
-			break;
-
-		case VPAPI_MOD_IOX_REG_WRITE:
-			ret = vpapi_reg_write(arg);
-			break;
-#endif
-		default:
-			printk("%s: error, ioctl command(0x%x) not supported !!!\n", __func__, cmd);
-			ret = -EFAULT;
-			break;
-	}
-
-#if defined(SLIC_TIMER_EVENT_SUPPORT)
-	/* Enable timer routine processing */
-	atomic_set(&vpapi_in_ioctl, 0);
-#endif
-
-	return ret;
-}
-
-#ifdef HAVE_UNLOCKED_IOCTL
-static long
-vpapi_unlocked_ioctl(
-	struct file *filp,
-	unsigned int cmd,
-	unsigned long arg)
-{
-	return vpapi_ioctl(NULL, filp, cmd, arg);
-}
-#endif
-
-static int vpapi_make_dev_object(unsigned long arg)
-{
-	VpApiModMkDevObjType data;
-	VpDeviceType deviceType;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMkDevObjType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	deviceType = data.deviceType;
-	deviceId = data.deviceId;
-
-	data.status = VpMakeDeviceObject(deviceType, deviceId, &pDevCtx[deviceId], &pDevObj[deviceId]);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMkDevObjType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_make_line_object(unsigned long arg)
-{
-	VpApiModMkLnObjType data;
-	VpTermType termType;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMkLnObjType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	termType = data.termType;
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-
-	data.status = VpMakeLineObject(termType, lineId, &pLineCtx[deviceId][lineId],
-				&pLineObj[deviceId][lineId], &pDevCtx[deviceId]);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMkLnObjType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-
-	return 0;
-}
-
-static int vpapi_map_line_id(unsigned long arg)
-{
-	VpApiModMapLnIdType data;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMapLnIdType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-
-	data.status = VpMapLineId(&pLineCtx[deviceId][lineId], data.lineId);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMapLnIdType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_map_slac_id(unsigned long arg)
-{
-	VpApiModMapSlacIdType data;
-	VpDeviceIdType deviceId;
-	u8 slacId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMapSlacIdType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	deviceId = data.deviceId;
-	slacId = data.slacId;
-
-	data.status = VpMapSlacId(&pDevCtx[deviceId], slacId);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMapSlacIdType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-
-}
-
-static int vpapi_free_line_context(unsigned long arg)
-{
-	VpApiModFreeLnCtxType data;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModFreeLnCtxType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-
-	data.status = VpFreeLineCtx(&pLineCtx[deviceId][lineId]);
-
-	if(data.status == VP_STATUS_SUCCESS) {
-		vpapi_line_status[data.lineId] = 0;
-		total_lines--;
-#if defined(SLIC_TIMER_EVENT_SUPPORT)
-		if(total_lines == 0) {
-			atomic_set(&vpapi_init, 0);
-			del_timer(&vpapi_timer);
-		}
-#endif
-	}
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModFreeLnCtxType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_init_device(unsigned long arg)
-{
-	VpApiModInitDeviceType data;
-	VpDeviceIdType deviceId;
-	VpProfileDataType devProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType acProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType dcProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType ringProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType fxoAcProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType fxoCfgProfile[MAX_PROFILE_SIZE];
-	VpProfilePtrType pDevProfile = NULL, pAcProfile = NULL;
-	VpProfilePtrType pDcProfile = NULL, pRingProfile = NULL;
-	VpProfilePtrType pFxoAcProfile = NULL, pFxoCfgProfile = NULL;
-	u16 devProfileSize, acProfileSize, dcProfileSize;
-	u16 ringProfileSize, fxoAcProfileSize, fxoCfgProfileSize;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModInitDeviceType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	deviceId = data.deviceId;
-	devProfileSize = data.devProfileSize;
-	acProfileSize = data.acProfileSize;
-	dcProfileSize = data.dcProfileSize;
-	ringProfileSize = data.ringProfileSize;
-	fxoAcProfileSize = data.fxoAcProfileSize;
-	fxoCfgProfileSize = data.fxoCfgProfileSize;
-
-	if(devProfileSize) {
-		/* Get device profile */
-		if(copy_from_user(devProfile, (void*)data.pDevProfile, (sizeof(VpProfileDataType)*devProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pDevProfile = devProfile;
-	}
-
-	if(acProfileSize) {
-		/* Get AC profile */
-		if(copy_from_user(acProfile, (void*)data.pAcProfile, (sizeof(VpProfileDataType)*acProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pAcProfile = acProfile;
-	}
-
-	if(dcProfileSize) {
-		/* Get DC profile */
-		if(copy_from_user(dcProfile, (void*)data.pDcProfile, (sizeof(VpProfileDataType)*dcProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pDcProfile = dcProfile;
-	}
-
-	if(ringProfileSize) {
-		/* Get ring profile */
-		if(copy_from_user(ringProfile, (void*)data.pRingProfile, (sizeof(VpProfileDataType)*ringProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pRingProfile = ringProfile;
-	}
-
-	if(fxoAcProfileSize) {
-		/* Get FXO AC profile */
-		if(copy_from_user(fxoAcProfile, (void*)data.pFxoAcProfile, (sizeof(VpProfileDataType)*fxoAcProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pFxoAcProfile = fxoAcProfile;
-	}
-
-	if(fxoCfgProfileSize) {
-		/* Get FXO configuration profile */
-		if(copy_from_user(fxoCfgProfile, (void*)data.pFxoCfgProfile,
-					 (sizeof(VpProfileDataType)*fxoCfgProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pFxoCfgProfile = fxoCfgProfile;
-	}
-
-	data.status = VpInitDevice(&pDevCtx[deviceId], pDevProfile, pAcProfile, pDcProfile, pRingProfile,
-					 pFxoAcProfile, pFxoCfgProfile);
-
-	if(data.status == VP_STATUS_SUCCESS) {
-		total_devs++;
-		REGISTER_DEVICE(deviceId);
-
-		if(!atomic_read(&vpapi_init)) {
-#if defined(SLIC_TIMER_EVENT_SUPPORT)
-			memset(&vpapi_timer, 0, sizeof(struct timer_list));
-			init_timer(&vpapi_timer);
-			vpapi_timer.function = vpapi_tick_handler;
-			vpapi_timer.data = -1;
-			vpapi_timer.expires = jiffies + VPAPI_TICK_TIMER_PERIOD;
-			add_timer(&vpapi_timer);
-#endif
-			atomic_set(&vpapi_init, 1);
-		}
-	}
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModInitDeviceType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_cal_line(unsigned long arg)
-{
-	VpApiModCalLnType data;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModCalLnType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-
-	data.status = VpCalLine(&pLineCtx[deviceId][lineId]);
-
-	if(data.status == VP_STATUS_SUCCESS) {
-		total_lines++;
-		REGISTER_LINE(data.lineId);
-	}
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModCalLnType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_set_line_state(unsigned long arg)
-{
-	VpApiModSetLnStType data;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-	VpLineStateType state;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModSetLnStType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-	state = data.state;
-
-	data.status = VpSetLineState(&pLineCtx[deviceId][lineId], state);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModSetLnStType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_set_option(unsigned long arg)
-{
-	VpApiModSetOptionType data;
-	u8 lineRequest;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-	VpOptionIdType option;
-	void *pOptInfo;
-	long size;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModSetOptionType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	option = data.option;
-	lineRequest = data.lineRequest;
-	deviceId = data.deviceId;
-	lineId = GET_LINE(data.lineId);
-
-	switch(option) {
-		case VP_OPTION_ID_TIMESLOT:
-			size = sizeof(VpOptionTimeslotType);
-			pOptInfo = (VpOptionTimeslotType*)kmalloc(size, GFP_KERNEL);
-			break;
-		case VP_OPTION_ID_CODEC:
-			size = sizeof(VpOptionCodecType);
-			pOptInfo = (VpOptionCodecType*)kmalloc(size, GFP_KERNEL);
-			break;
-		case VP_OPTION_ID_LOOPBACK:
-			size = sizeof(VpOptionLoopbackType);
-			pOptInfo = (VpOptionLoopbackType*)kmalloc(size, GFP_KERNEL);
-			break;
-		case VP_OPTION_ID_EVENT_MASK:
-			size = sizeof(VpOptionEventMaskType);
-			pOptInfo = (VpOptionEventMaskType*)kmalloc(size, GFP_KERNEL);
-			break;
-		case VP_OPTION_ID_LINE_STATE:
-			size = sizeof(VpOptionLineStateType);
-			pOptInfo = (VpOptionLineStateType*)kmalloc(size, GFP_KERNEL);
-			break;
-		default:
-			printk("%s: option(%d) not supported\n",__func__, option);
-			return -EFAULT;
-	}
-
-	/* Get option info */
-	if(copy_from_user(pOptInfo, (void*)data.pValue, size)) {
-			printk("%s: copy_from_user failed\n", __func__);
-			kfree(pOptInfo);
-			return -EFAULT;
-	}
-
-	/* Set option to line/device */
-	if(lineRequest)
-		data.status = VpSetOption(&pLineCtx[deviceId][lineId], VP_NULL, option, pOptInfo);
-	else
-		data.status = VpSetOption(VP_NULL, &pDevCtx[deviceId], option, pOptInfo);
-
-
-	kfree(pOptInfo);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModSetOptionType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-int vpapi_get_event(unsigned long arg)
-{
-	VpApiModGetEventType data;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModGetEventType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	deviceId = data.deviceId;
-
-	if(atomic_read(&event_count) == 0) {
-		data.newEvent = FALSE;
-	}
-	else {
-		/* Copy event info back to user */
-		if(copy_to_user(data.pEvent, &event_queue[curr_event].vp_event, sizeof(VpEventType))) {
-			printk("%s: copy_to_user failed\n", __func__);
-			return  -EFAULT;
-		}
-
-		event_queue[curr_event].valid = 0;
-		data.newEvent = TRUE;
-		atomic_dec(&event_count);
-		curr_event++;
-		if(curr_event == MAX_EVENT_QUEUE_SIZE)
-			curr_event = 0;
-	}
-
-	/* Copy status and event info back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModGetEventType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-#if defined(CONFIG_ZARLINK_SLIC_VE792)
-static int vpapi_batt_on(unsigned long arg)
-{
-	VpModBatteryOnType data;
-	int vbh, vbl, vbp;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpModBatteryOnType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	vbh = data.vbh;
-	vbl = data.vbl;
-	vbp = data.vbp;
-
-	data.status = BattOn(vbh, vbl, vbp);
-
-	/* Copy status and event info back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpModBatteryOnType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_batt_off(unsigned long arg)
-{
-	VpModBatteryOffType data;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpModBatteryOffType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	data.status = BattOff();
-
-	/* Copy status and event info back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpModBatteryOffType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-#endif
-
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-static int vpapi_reg_read(unsigned long arg)
-{
-	VpModRegOpType data;
-	VpLineIdType	line_id;
-	unsigned char	cmd;
-	unsigned short  cmd_len;
-	unsigned char *buff_p = NULL;
-	unsigned char ec_val[] = {0x1, 0x2};
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpModRegOpType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	line_id = data.lineId;
-	cmd = data.cmd;
-	cmd_len = data.cmdLen;
-	buff_p = data.buff;
-
-	VpMpiCmd(GET_DEVICE(line_id), ec_val[GET_LINE(line_id)], (cmd | 1), cmd_len, buff_p);
-
-	/* Copy status and event info back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpModRegOpType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_reg_write(unsigned long arg)
-{
-	VpModRegOpType data;
-	VpLineIdType	line_id;
-	unsigned char	cmd;
-	unsigned short  cmd_len;
-	unsigned char *buff_p = NULL;
-	unsigned char ec_val[] = {0x1, 0x2};
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpModRegOpType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	line_id = data.lineId;
-	cmd = data.cmd;
-	cmd_len = data.cmdLen;
-	buff_p = data.buff;
-
-	VpMpiCmd(GET_DEVICE(line_id), ec_val[GET_LINE(line_id)], cmd, cmd_len, buff_p);
-
-	return 0;
-}
-#endif
-
-static int vpapi_open(struct inode *pInode, struct file *pFile)
-{
-	try_module_get(THIS_MODULE);
-	return 0;
-}
-
-static int vpapi_release(struct inode *pInode, struct file *pFile)
-{
-	module_put(THIS_MODULE);
-	return 0;
-}
-
-#if defined(SLIC_TIMER_EVENT_SUPPORT)
-static void vpapi_tick_handler(unsigned long data)
-{
-	u8 deviceId;
-	unsigned long flags;
-	vpapi_event *pEvent;
-#if !defined(CONFIG_ZARLINK_SLIC_VE792)
-	bool eventStatus;
-#endif
-
-	/* Check if events are already active and not processing IOCTL */
-	if((atomic_read(&vpapi_init) == 0) || (atomic_read(&vpapi_in_ioctl) == 1))
-		goto timer_exit;
-
-	spin_lock_irqsave(&vpapi_lock, flags);
-
-	for(deviceId = 0; deviceId < MAX_DEVICES; deviceId++) {
-
-		if(GET_DEV_STATUS(deviceId) == 0)
-			continue;
-
-		/* Check for free resources */
-		if(atomic_read(&event_count) >= MAX_EVENT_QUEUE_SIZE)
-			goto timer_exit;
-
-#if !defined(CONFIG_ZARLINK_SLIC_VE792)
-		if(VP_STATUS_SUCCESS == VpApiTick(&pDevCtx[deviceId], &eventStatus)) {
-			if(eventStatus == TRUE) {
-#endif
-				pEvent = &event_queue[next_event];
-				while(VpGetEvent(&pDevCtx[deviceId], &pEvent->vp_event) == TRUE) {
-					if(pEvent->vp_event.status != VP_STATUS_SUCCESS) {
-						printk("%s: bad status(%d)\n", __func__, pEvent->vp_event.status);
-						break;
-					}
-
-					if(pEvent->vp_event.eventId == 0)  {
-						printk("%s: warning, empty event\n", __func__);
-						break;
-					}
-
-					next_event++;
-					if(next_event == MAX_EVENT_QUEUE_SIZE) {
-						next_event = 0;
-					}
-
-					atomic_inc(&event_count);
-
-					if(pEvent->valid == 0) {
-						pEvent->valid = 1;
-					}
-					else {
-						printk("%s: error, event(%u) was overrided\n", __func__, next_event);
-						break;
-					}
-
-					pEvent = &event_queue[next_event];
-				}
-#if !defined(CONFIG_ZARLINK_SLIC_VE792)
-			}
-		}
-#endif
-	}
-
-
-	spin_unlock_irqrestore(&vpapi_lock, flags);
-
-timer_exit:
-
-	/* Checks if user application should be signaled */
-	if(atomic_read(&event_count) > 0) {
-		wake_up_interruptible(&vpapi_wait);
-	}
-
-	/* Schedule next timer tick */
-	vpapi_timer.expires = jiffies + VPAPI_TICK_TIMER_PERIOD;
-	add_timer(&vpapi_timer);
-}
-#endif
-
-int __init vpapi_module_init(void)
-{
-	int status;
-
-	printk("Loading Marvell %s device\n", VPAPI_MOD_NAME);
-	status = misc_register(&vpapi_misc_dev);
-
-	/* Register VPAPI device module */
-	if (status < 0) {
-		printk("Error, failed to load %s module(%d)\n", VPAPI_MOD_NAME, status);
-		return status;
-	}
-
-	atomic_set(&vpapi_init, 0);
-	atomic_set(&vpapi_in_ioctl, 0);
-	total_devs = 0;
-	total_lines = 0;
-	next_event = 0;
-	curr_event = 0;
-	memset(vpapi_dev_status, 0, MAX_DEVICES);
-	memset(vpapi_line_status, 0, MAX_LINES);
-
-	/* Reset event counter */
-	atomic_set(&event_count, 0);
-
-	/* Clear event queue */
-	memset(event_queue, 0, (MAX_EVENT_QUEUE_SIZE * sizeof(vpapi_event)));
-
-	return 0;
-}
-
-void __exit vpapi_module_exit(void)
-{
-	printk("Unloading %s device module\n", VPAPI_MOD_NAME);
-
-#if defined(SLIC_TIMER_EVENT_SUPPORT)
-	if(total_lines == 0)
-		del_timer(&vpapi_timer);
-#endif
-
-	/* Unregister VPAPI misc device */
-	misc_deregister(&vpapi_misc_dev);
-
-	return;
-}
-
-/* Module stuff */
-module_init(vpapi_module_init);
-module_exit(vpapi_module_exit);
-MODULE_DESCRIPTION("Zarlink VPAPI-II Device");
-MODULE_AUTHOR("Eran Ben-Avi <benavi@marvell.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.h
deleted file mode 100644
index 18c2d9c..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.h
+++ /dev/null
@@ -1,265 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef _VPAPI_DEV_H_
-#define _VPAPI_DEV_H_
-
-#include "vp_api_common.h"
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-#include "vp880_api.h"
-#elif defined(CONFIG_ZARLINK_SLIC_VE792)
-#include "vp792_api.h"
-#endif
-
-#define VPAPI_MOD_IOCTL_MAGIC           'z'
-
-#define VPAPI_MOD_IOCTL_MIN 		1
-
-/* VP-API System Configuration Functions */
-#define VPAPI_MOD_IOX_MK_DEV_OBJ	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 1, VpApiModMkDevObjType)
-#define VPAPI_MOD_IOX_MK_LN_OBJ		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 2, VpApiModMkLnObjType)
-#define VPAPI_MOD_IOX_MAP_LN_ID		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 3, VpApiModMapLnIdType)
-#define VPAPI_MOD_IOX_MAP_SLAC_ID	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 4, VpApiModMapSlacIdType)
-#define VPAPI_MOD_IOX_FREE_LN_CTX	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 5, VpApiModFreeLnCtxType)
-
-/* VP-API Initialization Functions */
-#define VPAPI_MOD_IOX_INIT_DEV		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 6, VpApiModInitDeviceType)
-#define VPAPI_MOD_IOX_CAL_LN		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 7, VpApiModCalLnType)
-
-/* VP-API Control Functions */
-#define VPAPI_MOD_IOX_SET_LN_ST		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 8, VpApiModSetLnStType)
-#define VPAPI_MOD_IOX_SET_OPTION	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 9, VpApiModSetOptionType)
-
-/* VP-API Status and Query Functions */
-#define VPAPI_MOD_IOX_GET_EVENT		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 10, VpApiModGetEventType)
-
-/* VE792 Battery Control */
-#define VPAPI_MOD_IOX_BATT_ON		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 11, VpModBatteryOnType)
-#define VPAPI_MOD_IOX_BATT_OFF		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 12, VpModBatteryOffType)
-
-/* SLIC register read/write */
-#define VPAPI_MOD_IOX_REG_READ		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 13, VpModRegOpType)
-#define VPAPI_MOD_IOX_REG_WRITE		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 14, VpModRegOpType)
-
-#define VPAPI_MOD_IOCTL_MAX 		14
-#define MAX_SLIC_RDWR_BUFF_SIZE		128
-
-
-/******************** VP-API System Configuration Structs *********************/
-typedef struct VpApiModMkDevObj {
-	/* Input arg(s) */
-	VpDeviceType	deviceType;
-	VpDeviceIdType	deviceId;
-
-	/* Output arg(s) */
-	VpStatusType		status;
-} VpApiModMkDevObjType;
-
-
-typedef struct VpApiModMkLnObj {
-	/* Input arg(s) */
-	VpTermType	termType;
-	VpLineIdType	lineId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModMkLnObjType;
-
-typedef struct VpApiModMapLnId {
-	/* Input arg(s) */
-	VpLineIdType	lineId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModMapLnIdType;
-
-typedef struct VpApiModMapSlacId {
-	/* Input arg(s) */
-	VpDeviceIdType	deviceId;
-	unsigned char	slacId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModMapSlacIdType;
-
-typedef struct VpApiModFreeLnCtx {
-	/* Input arg(s) */
-	VpLineIdType	lineId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModFreeLnCtxType;
-
-
-/************************ VP-API Initialization Structs ************************/
-typedef struct VpApiModInitDevice {
-	/* Input arg(s) */
-	VpDeviceIdType		deviceId;
-	VpProfilePtrType	pDevProfile;
-	VpProfilePtrType	pAcProfile;
-	VpProfilePtrType	pDcProfile;
-	VpProfilePtrType	pRingProfile;
-	VpProfilePtrType	pFxoAcProfile;
-	VpProfilePtrType	pFxoCfgProfile;
-	unsigned short		devProfileSize;
-	unsigned short		acProfileSize;
-	unsigned short		dcProfileSize;
-	unsigned short		ringProfileSize;
-	unsigned short		fxoAcProfileSize;
-	unsigned short		fxoCfgProfileSize;
-
-	/* Output arg(s) */
-	VpStatusType		status;
-} VpApiModInitDeviceType;
-
-typedef struct VpApiModCalLn {
-	/* Input arg(s) */
-	VpLineIdType	lineId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModCalLnType;
-
-
-/****************************VP-API Control Structs ***************************/
-typedef struct VpApiModSetLnSt {
-	/* Input arg(s) */
-	VpLineIdType	lineId;
-	VpLineStateType	state;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModSetLnStType;
-
-
-typedef struct VpApiModSetOption {
-	/* Input arg(s) */
-	unsigned char	lineRequest;
-	VpLineIdType	lineId;
-	VpDeviceIdType	deviceId;
-	VpOptionIdType	option;
-	void		*pValue;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModSetOptionType;
-
-#if 0
-typedef struct VpApiModLowLvlCmd {
-	/* Input arg(s) */
-	const VpModLineRegNumType	lineRegNum;
-	uint8				*pCmdData;
-	const uint8			len;
-	const uint16			handle;
-
-	/* Output arg(s) */
-	VpStatusType			status;
-} VpApiModLowLvlCmdType;
-#endif
-
-/********************** VP-API Status and Query Structs ***********************/
-typedef struct VpApiModGetEvent {
-	/* Input arg(s) */
-	VpDeviceIdType	deviceId;
-
-	/* Output arg(s) */
-	bool		newEvent;
-	VpEventType	*pEvent;
-} VpApiModGetEventType;
-
-/********************** VE792 Battery Control ***********************/
-typedef struct VpModBatteryOn {
-	/* Input arg(s) */
-	int	vbh;
-	int	vbl;
-	int	vbp;
-
-	/* Output arg(s) */
-	int	status;
-} VpModBatteryOnType;
-
-typedef struct VpModBatteryOff {
-
-	/* Output arg(s) */
-	int	status;
-} VpModBatteryOffType;
-
-/********************** SLIC register read/write ********************/
-typedef struct VpModRegOp {
-	/* Input arg(s) */
-	VpLineIdType	lineId;
-	unsigned char	cmd;
-	unsigned short  cmdLen;
-	unsigned char buff[MAX_SLIC_RDWR_BUFF_SIZE];
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpModRegOpType;
-
-/* APIs */
-int vpapi_module_init(void);
-void vpapi_module_exit(void);
-
-
-#endif /*_VPAPI_DEV_H_*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/zarlink_if.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/zarlink_if.c
new file mode 100644
index 0000000..3ebb364
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/zarlink_if.c
@@ -0,0 +1,98 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <plat/zarlink_if.h>
+
+#include "voiceband/mvSysTdmSpi.h"
+
+void zarlink_if_enable_irq(unsigned int device)
+{
+	mvSysTdmIntEnable(device);
+}
+EXPORT_SYMBOL(zarlink_if_enable_irq);
+
+void zarlink_if_disable_irq(unsigned int device)
+{
+	mvSysTdmIntDisable(device);
+}
+EXPORT_SYMBOL(zarlink_if_disable_irq);
+
+void zarlink_if_spi_read(unsigned int line,
+	unsigned char *cmd, unsigned char cmd_size,
+	unsigned char *data, unsigned char data_size)
+{
+	mvSysTdmSpiRead(line, cmd, cmd_size, data, data_size);
+}
+EXPORT_SYMBOL(zarlink_if_spi_read);
+
+void zarlink_if_spi_write(unsigned int line,
+	unsigned char *cmd, unsigned char cmd_size,
+	unsigned char *data, unsigned char data_size)
+{
+	mvSysTdmSpiWrite(line, cmd, cmd_size, data, data_size);
+}
+EXPORT_SYMBOL(zarlink_if_spi_write);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/spi/spi_dev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/spi/spi_dev.c
new file mode 100644
index 0000000..f684468
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/spi/spi_dev.c
@@ -0,0 +1,259 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include "spi_dev.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "voiceband/mvSysTdmSpi.h"
+
+/* Defines */
+#define SPI_MOD_NAME				"spi"
+
+static ssize_t spi_read(struct file *file, char __user *buf, size_t size, loff_t *ppos);
+static ssize_t spi_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos);
+static unsigned int spi_poll(struct file *pFile, poll_table *pPollTable);
+static int spi_ioctl(struct file *pFile, unsigned int cmd, unsigned long arg);
+static int spi_open(struct inode *pInode, struct file *pFile);
+static int spi_release(struct inode *pInode, struct file *pFile);
+
+/* SPI-API Dispatchers */
+static int spi_read_reg(unsigned long arg);
+static int spi_write_reg(unsigned long arg);
+
+/* Structs */
+static const struct file_operations spi_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= NULL,
+	.read		= spi_read,
+	.write		= spi_write,
+	.poll		= spi_poll,
+	.unlocked_ioctl	= spi_ioctl,
+	.open		= spi_open,
+	.release	= spi_release,
+	.fasync		= NULL
+};
+
+/* Globals */
+static struct miscdevice spi_misc_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = SPI_MOD_NAME,
+	.fops = &spi_fops,
+};
+
+static ssize_t spi_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
+{
+	return 0;
+}
+
+static ssize_t spi_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos)
+{
+	return 0;
+}
+
+static unsigned int spi_poll(struct file *pFile, poll_table *pPollTable)
+{
+	return 0;
+}
+
+static int spi_ioctl(struct file *pFile, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	/* Argument checking */
+	if (_IOC_TYPE(cmd) != SPI_MOD_IOCTL_MAGIC) {
+		printk(KERN_ERR "%s: invalid SPI MOD Magic Num %i %i\n", __func__, _IOC_TYPE(cmd), SPI_MOD_IOCTL_MAGIC);
+		return -ENOTTY;
+	}
+
+	if ((_IOC_NR(cmd) > SPI_MOD_IOCTL_MAX) || (_IOC_NR(cmd) < SPI_MOD_IOCTL_MIN)) {
+		printk(KERN_ERR "%s: invalid SPI MOD IOCTL request\n", __func__);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if (ret) {
+		printk(KERN_ERR "%s: invalid SPI MOD access type %i from cmd %i\n", __func__, _IOC_DIR(cmd), cmd);
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case SPI_MOD_IOX_REG_READ:
+		/*printk("ioctl: SPI_MOD_IOX_REG_READ\n");*/
+		ret = spi_read_reg(arg);
+		break;
+
+	case SPI_MOD_IOX_REG_WRITE:
+		/*printk("ioctl: SPI_MOD_IOX_REG_WRITE\n");*/
+		ret = spi_write_reg(arg);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: error, ioctl command(0x%x) not supported !!!\n", __func__, cmd);
+		ret = -EFAULT;
+		break;
+	}
+
+	return ret;
+}
+
+static int spi_read_reg(unsigned long arg)
+{
+	SpiModRWObjType data;
+
+	/* Get user data */
+	if (copy_from_user(&data, (void *)arg, sizeof(SpiModRWObjType))) {
+		printk(KERN_ERR "%s: copy_from_user failed\n", __func__);
+		return -EFAULT;
+	}
+
+	mvSysTdmIntDisable(data.lineId);
+
+	mvSysTdmSpiRead(data.lineId, data.pCmdBuff, data.cmdSize, data.pDataBuff, data.dataSize);
+
+	mvSysTdmIntEnable(data.lineId);
+
+	/* Copy status back to user */
+	if (copy_to_user((void *)arg, &data, sizeof(SpiModRWObjType))) {
+		printk(KERN_ERR "%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int spi_write_reg(unsigned long arg)
+{
+	SpiModRWObjType data;
+
+	/* Get user data */
+	if (copy_from_user(&data, (void *)arg, sizeof(SpiModRWObjType))) {
+		printk(KERN_ERR "%s: copy_from_user failed\n", __func__);
+		return -EFAULT;
+	}
+
+	mvSysTdmIntDisable(data.lineId);
+
+	mvSysTdmSpiWrite(data.lineId, data.pCmdBuff, data.cmdSize, data.pDataBuff, data.dataSize);
+
+	mvSysTdmIntEnable(data.lineId);
+
+	/* Copy status back to user */
+	if (copy_to_user((void *)arg, &data, sizeof(SpiModRWObjType))) {
+		printk(KERN_ERR "%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int spi_open(struct inode *pInode, struct file *pFile)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int spi_release(struct inode *pInode, struct file *pFile)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+int __init spi_module_init(void)
+{
+	int status = 0;
+
+	printk(KERN_INFO "Loading Marvell %s device\n", SPI_MOD_NAME);
+
+	status = misc_register(&spi_misc_dev);
+
+	/* Register SPI device module */
+	if (status < 0) {
+		printk(KERN_ERR "Error, failed to load %s module(%d)\n", SPI_MOD_NAME, status);
+		return status;
+	}
+	return 0;
+}
+
+void __exit spi_module_exit(void)
+{
+	printk(KERN_INFO "Unloading %s device module\n", SPI_MOD_NAME);
+
+	/* Unregister SPI misc device */
+	misc_deregister(&spi_misc_dev);
+
+	return;
+}
+
+/* Module stuff */
+module_init(spi_module_init);
+module_exit(spi_module_exit);
+MODULE_DESCRIPTION("SPI Access Device");
+MODULE_AUTHOR("Nadav Haklai <nadavh@marvell.com>");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/spi/spi_dev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/spi/spi_dev.h
new file mode 100644
index 0000000..b91f3ac
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/spi/spi_dev.h
@@ -0,0 +1,94 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _SPI_DEV_H_
+#define _SPI_DEV_H_
+
+
+#define SPI_MOD_IOCTL_MAGIC	'z'
+
+#define SPI_MOD_IOCTL_MIN	1
+
+/* SI-API System Configuration Functions */
+#define SPI_MOD_IOX_REG_READ	_IOWR(SPI_MOD_IOCTL_MAGIC, 1, SpiModRWObjType)
+#define SPI_MOD_IOX_REG_WRITE	_IOWR(SPI_MOD_IOCTL_MAGIC, 2, SpiModRWObjType)
+
+#define SPI_MOD_IOCTL_MAX	2
+
+/********************** SPI register read/write ********************/
+typedef struct SpiModRWObj {
+	/* Input arg(s) */
+	unsigned short	lineId;
+	unsigned char	*pCmdBuff;
+	unsigned char	cmdSize;
+	unsigned char	*pDataBuff;
+	unsigned char	dataSize;
+} SpiModRWObjType;
+
+/* APIs */
+int spi_module_init(void);
+void spi_module_exit(void);
+
+
+#endif /*_SPI_DEV_H_*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.c
deleted file mode 100644
index d88c4b7..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.c
+++ /dev/null
@@ -1,157 +0,0 @@
-
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************/
-
-/* Marvell Telephony Adaptation Layer */
-
-#include "tal.h"
-#include "tdm_if.h"
-
-/* GLobals */
-static tdm_if_register_ops_t tal_tdm_if_register_ops;
-static tal_mmp_ops_t* tal_mmp_ops;
-static tdm_if_params_t tal_tdm_if_params;
- 
-/* Static APIs */
-static void tal_pcm_tx_callback(uint8_t* tx_buff, int size);
-static void tal_pcm_rx_callback(uint8_t* rx_buff, int size);
-
-/*---------------------------------------------------------------------------*
- * tal_init
- * Issue telephony subsytem initialization and callbacks registration
- *---------------------------------------------------------------------------*/
-tal_stat_t tal_init(tal_params_t* tal_params, tal_mmp_ops_t* mmp_ops)
-{
-	if((tal_params == NULL) || (mmp_ops == NULL))
-	{
-		mvOsPrintf("%s: Error, bad parameters\n",__FUNCTION__);
-		return TAL_STAT_BAD_PARAM;
-	}
-
-	if(mmp_ops->tal_mmp_rx_callback == NULL ||
-	   mmp_ops->tal_mmp_tx_callback == NULL) 
-	{
-		mvOsPrintf("%s:Error, missing callbacks(MMP)\n",__FUNCTION__);
-		return TAL_STAT_BAD_PARAM;
-	}
-
-	/* Convert tal_params to tdm_if_params */
-	memcpy(&tal_tdm_if_params, tal_params, sizeof(tal_params_t));
-
-	/* Assign MMP operations */
-	tal_mmp_ops = mmp_ops;
-
-	/* Clear tdm_if operations structure */
-	memset(&tal_tdm_if_register_ops, 0, sizeof(tdm_if_register_ops_t));
-	
-	/* Assign tdm_if operations */
-	tal_tdm_if_register_ops.tdm_if_pcm_ops.pcm_tx_callback = tal_pcm_tx_callback;
-	tal_tdm_if_register_ops.tdm_if_pcm_ops.pcm_rx_callback = tal_pcm_rx_callback;
-
-	/* Dispatch tdm_if driver */
-	if(tdm_if_init(&tal_tdm_if_register_ops, &tal_tdm_if_params) != MV_OK)
-	{
-		mvOsPrintf("%s: Error, could not initialize tdm_if driver !!!\n",__FUNCTION__);
-		return TAL_STAT_INIT_ERROR;
-	}
-
-	/* Verify control callbacks were assigned properly */
-	if(tal_tdm_if_register_ops.tdm_if_ctl_ops.ctl_pcm_start == NULL ||
-	   tal_tdm_if_register_ops.tdm_if_ctl_ops.ctl_pcm_stop == NULL)
-	{
-		mvOsPrintf("%s:Error, missing callbacks(tdm_if)\n",__FUNCTION__);
-		return TAL_STAT_BAD_PARAM;
-	}
-
-	return TAL_STAT_OK;
-}
-
-
-/*---------------------------------------------------------------------------*
- * tal_pcm_tx_completion
- * Tx callback
- *---------------------------------------------------------------------------*/
-
-static void tal_pcm_tx_callback(uint8_t* tx_buff, int size)
-{
-	tal_mmp_ops->tal_mmp_tx_callback(tx_buff, size);
-}
-
-/*---------------------------------------------------------------------------*
- * tal_pcm_rx_completion
- * Rx callback
- *---------------------------------------------------------------------------*/
-
-static void tal_pcm_rx_callback(uint8_t* rx_buff, int size)
-{
-	tal_mmp_ops->tal_mmp_rx_callback(rx_buff, size);
-}
-
-/*---------------------------------------------------------------------------*
- * tal_pcm_start
- * Start PCM bus
- *---------------------------------------------------------------------------*/
-tal_stat_t tal_pcm_start(void)
-{
-	tal_tdm_if_register_ops.tdm_if_ctl_ops.ctl_pcm_start();
-	return TAL_STAT_OK;
-}
-
-/*---------------------------------------------------------------------------*
- * tal_pcm_stop
- * Stop PCM bus
- *---------------------------------------------------------------------------*/
-tal_stat_t tal_pcm_stop(void)
-{
-	tal_tdm_if_register_ops.tdm_if_ctl_ops.ctl_pcm_stop();
-	return TAL_STAT_OK;
-}
-
-/*---------------------------------------------------------------------------*
- * tal_exit
- * Stop TDM channels and release all resources
- *---------------------------------------------------------------------------*/
-tal_stat_t tal_exit(void)
-{
-	tdm_if_exit();
-	return TAL_STAT_OK;
-}
-
-/*---------------------------------------------------------------------------*
- * tal_stats_get
- * Get TDM statistics
- *---------------------------------------------------------------------------*/
-tal_stat_t tal_stats_get(tal_stats_t* tal_stats)
-{
-	tdm_if_stats_t stats;
-
-	tdm_if_stats_get(&stats);
-	memcpy(&stats, tal_stats, sizeof(tal_stats_t));
-
-	return TAL_STAT_OK;
-}
-
-
-
-/* EXPORTS */
-EXPORT_SYMBOL(tal_init);
-EXPORT_SYMBOL(tal_pcm_start);
-EXPORT_SYMBOL(tal_pcm_stop);
-EXPORT_SYMBOL(tal_exit);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.h
deleted file mode 100644
index ea8a112..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tal.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************/
-
-/* Marvell Telephony Adaptation Layer */
-
-#ifndef _TAL_H_
-#define _TAL_H_
-
-#include "mvOs.h" /* for kernel abstraction wrappers */
-
-/* Defines */
-#define TAL_MAX_PHONE_LINES	32
-
-/* Enumerators */
-typedef enum {
-	TAL_PCM_FORMAT_1BYTE = 1,
-	TAL_PCM_FORMAT_2BYTES = 2,
-	TAL_PCM_FORMAT_4BYTES = 4
-} tal_pcm_format_t;
-
-typedef enum {
-	TAL_STAT_OK = 0,
-	TAL_STAT_BAD_PARAM,
-	TAL_STAT_INIT_ERROR
-} tal_stat_t;
-
-/* Structures */
-typedef struct {
-	tal_pcm_format_t pcm_format;
-	unsigned short pcm_slot[TAL_MAX_PHONE_LINES];
-	unsigned char sampling_period;
-	unsigned short total_lines;
-} tal_params_t;
-
-typedef struct {
-	int tdm_init;
-	unsigned int rx_overrun;
-	unsigned int tx_underrun;
-} tal_stats_t;
-
-typedef struct {
-	void (*tal_mmp_rx_callback)(unsigned char* rx_buff, int size);
-	void (*tal_mmp_tx_callback)(unsigned char* tx_buff, int size);
-} tal_mmp_ops_t;
-
-/* APIs */
-tal_stat_t tal_init(tal_params_t* tal_params, tal_mmp_ops_t* mmp_ops);
-tal_stat_t tal_stats_get(tal_stats_t* tal_stats);
-tal_stat_t tal_pcm_start(void);
-tal_stat_t tal_pcm_stop(void);
-tal_stat_t tal_exit(void);
-
-#endif /* _TAL_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c
index 27aba8e..de2e45c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c
@@ -148,11 +148,31 @@ tal_stat_t tal_stats_get(tal_stats_t* tal_stats)
 	return TAL_STAT_OK;
 }
 
+/*---------------------------------------------------------------------------*
+ * tal_tdm_clk_config
+ * Config TDM clock
+ *---------------------------------------------------------------------------*/
+void tal_tdm_clk_config(void)
+{
+	mvCtrlTdmClkCtrlConfig();
+}
 
+#if defined(MV_TDM_USE_DCO)
+/*---------------------------------------------------------------------------*
+ * tal_tdm_clk_get
+ * Get current TDM clock correction
+ *---------------------------------------------------------------------------*/
+int tal_tdm_clk_get(void)
+{
+	return mvCtrlTdmClkCtrlGet();
+}
 
-/* EXPORTS */
-EXPORT_SYMBOL(tal_init);
-EXPORT_SYMBOL(tal_pcm_start);
-EXPORT_SYMBOL(tal_pcm_stop);
-EXPORT_SYMBOL(tal_exit);
-EXPORT_SYMBOL(tal_stats_get);
+/*---------------------------------------------------------------------------*
+ * tal_tdm_clk_set
+ * Set TDM clock correction
+ *---------------------------------------------------------------------------*/
+void tal_tdm_clk_set(int correction)
+{
+	return mvCtrlTdmClkCtrlSet(correction);
+}
+#endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h
index 4216bc9..5c7005b 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h
@@ -56,6 +56,9 @@ typedef struct {
 	unsigned int tx_miss;
 	unsigned int rx_over;
 	unsigned int tx_under;
+#ifdef MV_TDM_EXT_STATS
+	MV_TDM_EXTENDED_STATS tdm_ext_stats;
+#endif
 } tal_stats_t;
 
 typedef struct {
@@ -64,10 +67,15 @@ typedef struct {
 } tal_mmp_ops_t;
 
 /* APIs */
-tal_stat_t tal_init(tal_params_t* tal_params, tal_mmp_ops_t* mmp_ops);
-tal_stat_t tal_stats_get(tal_stats_t* tal_stats);
-tal_stat_t tal_pcm_start(void);
-tal_stat_t tal_pcm_stop(void);
-tal_stat_t tal_exit(void);
+extern tal_stat_t tal_init(tal_params_t *tal_params, tal_mmp_ops_t *mmp_ops);
+extern tal_stat_t tal_stats_get(tal_stats_t *tal_stats);
+extern tal_stat_t tal_pcm_start(void);
+extern tal_stat_t tal_pcm_stop(void);
+extern tal_stat_t tal_exit(void);
+extern void tal_tdm_clk_config(void);
+#if defined(MV_TDM_USE_DCO)
+extern int tal_tdm_clk_get(void);
+extern void tal_tdm_clk_set(int correction);
+#endif
 
 #endif /* _TAL_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.c
index b2dd7bd..ac86564 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.c
@@ -67,6 +67,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/proc_fs.h>
+#include <plat/drv_dxt_if.h>
 #ifndef CONFIG_MV_TDM_SUPPORT
 #include "gpp/mvGppRegs.h"
 #endif
@@ -80,7 +81,7 @@ static void tdm_if_pcm_start(void);
 static void tdm_if_pcm_stop(void);
 
 /* Rx/Tx Tasklets  */
-#ifndef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+#if !(defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) && !(defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
 static void tdm_if_pcm_rx_process(unsigned long arg);
 static void tdm_if_pcm_tx_process(unsigned long arg);
 #else
@@ -98,7 +99,15 @@ static int proc_rx_over_read(char *buffer, char **buffer_location, off_t offset,
                             int buffer_length, int *zero, void *ptr);
 static int proc_tx_under_read(char *buffer, char **buffer_location, off_t offset,
                             int buffer_length, int *zero, void *ptr);
+#ifdef CONFIG_MV_TDM_EXT_STATS
+static int proc_dump_ext_stats(char *buffer, char **buffer_location, off_t offset,
+				int buffer_length, int *zero, void *ptr);
+#endif
 
+#ifdef CONFIG_MV_TDM_SUPPORT
+/* TDM SW Reset */
+static void tdm_if_stop_channels(unsigned long args);
+#endif
 
 /* Module */
 static int __init tdm_if_module_init(void);
@@ -106,10 +115,13 @@ static void __exit tdm_if_module_exit(void);
 
 /* Globals */
 static tdm_if_register_ops_t* tdm_if_register_ops;
-#ifndef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+#if !(defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) && !(defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
 static DECLARE_TASKLET(tdm_if_rx_tasklet, tdm_if_pcm_rx_process, 0);
 static DECLARE_TASKLET(tdm_if_tx_tasklet, tdm_if_pcm_tx_process, 0);
 #endif
+#ifdef CONFIG_MV_TDM_SUPPORT
+static DECLARE_TASKLET(tdm_if_stop_tasklet, tdm_if_stop_channels, 0);
+#endif
 static DEFINE_SPINLOCK(tdm_if_lock);
 static unsigned char *rxBuff = NULL, *txBuff = NULL;
 static char irqnr;
@@ -121,6 +133,15 @@ static int irq_init = 0;
 static int tdm_init = 0;
 static int buff_size = 0;
 static unsigned short test_enable = 0;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+static unsigned int pcm_stop_fail;
+#endif
+#ifdef CONFIG_MV_TDM_SUPPORT
+static int pcm_stop_flag;
+static int pcm_stop_status;
+static unsigned int pcm_start_stop_state;
+static unsigned int is_pcm_stopping;
+#endif
 
 static int proc_tdm_init_read(char *buffer, char **buffer_location, off_t offset,
                             int buffer_length, int *zero, void *ptr)
@@ -152,63 +173,100 @@ static int proc_tx_under_read(char *buffer, char **buffer_location, off_t offset
 	return sprintf(buffer, "%u\n", tx_under);
 }
 
+#ifdef CONFIG_MV_TDM_EXT_STATS
+static int proc_dump_ext_stats(char *buffer, char **buffer_location, off_t offset,
+				int buffer_length, int *zero, void *ptr)
+{
+	char *str;
+	MV_TDM_EXTENDED_STATS tdm_ext_stats;
+
+	if (offset > 0)
+		return 0;
+
+	mvTdmExtStatsGet(&tdm_ext_stats);
+
+	str = buffer;
+	str += sprintf(str, "\nTDM Extended Statistics:\n");
+	str += sprintf(str, "intRxCount = %u\n", tdm_ext_stats.intRxCount);
+	str += sprintf(str, "intTxCount = %u\n", tdm_ext_stats.intTxCount);
+	str += sprintf(str, "intRx0Count = %u\n", tdm_ext_stats.intRx0Count);
+	str += sprintf(str, "intTx0Count = %u\n", tdm_ext_stats.intTx0Count);
+	str += sprintf(str, "intRx1Count = %u\n", tdm_ext_stats.intRx1Count);
+	str += sprintf(str, "intTx1Count = %u\n", tdm_ext_stats.intTx1Count);
+	str += sprintf(str, "intRx0Miss = %u\n", tdm_ext_stats.intRx0Miss);
+	str += sprintf(str, "intTx0Miss	= %u\n", tdm_ext_stats.intTx0Miss);
+	str += sprintf(str, "intRx1Miss	= %u\n", tdm_ext_stats.intRx1Miss);
+	str += sprintf(str, "intTx1Miss	= %u\n", tdm_ext_stats.intTx1Miss);
+	str += sprintf(str, "pcmRestartCount = %u\n", tdm_ext_stats.pcmRestartCount);
+	str += sprintf(str, "pcm_stop_fail = %u\n", pcm_stop_fail);
+
+	return (int)(str - buffer);
+}
+#endif
+
 MV_STATUS tdm_if_init(tdm_if_register_ops_t* register_ops, tdm_if_params_t* tdm_if_params)
 {
 	MV_TDM_PARAMS tdm_params;
 
-	printk("Loading Marvell Telephony Driver\n");
-
-	/* Check if any SLIC module exists */
-	if(mvBoardTdmDevicesCountGet() == 0) {
-		mvCtrlPwrClckSet(TDM_2CH_UNIT_ID, 0, MV_FALSE);
-		printk("%s: Warning, no SLIC module is connected\n",__FUNCTION__);
+	if (tdm_init) {
+		printk(KERN_INFO "Marvell Telephony Driver already started...\n");
 		return MV_OK;
 	}
 
-	/* Check that selected TDM unit is active */
-	if (MV_FALSE == mvCtrlPwrClckGet(mvCtrlTdmUnitTypeGet(), 0)) {
-		printk("%s: Warning, TDM is powered off\n",__FUNCTION__);
+	printk(KERN_INFO "Loading Marvell Telephony Driver\n");
+
+	/* Check if any SLIC module exists */
+	if (mvCtrlSocUnitInfoNumGet(TDM_UNIT_ID) == 0) {
+		mvCtrlPwrClckSet(TDM_UNIT_ID, 0, MV_FALSE);
+		printk(KERN_WARNING "%s: Warning, no SLIC module is connected\n", __func__);
 		return MV_OK;
 	}
 
-
-	if((register_ops == NULL) || (tdm_if_params == NULL)) {
-		printk("%s: bad parameters\n",__FUNCTION__);
+	if ((register_ops == NULL) || (tdm_if_params == NULL)) {
+		printk(KERN_ERR "%s: bad parameters\n", __func__);
 		return MV_ERROR;
 
 	}
 
 	/* Check callbacks */
-	if(register_ops->tdm_if_pcm_ops.pcm_tx_callback == NULL ||
-	   register_ops->tdm_if_pcm_ops.pcm_rx_callback == NULL ) {
-		printk("%s: missing parameters\n",__FUNCTION__);
+	if (register_ops->tdm_if_pcm_ops.pcm_tx_callback == NULL ||
+		register_ops->tdm_if_pcm_ops.pcm_rx_callback == NULL) {
+		printk(KERN_ERR "%s: missing parameters\n", __func__);
 		return MV_ERROR;
 	}
 
 	/* Reset globals */
 	rxBuff = txBuff = NULL;
+	irq_init = 0;
+	tdm_init = 0;
+
 #ifdef CONFIG_MV_TDM_SUPPORT
 	pcm_enable = 0;
+	is_pcm_stopping = 0;
+	pcm_stop_flag = 0;
+	pcm_stop_status = 0;
 #else
 	pcm_enable = 1;
 #endif
-	irq_init = 0;
-	tdm_init = 0;
+
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	pcm_stop_fail = 0;
+#endif
 
 	/* Extract test enable */
 	test_enable = tdm_if_params->test_enable;
 
 	/* Calculate Rx/Tx buffer size(use in callbacks) */
 	buff_size = (tdm_if_params->pcm_format * tdm_if_params->total_lines * 80 *
-				(tdm_if_params->sampling_period/MV_TDM_BASE_SAMPLING_PERIOD));
+			(tdm_if_params->sampling_period/MV_TDM_BASE_SAMPLING_PERIOD));
 
 	/* Extract TDM irq number */
 	irqnr = mvCtrlTdmUnitIrqGet();
 
-	/* Start Marvell trace */
+	/* Enable Marvell tracing */
 	TRC_START();
-	TRC_INIT(NULL, NULL, 0, 0);
-	TRC_REC("->%s\n",__FUNCTION__);
+	TRC_INIT();
+	TRC_REC("->%s\n", __func__);
 
 	/* Assign TDM parameters */
 	memcpy(&tdm_params, tdm_if_params, sizeof(MV_TDM_PARAMS));
@@ -218,27 +276,45 @@ MV_STATUS tdm_if_init(tdm_if_register_ops_t* register_ops, tdm_if_params_t* tdm_
 	tdm_if_register_ops->tdm_if_ctl_ops.ctl_pcm_start = tdm_if_pcm_start;
 	tdm_if_register_ops->tdm_if_ctl_ops.ctl_pcm_stop = tdm_if_pcm_stop;
 
+#ifdef CONFIG_MV_TDM_SUPPORT
+	/* Soft reset to PCM I/F */
+	mvTdmPcmIfReset();
+#endif
+
 	/* TDM init */
-	if(mvSysTdmInit(&tdm_params) != MV_OK) {
-			printk("%s: Error, TDM initialization failed !!!\n",__FUNCTION__);
+	if (mvSysTdmInit(&tdm_params) != MV_OK) {
+			printk(KERN_ERR "%s: Error, TDM initialization failed !!!\n", __func__);
 			return MV_ERROR;
 	}
 	tdm_init = 1;
 
 	/* Register TDM interrupt */
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	if (request_fiq(irqnr, tdm_if_isr, IRQF_DISABLED, "tdm", NULL)) {
+		printk(KERN_ERR "%s: Failed to connect fiq(%d)\n", __func__, irqnr);
+		return MV_ERROR;
+	}
+#else /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 	if (request_irq(irqnr, tdm_if_isr, IRQF_DISABLED, "tdm", NULL)) {
-		printk("%s: Failed to connect irq(%d)\n", __FUNCTION__, irqnr);
+		printk(KERN_ERR "%s: Failed to connect irq(%d)\n", __func__, irqnr);
 		return MV_ERROR;
 	}
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+
 	irq_init = 1;
 
 	/* Create TDM procFS statistics */
 	tdm_stats = proc_mkdir("tdm", NULL);
-	create_proc_read_entry("tdm_init", 0, tdm_stats, proc_tdm_init_read, NULL);
-	create_proc_read_entry("rx_miss", 0, tdm_stats, proc_rx_miss_read, NULL);
-	create_proc_read_entry("tx_miss", 0, tdm_stats, proc_tx_miss_read, NULL);
-	create_proc_read_entry("rx_over", 0, tdm_stats, proc_rx_over_read, NULL);
-	create_proc_read_entry("tx_under", 0, tdm_stats, proc_tx_under_read, NULL);
+	if (tdm_stats != NULL) {
+		create_proc_read_entry("tdm_init", 0, tdm_stats, proc_tdm_init_read, NULL);
+		create_proc_read_entry("rx_miss", 0, tdm_stats, proc_rx_miss_read, NULL);
+		create_proc_read_entry("tx_miss", 0, tdm_stats, proc_tx_miss_read, NULL);
+		create_proc_read_entry("rx_over", 0, tdm_stats, proc_rx_over_read, NULL);
+		create_proc_read_entry("tx_under", 0, tdm_stats, proc_tx_under_read, NULL);
+#ifdef CONFIG_MV_TDM_EXT_STATS
+		create_proc_read_entry("tdm_extended_stats", 0, tdm_stats, proc_dump_ext_stats, NULL);
+#endif
+	}
 
 	TRC_REC("Marvell Telephony Driver Loaded Successfully\n");
 
@@ -247,49 +323,71 @@ MV_STATUS tdm_if_init(tdm_if_register_ops_t* register_ops, tdm_if_params_t* tdm_
 	tdm_if_pcm_stop();
 #endif
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
 	return MV_OK;
 }
 
 
 void tdm_if_exit(void)
 {
+	u32 max_poll = 0;
+
 	/* Check if already stopped */
-	if(!irq_init && !pcm_enable && !tdm_init)
+	if (!irq_init && !pcm_enable && !tdm_init)
 		return;
 
-	TRC_REC("->%s\n",__FUNCTION__);
+	TRC_REC("->%s\n", __func__);
 
-	if(irq_init) {
-		/* Release IRQ */
+	/* Stop PCM channels */
+	if (pcm_enable)
+		tdm_if_pcm_stop();
+
+	while ((is_pcm_stopping != 0) && (max_poll < 20)) {
+		mdelay(1);
+		max_poll++;
+	}
+
+	if (max_poll >= 20) {
+		printk(KERN_WARNING "%s: waiting for pcm channels to stop exceeded 20ms\n", __func__);
+		/*printk("is_pcm_stopping(%d), pcm_enable(%d)\n", is_pcm_stopping, pcm_enable);
+		printk("pcm_stop_flag(%d), pcm_start_stop_state(%d)\n", pcm_stop_flag, pcm_start_stop_state);
+		printk("pcm_stop_status(%d)\n", pcm_stop_status);*/
+	}
+
+	if (irq_init) {
+		/* Release interrupt */
+#ifndef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
 		free_irq(irqnr, NULL);
+#else /* !CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+		free_fiq(irqnr, NULL);
+#endif /* !CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 		irq_init = 0;
 	}
 
-	/* Stop PCM data sampling */
-	if(pcm_enable)
-		tdm_if_pcm_stop();
-
-	if(tdm_init) {
+	if (tdm_init) {
 #ifdef CONFIG_MV_TDM_SUPPORT
 		mvTdmRelease();
 #else
 		mvCommUnitRelease();
 #endif
-		tdm_init = 0;
-
 		/* Remove proc directory & entries */
 		remove_proc_entry("tdm_init", tdm_stats);
 		remove_proc_entry("rx_miss", tdm_stats);
 		remove_proc_entry("tx_miss", tdm_stats);
 		remove_proc_entry("rx_over", tdm_stats);
 		remove_proc_entry("tx_under", tdm_stats);
+#ifdef CONFIG_MV_TDM_EXT_STATS
+		remove_proc_entry("tdm_extended_stats", tdm_stats);
+#endif
 		remove_proc_entry("tdm", NULL);
+
+		tdm_init = 0;
 	}
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
 
-	TRC_OUTPUT();
+	/* Dump output and release Marvell trace resources */
+	TRC_OUTPUT(0, 1);
 	TRC_RELEASE();
 }
 
@@ -297,21 +395,30 @@ static void tdm_if_pcm_start(void)
 {
 	unsigned long flags;
 
-	TRC_REC("->%s\n",__FUNCTION__);
+	TRC_REC("->%s\n", __func__);
 
 	spin_lock_irqsave(&tdm_if_lock, flags);
-	if(!pcm_enable) {
-		rxBuff = txBuff = NULL;
+	if (!pcm_enable) {
 		pcm_enable = 1;
 #ifdef CONFIG_MV_TDM_SUPPORT
-		mvTdmPcmStart();
+		if (is_pcm_stopping == 0) {
+			pcm_stop_flag = 0;
+			pcm_stop_status = 0;
+			pcm_start_stop_state = 0;
+			rxBuff = txBuff = NULL;
+			mvTdmPcmStart();
+		} else {
+			pcm_start_stop_state++;
+			TRC_REC("pcm_start_stop_state(%d)\n", pcm_start_stop_state);
+		}
 #else
+		rxBuff = txBuff = NULL;
 		mvCommUnitPcmStart();
 #endif
 	}
 	spin_unlock_irqrestore(&tdm_if_lock, flags);
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
 	return;
 }
 
@@ -319,21 +426,26 @@ static void tdm_if_pcm_stop(void)
 {
 	unsigned long flags;
 
-	TRC_REC("->%s\n",__FUNCTION__);
+	TRC_REC("->%s\n", __func__);
 
 	spin_lock_irqsave(&tdm_if_lock, flags);
-	if(pcm_enable) {
+	if (pcm_enable) {
 		pcm_enable = 0;
-		rxBuff = txBuff = NULL;
 #ifdef CONFIG_MV_TDM_SUPPORT
-		mvTdmPcmStop();
+		if (is_pcm_stopping == 0) {
+			is_pcm_stopping = 1;
+			mvTdmPcmStop();
+		} else {
+			pcm_start_stop_state--;
+			TRC_REC("pcm_start_stop_state(%d)\n", pcm_start_stop_state);
+		}
 #else
 		mvCommUnitPcmStop();
 #endif
 	}
 	spin_unlock_irqrestore(&tdm_if_lock, flags);
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
 	return;
 }
 
@@ -341,12 +453,15 @@ static irqreturn_t tdm_if_isr(int irq, void* dev_id)
 {
 	MV_TDM_INT_INFO tdm_int_info;
 	unsigned int int_type;
+#ifdef CONFIG_MV_TDM_SUPPORT
+	int ret;
+#endif
 
-	TRC_REC("->%s\n",__FUNCTION__);
+	TRC_REC("->%s\n", __func__);
 
 	/* Extract interrupt information from low level ISR */
 #ifdef CONFIG_MV_TDM_SUPPORT
-	mvTdmIntLow(&tdm_int_info);
+	ret = mvTdmIntLow(&tdm_int_info);
 #else
 	mvCommUnitIntLow(&tdm_int_info);
 #endif
@@ -355,152 +470,258 @@ static irqreturn_t tdm_if_isr(int irq, void* dev_id)
 	/*device_id = tdm_int_info.cs;*/
 
 	/* Nothing to do - return */
-	if(int_type == MV_EMPTY_INT)
+	if (int_type == MV_EMPTY_INT)
 		goto out;
 
+#ifdef CONFIG_MV_TDM_SUPPORT
+	if ((ret == -1) && (pcm_stop_status == 0))  {
+		pcm_stop_status = 1;
+
+		/* If Rx/Tx tasklets already scheduled, let them do the work. */
+		if ((!rxBuff) && (!txBuff)) {
+			TRC_REC("Stopping the TDM\n");
+			tdm_if_pcm_stop();
+			pcm_stop_flag = 0;
+			tasklet_hi_schedule(&tdm_if_stop_tasklet);
+		} else {
+			TRC_REC("Some tasklet is running, mark pcm_stop_flag\n");
+			pcm_stop_flag = 1;
+		}
+	}
+
+	/* Restarting PCM, skip Rx/Tx handling */
+	if (pcm_stop_status)
+		goto skip_rx_tx;
+#endif
+
 	/* Support multiple interrupt handling */
 	/* RX interrupt */
-	if(int_type & MV_RX_INT) {
-		if(rxBuff != NULL) {
+	if (int_type & MV_RX_INT) {
+		if (rxBuff != NULL) {
 			rx_miss++;
-			TRC_REC("%s: Warning, missed Rx buffer processing !!!\n",__FUNCTION__);
+			TRC_REC("%s: Warning, missed Rx buffer processing !!!\n", __func__);
 		}
 		else {
 			rxBuff = tdm_int_info.tdmRxBuff;
-#ifdef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
-			TRC_REC("%s: running Rx in ISR\n", __FUNCTION__);
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+			TRC_REC("%s: running Rx in ISR\n", __func__);
 			tdm_if_pcm_rx_process();
 #else
 			/* Schedule Rx processing within SOFT_IRQ context */
-			TRC_REC("%s: schedule Rx tasklet\n", __FUNCTION__);
+			TRC_REC("%s: schedule Rx tasklet\n", __func__);
 			tasklet_hi_schedule(&tdm_if_rx_tasklet);
 #endif
 		}
 	}
 
 	/* TX interrupt */
-	if(int_type & MV_TX_INT) {
-		if(txBuff != NULL) {
+	if (int_type & MV_TX_INT) {
+		if (txBuff != NULL) {
 			tx_miss++;
-			TRC_REC("%s: Warning, missed Tx buffer processing !!!\n",__FUNCTION__);
+			TRC_REC("%s: Warning, missed Tx buffer processing !!!\n", __func__);
 		}
 		else {
 			txBuff = tdm_int_info.tdmTxBuff;
-#ifdef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
-			TRC_REC("%s: running Tx in ISR\n", __FUNCTION__);
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+			TRC_REC("%s: running Tx in ISR\n", __func__);
 			tdm_if_pcm_tx_process();
 #else
 			/* Schedule Tx processing within SOFT_IRQ context */
-			TRC_REC("%s: schedule Tx tasklet\n", __FUNCTION__);
+			TRC_REC("%s: schedule Tx tasklet\n", __func__);
 			tasklet_hi_schedule(&tdm_if_tx_tasklet);
 #endif
 		}
 	}
 
+#ifdef CONFIG_MV_TDM_SUPPORT
+	/* TDM2CH PCM channels stop indication */
+	if ((int_type & MV_CHAN_STOP_INT) && (tdm_int_info.data == 4)) {
+		TRC_REC("%s: Received MV_CHAN_STOP_INT indication\n", __func__);
+		is_pcm_stopping = 0;
+		if (pcm_start_stop_state) {
+			TRC_REC("%s: calling to tdm_if_pcm_start()\n", __func__);
+			pcm_enable = 0;
+			tdm_if_pcm_start();
+		}
+	}
+
+skip_rx_tx:
+#endif
 	/* PHONE interrupt */
-	if(int_type & MV_PHONE_INT) {
+	if (int_type & MV_PHONE_INT) {
 		/* TBD */
+#ifdef CONFIG_LANTIQ_SLIC_SUPPORT
+		drv_dxt_if_signal_interrupt();
+#endif
 	}
 
 	/* ERROR interrupt */
-	if(int_type & MV_ERROR_INT) {
-		if(int_type & MV_RX_ERROR_INT)
+	if (int_type & MV_ERROR_INT) {
+		if (int_type & MV_RX_ERROR_INT)
 			rx_over++;
 
-		if(int_type & MV_TX_ERROR_INT)
+		if (int_type & MV_TX_ERROR_INT)
 			tx_under++;
 	}
 
-
 out:
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
 	return IRQ_HANDLED;
 }
-
-#ifdef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
 static inline void tdm_if_pcm_rx_process(void)
 #else
 /* Rx tasklet */
 static void tdm_if_pcm_rx_process(unsigned long arg)
 #endif
 {
-	TRC_REC("->%s\n",__FUNCTION__);
-	if(pcm_enable) {
+	unsigned long flags;
+
+	TRC_REC("->%s\n", __func__);
+	if (pcm_enable) {
 		if(rxBuff == NULL) {
-			TRC_REC("%s: Error, empty Rx processing\n",__FUNCTION__);
+			TRC_REC("%s: Error, empty Rx processing\n", __func__);
 			return;
 		}
 
 		/* Fill TDM Rx aggregated buffer */
 #ifdef CONFIG_MV_TDM_SUPPORT
-		if(mvTdmRx(rxBuff) == MV_OK)
+		if (mvTdmRx(rxBuff) == MV_OK)
 			tdm_if_register_ops->tdm_if_pcm_ops.pcm_rx_callback(rxBuff, buff_size); /* Dispatch Rx handler */
 #else
-		if(mvCommUnitRx(rxBuff) == MV_OK) {
+		if (mvCommUnitRx(rxBuff) == MV_OK) {
 			tdm_if_register_ops->tdm_if_pcm_ops.pcm_rx_callback(rxBuff, buff_size); /* Dispatch Rx handler */
 			/* Since data buffer is shared among MCDMA and CPU, need to invalidate
-				before it accessed by MCDMA	*/
-			mvOsCacheInvalidate(NULL, rxBuff, buff_size);
+				before it accessed by MCDMA. MMP may stop channels from this context,
+				so make sure the buffer is still valid	*/
+			if (pcm_enable)
+				mvOsCacheInvalidate(NULL, rxBuff, buff_size);
 		}
 #endif
 		else
-			printk("%s: could not fill Rx buffer\n",__FUNCTION__);
+			printk(KERN_WARNING "%s: could not fill Rx buffer\n", __func__);
 
 	}
 
+	spin_lock_irqsave(&tdm_if_lock, flags);
+
 	/* Clear rxBuff for next iteration */
 	rxBuff = NULL;
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+#ifdef CONFIG_MV_TDM_SUPPORT
+	if ((pcm_stop_flag == 1) && !txBuff) {
+		TRC_REC("Stopping TDM from Rx tasklet\n");
+		tdm_if_pcm_stop();
+		pcm_stop_flag = 0;
+		tasklet_hi_schedule(&tdm_if_stop_tasklet);
+	}
+#endif
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+	TRC_REC("<-%s\n", __func__);
 	return;
 }
 
-#ifdef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
 static inline void tdm_if_pcm_tx_process(void)
 #else
 /* Tx tasklet */
 static void tdm_if_pcm_tx_process(unsigned long arg)
 #endif
 {
-	TRC_REC("->%s\n",__FUNCTION__);
+	unsigned long flags;
+
+	TRC_REC("->%s\n", __func__);
 
-	if(pcm_enable) {
-		if(txBuff == NULL) {
-			TRC_REC("%s: Error, empty Tx processing\n",__FUNCTION__);
+	if (pcm_enable) {
+		if (txBuff == NULL) {
+			TRC_REC("%s: Error, empty Tx processing\n", __func__);
 			return;
 		}
 
 		/* Dispatch Tx handler */
 		tdm_if_register_ops->tdm_if_pcm_ops.pcm_tx_callback(txBuff, buff_size);
 
-		if(test_enable == 0) {
+		if (test_enable == 0) {
 			/* Fill Tx aggregated buffer */
 #ifdef CONFIG_MV_TDM_SUPPORT
 			if(mvTdmTx(txBuff) != MV_OK)
 #else
 			if(mvCommUnitTx(txBuff) != MV_OK)
 #endif /* CONFIG_MV_TDM_SUPPORT */
-				printk("%s: could not fill Tx buffer\n",__FUNCTION__);
+				printk(KERN_WARNING "%s: could not fill Tx buffer\n", __func__);
 		}
 	}
 
+	spin_lock_irqsave(&tdm_if_lock, flags);
+
 	/* Clear txBuff for next iteration */
 	txBuff = NULL;
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+#ifdef CONFIG_MV_TDM_SUPPORT
+	if ((pcm_stop_flag == 1) && !rxBuff) {
+		TRC_REC("Stopping TDM from Tx tasklet\n");
+		tdm_if_pcm_stop();
+		pcm_stop_flag = 0;
+		tasklet_hi_schedule(&tdm_if_stop_tasklet);
+	}
+#endif
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+	TRC_REC("<-%s\n", __func__);
 	return;
 }
 
 void tdm_if_stats_get(tdm_if_stats_t* tdm_if_stats)
 {
+	if (tdm_init == 0)
+		return;
+
 	tdm_if_stats->tdm_init = tdm_init;
 	tdm_if_stats->rx_miss = rx_miss;
 	tdm_if_stats->tx_miss = tx_miss;
 	tdm_if_stats->rx_over = rx_over;
 	tdm_if_stats->tx_under = tx_under;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	mvTdmExtStatsGet(&tdm_if_stats->tdm_ext_stats);
+#endif
+	return;
+}
+
+#ifdef CONFIG_MV_TDM_SUPPORT
+static void tdm_if_stop_channels(unsigned long arg)
+{
+	u32 max_poll = 0;
+	unsigned long flags;
+
+	TRC_REC("->%s\n", __func__);
 
+	/* Wait for all channels to stop  */
+	while (((MV_REG_READ(CH_ENABLE_REG(0)) & 0x101) || (MV_REG_READ(CH_ENABLE_REG(1)) & 0x101)) && (max_poll < 30)) {
+		mdelay(1);
+		max_poll++;
+	}
+
+	TRC_REC("Finished polling on channels disable\n");
+	if (max_poll >= 30) {
+		MV_REG_WRITE(CH_ENABLE_REG(0), 0);
+		MV_REG_WRITE(CH_ENABLE_REG(1), 0);
+		printk(KERN_WARNING "\n\npolling on channels disabling exceeded 30ms\n\n");
+#ifdef CONFIG_MV_TDM_EXT_STATS
+		pcm_stop_fail++;
+#endif
+		mdelay(10);
+	}
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	is_pcm_stopping = 0;
+	tdm_if_pcm_start();
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+	TRC_REC("<-%s\n", __func__);
 	return;
 }
+#endif
 
 static int __init tdm_if_module_init(void)
 {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.h
index 3581229..e1753e5 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.h
@@ -72,6 +72,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  #include "voiceband/commUnit/mvCommUnit.h"
 #endif
 #include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
 #include "boardEnv/mvBoardEnvLib.h"
 
@@ -83,6 +84,9 @@ typedef struct {
 	unsigned int tx_miss;
 	unsigned int rx_over;
 	unsigned int tx_under;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	MV_TDM_EXTENDED_STATS tdm_ext_stats;
+#endif
 } tdm_if_stats_t;
 
 typedef struct {
@@ -114,5 +118,10 @@ typedef struct {
 void tdm_if_stats_get(tdm_if_stats_t* tdm_if_stats);
 MV_STATUS tdm_if_init(tdm_if_register_ops_t* register_ops, tdm_if_params_t* tdm_if_params);
 void tdm_if_exit(void);
+#if defined(MV_TDM_USE_DCO)
+MV_VOID mvCtrlTdmDcoReset(MV_VOID);
+MV_32 mvCtrlTdmDcoGet(MV_VOID);
+MV_VOID mvCtrlTdmDcoSet(MV_32 DcoCorrection);
+#endif
 
 #endif /*_TDM_IF_H_*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/Makefile
index 669d894..05c1b13 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/Makefile
@@ -5,8 +5,8 @@
 #
 #
 
-ifeq ($(CONFIG_PLAT_ARMADA),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_MV_INCLUDE_TDM) += tdm_dev.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c
index ea8329b..005bb80 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c
@@ -62,13 +62,15 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
 
+#include "mvSysHwConfig.h"
+#include "mvSysTdmConfig.h"
 #include "tdm_dev.h"
+#include "mv_phone/tdm/tdm_if.h"
 #include "mv_phone/tdm/tal.h"
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/miscdevice.h>
-#include <linux/version.h>
 #ifdef CONFIG_MV_TDM_SUPPORT
  #include "voiceband/tdm/mvTdm.h"
 #else
@@ -78,8 +80,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define TDM_DEV_NAME 	"tdm"
 #define DISABLE		0
 #define ENABLE		1
+#define MAX_POLL	12 /* millisecond */
 
-/* GLobals */
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include <asm/hardware/gic.h>
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+
+/* Globals */
 static DECLARE_WAIT_QUEUE_HEAD(tdm_dev_wait);
 static DEFINE_SPINLOCK(tdm_dev_lock);
 static tal_params_t tdm_dev_params;
@@ -87,16 +95,16 @@ static tal_mmp_ops_t tdm_dev_ops;
 static atomic_t tdm_init, rx_ready, tx_ready;
 static unsigned char *rx_buff_p = NULL, *tx_buff_p = NULL;
 static unsigned char rx_temp_buff[MV_TDM_TOTAL_CHANNELS * MV_TDM_TOTAL_CH_SAMPLES * 4];
+#if defined(MV_TDM_USE_DCO)
+static tdm_dev_clk_t tdm_dev_clk;
+#endif
 
 /* Forward declarations */
 static int tdm_dev_tdm_start(unsigned long arg);
 static ssize_t tdm_dev_read(struct file *file_p, char __user *buf, size_t size, loff_t * ppos);
 static ssize_t tdm_dev_write(struct file *file_p, const char __user *buf, size_t size, loff_t * ppos);
 static unsigned int tdm_dev_poll(struct file *file_p, poll_table *poll_table_p);
-static int tdm_dev_ioctl(struct inode *inode_p, struct file *file_p, unsigned int cmd, unsigned long arg);
-#ifdef HAVE_UNLOCKED_IOCTL
-static long tdm_dev_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
-#endif
+static long tdm_dev_ioctl(struct file *file_p, unsigned int cmd, unsigned long arg);
 static int tdm_dev_open(struct inode *inode_p, struct file *file_p);
 static int tdm_dev_release(struct inode *inode_p, struct file *file_p);
 void tdm_dev_tx_callback(unsigned char* tx_buff, int size);
@@ -104,21 +112,16 @@ void tdm_dev_rx_callback(unsigned char* rx_buff, int size);
 static int __init tdm_dev_init(void);
 static void __exit tdm_dev_exit(void);
 
-static struct file_operations tdm_dev_fops = {
-    owner:      THIS_MODULE,
-    llseek:     NULL,
-    read:       tdm_dev_read,
-    write:      tdm_dev_write,
-    poll:       tdm_dev_poll,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
-    ioctl:	tdm_dev_ioctl,
-#endif
-#ifdef HAVE_UNLOCKED_IOCTL
-    unlocked_ioctl: tdm_dev_unlocked_ioctl,
-#endif
-    open:       tdm_dev_open,
-    release:    tdm_dev_release,
-    fasync:     NULL
+static const struct file_operations tdm_dev_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= NULL,
+	.read		= tdm_dev_read,
+	.write		= tdm_dev_write,
+	.poll		= tdm_dev_poll,
+	.unlocked_ioctl	= tdm_dev_ioctl,
+	.open		= tdm_dev_open,
+	.release	= tdm_dev_release,
+	.fasync		= NULL
 };
 
 static struct miscdevice tdm_dev_misc_dev = {
@@ -153,18 +156,18 @@ static int tdm_dev_tdm_start(unsigned long arg)
 
 	/* Get user data */
 	if(copy_from_user(&data, (void*)arg, sizeof(tdm_dev_params_t))) {
-		printk("%s: copy_from_user failed\n", __FUNCTION__);
+		printk(KERN_ERR "%s: copy_from_user failed\n", __func__);
 		return -EFAULT;
 	}
 
 	/* Check parameters */
 	if((data.pcm_format != 1) && (data.pcm_format != 2) && (data.pcm_format != 4)) {
-		printk("%s: bad parameter(pcm_format=%u)\n", __FUNCTION__, data.pcm_format);
+		printk(KERN_ERR "%s: bad parameter(pcm_format=%u)\n", __func__, data.pcm_format);
 		return -EFAULT;
 	}
 
 	if(data.total_lines > MV_TDM_TOTAL_CHANNELS) {
-		printk("%s: bad parameter(data.total_lines=%u)\n", __FUNCTION__, data.total_lines);
+		printk(KERN_ERR "%s: bad parameter(data.total_lines=%u)\n", __func__, data.total_lines);
 		return -EFAULT;
 	}
 
@@ -182,7 +185,7 @@ static int tdm_dev_tdm_start(unsigned long arg)
 	tdm_dev_ops.tal_mmp_tx_callback = tdm_dev_tx_callback;
 
 	if(tal_init(&tdm_dev_params, &tdm_dev_ops) != MV_OK) {
-		printk("%s: Error, could not init tdm driver\n",__FUNCTION__);
+		printk(KERN_ERR "%s: Error, could not init tdm driver\n", __func__);
 		return -EFAULT;
 	}
 
@@ -200,8 +203,11 @@ static ssize_t tdm_dev_read(struct file *file_p, char __user *buf, size_t size,
 {
 	size_t ret = size;
 
-	TRC_REC("->%s\n",__FUNCTION__);
+	TRC_REC("->%s\n", __func__);
 
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	gic_mask_fiq(mvCtrlTdmUnitIrqGet());
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 	if(rx_buff_p != NULL) {
 		if (copy_to_user(buf, rx_buff_p, size))
 			ret = -EFAULT;
@@ -209,11 +215,14 @@ static ssize_t tdm_dev_read(struct file *file_p, char __user *buf, size_t size,
 		atomic_set(&rx_ready, DISABLE);
 	} else {
 		ret = 0;
-		TRC_REC("%s: missed Rx buffer\n",__FUNCTION__);
+		TRC_REC("%s: missed Rx buffer\n", __func__);
 	}
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
 
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	gic_unmask_fiq(mvCtrlTdmUnitIrqGet());
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 	return ret;
 }
 
@@ -223,8 +232,11 @@ static ssize_t tdm_dev_write(struct file *file_p, const char __user *buf, size_t
 	MV_STATUS status;
 	size_t ret = size;
 
-	TRC_REC("->%s\n",__FUNCTION__);
+	TRC_REC("->%s\n", __func__);
 
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	gic_mask_fiq(mvCtrlTdmUnitIrqGet());
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 	if(tx_buff_p != NULL) {
 		if (copy_from_user(tx_buff_p, buf, size))
 			ret = -EFAULT;
@@ -238,13 +250,16 @@ static ssize_t tdm_dev_write(struct file *file_p, const char __user *buf, size_t
 		spin_unlock_irqrestore(&tdm_dev_lock, flags);
 		tx_buff_p = NULL;
 		if(status != MV_OK)
-			printk("%s: could not fill Tx buffer\n",__FUNCTION__);
+			printk(KERN_WARNING "%s: could not fill Tx buffer\n", __func__);
 	} else {
 		ret = 0;
-		TRC_REC("%s: missed Tx buffer\n",__FUNCTION__);
+		TRC_REC("%s: missed Tx buffer\n", __func__);
 	}
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
 
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	gic_unmask_fiq(mvCtrlTdmUnitIrqGet());
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 	return ret;
 }
 
@@ -252,7 +267,30 @@ static unsigned int tdm_dev_poll(struct file *file_p, poll_table *poll_table_p)
 {
 	int mask = 0;
 
-	TRC_REC("->%s\n",__FUNCTION__);
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	int max_poll = 0;
+
+	while (!atomic_read(&rx_ready) && !atomic_read(&tx_ready) && (max_poll < MAX_POLL)) {
+		mdelay(1);
+		max_poll++;
+	}
+
+	if (max_poll >= MAX_POLL)
+		printk(KERN_WARNING "%s: Warning, no Rx/Tx callback for at least 10ms\n", __func__);
+
+	if (atomic_read(&rx_ready)) {
+		atomic_set(&rx_ready, DISABLE);
+		mask |= POLLIN | POLLRDNORM;	/* readable */
+		TRC_REC("poll can read\n");
+	}
+
+	if (atomic_read(&tx_ready)) {
+		atomic_set(&tx_ready, DISABLE);
+		mask |= POLLOUT | POLLWRNORM;	/* writable */
+		TRC_REC("poll can write\n");
+	}
+#else /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+	TRC_REC("->%s\n", __func__);
 
 	poll_wait(file_p, &tdm_dev_wait, poll_table_p);
 
@@ -266,34 +304,35 @@ static unsigned int tdm_dev_poll(struct file *file_p, poll_table *poll_table_p)
 		TRC_REC("poll can write\n");
 	}
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+
 	return mask;
 }
 
-static int tdm_dev_ioctl(struct inode *inode_p, struct file *file_p, unsigned int cmd, unsigned long arg)
+static long tdm_dev_ioctl(struct file *file_p, unsigned int cmd, unsigned long arg)
 {
 	int ret = 0;
 
 	/* Argument checking */
 	if (_IOC_TYPE(cmd) != TDM_DEV_IOCTL_MAGIC) {
-		printk("%s: invalid TDM DEV Magic Num %i %i\n", __FUNCTION__, _IOC_TYPE(cmd), TDM_DEV_IOCTL_MAGIC);
+		printk(KERN_ERR "%s: invalid TDM DEV Magic Num %i %i\n", __func__, _IOC_TYPE(cmd), TDM_DEV_IOCTL_MAGIC);
 		return -ENOTTY;
 	}
 
 	if ((_IOC_NR(cmd) > TDM_DEV_IOCTL_MAX) || (_IOC_NR(cmd) < TDM_DEV_IOCTL_MIN)) {
-		printk("%s: invalid TDM DEV IOCTL request\n", __FUNCTION__);
+		printk(KERN_ERR "%s: invalid TDM DEV IOCTL request\n", __func__);
 		return -ENOTTY;
 	}
 
 	if (_IOC_DIR(cmd) & _IOC_READ) {
 		ret = !access_ok(VERIFY_WRITE, (void __user*)arg, _IOC_SIZE(cmd));
-	}
-	else if (_IOC_DIR(cmd) & _IOC_WRITE) {
+	} else if (_IOC_DIR(cmd) & _IOC_WRITE) {
 		ret = !access_ok(VERIFY_READ, (void __user*)arg, _IOC_SIZE(cmd));
 	}
 
 	if (ret) {
-		printk("%s: invalid TDM DEV access type %i from cmd %i\n", __FUNCTION__, _IOC_DIR(cmd), cmd);
+		printk(KERN_ERR "%s: invalid TDM DEV access type %i from cmd %i\n", __func__, _IOC_DIR(cmd), cmd);
 		return -EFAULT;
 	}
 
@@ -322,22 +361,38 @@ static int tdm_dev_ioctl(struct inode *inode_p, struct file *file_p, unsigned in
 			tal_pcm_stop();
 			printk("ioctl: TDM_DEV_PCM_STOP\n");
 			break;
-	}
 
-	return ret;
-}
+#if defined(MV_TDM_USE_DCO)
+		case TDM_DEV_TDM_CLK_CONFIG:
+			mvCtrlTdmClkCtrlConfig();
+			printk(KERN_INFO "ioctl: TDM_DEV_TDM_CLK_CONFIG\n");
+			break;
 
-#ifdef HAVE_UNLOCKED_IOCTL
-static long
-tdm_dev_unlocked_ioctl(
-	struct file *filp,
-	unsigned int cmd,
-	unsigned long arg)
-{
-	return tdm_dev_ioctl(NULL, filp, cmd, arg);
-}
+		case TDM_DEV_TDM_CLK_GET:
+			tdm_dev_clk.correction = mvCtrlTdmClkCtrlGet();
+			printk(KERN_INFO "ioctl: TDM_DEV_TDM_CLK_GET: %x\n", tdm_dev_clk.correction);
+			/* Put user data */
+			if (copy_to_user((void *)arg, &tdm_dev_clk, sizeof(tdm_dev_clk_t))) {
+				printk(KERN_ERR "%s: copy_to_user failed\n", __func__);
+				return -EFAULT;
+			}
+			printk(KERN_INFO "ioctl: TDM_DEV_TDM_CLK_GET\n");
+			break;
+
+		case TDM_DEV_TDM_CLK_SET:
+			/* Get user data */
+			if (copy_from_user(&tdm_dev_clk, (void *)arg, sizeof(tdm_dev_clk_t))) {
+				printk(KERN_ERR "%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+			}
+			printk(KERN_INFO "ioctl: TDM_DEV_TDM_CLK_SET: %x\n", tdm_dev_clk.correction);
+			mvCtrlTdmClkCtrlSet(tdm_dev_clk.correction);
+			break;
 #endif
+	}
 
+	return (long)ret;
+}
 static int tdm_dev_open(struct inode *inode_p, struct file *file_p)
 {
 	try_module_get(THIS_MODULE);
@@ -352,26 +407,30 @@ static int tdm_dev_release(struct inode *inode_p, struct file *file_p)
 
 void tdm_dev_tx_callback(unsigned char* tx_buff, int size)
 {
-	TRC_REC("->%s\n",__FUNCTION__);
+	TRC_REC("->%s\n", __func__);
 
 	tx_buff_p = tx_buff;
 	atomic_set(&tx_ready, ENABLE);
+#ifndef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
 	wake_up_interruptible(&tdm_dev_wait);
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
 	return;
 }
 
 void tdm_dev_rx_callback(unsigned char* rx_buff, int size)
 {
-	TRC_REC("->%s\n",__FUNCTION__);
+	TRC_REC("->%s\n", __func__);
 
 	rx_buff_p = rx_temp_buff;
 	memcpy(rx_buff_p, rx_buff, size);
 	atomic_set(&rx_ready, ENABLE);
+#ifndef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
 	wake_up_interruptible(&tdm_dev_wait);
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 
-	TRC_REC("<-%s\n",__FUNCTION__);
+	TRC_REC("<-%s\n", __func__);
 	return;
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h
index 447693e..c920680 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h
@@ -74,7 +74,17 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define TDM_DEV_PCM_START		_IO(TDM_DEV_IOCTL_MAGIC, 3)
 #define TDM_DEV_PCM_STOP		_IO(TDM_DEV_IOCTL_MAGIC, 4)
 
-#define TDM_DEV_IOCTL_MAX 		4
+#define TDM_DEV_IOCTL_MAX		7
+
+#define TDM_DEV_TDM_CLK_CONFIG		_IOWR(TDM_DEV_IOCTL_MAGIC, 5, tdm_dev_clk_t)
+#if defined(MV_TDM_USE_DCO)
+#define TDM_DEV_TDM_CLK_GET		_IOWR(TDM_DEV_IOCTL_MAGIC, 6, tdm_dev_clk_t)
+#define TDM_DEV_TDM_CLK_SET		_IOWR(TDM_DEV_IOCTL_MAGIC, 7, tdm_dev_clk_t)
+
+typedef struct tdm_dev_clk {
+	int correction;
+} tdm_dev_clk_t;
+#endif /*_MV_TDM_USE_DCO_*/
 
 typedef struct tdm_dev_params {
 	unsigned char pcm_format;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm_if.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm_if.c
deleted file mode 100644
index 2fa60c9..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm_if.c
+++ /dev/null
@@ -1,449 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include "tdm_if.h"
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/proc_fs.h>
-#ifndef CONFIG_MV_TDM_SUPPORT
-#include "gpp/mvGppRegs.h"
-#endif
-
-
-/* TDM Interrupt Service Routine */
-static irqreturn_t tdm_if_isr(int irq, void* dev_id);
-
-/* PCM start/stop */
-static void tdm_if_pcm_start(void);
-static void tdm_if_pcm_stop(void);
-
-/* Rx/Tx Tasklets  */
-static void tdm_if_pcm_rx_process(unsigned long arg);
-static void tdm_if_pcm_tx_process(unsigned long arg);
-
-/* TDM proc-fs statistics */
-static int proc_tdm_init_read(char *buffer, char **buffer_location, off_t offset,
-                            int buffer_length, int *zero, void *ptr);
-static int proc_rx_miss_read(char *buffer, char **buffer_location, off_t offset,
-                            int buffer_length, int *zero, void *ptr);
-static int proc_tx_miss_read(char *buffer, char **buffer_location, off_t offset,
-                            int buffer_length, int *zero, void *ptr);
-
-/* Module */
-static int __init tdm_if_module_init(void);
-static void __exit tdm_if_module_exit(void);
-
-/* Globals */
-static tdm_if_register_ops_t* tdm_if_register_ops;
-static DECLARE_TASKLET(tdm_if_rx_tasklet, tdm_if_pcm_rx_process, 0);
-static DECLARE_TASKLET(tdm_if_tx_tasklet, tdm_if_pcm_tx_process, 0);
-static DEFINE_SPINLOCK(tdm_if_lock);
-static unsigned char *rxBuff = NULL, *txBuff = NULL;
-static char irqnr;
-static unsigned int rx_miss = 0, tx_miss = 0;
-static struct proc_dir_entry *tdm_stats;
-static int pcm_enable = 0;
-static int irq_init = 0;
-static int tdm_init = 0;
-static int buff_size = 0;
-
-static int proc_tdm_init_read(char *buffer, char **buffer_location, off_t offset,
-                            int buffer_length, int *zero, void *ptr)
-{
-	return sprintf(buffer, "%u\n", tdm_init);
-}
-
-static int proc_rx_miss_read(char *buffer, char **buffer_location, off_t offset,
-                            int buffer_length, int *zero, void *ptr)
-{
-	return sprintf(buffer, "%u\n", rx_miss);
-}
-
-static int proc_tx_miss_read(char *buffer, char **buffer_location, off_t offset,
-                            int buffer_length, int *zero, void *ptr)
-{
-	return sprintf(buffer, "%u\n", tx_miss);
-}
-
-MV_STATUS tdm_if_init(tdm_if_register_ops_t* register_ops, tdm_if_params_t* tdm_if_params)
-{
-	MV_TDM_PARAMS tdm_params;
-	
-	printk("Loading Marvell Telephony Driver:\n");
-
-	if (MV_FALSE == mvCtrlPwrClckGet(mvCtrlTdmUnitTypeGet(), 0)) {
-		printk("%s: Warning, TDM is powered off\n",__FUNCTION__);
-		return MV_OK;
-	}
-
-	if((register_ops == NULL) || (tdm_if_params == NULL)) {
-		printk("%s: bad parameters\n",__FUNCTION__);
-		return MV_ERROR;
-
-	}
-
-	/* Check callbacks */
-	if(register_ops->tdm_if_pcm_ops.pcm_tx_callback == NULL ||
-	   register_ops->tdm_if_pcm_ops.pcm_rx_callback == NULL ) {
-		printk("%s: missing parameters\n",__FUNCTION__);
-		return MV_ERROR;
-	}
-
-	/* Reset globals */
-	rxBuff = txBuff = NULL;
-	pcm_enable = 0;
-	irq_init = 0;
-	tdm_init = 0;
-	
-	/* Calculate Rx/Tx buffer size(use in callbacks) */
-	buff_size = (tdm_if_params->pcm_format * tdm_if_params->total_lines * 80 * 
-				(tdm_if_params->sampling_period/MV_TDM_BASE_SAMPLING_PERIOD));
-
-	/* Extract TDM irq number */
-	irqnr = mvCtrlTdmUnitIrqGet();
-
-	/* Enable Marvell tracing */
-	TRC_REC("->%s\n", __FUNCTION__);
-
-#if defined(CONFIG_ARCH_FEROCEON_KW)
-	/* Assign TDM MPPs  - TBD */
-    	mvBoardTdmMppSet(1);
-#endif
-	/* Assign TDM parameters */
-	memcpy(&tdm_params, tdm_if_params, sizeof(MV_TDM_PARAMS));
-
-	/* Assign control callbacks */
-	tdm_if_register_ops = register_ops;
-	tdm_if_register_ops->tdm_if_ctl_ops.ctl_pcm_start = tdm_if_pcm_start;
-	tdm_if_register_ops->tdm_if_ctl_ops.ctl_pcm_stop = tdm_if_pcm_stop;
-
-	/* TDM init */
-	if(mvSysTdmInit(&tdm_params) != MV_OK) {
-			printk("%s: Error, TDM initialization failed !!!\n",__FUNCTION__);
-			return MV_ERROR;
-	}
-	tdm_init = 1;
-	
-	/* Register TDM interrupt */
-	if (request_irq(irqnr, tdm_if_isr, IRQF_DISABLED, "tdm", NULL)) {
-		printk("%s: Failed to connect irq(%d)\n", __FUNCTION__, irqnr);
-		return MV_ERROR;
-	}
-	irq_init = 1;
-	
-	/* Create TDM statistics proc directory & entries */
-	tdm_stats = proc_mkdir("tdm", NULL);
-	create_proc_read_entry("tdm_init", 0, tdm_stats, proc_tdm_init_read, NULL);
-	create_proc_read_entry("rx_overrun", 0, tdm_stats, proc_rx_miss_read, NULL);
-	create_proc_read_entry("tx_underrun", 0, tdm_stats, proc_tx_miss_read, NULL);
-
-	printk("Marvell Telephony Driver Loaded Successfully\n");
-
-	TRC_REC("<-%s\n", __FUNCTION__);
-	return MV_OK;
-}
-
-
-void tdm_if_exit(void)
-{
-	/* Check if already stopped */
-	if(!irq_init && !pcm_enable && !tdm_init)
-		return;
-
-	TRC_REC("->%s\n", __FUNCTION__);
-
-	if(irq_init) {
-		/* Release IRQ */
-		free_irq(irqnr, NULL);
-		irq_init = 0;
-	}
-
-	/* Stop PCM data sampling */
-	if(pcm_enable)
-		tdm_if_pcm_stop();
-
-	if(tdm_init) {
-#ifdef CONFIG_MV_TDM_SUPPORT
-		mvTdmRelease();
-#else
-		mvCommUnitRelease();
-		mvOsDelay(1000);
-#endif
-		tdm_init = 0;
-	}
-		
-	/* Remove proc directory & entries */
-	remove_proc_entry("tdm_init", tdm_stats);
-	remove_proc_entry("rx_overrun", tdm_stats);
-	remove_proc_entry("tx_underrun", tdm_stats);
-	remove_proc_entry("tdm", NULL);
-
-	TRC_REC("<-%s\n", __FUNCTION__);
-
-	TRC_OUTPUT();
-	TRC_RELEASE();
-}
-
-static void tdm_if_pcm_start(void)
-{
-	unsigned long flags;
-
-	TRC_REC("->%s\n", __FUNCTION__);
-
-	spin_lock_irqsave(&tdm_if_lock, flags);
-	if(!pcm_enable) {
-		rxBuff = txBuff = NULL;
-		pcm_enable = 1;
-#ifdef CONFIG_MV_TDM_SUPPORT
-		mvTdmPcmStart();
-#else
-		mvCommUnitPcmStart();
-#endif
-	}
-	spin_unlock_irqrestore(&tdm_if_lock, flags);
-
-	TRC_REC("<-%s\n", __FUNCTION__);
-	return;
-}
-
-static void tdm_if_pcm_stop(void)
-{
-	unsigned long flags;
-
-	TRC_REC("->%s\n", __FUNCTION__);
-
-	spin_lock_irqsave(&tdm_if_lock, flags);
-	if(pcm_enable) {
-		pcm_enable = 0;
-		rxBuff = txBuff = NULL;
-#ifdef CONFIG_MV_TDM_SUPPORT
-		mvTdmPcmStop();
-#else
-		mvCommUnitPcmStop();
-#endif
-	}
-	spin_unlock_irqrestore(&tdm_if_lock, flags);
-
-	TRC_REC("<-%s\n", __FUNCTION__);
-	return;
-}
-
-static irqreturn_t tdm_if_isr(int irq, void* dev_id)
-{
-	MV_TDM_INT_INFO tdm_int_info;
-	unsigned int int_type;
-
-	TRC_REC("->%s\n", __FUNCTION__);
-
-	/* Extract interrupt information from low level ISR */
-#ifdef CONFIG_MV_TDM_SUPPORT
-	mvTdmIntLow(&tdm_int_info);
-#else
-	mvCommUnitIntLow(&tdm_int_info);
-#endif
-
-	int_type = tdm_int_info.intType;
-	/*device_id = tdm_int_info.cs;*/
-	
-	/* Nothing to do - return */
-	if(int_type == MV_EMPTY_INT)
-		goto out;
-
-	/* Support multiple interrupt handling */
-	/* RX interrupt */
-	if(int_type & MV_RX_INT) {
-		if(rxBuff != NULL) {
-			rx_miss++;
-			TRC_REC("%s: Warning, missed Rx buffer processing !!!\n", __FUNCTION__);
-		}
-		else {
-			rxBuff = tdm_int_info.tdmRxBuff;
-
-			/* Schedule Rx processing within SOFT_IRQ context */
-			TRC_REC("%s: schedule Rx tasklet\n", __FUNCTION__);
-			tasklet_hi_schedule(&tdm_if_rx_tasklet);
-		}
-	}
-
-	/* TX interrupt */
-	if(int_type & MV_TX_INT) {
-		if(txBuff != NULL) {
-			tx_miss++;
-			TRC_REC("%s: Warning, missed Tx buffer processing !!!\n", __FUNCTION__);
-		}
-		else {
-			txBuff = tdm_int_info.tdmTxBuff;
-
-			/* Schedule Tx processing within SOFT_IRQ context */
-			TRC_REC("%s: schedule Tx tasklet\n", __FUNCTION__);
-			tasklet_hi_schedule(&tdm_if_tx_tasklet);
-		}
-	}
-
-	/* PHONE interrupt */
-	if(int_type & MV_PHONE_INT) {
-		/* TBD */
-	}
-
-	/* ERROR interrupt */
-	if(int_type & MV_ERROR_INT) {
-		printk("%s: Error was generated by TDM HW !!!\n",__FUNCTION__);
-	}
-
-
-out:
-	TRC_REC("<-%s\n", __FUNCTION__);
-	return IRQ_HANDLED;
-}
-
-/* Rx tasklet */
-static void tdm_if_pcm_rx_process(unsigned long arg)
-{
-	TRC_REC("->%s\n", __FUNCTION__);
-	if(pcm_enable) {
-		if(rxBuff == NULL) {
-			TRC_REC("%s: Error, empty Rx processing\n", __FUNCTION__);
-			return;
-		}
-
-		/* Fill TDM Rx aggregated buffer */
-#ifdef CONFIG_MV_TDM_SUPPORT
-		if(mvTdmRx(rxBuff) == MV_OK)
-#else
-		if(mvCommUnitRx(rxBuff) == MV_OK)
-#endif
-			tdm_if_register_ops->tdm_if_pcm_ops.pcm_rx_callback(rxBuff, buff_size); /* Dispatch Rx handler */
-		else
-			printk("%s: could not fill Rx buffer\n",__FUNCTION__);
-
-	}
-	
-	/* Clear rxBuff for next iteration */
-	rxBuff = NULL;
-
-	TRC_REC("<-%s\n", __FUNCTION__);
-	return;
-}
-
-/* Tx tasklet */
-static void tdm_if_pcm_tx_process(unsigned long arg)
-{
-	TRC_REC("->%s\n", __FUNCTION__);
-
-	if(pcm_enable) {
-		if(txBuff == NULL) {
-			TRC_REC("%s: Error, empty Tx processing\n", __FUNCTION__);
-			return;
-		}
-
-		/* Dispatch Tx handler */
-		tdm_if_register_ops->tdm_if_pcm_ops.pcm_tx_callback(txBuff, buff_size);
-
-#ifndef CONFIG_TDM_DEV_TEST_SUPPORT
-		/* Fill Tx aggregated buffer */
-#ifdef CONFIG_MV_TDM_SUPPORT
-		if(mvTdmTx(txBuff) != MV_OK)
-#else
-		if(mvCommUnitTx(txBuff) != MV_OK)
-#endif /* CONFIG_MV_TDM_SUPPORT */
-			printk("%s: could not fill Tx buffer\n",__FUNCTION__);
-#endif /* CONFIG_TDM_DEV_TEST_SUPPORT */
-
-	}
-
-	/* Clear txBuff for next iteration */
-	txBuff = NULL;
-
-	TRC_REC("<-%s\n",__FUNCTION__);
-	return;
-}
-
-void tdm_if_stats_get(tdm_if_stats_t* tdm_if_stats)
-{
-	tdm_if_stats->tdm_init = tdm_init;
-	tdm_if_stats->rx_overrun = rx_miss;
-	tdm_if_stats->tx_underrun = tx_miss;
-	
-	return;
-}
-
-static int __init tdm_if_module_init(void)
-{
-	/* The real init is done later */
-	return 0;
-}
-
-static void __exit tdm_if_module_exit(void)
-{
-	tdm_if_exit();
-	return;
-}
-
-/* Module stuff */
-module_init(tdm_if_module_init);
-module_exit(tdm_if_module_exit);
-MODULE_DESCRIPTION("Marvell TDM I/F Device Driver - www.marvell.com");
-MODULE_AUTHOR("Eran Ben-Avi <benavi@marvell.com>");
-MODULE_LICENSE("GPL");
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm_if.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm_if.h
deleted file mode 100644
index e924935..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm_if.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef _TDM_IF_H_
-#define _TDM_IF_H_
-
-#include "mvSysTdmApi.h"
-#ifdef CONFIG_MV_TDM_SUPPORT
- #include "voiceband/tdm/mvTdm.h"
-#else
- #include "voiceband/commUnit/mvCommUnit.h"
-#endif
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-#include "ctrlEnv/mvCtrlEnvLib.h"
-#include "boardEnv/mvBoardEnvLib.h"
-
-
-/* Structures */
-typedef struct {
-	int tdm_init;
-	unsigned int rx_overrun;
-	unsigned int tx_underrun;
-} tdm_if_stats_t;
-
-typedef struct {
-	MV_PCM_FORMAT pcm_format;
-	unsigned short pcm_slot[32];
-	unsigned char sampling_period;
-	unsigned short total_lines;
-} tdm_if_params_t;
-
-/* control callbacks */
-typedef struct {
-	void (*ctl_pcm_start)(void);
-	void (*ctl_pcm_stop)(void);
-} tdm_if_ctl_ops_t;
-
-/* pcm callbacks */
-typedef struct {
-	void (*pcm_tx_callback)(unsigned char* tx_buff, int size);
-	void (*pcm_rx_callback)(unsigned char* rx_buff, int size);
-} tdm_if_pcm_ops_t;
-
-typedef struct {
-	tdm_if_ctl_ops_t tdm_if_ctl_ops;
-	tdm_if_pcm_ops_t tdm_if_pcm_ops;
-} tdm_if_register_ops_t;
-
-/* APIs */
-void tdm_if_stats_get(tdm_if_stats_t* tdm_if_stats);
-MV_STATUS tdm_if_init(tdm_if_register_ops_t* register_ops, tdm_if_params_t* tdm_if_params);
-void tdm_if_exit(void);
-
-#endif /*_TDM_IF_H_*/
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/Makefile
deleted file mode 100644
index 7382c2a..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-#
-# Makefile for the Marvell Phone Device Driver Test Module
-#
-#
-ifneq ($(MACHINE),)
-include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-obj-$(CONFIG_TDM_DEV_TEST_SUPPORT) += tdm_dev.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/tdm_dev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/tdm_dev.c
deleted file mode 100644
index b5d7fe3..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/tdm_dev.c
+++ /dev/null
@@ -1,367 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include "tdm_dev.h"
-#include "mv_phone/tal.h"
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/poll.h>
-#include <linux/miscdevice.h>
-#ifdef CONFIG_MV_TDM_SUPPORT
- #include "voiceband/tdm/mvTdm.h"
-#else
- #include "voiceband/commUnit/mvCommUnit.h"
-#endif
-
-#define TDM_DEV_NAME 	"tdm"
-#define DISABLE		0
-#define ENABLE		1
-
-/* GLobals */
-static DECLARE_WAIT_QUEUE_HEAD(tdm_dev_wait);
-static DEFINE_SPINLOCK(tdm_dev_lock);
-static tal_params_t tdm_dev_params;
-static tal_mmp_ops_t tdm_dev_ops;
-static atomic_t tdm_init, rx_ready, tx_ready;
-static unsigned char *rx_buff_p = NULL, *tx_buff_p = NULL;
-
-
-/* Forward declarations */
-static int tdm_dev_tdm_start(unsigned long arg);
-static ssize_t tdm_dev_read(struct file *file_p, char __user *buf, size_t size, loff_t * ppos);
-static ssize_t tdm_dev_write(struct file *file_p, const char __user *buf, size_t size, loff_t * ppos);
-static unsigned int tdm_dev_poll(struct file *file_p, poll_table *poll_table_p);
-static int tdm_dev_ioctl(struct inode *inode_p, struct file *file_p, unsigned int cmd, unsigned long arg);
-static int tdm_dev_open(struct inode *inode_p, struct file *file_p);
-static int tdm_dev_release(struct inode *inode_p, struct file *file_p);
-void tdm_dev_tx_callback(unsigned char* tx_buff, int size);
-void tdm_dev_rx_callback(unsigned char* rx_buff, int size);
-static int __init tdm_dev_init(void);
-static void __exit tdm_dev_exit(void);
-
-static struct file_operations tdm_dev_fops = {
-    owner:      THIS_MODULE,
-    llseek:     NULL,
-    read:       tdm_dev_read,
-    write:      tdm_dev_write,
-    poll:       tdm_dev_poll,
-    ioctl:      tdm_dev_ioctl,
-    open:       tdm_dev_open,
-    release:    tdm_dev_release,
-    fasync:     NULL
-};
-
-static struct miscdevice tdm_dev_misc_dev = {
-	.minor = TDMDEV_MINOR,
-	.name = TDM_DEV_NAME,
-	.fops = &tdm_dev_fops,
-};
-
-
-static int __init tdm_dev_init(void)
-{
-	int status;
-
-	printk("Loading Marvell tdm device\n");
-	status = misc_register(&tdm_dev_misc_dev);
-
-	/* Register tdm device */
-	if (status < 0) {
-		printk("Error, failed to load %s device(status %d)\n", TDM_DEV_NAME, status);
-		return status;
-	}
-
-	atomic_set(&tdm_init, DISABLE);
-
-	return 0;
-}
-
-static int tdm_dev_tdm_start(unsigned long arg)
-{
-	tdm_dev_params_t data;
-	int i;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(tdm_dev_params_t))) {
-		printk("%s: copy_from_user failed\n", __FUNCTION__);
-		return -EFAULT;
-	}
-
-	/* Check parameters */
-	if((data.pcm_format != 1) && (data.pcm_format != 2) && (data.pcm_format != 4)) {
-		printk("%s: bad parameter(pcm_format=%u)\n", __FUNCTION__, data.pcm_format);
-		return -EFAULT;
-	}
-
-	if(data.total_lines > MV_TDM_TOTAL_CHANNELS) {
-		printk("%s: bad parameter(data.total_lines=%u)\n", __FUNCTION__, data.total_lines);
-		return -EFAULT;
-	}
-
-	tdm_dev_params.pcm_format = (tal_pcm_format_t)data.pcm_format;
-	/* Fill time slot table */
-	for(i = 0; i < data.total_lines; i++)
-		tdm_dev_params.pcm_slot[i] = (i * data.pcm_format);
-
-	tdm_dev_params.sampling_period = 10;
-	tdm_dev_params.total_lines = data.total_lines;
-
-	/* Assign Rx/Tx callbacks */
-	tdm_dev_ops.tal_mmp_rx_callback = tdm_dev_rx_callback;
-	tdm_dev_ops.tal_mmp_tx_callback = tdm_dev_tx_callback;
-
-	if(tal_init(&tdm_dev_params, &tdm_dev_ops) != MV_OK) {
-		printk("%s: Error, could not init tdm driver\n",__FUNCTION__);
-		return -EFAULT;
-	}
-
-	/* Prepare globals */
-	atomic_set(&tdm_init, ENABLE);
-	atomic_set(&rx_ready, DISABLE);
-	atomic_set(&tx_ready, DISABLE);
-	rx_buff_p = NULL;
-	tx_buff_p = NULL;
-
-	return 0;
-}
-
-static ssize_t tdm_dev_read(struct file *file_p, char __user *buf, size_t size, loff_t * ppos)
-{
-	TRC_REC("->%s\n",__FUNCTION__);
-
-	if(rx_buff_p != NULL) {
-		memcpy(buf, rx_buff_p, size);
-		rx_buff_p = NULL;
-		atomic_set(&rx_ready, DISABLE);
-	}
-	else
-		TRC_REC("%s: missed Rx buffer\n",__FUNCTION__);
-
-	TRC_REC("<-%s\n",__FUNCTION__);
-
-	return size;
-}
-
-static ssize_t tdm_dev_write(struct file *file_p, const char __user *buf, size_t size, loff_t * ppos)
-{
-	unsigned long flags = 0;
-	MV_STATUS status;
-
-	TRC_REC("->%s\n",__FUNCTION__);
-
-	if(tx_buff_p != NULL) {
-		memcpy(tx_buff_p, buf, size);
-		atomic_set(&tx_ready, DISABLE);
-		spin_lock_irqsave(&tdm_dev_lock, flags);
-#ifdef CONFIG_MV_TDM_SUPPORT
-		status = mvTdmTx(tx_buff_p);
-#else
-		status = mvCommUnitTx(tx_buff_p);
-#endif
-		spin_unlock_irqrestore(&tdm_dev_lock, flags);
-		tx_buff_p = NULL;
-		if(status != MV_OK)
-			printk("%s: could not fill Tx buffer\n",__FUNCTION__);
-	}
-	else
-		TRC_REC("%s: missed Tx buffer\n",__FUNCTION__);
-
-	TRC_REC("<-%s\n",__FUNCTION__);
-
-	return size;
-}
-
-static unsigned int tdm_dev_poll(struct file *file_p, poll_table *poll_table_p)
-{
-	int mask = 0;
-
-	TRC_REC("->%s\n",__FUNCTION__);
-
-	poll_wait(file_p, &tdm_dev_wait, poll_table_p);
-
-	if(atomic_read(&rx_ready)) {
-		mask |= POLLIN | POLLRDNORM;	/* readable */
-		TRC_REC("poll can read\n");
-	}
-
-	if(atomic_read(&tx_ready)) {
-		mask |= POLLOUT | POLLWRNORM;	/* writable */
-		TRC_REC("poll can write\n");
-	}
-
-	TRC_REC("<-%s\n",__FUNCTION__);
-	return mask;
-}
-
-static int tdm_dev_ioctl(struct inode *inode_p, struct file *file_p, unsigned int cmd, unsigned long arg)
-{
-	int ret = 0;
-
-	/* Argument checking */
-	if (_IOC_TYPE(cmd) != TDM_DEV_IOCTL_MAGIC) {
-		printk("%s: invalid TDM DEV Magic Num %i %i\n", __FUNCTION__, _IOC_TYPE(cmd), TDM_DEV_IOCTL_MAGIC);
-		return -ENOTTY;
-	}
-
-	if ((_IOC_NR(cmd) > TDM_DEV_IOCTL_MAX) || (_IOC_NR(cmd) < TDM_DEV_IOCTL_MIN)) {
-		printk("%s: invalid TDM DEV IOCTL request\n", __FUNCTION__);
-		return -ENOTTY;
-	}
-
-	if (_IOC_DIR(cmd) & _IOC_READ) {
-		ret = !access_ok(VERIFY_WRITE, (void __user*)arg, _IOC_SIZE(cmd));
-	} 
-	else if (_IOC_DIR(cmd) & _IOC_WRITE) {
-		ret = !access_ok(VERIFY_READ, (void __user*)arg, _IOC_SIZE(cmd));
-	}
-
-	if (ret) {
-		printk("%s: invalid TDM DEV access type %i from cmd %i\n", __FUNCTION__, _IOC_DIR(cmd), cmd);
-		return -EFAULT;
-	}
-
-	switch (cmd) {
-		case TDM_DEV_TDM_START:
-			printk("ioctl: TDM_DEV_TDM_START\n");
-			ret = tdm_dev_tdm_start(arg);
-			break;
-
-		case TDM_DEV_TDM_STOP:
-			printk("ioctl: TDM_DEV_TDM_STOP\n");
-			atomic_set(&tdm_init, DISABLE);
-			tal_exit();
-			break;
-
-		case TDM_DEV_PCM_START:
-			printk("ioctl: TDM_DEV_PCM_START\n");
-			atomic_set(&rx_ready, DISABLE);
-			atomic_set(&tx_ready, DISABLE);
-			rx_buff_p = NULL;
-			tx_buff_p = NULL;
-			tal_pcm_start();
-			break;
-
-		case TDM_DEV_PCM_STOP:
-			printk("ioctl: TDM_DEV_PCM_STOP\n");
-			tal_pcm_stop();
-			break;
-	}
-
-	return ret;
-}
-static int tdm_dev_open(struct inode *inode_p, struct file *file_p)
-{
-	try_module_get(THIS_MODULE);
-	return 0;
-}
-
-static int tdm_dev_release(struct inode *inode_p, struct file *file_p)
-{
-	module_put(THIS_MODULE);
-	return 0;
-}
-
-void tdm_dev_tx_callback(unsigned char* tx_buff, int size)
-{
-	TRC_REC("->%s\n",__FUNCTION__);
-
-	tx_buff_p = tx_buff;
-	atomic_set(&tx_ready, ENABLE);
-	wake_up_interruptible(&tdm_dev_wait);
-
-	TRC_REC("<-%s\n",__FUNCTION__);
-	return;
-}
-
-void tdm_dev_rx_callback(unsigned char* rx_buff, int size)
-{
-	TRC_REC("->%s\n",__FUNCTION__);
-
-	rx_buff_p = rx_buff;
-	atomic_set(&rx_ready, ENABLE);
-	wake_up_interruptible(&tdm_dev_wait);
-
-	TRC_REC("<-%s\n",__FUNCTION__);
-	return;
-}
-
-static void __exit tdm_dev_exit(void)
-{
-	printk("Marvell telephony test device exits\n");
-
-	/* Stop TDM channels and release all resources */
-	tal_exit();
-
-	/* Unregister tdm misc device */
-	misc_deregister(&tdm_dev_misc_dev);
-}
-
-/* Module stuff */
-module_init(tdm_dev_init);
-module_exit(tdm_dev_exit);
-MODULE_DESCRIPTION("Marvell Telephony Test Device - www.marvell.com");
-MODULE_AUTHOR("Eran Ben-Avi <benavi@marvell.com>");
-MODULE_LICENSE("GPL");
-
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/tdm_dev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/tdm_dev.h
deleted file mode 100644
index b09d656..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/tdm_dev.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef _TDM_DEV_H_
-#define _TDM_DEV_H_
-
-#define TDM_DEV_IOCTL_MAGIC		't'
-
-#define TDM_DEV_IOCTL_MIN 		1
-
-#define TDM_DEV_TDM_START		_IOWR(TDM_DEV_IOCTL_MAGIC, 1, tdm_dev_params_t)
-#define TDM_DEV_TDM_STOP		_IO(TDM_DEV_IOCTL_MAGIC, 2)
-#define TDM_DEV_PCM_START		_IO(TDM_DEV_IOCTL_MAGIC, 3)
-#define TDM_DEV_PCM_STOP		_IO(TDM_DEV_IOCTL_MAGIC, 4)
-
-#define TDM_DEV_IOCTL_MAX 		4
-
-typedef struct tdm_dev_params {
-	unsigned char pcm_format;
-	unsigned short total_lines;
-} tdm_dev_params_t;
-
-/* APIs */
-
-#endif /*_TDM_DEV_H_*/
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/vpapi_dev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/vpapi_dev.c
deleted file mode 100644
index 99346d9..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/vpapi_dev.c
+++ /dev/null
@@ -1,1027 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include <linux/poll.h>
-#include <linux/miscdevice.h>
-#include <linux/slab.h>
-#include "vpapi_dev.h"
-
-#if !defined(CONFIG_MV_TDM_SUPPORT) && defined(CONFIG_ZARLINK_SLIC_VE880)
-#include "gpp/mvGppRegs.h"
-#endif
-
-/* Defines */
-#define GET_DEV_STATUS(deviceId)	vpapi_dev_status[deviceId]
-#define GET_LINE_STATUS(lineId)		vpapi_line_status[lineId]
-#define REGISTER_DEVICE(deviceId)	\
-	vpapi_dev_status[deviceId] = 1;
-#define REGISTER_LINE(lineId)		\
-	vpapi_line_status[lineId] = 1;
-
-#define MAX_PROFILE_SIZE		128
-#define GET_DEVICE(lineId)		(lineId/MAX_LINES_PER_DEVICE)
-#define GET_LINE(lineId)		(lineId % MAX_LINES_PER_DEVICE)
-#define MAX_EVENT_QUEUE_SIZE		256
-#define VPAPI_TICK_TIMER_PERIOD		1
-#define VPAPI_MOD_NAME                  "vpapi"
-
-/* VE880 */
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-
-#define MAX_DEVICES			2
-#define MAX_LINES			4
-#define MAX_LINES_PER_DEVICE		2
-	
-static VpDevCtxType pDevCtx[MAX_DEVICES];
-static VpLineCtxType pLineCtx[MAX_DEVICES][MAX_LINES_PER_DEVICE];
-static Vp880DeviceObjectType pDevObj[MAX_DEVICES];
-static Vp880LineObjectType pLineObj[MAX_DEVICES][MAX_LINES_PER_DEVICE];
-
-/* VE792 */
-#elif defined(CONFIG_ZARLINK_SLIC_VE792)
-
-#define MAX_DEVICES			4
-#define MAX_LINES			32
-#define MAX_LINES_PER_DEVICE		8
-
-static VpDevCtxType pDevCtx[MAX_DEVICES];
-static VpLineCtxType pLineCtx[MAX_DEVICES][MAX_LINES_PER_DEVICE];
-static Vp792DeviceObjectType pDevObj[MAX_DEVICES];
-static Vp792LineObjectType pLineObj[MAX_DEVICES][MAX_LINES_PER_DEVICE];
-
-extern int BattOn(int vbhSetting, int vblSetting, int vbpSetting);
-extern int BattOff(void);
-
-#endif
-
-
-#if !defined(CONFIG_MV_TDM_SUPPORT) && defined(CONFIG_ZARLINK_SLIC_VE880) 
-static irqreturn_t vpapi_slic_isr(int irq, void* dev_id);
-#endif
-static void vpapi_tick_handler(unsigned long data);
-static ssize_t vpapi_read(struct file *file, char __user *buf, size_t size, loff_t * ppos);
-static ssize_t vpapi_write(struct file *file, const char __user *buf, size_t size, loff_t * ppos);
-static unsigned int vpapi_poll(struct file *pFile, poll_table *pPollTable);
-static int vpapi_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg);
-static int vpapi_open(struct inode *pInode, struct file *pFile);
-static int vpapi_release(struct inode *pInode, struct file *pFile);
-//static int __init vpapi_module_init(void);
-//static void __exit vpapi_module_exit(void);
-
-/* VP-API-II Dispatchers */
-static int vpapi_make_dev_object(unsigned long arg);
-static int vpapi_make_line_object(unsigned long arg);
-static int vpapi_map_line_id(unsigned long arg);
-static int vpapi_map_slac_id(unsigned long arg);
-static int vpapi_free_line_context(unsigned long arg);
-static int vpapi_init_device(unsigned long arg);
-static int vpapi_cal_line(unsigned long arg);
-static int vpapi_set_line_state(unsigned long arg);
-static int vpapi_set_option(unsigned long arg);
-int vpapi_get_event(unsigned long arg);
-#if defined(CONFIG_ZARLINK_SLIC_VE792)
-static int vpapi_batt_on(unsigned long arg);
-static int vpapi_batt_off(unsigned long arg);
-#endif
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-static int vpapi_reg_read(unsigned long arg);
-static int vpapi_reg_write(unsigned long arg);
-#endif
-
-/* Enumurators */
-typedef struct {
-	unsigned char valid;		/* valid event */
-	VpEventType vp_event;
-} vpapi_event;
-
-
-/* Structs */
-static struct file_operations vpapi_fops = {
-    owner:      THIS_MODULE,
-    llseek:     NULL,
-    read:       vpapi_read,
-    write:      vpapi_write,
-    poll:       vpapi_poll,
-    ioctl:      vpapi_ioctl,
-    open:       vpapi_open,
-    release:    vpapi_release,
-    fasync:     NULL
-};
-
-/* Globals */
-static DEFINE_SPINLOCK(vpapi_lock);
-static DECLARE_WAIT_QUEUE_HEAD(vpapi_wait);
-static atomic_t event_count;
-static atomic_t vpapi_init;
-static vpapi_event event_queue[MAX_EVENT_QUEUE_SIZE];
-static u8 vpapi_dev_status[MAX_DEVICES];
-static u8 vpapi_line_status[MAX_LINES];
-static volatile u32 next_event = 0, curr_event = 0;
-static struct timer_list vpapi_timer;
-static u16 total_devs = 0, total_lines = 0;
-
-
-static struct miscdevice vpapi_misc_dev = {
-	.minor = SLICDEV_MINOR,
-	.name = VPAPI_MOD_NAME,
-	.fops = &vpapi_fops,
-};
-
-static ssize_t vpapi_read(struct file *file, char __user *buf, size_t size, loff_t * ppos)
-{
-	return 0;
-}
-
-static ssize_t vpapi_write(struct file *file, const char __user *buf, size_t size, loff_t * ppos)
-{
-	return 0;
-}
-
-static unsigned int vpapi_poll(struct file *pFile, poll_table *pPollTable)
-{
-	int mask = 0;
-
-	poll_wait(pFile, &vpapi_wait, pPollTable);
-	
-	if(atomic_read(&event_count) > 0) {
-		mask |= POLLPRI;
-	}
-
-	return mask;
-}
-
-static int vpapi_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg)
-{
-	int ret = 0;
-	unsigned long flags = 0;
-
-	/* Argument checking */
-	if (_IOC_TYPE(cmd) != VPAPI_MOD_IOCTL_MAGIC) {
-		printk("%s: invalid VPAPI MOD Magic Num %i %i\n", __func__, _IOC_TYPE(cmd), VPAPI_MOD_IOCTL_MAGIC);
-		return -ENOTTY;
-	}
-
-	if ((_IOC_NR(cmd) > VPAPI_MOD_IOCTL_MAX) || (_IOC_NR(cmd) < VPAPI_MOD_IOCTL_MIN)) {
-		printk("%s: invalid VPAPI MOD IOCTL request\n", __func__);
-		return -ENOTTY;
-	}
-
-	if (_IOC_DIR(cmd) & _IOC_READ) {
-		ret = !access_ok(VERIFY_WRITE, (void __user*)arg, _IOC_SIZE(cmd));
-	} 
-	else if (_IOC_DIR(cmd) & _IOC_WRITE) {
-		ret = !access_ok(VERIFY_READ, (void __user*)arg, _IOC_SIZE(cmd));
-	}
-
-	if (ret) {
-		printk("%s: invalid VPAPI MOD access type %i from cmd %i\n", __func__, _IOC_DIR(cmd), cmd);
-		return -EFAULT;
-	}
-
-	spin_lock_irqsave(&vpapi_lock, flags);
-
-	switch (cmd) {
-		case VPAPI_MOD_IOX_MK_DEV_OBJ:
-			//printk("ioctl: VPAPI_MOD_IOX_MK_DEV_OBJ\n");
-			ret = vpapi_make_dev_object(arg);	
-			break;
-		
-		case VPAPI_MOD_IOX_MK_LN_OBJ:
-			//printk("ioctl: VPAPI_MOD_IOX_MK_LN_OBJ\n");
-			ret = vpapi_make_line_object(arg);
-			break;
-
-		case VPAPI_MOD_IOX_MAP_LN_ID:
-			//printk("ioctl: VPAPI_MOD_IOX_MAP_LN_ID\n");
-			ret = vpapi_map_line_id(arg);
-			break;
-
-		case VPAPI_MOD_IOX_MAP_SLAC_ID:
-			//printk("ioctl: VPAPI_MOD_IOX_MAP_SLAC_ID\n");
-			ret  = vpapi_map_slac_id(arg);
-			break;
-
-		case VPAPI_MOD_IOX_FREE_LN_CTX:
-			//printk("ioctl: VPAPI_MOD_IOX_FREE_LN_CTX\n");
-			ret = vpapi_free_line_context(arg);
-			break;
-
-		case VPAPI_MOD_IOX_INIT_DEV:
-			//printk("ioctl: VPAPI_MOD_IOX_INIT_DEV\n");
-			ret = vpapi_init_device(arg);
-			break;
-
-		case VPAPI_MOD_IOX_CAL_LN:
-			//printk("ioctl: VPAPI_MOD_IOX_CAL_LN\n");
-			ret = vpapi_cal_line(arg);
-			break;
-
-		case VPAPI_MOD_IOX_SET_LN_ST:
-			//printk("ioctl: VPAPI_MOD_IOX_SET_LN_ST\n");
-			ret = vpapi_set_line_state(arg);
-			break;
-
-		case VPAPI_MOD_IOX_SET_OPTION:
-			//printk("ioctl: VPAPI_MOD_IOX_SET_OPTION\n");
-			ret = vpapi_set_option(arg);
-			break;
-
-		case VPAPI_MOD_IOX_GET_EVENT:
-			//printk("ioctl: VPAPI_MOD_IOX_GET_EVENT\n");
-			ret = vpapi_get_event(arg);
-			break;
-
-#if defined(CONFIG_ZARLINK_SLIC_VE792)		
-		case VPAPI_MOD_IOX_BATT_ON:
-			//printk("ioctl: VPAPI_MOD_IOX_BATT_ON\n");
-			ret = vpapi_batt_on(arg);
-			break;
-
-		case VPAPI_MOD_IOX_BATT_OFF:
-			//printk("ioctl: VPAPI_MOD_IOX_BATT_OFF\n");
-			ret = vpapi_batt_off(arg);
-			break;
-#endif
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-		case VPAPI_MOD_IOX_REG_READ:
-			ret = vpapi_reg_read(arg);
-			break;
-
-		case VPAPI_MOD_IOX_REG_WRITE:
-			ret = vpapi_reg_write(arg);
-			break;
-#endif
-		default:
-			printk("%s: error, ioctl command(0x%x) not supported !!!\n", __func__, cmd);
-			ret = -EFAULT;
-			break;
-	}
-
-	spin_unlock_irqrestore(&vpapi_lock, flags);
-
-	return ret;
-}
-
-static int vpapi_make_dev_object(unsigned long arg)
-{
-	VpApiModMkDevObjType data;
-	VpDeviceType deviceType;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMkDevObjType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	deviceType = data.deviceType;
-	deviceId = data.deviceId;
-	
-	data.status = VpMakeDeviceObject(deviceType, deviceId, &pDevCtx[deviceId], &pDevObj[deviceId]);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMkDevObjType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_make_line_object(unsigned long arg)
-{
-	VpApiModMkLnObjType data;
-	VpTermType termType;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMkLnObjType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	termType = data.termType;
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-
-	data.status = VpMakeLineObject(termType, lineId, &pLineCtx[deviceId][lineId],
-                        	&pLineObj[deviceId][lineId], &pDevCtx[deviceId]);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMkLnObjType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	
-	return 0;
-}
-
-static int vpapi_map_line_id(unsigned long arg)
-{
-	VpApiModMapLnIdType data;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMapLnIdType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-
-	data.status = VpMapLineId(&pLineCtx[deviceId][lineId], data.lineId);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMapLnIdType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_map_slac_id(unsigned long arg)
-{
-	VpApiModMapSlacIdType data;
-	VpDeviceIdType deviceId;
-	u8 slacId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMapSlacIdType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-	
-	deviceId = data.deviceId;
-	slacId = data.slacId;
-
-	data.status = VpMapSlacId(&pDevCtx[deviceId], slacId);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMapSlacIdType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-	
-}
-
-static int vpapi_free_line_context(unsigned long arg)
-{
-	VpApiModFreeLnCtxType data;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModFreeLnCtxType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-
-	data.status = VpFreeLineCtx(&pLineCtx[deviceId][lineId]);
-
-	if(data.status == VP_STATUS_SUCCESS)
-		vpapi_line_status[data.lineId] = 0;
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModFreeLnCtxType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_init_device(unsigned long arg)
-{
-	VpApiModInitDeviceType data;
-	VpDeviceIdType deviceId;
-	VpProfileDataType devProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType acProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType dcProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType ringProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType fxoAcProfile[MAX_PROFILE_SIZE];
-	VpProfileDataType fxoCfgProfile[MAX_PROFILE_SIZE];
-	VpProfilePtrType pDevProfile = NULL, pAcProfile = NULL;
-	VpProfilePtrType pDcProfile = NULL, pRingProfile = NULL;
-	VpProfilePtrType pFxoAcProfile = NULL, pFxoCfgProfile = NULL;
-	u16 devProfileSize, acProfileSize, dcProfileSize;
-	u16 ringProfileSize, fxoAcProfileSize, fxoCfgProfileSize;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModInitDeviceType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	deviceId = data.deviceId;
-	devProfileSize = data.devProfileSize;
-	acProfileSize = data.acProfileSize;
-	dcProfileSize = data.dcProfileSize;
-	ringProfileSize = data.ringProfileSize;
-	fxoAcProfileSize = data.fxoAcProfileSize;
-	fxoCfgProfileSize = data.fxoCfgProfileSize;
-
-	if(devProfileSize) {
-		/* Get device profile */
-		if(copy_from_user(devProfile, (void*)data.pDevProfile, (sizeof(VpProfileDataType)*devProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pDevProfile = devProfile;
-	}
-
-	if(acProfileSize) {
-		/* Get AC profile */
-		if(copy_from_user(acProfile, (void*)data.pAcProfile, (sizeof(VpProfileDataType)*acProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pAcProfile = acProfile;
-	}
-
-	if(dcProfileSize) {
-		/* Get DC profile */
-		if(copy_from_user(dcProfile, (void*)data.pDcProfile, (sizeof(VpProfileDataType)*dcProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pDcProfile = dcProfile;
-	}
-
-	if(ringProfileSize) {
-		/* Get ring profile */
-		if(copy_from_user(ringProfile, (void*)data.pRingProfile, (sizeof(VpProfileDataType)*ringProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pRingProfile = ringProfile;
-	}
-
-	if(fxoAcProfileSize) {
-		/* Get FXO AC profile */
-		if(copy_from_user(fxoAcProfile, (void*)data.pFxoAcProfile, (sizeof(VpProfileDataType)*fxoAcProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pFxoAcProfile = fxoAcProfile;
-	}
-
-	if(fxoCfgProfileSize) {
-		/* Get FXO configuration profile */
-		if(copy_from_user(fxoCfgProfile, (void*)data.pFxoCfgProfile,
-					 (sizeof(VpProfileDataType)*fxoCfgProfileSize))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-		}
-		pFxoCfgProfile = fxoCfgProfile;
-	}
-
-	data.status = VpInitDevice(&pDevCtx[deviceId], pDevProfile, pAcProfile, pDcProfile, pRingProfile,
-					 pFxoAcProfile, pFxoCfgProfile);
-
-	if(data.status == VP_STATUS_SUCCESS) {
-		total_devs++;
-		REGISTER_DEVICE(deviceId);
-
-		if(!atomic_read(&vpapi_init))
-			atomic_set(&vpapi_init, 1);
-	}
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModInitDeviceType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_cal_line(unsigned long arg)
-{
-	VpApiModCalLnType data;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModCalLnType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-
-	data.status = VpCalLine(&pLineCtx[deviceId][lineId]);
-
-	if(data.status == VP_STATUS_SUCCESS) {
-		total_lines++;
-		REGISTER_LINE(data.lineId);
-	}
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModCalLnType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_set_line_state(unsigned long arg)
-{
-	VpApiModSetLnStType data;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-	VpLineStateType state;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModSetLnStType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	lineId = GET_LINE(data.lineId);
-	deviceId = GET_DEVICE(data.lineId);
-	state = data.state;
-
-	data.status = VpSetLineState(&pLineCtx[deviceId][lineId], state);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModSetLnStType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_set_option(unsigned long arg)
-{
-	VpApiModSetOptionType data;
-	u8 lineRequest;
-	VpLineIdType lineId;
-	VpDeviceIdType deviceId;
-	VpOptionIdType option;
-	void *pOptInfo;
-	long size;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModSetOptionType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	option = data.option;
-	lineRequest = data.lineRequest;
-	deviceId = data.deviceId;
-	lineId = GET_LINE(data.lineId);
-
-	switch(option) {
-		case VP_OPTION_ID_TIMESLOT:
-			size = sizeof(VpOptionTimeslotType);
-			pOptInfo = (VpOptionTimeslotType*)kmalloc(size, GFP_KERNEL);
-			break;
-		case VP_OPTION_ID_CODEC:
-			size = sizeof(VpOptionCodecType);
-			pOptInfo = (VpOptionCodecType*)kmalloc(size, GFP_KERNEL);
-			break;
-		case VP_OPTION_ID_LOOPBACK:
-			size = sizeof(VpOptionLoopbackType);
-			pOptInfo = (VpOptionLoopbackType*)kmalloc(size, GFP_KERNEL);
-			break;
-		case VP_OPTION_ID_EVENT_MASK:
-			size = sizeof(VpOptionEventMaskType);
-			pOptInfo = (VpOptionEventMaskType*)kmalloc(size, GFP_KERNEL);
-			break;
-		default:
-			printk("%s: option(%d) not supported\n",__func__, option);
-			return -EFAULT;
-	}
-
-	/* Get option info */
-	if(copy_from_user(pOptInfo, (void*)data.pValue, size)) {
-			printk("%s: copy_from_user failed\n", __func__);
-			kfree(pOptInfo);
-			return -EFAULT;
-	}
-
-	/* Set option to line/device */
-	if(lineRequest)
-		data.status = VpSetOption(&pLineCtx[deviceId][lineId], VP_NULL, option, pOptInfo);
-	else
-		data.status = VpSetOption(VP_NULL, &pDevCtx[deviceId], option, pOptInfo);
-
-
-	kfree(pOptInfo);
-
-	/* Copy status back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModSetOptionType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-int vpapi_get_event(unsigned long arg)
-{
-	VpApiModGetEventType data;
-	VpDeviceIdType deviceId;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModGetEventType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	deviceId = data.deviceId;
-
-	if(atomic_read(&event_count) == 0) {
-		data.newEvent = FALSE;
-	}
-	else {
-		/* Copy event info back to user */
-		if(copy_to_user(data.pEvent, &event_queue[curr_event].vp_event, sizeof(VpEventType))) {
-			printk("%s: copy_to_user failed\n", __func__);
-			return  -EFAULT;
-		}
-
-		event_queue[curr_event].valid = 0;
-		data.newEvent = TRUE;
-		atomic_dec(&event_count);
-		curr_event++;
-		if(curr_event == MAX_EVENT_QUEUE_SIZE)
-			curr_event = 0;
-	}
-
-	/* Copy status and event info back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpApiModGetEventType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-#if defined(CONFIG_ZARLINK_SLIC_VE792)
-static int vpapi_batt_on(unsigned long arg)
-{
-	VpModBatteryOnType data;
-	int vbh, vbl, vbp;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpModBatteryOnType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-	
-	vbh = data.vbh;
-	vbl = data.vbl;
-	vbp = data.vbp;
-
-	data.status = BattOn(vbh, vbl, vbp);
-
-	/* Copy status and event info back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpModBatteryOnType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_batt_off(unsigned long arg)
-{
-	VpModBatteryOffType data;
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpModBatteryOffType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-	
-	data.status = BattOff();
-
-	/* Copy status and event info back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpModBatteryOffType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-#endif
-
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-static int vpapi_reg_read(unsigned long arg)
-{
-	VpModRegOpType data;
-	VpLineIdType	line_id;
-	unsigned char	cmd;
-	unsigned short  cmd_len;
-	unsigned char *buff_p = NULL;
-	unsigned char ec_val[] = {0x1, 0x2};
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpModRegOpType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	line_id = data.lineId;
-	cmd = data.cmd;
-	cmd_len = data.cmdLen;
-	buff_p = data.buff;
-
-	VpMpiCmd(GET_DEVICE(line_id), ec_val[GET_LINE(line_id)], (cmd | 1), cmd_len, buff_p);
-
-	/* Copy status and event info back to user */
-	if(copy_to_user((void*)arg, &data, sizeof(VpModRegOpType))) {
-		printk("%s: copy_to_user failed\n", __func__);
-		return  -EFAULT;
-	}
-
-	return 0;
-}
-
-static int vpapi_reg_write(unsigned long arg)
-{
-	VpModRegOpType data;
-	VpLineIdType	line_id;
-	unsigned char	cmd;
-	unsigned short  cmd_len;
-	unsigned char *buff_p = NULL;
-	unsigned char ec_val[] = {0x1, 0x2};
-
-	/* Get user data */
-	if(copy_from_user(&data, (void*)arg, sizeof(VpModRegOpType))) {
-			printk("%s: copy_from_user failed\n", __func__);
-			return -EFAULT;
-	}
-
-	line_id = data.lineId;
-	cmd = data.cmd;
-	cmd_len = data.cmdLen;
-	buff_p = data.buff;
-
-	VpMpiCmd(GET_DEVICE(line_id), ec_val[GET_LINE(line_id)], cmd, cmd_len, buff_p);
-
-	return 0;
-}
-#endif
-
-static int vpapi_open(struct inode *pInode, struct file *pFile)
-{
-	try_module_get(THIS_MODULE);
-	return 0;
-}
-
-static int vpapi_release(struct inode *pInode, struct file *pFile)
-{
-	module_put(THIS_MODULE);
-	return 0;
-}
-
-#if !defined(CONFIG_MV_TDM_SUPPORT) && defined(CONFIG_ZARLINK_SLIC_VE880) 
-static irqreturn_t vpapi_slic_isr(int irq, void* dev_id)
-{
-	unsigned int gpp;
-	unsigned int deviceId;
-
-	/* Mark interrupt/s for active SLAC device/s */
-	for(deviceId = 0; deviceId < MAX_DEVICES; deviceId++) {
-		if(GET_DEV_STATUS(deviceId))
-			VpVirtualISR(&pDevCtx[deviceId]);
-	}
-	//MV_REG_WRITE(MV_GPP_IRQ_CAUSE_REG(0), ~BIT23);
-
-	/* ack interrupt */
-	gpp = MV_REG_READ(GPP_DATA_IN_POL_REG(0));
-        gpp = gpp^(1 << 23);
-        MV_REG_WRITE(GPP_DATA_IN_POL_REG(0), gpp);
-	
-	return IRQ_HANDLED;
-}
-#endif
-
-#if defined(SLIC_TIMER_EVENT_SUPPORT)
-static void vpapi_tick_handler(unsigned long data)
-{
-	u8 deviceId;
-	unsigned long flags;
-	vpapi_event *pEvent;
-#if !defined(CONFIG_ZARLINK_SLIC_VE792)
-	MV_STD_BOOL eventStatus;
-#endif
-
-	/* Check if events are already active */
-	if(atomic_read(&vpapi_init) == 0)
-		goto timer_exit;
-
-	spin_lock_irqsave(&vpapi_lock, flags);
-
-	for(deviceId = 0; deviceId < MAX_DEVICES; deviceId++) {
-
-		if(GET_DEV_STATUS(deviceId) == 0)
-			continue;
-
-		/* Check for free resources */
-		if(atomic_read(&event_count) >= MAX_EVENT_QUEUE_SIZE)
-			goto timer_exit;
-
-#if !defined(CONFIG_ZARLINK_SLIC_VE792)
-		if(VP_STATUS_SUCCESS == VpApiTick(&pDevCtx[deviceId], &eventStatus)) {
-			if(eventStatus == TRUE) {
-#endif
-				pEvent = &event_queue[next_event];
-				while(VpGetEvent(&pDevCtx[deviceId], &pEvent->vp_event) == TRUE) {
-					if(pEvent->vp_event.status != VP_STATUS_SUCCESS) {
-						printk("%s: bad status(%d)\n", __func__, pEvent->vp_event.status);
-						break;
-					}
-					
-					if(pEvent->vp_event.eventId == 0)  {
-						printk("%s: warning, empty event\n", __func__);
-						break;
-					}
-					
-					next_event++;
-					if(next_event == MAX_EVENT_QUEUE_SIZE) {
-						next_event = 0;
-					}
-
-					atomic_inc(&event_count);
-					
-					if(pEvent->valid == 0) {
-						pEvent->valid = 1;			
-					}
-					else {
-						printk("%s: error, event(%u) was overrided\n", __func__, next_event);
-						break;
-					}
-
-					pEvent = &event_queue[next_event];
-				}
-#if !defined(CONFIG_ZARLINK_SLIC_VE792)
-			}
-		}
-#endif
-	}
-
-	
-	spin_unlock_irqrestore(&vpapi_lock, flags);
-
-timer_exit:
-
-	/* Checks if user application should be signaled */
-	if(atomic_read(&event_count) > 0) {
-		wake_up_interruptible(&vpapi_wait);
-	}
-
-	/* Schedule next timer tick */
-	vpapi_timer.expires = jiffies + VPAPI_TICK_TIMER_PERIOD;
-    	add_timer(&vpapi_timer);
-}
-#endif
-
-int __init vpapi_module_init(void)
-{
-	int status;
-
-	printk("Loading Marvell %s device\n", VPAPI_MOD_NAME);
-	status = misc_register(&vpapi_misc_dev);
-
-	/* Register VPAPI device module */
-	if (status < 0) {
-		printk("Error, failed to load %s module(%d)\n", VPAPI_MOD_NAME, status);
-		return status;
-	}
-
-	atomic_set(&vpapi_init, 0);
-	total_devs = 0;
-	total_lines = 0;
-	next_event = 0;
-	curr_event = 0;
-	memset(vpapi_dev_status, 0, MAX_DEVICES);
-	memset(vpapi_line_status, 0, MAX_LINES);
-
-	/* Reset event counter */
-	atomic_set(&event_count, 0);
-
-	/* Clear event queue */
-	memset(event_queue, 0, (MAX_EVENT_QUEUE_SIZE * sizeof(vpapi_event)));
-
-#if defined(SLIC_TIMER_EVENT_SUPPORT)
-	memset(&vpapi_timer, 0, sizeof(struct timer_list));
-	init_timer(&vpapi_timer);
-    	vpapi_timer.function = vpapi_tick_handler;
-    	vpapi_timer.data = -1;
-	vpapi_timer.expires = jiffies + VPAPI_TICK_TIMER_PERIOD;
-	add_timer(&vpapi_timer);
-#endif
-
-#if !defined(CONFIG_MV_TDM_SUPPORT) && defined(CONFIG_ZARLINK_SLIC_VE880)
-	/* Register SLIC interrupt */
-	if (request_irq((23+IRQ_GPP_START), vpapi_slic_isr, IRQF_DISABLED, "slic", event_queue)) {
-		printk("%s: Failed to connect irq(%d)\n", __func__, (23+IRQ_GPP_START));
-		return MV_ERROR;
-	}
-#endif
-
-	return 0;
-}
-
-void __exit vpapi_module_exit(void)
-{
-	printk("Unloading %s device module\n", VPAPI_MOD_NAME);
-
-#if defined(SLIC_TIMER_EVENT_SUPPORT)
-	del_timer(&vpapi_timer);
-#endif
-
-	/* Unregister VPAPI misc device */
-	misc_deregister(&vpapi_misc_dev);
-
-#if !defined(CONFIG_MV_TDM_SUPPORT) && defined(CONFIG_ZARLINK_SLIC_VE880)
-	free_irq((23+IRQ_GPP_START), event_queue);
-#endif
-
-	return;
-}
-
-/* Module stuff */
-module_init(vpapi_module_init);
-module_exit(vpapi_module_exit);
-MODULE_DESCRIPTION("Zarlink VPAPI-II Device");
-MODULE_AUTHOR("Eran Ben-Avi <benavi@marvell.com>");
-MODULE_LICENSE("GPL");
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/vpapi_dev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/vpapi_dev.h
deleted file mode 100644
index 96d2666..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/vpapi_dev.h
+++ /dev/null
@@ -1,266 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef _VPAPI_DEV_H_
-#define _VPAPI_DEV_H_
-
-#include "vp_api_common.h"
-#if defined(CONFIG_ZARLINK_SLIC_VE880)
-#include "vp880_api.h"
-#elif defined(CONFIG_ZARLINK_SLIC_VE792)
-#include "vp792_api.h"
-#endif
-
-#define VPAPI_MOD_IOCTL_MAGIC           'z'
-
-#define VPAPI_MOD_IOCTL_MIN 		1
-
-/* VP-API System Configuration Functions */
-#define VPAPI_MOD_IOX_MK_DEV_OBJ	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 1, VpApiModMkDevObjType)
-#define VPAPI_MOD_IOX_MK_LN_OBJ		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 2, VpApiModMkLnObjType)
-#define VPAPI_MOD_IOX_MAP_LN_ID		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 3, VpApiModMapLnIdType)
-#define VPAPI_MOD_IOX_MAP_SLAC_ID	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 4, VpApiModMapSlacIdType)
-#define VPAPI_MOD_IOX_FREE_LN_CTX	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 5, VpApiModFreeLnCtxType)
-
-/* VP-API Initialization Functions */
-#define VPAPI_MOD_IOX_INIT_DEV		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 6, VpApiModInitDeviceType)
-#define VPAPI_MOD_IOX_CAL_LN		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 7, VpApiModCalLnType)
-
-/* VP-API Control Functions */
-#define VPAPI_MOD_IOX_SET_LN_ST		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 8, VpApiModSetLnStType)
-#define VPAPI_MOD_IOX_SET_OPTION	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 9, VpApiModSetOptionType)
-
-/* VP-API Status and Query Functions */
-#define VPAPI_MOD_IOX_GET_EVENT		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 10, VpApiModGetEventType)
-
-/* VE792 Battery Control */
-#define VPAPI_MOD_IOX_BATT_ON		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 11, VpModBatteryOnType)
-#define VPAPI_MOD_IOX_BATT_OFF		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 12, VpModBatteryOffType)
-
-/* SLIC register read/write */
-#define VPAPI_MOD_IOX_REG_READ		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 13, VpModRegOpType)
-#define VPAPI_MOD_IOX_REG_WRITE		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 14, VpModRegOpType)
-
-#define VPAPI_MOD_IOCTL_MAX 		14
-#define MAX_SLIC_RDWR_BUFF_SIZE		128
-
-
-/******************** VP-API System Configuration Structs *********************/
-typedef struct VpApiModMkDevObj {
-	/* Input arg(s) */
-	VpDeviceType	deviceType;
-	VpDeviceIdType	deviceId;
-    
-	/* Output arg(s) */
-	VpStatusType		status;
-} VpApiModMkDevObjType;
-
-
-typedef struct VpApiModMkLnObj {
-	/* Input arg(s) */
-	VpTermType	termType;
-	VpLineIdType	lineId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModMkLnObjType;
-
-typedef struct VpApiModMapLnId {
-	/* Input arg(s) */
-	VpLineIdType	lineId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModMapLnIdType;
-
-typedef struct VpApiModMapSlacId {
- 	/* Input arg(s) */
-	VpDeviceIdType	deviceId;
-	unsigned char	slacId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModMapSlacIdType;
-
-typedef struct VpApiModFreeLnCtx {
- 	/* Input arg(s) */
-	VpLineIdType	lineId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModFreeLnCtxType;
-
-
-/************************ VP-API Initialization Structs ************************/
-typedef struct VpApiModInitDevice {
-    	/* Input arg(s) */
-	VpDeviceIdType		deviceId;
-	VpProfilePtrType	pDevProfile;
-	VpProfilePtrType	pAcProfile;
-	VpProfilePtrType	pDcProfile;
-	VpProfilePtrType	pRingProfile;
-	VpProfilePtrType	pFxoAcProfile;
-	VpProfilePtrType	pFxoCfgProfile;
-	unsigned short		devProfileSize;
-	unsigned short		acProfileSize;
-	unsigned short		dcProfileSize;
-	unsigned short		ringProfileSize;
-	unsigned short		fxoAcProfileSize;
-	unsigned short		fxoCfgProfileSize;
-
-	/* Output arg(s) */
-	VpStatusType		status;
-} VpApiModInitDeviceType;
-
-typedef struct VpApiModCalLn {
-	/* Input arg(s) */
-	VpLineIdType	lineId;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModCalLnType;
-
-
-/****************************VP-API Control Structs ***************************/
-typedef struct VpApiModSetLnSt {
-	/* Input arg(s) */
-	VpLineIdType	lineId;
-	VpLineStateType	state;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModSetLnStType;
-
-
-typedef struct VpApiModSetOption {
-	/* Input arg(s) */
-	unsigned char	lineRequest;
-	VpLineIdType	lineId;
-	VpDeviceIdType	deviceId;
-	VpOptionIdType	option;
-	void		*pValue;
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpApiModSetOptionType;
-
-#if 0
-typedef struct VpApiModLowLvlCmd {
-	/* Input arg(s) */
-	const VpModLineRegNumType	lineRegNum;
-	uint8				*pCmdData;
-	const uint8			len;
-	const uint16			handle;
-
-	/* Output arg(s) */
-	VpStatusType			status;
-} VpApiModLowLvlCmdType;
-#endif
-
-/********************** VP-API Status and Query Structs ***********************/
-typedef struct VpApiModGetEvent {
-	/* Input arg(s) */
-	VpDeviceIdType	deviceId;
-
-	/* Output arg(s) */
-	bool		newEvent;
-	VpEventType	*pEvent;
-} VpApiModGetEventType;
-
-/********************** VE792 Battery Control ***********************/
-typedef struct VpModBatteryOn {
-	/* Input arg(s) */
-	int	vbh;
-	int	vbl;
-	int	vbp;
-
-	/* Output arg(s) */
-	int	status;
-} VpModBatteryOnType;
-
-typedef struct VpModBatteryOff {
-
-	/* Output arg(s) */
-	int	status;
-} VpModBatteryOffType;
-
-/********************** SLIC register read/write ********************/
-typedef struct VpModRegOp {
-	/* Input arg(s) */
-	VpLineIdType	lineId;
-	unsigned char	cmd;
-	unsigned short  cmdLen;
-	unsigned char buff[MAX_SLIC_RDWR_BUFF_SIZE];
-
-	/* Output arg(s) */
-	VpStatusType	status;
-} VpModRegOpType;
-
-/* APIs */
-int vpapi_module_init(void);
-void vpapi_module_exit(void);
-
-
-#endif /*_VPAPI_DEV_H_*/
-
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.c b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.c
index ccab519..e8eafaa 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.c
+++ b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.c
@@ -245,7 +245,6 @@ MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 	/**********************/
 	/* MCSC Configuration */
 	/**********************/
-
 	if (IS_KW2_A0(ctrlModel, ctrlRev)) {
 		/* Disable Rx/Tx channel balancing & Linear mode fix */
 		MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TCBD_MASK);
@@ -474,8 +473,7 @@ MV_VOID mvCommUnitRelease(MV_VOID)
 		mvOsDelay(10);
 
 		/* Calculate total Rx/Tx buffer size */
-		buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels)
-				+ CPU_D_CACHE_LINE_SIZE;
+		buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels) + CPU_D_CACHE_LINE_SIZE;
 
 		/* Calculate total MCDMA Rx/Tx descriptors chain size */
 		totalRxDescSize = totalChannels * sizeof(MV_TDM_MCDMA_RX_DESC);
@@ -852,7 +850,7 @@ MV_STATUS mvCommUnitRx(MV_U8 *pTdmRxBuff)
 }
 
 /* Low level TDM interrupt service routine */
-MV_VOID mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo)
+MV_32 mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo)
 {
 	MV_U32 causeReg, maskReg, causeAndMask;
 	MV_U32 intAckBits = 0, currDesc;
@@ -896,7 +894,7 @@ MV_VOID mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo)
 	if (tdmEnable == MV_FALSE) {
 		MV_TRC_REC("TDM is disabled - quit low level ISR\n");
 		MV_REG_WRITE(TDM_CAUSE_REG, ~intAckBits);
-		return;
+		return 0;
 	}
 
 	/* Handle TDM Error/s */
@@ -944,7 +942,7 @@ MV_VOID mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo)
 	MV_REG_WRITE(TDM_CAUSE_REG, ~intAckBits);
 
 	TRC_REC("<-%s\n", __func__);
-	return;
+	return 0;
 }
 
 static MV_VOID mvCommUnitDescChainBuild(MV_VOID)
@@ -1014,9 +1012,12 @@ MV_VOID mvCommUnitShow(MV_VOID)
 			   (MV_U32) rxBuffPhys[index]);
 		mvOsPrintf("Tx Buff(%d): virt = 0x%x, phys = 0x%x\n", index, (MV_U32) txBuffVirt[index],
 			   (MV_U32) txBuffPhys[index]);
+
 		mvOsPrintf("Rx Desc(%d): virt = 0x%x, phys = 0x%x\n", index,
 			   (MV_U32) mcdmaRxDescPtr[index], (MV_U32) mcdmaRxDescPhys[index]);
+
 		mvOsPrintf("Tx Desc(%d): virt = 0x%x, phys = 0x%x\n", index,
 			   (MV_U32) mcdmaTxDescPtr[index], (MV_U32) mcdmaTxDescPhys[index]);
+
 	}
 }
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.h b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.h
index 620e458..966027d 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.h
+++ b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.h
@@ -188,7 +188,7 @@ extern "C" {
 /* CommUnit APIs */
 	MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *pTdmParams, MV_TDM_HAL_DATA *halData);
 	MV_STATUS mvCommUnitWinInit(MV_UNIT_WIN_INFO *pAddrWinMap);
-	MV_VOID mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo);
+	MV_32 mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo);
 	MV_VOID mvCommUnitPcmStart(MV_VOID);
 	MV_VOID mvCommUnitPcmStop(MV_VOID);
 	MV_STATUS mvCommUnitTx(MV_U8 *pTdmTxBuff);
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c
index eb76460..f1c0e2b 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c
+++ b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c
@@ -106,6 +106,20 @@ static MV_U8 factor;
 static MV_PCM_FORMAT pcmFormat;
 static MV_BAND_MODE tdmBandMode;
 static MV_TDM_CH_INFO *tdmChInfo[MV_TDM_TOTAL_CHANNELS] = { NULL, NULL };
+static volatile MV_U8 chanStopCount;
+
+static MV_U8 intLock;
+static MV_U32 intRxCount;
+static MV_U32 intTxCount;
+static MV_U32 intRx0Count;
+static MV_U32 intTx0Count;
+static MV_U32 intRx1Count;
+static MV_U32 intTx1Count;
+static MV_U32 intRx0Miss;
+static MV_U32 intTx0Miss;
+static MV_U32 intRx1Miss;
+static MV_U32 intTx1Miss;
+static MV_U32 pcmRestartCount;
 
 MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 {
@@ -119,9 +133,15 @@ MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 	/* Init globals */
 	rxInt = txInt = 0;
 	rxFull = txEmpty = BUFF_INVALID;
-	tdmEnable = 0;
+	tdmEnable = 0, intLock = 0;
 	spiMode = halData->spiMode;
 	pcmFormat = tdmParams->pcmFormat;
+	intRxCount = 0, intTxCount = 0;
+	intRx0Count = 0, intTx0Count = 0;
+	intRx1Count = 0, intTx1Count = 0;
+	intRx0Miss = 0, intTx0Miss = 0;
+	intRx1Miss = 0, intTx1Miss = 0;
+	pcmRestartCount = 0;
 
 	if (tdmParams->samplingPeriod > MV_TDM_MAX_SAMPLING_PERIOD)
 		factor = 1;	/* use base sample period(10ms) */
@@ -160,8 +180,8 @@ MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 	}
 
 	/* Config TDM */
-	MV_REG_BIT_RESET(TDM_SPI_MUX_REG, 1);	/* enable TDM/SPI interface */
-	MV_REG_BIT_SET(TDM_MISC_REG, BIT0);	/* sw reset to TDM for 5181L-A1 & up */
+	MV_REG_BIT_RESET(TDM_SPI_MUX_REG, BIT0);	/* enable TDM/SPI interface */
+	MV_REG_BIT_SET(TDM_MISC_REG, BIT0);		/* sw reset to TDM for 5181L-A1 & up */
 	MV_REG_WRITE(INT_RESET_SELECT_REG, CLEAR_ON_ZERO);	/* int cause is not clear on read */
 	MV_REG_WRITE(INT_EVENT_MASK_REG, 0x3ffff);	/* all interrupt bits latched in status */
 	MV_REG_WRITE(INT_STATUS_MASK_REG, 0);	/* disable interrupts */
@@ -344,6 +364,8 @@ MV_VOID mvTdmPcmStart(MV_VOID)
 	MV_TRC_REC("->%s\n", __func__);
 
 	tdmEnable = 1;		/* TDM is enabled  */
+	intLock = 0;
+	chanStopCount = 0;
 	mvTdmReset();
 
 	for (ch = 0; ch < MV_TDM_TOTAL_CHANNELS; ch++) {
@@ -471,9 +493,12 @@ MV_STATUS mvTdmRx(MV_U8 *tdmRxBuff)
 }
 
 /* Low level TDM interrupt service routine */
-MV_VOID mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo)
+MV_32 mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo)
 {
 	MV_U32 statusReg, maskReg, statusAndMask;
+	MV_32 ret = 0;
+	MV_32 intTxMiss = -1;
+	MV_32 intRxMiss = -1;
 	MV_U8 ch;
 
 	MV_TRC_REC("->%s\n", __func__);
@@ -512,68 +537,111 @@ MV_VOID mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo)
 	}
 
 	for (ch = 0; ch < MV_TDM_TOTAL_CHANNELS; ch++) {
-		if (statusAndMask & TDM_INT_TX(ch)) {
-			/* Give next buff to TDM and set curr buff as empty */
-			if ((statusAndMask & TX_BIT(ch)) && tdmEnable) {
-				MV_TRC_REC("Tx interrupt(ch%d) !!!\n", ch);
-
-				/* MV_OK -> Tx is done for both channels */
-				if (mvTdmChTxLow(ch) == MV_OK) {
-					MV_TRC_REC("Assign Tx aggregate buffer for further processing\n");
-					tdmIntInfo->tdmTxBuff = txAggrBuffVirt;
-					tdmIntInfo->intType |= MV_TX_INT;
+
+		/* Give next buff to TDM and set curr buff as empty */
+		if ((statusAndMask & TX_BIT(ch)) && tdmEnable && !intLock) {
+			MV_TRC_REC("Tx interrupt(ch%d) !!!\n", ch);
+
+			intTxCount++;
+			if (ch == 0) {
+				intTx0Count++;
+				if (intTx0Count <= intTx1Count) {
+					intTxMiss = 0;
+					intTx0Miss++;
+				}
+			} else {
+				intTx1Count++;
+				if (intTx1Count < intTx0Count) {
+					intTxMiss = 1;
+					intTx1Miss++;
 				}
 			}
 
-			if (statusAndMask & TX_UNDERFLOW_BIT(ch)) {
-				MV_TRC_REC("Tx underflow(ch%d) - checking for root cause...\n", ch);
-				if (tdmEnable) {
-					MV_TRC_REC("Tx underflow ERROR\n");
-					tdmIntInfo->intType |= MV_TX_ERROR_INT;
-					if (!(statusAndMask & TX_BIT(ch))) {
-						MV_TRC_REC("Trying to recover for ch(%d)\n", ch);
-						/* Set HW ownership */
-						MV_REG_BYTE_WRITE(CH_BUFF_OWN_REG(ch) + TX_OWN_BYTE_OFFS, OWN_BY_HW);
-						/* Enable Tx */
-						MV_REG_BYTE_WRITE(CH_ENABLE_REG(ch) + TX_ENABLE_BYTE_OFFS, CH_ENABLE);
-					}
-				} else {
-					MV_TRC_REC("Expected Tx underflow(not an error)\n");
-					MV_REG_WRITE(INT_STATUS_MASK_REG,
-						     MV_REG_READ(INT_STATUS_MASK_REG) & (~(TDM_INT_TX(ch))));
+			/* MV_OK -> Tx is done for both channels */
+			if (mvTdmChTxLow(ch) == MV_OK) {
+				MV_TRC_REC("Assign Tx aggregate buffer for further processing\n");
+				tdmIntInfo->tdmTxBuff = txAggrBuffVirt;
+				tdmIntInfo->intType |= MV_TX_INT;
+			}
+		}
+	}
+
+	for (ch = 0; ch < MV_TDM_TOTAL_CHANNELS; ch++) {
+
+		if ((statusAndMask & RX_BIT(ch)) && tdmEnable && !intLock) {
+			MV_TRC_REC("Rx interrupt(ch%d) !!!\n", ch);
+
+			intRxCount++;
+			if (ch == 0) {
+				intRx0Count++;
+				if (intRx0Count <= intRx1Count) {
+					intRxMiss = 0;
+					intRx0Miss++;
 				}
+			} else {
+				intRx1Count++;
+				if (intRx1Count < intRx0Count) {
+					intRxMiss = 1;
+					intRx1Miss++;
+				}
+			}
+
+			/* MV_OK -> Rx is done for both channels */
+			if (mvTdmChRxLow(ch) == MV_OK) {
+				MV_TRC_REC("Assign Rx aggregate buffer for further processing\n");
+				tdmIntInfo->tdmRxBuff = rxAggrBuffVirt;
+				tdmIntInfo->intType |= MV_RX_INT;
 			}
 		}
+	}
 
-		if (statusAndMask & TDM_INT_RX(ch)) {
-			if ((statusAndMask & RX_BIT(ch)) && tdmEnable) {
-				MV_TRC_REC("Rx interrupt(ch%d) !!!\n", ch);
+	for (ch = 0; ch < MV_TDM_TOTAL_CHANNELS; ch++) {
 
-				/* MV_OK -> Rx is done for both channels */
-				if (mvTdmChRxLow(ch) == MV_OK) {
-					MV_TRC_REC("Assign Rx aggregate buffer for further processing\n");
-					tdmIntInfo->tdmRxBuff = rxAggrBuffVirt;
-					tdmIntInfo->intType |= MV_RX_INT;
+		if (statusAndMask & TX_UNDERFLOW_BIT(ch)) {
+
+			MV_TRC_REC("Tx underflow(ch%d) - checking for root cause...\n", ch);
+			if (tdmEnable) {
+				MV_TRC_REC("Tx underflow ERROR\n");
+				tdmIntInfo->intType |= MV_TX_ERROR_INT;
+				if (!(statusAndMask & TX_BIT(ch))) {
+					ret = -1;
+					/* MV_OK -> Tx is done for both channels */
+					if (mvTdmChTxLow(ch) == MV_OK) {
+						MV_TRC_REC("Assign Tx aggregate buffer for further processing\n");
+						tdmIntInfo->tdmTxBuff = txAggrBuffVirt;
+						tdmIntInfo->intType |= MV_TX_INT;
+					}
 				}
+			} else {
+				MV_TRC_REC("Expected Tx underflow(not an error)\n");
+				tdmIntInfo->intType |= MV_CHAN_STOP_INT;
+				tdmIntInfo->data = ++chanStopCount; /* Update number of channels already stopped */
+				MV_REG_WRITE(INT_STATUS_MASK_REG,
+					MV_REG_READ(INT_STATUS_MASK_REG) & (~(TDM_INT_TX(ch))));
 			}
+		}
+
 
-			if (statusAndMask & RX_OVERFLOW_BIT(ch)) {
-				MV_TRC_REC("Rx overflow(ch%d) - checking for root cause...\n", ch);
-				if (tdmEnable) {
-					MV_TRC_REC("Rx overflow ERROR\n");
-					tdmIntInfo->intType |= MV_RX_ERROR_INT;
-					if (!(statusAndMask & RX_BIT(ch))) {
-						MV_TRC_REC("Trying to recover for ch(%d)\n", ch);
-						/* Set HW ownership */
-						MV_REG_BYTE_WRITE(CH_BUFF_OWN_REG(ch) + RX_OWN_BYTE_OFFS, OWN_BY_HW);
-						/* Enable Rx */
-						MV_REG_BYTE_WRITE(CH_ENABLE_REG(ch) + RX_ENABLE_BYTE_OFFS, CH_ENABLE);
+		if (statusAndMask & RX_OVERFLOW_BIT(ch)) {
+			MV_TRC_REC("Rx overflow(ch%d) - checking for root cause...\n", ch);
+			if (tdmEnable) {
+				MV_TRC_REC("Rx overflow ERROR\n");
+				tdmIntInfo->intType |= MV_RX_ERROR_INT;
+				if (!(statusAndMask & RX_BIT(ch))) {
+					ret = -1;
+					/* MV_OK -> Rx is done for both channels */
+					if (mvTdmChRxLow(ch) == MV_OK) {
+						MV_TRC_REC("Assign Rx aggregate buffer for further processing\n");
+						tdmIntInfo->tdmRxBuff = rxAggrBuffVirt;
+						tdmIntInfo->intType |= MV_RX_INT;
 					}
-				} else {
-					MV_TRC_REC("Expected Rx overflow(not an error)\n");
-					MV_REG_WRITE(INT_STATUS_MASK_REG,
-						     MV_REG_READ(INT_STATUS_MASK_REG) & (~(TDM_INT_RX(ch))));
 				}
+			} else {
+				MV_TRC_REC("Expected Rx overflow(not an error)\n");
+				tdmIntInfo->intType |= MV_CHAN_STOP_INT;
+				tdmIntInfo->data = ++chanStopCount; /* Update number of channels already stopped */
+				MV_REG_WRITE(INT_STATUS_MASK_REG,
+					     MV_REG_READ(INT_STATUS_MASK_REG) & (~(TDM_INT_RX(ch))));
 			}
 		}
 	}
@@ -581,8 +649,32 @@ MV_VOID mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo)
 	/* clear TDM interrupts */
 	MV_REG_WRITE(INT_STATUS_REG, ~statusReg);
 
+	/* Check if interrupt was missed -> restart */
+	if  (intTxMiss != -1)  {
+		MV_TRC_REC("Missing Tx Interrupt Detected ch%d!!!\n", intTxMiss);
+		if (intTxMiss)
+			intTx1Count = intTx0Count;
+		else
+			intTx0Count  = (intTx1Count + 1);
+		ret = -1;
+	}
+
+	if  (intRxMiss != -1)  {
+		MV_TRC_REC("Missing Rx Interrupt Detected ch%d!!!\n", intRxMiss);
+		if (intRxMiss)
+			intRx1Count = intRx0Count;
+		else
+			intRx0Count  = (intRx1Count + 1);
+		ret = -1;
+	}
+
+	if (ret == -1) {
+		intLock = 1;
+		pcmRestartCount++;
+	}
+
 	MV_TRC_REC("<-%s\n", __func__);
-	return;
+	return ret;
 }
 
 static INLINE MV_STATUS mvTdmChTxLow(MV_U8 ch)
@@ -933,3 +1025,41 @@ MV_VOID mvTdmIntDisable(MV_VOID)
 
 	MV_TRC_REC("<-%s\n", __func__);
 }
+
+MV_VOID mvTdmPcmIfReset(MV_VOID)
+{
+	MV_TRC_REC("->%s\n", __func__);
+
+	MV_REG_BIT_RESET(PCM_CTRL_REG, BIT0);
+
+	/* Wait a bit - might be fine tuned */
+	mvOsDelay(5);
+
+	MV_REG_BIT_SET(TDM_SPI_MUX_REG, BIT0);	/* Disable TDM/SPI interface */
+
+	MV_REG_WRITE(TDM_MISC_REG, 0);		/* SW PCM reset */
+
+	/* Wait a bit more - might be fine tuned */
+	mvOsDelay(100);
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+#ifdef MV_TDM_EXT_STATS
+MV_VOID mvTdmExtStatsGet(MV_TDM_EXTENDED_STATS *tdmExtStats)
+{
+	tdmExtStats->intRxCount = intRxCount;
+	tdmExtStats->intTxCount = intTxCount;
+	tdmExtStats->intRx0Count = intRx0Count;
+	tdmExtStats->intTx0Count = intTx0Count;
+	tdmExtStats->intRx1Count = intRx1Count;
+	tdmExtStats->intTx1Count = intTx1Count;
+	tdmExtStats->intRx0Miss = intRx0Miss;
+	tdmExtStats->intTx0Miss = intTx0Miss;
+	tdmExtStats->intRx1Miss = intRx1Miss;
+	tdmExtStats->intTx1Miss = intTx1Miss;
+	tdmExtStats->pcmRestartCount = pcmRestartCount;
+
+	return;
+}
+#endif
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h
index 3909a7f..7f4e826 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h
+++ b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h
@@ -92,6 +92,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define	MV_RX_ERROR_INT 	BIT3
 #define	MV_TX_ERROR_INT 	BIT4
 #define MV_DMA_ERROR_INT	BIT5
+#define MV_CHAN_STOP_INT	BIT6
 #define MV_ERROR_INT		(MV_RX_ERROR_INT | MV_TX_ERROR_INT | MV_DMA_ERROR_INT)
 
 /* PCM SLOT configuration */
@@ -147,6 +148,7 @@ typedef struct {
 	MV_U8 *tdmTxBuff;
 	MV_U32 intType;
 	MV_U8 cs;
+	MV_U8 data;
 } MV_TDM_INT_INFO;
 
 typedef struct {
@@ -164,11 +166,27 @@ typedef struct {
 	MV_FRAME_TS frameTs;
 } MV_TDM_HAL_DATA;
 
+#ifdef MV_TDM_EXT_STATS
+typedef struct {
+	MV_U32 intRxCount;
+	MV_U32 intTxCount;
+	MV_U32 intRx0Count;
+	MV_U32 intTx0Count;
+	MV_U32 intRx1Count;
+	MV_U32 intTx1Count;
+	MV_U32 intRx0Miss;
+	MV_U32 intTx0Miss;
+	MV_U32 intRx1Miss;
+	MV_U32 intTx1Miss;
+	MV_U32 pcmRestartCount;
+} MV_TDM_EXTENDED_STATS;
+#endif
+
 /* APIs */
 MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData);
 MV_STATUS mvTdmWinInit(MV_UNIT_WIN_INFO *addrWinMap);
 MV_VOID mvTdmRelease(MV_VOID);
-MV_VOID mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo);
+MV_32 mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo);
 MV_VOID mvTdmPcmStart(MV_VOID);
 MV_VOID mvTdmPcmStop(MV_VOID);
 MV_STATUS mvTdmTx(MV_U8 *tdmTxBuff);
@@ -180,4 +198,9 @@ MV_U8 currRxSampleGet(MV_U8 ch);
 MV_U8 currTxSampleGet(MV_U8 ch);
 MV_VOID mvTdmIntEnable(MV_VOID);
 MV_VOID mvTdmIntDisable(MV_VOID);
+MV_VOID mvTdmPcmIfReset(MV_VOID);
+#ifdef MV_TDM_EXT_STATS
+MV_VOID mvTdmExtStatsGet(MV_TDM_EXTENDED_STATS *tdmExtStats);
+#endif
+
 #endif /* __INCmvTdmh */
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdmAddrDec.c b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdmAddrDec.c
index 8e633954..bb3d6e2 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdmAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdmAddrDec.c
@@ -174,7 +174,7 @@ static MV_STATUS mvTdmWinWrite(MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin)
 	if (MV_IS_NOT_ALIGN(pDecWin->addrWin.baseLow, pDecWin->addrWin.size)) {
 		mvOsPrintf("mvTdmWinWrite: Error setting TDM window %d"
 			   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
-			   winNum, pDecWin->addrWin.baseLow, pDecWin->addrWin.size);
+			   winNum, pDecWin->addrWin.baseLow, (MV_U32)pDecWin->addrWin.size);
 		return MV_ERROR;
 	}
 
diff --git a/drivers/staging/telephony/Makefile b/drivers/staging/telephony/Makefile
index 5e45cb5..6feb83b 100644
--- a/drivers/staging/telephony/Makefile
+++ b/drivers/staging/telephony/Makefile
@@ -5,4 +5,8 @@
 obj-$(CONFIG_PHONE) += phonedev.o
 obj-$(CONFIG_PHONE_IXJ) += ixj.o
 obj-$(CONFIG_PHONE_IXJ_PCMCIA) += ixj_pcmcia.o
+ifeq ($(CONFIG_PLAT_ARMADA),y)
+obj-$(CONFIG_MV_PHONE) += ../../../arch/arm/plat-armada/mv_drivers_lsp/mv_phone/
+else
 obj-$(CONFIG_MV_PHONE) += ../../../arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/
+endif
diff --git a/tools/voice/zarlink/kernel/Makefile b/tools/voice/zarlink/kernel/Makefile
index f930afb..6bb8fda 100644
--- a/tools/voice/zarlink/kernel/Makefile
+++ b/tools/voice/zarlink/kernel/Makefile
@@ -13,19 +13,20 @@ ifdef CONFIG_CPU_BIG_ENDIAN
 CFLAGS  += -DCONFIG_CPU_BIG_ENDIAN
 endif
 
+ifeq ($(CONFIG_MV_TDM_USE_DCO),y)
+ CFLAGS += -DMV_TDM_USE_DCO
+endif
+
 CC := $(CROSS_COMPILE)gcc
 LD := $(CROSS_COMPILE)ld
 AR := $(CROSS_COMPILE)ar
 
-#CFLAGS += -I$(KSRC)/tools/voice/
-
 ifeq ($(CONFIG_ZARLINK_SLIC_SUPPORT),y)
-TARGETS += vpapi_lib.o
-LIBS := libvpapi.a
-TOOL := mv_voice_tool.c
-CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_hal/voiceband/slic/zarlink/arch_marvell/
+ifeq ($(CONFIG_PLAT_ARMADA),y)
+CFLAGS += -I$(KSRC)/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/
+else
 CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/
-
+endif
 ifeq ($(CONFIG_ZARLINK_SLIC_EXTERNAL_DRIVER),y)
 CFLAGS_VE792 = -I$(ZARLINK_VPAPI)/zarlink-ve792/api_lib/includes -I$(ZARLINK_VPAPI)/vp_hal -I$(ZARLINK_VPAPI)/vpapi_dev
 CFLAGS_VE8XX = -I$(ZARLINK_VPAPI)/api_lib/includes -I$(ZARLINK_VPAPI)/vp_hal -I$(ZARLINK_VPAPI)/vpapi_dev
-- 
1.7.5.4

