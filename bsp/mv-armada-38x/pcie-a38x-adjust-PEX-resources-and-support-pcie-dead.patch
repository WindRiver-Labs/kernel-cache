From 481ccc78f3f7de0437e0d9b6110411c04f8e9c5a Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Sun, 20 Oct 2013 10:15:47 +0200
Subject: [PATCH 1112/1825] pcie: a38x: adjust PEX resources and support pcie
 deadlock

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 781043767d2dde2a257134a06f2c03fa542bd87a

	- add decoding windows for additional ports in sysmap
	- assign physical and virtual addresses
	- correct MV_PEX_IF_REGS_OFFSET value for ports 1-3
	- modify mvTarget enumerator
	- According to ARM, in order to avoid CPU deadlock when
	  stressing I/O over PCIe in SMP mode with Cortex-A9,
	  the following workarounds should be implemented:
	  - Set PCIe I/O and memory windows to strongly ordered type
	  - Avoid PL310 L2 sync operation: for PL310 rev >= r3p2 no
	    need for explicit L2 sync by CPU as it is done by the HW

Change-Id: If81f4aad14b04d792bbea43dc73de06faa92b767
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3763
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada38x/core.c                   |   54 ++++++++++++++++++++++
 arch/arm/mach-armada38x/include/mach/armada38x.h |   23 ++++++++--
 arch/arm/mach-armada38x/include/mach/io.h        |    6 ++
 arch/arm/mach-armada38x/include/mach/irqs.h      |    2 +
 arch/arm/mach-armada38x/pex.c                    |   14 ++++++
 arch/arm/mach-armada38x/sysmap.c                 |   28 ++++++++++-
 arch/arm/mm/Kconfig                              |    2 +-
 7 files changed, 121 insertions(+), 8 deletions(-)

diff --git a/arch/arm/mach-armada38x/core.c b/arch/arm/mach-armada38x/core.c
index 38c8b3c..29af572 100644
--- a/arch/arm/mach-armada38x/core.c
+++ b/arch/arm/mach-armada38x/core.c
@@ -1254,6 +1254,60 @@ static void __init a38x_init_l2x0_cache(void)
 #endif
 }
 
+static inline int is_a38x_pcie_phys_memory(u32 addr)
+{
+	switch (mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID)) {
+	case 0:
+		return 0;
+	case 1:
+		return ((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE)));
+	case 2:
+		return (((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE))) || \
+			((addr >= PEX1_MEM_PHYS_BASE) && (addr < (PEX1_MEM_PHYS_BASE + PEX1_MEM_SIZE))));
+	default:
+		pr_err("%s: Error: invalid number of PCIe ports\n", __func__);
+		return 0;
+	}
+}
+
+static inline int is_a38x_pcie_virt_memory(u32 addr)
+{
+	switch (mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID)) {
+	case 0:
+		return 0;
+	case 1:
+		return ((addr >= PEX0_MEM_VIRT_BASE) && (addr < (PEX0_MEM_VIRT_BASE + PEX0_MEM_SIZE)));
+	case 2:
+		return (((addr >= PEX0_MEM_VIRT_BASE) && (addr < (PEX0_MEM_VIRT_BASE + PEX0_MEM_SIZE))) || \
+			((addr >= PEX1_MEM_VIRT_BASE) && (addr < (PEX1_MEM_VIRT_BASE + PEX1_MEM_SIZE))));
+	default:
+		pr_err("%s: Error: invalid number of PCIe ports\n", __func__);
+		return 0;
+	}
+}
+
+void __iomem *__a38x_ioremap(unsigned long addr, unsigned long size, unsigned int mtype)
+{
+	if (!is_a38x_pcie_phys_memory(addr))
+		return __arm_ioremap(addr, size, mtype);
+
+	if ((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE)))
+		return (void __iomem *)(PEX0_MEM_VIRT_BASE + (addr - PEX0_MEM_PHYS_BASE));
+	else
+		return (void __iomem *)(PEX1_MEM_VIRT_BASE + (addr - PEX1_MEM_PHYS_BASE));
+
+}
+EXPORT_SYMBOL(__a38x_ioremap);
+
+void __a38x_iounmap(void __iomem *addr)
+{
+	if (is_a38x_pcie_virt_memory(addr))
+		return;
+	else
+		return __iounmap(addr);
+}
+EXPORT_SYMBOL(__a38x_iounmap);
+
 static void __init a38x_board_init(void)
 {
 	mvBoardEnvInit();
diff --git a/arch/arm/mach-armada38x/include/mach/armada38x.h b/arch/arm/mach-armada38x/include/mach/armada38x.h
index d835546..198f418 100644
--- a/arch/arm/mach-armada38x/include/mach/armada38x.h
+++ b/arch/arm/mach-armada38x/include/mach/armada38x.h
@@ -32,14 +32,22 @@
 #define INTER_REGS_PHYS_BASE		0xF1000000
 
 #define PEX0_MEM_PHYS_BASE		0xE0000000
-#define PEX0_MEM_SIZE			_32M
+#define PEX0_MEM_SIZE			_16M
 #define PEX1_MEM_PHYS_BASE		0xE2000000
-#define PEX1_MEM_SIZE			_32M
+#define PEX1_MEM_SIZE			_16M
+#define PEX2_MEM_PHYS_BASE		0xE4000000
+#define PEX2_MEM_SIZE			_16M
+#define PEX3_MEM_PHYS_BASE		0xE6000000
+#define PEX3_MEM_SIZE			_16M
 
 #define PEX0_IO_PHYS_BASE		0xF1100000
 #define PEX0_IO_SIZE			_1M
 #define PEX1_IO_PHYS_BASE		0xF1200000
 #define PEX1_IO_SIZE			_1M
+#define PEX2_IO_PHYS_BASE		0xF1300000
+#define PEX2_IO_SIZE			_1M
+#define PEX3_IO_PHYS_BASE		0xF1400000
+#define PEX3_IO_SIZE			_1M
 
 #define SPI_CS0_PHYS_BASE		0xF0000000
 #define SPI_CS0_SIZE			_16M
@@ -92,10 +100,17 @@
 
 #define PEX0_IO_VIRT_BASE		0xFBC00000
 #define PEX1_IO_VIRT_BASE		0xFBD00000
+#define PEX2_IO_VIRT_BASE		0xFBE00000
+#define PEX3_IO_VIRT_BASE		0xFBF00000
 
-#define IOCC_WA_WIN0_VIRT_BASE		0xFBE00000
+#define PEX0_MEM_VIRT_BASE		0xF5000000
+#define PEX1_MEM_VIRT_BASE		0xF6000000
+#define PEX2_MEM_VIRT_BASE		0xF7000000
+#define PEX3_MEM_VIRT_BASE		0xF8000000
 
-#define USB3_REGS_VIRT_BASE		0xFBF00000
+#define IOCC_WA_WIN0_VIRT_BASE		0xFC000000
+
+#define USB3_REGS_VIRT_BASE		0xFC100000
 
 #define UART_VIRT_BASE			0xFC600000
 
diff --git a/arch/arm/mach-armada38x/include/mach/io.h b/arch/arm/mach-armada38x/include/mach/io.h
index 72de183..2f8da5d 100644
--- a/arch/arm/mach-armada38x/include/mach/io.h
+++ b/arch/arm/mach-armada38x/include/mach/io.h
@@ -18,4 +18,10 @@
 
 void dma_io_sync(void);
 
+extern void __iomem *__a38x_ioremap(unsigned long addr, unsigned long size, unsigned int mtype);
+extern void __a38x_iounmap(void __iomem *addr);
+
+#define __arch_ioremap	__a38x_ioremap
+#define __arch_iounmap	__a38x_iounmap
+
 #endif /* __ASM_ARCH_IO_H */
diff --git a/arch/arm/mach-armada38x/include/mach/irqs.h b/arch/arm/mach-armada38x/include/mach/irqs.h
index 275f8a4..c62c24f 100644
--- a/arch/arm/mach-armada38x/include/mach/irqs.h
+++ b/arch/arm/mach-armada38x/include/mach/irqs.h
@@ -60,6 +60,8 @@
 
 #define IRQ_GLOBAL_PCIE0		61
 #define IRQ_GLOBAL_PCIE1		65
+#define IRQ_GLOBAL_PCIE2		102
+#define IRQ_GLOBAL_PCIE3		103
 
 #define IRQ_GLOBAL_GUNIT0_SUM		69
 #define IRQ_GLOBAL_GUNIT0_RX		70
diff --git a/arch/arm/mach-armada38x/pex.c b/arch/arm/mach-armada38x/pex.c
index 91a21f7..c383184 100644
--- a/arch/arm/mach-armada38x/pex.c
+++ b/arch/arm/mach-armada38x/pex.c
@@ -49,6 +49,8 @@
 
 static int __init mv_map_irq_0(const struct pci_dev *dev, u8 slot, u8 pin);
 static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_2(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_3(const struct pci_dev *dev, u8 slot, u8 pin);
 
 extern u32 mv_pci_mem_size_get(int ifNum);
 extern u32 mv_pci_io_base_get(int ifNum);
@@ -66,6 +68,8 @@ static struct platform_device mv_pex = {
 static void *mv_get_irqmap_func[] __initdata = {
 	mv_map_irq_0,
 	mv_map_irq_1,
+	mv_map_irq_2,
+	mv_map_irq_3,
 };
 
 void __init mv_pex_preinit(void)
@@ -332,6 +336,16 @@ static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin)
 	return IRQ_GLOBAL_PCIE1;
 }
 
+static int __init mv_map_irq_2(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_GLOBAL_PCIE2;
+}
+
+static int __init mv_map_irq_3(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_GLOBAL_PCIE3;
+}
+
 static struct hw_pci mv_pci __initdata = {
 	.swizzle = pci_std_swizzle,
 	.setup = mv_pex_setup,
diff --git a/arch/arm/mach-armada38x/sysmap.c b/arch/arm/mach-armada38x/sysmap.c
index a86ce2b..cdbdc07 100644
--- a/arch/arm/mach-armada38x/sysmap.c
+++ b/arch/arm/mach-armada38x/sysmap.c
@@ -24,6 +24,14 @@
 struct map_desc MEM_TABLE[] = {
 	/* no use for pex mem remap */
 	{ INTER_REGS_VIRT_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,		MT_DEVICE},
+	{ PEX0_IO_VIRT_BASE,		__phys_to_pfn(PEX0_IO_PHYS_BASE),	PEX0_IO_SIZE,	MT_DEVICE},
+	{ PEX1_IO_VIRT_BASE,		__phys_to_pfn(PEX1_IO_PHYS_BASE),	PEX1_IO_SIZE,	MT_DEVICE},
+	{ PEX2_IO_VIRT_BASE,		__phys_to_pfn(PEX2_IO_PHYS_BASE),	PEX2_IO_SIZE,	MT_DEVICE},
+	{ PEX3_IO_VIRT_BASE,		__phys_to_pfn(PEX3_IO_PHYS_BASE),	PEX3_IO_SIZE,	MT_DEVICE},
+	{ PEX0_MEM_VIRT_BASE,		__phys_to_pfn(PEX0_MEM_PHYS_BASE),	PEX0_MEM_SIZE,	MT_DEVICE},
+	{ PEX1_MEM_VIRT_BASE,		__phys_to_pfn(PEX1_MEM_PHYS_BASE),	PEX1_MEM_SIZE,	MT_DEVICE},
+	{ PEX2_MEM_VIRT_BASE,		__phys_to_pfn(PEX2_MEM_PHYS_BASE),	PEX2_MEM_SIZE,	MT_DEVICE},
+	{ PEX3_MEM_VIRT_BASE,		__phys_to_pfn(PEX3_MEM_PHYS_BASE),	PEX3_MEM_SIZE,	MT_DEVICE},
 	{ CRYPT_ENG_VIRT_BASE(0),	__phys_to_pfn(CRYPT_ENG_PHYS_BASE(0)),	CRYPT_ENG_SIZE,	MT_DEVICE},
 	{ IOCC_WA_WIN0_VIRT_BASE,	__phys_to_pfn(IOCC_WA_WIN0_PHYS_BASE),	SZ_64K,		MT_DEVICE},
 };
@@ -39,9 +47,13 @@ MV_CPU_DEC_WIN SYSMAP_A38X_68XX[] = {
 	{{DEVICE_CS2_PHYS_BASE,		0,	DEVICE_CS2_SIZE,	},	TBL_UNUSED,	DIS}, /* DEVICE_CS2 */
 	{{DEVICE_CS3_PHYS_BASE,		0,	DEVICE_CS3_SIZE,	},	TBL_UNUSED,	DIS}, /* DEVICE_CS3 */
 	{{PEX0_MEM_PHYS_BASE,		0,	PEX0_MEM_SIZE		},	0,		 EN}, /* PEX0_MEM */
-	{{PEX0_IO_PHYS_BASE,		0,	PEX0_IO_SIZE		},	TBL_UNUSED,	DIS}, /* PEX0_IO */
-	{{PEX1_MEM_PHYS_BASE,		0,	PEX1_MEM_SIZE		},	1,		 EN}, /* PEX1_MEM */
-	{{PEX1_IO_PHYS_BASE,		0,	PEX1_IO_SIZE		},	TBL_UNUSED,	DIS}, /* PEX1_IO */
+	{{PEX0_IO_PHYS_BASE,		0,	PEX0_IO_SIZE		},	1,		 EN}, /* PEX0_IO */
+	{{PEX1_MEM_PHYS_BASE,		0,	PEX1_MEM_SIZE		},	2,		 EN}, /* PEX1_MEM */
+	{{PEX1_IO_PHYS_BASE,		0,	PEX1_IO_SIZE		},	3,		 EN}, /* PEX1_IO */
+	{{PEX2_MEM_PHYS_BASE,		0,	PEX2_MEM_SIZE		},	4,		 EN}, /* PEX2_MEM */
+	{{PEX2_IO_PHYS_BASE,		0,	PEX2_IO_SIZE		},	5,		 EN}, /* PEX2_IO */
+	{{PEX3_MEM_PHYS_BASE,		0,	PEX3_MEM_SIZE		},	6,		 EN}, /* PEX3_MEM */
+	{{PEX3_IO_PHYS_BASE,		0,	PEX3_IO_SIZE		},	7,		 EN}, /* PEX3_IO */
 	{{INTER_REGS_PHYS_BASE,		0,	INTER_REGS_SIZE		},	20,		 EN}, /* INTER_REGS */
 	{{UART_REGS_BASE,		0,	UART_SIZE		},	TBL_UNUSED,	DIS}, /* DMA_UART */
 	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	14,		 EN}, /* SPI_CS0 */
@@ -99,26 +111,36 @@ void __init a38x_map_io(void)
 static u32 mv_pci_mem_base[] = {
 	PEX0_MEM_PHYS_BASE,
 	PEX1_MEM_PHYS_BASE,
+	PEX2_MEM_PHYS_BASE,
+	PEX3_MEM_PHYS_BASE,
 };
 
 static u32 mv_pci_mem_size[] = {
 	PEX0_MEM_SIZE,
 	PEX1_MEM_SIZE,
+	PEX2_MEM_SIZE,
+	PEX3_MEM_SIZE,
 };
 
 static u32 mv_pci_io_base[] = {
 	PEX0_IO_PHYS_BASE,
 	PEX1_IO_PHYS_BASE,
+	PEX2_IO_PHYS_BASE,
+	PEX3_IO_PHYS_BASE,
 };
 
 static u32 mv_pci_io_size[] = {
 	PEX0_IO_SIZE,
 	PEX1_IO_SIZE,
+	PEX2_IO_SIZE,
+	PEX3_IO_SIZE,
 };
 
 static MV_TARGET mv_pci_io_target[] = {
 	PEX0_IO,
 	PEX1_IO,
+	PEX2_IO,
+	PEX3_IO,
 };
 
 u32 mv_pci_mem_base_get(int ifNum)
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 1cdae58..ec173d6 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -1279,7 +1279,7 @@ config CACHE_L2X0
 	bool "Enable the L2x0 outer cache controller" if MIGHT_HAVE_CACHE_L2X0
 	default MIGHT_HAVE_CACHE_L2X0
 	select OUTER_CACHE
-	select OUTER_CACHE_SYNC if (ARCH_AVANTA_LP || ARCH_ARMADA38X) && !AURORA_IO_CACHE_COHERENCY
+	select OUTER_CACHE_SYNC if (ARCH_AVANTA_LP || !ARCH_ARMADA38X) && !AURORA_IO_CACHE_COHERENCY
 	help
 	  This option enables the L2x0 PrimeCell.
 
-- 
1.7.5.4

