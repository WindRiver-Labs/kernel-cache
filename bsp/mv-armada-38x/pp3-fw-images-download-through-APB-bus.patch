From 8217eab1f633be454e2762a1c317fa522188b879 Mon Sep 17 00:00:00 2001
From: Margarita Granov <margra@marvell.com>
Date: Tue, 29 Apr 2014 10:29:59 +0300
Subject: [PATCH 1640/1825] pp3: fw images download through APB bus

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 2ec5f1e09473f8d7e656b7ad7c18282b924cd027

	new sysfs command added

Change-Id: I82d1dfc5707b8c494f894ef9e58d4e07734df256
Signed-off-by: Margarita Granov <margra@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7811
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/fw/mv_fw.c       |  110 ++++++++++++++++++--
 drivers/net/ethernet/marvell/pp3/fw/mv_fw.h       |   43 ++++++--
 drivers/net/ethernet/marvell/pp3/fw/mv_fw_sysfs.c |   12 +++
 3 files changed, 144 insertions(+), 21 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/fw/mv_fw.c b/drivers/net/ethernet/marvell/pp3/fw/mv_fw.c
index e1c9149..147bbc4 100644
--- a/drivers/net/ethernet/marvell/pp3/fw/mv_fw.c
+++ b/drivers/net/ethernet/marvell/pp3/fw/mv_fw.c
@@ -70,10 +70,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/syscalls.h>
 #include <linux/fcntl.h>
 #include <linux/uaccess.h>
+#include "common/mv_hw_if.h"
+#include <linux/io.h>
 
 #include "mv_fw.h"
 
-
+unsigned int apb_base_addr;
 
 
 int mv_pp3_fw_read_img_file(char *path, struct mem_image *img)
@@ -93,12 +95,12 @@ int mv_pp3_fw_read_img_file(char *path, struct mem_image *img)
 	fd = sys_open(path, O_RDONLY, 0);
 	if (fd >= 0) {
 		while ((tmp = sys_read(fd, &ch, 1)) > 0) {
-			if (size >= MV_FW_MAX_LINE_SIZE || ch == '\n') {
+			if (size >= MV_FW_MAX_LINE_SIZE || ch == '\n' || ch == '/') {
 				sscanf(buf, "%X:%X", &addr, &value);
 				img->rows[img->size].address = addr;
 				img->rows[img->size].data = value;
 				img->size++;
-				pr_info("0x%08X->0x%08X", addr, value);
+				/*pr_info("0x%08X->0x%08X", addr, value);*/
 				size = 0;
 			} else {
 				buf[size++] = ch;
@@ -195,11 +197,33 @@ int mv_pp3_profile_download(char *path)
 		return -ENOMEM;
 	}
 	pr_info("ALLOCATED: %d Rows\n", mem.allocated);
-
 	mv_pp3_fw_read_img_file(path, &mem);
 	if (mem.size > 0)
-		mv_fw_mem_img_write(&mem,  PP3_PROFILE_MEM);
+		mv_pp3_fw_load(&mem,  PP3_PROFILE_MEM);
+	kfree(mem.rows);
+
+	return 0;
+}
+
+int mv_pp3_se_download(char *path)
+{
+	struct mem_image mem;
+
+	memset(&mem, 0, sizeof(mem));
+
+	pr_info("DOWNLOAD PATH: %s\n", path);
+
+	mem.rows = kzalloc(MV_PP3_PROFILE_MEM_ROWS * sizeof(struct mem_rec), GFP_KERNEL);
+	mem.allocated = MV_PP3_PROFILE_MEM_ROWS;
 
+	if (!mem.rows) {
+		pr_err("SE Allocation Failed in <%s>\n", __func__);
+		return -ENOMEM;
+	}
+	pr_info("ALLOCATED: %d Rows\n", mem.allocated);
+	mv_pp3_fw_read_img_file(path, &mem);
+	if (mem.size > 0)
+		mv_pp3_fw_load(&mem,  PP3_SE_CFG);
 	kfree(mem.rows);
 
 	return 0;
@@ -230,6 +254,7 @@ int mv_pp3_profile_dump(char *path)
 
 int mv_pp3_cfg_dump(char *path)
 {
+
 	char *buf = NULL;
 	int size = 0;
 
@@ -247,7 +272,6 @@ int mv_pp3_cfg_dump(char *path)
 		size = mv_pp3_fw_write_file(path, buf, MV_PP3_CFG_MEM_SIZE);
 
 	kfree(buf);
-
 	return 0;
 }
 
@@ -275,9 +299,10 @@ int mv_pp3_cfg_download(char *path)
 }
 
 
+
 int mv_pp3_ppn_run(char *path)
 {
-
+	mv_pp3_ppc_registers_init();
 	return 0;
 }
 
@@ -302,7 +327,7 @@ int mv_pp3_imem_download(char *path)
 
 	mv_pp3_fw_read_img_file(path, &mem);
 	if (mem.size > 0)
-		mv_fw_mem_img_write(&mem,  PP3_IMEM);
+		mv_pp3_fw_load(&mem,  PP3_IMEM);
 
 	kfree(mem.rows);
 
@@ -335,7 +360,7 @@ int mv_pp3_imem_dump(char *path)
 
 
 
-int mv_fw_mem_write(char *data, int size, enum pp3_mem_type mem_type)
+int mv_fw_mem_write(char *data, int size, unsigned int mem_type)
 {
 	int i;
 
@@ -352,7 +377,7 @@ int mv_fw_mem_write(char *data, int size, enum pp3_mem_type mem_type)
 }
 
 
-int mv_fw_mem_img_write(struct mem_image *img, enum pp3_mem_type mem_type)
+int mv_fw_mem_img_write(struct mem_image *img, unsigned int mem_type)
 {
 	int i;
 
@@ -370,7 +395,7 @@ int mv_fw_mem_img_write(struct mem_image *img, enum pp3_mem_type mem_type)
 
 
 
-int mv_fw_mem_read(char *data, int size, enum pp3_mem_type mem_type)
+int mv_fw_mem_read(char *data, int size, unsigned int mem_type)
 {
 	int i;
 
@@ -385,3 +410,66 @@ int mv_fw_mem_read(char *data, int size, enum pp3_mem_type mem_type)
 		mem_type, size);
 	return size;
 }
+int mv_pp3_fw_load(struct mem_image *ptr_to_image , unsigned int image_type)
+{
+	unsigned int data;
+	unsigned int size;
+	unsigned int curr_apb_address, curr_val;
+
+	apb_base_addr = mv_hw_silicon_base_addr_get();
+	/* calculate APB start address */
+
+	pr_info("start adr for  dwnld %x", apb_base_addr);
+	size = ptr_to_image->size;
+	pr_info("size %d\n", size);
+	for (curr_val = 0; curr_val < size; curr_val++)	{
+		curr_apb_address = apb_base_addr  + ptr_to_image->rows[curr_val].address;
+		data = ptr_to_image->rows[curr_val].data;
+		/* write 4 bytes to APB */
+		mv_pp3_hw_reg_write(curr_apb_address, data);
+		if (!(curr_val % 0x10))
+			pr_info(" type %x address %x data %x\n", image_type, curr_apb_address, data);
+	}
+
+	return 0;
+}
+
+void mv_pp3_ppc_registers_init(void)
+{
+	u32 eap_addr;
+
+	/* calculate EAP start address */
+	eap_addr = apb_base_addr + MV_NSS_APB_EAP_OFFSET;
+	pr_info(" eap address %x\n", eap_addr);
+	mv_pp3_hw_reg_write(eap_addr + MV_NSS_PPC_PUSH_MODE_OFFSET, 1);
+	mv_pp3_hw_reg_write(eap_addr + MV_NSS_PPC_QM_MSG_0_TARGET_CORE_OFFSET, 0);
+	mv_pp3_hw_reg_write(eap_addr + MV_NSS_PPC_QM_MSG_1_TARGET_CORE_OFFSET, 1);
+	mv_pp3_hw_reg_write(eap_addr + MV_NSS_PPC_QM_DEQ_ADDRESS_OFFSET, 0);
+	mv_pp3_hw_reg_write(eap_addr + MV_NSS_PPC_IMEM_HOLD_OFF_OFFSET, 0);
+
+}
+int mv_pp3_fw_dram_allocation(char *path)
+{
+	dma_addr_t nss_dram_start_addr;
+	unsigned int *host_to_nss_dram_addr;
+	unsigned int apb_shared_sram_adr;
+	u32 data_to_write[4];
+
+	host_to_nss_dram_addr = dma_alloc_coherent(NULL, 0x1024, &nss_dram_start_addr , GFP_KERNEL);
+	pr_err("vitual host address - %x: physical addres - %x\n",
+	       (unsigned int)host_to_nss_dram_addr,
+	       (unsigned int)nss_dram_start_addr);
+	/* write physical address to Shared/Config SRAM offset DRAM_FOR_FW_OFFSET = 0x200)*/
+	apb_base_addr = mv_hw_silicon_base_addr_get();
+	pr_info(" apb_base_addr %x\n", apb_base_addr);
+	apb_shared_sram_adr = apb_base_addr+MV_NSS_APB_SHARED_MEM_OFFSET+
+	  DRAM_START_ADDR_FOR_FW_OFFSET;
+	pr_info(" shared_sram_adr %x\n", apb_shared_sram_adr);
+	data_to_write[0] = (u32)nss_dram_start_addr;
+	data_to_write[1] = 0;
+	data_to_write[2] = 0;
+	data_to_write[3] = 0;
+	mv_pp3_hw_write(apb_shared_sram_adr, 4, data_to_write);
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/marvell/pp3/fw/mv_fw.h b/drivers/net/ethernet/marvell/pp3/fw/mv_fw.h
index e671f28..58e47be 100644
--- a/drivers/net/ethernet/marvell/pp3/fw/mv_fw.h
+++ b/drivers/net/ethernet/marvell/pp3/fw/mv_fw.h
@@ -75,15 +75,33 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_PP3_CFG_MEM_ROWS (32*1024/4)
 
 #define MV_FW_MAX_LINE_SIZE (128)
+#define MV_NSS_APB_IMEM_OFFSET          0x40000
+#define MV_NSS_APB_PT_OFFSET            0x70000
+#define MV_NSS_APB_SHARED_MEM_OFFSET    0x60000
+#define MV_NSS_APB_EAP_OFFSET           0x74000
+#define MV_NSS_APB_SEARCH_ENGINE_OFFSET 0x40000
 
+#define MV_NSS_PPC_PUSH_MODE_OFFSET            0x10
+#define MV_NSS_PPC_QM_MSG_0_TARGET_CORE_OFFSET 0x20
+#define MV_NSS_PPC_QM_MSG_1_TARGET_CORE_OFFSET 0x24
+#define MV_NSS_PPC_QM_DEQ_ADDRESS_OFFSET       0x30
+#define MV_NSS_PPC_IMEM_HOLD_OFF_OFFSET        0x34
 
-enum pp3_mem_type {
-	PP3_IMEM = 0,
-	PP3_CFG_MEM = 1,
-	PP3_PROFILE_MEM = 2,
-	PP3_SRAM_MEM = 3,
-	PP3_SPAD = 4
-};
+
+#define IMEM_IMAGE           0
+#define PROFILE_TABLE_IMAGE  1
+#define SHARED_MEMORY_DATA   2
+#define SEARCH_ENGINE_IMAGE  3
+
+#define PP3_IMEM          0
+#define PP3_CFG_MEM       1
+#define PP3_PROFILE_MEM   2
+#define PP3_SE_CFG        3
+#define PP3_SRAM_MEM      4
+#define PP3_SPAD          5
+
+
+#define DRAM_START_ADDR_FOR_FW_OFFSET   0x200
 
 struct mem_rec {
 	u32 address;
@@ -97,6 +115,11 @@ struct mem_image {
 };
 
 
+void mv_pp3_ppc_registers_init(void);
+int mv_pp3_imem_download(char *path);
+int mv_pp3_se_download(char *path);
+int mv_pp3_fw_load(struct mem_image *ptr_to_image , unsigned int image_type);
+int mv_pp3_fw_dram_allocation(char *path);
 
 int mv_pp3_imem_download(char *path);
 int mv_pp3_imem_dump(char *path);
@@ -114,10 +137,10 @@ int mv_pp3_fw_read_file(char *path, char *buf, int size);
 int mv_pp3_fw_write_file(char *path, char *buf, int size);
 int mv_pp3_fw_read_img_file(char *path, struct mem_image *img);
 
-int mv_fw_mem_write(char *data, int size, enum pp3_mem_type target_mem);
-int mv_fw_mem_read(char *data, int size, enum pp3_mem_type source_mem);
+int mv_fw_mem_write(char *data, int size, unsigned int target_mem);
+int mv_fw_mem_read(char *data, int size, unsigned int source_mem);
 
-int mv_fw_mem_img_write(struct mem_image *img, enum pp3_mem_type mem_type);
+int mv_fw_mem_img_write(struct mem_image *img, unsigned int mem_type);
 
 /* SYSFS*/
 int mv_pp3_fw_sysfs_init(struct kobject *fw_kobj);
diff --git a/drivers/net/ethernet/marvell/pp3/fw/mv_fw_sysfs.c b/drivers/net/ethernet/marvell/pp3/fw/mv_fw_sysfs.c
index 306eaff..91e054c 100644
--- a/drivers/net/ethernet/marvell/pp3/fw/mv_fw_sysfs.c
+++ b/drivers/net/ethernet/marvell/pp3/fw/mv_fw_sysfs.c
@@ -75,6 +75,8 @@ static ssize_t mv_fw_help(char *b)
 	o += scnprintf(b + o, PAGE_SIZE - o,
 		       "echo [path]         > imem_dump     - Save FW to file\n");
 	o += scnprintf(b + o, PAGE_SIZE - o,
+		       "echo [path]         > se_dnld     -   Download SE from file\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
 		       "echo [path]         > profile_dnld  - Download profile from file\n");
 	o += scnprintf(b + o, PAGE_SIZE - o,
 		       "echo [path]         > profile_dump  - Save profile to file\n");
@@ -84,6 +86,8 @@ static ssize_t mv_fw_help(char *b)
 		       "echo [path]         > cfg_dump      - Save Config RAM to file\n");
 	o += scnprintf(b + o, PAGE_SIZE - o,
 		       "echo 'run'          > ppn_run       - Run PPN\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		       "echo 'dram'         > fw_dram_alloc - Allocated buffer in DRAM for FW\n");
 
 
 	return o;
@@ -126,8 +130,12 @@ static ssize_t mv_fw_store(struct device *dev,
 		mv_pp3_profile_download(str);
 	} else if (!strcmp(name, "profile_dump")) {
 		mv_pp3_profile_dump(str);
+	} else if (!strcmp(name, "se_dnld")) {
+		mv_pp3_se_download(str);
 	} else if (!strcmp(name, "ppn_run")) {
 		mv_pp3_ppn_run(str);
+	} else if (!strcmp(name, "fw_dram_alloc")) {
+		mv_pp3_fw_dram_allocation(str);
 	} else if (!strcmp(name, "cfg_dnld")) {
 		mv_pp3_cfg_download(str);
 	} else if (!strcmp(name, "cfg_dump")) {
@@ -144,20 +152,24 @@ static ssize_t mv_fw_store(struct device *dev,
 static DEVICE_ATTR(help, S_IRUSR, mv_fw_show, NULL);
 static DEVICE_ATTR(imem_dnld, S_IWUSR, NULL, mv_fw_store);
 static DEVICE_ATTR(imem_dump, S_IWUSR, NULL, mv_fw_store);
+static DEVICE_ATTR(se_dnld, S_IWUSR, NULL, mv_fw_store);
 static DEVICE_ATTR(cfg_dnld, S_IWUSR, NULL, mv_fw_store);
 static DEVICE_ATTR(cfg_dump, S_IWUSR, NULL, mv_fw_store);
 static DEVICE_ATTR(profile_dump, S_IWUSR, NULL, mv_fw_store);
 static DEVICE_ATTR(profile_dnld, S_IWUSR, NULL, mv_fw_store);
 static DEVICE_ATTR(ppn_run, S_IWUSR, NULL, mv_fw_store);
+static DEVICE_ATTR(fw_dram_alloc, S_IWUSR, NULL, mv_fw_store);
 
 
 static struct attribute *mv_fw_attrs[] = {
 	&dev_attr_help.attr,
 	&dev_attr_imem_dnld.attr,
 	&dev_attr_imem_dump.attr,
+	&dev_attr_se_dnld.attr,
 	&dev_attr_profile_dnld.attr,
 	&dev_attr_profile_dump.attr,
 	&dev_attr_ppn_run.attr,
+	&dev_attr_fw_dram_alloc.attr,
 	&dev_attr_cfg_dnld.attr,
 	&dev_attr_cfg_dump.attr,
 
-- 
1.7.5.4

