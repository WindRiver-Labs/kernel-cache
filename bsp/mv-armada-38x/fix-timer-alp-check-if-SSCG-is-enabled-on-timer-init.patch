From 3230042f48efc9f3e1720dd307264dd28e21853d Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Mon, 30 Sep 2013 16:07:54 +0300
Subject: [PATCH 1035/1825] fix: timer: alp: check if SSCG is enabled on timer
 init

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit afb198adcda50c89a31a848fb7b48a9f02c93856

Change-Id: Ia3a91982fca6188876927cb4812d4e4d117a8372
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3744
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   10 +++--
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |    2 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |   23 +++++++++++---
 arch/arm/mach-avantalp/core.h                      |    2 +-
 arch/arm/mach-avantalp/time.c                      |   33 ++++++++++++++-----
 5 files changed, 50 insertions(+), 20 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 699390b..c23ab4f 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -473,10 +473,13 @@ MV_U32 mvBoardTclkGet(MV_VOID)
 }
 
 /*******************************************************************************
-* mvBoardL2ClkGetRaw
+* mvBoardL2ClkGet
 *
 * DESCRIPTION:
 *	This routine extract the L2 Cache frequency/clock.
+*	Note: this function is called at the very early stage
+*	in Linux Kernel, hence, it has to read from SoC register, not
+*	from pre-built database.
 *
 * INPUT:
 *	None.
@@ -488,7 +491,7 @@ MV_U32 mvBoardTclkGet(MV_VOID)
 *	32bit clock cycles in Hertz.
 *
 *******************************************************************************/
-MV_U32 mvBoardL2ClkGetRaw(MV_VOID)
+MV_U32 mvBoardL2ClkGet(MV_VOID)
 {
 #ifdef CONFIG_MACH_AVANTA_LP_FPGA
 	return MV_FPGA_L2_CLK;
@@ -496,8 +499,7 @@ MV_U32 mvBoardL2ClkGetRaw(MV_VOID)
 	MV_U32 clkSelect;
 	MV_FREQ_MODE freq[] = MV_SAR_FREQ_MODES;
 
-	clkSelect = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
-
+	clkSelect = MV_REG_READ(MPP_SAMPLE_AT_RESET(1));
 	clkSelect = clkSelect & (0x1f << 17);
 	clkSelect >>= 17;
 
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index 4aa191a..1048d5e 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -478,7 +478,7 @@ MV_STATUS mvBoardExtPhyBufferSelect(MV_BOOL enable);
 MV_STATUS mvBoardSgmiiSfp0TxSet(MV_BOOL enable);
 MV_STATUS mvBoardUsbSsEnSet(MV_BOOL enable);
 MV_U32 mvBoardTclkGet(MV_VOID);
-MV_U32 mvBoardL2ClkGetRaw(MV_VOID);
+MV_U32 mvBoardL2ClkGet(MV_VOID);
 MV_U32 mvBoardSysClkGet(MV_VOID);
 MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId);
 MV_VOID mvBoardDebugLed(MV_U32 hexNum);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index c959328..8720af1 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -133,15 +133,28 @@ MV_U32 mvCtrlGetCpuNum(MV_VOID)
 		return cpu1Enabled;
 }
 
+/*
+ * Note: this function is called at the very early stage
+ * in Linux Kernel, hence, it has to read from SoC register, not
+ * from pre-built database.
+ */
 MV_BOOL mvCtrlIsSscgEnabled(MV_VOID)
 {
+	MV_BOARD_SATR_INFO satrInfo;
 	MV_U32 sscgDisabled;
 
-	if (mvCtrlSatRRead(MV_SATR_SSCG_DISABLE, &sscgDisabled) != MV_OK) {
-		mvOsPrintf("%s: Error: failed to read SSCG status\n", __func__);
-		return MV_TRUE; /* if error reading S@R, assume sscg is default (enabled) */
-	} else
-		return sscgDisabled == 0x1 ? MV_FALSE : MV_TRUE;
+	if (mvBoardSatrInfoConfig(MV_SATR_SSCG_DISABLE, &satrInfo, MV_TRUE) != MV_OK) {
+		mvOsPrintf("%s: mvBoardSatrInfoConfig failed\n", __func__);
+		return MV_FALSE;
+	}
+
+	sscgDisabled = MV_REG_READ(MPP_SAMPLE_AT_RESET(satrInfo.regNum));
+	sscgDisabled = (sscgDisabled & (satrInfo.mask)) >> (satrInfo.offset);
+
+	if (sscgDisabled == 0)
+		return MV_TRUE; /* SSCG mechanism is enabled */
+	else
+		return MV_FALSE; /* SSCG mechanism is disabled */
 }
 
 /*******************************************************************************
diff --git a/arch/arm/mach-avantalp/core.h b/arch/arm/mach-avantalp/core.h
index bc9180a..73a8d91 100644
--- a/arch/arm/mach-avantalp/core.h
+++ b/arch/arm/mach-avantalp/core.h
@@ -6,5 +6,5 @@
 
 void alp_irq_init(void);
 void __init mv_usb_init(struct mbus_dram_target_info *dram);
-
 void set_core_count(unsigned int cpu_count);
+u32 alp_soc_timer_rate_get(void);
diff --git a/arch/arm/mach-avantalp/time.c b/arch/arm/mach-avantalp/time.c
index 961c487..304205f 100644
--- a/arch/arm/mach-avantalp/time.c
+++ b/arch/arm/mach-avantalp/time.c
@@ -28,6 +28,7 @@
 #include <asm/smp_twd.h>
 
 #include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
 #include "cpu/mvCpu.h"
 #include "ctrlEnv/mvUnitMap.h"
 #include "include/mach/smp.h"
@@ -58,8 +59,8 @@ static int source_timer_id;
 /*
  * Timer rate/frequency for ARM CA9 timers and Marvell SoC timers.
  */
-static u32 ca9_twd_rate;
-static u32 mv_twd_rate;
+static u32 ca9_twd_rate; /* CA9 internal timer */
+static u32 mv_twd_rate;  /* Marvell SoC timer  */
 
 static u32 ticks_per_jiffy;
 
@@ -272,16 +273,13 @@ static void alp_clear_timer_config(void)
  * When the SSCG is in spread up or down a frequency swing
  * should be calculated according to the correct frequency.
  */
-static u32 __init alp_timer_rate_get(void)
+static u32 __init alp_ca9_twd_timer_rate_sscg_get(void)
 {
-#ifdef CONFIG_MACH_AVANTA_LP_FPGA
-	return MV_FPGA_L2_CLK;
-#else
 	u32 target_freq, freq_swing, system_freq;
 	u32 sscg_reg;
 	int high_bound, low_bound, diff;
 
-	target_freq = mvBoardL2ClkGetRaw();
+	target_freq = mvBoardL2ClkGet();
 
 	sscg_reg   = MV_REG_READ(SSCG_CONF_REG);
 	high_bound = SSCG_CONF_HIGH(sscg_reg);
@@ -307,15 +305,32 @@ static u32 __init alp_timer_rate_get(void)
 	}
 
 	return system_freq;
+}
+
+static u32 __init alp_ca9_twd_timer_rate_get(void)
+{
+#ifdef CONFIG_MACH_AVANTA_LP_FPGA
+	return MV_FPGA_L2_CLK;
+#else
+	if (mvCtrlIsSscgEnabled() == MV_TRUE)
+		return alp_ca9_twd_timer_rate_sscg_get();
+	else
+		return mvBoardL2ClkGet();
 #endif
 }
 
+u32 alp_soc_timer_rate_get(void)
+{
+	return mv_twd_rate;
+}
+
 static void __init alp_timer_init(void)
 {
-	ca9_twd_rate = alp_timer_rate_get();
+	pr_info("Initializing Avanta-LP timers:\n");
+
+	ca9_twd_rate = alp_ca9_twd_timer_rate_get();
 	mv_twd_rate = ca9_twd_rate / 2;
 
-	printk("Initializing AvantaLP SoC Timers\n");
 	ticks_per_jiffy = (mv_twd_rate + HZ/2) / HZ;
 
 #ifdef CONFIG_MV_AMP_ENABLE
-- 
1.7.5.4

