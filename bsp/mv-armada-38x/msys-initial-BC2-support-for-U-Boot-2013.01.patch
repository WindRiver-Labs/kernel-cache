From d0b1b5845da494d6caacfb8861b670194a0ee8cd Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Wed, 25 Dec 2013 14:49:50 +0200
Subject: [PATCH 1262/1825] msys: initial BC2 support for U-Boot 2013.01

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit da7e18492a06a65e8e33ee386451a27fa690161e

	This patch applies necessary changes to msys_family and U-Boot 2013.01
	- New build chain added : bobcat2
	  SPI build example: "./build.pl -f spi -v 14t1 -i spi -b bobcat2 -c"

	Supported:
		UART, SPI0, SDMMC, Boot from UART/Lauterbach
	known issues:
		No binary header/DDR training, NAND, Networking
		PCIe link detected succesfully, but devices don't function

Change-Id: I1af9da173ea273ec84bac228ba639d4079dfd505
Signed-off-by: Omri Itach <omrii@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4914
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mach-msys/msys_family/boardEnv/mvBoardEnvLib.c |  103 ++++++++++++++------
 .../mach-msys/msys_family/boardEnv/mvBoardEnvLib.h |    4 +-
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c   |   39 +++++++-
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h   |    1 +
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h  |   18 +++-
 .../mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c    |   14 ++--
 6 files changed, 136 insertions(+), 43 deletions(-)

diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
index d497076..92dc1ef 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
@@ -113,7 +113,6 @@ MV_VOID mvBoardEnvInit(MV_VOID)
 	MV_U32 boardId = mvBoardIdGet();
 	MV_U32 nandDev;
 	MV_U32 norDev;
-	MV_U32 I2C_conf;
 
 	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
 		mvOsPrintf("mvBoardEnvInit:Board unknown.\n");
@@ -149,15 +148,25 @@ MV_VOID mvBoardEnvInit(MV_VOID)
 	mvGppTypeSet(0, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValLow);
 	mvGppTypeSet(1, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValMid);
 
+}
+
+MV_U32 mvBoardDfxConfig(MV_VOID)
+{
+	MV_U32 I2C_conf;
+
 	/* set acess to DFX */
 	I2C_conf = MV_REG_READ(I2C_CONFIC_DEBUG_REG);
 	I2C_conf &= ICDR_UINIT_ID_MASK;
 	I2C_conf |= 8; /* acess to DFX */
 	MV_REG_WRITE(I2C_CONFIC_DEBUG_REG,I2C_conf);
+
 	/* open windows to DFX */
 	MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(1), 0x000f0081);
 	MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(1), DFX_REGS_BASE);
+
+	return 0;
 }
+
 /*******************************************************************************
 * mvBoardModelGet - Get Board model
 *
@@ -237,6 +246,54 @@ MV_STATUS mvBoardNameGet(char *pNameBuff)
 	mvOsSPrintf(pNameBuff, "%s", BOARD_INFO(boardId)->boardName);
 	return MV_OK;
 }
+
+/*******************************************************************************
+* mvBoardIsEthConnected - detect if a certain Ethernet port is Connected
+*
+* DESCRIPTION:
+*	This routine returns true if a certain Ethernet port is Connected
+*
+* INPUT:
+*	ethNum - index of the ethernet port requested
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_TRUE if the requested ethernet port is connected.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsEthConnected(MV_U32 ethNum)
+{
+	if (ethNum == 0)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsEthActive - this routine indicate which ports can be used by U-Boot
+*
+* DESCRIPTION:
+*	This routine returns true if a certain Ethernet port is
+*	Active and usable as a regular eth interface
+*
+* INPUT:
+*	ethNum - index of the ethernet port requested
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_TRUE if the requested ethernet port is Active and usable.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsEthActive(MV_U32 ethNum)
+{
+	/* for Msys, all connected ports are Active and usabe */
+	return mvBoardIsEthConnected(ethNum);
+}
+
 /*******************************************************************************
 * mvBoardIsPortInSgmii -
 *
@@ -448,7 +505,7 @@ MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum)
 MV_U32 freq_tbl[] = {
 	360000000, /* 0 */
 	220000000, /* 1 */
-	250000000, /* 2 */
+	200000000, /* 2 */
 	400000000, /* 3 */
 	500000000, /* 4 */
 	520000000, /* 5 */
@@ -461,8 +518,11 @@ MV_U32 mvBoardTclkGet(MV_VOID)
 	MV_U32  freq;
 
 	freq = MSAR_CORE_CLK(0, MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1)));
+	printf("%s: Core Clock from DFX S@R register = 0x%x\n", __func__, freq);
+	printf("%s: Using Hard-coded value instead from freq_tbl[2] = TClock @ 200 [MHz]\n", __func__);
+
+	return freq_tbl[2];
 
-	return freq_tbl[freq];
 }
 
 /*******************************************************************************
@@ -1107,28 +1167,6 @@ MV_32 mvBoardNandWidthGet(void)
 
 MV_U32 gBoardId = -1;
 /*******************************************************************************
-* mvBoardIdSet - Set Board model
-*
-* DESCRIPTION:
-*       This function sets the board ID.
-*       Board ID is 32bit word constructed of board model (16bit) and
-*       board revision (16bit) in the following way: 0xMMMMRRRR.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       void
-*
-*******************************************************************************/
-MV_VOID mvBoardIdSet(MV_VOID)
-{
-	mvOsPrintf("mvBoardIdSet: Board ID ir read only must be defined in PLD!\n");
-}
-/*******************************************************************************
 * mvBoardIdGet - Get Board model
 *
 * DESCRIPTION:
@@ -1146,19 +1184,26 @@ MV_VOID mvBoardIdSet(MV_VOID)
 *       32bit board ID number, '-1' if board is undefined.
 *
 *******************************************************************************/
+int count = -1;
 MV_U32 mvBoardIdGet(MV_VOID)
 {
-	MV_U8 boadId;
+	MV_U8 boardId;
+
+	if (count++ < 0)
+		printf("%s: TODO fix read from TWSI of boardID (using hard-coded value RD_98DX4051_ID)\n", __func__);
+
+	return RD_98DX4051_ID;
+
 	if (gBoardId == -1) {
-		if (MV_ERROR == mvBoardTwsiRead(BOARD_DEV_TWSI_PLD, 1, 0, &boadId)) {
+		if (MV_ERROR == mvBoardTwsiRead(BOARD_DEV_TWSI_PLD, 1, 0, &boardId)) {
 			mvOsWarning();
 			return INVALID_BAORD_ID;
 		}
-		switch (boadId) {
+		switch (boardId) {
 		case 0: gBoardId = RD_98DX4051_ID; break;
 		case 1: gBoardId = DB_98DX4251_BP_ID; break;
 		default:
-			mvOsWarning();
+			mvOsPrintf("%s: Error: read un-expected board ID (%d)\n", __func__, boardId);
 			return INVALID_BAORD_ID;
 		}
 	}
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
index 8063cf7..c010162 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
@@ -253,9 +253,12 @@ typedef struct _boardInfo {
 } MV_BOARD_INFO;
 
 MV_VOID mvBoardEnvInit(MV_VOID);
+MV_U32 mvBoardDfxConfig(MV_VOID);
 MV_U16 mvBoardModelGet(MV_VOID);
 MV_U16 mvBoardRevGet(MV_VOID);
 MV_STATUS mvBoardNameGet(char *pNameBuff);
+MV_BOOL mvBoardIsEthConnected(MV_U32 ethNum);
+MV_BOOL mvBoardIsEthActive(MV_U32 ethNum);
 MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortInRgmii(MV_U32 ethPortNum);
@@ -286,7 +289,6 @@ MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
 MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
 MV_32 mvBoardNandWidthGet(void);
 MV_U32 mvBoardIdGet(MV_VOID);
-MV_VOID mvBoardIdSet(MV_VOID);
 MV_U32 mvBoardSledCpuNumGet(MV_VOID);
 
 MV_STATUS mvBoardTwsiRead(MV_BOARD_TWSI_CLASS class1, MV_U8 devNum, MV_U8 regNum, MV_U8 *pData);
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
index 353ac53..aabdc30 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
@@ -108,9 +108,45 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define DB(x)
 #endif
 
+
+MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][1] = {
+/* DRAM_UNIT_ID         */ { 1, },
+/* PEX_UNIT_ID          */ { 1, },
+/* ETH_GIG_UNIT_ID      */ { 2, },
+/* USB_UNIT_ID          */ { 1, },
+/* USB3_UNIT_ID          */ { 1, },
+/* IDMA_UNIT_ID         */ { 0, },
+/* XOR_UNIT_ID          */ { 2, },
+/* SATA_UNIT_ID         */ { 2, },
+/* TDM_32CH_UNIT_ID     */ { 1, },
+/* UART_UNIT_ID         */ { 2, },
+/* CESA_UNIT_ID         */ { 1, },
+/* SPI_UNIT_ID          */ { 2, },
+/* AUDIO_UNIT_ID        */ { 1, },
+/* SDIO_UNIT_ID         */ { 1, },
+/* TS_UNIT_ID           */ { 0, },
+/* XPON_UNIT_ID         */ { 1, },
+/* BM_UNIT_ID           */ { 1, },
+/* PNC_UNIT_ID          */ { 1, },
+/* I2C_UNIT_ID          */ { 2, },
+};
+
+MV_U32 mvCtrlSocUnitInfoNumGet(MV_UNIT_ID unit)
+{
+	MV_U32 devIdIndex;
+
+	if (unit >= MAX_UNITS_ID) {
+		mvOsPrintf("%s: Error: Wrong unit type (%u)\n", __func__, unit);
+		return 0;
+	}
+
+	devIdIndex = 0;
+	return mvCtrlSocUnitNums[unit][devIdIndex];
+}
+
 MV_U32 mvCtrlGetCpuNum(MV_VOID)
 {
-	return 2;
+	return 0;
 }
 MV_BOOL mvCtrlIsValidSatR(MV_VOID)
 {
@@ -1496,6 +1532,7 @@ void mvCtrlNandClkSet(int nClock)
 {
 	/* Set the division ratio of ECC Clock 0x00018748[13:8] (by default it's double of core clock) */
 	MV_U32 nVal = MV_DFX_REG_READ(CORE_DIV_CLK_CTRL(1));
+
 	nVal &= ~(NAND_ECC_DIVCKL_RATIO_MASK);
 	nVal |= (nClock << NAND_ECC_DIVCKL_RATIO_OFFS);
 	MV_DFX_REG_WRITE(CORE_DIV_CLK_CTRL(1), nVal);
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h
index 5538f0e..ca69b7c 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h
@@ -140,6 +140,7 @@ typedef struct {
 } MV_BIOS_MODE;
 
 /* mcspLib.h API list */
+MV_U32 mvCtrlSocUnitInfoNumGet(MV_UNIT_ID unit);
 MV_U32 mvCtrlGetCpuNum(MV_VOID);
 MV_BOOL mvCtrlIsValidSatR(MV_VOID);
 
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
index c1af8e1..ed32f5e 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -83,7 +83,7 @@ extern "C" {
  */
 #define MV_DRAM_REGS_OFFSET			(0x0)
 #define MV_AURORA_L2_REGS_OFFSET		(0x8000)
-
+#define MV_RTC_REGS_OFFSET			(0x10300)
 #define MV_DEV_BUS_REGS_OFFSET			(0x10400)
 #define MV_SPI_REGS_OFFSET(unit)		(0x10600 + (unit * 0x80))
 #define MV_TWSI_SLAVE_REGS_OFFSET(chanNum)	(0x11000 + (chanNum * 0x100))
@@ -109,12 +109,15 @@ extern "C" {
 	#define MV_ETH_BASE_ADDR		(0x70000)
 #endif
 #define MV_ETH_REGS_OFFSET(port)		(MV_ETH_BASE_ADDR + (port)* 0x40000 )
-#define MV_PEX_IF_REGS_OFFSET(pexIf)		(0x40000)
-
+#define MV_PEX_IF_REGS_OFFSET(pexIf)\
+			(pexIf < 8 ? (0x40000 + ((pexIf) / 4) * 0x40000 + ((pexIf) % 4) * 0x4000)\
+	: (0X42000 + ((pexIf) % 8) * 0x40000))
+#define MV_USB_REGS_OFFSET(dev)			(0x50000 + (dev * 0x1000))
 #define MV_XOR_REGS_OFFSET(unit)		(0xF0000)
 #if defined(MV_INCLUDE_IDMA)
 #define MV_IDMA_REGS_OFFSET			(0x60800)
 #endif
+#define MV_SATA_REGS_OFFSET			(0xA0000)
 #define MV_COMM_UNIT_REGS_OFFSET		(0xB0000)
 #define MV_NFC_REGS_OFFSET			(0xD0000)
 #define MV_BM_REGS_OFFSET			(0xC0000)
@@ -156,7 +159,7 @@ extern "C" {
 
 #define MV_SATA_MAX_CHAN			0
 
-#define MV_MPP_MAX_GROUP			2
+#define MV_MPP_MAX_GROUP			5
 
 #define MV_DRAM_MAX_CS				4
 #define MV_SPI_MAX_CS				8
@@ -249,16 +252,21 @@ typedef enum _mvUnitId {
 	PEX_UNIT_ID,
 	ETH_GIG_UNIT_ID,
 	USB_UNIT_ID,
+	USB3_UNIT_ID,
 	IDMA_UNIT_ID,
 	XOR_UNIT_ID,
 	SATA_UNIT_ID,
-	TDM_32CH_UNIT_ID,
+	TDM_UNIT_ID,
 	UART_UNIT_ID,
 	CESA_UNIT_ID,
 	SPI_UNIT_ID,
+	AUDIO_UNIT_ID,
 	SDIO_UNIT_ID,
+	TS_UNIT_ID,
+	XPON_UNIT_ID,
 	BM_UNIT_ID,
 	PNC_UNIT_ID,
+	I2C_UNIT_ID,
 	MAX_UNITS_ID
 } MV_UNIT_ID;
 
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c
index c2da768..0963d75 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c
@@ -290,6 +290,7 @@ MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
 *       None.
 *
 *******************************************************************************/
+int DramCount = -1;
 MV_STATUS mvCpuIfDramInit()
 {
 	MV_U64 base = 0;
@@ -297,7 +298,6 @@ MV_STATUS mvCpuIfDramInit()
 
 	for (cs = 0; cs < SDRAM_MAX_CS; cs++) {
 		size = MV_REG_READ(SDRAM_SIZE_REG(cs)) & SDRAM_ADDR_MASK;
-/*		if (size > 0 && base < SDRAM_MAX_ADDR) { */
 		if (size != 0) {
 			size |= ~(SDRAM_ADDR_MASK);
 
@@ -306,15 +306,15 @@ MV_STATUS mvCpuIfDramInit()
 			MV_REG_WRITE(SDRAM_WIN_BASE_REG(cs), temp);
 
 			/* Check if out of max window size and resize the window */
-#if 0
-			if (base+size > SDRAM_MAX_ADDR) {
-				size = SDRAM_MAX_ADDR - base - 1;
-				MV_REG_WRITE(SDRAM_SIZE_REG(cs), 0);
-			}
-#endif
 			temp = (MV_REG_READ(SDRAM_WIN_CTRL_REG(cs)) & ~(SDRAM_ADDR_MASK)) | (1<<SDRAM_WIN_CTRL_WIN_ENA_OFFS);
 			temp |= (size & SDRAM_ADDR_MASK);
 
+			temp = 0x7FFFFFE1;
+			if (DramCount++ < 0) {
+				printf("%s: TODO when ddr training is ready:\n", __func__);
+				printf("fix SDRAM_WIN_CTRL_REG (currently hard-coded value 0x7FFFFFE1)\n");
+			}
+
 			MV_REG_WRITE(SDRAM_WIN_CTRL_REG(cs), temp);
 			base += ((MV_U64)size + 1);
 		}
-- 
1.7.5.4

