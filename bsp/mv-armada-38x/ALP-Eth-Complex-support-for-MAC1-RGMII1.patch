From bbd20a0cf5cedf5e9a1dff53fbd90f597fb6d166 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Thu, 2 May 2013 16:44:44 +0300
Subject: [PATCH 0633/1825] ALP: Eth Complex support for MAC1-RGMII1

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit a0f34c42aadb5888fba342a972d30657cbe5df2e

Change-Id: I8cf0aa175aacde515796e1ff49c42ac7e5463cad
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/1745
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |    2 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c    |  412 ++++++++++++++++++-
 .../avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h    |  103 ++++--
 3 files changed, 457 insertions(+), 60 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index 6ec8557..421c627 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -280,7 +280,7 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 		mvGppPolaritySet(i, gppMask, (MV_GPP_IN_INVERT & gppMask));
 	}
 
-	mvEthernetComplexInit();
+	mvEthCompInit();
 	return MV_OK;
 }
 
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c
index ba6220e..32927aa 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c
@@ -68,7 +68,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "ctrlEnv/mvCtrlEthCompLib.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
 #include "boardEnv/mvBoardEnvLib.h"
-#include "neta/gbe/mvEthRegs.h"
+#include "pp2/gmac/mvEthGmacRegs.h"
+#include "pp2/gbe/mvPp2Gbe.h"
 
 static MV_BOOL gEthComplexSkipInit = MV_FALSE;
 
@@ -202,7 +203,7 @@ MV_STATUS mvEthCompSataConfig(MV_U32 ethCompCfg)
 }
 
 /******************************************************************************
-* mvEthernetComplexShutdownIf
+* mvEthCompShutdownIf
 *
 * DESCRIPTION:
 *	Shutdown ethernet complex interfaces.
@@ -219,13 +220,47 @@ MV_STATUS mvEthCompSataConfig(MV_U32 ethCompCfg)
 *	MV_OK on success,
 *	MV_ERROR otherwise.
 *******************************************************************************/
-MV_STATUS mvEthernetComplexShutdownIf(MV_BOOL integSwitch, MV_BOOL gePhy, MV_BOOL fePhy)
+MV_STATUS mvEthCompShutdownIf(MV_BOOL integSwitch, MV_BOOL gePhy, MV_BOOL fePhy)
 {
 	return MV_OK;
 }
 
 /******************************************************************************
-* mvEthernetComplexPreInit
+* mvEthCompGopPhySmiAutoPollSet
+*
+* DESCRIPTION:
+* 	Disables hardware PHY polling mode.
+* 	Relevant for SMI Interface0.
+* 	Used for Auto-Negotiation and PHY configuration of the PHY devices
+* 	connected to ports 0 through 11. Stops the Auto-Negotiation process
+* 	on SMI Interface0. When the CPU accesses a PHY via SMI Interface0,
+* 	this bit must be set to 1 when a 88E1112 is connected to one of the ports.
+* 	NOTE: Although the device ignores the information read from the
+* 	PHY registers, it keeps polling these registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+*******************************************************************************/
+#if 0 /* This bit does not work !!! */
+static void mvEthCompGopPhySmiAutoPollSet(MV_BOOL enable)
+{
+	if (enable == MV_TRUE)
+		MV_REG_BIT_RESET(ETH_PHY_AN_CFG0_REG(0),
+				 ETH_PHY_AN_CFG0_STOP_AN_SMI0_MASK);
+	else
+		MV_REG_BIT_SET  (ETH_PHY_AN_CFG0_REG(0),
+				 ETH_PHY_AN_CFG0_STOP_AN_SMI0_MASK);
+}
+#endif
+
+/******************************************************************************
+* mvEthCompGopPhySmiAddrSet
 *
 * DESCRIPTION:
 *	Perform basic setup that is needed before configuring the eth-complex
@@ -238,17 +273,86 @@ MV_STATUS mvEthernetComplexShutdownIf(MV_BOOL integSwitch, MV_BOOL gePhy, MV_BOO
 *	None.
 *
 * RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
+*	None.
 *******************************************************************************/
-MV_STATUS mvEthernetComplexPreInit(MV_U32 ethCompCfg)
+static void mvEthCompGopPhySmiAddrSet(MV_U32 port, MV_U32 smiAddr)
 {
-	return MV_OK;
+	MV_U32 reg;
+
+	/*
+	 * Set PHY SMI address: set PcsPhyAddress to PHY SMI address.
+	 */
+	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL0_REG(port));
+	reg &= ~ETHCGPC0_PCS_PHY_ADDR_MASK;
+	smiAddr &= ETHCGPC0_PCS_PHY_ADDR_MASK;
+	reg |= (smiAddr << ETHCGPC0_PCS_PHY_ADDR_OFFSET);
+	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL0_REG(port), reg);
 }
 
+/******************************************************************************
+* mvEthCompMacSetReset
+*
+* DESCRIPTION:
+* 	None.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+*******************************************************************************/
+void mvEthCompMacSetReset(MV_U32 port, MV_BOOL enable)
+{
+	MV_U32 reg, mask;
+
+	if (enable == MV_TRUE)
+		mask = 0x1;
+	else
+		mask = 0x0;
+
+	/*
+	 * Set 'PortMACReset' in Port MAC Control Register 2 to 'Port_MAC_Not_reset'.
+	 */
+	reg = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
+	reg &= ~ETH_GMAC_PORT_RESET_MASK;
+	reg |= (mask << ETH_GMAC_PORT_RESET_BIT);
+	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), reg);
+}
 
 /******************************************************************************
-* mvEthernetComplexPostInit
+* mvEthCompPreInit
+*
+* DESCRIPTION:
+*	Perform basic setup that is needed before configuring the eth-complex
+*	registers.
+*
+* INPUT:
+*	ethCompCfg - Ethernet complex configuration.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+*******************************************************************************/
+static void mvEthCompPreInit(MV_U32 ethCompCfg, MV_U32 smiAddr)
+{
+#if 0
+	mvEthCompMacSetReset(GBE_PORT(0), MV_TRUE);
+	mvEthCompMacSetReset(GBE_PORT(1), MV_TRUE);
+#endif
+
+	/* mvEthCompGopPhySmiAutoPollSet(MV_FALSE); <--- does not works according to Eran Maor !!! */
+
+	mvEthCompGopPhySmiAddrSet(GBE_PORT(0), smiAddr);
+	mvEthCompGopPhySmiAddrSet(GBE_PORT(1), smiAddr);
+}
+
+/******************************************************************************
+* mvEthCompPostInit
 *
 * DESCRIPTION:
 *	Perform basic setup that is needed after configuring the eth-complex
@@ -261,17 +365,276 @@ MV_STATUS mvEthernetComplexPreInit(MV_U32 ethCompCfg)
 *	None.
 *
 * RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
+*	None.
 *******************************************************************************/
- MV_STATUS mvEthernetComplexPostInit(MV_U32 ethCompCfg)
+static void mvEthCompPostInit(MV_U32 ethCompCfg)
 {
-	return MV_OK;
+	/* mvEthCompGopPhySmiAutoPollSet(MV_FALSE); <--- does not works according to Eran Maor !!! */
 }
 
+/******************************************************************************
+* mvEthCompMacSetAutoNegMode
+*
+* DESCRIPTION:
+* 	None.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+*******************************************************************************/
+static void mvEthCompMacSetAutoNegMode(MV_U32 macId)
+{
+	MV_U32 reg;
+
+	/*
+	 * When working on AN mode, set the following:
+	 * 'AnFcEn'		=> 'AnFcEnable'
+	 * 'PauseAdv'		=> 'Support_Flow_Control'
+	 * 'AnSpeedEn'		=> 'Enable_Update'
+	 * 'AnDuplexEn'		=> 'AnDuplexEnable'
+	 * 'SetFullDuplex'	=> 'Full_duplex'
+	 */
+
+	reg = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(macId));
+
+	/* 'AnFcEn'		=> 'AnFcEnable' */
+	reg &= ~ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;
+	reg |= (0x1 << ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_BIT);
+
+	/* 'PauseAdv'		=> 'Support_Flow_Control' */
+	reg &= ~ETH_FLOW_CONTROL_ADVERTISE_MASK;
+	reg |= (0x1 << ETH_FLOW_CONTROL_ADVERTISE_BIT);
+
+	/* 'AnSpeedEn'		=> 'Enable_Update' */
+	reg &= ~ETH_ENABLE_SPEED_AUTO_NEG_MASK;
+	reg |= (0x1 << ETH_ENABLE_SPEED_AUTO_NEG_BIT);
+
+	/* 'AnDuplexEn'		=> 'AnDuplexEnable' */
+	reg &= ~ETH_ENABLE_DUPLEX_AUTO_NEG_MASK;
+	reg |= (0x1 << ETH_ENABLE_DUPLEX_AUTO_NEG_BIT);
+
+	/* 'SetFullDuplex'	=> 'Full_duplex' */
+	reg &= ~ETH_SET_FULL_DUPLEX_MASK;
+	reg |= (0x1 << ETH_SET_FULL_DUPLEX_BIT);
+
+	MV_REG_WRITE(ETH_GMAC_AN_CTRL_REG(macId), reg);
+}
+
+/******************************************************************************
+* mvEthCompMac0ToGePhyConfig
+*
+* DESCRIPTION:
+*	This flow assumes Auto Negotionation (AN) between MAC and GE PHY.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+*******************************************************************************/
+static void mvEthCompMacToGePhyConfig(MV_U32 port, MV_U32 phy, MV_U32 ethCompCfg)
+{
+	MV_U32 reg;
+
+	if ((ethCompCfg & MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0) == 0)
+		return;
+
+	/*----------------------------------------------------------------------
+	 * GE MAC 0 to GE PHY Port 0
+	 */
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+
+	/* Set 'GbEPhyPort0Source' field in Ethernet Complex Control 0 reg to 0x0 */
+	reg &= ~ETHCC_GBE_PHY_PORT_0_SRC_MASK;
+	reg |= (0x0 << ETHCC_GBE_PHY_PORT_0_SRC_OFFSET);
+
+	/* Set 'GeMAC0Source' field in Ethernet Complex Control 0 reg to 0x2 */
+	reg &= ~ETHCC_GBE_MAC0_SRC_MASK;
+	reg |= (0x2 << ETHCC_GBE_MAC0_SRC_OFFSET);
+
+	/* Set 'SwitchPort6Source' field in Ethernet Complex Control 0 to 0x0 'UC' */
+	reg &= ~ETHCC_SW_PORT_6_SRC_MASK;
+	reg |= (0x0 << ETHCC_SW_PORT_6_SRC_OFFSET);
+
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
+
+	/*----------------------------------------------------------------------
+	 * Set 'Port[0/1]DpClkSource' field in Ports Group Control and Status to 0x1
+	 */
+	reg = MV_REG_READ(MV_ETHCOMP_GOP_CTRL_STAT_REG);
+	reg &= ~ETHCGCS_PORT_DP_CLK_SRC_MASK(port);
+	reg |= (0x1 << ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port));
+	MV_REG_WRITE(MV_ETHCOMP_GOP_CTRL_STAT_REG, reg);
+
+	/*----------------------------------------------------------------------
+	 * GE PHY configuration
+	 */
+
+	/* Set PHY SMI address: set PcsPhyAddress to PHY SMI address.
+	 * Note: it is set in pre-init function.
+	 */
+
+	/* Set PdConfigEdetA field */
+	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy));
+	reg &= ~ETHCGPC1_PD_CFG_EDED_A_MASK;
+	reg |= (0x0 << ETHCGPC1_PD_CFG_EDED_A_OFFSET);
+	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy), reg);
+
+	/* Set PsEnaXcS field */
+	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy));
+	reg &= ~ETHCGPC1_PS_ENA_XCS_MASK;
+	reg |= (0x0 << ETHCGPC1_PS_ENA_XCS_OFFSET);
+	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy), reg);
+
+	mvOsDelay(200);
+
+	/* Set 'DPLLReset' field in Quad Gbe PHY Common Control and Status
+	 * register to 'Normal Operation'.
+	 */
+	reg = MV_REG_READ(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG);
+	reg &= ~ETHQPCS_DPLL_RESET_MASK;
+	reg |= (0x1 << ETHQPCS_DPLL_RESET_OFFSET);
+	MV_REG_WRITE(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG, reg);
+
+	mvOsDelay(20);
+
+	/* Set 'Reset' field in Quad Gbe PHY Common Control and Status
+	 * register to 'Normal'.
+	 */
+	reg = MV_REG_READ(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG);
+	reg &= ~ETHQPCS_RESET_MASK;
+	reg |= (0x1 << ETHQPCS_RESET_OFFSET);
+	MV_REG_WRITE(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG, reg);
+
+	/*----------------------------------------------------------------------
+	 * GOP init
+	 */
+
+	/* GOP works NOT in SGMII, ==> set 'PcsEn' field in
+	 * Port MAC Control Register2 to 'Not_working'.
+	 */
+	reg = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
+	reg &= ETH_GMAC_PCS_ENABLE_MASK;
+	reg |= (0 << ETH_GMAC_PCS_ENABLE_BIT);
+	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), reg);
+
+	/*
+	 * When working with GbE PHY:
+	 * Set 'PeriodicXonEn' field in Port MAC Control Register 1 to 'Disabled'.
+	 */
+	reg = MV_REG_READ(ETH_GMAC_CTRL_1_REG(port));
+	reg &= ~ETH_GMAC_PERIODIC_XON_EN_MASK;
+	reg |= (0x0 << ETH_GMAC_PERIODIC_XON_EN_BIT);
+	MV_REG_WRITE(ETH_GMAC_CTRL_1_REG(port), reg);
+
+	/*
+	 * Working in Auto Negotiation (AN) mode
+	 */
+	mvEthCompMacSetAutoNegMode(port);
+
+	/*
+	 * Set 'PortMACReset' in Port MAC Control Register 2 to 'Port_MAC_Not_reset'.
+	 */
+	mvEthCompMacSetReset(port, MV_FALSE);
+}
 
 /******************************************************************************
-* mvEthernetComplexInit
+* mvEthCompMacRgmii1Config
+*
+* DESCRIPTION:
+* 	None.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+*******************************************************************************/
+static void mvEthCompMacRgmii1Config(MV_U32 port, MV_U32 ethCompCfg)
+{
+	MV_U32 reg;
+
+	if ((ethCompCfg & MV_ETHCOMP_GE_MAC1_2_RGMII1) == 0)
+		return;
+
+	/*----------------------------------------------------------------------
+	 * Connect GE MAC 1 to RGMII 1
+	 */
+
+	/*
+	 * Set 'GeMAC1Source' field in Ethernet Complex Control 0 reg to 0x0, ==>
+	 * GbE MAC 1 is connected to an MPP (RGMII).
+	 */
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg &= ~ETHCC_GBE_MAC1_SRC_MASK;
+	reg |= (0x0 << ETHCC_GBE_MAC1_SRC_OFFSET);
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
+
+	/*
+	 * Set MPP[35:24] to option 0x2.
+	 */
+
+	/* Read MPP[31:24] and config MPP[31:24] to option 0x2 */
+	reg = MV_REG_READ(MPP_CONTROL_REG(3));
+	reg &= ~0xffffffff; /* each MPP stands for 4 bits */
+	reg |= 0x22222222;
+	MV_REG_WRITE(MPP_CONTROL_REG(3), reg);
+
+	/* Read MPP[32:39] and config MPP[35:32] to option 0x2 */
+	reg = MV_REG_READ(MPP_CONTROL_REG(4));
+	reg &= ~0xffff; /* each MPP stands for 4 bits */
+	reg |= 0x2222;
+	MV_REG_WRITE(MPP_CONTROL_REG(4), reg);
+
+	/*----------------------------------------------------------------------
+	 * Set 'Port[0/1]DpClkSource' field in Ports Group Control and Status to 0x1
+	 */
+	reg = MV_REG_READ(MV_ETHCOMP_GOP_CTRL_STAT_REG);
+
+	reg &= ~ETHCGCS_PORT_DP_CLK_SRC_MASK(port);
+	reg |= (0x1 << ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port));
+
+	reg &= ~ETHCGCS_GOP_ENABLE_DEV_MASK;
+	reg |= (0x1 << ETHCGCS_GOP_ENABLE_DEV_OFFSET);
+
+	MV_REG_WRITE(MV_ETHCOMP_GOP_CTRL_STAT_REG, reg);
+
+	/*----------------------------------------------------------------------
+	 * GOP init
+	 */
+
+	/* GOP works NOT in SGMII, ==> set 'PcsEn' field in
+	 * Port MAC Control Register2 to 'Not_working'.
+	 */
+	reg = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
+	reg &= ETH_GMAC_PCS_ENABLE_MASK;
+	reg |= (0 << ETH_GMAC_PCS_ENABLE_BIT);
+	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), reg);
+
+	/*
+	 * Working in Auto Negotiation (AN) mode
+	 */
+	mvEthCompMacSetAutoNegMode(port);
+
+	/*
+	 * Set 'PortMACReset' in Port MAC Control Register 2 to 'Port_MAC_Not_reset'.
+	 */
+	mvEthCompMacSetReset(port, MV_FALSE);
+}
+
+/******************************************************************************
+* mvEthCompInit
 *
 * DESCRIPTION:
 *	Initialize the ethernet complex according to the boardEnv setup.
@@ -286,26 +649,31 @@ MV_STATUS mvEthernetComplexPreInit(MV_U32 ethCompCfg)
 *	MV_OK on success,
 *	MV_ERROR otherwise.
 *******************************************************************************/
-MV_STATUS mvEthernetComplexInit(void)
+MV_STATUS mvEthCompInit(void)
 {
 	MV_U32 ethCompCfg = mvBoardEthComplexConfigGet();
 
 	if (gEthComplexSkipInit == MV_TRUE)
 		return MV_OK;
 
-	mvEthernetComplexPreInit(ethCompCfg);
+	mvEthCompPreInit(ethCompCfg, mvBoardPhyAddrGet(GBE_PORT(0)));
 
-		/*  Reset the switch after all configurations are done. */
-		mvEthCompSwitchReset(ethCompCfg);
+	/* MAC1 to RGMII1 */
+	mvEthCompMacRgmii1Config(GBE_PORT(1), ethCompCfg);
 
-	mvEthernetComplexPostInit(ethCompCfg);
+	/* MAC0 to GE PHY Port0 */
+	mvEthCompMacToGePhyConfig(GBE_PORT(0), GE_PHY(0), ethCompCfg);
+
+	/*  Reset the switch after all configurations are done. */
+	mvEthCompSwitchReset(ethCompCfg);
+
+	mvEthCompPostInit(ethCompCfg);
 
 	return MV_OK;
 }
 
-
 /******************************************************************************
-* mvEthernetComplexChangeMode
+* mvEthCompChangeMode
 *
 * DESCRIPTION:
 *	Change the ethernet complex configuration at runtime.
@@ -325,7 +693,7 @@ MV_STATUS mvEthernetComplexInit(void)
 *	MV_OK on success,
 *	MV_ERROR otherwise.
 *******************************************************************************/
-MV_STATUS mvEthernetComplexChangeMode(MV_U32 oldCfg, MV_U32 newCfg)
+static MV_STATUS mvEthCompChangeMode(MV_U32 oldCfg, MV_U32 newCfg)
 {
 	return MV_OK;
 }
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h
index 14cbd9b..04be499 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h
@@ -68,42 +68,71 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "mvSysEthConfig.h"
 
-#define MV_ETHCOMP_CTRL_REG(id)			(MV_ETH_COMPLEX_BASE + 0x10 + (id * 4))
-
-/* Ethernet Complex Control 0 */
-#define ETHCC_SW_PORT_0_SRC_OFFSET		4
-#define ETHCC_SW_PORT_0_SRC_MASK		(0x1 << ETHCC_SW_PORT_0_SRC_OFFSET)
-#define ETHCC_SW_PORT_3_SRC_OFFSET		5
-#define ETHCC_SW_PORT_3_SRC_MASK		(0x1 << ETHCC_SW_PORT_3_SRC_OFFSET)
-#define ETHCC_SW_PORT_4_SRC_OFFSET		6
-#define ETHCC_SW_PORT_4_SRC_MASK		(0x1 << ETHCC_SW_PORT_4_SRC_OFFSET)
-#define ETHCC_SW_PORT_6_SRC_OFFSET		7
-#define ETHCC_SW_PORT_6_SRC_MASK		(0x1 << ETHCC_SW_PORT_6_SRC_OFFSET)
-#define ETHCC_GBE_MAC0_SRC_OFFSET		10
-#define ETHCC_GBE_MAC0_SRC_MASK			(0x3 << ETHCC_GBE_MAC0_SRC_OFFSET)
-#define ETHCC_GBE_MAC1_SRC_OFFSET		12
-#define ETHCC_GBE_MAC1_SRC_MASK			(0x3 << ETHCC_GBE_MAC1_SRC_OFFSET)
-#define ETHCC_GBE_PHY_PORT_0_SRC_OFFSET		14
-#define ETHCC_GBE_PHY_PORT_0_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_0_SRC_OFFSET)
-#define ETHCC_GBE_PHY_PORT_1_SMI_SRC_OFFSET	15
-#define ETHCC_GBE_PHY_PORT_1_SMI_SRC_MASK	(0x1 << ETHCC_GBE_PHY_PORT_1_SMI_SRC_OFFSET)
-#define ETHCC_GBE_PHY_PORT_2_SMI_SRC_OFFSET	16
-#define ETHCC_GBE_PHY_PORT_2_SMI_SRC_MASK	(0x1 << ETHCC_GBE_PHY_PORT_2_SMI_SRC_OFFSET)
-#define ETHCC_GBE_PHY_PORT_3_SRC_OFFSET		17
-#define ETHCC_GBE_PHY_PORT_3_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_0_SRC_OFFSET)
-#define ETHCC_GE_MAC0_SW_PORT_6_SPD_OFFSET	18
-#define ETHCC_GE_MAC0_SW_PORT_6_SPD_MASK	(0x1 << ETHCC_GE_MAC0_SW_PORT_6_SPD_OFFSET)
-#define ETHCC_LOOPBACK_PORT_SPD_OFFSET		18
-#define ETHCC_LOOPBACK_PORT_SPD_MASK		(0x1 << ETHCC_LOOPBACK_PORT_SPD_OFFSET)
-
-MV_VOID mvEthCompSkipInitSet(MV_BOOL skip);
-MV_STATUS mvEthCompMac2SwitchConfig(MV_U32 ethCompCfg, MV_BOOL muxCfgOnly);
-MV_STATUS mvEthCompSwitchReset(MV_U32 ethCompCfg);
-MV_STATUS mvEthCompMac2RgmiiConfig(MV_U32 ethCompCfg);
-MV_STATUS mvEthCompSwP56ToRgmiiConfig(MV_U32 ethCompCfg);
-MV_STATUS mvEthCompSataConfig(MV_U32 ethCompCfg);
-MV_STATUS mvEthernetComplexShutdownIf(MV_BOOL integSwitch, MV_BOOL gePhy, MV_BOOL fePhy);
-MV_STATUS mvEthernetComplexInit(MV_VOID);
-MV_STATUS mvEthernetComplexChangeMode(MV_U32 oldCfg, MV_U32 newCfg);
+/*
+ * Ports Group Control and Status
+ */
+#define MV_ETHCOMP_GOP_CTRL_STAT_REG			MV_ETH_COMPLEX_BASE
+#define     ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port)	(port == GBE_PORT(0) ? 13 : 14)
+#define     ETHCGCS_PORT_DP_CLK_SRC_MASK(port)		(0x1 << ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port))
+#define     ETHCGCS_GOP_ENABLE_DEV_OFFSET		19
+#define     ETHCGCS_GOP_ENABLE_DEV_MASK			(0x1 << ETHCGCS_GOP_ENABLE_DEV_OFFSET)
+
+/*
+ * Ethernet Complex Control 0
+ */
+#define MV_ETHCOMP_CTRL_REG				(MV_ETH_COMPLEX_BASE + 0x10)
+#define     ETHCC_SW_PORT_0_SRC_OFFSET			4
+#define     ETHCC_SW_PORT_0_SRC_MASK			(0x1 << ETHCC_SW_PORT_0_SRC_OFFSET)
+#define     ETHCC_SW_PORT_3_SRC_OFFSET			5
+#define     ETHCC_SW_PORT_3_SRC_MASK			(0x1 << ETHCC_SW_PORT_3_SRC_OFFSET)
+#define     ETHCC_SW_PORT_4_SRC_OFFSET			6
+#define     ETHCC_SW_PORT_4_SRC_MASK			(0x1 << ETHCC_SW_PORT_4_SRC_OFFSET)
+#define     ETHCC_SW_PORT_6_SRC_OFFSET			7
+#define     ETHCC_SW_PORT_6_SRC_MASK			(0x1 << ETHCC_SW_PORT_6_SRC_OFFSET)
+#define     ETHCC_GBE_MAC0_SRC_OFFSET			10
+#define     ETHCC_GBE_MAC0_SRC_MASK			(0x3 << ETHCC_GBE_MAC0_SRC_OFFSET)
+#define     ETHCC_GBE_MAC1_SRC_OFFSET			12
+#define     ETHCC_GBE_MAC1_SRC_MASK			(0x3 << ETHCC_GBE_MAC1_SRC_OFFSET)
+#define     ETHCC_GBE_PHY_PORT_0_SRC_OFFSET		14
+#define     ETHCC_GBE_PHY_PORT_0_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_0_SRC_OFFSET)
+#define     ETHCC_GBE_PHY_PORT_1_SMI_SRC_OFFSET		15
+#define     ETHCC_GBE_PHY_PORT_1_SMI_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_1_SMI_SRC_OFFSET)
+#define     ETHCC_GBE_PHY_PORT_2_SMI_SRC_OFFSET		16
+#define     ETHCC_GBE_PHY_PORT_2_SMI_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_2_SMI_SRC_OFFSET)
+#define     ETHCC_GBE_PHY_PORT_3_SRC_OFFSET		17
+#define     ETHCC_GBE_PHY_PORT_3_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_0_SRC_OFFSET)
+#define     ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET	18
+#define     ETHCC_GE_MAC0_SW_PORT_6_SPEED_MASK		(0x1 << ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET)
+#define     ETHCC_LOOPBACK_PORT_SPEED_OFFSET		19
+#define     ETHCC_LOOPBACK_PORT_SPEED_MASK		(0x1 << ETHCC_LOOPBACK_PORT_SPEED_OFFSET)
+
+/*
+ * GbE PHY <<%n>> Control 0.
+ * 0x000189A0 + n*4: where n (0-3) represents GPHY_Num.
+ */
+#define MV_ETHCOMP_GBE_PHY_CTRL0_REG(phy)		(MV_ETH_COMPLEX_BASE + 0xA0 + (phy * 0x4))
+#define     ETHCGPC0_PCS_PHY_ADDR_OFFSET		13
+#define     ETHCGPC0_PCS_PHY_ADDR_MASK			(0x1F << ETHCGPC0_PCS_PHY_ADDR_OFFSET)
+
+/*
+ * GbE PHY <<%n>> Control 1.
+ * 0x000189B0 + n*4: where n (0-3) represents GPHY_Num.
+ */
+#define MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy)		(MV_ETH_COMPLEX_BASE + 0xB0 + (phy * 0x4))
+#define     ETHCGPC1_PD_CFG_EDED_A_OFFSET		14
+#define     ETHCGPC1_PD_CFG_EDED_A_MASK		(0x7 << ETHCGPC1_PD_CFG_EDED_A_OFFSET)
+#define     ETHCGPC1_PS_ENA_XCS_OFFSET			12
+#define     ETHCGPC1_PS_ENA_XCS_MASK			(0x3 << ETHCGPC1_PS_ENA_XCS_OFFSET)
+
+/*
+ * Quad GbE PHY Common Control and Status
+ */
+#define MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG		(MV_ETH_COMPLEX_BASE + 0xD0)
+#define     ETHQPCS_RESET_OFFSET			0
+#define     ETHQPCS_RESET_MASK				(0x1 << ETHQPCS_DPLL_RESET_OFFSET)
+#define     ETHQPCS_DPLL_RESET_OFFSET			4
+#define     ETHQPCS_DPLL_RESET_MASK			(0x1 << ETHQPCS_DPLL_RESET_OFFSET)
+
+MV_STATUS mvEthCompInit(MV_VOID);
 
 #endif /* __INCmvCtrlEthCompLibh */
-- 
1.7.5.4

