From 4c9e8390fa741a067d2c407fda23a3888b59ff9d Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Tue, 16 Apr 2013 15:41:46 +0300
Subject: [PATCH 0583/1825] ALP: Add init of NAND, SDIO, HWMON, XOR, SPI

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 44f8bf4baf42d2ece32a05df2290ddedbbc1430b

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: Ic8fc01c462f4fcb5dfede1bff05a6aac0dad57f0
Reviewed-on: http://vgitil04.il.marvell.com:8080/1560
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/Makefile |    2 +-
 arch/arm/mach-avantalp/core.c   |  501 +++++++++++++++++++++++++++++++++++----
 drivers/hwmon/Kconfig           |    9 +
 3 files changed, 467 insertions(+), 45 deletions(-)

diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index 42cec62..7c369bf 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -176,7 +176,7 @@ obj-$(CONFIG_MV_IPC_NET)		+= $(PLAT_DRIVERS)/mv_ipc_net/
 obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
 obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
 obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
-obj-$(CONFIG_SENSORS_ARMADA_XP)		+= hwmon.o
+obj-$(CONFIG_SENSORS_ALP)		+= hwmon.o
 # The rest of the drivers are compiled through the driver dir directly.
 
 
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 01c8fc6..601182a 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -20,6 +20,7 @@
 #include <linux/ata_platform.h>
 #include <linux/ethtool.h>
 #include <linux/device.h>
+#include <linux/mtd/partitions.h>
 #include <linux/string.h>
 #include <linux/mbus.h>
 #include <linux/mv643xx_i2c.h>
@@ -47,6 +48,19 @@
 #include "boardEnv/mvBoardEnvLib.h"
 #include "mvSysHwConfig.h"
 
+#ifdef CONFIG_MTD_NAND_NFC
+#include "mv_mtd/nand_nfc.h"
+#endif
+
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+#include "sdmmc/mvSdmmc.h"
+#include <plat/mvsdio.h>
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_XOR
+#include <plat/mv_xor.h>
+#endif
+
 #if defined(CONFIG_MV_ETH_NETA)
 #include <linux/mv_neta.h>
 #elif defined (CONFIG_MV_ETH_PP2)
@@ -61,6 +75,8 @@
 #include <asm/hardware/gic.h>
 #include "ca9x2.h"
 
+MV_STATUS mvSysSpiInit(MV_U8 spiId, MV_U32 serialBaudRate);
+
 extern void __init alp_map_io(void);
 extern struct sys_timer alp_timer;
 extern MV_CPU_DEC_WIN* mv_sys_map(void);
@@ -82,6 +98,8 @@ MV_U8 mvMacAddr[MV_UBOOT_ETH_PORTS][6];
 MV_U16 mvMtu[MV_UBOOT_ETH_PORTS] = { 0 };
 #endif
 
+struct mbus_dram_target_info alp_mbus_dram_info;
+
 /*
  * Helpers to get DDR bank info
  */
@@ -190,7 +208,15 @@ static int __init mv_rsrc_setup(char *s)
 __setup("mv_rsrc=", mv_rsrc_setup);
 #endif
 
-static void __init setup_cpu_mbus(void)
+char *nfcConfig = NULL;
+static int __init nfcConfig_setup(char *s)
+{
+	nfcConfig = s;
+	return 1;
+}
+__setup("nfcConfig=", nfcConfig_setup);
+
+static void __init alp_init_cpu_mbus(void)
 {
 	void __iomem *addr;
 	int i;
@@ -252,12 +278,8 @@ unsigned char*  mv_sram_usage_get(int* sram_size_ptr)
 #endif
 
 /*******************************************************************************
- * I/O Devices Platform Info
+ * I2C (TWSI)
  */
-
-/**************
- * I2C (TWSI) *
- **************/
 #ifdef CONFIG_I2C_MV64XXX
 static struct mv64xxx_i2c_pdata alp_i2c_pdata = {
 	.freq_m         = 8, /* assumes 166 MHz TCLK */
@@ -316,7 +338,7 @@ static struct platform_device alp_i2c1 = {
 };
 #endif
 
-static void __init alp_i2c_init(void)
+static void __init alp_init_i2c(void)
 {
 #ifdef CONFIG_I2C_MV64XXX
 	if (mvUnitMapIsMine(I2C0) == MV_TRUE)
@@ -328,9 +350,9 @@ static void __init alp_i2c_init(void)
 #endif
 }
 
-/**********
-* UART-0 *
-**********/
+/*******************************************************************************
+ * UART-0
+ */
 static struct plat_serial8250_port uart0_data[] = {
 	{
 		.iotype         = UPIO_MEM32,
@@ -361,9 +383,9 @@ static struct platform_device uart0 = {
 	.num_resources		= ARRAY_SIZE(uart0_resources),
 };
 
-/**********
-* UART-1 *
-**********/
+/*******************************************************************************
+ * UART-1
+ */
 static struct plat_serial8250_port uart1_data[] = {
 	{
 		.iotype         = UPIO_MEM32,
@@ -394,7 +416,7 @@ static struct platform_device uart1 = {
 	.num_resources		= ARRAY_SIZE(uart1_resources),
 };
 
-static void __init serial_initialize(int port)
+static void __init alp_init_serial(int port)
 {
 	if (port == 0) {
 		if (mvUnitMapIsMine(UART0) == MV_FALSE) {
@@ -417,9 +439,73 @@ static void __init serial_initialize(int port)
 	}
 }
 
-/*******
-* GBE *
-*******/
+/*******************************************************************************
+ * SDIO
+ */
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+static struct resource mvsdio_resources[] = {
+	[0] = {
+		.start	= INTER_REGS_PHYS_BASE + MV_SDMMC_REGS_OFFSET,
+		.end	= INTER_REGS_PHYS_BASE + MV_SDMMC_REGS_OFFSET + SZ_1K -1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_GLOBAL_SDIO,
+		.end	= IRQ_GLOBAL_SDIO,
+		.flags	= IORESOURCE_IRQ,
+	},
+
+};
+
+static u64 mvsdio_dmamask = 0xffffffffUL;
+
+static struct mvsdio_platform_data mvsdio_data = {
+	.gpio_write_protect	= 0,
+	.gpio_card_detect	= 0,
+	.dram			= NULL,
+};
+
+static struct platform_device mv_sdio_plat = {
+	.name		= "mvsdio",
+	.id		= -1,
+	.dev		= {
+		.dma_mask = &mvsdio_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data	= &mvsdio_data,
+	},
+	.num_resources	= ARRAY_SIZE(mvsdio_resources),
+	.resource	= mvsdio_resources,
+};
+#endif
+
+void __init alp_init_sdio(void)
+{
+#ifdef CONFIG_MV_INCLUDE_SDIO
+	if (mvUnitMapIsMine(SDIO) != MV_TRUE)
+		return;
+
+	if (MV_TRUE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0)) {
+		int irq_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+		static MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+
+		if (irq_detect != MV_ERROR) {
+			mvsdio_data.gpio_card_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+		}
+
+		if (mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP) != MV_ERROR)
+			mvsdio_data.gpio_write_protect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP);
+
+		if (MV_OK == mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1))
+			if (MV_OK == mvSdmmcWinInit(addrWinMap))
+				mvsdio_data.clock = mvBoardTclkGet();
+		platform_device_register(&mv_sdio_plat);
+	}
+#endif
+}
+
+/*******************************************************************************
+ * GBE
+ */
 #ifdef CONFIG_MV_ETHERNET
 #if defined(CONFIG_MV_ETH_LEGACY)
 static struct platform_device mv88fx_eth = {
@@ -590,23 +676,31 @@ static void __init eth_init(void)
 
 #endif /* CONFIG_MV_ETHERNET */
 
-/************
+static void alp_init_eth(void)
+{
+#ifdef CONFIG_MV_ETHERNET
+	mvSysEthPhyInit();
+	eth_init();
+#endif
+}
+
+/*******************************************************************************
  * GPIO
- ***********/
+ */
 static struct platform_device mv_gpio = {
 	.name		= "mv_gpio",
 	.id		= 0,
 	.num_resources	= 0,
 };
 
-static void __init mv_gpio_init(void)
+static void __init alp_init_gpio(void)
 {
 	platform_device_register(&mv_gpio);
 }
 
-/*******
-* RTC *
-*******/
+/*******************************************************************************
+ * RTC
+ */
 static struct resource rtc_resource[] = {
 	{
 		.start  = INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET,
@@ -618,14 +712,14 @@ static struct resource rtc_resource[] = {
 	}
 };
 
-static void __init rtc_init(void)
+static void __init alp_init_rtc(void)
 {
 	platform_device_register_simple("rtc-mv", -1, rtc_resource, 2);
 }
 
-/********
- * SATA *
- ********/
+/*******************************************************************************
+ * SATA
+ */
 #ifdef CONFIG_SATA_MV
 #define SATA_PHYS_BASE (INTER_REGS_PHYS_BASE | 0xA0000)
 
@@ -658,7 +752,7 @@ static struct platform_device alp_sata = {
 };
 #endif
 
-static void __init alp_sata_init(void)
+static void __init alp_init_sata(void)
 {
 #ifdef CONFIG_SATA_MV
 	if (mvUnitMapIsMine(SATA) != MV_TRUE)
@@ -670,6 +764,321 @@ static void __init alp_sata_init(void)
 }
 
 /*******************************************************************************
+ * SoC hwmon Thermal Sensor
+ */
+static void __init alp_init_hwmon(void)
+{
+	if (mvUnitMapIsMine(HWMON) == MV_TRUE)
+		platform_device_register_simple("alp-temp", 0, NULL, 0);
+}
+
+/*******************************************************************************
+ * NAND controller
+ */
+#ifdef CONFIG_MTD_NAND_NFC
+static struct resource alp_nfc_resources[] = {
+	{
+		.start  = INTER_REGS_PHYS_BASE + MV_NFC_REGS_OFFSET,
+		.end    = INTER_REGS_PHYS_BASE + MV_NFC_REGS_OFFSET + 0x400 - 1,
+		.flags  = IORESOURCE_MEM,
+	}
+};
+
+static struct mtd_partition nand_parts_info[] = {
+	{
+		.name		= "UBoot",
+		.offset		= 0,
+		.size		= 1 * SZ_1M
+	}, {
+		.name		= "UImage",
+		.offset	= MTDPART_OFS_APPEND,
+		.size		= 4 * SZ_1M
+	}, {
+		.name		= "Root",
+		.offset	= MTDPART_OFS_APPEND,
+		.size         = MTDPART_SIZ_FULL
+	},
+};
+
+static struct nfc_platform_data alp_nfc_data = {
+	.nfc_width	= 8,
+	.num_devs	= 1,
+	.num_cs		= 1,
+	.use_dma	= 0,
+	.ecc_type	= MV_NFC_ECC_BCH_2K,
+	.parts		= nand_parts_info,
+	.nr_parts	= ARRAY_SIZE(nand_parts_info),
+};
+
+static struct platform_device alp_nfc = {
+	.name           = "armada-nand",
+	.id             = 0,
+	.dev            = {
+		.platform_data = &alp_nfc_data,
+	},
+	.num_resources  = ARRAY_SIZE(alp_nfc_resources),
+	.resource       = alp_nfc_resources,
+};
+#endif
+
+static void __init alp_init_nand_nfc(void)
+{
+#ifdef CONFIG_MTD_NAND_NFC
+	if (mvUnitMapIsMine(NAND) != MV_TRUE)
+		return;
+
+	/* Check for ganaged mode */
+	if (nfcConfig) {
+		if (strncmp(nfcConfig, "ganged", 6) == 0) {
+			alp_nfc_data.nfc_width = 16;
+			alp_nfc_data.num_devs = 2;
+			nfcConfig += 7;
+		}
+
+		/* Check for ECC type directive */
+		if (strcmp(nfcConfig, "8bitecc") == 0) {
+			alp_nfc_data.ecc_type = MV_NFC_ECC_BCH_1K;
+		} else if (strcmp(nfcConfig, "12bitecc") == 0) {
+			alp_nfc_data.ecc_type = MV_NFC_ECC_BCH_704B;
+		} else if (strcmp(nfcConfig, "16bitecc") == 0) {
+			alp_nfc_data.ecc_type = MV_NFC_ECC_BCH_512B;
+		}
+	}
+
+	alp_nfc_data.tclk = mvBoardTclkGet();
+
+	platform_device_register(&alp_nfc);
+#endif
+}
+
+/*******************************************************************************
+ * XOR
+ */
+#ifdef CONFIG_MV_INCLUDE_XOR
+static struct mv_xor_platform_shared_data alp_xor_shared_data = {
+	.dram		= &alp_mbus_dram_info,
+};
+
+static u64 alp_xor_dmamask = DMA_BIT_MASK(32);
+
+/*
+ * XOR0
+ */
+static struct resource alp_xor0_shared_resources[] = {
+	{
+		.name	= "xor 0 low",
+		.start	= XOR0_PHYS_BASE,
+		.end	= XOR0_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "xor 0 high",
+		.start	= XOR0_HIGH_PHYS_BASE,
+		.end	= XOR0_HIGH_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device alp_xor0_shared = {
+	.name		= MV_XOR_SHARED_NAME,
+	.id		= 0,
+	.dev		= {
+		.platform_data = &alp_xor_shared_data,
+	},
+	.num_resources	= ARRAY_SIZE(alp_xor0_shared_resources),
+	.resource	= alp_xor0_shared_resources,
+};
+
+static struct resource alp_xor00_resources[] = {
+	[0] = {
+		.start	= IRQ_GLOBAL_XOR0_CHAN0,
+		.end	= IRQ_GLOBAL_XOR0_CHAN0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data alp_xor00_data = {
+	.shared		= &alp_xor0_shared,
+	.hw_id		= 0,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device alp_xor00_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(alp_xor00_resources),
+	.resource	= alp_xor00_resources,
+	.dev		= {
+		.dma_mask		= &alp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &alp_xor00_data,
+	},
+};
+
+static struct resource alp_xor01_resources[] = {
+	[0] = {
+		.start	= IRQ_GLOBAL_XOR0_CHAN1,
+		.end	= IRQ_GLOBAL_XOR0_CHAN1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data alp_xor01_data = {
+	.shared		= &alp_xor0_shared,
+	.hw_id		= 1,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device alp_xor01_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(alp_xor01_resources),
+	.resource	= alp_xor01_resources,
+	.dev		= {
+		.dma_mask		= &alp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &alp_xor01_data,
+	},
+};
+
+static void __init alp_init_xor0(void)
+{
+	if (mvUnitMapIsMine(XOR0) != MV_TRUE)
+		return;
+
+	platform_device_register(&alp_xor0_shared);
+
+	/*
+	 * two engines can't do memset simultaneously, this limitation
+	 * satisfied by removing memset support from one of the engines.
+	 */
+	dma_cap_set(DMA_MEMCPY, alp_xor00_data.cap_mask);
+	dma_cap_set(DMA_XOR, alp_xor00_data.cap_mask);
+	platform_device_register(&alp_xor00_channel);
+
+	dma_cap_set(DMA_MEMCPY, alp_xor01_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, alp_xor01_data.cap_mask);
+	dma_cap_set(DMA_XOR, alp_xor01_data.cap_mask);
+	platform_device_register(&alp_xor01_channel);
+}
+
+/*
+ * XOR1
+ */
+static struct resource alp_xor1_shared_resources[] = {
+	{
+		.name	= "xor 1 low",
+		.start	= XOR1_PHYS_BASE,
+		.end	= XOR1_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "xor 1 high",
+		.start	= XOR1_HIGH_PHYS_BASE,
+		.end	= XOR1_HIGH_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device alp_xor1_shared = {
+	.name		= MV_XOR_SHARED_NAME,
+	.id		= 1,
+	.dev		= {
+		.platform_data = &alp_xor_shared_data,
+	},
+	.num_resources	= ARRAY_SIZE(alp_xor1_shared_resources),
+	.resource	= alp_xor1_shared_resources,
+};
+
+static struct resource alp_xor10_resources[] = {
+	[0] = {
+		.start	= IRQ_GLOBAL_XOR1_CHAN0,
+		.end	= IRQ_GLOBAL_XOR1_CHAN0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data alp_xor10_data = {
+	.shared		= &alp_xor1_shared,
+	.hw_id		= 0,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device alp_xor10_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(alp_xor10_resources),
+	.resource	= alp_xor10_resources,
+	.dev		= {
+		.dma_mask		= &alp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &alp_xor10_data,
+	},
+};
+
+static struct resource alp_xor11_resources[] = {
+	[0] = {
+		.start	= IRQ_GLOBAL_XOR1_CHAN1,
+		.end	= IRQ_GLOBAL_XOR1_CHAN1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data alp_xor11_data = {
+	.shared		= &alp_xor1_shared,
+	.hw_id		= 1,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device alp_xor11_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 3,
+	.num_resources	= ARRAY_SIZE(alp_xor11_resources),
+	.resource	= alp_xor11_resources,
+	.dev		= {
+		.dma_mask		= &alp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &alp_xor11_data,
+	},
+};
+
+static void __init alp_init_xor1(void)
+{
+	if (mvUnitMapIsMine(XOR1) != MV_TRUE)
+		return;
+
+	platform_device_register(&alp_xor1_shared);
+
+	/*
+	 * two engines can't do memset simultaneously, this limitation
+	 * satisfied by removing memset support from one of the engines.
+	 */
+	dma_cap_set(DMA_XOR, alp_xor10_data.cap_mask);
+	platform_device_register(&alp_xor10_channel);
+
+	dma_cap_set(DMA_MEMCPY, alp_xor11_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, alp_xor11_data.cap_mask);
+	platform_device_register(&alp_xor11_channel);
+}
+#endif
+
+static void __init alp_init_xor(void)
+{
+	alp_init_xor0();
+	alp_init_xor1();
+}
+
+/*******************************************************************************
+ * SPI
+ */
+static void alp_init_spi(void)
+{
+#ifdef CONFIG_MV_INCLUDE_SPI
+	/* SPI */
+	if(mvUnitMapIsMine(SPI) == MV_TRUE)
+		mvSysSpiInit(0, _16M);
+#endif
+}
+
+/*******************************************************************************
  * Helper Routines
  */
 
@@ -716,14 +1125,16 @@ extern MV_TARGET_ATTRIB mvTargetDefaultsArray[];
  *     SMP + HWCC
  *     SMP + SWCC
  */
-static void __init alp_iocc_init(void)
+static void __init alp_init_iocc(void)
 {
 #if !defined(CONFIG_SMP) && defined(CONFIG_AURORA_IO_CACHE_COHERENCY)
-	scu_enable(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
+	void __iomem *scu_base =
+		(void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
+	scu_enable(scu_base);
 #endif
 }
 
-static void __init alp_l2_cache_init(void)
+static void __init alp_init_l2x0_cache(void)
 {
 #ifdef CONFIG_CACHE_L2X0
 	void __iomem *l2x0_base =
@@ -744,8 +1155,10 @@ static void __init board_init(void)
 	mvTargetDefaultsArray[PEX0_MEM].attrib = 0xD8;
 	setup_cpu_mbus();
 
-	alp_iocc_init();
-	alp_l2_cache_init();
+	alp_init_cpu_mbus();
+	alp_init_cpu_mbus();
+	alp_init_iocc();
+	alp_init_l2x0_cache();
 
 	/* Init the CPU windows setting and the access protection windows. */
 	if (mvCpuIfInit(mv_sys_map())) {
@@ -755,21 +1168,21 @@ static void __init board_init(void)
 
 	elf_hwcap &= ~HWCAP_JAVA;
 
-	serial_initialize(0);
+	alp_init_serial(0);
 
 	mvCpuIfAddDecShow();
 	print_board_info();
 
-	mv_gpio_init();
-	rtc_init();
-
-#ifdef CONFIG_MV_ETHERNET
-	mvSysEthPhyInit();
-	eth_init();
-#endif
-
-	alp_sata_init();
-	alp_i2c_init();
+	alp_init_gpio();
+	alp_init_rtc();
+	alp_init_spi();
+	alp_init_eth();
+	alp_init_sata();
+	alp_init_nand_nfc();
+	alp_init_hwmon();
+	alp_init_xor();
+	alp_init_i2c();
+	alp_init_sdio();
 }
 
 static void board_restart(char mode, const char *cmd)
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 8cf0ca5..e01a71a 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -220,6 +220,15 @@ config SENSORS_ADT7475
 
 	  This driver can also be build as a module.  If so, the module
 	  will be called adt7475.
+
+config SENSORS_ALP
+	tristate "Avanta LP SoC Thermal Sensor"
+	depends on ARCH_AVANTA_LP
+	default y
+	help
+	  This driver provides support for the Marvell's Avanta LP SoC thermal
+	  Controller, which provides onchip temperature sensors.
+
 config SENSORS_ARMADA
 	tristate "Armada XP SoC Thermal Sensor"
 	depends on PLAT_ARMADA
-- 
1.7.5.4

